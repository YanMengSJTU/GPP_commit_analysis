diff --git a/compiler/src/it/producers-functional-tests/src/main/java/test/MultibindingComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/test/MultibindingComponent.java
index 561ad4a89..010ea8d0f 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/test/MultibindingComponent.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/test/MultibindingComponent.java
@@ -16,11 +16,18 @@
 package test;
 
 import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.Produced;
 import dagger.producers.ProductionComponent;
 import java.util.Set;
+import test.MultibindingProducerModule.PossiblyThrowingSet;
 
 @ProductionComponent(modules = MultibindingProducerModule.class)
 interface MultibindingComponent {
   ListenableFuture<Set<String>> strs();
   ListenableFuture<Integer> strCount();
+
+  ListenableFuture<Set<Produced<String>>> successfulSet();
+
+  @PossiblyThrowingSet
+  ListenableFuture<Set<Produced<String>>> possiblyThrowingSet();
 }
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/test/MultibindingProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/test/MultibindingProducerModule.java
index 4651afcc6..fef7627c7 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/test/MultibindingProducerModule.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/test/MultibindingProducerModule.java
@@ -21,29 +21,56 @@
 import dagger.producers.ProducerModule;
 import dagger.producers.Produces;
 import java.util.Set;
+import javax.inject.Qualifier;
 
 import static dagger.producers.Produces.Type.SET;
 import static dagger.producers.Produces.Type.SET_VALUES;
 
 @ProducerModule
 final class MultibindingProducerModule {
-  @Produces(type = SET) ListenableFuture<String> futureStr() {
+  @Qualifier
+  @interface PossiblyThrowingSet {}
+
+  @Produces(type = SET)
+  static ListenableFuture<String> futureStr() {
     return Futures.immediateFuture("foo");
   }
 
-  @Produces(type = SET) String str() {
+  @Produces(type = SET)
+  static String str() {
     return "bar";
   }
 
-  @Produces(type = SET_VALUES) ListenableFuture<Set<String>> futureStrs() {
+  @Produces(type = SET_VALUES)
+  static ListenableFuture<Set<String>> futureStrs() {
     return Futures.<Set<String>>immediateFuture(ImmutableSet.of("foo1", "foo2"));
   }
 
-  @Produces(type = SET_VALUES) Set<String> strs() {
+  @Produces(type = SET_VALUES)
+  static Set<String> strs() {
     return ImmutableSet.of("bar1", "bar2");
   }
 
-  @Produces int strCount(Set<String> strs) {
+  @Produces
+  static int strCount(Set<String> strs) {
     return strs.size();
   }
+
+  @Produces(type = SET)
+  @PossiblyThrowingSet
+  static String successfulStringForSet() {
+    return "singleton";
+  }
+
+  @Produces(type = SET_VALUES)
+  @PossiblyThrowingSet
+  static Set<String> successfulStringsForSet() {
+    return ImmutableSet.of("double", "ton");
+  }
+
+  @Produces(type = SET)
+  @PossiblyThrowingSet
+  static String throwingStringForSet() {
+    throw new RuntimeException("monkey");
+  }
 }
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/test/MultibindingTest.java b/compiler/src/it/producers-functional-tests/src/test/java/test/MultibindingTest.java
index 20c86dc52..bc916dd01 100644
--- a/compiler/src/it/producers-functional-tests/src/test/java/test/MultibindingTest.java
+++ b/compiler/src/it/producers-functional-tests/src/test/java/test/MultibindingTest.java
@@ -15,7 +15,12 @@
 */
 package test;
 
+import com.google.common.collect.Iterables;
 import com.google.common.util.concurrent.MoreExecutors;
+import dagger.producers.Produced;
+import java.util.HashSet;
+import java.util.Set;
+import java.util.concurrent.ExecutionException;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -24,12 +29,45 @@
 
 @RunWith(JUnit4.class)
 public class MultibindingTest {
-  @Test public void multibinding() throws Exception {
-    MultibindingComponent multibindingComponent = DaggerMultibindingComponent.builder()
-        .executor(MoreExecutors.directExecutor())
-        .build();
+  @Test
+  public void setBinding() throws Exception {
+    MultibindingComponent multibindingComponent =
+        DaggerMultibindingComponent.builder().executor(MoreExecutors.directExecutor()).build();
     assertThat(multibindingComponent.strs().get())
         .containsExactly("foo", "foo1", "foo2", "bar", "bar1", "bar2");
     assertThat(multibindingComponent.strCount().get()).isEqualTo(6);
   }
+
+  @Test
+  public void setBindingOfProduced() throws Exception {
+    MultibindingComponent multibindingComponent =
+        DaggerMultibindingComponent.builder().executor(MoreExecutors.directExecutor()).build();
+    assertThat(multibindingComponent.successfulSet().get())
+        .containsExactly(
+            Produced.successful("foo"),
+            Produced.successful("foo1"),
+            Produced.successful("foo2"),
+            Produced.successful("bar"),
+            Produced.successful("bar1"),
+            Produced.successful("bar2"));
+  }
+
+  @Test
+  public void setBindingOfProducedWithFailures() throws Exception {
+    MultibindingComponent multibindingComponent =
+        DaggerMultibindingComponent.builder().executor(MoreExecutors.directExecutor()).build();
+    Set<Produced<String>> possiblyThrowingSet = multibindingComponent.possiblyThrowingSet().get();
+    Set<String> successes = new HashSet<>();
+    Set<ExecutionException> failures = new HashSet<>();
+    for (Produced<String> str : possiblyThrowingSet) {
+      try {
+        successes.add(str.get());
+      } catch (ExecutionException e) {
+        failures.add(e);
+      }
+    }
+    assertThat(successes).containsExactly("singleton", "double", "ton");
+    assertThat(failures).hasSize(1);
+    assertThat(Iterables.getOnlyElement(failures).getCause()).hasMessage("monkey");
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index ef608b508..86a7091cf 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -56,6 +56,7 @@
 import dagger.internal.codegen.writer.VoidName;
 import dagger.producers.Producer;
 import dagger.producers.internal.Producers;
+import dagger.producers.internal.SetOfProducedProducer;
 import dagger.producers.internal.SetProducer;
 import java.util.Collection;
 import java.util.EnumSet;
@@ -134,6 +135,8 @@
   protected final BindingGraph graph;
   private final Map<String, ProxyClassAndField> packageProxies = new HashMap<>();
   private final Map<BindingKey, InitializationState> initializationStates = new HashMap<>();
+  private final Map<Binding, InitializationState> contributionInitializationStates =
+      new HashMap<>();
   protected ClassWriter componentWriter;
   private ImmutableMap<BindingKey, MemberSelect> memberSelectSnippets;
   private ImmutableMap<ContributionBinding, MemberSelect> multibindingContributionSnippets;
@@ -243,6 +246,16 @@ private void setInitializationState(BindingKey bindingKey, InitializationState s
     initializationStates.put(bindingKey, state);
   }
 
+  private InitializationState getContributionInitializationState(Binding binding) {
+    return contributionInitializationStates.containsKey(binding)
+        ? contributionInitializationStates.get(binding)
+        : UNINITIALIZED;
+  }
+
+  private void setContributionInitializationState(Binding binding, InitializationState state) {
+    contributionInitializationStates.put(binding, state);
+  }
+
   ImmutableSet<JavaWriter> write() {
     if (javaWriters.isEmpty()) {
       writeComponent();
@@ -537,7 +550,7 @@ private void addField(
             if (resolvedBindings.ownedBindings().contains(contributionBinding)) {
               FrameworkField contributionBindingField =
                   FrameworkField.createForSyntheticContributionBinding(
-                      bindingKey, contributionNumber, contributionBinding);
+                      contributionNumber, contributionBinding);
               FieldWriter contributionField =
                   classWithFields.addField(
                       contributionBindingField.frameworkType(), contributionBindingField.name());
@@ -764,18 +777,27 @@ private void initializeSetMultibindings(
           getMultibindingContributionSnippet(binding);
       checkState(multibindingContributionSnippet.isPresent(), "%s was not found", binding);
       Snippet snippet = multibindingContributionSnippet.get().getSnippetFor(name);
-      if (multibindingContributionSnippet.get().owningClass().equals(name)) {
+      if (multibindingContributionSnippet.get().owningClass().equals(name)
+          // the binding might already be initialized by a different set binding that shares the
+          // same contributions (e.g., Set<T> and Set<Produced<T>>)
+          && getContributionInitializationState(binding)
+              .equals(InitializationState.UNINITIALIZED)) {
         Snippet initializeSnippet = initializeFactoryForContributionBinding(binding);
         initializeMethod.body().addSnippet("this.%s = %s;", snippet, initializeSnippet);
+        setContributionInitializationState(binding, InitializationState.INITIALIZED);
       }
       parameterSnippets.add(snippet);
     }
+    Class<?> factoryClass =
+        Iterables.all(resolvedBindings.contributionBindings(), Binding.Type.PROVISION)
+            ? SetFactory.class
+            : Util.isSetOfProduced(resolvedBindings.bindingKey().key().type())
+                ? SetOfProducedProducer.class
+                : SetProducer.class;
     Snippet initializeSetSnippet =
         Snippet.format(
             "%s.create(%s)",
-            Iterables.all(resolvedBindings.contributionBindings(), Binding.Type.PROVISION)
-                ? ClassName.fromClass(SetFactory.class)
-                : ClassName.fromClass(SetProducer.class),
+            ClassName.fromClass(factoryClass),
             makeParametersSnippet(parameterSnippets.build()));
     initializeMember(initializeMethod, resolvedBindings.bindingKey(), initializeSetSnippet);
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Binding.java b/compiler/src/main/java/dagger/internal/codegen/Binding.java
index afdfd23d4..0a6b84052 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Binding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Binding.java
@@ -40,7 +40,6 @@
 import javax.lang.model.util.SimpleTypeVisitor6;
 import javax.lang.model.util.Types;
 
-import static com.google.common.base.Preconditions.checkArgument;
 import static javax.lang.model.element.Modifier.PUBLIC;
 
 /**
@@ -78,7 +77,19 @@ private Type(Class<?> frameworkClass) {
     Class<?> frameworkClass() {
       return frameworkClass;
     }
-    
+
+    BindingKey.Kind bindingKeyKind() {
+      switch (this) {
+        case MEMBERS_INJECTION:
+          return BindingKey.Kind.MEMBERS_INJECTION;
+        case PROVISION:
+        case PRODUCTION:
+          return BindingKey.Kind.CONTRIBUTION;
+        default:
+          throw new AssertionError();
+      }
+    }
+
     @Override
     public boolean apply(Binding binding) {
       return this.equals(binding.bindingType());
@@ -113,6 +124,10 @@ public boolean apply(Binding binding) {
   /** The {@link Key} that is provided by this binding. */
   protected abstract Key key();
 
+  BindingKey bindingKey() {
+    return BindingKey.create(bindingType().bindingKeyKind(), key());
+  }
+
   /** Returns the {@link Element} instance that is responsible for declaring the binding. */
   abstract Element bindingElement();
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index 7084fb924..525bfd28d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -311,14 +311,22 @@ ResolvedBindings lookUpBindings(DependencyRequest request) {
             ImmutableSet<ContributionBinding> explicitMapBindings =
                 explicitMapBindingsBuilder.build();
 
-            if (!explicitBindingsForKey.isEmpty()) {
+            // If the key is Set<Produced<T>>, then we look up bindings by the alternate key Set<T>.
+            Optional<Key> setKeyFromProduced =
+                keyFactory.implicitSetKeyFromProduced(bindingKey.key());
+            ImmutableSet<ContributionBinding> explicitSetBindings =
+                setKeyFromProduced.isPresent()
+                    ? getExplicitBindings(setKeyFromProduced.get())
+                    : ImmutableSet.<ContributionBinding>of();
+
+            if (!explicitBindingsForKey.isEmpty() || !explicitSetBindings.isEmpty()) {
               /* If there are any explicit bindings for this key, then combine those with any
                * conflicting Map<K, Provider<V>> bindings and let the validator fail. */
               ImmutableSet.Builder<ContributionBinding> ownedBindings = ImmutableSet.builder();
               ImmutableSetMultimap.Builder<ComponentDescriptor, ContributionBinding>
                   inheritedBindings = ImmutableSetMultimap.builder();
               for (ContributionBinding binding :
-                  union(explicitBindingsForKey, explicitMapBindings)) {
+                  union(explicitBindingsForKey, union(explicitSetBindings, explicitMapBindings))) {
                 if (isResolvedInParent(request, binding)
                     && !shouldOwnParentBinding(request, binding)) {
                   inheritedBindings.put(
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
index a100a40dc..beaf206d4 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -167,6 +167,21 @@ DependencyRequest forImplicitMapBinding(
           false /* doesn't allow null */);
     }
 
+    /**
+     * Creates a DependencyRequest for a binding for {@code Set<T>}, given a request for
+     * {@code Set<Produced<T>>}.
+     */
+    DependencyRequest forImplicitProductionSetBinding(
+        DependencyRequest delegatingRequest, Key delegateKey) {
+      checkNotNull(delegatingRequest);
+      return new AutoValue_DependencyRequest(
+          Kind.PRODUCER,
+          delegateKey,
+          delegatingRequest.requestElement(),
+          delegatingRequest.enclosingType(),
+          false /* doesn't allow null */);
+    }
+
     DependencyRequest forRequiredVariable(VariableElement variableElement) {
       checkNotNull(variableElement);
       TypeMirror type = variableElement.asType();
diff --git a/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java b/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
index cae7d35f5..85da4ad5b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
@@ -21,7 +21,6 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 import dagger.MembersInjector;
-import dagger.internal.codegen.ContributionBinding.ContributionType;
 import dagger.internal.codegen.writer.ClassName;
 import dagger.internal.codegen.writer.ParameterizedTypeName;
 import dagger.internal.codegen.writer.TypeNames;
@@ -65,27 +64,22 @@ private static FrameworkField createForMapBindingContribution(
   }
 
   static FrameworkField createForSyntheticContributionBinding(
-      BindingKey bindingKey, int contributionNumber, ContributionBinding contributionBinding) {
+      int contributionNumber, ContributionBinding contributionBinding) {
     switch (contributionBinding.contributionType()) {
       case MAP:
         return createForMapBindingContribution(
             contributionBinding.frameworkClass(),
-            BindingKey.create(bindingKey.kind(), contributionBinding.key()),
-            KeyVariableNamer.INSTANCE.apply(bindingKey.key())
+            contributionBinding.bindingKey(),
+            KeyVariableNamer.INSTANCE.apply(contributionBinding.key())
                 + "Contribution"
                 + contributionNumber);
+
       case SET:
-        return createWithTypeFromKey(
-            contributionBinding.frameworkClass(),
-            bindingKey,
-            KeyVariableNamer.INSTANCE.apply(bindingKey.key())
-                + "Contribution"
-                + contributionNumber);
       case UNIQUE:
         return createWithTypeFromKey(
             contributionBinding.frameworkClass(),
-            bindingKey,
-            KeyVariableNamer.INSTANCE.apply(bindingKey.key())
+            contributionBinding.bindingKey(),
+            KeyVariableNamer.INSTANCE.apply(contributionBinding.key())
                 + "Contribution"
                 + contributionNumber);
       default:
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index c14cc22c4..fe03c3946 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -25,6 +25,7 @@
 import com.google.common.collect.Iterables;
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.Provides;
+import dagger.producers.Produced;
 import dagger.producers.Producer;
 import dagger.producers.Produces;
 import java.util.Map;
@@ -350,5 +351,22 @@ Key forQualifiedType(Optional<AnnotationMirror> qualifier, TypeMirror type) {
       }
       return Optional.absent();
     }
+
+    /**
+     * Optionally extract a {@link Key} for a {@code Set<T>} if the given key is for
+     * {@code Set<Produced<T>>}.
+     */
+    Optional<Key> implicitSetKeyFromProduced(Key possibleSetOfProducedKey) {
+      if (MoreTypes.isTypeOf(Set.class, possibleSetOfProducedKey.type())) {
+        TypeMirror argType =
+            MoreTypes.asDeclared(possibleSetOfProducedKey.type()).getTypeArguments().get(0);
+        if (MoreTypes.isTypeOf(Produced.class, argType)) {
+          TypeMirror producedArgType = MoreTypes.asDeclared(argType).getTypeArguments().get(0);
+          TypeMirror setType = types.getDeclaredType(getSetElement(), producedArgType);
+          return Optional.of(possibleSetOfProducedKey.withType(types, setType));
+        }
+      }
+      return Optional.absent();
+    }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index faa0459c4..65c5a6093 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -21,6 +21,7 @@
 import com.google.common.base.Equivalence.Wrapper;
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableSet;
+import dagger.producers.Produced;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
@@ -91,6 +92,13 @@ public static boolean isMapWithProvidedValues(TypeMirror type) {
         && MoreTypes.isTypeOf(Provider.class, asDeclared(type).getTypeArguments().get(1));
   }
 
+  /** Returns true if {@code type} is a {@code Set<Produced<T>>}. */
+  static boolean isSetOfProduced(TypeMirror type) {
+    return MoreTypes.isType(type)
+        && MoreTypes.isTypeOf(Set.class, type)
+        && MoreTypes.isTypeOf(Produced.class, MoreTypes.asDeclared(type).getTypeArguments().get(0));
+  }
+
   /**
    * Wraps an {@link Optional} of a type in an {@code Optional} of a {@link Wrapper} for that type.
    */
diff --git a/producers/src/main/java/dagger/producers/internal/Producers.java b/producers/src/main/java/dagger/producers/internal/Producers.java
index ea32c7829..c72c7eecc 100644
--- a/producers/src/main/java/dagger/producers/internal/Producers.java
+++ b/producers/src/main/java/dagger/producers/internal/Producers.java
@@ -109,5 +109,25 @@ public static ProducerMonitor producerMonitorFor(
     return null;
   }
 
+  /** Returns a producer that succeeds with the given value. */
+  public static <T> Producer<T> immediateProducer(final T value) {
+    return new Producer<T>() {
+      @Override
+      public ListenableFuture<T> get() {
+        return Futures.immediateFuture(value);
+      }
+    };
+  }
+
+  /** Returns a producer that fails with the given exception. */
+  public static <T> Producer<T> immediateFailedProducer(final Throwable throwable) {
+    return new Producer<T>() {
+      @Override
+      public ListenableFuture<T> get() {
+        return Futures.immediateFailedFuture(throwable);
+      }
+    };
+  }
+
   private Producers() {}
 }
diff --git a/producers/src/main/java/dagger/producers/internal/SetOfProducedProducer.java b/producers/src/main/java/dagger/producers/internal/SetOfProducedProducer.java
new file mode 100644
index 000000000..ab886714d
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/internal/SetOfProducedProducer.java
@@ -0,0 +1,116 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.internal;
+
+import com.google.common.base.Function;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.Produced;
+import dagger.producers.Producer;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.ExecutionException;
+
+/**
+ * A {@link Producer} implementation used to implement {@link Set} bindings. This producer returns a
+ * future {@code Set<Produced<T>>} whose elements are populated by subsequent calls to the delegate
+ * {@link Producer#get} methods.
+ *
+ * @author Jesse Beder
+ * @since 2.0
+ */
+public final class SetOfProducedProducer<T> extends AbstractProducer<Set<Produced<T>>> {
+  /**
+   * Returns a new producer that creates {@link Set} futures from the union of the given
+   * {@link Producer} instances.
+   */
+  public static <T> Producer<Set<Produced<T>>> create(
+      @SuppressWarnings("unchecked") Producer<Set<T>>... producers) {
+    return new SetOfProducedProducer<T>(ImmutableSet.copyOf(producers));
+  }
+
+  private final ImmutableSet<Producer<Set<T>>> contributingProducers;
+
+  private SetOfProducedProducer(ImmutableSet<Producer<Set<T>>> contributingProducers) {
+    this.contributingProducers = contributingProducers;
+  }
+
+  /**
+   * Returns a future {@link Set} of {@link Produced} values whose iteration order is that of the
+   * elements given by each of the producers, which are invoked in the order given at creation.
+   *
+   * <p>If any of the delegate sets, or any elements therein, are null, then that corresponding
+   * {@code Produced} element will fail with a NullPointerException.
+   *
+   * <p>Canceling this future will attempt to cancel all of the component futures; but if any of the
+   * delegate futures fail or are canceled, this future succeeds, with the appropriate failed
+   * {@link Produced}.
+   *
+   * @throws NullPointerException if any of the delegate producers return null
+   */
+  @Override
+  public ListenableFuture<Set<Produced<T>>> compute() {
+    List<ListenableFuture<Produced<Set<T>>>> futureProducedSets =
+        new ArrayList<ListenableFuture<Produced<Set<T>>>>(contributingProducers.size());
+    for (Producer<Set<T>> producer : contributingProducers) {
+      ListenableFuture<Set<T>> futureSet = producer.get();
+      if (futureSet == null) {
+        throw new NullPointerException(producer + " returned null");
+      }
+      futureProducedSets.add(Producers.createFutureProduced(futureSet));
+    }
+    return Futures.transform(
+        Futures.allAsList(futureProducedSets),
+        new Function<List<Produced<Set<T>>>, Set<Produced<T>>>() {
+          @Override
+          public Set<Produced<T>> apply(List<Produced<Set<T>>> producedSets) {
+            ImmutableSet.Builder<Produced<T>> builder = ImmutableSet.builder();
+            for (Produced<Set<T>> producedSet : producedSets) {
+              try {
+                Set<T> set = producedSet.get();
+                if (set == null) {
+                  // TODO(beder): This is a vague exception. Can we somehow point to the failing
+                  // producer? See the similar comment in the component writer about null
+                  // provisions.
+                  builder.add(
+                      Produced.<T>failed(
+                          new NullPointerException(
+                              "Cannot contribute a null set into a producer set binding when it's"
+                                  + " injected as Set<Produced<T>>.")));
+                } else {
+                  for (T value : set) {
+                    if (value == null) {
+                      builder.add(
+                          Produced.<T>failed(
+                              new NullPointerException(
+                                  "Cannot contribute a null element into a producer set binding"
+                                      + " when it's injected as Set<Produced<T>>.")));
+                    } else {
+                      builder.add(Produced.successful(value));
+                    }
+                  }
+                }
+              } catch (ExecutionException e) {
+                builder.add(Produced.<T>failed(e.getCause()));
+              }
+            }
+            return builder.build();
+          }
+        });
+  }
+}
diff --git a/producers/src/test/java/dagger/producers/internal/SetOfProducedProducerTest.java b/producers/src/test/java/dagger/producers/internal/SetOfProducedProducerTest.java
new file mode 100644
index 000000000..e36ba05a4
--- /dev/null
+++ b/producers/src/test/java/dagger/producers/internal/SetOfProducedProducerTest.java
@@ -0,0 +1,134 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.internal;
+
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Sets;
+import dagger.producers.Produced;
+import dagger.producers.Producer;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.Set;
+import java.util.concurrent.ExecutionException;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+
+/**
+ * Tests {@link SetOfProducedProducer}.
+ */
+@RunWith(JUnit4.class)
+public class SetOfProducedProducerTest {
+  @Test
+  public void success() throws Exception {
+    Producer<Set<Produced<Integer>>> producer =
+        SetOfProducedProducer.create(
+            Producers.<Set<Integer>>immediateProducer(ImmutableSet.of(1, 2)),
+            Producers.<Set<Integer>>immediateProducer(ImmutableSet.of(5, 7)));
+    assertThat(producer.get().get())
+        .containsExactly(
+            Produced.successful(1),
+            Produced.successful(2),
+            Produced.successful(5),
+            Produced.successful(7));
+  }
+
+  @Test
+  public void failure() throws Exception {
+    RuntimeException e = new RuntimeException("monkey");
+    Producer<Set<Produced<Integer>>> producer =
+        SetOfProducedProducer.create(
+            Producers.<Set<Integer>>immediateProducer(ImmutableSet.of(1, 2)),
+            Producers.<Set<Integer>>immediateFailedProducer(e));
+    assertThat(producer.get().get())
+        .containsExactly(
+            Produced.successful(1), Produced.successful(2), Produced.<Integer>failed(e));
+  }
+
+  @Test
+  public void delegateSetNpe() throws Exception {
+    Producer<Set<Produced<Integer>>> producer =
+        SetOfProducedProducer.create(Producers.<Set<Integer>>immediateProducer(null));
+    Results<Integer> results = Results.create(producer.get().get());
+    assertThat(results.successes).isEmpty();
+    assertThat(results.failures).hasSize(1);
+    assertThat(Iterables.getOnlyElement(results.failures).getCause())
+        .isInstanceOf(NullPointerException.class);
+  }
+
+  @Test
+  public void oneOfDelegateSetNpe() throws Exception {
+    Producer<Set<Produced<Integer>>> producer =
+        SetOfProducedProducer.create(
+            Producers.<Set<Integer>>immediateProducer(null),
+            Producers.<Set<Integer>>immediateProducer(ImmutableSet.of(7, 3)));
+    Results<Integer> results = Results.create(producer.get().get());
+    assertThat(results.successes).containsExactly(3, 7);
+    assertThat(results.failures).hasSize(1);
+    assertThat(Iterables.getOnlyElement(results.failures).getCause())
+        .isInstanceOf(NullPointerException.class);
+  }
+
+  @Test
+  public void delegateElementNpe() throws Exception {
+    Producer<Set<Produced<Integer>>> producer =
+        SetOfProducedProducer.create(
+            Producers.<Set<Integer>>immediateProducer(Collections.<Integer>singleton(null)));
+    Results<Integer> results = Results.create(producer.get().get());
+    assertThat(results.successes).isEmpty();
+    assertThat(results.failures).hasSize(1);
+    assertThat(Iterables.getOnlyElement(results.failures).getCause())
+        .isInstanceOf(NullPointerException.class);
+  }
+
+  @Test
+  public void oneOfDelegateElementNpe() throws Exception {
+    Producer<Set<Produced<Integer>>> producer =
+        SetOfProducedProducer.create(
+            Producers.<Set<Integer>>immediateProducer(Sets.newHashSet(Arrays.asList(5, 2, null))));
+    Results<Integer> results = Results.create(producer.get().get());
+    assertThat(results.successes).containsExactly(2, 5);
+    assertThat(results.failures).hasSize(1);
+    assertThat(Iterables.getOnlyElement(results.failures).getCause())
+        .isInstanceOf(NullPointerException.class);
+  }
+
+  static final class Results<T> {
+    final ImmutableSet<T> successes;
+    final ImmutableSet<ExecutionException> failures;
+
+    private Results(ImmutableSet<T> successes, ImmutableSet<ExecutionException> failures) {
+      this.successes = successes;
+      this.failures = failures;
+    }
+
+    static <T> Results<T> create(Set<Produced<T>> setOfProduced) {
+      ImmutableSet.Builder<T> successes = ImmutableSet.builder();
+      ImmutableSet.Builder<ExecutionException> failures = ImmutableSet.builder();
+      for (Produced<T> produced : setOfProduced) {
+        try {
+          successes.add(produced.get());
+        } catch (ExecutionException e) {
+          failures.add(e);
+        }
+      }
+      return new Results<T>(successes.build(), failures.build());
+    }
+  }
+}
diff --git a/producers/src/test/java/dagger/producers/internal/SetProducerTest.java b/producers/src/test/java/dagger/producers/internal/SetProducerTest.java
index 1f8ff7c3a..a38830f0a 100644
--- a/producers/src/test/java/dagger/producers/internal/SetProducerTest.java
+++ b/producers/src/test/java/dagger/producers/internal/SetProducerTest.java
@@ -16,7 +16,6 @@
 package dagger.producers.internal;
 
 import com.google.common.collect.ImmutableSet;
-import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.Producer;
 import java.util.Collections;
@@ -35,16 +34,18 @@
 @RunWith(JUnit4.class)
 public class SetProducerTest {
   @Test public void success() throws Exception {
-    Producer<Set<Integer>> producer = SetProducer.create(
-        new ImmediateProducer<Set<Integer>>(ImmutableSet.of(1, 2)),
-        new ImmediateProducer<Set<Integer>>(ImmutableSet.of(5, 7)));
+    Producer<Set<Integer>> producer =
+        SetProducer.create(
+            Producers.<Set<Integer>>immediateProducer(ImmutableSet.of(1, 2)),
+            Producers.<Set<Integer>>immediateProducer(ImmutableSet.of(5, 7)));
     assertThat(producer.get().get()).containsExactly(1, 2, 5, 7);
   }
 
   @Test public void delegateSetNpe() throws Exception {
-    Producer<Set<Integer>> producer = SetProducer.create(
-        new ImmediateProducer<Set<Integer>>(ImmutableSet.of(1, 2)),
-        new ImmediateProducer<Set<Integer>>(null));
+    Producer<Set<Integer>> producer =
+        SetProducer.create(
+            Producers.<Set<Integer>>immediateProducer(ImmutableSet.of(1, 2)),
+            Producers.<Set<Integer>>immediateProducer(null));
     ListenableFuture<Set<Integer>> future = producer.get();
     try {
       future.get();
@@ -55,10 +56,10 @@
   }
 
   @Test public void delegateElementNpe() throws Exception {
-    Producer<Set<Integer>> producer = SetProducer.create(
-        new ImmediateProducer<Set<Integer>>(ImmutableSet.of(1, 2)),
-        new ImmediateProducer<Set<Integer>>(
-            Collections.<Integer>singleton(null)));
+    Producer<Set<Integer>> producer =
+        SetProducer.create(
+            Producers.<Set<Integer>>immediateProducer(ImmutableSet.of(1, 2)),
+            Producers.<Set<Integer>>immediateProducer(Collections.<Integer>singleton(null)));
     ListenableFuture<Set<Integer>> future = producer.get();
     try {
       future.get();
@@ -67,16 +68,4 @@
       assertThat(e.getCause()).isInstanceOf(NullPointerException.class);
     }
   }
-
-  private static final class ImmediateProducer<T> implements Producer<T> {
-    private final T value;
-
-    ImmediateProducer(T value) {
-      this.value = value;
-    }
-
-    @Override public ListenableFuture<T> get() {
-      return Futures.immediateFuture(value);
-    }
-  }
 }
