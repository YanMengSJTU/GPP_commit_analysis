diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
index 6dfa0952b..eb36e983f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -179,10 +179,16 @@ public boolean apply(DependencyRequest dependency) {
             futureTransform.applyArgName(),
             getThrowsClause(binding.thrownTypes()),
             getInvocationCodeBlock(
-                !returnsFuture, binding, providedTypeName, futureTransform.parameterCodeBlocks()));
+                generatedTypeName,
+                !returnsFuture,
+                binding,
+                providedTypeName,
+                futureTransform.parameterCodeBlocks()));
     computeMethodBuilder.addStatement(
         "return $T.transformAsync($L, $L, executor)",
-        FUTURES, futureTransform.futureCodeBlock(), transformCodeBlock);
+        FUTURES,
+        futureTransform.futureCodeBlock(),
+        transformCodeBlock);
 
     factoryBuilder.addMethod(constructorBuilder.build());
     factoryBuilder.addMethod(computeMethodBuilder.build());
@@ -436,6 +442,7 @@ private static TypeName asyncDependencyType(DependencyRequest dependency) {
    * @param parameterCodeBlocks The code blocks for all the parameters to the producer method.
    */
   private CodeBlock getInvocationCodeBlock(
+      ClassName generatedTypeName,
       boolean wrapWithFuture,
       ProductionBinding binding,
       TypeName providedTypeName,
@@ -443,7 +450,7 @@ private CodeBlock getInvocationCodeBlock(
     CodeBlock moduleCodeBlock = CodeBlocks.format("$L.$L($L)",
         binding.bindingElement().getModifiers().contains(STATIC)
             ? CodeBlocks.format("$T", ClassName.get(binding.bindingTypeElement()))
-            : "module",
+            : CodeBlocks.format("$T.this.module", generatedTypeName),
         binding.bindingElement().getSimpleName(),
         makeParametersCodeBlock(parameterCodeBlocks));
 
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
index 41a40a88c..0e7e6124a 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
@@ -480,6 +480,25 @@ public void publicModuleNonPublicIncludes() {
         .in(publicModuleFile).onLine(8);
   }
 
+  @Test public void argumentNamedModuleCompiles() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces String produceString(int module) {",
+        "    return null;",
+        "  }",
+        "}");
+    assertAbout(javaSource())
+        .that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError();
+  }
+
   @Test public void singleProducesMethodNoArgsFuture() {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
@@ -539,7 +558,7 @@ public void publicModuleNonPublicIncludes() {
             "        @Override public ListenableFuture<String> apply(Void ignoredVoidArg) {",
             "          monitor.methodStarting();",
             "          try {",
-            "            return module.produceString();",
+            "            return TestModule_ProduceStringFactory.this.module.produceString();",
             "          } finally {",
             "            monitor.methodFinished();",
             "          }",
