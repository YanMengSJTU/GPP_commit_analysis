diff --git a/core/src/main/java/dagger/ObjectGraph.java b/core/src/main/java/dagger/ObjectGraph.java
index a1736d2b8..1e86b1b82 100644
--- a/core/src/main/java/dagger/ObjectGraph.java
+++ b/core/src/main/java/dagger/ObjectGraph.java
@@ -24,6 +24,7 @@
 import dagger.internal.Loader;
 import dagger.internal.ModuleAdapter;
 import dagger.internal.Modules;
+import dagger.internal.Modules.ModuleWithAdapter;
 import dagger.internal.ProblemDetector;
 import dagger.internal.SetBinding;
 import dagger.internal.StaticInjection;
@@ -171,9 +172,13 @@ private static ObjectGraph makeGraph(DaggerObjectGraph base, Loader plugin, Obje
           (base == null) ? new StandardBindings() : new StandardBindings(base.setBindings);
       BindingsGroup overrideBindings = new OverridesBindings();
 
-      Map<ModuleAdapter<?>, Object> loadedModules = Modules.loadModules(plugin, modules);
-      for (Entry<ModuleAdapter<?>, Object> loadedModule : loadedModules.entrySet()) {
-        ModuleAdapter<Object> moduleAdapter = (ModuleAdapter<Object>) loadedModule.getKey();
+      ArrayList<ModuleWithAdapter> loadedModules = Modules.loadModules(plugin, modules);
+      int loadedModulesCount = loadedModules.size();
+      for (int moduleIndex = 0; moduleIndex < loadedModulesCount; moduleIndex++) {
+        ModuleWithAdapter loadedModule = loadedModules.get(moduleIndex);
+        @SuppressWarnings("unchecked")
+        ModuleAdapter<Object> moduleAdapter =
+            (ModuleAdapter<Object>) loadedModule.getModuleAdapter();
         for (int i = 0; i < moduleAdapter.injectableTypes.length; i++) {
           injectableTypes.put(moduleAdapter.injectableTypes[i], moduleAdapter.moduleClass);
         }
@@ -182,7 +187,7 @@ private static ObjectGraph makeGraph(DaggerObjectGraph base, Loader plugin, Obje
         }
         try {
           BindingsGroup addTo = moduleAdapter.overrides ? overrideBindings : baseBindings;
-          moduleAdapter.getBindings(addTo, loadedModule.getValue());
+          moduleAdapter.getBindings(addTo, loadedModule.getModule());
         } catch (IllegalArgumentException e) {
           throw new IllegalArgumentException(
               moduleAdapter.moduleClass.getSimpleName() + ": " + e.getMessage(), e);
diff --git a/core/src/main/java/dagger/internal/Modules.java b/core/src/main/java/dagger/internal/Modules.java
index 8b269f57f..4f8d3cf7d 100644
--- a/core/src/main/java/dagger/internal/Modules.java
+++ b/core/src/main/java/dagger/internal/Modules.java
@@ -16,9 +16,9 @@
  */
 package dagger.internal;
 
-
-import java.util.LinkedHashMap;
-import java.util.Map;
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
 
 /**
  * Static helper for organizing modules.
@@ -31,38 +31,57 @@ private Modules() { }
    * Returns a full set of module adapters, including module adapters for included
    * modules.
    */
-  public static Map<ModuleAdapter<?>, Object> loadModules(Loader loader,
+  public static ArrayList<ModuleWithAdapter> loadModules(Loader loader,
       Object[] seedModulesOrClasses) {
-    Map<ModuleAdapter<?>, Object> seedAdapters =
-        new LinkedHashMap<ModuleAdapter<?>, Object>(seedModulesOrClasses.length);
-    for (int i = 0; i < seedModulesOrClasses.length; i++) {
-      if (seedModulesOrClasses[i] instanceof Class<?>) {
-        ModuleAdapter<?> adapter = loader.getModuleAdapter((Class<?>) seedModulesOrClasses[i]);
-        seedAdapters.put(adapter, adapter.newModule());
+    int seedModuleCount = seedModulesOrClasses.length;
+    ArrayList<ModuleWithAdapter> result = new ArrayList<ModuleWithAdapter>(seedModuleCount);
+    HashSet<Class<?>> visitedClasses = new HashSet<Class<?>>(seedModuleCount);
+    // Add all seed classes to visited classes right away, so that we won't instantiate modules for
+    // them in collectIncludedModulesRecursively
+    // Iterate over seedModulesOrClasses in reverse, so that if multiple instances/classes of the
+    // same module are provided, the later one is used (this matches previous behavior which some
+    // code came to depend on.)
+    for (int i = seedModuleCount-1; i >= 0; i--) {
+      Object moduleOrClass = seedModulesOrClasses[i];
+      if (moduleOrClass instanceof Class<?>) {
+        if (visitedClasses.add((Class<?>) moduleOrClass)) {
+          ModuleAdapter<?> moduleAdapter = loader.getModuleAdapter((Class<?>) moduleOrClass);
+          result.add(new ModuleWithAdapter(moduleAdapter, moduleAdapter.newModule()));
+        }
       } else {
-        ModuleAdapter<?> adapter = loader.getModuleAdapter(seedModulesOrClasses[i].getClass());
-        seedAdapters.put(adapter, seedModulesOrClasses[i]);
+        if (visitedClasses.add(moduleOrClass.getClass())) {
+          ModuleAdapter<?> moduleAdapter = loader.getModuleAdapter(moduleOrClass.getClass());
+          result.add(new ModuleWithAdapter(moduleAdapter, moduleOrClass));
+        }
       }
     }
+    int dedupedSeedModuleCount = result.size();
+    for (int i = 0; i < dedupedSeedModuleCount; i++) {
+      ModuleAdapter<?> seedAdapter = result.get(i).getModuleAdapter();
+      collectIncludedModulesRecursively(loader, seedAdapter, result, visitedClasses);
+    }
+    return result;
+  }
 
-    // Add the adapters that we have module instances for. This way we won't
-    // construct module objects when we have a user-supplied instance.
-    Map<ModuleAdapter<?>, Object> result =
-        new LinkedHashMap<ModuleAdapter<?>, Object>(seedAdapters);
+  /**
+   * Wrapper around a module adapter and an instance of the corresponding module.
+   */
+  public static class ModuleWithAdapter {
+    private final ModuleAdapter<?> moduleAdapter;
+    private final Object module;
 
-    // Next collect included modules
-    Map<Class<?>, ModuleAdapter<?>> transitiveInclusions =
-        new LinkedHashMap<Class<?>, ModuleAdapter<?>>();
-    for (ModuleAdapter<?> adapter : seedAdapters.keySet()) {
-      collectIncludedModulesRecursively(loader, adapter, transitiveInclusions);
+    ModuleWithAdapter(ModuleAdapter<?> moduleAdapter, Object module) {
+      this.moduleAdapter = moduleAdapter;
+      this.module = module;
     }
-    // and create them if necessary
-    for (ModuleAdapter<?> dependency : transitiveInclusions.values()) {
-      if (!result.containsKey(dependency)) {
-        result.put(dependency, dependency.newModule());
-      }
+
+    public ModuleAdapter<?> getModuleAdapter() {
+      return moduleAdapter;
+    }
+
+    public Object getModule() {
+      return module;
     }
-    return result;
   }
 
   /**
@@ -70,12 +89,13 @@ private Modules() { }
    * adapter}, and their includes recursively.
    */
   private static void collectIncludedModulesRecursively(Loader plugin, ModuleAdapter<?> adapter,
-      Map<Class<?>, ModuleAdapter<?>> result) {
+      List<ModuleWithAdapter> result, HashSet<Class<?>> visitedClasses) {
     for (Class<?> include : adapter.includes) {
-      if (!result.containsKey(include)) {
+      if (!visitedClasses.contains(include)) {
         ModuleAdapter<?> includedModuleAdapter = plugin.getModuleAdapter(include);
-        result.put(include, includedModuleAdapter);
-        collectIncludedModulesRecursively(plugin, includedModuleAdapter, result);
+        result.add(new ModuleWithAdapter(includedModuleAdapter, includedModuleAdapter.newModule()));
+        visitedClasses.add(include);
+        collectIncludedModulesRecursively(plugin, includedModuleAdapter, result, visitedClasses);
       }
     }
   }
