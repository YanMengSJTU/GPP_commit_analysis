diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/ProvidesInProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/ProvidesInProducerModule.java
new file mode 100644
index 000000000..37677aa81
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/ProvidesInProducerModule.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import com.google.common.util.concurrent.MoreExecutors;
+import dagger.Provides;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import dagger.producers.Production;
+import dagger.producers.ProductionComponent;
+import java.util.concurrent.Executor;
+
+final class ProvidesInProducerModule {
+  @ProducerModule
+  static class OnlyModule {
+    @Provides
+    @Production
+    static Executor provideExecutor() {
+      return MoreExecutors.directExecutor();
+    }
+
+    @Produces
+    static String produceString() {
+      return "produced";
+    }
+  }
+
+  @ProductionComponent(modules = OnlyModule.class)
+  interface C {
+    ListenableFuture<String> string();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index 5fae068e6..7b32c9da0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -201,6 +201,9 @@ public SourceVersion getSupportedSourceVersion() {
         producerModuleProcessingStep(
             messager,
             moduleValidator,
+            provisionBindingFactory,
+            factoryGenerator,
+            providesMethodValidator,
             productionBindingFactory,
             producerFactoryGenerator,
             producesMethodValidator,
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
index 33fd0b82b..f86fac5d4 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
@@ -39,16 +39,14 @@
 /**
  * A {@link ProcessingStep} that validates module classes and generates factories for binding
  * methods.
- *
- * @param <B> the type of binding created from methods
  */
-final class ModuleProcessingStep<B extends Binding> implements ProcessingStep {
+final class ModuleProcessingStep implements ProcessingStep {
 
   /**
-   * A {@link ProcessingStep} for {@link Module @Module} classes that generates factories for
-   * {@link Provides @Provides} methods.
+   * A {@link ProcessingStep} for {@code @Module} classes that generates factories for {@code
+   * @Provides} methods.
    */
-  static ModuleProcessingStep<ProvisionBinding> moduleProcessingStep(
+  static ModuleProcessingStep moduleProcessingStep(
       Messager messager,
       ModuleValidator moduleValidator,
       final ProvisionBinding.Factory provisionBindingFactory,
@@ -56,56 +54,49 @@
       ProvidesMethodValidator providesMethodValidator,
       BindsMethodValidator bindsMethodValidator,
       MultibindsMethodValidator multibindsMethodValidator) {
-    return new ModuleProcessingStep<>(
+    return new ModuleProcessingStep(
         messager,
         Module.class,
         moduleValidator,
-        Provides.class,
-        new ModuleMethodBindingFactory<ProvisionBinding>() {
-          @Override
-          public ProvisionBinding bindingForModuleMethod(
-              ExecutableElement method, TypeElement module) {
-            return provisionBindingFactory.forProvidesMethod(method, module);
-          }
-        },
-        factoryGenerator,
+        ImmutableSet.<ModuleMethodFactoryGenerator>of(
+            new ProvisionModuleMethodFactoryGenerator(provisionBindingFactory, factoryGenerator)),
         ImmutableSet.of(providesMethodValidator, bindsMethodValidator, multibindsMethodValidator));
   }
 
   /**
-   * A {@link ProcessingStep} for {@link ProducerModule @ProducerModule} classes that generates
-   * factories for {@link Produces @Produces} methods.
+   * A {@link ProcessingStep} for {@code @ProducerModule} classes that generates factories for
+   * {@code @Provides} and {@code @Produces} methods.
    */
-  static ModuleProcessingStep<ProductionBinding> producerModuleProcessingStep(
+  static ModuleProcessingStep producerModuleProcessingStep(
       Messager messager,
       ModuleValidator moduleValidator,
-      final ProductionBinding.Factory productionBindingFactory,
+      ProvisionBinding.Factory provisionBindingFactory,
+      FactoryGenerator factoryGenerator,
+      ProvidesMethodValidator providesMethodValidator,
+      ProductionBinding.Factory productionBindingFactory,
       ProducerFactoryGenerator producerFactoryGenerator,
       ProducesMethodValidator producesMethodValidator,
       BindsMethodValidator bindsMethodValidator,
       MultibindsMethodValidator multibindsMethodValidator) {
-    return new ModuleProcessingStep<>(
+    return new ModuleProcessingStep(
         messager,
         ProducerModule.class,
         moduleValidator,
-        Produces.class,
-        new ModuleMethodBindingFactory<ProductionBinding>() {
-          @Override
-          public ProductionBinding bindingForModuleMethod(
-              ExecutableElement method, TypeElement module) {
-            return productionBindingFactory.forProducesMethod(method, module);
-          }
-        },
-        producerFactoryGenerator,
-        ImmutableSet.of(producesMethodValidator, bindsMethodValidator, multibindsMethodValidator));
+        ImmutableSet.of(
+            new ProvisionModuleMethodFactoryGenerator(provisionBindingFactory, factoryGenerator),
+            new ProductionModuleMethodFactoryGenerator(
+                productionBindingFactory, producerFactoryGenerator)),
+        ImmutableSet.of(
+            providesMethodValidator,
+            producesMethodValidator,
+            bindsMethodValidator,
+            multibindsMethodValidator));
   }
 
   private final Messager messager;
   private final Class<? extends Annotation> moduleAnnotation;
   private final ModuleValidator moduleValidator;
-  private final Class<? extends Annotation> factoryMethodAnnotation;
-  private final ModuleMethodBindingFactory<B> moduleMethodBindingFactory;
-  private final SourceFileGenerator<B> factoryGenerator;
+  private final ImmutableSet<ModuleMethodFactoryGenerator> moduleMethodFactoryGenerators;
   private final ImmutableSet<? extends BindingMethodValidator> methodValidators;
   private final Set<TypeElement> processedModuleElements = Sets.newLinkedHashSet();
 
@@ -113,23 +104,18 @@ public ProductionBinding bindingForModuleMethod(
    * Creates a new processing step.
    *
    * @param moduleAnnotation the annotation on the module class
-   * @param factoryMethodAnnotation the annotation on methods that need factories
    * @param methodValidators validators for binding methods
    */
   ModuleProcessingStep(
       Messager messager,
       Class<? extends Annotation> moduleAnnotation,
       ModuleValidator moduleValidator,
-      Class<? extends Annotation> factoryMethodAnnotation,
-      ModuleMethodBindingFactory<B> moduleMethodBindingFactory,
-      SourceFileGenerator<B> factoryGenerator,
+      ImmutableSet<ModuleMethodFactoryGenerator> moduleMethodFactoryGenerators,
       Iterable<? extends BindingMethodValidator> methodValidators) {
     this.messager = messager;
     this.moduleAnnotation = moduleAnnotation;
     this.moduleValidator = moduleValidator;
-    this.factoryMethodAnnotation = factoryMethodAnnotation;
-    this.moduleMethodBindingFactory = moduleMethodBindingFactory;
-    this.factoryGenerator = factoryGenerator;
+    this.moduleMethodFactoryGenerators = moduleMethodFactoryGenerators;
     this.methodValidators = ImmutableSet.copyOf(methodValidators);
   }
 
@@ -158,10 +144,15 @@ public ProductionBinding bindingForModuleMethod(
       if (report.isClean()) {
         List<ExecutableElement> moduleMethods = methodsIn(moduleElement.getEnclosedElements());
         if (moduleMethodsAreValid(validMethods, moduleMethods)) {
-          for (ExecutableElement method :
-              elementsWithAnnotation(moduleMethods, factoryMethodAnnotation)) {
-            generateFactory(
-                moduleMethodBindingFactory.bindingForModuleMethod(method, moduleElement));
+          for (ModuleMethodFactoryGenerator generator : moduleMethodFactoryGenerators) {
+            for (ExecutableElement method :
+                elementsWithAnnotation(moduleMethods, generator.factoryMethodAnnotation())) {
+              try {
+                generator.generate(method, moduleElement);
+              } catch (SourceFileGenerationException e) {
+                e.printMessageTo(messager);
+              }
+            }
           }
         }
       }
@@ -200,15 +191,62 @@ private boolean moduleMethodsAreValid(
     return true;
   }
 
-  private void generateFactory(B binding) {
-    try {
-      factoryGenerator.generate(binding);
-    } catch (SourceFileGenerationException e) {
-      e.printMessageTo(messager);
+  interface ModuleMethodFactoryGenerator {
+    /** Binding method annotation for which factories should be generated. */
+    Class<? extends Annotation> factoryMethodAnnotation();
+
+    /** Generates the factory source file for the given method and module. */
+    void generate(ExecutableElement method, TypeElement moduleElement)
+        throws SourceFileGenerationException;
+  }
+
+  private static final class ProvisionModuleMethodFactoryGenerator
+      implements ModuleMethodFactoryGenerator {
+
+    private final ProvisionBinding.Factory provisionBindingFactory;
+    private final FactoryGenerator factoryGenerator;
+
+    ProvisionModuleMethodFactoryGenerator(
+        ProvisionBinding.Factory provisionBindingFactory, FactoryGenerator factoryGenerator) {
+      this.provisionBindingFactory = provisionBindingFactory;
+      this.factoryGenerator = factoryGenerator;
+    }
+
+    @Override
+    public Class<? extends Annotation> factoryMethodAnnotation() {
+      return Provides.class;
+    }
+
+    @Override
+    public void generate(ExecutableElement method, TypeElement moduleElement)
+        throws SourceFileGenerationException {
+      factoryGenerator.generate(provisionBindingFactory.forProvidesMethod(method, moduleElement));
     }
   }
 
-  private interface ModuleMethodBindingFactory<B extends Binding> {
-    B bindingForModuleMethod(ExecutableElement method, TypeElement module);
+  private static final class ProductionModuleMethodFactoryGenerator
+      implements ModuleMethodFactoryGenerator {
+
+    private final ProductionBinding.Factory productionBindingFactory;
+    private final ProducerFactoryGenerator producerFactoryGenerator;
+
+    ProductionModuleMethodFactoryGenerator(
+        ProductionBinding.Factory productionBindingFactory,
+        ProducerFactoryGenerator productionFactoryGenerator) {
+      this.productionBindingFactory = productionBindingFactory;
+      this.producerFactoryGenerator = productionFactoryGenerator;
+    }
+
+    @Override
+    public Class<? extends Annotation> factoryMethodAnnotation() {
+      return Produces.class;
+    }
+
+    @Override
+    public void generate(ExecutableElement method, TypeElement moduleElement)
+        throws SourceFileGenerationException {
+      producerFactoryGenerator.generate(
+          productionBindingFactory.forProducesMethod(method, moduleElement));
+    }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
index 4de6fd673..3c6b46e62 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
@@ -15,8 +15,10 @@
  */
 package dagger.internal.codegen;
 
+import com.google.common.collect.ImmutableSet;
 import dagger.Module;
 import dagger.Provides;
+import dagger.producers.ProducerModule;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.util.Elements;
@@ -35,7 +37,13 @@
 final class ProvidesMethodValidator extends BindingMethodValidator {
 
   ProvidesMethodValidator(Elements elements, Types types) {
-    super(elements, types, Provides.class, Module.class, MUST_BE_CONCRETE, RUNTIME_EXCEPTION);
+    super(
+        elements,
+        types,
+        Provides.class,
+        ImmutableSet.of(Module.class, ProducerModule.class),
+        MUST_BE_CONCRETE,
+        RUNTIME_EXCEPTION);
   }
 
   @Override
