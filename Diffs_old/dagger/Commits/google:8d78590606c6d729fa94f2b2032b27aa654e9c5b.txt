diff --git a/core/src/main/java/dagger/internal/Collections.java b/core/src/main/java/dagger/internal/Collections.java
index a43ab2d01..55f26ebab 100644
--- a/core/src/main/java/dagger/internal/Collections.java
+++ b/core/src/main/java/dagger/internal/Collections.java
@@ -19,32 +19,40 @@
 import java.util.LinkedHashSet;
 
 final class Collections {
+  /**
+   * The maximum value for a signed 32-bit integer that is equal to a power of 2.
+   */
+  private static final int MAX_POWER_OF_TWO = 1 << (Integer.SIZE - 2);
+
   private Collections() {
   }
 
   /**
    * Creates a {@link LinkedHashSet} instance, with a high enough "initial capacity" that it
-   * <em>should</em> hold {@code expectedSize} elements without growth. The load factor is set at
-   * {@code 1f} under the assumption this will be filled and wrapped in an unmodifiable wrapper.
+   * <em>should</em> hold {@code expectedSize} elements without growth.
    */
   static <E> LinkedHashSet<E> newLinkedHashSetWithExpectedSize(int expectedSize) {
-    return new LinkedHashSet<E>(calculateInitialCapacity(expectedSize), 1f);
+    return new LinkedHashSet<E>(calculateInitialCapacity(expectedSize));
   }
 
   /**
    * Creates a {@link LinkedHashMap} instance, with a high enough "initial capacity" that it
-   * <em>should</em> hold {@code expectedSize} elements without growth. The load factor is set at
-   * {@code 1f} under the assumption this will be filled and wrapped in an unmodifiable wrapper.
+   * <em>should</em> hold {@code expectedSize} elements without growth.
    */
   static <K, V> LinkedHashMap<K, V> newLinkedHashMapWithExpectedSize(int expectedSize) {
-    return new LinkedHashMap<K, V>(calculateInitialCapacity(expectedSize), 1f);
+    return new LinkedHashMap<K, V>(calculateInitialCapacity(expectedSize));
   }
 
   private static int calculateInitialCapacity(int expectedSize) {
-    return (expectedSize < 3)
-        ? expectedSize + 1
-        : (expectedSize < (1 << (Integer.SIZE - 2)))
-            ? expectedSize + expectedSize / 3
-            : Integer.MAX_VALUE;
+    if (expectedSize < 3) {
+      return expectedSize + 1;
+    }
+    if (expectedSize < MAX_POWER_OF_TWO) {
+      // This is the calculation used in JDK8 to resize when a putAll
+      // happens; it seems to be the most conservative calculation we
+      // can make.  0.75 is the default load factor.
+      return (int) (expectedSize / 0.75F + 1.0F);
+    }
+    return Integer.MAX_VALUE; // any large value
   }
 }
