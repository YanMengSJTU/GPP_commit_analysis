diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/SimpleProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/SimpleProducerModule.java
index 2d831ed7f..63500ca0c 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/SimpleProducerModule.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/SimpleProducerModule.java
@@ -19,6 +19,7 @@
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
 import com.google.common.util.concurrent.SettableFuture;
+import dagger.Lazy;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
 import dagger.producers.ProducerModule;
@@ -130,6 +131,15 @@ static String strWithArgsThrowingException(
     return Futures.immediateFuture("str with args throwing exception");
   }
 
+  @Produces
+  @Qual(12)
+  static String strWithFrameworkTypeArgs(
+      @Qual(1) int i, @Qual(1) Provider<Integer> iProvider, @Qual(1) Lazy<Integer> iLazy,
+      @Qual(2) int j, @Qual(2) Produced<Integer> jProduced, @Qual(2) Producer<Integer> jProducer,
+      @Qual(3) Produced<Integer> kProduced, @Qual(3) Producer<Integer> kProducer) {
+    return "str with framework type args";
+  }
+
   // Set bindings.
 
   @Produces(type = SET)
diff --git a/compiler/src/main/java/dagger/internal/codegen/FrameworkDependency.java b/compiler/src/main/java/dagger/internal/codegen/FrameworkDependency.java
index 57851cbf0..1b941e475 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FrameworkDependency.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FrameworkDependency.java
@@ -117,6 +117,19 @@
     return frameworkDependencies.build();
   }
 
+  /** Indexes {@code dependencies} by their {@link #dependencyRequests()}. */
+  static ImmutableMap<DependencyRequest, FrameworkDependency> indexByDependencyRequest(
+      Iterable<FrameworkDependency> dependencies) {
+    ImmutableMap.Builder<DependencyRequest, FrameworkDependency> frameworkDependencyMap =
+        ImmutableMap.builder();
+    for (FrameworkDependency dependency : dependencies) {
+      for (DependencyRequest request : dependency.dependencyRequests()) {
+        frameworkDependencyMap.put(request, dependency);
+      }
+    }
+    return frameworkDependencyMap.build();
+  }
+
   /**
    * Groups {@code binding}'s implicit dependencies by their binding key, using the dependency keys
    * from the {@link Binding#unresolved()} binding if it exists.
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
index 9aa21f4ca..d7bbdbd27 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -123,19 +123,6 @@ ClassName nameGeneratedType(ProductionBinding binding) {
           factoryBuilder, constructorBuilder, bindingField.name(), fieldType);
     }
 
-    boolean returnsFuture =
-        binding.bindingKind().equals(ContributionBinding.Kind.FUTURE_PRODUCTION);
-    ImmutableList<DependencyRequest> asyncDependencies =
-        FluentIterable.from(binding.implicitDependencies())
-            .filter(
-                new Predicate<DependencyRequest>() {
-                  @Override
-                  public boolean apply(DependencyRequest dependency) {
-                    return isAsyncDependency(dependency);
-                  }
-                })
-            .toList();
-
     MethodSpec.Builder computeMethodBuilder =
         methodBuilder("compute")
             .returns(futureTypeName)
@@ -143,6 +130,7 @@ public boolean apply(DependencyRequest dependency) {
             .addModifiers(PROTECTED)
             .addParameter(ProducerMonitor.class, "monitor", FINAL);
 
+    ImmutableList<DependencyRequest> asyncDependencies = asyncDependencies(binding);
     for (DependencyRequest dependency : asyncDependencies) {
       TypeName futureType = listenableFutureOf(asyncDependencyType(dependency));
       CodeBlock futureAccess =
@@ -177,7 +165,6 @@ public boolean apply(DependencyRequest dependency) {
             getThrowsClause(binding.thrownTypes()),
             getInvocationCodeBlock(
                 generatedTypeName,
-                !returnsFuture,
                 binding,
                 providedTypeName,
                 futureTransform.parameterCodeBlocks()));
@@ -207,6 +194,26 @@ private static void addFieldAndConstructorParameter(
         .addStatement("this.$1L = $1L", variableName);
   }
 
+  /** Returns a list of dependencies that are generated asynchronously. */
+  private static ImmutableList<DependencyRequest> asyncDependencies(Binding binding) {
+    final ImmutableMap<DependencyRequest, FrameworkDependency> frameworkDependencies =
+        FrameworkDependency.indexByDependencyRequest(
+            FrameworkDependency.frameworkDependenciesForBinding(binding));
+    return FluentIterable.from(binding.implicitDependencies())
+        .filter(
+            new Predicate<DependencyRequest>() {
+              @Override
+              public boolean apply(DependencyRequest dependency) {
+                return isAsyncDependency(dependency)
+                    && frameworkDependencies
+                        .get(dependency)
+                        .frameworkClass()
+                        .equals(Producer.class);
+              }
+            })
+        .toList();
+  }
+
   /** Returns a name of the variable representing this dependency's future. */
   private static String dependencyFutureName(DependencyRequest dependency) {
     return dependency.requestElement().getSimpleName() + "Future";
@@ -432,15 +439,12 @@ private static TypeName asyncDependencyType(DependencyRequest dependency) {
    * Creates a code block for the invocation of the producer method from the module, which should be
    * used entirely within a method body.
    *
-   * @param wrapWithFuture If true, wraps the result of the call to the producer method
-   *        in an immediate future.
    * @param binding The binding to generate the invocation code block for.
    * @param providedTypeName The type name that should be provided by this producer.
    * @param parameterCodeBlocks The code blocks for all the parameters to the producer method.
    */
   private CodeBlock getInvocationCodeBlock(
       ClassName generatedTypeName,
-      boolean wrapWithFuture,
       ProductionBinding binding,
       TypeName providedTypeName,
       ImmutableList<CodeBlock> parameterCodeBlocks) {
@@ -470,13 +474,13 @@ private CodeBlock getInvocationCodeBlock(
       valueCodeBlock = moduleCodeBlock;
     }
     CodeBlock returnCodeBlock =
-        wrapWithFuture
-            ? CodeBlocks.format(
+        binding.bindingKind().equals(ContributionBinding.Kind.FUTURE_PRODUCTION)
+            ? valueCodeBlock
+            : CodeBlocks.format(
                 "$T.<$T>immediateFuture($L)",
                 FUTURES,
                 providedTypeName,
-                valueCodeBlock)
-            : valueCodeBlock;
+                valueCodeBlock);
     return CodeBlocks.format(
         Joiner.on('\n')
             .join(
