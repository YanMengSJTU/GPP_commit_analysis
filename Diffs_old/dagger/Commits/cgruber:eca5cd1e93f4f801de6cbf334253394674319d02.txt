diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 6b191fce0..97bb0c7e6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -579,7 +579,7 @@ private boolean useRawType(Optional<String> bindingPackage) {
               MapType mapType = MapType.from(contributionBinding.key());
               return Optional.of(
                   emptyFrameworkMapFactory(
-                      frameworkMapFactoryClassName(bindingType),
+                      bindingType,
                       mapType.keyType(),
                       mapType.unwrappedValueType(bindingType.frameworkClass())));
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/MemberSelect.java b/compiler/src/main/java/dagger/internal/codegen/MemberSelect.java
index 015ad36bf..9525860e3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MemberSelect.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MemberSelect.java
@@ -16,7 +16,6 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
@@ -31,8 +30,6 @@
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import dagger.MembersInjector;
-import dagger.internal.MapProviderFactory;
-import dagger.producers.internal.MapOfProducerProducer;
 import java.util.List;
 import java.util.Set;
 import javax.lang.model.type.TypeMirror;
@@ -116,24 +113,31 @@ static MemberSelect noOpMembersInjector(TypeMirror type) {
         MEMBERS_INJECTOR);
   }
 
-  /**
+   /**
    * A {@link MemberSelect} for an empty map of framework types.
    *
-   * @param frameworkMapFactoryClass either {@link MapProviderFactory}
-   *     or {@link MapOfProducerProducer}
+   * @param bindingType the type of the binding of the empty map
    */
   static MemberSelect emptyFrameworkMapFactory(
-      ClassName frameworkMapFactoryClass, TypeMirror keyType, TypeMirror unwrappedValueType) {
-    checkArgument(
-        frameworkMapFactoryClass.equals(MAP_PROVIDER_FACTORY)
-            || frameworkMapFactoryClass.equals(MAP_OF_PRODUCER_PRODUCER),
-        "frameworkMapFactoryClass must be MapProviderFactory or MapOfProducerProducer: %s",
-        frameworkMapFactoryClass);
+      BindingType bindingType, TypeMirror keyType, TypeMirror unwrappedValueType) {
+    final ClassName frameworkMapFactoryClass;
+    switch (bindingType) {
+      case PROVISION:
+        frameworkMapFactoryClass = MAP_PROVIDER_FACTORY;
+        break;
+      case PRODUCTION:
+        frameworkMapFactoryClass = MAP_OF_PRODUCER_PRODUCER;
+        break;
+      case MEMBERS_INJECTION:
+        throw new IllegalArgumentException();
+      default:
+        throw new AssertionError();
+    }
     return new ParameterizedStaticMethod(
         frameworkMapFactoryClass,
         ImmutableList.of(keyType, unwrappedValueType),
         CodeBlock.of("empty()"),
-        frameworkMapFactoryClass);
+        ClassName.get(bindingType.frameworkClass()));
   }
 
   /**
diff --git a/core/src/main/java/dagger/internal/InstanceFactory.java b/core/src/main/java/dagger/internal/InstanceFactory.java
index d4b96ea2d..8cb993f17 100644
--- a/core/src/main/java/dagger/internal/InstanceFactory.java
+++ b/core/src/main/java/dagger/internal/InstanceFactory.java
@@ -16,24 +16,25 @@
 
 package dagger.internal;
 
+import static dagger.internal.Preconditions.checkNotNull;
+
+import dagger.Lazy;
+
 /**
- * A {@link Factory} implementation that returns a single instance for all invocations of
- * {@link #get}.
+ * A {@link Factory} implementation that returns a single instance for all invocations of {@link
+ * #get}.
  *
  * <p>Note that while this is a {@link Factory} implementation, and thus unscoped, each call to
- * {@link #get} will always return the same instance.  As such, any scoping applied to this factory
- * is redundant and unnecessary.  However, using this with {@link DoubleCheck#provider} is valid and
+ * {@link #get} will always return the same instance. As such, any scoping applied to this factory
+ * is redundant and unnecessary. However, using this with {@link DoubleCheck#provider} is valid and
  * may be desired for testing or contractual guarantees.
  *
  * @author Gregory Kick
  * @since 2.0
  */
-public final class InstanceFactory<T> implements Factory<T> {
+public final class InstanceFactory<T> implements Factory<T>, Lazy<T> {
   public static <T> Factory<T> create(T instance) {
-    if (instance == null) {
-      throw new NullPointerException();
-    }
-    return new InstanceFactory<T>(instance);
+    return new InstanceFactory<T>(checkNotNull(instance, "instance cannot be null"));
   }
 
   private final T instance;
diff --git a/core/src/main/java/dagger/internal/SetFactory.java b/core/src/main/java/dagger/internal/SetFactory.java
index 618df1b6e..b5a2ecd1e 100644
--- a/core/src/main/java/dagger/internal/SetFactory.java
+++ b/core/src/main/java/dagger/internal/SetFactory.java
@@ -38,13 +38,7 @@
  * @since 2.0
  */
 public final class SetFactory<T> implements Factory<Set<T>> {
-  private static final Factory<Set<Object>> EMPTY_FACTORY =
-      new Factory<Set<Object>>() {
-        @Override
-        public Set<Object> get() {
-          return emptySet();
-        }
-      };
+  private static final Factory<Set<Object>> EMPTY_FACTORY = InstanceFactory.create(emptySet());
 
   @SuppressWarnings({"unchecked", "rawtypes"}) // safe covariant cast
   public static <T> Factory<Set<T>> empty() {
diff --git a/core/src/test/java/dagger/internal/DoubleCheckTest.java b/core/src/test/java/dagger/internal/DoubleCheckTest.java
index eda82aaa0..0a5a55160 100644
--- a/core/src/test/java/dagger/internal/DoubleCheckTest.java
+++ b/core/src/test/java/dagger/internal/DoubleCheckTest.java
@@ -181,4 +181,10 @@ public Object get() {
       fail();
     } catch (IllegalStateException expected) {}
   }
+
+  @Test
+  public void instanceFactoryAsLazyDoesNotWrap() {
+    Factory<Object> factory = InstanceFactory.create(new Object());
+    assertThat(DoubleCheck.lazy(factory)).isSameAs(factory);
+  }
 }
diff --git a/core/src/test/java/dagger/internal/InstanceFactoryTest.java b/core/src/test/java/dagger/internal/InstanceFactoryTest.java
index 14474723a..82b66e687 100644
--- a/core/src/test/java/dagger/internal/InstanceFactoryTest.java
+++ b/core/src/test/java/dagger/internal/InstanceFactoryTest.java
@@ -17,17 +17,14 @@
 package dagger.internal;
 
 import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
 
-import org.junit.Rule;
 import org.junit.Test;
-import org.junit.rules.ExpectedException;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
 @RunWith(JUnit4.class)
 public final class InstanceFactoryTest {
-  @Rule public final ExpectedException thrown = ExpectedException.none();
-
   @Test public void instanceFactory() {
     Object instance = new Object();
     Factory<Object> factory = InstanceFactory.create(instance);
@@ -37,7 +34,10 @@
   }
 
   @Test public void create_throwsNullPointerException() {
-    thrown.expect(NullPointerException.class);
-    InstanceFactory.create(null);
+    try {
+      InstanceFactory.create(null);
+      fail();
+    } catch (NullPointerException expected) {
+    }
   }
 }
