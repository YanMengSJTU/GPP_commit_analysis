diff --git a/java/dagger/android/AndroidInjector.java b/java/dagger/android/AndroidInjector.java
index df778e2d5..260ecd231 100644
--- a/java/dagger/android/AndroidInjector.java
+++ b/java/dagger/android/AndroidInjector.java
@@ -16,7 +16,6 @@
 
 package dagger.android;
 
-import com.google.errorprone.annotations.DoNotMock;
 import dagger.BindsInstance;
 import dagger.internal.Beta;
 
@@ -33,8 +32,6 @@
  * @see DispatchingAndroidInjector
  */
 @Beta
-@DoNotMock(
-    "Faked versions of AndroidInjector are much clearer than a mock. See https://google.github.io/dagger/testing")
 public interface AndroidInjector<T> {
 
   /** Injects the members of {@code instance}. */
@@ -45,7 +42,6 @@
    *
    * @param <T> the concrete type to be injected
    */
-  @DoNotMock
   interface Factory<T> {
     /**
      * Creates an {@link AndroidInjector} for {@code instance}. This should be the same instance
@@ -60,7 +56,6 @@
    *
    * @param <T> the concrete type to be injected
    */
-  @DoNotMock
   abstract class Builder<T> implements AndroidInjector.Factory<T> {
     @Override
     public final AndroidInjector<T> create(T instance) {
diff --git a/java/dagger/android/AndroidMemorySensitiveReferenceManager.java b/java/dagger/android/AndroidMemorySensitiveReferenceManager.java
index 4a53639bb..80de62760 100644
--- a/java/dagger/android/AndroidMemorySensitiveReferenceManager.java
+++ b/java/dagger/android/AndroidMemorySensitiveReferenceManager.java
@@ -44,7 +44,7 @@
  * @since 2.8
  * @deprecated The releasable references feature is deprecated and scheduled for removal in July
  *     2018. If you use it or are planning to add usages, please
- *     <a href="https://github.com/google/dagger/issues/1117">this bug</a>.
+ *     comment on <a href="https://github.com/google/dagger/issues/1117">this bug</a>.
  */
 @Beta
 @GwtIncompatible
diff --git a/java/dagger/android/ReleaseReferencesAt.java b/java/dagger/android/ReleaseReferencesAt.java
index 53efe7665..78ae99c4d 100644
--- a/java/dagger/android/ReleaseReferencesAt.java
+++ b/java/dagger/android/ReleaseReferencesAt.java
@@ -48,7 +48,7 @@
  * @since 2.8
  * @deprecated The releasable references feature is deprecated and scheduled for removal in July
  *     2018. If you use it or are planning to add usages, please
- *     <a href="https://github.com/google/dagger/issues/1117">this bug</a>.
+ *     comment on <a href="https://github.com/google/dagger/issues/1117">this bug</a>.
  */
 @Beta
 @Documented
diff --git a/java/dagger/android/processor/AndroidInjectorDescriptor.java b/java/dagger/android/processor/AndroidInjectorDescriptor.java
index 4c4b6379d..1deb3c3fd 100644
--- a/java/dagger/android/processor/AndroidInjectorDescriptor.java
+++ b/java/dagger/android/processor/AndroidInjectorDescriptor.java
@@ -33,7 +33,9 @@
 import com.squareup.javapoet.TypeName;
 import dagger.Module;
 import dagger.android.ContributesAndroidInjector;
+import java.lang.annotation.Annotation;
 import java.util.List;
+import java.util.Map;
 import java.util.Optional;
 import javax.annotation.processing.Messager;
 import javax.inject.Qualifier;
@@ -64,6 +66,9 @@
    */
   abstract ClassName frameworkType();
 
+  /** The {@link dagger.MapKey} type for the associated {@link #frameworkType()}. */
+  abstract ClassName mapKeyType();
+
   /** Scopes to apply to the generated {@link dagger.Subcomponent}. */
   abstract ImmutableSet<AnnotationSpec> scopes();
 
@@ -76,20 +81,6 @@
   /** Simple name of the {@link ContributesAndroidInjector} method. */
   abstract String methodName();
 
-  /**
-   * The {@link dagger.MapKey} annotation that groups {@link #frameworkType()}s, e.g.
-   * {@code @ActivityKey(MyActivity.class)}.
-   */
-  AnnotationSpec mapKeyAnnotation() {
-    String packageName =
-        frameworkType().packageName().contains(".support.")
-            ? "dagger.android.support"
-            : "dagger.android";
-    return AnnotationSpec.builder(ClassName.get(packageName, frameworkType().simpleName() + "Key"))
-        .addMember("value", "$T.class", injectedType())
-        .build();
-  }
-
   @AutoValue.Builder
   abstract static class Builder {
     abstract Builder injectedType(ClassName injectedType);
@@ -100,6 +91,8 @@ AnnotationSpec mapKeyAnnotation() {
 
     abstract Builder frameworkType(ClassName frameworkType);
 
+    abstract Builder mapKeyType(ClassName mapKeyType);
+
     abstract Builder enclosingModule(ClassName enclosingModule);
 
     abstract Builder methodName(String methodName);
@@ -142,14 +135,19 @@ AnnotationSpec mapKeyAnnotation() {
       builder.enclosingModule(ClassName.get(enclosingElement));
 
       TypeMirror injectedType = method.getReturnType();
-      Optional<TypeMirror> maybeFrameworkType =
+      Optional<? extends Class<? extends Annotation>> maybeMapKeyAnnotation =
           annotationsAndFrameworkTypes(elements)
-              .values()
+              .entrySet()
               .stream()
-              .filter(frameworkType -> types.isAssignable(injectedType, frameworkType))
+              .filter(entry -> types.isAssignable(injectedType, entry.getValue()))
+              .map(Map.Entry::getKey)
               .findFirst();
-      if (maybeFrameworkType.isPresent()) {
-        builder.frameworkType((ClassName) TypeName.get(maybeFrameworkType.get()));
+      if (maybeMapKeyAnnotation.isPresent()) {
+        Class<? extends Annotation> mapKeyAnnotation = maybeMapKeyAnnotation.get();
+        TypeMirror frameworkType = annotationsAndFrameworkTypes(elements).get(mapKeyAnnotation);
+        builder
+            .mapKeyType(ClassName.get(mapKeyAnnotation))
+            .frameworkType((ClassName) TypeName.get(frameworkType));
         if (MoreTypes.asDeclared(injectedType).getTypeArguments().isEmpty()) {
           builder.injectedType(ClassName.get(MoreTypes.asTypeElement(injectedType)));
         } else {
diff --git a/java/dagger/android/processor/AndroidProcessor.java b/java/dagger/android/processor/AndroidProcessor.java
index 7bb44474a..5db7fabeb 100644
--- a/java/dagger/android/processor/AndroidProcessor.java
+++ b/java/dagger/android/processor/AndroidProcessor.java
@@ -43,7 +43,10 @@
     return ImmutableList.of(
         new AndroidMapKeyValidator(elements, types, messager),
         new ContributesAndroidInjectorGenerator(
-            filer, new AndroidInjectorDescriptor.Validator(types, elements, messager)));
+            new AndroidInjectorDescriptor.Validator(types, elements, messager),
+            filer,
+            elements,
+            processingEnv.getSourceVersion()));
   }
 
   @Override
diff --git a/java/dagger/android/processor/ContributesAndroidInjectorGenerator.java b/java/dagger/android/processor/ContributesAndroidInjectorGenerator.java
index 10236dfbb..2d1023abc 100644
--- a/java/dagger/android/processor/ContributesAndroidInjectorGenerator.java
+++ b/java/dagger/android/processor/ContributesAndroidInjectorGenerator.java
@@ -16,6 +16,7 @@
 
 package dagger.android.processor;
 
+import static com.google.auto.common.GeneratedAnnotationSpecs.generatedAnnotationSpec;
 import static com.google.common.base.CaseFormat.LOWER_CAMEL;
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
 import static com.squareup.javapoet.MethodSpec.constructorBuilder;
@@ -47,23 +48,31 @@
 import dagger.Subcomponent.Builder;
 import dagger.android.AndroidInjector;
 import dagger.android.ContributesAndroidInjector;
+import dagger.android.processor.AndroidInjectorDescriptor.Validator;
 import dagger.multibindings.IntoMap;
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.util.Set;
 import javax.annotation.processing.Filer;
+import javax.lang.model.SourceVersion;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.util.Elements;
 
 /** Generates the implementation specified in {@link ContributesAndroidInjector}. */
 final class ContributesAndroidInjectorGenerator implements ProcessingStep {
 
-  private final Filer filer;
   private final AndroidInjectorDescriptor.Validator validator;
+  private final Filer filer;
+  private final Elements elements;
+  private final SourceVersion sourceVersion;
 
-  ContributesAndroidInjectorGenerator(Filer filer, AndroidInjectorDescriptor.Validator validator) {
+  ContributesAndroidInjectorGenerator(
+      Validator validator, Filer filer, Elements elements, SourceVersion sourceVersion) {
     this.filer = filer;
     this.validator = validator;
+    this.elements = elements;
+    this.sourceVersion = sourceVersion;
   }
 
   @Override
@@ -94,19 +103,21 @@ private void generate(AndroidInjectorDescriptor descriptor) {
     ClassName subcomponentName = moduleName.nestedClass(baseName + "Subcomponent");
     ClassName subcomponentBuilderName = subcomponentName.nestedClass("Builder");
 
-    TypeSpec module =
+    TypeSpec.Builder module =
         classBuilder(moduleName)
-            .addModifiers(PUBLIC, ABSTRACT)
             .addAnnotation(
                 AnnotationSpec.builder(Module.class)
                     .addMember("subcomponents", "$T.class", subcomponentName)
                     .build())
+            .addModifiers(PUBLIC, ABSTRACT)
             .addMethod(bindAndroidInjectorFactory(descriptor, subcomponentBuilderName))
             .addType(subcomponent(descriptor, subcomponentName, subcomponentBuilderName))
-            .addMethod(constructorBuilder().addModifiers(PRIVATE).build())
-            .build();
+            .addMethod(constructorBuilder().addModifiers(PRIVATE).build());
+    generatedAnnotationSpec(elements, sourceVersion, AndroidProcessor.class)
+        .ifPresent(module::addAnnotation);
+
     try {
-      JavaFile.builder(moduleName.packageName(), module)
+      JavaFile.builder(moduleName.packageName(), module.build())
           .skipJavaLangImports(true)
           .build()
           .writeTo(filer);
@@ -120,7 +131,10 @@ private MethodSpec bindAndroidInjectorFactory(
     return methodBuilder("bindAndroidInjectorFactory")
         .addAnnotation(Binds.class)
         .addAnnotation(IntoMap.class)
-        .addAnnotation(descriptor.mapKeyAnnotation())
+        .addAnnotation(
+            AnnotationSpec.builder(descriptor.mapKeyType())
+                .addMember("value", "$T.class", descriptor.injectedType())
+                .build())
         .addModifiers(ABSTRACT)
         .returns(
             parameterizedTypeName(
diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index 7161fbc79..914fb2426 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -31,10 +31,7 @@ CODEGEN_SRCS = glob(
     exclude = EXPERIMENTAL_VISUALIZER_SRCS + KYTHE_SRCS,
 )
 
-CODEGEN_PLUGINS = [
-    ":bootstrap_compiler_plugin",
-    # TODO(cgruber): Enable Beta checker.
-]
+CODEGEN_PLUGINS = [":bootstrap_compiler_plugin"]
 
 CODEGEN_SHARED_DEPS = [
     "//third_party:auto_service",
@@ -85,6 +82,7 @@ java_library(
         "DiagnosticFormatting.java",
         "Expression.java",
         "FeatureStatus.java",
+        "Formatter.java",
         "FrameworkTypes.java",
         "InjectionAnnotations.java",
         "Keys.java",
@@ -123,6 +121,7 @@ java_library(
         "BindingDeclaration.java",
         "BindingFactory.java",
         "BindingGraph.java",
+        "BindingNodeImpl.java",
         "BindingType.java",
         "BindingTypeMapper.java",
         "BindingVariableNamer.java",  # needed by FrameworkField
@@ -176,11 +175,9 @@ java_library(
         "ComponentValidator.java",
         "DependencyRequestFormatter.java",
         "ForReleasableReferencesValidator.java",
-        "Formatter.java",
         "InjectValidator.java",
         "MapKeyValidator.java",
         "MethodSignatureFormatter.java",
-        "MissingBindingSuggestions.java",
         "ModuleValidator.java",
         "MultibindingAnnotationsProcessingStep.java",
         "MultibindsMethodValidator.java",
@@ -200,13 +197,16 @@ java_library(
     name = "internal_validation",
     srcs = [
         "BindingGraphValidationModule.java",
+        "DuplicateBindingsValidation.java",
         "InjectBindingValidation.java",
         "MapMultibindingValidation.java",
         "MembersInjectionBindingValidation.java",
+        "MissingBindingValidation.java",
         "NonNullableRequestForNullableBindingValidation.java",
         "ProvisionDependencyOnProducerBindingValidation.java",
         "Validation.java",
     ],
+    tags = ["maven:merged"],
     deps = CODEGEN_DEPS + [
         ":base",
         ":binding",
@@ -261,6 +261,7 @@ java_library(
         "MonitoringModuleProcessingStep.java",
         "OptionalBindingExpression.java",
         "OptionalFactories.java",
+        "OptionalFactoryInstanceCreationExpression.java",
         "PrivateMethodBindingExpression.java",
         "ProducerCreationExpression.java",
         "ProducerFactoryGenerator.java",
@@ -376,6 +377,13 @@ java_library(
 java_plugin(
     name = "component-codegen",
     generates_api = 1,
+    output_licenses = ["unencumbered"],
     processor_class = "dagger.internal.codegen.ComponentProcessor",
+    tags = [
+        "annotation=dagger.Component;" +
+        "genclass=${package}.Dagger${outerclasses}${classname}",
+        "annotation=dagger.producers.ProductionComponent;" +
+        "genclass=${package}.Dagger${outerclasses}${classname}",
+    ],
     deps = [":processor"],
 )
diff --git a/java/dagger/internal/codegen/BindingDeclarationFormatter.java b/java/dagger/internal/codegen/BindingDeclarationFormatter.java
index 6acb4ed29..13a960c4e 100644
--- a/java/dagger/internal/codegen/BindingDeclarationFormatter.java
+++ b/java/dagger/internal/codegen/BindingDeclarationFormatter.java
@@ -32,6 +32,7 @@
 import com.google.common.collect.Iterables;
 import dagger.model.BindingKind;
 import javax.inject.Inject;
+import javax.lang.model.element.Element;
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 
@@ -85,42 +86,34 @@ public String format(BindingDeclaration bindingDeclaration) {
       return formatSubcomponentDeclaration((SubcomponentDeclaration) bindingDeclaration);
     }
 
-    if (bindingDeclaration instanceof ContributionBinding) {
-      ContributionBinding binding = (ContributionBinding) bindingDeclaration;
-      switch (binding.kind()) {
-        case RELEASABLE_REFERENCE_MANAGER:
-          return String.format(
-              "binding for %s from the scope declaration",
-              stripCommonTypePrefixes(binding.key().toString()));
-        case RELEASABLE_REFERENCE_MANAGERS:
-          return String.format(
-              "Dagger-generated binding for %s",
-              stripCommonTypePrefixes(binding.key().toString()));
+    if (bindingDeclaration.bindingElement().isPresent()) {
+      Element bindingElement = bindingDeclaration.bindingElement().get();
+      switch (bindingElement.asType().getKind()) {
+        case EXECUTABLE:
+          return methodSignatureFormatter.format(
+              MoreElements.asExecutable(bindingElement),
+              bindingDeclaration
+                  .contributingModule()
+                  .map(module -> MoreTypes.asDeclared(module.asType())));
+
+        case DECLARED:
+          return stripCommonTypePrefixes(bindingElement.asType().toString());
+
         default:
-          break;
+          throw new IllegalArgumentException(
+              "Formatting unsupported for element: " + bindingElement);
       }
     }
 
-    return bindingDeclaration
-        .bindingElement()
-        .map(
-            bindingElement -> {
-              switch (bindingElement.asType().getKind()) {
-                case EXECUTABLE:
-                  return methodSignatureFormatter.format(
-                      MoreElements.asExecutable(bindingElement),
-                      bindingDeclaration
-                          .contributingModule()
-                          .map(module -> MoreTypes.asDeclared(module.asType())));
-                case DECLARED:
-                  return stripCommonTypePrefixes(bindingElement.asType().toString());
-                default:
-                  throw new IllegalArgumentException(
-                      "Formatting unsupported for element: " + bindingElement);
-              }
-            })
-        // TODO(dpb): Give synthetic bindings a better string representation.
-        .orElseGet(() -> "synthetic binding for " + bindingDeclaration.key());
+    if (isReleasableReferenceManagerBinding(bindingDeclaration)) {
+      return String.format(
+          "binding for %s from the scope declaration",
+          stripCommonTypePrefixes(bindingDeclaration.key().toString()));
+    }
+
+    return String.format(
+        "Dagger-generated binding for %s",
+        stripCommonTypePrefixes(bindingDeclaration.key().toString()));
   }
 
   private String formatSubcomponentDeclaration(SubcomponentDeclaration subcomponentDeclaration) {
@@ -150,4 +143,9 @@ private String formatSubcomponentDeclaration(SubcomponentDeclaration subcomponen
         annotationValue,
         subcomponentDeclaration.contributingModule().get());
   }
+
+  private boolean isReleasableReferenceManagerBinding(BindingDeclaration bindingDeclaration) {
+    return bindingDeclaration instanceof ContributionBinding
+        && ((ContributionBinding) bindingDeclaration).kind().equals(RELEASABLE_REFERENCE_MANAGER);
+  }
 }
diff --git a/java/dagger/internal/codegen/BindingGraphConverter.java b/java/dagger/internal/codegen/BindingGraphConverter.java
index 9f17dc9aa..f35b5ce7f 100644
--- a/java/dagger/internal/codegen/BindingGraphConverter.java
+++ b/java/dagger/internal/codegen/BindingGraphConverter.java
@@ -16,25 +16,25 @@
 
 package dagger.internal.codegen;
 
-import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
+import static dagger.internal.codegen.DaggerStreams.instancesOf;
 import static dagger.model.BindingGraphProxies.childFactoryMethodEdge;
 import static dagger.model.BindingGraphProxies.componentNode;
 import static dagger.model.BindingGraphProxies.dependencyEdge;
 
-import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
 import com.google.common.graph.MutableNetwork;
 import com.google.common.graph.NetworkBuilder;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.model.BindingGraph.BindingNode;
 import dagger.model.BindingGraph.ComponentNode;
+import dagger.model.BindingGraph.DependencyEdge;
 import dagger.model.BindingGraph.Edge;
+import dagger.model.BindingGraph.MissingBindingNode;
 import dagger.model.BindingGraph.Node;
 import dagger.model.BindingGraphProxies;
 import dagger.model.DependencyRequest;
-import java.util.Collection;
 import javax.inject.Inject;
-import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 
 /** Converts {@link dagger.internal.codegen.BindingGraph}s to {@link dagger.model.BindingGraph}s. */
@@ -75,16 +75,18 @@ protected void visitComponent(BindingGraph graph) {
       parentComponent = currentComponent;
       currentComponent =
           componentNode(
-              componentTreePath().toComponentPath(), graph.componentDescriptor().entryPoints());
+              componentTreePath().toComponentPath(),
+              graph.componentDescriptor().entryPoints(),
+              graph.componentDescriptor().scopes());
 
       network.addNode(currentComponent);
 
       for (ComponentMethodDescriptor method : graph.componentDescriptor().entryPointMethods()) {
-        addDependencyEdges(currentComponent, method.dependencyRequest().get(), graph);
+        addDependencyEdges(currentComponent, method.dependencyRequest().get());
       }
 
       for (ResolvedBindings resolvedBindings : graph.resolvedBindings()) {
-        bindingNodes(resolvedBindings).forEach(node -> addBindingNode(node, graph));
+        bindingNodes(resolvedBindings).forEach(node -> addBindingNode(node));
       }
 
       super.visitComponent(graph);
@@ -104,15 +106,51 @@ protected void visitSubcomponentFactoryMethod(
      * Adds a {@link dagger.model.BindingGraph.DependencyEdge} from a node to the binding(s) that
      * satisfy a dependency request.
      */
-    private void addDependencyEdges(
-        Node source, DependencyRequest dependencyRequest, BindingGraph graph) {
-      for (BindingNode dependency :
-          bindingNodes(graph.resolvedBindings(dependencyRequest.kind(), dependencyRequest.key()))) {
+    private void addDependencyEdges(Node source, DependencyRequest dependencyRequest) {
+      ResolvedBindings dependencies = resolvedDependencies(source, dependencyRequest);
+      if (dependencies.isEmpty()) {
+        addDependencyEdge(source, dependencyRequest, missingBindingNode(dependencies));
+      } else {
+        for (BindingNode dependency : bindingNodes(dependencies)) {
+          addDependencyEdge(source, dependencyRequest, dependency);
+        }
+      }
+    }
+
+    private void addDependencyEdge(
+        Node source, DependencyRequest dependencyRequest, Node dependency) {
+      network.addNode(dependency);
+      if (!hasDependencyEdge(source, dependency, dependencyRequest)) {
         network.addEdge(
             source, dependency, dependencyEdge(dependencyRequest, source instanceof ComponentNode));
       }
     }
 
+    private boolean hasDependencyEdge(
+        Node source, Node dependency, DependencyRequest dependencyRequest) {
+      return network
+          .edgesConnecting(source, dependency)
+          .stream()
+          .flatMap(instancesOf(DependencyEdge.class))
+          .anyMatch(edge -> edge.dependencyRequest().equals(dependencyRequest));
+    }
+
+    private ResolvedBindings resolvedDependencies(
+        Node source, DependencyRequest dependencyRequest) {
+      return componentTreePath()
+          .pathFromRootToAncestor(source.componentPath().currentComponent())
+          .currentGraph()
+          .resolvedBindings(dependencyRequest.kind(), dependencyRequest.key());
+    }
+
+    /** Adds a binding node and edges for all its dependencies. */
+    private void addBindingNode(BindingNode node) {
+      network.addNode(node);
+      for (DependencyRequest dependencyRequest : node.binding().dependencies()) {
+        addDependencyEdges(node, dependencyRequest);
+      }
+    }
+
     private ImmutableSet<BindingNode> bindingNodes(ResolvedBindings resolvedBindings) {
       ImmutableSet.Builder<BindingNode> bindingNodes = ImmutableSet.builder();
       resolvedBindings
@@ -127,32 +165,31 @@ private void addDependencyEdges(
       return bindingNodes.build();
     }
 
-    /** Adds a binding node and edges for all its dependencies. */
-    private void addBindingNode(BindingNode node, BindingGraph graph) {
-      network.addNode(node);
-      for (DependencyRequest dependencyRequest : node.binding().dependencies()) {
-        addDependencyEdges(node, dependencyRequest, graph);
-      }
-    }
-
     private BindingNode bindingNode(
         ResolvedBindings resolvedBindings, Binding binding, ComponentDescriptor owningComponent) {
-      return BindingGraphProxies.bindingNode(
-          componentTreePath().pathFromRootToAncestor(owningComponent).toComponentPath(),
+      return BindingNodeImpl.create(
+          componentTreePath()
+              .pathFromRootToAncestor(owningComponent.componentDefinitionType())
+              .toComponentPath(),
           binding,
           associatedDeclaringElements(resolvedBindings),
           () -> bindingDeclarationFormatter.format(binding));
     }
 
-    private ImmutableSet<Element> associatedDeclaringElements(ResolvedBindings resolvedBindings) {
-      return ImmutableList.of(
-              resolvedBindings.multibindingDeclarations(),
-              resolvedBindings.optionalBindingDeclarations(),
-              resolvedBindings.subcomponentDeclarations())
-          .stream()
-          .flatMap(Collection::stream)
-          .map(declaration -> declaration.bindingElement().get())
-          .collect(toImmutableSet());
+    private Iterable<BindingDeclaration> associatedDeclaringElements(
+        ResolvedBindings resolvedBindings) {
+      return Iterables.concat(
+          resolvedBindings.multibindingDeclarations(),
+          resolvedBindings.optionalBindingDeclarations(),
+          resolvedBindings.subcomponentDeclarations());
+    }
+
+    private MissingBindingNode missingBindingNode(ResolvedBindings dependencies) {
+      return BindingGraphProxies.missingBindingNode(
+          componentTreePath()
+              .pathFromRootToAncestor(dependencies.owningComponent().componentDefinitionType())
+              .toComponentPath(),
+          dependencies.key());
     }
   }
 }
diff --git a/java/dagger/internal/codegen/BindingGraphValidationModule.java b/java/dagger/internal/codegen/BindingGraphValidationModule.java
index b3f6afa42..fc231522b 100644
--- a/java/dagger/internal/codegen/BindingGraphValidationModule.java
+++ b/java/dagger/internal/codegen/BindingGraphValidationModule.java
@@ -25,6 +25,11 @@
 @Module
 interface BindingGraphValidationModule {
 
+  @Binds
+  @IntoSet
+  @Validation
+  BindingGraphPlugin duplicateBindings(DuplicateBindingsValidation validation);
+
   @Binds
   @IntoSet
   @Validation
@@ -40,6 +45,11 @@
   @Validation
   BindingGraphPlugin membersInjection(MembersInjectionBindingValidation validation);
 
+  @Binds
+  @IntoSet
+  @Validation
+  BindingGraphPlugin missingBinding(MissingBindingValidation validation);
+
   @Binds
   @IntoSet
   @Validation
diff --git a/java/dagger/internal/codegen/BindingGraphValidator.java b/java/dagger/internal/codegen/BindingGraphValidator.java
index e11658151..a9767df95 100644
--- a/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -16,37 +16,21 @@
 
 package dagger.internal.codegen;
 
-import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.auto.common.MoreTypes.asDeclared;
 import static com.google.auto.common.MoreTypes.asExecutable;
 import static com.google.auto.common.MoreTypes.asTypeElements;
-import static com.google.auto.common.MoreTypes.isType;
-import static com.google.auto.common.MoreTypes.isTypeOf;
-import static com.google.common.base.Verify.verify;
 import static com.google.common.collect.Iterables.getOnlyElement;
-import static dagger.internal.codegen.BindingType.PROVISION;
 import static dagger.internal.codegen.ComponentRequirement.Kind.BOUND_INSTANCE;
 import static dagger.internal.codegen.ComponentRequirement.Kind.MODULE;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentAnnotation;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
 import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
-import static dagger.internal.codegen.DaggerElements.isAnnotationPresent;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 import static dagger.internal.codegen.DiagnosticFormatting.stripCommonTypePrefixes;
 import static dagger.internal.codegen.ErrorMessages.CONTAINS_DEPENDENCY_CYCLE_FORMAT;
 import static dagger.internal.codegen.ErrorMessages.DEPENDS_ON_PRODUCTION_EXECUTOR_FORMAT;
-import static dagger.internal.codegen.ErrorMessages.DUPLICATE_BINDINGS_FOR_KEY_FORMAT;
-import static dagger.internal.codegen.ErrorMessages.DUPLICATE_SIZE_LIMIT;
-import static dagger.internal.codegen.ErrorMessages.INDENT;
-import static dagger.internal.codegen.ErrorMessages.MULTIPLE_CONTRIBUTION_TYPES_FOR_KEY_FORMAT;
 import static dagger.internal.codegen.ErrorMessages.abstractModuleHasInstanceBindingMethods;
-import static dagger.internal.codegen.ErrorMessages.referenceReleasingScopeMetadataMissingCanReleaseReferences;
-import static dagger.internal.codegen.ErrorMessages.referenceReleasingScopeNotAnnotatedWithMetadata;
-import static dagger.internal.codegen.ErrorMessages.referenceReleasingScopeNotInComponentHierarchy;
-import static dagger.internal.codegen.Keys.isValidImplicitProvisionKey;
-import static dagger.internal.codegen.Keys.isValidMembersInjectionKey;
-import static dagger.internal.codegen.MoreAnnotationMirrors.getTypeValue;
-import static dagger.internal.codegen.RequestKinds.entryPointCanUseProduction;
+import static dagger.internal.codegen.Formatter.INDENT;
 import static dagger.internal.codegen.RequestKinds.extractKeyType;
 import static dagger.internal.codegen.RequestKinds.getRequestKind;
 import static dagger.internal.codegen.Scopes.getReadableSource;
@@ -54,7 +38,6 @@
 import static dagger.internal.codegen.Scopes.singletonScope;
 import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
 import static dagger.internal.codegen.Util.reentrantComputeIfAbsent;
-import static java.util.function.Predicate.isEqual;
 import static java.util.stream.Collectors.groupingBy;
 import static java.util.stream.Collectors.joining;
 import static java.util.stream.Collectors.mapping;
@@ -65,12 +48,8 @@
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.Equivalence;
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.ImmutableSetMultimap;
-import com.google.common.collect.ImmutableSortedMap;
 import com.google.common.collect.LinkedHashMultimap;
-import com.google.common.collect.Multimaps;
 import com.google.common.collect.SetMultimap;
 import com.google.common.collect.Sets;
 import dagger.BindsOptionalOf;
@@ -80,25 +59,17 @@
 import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.internal.codegen.ComponentRequirement.NullPolicy;
-import dagger.internal.codegen.ContributionType.HasContributionType;
 import dagger.internal.codegen.ErrorMessages.ComponentBuilderMessages;
-import dagger.model.BindingKind;
 import dagger.model.DependencyRequest;
 import dagger.model.Key;
 import dagger.model.RequestKind;
 import dagger.model.Scope;
-import dagger.releasablereferences.CanReleaseReferences;
-import dagger.releasablereferences.ForReleasableReferences;
-import dagger.releasablereferences.ReleasableReferenceManager;
-import dagger.releasablereferences.TypedReleasableReferenceManager;
 import java.util.ArrayDeque;
 import java.util.Deque;
-import java.util.Formatter;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Optional;
-import java.util.Queue;
 import java.util.Set;
 import java.util.concurrent.atomic.AtomicBoolean;
 import javax.inject.Inject;
@@ -109,7 +80,6 @@
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ExecutableType;
-import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 
@@ -119,8 +89,6 @@
   private final Elements elements;
   private final DaggerTypes types;
   private final CompilerOptions compilerOptions;
-  private final InjectBindingRegistry injectBindingRegistry;
-  private final BindingDeclarationFormatter bindingDeclarationFormatter;
   private final MethodSignatureFormatter methodSignatureFormatter;
   private final DependencyRequestFormatter dependencyRequestFormatter;
   private final KeyFactory keyFactory;
@@ -130,16 +98,12 @@
       Elements elements,
       DaggerTypes types,
       CompilerOptions compilerOptions,
-      InjectBindingRegistry injectBindingRegistry,
-      BindingDeclarationFormatter bindingDeclarationFormatter,
       MethodSignatureFormatter methodSignatureFormatter,
       DependencyRequestFormatter dependencyRequestFormatter,
       KeyFactory keyFactory) {
     this.elements = elements;
     this.types = types;
     this.compilerOptions = compilerOptions;
-    this.injectBindingRegistry = injectBindingRegistry;
-    this.bindingDeclarationFormatter = bindingDeclarationFormatter;
     this.methodSignatureFormatter = methodSignatureFormatter;
     this.dependencyRequestFormatter = dependencyRequestFormatter;
     this.keyFactory = keyFactory;
@@ -526,7 +490,7 @@ private void checkScopedBindings(BindingGraph graph) {
       }
       for (ContributionBinding binding :
           incompatiblyScopedBindings.get(graph.componentDescriptor())) {
-        message.append(ErrorMessages.INDENT);
+        message.append(INDENT);
 
         switch (binding.kind()) {
           case DELEGATE:
@@ -587,16 +551,6 @@ protected void visitDependencyRequest(DependencyRequest dependencyRequest) {
         }
       }
 
-      @Override
-      protected void visitResolvedBindings(ResolvedBindings resolvedBindings) {
-        if (resolvedBindings.isEmpty()) {
-          reportMissingBinding();
-        } else if (resolvedBindings.bindings().size() > 1) {
-          reportDuplicateBindings();
-        }
-        super.visitResolvedBindings(resolvedBindings);
-      }
-
       @Override
       protected void visitContributionBinding(
           ContributionBinding binding, ComponentDescriptor owningComponent) {
@@ -619,234 +573,12 @@ protected void visitContributionBinding(
         super.visitContributionBinding(binding, owningComponent);
       }
 
-      /**
-       * Returns the binding declarations that can be reported for {@code resolvedBindings}, indexed
-       * by the component that owns each declaration.
-       *
-       * <p>Contains all {@link MultibindingDeclaration}s, {@link SubcomponentDeclaration}s, and
-       * {@link OptionalBindingDeclaration}s within {@code resolvedBindings}, as well as all {@link
-       * ContributionBinding}s with present {@linkplain BindingDeclaration#bindingElement() binding
-       * elements}.
-       *
-       * <p>Includes {@link BindingKind#RELEASABLE_REFERENCE_MANAGER} or
-       * {@link BindingKind#RELEASABLE_REFERENCE_MANAGERS} bindings, even
-       * though they have no binding elements, because they will be reported via the declared
-       * scopes.
-       *
-       * <p>For other bindings without binding elements, such as the {@link
-       * ContributionBinding#isSyntheticMultibinding()}, includes the conflicting declarations in
-       * their resolved dependencies.
-       */
-      private ImmutableSetMultimap<ComponentDescriptor, BindingDeclaration>
-          reportableDeclarations() {
-        ImmutableSetMultimap.Builder<ComponentDescriptor, BindingDeclaration> declarations =
-            ImmutableSetMultimap.builder();
-
-        Queue<ResolvedBindings> queue = new ArrayDeque<>();
-        queue.add(resolvedBindings());
-
-        while (!queue.isEmpty()) {
-          ResolvedBindings queued = queue.remove();
-          declarations
-              .putAll(queued.owningComponent(), queued.multibindingDeclarations())
-              .putAll(queued.owningComponent(), queued.subcomponentDeclarations())
-              .putAll(queued.owningComponent(), queued.optionalBindingDeclarations());
-          queued
-              .allContributionBindings()
-              .asMap()
-              .forEach(
-                  (owningComponent, bindings) -> {
-                    BindingGraph owningGraph =
-                        componentTreePath().graphForComponent(owningComponent);
-                    for (ContributionBinding binding : bindings) {
-                      if (bindingDeclarationFormatter.canFormat(binding)) {
-                        declarations.put(owningComponent, binding);
-                      } else {
-                        queue.addAll(owningGraph.resolvedDependencies(binding));
-                      }
-                    }
-                  });
-        }
-
-        return declarations.build();
-      }
-
-      /**
-       * Descriptive portion of the error message for when the given request has no binding.
-       * Currently, the only other portions of the message are the dependency path, line number and
-       * filename.
-       */
-      private StringBuilder requiresErrorMessageBase() {
-        Key key = dependencyRequest().key();
-        StringBuilder errorMessage = new StringBuilder();
-        // TODO(dpb): Check for wildcard injection somewhere else first?
-        if (key.type().getKind().equals(TypeKind.WILDCARD)) {
-          errorMessage
-              .append("Dagger does not support injecting Provider<T>, Lazy<T> or Produced<T> when ")
-              .append("T is a wildcard type such as ")
-              .append(formatCurrentDependencyRequestKey());
-        } else {
-          // TODO(ronshapiro): replace "provided" with "satisfied"?
-          errorMessage
-              .append(formatCurrentDependencyRequestKey())
-              .append(" cannot be provided without ");
-          if (isValidImplicitProvisionKey(key, types)) {
-            errorMessage.append("an @Inject constructor or ");
-          }
-          errorMessage.append("an @Provides-");
-          if (dependencyRequestCanUseProduction()) {
-            errorMessage.append(" or @Produces-");
-          }
-          errorMessage.append("annotated method.");
-        }
-        if (isValidMembersInjectionKey(key)
-            && injectBindingRegistry.getOrFindMembersInjectionBinding(key)
-                .map(binding -> !binding.injectionSites().isEmpty())
-                .orElse(false)) {
-          errorMessage.append(" ").append(ErrorMessages.MEMBERS_INJECTION_DOES_NOT_IMPLY_PROVISION);
-        }
-        return errorMessage.append('\n');
-      }
-
-      private void reportMissingBinding() {
-        if (reportMissingReleasableReferenceManager()) {
-          return;
-        }
-        StringBuilder errorMessage = requiresErrorMessageBase().append(formatDependencyTrace());
-        for (String suggestion :
-            MissingBindingSuggestions.forKey(rootGraph, dependencyRequest().key())) {
-          errorMessage.append('\n').append(suggestion);
-        }
-        reportErrorAtEntryPoint(rootGraph, errorMessage.toString());
-      }
-
-      /**
-       * If the current dependency request is missing a binding because it's an invalid
-       * {@code @ForReleasableReferences} request, reports that.
-       *
-       * <p>An invalid request is one whose type is either {@link ReleasableReferenceManager} or
-       * {@link TypedReleasableReferenceManager}, and whose scope:
-       *
-       * <ul>
-       *   <li>does not annotate any component in the hierarchy, or
-       *   <li>is not annotated with the metadata annotation type that is the {@link
-       *       TypedReleasableReferenceManager}'s type argument
-       * </ul>
-       *
-       * @return {@code true} if the request was invalid and an error was reported
-       */
-      private boolean reportMissingReleasableReferenceManager() {
-        Key key = dependencyRequest().key();
-        if (!key.qualifier().isPresent()
-            || !isTypeOf(ForReleasableReferences.class, key.qualifier().get().getAnnotationType())
-            || !isType(key.type())) {
-          return false;
-        }
-
-        Optional<DeclaredType> metadataType;
-        if (isTypeOf(ReleasableReferenceManager.class, key.type())) {
-          metadataType = Optional.empty();
-        } else if (isTypeOf(TypedReleasableReferenceManager.class, key.type())) {
-          List<? extends TypeMirror> typeArguments =
-              MoreTypes.asDeclared(key.type()).getTypeArguments();
-          if (typeArguments.size() != 1
-              || !typeArguments.get(0).getKind().equals(TypeKind.DECLARED)) {
-            return false;
-          }
-          metadataType = Optional.of(MoreTypes.asDeclared(typeArguments.get(0)));
-        } else {
-          return false;
-        }
-
-        Scope scope =
-            Scopes.scope(MoreTypes.asTypeElement(getTypeValue(key.qualifier().get(), "value")));
-        String missingRequestKey = formatCurrentDependencyRequestKey();
-        if (!rootGraph.componentDescriptor().releasableReferencesScopes().contains(scope)) {
-          reportErrorAtEntryPoint(
-              rootGraph,
-              referenceReleasingScopeNotInComponentHierarchy(missingRequestKey, scope, rootGraph));
-          return true;
-        }
-        if (metadataType.isPresent()) {
-          if (!isAnnotationPresent(scope.scopeAnnotationElement(), metadataType.get())) {
-            reportErrorAtEntryPoint(
-                rootGraph,
-                referenceReleasingScopeNotAnnotatedWithMetadata(
-                    missingRequestKey, scope, metadataType.get()));
-          }
-          if (!isAnnotationPresent(metadataType.get().asElement(), CanReleaseReferences.class)) {
-            reportErrorAtEntryPoint(
-                rootGraph,
-                referenceReleasingScopeMetadataMissingCanReleaseReferences(
-                    missingRequestKey, metadataType.get()));
-          }
-        }
-        return false;
-      }
-
       @SuppressWarnings("resource") // Appendable is a StringBuilder.
       private void reportDependsOnProductionExecutor() {
         reportErrorAtEntryPoint(
             DEPENDS_ON_PRODUCTION_EXECUTOR_FORMAT, formatCurrentDependencyRequestKey());
       }
 
-      @SuppressWarnings("resource") // Appendable is a StringBuilder.
-      private void reportDuplicateBindings() {
-        // If any of the duplicate bindings results from multibinding contributions or declarations,
-        // report the conflict using those contributions and declarations.
-        if (resolvedBindings()
-            .contributionBindings()
-            .stream()
-            // TODO(dpb): Kill with fire.
-            .anyMatch(ContributionBinding::isSyntheticMultibinding)) {
-          reportMultipleContributionTypes();
-          return;
-        }
-        StringBuilder builder = new StringBuilder();
-        new Formatter(builder)
-            .format(DUPLICATE_BINDINGS_FOR_KEY_FORMAT, formatCurrentDependencyRequestKey());
-        ImmutableSetMultimap<ComponentDescriptor, BindingDeclaration> duplicateDeclarations =
-            reportableDeclarations();
-        bindingDeclarationFormatter.formatIndentedList(
-            builder, duplicateDeclarations.values(), 1, DUPLICATE_SIZE_LIMIT);
-        reportErrorAtEntryPoint(
-            componentTreePath().rootmostGraph(duplicateDeclarations.keySet()), builder.toString());
-      }
-
-      @SuppressWarnings("resource") // Appendable is a StringBuilder.
-      private void reportMultipleContributionTypes() {
-        StringBuilder builder = new StringBuilder();
-        new Formatter(builder)
-            .format(
-                MULTIPLE_CONTRIBUTION_TYPES_FOR_KEY_FORMAT, formatCurrentDependencyRequestKey());
-        ImmutableSetMultimap<ComponentDescriptor, BindingDeclaration> duplicateDeclarations =
-            reportableDeclarations();
-        ImmutableListMultimap<ContributionType, BindingDeclaration> duplicateDeclarationsByType =
-            Multimaps.index(
-                duplicateDeclarations.values(),
-                declaration ->
-                    declaration instanceof HasContributionType
-                        ? ((HasContributionType) declaration).contributionType()
-                        : ContributionType.UNIQUE);
-        verify(
-            duplicateDeclarationsByType.keySet().size() > 1,
-            "expected multiple contribution types for %s: %s",
-            dependencyRequest().key(),
-            duplicateDeclarationsByType);
-        ImmutableSortedMap.copyOf(Multimaps.asMap(duplicateDeclarationsByType))
-            .forEach(
-                (contributionType, declarations) -> {
-                  builder.append(INDENT);
-                  builder.append(formatContributionType(contributionType));
-                  builder.append(" bindings and declarations:");
-                  bindingDeclarationFormatter.formatIndentedList(
-                      builder, declarations, 2, DUPLICATE_SIZE_LIMIT);
-                  builder.append('\n');
-                });
-        reportErrorAtEntryPoint(
-            componentTreePath().rootmostGraph(duplicateDeclarations.keySet()), builder.toString());
-      }
-
       // TODO(cgruber): Provide a hint for the start and end of the cycle.
       private void reportDependencyCycle() {
         if (!providersBreakingCycle().isEmpty()) {
@@ -920,24 +652,6 @@ private boolean breaksCycle(TypeMirror requestedType, RequestKind requestKind) {
         }
       }
 
-      /**
-       * Returns true if the current dependency request can be satisfied by a production binding.
-       */
-      private boolean dependencyRequestCanUseProduction() {
-        if (atEntryPoint()) {
-          return entryPointCanUseProduction(dependencyRequest().kind());
-        } else {
-          // The current request can be satisfied by a production binding if it's not from a
-          // provision binding
-          return !hasDependentProvisionBindings();
-        }
-      }
-
-      /** Returns {@code true} if any provision bindings contain the latest request in the path. */
-      private boolean hasDependentProvisionBindings() {
-        return dependentBindings().stream().map(Binding::bindingType).anyMatch(isEqual(PROVISION));
-      }
-
       private String formatCurrentDependencyRequestKey() {
         return dependencyRequest().key().toString();
       }
@@ -971,17 +685,4 @@ private void appendIndentedComponentsList(StringBuilder message, Iterable<TypeEl
   private ImmutableSet<TypeElement> scopedTypesIn(Set<TypeElement> types) {
     return types.stream().filter(type -> !scopesOf(type).isEmpty()).collect(toImmutableSet());
   }
-
-  private String formatContributionType(ContributionType type) {
-    switch (type) {
-      case MAP:
-        return "Map";
-      case SET:
-      case SET_VALUES:
-        return "Set";
-      case UNIQUE:
-        return "Unique";
-    }
-    throw new AssertionError(type);
-  }
 }
diff --git a/java/dagger/internal/codegen/BindingNodeImpl.java b/java/dagger/internal/codegen/BindingNodeImpl.java
new file mode 100644
index 000000000..3c2b32859
--- /dev/null
+++ b/java/dagger/internal/codegen/BindingNodeImpl.java
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+
+import com.google.auto.value.AutoValue;
+import com.google.common.collect.ImmutableSet;
+import dagger.BindsOptionalOf;
+import dagger.Module;
+import dagger.model.BindingGraph.BindingNode;
+import dagger.model.ComponentPath;
+import dagger.multibindings.Multibinds;
+import java.util.function.Supplier;
+import javax.lang.model.element.Element;
+
+/**
+ * An implementation of {@link BindingNode} that also exposes {@link BindingDeclaration}s associated
+ * with the binding.
+ */
+@AutoValue
+abstract class BindingNodeImpl implements BindingNode {
+  static BindingNode create(
+      ComponentPath component,
+      dagger.model.Binding binding,
+      Iterable<BindingDeclaration> associatedDeclarations,
+      Supplier<String> toStringFunction) {
+    BindingNodeImpl node =
+        new AutoValue_BindingNodeImpl(
+            component, binding, ImmutableSet.copyOf(associatedDeclarations));
+    node.toStringFunction = checkNotNull(toStringFunction);
+    return node;
+  }
+
+  private Supplier<String> toStringFunction;
+
+  /**
+   * The {@link Element}s (other than the binding's {@link dagger.model.Binding#bindingElement()})
+   * that are associated with the binding.
+   *
+   * <ul>
+   *   <li>{@linkplain BindsOptionalOf optional binding} declarations
+   *   <li>{@linkplain Module#subcomponents() module subcomponent} declarations
+   *   <li>{@linkplain Multibinds multibinding} declarations
+   * </ul>
+   */
+  abstract ImmutableSet<BindingDeclaration> associatedDeclarations();
+
+  @Override
+  public final String toString() {
+    return toStringFunction.get();
+  }
+}
diff --git a/java/dagger/internal/codegen/ComponentBindingExpressions.java b/java/dagger/internal/codegen/ComponentBindingExpressions.java
index 57a23ede9..7ac1d1804 100644
--- a/java/dagger/internal/codegen/ComponentBindingExpressions.java
+++ b/java/dagger/internal/codegen/ComponentBindingExpressions.java
@@ -18,14 +18,12 @@
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
-import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.Accessibility.isRawTypeAccessible;
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
 import static dagger.internal.codegen.BindingType.MEMBERS_INJECTION;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.DelegateBindingExpression.isBindsScopeStrongerThanDependencyScope;
 import static dagger.internal.codegen.MemberSelect.staticFactoryCreation;
-import static dagger.internal.codegen.SourceFiles.membersInjectorNameForType;
 import static dagger.internal.codegen.TypeNames.DOUBLE_CHECK;
 import static dagger.internal.codegen.TypeNames.REFERENCE_RELEASING_PROVIDER;
 import static dagger.internal.codegen.TypeNames.SINGLE_CHECK;
@@ -40,7 +38,6 @@
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.MethodSpec;
-import dagger.internal.MembersInjectors;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.internal.codegen.FrameworkFieldInitializer.FrameworkInstanceCreationExpression;
 import dagger.model.DependencyRequest;
@@ -391,34 +388,11 @@ private FrameworkInstanceCreationExpression frameworkInstanceCreationExpression(
             binding, generatedComponentModel, this);
 
       case OPTIONAL:
-        if (binding.explicitDependencies().isEmpty()) {
-          return () -> optionalFactories.absentOptionalProvider(binding);
-        } else {
-          return () ->
-              optionalFactories.presentOptionalFactory(
-                  binding,
-                  getDependencyExpression(
-                          getOnlyElement(binding.frameworkDependencies()),
-                          generatedComponentModel.name())
-                      .codeBlock());
-        }
+        return new OptionalFactoryInstanceCreationExpression(
+            optionalFactories, binding, generatedComponentModel, this);
 
       case MEMBERS_INJECTOR:
-        TypeMirror membersInjectedType =
-            getOnlyElement(MoreTypes.asDeclared(binding.key().type()).getTypeArguments());
-
-        if (((ProvisionBinding) binding).injectionSites().isEmpty()) {
-          return new InstanceFactoryCreationExpression(
-              // The type parameter can be removed when we drop Java 7 source support.
-              () -> CodeBlock.of("$T.<$T>noOp()", MembersInjectors.class, membersInjectedType));
-        } else {
-          return new InstanceFactoryCreationExpression(
-              () ->
-                  CodeBlock.of(
-                      "$T.create($L)",
-                      membersInjectorNameForType(MoreTypes.asTypeElement(membersInjectedType)),
-                      getCreateMethodArgumentsCodeBlock(binding)));
-        }
+        return new MembersInjectorProviderCreationExpression((ProvisionBinding) binding, this);
 
       default:
         throw new AssertionError(binding);
@@ -621,30 +595,28 @@ private boolean canUseDirectInstanceExpression(ResolvedBindings resolvedBindings
   /**
    * Returns a binding expression for {@link RequestKind#PROVIDER} requests.
    *
-   * <p>In default mode, {@code @Binds} bindings that don't {@linkplain
-   * #needsCaching(ResolvedBindings) need to be cached} can use a {@link DelegateBindingExpression}.
+   * <p>{@code @Binds} bindings that don't {@linkplain #needsCaching(ResolvedBindings) need to be
+   * cached} can use a {@link DelegateBindingExpression}.
    *
-   * <p>In Android mode, if {@linkplain #instanceBindingExpression(ResolvedBindings) instance
-   * binding expressions} don't call {@code Provider.get()} on the provider binding expression, and
-   * there's no simple factory, then return a {@link SwitchingProviders} binding expression wrapped
-   * in a method.
+   * <p>In Android mode, use an {@link InnerSwitchingProviders inner switching provider} unless that
+   * provider's case statement will simply call {@code get()} on another {@link Provider} (in which
+   * case, just use that Provider directly).
    *
    * <p>Otherwise, return a {@link FrameworkInstanceBindingExpression}.
    */
   private BindingExpression providerBindingExpression(ResolvedBindings resolvedBindings) {
-    if (compilerOptions.experimentalAndroidMode()) {
-      if (!frameworkInstanceCreationExpression(resolvedBindings).isSimpleFactory()
-          && !(instanceBindingExpression(resolvedBindings)
-              instanceof DerivedFromProviderBindingExpression)) {
-        return wrapInMethod(
-            resolvedBindings,
-            RequestKind.PROVIDER,
-            innerSwitchingProviders.newBindingExpression(resolvedBindings.contributionBinding()));
-      }
-    } else if (resolvedBindings.contributionBinding().kind().equals(DELEGATE)
+    if (resolvedBindings.contributionBinding().kind().equals(DELEGATE)
         && !needsCaching(resolvedBindings)) {
       return new DelegateBindingExpression(
           resolvedBindings, RequestKind.PROVIDER, this, types, elements);
+    } else if (compilerOptions.experimentalAndroidMode()
+        && frameworkInstanceCreationExpression(resolvedBindings).useInnerSwitchingProvider()
+        && !(instanceBindingExpression(resolvedBindings)
+            instanceof DerivedFromProviderBindingExpression)) {
+      return wrapInMethod(
+          resolvedBindings,
+          RequestKind.PROVIDER,
+          innerSwitchingProviders.newBindingExpression(resolvedBindings.contributionBinding()));
     }
     return frameworkInstanceBindingExpression(resolvedBindings, RequestKind.PROVIDER);
   }
diff --git a/java/dagger/internal/codegen/ComponentTreeTraverser.java b/java/dagger/internal/codegen/ComponentTreeTraverser.java
index 5a19a67be..778c651e9 100644
--- a/java/dagger/internal/codegen/ComponentTreeTraverser.java
+++ b/java/dagger/internal/codegen/ComponentTreeTraverser.java
@@ -616,19 +616,16 @@ public BindingGraph graphForComponent(ComponentDescriptor component) {
      * Returns the subpath from the root component to the matching {@code ancestor} of the current
      * component.
      */
-    ComponentTreePath pathFromRootToAncestor(ComponentDescriptor ancestor) {
-      checkNotNull(ancestor);
+    ComponentTreePath pathFromRootToAncestor(TypeElement ancestor) {
       ImmutableList.Builder<BindingGraph> path = ImmutableList.builder();
       for (BindingGraph graph : graphsInPath()) {
         path.add(graph);
-        if (graph.componentDescriptor().equals(ancestor)) {
+        if (graph.componentDescriptor().componentDefinitionType().equals(ancestor)) {
           return create(path.build());
         }
       }
       throw new IllegalArgumentException(
-          String.format(
-              "%s is not in the current path: %s",
-              ancestor.componentDefinitionType().getQualifiedName(), this));
+          String.format("%s is not in the current path: %s", ancestor.getQualifiedName(), this));
     }
 
     /**
diff --git a/java/dagger/internal/codegen/DaggerElements.java b/java/dagger/internal/codegen/DaggerElements.java
index 6aacc5437..314c26db7 100644
--- a/java/dagger/internal/codegen/DaggerElements.java
+++ b/java/dagger/internal/codegen/DaggerElements.java
@@ -16,11 +16,14 @@
 
 package dagger.internal.codegen;
 
+import static com.google.auto.common.MoreElements.asExecutable;
 import static com.google.auto.common.MoreElements.getLocalAndInheritedMethods;
 import static com.google.auto.common.MoreElements.hasModifiers;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.Lists.asList;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
+import static dagger.internal.codegen.Formatter.formatArgumentInList;
+import static java.util.stream.Collectors.joining;
 import static java.util.stream.Collectors.toSet;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 
@@ -47,7 +50,9 @@
 import javax.lang.model.element.Name;
 import javax.lang.model.element.PackageElement;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.ElementKindVisitor8;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.SimpleElementVisitor8;
 import javax.lang.model.util.Types;
@@ -85,6 +90,69 @@ public TypeElement getTypeElement(CharSequence name) {
     return elements.getTypeElement(name);
   }
 
+  /**
+   * Returns a useful string form for an element.
+   *
+   * <p>Elements directly enclosed by a type are preceded by the enclosing type's qualified name.
+   *
+   * <p>Parameters are given with their enclosing executable, with other parameters elided.
+   */
+  static String elementToString(Element element) {
+    return element.accept(ELEMENT_TO_STRING, null);
+  }
+
+  private static final ElementVisitor<String, Void> ELEMENT_TO_STRING =
+      new ElementKindVisitor8<String, Void>() {
+        @Override
+        public String visitExecutable(ExecutableElement executableElement, Void aVoid) {
+          return enclosingTypeAndMemberName(executableElement)
+              .append(
+                  executableElement
+                      .getParameters()
+                      .stream()
+                      .map(parameter -> parameter.asType().toString())
+                      .collect(joining(", ", "(", ")")))
+              .toString();
+        }
+
+        @Override
+        public String visitVariableAsParameter(VariableElement parameter, Void aVoid) {
+          ExecutableElement methodOrConstructor = asExecutable(parameter.getEnclosingElement());
+          return enclosingTypeAndMemberName(methodOrConstructor)
+              .append('(')
+              .append(
+                  formatArgumentInList(
+                      methodOrConstructor.getParameters().indexOf(parameter),
+                      methodOrConstructor.getParameters().size(),
+                      parameter.getSimpleName()))
+              .append(')')
+              .toString();
+        }
+
+        @Override
+        public String visitVariableAsField(VariableElement field, Void aVoid) {
+          return enclosingTypeAndMemberName(field).toString();
+        }
+
+        @Override
+        public String visitType(TypeElement type, Void aVoid) {
+          return type.getQualifiedName().toString();
+        }
+
+        @Override
+        protected String defaultAction(Element element, Void aVoid) {
+          throw new UnsupportedOperationException(
+              "Can't determine string for " + element.getKind() + " element " + element);
+        }
+
+        private StringBuilder enclosingTypeAndMemberName(Element element) {
+          return new StringBuilder()
+              .append(element.getEnclosingElement().accept(this, null))
+              .append('.')
+              .append(element.getSimpleName());
+        }
+      };
+
   /** Returns the argument or the closest enclosing element that is a {@link TypeElement}. */
   static TypeElement closestEnclosingTypeElement(Element element) {
     return element.accept(CLOSEST_ENCLOSING_TYPE_ELEMENT, null);
diff --git a/java/dagger/internal/codegen/DaggerStreams.java b/java/dagger/internal/codegen/DaggerStreams.java
index 97072e3b6..83a4e30d1 100644
--- a/java/dagger/internal/codegen/DaggerStreams.java
+++ b/java/dagger/internal/codegen/DaggerStreams.java
@@ -22,6 +22,7 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Maps;
 import java.util.Map;
 import java.util.function.Function;
@@ -36,6 +37,7 @@
    * Returns a {@link Collector} that accumulates the input elements into a new {@link
    * ImmutableList}, in encounter order.
    */
+  // TODO(b/68008628): Use ImmutableList.toImmutableList().
   public static <T> Collector<T, ?, ImmutableList<T>> toImmutableList() {
     return collectingAndThen(toList(), ImmutableList::copyOf);
   }
@@ -44,6 +46,7 @@
    * Returns a {@link Collector} that accumulates the input elements into a new {@link
    * ImmutableSet}, in encounter order.
    */
+  // TODO(b/68008628): Use ImmutableSet.toImmutableSet().
   public static <T> Collector<T, ?, ImmutableSet<T>> toImmutableSet() {
     return collectingAndThen(toList(), ImmutableSet::copyOf);
   }
@@ -53,6 +56,7 @@
    * and values are the result of applying the provided mapping functions to the input elements.
    * Entries appear in the result {@code ImmutableMap} in encounter order.
    */
+  // TODO(b/68008628): Use ImmutableMap.toImmutableMap().
   public static <T, K, V> Collector<T, ?, ImmutableMap<K, V>> toImmutableMap(
       Function<? super T, K> keyMapper, Function<? super T, V> valueMapper) {
     return Collectors.mapping(
@@ -64,6 +68,24 @@
             ImmutableMap.Builder::build));
   }
 
+  /**
+   * Returns a {@link Collector} that accumulates elements into an {@code ImmutableSetMultimap}
+   * whose keys and values are the result of applying the provided mapping functions to the input
+   * elements. Entries appear in the result {@code ImmutableSetMultimap} in encounter order.
+   */
+  // TODO(b/68008628): Use ImmutableSetMultimap.toImmutableSetMultimap().
+  public static <T, K, V> Collector<T, ?, ImmutableSetMultimap<K, V>> toImmutableSetMultimap(
+      Function<? super T, ? extends K> keyMapper, Function<? super T, ? extends V> valueMapper) {
+    return Collectors.mapping(
+        value -> Maps.immutableEntry(keyMapper.apply(value), valueMapper.apply(value)),
+        Collector.of(
+            ImmutableSetMultimap::builder,
+            (ImmutableSetMultimap.Builder<K, V> builder, Map.Entry<K, V> entry) ->
+                builder.put(entry),
+            (left, right) -> left.putAll(right.build()),
+            ImmutableSetMultimap.Builder::build));
+  }
+
   /**
    * Returns a function from {@link Object} to {@code Stream<T>}, which returns a stream containing
    * its input if its input is an instance of {@code T}.
diff --git a/java/dagger/internal/codegen/DependencyRequestFormatter.java b/java/dagger/internal/codegen/DependencyRequestFormatter.java
index 6443d7d2f..9fb3b885e 100644
--- a/java/dagger/internal/codegen/DependencyRequestFormatter.java
+++ b/java/dagger/internal/codegen/DependencyRequestFormatter.java
@@ -16,32 +16,27 @@
 
 package dagger.internal.codegen;
 
-import static com.google.auto.common.MoreElements.asExecutable;
+import static dagger.internal.codegen.DaggerElements.elementToString;
 import static dagger.internal.codegen.DaggerStreams.toImmutableList;
-import static dagger.internal.codegen.ErrorMessages.DOUBLE_INDENT;
-import static dagger.internal.codegen.ErrorMessages.INDENT;
 import static dagger.internal.codegen.RequestKinds.requestType;
 
-import com.google.auto.common.MoreElements;
 import com.google.common.base.Joiner;
 import com.google.common.collect.ImmutableSet;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import dagger.Provides;
 import dagger.internal.codegen.ComponentTreeTraverser.DependencyTrace;
 import dagger.model.DependencyRequest;
-import dagger.model.Key;
 import dagger.producers.Produces;
-import java.util.List;
 import java.util.Optional;
 import java.util.concurrent.atomic.AtomicReference;
 import javax.inject.Inject;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementVisitor;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.ElementKindVisitor7;
+import javax.lang.model.util.ElementKindVisitor8;
 
 /**
  * Formats a {@link DependencyRequest} into a {@link String} suitable for an error message listing
@@ -95,109 +90,53 @@ String format(DependencyTrace dependencyTrace) {
                 .reverse());
   }
 
-  // TODO(cgruber): Sweep this class for TypeMirror.toString() usage and do some preventive format.
-  // TODO(cgruber): consider returning a small structure containing strings to be indented later.
   @Override
   public String format(DependencyRequest request) {
-    if (!request.requestElement().isPresent()) {
-      return "";
-    }
     return request
         .requestElement()
-        .get()
-        .accept(
-            new ElementKindVisitor7<String, DependencyRequest>() {
-
-              /** Returns the description for component methods. */
-              @Override
-              public String visitExecutableAsMethod(
-                  ExecutableElement method, DependencyRequest request) {
-                StringBuilder builder = new StringBuilder();
-                builder
-                    .append(INDENT)
-                    .append(formatKey(request.key()))
-                    .append(" is ")
-                    .append(componentMethodRequestVerb(request))
-                    .append(" at\n")
-                    .append(DOUBLE_INDENT);
-                appendEnclosingTypeAndMemberName(method, builder);
-                builder.append('(');
-                for (VariableElement parameter : method.getParameters()) {
-                  builder.append(parameter.getSimpleName());
-                }
-                builder.append(')');
-                return builder.toString();
-              }
-
-              /**
-               * Returns the description for {@link javax.inject.Inject @Inject} constructor and
-               * method parameters and for {@link dagger.Provides @Provides} and {@link
-               * dagger.producers.Produces @Produces} method parameters.
-               */
-              @Override
-              public String visitVariableAsParameter(
-                  VariableElement variable, DependencyRequest request) {
-                StringBuilder builder = new StringBuilder();
-                appendRequestedTypeIsInjectedAt(builder, request);
-
-                ExecutableElement methodOrConstructor =
-                    asExecutable(variable.getEnclosingElement());
-                appendEnclosingTypeAndMemberName(methodOrConstructor, builder).append('(');
-                List<? extends VariableElement> parameters = methodOrConstructor.getParameters();
-                int parameterIndex = parameters.indexOf(variable);
-                builder.append(
-                    formatArgumentInList(
-                        parameterIndex, parameters.size(), variable.getSimpleName()));
-                builder.append(')');
-                return builder.toString();
-              }
-
-              /** Returns the description for {@link javax.inject.Inject @Inject} fields. */
-              @Override
-              public String visitVariableAsField(
-                  VariableElement variable, DependencyRequest request) {
-                StringBuilder builder = new StringBuilder();
-                appendRequestedTypeIsInjectedAt(builder, request);
-                appendEnclosingTypeAndMemberName(variable, builder);
-                return builder.toString();
-              }
-
-              @Override
-              public String visitType(TypeElement e, DependencyRequest request) {
-                return ""; // types by themselves provide no useful information.
-              }
-
-              @Override
-              protected String defaultAction(Element element, DependencyRequest request) {
-                throw new IllegalStateException(
-                    "Invalid request " + element.getKind() + " element " + element);
-              }
-            },
-            request);
+        .map(element -> element.accept(formatVisitor, request))
+        .orElse("");
   }
 
-  @CanIgnoreReturnValue
-  private StringBuilder appendRequestedTypeIsInjectedAt(
-      StringBuilder builder, DependencyRequest request) {
-    TypeMirror requestedType = requestType(request.kind(), request.key().type(), types);
-    return builder
-        .append(INDENT)
-        .append(formatKey(request.key().qualifier(), requestedType))
-        .append(" is injected at\n")
-        .append(DOUBLE_INDENT);
-  }
-
-  private String formatKey(Key key) {
-    return formatKey(key.qualifier(), key.type());
-  }
-
-  private String formatKey(Optional<AnnotationMirror> qualifier, TypeMirror type) {
-    StringBuilder builder = new StringBuilder();
-    if (qualifier.isPresent()) {
-      builder.append(qualifier.get()).append(' ');
-    }
-    builder.append(type);
-    return builder.toString();
+  private final ElementVisitor<String, DependencyRequest> formatVisitor =
+      new ElementKindVisitor8<String, DependencyRequest>() {
+
+        @Override
+        public String visitExecutableAsMethod(ExecutableElement method, DependencyRequest request) {
+          return INDENT
+              + request.key()
+              + " is "
+              + componentMethodRequestVerb(request)
+              + " at\n"
+              + DOUBLE_INDENT
+              + elementToString(method);
+        }
+
+        @Override
+        public String visitVariable(VariableElement variable, DependencyRequest request) {
+          TypeMirror requestedType = requestType(request.kind(), request.key().type(), types);
+          return INDENT
+              + formatQualifier(request.key().qualifier())
+              + requestedType
+              + " is injected at\n"
+              + DOUBLE_INDENT
+              + elementToString(variable);
+        }
+
+        @Override
+        public String visitType(TypeElement e, DependencyRequest request) {
+          return ""; // types by themselves provide no useful information.
+        }
+
+        @Override
+        protected String defaultAction(Element element, DependencyRequest request) {
+          throw new IllegalStateException(
+              "Invalid request " + element.getKind() + " element " + element);
+        }
+      };
+
+  private String formatQualifier(Optional<AnnotationMirror> maybeQualifier) {
+    return maybeQualifier.map(qualifier -> qualifier + " ").orElse("");
   }
 
   /**
@@ -225,15 +164,6 @@ private String componentMethodRequestVerb(DependencyRequest request) {
     }
   }
 
-  @CanIgnoreReturnValue
-  private StringBuilder appendEnclosingTypeAndMemberName(Element member, StringBuilder builder) {
-    TypeElement type = MoreElements.asType(member.getEnclosingElement());
-    return builder
-        .append(type.getQualifiedName())
-        .append('.')
-        .append(member.getSimpleName());
-  }
-
   /**
    * Returns a string of the form "{@code @BindsOptionalOf SomeKey is declared at Module.method()}",
    * where {@code Module.method()} is the declaration. If there is more than one such declaration,
@@ -247,12 +177,11 @@ private String formatSyntheticOptionalBindingDependency(
     builder
         .append(INDENT)
         .append("@BindsOptionalOf ")
-        .append(formatKey(optionalBindingDeclaration.key()))
+        .append(optionalBindingDeclaration.key())
         .append(" is declared at\n")
-        .append(DOUBLE_INDENT);
+        .append(DOUBLE_INDENT)
+        .append(elementToString(optionalBindingDeclaration.bindingElement().get()));
 
-    appendEnclosingTypeAndMemberName(optionalBindingDeclaration.bindingElement().get(), builder);
-    builder.append("()");
     if (optionalBindingDeclarations.size() > 1) {
       builder.append(", among others");
     }
diff --git a/java/dagger/internal/codegen/DiagnosticReporterFactory.java b/java/dagger/internal/codegen/DiagnosticReporterFactory.java
index e952bca98..ddb98e8fc 100644
--- a/java/dagger/internal/codegen/DiagnosticReporterFactory.java
+++ b/java/dagger/internal/codegen/DiagnosticReporterFactory.java
@@ -18,6 +18,7 @@
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.collect.Lists.asList;
+import static dagger.internal.codegen.DaggerElements.elementToString;
 import static dagger.internal.codegen.DaggerGraphs.shortestPath;
 
 import com.google.common.collect.ImmutableList;
@@ -87,7 +88,7 @@ DiagnosticReporterImpl reporter(BindingGraph graph, BindingGraphPlugin plugin) {
     @Override
     public void reportComponent(
         Diagnostic.Kind diagnosticKind, ComponentNode componentNode, String messageFormat) {
-      StringBuilder messageBuilder = messagePrefix(messageFormat);
+      StringBuilder messageBuilder = new StringBuilder(messageFormat);
       if (!componentNode.componentPath().currentComponent().equals(rootComponent)) {
         appendComponentPath(messageBuilder, componentNode);
       }
@@ -110,7 +111,8 @@ public void reportComponent(
     public void reportBinding(
         Diagnostic.Kind diagnosticKind, BindingNode bindingNode, String message) {
       // TODO(ronshapiro): should this also include the binding element?
-      reportAtEntryPointsWithDependencyTrace(diagnosticKind, messagePrefix(message), bindingNode);
+      reportAtEntryPointsWithDependencyTrace(
+          diagnosticKind, new StringBuilder(message), bindingNode);
     }
 
     @Override
@@ -127,7 +129,7 @@ public void reportBinding(
     public void reportDependency(
         Diagnostic.Kind diagnosticKind, DependencyEdge dependencyEdge, String message) {
       StringBuilder messageBuilder =
-          messagePrefix(message)
+          new StringBuilder(message)
               .append('\n')
               .append(dependencyRequestFormatter.format(dependencyEdge.dependencyRequest()));
 
@@ -202,24 +204,29 @@ private void printAtEntryPoint(
         Diagnostic.Kind diagnosticKind, CharSequence message, DependencyEdge entryPoint) {
       checkArgument(entryPoint.isEntryPoint());
       Element entryPointElement = entryPoint.dependencyRequest().requestElement().get();
-      Element elementToReport =
-          // TODO(ronshapiro): should we create a HashSet out of getEnclosedElements() so we don't
-          // need to do an O(n) contains() each time?
-          rootComponent.getEnclosedElements().contains(entryPointElement)
-              ? entryPointElement
-              : rootComponent;
 
+      StringBuilder messageBuilder = new StringBuilder(message);
       Node component = graph.incidentNodes(entryPoint).source();
       if (!component.equals(graph.rootComponentNode())) {
-        message = appendComponentPath(new StringBuilder(message), component);
+        appendComponentPath(messageBuilder, component);
+      }
+
+      // TODO(ronshapiro): should we create a HashSet out of getEnclosedElements() so we don't
+      // need to do an O(n) contains() each time?
+      if (rootComponent.getEnclosedElements().contains(entryPointElement)) {
+        printMessage(diagnosticKind, messageBuilder, entryPointElement);
+      } else {
+        printMessage(
+            diagnosticKind,
+            insertBracketPrefix(messageBuilder, elementToString(entryPointElement)),
+            rootComponent);
       }
-      printMessage(diagnosticKind, message, elementToReport);
     }
 
     private void printMessage(
-        Diagnostic.Kind diagnosticKind, CharSequence message, Element elementToReport) {
+        Diagnostic.Kind diagnosticKind, StringBuilder message, Element elementToReport) {
       reportedDiagnosticKinds.add(diagnosticKind);
-      messager.printMessage(diagnosticKind, message, elementToReport);
+      messager.printMessage(diagnosticKind, insertBracketPrefix(message, plugin), elementToReport);
     }
 
     @CanIgnoreReturnValue
@@ -227,8 +234,9 @@ private StringBuilder appendComponentPath(StringBuilder message, Node node) {
       return message.append("\ncomponent path: ").append(node.componentPath());
     }
 
-    private StringBuilder messagePrefix(String message) {
-      return new StringBuilder(String.format("[%s] ", plugin)).append(message);
+    @CanIgnoreReturnValue
+    private StringBuilder insertBracketPrefix(StringBuilder messageBuilder, String prefix) {
+      return messageBuilder.insert(0, String.format("[%s] ", prefix));
     }
   }
 }
diff --git a/java/dagger/internal/codegen/DuplicateBindingsValidation.java b/java/dagger/internal/codegen/DuplicateBindingsValidation.java
new file mode 100644
index 000000000..6074d38fe
--- /dev/null
+++ b/java/dagger/internal/codegen/DuplicateBindingsValidation.java
@@ -0,0 +1,230 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Verify.verify;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.DaggerStreams.instancesOf;
+import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
+import static dagger.internal.codegen.DaggerStreams.toImmutableSetMultimap;
+import static dagger.internal.codegen.DuplicateBindingsValidation.SourceAndRequest.indexEdgesBySourceAndRequest;
+import static dagger.internal.codegen.ErrorMessages.DUPLICATE_SIZE_LIMIT;
+import static dagger.internal.codegen.Formatter.INDENT;
+import static dagger.internal.codegen.Optionals.emptiesLast;
+import static java.util.Comparator.comparing;
+import static javax.tools.Diagnostic.Kind.ERROR;
+
+import com.google.auto.value.AutoValue;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ImmutableSetMultimap;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Multimaps;
+import com.google.common.collect.Sets;
+import dagger.model.BindingGraph;
+import dagger.model.BindingGraph.BindingNode;
+import dagger.model.BindingGraph.DependencyEdge;
+import dagger.model.BindingGraph.Node;
+import dagger.model.DependencyRequest;
+import dagger.spi.BindingGraphPlugin;
+import dagger.spi.DiagnosticReporter;
+import java.util.Comparator;
+import java.util.Set;
+import javax.inject.Inject;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
+
+/** Reports errors for conflicting bindings with the same key. */
+final class DuplicateBindingsValidation implements BindingGraphPlugin {
+
+  // 1. contributing module or enclosing type
+  // 2. binding element's simple name
+  // 3. binding element's type
+  private static final Comparator<BindingDeclaration> BINDING_DECLARATION_COMPARATOR =
+      comparing(
+              (BindingDeclaration declaration) ->
+                  declaration.contributingModule().isPresent()
+                      ? declaration.contributingModule()
+                      : declaration.bindingTypeElement(),
+              emptiesLast(comparing((TypeElement type) -> type.getQualifiedName().toString())))
+          .thenComparing(
+              (BindingDeclaration declaration) -> declaration.bindingElement(),
+              emptiesLast(
+                  comparing((Element element) -> element.getSimpleName().toString())
+                      .thenComparing((Element element) -> element.asType().toString())));
+
+  private final BindingDeclarationFormatter bindingDeclarationFormatter;
+
+  @Inject
+  DuplicateBindingsValidation(BindingDeclarationFormatter bindingDeclarationFormatter) {
+    this.bindingDeclarationFormatter = bindingDeclarationFormatter;
+  }
+
+  @Override
+  public String pluginName() {
+    return "Dagger/DuplicateBindings";
+  }
+
+  @Override
+  public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticReporter) {
+    Multimaps.asMap(indexEdgesBySourceAndRequest(bindingGraph))
+        .forEach(
+            (sourceAndRequest, dependencyEdges) -> {
+              if (dependencyEdges.size() > 1) {
+                reportDuplicateBindings(
+                    sourceAndRequest.request(), dependencyEdges, bindingGraph, diagnosticReporter);
+              }
+            });
+  }
+
+  private void reportDuplicateBindings(
+      DependencyRequest dependencyRequest,
+      Set<DependencyEdge> duplicateDependencies,
+      BindingGraph bindingGraph,
+      DiagnosticReporter diagnosticReporter) {
+    ImmutableSet<BindingNode> duplicateBindings =
+        duplicateDependencies
+            .stream()
+            .map(edge -> bindingGraph.incidentNodes(edge).target())
+            .flatMap(instancesOf(BindingNode.class))
+            .collect(toImmutableSet());
+    diagnosticReporter.reportDependency(
+        ERROR,
+        Iterables.get(duplicateDependencies, 0),
+        Iterables.any(duplicateBindings, node -> node.binding().kind().isMultibinding())
+            ? incompatibleBindingsMessage(dependencyRequest, duplicateBindings, bindingGraph)
+            : duplicateBindingMessage(dependencyRequest, duplicateBindings, bindingGraph));
+  }
+
+  private String duplicateBindingMessage(
+      DependencyRequest dependencyRequest,
+      ImmutableSet<BindingNode> duplicateBindings,
+      BindingGraph graph) {
+    StringBuilder message =
+        new StringBuilder().append(dependencyRequest.key()).append(" is bound multiple times:");
+    formatDeclarations(message, 1, declarations(graph, duplicateBindings));
+    return message.toString();
+  }
+
+  private String incompatibleBindingsMessage(
+      DependencyRequest dependencyRequest,
+      ImmutableSet<BindingNode> duplicateBindings,
+      BindingGraph graph) {
+    ImmutableSet<BindingNode> multibindings =
+        duplicateBindings
+            .stream()
+            .filter(node -> node.binding().kind().isMultibinding())
+            .collect(toImmutableSet());
+    verify(
+        multibindings.size() == 1,
+        "expected only one multibinding for %s: %s",
+        dependencyRequest,
+        multibindings);
+    StringBuilder message = new StringBuilder();
+    java.util.Formatter messageFormatter = new java.util.Formatter(message);
+    messageFormatter.format(
+        "%s has incompatible bindings or declarations:\n", dependencyRequest.key());
+    message.append(INDENT);
+    BindingNode multibinding = getOnlyElement(multibindings);
+    messageFormatter.format("%s bindings and declarations:", multibindingTypeString(multibinding));
+    formatDeclarations(message, 2, declarations(graph, multibindings));
+
+    Set<BindingNode> uniqueBindings =
+        Sets.filter(duplicateBindings, binding -> !binding.equals(multibinding));
+    message.append(INDENT).append("Unique bindings and declarations:");
+    formatDeclarations(
+        message,
+        2,
+        Sets.filter(
+            declarations(graph, uniqueBindings),
+            declaration -> !(declaration instanceof MultibindingDeclaration)));
+    return message.toString();
+  }
+
+  private void formatDeclarations(
+      StringBuilder builder,
+      int indentLevel,
+      Iterable<? extends BindingDeclaration> bindingDeclarations) {
+    bindingDeclarationFormatter.formatIndentedList(
+        builder, ImmutableList.copyOf(bindingDeclarations), indentLevel, DUPLICATE_SIZE_LIMIT);
+    builder.append('\n');
+  }
+
+  private ImmutableSet<BindingDeclaration> declarations(
+      BindingGraph graph, Set<BindingNode> bindings) {
+    return bindings
+        .stream()
+        .flatMap(node -> declarations(graph, node).stream())
+        .distinct()
+        .sorted(BINDING_DECLARATION_COMPARATOR)
+        .collect(toImmutableSet());
+  }
+
+  private ImmutableSet<BindingDeclaration> declarations(BindingGraph graph, BindingNode node) {
+    ImmutableSet.Builder<BindingDeclaration> declarations = ImmutableSet.builder();
+    ((BindingNodeImpl) node).associatedDeclarations().forEach(declarations::add);
+    if (node.binding() instanceof BindingDeclaration) {
+      BindingDeclaration declaration = ((BindingDeclaration) node.binding());
+      if (bindingDeclarationFormatter.canFormat(declaration)) {
+        declarations.add(declaration);
+      } else {
+        graph
+            .successors(node)
+            .stream()
+            .flatMap(instancesOf(BindingNode.class))
+            .flatMap(dependency -> declarations(graph, dependency).stream())
+            .forEach(declarations::add);
+      }
+    }
+    return declarations.build();
+  }
+
+  private String multibindingTypeString(BindingNode multibinding) {
+    switch (multibinding.binding().kind()) {
+      case MULTIBOUND_MAP:
+        return "Map";
+      case MULTIBOUND_SET:
+        return "Set";
+      default:
+        throw new AssertionError(multibinding);
+    }
+  }
+
+  @AutoValue
+  abstract static class SourceAndRequest {
+
+    abstract Node source();
+
+    abstract DependencyRequest request();
+
+    static ImmutableSetMultimap<SourceAndRequest, DependencyEdge> indexEdgesBySourceAndRequest(
+        BindingGraph bindingGraph) {
+      return bindingGraph
+          .dependencyEdges()
+          .stream()
+          .collect(
+              toImmutableSetMultimap(
+                  edge ->
+                      create(bindingGraph.incidentNodes(edge).source(), edge.dependencyRequest()),
+                  edge -> edge));
+    }
+
+    static SourceAndRequest create(Node source, DependencyRequest request) {
+      return new AutoValue_DuplicateBindingsValidation_SourceAndRequest(source, request);
+    }
+  }
+}
diff --git a/java/dagger/internal/codegen/ErrorMessages.java b/java/dagger/internal/codegen/ErrorMessages.java
index 9d408488a..742349cde 100644
--- a/java/dagger/internal/codegen/ErrorMessages.java
+++ b/java/dagger/internal/codegen/ErrorMessages.java
@@ -18,14 +18,11 @@
 
 import static dagger.internal.codegen.ConfigurationAnnotations.getSubcomponentAnnotation;
 import static dagger.internal.codegen.MoreAnnotationMirrors.simpleName;
-import static dagger.internal.codegen.Scopes.getReadableSource;
 import static java.util.stream.Collectors.joining;
-import static java.util.stream.Collectors.toList;
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.Joiner;
-import dagger.model.Scope;
 import dagger.multibindings.Multibinds;
 import dagger.releasablereferences.CanReleaseReferences;
 import dagger.releasablereferences.ForReleasableReferences;
@@ -35,18 +32,12 @@
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
 
 /**
  * The collection of error messages to be reported back to users.
  */
 final class ErrorMessages {
-  /*
-   * Common constants.
-   */
-  static final String INDENT = "    ";
-  static final String DOUBLE_INDENT = INDENT + INDENT;
   static final int DUPLICATE_SIZE_LIMIT = 10;
 
   /*
@@ -118,9 +109,6 @@
    * These are errors that relate specifically to the Dagger configuration API (@Module, @Provides,
    * etc.)
    */
-  static final String DUPLICATE_BINDINGS_FOR_KEY_FORMAT =
-      "%s is bound multiple times:";
-
   static final String COMPONENT_ANNOTATED_REUSABLE =
       "@Reusable cannot be applied to components or subcomponents.";
 
@@ -143,9 +131,6 @@
   static final String BINDING_METHOD_SET_VALUES_RAW_SET =
       "@%s methods of type set values cannot return a raw Set";
 
-  static final String BINDS_ELEMENTS_INTO_SET_METHOD_RAW_SET_PARAMETER =
-      "@Binds @ElementsIntoSet methods cannot take a raw Set parameter";
-
   static final String BINDING_METHOD_SET_VALUES_RETURN_SET =
       "@%s methods of type set values must return a Set";
 
@@ -227,9 +212,8 @@
   static final String BINDING_METHOD_MULTIPLE_QUALIFIERS =
       "Cannot use more than one @Qualifier";
 
-  /* mapKey errors*/
-  static final String MAPKEY_WITHOUT_MEMBERS =
-      "Map key annotations must have members";
+  /* mapKey errors */
+  static final String MAPKEY_WITHOUT_MEMBERS = "Map key annotations must have members";
 
   static final String UNWRAPPED_MAP_KEY_WITH_TOO_MANY_MEMBERS=
       "Map key annotations with unwrapped values must have exactly one member";
@@ -237,10 +221,7 @@
   static final String UNWRAPPED_MAP_KEY_WITH_ARRAY_MEMBER =
       "Map key annotations with unwrapped values cannot use arrays";
 
-  /* collection binding errors */
-  static final String MULTIPLE_CONTRIBUTION_TYPES_FOR_KEY_FORMAT =
-      "%s has incompatible bindings or declarations:\n";
-
+  /* producer errors */
   static final String DEPENDS_ON_PRODUCTION_EXECUTOR_FORMAT =
       "%s may not depend on the production executor.";
 
@@ -253,15 +234,6 @@ static String provisionMayNotDependOnProducerType(TypeMirror type) {
         MoreTypes.asTypeElement(type).getSimpleName());
   }
 
-  static final String MEMBERS_INJECTION_DOES_NOT_IMPLY_PROVISION =
-      "This type supports members injection but cannot be implicitly provided.";
-
-  static final String MEMBERS_INJECTION_WITH_RAW_TYPE =
-      "%s has type parameters, cannot members inject the raw type. via:\n%s";
-
-  static final String MEMBERS_INJECTION_WITH_UNBOUNDED_TYPE =
-      "Type parameters must be bounded for members injection. %s required by %s, via:\n%s";
-
   static final String CONTAINS_DEPENDENCY_CYCLE_FORMAT = "Found a dependency cycle:\n%s";
 
   static final String CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD =
@@ -331,36 +303,6 @@ private static String forReleasableReferencesValueNeedsAnnotation(
         ForReleasableReferences.class.getSimpleName(), scopeType.getQualifiedName(), annotations);
   }
 
-  static String referenceReleasingScopeNotInComponentHierarchy(
-      String formattedKey, Scope scope, BindingGraph topLevelGraph) {
-    return String.format(
-        "There is no binding for %s because no component in %s's component hierarchy is "
-            + "annotated with %s. The available reference-releasing scopes are %s.",
-        formattedKey,
-        topLevelGraph.componentType().getQualifiedName(),
-        getReadableSource(scope),
-        topLevelGraph
-            .componentDescriptor()
-            .releasableReferencesScopes()
-            .stream()
-            .map(Scopes::getReadableSource)
-            .collect(toList()));
-  }
-
-  static String referenceReleasingScopeMetadataMissingCanReleaseReferences(
-      String formattedKey, DeclaredType metadataType) {
-    return String.format(
-        "There is no binding for %s because %s is not annotated with @%s.",
-        formattedKey, metadataType, CanReleaseReferences.class.getCanonicalName());
-  }
-
-  static String referenceReleasingScopeNotAnnotatedWithMetadata(
-      String formattedKey, Scope scope, TypeMirror metadataType) {
-    return String.format(
-        "There is no binding for %s because %s is not annotated with @%s.",
-        formattedKey, scope.scopeAnnotationElement().getQualifiedName(), metadataType);
-  }
-
   /**
    * Returns an error message for a method that has more than one binding method annotation.
    *
diff --git a/java/dagger/internal/codegen/Formatter.java b/java/dagger/internal/codegen/Formatter.java
index af8a183e3..176477e06 100644
--- a/java/dagger/internal/codegen/Formatter.java
+++ b/java/dagger/internal/codegen/Formatter.java
@@ -17,7 +17,6 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Preconditions.checkElementIndex;
-import static dagger.internal.codegen.ErrorMessages.INDENT;
 
 import com.google.common.base.Function;
 import com.google.common.collect.Iterables;
@@ -30,6 +29,9 @@
  */
 abstract class Formatter<T> implements Function<T, String> {
 
+  static final String INDENT = "    ";
+  static final String DOUBLE_INDENT = INDENT + INDENT;
+
   /**
    * Performs the transformation of an object into a string representation.
    */
@@ -85,7 +87,7 @@ private void appendIndent(StringBuilder builder, int indentLevel) {
     }
   }
 
-  protected String formatArgumentInList(int index, int size, CharSequence name) {
+  static String formatArgumentInList(int index, int size, CharSequence name) {
     checkElementIndex(index, size);
     StringBuilder builder = new StringBuilder();
     if (index > 0) {
diff --git a/java/dagger/internal/codegen/FrameworkFieldInitializer.java b/java/dagger/internal/codegen/FrameworkFieldInitializer.java
index f5531b3b7..9bc1d176a 100644
--- a/java/dagger/internal/codegen/FrameworkFieldInitializer.java
+++ b/java/dagger/internal/codegen/FrameworkFieldInitializer.java
@@ -59,12 +59,15 @@
     }
 
     /**
-     * Returns {@code true} if the factory created for a binding is not worth inlining because it's
-     * a singleton or an {@link dagger.internal.InstanceFactory} or a nested {@code Provider} for a
-     * component dependency provision method.
+     * Returns {@code true} if instead of using {@link #creationExpression()} to create a framework
+     * instance, a case in {@link InnerSwitchingProviders} should be created for this binding.
      */
-    default boolean isSimpleFactory() {
-      return false;
+    // TODO(ronshapiro): perhaps this isn't the right approach. Instead of saying "Use
+    // SetFactory.EMPTY because you will only get 1 class for all types of bindings that use
+    // SetFactory", maybe we should still use an inner switching provider but the same switching
+    // provider index for all cases.
+    default boolean useInnerSwitchingProvider() {
+      return true;
     }
   }
 
diff --git a/java/dagger/internal/codegen/InstanceFactoryCreationExpression.java b/java/dagger/internal/codegen/InstanceFactoryCreationExpression.java
index 3aefff16a..c9b26d755 100644
--- a/java/dagger/internal/codegen/InstanceFactoryCreationExpression.java
+++ b/java/dagger/internal/codegen/InstanceFactoryCreationExpression.java
@@ -51,7 +51,7 @@ public CodeBlock creationExpression() {
   }
 
   @Override
-  public boolean isSimpleFactory() {
-    return true;
+  public boolean useInnerSwitchingProvider() {
+    return false;
   }
 }
diff --git a/java/dagger/internal/codegen/MapFactoryCreationExpression.java b/java/dagger/internal/codegen/MapFactoryCreationExpression.java
index 4bc3921fc..b5804908b 100644
--- a/java/dagger/internal/codegen/MapFactoryCreationExpression.java
+++ b/java/dagger/internal/codegen/MapFactoryCreationExpression.java
@@ -91,4 +91,9 @@ public CodeBlock creationExpression() {
 
     return builder.build();
   }
+
+  @Override
+  public boolean useInnerSwitchingProvider() {
+    return !binding.dependencies().isEmpty();
+  }
 }
diff --git a/java/dagger/internal/codegen/MapMultibindingValidation.java b/java/dagger/internal/codegen/MapMultibindingValidation.java
index ff0df9f04..1f963717a 100644
--- a/java/dagger/internal/codegen/MapMultibindingValidation.java
+++ b/java/dagger/internal/codegen/MapMultibindingValidation.java
@@ -20,7 +20,7 @@
 import static dagger.internal.codegen.DaggerStreams.instancesOf;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 import static dagger.internal.codegen.ErrorMessages.DUPLICATE_SIZE_LIMIT;
-import static dagger.internal.codegen.ErrorMessages.INDENT;
+import static dagger.internal.codegen.Formatter.INDENT;
 import static dagger.model.BindingKind.MULTIBOUND_MAP;
 import static javax.tools.Diagnostic.Kind.ERROR;
 
diff --git a/java/dagger/internal/codegen/MembersInjectorProviderCreationExpression.java b/java/dagger/internal/codegen/MembersInjectorProviderCreationExpression.java
index eecadefca..25d034a53 100644
--- a/java/dagger/internal/codegen/MembersInjectorProviderCreationExpression.java
+++ b/java/dagger/internal/codegen/MembersInjectorProviderCreationExpression.java
@@ -32,11 +32,10 @@
     implements FrameworkInstanceCreationExpression {
 
   private final ComponentBindingExpressions componentBindingExpressions;
-  private final ContributionBinding binding;
+  private final ProvisionBinding binding;
 
   MembersInjectorProviderCreationExpression(
-      ContributionBinding binding,
-      ComponentBindingExpressions componentBindingExpressions) {
+      ProvisionBinding binding, ComponentBindingExpressions componentBindingExpressions) {
     this.binding = checkNotNull(binding);
     this.componentBindingExpressions = checkNotNull(componentBindingExpressions);
   }
@@ -47,7 +46,7 @@ public CodeBlock creationExpression() {
         getOnlyElement(MoreTypes.asDeclared(binding.key().type()).getTypeArguments());
 
     CodeBlock membersInjector =
-        ((ProvisionBinding) binding).injectionSites().isEmpty()
+        binding.injectionSites().isEmpty()
             ? CodeBlock.of("$T.<$T>noOp()", MEMBERS_INJECTORS, membersInjectedType)
             : CodeBlock.of(
                 "$T.create($L)",
@@ -58,4 +57,9 @@ public CodeBlock creationExpression() {
     // (as it's rarely requested as a Provider).
     return CodeBlock.of("$T.create($L)", INSTANCE_FACTORY, membersInjector);
   }
+
+  @Override
+  public boolean useInnerSwitchingProvider() {
+    return !binding.injectionSites().isEmpty();
+  }
 }
diff --git a/java/dagger/internal/codegen/MissingBindingSuggestions.java b/java/dagger/internal/codegen/MissingBindingSuggestions.java
deleted file mode 100644
index 9380863de..000000000
--- a/java/dagger/internal/codegen/MissingBindingSuggestions.java
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import com.google.common.collect.ImmutableList;
-import dagger.model.Key;
-import java.util.ArrayDeque;
-import java.util.Deque;
-
-/**
- * Utility code that looks for bindings matching a key in all subcomponents in a binding graph so
- * that a user is advised that a binding exists elsewhere when it is not found in the current
- * subgraph. If a binding matching a key exists in a sub- or sibling component, that is often what
- * the user actually wants to use.
- */
-class MissingBindingSuggestions {
-  /**
-   * Searches the entire binding graph from the top-level graph for a binding matching
-   * {@code key}.
-   */
-  static ImmutableList<String> forKey(BindingGraph topLevelGraph, Key key) {
-    ImmutableList.Builder<String> resolutions = new ImmutableList.Builder<>();
-    Deque<BindingGraph> graphsToTry = new ArrayDeque<>();
-
-    graphsToTry.add(topLevelGraph);
-    do {
-      BindingGraph graph = graphsToTry.removeLast();
-      ResolvedBindings bindings = graph.contributionBindings().get(key);
-      if ((bindings == null) || bindings.bindings().isEmpty()) {
-        graphsToTry.addAll(graph.subgraphs());
-      } else {
-        resolutions.add(
-            "A binding with matching key exists in component: "
-                + graph.componentType().getQualifiedName());
-      }
-    } while (!graphsToTry.isEmpty());
-
-    return resolutions.build();
-  }
-
-  private MissingBindingSuggestions() {}
-}
diff --git a/java/dagger/internal/codegen/MissingBindingValidation.java b/java/dagger/internal/codegen/MissingBindingValidation.java
new file mode 100644
index 000000000..5ce5f9bab
--- /dev/null
+++ b/java/dagger/internal/codegen/MissingBindingValidation.java
@@ -0,0 +1,228 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.auto.common.MoreTypes.asTypeElement;
+import static com.google.auto.common.MoreTypes.isType;
+import static com.google.auto.common.MoreTypes.isTypeOf;
+import static dagger.internal.codegen.DaggerElements.isAnnotationPresent;
+import static dagger.internal.codegen.DaggerStreams.instancesOf;
+import static dagger.internal.codegen.Keys.isValidImplicitProvisionKey;
+import static dagger.internal.codegen.Keys.isValidMembersInjectionKey;
+import static dagger.internal.codegen.MoreAnnotationMirrors.getTypeValue;
+import static dagger.internal.codegen.RequestKinds.entryPointCanUseProduction;
+import static dagger.internal.codegen.Scopes.getReadableSource;
+import static java.util.function.Predicate.isEqual;
+import static java.util.stream.Collectors.toList;
+import static javax.tools.Diagnostic.Kind.ERROR;
+
+import com.google.auto.common.MoreTypes;
+import dagger.model.BindingGraph;
+import dagger.model.BindingGraph.BindingNode;
+import dagger.model.BindingGraph.ComponentNode;
+import dagger.model.BindingGraph.DependencyEdge;
+import dagger.model.BindingGraph.Node;
+import dagger.model.Key;
+import dagger.model.Scope;
+import dagger.releasablereferences.CanReleaseReferences;
+import dagger.releasablereferences.ForReleasableReferences;
+import dagger.releasablereferences.ReleasableReferenceManager;
+import dagger.releasablereferences.TypedReleasableReferenceManager;
+import dagger.spi.BindingGraphPlugin;
+import dagger.spi.DiagnosticReporter;
+import java.util.List;
+import java.util.Optional;
+import java.util.stream.Stream;
+import javax.inject.Inject;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.TypeMirror;
+
+/** Reports errors for missing bindings. */
+final class MissingBindingValidation implements BindingGraphPlugin {
+
+  private final DaggerTypes types;
+  private final DaggerElements elements;
+  private final InjectBindingRegistry injectBindingRegistry;
+
+  @Inject
+  MissingBindingValidation(
+      DaggerTypes types, DaggerElements elements, InjectBindingRegistry injectBindingRegistry) {
+    this.types = types;
+    this.injectBindingRegistry = injectBindingRegistry;
+    this.elements = elements;
+  }
+
+  @Override
+  public String pluginName() {
+    return "Dagger/MissingBinding";
+  }
+
+  @Override
+  public void visitGraph(BindingGraph graph, DiagnosticReporter diagnosticReporter) {
+    // TODO(ronshapiro): Maybe report each missing binding once instead of each dependency.
+    graph
+        .missingBindingNodes()
+        .stream()
+        .flatMap(node -> graph.inEdges(node).stream())
+        .flatMap(instancesOf(DependencyEdge.class))
+        .forEach(edge -> reportMissingBinding(edge, graph, diagnosticReporter));
+  }
+
+  private void reportMissingBinding(
+      DependencyEdge edge, BindingGraph graph, DiagnosticReporter diagnosticReporter) {
+    diagnosticReporter.reportDependency(
+        ERROR,
+        edge,
+        missingReleasableReferenceManagerBindingErrorMessage(edge, graph)
+            .orElseGet(() -> missingBindingErrorMessage(edge, graph)));
+  }
+
+  private String missingBindingErrorMessage(DependencyEdge edge, BindingGraph graph) {
+    Key key = edge.dependencyRequest().key();
+    StringBuilder errorMessage = new StringBuilder();
+    // TODO(dpb): Check for wildcard injection somewhere else first?
+    if (key.type().getKind().equals(TypeKind.WILDCARD)) {
+      // TODO(ronshapiro): Explore creating this message using RequestKinds.
+      errorMessage
+          .append("Dagger does not support injecting Provider<T>, Lazy<T>, Producer<T>, ")
+          .append("or Produced<T> when T is a wildcard type such as ")
+          .append(key);
+    } else {
+      // TODO(ronshapiro): replace "provided" with "satisfied"?
+      errorMessage.append(key).append(" cannot be provided without ");
+      if (isValidImplicitProvisionKey(key, types)) {
+        errorMessage.append("an @Inject constructor or ");
+      }
+      errorMessage.append("an @Provides-"); // TODO(dpb): s/an/a
+      if (dependencyCanBeProduction(edge, graph)) {
+        errorMessage.append(" or @Produces-");
+      }
+      errorMessage.append("annotated method.");
+    }
+    if (isValidMembersInjectionKey(key) && typeHasInjectionSites(key)) {
+      errorMessage.append(
+          " This type supports members injection but cannot be implicitly provided.");
+    }
+    graph
+        .bindingNodes(key)
+        .stream()
+        .map(bindingNode -> bindingNode.componentPath().currentComponent())
+        .distinct()
+        .forEach(
+            component ->
+                errorMessage
+                    .append("\nA binding with matching key exists in component: ")
+                    .append(component.getQualifiedName()));
+    return errorMessage.toString();
+  }
+
+  private boolean dependencyCanBeProduction(DependencyEdge edge, BindingGraph graph) {
+    Node source = graph.incidentNodes(edge).source();
+    if (source instanceof ComponentNode) {
+      return entryPointCanUseProduction(edge.dependencyRequest().kind());
+    }
+    if (source instanceof BindingNode) {
+      return ((BindingNode) source).binding().isProduction();
+    }
+    throw new IllegalArgumentException("expected a BindingNode or ComponentNode: " + source);
+  }
+
+  private boolean typeHasInjectionSites(Key key) {
+    return injectBindingRegistry
+        .getOrFindMembersInjectionBinding(key)
+        .map(binding -> !binding.injectionSites().isEmpty())
+        .orElse(false);
+  }
+
+  /**
+   * If {@code edge} is missing a binding because it's an invalid {@code @ForReleasableReferences}
+   * request, returns a more specific error message.
+   *
+   * <p>An invalid request is one whose type is either {@link ReleasableReferenceManager} or {@link
+   * TypedReleasableReferenceManager}, and whose scope:
+   *
+   * <ul>
+   *   <li>does not annotate any component in the hierarchy, or
+   *   <li>is not annotated with the metadata annotation type that is the {@link
+   *       TypedReleasableReferenceManager}'s type argument
+   * </ul>
+   */
+  private Optional<String> missingReleasableReferenceManagerBindingErrorMessage(
+      DependencyEdge edge, BindingGraph graph) {
+    Key key = edge.dependencyRequest().key();
+    if (!key.qualifier().isPresent()
+        || !isTypeOf(ForReleasableReferences.class, key.qualifier().get().getAnnotationType())
+        || !isType(key.type())) {
+      return Optional.empty();
+    }
+
+    Optional<DeclaredType> metadataType;
+    if (isTypeOf(ReleasableReferenceManager.class, key.type())) {
+      metadataType = Optional.empty();
+    } else if (isTypeOf(TypedReleasableReferenceManager.class, key.type())) {
+      List<? extends TypeMirror> typeArguments =
+          MoreTypes.asDeclared(key.type()).getTypeArguments();
+      if (typeArguments.size() != 1 || !typeArguments.get(0).getKind().equals(TypeKind.DECLARED)) {
+        return Optional.empty();
+      }
+      metadataType = Optional.of(MoreTypes.asDeclared(typeArguments.get(0)));
+    } else {
+      return Optional.empty();
+    }
+
+    Scope scope = Scopes.scope(asTypeElement(getTypeValue(key.qualifier().get(), "value")));
+    if (releasableReferencesScopes(graph).noneMatch(isEqual(scope))) {
+      return Optional.of(
+          String.format(
+              "There is no binding for %s because no component in %s's component hierarchy is "
+                  + "annotated with %s. The available reference-releasing scopes are %s.",
+              key,
+              graph.rootComponentNode().toString(),
+              getReadableSource(scope),
+              releasableReferencesScopes(graph).map(Scopes::getReadableSource).collect(toList())));
+    }
+    if (metadataType.isPresent()) {
+      TypeElement metadataTypeElement = asTypeElement(metadataType.get());
+      if (!isAnnotationPresent(scope.scopeAnnotationElement(), metadataType.get())) {
+        return Optional.of(notAnnotated(key, scope.scopeAnnotationElement(), metadataTypeElement));
+      }
+      if (!isAnnotationPresent(metadataTypeElement, CanReleaseReferences.class)) {
+        return Optional.of(
+            notAnnotated(
+                key, metadataTypeElement, elements.getTypeElement(CanReleaseReferences.class)));
+      }
+    }
+    return Optional.empty();
+  }
+
+  private static String notAnnotated(Key key, TypeElement type, TypeElement annotation) {
+    return String.format(
+        "There is no binding for %s because %s is not annotated with @%s.",
+        key, type.getQualifiedName(), annotation);
+  }
+
+  private Stream<Scope> releasableReferencesScopes(BindingGraph graph) {
+    return graph
+        .componentNodes()
+        .stream()
+        .flatMap(node -> node.scopes().stream())
+        .filter(Scope::canReleaseReferences);
+  }
+}
diff --git a/java/dagger/internal/codegen/OptionalFactoryInstanceCreationExpression.java b/java/dagger/internal/codegen/OptionalFactoryInstanceCreationExpression.java
new file mode 100644
index 000000000..cffcbc83e
--- /dev/null
+++ b/java/dagger/internal/codegen/OptionalFactoryInstanceCreationExpression.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.collect.Iterables.getOnlyElement;
+
+import com.squareup.javapoet.CodeBlock;
+import dagger.internal.codegen.FrameworkFieldInitializer.FrameworkInstanceCreationExpression;
+
+/**
+ * A {@link FrameworkInstanceCreationExpression} for {@link dagger.model.BindingKind#OPTIONAL
+ * optional bindings}.
+ */
+final class OptionalFactoryInstanceCreationExpression
+    implements FrameworkInstanceCreationExpression {
+  private final OptionalFactories optionalFactories;
+  private final ContributionBinding binding;
+  private final GeneratedComponentModel generatedComponentModel;
+  private final ComponentBindingExpressions componentBindingExpressions;
+
+  OptionalFactoryInstanceCreationExpression(
+      OptionalFactories optionalFactories,
+      ContributionBinding binding,
+      GeneratedComponentModel generatedComponentModel,
+      ComponentBindingExpressions componentBindingExpressions) {
+    this.optionalFactories = optionalFactories;
+    this.binding = binding;
+    this.generatedComponentModel = generatedComponentModel;
+    this.componentBindingExpressions = componentBindingExpressions;
+  }
+
+  @Override
+  public CodeBlock creationExpression() {
+    return binding.dependencies().isEmpty()
+        ? optionalFactories.absentOptionalProvider(binding)
+        : optionalFactories.presentOptionalFactory(
+            binding,
+            componentBindingExpressions
+                .getDependencyExpression(
+                    getOnlyElement(binding.frameworkDependencies()), generatedComponentModel.name())
+                .codeBlock());
+  }
+
+  @Override
+  public boolean useInnerSwitchingProvider() {
+    // Share providers for empty optionals from OptionalFactories so we don't have numerous
+    // switch cases that all return Optional.empty().
+    return !binding.dependencies().isEmpty();
+  }
+}
diff --git a/java/dagger/internal/codegen/Optionals.java b/java/dagger/internal/codegen/Optionals.java
index e74be14e4..f8963db36 100644
--- a/java/dagger/internal/codegen/Optionals.java
+++ b/java/dagger/internal/codegen/Optionals.java
@@ -16,6 +16,7 @@
 
 package dagger.internal.codegen;
 
+import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.Lists.asList;
 
 import java.util.Comparator;
@@ -32,6 +33,11 @@
         .thenComparing(Optional::get);
   }
 
+  static <T> Comparator<Optional<T>> emptiesLast(Comparator<? super T> valueComparator) {
+    checkNotNull(valueComparator);
+    return Comparator.comparing(o -> o.orElse(null), Comparator.nullsLast(valueComparator));
+  }
+
   /** Returns the first argument that is present, or empty if none are. */
   @SafeVarargs
   static <T> Optional<T> firstPresent(Optional<T> first, Optional<T> second, Optional<T>... rest) {
diff --git a/java/dagger/internal/codegen/ProducerFromProviderCreationExpression.java b/java/dagger/internal/codegen/ProducerFromProviderCreationExpression.java
index 05a0e41fe..f34e26cfd 100644
--- a/java/dagger/internal/codegen/ProducerFromProviderCreationExpression.java
+++ b/java/dagger/internal/codegen/ProducerFromProviderCreationExpression.java
@@ -54,6 +54,8 @@ public CodeBlock creationExpression() {
 
   @Override
   public Optional<ClassName> alternativeFrameworkClass() {
-    return Optional.of(ClassName.get(Producer.class));
+    return Optional.of(TypeNames.PRODUCER);
   }
+
+  // TODO(ronshapiro): should this have a simple factory if the delegate expression is simple?
 }
diff --git a/java/dagger/internal/codegen/SetFactoryCreationExpression.java b/java/dagger/internal/codegen/SetFactoryCreationExpression.java
index e1a161807..94975680f 100644
--- a/java/dagger/internal/codegen/SetFactoryCreationExpression.java
+++ b/java/dagger/internal/codegen/SetFactoryCreationExpression.java
@@ -89,4 +89,9 @@ public CodeBlock creationExpression() {
     builder.add(builderMethodCalls.build());
     return builder.add(".build()").build();
   }
+
+  @Override
+  public boolean useInnerSwitchingProvider() {
+    return !binding.dependencies().isEmpty();
+  }
 }
diff --git a/java/dagger/internal/codegen/SimpleMethodBindingExpression.java b/java/dagger/internal/codegen/SimpleMethodBindingExpression.java
index 6c884fa75..f35d0a0d6 100644
--- a/java/dagger/internal/codegen/SimpleMethodBindingExpression.java
+++ b/java/dagger/internal/codegen/SimpleMethodBindingExpression.java
@@ -99,9 +99,7 @@ private Expression invokeMethod(ClassName requestingClass) {
         throw new IllegalStateException();
     }
 
-    return Expression.create(
-        provisionBinding.contributedPrimitiveType().orElse(provisionBinding.key().type()),
-        invocation);
+    return Expression.create(simpleMethodReturnType(), invocation);
   }
 
   private TypeName constructorTypeName(ClassName requestingClass) {
@@ -133,7 +131,7 @@ private CodeBlock dependencyArgument(DependencyRequest dependency, ClassName req
 
   private Expression injectMembers(CodeBlock instance) {
     if (provisionBinding.injectionSites().isEmpty()) {
-      return Expression.create(provisionBinding.key().type(), instance);
+      return Expression.create(simpleMethodReturnType(), instance);
     }
     // Java 7 type inference can't figure out that instance in
     // injectParameterized(Parameterized_Factory.newParameterized()) is Parameterized<T> and not
@@ -162,4 +160,8 @@ private Expression injectMembers(CodeBlock instance) {
                     componentRequirementFields.getExpression(requirement, requestingClass))
         : Optional.empty();
   }
+
+  private TypeMirror simpleMethodReturnType() {
+    return provisionBinding.contributedPrimitiveType().orElse(provisionBinding.key().type());
+  }
 }
diff --git a/java/dagger/internal/codegen/ValidationReport.java b/java/dagger/internal/codegen/ValidationReport.java
index 9fd2c734a..ef2142144 100644
--- a/java/dagger/internal/codegen/ValidationReport.java
+++ b/java/dagger/internal/codegen/ValidationReport.java
@@ -16,6 +16,7 @@
 
 package dagger.internal.codegen;
 
+import static dagger.internal.codegen.DaggerElements.elementToString;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 import static javax.tools.Diagnostic.Kind.ERROR;
 import static javax.tools.Diagnostic.Kind.NOTE;
@@ -31,8 +32,6 @@
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.element.Element;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.util.SimpleElementVisitor8;
 import javax.tools.Diagnostic;
 import javax.tools.Diagnostic.Kind;
 
@@ -113,7 +112,7 @@ void printMessagesTo(Messager messager) {
           messager.printMessage(item.kind(), item.message(), item.element());
         }
       } else {
-        String message = String.format("[%s] %s", elementString(item.element()), item.message());
+        String message = String.format("[%s] %s", elementToString(item.element()), item.message());
         messager.printMessage(item.kind(), message, subject());
       }
     }
@@ -122,22 +121,6 @@ void printMessagesTo(Messager messager) {
     }
   }
 
-  private static String elementString(Element element) {
-    return element.accept(
-        new SimpleElementVisitor8<String, Void>() {
-          @Override
-          protected String defaultAction(Element e, Void p) {
-            return e.toString();
-          }
-
-          @Override
-          public String visitExecutable(ExecutableElement e, Void p) {
-            return e.getEnclosingElement().accept(this, null) + '.' + e;
-          }
-        },
-        null);
-  }
-
   private static boolean isEnclosedIn(Element parent, Element child) {
     Element current = child;
     while (current != null) {
diff --git a/java/dagger/model/Binding.java b/java/dagger/model/Binding.java
index 38a452711..3e0cad0ab 100644
--- a/java/dagger/model/Binding.java
+++ b/java/dagger/model/Binding.java
@@ -17,7 +17,6 @@
 package dagger.model;
 
 import com.google.common.collect.ImmutableSet;
-import com.google.errorprone.annotations.DoNotMock;
 import java.util.Optional;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
@@ -27,7 +26,6 @@
  * Includes any {@linkplain DependencyRequest dependencies} that are needed in order to provide the
  * instances.
  */
-@DoNotMock("Equality semantics are important but not specified, so use only Dagger implementations")
 public interface Binding {
   /** The binding's key. */
   Key key();
diff --git a/java/dagger/model/BindingGraph.java b/java/dagger/model/BindingGraph.java
index 9b578b816..f37cfc760 100644
--- a/java/dagger/model/BindingGraph.java
+++ b/java/dagger/model/BindingGraph.java
@@ -17,7 +17,6 @@
 package dagger.model;
 
 import static com.google.common.base.MoreObjects.toStringHelper;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.Sets.intersection;
 import static com.google.common.graph.Graphs.inducedSubgraph;
 import static com.google.common.graph.Graphs.reachableNodes;
@@ -31,16 +30,11 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.graph.ImmutableNetwork;
 import com.google.common.graph.Network;
-import com.google.errorprone.annotations.DoNotMock;
-import dagger.BindsOptionalOf;
 import dagger.Module;
 import dagger.model.BindingGraph.Edge;
 import dagger.model.BindingGraph.Node;
-import dagger.multibindings.Multibinds;
 import java.util.Optional;
-import java.util.function.Supplier;
 import java.util.stream.Stream;
-import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 
@@ -71,8 +65,9 @@
  * binding node for the {@code @Subcomponent.Builder} type. For subcomponents defined by {@linkplain
  * ChildFactoryMethodEdge subcomponent factory methods}, the source node is the component node for
  * the parent.
+ *
+ * <p><b>Note that this API is experimental and will change.</b>
  */
-// TODO(dpb): Represent graphs with missing or conflicting bindings.
 public final class BindingGraph extends ForwardingNetwork<Node, Edge> {
   BindingGraph(Network<Node, Edge> network) {
     super(ImmutableNetwork.copyOf(network));
@@ -80,38 +75,43 @@
 
   /** Returns the binding nodes. */
   public ImmutableSet<BindingNode> bindingNodes() {
-    return bindingNodesStream().collect(toImmutableSet());
+    return nodes(BindingNode.class);
   }
 
   /** Returns the binding nodes for a key. */
   public ImmutableSet<BindingNode> bindingNodes(Key key) {
-    return bindingNodesStream()
+    return nodeStream(BindingNode.class)
         .filter(node -> node.binding().key().equals(key))
         .collect(toImmutableSet());
   }
 
+  /** Returns the nodes that represent missing bindings. */
+  public ImmutableSet<MissingBindingNode> missingBindingNodes() {
+    return nodes(MissingBindingNode.class);
+  }
+
   /** Returns the component nodes. */
   public ImmutableSet<ComponentNode> componentNodes() {
-    return componentNodeStream().collect(toImmutableSet());
+    return nodes(ComponentNode.class);
   }
 
   /** Returns the component node for a component. */
   public Optional<ComponentNode> componentNode(ComponentPath component) {
-    return componentNodeStream()
+    return nodeStream(ComponentNode.class)
         .filter(node -> node.componentPath().equals(component))
         .findFirst();
   }
 
   /** Returns the component nodes for a component. */
   public ImmutableSet<ComponentNode> componentNodes(TypeElement component) {
-    return componentNodeStream()
+    return nodeStream(ComponentNode.class)
         .filter(node -> node.componentPath().currentComponent().equals(component))
         .collect(toImmutableSet());
   }
 
   /** Returns the component node for the root component. */
   public ComponentNode rootComponentNode() {
-    return componentNodeStream()
+    return nodeStream(ComponentNode.class)
         .filter(node -> node.componentPath().atRoot())
         .findFirst()
         .get();
@@ -124,13 +124,11 @@ public ComponentNode rootComponentNode() {
 
   /** Returns the dependency edges for the dependencies of a binding. */
   public ImmutableMap<DependencyRequest, DependencyEdge> dependencyEdges(BindingNode bindingNode) {
-    return outEdges(bindingNode)
-        .stream()
-        .flatMap(instancesOf(DependencyEdge.class))
+    return dependencyEdgeStream(bindingNode)
         .collect(toImmutableMap(DependencyEdge::dependencyRequest, edge -> edge));
   }
 
-  /** Returns the dependency edges from any binding for a dependency request. */
+  /** Returns the dependency edges for a dependency request. */
   public ImmutableSet<DependencyEdge> dependencyEdges(DependencyRequest dependencyRequest) {
     return dependencyEdgeStream()
         .filter(edge -> edge.dependencyRequest().equals(dependencyRequest))
@@ -138,22 +136,23 @@ public ComponentNode rootComponentNode() {
   }
 
   /**
-   * Returns the dependency edges for all entry points for all components and subcomponents. Each
-   * edge's source node is a component node.
+   * Returns the dependency edges for the entry points of a given {@code component}. Each edge's
+   * source node is that component's component node.
    */
-  public ImmutableSet<DependencyEdge> entryPointEdges() {
-    return entryPointEdgeStream().collect(toImmutableSet());
+  public ImmutableSet<DependencyEdge> entryPointEdges(ComponentPath component) {
+    return dependencyEdgeStream(componentNode(component).get()).collect(toImmutableSet());
+  }
+
+  private Stream<DependencyEdge> dependencyEdgeStream(Node node) {
+    return outEdges(node).stream().flatMap(instancesOf(DependencyEdge.class));
   }
 
   /**
-   * Returns the dependency edges for the entry points of a given {@code component}. Each edge's
-   * source node is that component's component node.
+   * Returns the dependency edges for all entry points for all components and subcomponents. Each
+   * edge's source node is a component node.
    */
-  public ImmutableSet<DependencyEdge> entryPointEdges(ComponentPath component) {
-    return outEdges(componentNode(component).get())
-        .stream()
-        .flatMap(instancesOf(DependencyEdge.class))
-        .collect(toImmutableSet());
+  public ImmutableSet<DependencyEdge> entryPointEdges() {
+    return entryPointEdgeStream().collect(toImmutableSet());
   }
 
   /** Returns the binding nodes for bindings that directly satisfy entry points. */
@@ -172,12 +171,12 @@ public ComponentNode rootComponentNode() {
         intersection(entryPointEdges(), subgraphDependingOnBindingNode.edges()));
   }
 
-  private Stream<BindingNode> bindingNodesStream() {
-    return nodes().stream().flatMap(instancesOf(BindingNode.class));
+  private <N extends Node> ImmutableSet<N> nodes(Class<N> clazz) {
+    return nodeStream(clazz).collect(toImmutableSet());
   }
 
-  private Stream<ComponentNode> componentNodeStream() {
-    return nodes().stream().flatMap(instancesOf(ComponentNode.class));
+  private <N extends Node> Stream<N> nodeStream(Class<N> clazz) {
+    return nodes().stream().flatMap(instancesOf(clazz));
   }
 
   private Stream<DependencyEdge> dependencyEdgeStream() {
@@ -200,6 +199,12 @@ public ComponentNode rootComponentNode() {
    * <p>Because one {@link DependencyRequest} may represent a dependency from two bindings (e.g., a
    * dependency of {@code Foo<String>} and {@code Foo<Number>} may have the same key and request
    * element), this class does not override {@link #equals(Object)} to use value semantics.
+   *
+   * <p>For entry points, the source node is the {@link ComponentNode} that contains the entry
+   * point. Otherwise the source node is a {@link BindingNode}.
+   *
+   * <p>For dependencies on missing bindings, the target node is a {@link MissingBindingNode}.
+   * Otherwise the target node is a {@link BindingNode}.
    */
   public static final class DependencyEdge implements Edge {
 
@@ -293,45 +298,33 @@ public String toString() {
    * A <b>binding node</b> in the binding graph. If a binding is owned by more than one component,
    * there is one binding node for that binding for every owning component.
    */
-  @AutoValue
-  @DoNotMock("Use Dagger-supplied implementations")
-  public abstract static class BindingNode implements Node {
-    static BindingNode create(
-        ComponentPath component,
-        Binding binding,
-        Iterable<Element> associatedDeclarations,
-        Supplier<String> toStringFunction) {
-      BindingNode bindingNode =
-          new AutoValue_BindingGraph_BindingNode(
-              component, binding, ImmutableSet.copyOf(associatedDeclarations));
-      bindingNode.toStringFunction = checkNotNull(toStringFunction);
-      return bindingNode;
-    }
-
-    private Supplier<String> toStringFunction;
+  public interface BindingNode extends Node {
 
     /** The component that owns the {@link #binding()}. */
     @Override
-    public abstract ComponentPath componentPath();
+    ComponentPath componentPath();
 
     /** The binding. */
-    public abstract Binding binding();
+    Binding binding();
+  }
 
-    /**
-     * The {@link Element}s (other than the binding's {@link Binding#bindingElement()}) that are
-     * associated with the binding.
-     *
-     * <ul>
-     *   <li>{@linkplain BindsOptionalOf optional binding} declarations
-     *   <li>{@linkplain Module#subcomponents() module subcomponent} declarations
-     *   <li>{@linkplain Multibinds multibinding} declarations
-     * </ul>
-     */
-    public abstract ImmutableSet<Element> associatedDeclarations();
+  /** A node in the binding graph that represents a missing binding for a key in a component. */
+  @AutoValue
+  public abstract static class MissingBindingNode implements Node {
+    static MissingBindingNode create(ComponentPath component, Key key) {
+      return new AutoValue_BindingGraph_MissingBindingNode(component, key);
+    }
+
+    /** The component in which the binding is missing. */
+    @Override
+    public abstract ComponentPath componentPath();
+
+    /** The key for which there is no binding. */
+    public abstract Key key();
 
     @Override
     public String toString() {
-      return toStringFunction.get();
+      return String.format("missing binding for %s in %s", key(), componentPath());
     }
   }
 
@@ -342,8 +335,10 @@ public String toString() {
   @AutoValue
   public abstract static class ComponentNode implements Node {
     static ComponentNode create(
-        ComponentPath componentPath, ImmutableSet<DependencyRequest> entryPoints) {
-      return new AutoValue_BindingGraph_ComponentNode(componentPath, entryPoints);
+        ComponentPath componentPath,
+        ImmutableSet<DependencyRequest> entryPoints,
+        ImmutableSet<Scope> scopes) {
+      return new AutoValue_BindingGraph_ComponentNode(componentPath, entryPoints, scopes);
     }
 
     /** The component represented by this node. */
@@ -353,6 +348,9 @@ static ComponentNode create(
     /** The entry points on this component. */
     public abstract ImmutableSet<DependencyRequest> entryPoints();
 
+    /** The scopes declared on this component. */
+    public abstract ImmutableSet<Scope> scopes();
+
     @Override
     public final String toString() {
       return componentPath().toString();
diff --git a/java/dagger/model/BindingGraphProxies.java b/java/dagger/model/BindingGraphProxies.java
index 1bdd17fd9..a5e24ff3e 100644
--- a/java/dagger/model/BindingGraphProxies.java
+++ b/java/dagger/model/BindingGraphProxies.java
@@ -18,15 +18,13 @@
 
 import com.google.common.collect.ImmutableSet;
 import com.google.common.graph.Network;
-import dagger.model.BindingGraph.BindingNode;
 import dagger.model.BindingGraph.ChildFactoryMethodEdge;
 import dagger.model.BindingGraph.ComponentNode;
 import dagger.model.BindingGraph.DependencyEdge;
 import dagger.model.BindingGraph.Edge;
+import dagger.model.BindingGraph.MissingBindingNode;
 import dagger.model.BindingGraph.Node;
 import dagger.model.BindingGraph.SubcomponentBuilderBindingEdge;
-import java.util.function.Supplier;
-import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 
@@ -41,19 +39,17 @@ public static BindingGraph bindingGraph(Network<Node, Edge> network) {
     return new BindingGraph(network);
   }
 
-  /** Creates a new {@link BindingNode}. */
-  public static BindingNode bindingNode(
-      ComponentPath component,
-      Binding binding,
-      Iterable<Element> associatedDeclarations,
-      Supplier<String> toStringFunction) {
-    return BindingNode.create(component, binding, associatedDeclarations, toStringFunction);
+  /** Creates a new {@link MissingBindingNode}. */
+  public static MissingBindingNode missingBindingNode(ComponentPath component, Key key) {
+    return MissingBindingNode.create(component, key);
   }
 
   /** Creates a new {@link ComponentNode}. */
   public static ComponentNode componentNode(
-      ComponentPath component, ImmutableSet<DependencyRequest> entryPoints) {
-    return ComponentNode.create(component, entryPoints);
+      ComponentPath component,
+      ImmutableSet<DependencyRequest> entryPoints,
+      ImmutableSet<Scope> scopes) {
+    return ComponentNode.create(component, entryPoints, scopes);
   }
 
   /** Creates a new {@link DependencyEdge}. */
diff --git a/java/dagger/model/BindingKind.java b/java/dagger/model/BindingKind.java
index 6bcdb575d..3ea2f9c93 100644
--- a/java/dagger/model/BindingKind.java
+++ b/java/dagger/model/BindingKind.java
@@ -106,4 +106,19 @@
   /** A binding for a members injection method on a component. */
   MEMBERS_INJECTION,
   ;
+
+  /**
+   * Returns {@code true} if this is a kind of multibinding (not a contribution to a multibinding,
+   * but the multibinding itself).
+   */
+  public boolean isMultibinding() {
+    switch (this) {
+      case MULTIBOUND_MAP:
+      case MULTIBOUND_SET:
+        return true;
+
+      default:
+        return false;
+    }
+  }
 }
diff --git a/java/dagger/model/ComponentPath.java b/java/dagger/model/ComponentPath.java
index ce9329ac7..5ef7b41f9 100644
--- a/java/dagger/model/ComponentPath.java
+++ b/java/dagger/model/ComponentPath.java
@@ -22,12 +22,10 @@
 
 import com.google.auto.value.AutoValue;
 import com.google.common.collect.ImmutableList;
-import com.google.errorprone.annotations.DoNotMock;
 import javax.lang.model.element.TypeElement;
 
 /** A path containing a component and all of its ancestor components. */
 @AutoValue
-@DoNotMock("Use ComponentPath.create() to create an instance.")
 public abstract class ComponentPath {
   /** Returns a new {@link ComponentPath} from {@code components}. */
   public static ComponentPath create(Iterable<TypeElement> components) {
diff --git a/java/dagger/model/DependencyRequest.java b/java/dagger/model/DependencyRequest.java
index 09d77920c..607b5ec00 100644
--- a/java/dagger/model/DependencyRequest.java
+++ b/java/dagger/model/DependencyRequest.java
@@ -19,7 +19,6 @@
 import com.google.auto.value.AutoValue;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.google.errorprone.annotations.CheckReturnValue;
-import com.google.errorprone.annotations.DoNotMock;
 import dagger.Provides;
 import java.util.Optional;
 import javax.inject.Inject;
@@ -36,7 +35,6 @@
  * asynchronously even though it is not directly specified as a parameter to the binding method.
  */
 @AutoValue
-@DoNotMock("Use DependencyRequest.builder() to create an instance")
 public abstract class DependencyRequest {
   /** The kind of this request. */
   public abstract RequestKind kind();
diff --git a/java/dagger/model/Key.java b/java/dagger/model/Key.java
index 119396c39..daeb35a94 100644
--- a/java/dagger/model/Key.java
+++ b/java/dagger/model/Key.java
@@ -25,7 +25,6 @@
 import com.google.common.base.Equivalence;
 import com.google.common.base.Equivalence.Wrapper;
 import com.google.common.base.Joiner;
-import com.google.errorprone.annotations.DoNotMock;
 import java.util.Optional;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
@@ -37,7 +36,6 @@
  * is the lookup key for a binding.
  */
 @AutoValue
-@DoNotMock("Use Key.builder() to create an instance.")
 public abstract class Key {
   /**
    * A {@link javax.inject.Qualifier} annotation that provides a unique namespace prefix
@@ -132,7 +130,7 @@ public abstract Builder multibindingContributionIdentifier(
 
     public abstract Key build();
   }
-  
+
   /**
    * An object that identifies a multibinding contribution method and the module class that
    * contributes it to the graph.
diff --git a/java/dagger/model/Scope.java b/java/dagger/model/Scope.java
index 8e8457724..541a69f0b 100644
--- a/java/dagger/model/Scope.java
+++ b/java/dagger/model/Scope.java
@@ -26,7 +26,6 @@
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
 import com.google.common.collect.ImmutableSet;
-import com.google.errorprone.annotations.DoNotMock;
 import dagger.Reusable;
 import dagger.producers.ProductionScope;
 import dagger.releasablereferences.CanReleaseReferences;
@@ -40,7 +39,6 @@
 /** A representation of a {@link javax.inject.Scope}. */
 @AutoValue
 // TODO(ronshapiro): point to SimpleAnnotationMirror
-@DoNotMock("Use Scope.scope(AnnotationMirror) to create an instance")
 public abstract class Scope {
   abstract Equivalence.Wrapper<AnnotationMirror> wrappedScopeAnnotation();
 
diff --git a/java/dagger/producers/BUILD b/java/dagger/producers/BUILD
index 2ebf82534..435d29699 100644
--- a/java/dagger/producers/BUILD
+++ b/java/dagger/producers/BUILD
@@ -37,9 +37,6 @@ java_library(
     name = "producers",
     srcs = SRCS,
     javacopts = SOURCE_7_TARGET_7 + DOCLINT_HTML_AND_SYNTAX + DOCLINT_REFERENCES,
-    plugins = [
-        # TODO(cgruber): Enable Beta checker.
-    ],
     exports = [
         # TODO(dpb): Don't export any of Guava.
         "//third_party:guava",
diff --git a/java/dagger/producers/internal/Producers.java b/java/dagger/producers/internal/Producers.java
index c98a8ca7e..4de3354ee 100644
--- a/java/dagger/producers/internal/Producers.java
+++ b/java/dagger/producers/internal/Producers.java
@@ -52,19 +52,23 @@
   // trigger one in a test.
   public static <T> ListenableFuture<Produced<T>> createFutureProduced(ListenableFuture<T> future) {
     return catchingAsync(
-        transform(
-            future,
-            new Function<T, Produced<T>>() {
-              @Override
-              public Produced<T> apply(final T value) {
-                return Produced.successful(value);
-              }
-            },
-            directExecutor()),
+        transform(future, Producers.<T>resultToProduced(), directExecutor()),
         Throwable.class,
         Producers.<T>futureFallbackForProduced(),
         directExecutor());
+  }
+
+  private static final Function<Object, Produced<Object>> RESULT_TO_PRODUCED =
+      new Function<Object, Produced<Object>>() {
+        @Override
+        public Produced<Object> apply(Object result) {
+          return Produced.successful(result);
+        }
+      };
 
+  @SuppressWarnings({"unchecked", "rawtypes"}) // bivariant implementation
+  private static <T> Function<T, Produced<T>> resultToProduced() {
+    return (Function) RESULT_TO_PRODUCED;
   }
 
   private static final AsyncFunction<Throwable, Produced<Object>> FUTURE_FALLBACK_FOR_PRODUCED =
diff --git a/java/dagger/releasablereferences/CanReleaseReferences.java b/java/dagger/releasablereferences/CanReleaseReferences.java
index cc7c2151a..b240b0442 100644
--- a/java/dagger/releasablereferences/CanReleaseReferences.java
+++ b/java/dagger/releasablereferences/CanReleaseReferences.java
@@ -59,7 +59,7 @@
  * @since 2.8
  * @deprecated The releasable references feature is deprecated and scheduled for removal in July
  *     2018. If you use it or are planning to add usages, please
- *     <a href="https://github.com/google/dagger/issues/1117">this bug</a>.
+ *     comment on <a href="https://github.com/google/dagger/issues/1117">this bug</a>.
  */
 @Beta
 @Documented
diff --git a/java/dagger/releasablereferences/ReleasableReferenceManager.java b/java/dagger/releasablereferences/ReleasableReferenceManager.java
index 290c658df..506bee25f 100644
--- a/java/dagger/releasablereferences/ReleasableReferenceManager.java
+++ b/java/dagger/releasablereferences/ReleasableReferenceManager.java
@@ -70,7 +70,7 @@
  * @since 2.8
  * @deprecated The releasable references feature is deprecated and scheduled for removal in July
  *     2018. If you use it or are planning to add usages, please
- *     <a href="https://github.com/google/dagger/issues/1117">this bug</a>.
+ *     comment on <a href="https://github.com/google/dagger/issues/1117">this bug</a>.
  */
 @Beta
 @GwtIncompatible
diff --git a/java/dagger/releasablereferences/TypedReleasableReferenceManager.java b/java/dagger/releasablereferences/TypedReleasableReferenceManager.java
index 1ba4f4703..eb42b7898 100644
--- a/java/dagger/releasablereferences/TypedReleasableReferenceManager.java
+++ b/java/dagger/releasablereferences/TypedReleasableReferenceManager.java
@@ -52,7 +52,7 @@
  * @param <M> the type of the metadata annotation
  * @deprecated The releasable references feature is deprecated and scheduled for removal in July
  *     2018. If you use it or are planning to add usages, please
- *     <a href="https://github.com/google/dagger/issues/1117">this bug</a>.
+ *     comment on <a href="https://github.com/google/dagger/issues/1117">this bug</a>.
  */
 @Beta
 @GwtIncompatible
diff --git a/javatests/dagger/functional/multibindings/ComplexMapKeysInDifferentOrderTest.java b/javatests/dagger/functional/multibindings/ComplexMapKeysInDifferentOrderTest.java
new file mode 100644
index 000000000..f2b5598ac
--- /dev/null
+++ b/javatests/dagger/functional/multibindings/ComplexMapKeysInDifferentOrderTest.java
@@ -0,0 +1,74 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.multibindings;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.auto.value.AutoAnnotation;
+import dagger.Component;
+import dagger.MapKey;
+import dagger.Module;
+import dagger.Provides;
+import dagger.multibindings.IntoMap;
+import java.util.Map;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public final class ComplexMapKeysInDifferentOrderTest {
+  @MapKey(unwrapValue = false)
+  @interface ComplexMapKey {
+    int i();
+    int j();
+  }
+
+  @Module
+  interface TestModule {
+    @Provides
+    @IntoMap
+    @ComplexMapKey(i = 1, j = 2)
+    static int inOrder() {
+      return 3;
+    }
+
+    @Provides
+    @IntoMap
+    @ComplexMapKey(j = 4, i = 5)
+    static int backwardsOrder() {
+      return 6;
+    }
+  }
+
+  @Component(modules = TestModule.class)
+  interface TestComponent {
+    Map<ComplexMapKey, Integer> map();
+  }
+
+  @Test
+  public void test() {
+    Map<ComplexMapKey, Integer> map =
+        DaggerComplexMapKeysInDifferentOrderTest_TestComponent.create().map();
+    assertThat(map.get(mapKey(1, 2))).isEqualTo(3);
+    assertThat(map.get(mapKey(5, 4))).isEqualTo(6);
+  }
+
+  @AutoAnnotation
+  static ComplexMapKey mapKey(int i, int j) {
+    return new AutoAnnotation_ComplexMapKeysInDifferentOrderTest_mapKey(i, j);
+  }
+}
diff --git a/javatests/dagger/functional/multibindings/MapKeyWithDefaultTest.java b/javatests/dagger/functional/multibindings/MapKeyWithDefaultTest.java
new file mode 100644
index 000000000..f1884052a
--- /dev/null
+++ b/javatests/dagger/functional/multibindings/MapKeyWithDefaultTest.java
@@ -0,0 +1,74 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.multibindings;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.auto.value.AutoAnnotation;
+import dagger.Component;
+import dagger.MapKey;
+import dagger.Module;
+import dagger.Provides;
+import dagger.multibindings.IntoMap;
+import java.util.Map;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public final class MapKeyWithDefaultTest {
+  @MapKey(unwrapValue = false)
+  @interface MapKeyWithDefault {
+    boolean hasDefault() default true;
+    boolean required();
+  }
+
+  @Module
+  interface TestModule {
+    @Provides
+    @IntoMap
+    @MapKeyWithDefault(required = false)
+    static int justRequired() {
+      return 1;
+    }
+
+    @Provides
+    @IntoMap
+    @MapKeyWithDefault(required = false, hasDefault = false)
+    static int both() {
+      return 2;
+    }
+  }
+
+  @Component(modules = TestModule.class)
+  interface TestComponent {
+    Map<MapKeyWithDefault, Integer> map();
+  }
+
+  @Test
+  public void test() {
+    Map<MapKeyWithDefault, Integer> map = DaggerMapKeyWithDefaultTest_TestComponent.create().map();
+    assertThat(map).hasSize(2);
+    assertThat(map.get(mapKey(true, false))).isEqualTo(1);
+    assertThat(map.get(mapKey(false, false))).isEqualTo(2);
+  }
+
+  @AutoAnnotation
+  static MapKeyWithDefault mapKey(boolean hasDefault, boolean required) {
+    return new AutoAnnotation_MapKeyWithDefaultTest_mapKey(hasDefault, required);
+  }
+}
diff --git a/javatests/dagger/functional/multipackage/PrimitivesAcrossPackagesComponent.java b/javatests/dagger/functional/multipackage/PrimitivesAcrossPackagesComponent.java
new file mode 100644
index 000000000..639558f7a
--- /dev/null
+++ b/javatests/dagger/functional/multipackage/PrimitivesAcrossPackagesComponent.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.multipackage;
+
+import dagger.Component;
+import dagger.functional.multipackage.primitives.PrimitiveAcrossPackagesModule;
+import javax.inject.Provider;
+
+// b/77150738#comment11
+@Component(modules = PrimitiveAcrossPackagesModule.class)
+interface PrimitivesAcrossPackagesComponent {
+  boolean primitive();
+
+  Provider<Boolean> boxedPrimitive();
+}
diff --git a/javatests/dagger/functional/multipackage/primitives/PrimitiveAcrossPackagesModule.java b/javatests/dagger/functional/multipackage/primitives/PrimitiveAcrossPackagesModule.java
new file mode 100644
index 000000000..1e6e36203
--- /dev/null
+++ b/javatests/dagger/functional/multipackage/primitives/PrimitiveAcrossPackagesModule.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.multipackage.primitives;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+public final class PrimitiveAcrossPackagesModule {
+  // This method should be package-private so that a proxy method is created
+  @Provides
+  static boolean primitive() {
+    return false;
+  }
+}
diff --git a/javatests/dagger/internal/codegen/BindsInstanceValidationTest.java b/javatests/dagger/internal/codegen/BindsInstanceValidationTest.java
new file mode 100644
index 000000000..063cd738f
--- /dev/null
+++ b/javatests/dagger/internal/codegen/BindsInstanceValidationTest.java
@@ -0,0 +1,165 @@
+/*
+ * Copyright (C) 2014 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
+
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public final class BindsInstanceValidationTest {
+  @Test
+  public void bindsInstanceInModule() {
+    JavaFileObject testModule =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.BindsInstance;",
+            "import dagger.Module;",
+            "",
+            "@Module",
+            "abstract class TestModule {",
+            "  @BindsInstance abstract void str(String string);",
+            "}");
+    Compilation compilation = daggerCompiler().compile(testModule);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "@BindsInstance methods should not be included in @Modules. Did you mean @Binds");
+  }
+
+  @Test
+  public void bindsInstanceInComponent() {
+    JavaFileObject testComponent =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.BindsInstance;",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface TestComponent {",
+            "  @BindsInstance String s(String s);",
+            "}");
+    Compilation compilation = daggerCompiler().compile(testComponent);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "@BindsInstance methods should not be included in @Components. "
+                + "Did you mean to put it in a @Component.Builder?");
+  }
+
+  @Test
+  public void bindsInstanceNotAbstract() {
+    JavaFileObject notAbstract =
+        JavaFileObjects.forSourceLines(
+            "test.BindsInstanceNotAbstract",
+            "package test;",
+            "",
+            "import dagger.BindsInstance;",
+            "import dagger.Component;",
+            "",
+            "class BindsInstanceNotAbstract {",
+            "  @BindsInstance BindsInstanceNotAbstract bind(int unused) { return this; }",
+            "}");
+    Compilation compilation = daggerCompiler().compile(notAbstract);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("@BindsInstance methods must be abstract")
+        .inFile(notAbstract)
+        .onLine(7);
+  }
+
+  @Test
+  public void bindsInstanceNoParameters() {
+    JavaFileObject notAbstract =
+        JavaFileObjects.forSourceLines(
+            "test.BindsInstanceNoParameters",
+            "package test;",
+            "",
+            "import dagger.BindsInstance;",
+            "",
+            "interface BindsInstanceNoParameters {",
+            "  @BindsInstance void noParams();",
+            "}");
+    Compilation compilation = daggerCompiler().compile(notAbstract);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "@BindsInstance methods should have exactly one parameter for the bound type")
+        .inFile(notAbstract)
+        .onLine(6);
+  }
+
+  @Test
+  public void bindsInstanceManyParameters() {
+    JavaFileObject notAbstract =
+        JavaFileObjects.forSourceLines(
+            "test.BindsInstanceNoParameter",
+            "package test;",
+            "",
+            "import dagger.BindsInstance;",
+            "",
+            "interface BindsInstanceManyParameters {",
+            "  @BindsInstance void manyParams(int i, long l);",
+            "}");
+    Compilation compilation = daggerCompiler().compile(notAbstract);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "@BindsInstance methods should have exactly one parameter for the bound type")
+        .inFile(notAbstract)
+        .onLine(6);
+  }
+
+  @Test
+  public void bindsInstanceFrameworkType() {
+    JavaFileObject bindsFrameworkType =
+        JavaFileObjects.forSourceLines(
+            "test.BindsInstanceFrameworkType",
+            "package test;",
+            "",
+            "import dagger.BindsInstance;",
+            "import dagger.producers.Producer;",
+            "import javax.inject.Provider;",
+            "",
+            "interface BindsInstanceFrameworkType {",
+            "  @BindsInstance void bindsProvider(Provider<Object> objectProvider);",
+            "  @BindsInstance void bindsProducer(Producer<Object> objectProducer);",
+            "}");
+    Compilation compilation = daggerCompiler().compile(bindsFrameworkType);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("@BindsInstance parameters may not be framework types")
+        .inFile(bindsFrameworkType)
+        .onLine(8);
+
+    assertThat(compilation)
+        .hadErrorContaining("@BindsInstance parameters may not be framework types")
+        .inFile(bindsFrameworkType)
+        .onLine(9);
+  }
+
+}
diff --git a/javatests/dagger/internal/codegen/ComponentProcessorTest.java b/javatests/dagger/internal/codegen/ComponentProcessorTest.java
index 312a918e4..851b92bd7 100644
--- a/javatests/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/javatests/dagger/internal/codegen/ComponentProcessorTest.java
@@ -50,7 +50,6 @@
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
 import javax.tools.JavaFileObject;
-import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
@@ -74,97 +73,6 @@ public ComponentProcessorTest(CompilerMode compilerMode) {
   private static final CodeBlock NPE_FROM_PROVIDES_METHOD =
       stringLiteral(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD);
 
-  @Test public void componentOnConcreteClass() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.NotAComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component",
-        "final class NotAComponent {}");
-    Compilation compilation =
-        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining("interface");
-  }
-
-  @Test public void componentOnEnum() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.NotAComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component",
-        "enum NotAComponent {",
-        "  INSTANCE",
-        "}");
-    Compilation compilation =
-        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining("interface");
-  }
-
-  @Test public void componentOnAnnotation() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.NotAComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component",
-        "@interface NotAComponent {}");
-    Compilation compilation =
-        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining("interface");
-  }
-
-  @Test public void nonModuleModule() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.NotAComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component(modules = Object.class)",
-        "interface NotAComponent {}");
-    Compilation compilation =
-        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining("is not annotated with @Module");
-  }
-
-  @Test
-  public void componentWithInvalidModule() {
-    JavaFileObject module =
-        JavaFileObjects.forSourceLines(
-            "test.BadModule",
-            "package test;",
-            "",
-            "import dagger.Binds;",
-            "import dagger.Module;",
-            "",
-            "@Module",
-            "abstract class BadModule {",
-            "  @Binds abstract Object noParameters();",
-            "}");
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.BadComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component(modules = BadModule.class)",
-            "interface BadComponent {",
-            "  Object object();",
-            "}");
-    Compilation compilation =
-        daggerCompiler().withOptions(compilerMode.javacopts()).compile(module, component);
-    assertThat(compilation)
-        .hadErrorContaining("test.BadModule has errors")
-        .inFile(component)
-        .onLine(5);
-  }
-
   @Test public void doubleBindingFromResolvedModules() {
     JavaFileObject parent = JavaFileObjects.forSourceLines("test.ParentModule",
         "package test;",
@@ -2126,29 +2034,6 @@ public void scopeAnnotationOnInjectConstructorNotValid() {
         .onLine(6);
   }
 
-  @Test
-  public void attemptToInjectWildcardGenerics() {
-    JavaFileObject testComponent =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import dagger.Lazy;",
-            "import javax.inject.Provider;",
-            "",
-            "@Component",
-            "interface TestComponent {",
-            "  Lazy<? extends Number> wildcardNumberLazy();",
-            "  Provider<? super Number> wildcardNumberProvider();",
-            "}");
-    Compilation compilation =
-        daggerCompiler().withOptions(compilerMode.javacopts()).compile(testComponent);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining("wildcard type").inFile(testComponent).onLine(9);
-    assertThat(compilation).hadErrorContaining("wildcard type").inFile(testComponent).onLine(10);
-  }
-
   @Test
   public void unusedSubcomponents_dontResolveExtraBindingsInParentComponents() {
     JavaFileObject foo =
@@ -2248,212 +2133,6 @@ public void unusedSubcomponents_dontResolveExtraBindingsInParentComponents() {
         .hasSourceEquivalentTo(generated);
   }
 
-  // TODO(b/34107586): Fix and enable test.
-  @Test
-  @Ignore
-  public void invalidComponentDependencies() {
-    JavaFileObject testComponent =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component(dependencies = int.class)",
-            "interface TestComponent {}");
-    Compilation compilation =
-        daggerCompiler().withOptions(compilerMode.javacopts()).compile(testComponent);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining("int is not a valid component dependency type");
-  }
-
-  @Test
-  public void invalidComponentModules() {
-    JavaFileObject testComponent =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component(modules = int.class)",
-            "interface TestComponent {}");
-    Compilation compilation =
-        daggerCompiler().withOptions(compilerMode.javacopts()).compile(testComponent);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining("int is not a valid module type");
-  }
-
-  @Test
-  public void moduleInDependencies() {
-    JavaFileObject testModule =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "final class TestModule {",
-            "  @Provides String s() { return null; }",
-            "}");
-    JavaFileObject testComponent =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component(dependencies = TestModule.class)",
-            "interface TestComponent {}");
-    Compilation compilation =
-        daggerCompiler().withOptions(compilerMode.javacopts()).compile(testModule, testComponent);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining("test.TestModule is a module, which cannot be a component dependency");
-  }
-
-  @Test
-  public void bindsInstanceInModule() {
-    JavaFileObject testModule =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.BindsInstance;",
-            "import dagger.Module;",
-            "",
-            "@Module",
-            "abstract class TestModule {",
-            "  @BindsInstance abstract void str(String string);",
-            "}");
-    Compilation compilation =
-        daggerCompiler().withOptions(compilerMode.javacopts()).compile(testModule);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            "@BindsInstance methods should not be included in @Modules. Did you mean @Binds");
-  }
-
-  @Test
-  public void bindsInstanceInComponent() {
-    JavaFileObject testComponent =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.BindsInstance;",
-            "import dagger.Component;",
-            "",
-            "@Component",
-            "interface TestComponent {",
-            "  @BindsInstance String s(String s);",
-            "}");
-    Compilation compilation =
-        daggerCompiler().withOptions(compilerMode.javacopts()).compile(testComponent);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            "@BindsInstance methods should not be included in @Components. "
-                + "Did you mean to put it in a @Component.Builder?");
-  }
-
-  @Test
-  public void bindsInstanceNotAbstract() {
-    JavaFileObject notAbstract =
-        JavaFileObjects.forSourceLines(
-            "test.BindsInstanceNotAbstract",
-            "package test;",
-            "",
-            "import dagger.BindsInstance;",
-            "import dagger.Component;",
-            "",
-            "class BindsInstanceNotAbstract {",
-            "  @BindsInstance BindsInstanceNotAbstract bind(int unused) { return this; }",
-            "}");
-    Compilation compilation =
-        daggerCompiler().withOptions(compilerMode.javacopts()).compile(notAbstract);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining("@BindsInstance methods must be abstract")
-        .inFile(notAbstract)
-        .onLine(7);
-  }
-
-  @Test
-  public void bindsInstanceNoParameters() {
-    JavaFileObject notAbstract =
-        JavaFileObjects.forSourceLines(
-            "test.BindsInstanceNoParameters",
-            "package test;",
-            "",
-            "import dagger.BindsInstance;",
-            "",
-            "interface BindsInstanceNoParameters {",
-            "  @BindsInstance void noParams();",
-            "}");
-    Compilation compilation =
-        daggerCompiler().withOptions(compilerMode.javacopts()).compile(notAbstract);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            "@BindsInstance methods should have exactly one parameter for the bound type")
-        .inFile(notAbstract)
-        .onLine(6);
-  }
-
-  @Test
-  public void bindsInstanceManyParameters() {
-    JavaFileObject notAbstract =
-        JavaFileObjects.forSourceLines(
-            "test.BindsInstanceNoParameter",
-            "package test;",
-            "",
-            "import dagger.BindsInstance;",
-            "",
-            "interface BindsInstanceManyParameters {",
-            "  @BindsInstance void manyParams(int i, long l);",
-            "}");
-    Compilation compilation =
-        daggerCompiler().withOptions(compilerMode.javacopts()).compile(notAbstract);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            "@BindsInstance methods should have exactly one parameter for the bound type")
-        .inFile(notAbstract)
-        .onLine(6);
-  }
-
-  @Test
-  public void bindsInstanceFrameworkType() {
-    JavaFileObject bindsFrameworkType =
-        JavaFileObjects.forSourceLines(
-            "test.BindsInstanceFrameworkType",
-            "package test;",
-            "",
-            "import dagger.BindsInstance;",
-            "import dagger.producers.Producer;",
-            "import javax.inject.Provider;",
-            "",
-            "interface BindsInstanceFrameworkType {",
-            "  @BindsInstance void bindsProvider(Provider<Object> objectProvider);",
-            "  @BindsInstance void bindsProducer(Producer<Object> objectProducer);",
-            "}");
-    Compilation compilation =
-        daggerCompiler().withOptions(compilerMode.javacopts()).compile(bindsFrameworkType);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining("@BindsInstance parameters may not be framework types")
-        .inFile(bindsFrameworkType)
-        .onLine(8);
-
-    assertThat(compilation)
-        .hadErrorContaining("@BindsInstance parameters may not be framework types")
-        .inFile(bindsFrameworkType)
-        .onLine(9);
-  }
-
   @Test
   public void bindsToDuplicateBinding_bindsKeyIsNotDuplicated() {
     JavaFileObject firstModule =
diff --git a/javatests/dagger/internal/codegen/ComponentRequirementFieldTest.java b/javatests/dagger/internal/codegen/ComponentRequirementFieldTest.java
index 0121acc59..962e5e11d 100644
--- a/javatests/dagger/internal/codegen/ComponentRequirementFieldTest.java
+++ b/javatests/dagger/internal/codegen/ComponentRequirementFieldTest.java
@@ -285,31 +285,7 @@ public void componentInstances() {
                 "        dep.object(), " + NPE_FROM_COMPONENT_METHOD + " );",
                 "  }",
                 "",
-                "  @Override",
-                "  public TestSubcomponent subcomponent() {",
-                "    return new TestSubcomponentImpl();",
-                "  }",
-                "",
-                "  public static final class Builder {",
-                "    private Dep dep;",
-                "",
-                "    public TestComponent build() {",
-                "      if (dep == null) {",
-                "        throw new IllegalStateException(",
-                "            Dep.class.getCanonicalName() + \" must be set\");",
-                "      }",
-                "      return new DaggerTestComponent(this);",
-                "    }",
-                "",
-                "    public Builder dep(Dep dep) {",
-                "      this.dep = Preconditions.checkNotNull(dep);",
-                "      return this;",
-                "    }",
-                "  }",
-                "",
                 "  private final class TestSubcomponentImpl implements TestSubcomponent {",
-                "    private TestSubcomponentImpl() {}",
-                "",
                 "    @Override",
                 "    public TestComponent parent() {",
                 "      return DaggerTestComponent.this;",
@@ -402,11 +378,6 @@ public void componentRequirementNeededInFactoryCreationOfSubcomponent() {
                 "    this.parentModule = builder.parentModule;",
                 "  }",
                 "",
-                "  @Override",
-                "  public TestSubcomponent subcomponent() {",
-                "    return new TestSubcomponentImpl();",
-                "  }",
-                "",
                 "  private final class TestSubcomponentImpl implements TestSubcomponent {",
                 "    private Set<Object> getSetOfObject() {",
                 "      return ImmutableSet.<Object>of(",
@@ -443,11 +414,6 @@ public void componentRequirementNeededInFactoryCreationOfSubcomponent() {
                 "    this.parentModule = builder.parentModule;",
                 "  }",
                 "",
-                "  @Override",
-                "  public TestSubcomponent subcomponent() {",
-                "    return new TestSubcomponentImpl();",
-                "  }",
-                "",
                 "  private final class TestSubcomponentImpl implements TestSubcomponent {",
                 "    @SuppressWarnings(\"unchecked\")",
                 "    private void initialize() {",
diff --git a/javatests/dagger/internal/codegen/ComponentValidationTest.java b/javatests/dagger/internal/codegen/ComponentValidationTest.java
new file mode 100644
index 000000000..5a84052b9
--- /dev/null
+++ b/javatests/dagger/internal/codegen/ComponentValidationTest.java
@@ -0,0 +1,204 @@
+/*
+ * Copyright (C) 2014 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
+
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Ignore;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public final class ComponentValidationTest {
+  @Test
+  public void componentOnConcreteClass() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.NotAComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "final class NotAComponent {}");
+    Compilation compilation = daggerCompiler().compile(componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("interface");
+  }
+
+  @Test public void componentOnEnum() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.NotAComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "enum NotAComponent {",
+        "  INSTANCE",
+        "}");
+    Compilation compilation = daggerCompiler().compile(componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("interface");
+  }
+
+  @Test public void componentOnAnnotation() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.NotAComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "@interface NotAComponent {}");
+    Compilation compilation = daggerCompiler().compile(componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("interface");
+  }
+
+  @Test public void nonModuleModule() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.NotAComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component(modules = Object.class)",
+        "interface NotAComponent {}");
+    Compilation compilation = daggerCompiler().compile(componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("is not annotated with @Module");
+  }
+
+  @Test
+  public void componentWithInvalidModule() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.BadModule",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "import dagger.Module;",
+            "",
+            "@Module",
+            "abstract class BadModule {",
+            "  @Binds abstract Object noParameters();",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.BadComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = BadModule.class)",
+            "interface BadComponent {",
+            "  Object object();",
+            "}");
+    Compilation compilation = daggerCompiler().compile(module, component);
+    assertThat(compilation)
+        .hadErrorContaining("test.BadModule has errors")
+        .inFile(component)
+        .onLine(5);
+  }
+
+  @Test
+  public void attemptToInjectWildcardGenerics() {
+    JavaFileObject testComponent =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Lazy;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "interface TestComponent {",
+            "  Lazy<? extends Number> wildcardNumberLazy();",
+            "  Provider<? super Number> wildcardNumberProvider();",
+            "}");
+    Compilation compilation = daggerCompiler().compile(testComponent);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("wildcard type").inFile(testComponent).onLine(9);
+    assertThat(compilation).hadErrorContaining("wildcard type").inFile(testComponent).onLine(10);
+  }
+
+  // TODO(b/34107586): Fix and enable test.
+  @Test
+  @Ignore
+  public void invalidComponentDependencies() {
+    JavaFileObject testComponent =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(dependencies = int.class)",
+            "interface TestComponent {}");
+    Compilation compilation = daggerCompiler().compile(testComponent);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("int is not a valid component dependency type");
+  }
+
+  @Test
+  public void invalidComponentModules() {
+    JavaFileObject testComponent =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = int.class)",
+            "interface TestComponent {}");
+    Compilation compilation = daggerCompiler().compile(testComponent);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("int is not a valid module type");
+  }
+
+  @Test
+  public void moduleInDependencies() {
+    JavaFileObject testModule =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "final class TestModule {",
+            "  @Provides String s() { return null; }",
+            "}");
+    JavaFileObject testComponent =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(dependencies = TestModule.class)",
+            "interface TestComponent {}");
+    Compilation compilation = daggerCompiler().compile(testModule, testComponent);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("test.TestModule is a module, which cannot be a component dependency");
+  }
+
+}
diff --git a/javatests/dagger/internal/codegen/DelegateBindingExpressionTest.java b/javatests/dagger/internal/codegen/DelegateBindingExpressionTest.java
index 2be29852b..8ed23d776 100644
--- a/javatests/dagger/internal/codegen/DelegateBindingExpressionTest.java
+++ b/javatests/dagger/internal/codegen/DelegateBindingExpressionTest.java
@@ -818,27 +818,25 @@ public void castedToRawType() {
                     "}")
                 .addLinesIn(
                     EXPERIMENTAL_ANDROID_MODE,
-                    "  private volatile Provider<CharSequence> charSequenceProvider;",
-                    "  private volatile Provider<String> namedStringProvider;",
+                    "  private volatile Provider<String> provideStringProvider;",
                     "",
-                    "  @Override",
-                    "  public Provider<CharSequence> charSequence() {",
-                    "    Object local = charSequenceProvider;",
+                    "  private Provider<String> getStringProvider() {",
+                    "    Object local = provideStringProvider;",
                     "    if (local == null) {",
                     "      local = new SwitchingProvider<>(0);",
-                    "      charSequenceProvider = (Provider<CharSequence>) local;",
+                    "      provideStringProvider = (Provider<String>) local;",
                     "    }",
-                    "    return (Provider<CharSequence>) local;",
+                    "    return (Provider<String>) local;",
+                    "  }",
+                    "",
+                    "  @Override",
+                    "  public Provider<CharSequence> charSequence() {",
+                    "    return (Provider) getStringProvider();",
                     "  }",
                     "",
                     "  @Override",
                     "  public Provider<String> namedString() {",
-                    "    Object local = namedStringProvider;",
-                    "    if (local == null) {",
-                    "      local = new SwitchingProvider<>(1);",
-                    "      namedStringProvider = (Provider<String>) local;",
-                    "    }",
-                    "    return (Provider<String>) local;",
+                    "    return getStringProvider();",
                     "  }",
                     "",
                     "  private final class SwitchingProvider<T> implements Provider<T> {",
@@ -846,11 +844,8 @@ public void castedToRawType() {
                     "    @Override",
                     "    public T get() {",
                     "      switch (id) {",
-                    // TODO(cl/189031410): Dedupe identical cases in SwitchingProviders.
                     "        case 0:",
                     "            return (T) TestModule_ProvideStringFactory.proxyProvideString();",
-                    "        case 1:",
-                    "            return (T) TestModule_ProvideStringFactory.proxyProvideString();",
                     "        default:",
                     "            throw new AssertionError(id);",
                     "      }",
@@ -924,27 +919,25 @@ public void doubleBinds() {
                     "}")
                 .addLinesIn(
                     EXPERIMENTAL_ANDROID_MODE,
-                    "  private volatile Provider<CharSequence> charSequenceProvider;",
-                    "  private volatile Provider<Object> objectProvider;",
+                    "  private volatile Provider<String> provideStringProvider;",
                     "",
-                    "  @Override",
-                    "  public Provider<CharSequence> charSequence() {",
-                    "    Object local = charSequenceProvider;",
+                    "  private Provider<String> getStringProvider() {",
+                    "    Object local = provideStringProvider;",
                     "    if (local == null) {",
                     "      local = new SwitchingProvider<>(0);",
-                    "      charSequenceProvider = (Provider<CharSequence>) local;",
+                    "      provideStringProvider = (Provider<String>) local;",
                     "    }",
-                    "    return (Provider<CharSequence>) local;",
+                    "    return (Provider<String>) local;",
+                    "  }",
+                    "",
+                    "  @Override",
+                    "  public Provider<CharSequence> charSequence() {",
+                    "    return (Provider) getStringProvider();",
                     "  }",
                     "",
                     "  @Override",
                     "  public Provider<Object> object() {",
-                    "    Object local = objectProvider;",
-                    "    if (local == null) {",
-                    "      local = new SwitchingProvider<>(1);",
-                    "      objectProvider = (Provider<Object>) local;",
-                    "    }",
-                    "    return (Provider<Object>) local;",
+                    "    return (Provider) getStringProvider();",
                     "  }",
                     "",
                     "  private final class SwitchingProvider<T> implements Provider<T> {",
@@ -954,8 +947,6 @@ public void doubleBinds() {
                     "      switch (id) {",
                     "        case 0:",
                     "            return (T) TestModule_ProvideStringFactory.proxyProvideString();",
-                    "        case 1:",
-                    "            return (T) TestModule_ProvideStringFactory.proxyProvideString();",
                     "        default:",
                     "            throw new AssertionError(id);",
                     "      }",
@@ -1031,16 +1022,20 @@ public void inlineFactoryOfInacessibleType() {
                     "}")
                 .addLinesIn(
                     EXPERIMENTAL_ANDROID_MODE,
-                    "  private volatile Provider<Supertype> toProvider;",
+                    "  private volatile Provider subtypeProvider;",
                     "",
-                    "  @Override",
-                    "  public Provider<Supertype> supertypeProvider() {",
-                    "    Object local = toProvider;",
+                    "  private Provider getSubtypeProvider() {",
+                    "    Object local = subtypeProvider;",
                     "    if (local == null) {",
                     "      local = new SwitchingProvider<>(0);",
-                    "      toProvider = (Provider<Supertype>) local;",
+                    "      subtypeProvider = (Provider) local;",
                     "    }",
-                    "    return (Provider<Supertype>) local;",
+                    "    return (Provider) local;",
+                    "  }",
+                    "",
+                    "  @Override",
+                    "  public Provider<Supertype> supertypeProvider() {",
+                    "    return getSubtypeProvider();",
                     "  }",
                     "",
                     "  private final class SwitchingProvider<T> implements Provider<T> {",
diff --git a/javatests/dagger/internal/codegen/ErrorMessagesTest.java b/javatests/dagger/internal/codegen/DiagnosticFormattingTest.java
similarity index 91%
rename from javatests/dagger/internal/codegen/ErrorMessagesTest.java
rename to javatests/dagger/internal/codegen/DiagnosticFormattingTest.java
index 4d50d4413..a2da92f57 100644
--- a/javatests/dagger/internal/codegen/ErrorMessagesTest.java
+++ b/javatests/dagger/internal/codegen/DiagnosticFormattingTest.java
@@ -23,9 +23,10 @@
 import org.junit.runners.JUnit4;
 
 @RunWith(JUnit4.class)
-public class ErrorMessagesTest {
+public class DiagnosticFormattingTest {
   @Test public void stripCommonTypePrefixes() {
     String typeName = "com.google.common.collect.ImmutableList<java.lang.Boolean>";
-    assertThat(DiagnosticFormatting.stripCommonTypePrefixes(typeName)).isEqualTo("ImmutableList<Boolean>");
+    assertThat(DiagnosticFormatting.stripCommonTypePrefixes(typeName))
+        .isEqualTo("ImmutableList<Boolean>");
   }
 }
diff --git a/javatests/dagger/internal/codegen/GraphValidationTest.java b/javatests/dagger/internal/codegen/GraphValidationTest.java
index 93f1df27c..1d0d0c110 100644
--- a/javatests/dagger/internal/codegen/GraphValidationTest.java
+++ b/javatests/dagger/internal/codegen/GraphValidationTest.java
@@ -208,7 +208,7 @@ public void membersInjectDependsOnUnboundedType() {
                     "      dagger.MembersInjector<java.util.ArrayList<?>> is injected at",
                     "          test.InjectsUnboundedType.listInjector",
                     "      test.InjectsUnboundedType is injected at",
-                    "          test.TestComponent.injectsUnboundedType(injects)"))
+                    "          test.TestComponent.injectsUnboundedType(test.InjectsUnboundedType)"))
         .in(component)
         .onLine(7);
   }
@@ -859,17 +859,18 @@ public void cycleFromMembersInjectionMethod_WithSameKeyAsMembersInjectionMethod(
     Compilation compilation = daggerCompiler().compile(a, b, component);
     assertThat(compilation).failed();
     assertThat(compilation)
-        .hadErrorContaining(Joiner.on('\n')
-            .join(
-                "Found a dependency cycle:",
-                "      test.B is injected at",
-                "          test.A.b",
-                "      test.A is injected at",
-                "          test.B.a",
-                "      test.B is injected at",
-                "          test.A.b",
-                "      test.A is injected at",
-                "          test.CycleComponent.inject(a)"))
+        .hadErrorContaining(
+            Joiner.on('\n')
+                .join(
+                    "Found a dependency cycle:",
+                    "      test.B is injected at",
+                    "          test.A.b",
+                    "      test.A is injected at",
+                    "          test.B.a",
+                    "      test.B is injected at",
+                    "          test.A.b",
+                    "      test.A is injected at",
+                    "          test.CycleComponent.inject(test.A)"))
         .inFile(component)
         .onLineContaining("void inject(A a);");
   }
@@ -942,9 +943,11 @@ public void missingBindingWithSameKeyAsMembersInjectionMethod() {
         "  }",
         "}");
 
-    String expectedError = "test.Outer.A is bound multiple times:\n"
-        + "      test.Outer.A test.Outer.Parent.getA()\n"
-        + "      @Provides test.Outer.A test.Outer.AModule.provideA(String)";
+    String expectedError =
+        error(
+            "test.Outer.A is bound multiple times:",
+            "@Provides test.Outer.A test.Outer.AModule.provideA(String)",
+            "test.Outer.A test.Outer.Parent.getA()");
 
     assertAbout(javaSource()).that(component)
         .processedWith(new ComponentProcessor())
@@ -1100,27 +1103,29 @@ public void duplicateExplicitBindings_ProvidesVsBinds() {
         "}");
 
     String expectedSetError =
-        "java.util.Set<java.lang.String> has incompatible bindings or declarations:\n"
-            + "      Set bindings and declarations:\n"
-            + "          @Provides @dagger.multibindings.IntoSet String "
-            + "test.Outer.TestModule1.stringSetElement()\n"
-            + "          @Binds @dagger.multibindings.IntoSet String "
-            + "test.Outer.TestModule1.bindStringSetElement(@test.Outer.SomeQualifier String)\n"
-            + "      Unique bindings and declarations:\n"
-            + "          @Provides Set<String> test.Outer.TestModule2.stringSet()";
+        error(
+            "java.util.Set<java.lang.String> has incompatible bindings or declarations:",
+            "Set bindings and declarations:",
+            "    @Binds @dagger.multibindings.IntoSet String "
+                + "test.Outer.TestModule1.bindStringSetElement(@test.Outer.SomeQualifier String)",
+            "    @Provides @dagger.multibindings.IntoSet String "
+                + "test.Outer.TestModule1.stringSetElement()",
+            "Unique bindings and declarations:",
+            "    @Provides Set<String> test.Outer.TestModule2.stringSet()");
 
     String expectedMapError =
-        "java.util.Map<java.lang.String,java.lang.String> has incompatible bindings "
-            + "or declarations:\n"
-            + "      Map bindings and declarations:\n"
-            + "          @Provides @dagger.multibindings.IntoMap "
-            + "@test.Outer.StringKey(\"foo\") String"
-            + " test.Outer.TestModule1.stringMapEntry()\n"
-            + "          @Binds @dagger.multibindings.IntoMap "
-            + "@test.Outer.StringKey(\"bar\") String"
-            + " test.Outer.TestModule1.bindStringMapEntry(@test.Outer.SomeQualifier String)\n"
-            + "      Unique bindings and declarations:\n"
-            + "          @Provides Map<String,String> test.Outer.TestModule2.stringMap()";
+        error(
+            "java.util.Map<java.lang.String,java.lang.String> has incompatible bindings "
+                + "or declarations:",
+            "Map bindings and declarations:",
+            "    @Binds @dagger.multibindings.IntoMap "
+                + "@test.Outer.StringKey(\"bar\") String"
+                + " test.Outer.TestModule1.bindStringMapEntry(@test.Outer.SomeQualifier String)",
+            "    @Provides @dagger.multibindings.IntoMap "
+                + "@test.Outer.StringKey(\"foo\") String"
+                + " test.Outer.TestModule1.stringMapEntry()",
+            "Unique bindings and declarations:",
+            "    @Provides Map<String,String> test.Outer.TestModule2.stringMap()");
 
     assertAbout(javaSource())
         .that(component)
@@ -1207,113 +1212,117 @@ public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration()
   }
 
   @Test public void duplicateBindings_TruncateAfterLimit() {
-    JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import javax.inject.Inject;",
-        "",
-        "final class Outer {",
-        "  interface A {}",
-        "",
-        "  @Module",
-        "  static class Module1 {",
-        "    @Provides A provideA() { return new A() {}; }",
-        "  }",
-        "",
-        "  @Module",
-        "  static class Module2 {",
-        "    @Provides A provideA() { return new A() {}; }",
-        "  }",
-        "",
-        "  @Module",
-        "  static class Module3 {",
-        "    @Provides A provideA() { return new A() {}; }",
-        "  }",
-        "",
-        "  @Module",
-        "  static class Module4 {",
-        "    @Provides A provideA() { return new A() {}; }",
-        "  }",
-        "",
-        "  @Module",
-        "  static class Module5 {",
-        "    @Provides A provideA() { return new A() {}; }",
-        "  }",
-        "",
-        "  @Module",
-        "  static class Module6 {",
-        "    @Provides A provideA() { return new A() {}; }",
-        "  }",
-        "",
-        "  @Module",
-        "  static class Module7 {",
-        "    @Provides A provideA() { return new A() {}; }",
-        "  }",
-        "",
-        "  @Module",
-        "  static class Module8 {",
-        "    @Provides A provideA() { return new A() {}; }",
-        "  }",
-        "",
-        "  @Module",
-        "  static class Module9 {",
-        "    @Provides A provideA() { return new A() {}; }",
-        "  }",
-        "",
-        "  @Module",
-        "  static class Module10 {",
-        "    @Provides A provideA() { return new A() {}; }",
-        "  }",
-        "",
-        "  @Module",
-        "  static class Module11 {",
-        "    @Provides A provideA() { return new A() {}; }",
-        "  }",
-        "",
-        "  @Module",
-        "  static class Module12 {",
-        "    @Provides A provideA() { return new A() {}; }",
-        "  }",
-        "",
-        "  @Component(modules = {",
-        "    Module1.class,",
-        "    Module2.class,",
-        "    Module3.class,",
-        "    Module4.class,",
-        "    Module5.class,",
-        "    Module6.class,",
-        "    Module7.class,",
-        "    Module8.class,",
-        "    Module9.class,",
-        "    Module10.class,",
-        "    Module11.class,",
-        "    Module12.class",
-        "  })",
-        "  interface TestComponent {",
-        "    A getA();",
-        "  }",
-        "}");
-
-    String expectedError = "test.Outer.A is bound multiple times:\n"
-        + "      @Provides test.Outer.A test.Outer.Module1.provideA()\n"
-        + "      @Provides test.Outer.A test.Outer.Module2.provideA()\n"
-        + "      @Provides test.Outer.A test.Outer.Module3.provideA()\n"
-        + "      @Provides test.Outer.A test.Outer.Module4.provideA()\n"
-        + "      @Provides test.Outer.A test.Outer.Module5.provideA()\n"
-        + "      @Provides test.Outer.A test.Outer.Module6.provideA()\n"
-        + "      @Provides test.Outer.A test.Outer.Module7.provideA()\n"
-        + "      @Provides test.Outer.A test.Outer.Module8.provideA()\n"
-        + "      @Provides test.Outer.A test.Outer.Module9.provideA()\n"
-        + "      @Provides test.Outer.A test.Outer.Module10.provideA()\n"
-        + "      and 2 others";
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.Outer",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import javax.inject.Inject;",
+            "",
+            "final class Outer {",
+            "  interface A {}",
+            "",
+            "  @Module",
+            "  static class Module01 {",
+            "    @Provides A provideA() { return new A() {}; }",
+            "  }",
+            "",
+            "  @Module",
+            "  static class Module02 {",
+            "    @Provides A provideA() { return new A() {}; }",
+            "  }",
+            "",
+            "  @Module",
+            "  static class Module03 {",
+            "    @Provides A provideA() { return new A() {}; }",
+            "  }",
+            "",
+            "  @Module",
+            "  static class Module04 {",
+            "    @Provides A provideA() { return new A() {}; }",
+            "  }",
+            "",
+            "  @Module",
+            "  static class Module05 {",
+            "    @Provides A provideA() { return new A() {}; }",
+            "  }",
+            "",
+            "  @Module",
+            "  static class Module06 {",
+            "    @Provides A provideA() { return new A() {}; }",
+            "  }",
+            "",
+            "  @Module",
+            "  static class Module07 {",
+            "    @Provides A provideA() { return new A() {}; }",
+            "  }",
+            "",
+            "  @Module",
+            "  static class Module08 {",
+            "    @Provides A provideA() { return new A() {}; }",
+            "  }",
+            "",
+            "  @Module",
+            "  static class Module09 {",
+            "    @Provides A provideA() { return new A() {}; }",
+            "  }",
+            "",
+            "  @Module",
+            "  static class Module10 {",
+            "    @Provides A provideA() { return new A() {}; }",
+            "  }",
+            "",
+            "  @Module",
+            "  static class Module11 {",
+            "    @Provides A provideA() { return new A() {}; }",
+            "  }",
+            "",
+            "  @Module",
+            "  static class Module12 {",
+            "    @Provides A provideA() { return new A() {}; }",
+            "  }",
+            "",
+            "  @Component(modules = {",
+            "    Module01.class,",
+            "    Module02.class,",
+            "    Module03.class,",
+            "    Module04.class,",
+            "    Module05.class,",
+            "    Module06.class,",
+            "    Module07.class,",
+            "    Module08.class,",
+            "    Module09.class,",
+            "    Module10.class,",
+            "    Module11.class,",
+            "    Module12.class",
+            "  })",
+            "  interface TestComponent {",
+            "    A getA();",
+            "  }",
+            "}");
 
-    assertAbout(javaSource()).that(component)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(expectedError).in(component).onLine(86);
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            error(
+                "test.Outer.A is bound multiple times:",
+                "@Provides test.Outer.A test.Outer.Module01.provideA()",
+                "@Provides test.Outer.A test.Outer.Module02.provideA()",
+                "@Provides test.Outer.A test.Outer.Module03.provideA()",
+                "@Provides test.Outer.A test.Outer.Module04.provideA()",
+                "@Provides test.Outer.A test.Outer.Module05.provideA()",
+                "@Provides test.Outer.A test.Outer.Module06.provideA()",
+                "@Provides test.Outer.A test.Outer.Module07.provideA()",
+                "@Provides test.Outer.A test.Outer.Module08.provideA()",
+                "@Provides test.Outer.A test.Outer.Module09.provideA()",
+                "@Provides test.Outer.A test.Outer.Module10.provideA()",
+                "and 2 others"))
+        .inFile(component)
+        .onLineContaining("getA();");
   }
 
   @Test public void longChainOfDependencies() {
@@ -1368,52 +1377,48 @@ public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration()
             "}");
     String errorText = "test.TestClass.A cannot be provided without an @Provides-annotated method.";
     String firstError =
-        Joiner.on("\n      ")
-            .join(
-                errorText,
-                "test.TestClass.A is injected at",
-                "    test.TestClass.B.<init>(a)",
-                "test.TestClass.B is injected at",
-                "    test.TestClass.C.b",
-                "test.TestClass.C is injected at",
-                "    test.TestClass.DImpl.<init>(c, …)",
-                "test.TestClass.DImpl is injected at",
-                "    test.TestClass.DModule.d(…, impl, …)",
-                "@javax.inject.Named(\"slim shady\") test.TestClass.D is provided at",
-                "    test.TestClass.AComponent.getFoo()");
+        error(
+            errorText,
+            "test.TestClass.A is injected at",
+            "    test.TestClass.B.<init>(a)",
+            "test.TestClass.B is injected at",
+            "    test.TestClass.DImpl.<init>(…, b)",
+            "test.TestClass.DImpl is injected at",
+            "    test.TestClass.DModule.d(…, impl, …)",
+            "@javax.inject.Named(\"slim shady\") test.TestClass.D is provided at",
+            "    test.TestClass.AComponent.getFoo()");
     String otherErrorFormat =
-        Joiner.on("\n      ")
-            .join(
-                errorText,
-                "test.TestClass.A is injected at",
-                "    test.TestClass.B.<init>(a)",
-                "test.TestClass.B is injected at",
-                "    test.TestClass.C.b",
-                "test.TestClass.C is %s at",
-                "    test.TestClass.AComponent.%s");
-    assertAbout(javaSource())
-        .that(component)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(firstError)
-        .in(component)
-        .onLine(40)
-        .and()
-        .withErrorContaining(String.format(otherErrorFormat, "injected", "injectC(c)"))
-        .in(component)
-        .onLine(41)
-        .and()
-        .withErrorContaining(String.format(otherErrorFormat, "provided", "cProvider()"))
-        .in(component)
-        .onLine(42)
-        .and()
-        .withErrorContaining(String.format(otherErrorFormat, "provided", "lazyC()"))
-        .in(component)
-        .onLine(43)
-        .and()
-        .withErrorContaining(String.format(otherErrorFormat, "provided", "lazyCProvider()"))
-        .in(component)
-        .onLine(44);
+        error(
+            errorText,
+            "test.TestClass.A is injected at",
+            "    test.TestClass.B.<init>(a)",
+            "test.TestClass.B is injected at",
+            "    test.TestClass.C.b",
+            "test.TestClass.C is %s at",
+            "    test.TestClass.AComponent.%s");
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(firstError)
+        .inFile(component)
+        .onLineContaining("getFoo();");
+    assertThat(compilation)
+        .hadErrorContaining(
+            String.format(otherErrorFormat, "injected", "injectC(test.TestClass.C)"))
+        .inFile(component)
+        .onLineContaining("injectC(C c);");
+    assertThat(compilation)
+        .hadErrorContaining(String.format(otherErrorFormat, "provided", "cProvider()"))
+        .inFile(component)
+        .onLineContaining("cProvider();");
+    assertThat(compilation)
+        .hadErrorContaining(String.format(otherErrorFormat, "provided", "lazyC()"))
+        .inFile(component)
+        .onLineContaining("lazyC();");
+    assertThat(compilation)
+        .hadErrorContaining(String.format(otherErrorFormat, "provided", "lazyCProvider()"))
+        .inFile(component)
+        .onLineContaining("lazyCProvider();");
   }
 
   @Test
@@ -1535,11 +1540,15 @@ public void bindsMissingRightHandSide() {
     Compilation compilation = daggerCompiler().compile(duplicates, component);
     assertThat(compilation).failed();
     assertThat(compilation)
-        .hadErrorContaining("test.Duplicates.BoundTwice is bound multiple times:")
-        .inFile(component)
-        .onLineContaining("boundTwice();");
-    assertThat(compilation)
-        .hadErrorContaining("test.Duplicates.DuplicatesModule.bindWithUnresolvedKey")
+        .hadErrorContaining(
+            error(
+                "test.Duplicates.BoundTwice is bound multiple times:",
+                "@Binds test.Duplicates.BoundTwice "
+                    + "test.Duplicates.DuplicatesModule"
+                    + ".bindWithResolvedKey(test.Duplicates.BoundImpl)",
+                "@Binds test.Duplicates.BoundTwice "
+                    + "test.Duplicates.DuplicatesModule"
+                    + ".bindWithUnresolvedKey(test.Duplicates.NotBound)"))
         .inFile(component)
         .onLineContaining("boundTwice();");
     assertThat(compilation)
@@ -1554,8 +1563,11 @@ public void bindsMissingRightHandSide() {
         .hadErrorContaining("test.Duplicates.NotBound cannot be provided")
         .inFile(component)
         .onLineContaining("intMap();");
+    // Some javacs report only the first error for each source line.
+    // Assert that one of the expected errors is reported.
     assertThat(compilation)
-        .hadErrorContaining("test.Duplicates.NotBound cannot be provided")
+        .hadErrorContainingMatch(
+            "test\\.Duplicates\\.NotBound cannot be provided|same map key is bound more than once")
         .inFile(component)
         .onLineContaining("longMap();");
   }
@@ -2091,178 +2103,197 @@ public void nullCheckForOptionalProviderOfLazy() {
   }
 
   @Test
-  public void subcomponentBindingConflictsWithParent() {
-    JavaFileObject parentChildConflict =
+  public void childBindingConflictsWithParent() {
+    JavaFileObject aComponent =
         JavaFileObjects.forSourceLines(
-            "test.ParentChildConflict",
+            "test.A",
             "package test;",
             "",
-            "import javax.inject.Qualifier;",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
             "",
-            "@Qualifier @interface ParentChildConflict {}");
-    JavaFileObject parentGrandchildConflict =
-        JavaFileObjects.forSourceLines(
-            "test.ParentGrandchildConflict",
-            "package test;",
+            "@Component(modules = A.AModule.class)",
+            "interface A {",
+            "  Object conflict();",
             "",
-            "import javax.inject.Qualifier;",
+            "  B b();",
             "",
-            "@Qualifier @interface ParentGrandchildConflict {}");
-    JavaFileObject childGrandchildConflict =
+            "  @Module",
+            "  static class AModule {",
+            "    @Provides static Object abConflict() {",
+            "      return \"a\";",
+            "    }",
+            "  }",
+            "}");
+    JavaFileObject bComponent =
         JavaFileObjects.forSourceLines(
-            "test.ChildGrandchildConflict",
+            "test.B",
             "package test;",
             "",
-            "import javax.inject.Qualifier;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = B.BModule.class)",
+            "interface B {",
+            "  Object conflict();",
             "",
-            "@Qualifier @interface ChildGrandchildConflict {}");
+            "  @Module",
+            "  static class BModule {",
+            "    @Provides static Object abConflict() {",
+            "      return \"b\";",
+            "    }",
+            "  }",
+            "}");
+    Compilation compilation = daggerCompiler().compile(aComponent, bComponent);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            error(
+                "[test.B.conflict()] java.lang.Object is bound multiple times:",
+                "@Provides Object test.A.AModule.abConflict()",
+                "@Provides Object test.B.BModule.abConflict()"))
+        .inFile(aComponent)
+        .onLineContaining("interface A {");
+  }
 
-    /* Some annotation processor implementations do not report more than one error per element. So
-     * separate parents for testing parent-conflicts-with-child and
-     * parent-conflicts-with-grandchild.
-     */
-    JavaFileObject parentConflictsWithChild =
+  @Test
+  public void grandchildBindingConflictsWithGrandparent() {
+    JavaFileObject aComponent =
         JavaFileObjects.forSourceLines(
-            "test.ParentConflictsWithChild",
+            "test.A",
             "package test;",
             "",
             "import dagger.Component;",
             "import dagger.Module;",
             "import dagger.Provides;",
             "",
-            "@Component(modules = ParentConflictsWithChild.ParentModule.class)",
-            "interface ParentConflictsWithChild {",
-            "  @ParentChildConflict Object parentChildConflict();",
+            "@Component(modules = A.AModule.class)",
+            "interface A {",
+            "  Object conflict();",
             "",
-            "  Child child();",
+            "  B b();",
             "",
             "  @Module",
-            "  static class ParentModule {",
-            "    @Provides @ParentChildConflict static Object parentChildConflict() {",
-            "      return \"parent\";",
+            "  static class AModule {",
+            "    @Provides static Object acConflict() {",
+            "      return \"a\";",
             "    }",
             "  }",
             "}");
-    JavaFileObject parentConflictsWithGrandchild =
+    JavaFileObject bComponent =
+        JavaFileObjects.forSourceLines(
+            "test.B",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface B {",
+            "  C c();",
+            "}");
+    JavaFileObject cComponent =
         JavaFileObjects.forSourceLines(
-            "test.ParentConflictsWithGrandchild",
+            "test.C",
             "package test;",
             "",
-            "import dagger.Component;",
             "import dagger.Module;",
             "import dagger.Provides;",
+            "import dagger.Subcomponent;",
             "",
-            "@Component(modules = ParentConflictsWithGrandchild.ParentModule.class)",
-            "interface ParentConflictsWithGrandchild {",
-            "  @ParentGrandchildConflict Object parentGrandchildConflict();",
-            "",
-            "  Child child();",
+            "@Subcomponent(modules = C.CModule.class)",
+            "interface C {",
+            "  Object conflict();",
             "",
             "  @Module",
-            "  static class ParentModule {",
-            "    @Provides @ParentGrandchildConflict static Object parentGrandchildConflict() {",
-            "      return \"parent\";",
+            "  static class CModule {",
+            "    @Provides static Object acConflict() {",
+            "      return \"c\";",
             "    }",
             "  }",
             "}");
-    JavaFileObject child =
+    Compilation compilation = daggerCompiler().compile(aComponent, bComponent, cComponent);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            error(
+                "[test.C.conflict()] java.lang.Object is bound multiple times:",
+                "@Provides Object test.A.AModule.acConflict()",
+                "@Provides Object test.C.CModule.acConflict()"))
+        .inFile(aComponent)
+        .onLineContaining("interface A {");
+  }
+
+  @Test
+  public void grandchildBindingConflictsWithChild() {
+    JavaFileObject aComponent =
         JavaFileObjects.forSourceLines(
-            "test.Child",
+            "test.A",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface A {",
+            "  B b();",
+            "}");
+    JavaFileObject bComponent =
+        JavaFileObjects.forSourceLines(
+            "test.B",
             "package test;",
             "",
             "import dagger.Module;",
             "import dagger.Provides;",
             "import dagger.Subcomponent;",
             "",
-            "@Subcomponent(modules = Child.ChildModule.class)",
-            "interface Child {",
-            "  @ParentChildConflict Object parentChildConflict();",
-            "  @ChildGrandchildConflict Object childGrandchildConflict();",
+            "@Subcomponent(modules = B.BModule.class)",
+            "interface B {",
+            "  Object conflict();",
             "",
-            "  Grandchild grandchild();",
+            "  C c();",
             "",
             "  @Module",
-            "  static class ChildModule {",
-            "    @Provides @ParentChildConflict static Object parentChildConflict() {",
-            "      return \"child\";",
-            "    }",
-            "",
-            "    @Provides @ChildGrandchildConflict static Object childGrandchildConflict() {",
-            "      return \"child\";",
+            "  static class BModule {",
+            "    @Provides static Object bcConflict() {",
+            "      return \"b\";",
             "    }",
             "  }",
             "}");
-    JavaFileObject grandchild =
+    JavaFileObject cComponent =
         JavaFileObjects.forSourceLines(
-            "test.Grandchild",
+            "test.C",
             "package test;",
             "",
             "import dagger.Module;",
             "import dagger.Provides;",
             "import dagger.Subcomponent;",
             "",
-            "@Subcomponent(modules = Grandchild.GrandchildModule.class)",
-            "interface Grandchild {",
-            "  @ParentChildConflict Object parentChildConflict();",
-            "  @ParentGrandchildConflict Object parentGrandchildConflict();",
-            "  @ChildGrandchildConflict Object childGrandchildConflict();",
+            "@Subcomponent(modules = C.CModule.class)",
+            "interface C {",
+            "  Object conflict();",
             "",
             "  @Module",
-            "  static class GrandchildModule {",
-            "    @Provides @ParentGrandchildConflict static Object parentGrandchildConflict() {",
-            "      return \"grandchild\";",
-            "    }",
-            "",
-            "    @Provides @ChildGrandchildConflict static Object childGrandchildConflict() {",
-            "      return \"grandchild\";",
+            "  static class CModule {",
+            "    @Provides static Object bcConflict() {",
+            "      return \"c\";",
             "    }",
             "  }",
             "}");
-    assertAbout(javaSources())
-        .that(
-            ImmutableList.of(
-                parentChildConflict,
-                parentGrandchildConflict,
-                childGrandchildConflict,
-                parentConflictsWithChild,
-                parentConflictsWithGrandchild,
-                child,
-                grandchild))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            "[test.Child.parentChildConflict()] "
-                + "@test.ParentChildConflict java.lang.Object is bound multiple times:\n"
-                + "      @Provides @test.ParentChildConflict Object"
-                + " test.ParentConflictsWithChild.ParentModule.parentChildConflict()\n"
-                + "      @Provides @test.ParentChildConflict Object"
-                + " test.Child.ChildModule.parentChildConflict()")
-        .in(parentConflictsWithChild)
-        .onLine(8)
-        .and()
-        .withErrorContaining(
-            "[test.Grandchild.parentGrandchildConflict()] "
-                + "@test.ParentGrandchildConflict java.lang.Object is bound multiple times:\n"
-                + "      @Provides @test.ParentGrandchildConflict Object"
-                + " test.ParentConflictsWithGrandchild.ParentModule.parentGrandchildConflict()\n"
-                + "      @Provides @test.ParentGrandchildConflict Object"
-                + " test.Grandchild.GrandchildModule.parentGrandchildConflict()")
-        .in(parentConflictsWithGrandchild)
-        .onLine(8)
-        .and()
-        .withErrorContaining(
-            "[test.Grandchild.childGrandchildConflict()] "
-                + "@test.ChildGrandchildConflict java.lang.Object is bound multiple times:\n"
-                + "      @Provides @test.ChildGrandchildConflict Object"
-                + " test.Child.ChildModule.childGrandchildConflict()\n"
-                + "      @Provides @test.ChildGrandchildConflict Object"
-                + " test.Grandchild.GrandchildModule.childGrandchildConflict()")
-        .in(child)
-        .onLine(8);
+    Compilation compilation = daggerCompiler().compile(aComponent, bComponent, cComponent);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            error(
+                "[test.C.conflict()] java.lang.Object is bound multiple times:",
+                "@Provides Object test.B.BModule.bcConflict()",
+                "@Provides Object test.C.CModule.bcConflict()"))
+        .inFile(aComponent)
+        .onLineContaining("interface A {");
   }
 
   @Test
-  public void subcomponentBindingConflictsWithParentWithNullableViolationAsWarning() {
+  public void grandchildBindingConflictsWithParentWithNullableViolationAsWarning() {
     JavaFileObject parentConflictsWithChild =
         JavaFileObjects.forSourceLines(
             "test.ParentConflictsWithChild",
@@ -2310,12 +2341,12 @@ public void subcomponentBindingConflictsWithParentWithNullableViolationAsWarning
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(
-            "[test.Child.parentChildConflictThatViolatesNullability()] "
-                + "java.lang.Object is bound multiple times:\n"
-                + "      @Provides @javax.annotation.Nullable Object"
-                + " test.ParentConflictsWithChild.ParentModule.nullableParentChildConflict()\n"
-                + "      @Provides Object"
-                + " test.Child.ChildModule.nonNullableParentChildConflict()")
+            error(
+                "[test.Child.parentChildConflictThatViolatesNullability()] "
+                    + "java.lang.Object is bound multiple times:",
+                "@Provides Object test.Child.ChildModule.nonNullableParentChildConflict()",
+                "@Provides @javax.annotation.Nullable Object"
+                    + " test.ParentConflictsWithChild.ParentModule.nullableParentChildConflict()"))
         .in(parentConflictsWithChild)
         .onLine(9);
   }
diff --git a/javatests/dagger/internal/codegen/InaccessibleTypeTest.java b/javatests/dagger/internal/codegen/InaccessibleTypeTest.java
deleted file mode 100644
index 79d69951f..000000000
--- a/javatests/dagger/internal/codegen/InaccessibleTypeTest.java
+++ /dev/null
@@ -1,240 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.testing.compile.CompilationSubject.assertThat;
-import static dagger.internal.codegen.Compilers.daggerCompiler;
-import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
-
-import com.google.common.collect.FluentIterable;
-import com.google.testing.compile.Compilation;
-import com.google.testing.compile.JavaFileObjects;
-import java.util.Collection;
-import javax.tools.JavaFileObject;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
-import org.junit.runners.Parameterized.Parameters;
-
-@RunWith(Parameterized.class)
-public class InaccessibleTypeTest {
-  @Parameters(name = "{0}")
-  public static Collection<Object[]> parameters() {
-    return CompilerMode.TEST_PARAMETERS;
-  }
-
-  private final CompilerMode compilerMode;
-
-  public InaccessibleTypeTest(CompilerMode compilerMode) {
-    this.compilerMode = compilerMode;
-  }
-
-  @Test public void basicInjectedType() {
-    JavaFileObject noDepClassFile = JavaFileObjects.forSourceLines("foreign.NoDepClass",
-        "package foreign;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "public final class NoDepClass {",
-        "  @Inject NoDepClass() {}",
-        "}");
-    JavaFileObject publicClassFile = JavaFileObjects.forSourceLines("foreign.PublicClass",
-        "package foreign;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "public final class PublicClass {",
-        "  @Inject PublicClass(NonPublicClass1 dep1, NonPublicClass2 dep2, NoDepClass dep3) {}",
-        "}");
-    JavaFileObject nonPublicClass1File = JavaFileObjects.forSourceLines("foreign.NonPublicClass1",
-        "package foreign;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "final class NonPublicClass1 {",
-        "  @Inject NonPublicClass1(NoDepClass dep) {}",
-        "}");
-    JavaFileObject nonPublicClass2File = JavaFileObjects.forSourceLines("foreign.NonPublicClass2",
-        "package foreign;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "final class NonPublicClass2 {",
-        "  @Inject NonPublicClass2(NoDepClass dep) {}",
-        "}");
-
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import foreign.PublicClass;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "interface TestComponent {",
-        "  PublicClass publicClass();",
-        "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerTestComponent",
-            "package test;",
-            "",
-            "import foreign.NoDepClass_Factory;",
-            "import foreign.NonPublicClass1_Factory;",
-            "import foreign.NonPublicClass2_Factory;",
-            "import foreign.PublicClass;",
-            "import foreign.PublicClass_Factory;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerTestComponent implements TestComponent {",
-            "  private Object getNonPublicClass1() {",
-            "    return NonPublicClass1_Factory.newNonPublicClass1(",
-            "        NoDepClass_Factory.newNoDepClass());",
-            "  }",
-            "",
-            "  private Object getNonPublicClass2() {",
-            "    return NonPublicClass2_Factory.newNonPublicClass2(",
-            "        NoDepClass_Factory.newNoDepClass());",
-            "  }",
-            "",
-            "  @Override",
-            "  public PublicClass publicClass() {",
-            "    return PublicClass_Factory.newPublicClass(",
-            "        getNonPublicClass1(), ",
-            "        getNonPublicClass2(), ",
-            "        NoDepClass_Factory.newNoDepClass());",
-            "  }",
-            "}");
-    Compilation compilation =
-        daggerCompiler()
-            .withOptions(
-                FluentIterable.from(compilerMode.javacopts())
-                    .append(
-                        "-Xlint:-processing",
-                        "-Xlint:rawtypes",
-                        "-Xlint:unchecked",
-                        "-Xlint:-classfile"))
-            .compile(
-                noDepClassFile,
-                publicClassFile,
-                nonPublicClass1File,
-                nonPublicClass2File,
-                componentFile);
-    assertThat(compilation).succeeded();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerTestComponent")
-        .containsElementsIn(generatedComponent);
-  }
-
-  @Test public void memberInjectedType() {
-    JavaFileObject noDepClassFile = JavaFileObjects.forSourceLines("test.NoDepClass",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "public final class NoDepClass {",
-        "  @Inject NoDepClass() {}",
-        "}");
-    JavaFileObject aClassFile = JavaFileObjects.forSourceLines("test.A",
-        "package test;",
-        "",
-        "import foreign.B;",
-        "import javax.inject.Inject;",
-        "",
-        "final class A extends B {",
-        "  @Inject NoDepClass dep;",
-        "}");
-    JavaFileObject bClassFile = JavaFileObjects.forSourceLines("foreign.B",
-        "package foreign;",
-        "",
-        "import test.NoDepClass;",
-        "import javax.inject.Inject;",
-        "",
-        "public class B extends C {",
-        "  @Inject NoDepClass dep;",
-        "}");
-    JavaFileObject cClassFile = JavaFileObjects.forSourceLines("foreign.C",
-        "package foreign;",
-        "",
-        "import test.D;",
-        "import test.NoDepClass;",
-        "import javax.inject.Inject;",
-        "",
-        "class C extends D {",
-        "  @Inject NoDepClass dep;",
-        "}");
-    JavaFileObject dClassFile = JavaFileObjects.forSourceLines("test.D",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "public class D {",
-        "  @Inject NoDepClass dep;",
-        "}");
-
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "interface TestComponent {",
-        "  void injectA(A a);",
-        "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerTestComponent",
-            "package test;",
-            "",
-            "import foreign.B_MembersInjector;",
-            "import foreign.C_MembersInjector;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerTestComponent implements TestComponent {",
-            "  @Override",
-            "  public void injectA(A a) {",
-            "    injectA2(a);",
-            "  }",
-            "",
-            "  @CanIgnoreReturnValue",
-            "  private A injectA2(A instance) {",
-            "    D_MembersInjector.injectDep(instance, new NoDepClass());",
-            "    C_MembersInjector.injectDep(instance, new NoDepClass());",
-            "    B_MembersInjector.injectDep(instance, new NoDepClass());",
-            "    A_MembersInjector.injectDep(instance, new NoDepClass());",
-            "    return instance;",
-            "  }",
-            "}");
-    Compilation compilation =
-        daggerCompiler()
-            .withOptions(
-                FluentIterable.from(compilerMode.javacopts())
-                    .append(
-                        "-Xlint:-processing",
-                        "-Xlint:rawtypes",
-                        "-Xlint:unchecked",
-                        "-Xlint:-classfile"))
-            .compile(
-                noDepClassFile,
-                aClassFile, bClassFile, cClassFile, dClassFile, componentFile);
-    assertThat(compilation).succeeded();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerTestComponent")
-        .containsElementsIn(generatedComponent);
-  }
-}
diff --git a/javatests/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java b/javatests/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
index 7941803af..f8baa6059 100644
--- a/javatests/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
+++ b/javatests/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
@@ -1101,54 +1101,6 @@
         .generatesSources(expectedFactory);
   }
 
-  @Test
-  public void neitherTypeNorSupertypeRequiresMemberInjection() {
-    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
-        "package test;",
-        "",
-        "class A {}");
-    JavaFileObject bFile = JavaFileObjects.forSourceLines("test.B",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "class B extends A {",
-        "  @Inject B() {}",
-        "}");
-    JavaFileObject expectedFactory =
-        JavaFileObjects.forSourceLines(
-            "test.B_Factory",
-            "package test;",
-            "",
-            "import dagger.internal.Factory;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATED_ANNOTATION,
-            "public final class B_Factory implements Factory<B> {",
-            "  private static final B_Factory INSTANCE = new B_Factory();",
-            "",
-            "  @Override public B get() {",
-            "    return provideInstance();",
-            "  }",
-            "",
-            "  public static B provideInstance() {",
-            "    return new B();",
-            "  }",
-            "",
-            "  public static B_Factory create() {",
-            "    return INSTANCE;",
-            "  }",
-            "",
-            "  public static B newB() {",
-            "    return new B();",
-            "  }",
-            "}");
-    assertAbout(javaSources()).that(ImmutableList.of(aFile, bFile))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and().generatesSources(expectedFactory);
-  }
-
   @Test
   public void wildcardDependency() {
     JavaFileObject file = JavaFileObjects.forSourceLines("test.InjectConstructor",
@@ -1454,10 +1406,6 @@ public void noDeps() {
         "  static class B {",
         "    @Inject A a;",
         "  }",
-        "  @Component interface SimpleComponent {",
-        "    A a();",
-        "    void inject(B b);",
-        "  }",
         "}");
     JavaFileObject aFactory =
         JavaFileObjects.forSourceLines(
diff --git a/javatests/dagger/internal/codegen/MapKeyProcessorTest.java b/javatests/dagger/internal/codegen/MapKeyProcessorTest.java
index 9d0c50b36..746c60d17 100644
--- a/javatests/dagger/internal/codegen/MapKeyProcessorTest.java
+++ b/javatests/dagger/internal/codegen/MapKeyProcessorTest.java
@@ -17,18 +17,12 @@
 package dagger.internal.codegen;
 
 import static com.google.common.truth.Truth.assertAbout;
-import static com.google.testing.compile.CompilationSubject.assertThat;
-import static com.google.testing.compile.JavaSourcesSubject.assertThat;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
-import static dagger.internal.codegen.CompilerMode.DEFAULT_MODE;
-import static dagger.internal.codegen.CompilerMode.EXPERIMENTAL_ANDROID_MODE;
-import static dagger.internal.codegen.Compilers.daggerCompiler;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 import static dagger.internal.codegen.GeneratedLines.IMPORT_GENERATED_ANNOTATION;
 
 import com.google.auto.value.processor.AutoAnnotationProcessor;
 import com.google.common.collect.ImmutableList;
-import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
 import java.util.Collection;
 import javax.tools.JavaFileObject;
@@ -147,299 +141,4 @@ public void nestedMapKeyCreatorFile() {
         .and()
         .generatesSources(generatedKeyCreator);
   }
-
-  @Test
-  public void mapKeyComponentFileWithDisorderedKeyField() {
-    JavaFileObject mapModuleOneFile = JavaFileObjects.forSourceLines("test.MapModuleOne",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import dagger.multibindings.IntoMap;",
-        "",
-        "@Module",
-        "final class MapModuleOne {",
-        "  @Provides",
-        "  @IntoMap",
-        "  @PathKey(relativePath = \"AdminPath\", value = PathEnum.ADMIN)",
-        "  Handler provideAdminHandler() {",
-        "    return new AdminHandler();",
-        "  }",
-        "}");
-    JavaFileObject mapModuleTwoFile =JavaFileObjects.forSourceLines("test.MapModuleTwo",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import dagger.multibindings.IntoMap;",
-        "",
-        "@Module",
-        "final class MapModuleTwo {",
-        "  @Provides",
-        "  @IntoMap",
-        "  @PathKey(value = PathEnum.LOGIN, relativePath = \"LoginPath\")",
-        "  Handler provideLoginHandler() {",
-        "    return new LoginHandler();",
-        "  }",
-        "}");
-    JavaFileObject enumKeyFile = JavaFileObjects.forSourceLines("test.PathKey",
-        "package test;",
-        "import dagger.MapKey;",
-        "import java.lang.annotation.Retention;",
-        "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
-        "",
-        "@MapKey(unwrapValue = false)",
-        "@Retention(RUNTIME)",
-        "public @interface PathKey {",
-        "  PathEnum value();",
-        "  String relativePath() default \"DefaultPath\";",
-        "}");
-    JavaFileObject pathEnumFile = JavaFileObjects.forSourceLines("test.PathEnum",
-        "package test;",
-        "",
-        "public enum PathEnum {",
-        "    ADMIN,",
-        "    LOGIN;",
-        "}");
-    JavaFileObject handlerFile = JavaFileObjects.forSourceLines("test.Handler",
-        "package test;",
-        "",
-        "interface Handler {}");
-    JavaFileObject loginHandlerFile = JavaFileObjects.forSourceLines("test.LoginHandler",
-        "package test;",
-        "",
-        "class LoginHandler implements Handler {",
-        "  public LoginHandler() {}",
-        "}");
-    JavaFileObject adminHandlerFile = JavaFileObjects.forSourceLines("test.AdminHandler",
-        "package test;",
-        "",
-        "class AdminHandler implements Handler {",
-        "  public AdminHandler() {}",
-        "}");
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import java.util.Map;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component(modules = {MapModuleOne.class, MapModuleTwo.class})",
-        "interface TestComponent {",
-        "  Map<PathKey, Provider<Handler>> dispatcher();",
-        "}");
-    JavaFileObject generatedComponent =
-        new JavaFileBuilder(compilerMode, "test.DaggerTestComponent")
-            .addLines(
-                "package test;",
-                "",
-                GENERATED_ANNOTATION,
-                "public final class DaggerTestComponent implements TestComponent {")
-            .addLinesIn(
-                EXPERIMENTAL_ANDROID_MODE,
-                "  @Override",
-                "  public Map<PathKey, Provider<Handler>> dispatcher() {",
-                "    return ImmutableMap.<PathKey, Provider<Handler>>of(",
-                "        PathKeyCreator.createPathKey(PathEnum.ADMIN, \"AdminPath\"),",
-                "        getMapOfPathKeyAndProviderOfHandlerProvider(),",
-                "        PathKeyCreator.createPathKey(PathEnum.LOGIN, \"LoginPath\"),",
-                "        getMapOfPathKeyAndProviderOfHandlerProvider2());",
-                "  }")
-            .addLinesIn(
-                DEFAULT_MODE,
-                "  @Override",
-                "  public Map<PathKey, Provider<Handler>> dispatcher() {",
-                "    return ImmutableMap.<PathKey, Provider<Handler>>of(",
-                "        PathKeyCreator.createPathKey(PathEnum.ADMIN, \"AdminPath\"),",
-                "        provideAdminHandlerProvider,",
-                "        PathKeyCreator.createPathKey(PathEnum.LOGIN, \"LoginPath\"),",
-                "        provideLoginHandlerProvider);",
-                "  }")
-            .addLines("}")
-            .build();
-    Compilation compilation =
-        daggerCompiler()
-            .withOptions(compilerMode.javacopts())
-            .compile(
-                mapModuleOneFile,
-                mapModuleTwoFile,
-                enumKeyFile,
-                pathEnumFile,
-                handlerFile,
-                loginHandlerFile,
-                adminHandlerFile,
-                componentFile);
-    assertThat(compilation).succeeded();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerTestComponent")
-        .containsElementsIn(generatedComponent);
-  }
-
-  @Test
-  public void mapKeyComponentFileWithDefaultField() {
-    JavaFileObject mapModuleOneFile = JavaFileObjects.forSourceLines("test.MapModuleOne",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import dagger.multibindings.IntoMap;",
-        "",
-        "@Module",
-        "final class MapModuleOne {",
-        "  @Provides",
-        "  @IntoMap",
-        "  @PathKey(value = PathEnum.ADMIN) Handler provideAdminHandler() {",
-        "    return new AdminHandler();",
-        "  }",
-        "}");
-    JavaFileObject mapModuleTwoFile =JavaFileObjects.forSourceLines("test.MapModuleTwo",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import dagger.multibindings.IntoMap;",
-        "",
-        "@Module",
-        "final class MapModuleTwo {",
-        "  @Provides",
-        "  @IntoMap",
-        "  @PathKey(value = PathEnum.LOGIN, relativePath = \"LoginPath\")",
-        "  Handler provideLoginHandler() {",
-        "    return new LoginHandler();",
-        "  }",
-        "}");
-    JavaFileObject enumKeyFile = JavaFileObjects.forSourceLines("test.PathKey",
-        "package test;",
-        "import dagger.MapKey;",
-        "import java.lang.annotation.Retention;",
-        "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
-        "",
-        "@MapKey(unwrapValue = false)",
-        "@Retention(RUNTIME)",
-        "public @interface PathKey {",
-        "  PathEnum value();",
-        "  String relativePath() default \"DefaultPath\";",
-        "}");
-    JavaFileObject pathEnumFile = JavaFileObjects.forSourceLines("test.PathEnum",
-        "package test;",
-        "",
-        "public enum PathEnum {",
-        "    ADMIN,",
-        "    LOGIN;",
-        "}");
-    JavaFileObject handlerFile = JavaFileObjects.forSourceLines("test.Handler",
-        "package test;",
-        "",
-        "interface Handler {}");
-    JavaFileObject loginHandlerFile = JavaFileObjects.forSourceLines("test.LoginHandler",
-        "package test;",
-        "",
-        "class LoginHandler implements Handler {",
-        "  public LoginHandler() {}",
-        "}");
-    JavaFileObject adminHandlerFile = JavaFileObjects.forSourceLines("test.AdminHandler",
-        "package test;",
-        "",
-        "class AdminHandler implements Handler {",
-        "  public AdminHandler() {}",
-        "}");
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import java.util.Map;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component(modules = {MapModuleOne.class, MapModuleTwo.class})",
-        "interface TestComponent {",
-        "  Map<PathKey, Provider<Handler>> dispatcher();",
-        "}");
-    JavaFileObject generatedComponent =
-        new JavaFileBuilder(compilerMode, "test.DaggerTestComponent")
-            .addLines(
-                "package test;",
-                "",
-                GENERATED_ANNOTATION,
-                "public final class DaggerTestComponent implements TestComponent {")
-            .addLinesIn(
-                EXPERIMENTAL_ANDROID_MODE,
-                "  @Override",
-                "  public Map<PathKey, Provider<Handler>> dispatcher() {",
-                "    return ImmutableMap.<PathKey, Provider<Handler>>of(",
-                "        PathKeyCreator.createPathKey(PathEnum.ADMIN, \"DefaultPath\"),",
-                "        getMapOfPathKeyAndProviderOfHandlerProvider(),",
-                "        PathKeyCreator.createPathKey(PathEnum.LOGIN, \"LoginPath\"),",
-                "        getMapOfPathKeyAndProviderOfHandlerProvider2());",
-                "  }")
-            .addLinesIn(
-                DEFAULT_MODE,
-                "  @Override",
-                "  public Map<PathKey, Provider<Handler>> dispatcher() {",
-                "    return ImmutableMap.<PathKey, Provider<Handler>>of(",
-                "        PathKeyCreator.createPathKey(PathEnum.ADMIN, \"DefaultPath\"),",
-                "        provideAdminHandlerProvider,",
-                "        PathKeyCreator.createPathKey(PathEnum.LOGIN, \"LoginPath\"),",
-                "        provideLoginHandlerProvider);",
-                "  }")
-            .addLines("}")
-            .build();
-    Compilation compilation =
-        daggerCompiler()
-            .withOptions(compilerMode.javacopts())
-            .compile(
-                mapModuleOneFile,
-                mapModuleTwoFile,
-                enumKeyFile,
-                pathEnumFile,
-                handlerFile,
-                loginHandlerFile,
-                adminHandlerFile,
-                componentFile);
-    assertThat(compilation).succeeded();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerTestComponent")
-        .containsElementsIn(generatedComponent);
-  }
-
-  @Test
-  public void mapKeyWithDefaultValue() {
-    JavaFileObject module =
-        JavaFileObjects.forSourceLines(
-            "test.MapModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntoMap;",
-            "",
-            "@Module",
-            "final class MapModule {",
-            "  @Provides",
-            "  @IntoMap",
-            "  @BoolKey int provideFalseValue() {",
-            "    return -1;",
-            "  }",
-            "",
-            "  @Provides",
-            "  @IntoMap",
-            "  @BoolKey(true) int provideTrueValue() {",
-            "    return 1;",
-            "  }",
-            "}");
-    JavaFileObject mapKey =
-        JavaFileObjects.forSourceLines(
-            "test.BoolKey",
-            "package test;",
-            "",
-            "import dagger.MapKey;",
-            "",
-            "@MapKey",
-            "@interface BoolKey {",
-            "  boolean value() default false;",
-            "}");
-    assertThat(module, mapKey)
-        .withCompilerOptions(compilerMode.javacopts())
-        .processedWith(new ComponentProcessor(), new AutoAnnotationProcessor())
-        .compilesWithoutError();
-  }
 }
diff --git a/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java b/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
index 1bde5eba6..fad441e49 100644
--- a/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
+++ b/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
@@ -226,16 +226,15 @@ public void simpleComponent() {
                 "test.DaggerTestClass_SimpleComponent",
                 "package test;",
                 "",
-                "import com.google.common.collect.ImmutableSet;",
                 "import com.google.common.util.concurrent.ListenableFuture;",
                 "import dagger.internal.DoubleCheck;",
                 "import dagger.internal.InstanceFactory;",
                 "import dagger.internal.MemoizedSentinel;",
                 "import dagger.internal.Preconditions;",
+                "import dagger.internal.SetFactory;",
                 "import dagger.producers.Producer;",
                 "import dagger.producers.internal.Producers;",
                 "import dagger.producers.monitoring.ProductionComponentMonitor;",
-                "import java.util.Set;",
                 "import java.util.concurrent.Executor;",
                 IMPORT_GENERATED_ANNOTATION,
                 "import javax.inject.Provider;",
@@ -248,8 +247,6 @@ public void simpleComponent() {
                 "      new MemoizedSentinel();",
                 "  private volatile Provider<ProductionComponentMonitor> monitorProvider;",
                 "  private volatile Object productionComponentMonitor = new MemoizedSentinel();",
-                "  private volatile Provider<Set<ProductionComponentMonitor.Factory>>",
-                "      setOfFactoryProvider;",
                 "  private volatile Provider<TestClass.B> bProvider;",
                 "  private TestClass.BModule bModule;",
                 "  private Provider<TestClass.SimpleComponent> simpleComponentProvider;",
@@ -296,17 +293,6 @@ public void simpleComponent() {
                 "    return (Provider<Executor>) local;",
                 "  }",
                 "",
-                "  private Provider<Set<ProductionComponentMonitor.Factory>>",
-                "      getSetOfFactoryProvider() {",
-                "      Object local = setOfFactoryProvider;",
-                "      if (local == null) {",
-                "        local = new SwitchingProvider<>(2);",
-                "        setOfFactoryProvider =",
-                "            (Provider<Set<ProductionComponentMonitor.Factory>>) local;",
-                "      }",
-                "      return (Provider<Set<ProductionComponentMonitor.Factory>>) local;",
-                "  }",
-                "",
                 "  private ProductionComponentMonitor getProductionComponentMonitor() {",
                 "    Object local = productionComponentMonitor;",
                 "    if (local instanceof MemoizedSentinel) {",
@@ -317,7 +303,7 @@ public void simpleComponent() {
                 "              TestClass_SimpleComponent_MonitoringModule_MonitorFactory",
                 "                  .proxyMonitor(",
                 "                      simpleComponentProvider,",
-                "                      getSetOfFactoryProvider());",
+                "                      SetFactory.<ProductionComponentMonitor.Factory>empty());",
                 "          productionComponentMonitor =",
                 "              DoubleCheck.reentrantCheck(",
                 "                  productionComponentMonitor, local);",
@@ -344,7 +330,7 @@ public void simpleComponent() {
                 "  private Provider<TestClass.B> getBProvider() {",
                 "    Object local = bProvider;",
                 "    if (local == null) {",
-                "      local = new SwitchingProvider<>(3);",
+                "      local = new SwitchingProvider<>(2);",
                 "      bProvider = (Provider<TestClass.B>) local;",
                 "    }",
                 "    return (Provider<TestClass.B>) local;",
@@ -418,8 +404,7 @@ public void simpleComponent() {
                 "      switch (id) {",
                 "        case 0: return (T) getProductionImplementationExecutor();",
                 "        case 1: return (T) getProductionComponentMonitor();",
-                "        case 2: return (T) ImmutableSet.<ProductionComponentMonitor.Factory>of();",
-                "        case 3: return (T) getB();",
+                "        case 2: return (T) getB();",
                 "        default: throw new AssertionError(id);",
                 "      }",
                 "    }",
diff --git a/javatests/dagger/internal/codegen/SubcomponentBuilderValidationTest.java b/javatests/dagger/internal/codegen/SubcomponentBuilderValidationTest.java
index f4cb9ed51..1351702e0 100644
--- a/javatests/dagger/internal/codegen/SubcomponentBuilderValidationTest.java
+++ b/javatests/dagger/internal/codegen/SubcomponentBuilderValidationTest.java
@@ -719,18 +719,17 @@ public void testMultipleSettersPerBoundInstanceTypeFails() {
             "    @BindsInstance void set2(String s);",
             "  }",
             "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(componentFile, childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation = daggerCompiler().compile(componentFile, childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             Joiner.on("\n      ")
                 .join(
-                    "java.lang.String is bound multiple times:",
+                    "[test.ChildComponent.s()] java.lang.String is bound multiple times:",
                     "@BindsInstance void test.ChildComponent.Builder.set1(String)",
                     "@BindsInstance void test.ChildComponent.Builder.set2(String)"))
-        .in(childComponentFile)
-        .onLine(8);
+        .inFile(componentFile)
+        .onLineContaining("interface ParentComponent {");
   }
 
   @Test
diff --git a/javatests/dagger/internal/codegen/SwitchingProviderTest.java b/javatests/dagger/internal/codegen/SwitchingProviderTest.java
index e6f7a4727..bb2a3316c 100644
--- a/javatests/dagger/internal/codegen/SwitchingProviderTest.java
+++ b/javatests/dagger/internal/codegen/SwitchingProviderTest.java
@@ -18,35 +18,19 @@
 
 import static com.google.testing.compile.CompilationSubject.assertThat;
 import static com.google.testing.compile.Compiler.javac;
-import static dagger.internal.codegen.CompilerMode.EXPERIMENTAL_ANDROID_MODE;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.Lists;
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.Compiler;
 import com.google.testing.compile.JavaFileObjects;
-import java.util.Collection;
-import javax.annotation.processing.Processor;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
-import org.junit.runners.Parameterized.Parameters;
+import org.junit.runners.JUnit4;
 
-@RunWith(Parameterized.class)
+@RunWith(JUnit4.class)
 public class SwitchingProviderTest {
-  @Parameters(name = "{0}")
-  public static Collection<Object[]> parameters() {
-    return CompilerMode.TEST_PARAMETERS;
-  }
-
-  private final CompilerMode compilerMode;
-
-  public SwitchingProviderTest(CompilerMode compilerMode) {
-    this.compilerMode = compilerMode;
-  }
-
   @Test
   public void switchingProviderTest() {
     ImmutableList.Builder<JavaFileObject> javaFileObjects = ImmutableList.builder();
@@ -81,14 +65,11 @@ public void switchingProviderTest() {
             "}"));
 
     JavaFileObject generatedComponent =
-        compilerMode
-            .javaFileBuilder("test.DaggerTestComponent")
-            .addLines(
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
                 "package test;",
                 GENERATED_ANNOTATION,
-                "public final class DaggerTestComponent implements TestComponent {")
-            .addLinesIn(
-                EXPERIMENTAL_ANDROID_MODE,
+                "public final class DaggerTestComponent implements TestComponent {",
                 "  private final class SwitchingProvider<T> implements Provider<T> {",
                 "    @SuppressWarnings(\"unchecked\")",
                 "    private T get0() {",
@@ -213,19 +194,408 @@ public void switchingProviderTest() {
                 "        default: throw new AssertionError(id);",
                 "      }",
                 "    }",
-                "  }")
-            .build();
+                "  }",
+                "}");
 
-    Compilation compilation = daggerCompiler().compile(javaFileObjects.build());
+    Compilation compilation = compilerWithAndroidMode().compile(javaFileObjects.build());
     assertThat(compilation).succeededWithoutWarnings();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerTestComponent")
         .containsElementsIn(generatedComponent);
   }
 
-  private Compiler daggerCompiler(Processor... extraProcessors) {
+  @Test
+  public void unscopedBinds() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "interface TestModule {",
+            "  @Provides",
+            "  static String s() {",
+            "    return new String();",
+            "  }",
+            "",
+            "  @Binds CharSequence c(String s);",
+            "  @Binds Object o(CharSequence c);",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  Provider<Object> objectProvider();",
+            "  Provider<CharSequence> charSequenceProvider();",
+            "}");
+
+    Compilation compilation = compilerWithAndroidMode().compile(module, component);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .containsElementsIn(
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private volatile Provider<String> sProvider;",
+                "",
+                "  private Provider<String> getStringProvider() {",
+                "    Object local = sProvider;",
+                "    if (local == null) {",
+                "      local = new SwitchingProvider<>(0);",
+                "      sProvider = (Provider<String>) local;",
+                "    }",
+                "    return (Provider<String>) local;",
+                "  }",
+                "",
+                "  @Override",
+                "  public Provider<Object> objectProvider() {",
+                "    return (Provider) getStringProvider();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Provider<CharSequence> charSequenceProvider() {",
+                "    return (Provider) getStringProvider();",
+                "  }",
+                "",
+                "  private final class SwitchingProvider<T> implements Provider<T> {",
+                "    @SuppressWarnings(\"unchecked\")",
+                "    @Override",
+                "    public T get() {",
+                "      switch (id) {",
+                "        case 0:",
+                "          return (T) TestModule_SFactory.proxyS();",
+                "        default:",
+                "          throw new AssertionError(id);",
+                "      }",
+                "    }",
+                "  }",
+                "}"));
+  }
+
+  @Test
+  public void scopedBinds() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import javax.inject.Singleton;",
+            "",
+            "@Module",
+            "interface TestModule {",
+            "  @Provides",
+            "  static String s() {",
+            "    return new String();",
+            "  }",
+            "",
+            "  @Binds @Singleton Object o(CharSequence s);",
+            "  @Binds @Singleton CharSequence c(String s);",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "import javax.inject.Singleton;",
+            "",
+            "@Singleton",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  Provider<Object> objectProvider();",
+            "  Provider<CharSequence> charSequenceProvider();",
+            "}");
+
+    Compilation compilation = compilerWithAndroidMode().compile(module, component);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .containsElementsIn(
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private volatile Provider<CharSequence> cProvider;",
+                "  private volatile Object charSequence = new MemoizedSentinel();",
+                "",
+                "  private CharSequence getCharSequence() {",
+                "    Object local = charSequence;",
+                "    if (local instanceof MemoizedSentinel) {",
+                "      synchronized (local) {",
+                "        local = charSequence;",
+                "        if (local instanceof MemoizedSentinel) {",
+                "          local = TestModule_SFactory.proxyS();",
+                "          charSequence = DoubleCheck.reentrantCheck(charSequence, local);",
+                "        }",
+                "      }",
+                "    }",
+                "    return (CharSequence) local;",
+                "  }",
+                "",
+                "  @Override",
+                "  public Provider<Object> objectProvider() {",
+                "    return (Provider) charSequenceProvider();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Provider<CharSequence> charSequenceProvider() {",
+                "    Object local = cProvider;",
+                "    if (local == null) {",
+                "      local = new SwitchingProvider<>(0);",
+                "      cProvider = (Provider<CharSequence>) local;",
+                "    }",
+                "    return (Provider<CharSequence>) local;",
+                "  }",
+                "",
+                "  private final class SwitchingProvider<T> implements Provider<T> {",
+                "    @SuppressWarnings(\"unchecked\")",
+                "    @Override",
+                "    public T get() {",
+                "      switch (id) {",
+                "        case 0:",
+                "          return (T) getCharSequence();",
+                "        default:",
+                "          throw new AssertionError(id);",
+                "      }",
+                "    }",
+                "  }",
+                "}"));
+  }
+
+  @Test
+  public void emptyMultibindings_avoidSwitchProviders() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.multibindings.Multibinds;",
+            "import dagger.Module;",
+            "import java.util.Map;",
+            "import java.util.Set;",
+            "",
+            "@Module",
+            "interface TestModule {",
+            "  @Multibinds Set<String> set();",
+            "  @Multibinds Map<String, String> map();",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import java.util.Map;",
+            "import java.util.Set;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  Provider<Set<String>> setProvider();",
+            "  Provider<Map<String, String>> mapProvider();",
+            "}");
+
+    Compilation compilation = compilerWithAndroidMode().compile(module, component);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .containsElementsIn(
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  @Override",
+                "  public Provider<Set<String>> setProvider() {",
+                "    return SetFactory.<String>empty();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Provider<Map<String, String>> mapProvider() {",
+                "    return MapFactory.<String, String>emptyMapProvider();",
+                "  }",
+                "}"));
+  }
+
+  @Test
+  public void memberInjectors() {
+    JavaFileObject foo =
+        JavaFileObjects.forSourceLines(
+            "test.Foo",
+            "package test;",
+            "",
+            "class Foo {}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.MembersInjector;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "interface TestComponent {",
+            "  Provider<MembersInjector<Foo>> providerOfMembersInjector();",
+            "}");
+
+    Compilation compilation = compilerWithAndroidMode().compile(foo, component);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .containsElementsIn(
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private Provider<MembersInjector<Foo>> fooMembersInjectorProvider;",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.fooMembersInjectorProvider = ",
+                "        InstanceFactory.create(MembersInjectors.<Foo>noOp());",
+                "  }",
+                "",
+                "  @Override",
+                "  public Provider<MembersInjector<Foo>> providerOfMembersInjector() {",
+                "    return fooMembersInjectorProvider;",
+                "  }",
+                "}"));
+  }
+
+  @Test
+  public void optionals() {
+    JavaFileObject present =
+        JavaFileObjects.forSourceLines(
+            "test.Present",
+            "package test;",
+            "",
+            "class Present {}");
+    JavaFileObject absent =
+        JavaFileObjects.forSourceLines(
+            "test.Absent",
+            "package test;",
+            "",
+            "class Absent {}");
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.BindsOptionalOf;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "interface TestModule {",
+            "  @BindsOptionalOf Present bindOptionalOfPresent();",
+            "  @BindsOptionalOf Absent bindOptionalOfAbsent();",
+            "",
+            "  @Provides static Present p() { return new Present(); }",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import java.util.Optional;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  Provider<Optional<Present>> providerOfOptionalOfPresent();",
+            "  Provider<Optional<Absent>> providerOfOptionalOfAbsent();",
+            "}");
+
+    Compilation compilation = compilerWithAndroidMode().compile(present, absent, module, component);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .containsElementsIn(
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+
+                "  @SuppressWarnings(\"rawtypes\")",
+                "  private static final Provider ABSENT_JDK_OPTIONAL_PROVIDER =",
+                "      InstanceFactory.create(Optional.empty());",
+                "",
+                "  private volatile Provider<Optional<Present>> optionalOfPresentProvider;",
+                "",
+                "  private Provider<Optional<Absent>> optionalOfAbsentProvider;",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.optionalOfAbsentProvider = absentJdkOptionalProvider();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Provider<Optional<Present>> providerOfOptionalOfPresent() {",
+                "    Object local = optionalOfPresentProvider;",
+                "    if (local == null) {",
+                "      local = new SwitchingProvider<>(0);",
+                "      optionalOfPresentProvider = (Provider<Optional<Present>>) local;",
+                "    }",
+                "    return (Provider<Optional<Present>>) local;",
+                "  }",
+                "",
+                "  @Override",
+                "  public Provider<Optional<Absent>> providerOfOptionalOfAbsent() {",
+                "    return optionalOfAbsentProvider;",
+                "  }",
+                "",
+                "  private static <T> Provider<Optional<T>> absentJdkOptionalProvider() {",
+                "    @SuppressWarnings(\"unchecked\")",
+                "    Provider<Optional<T>> provider = ",
+                "          (Provider<Optional<T>>) ABSENT_JDK_OPTIONAL_PROVIDER;",
+                "    return provider;",
+                "  }",
+                "",
+                "  private final class SwitchingProvider<T> implements Provider<T> {",
+                "    @SuppressWarnings(\"unchecked\")",
+                "    @Override",
+                "    public T get() {",
+                "      switch (id) {",
+                "        case 0: // java.util.Optional<test.Present>",
+                "          return (T) Optional.of(TestModule_PFactory.proxyP());",
+                "        default:",
+                "          throw new AssertionError(id);",
+                "      }",
+                "    }",
+                "  }",
+                "}"));
+  }
+
+  private Compiler compilerWithAndroidMode() {
     return javac()
-        .withProcessors(Lists.asList(new ComponentProcessor(), extraProcessors))
-        .withOptions(compilerMode.javacopts());
+        .withProcessors(new ComponentProcessor())
+        .withOptions(CompilerMode.EXPERIMENTAL_ANDROID_MODE.javacopts());
   }
 }
diff --git a/javatests/dagger/spi/SpiPluginTest.java b/javatests/dagger/spi/SpiPluginTest.java
index be63d8217..d9d479b38 100644
--- a/javatests/dagger/spi/SpiPluginTest.java
+++ b/javatests/dagger/spi/SpiPluginTest.java
@@ -261,7 +261,7 @@ public void dependencyTraceAtDependencyRequest_subcomponents() {
     assertThat(compilationFactory.compilationWithErrorOnDependency("childEntryPoint"))
         .hadErrorContaining(
             lines(
-                "[FailingPlugin] Bad Dependency!",
+                "[FailingPlugin] [test.TestSubcomponent.childEntryPoint()] Bad Dependency!",
                 "      test.EntryPoint is provided at",
                 "          test.TestSubcomponent.childEntryPoint()",
                 "  component path: test.TestComponent → test.TestSubcomponent"))
@@ -270,7 +270,7 @@ public void dependencyTraceAtDependencyRequest_subcomponents() {
     assertThat(compilationFactory.compilationWithErrorOnDependency("foo"))
         .hadErrorContaining(
             lines(
-                "[FailingPlugin] Bad Dependency!",
+                "[FailingPlugin] [test.TestSubcomponent.childEntryPoint()] Bad Dependency!",
                 "      test.Foo is injected at",
                 "          test.EntryPoint.<init>(foo)",
                 "      test.EntryPoint is provided at",
@@ -463,7 +463,7 @@ public void shortestPathToBindingExistsThroughSubcomponentBuilder() {
             lines(
                 // TODO(ronshapiro): should this error be reported if it's already been reported at
                 // an ancestor component?
-                "[FailingPlugin] Bad Binding!",
+                "[FailingPlugin] [test.TestSubcomponent.exposedOnSubcomponent()] Bad Binding!",
                 "      test.ExposedOnSubcomponent is provided at",
                 "          test.TestSubcomponent.exposedOnSubcomponent()",
                 "  component path: test.TestComponent → test.TestSubcomponent"))
