diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AGrandchild.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AGrandchild.java
index 31a5e61fc..0aa46faed 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AGrandchild.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AGrandchild.java
@@ -36,6 +36,7 @@ protected void aParentMethod(APublicObject aParentMethod) {
     super.aParentMethod(aParentMethod);
   }
 
+  @SuppressWarnings("OverridesJavaxInjectableMethod")
   @Override
   protected void aChildMethod(APublicObject aChildMethod) {
     super.aChildMethod(aChildMethod);
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/b/BChild.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/b/BChild.java
index 8fec0c5bb..6a62006b9 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/multipackage/b/BChild.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/b/BChild.java
@@ -31,6 +31,7 @@ protected void aChildMethod(APublicObject aChildMethod) {
     this.aChildMethod = aChildMethod;
   }
 
+  @SuppressWarnings("OverridesJavaxInjectableMethod")
   @Override
   protected void aParentMethod(APublicObject aParentMethod) {
     super.aParentMethod(aParentMethod);
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index 7ca284831..533e2681f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -54,7 +54,6 @@
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
 import com.google.common.collect.TreeTraverser;
-import com.google.common.util.concurrent.ListenableFuture;
 import dagger.Component;
 import dagger.Reusable;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
@@ -253,7 +252,7 @@ private BindingGraph create(
       for (ComponentMethodDescriptor componentMethod : componentDescriptor.componentMethods()) {
         Optional<DependencyRequest> componentMethodRequest = componentMethod.dependencyRequest();
         if (componentMethodRequest.isPresent()) {
-          requestResolver.resolve(componentMethodRequest.get());
+          requestResolver.resolve(componentMethodRequest.get().bindingKey());
         }
       }
 
@@ -293,9 +292,9 @@ private BindingGraph create(
       final Map<BindingKey, ResolvedBindings> resolvedBindings;
       final Deque<BindingKey> cycleStack = new ArrayDeque<>();
       final Cache<BindingKey, Boolean> dependsOnLocalMultibindingsCache =
-          CacheBuilder.newBuilder().<BindingKey, Boolean>build();
+          CacheBuilder.newBuilder().build();
       final Cache<Binding, Boolean> bindingDependsOnLocalMultibindingsCache =
-          CacheBuilder.newBuilder().<Binding, Boolean>build();
+          CacheBuilder.newBuilder().build();
 
       Resolver(
           Optional<Resolver> parentResolver,
@@ -317,35 +316,33 @@ private BindingGraph create(
       }
 
       /**
-       * Returns the bindings that satisfy a given dependency request.
+       * Returns the bindings for the given {@link BindingKey}.
        *
        * <p>For {@link BindingKey.Kind#CONTRIBUTION} requests, returns all of:
+       *
        * <ul>
        * <li>All explicit bindings for:
        *     <ul>
        *     <li>the requested key
        *     <li>{@code Set<T>} if the requested key's type is {@code Set<Produced<T>>}
-       *     <li>{@code Map<K, Provider<V>>} if the requested key's type is
-       *         {@code Map<K, Producer<V>>}.
+       *     <li>{@code Map<K, Provider<V>>} if the requested key's type is {@code Map<K,
+       *         Producer<V>>}.
        *     </ul>
        *
        * <li>A synthetic binding that depends on {@code Map<K, Producer<V>>} if the requested key's
-       *     type is {@code Map<K, V>} and there are some explicit bindings for
-       *     {@code Map<K, Producer<V>>}.
-       *
+       *     type is {@code Map<K, V>} and there are some explicit bindings for {@code Map<K,
+       *     Producer<V>>}.
        * <li>A synthetic binding that depends on {@code Map<K, Provider<V>>} if the requested key's
-       *     type is {@code Map<K, V>} and there are some explicit bindings for
-       *     {@code Map<K, Provider<V>>} but no explicit bindings for {@code Map<K, Producer<V>>}.
-       *
+       *     type is {@code Map<K, V>} and there are some explicit bindings for {@code Map<K,
+       *     Provider<V>>} but no explicit bindings for {@code Map<K, Producer<V>>}.
        * <li>An implicit {@link Inject @Inject}-annotated constructor binding if there is one and
        *     there are no explicit bindings or synthetic bindings.
        * </ul>
        *
-       * <p>For {@link BindingKey.Kind#MEMBERS_INJECTION} requests, returns the
-       * {@link MembersInjectionBinding} for the type.
+       * <p>For {@link BindingKey.Kind#MEMBERS_INJECTION} requests, returns the {@link
+       * MembersInjectionBinding} for the type.
        */
-      ResolvedBindings lookUpBindings(DependencyRequest request) {
-        BindingKey bindingKey = request.bindingKey();
+      ResolvedBindings lookUpBindings(BindingKey bindingKey) {
         Key requestKey = bindingKey.key();
         switch (bindingKey.kind()) {
           case CONTRIBUTION:
@@ -366,9 +363,10 @@ ResolvedBindings lookUpBindings(DependencyRequest request) {
             ImmutableSet<MultibindingDeclaration> multibindingDeclarations =
                 multibindingDeclarationsBuilder.build();
 
-            contributionBindings.addAll(syntheticMapOfValuesBinding(request).asSet());
+            contributionBindings.addAll(syntheticMapOfValuesBinding(bindingKey.key()).asSet());
             contributionBindings.addAll(
-                syntheticMultibinding(request, multibindingContributions, multibindingDeclarations)
+                syntheticMultibinding(
+                        bindingKey.key(), multibindingContributions, multibindingDeclarations)
                     .asSet());
 
             /* If there are no bindings, add the implicit @Inject-constructed binding if there is
@@ -381,7 +379,8 @@ ResolvedBindings lookUpBindings(DependencyRequest request) {
             return ResolvedBindings.forContributionBindings(
                 bindingKey,
                 componentDescriptor,
-                indexBindingsByOwningComponent(request, ImmutableSet.copyOf(contributionBindings)),
+                indexBindingsByOwningComponent(
+                    bindingKey, ImmutableSet.copyOf(contributionBindings)),
                 multibindingDeclarations);
 
           case MEMBERS_INJECTION:
@@ -408,32 +407,29 @@ ResolvedBindings lookUpBindings(DependencyRequest request) {
       }
 
       /**
-       * If {@code request} is for a {@code Map<K, V>} or {@code Map<K, Produced<V>>}, and there are
-       * any multibinding contributions or declarations that apply to that map, returns a synthetic
-       * binding for the {@code request} that depends on an {@linkplain
-       * #syntheticMultibinding(DependencyRequest, Iterable, Iterable) underlying synthetic
-       * multibinding}.
+       * If {@code key} is a {@code Map<K, V>} or {@code Map<K, Produced<V>>}, and there are any
+       * multibinding contributions or declarations that apply to that map, returns a synthetic
+       * binding for the {@code key} that depends on an {@linkplain #syntheticMultibinding(Key,
+       * Iterable, Iterable) underlying synthetic multibinding}.
        *
        * <p>The returned binding has the same {@link BindingType} as the underlying synthetic
        * multibinding.
        */
-      private Optional<ContributionBinding> syntheticMapOfValuesBinding(
-          final DependencyRequest request) {
+      private Optional<ContributionBinding> syntheticMapOfValuesBinding(final Key key) {
         return syntheticMultibinding(
-                request,
-                multibindingContributionsForValueMap(request.key()),
-                multibindingDeclarationsForValueMap(request.key()))
+                key,
+                multibindingContributionsForValueMap(key),
+                multibindingDeclarationsForValueMap(key))
             .transform(
                 new Function<ContributionBinding, ContributionBinding>() {
                   @Override
                   public ContributionBinding apply(ContributionBinding syntheticMultibinding) {
                     switch (syntheticMultibinding.bindingType()) {
                       case PROVISION:
-                        return provisionBindingFactory.syntheticMapOfValuesBinding(request);
+                        return provisionBindingFactory.syntheticMapOfValuesBinding(key);
 
                       case PRODUCTION:
-                        return productionBindingFactory.syntheticMapOfValuesOrProducedBinding(
-                            request);
+                        return productionBindingFactory.syntheticMapOfValuesOrProducedBinding(key);
 
                       default:
                         throw new VerifyException(syntheticMultibinding.toString());
@@ -488,9 +484,6 @@ public ContributionBinding apply(ContributionBinding syntheticMultibinding) {
        * the following types, returns a {@link ProductionBinding}.
        *
        * <ul>
-       * <li>{@link Producer Producer<SetOrMap>}
-       * <li>{@link Produced Produced<SetOrMap>}
-       * <li>{@link ListenableFuture ListenableFuture<SetOrMap>}
        * <li>{@code Set<Produced<T>>}
        * <li>{@code Map<K, Producer<V>>}
        * <li>{@code Map<K, Produced<V>>}
@@ -499,48 +492,32 @@ public ContributionBinding apply(ContributionBinding syntheticMultibinding) {
        * Otherwise, returns a {@link ProvisionBinding}.
        */
       private Optional<? extends ContributionBinding> syntheticMultibinding(
-          DependencyRequest request,
+          Key key,
           Iterable<ContributionBinding> multibindingContributions,
           Iterable<MultibindingDeclaration> multibindingDeclarations) {
         if (isEmpty(multibindingContributions) && isEmpty(multibindingDeclarations)) {
           return Optional.absent();
-        } else if (multibindingsRequireProduction(multibindingContributions, request)) {
+        } else if (multibindingsRequireProduction(multibindingContributions, key)) {
           return Optional.of(
-              productionBindingFactory.syntheticMultibinding(request, multibindingContributions));
+              productionBindingFactory.syntheticMultibinding(key, multibindingContributions));
         } else {
           return Optional.of(
-              provisionBindingFactory.syntheticMultibinding(request, multibindingContributions));
+              provisionBindingFactory.syntheticMultibinding(key, multibindingContributions));
         }
       }
 
       private boolean multibindingsRequireProduction(
-          Iterable<ContributionBinding> multibindingContributions, DependencyRequest request) {
-        switch (request.kind()) {
-          case PRODUCER:
-          case PRODUCED:
-          case FUTURE:
+          Iterable<ContributionBinding> multibindingContributions, Key requestKey) {
+        if (MapType.isMap(requestKey)) {
+          MapType mapType = MapType.from(requestKey);
+          if (mapType.valuesAreTypeOf(Producer.class) || mapType.valuesAreTypeOf(Produced.class)) {
             return true;
-
-          case INSTANCE:
-          case LAZY:
-          case PROVIDER:
-          case PROVIDER_OF_LAZY:
-            if (MapType.isMap(request.key())) {
-              MapType mapType = MapType.from(request.key());
-              if (mapType.valuesAreTypeOf(Producer.class)
-                  || mapType.valuesAreTypeOf(Produced.class)) {
-                return true;
-              }
-            } else if (SetType.isSet(request.key())
-                && SetType.from(request.key()).elementsAreTypeOf(Produced.class)) {
-              return true;
-            }
-            return Iterables.any(multibindingContributions, isOfType(BindingType.PRODUCTION));
-
-          case MEMBERS_INJECTOR:
-          default:
-            throw new AssertionError(request.kind());
+          }
+        } else if (SetType.isSet(requestKey)
+            && SetType.from(requestKey).elementsAreTypeOf(Produced.class)) {
+          return true;
         }
+        return Iterables.any(multibindingContributions, isOfType(BindingType.PRODUCTION));
       }
 
       private ImmutableSet<ContributionBinding> createDelegateBindings(
@@ -559,7 +536,8 @@ private boolean multibindingsRequireProduction(
        * delegate key.
        */
       private ContributionBinding createDelegateBinding(DelegateDeclaration delegateDeclaration) {
-        ResolvedBindings resolvedDelegate = lookUpBindings(delegateDeclaration.delegateRequest());
+        ResolvedBindings resolvedDelegate =
+            lookUpBindings(delegateDeclaration.delegateRequest().bindingKey());
         if (resolvedDelegate.contributionBindings().isEmpty()) {
           // This is guaranteed to result in a missing binding error, so it doesn't matter if the
           // binding is a Provision or Production, except if it is a @IntoMap method, in which
@@ -592,11 +570,11 @@ private ContributionBinding createDelegateBinding(DelegateDeclaration delegateDe
 
       private ImmutableSetMultimap<ComponentDescriptor, ContributionBinding>
           indexBindingsByOwningComponent(
-              DependencyRequest request, Iterable<? extends ContributionBinding> bindings) {
+              BindingKey bindingKey, Iterable<? extends ContributionBinding> bindings) {
         ImmutableSetMultimap.Builder<ComponentDescriptor, ContributionBinding> index =
             ImmutableSetMultimap.builder();
         for (ContributionBinding binding : bindings) {
-          index.put(getOwningComponent(request, binding), binding);
+          index.put(getOwningComponent(bindingKey, binding), binding);
         }
         return index.build();
       }
@@ -608,15 +586,15 @@ private ContributionBinding createDelegateBinding(DelegateDeclaration delegateDe
        * multibinding contributions in this component, returns this component.
        *
        * <p>Otherwise, resolves {@code request} in this component's parent in order to resolve any
-       * multibinding contributions in the parent, and returns the parent-resolved
-       * {@link ResolvedBindings#owningComponent(ContributionBinding)}.
+       * multibinding contributions in the parent, and returns the parent-resolved {@link
+       * ResolvedBindings#owningComponent(ContributionBinding)}.
        */
       private ComponentDescriptor getOwningComponent(
-          DependencyRequest request, ContributionBinding binding) {
-        if (isResolvedInParent(request, binding)
+          BindingKey bindingKey, ContributionBinding binding) {
+        if (isResolvedInParent(bindingKey, binding)
             && !new MultibindingDependencies().dependsOnLocalMultibindings(binding)) {
           ResolvedBindings parentResolvedBindings =
-              parentResolver.get().resolvedBindings.get(request.bindingKey());
+              parentResolver.get().resolvedBindings.get(bindingKey);
           return parentResolvedBindings.owningComponent(binding);
         } else {
           return componentDescriptor;
@@ -624,15 +602,15 @@ private ComponentDescriptor getOwningComponent(
       }
 
       /**
-       * Returns {@code true} if {@code binding} is owned by an ancestor. If so,
-       * {@linkplain #resolve(DependencyRequest) resolves} the request in this component's parent.
-       * Don't resolve directly in the owning component in case it depends on multibindings in any
-       * of its descendants.
+       * Returns {@code true} if {@code binding} is owned by an ancestor. If so, {@linkplain
+       * #resolve resolves} the {@link BindingKey} in this component's parent. Don't resolve
+       * directly in the owning component in case it depends on multibindings in any of its
+       * descendants.
        */
-      private boolean isResolvedInParent(DependencyRequest request, ContributionBinding binding) {
+      private boolean isResolvedInParent(BindingKey bindingKey, ContributionBinding binding) {
         Optional<Resolver> owningResolver = getOwningResolver(binding);
         if (owningResolver.isPresent() && !owningResolver.get().equals(this)) {
-          parentResolver.get().resolve(request);
+          parentResolver.get().resolve(bindingKey);
           return true;
         } else {
           return false;
@@ -744,9 +722,7 @@ private boolean isResolvedInParent(DependencyRequest request, ContributionBindin
         }
       }
 
-      void resolve(DependencyRequest request) {
-        BindingKey bindingKey = request.bindingKey();
-
+      void resolve(BindingKey bindingKey) {
         // If we find a cycle, stop resolving. The original request will add it with all of the
         // other resolved deps.
         if (cycleStack.contains(bindingKey)) {
@@ -770,7 +746,7 @@ void resolve(DependencyRequest request) {
         if (getPreviouslyResolvedBindings(bindingKey).isPresent()) {
           /* Resolve in the parent in case there are multibinding contributions or conflicts in some
            * component between this one and the previously-resolved one. */
-          parentResolver.get().resolve(request);
+          parentResolver.get().resolve(bindingKey);
           if (!new MultibindingDependencies().dependsOnLocalMultibindings(bindingKey)
               && getExplicitBindings(bindingKey.key()).isEmpty()) {
             /* Cache the inherited parent component's bindings in case resolving at the parent found
@@ -784,10 +760,10 @@ void resolve(DependencyRequest request) {
 
         cycleStack.push(bindingKey);
         try {
-          ResolvedBindings bindings = lookUpBindings(request);
+          ResolvedBindings bindings = lookUpBindings(bindingKey);
           for (Binding binding : bindings.ownedBindings()) {
             for (DependencyRequest dependency : binding.implicitDependencies()) {
-              resolve(dependency);
+              resolve(dependency.bindingKey());
             }
           }
           resolvedBindings.put(bindingKey, bindings);
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
index 816c51f80..48ac39a01 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
@@ -134,8 +134,8 @@ public Kind apply(ContributionBinding binding) {
     FUTURE_PRODUCTION,
 
     /**
-     * A production method on a production component's
-     * {@linkplain ProductionComponent#dependencies() dependency} that returns a
+     * A production method on a production component's {@linkplain
+     * dagger.producers.ProductionComponent#dependencies()} dependency} that returns a
      * {@link ListenableFuture}. Methods on production component dependencies that don't return a
      * {@link ListenableFuture} are considered {@linkplain #PROVISION provision bindings}.
      */
@@ -149,18 +149,15 @@ public Kind apply(ContributionBinding binding) {
         Predicates.in(immutableEnumSet(SYNTHETIC_MULTIBOUND_SET, SYNTHETIC_MULTIBOUND_MAP));
 
     /**
-     * {@link #SYNTHETIC_MULTIBOUND_SET} or {@link #SYNTHETIC_MULTIBOUND_MAP}, depending on the
-     * request's key.
+     * {@link #SYNTHETIC_MULTIBOUND_SET} or {@link #SYNTHETIC_MULTIBOUND_MAP}, depending on the key.
      */
-    static Kind forMultibindingRequest(DependencyRequest request) {
-      Key key = request.key();
+    static Kind forMultibindingKey(Key key) {
       if (SetType.isSet(key)) {
         return SYNTHETIC_MULTIBOUND_SET;
       } else if (MapType.isMap(key)) {
         return SYNTHETIC_MULTIBOUND_MAP;
       } else {
-        throw new IllegalArgumentException(
-            String.format("request is not for a set or map: %s", request));
+        throw new IllegalArgumentException(String.format("key is not for a set or map: %s", key));
       }
     }
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
index 4dba30056..22efe9bbc 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
@@ -151,20 +151,19 @@ ProductionBinding forProducesMethod(
      * A synthetic binding of {@code Map<K, V>} or {@code Map<K, Produced<V>>} that depends on
      * {@code Map<K, Producer<V>>}.
      */
-    ProductionBinding syntheticMapOfValuesOrProducedBinding(
-        DependencyRequest requestForMapOfValuesOrProduced) {
-      checkNotNull(requestForMapOfValuesOrProduced);
+    ProductionBinding syntheticMapOfValuesOrProducedBinding(Key mapOfValuesOrProducedKey) {
+      checkNotNull(mapOfValuesOrProducedKey);
       Optional<Key> mapOfProducersKey =
-          keyFactory.implicitMapProducerKeyFrom(requestForMapOfValuesOrProduced.key());
+          keyFactory.implicitMapProducerKeyFrom(mapOfValuesOrProducedKey);
       checkArgument(
           mapOfProducersKey.isPresent(),
-          "%s is not for a Map<K, V> or Map<K, Produced<V>>",
-          requestForMapOfValuesOrProduced);
+          "%s is not a key for of Map<K, V> or Map<K, Produced<V>>",
+          mapOfValuesOrProducedKey);
       DependencyRequest requestForMapOfProducers =
           dependencyRequestFactory.forImplicitMapBinding(mapOfProducersKey.get());
       return ProductionBinding.builder()
           .contributionType(ContributionType.UNIQUE)
-          .key(requestForMapOfValuesOrProduced.key())
+          .key(mapOfValuesOrProducedKey)
           .dependencies(requestForMapOfProducers)
           .bindingKind(Kind.SYNTHETIC_MAP)
           .build();
@@ -177,13 +176,13 @@ ProductionBinding syntheticMapOfValuesOrProducedBinding(
      * <p>Note that these could be set multibindings or map multibindings.
      */
     ProductionBinding syntheticMultibinding(
-        DependencyRequest request, Iterable<ContributionBinding> multibindingContributions) {
+        Key key, Iterable<ContributionBinding> multibindingContributions) {
       return ProductionBinding.builder()
           .contributionType(ContributionType.UNIQUE)
-          .key(request.key())
+          .key(key)
           .dependencies(
               dependencyRequestFactory.forMultibindingContributions(multibindingContributions))
-          .bindingKind(Kind.forMultibindingRequest(request))
+          .bindingKind(Kind.forMultibindingKey(key))
           .build();
     }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index 3fc438624..9dbeb02bd 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -205,22 +205,16 @@ ProvisionBinding forProvidesMethod(
           .build();
     }
 
-    /**
-     * A synthetic binding of {@code Map<K, V>} that depends on {@code Map<K, Provider<V>>}.
-     */
-    ProvisionBinding syntheticMapOfValuesBinding(DependencyRequest requestForMapOfValues) {
-      checkNotNull(requestForMapOfValues);
-      Optional<Key> mapOfProvidersKey =
-          keyFactory.implicitMapProviderKeyFrom(requestForMapOfValues.key());
-      checkArgument(
-          mapOfProvidersKey.isPresent(),
-          "%s is not a request for Map<K, V>",
-          requestForMapOfValues);
+    /** A synthetic binding of {@code Map<K, V>} that depends on {@code Map<K, Provider<V>>}. */
+    ProvisionBinding syntheticMapOfValuesBinding(Key mapOfValuesKey) {
+      checkNotNull(mapOfValuesKey);
+      Optional<Key> mapOfProvidersKey = keyFactory.implicitMapProviderKeyFrom(mapOfValuesKey);
+      checkArgument(mapOfProvidersKey.isPresent(), "%s is not a key for Map<K, V>", mapOfValuesKey);
       DependencyRequest requestForMapOfProviders =
           dependencyRequestFactory.forImplicitMapBinding(mapOfProvidersKey.get());
       return ProvisionBinding.builder()
           .contributionType(ContributionType.UNIQUE)
-          .key(requestForMapOfValues.key())
+          .key(mapOfValuesKey)
           .dependencies(requestForMapOfProviders)
           .bindingKind(Kind.SYNTHETIC_MAP)
           .build();
@@ -233,13 +227,13 @@ ProvisionBinding syntheticMapOfValuesBinding(DependencyRequest requestForMapOfVa
      * <p>Note that these could be set multibindings or map multibindings.
      */
     ProvisionBinding syntheticMultibinding(
-        DependencyRequest request, Iterable<ContributionBinding> multibindingContributions) {
+        Key key, Iterable<ContributionBinding> multibindingContributions) {
       return ProvisionBinding.builder()
           .contributionType(ContributionType.UNIQUE)
-          .key(request.key())
+          .key(key)
           .dependencies(
               dependencyRequestFactory.forMultibindingContributions(multibindingContributions))
-          .bindingKind(Kind.forMultibindingRequest(request))
+          .bindingKind(Kind.forMultibindingKey(key))
           .build();
     }
 
