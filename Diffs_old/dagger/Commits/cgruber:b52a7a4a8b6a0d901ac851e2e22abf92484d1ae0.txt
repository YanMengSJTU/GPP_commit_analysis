diff --git a/java/dagger/internal/codegen/BindingGraph.java b/java/dagger/internal/codegen/BindingGraph.java
index c0e10a3a3..b347f7d28 100644
--- a/java/dagger/internal/codegen/BindingGraph.java
+++ b/java/dagger/internal/codegen/BindingGraph.java
@@ -729,8 +729,6 @@ private ContributionBinding createDelegateBinding(DelegateDeclaration delegateDe
         }
         // It doesn't matter which of these is selected, since they will later on produce a
         // duplicate binding error.
-        // TODO(ronshapiro): Once compile-testing has a CompilationResult, add a test which asserts
-        // that a duplicate binding for the RHS does not result in a duplicate binding for the LHS.
         ContributionBinding explicitDelegate =
             resolvedDelegate.contributionBindings().iterator().next();
         switch (explicitDelegate.bindingType()) {
diff --git a/javatests/dagger/internal/codegen/ComponentProcessorTest.java b/javatests/dagger/internal/codegen/ComponentProcessorTest.java
index 06d6d5941..54e49e294 100644
--- a/javatests/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/javatests/dagger/internal/codegen/ComponentProcessorTest.java
@@ -2350,6 +2350,66 @@ public void bindsInstanceFrameworkType() {
         .onLine(9);
   }
 
+  @Test
+  public void bindsToDuplicateBinding_bindsKeyIsNotDuplicated() {
+    JavaFileObject firstModule =
+        JavaFileObjects.forSourceLines(
+            "test.FirstModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "abstract class FirstModule {",
+            "  @Provides static String first() { return \"first\"; }",
+            "}");
+    JavaFileObject secondModule =
+        JavaFileObjects.forSourceLines(
+            "test.SecondModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "abstract class SecondModule {",
+            "  @Provides static String second() { return \"second\"; }",
+            "}");
+    JavaFileObject bindsModule =
+        JavaFileObjects.forSourceLines(
+            "test.BindsModule",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "import dagger.Module;",
+            "",
+            "@Module",
+            "abstract class BindsModule {",
+            "  @Binds abstract Object bindToDuplicateBinding(String duplicate);",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = {FirstModule.class, SecondModule.class, BindsModule.class})",
+            "interface TestComponent {",
+            "  Object notDuplicated();",
+            "}");
+
+    Compilation compilation =
+        daggerCompiler().compile(firstModule, secondModule, bindsModule, component);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorCount(1);
+    assertThat(compilation)
+        .hadErrorContaining("java.lang.String is bound multiple times")
+        .inFile(component)
+        .onLineContaining("Object notDuplicated();");
+  }
+
   @Test
   public void nullIncorrectlyReturnedFromNonNullableInlinedProvider() {
     Compilation compilation =
