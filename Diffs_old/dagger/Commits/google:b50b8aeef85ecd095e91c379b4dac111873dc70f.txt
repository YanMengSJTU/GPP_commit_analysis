diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 785093357..87b3dca0e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -49,7 +49,6 @@
 import static dagger.internal.codegen.TypeNames.DELEGATE_FACTORY;
 import static dagger.internal.codegen.TypeNames.DOUBLE_CHECK;
 import static dagger.internal.codegen.TypeNames.FACTORY;
-import static dagger.internal.codegen.TypeNames.ILLEGAL_STATE_EXCEPTION;
 import static dagger.internal.codegen.TypeNames.INSTANCE_FACTORY;
 import static dagger.internal.codegen.TypeNames.LISTENABLE_FUTURE;
 import static dagger.internal.codegen.TypeNames.MAP_FACTORY;
@@ -66,13 +65,9 @@
 import static dagger.internal.codegen.TypeNames.SET_OF_PRODUCED_PRODUCER;
 import static dagger.internal.codegen.TypeNames.SET_PRODUCER;
 import static dagger.internal.codegen.TypeNames.SINGLE_CHECK;
-import static dagger.internal.codegen.TypeNames.STRING;
 import static dagger.internal.codegen.TypeNames.TYPED_RELEASABLE_REFERENCE_MANAGER_DECORATOR;
-import static dagger.internal.codegen.TypeNames.UNSUPPORTED_OPERATION_EXCEPTION;
 import static dagger.internal.codegen.TypeNames.providerOf;
 import static dagger.internal.codegen.TypeSpecs.addSupertype;
-import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
-import static dagger.internal.codegen.Util.requiresAPassedInstance;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
@@ -102,11 +97,13 @@
 import com.squareup.javapoet.TypeSpec;
 import com.squareup.javapoet.TypeVariableName;
 import dagger.internal.DelegateFactory;
+import dagger.internal.InstanceFactory;
 import dagger.internal.MapFactory;
 import dagger.internal.MapProviderFactory;
 import dagger.internal.Preconditions;
 import dagger.internal.SetFactory;
 import dagger.internal.TypedReleasableReferenceManagerDecorator;
+import dagger.internal.codegen.ComponentDescriptor.BuilderRequirementMethod;
 import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.producers.Produced;
@@ -170,7 +167,7 @@
    * For each component requirement, the builder field. This map is empty for subcomponents that do
    * not use a builder.
    */
-  private ImmutableMap<TypeElement, FieldSpec> builderFields = ImmutableMap.of();
+  private ImmutableMap<ComponentRequirement, FieldSpec> builderFields = ImmutableMap.of();
 
   /**
    * For each component requirement, the member select for the component field that holds it.
@@ -178,7 +175,8 @@
    * <p>Fields are written for all requirements for subcomponents that do not use a builder, and for
    * any requirement that is reused from a subcomponent of this component.
    */
-  protected final Map<TypeElement, MemberSelect> componentContributionFields = Maps.newHashMap();
+  protected final Map<ComponentRequirement, MemberSelect> componentContributionFields =
+      Maps.newHashMap();
 
   /**
    * The member-selects for {@link dagger.internal.ReferenceReleasingProviderManager} fields,
@@ -226,40 +224,43 @@ protected final ClassName componentDefinitionTypeName() {
   }
 
   /**
-   * Returns an expression that evaluates to an instance of the contribution, looking for either a
+   * Returns an expression that evaluates to an instance of the requirement, looking for either a
    * builder field or a component field.
    */
-  private CodeBlock getComponentContributionExpression(TypeElement contributionType) {
-    if (builderFields.containsKey(contributionType)) {
-      return CodeBlock.of("builder.$N", builderFields.get(contributionType));
+  private CodeBlock getComponentContributionExpression(ComponentRequirement componentRequirement) {
+    if (builderFields.containsKey(componentRequirement)) {
+      return CodeBlock.of("builder.$N", builderFields.get(componentRequirement));
     } else {
       Optional<CodeBlock> codeBlock =
-          getOrCreateComponentContributionFieldExpression(contributionType);
-      checkState(codeBlock.isPresent(), "no builder or component field for %s", contributionType);
+          getOrCreateComponentRequirementFieldExpression(componentRequirement);
+      checkState(
+          codeBlock.isPresent(), "no builder or component field for %s", componentRequirement);
       return codeBlock.get();
     }
   }
 
   /**
-   * Returns an expression for a component contribution field. Adds a field the first time one is
-   * requested for a contribution type if this component's builder has a field for it.
+   * Returns an expression for a component requirement field. Adds a field the first time one is
+   * requested for a requirement if this component's builder has a field for it.
    */
-  protected Optional<CodeBlock> getOrCreateComponentContributionFieldExpression(
-      TypeElement contributionType) {
-    MemberSelect fieldSelect = componentContributionFields.get(contributionType);
+  protected Optional<CodeBlock> getOrCreateComponentRequirementFieldExpression(
+      ComponentRequirement componentRequirement) {
+    MemberSelect fieldSelect = componentContributionFields.get(componentRequirement);
     if (fieldSelect == null) {
-      if (!builderFields.containsKey(contributionType)) {
+      if (!builderFields.containsKey(componentRequirement)) {
         return Optional.absent();
       }
       FieldSpec componentField =
-          componentField(ClassName.get(contributionType), simpleVariableName(contributionType))
+          componentField(
+                  TypeName.get(componentRequirement.type()),
+                  simpleVariableName(componentRequirement.typeElement()))
               .addModifiers(PRIVATE, FINAL)
               .build();
       component.addField(componentField);
       constructor.addCode(
-          "this.$N = builder.$N;", componentField, builderFields.get(contributionType));
+          "this.$N = builder.$N;", componentField, builderFields.get(componentRequirement));
       fieldSelect = localField(name, componentField.name);
-      componentContributionFields.put(contributionType, fieldSelect);
+      componentContributionFields.put(componentRequirement, fieldSelect);
     }
     return Optional.of(fieldSelect.getExpressionFor(name));
   }
@@ -367,16 +368,18 @@ protected void addBuilder() {
    * Adds fields for each of the {@linkplain BindingGraph#componentRequirements component
    * requirements}. Regardless of builder spec, there is always one field per requirement.
    */
-  private ImmutableMap<TypeElement, FieldSpec> addBuilderFields(TypeSpec.Builder componentBuilder) {
+  private ImmutableMap<ComponentRequirement, FieldSpec> addBuilderFields(
+      TypeSpec.Builder componentBuilder) {
     UniqueNameSet builderFieldNames = new UniqueNameSet();
-    ImmutableMap.Builder<TypeElement, FieldSpec> builderFields = ImmutableMap.builder();
-    for (TypeElement contributionElement : graph.componentRequirements()) {
+    ImmutableMap.Builder<ComponentRequirement, FieldSpec> builderFields = ImmutableMap.builder();
+    for (ComponentRequirement componentRequirement : graph.componentRequirements()) {
       String contributionName =
-          builderFieldNames.getUniqueName(simpleVariableName(contributionElement));
+          builderFieldNames.getUniqueName(simpleVariableName(componentRequirement.typeElement()));
       FieldSpec builderField =
-          FieldSpec.builder(ClassName.get(contributionElement), contributionName, PRIVATE).build();
+          FieldSpec.builder(TypeName.get(componentRequirement.type()), contributionName, PRIVATE)
+              .build();
       componentBuilder.addField(builderField);
-      builderFields.put(contributionElement, builderField);
+      builderFields.put(componentRequirement, builderField);
     }
     return builderFields.build();
   }
@@ -397,18 +400,25 @@ private void addBuildMethod(
     }
     buildMethod.returns(componentDefinitionTypeName()).addModifiers(PUBLIC);
 
-    for (Map.Entry<TypeElement, FieldSpec> builderFieldEntry : builderFields.entrySet()) {
+    for (Map.Entry<ComponentRequirement, FieldSpec> builderFieldEntry : builderFields.entrySet()) {
       FieldSpec builderField = builderFieldEntry.getValue();
-      if (componentCanMakeNewInstances(builderFieldEntry.getKey())) {
-        buildMethod.addCode(
-            "if ($1N == null) { this.$1N = new $2T(); }", builderField, builderField.type);
-      } else if (requiresAPassedInstance(elements, types, builderFieldEntry.getKey())) {
-        buildMethod.addCode(
-            "if ($N == null) { throw new $T($T.class.getCanonicalName() + $S); }",
-            builderField,
-            ILLEGAL_STATE_EXCEPTION,
-            builderField.type,
-            " must be set");
+      switch (builderFieldEntry.getKey().nullPolicy(elements, types)) {
+        case NEW:
+          buildMethod.addCode(
+              "if ($1N == null) { this.$1N = new $2T(); }", builderField, builderField.type);
+          break;
+        case THROW:
+          buildMethod.addCode(
+              "if ($N == null) { throw new $T($T.class.getCanonicalName() + $S); }",
+              builderField,
+              IllegalStateException.class,
+              TypeNames.rawTypeName(builderField.type),
+              " must be set");
+          break;
+        case ALLOW:
+          break;
+        default:
+          throw new AssertionError(builderFieldEntry.getKey());
       }
     }
     buildMethod.addStatement("return new $T(this)", name);
@@ -421,27 +431,36 @@ private void addBuildMethod(
    */
   private void addBuilderMethods(
       TypeSpec.Builder componentBuilder, Optional<BuilderSpec> builderSpec) {
-    ImmutableSet<TypeElement> componentRequirements = graph.componentRequirements();
+    ImmutableSet<ComponentRequirement> componentRequirements = graph.componentRequirements();
     if (builderSpec.isPresent()) {
       UniqueNameSet parameterNames = new UniqueNameSet();
-      for (Map.Entry<TypeElement, ExecutableElement> builderMethodEntry :
-          builderSpec.get().methodMap().entrySet()) {
-        TypeElement builderMethodType = builderMethodEntry.getKey();
-        ExecutableElement specMethod = builderMethodEntry.getValue();
+      for (BuilderRequirementMethod requirementMethod : builderSpec.get().requirementMethods()) {
+        ComponentRequirement builderRequirement = requirementMethod.requirement();
+        ExecutableElement specMethod = requirementMethod.method();
         MethodSpec.Builder builderMethod = addBuilderMethodFromSpec(specMethod);
-        String parameterName =
-            parameterNames.getUniqueName(
-                Iterables.getOnlyElement(specMethod.getParameters()).getSimpleName());
-        builderMethod.addParameter(ClassName.get(builderMethodType), parameterName);
-        if (componentRequirements.contains(builderMethodType)) {
+        VariableElement parameterElement = Iterables.getOnlyElement(specMethod.getParameters());
+        String parameterName = parameterNames.getUniqueName(parameterElement.getSimpleName());
+
+        TypeName argType =
+            parameterElement.asType().getKind().isPrimitive()
+                // Primitives need to use the original (unresolved) type to avoid boxing.
+                ? TypeName.get(parameterElement.asType())
+                // Otherwise we use the full resolved type.
+                : TypeName.get(builderRequirement.type());
+
+        builderMethod.addParameter(argType, parameterName);
+        if (componentRequirements.contains(builderRequirement)) {
           // required type
           builderMethod.addStatement(
-              "this.$N = $T.checkNotNull($L)",
-              builderFields.get(builderMethodType),
-              Preconditions.class,
-              parameterName);
+              "this.$N = $L",
+              builderFields.get(builderRequirement),
+              builderRequirement
+                      .nullPolicy(elements, types)
+                      .equals(ComponentRequirement.NullPolicy.ALLOW)
+                  ? parameterName
+                  : CodeBlock.of("$T.checkNotNull($L)", Preconditions.class, parameterName));
           addBuilderMethodReturnStatementForSpec(specMethod, builderMethod);
-        } else if (graph.ownedModuleTypes().contains(builderMethodType)) {
+        } else if (graph.ownedModuleTypes().contains(builderRequirement.typeElement())) {
           // owned, but not required
           builderMethod.addJavadoc(NOOP_BUILDER_METHOD_JAVADOC);
           addBuilderMethodReturnStatementForSpec(specMethod, builderMethod);
@@ -449,21 +468,21 @@ private void addBuilderMethods(
           // neither owned nor required, so it must be an inherited module
           builderMethod.addStatement(
               "throw new $T($T.format($S, $T.class.getCanonicalName()))",
-              UNSUPPORTED_OPERATION_EXCEPTION,
-              STRING,
+              UnsupportedOperationException.class,
+              String.class,
               "%s cannot be set because it is inherited from the enclosing component",
-              ClassName.get(builderMethodType));
+              TypeNames.rawTypeName(TypeName.get(builderRequirement.type())));
         }
         componentBuilder.addMethod(builderMethod.build());
       }
     } else {
-      for (TypeElement componentRequirement : graph.availableDependencies()) {
-        String componentRequirementName = simpleVariableName(componentRequirement);
+      for (ComponentRequirement componentRequirement : graph.availableDependencies()) {
+        String componentRequirementName = simpleVariableName(componentRequirement.typeElement());
         MethodSpec.Builder builderMethod =
             methodBuilder(componentRequirementName)
                 .returns(builderName.get())
                 .addModifiers(PUBLIC)
-                .addParameter(ClassName.get(componentRequirement), componentRequirementName);
+                .addParameter(ClassName.get(componentRequirement.type()), componentRequirementName);
         if (componentRequirements.contains(componentRequirement)) {
           builderMethod.addStatement(
               "this.$N = $T.checkNotNull($L)",
@@ -1081,7 +1100,7 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
             bindingKeyTypeName.equals(componentDefinitionTypeName())
                 ? "this"
                 : getComponentContributionExpression(
-                    MoreTypes.asTypeElement(binding.key().type())));
+                    ComponentRequirement.forDependency(binding.key().type())));
 
       case COMPONENT_PROVISION:
         {
@@ -1100,7 +1119,8 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
               binding.nullableType().isPresent()
                       || compilerOptions.nullableValidationKind().equals(Diagnostic.Kind.WARNING)
                   ? CodeBlock.of("return $L;", callFactoryMethod)
-                  : CodeBlock.of("return $T.checkNotNull($L, $S);",
+                  : CodeBlock.of(
+                      "return $T.checkNotNull($L, $S);",
                       Preconditions.class,
                       callFactoryMethod,
                       CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD);
@@ -1115,7 +1135,8 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
                       "}"),
               /* 1 */ FACTORY,
               /* 2 */ bindingKeyTypeName,
-              /* 3 */ getComponentContributionExpression(dependencyType),
+              /* 3 */ getComponentContributionExpression(
+                  ComponentRequirement.forDependency(dependencyType.asType())),
               /* 4 */ nullableAnnotation(binding.nullableType()),
               /* 5 */ TypeName.get(dependencyType.asType()),
               /* 6 */ dependencyVariable,
@@ -1140,13 +1161,22 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
             /* 2 */ bindingKeyTypeName,
             /* 3 */ subcomponentName);
 
+      case BUILDER_BINDING:
+        return CodeBlock.of(
+            "$T.$L($L)",
+            InstanceFactory.class,
+            binding.nullableType().isPresent() ? "createNullable" : "create",
+            getComponentContributionExpression(ComponentRequirement.forBinding(binding)));
+
       case INJECTION:
       case PROVISION:
         {
           List<CodeBlock> arguments =
               Lists.newArrayListWithCapacity(binding.explicitDependencies().size() + 1);
           if (binding.requiresModuleInstance()) {
-            arguments.add(getComponentContributionExpression(binding.contributingModule().get()));
+            arguments.add(
+                getComponentContributionExpression(
+                    ComponentRequirement.forModule(binding.contributingModule().get().asType())));
           }
           arguments.addAll(getDependencyArguments(binding));
 
@@ -1175,7 +1205,8 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
               /* 1 */ PRODUCER,
               /* 2 */ TypeName.get(binding.key().type()),
               /* 3 */ LISTENABLE_FUTURE,
-              /* 4 */ getComponentContributionExpression(dependencyType),
+              /* 4 */ getComponentContributionExpression(
+                  ComponentRequirement.forDependency(dependencyType.asType())),
               /* 5 */ binding.bindingElement().get().getSimpleName(),
               /* 6 */ TypeName.get(dependencyType.asType()),
               /* 7 */ simpleVariableName(dependencyType));
@@ -1186,7 +1217,9 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
           List<CodeBlock> arguments =
               Lists.newArrayListWithCapacity(binding.dependencies().size() + 2);
           if (binding.requiresModuleInstance()) {
-            arguments.add(getComponentContributionExpression(binding.contributingModule().get()));
+            arguments.add(
+                getComponentContributionExpression(
+                    ComponentRequirement.forModule(binding.contributingModule().get().asType())));
           }
           arguments.addAll(getDependencyArguments(binding));
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index 129619bb5..0443fffa0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -16,11 +16,8 @@
 
 package dagger.internal.codegen;
 
-import static com.google.auto.common.MoreElements.hasModifiers;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
-import static com.google.common.base.Predicates.in;
-import static com.google.common.base.Predicates.not;
 import static com.google.common.base.Verify.verify;
 import static com.google.common.collect.Iterables.isEmpty;
 import static dagger.internal.codegen.BindingKey.contribution;
@@ -54,6 +51,7 @@
 import com.google.common.collect.TreeTraverser;
 import dagger.Reusable;
 import dagger.Subcomponent;
+import dagger.internal.codegen.ComponentDescriptor.BuilderRequirementMethod;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.internal.codegen.ContributionBinding.Kind;
 import dagger.internal.codegen.Key.HasKey;
@@ -69,6 +67,8 @@
 import java.util.Queue;
 import java.util.Set;
 import java.util.concurrent.ExecutionException;
+import java.util.stream.Stream;
+import java.util.stream.StreamSupport;
 import javax.inject.Inject;
 import javax.inject.Provider;
 import javax.lang.model.element.AnnotationMirror;
@@ -135,27 +135,43 @@ TypeElement componentType() {
 
   /**
    * The types for which the component needs instances.
+   *
    * <ul>
-   * <li>component dependencies
-   * <li>{@linkplain #ownedModules() owned modules} with concrete instance bindings that are used in
-   *     the graph
+   *   <li>component dependencies
+   *   <li>{@linkplain #ownedModules() owned modules} with concrete instance bindings that are used
+   *       in the graph
+   *   <li>bound instances
    * </ul>
    */
   @Memoized
-  ImmutableSet<TypeElement> componentRequirements() {
-    return SUBGRAPH_TRAVERSER
-        .preOrderTraversal(this)
-        .transformAndConcat(graph -> graph.resolvedBindings().values())
-        .transformAndConcat(ResolvedBindings::contributionBindings)
+  ImmutableSet<ComponentRequirement> componentRequirements() {
+    ImmutableSet.Builder<ComponentRequirement> requirements = ImmutableSet.builder();
+    StreamSupport.stream(SUBGRAPH_TRAVERSER.preOrderTraversal(this).spliterator(), false)
+        .flatMap(graph -> graph.resolvedBindings().values().stream())
+        .flatMap(bindings -> bindings.contributionBindings().stream())
         .filter(ContributionBinding::requiresModuleInstance)
-        .transformAndConcat(bindingDeclaration -> bindingDeclaration.contributingModule().asSet())
-        .filter(in(ownedModuleTypes()))
-        .append(componentDescriptor().dependencies())
-        .toSet();
+        .flatMap(bindingDeclaration -> bindingDeclaration.contributingModule().asSet().stream())
+        .filter(module -> ownedModuleTypes().contains(module))
+        .map(module -> ComponentRequirement.forModule(module.asType()))
+        .forEach(requirements::add);
+    componentDescriptor()
+        .dependencies()
+        .stream()
+        .map(dep -> ComponentRequirement.forDependency(dep.asType()))
+        .forEach(requirements::add);
+    if (componentDescriptor().builderSpec().isPresent()) {
+      componentDescriptor()
+          .builderSpec()
+          .get()
+          .requirementMethods()
+          .stream()
+          .map(BuilderRequirementMethod::requirement)
+          .filter(req -> req.kind().equals(ComponentRequirement.Kind.BINDING))
+          .forEach(requirements::add);
+    }
+    return requirements.build();
   }
-  /**
-   * Returns the {@link ComponentDescriptor}s for this component and its subcomponents.
-   */
+  /** Returns the {@link ComponentDescriptor}s for this component and its subcomponents. */
   ImmutableSet<ComponentDescriptor> componentDescriptors() {
     return SUBGRAPH_TRAVERSER
         .preOrderTraversal(this)
@@ -163,11 +179,18 @@ TypeElement componentType() {
         .toSet();
   }
 
-  ImmutableSet<TypeElement> availableDependencies() {
-    return FluentIterable.from(componentDescriptor().transitiveModuleTypes())
-        .filter(not(hasModifiers(ABSTRACT)))
-        .append(componentDescriptor().dependencies())
-        .toSet();
+  ImmutableSet<ComponentRequirement> availableDependencies() {
+    return Stream.concat(
+            componentDescriptor()
+                .transitiveModuleTypes()
+                .stream()
+                .filter(dep -> !dep.getModifiers().contains(ABSTRACT))
+                .map(module -> ComponentRequirement.forModule(module.asType())),
+            componentDescriptor()
+                .dependencies()
+                .stream()
+                .map(dep -> ComponentRequirement.forDependency(dep.asType())))
+        .collect(toImmutableSet());
   }
 
   static final class Factory {
@@ -221,6 +244,16 @@ private BindingGraph create(
         }
       }
 
+      // Collect bindings on the builder.
+      if (componentDescriptor.builderSpec().isPresent()) {
+        for (BuilderRequirementMethod method :
+            componentDescriptor.builderSpec().get().requirementMethods()) {
+          if (method.requirement().kind().equals(ComponentRequirement.Kind.BINDING)) {
+            explicitBindingsBuilder.add(provisionBindingFactory.forBuilderBinding(method));
+          }
+        }
+      }
+
       for (Map.Entry<ComponentMethodDescriptor, ComponentDescriptor>
           componentMethodAndSubcomponent :
               componentDescriptor.subcomponentsByBuilderMethod().entrySet()) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index a0e018c97..32d864e49 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -64,14 +64,16 @@
 import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
 import static dagger.internal.codegen.Util.isAnnotationPresent;
 import static dagger.internal.codegen.Util.toImmutableSet;
+import static java.util.stream.Collectors.groupingBy;
 import static java.util.stream.Collectors.joining;
+import static java.util.stream.Collectors.mapping;
+import static java.util.stream.Collectors.toList;
 import static java.util.stream.Collectors.toSet;
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.Equivalence;
 import com.google.common.base.Optional;
-import com.google.common.base.Predicates;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableListMultimap;
@@ -79,7 +81,6 @@
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.ImmutableSortedMap;
 import com.google.common.collect.LinkedHashMultimap;
-import com.google.common.collect.Maps;
 import com.google.common.collect.Multimap;
 import com.google.common.collect.Multimaps;
 import com.google.common.collect.SetMultimap;
@@ -89,7 +90,10 @@
 import dagger.Component;
 import dagger.Lazy;
 import dagger.MapKey;
+import dagger.internal.codegen.ComponentDescriptor.BuilderRequirementMethod;
 import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
+import dagger.internal.codegen.ComponentTreeTraverser.BindingGraphTraverser;
+import dagger.internal.codegen.ComponentTreeTraverser.ComponentTreePath;
 import dagger.internal.codegen.ContributionType.HasContributionType;
 import dagger.releasablereferences.CanReleaseReferences;
 import dagger.releasablereferences.ForReleasableReferences;
@@ -210,8 +214,11 @@ protected void visitSubcomponentFactoryMethod(
               .stream()
               .filter(
                   componentRequirement ->
-                      !subgraphFactoryMethodParameters(parent, factoryMethod)
-                          .contains(componentRequirement))
+                      componentRequirement.kind().equals(ComponentRequirement.Kind.MODULE))
+              .map(ComponentRequirement::typeElement)
+              .filter(
+                  moduleType ->
+                      !subgraphFactoryMethodParameters(parent, factoryMethod).contains(moduleType))
               .filter(moduleType -> !componentCanMakeNewInstances(moduleType))
               .collect(toSet());
       if (!missingModules.isEmpty()) {
@@ -346,18 +353,34 @@ private void validateBuilders(BindingGraph graph) {
         return;
       }
 
-      Set<TypeElement> availableDependencies = graph.availableDependencies();
-      Set<TypeElement> requiredDependencies =
-          Sets.filter(availableDependencies, input -> !componentCanMakeNewInstances(input));
+      Set<ComponentRequirement> availableDependencies = graph.availableDependencies();
+      Set<ComponentRequirement> requiredDependencies =
+          Sets.filter(
+              availableDependencies, input -> !componentCanMakeNewInstances(input.typeElement()));
       final BuilderSpec spec = componentDesc.builderSpec().get();
-      Map<TypeElement, ExecutableElement> allSetters = spec.methodMap();
+      ImmutableSet<BuilderRequirementMethod> declaredSetters =
+          spec.requirementMethods()
+              .stream()
+              .filter(
+                  method -> !method.requirement().kind().equals(ComponentRequirement.Kind.BINDING))
+              .collect(toImmutableSet());
+      ImmutableSet<ComponentRequirement> declaredRequirements =
+          declaredSetters
+              .stream()
+              .map(BuilderRequirementMethod::requirement)
+              .collect(toImmutableSet());
 
       ErrorMessages.ComponentBuilderMessages msgs =
           ErrorMessages.builderMsgsFor(graph.componentDescriptor().kind());
-      Set<TypeElement> extraSetters = Sets.difference(allSetters.keySet(), availableDependencies);
+      Set<ComponentRequirement> extraSetters =
+          Sets.difference(declaredRequirements, availableDependencies);
       if (!extraSetters.isEmpty()) {
-        Collection<ExecutableElement> excessMethods =
-            Maps.filterKeys(allSetters, Predicates.in(extraSetters)).values();
+        List<ExecutableElement> excessMethods =
+            declaredSetters
+                .stream()
+                .filter(method -> extraSetters.contains(method.requirement()))
+                .map(BuilderRequirementMethod::method)
+                .collect(toList());
         Optional<DeclaredType> container =
             Optional.of(MoreTypes.asDeclared(spec.builderDefinitionType().asType()));
         String formatted =
@@ -369,11 +392,36 @@ private void validateBuilders(BindingGraph graph) {
             .addError(String.format(msgs.extraSetters(), formatted), spec.builderDefinitionType());
       }
 
-      Set<TypeElement> missingSetters = Sets.difference(requiredDependencies, allSetters.keySet());
+      Set<ComponentRequirement> missingSetters =
+          Sets.difference(requiredDependencies, declaredRequirements);
       if (!missingSetters.isEmpty()) {
         report(graph)
             .addError(
-                String.format(msgs.missingSetters(), missingSetters), spec.builderDefinitionType());
+                String.format(
+                    msgs.missingSetters(),
+                    missingSetters.stream().map(ComponentRequirement::type).collect(toList())),
+                spec.builderDefinitionType());
+      }
+
+      // Validate that declared builder requirements (modules, dependencies) have unique types.
+      Map<Equivalence.Wrapper<TypeMirror>, List<ExecutableElement>> declaredRequirementsByType =
+          spec.requirementMethods()
+              .stream()
+              .filter(
+                  method -> !method.requirement().kind().equals(ComponentRequirement.Kind.BINDING))
+              .collect(
+                  groupingBy(
+                      method -> method.requirement().wrappedType(),
+                      mapping(method -> method.method(), toList())));
+      for (Map.Entry<Equivalence.Wrapper<TypeMirror>, List<ExecutableElement>> entry :
+          declaredRequirementsByType.entrySet()) {
+        if (entry.getValue().size() > 1) {
+          TypeMirror type = entry.getKey().get();
+          report(graph)
+              .addError(
+                  String.format(msgs.manyMethodsForType(), type, entry.getValue()),
+                  spec.builderDefinitionType());
+        }
       }
     }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java b/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java
index 7b2038e5d..5b4337ad1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java
@@ -25,14 +25,8 @@
 import static javax.lang.model.element.Modifier.STATIC;
 
 import com.google.auto.common.MoreTypes;
-import com.google.common.base.Equivalence;
-import com.google.common.collect.Iterables;
-import com.google.common.collect.LinkedHashMultimap;
-import com.google.common.collect.Multimap;
 import java.lang.annotation.Annotation;
-import java.util.Collection;
 import java.util.List;
-import java.util.Map;
 import java.util.Set;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
@@ -108,8 +102,6 @@
     }
 
     ExecutableElement buildMethod = null;
-    Multimap<Equivalence.Wrapper<TypeMirror>, ExecutableElement> methodsPerParam =
-        LinkedHashMultimap.create();
     for (ExecutableElement method : getUnimplementedMethods(elements, types, subject)) {
       ExecutableType resolvedMethodType =
           MoreTypes.asExecutable(types.asMemberOf(MoreTypes.asDeclared(subject.asType()), method));
@@ -134,18 +126,16 @@
       } else if (returnType.getKind() != TypeKind.VOID
           && !types.isSubtype(subject.asType(), returnType)) {
         // If this correctly had one arg, make sure the return types are valid.
-        error(builder, method, msgs.methodsMustReturnVoidOrBuilder(),
+        error(
+            builder,
+            method,
+            msgs.methodsMustReturnVoidOrBuilder(),
             msgs.inheritedMethodsMustReturnVoidOrBuilder());
-      } else {
-        // If the return types are valid, record the method.
-        methodsPerParam.put(
-            MoreTypes.equivalence().<TypeMirror>wrap(
-                Iterables.getOnlyElement(resolvedMethodType.getParameterTypes())),
-            method);
-      }
-
-      if (!method.getTypeParameters().isEmpty()) {
-        error(builder, method, msgs.methodsMayNotHaveTypeParameters(),
+      } else if (!method.getTypeParameters().isEmpty()) {
+        error(
+            builder,
+            method,
+            msgs.methodsMayNotHaveTypeParameters(),
             msgs.inheritedMethodsMayNotHaveTypeParameters());
       }
     }
@@ -154,18 +144,9 @@
       builder.addError(msgs.missingBuildMethod(), subject);
     }
 
-    // Go back through each recorded method per param type.  If we had more than one method
-    // for a given param, fail.
-    for (Map.Entry<Equivalence.Wrapper<TypeMirror>, Collection<ExecutableElement>> entry :
-        methodsPerParam.asMap().entrySet()) {
-      if (entry.getValue().size() > 1) {
-        TypeMirror type = entry.getKey().get();
-        builder.addError(String.format(msgs.manyMethodsForType(), type, entry.getValue()), subject);
-      }
-    }
-
-    // Note: there's more validation in BindingGraphValidator,
-    // specifically to make sure the setter methods mirror the deps.
+    // Note: there's more validation in BindingGraphValidator:
+    // - to make sure the setter methods mirror the deps
+    // - to make sure each type or key is set by only one method
 
     return builder.build();
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index d8a77d6aa..a27768703 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -58,7 +58,6 @@
 import java.util.EnumSet;
 import java.util.LinkedHashSet;
 import java.util.List;
-import java.util.Map;
 import java.util.Set;
 import javax.inject.Provider;
 import javax.lang.model.element.AnnotationMirror;
@@ -103,7 +102,7 @@
     static Optional<Kind> forAnnotatedElement(TypeElement element) {
       Set<Kind> kinds = EnumSet.noneOf(Kind.class);
       for (Kind kind : values()) {
-        if (MoreElements.isAnnotationPresent(element, kind.annotationType())) {
+        if (isAnnotationPresent(element, kind.annotationType())) {
           kinds.add(kind);
         }
       }
@@ -122,7 +121,7 @@
     static Optional<Kind> forAnnotatedBuilderElement(TypeElement element) {
       Set<Kind> kinds = EnumSet.noneOf(Kind.class);
       for (Kind kind : values()) {
-        if (MoreElements.isAnnotationPresent(element, kind.builderAnnotationType())) {
+        if (isAnnotationPresent(element, kind.builderAnnotationType())) {
           kinds.add(kind);
         }
       }
@@ -428,10 +427,17 @@ Kind componentKind() {
     }
   }
 
+  @AutoValue
+  abstract static class BuilderRequirementMethod {
+    abstract ExecutableElement method();
+
+    abstract ComponentRequirement requirement();
+  }
+
   @AutoValue
   abstract static class BuilderSpec {
     abstract TypeElement builderDefinitionType();
-    abstract Map<TypeElement, ExecutableElement> methodMap();
+    abstract ImmutableSet<BuilderRequirementMethod> requirementMethods();
     abstract ExecutableElement buildMethod();
     abstract TypeMirror componentType();
   }
@@ -661,7 +667,7 @@ private ComponentMethodDescriptor getDescriptorForComponentMethod(
       }
       TypeElement element = MoreTypes.asTypeElement(builderType.get());
       ImmutableSet<ExecutableElement> methods = getUnimplementedMethods(elements, types, element);
-      ImmutableMap.Builder<TypeElement, ExecutableElement> map = ImmutableMap.builder();
+      ImmutableSet.Builder<BuilderRequirementMethod> requirementMethods = ImmutableSet.builder();
       ExecutableElement buildMethod = null;
       for (ExecutableElement method : methods) {
         if (method.getParameters().isEmpty()) {
@@ -669,12 +675,28 @@ private ComponentMethodDescriptor getDescriptorForComponentMethod(
         } else {
           ExecutableType resolved =
               MoreTypes.asExecutable(types.asMemberOf(builderType.get(), method));
-          map.put(MoreTypes.asTypeElement(getOnlyElement(resolved.getParameterTypes())), method);
+          requirementMethods.add(
+              new AutoValue_ComponentDescriptor_BuilderRequirementMethod(
+                  method, requirementForBuilderMethod(method, resolved)));
         }
       }
       verify(buildMethod != null); // validation should have ensured this.
-      return Optional.<BuilderSpec>of(new AutoValue_ComponentDescriptor_BuilderSpec(element,
-          map.build(), buildMethod, element.getEnclosingElement().asType()));
+      return Optional.of(
+          new AutoValue_ComponentDescriptor_BuilderSpec(
+              element,
+              requirementMethods.build(),
+              buildMethod,
+              element.getEnclosingElement().asType()));
+    }
+
+    private ComponentRequirement requirementForBuilderMethod(
+        ExecutableElement method, ExecutableType resolvedType) {
+      checkArgument(method.getParameters().size() == 1);
+
+      TypeMirror type = getOnlyElement(resolvedType.getParameterTypes());
+      return ConfigurationAnnotations.getModuleAnnotation(MoreTypes.asTypeElement(type)).isPresent()
+          ? ComponentRequirement.forModule(type)
+          : ComponentRequirement.forDependency(type);
     }
 
     /**
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentRequirement.java b/compiler/src/main/java/dagger/internal/codegen/ComponentRequirement.java
new file mode 100644
index 000000000..b5ca7a6c7
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentRequirement.java
@@ -0,0 +1,133 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
+import static dagger.internal.codegen.Util.requiresAPassedInstance;
+
+import com.google.auto.common.MoreTypes;
+import com.google.auto.value.AutoValue;
+import com.google.common.base.Equivalence;
+import java.util.Optional;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+
+/** A type that a component needs an instance of. */
+@AutoValue
+abstract class ComponentRequirement {
+  enum Kind {
+    /** A type listed in the component's {@code dependencies} attribute. */
+    DEPENDENCY,
+    /** A type listed in the component or subcomponent's {@code modules} attribute. */
+    MODULE,
+    /** An object key that can be bound to an instance provided to the builder. */
+    BINDING,
+  }
+
+  /** The kind of requirement. */
+  abstract Kind kind();
+
+  /**
+   * The type of the instance the component must have, wrapped so that requirements can be used as
+   * value types.
+   */
+  abstract Equivalence.Wrapper<TypeMirror> wrappedType();
+
+  /** The type of the instance the component must have. */
+  TypeMirror type() {
+    return wrappedType().get();
+  }
+
+  /** The element associated with the type of this requirement. */
+  TypeElement typeElement() {
+    return MoreTypes.asTypeElement(type());
+  }
+
+  /** The action a component builder should take if it {@code null} is passed. */
+  enum NullPolicy {
+    /** Make a new instance. */
+    NEW,
+    /** Throw an exception. */
+    THROW,
+    /** Allow use of null values. */
+    ALLOW,
+  }
+
+  /**
+   * An override for the requirement's null policy. If set, this is used as the null policy instead
+   * of the default behavior in {@link #nullPolicy}.
+   *
+   * <p>Some implementations' null policy can be determined upon construction (e.g., for binding
+   * instances), but others' require Elements and Types, which must wait until {@link #nullPolicy}
+   * is called.
+   */
+  abstract Optional<NullPolicy> overrideNullPolicy();
+
+  /** The requirement's null policy. */
+  NullPolicy nullPolicy(Elements elements, Types types) {
+    if (overrideNullPolicy().isPresent()) {
+      return overrideNullPolicy().get();
+    }
+    switch (kind()) {
+      case DEPENDENCY:
+        return NullPolicy.THROW;
+      case MODULE:
+        return componentCanMakeNewInstances(typeElement())
+            ? NullPolicy.NEW
+            : requiresAPassedInstance(elements, types, typeElement())
+                ? NullPolicy.THROW
+                : NullPolicy.ALLOW;
+      case BINDING:
+        return NullPolicy.THROW;
+    }
+    throw new AssertionError();
+  }
+
+  /** The key for this requirement, if one is available. */
+  abstract Optional<Key> key();
+
+  static ComponentRequirement forDependency(TypeMirror type) {
+    return new AutoValue_ComponentRequirement(
+        Kind.DEPENDENCY,
+        MoreTypes.equivalence().wrap(checkNotNull(type)),
+        Optional.<NullPolicy>empty(),
+        Optional.<Key>empty());
+  }
+
+  static ComponentRequirement forModule(TypeMirror type) {
+    return new AutoValue_ComponentRequirement(
+        Kind.MODULE,
+        MoreTypes.equivalence().wrap(checkNotNull(type)),
+        Optional.<NullPolicy>empty(),
+        Optional.<Key>empty());
+  }
+
+  static ComponentRequirement forBinding(Key key, boolean nullable) {
+    return new AutoValue_ComponentRequirement(
+        Kind.BINDING,
+        key.wrappedType(),
+        nullable ? Optional.of(NullPolicy.ALLOW) : Optional.<NullPolicy>empty(),
+        Optional.of(key));
+  }
+
+  static ComponentRequirement forBinding(ContributionBinding binding) {
+    return forBinding(binding.key(), binding.nullableType().isPresent());
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
index bb90d0a46..67ffa5e5e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
@@ -191,6 +191,6 @@ protected void addFactoryMethods() {
   private boolean canInstantiateAllRequirements() {
     return !Iterables.any(
         graph.componentRequirements(),
-        dependency -> requiresAPassedInstance(elements, types, dependency));
+        dependency -> requiresAPassedInstance(elements, types, dependency.typeElement()));
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
index 25936ad8d..b363d815f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
@@ -134,6 +134,9 @@
      */
     SUBCOMPONENT_BUILDER,
 
+    /** A builder binding method. */
+    BUILDER_BINDING,
+
     // Production kinds
 
     /** A {@link Produces}-annotated method. */
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index 70b207c0d..3a774cadc 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -33,8 +33,10 @@
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
 import com.google.common.collect.Sets;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import dagger.internal.codegen.ComponentDescriptor.BuilderRequirementMethod;
 import java.util.Set;
 import javax.annotation.CheckReturnValue;
 import javax.inject.Inject;
@@ -43,6 +45,7 @@
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeMirror;
@@ -263,6 +266,22 @@ ProvisionBinding forComponentMethod(ExecutableElement componentMethod) {
           .build();
     }
 
+    ProvisionBinding forBuilderBinding(BuilderRequirementMethod method) {
+      ExecutableElement builderMethod = method.method();
+
+      checkNotNull(builderMethod);
+      checkArgument(builderMethod.getKind().equals(METHOD));
+      checkArgument(builderMethod.getParameters().size() == 1);
+      VariableElement parameterElement = Iterables.getOnlyElement(builderMethod.getParameters());
+      return ProvisionBinding.builder()
+          .contributionType(ContributionType.UNIQUE)
+          .bindingElement(builderMethod)
+          .key(method.requirement().key().get())
+          .nullableType(ConfigurationAnnotations.getNullableType(parameterElement))
+          .bindingKind(Kind.BUILDER_BINDING)
+          .build();
+    }
+
     ProvisionBinding forSubcomponentBuilderMethod(
         ExecutableElement subcomponentBuilderMethod, TypeElement contributedBy) {
       checkNotNull(subcomponentBuilderMethod);
diff --git a/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
index d55fadcd6..3a9cbfc72 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
@@ -85,10 +85,10 @@ protected InitializationState getInitializationState(BindingKey bindingKey) {
   }
 
   @Override
-  protected Optional<CodeBlock> getOrCreateComponentContributionFieldExpression(
-      TypeElement contributionType) {
-    return super.getOrCreateComponentContributionFieldExpression(contributionType)
-        .or(parent.getOrCreateComponentContributionFieldExpression(contributionType));
+  protected Optional<CodeBlock> getOrCreateComponentRequirementFieldExpression(
+      ComponentRequirement componentRequirement) {
+    return super.getOrCreateComponentRequirementFieldExpression(componentRequirement)
+        .or(parent.getOrCreateComponentRequirementFieldExpression(componentRequirement));
   }
 
   @Override
@@ -177,9 +177,11 @@ private void writeSubcomponentWithoutBuilder(
     for (int i = 0; i < params.size(); i++) {
       VariableElement moduleVariable = params.get(i);
       TypeElement moduleTypeElement = MoreTypes.asTypeElement(paramTypes.get(i));
+      ComponentRequirement componentRequirement =
+          ComponentRequirement.forModule(moduleTypeElement.asType());
       TypeName moduleType = TypeName.get(paramTypes.get(i));
       componentMethod.addParameter(moduleType, moduleVariable.getSimpleName().toString());
-      if (!componentContributionFields.containsKey(moduleTypeElement)) {
+      if (!componentContributionFields.containsKey(componentRequirement)) {
         String preferredModuleName =
             CaseFormat.UPPER_CAMEL.to(LOWER_CAMEL, moduleTypeElement.getSimpleName().toString());
         FieldSpec contributionField =
@@ -197,16 +199,18 @@ private void writeSubcomponentWithoutBuilder(
                 Preconditions.class);
 
         MemberSelect moduleSelect = localField(name, actualModuleName);
-        componentContributionFields.put(moduleTypeElement, moduleSelect);
+        componentContributionFields.put(componentRequirement, moduleSelect);
         subcomponentConstructorParameters.add(
             CodeBlock.of("$L", moduleVariable.getSimpleName()));
       }
     }
 
-    Set<TypeElement> uninitializedModules =
+    Set<ComponentRequirement> uninitializedModules =
         difference(graph.componentRequirements(), componentContributionFields.keySet());
 
-    for (TypeElement moduleType : uninitializedModules) {
+    for (ComponentRequirement componentRequirement : uninitializedModules) {
+      checkState(componentRequirement.kind().equals(ComponentRequirement.Kind.MODULE));
+      TypeElement moduleType = componentRequirement.typeElement();
       String preferredModuleName =
           CaseFormat.UPPER_CAMEL.to(LOWER_CAMEL, moduleType.getSimpleName().toString());
       FieldSpec contributionField =
@@ -218,7 +222,7 @@ private void writeSubcomponentWithoutBuilder(
       constructor.addStatement(
           "this.$L = new $T()", actualModuleName, ClassName.get(moduleType));
       MemberSelect moduleSelect = localField(name, actualModuleName);
-      componentContributionFields.put(moduleType, moduleSelect);
+      componentContributionFields.put(componentRequirement, moduleSelect);
     }
 
     componentMethod.addStatement("return new $T($L)",
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java
index aa493b864..9a2343ad9 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java
@@ -757,57 +757,95 @@ public void testGenericsOnInheritedSetterMethodFails() {
 
   @Test
   public void testMultipleSettersPerTypeFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  @Component.Builder",
-        "  interface Builder {",
-        "    SimpleComponent build();",
-        "    void set1(String s);",
-        "    void set2(String s);",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "final class TestModule {",
+            "  @Provides String s() { return \"\"; }",
+            "}");
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "abstract class SimpleComponent {",
+            "  abstract String s();",
+            "",
+            "  @Component.Builder",
+            "  interface Builder {",
+            "    SimpleComponent build();",
+            "    void set1(TestModule s);",
+            "    void set2(TestModule s);",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(moduleFile, componentFile))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(
-            String.format(MSGS.manyMethodsForType(),
-                  "java.lang.String", "[set1(java.lang.String), set2(java.lang.String)]"))
-            .in(componentFile).onLine(9);
+            String.format(
+                MSGS.manyMethodsForType(),
+                "test.TestModule",
+                "[set1(test.TestModule), set2(test.TestModule)]"))
+        .in(componentFile)
+        .onLine(11);
   }
 
   @Test
   public void testMultipleSettersPerTypeIncludingResolvedGenericsFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  interface Parent<T> {",
-        "    void set1(T t);",
-        "  }",
-        "",
-        "  @Component.Builder",
-        "  interface Builder extends Parent<String> {",
-        "    SimpleComponent build();",
-        "    void set2(String s);",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "final class TestModule {",
+            "  @Provides String s() { return \"\"; }",
+            "}");
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "abstract class SimpleComponent {",
+            "  abstract String s();",
+            "",
+            "  interface Parent<T> {",
+            "    void set1(T t);",
+            "  }",
+            "",
+            "  @Component.Builder",
+            "  interface Builder extends Parent<TestModule> {",
+            "    SimpleComponent build();",
+            "    void set2(TestModule s);",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(moduleFile, componentFile))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(
-            String.format(MSGS.manyMethodsForType(),
-                  "java.lang.String", "[set1(T), set2(java.lang.String)]"))
-            .in(componentFile).onLine(13);
+            String.format(
+                MSGS.manyMethodsForType(), "test.TestModule", "[set1(T), set2(test.TestModule)]"))
+        .in(componentFile)
+        .onLine(15);
   }
 
   @Test
diff --git a/compiler/src/test/java/dagger/internal/codegen/SubcomponentBuilderValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/SubcomponentBuilderValidationTest.java
index 3cb0e16be..64a0b57a1 100644
--- a/compiler/src/test/java/dagger/internal/codegen/SubcomponentBuilderValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/SubcomponentBuilderValidationTest.java
@@ -572,55 +572,115 @@ public void testGenericsOnInheritedSetterMethodFails() {
 
   @Test
   public void testMultipleSettersPerTypeFails() {
-    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
-        "package test;",
-        "",
-        "import dagger.Subcomponent;",
-        "",
-        "@Subcomponent",
-        "abstract class ChildComponent {",
-        "  @Subcomponent.Builder",
-        "  interface Builder {",
-        "    ChildComponent build();",
-        "    void set1(String s);",
-        "    void set2(String s);",
-        "  }",
-        "}");
-    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "final class TestModule {",
+            "  @Provides String s() { return \"\"; }",
+            "}");
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.ParentComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface ParentComponent {",
+            "  ChildComponent.Builder childComponentBuilder();",
+            "}");
+    JavaFileObject childComponentFile =
+        JavaFileObjects.forSourceLines(
+            "test.ChildComponent",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = TestModule.class)",
+            "abstract class ChildComponent {",
+            "  abstract String s();",
+            "",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    ChildComponent build();",
+            "    void set1(TestModule s);",
+            "    void set2(TestModule s);",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(moduleFile, componentFile, childComponentFile))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(
-            String.format(MSGS.manyMethodsForType(),
-                  "java.lang.String", "[set1(java.lang.String), set2(java.lang.String)]"))
-            .in(childComponentFile).onLine(8);
+            String.format(
+                MSGS.manyMethodsForType(),
+                "test.TestModule",
+                "[set1(test.TestModule), set2(test.TestModule)]"))
+        .in(childComponentFile)
+        .onLine(10);
   }
 
   @Test
   public void testMultipleSettersPerTypeIncludingResolvedGenericsFails() {
-    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
-        "package test;",
-        "",
-        "import dagger.Subcomponent;",
-        "",
-        "@Subcomponent",
-        "abstract class ChildComponent {",
-        "  interface Parent<T> {",
-        "    void set1(T t);",
-        "  }",
-        "",
-        "  @Subcomponent.Builder",
-        "  interface Builder extends Parent<String> {",
-        "    ChildComponent build();",
-        "    void set2(String s);",
-        "  }",
-        "}");
-    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "final class TestModule {",
+            "  @Provides String s() { return \"\"; }",
+            "}");
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.ParentComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface ParentComponent {",
+            "  ChildComponent.Builder childComponentBuilder();",
+            "}");
+    JavaFileObject childComponentFile =
+        JavaFileObjects.forSourceLines(
+            "test.ChildComponent",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = TestModule.class)",
+            "abstract class ChildComponent {",
+            "  abstract String s();",
+            "",
+            "  interface Parent<T> {",
+            "    void set1(T t);",
+            "  }",
+            "",
+            "  @Subcomponent.Builder",
+            "  interface Builder extends Parent<TestModule> {",
+            "    ChildComponent build();",
+            "    void set2(TestModule s);",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(moduleFile, componentFile, childComponentFile))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(
-            String.format(MSGS.manyMethodsForType(),
-                  "java.lang.String", "[set1(T), set2(java.lang.String)]"))
-            .in(childComponentFile).onLine(12);
+            String.format(
+                MSGS.manyMethodsForType(), "test.TestModule", "[set1(T), set2(test.TestModule)]"))
+        .in(childComponentFile)
+        .onLine(14);
   }
 
   @Test
diff --git a/core/src/main/java/dagger/internal/InstanceFactory.java b/core/src/main/java/dagger/internal/InstanceFactory.java
index 8cb993f17..c3d1f5675 100644
--- a/core/src/main/java/dagger/internal/InstanceFactory.java
+++ b/core/src/main/java/dagger/internal/InstanceFactory.java
@@ -37,6 +37,20 @@
     return new InstanceFactory<T>(checkNotNull(instance, "instance cannot be null"));
   }
 
+  public static <T> Factory<T> createNullable(T instance) {
+    return instance == null
+        ? InstanceFactory.<T>nullInstanceFactory()
+        : new InstanceFactory<T>(instance);
+  }
+
+  @SuppressWarnings("unchecked") // bivariant implementation
+  private static <T> InstanceFactory<T> nullInstanceFactory() {
+    return (InstanceFactory<T>) NULL_INSTANCE_FACTORY;
+  }
+
+  private static final InstanceFactory<Object> NULL_INSTANCE_FACTORY =
+      new InstanceFactory<Object>(null);
+
   private final T instance;
 
   private InstanceFactory(T instance) {
