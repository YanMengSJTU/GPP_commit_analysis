diff --git a/compiler/src/main/java/dagger/internal/codegen/AnnotationMirrors.java b/compiler/src/main/java/dagger/internal/codegen/AnnotationMirrors.java
index c2f4c5842..eeb31af73 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AnnotationMirrors.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AnnotationMirrors.java
@@ -83,17 +83,18 @@
         return MoreTypes.equivalence()
             .equivalent(left.getAnnotationType(), right.getAnnotationType())
                 && AnnotationValues.equivalence().pairwise().equivalent(
-                    getAnnotationValuesWithDefaults(left),
-                    getAnnotationValuesWithDefaults(right));
+                    getAnnotationValuesWithDefaults(left).values(),
+                    getAnnotationValuesWithDefaults(right).values());
       }
 
-      @Override protected int doHash(AnnotationMirror annotation) {
-        DeclaredType type = annotation.getAnnotationType();
-        Iterable<AnnotationValue> annotationValues = getAnnotationValuesWithDefaults(annotation);
-        return Arrays.hashCode(new int[] {
-            MoreTypes.equivalence().hash(type),
-            AnnotationValues.equivalence().pairwise().hash(annotationValues)});
-      }
+        @Override
+        protected int doHash(AnnotationMirror annotation) {
+          DeclaredType type = annotation.getAnnotationType();
+          Iterable<AnnotationValue> annotationValues =
+              getAnnotationValuesWithDefaults(annotation).values();
+          return Arrays.hashCode(new int[] {MoreTypes.equivalence().hash(type),
+              AnnotationValues.equivalence().pairwise().hash(annotationValues)});
+        }
     };
 
   /**
@@ -117,15 +118,15 @@
    * {@link Elements#getElementValuesWithDefaults(AnnotationMirror)} but can be called
    * statically without an {@Elements} instance.
    */
-  static Iterable<AnnotationValue> getAnnotationValuesWithDefaults(
+  static Map<ExecutableElement, AnnotationValue> getAnnotationValuesWithDefaults(
       AnnotationMirror annotation) {
-    Map<ExecutableElement, AnnotationValue> values = Maps.newHashMap();
+    Map<ExecutableElement, AnnotationValue> values = Maps.newLinkedHashMap();
     for (ExecutableElement method :
         ElementFilter.methodsIn(annotation.getAnnotationType().asElement().getEnclosedElements())) {
       values.put(method, method.getDefaultValue());
     }
     values.putAll(annotation.getElementValues());
-    return values.values();
+    return values;
   }
   
   static ImmutableSet<? extends AnnotationMirror> getAnnotatedAnnotations(Element element,
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index 4a01bd0f0..20ccdcc23 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -20,6 +20,7 @@
 import com.google.common.base.Functions;
 import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
+import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
@@ -31,6 +32,7 @@
 import com.google.common.collect.Sets;
 import dagger.Component;
 import dagger.Factory;
+import dagger.MapKey;
 import dagger.MembersInjector;
 import dagger.internal.InstanceFactory;
 import dagger.internal.MapProviderFactory;
@@ -61,6 +63,7 @@
 import javax.inject.Provider;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
+import javax.lang.model.element.AnnotationValueVisitor;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
@@ -69,6 +72,7 @@
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.SimpleAnnotationValueVisitor6;
 
 import static com.google.common.base.CaseFormat.LOWER_CAMEL;
 import static dagger.internal.codegen.ConfigurationAnnotations.getMapKeys;
@@ -462,8 +466,87 @@ private void writeEntry(ConstructorWriter constructorWriter, ProvisionBinding bi
         Iterables.getOnlyElement(getMapKeys(binding.bindingElement()));
     Map<? extends ExecutableElement, ? extends AnnotationValue> map =
         mapKeyAnnotationMirror.getElementValues();
-    // TODO(gak): this somewhat wrongly relies on the toString of AnnotationValue being valid java
-    constructorWriter.body().addSnippet("    .put(%s, %s)",
-        Iterables.getOnlyElement(map.entrySet()).getValue(), factory);
+    MapKey mapKey =
+        mapKeyAnnotationMirror.getAnnotationType().asElement().getAnnotation(MapKey.class);
+    if (!mapKey.unwrapValue()) {// wrapped key case
+      FluentIterable<AnnotationValue> originIterable = FluentIterable.from(
+          AnnotationMirrors.getAnnotationValuesWithDefaults(mapKeyAnnotationMirror).values());
+      FluentIterable<Snippet> annotationValueNames =
+          originIterable.transform(new Function<AnnotationValue, Snippet>() {
+            @Override
+            public Snippet apply(AnnotationValue value) {
+              return getValueSnippet(value);
+            }
+          });
+      ImmutableList.Builder<Snippet> snippets = ImmutableList.builder();
+      for (Snippet snippet : annotationValueNames) {
+        snippets.add(snippet);
+      }
+      constructorWriter.body().addSnippet("    .put(%sCreator.create(%s),%n         %s)",
+          TypeNames.forTypeMirror(mapKeyAnnotationMirror.getAnnotationType()),
+          Snippet.makeParametersSnippet(snippets.build()), factory);
+    } else { // unwrapped key case
+      constructorWriter.body().addSnippet("    .put(%s, %s)",
+          getValueSnippet(Iterables.getOnlyElement(map.entrySet()).getValue()), factory);
+    }
+  }
+
+  // Get the string representation of a Annotation Value
+  // TODO(user) write corresponding test to verify the AnnotationValueVisitor is right
+  private Snippet getValueSnippet(AnnotationValue value) {
+    AnnotationValueVisitor<Snippet, Void> mapKeyVisitor =
+        new SimpleAnnotationValueVisitor6<Snippet, Void>() {
+          @Override
+          public Snippet visitEnumConstant(VariableElement c, Void p) {
+            return Snippet.format("%s.%s",
+                TypeNames.forTypeMirror(c.getEnclosingElement().asType()), c.getSimpleName());
+          }
+
+          @Override
+          public Snippet visitAnnotation(AnnotationMirror a, Void p) {
+            if (a.getElementValues().isEmpty()) {
+              return Snippet.format("@%s", TypeNames.forTypeMirror(a.getAnnotationType()));
+            } else {
+              Map<ExecutableElement, AnnotationValue> map =
+                  AnnotationMirrors.getAnnotationValuesWithDefaults(a);
+              // build "@Annotation(a = , b = , c = ))
+              ImmutableList.Builder<Snippet> snippets = ImmutableList.builder();
+              for (Entry<ExecutableElement, AnnotationValue> entry : map.entrySet()) {
+                snippets.add(Snippet.format("%s = %s",
+                    TypeNames.forTypeMirror(entry.getKey().asType()),
+                    getValueSnippet(entry.getValue())));
+
+              }
+              return Snippet.format("@%s(%s)", TypeNames.forTypeMirror(a.getAnnotationType()),
+                  Snippet.makeParametersSnippet(snippets.build()));
+            }
+          }
+
+          @Override
+          public Snippet visitType(TypeMirror t, Void p) {
+            return Snippet.format("%s", TypeNames.forTypeMirror(t));
+          }
+
+          @Override
+          public Snippet visitString(String s, Void p) {
+            return Snippet.format("\"%s\"", s);
+          }
+
+          @Override
+          protected Snippet defaultAction(Object o, Void v) {
+            return Snippet.format("%s", o);
+          }
+
+          @Override
+          public Snippet visitArray(List<? extends AnnotationValue> values, Void v) {
+            ImmutableList.Builder<Snippet> snippets = ImmutableList.builder();
+            for (int i = 0; i < values.size(); i++) {
+              snippets.add(values.get(i).accept(this, null));
+            }
+            return Snippet.format("[%s]", Snippet.makeParametersSnippet(snippets.build()));
+          }
+        };
+    return value.accept(mapKeyVisitor, null);
   }
+
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index 41bc547c3..dcf54d775 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -15,11 +15,14 @@
  */
 package dagger.internal.codegen;
 
+import dagger.MapKey;
+
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import dagger.Component;
 import dagger.Module;
 import dagger.Provides;
+import dagger.internal.codegen.MembersInjectionBinding.InjectionSite;
 import java.util.Set;
 import javax.annotation.processing.AbstractProcessor;
 import javax.annotation.processing.Filer;
@@ -50,7 +53,8 @@
         Component.class.getName(),
         Inject.class.getName(),
         Module.class.getName(),
-        Provides.class.getName());
+        Provides.class.getName(),
+        MapKey.class.getName());
   }
 
   @Override
@@ -97,11 +101,13 @@ public synchronized void init(ProcessingEnvironment processingEnv) {
     ComponentDescriptor.Factory componentDescriptorFactory =
         new ComponentDescriptor.Factory(elements, types, injectBindingRegistry,
             provisionBindingFactory, dependencyRequestFactory);
+    MapKeyGenerator mapKeyGenerator = new MapKeyGenerator(filer);
 
     this.processingSteps = ImmutableList.<ProcessingStep>of(
         new MapKeyProcessingStep(
             messager,
-            mapKeyValidator),
+            mapKeyValidator,
+            mapKeyGenerator),
         new InjectProcessingStep(
             messager,
             injectConstructorValidator,
@@ -132,4 +138,4 @@ public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment
     }
     return false;
   }
-}
+}
\ No newline at end of file
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index bcf108701..001a42b7a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -115,24 +115,22 @@
   static final String PROVIDES_METHOD_WITH_MULTIPLE_MAP_KEY =
       "@Provides methods may not have more than one @MapKey-marked annotation";
 
-  static final String PROVIDES_METHOD_WITH_UNSUPPORTED_MAP_KEY =
-      "@Provides methods only support String and Enum key types";
-
   static final String PROVIDES_METHOD_WITH_SAME_NAME =
       "Cannot have more than one @Provides method with the same name in a single module";
-  
-  static final String WRAP_MAPKEY =
-      "unwrapValue = false is not yet supported";
-  
+
+  /*mapKey errors*/
+  static final String MAPKEY_WITHOUT_FIELDS = 
+      "Map key annotation does not have fields";
+
   /* collection binding errors */
   static final String NON_SETBINDING =
-      "more than one binding present including at least a set binding and a non-set binding";
+      "More than one binding present including at least a set binding and a non-set binding";
 
   static final String NON_MAPBINDING =
-      "more than one binding present including at least a map binding and a non-map binding";
+      "More than one binding present including at least a map binding and a non-map binding";
 
   static final String INVALID_COLLECTIONBINDING =
-      "more than one binding present, but found an invalid binding";
+      "More than one binding present, but found an invalid binding";
 
   private ErrorMessages() {}
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index e7087ed13..874e9f2e8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -15,6 +15,8 @@
  */
 package dagger.internal.codegen;
 
+import dagger.MapKey;
+
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
@@ -36,7 +38,6 @@
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
-
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static dagger.internal.codegen.ConfigurationAnnotations.getMapKeys;
@@ -141,8 +142,12 @@ Key forProvidesMethod(ExecutableElement e) {
           TypeMirror setType = types.getDeclaredType(getSetElement(), returnType);
           return new AutoValue_Key(rewrap(qualifier), MoreTypes.equivalence().wrap(setType));
         case MAP:
-          AnnotationMirror mapKey = Iterables.getOnlyElement(getMapKeys(e));
-          TypeElement keyTypeElement = Util.getKeyTypeElement(mapKey, elements);
+          AnnotationMirror mapKeyAnnotation = Iterables.getOnlyElement(getMapKeys(e));
+          MapKey mapKey =
+              mapKeyAnnotation.getAnnotationType().asElement().getAnnotation(MapKey.class);
+          TypeElement keyTypeElement =
+              mapKey.unwrapValue() ? Util.getKeyTypeElement(mapKeyAnnotation, elements)
+                  : (TypeElement) mapKeyAnnotation.getAnnotationType().asElement();
           TypeMirror valueType = types.getDeclaredType(getProviderElement(), returnType);
           TypeMirror mapType =
               types.getDeclaredType(getMapElement(), keyTypeElement.asType(), valueType);
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
new file mode 100644
index 000000000..2fa5ff219
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
@@ -0,0 +1,104 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.value.AutoAnnotation;
+import com.google.common.base.Joiner;
+import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableSet;
+import dagger.MapKey;
+import dagger.internal.codegen.writer.ClassName;
+import dagger.internal.codegen.writer.ClassWriter;
+import dagger.internal.codegen.writer.JavaWriter;
+import dagger.internal.codegen.writer.MethodWriter;
+import java.util.ArrayList;
+import java.util.List;
+import javax.annotation.Generated;
+import javax.annotation.processing.Filer;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Name;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
+
+import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.STATIC;
+
+/**
+ * Generates implementations to create{@link MapKey} instances
+ *
+ * @author Chenying Hou
+ * @since 2.0
+ */
+final class MapKeyGenerator extends SourceFileGenerator<Element> {
+  MapKeyGenerator(Filer filer) {
+    super(filer);
+  }
+
+  @Override
+  ClassName nameGeneratedType(Element e) {
+    ClassName enclosingClassName = ClassName.fromTypeElement((TypeElement)e);
+    return enclosingClassName.topLevelClassName().peerNamed(
+        enclosingClassName.classFileName() + "Creator");
+  }
+
+  @Override
+  Iterable<? extends Element> getOriginatingElements(Element e) {
+    return ImmutableSet.of(e);
+  }
+
+  @Override
+  Optional<? extends Element> getElementForErrorReporting(Element e) {
+    return Optional.of(e);
+  }
+
+  @Override
+  ImmutableSet<JavaWriter> write(ClassName generatedTypeName, Element e) {
+    JavaWriter writer = JavaWriter.inPackage(generatedTypeName.packageName());
+    ClassWriter mapKeyWriter = writer.addClass(generatedTypeName.simpleName());
+    mapKeyWriter.annotate(Generated.class).setValue(ComponentProcessor.class.getName());
+    mapKeyWriter.addModifiers(PUBLIC);
+
+    //create map key create method, which will return an instance of map key
+    MethodWriter getMethodWriter = mapKeyWriter.addMethod(e.asType(), "create");
+    //get parameter list of create method
+    List<? extends Element> enclosingElements = e.getEnclosedElements();
+    List<String> paraList = new ArrayList<String>();
+
+    //Using AutoAnnotation to generate mapkey creator files later
+    getMethodWriter.annotate(AutoAnnotation.class);
+    getMethodWriter.addModifiers(PUBLIC, STATIC);
+
+    for (Element element : enclosingElements) {
+      if (element instanceof ExecutableElement) {
+        ExecutableElement executableElement = (ExecutableElement) element;
+        Name parameterName = executableElement.getSimpleName();
+        getMethodWriter.addParameter(
+            (TypeElement) ((DeclaredType) (executableElement.getReturnType())).asElement(),
+            parameterName.toString());
+        paraList.add(parameterName.toString());
+      } else {
+        throw new IllegalStateException();
+      }
+    }
+
+    getMethodWriter.body().addSnippet(
+        "return new AutoAnnotation_" + generatedTypeName.simpleName() + "_create(%s);",
+        Joiner.on(", ").join(paraList));
+
+    return ImmutableSet.of(writer);
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeyProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/MapKeyProcessingStep.java
index 69a5fafd1..9807d35d6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapKeyProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeyProcessingStep.java
@@ -23,10 +23,8 @@
 import javax.lang.model.element.TypeElement;
 
 /**
- * The annotation processor responsible for validating the mapKey annotation
- *
- *
- * TODO(user): auto-generate implementation of annotations marked with &#064MapKey where necessary.
+ * The annotation processor responsible for validating the mapKey annotation and auto-generate
+ * implementation of annotations marked with &#064MapKey where necessary.
  *
  * @author Chenying Hou
  * @since 2.0
@@ -34,20 +32,34 @@
 public class MapKeyProcessingStep implements ProcessingStep {
   private final Messager messager;
   private final MapKeyValidator mapKeyValidator;
+  private final MapKeyGenerator mapKeyGenerator;
 
-  MapKeyProcessingStep(Messager messager, MapKeyValidator mapKeyValidator) {
+  MapKeyProcessingStep(Messager messager, MapKeyValidator mapKeyValidator, MapKeyGenerator mapKeyGenerator) {
     this.messager = messager;
     this.mapKeyValidator = mapKeyValidator;
+    this.mapKeyGenerator = mapKeyGenerator;
   }
 
   @Override
   public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
-    // check the map key annotation field is valid
     if (!roundEnv.getElementsAnnotatedWith(MapKey.class).isEmpty()) {
       Set<? extends Element> mapKeyAnnotateds = roundEnv.getElementsAnnotatedWith(MapKey.class);
+      // for each element annotated with @mapKey, validate it and auto generate key creator file for
+      // any unwrapped key
       for (Element element : mapKeyAnnotateds) {
         ValidationReport<Element> mapKeyReport = mapKeyValidator.validate(element);
         mapKeyReport.printMessagesTo(messager);
+
+        if (mapKeyReport.isClean()) {
+          MapKey mapkey = element.getAnnotation(MapKey.class);
+          if (!mapkey.unwrapValue()) {
+            try {
+              mapKeyGenerator.generate(element);
+            } catch (SourceFileGenerationException e) {
+              e.printMessageTo(messager);
+            }
+          }
+        }
       }
     }
     return false;
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeyValidator.java b/compiler/src/main/java/dagger/internal/codegen/MapKeyValidator.java
index 7835f6770..8411b20fb 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapKeyValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeyValidator.java
@@ -17,8 +17,9 @@
 
 import dagger.MapKey;
 import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
 
-import static dagger.internal.codegen.ErrorMessages.WRAP_MAPKEY;
+import static dagger.internal.codegen.ErrorMessages.MAPKEY_WITHOUT_FIELDS;
 
 /**
  * A {@link Validator} for {@link MapKey} Annotation.
@@ -26,16 +27,13 @@
  * @author Chenying Hou
  * @since 2.0
  */
-final class MapKeyValidator implements Validator<Element>  {
+final class MapKeyValidator implements Validator<Element> {
   @Override
   public ValidationReport<Element> validate(Element element) {
-    ValidationReport.Builder<Element> builder =
-        ValidationReport.Builder.about(element);
-    MapKey mapkey = element.getAnnotation(MapKey.class);
-    if (!mapkey.unwrapValue()) {
-      builder.addItem(WRAP_MAPKEY, element);
+    ValidationReport.Builder<Element> builder = ValidationReport.Builder.about(element);
+    if (((TypeElement) element).getEnclosedElements().isEmpty()) {
+      builder.addItem(MAPKEY_WITHOUT_FIELDS, element);
     }
     return builder.build();
   }
-
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
index 77eeb7179..fa4e70d30 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
@@ -46,7 +46,6 @@
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_TYPE_PARAMETER;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_WITH_MULTIPLE_MAP_KEY;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_WITH_NO_MAP_KEY;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_WITH_UNSUPPORTED_MAP_KEY;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.STATIC;
@@ -128,11 +127,6 @@ private TypeElement getSetElement() {
             builder.addItem(PROVIDES_METHOD_WITH_NO_MAP_KEY, providesMethodElement);
             break;
           case 1:
-            AnnotationMirror mapKeyAnnotationMirror = Iterables.getOnlyElement(annotationMirrors); 
-            TypeElement keyTypeElement = Util.getKeyTypeElement(mapKeyAnnotationMirror, elements);
-            if (keyTypeElement == null) {
-              builder.addItem(PROVIDES_METHOD_WITH_UNSUPPORTED_MAP_KEY, providesMethodElement);
-            }
             break;
           default:
             builder.addItem(PROVIDES_METHOD_WITH_MULTIPLE_MAP_KEY, providesMethodElement);
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index 84df3dfb1..2eeb7e799 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -386,7 +386,7 @@ public CodeGenerationIncompleteException(String s) {
   }
 
   /**
-   * returns the value type for a {@link Map} type like Map<K, Provider<V>>}.
+   * Returns the value type for a {@link Map} type like Map<K, Provider<V>>}.
    */
   public static TypeMirror getValueTypeOfMap(DeclaredType declaredMapType) {
     List<? extends TypeMirror> mapArgs = declaredMapType.getTypeArguments();
@@ -396,7 +396,7 @@ public static TypeMirror getValueTypeOfMap(DeclaredType declaredMapType) {
   }
 
   /**
-   * returns the key type for a {@link Map} type like Map<K, Provider<V>>}
+   * Returns the key type for a {@link Map} type like Map<K, Provider<V>>}
    */
   public static TypeMirror getKeyTypeOfMap(DeclaredType declaredMapType) {
     List<? extends TypeMirror> mapArgs = declaredMapType.getTypeArguments();
@@ -404,8 +404,8 @@ public static TypeMirror getKeyTypeOfMap(DeclaredType declaredMapType) {
   }
 
   /**
-   * returns the key's {@link TypeElement} for a {@link Map} given the {@link AnnotationMirror} of
-   * the key..
+   * Returns the unwrapped key's {@link TypeElement} for a {@link Map} given the
+   * {@link AnnotationMirror} of the key.
    */
   public static TypeElement getKeyTypeElement(AnnotationMirror mapKey, final Elements elements) {
     Map<? extends ExecutableElement, ? extends AnnotationValue> map = mapKey.getElementValues();
@@ -424,15 +424,12 @@ public TypeElement visitString(String s, Void p) {
 
           @Override
           protected TypeElement defaultAction(Object o, Void v) {
-            throw new IllegalStateException();
+            throw new IllegalStateException(
+                "Non-supported key type for map binding " + o.getClass().getCanonicalName());
           }
         };
     TypeElement keyTypeElement =
         Iterables.getOnlyElement(map.entrySet()).getValue().accept(mapKeyVisitor, null);
-    if (keyTypeElement == null) {
-      throw new IllegalStateException("Non-supported key type for map binding "
-          + Iterables.getOnlyElement(map.entrySet()).getValue());
-    }
     return keyTypeElement;
   }
 
diff --git a/compiler/src/test/java/dagger/internal/codegen/AnnotationMirrorsTest.java b/compiler/src/test/java/dagger/internal/codegen/AnnotationMirrorsTest.java
index 55b058594..5e277284a 100644
--- a/compiler/src/test/java/dagger/internal/codegen/AnnotationMirrorsTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/AnnotationMirrorsTest.java
@@ -159,7 +159,7 @@
   @Test public void testGetDefaultValuesUnset() {
     assert_().that(annotationOn(StringyUnset.class).getElementValues()).isEmpty();
     Iterable<AnnotationValue> values = AnnotationMirrors.getAnnotationValuesWithDefaults(
-        annotationOn(StringyUnset.class));
+        annotationOn(StringyUnset.class)).values();
     String value = getOnlyElement(values).accept(new SimpleAnnotationValueVisitor6<String, Void>() {
           @Override public String visitString(String value, Void ignored) {
             return value;
@@ -170,7 +170,7 @@
 
   @Test public void testGetDefaultValuesSet() {
     Iterable<AnnotationValue> values = AnnotationMirrors.getAnnotationValuesWithDefaults(
-        annotationOn(StringySet.class));
+        annotationOn(StringySet.class)).values();
     String value = getOnlyElement(values).accept(new SimpleAnnotationValueVisitor6<String, Void>() {
           @Override public String visitString(String value, Void ignored) {
             return value;
diff --git a/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
index 256727a7e..096cb3ada 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
@@ -131,9 +131,9 @@ public void mapBindingsWithEnumKey() {
                 "    this.mapModuleTwo = builder.mapModuleTwo;",
                 "    this.mapOfPathEnumAndProviderOfHandlerProvider = ",
                 "        MapProviderFactory.<PathEnum, Handler>builder(2)",
-                "            .put(test.PathEnum.ADMIN, ",
+                "            .put(PathEnum.ADMIN, ",
                 "                new MapModuleOne$$ProvideAdminHandlerFactory(mapModuleOne))",
-                "            .put(test.PathEnum.LOGIN, ",
+                "            .put(PathEnum.LOGIN, ",
                 "                new MapModuleTwo$$ProvideLoginHandlerFactory(mapModuleTwo))",
                 "            .build();",
                 "  }",
diff --git a/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
new file mode 100644
index 000000000..129fb46c5
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
@@ -0,0 +1,412 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.value.processor.AutoAnnotationProcessor;
+import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assert_;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+
+@RunWith(JUnit4.class)
+public class MapKeyProcessorTest {
+  @Test
+  public void mapKeyCreatorFile() {
+    JavaFileObject enumKeyFile = JavaFileObjects.forSourceLines("test.PathKey",
+        "package test;",
+        "import dagger.MapKey;",
+        "import java.lang.annotation.Retention;",
+        "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+        "",
+        "@MapKey(unwrapValue = false)",
+        "@Retention(RUNTIME)",
+        "public @interface PathKey {",
+        "  PathEnum value();",
+        "  String relativePath() default \"Defaultpath\";",
+        "}");
+    JavaFileObject pathEnumFile = JavaFileObjects.forSourceLines("test.PathEnum",
+        "package test;",
+        "",
+        "public enum PathEnum {",
+        "    ADMIN,",
+        "    LOGIN;",
+        "}");
+    JavaFileObject generatedKeyCreator = JavaFileObjects.forSourceLines("test.PathKeyCreator",
+        "package test;",
+        "",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public class PathKeyCreator {",
+        "  @com.google.auto.value.AutoAnnotation",
+        "  public static PathKey create(PathEnum value, String relativePath) { ",
+        "    return new AutoAnnotation_PathKeyCreator_create(value, relativePath);",
+        "  }",
+        "}");
+    assert_().about(javaSources())
+    .that(ImmutableList.of(
+        enumKeyFile,
+        pathEnumFile))
+    .processedWith(new ComponentProcessor(), new AutoAnnotationProcessor())
+    .compilesWithoutError()
+    .and()
+    .generatesSources(generatedKeyCreator);
+  }
+
+  @Test
+  public void mapKeyComponentFileWithDisorderedKeyField() {
+    JavaFileObject mapModuleOneFile = JavaFileObjects.forSourceLines("test.MapModuleOne",
+        "package test;",
+        "",
+        "import static dagger.Provides.Type.MAP;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class MapModuleOne {",
+        "  @Provides(type = MAP) @PathKey(relativePath = \"AdminPath\", value = PathEnum.ADMIN)",
+        "      Handler provideAdminHandler() {",
+        "    return new AdminHandler(); ",
+        "  }",
+        "}");
+    JavaFileObject mapModuleTwoFile =JavaFileObjects.forSourceLines("test.MapModuleTwo",
+        "package test;",
+        "",
+        "import static dagger.Provides.Type.MAP;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class MapModuleTwo {",
+        "  @Provides(type = MAP) @PathKey(value = PathEnum.LOGIN, relativePath = \"LoginPath\")",
+        "      Handler provideLoginHandler() {",
+        "    return new LoginHandler(); ",
+        "  }",
+        "}");
+    JavaFileObject enumKeyFile = JavaFileObjects.forSourceLines("test.PathKey",
+        "package test;",
+        "import dagger.MapKey;",
+        "import java.lang.annotation.Retention;",
+        "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+        "",
+        "@MapKey(unwrapValue = false)",
+        "@Retention(RUNTIME)",
+        "public @interface PathKey {",
+        "  PathEnum value();",
+        "  String relativePath() default \"DefaultPath\";",
+        "}");
+    JavaFileObject pathEnumFile = JavaFileObjects.forSourceLines("test.PathEnum",
+        "package test;",
+        "",
+        "public enum PathEnum {",
+        "    ADMIN,",
+        "    LOGIN;",
+        "}");
+    JavaFileObject handlerFile = JavaFileObjects.forSourceLines("test.Handler",
+        "package test;",
+        "",
+        "interface Handler {}");
+    JavaFileObject loginHandlerFile = JavaFileObjects.forSourceLines("test.LoginHandler",
+        "package test;",
+        "",
+        "class LoginHandler implements Handler {",
+        "  public LoginHandler() {}",
+        "}");
+    JavaFileObject adminHandlerFile = JavaFileObjects.forSourceLines("test.AdminHandler",
+        "package test;",
+        "",
+        "class AdminHandler implements Handler {",
+        "  public AdminHandler() {}",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import java.util.Map;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component(modules = {MapModuleOne.class, MapModuleTwo.class})",
+        "interface TestComponent {",
+        "  Map<PathKey, Provider<Handler>> dispatcher();",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines("test.Dagger_TestComponent",
+        "package test;",
+        "",
+        "import dagger.internal.MapProviderFactory;",
+        "import java.util.Map;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class Dagger_TestComponent implements TestComponent {",
+        "  private final MapModuleOne mapModuleOne;",
+        "  private final MapModuleTwo mapModuleTwo;",
+        "  private final Provider<Map<PathKey, Provider<Handler>>> ",
+        "      mapOfPathKeyAndProviderOfHandlerProvider;",
+        "",
+        "  private Dagger_TestComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    this.mapModuleOne = builder.mapModuleOne;",
+        "    this.mapModuleTwo = builder.mapModuleTwo;",
+        "    this.mapOfPathKeyAndProviderOfHandlerProvider = ",
+        "        MapProviderFactory.<PathKey, Handler>builder(2)",
+        "            .put(PathKeyCreator.create(PathEnum.ADMIN, \"AdminPath\"),",
+        "                 new MapModuleOne$$ProvideAdminHandlerFactory(mapModuleOne))",
+        "            .put(PathKeyCreator.create(PathEnum.LOGIN, \"LoginPath\"),",
+        "                 new MapModuleTwo$$ProvideLoginHandlerFactory(mapModuleTwo))",
+        "            .build();",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static TestComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  @Override",
+        "  public Map<PathKey, Provider<Handler>> dispatcher() {",
+        "    return mapOfPathKeyAndProviderOfHandlerProvider.get();",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private MapModuleOne mapModuleOne;",
+        "    private MapModuleTwo mapModuleTwo;",
+        "",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public TestComponent build() {",
+        "      if (mapModuleOne == null) {",
+        "        this.mapModuleOne = new MapModuleOne();",
+        "      }",
+        "      if (mapModuleTwo == null) {",
+        "        this.mapModuleTwo = new MapModuleTwo();",
+        "      }",
+        "      return new Dagger_TestComponent(this);",
+        "    }",
+        "",
+        "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
+        "      if (mapModuleOne == null) {",
+        "        throw new NullPointerException(\"mapModuleOne\");",
+        "      }",
+        "      this.mapModuleOne = mapModuleOne;",
+        "      return this;",
+        "    }",
+        "",
+        "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
+        "      if (mapModuleTwo == null) {",
+        "        throw new NullPointerException(\"mapModuleTwo\");",
+        "      }",
+        "      this.mapModuleTwo = mapModuleTwo;",
+        "      return this;",
+        "    }",
+        "  }",
+        "}",
+        "");
+    assert_().about(javaSources())
+        .that(ImmutableList.of(
+            mapModuleOneFile,
+            mapModuleTwoFile,
+            enumKeyFile,
+            pathEnumFile,
+            handlerFile,
+            loginHandlerFile,
+            adminHandlerFile,
+            componentFile))
+        .processedWith(new ComponentProcessor(), new AutoAnnotationProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(generatedComponent);
+  }
+
+  @Test
+  public void mapKeyComponentFileWithDefaultField() {
+    JavaFileObject mapModuleOneFile = JavaFileObjects.forSourceLines("test.MapModuleOne",
+        "package test;",
+        "",
+        "import static dagger.Provides.Type.MAP;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class MapModuleOne {",
+        "  @Provides(type = MAP) @PathKey(value = PathEnum.ADMIN) Handler provideAdminHandler() {",
+        "    return new AdminHandler(); ",
+        "  }",
+        "}");
+    JavaFileObject mapModuleTwoFile =JavaFileObjects.forSourceLines("test.MapModuleTwo",
+        "package test;",
+        "",
+        "import static dagger.Provides.Type.MAP;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class MapModuleTwo {",
+        "  @Provides(type = MAP) @PathKey(value = PathEnum.LOGIN, relativePath = \"LoginPath\")",
+        "      Handler provideLoginHandler() {",
+        "    return new LoginHandler(); ",
+        "  }",
+        "}");
+    JavaFileObject enumKeyFile = JavaFileObjects.forSourceLines("test.PathKey",
+        "package test;",
+        "import dagger.MapKey;",
+        "import java.lang.annotation.Retention;",
+        "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+        "",
+        "@MapKey(unwrapValue = false)",
+        "@Retention(RUNTIME)",
+        "public @interface PathKey {",
+        "  PathEnum value();",
+        "  String relativePath() default \"DefaultPath\";",
+        "}");
+    JavaFileObject pathEnumFile = JavaFileObjects.forSourceLines("test.PathEnum",
+        "package test;",
+        "",
+        "public enum PathEnum {",
+        "    ADMIN,",
+        "    LOGIN;",
+        "}");
+    JavaFileObject handlerFile = JavaFileObjects.forSourceLines("test.Handler",
+        "package test;",
+        "",
+        "interface Handler {}");
+    JavaFileObject loginHandlerFile = JavaFileObjects.forSourceLines("test.LoginHandler",
+        "package test;",
+        "",
+        "class LoginHandler implements Handler {",
+        "  public LoginHandler() {}",
+        "}");
+    JavaFileObject adminHandlerFile = JavaFileObjects.forSourceLines("test.AdminHandler",
+        "package test;",
+        "",
+        "class AdminHandler implements Handler {",
+        "  public AdminHandler() {}",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import java.util.Map;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component(modules = {MapModuleOne.class, MapModuleTwo.class})",
+        "interface TestComponent {",
+        "  Map<PathKey, Provider<Handler>> dispatcher();",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines("test.Dagger_TestComponent",
+        "package test;",
+        "",
+        "import dagger.internal.MapProviderFactory;",
+        "import java.util.Map;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class Dagger_TestComponent implements TestComponent {",
+        "  private final MapModuleOne mapModuleOne;",
+        "  private final MapModuleTwo mapModuleTwo;",
+        "  private final Provider<Map<PathKey, Provider<Handler>>> ",
+        "      mapOfPathKeyAndProviderOfHandlerProvider;",
+        "",
+        "  private Dagger_TestComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    this.mapModuleOne = builder.mapModuleOne;",
+        "    this.mapModuleTwo = builder.mapModuleTwo;",
+        "    this.mapOfPathKeyAndProviderOfHandlerProvider = ",
+        "        MapProviderFactory.<PathKey, Handler>builder(2)",
+        "            .put(PathKeyCreator.create(PathEnum.ADMIN, \"DefaultPath\"),",
+        "                 new MapModuleOne$$ProvideAdminHandlerFactory(mapModuleOne))",
+        "            .put(PathKeyCreator.create(PathEnum.LOGIN, \"LoginPath\"),",
+        "                 new MapModuleTwo$$ProvideLoginHandlerFactory(mapModuleTwo))",
+        "            .build();",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static TestComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  @Override",
+        "  public Map<PathKey, Provider<Handler>> dispatcher() {",
+        "    return mapOfPathKeyAndProviderOfHandlerProvider.get();",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private MapModuleOne mapModuleOne;",
+        "    private MapModuleTwo mapModuleTwo;",
+        "",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public TestComponent build() {",
+        "      if (mapModuleOne == null) {",
+        "        this.mapModuleOne = new MapModuleOne();",
+        "      }",
+        "      if (mapModuleTwo == null) {",
+        "        this.mapModuleTwo = new MapModuleTwo();",
+        "      }",
+        "      return new Dagger_TestComponent(this);",
+        "    }",
+        "",
+        "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
+        "      if (mapModuleOne == null) {",
+        "        throw new NullPointerException(\"mapModuleOne\");",
+        "      }",
+        "      this.mapModuleOne = mapModuleOne;",
+        "      return this;",
+        "    }",
+        "",
+        "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
+        "      if (mapModuleTwo == null) {",
+        "        throw new NullPointerException(\"mapModuleTwo\");",
+        "      }",
+        "      this.mapModuleTwo = mapModuleTwo;",
+        "      return this;",
+        "    }",
+        "  }",
+        "}",
+        "");
+    assert_().about(javaSources())
+        .that(ImmutableList.of(
+            mapModuleOneFile,
+            mapModuleTwoFile,
+            enumKeyFile,
+            pathEnumFile,
+            handlerFile,
+            loginHandlerFile,
+            adminHandlerFile,
+            componentFile))
+        .processedWith(new ComponentProcessor(), new AutoAnnotationProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(generatedComponent);
+  }
+}
\ No newline at end of file
diff --git a/core/src/main/java/dagger/MapKey.java b/core/src/main/java/dagger/MapKey.java
index 5657245d0..06c3b65d9 100644
--- a/core/src/main/java/dagger/MapKey.java
+++ b/core/src/main/java/dagger/MapKey.java
@@ -23,21 +23,26 @@
 import java.lang.annotation.Target;
 
 /**
- * It enables to define customized key type annotation for map binding by annotating an annotation
- * of a {@code Map}'s key type. The defined key type annotation can be later applied to the
- * key of the {@code Map}. Currently {@code String} and {@code enum} key types
- * are supported for map binding.
+ * It enables to define customized key type annotation for map binding by
+ * annotating an annotation of a {@code Map}'s key type. The defined key type
+ * annotation can be later applied to the key of the {@code Map}. Currently
+ * {@code String} and {@code enum} key types are supported for map binding.
  *
- * <h2>Example</h2> For example, if you want to define a key type annotation called StringKey, you
- * can define it the following way:
+ * <h2>Example</h2> For example, if you want to define a key type annotation
+ * called StringKey, you can define it the following way:
  *
  * <pre><code>
- * &#64;MapKey(unwrapValue = false)
- * &#64;Retention(RUNTIME)
- * public &#64;interface StringKey {
- *   String value();
- * }
+ *&#64;MapKey(unwrapValue = true)
+ *&#64;Retention(RUNTIME)
+ *public &#64;interface StringKey {
+ *String value();
+ *}
  *</code></pre>
+ *
+ * if {@code unwrapValue} is false, then the whole annotation will be the key
+ * type for the map and annotation instances will be the keys. If
+ * {@code unwrapValue} is true, the value() type of key type annotation will be
+ * the key type for injected map and the value instances will be the keys.
  */
 @Documented
 @Target(ANNOTATION_TYPE)
