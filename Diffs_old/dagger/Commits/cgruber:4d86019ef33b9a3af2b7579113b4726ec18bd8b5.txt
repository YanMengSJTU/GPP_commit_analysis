diff --git a/compiler/src/it/functional-tests/src/main/java/test/ParentModule.java b/compiler/src/it/functional-tests/src/main/java/test/ParentModule.java
index f550f2f21..4d0f56266 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/ParentModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/ParentModule.java
@@ -25,5 +25,4 @@
   static List<Set<String>> provideStaticGenericTypeWithNoTypeParametersInParameterizedModule() {
     return new ArrayList<>();
   }
-
 }
diff --git a/compiler/src/it/functional-tests/src/test/java/test/GenericTest.java b/compiler/src/it/functional-tests/src/test/java/test/GenericTest.java
index f62a1a80d..0bb10b20b 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/GenericTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/GenericTest.java
@@ -144,6 +144,5 @@
     GenericComponent component = DaggerGenericComponent.create();
     assertThat(component.iterableInt()).containsExactly(1, 2).inOrder();
     assertThat(component.iterableDouble()).containsExactly(3d, 4d).inOrder();
-    
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 7bf1587d7..46ced416f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -27,10 +27,11 @@
 import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.DELEGATED;
 import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.INITIALIZED;
 import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.UNINITIALIZED;
-import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_UNCHECKED;
+import static dagger.internal.codegen.AnnotationSpecs.Suppression.RAWTYPES;
+import static dagger.internal.codegen.AnnotationSpecs.Suppression.UNCHECKED;
 import static dagger.internal.codegen.BindingKey.contribution;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
-import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.ENUM_INSTANCE;
+import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.SINGLETON_INSTANCE;
 import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD;
 import static dagger.internal.codegen.MapKeys.getMapKeyExpression;
 import static dagger.internal.codegen.MemberSelect.emptyFrameworkMapFactory;
@@ -40,6 +41,7 @@
 import static dagger.internal.codegen.MemberSelect.staticMethod;
 import static dagger.internal.codegen.MembersInjectionBinding.Strategy.NO_OP;
 import static dagger.internal.codegen.Scope.reusableScope;
+import static dagger.internal.codegen.SourceFiles.bindingTypeElementTypeVariableNames;
 import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
 import static dagger.internal.codegen.SourceFiles.membersInjectorNameForType;
 import static dagger.internal.codegen.TypeNames.DELEGATE_FACTORY;
@@ -533,7 +535,7 @@ private FieldSpec addFrameworkField(
             contributionBindingField.name());
     contributionField.addModifiers(PRIVATE);
     if (useRawType) {
-      contributionField.addAnnotation(AnnotationSpecs.SUPPRESS_WARNINGS_RAWTYPES);
+      contributionField.addAnnotation(AnnotationSpecs.suppressWarnings(RAWTYPES));
     }
 
     FieldSpec field = contributionField.build();
@@ -564,7 +566,7 @@ private boolean useRawType(Optional<String> bindingPackage) {
     switch (bindingKey.kind()) {
       case CONTRIBUTION:
         ContributionBinding contributionBinding = resolvedBindings.contributionBinding();
-        if (contributionBinding.factoryCreationStrategy().equals(ENUM_INSTANCE)
+        if (contributionBinding.factoryCreationStrategy().equals(SINGLETON_INSTANCE)
             && !contributionBinding.scope().isPresent()) {
           switch (contributionBinding.bindingKind()) {
             case SYNTHETIC_MULTIBOUND_MAP:
@@ -585,7 +587,7 @@ private boolean useRawType(Optional<String> bindingPackage) {
             case PROVISION:
               if (bindingKey.key().type().getKind().equals(DECLARED)) {
                 ImmutableList<TypeVariableName> typeVariables =
-                    SourceFiles.bindingTypeElementTypeVariableNames(contributionBinding);
+                    bindingTypeElementTypeVariableNames(contributionBinding);
                 if (!typeVariables.isEmpty()) {
                   List<? extends TypeMirror> typeArguments =
                       ((DeclaredType) bindingKey.key().type()).getTypeArguments();
@@ -791,7 +793,7 @@ private void initializeFrameworkTypes() {
                * initializing a raw field in this method, but the structure of this code makes it
                * awkward to pass that bit through.  This will be cleaned up when we no longer
                * separate fields and initilization as we do now. */
-              .addAnnotation(SUPPRESS_WARNINGS_UNCHECKED)
+              .addAnnotation(AnnotationSpecs.suppressWarnings(UNCHECKED))
               .addCode(CodeBlocks.concat(partition));
       if (builderName.isPresent()) {
         initializeMethod.addParameter(builderName.get(), "builder", FINAL);
@@ -852,7 +854,7 @@ private void initializeFrameworkTypes() {
                         binding.scope().isPresent()
                             ? decorateForScope(delegatingCodeBlock, binding.scope().get())
                             : delegatingCodeBlock))));
-      case ENUM_INSTANCE:
+      case SINGLETON_INSTANCE:
         if (!binding.scope().isPresent()) {
           return Optional.absent();
         }
diff --git a/compiler/src/main/java/dagger/internal/codegen/AnnotationSpecs.java b/compiler/src/main/java/dagger/internal/codegen/AnnotationSpecs.java
index 1b8a1f151..06416f953 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AnnotationSpecs.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AnnotationSpecs.java
@@ -16,15 +16,32 @@
 
 package dagger.internal.codegen;
 
+import static com.google.common.base.Preconditions.checkNotNull;
+
+import com.google.common.base.Ascii;
+import com.google.common.base.Preconditions;
+import com.google.common.collect.Lists;
 import com.squareup.javapoet.AnnotationSpec;
+import java.util.Arrays;
 
 final class AnnotationSpecs {
+  enum Suppression {
+    RAWTYPES,
+    UNCHECKED,
+    ;
 
-  static final AnnotationSpec SUPPRESS_WARNINGS_UNCHECKED = suppressWarnings("unchecked");
-  static final AnnotationSpec SUPPRESS_WARNINGS_RAWTYPES = suppressWarnings("rawtypes");
+    @Override
+    public String toString() {
+      return Ascii.toLowerCase(name());
+    }
+  }
 
-  private static AnnotationSpec suppressWarnings(String value) {
-    return AnnotationSpec.builder(SuppressWarnings.class).addMember("value", "$S", value).build();
+  static AnnotationSpec suppressWarnings(Suppression first, Suppression... rest) {
+    checkNotNull(first);
+    Arrays.stream(rest).forEach(Preconditions::checkNotNull);
+    AnnotationSpec.Builder builder = AnnotationSpec.builder(SuppressWarnings.class);
+    Lists.asList(first, rest).forEach(suppression -> builder.addMember("value", "$S", suppression));
+    return builder.build();
   }
 
   private AnnotationSpecs() {}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
index 235b99a2e..61f1a1b51 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
@@ -19,7 +19,7 @@
 import static com.google.common.collect.Sets.immutableEnumSet;
 import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.CLASS_CONSTRUCTOR;
 import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.DELEGATE;
-import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.ENUM_INSTANCE;
+import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.SINGLETON_INSTANCE;
 import static dagger.internal.codegen.MapKeys.unwrapValue;
 import static dagger.internal.codegen.MoreAnnotationMirrors.unwrapOptionalEquivalence;
 import static javax.lang.model.element.Modifier.ABSTRACT;
@@ -174,8 +174,8 @@ boolean requiresModuleInstance() {
    * The strategy for getting an instance of a factory for a {@link ContributionBinding}.
    */
   enum FactoryCreationStrategy {
-    /** The factory class is an enum with one value named {@code INSTANCE}. */
-    ENUM_INSTANCE,
+    /** The factory class is a single instance. */
+    SINGLETON_INSTANCE,
     /** The factory must be created by calling the constructor. */
     CLASS_CONSTRUCTOR,
     /** The factory is simply delegated to another. */
@@ -188,7 +188,7 @@ boolean requiresModuleInstance() {
    * <p>Delegate bindings use the {@link FactoryCreationStrategy#DELEGATE} strategy.
    *
    * <p>Bindings without dependencies that don't require a module instance use the {@link
-   * FactoryCreationStrategy#ENUM_INSTANCE} strategy.
+   * FactoryCreationStrategy#SINGLETON_INSTANCE} strategy.
    *
    * <p>All other bindings use the {@link FactoryCreationStrategy#CLASS_CONSTRUCTOR} strategy.
    */
@@ -198,12 +198,12 @@ FactoryCreationStrategy factoryCreationStrategy() {
         return DELEGATE;
       case PROVISION:
         return dependencies().isEmpty() && !requiresModuleInstance()
-            ? ENUM_INSTANCE
+            ? SINGLETON_INSTANCE
             : CLASS_CONSTRUCTOR;
       case INJECTION:
       case SYNTHETIC_MULTIBOUND_SET:
       case SYNTHETIC_MULTIBOUND_MAP:
-        return dependencies().isEmpty() ? ENUM_INSTANCE : CLASS_CONSTRUCTOR;
+        return dependencies().isEmpty() ? SINGLETON_INSTANCE : CLASS_CONSTRUCTOR;
       default:
         return CLASS_CONSTRUCTOR;
     }
@@ -214,7 +214,7 @@ FactoryCreationStrategy factoryCreationStrategy() {
    * for this binding. Uses the binding's key, V in the came of {@code Map<K, FrameworkClass<V>>>},
    * and E {@code Set<E>} for {@link dagger.multibindings.IntoSet @IntoSet} methods.
    */
-  final TypeMirror factoryType() {
+  final TypeMirror contributedType() {
     switch (contributionType()) {
       case MAP:
         return MapType.from(key()).unwrappedValueType(bindingType().frameworkClass());
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index 332562b61..13504f3a2 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -20,11 +20,10 @@
 import static com.squareup.javapoet.MethodSpec.constructorBuilder;
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static com.squareup.javapoet.TypeSpec.classBuilder;
-import static com.squareup.javapoet.TypeSpec.enumBuilder;
-import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_RAWTYPES;
-import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_UNCHECKED;
+import static dagger.internal.codegen.AnnotationSpecs.Suppression.RAWTYPES;
+import static dagger.internal.codegen.AnnotationSpecs.Suppression.UNCHECKED;
+import static dagger.internal.codegen.AnnotationSpecs.suppressWarnings;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
-import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.ENUM_INSTANCE;
 import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
 import static dagger.internal.codegen.ContributionBinding.Kind.PROVISION;
 import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD;
@@ -103,38 +102,39 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
     checkArgument(binding.bindingElement().isPresent());
 
     if (binding.bindingKind().equals(INJECTION)
-        && !injectValidator.isValidType(binding.factoryType())) {
+        && !injectValidator.isValidType(binding.contributedType())) {
       return Optional.absent();
     }
 
-    TypeName providedTypeName = TypeName.get(binding.factoryType());
-    ParameterizedTypeName parameterizedFactoryName = factoryOf(providedTypeName);
-    Optional<ParameterizedTypeName> factoryOfRawTypeName = Optional.absent();
-    TypeSpec.Builder factoryBuilder;
-    Optional<MethodSpec.Builder> constructorBuilder = Optional.absent();
+    TypeName providedTypeName = TypeName.get(binding.contributedType());
+    ParameterizedTypeName factoryTypeName = factoryOf(providedTypeName);
     ImmutableList<TypeVariableName> typeParameters = bindingTypeElementTypeVariableNames(binding);
+    TypeSpec.Builder factoryBuilder = classBuilder(generatedTypeName).addModifiers(FINAL);
+    // Use type parameters from the injected type or the module instance *only* if we require it.
+    boolean factoryHasTypeParameters =
+        (binding.bindingKind().equals(INJECTION) || binding.requiresModuleInstance())
+            && !typeParameters.isEmpty();
+    if (factoryHasTypeParameters) {
+      factoryBuilder.addTypeVariables(typeParameters);
+    }
+    Optional<MethodSpec.Builder> constructorBuilder = Optional.absent();
     UniqueNameSet uniqueFieldNames = new UniqueNameSet();
     ImmutableMap.Builder<BindingKey, FieldSpec> fieldsBuilder = ImmutableMap.builder();
 
-    boolean useRawType =
-        binding.factoryCreationStrategy() == ENUM_INSTANCE
-            && binding.bindingKind() == INJECTION
-            && !typeParameters.isEmpty();
     switch (binding.factoryCreationStrategy()) {
-      case ENUM_INSTANCE:
-        factoryBuilder = enumBuilder(generatedTypeName.simpleName()).addEnumConstant("INSTANCE");
-        // If we have type parameters, then remove the parameters from our providedTypeName,
-        // since we'll be implementing an erased version of it.
-        if (useRawType) {
-          factoryBuilder.addAnnotation(SUPPRESS_WARNINGS_RAWTYPES);
-          // TODO(ronshapiro): instead of reassigning, introduce an optional/second parameter
-          providedTypeName = ((ParameterizedTypeName) providedTypeName).rawType;
-          factoryOfRawTypeName = Optional.of(factoryOf(providedTypeName));
+      case SINGLETON_INSTANCE:
+        FieldSpec.Builder instanceFieldBuilder =
+            FieldSpec.builder(generatedTypeName, "INSTANCE", PRIVATE, STATIC, FINAL)
+                .initializer("new $T()", generatedTypeName);
+
+        // if the factory has type parameters, we're ignoring them in the initializer
+        if (factoryHasTypeParameters) {
+          instanceFieldBuilder.addAnnotation(suppressWarnings(RAWTYPES));
         }
+
+        factoryBuilder.addField(instanceFieldBuilder.build());
         break;
       case CLASS_CONSTRUCTOR:
-        factoryBuilder =
-            classBuilder(generatedTypeName).addTypeVariables(typeParameters).addModifiers(FINAL);
         constructorBuilder = Optional.of(constructorBuilder().addModifiers(PUBLIC));
         if (binding.requiresModuleInstance()) {
           addConstructorParameterAndTypeField(
@@ -163,9 +163,7 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
     }
     ImmutableMap<BindingKey, FieldSpec> fields = fieldsBuilder.build();
 
-    factoryBuilder
-        .addModifiers(PUBLIC)
-        .addSuperinterface(factoryOfRawTypeName.or(parameterizedFactoryName));
+    factoryBuilder.addModifiers(PUBLIC).addSuperinterface(factoryTypeName);
 
     // If constructing a factory for @Inject or @Provides bindings, we use a static create method
     // so that generated components can avoid having to refer to the generic types
@@ -177,26 +175,24 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
         // The return type is usually the same as the implementing type, except in the case
         // of enums with type variables (where we cast).
         MethodSpec.Builder createMethodBuilder =
-            methodBuilder("create")
-                .addModifiers(PUBLIC, STATIC)
-                .returns(parameterizedFactoryName);
-        if (binding.factoryCreationStrategy() != ENUM_INSTANCE
-            || binding.bindingKind() == INJECTION) {
+            methodBuilder("create").addModifiers(PUBLIC, STATIC).returns(factoryTypeName);
+        if (factoryHasTypeParameters) {
           createMethodBuilder.addTypeVariables(typeParameters);
         }
         List<ParameterSpec> params =
             constructorBuilder.isPresent()
-                ? constructorBuilder.get().build().parameters : ImmutableList.<ParameterSpec>of();
+                ? constructorBuilder.get().build().parameters
+                : ImmutableList.of();
         createMethodBuilder.addParameters(params);
         switch (binding.factoryCreationStrategy()) {
-          case ENUM_INSTANCE:
-            if (!useRawType) {
-              createMethodBuilder.addStatement("return INSTANCE");
-            } else {
+          case SINGLETON_INSTANCE:
+            if (factoryHasTypeParameters) {
               // We use an unsafe cast here because the types are different.
               // It's safe because the type is never referenced anywhere.
               createMethodBuilder.addStatement("return ($T) INSTANCE", TypeNames.FACTORY);
-              createMethodBuilder.addAnnotation(SUPPRESS_WARNINGS_UNCHECKED);
+              createMethodBuilder.addAnnotation(suppressWarnings(RAWTYPES, UNCHECKED));
+            } else {
+              createMethodBuilder.addStatement("return INSTANCE");
             }
             break;
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/MemberSelect.java b/compiler/src/main/java/dagger/internal/codegen/MemberSelect.java
index 9525860e3..6643208e1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MemberSelect.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MemberSelect.java
@@ -80,10 +80,7 @@ static MemberSelect staticMethod(ClassName owningClass, CodeBlock methodInvocati
   static MemberSelect parameterizedFactoryCreateMethod(
       ClassName owningClass, List<? extends TypeMirror> parameters) {
     return new ParameterizedStaticMethod(
-        owningClass,
-        ImmutableList.<TypeMirror>copyOf(parameters),
-        CodeBlock.of("create()"),
-        FACTORY);
+        owningClass, ImmutableList.copyOf(parameters), CodeBlock.of("create()"), FACTORY);
   }
 
   private static final class StaticMethod extends MemberSelect {
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
index 4b6563406..53278fb91 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
@@ -22,8 +22,9 @@
 import static com.squareup.javapoet.MethodSpec.constructorBuilder;
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static com.squareup.javapoet.TypeSpec.classBuilder;
-import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_RAWTYPES;
-import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_UNCHECKED;
+import static dagger.internal.codegen.AnnotationSpecs.Suppression.RAWTYPES;
+import static dagger.internal.codegen.AnnotationSpecs.Suppression.UNCHECKED;
+import static dagger.internal.codegen.AnnotationSpecs.suppressWarnings;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.SourceFiles.bindingTypeElementTypeVariableNames;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
@@ -171,8 +172,8 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
       // parameters' raw-type warnings.
       if (useRawFrameworkType) {
         usesRawFrameworkTypes = true;
-        fieldBuilder.addAnnotation(SUPPRESS_WARNINGS_RAWTYPES);
-        parameterBuilder.addAnnotation(SUPPRESS_WARNINGS_RAWTYPES);
+        fieldBuilder.addAnnotation(suppressWarnings(RAWTYPES));
+        parameterBuilder.addAnnotation(suppressWarnings(RAWTYPES));
       }
       constructorBuilder.addParameter(parameterBuilder.build());
       createMethodBuilder.addParameter(parameterBuilder.build());
@@ -212,7 +213,7 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
     }
 
     if (usesRawFrameworkTypes) {
-      injectMembersBuilder.addAnnotation(SUPPRESS_WARNINGS_UNCHECKED);
+      injectMembersBuilder.addAnnotation(suppressWarnings(UNCHECKED));
     }
 
     injectorTypeBuilder.addMethod(injectMembersBuilder.build());
diff --git a/compiler/src/main/java/dagger/internal/codegen/OptionalFactories.java b/compiler/src/main/java/dagger/internal/codegen/OptionalFactories.java
index d0a268e12..989da3fae 100644
--- a/compiler/src/main/java/dagger/internal/codegen/OptionalFactories.java
+++ b/compiler/src/main/java/dagger/internal/codegen/OptionalFactories.java
@@ -22,8 +22,8 @@
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static com.squareup.javapoet.TypeSpec.anonymousClassBuilder;
 import static com.squareup.javapoet.TypeSpec.classBuilder;
-import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_RAWTYPES;
-import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_UNCHECKED;
+import static dagger.internal.codegen.AnnotationSpecs.Suppression.RAWTYPES;
+import static dagger.internal.codegen.AnnotationSpecs.Suppression.UNCHECKED;
 import static dagger.internal.codegen.TypeNames.PROVIDER;
 import static dagger.internal.codegen.TypeNames.listenableFutureOf;
 import static dagger.internal.codegen.TypeNames.providerOf;
@@ -111,7 +111,7 @@ private MethodSpec absentOptionalProviderMethod(OptionalKind optionalKind) {
             "Returns a {@link $T} that returns {@code $L}.",
             Provider.class,
             optionalKind.absentValueExpression())
-        .addCode("$L // safe covariant cast\n", SUPPRESS_WARNINGS_UNCHECKED)
+        .addCode("$L // safe covariant cast\n", AnnotationSpecs.suppressWarnings(UNCHECKED))
         .addCode(
             "$1T provider = ($1T) $2N;",
             providerOf(optionalKind.of(typeVariable)),
@@ -132,7 +132,7 @@ private FieldSpec absentOptionalProviderField(OptionalKind optionalKind) {
             PRIVATE,
             STATIC,
             FINAL)
-        .addAnnotation(SUPPRESS_WARNINGS_RAWTYPES)
+        .addAnnotation(AnnotationSpecs.suppressWarnings(RAWTYPES))
         .initializer("$T.create($L)", InstanceFactory.class, optionalKind.absentValueExpression())
         .addJavadoc(
             "A {@link $T} that returns {@code $L}.",
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
index c759af798..485f95cf6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -21,7 +21,7 @@
 import static com.squareup.javapoet.MethodSpec.constructorBuilder;
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static com.squareup.javapoet.TypeSpec.classBuilder;
-import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_UNCHECKED;
+import static dagger.internal.codegen.AnnotationSpecs.Suppression.UNCHECKED;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
 import static dagger.internal.codegen.SourceFiles.generateBindingFieldsForDependencies;
@@ -89,7 +89,7 @@ ClassName nameGeneratedType(ProductionBinding binding) {
   Optional<TypeSpec.Builder> write(ClassName generatedTypeName, ProductionBinding binding) {
     checkArgument(binding.bindingElement().isPresent());
 
-    TypeName providedTypeName = TypeName.get(binding.factoryType());
+    TypeName providedTypeName = TypeName.get(binding.contributedType());
     TypeName futureTypeName = listenableFutureOf(providedTypeName);
 
     TypeSpec.Builder factoryBuilder =
@@ -188,7 +188,7 @@ ClassName nameGeneratedType(ProductionBinding binding) {
                     providedTypeName,
                     futureTransform.parameterCodeBlocks()));
     if (futureTransform.hasUncheckedCast()) {
-      applyMethodBuilder.addAnnotation(SUPPRESS_WARNINGS_UNCHECKED);
+      applyMethodBuilder.addAnnotation(AnnotationSpecs.suppressWarnings(UNCHECKED));
     }
 
     factoryBuilder.addMethod(constructorBuilder.build());
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index 2b7aebda5..43bce4baf 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -16,6 +16,7 @@
 
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
 import static com.google.common.base.Preconditions.checkArgument;
+import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
 import static dagger.internal.codegen.TypeNames.DOUBLE_CHECK;
 import static dagger.internal.codegen.TypeNames.PROVIDER_OF_LAZY;
 import static dagger.internal.codegen.Util.ELEMENT_SIMPLE_NAME;
@@ -23,7 +24,6 @@
 
 import com.google.common.base.CaseFormat;
 import com.google.common.base.Joiner;
-import com.google.common.base.Optional;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
@@ -39,7 +39,6 @@
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.TypeParameterElement;
-import javax.lang.model.type.TypeMirror;
 
 /**
  * Utilities for generating files.
@@ -173,62 +172,12 @@ static ClassName generatedClassNameForBinding(Binding binding) {
     }
   }
 
-  static TypeName parameterizedGeneratedTypeNameForBinding(
-      Binding binding) {
+  static TypeName parameterizedGeneratedTypeNameForBinding(Binding binding) {
     ClassName className = generatedClassNameForBinding(binding);
-    ImmutableList<TypeName> typeParameters = bindingTypeParameters(binding);
-    if (typeParameters.isEmpty()) {
-      return className;
-    } else {
-      return ParameterizedTypeName.get(
-          className,
-          FluentIterable.from(typeParameters).toArray(TypeName.class));
-    }
-  }
-
-  private static Optional<TypeMirror> typeMirrorForBindingTypeParameters(Binding binding)
-      throws AssertionError {
-    switch (binding.bindingType()) {
-      case PROVISION:
-      case PRODUCTION:
-        ContributionBinding contributionBinding = (ContributionBinding) binding;
-        switch (contributionBinding.bindingKind()) {
-          case INJECTION:
-            return Optional.of(contributionBinding.key().type());
-
-          case PROVISION:
-            // For provision bindings, we parameterize creation on the types of
-            // the module, not the types of the binding.
-            // Consider: Module<A, B, C> { @Provides List<B> provideB(B b) { .. }}
-            // The binding is just parameterized on <B>, but we need all of <A, B, C>.
-            return Optional.of(contributionBinding.bindingTypeElement().get().asType());
-
-          case PRODUCTION:
-            // TODO(beder): Can these be treated just like PROVISION?
-            throw new UnsupportedOperationException();
-            
-          default:
-            return Optional.absent();
-        }
-
-      case MEMBERS_INJECTION:
-        return Optional.of(binding.key().type());
-
-      default:
-        throw new AssertionError();
-    }
-  }
-
-  static ImmutableList<TypeName> bindingTypeParameters(
-      Binding binding) {
-    Optional<TypeMirror> typeMirror = typeMirrorForBindingTypeParameters(binding);
-    if (!typeMirror.isPresent()) {
-      return ImmutableList.of();
-    }
-    TypeName bindingTypeName = TypeName.get(typeMirror.get());
-    return bindingTypeName instanceof ParameterizedTypeName
-        ? ImmutableList.copyOf(((ParameterizedTypeName) bindingTypeName).typeArguments)
-        : ImmutableList.<TypeName>of();
+    ImmutableList<TypeVariableName> typeParameters = bindingTypeElementTypeVariableNames(binding);
+    return typeParameters.isEmpty()
+        ? className
+        : ParameterizedTypeName.get(className, Iterables.toArray(typeParameters, TypeName.class));
   }
 
   static ClassName membersInjectorNameForType(TypeElement typeElement) {
@@ -271,6 +220,13 @@ private static String factoryPrefix(ContributionBinding binding) {
   }
 
   static ImmutableList<TypeVariableName> bindingTypeElementTypeVariableNames(Binding binding) {
+    if (binding instanceof ContributionBinding) {
+      ContributionBinding contributionBinding = (ContributionBinding) binding;
+      if (!contributionBinding.bindingKind().equals(INJECTION)
+          && !contributionBinding.requiresModuleInstance()) {
+        return ImmutableList.of();
+      }
+    }
     ImmutableList.Builder<TypeVariableName> builder = ImmutableList.builder();
     for (TypeParameterElement typeParameter :
         binding.bindingTypeElement().get().getTypeParameters()) {
diff --git a/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
index 6382d8d27..a23a5008b 100644
--- a/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
@@ -222,28 +222,30 @@
         "class GenericClass<T> {",
         "  @Inject GenericClass() {}",
         "}");
-    JavaFileObject expected = JavaFileObjects.forSourceLines("test.GenericClass_Factory",
-        "package test;",
-        "",
-        "import dagger.internal.Factory;",
-        "import javax.annotation.Generated;",
-        "",
-        "@SuppressWarnings(\"rawtypes\")",
-        GENERATED_ANNOTATION,
-        "public enum GenericClass_Factory implements Factory<GenericClass> {",
-        "  INSTANCE;",
-        "",
-        "  @Override",
-        "  public GenericClass get() {",
-        "    return new GenericClass();",
-        "  }",
-        "",
-        "  @SuppressWarnings(\"unchecked\")",
-        "  public static <T> Factory<GenericClass<T>> create() {",
-        "    return (Factory) INSTANCE;",
-        "  }",
-        "",
-        "}");
+    JavaFileObject expected =
+        JavaFileObjects.forSourceLines(
+            "test.GenericClass_Factory",
+            "package test;",
+            "",
+            "import dagger.internal.Factory;",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class GenericClass_Factory<T> implements Factory<GenericClass<T>> {",
+            "  @SuppressWarnings(\"rawtypes\")",
+            "  private static final GenericClass_Factory INSTANCE = new GenericClass_Factory();",
+            "",
+            "  @Override",
+            "  public GenericClass<T> get() {",
+            "    return new GenericClass<T>();",
+            "  }",
+            "",
+            "  @SuppressWarnings({\"rawtypes\", \"unchecked\"})",
+            "  public static <T> Factory<GenericClass<T>> create() {",
+            "    return (Factory) INSTANCE;",
+            "  }",
+            "",
+            "}");
     assertAbout(javaSource()).that(file)
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
@@ -1271,24 +1273,26 @@ public void noDeps() {
         "final class SimpleType {",
         "  @Inject SimpleType() {}",
         "}");
-    JavaFileObject factory = JavaFileObjects.forSourceLines("test.SimpleType_Factory",
-        "package test;",
-        "",
-        "import dagger.internal.Factory;",
-        "import javax.annotation.Generated;",
-        "",
-        GENERATED_ANNOTATION,
-        "public enum SimpleType_Factory implements Factory<SimpleType> {",
-        "  INSTANCE;",
-        "",
-        "  @Override public SimpleType get() {",
-        "    return new SimpleType();",
-        "  }",
-        "",
-        "  public static Factory<SimpleType> create() {",
-        "    return INSTANCE;",
-        "  }",
-        "}");
+    JavaFileObject factory =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleType_Factory",
+            "package test;",
+            "",
+            "import dagger.internal.Factory;",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class SimpleType_Factory implements Factory<SimpleType> {",
+            "  private static final SimpleType_Factory INSTANCE = new SimpleType_Factory();",
+            "",
+            "  @Override public SimpleType get() {",
+            "    return new SimpleType();",
+            "  }",
+            "",
+            "  public static Factory<SimpleType> create() {",
+            "    return INSTANCE;",
+            "  }",
+            "}");
     assertAbout(javaSource())
         .that(simpleType)
         .processedWith(new ComponentProcessor())
@@ -1315,25 +1319,26 @@ public void noDeps() {
         "    void inject(B b);",
         "  }",
         "}");
-    JavaFileObject aFactory = JavaFileObjects.forSourceLines(
-        "test.OuterType_A_Factory",
-        "package test;",
-        "",
-        "import dagger.internal.Factory;",
-        "import javax.annotation.Generated;",
-        "",
-        GENERATED_ANNOTATION,
-        "public enum OuterType_A_Factory implements Factory<OuterType.A> {",
-        "  INSTANCE;",
-        "",
-        "  @Override public OuterType.A get() {",
-        "    return new OuterType.A();",
-        "  }",
-        "",
-        "  public static Factory<OuterType.A> create() {",
-        "    return INSTANCE;",
-        "  }",
-        "}");
+    JavaFileObject aFactory =
+        JavaFileObjects.forSourceLines(
+            "test.OuterType_A_Factory",
+            "package test;",
+            "",
+            "import dagger.internal.Factory;",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class OuterType_A_Factory implements Factory<OuterType.A> {",
+            "  private static final OuterType_A_Factory INSTANCE = new OuterType_A_Factory();",
+            "",
+            "  @Override public OuterType.A get() {",
+            "    return new OuterType.A();",
+            "  }",
+            "",
+            "  public static Factory<OuterType.A> create() {",
+            "    return INSTANCE;",
+            "  }",
+            "}");
     assertAbout(javaSources()).that(ImmutableList.of(nestedTypesFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
diff --git a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
index 7f167647d..202c8c485 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
@@ -1050,6 +1050,10 @@ public void genericSubclassedModule() {
             "  @Provides static Object provideNonGenericType() {",
             "    return new Object();",
             "  }",
+            "",
+            "  @Provides static String provideNonGenericTypeWithDeps(Object o) {",
+            "    return o.toString();",
+            "  }",
             "}");
 
     JavaFileObject provideMapStringNumberFactory =
@@ -1063,9 +1067,10 @@ public void genericSubclassedModule() {
             "import javax.annotation.Generated;",
             "",
             GENERATED_ANNOTATION,
-            "public enum ParameterizedModule_ProvideMapStringNumberFactory",
+            "public final class ParameterizedModule_ProvideMapStringNumberFactory",
             "    implements Factory<Map<String, Number>> {",
-            "  INSTANCE;",
+            "  private static final ParameterizedModule_ProvideMapStringNumberFactory INSTANCE =",
+            "      new ParameterizedModule_ProvideMapStringNumberFactory();",
             "",
             "  @Override",
             "  public Map<String, Number> get() {",
@@ -1088,9 +1093,10 @@ public void genericSubclassedModule() {
             "import javax.annotation.Generated;",
             "",
             GENERATED_ANNOTATION,
-            "public enum ParameterizedModule_ProvideNonGenericTypeFactory",
+            "public final class ParameterizedModule_ProvideNonGenericTypeFactory",
             "    implements Factory<Object> {",
-            "  INSTANCE;",
+            "  private static final ParameterizedModule_ProvideNonGenericTypeFactory INSTANCE = ",
+            "      new ParameterizedModule_ProvideNonGenericTypeFactory();",
             "",
             "  @Override",
             "  public Object get() {",
@@ -1103,12 +1109,48 @@ public void genericSubclassedModule() {
             "  }",
             "}");
 
+    JavaFileObject provideNonGenericTypeWithDepsFactory =
+        JavaFileObjects.forSourceLines(
+            "test.ParameterizedModule_ProvideNonGenericTypeWithDepsFactory;",
+            "package test;",
+            "",
+            "import dagger.internal.Factory;",
+            "import dagger.internal.Preconditions;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class ParameterizedModule_ProvideNonGenericTypeWithDepsFactory",
+            "    implements Factory<String> {",
+            "  private final Provider<Object> oProvider;",
+            "",
+            "  public ParameterizedModule_ProvideNonGenericTypeWithDepsFactory(",
+            "      Provider<Object> oProvider) {",
+            "    assert oProvider != null;",
+            "    this.oProvider = oProvider;",
+            "  }",
+            "",
+            "  @Override",
+            "  public String get() {",
+            "    return Preconditions.checkNotNull(",
+            "        ParameterizedModule.provideNonGenericTypeWithDeps(oProvider.get()),",
+            "        " + NPE_LITERAL + ");",
+            "  }",
+            "",
+            "  public static Factory<String> create(Provider<Object> oProvider) {",
+            "    return new ParameterizedModule_ProvideNonGenericTypeWithDepsFactory(oProvider);",
+            "  }",
+            "}");
+
     assertAbout(javaSource())
         .that(moduleFile)
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and()
-        .generatesSources(provideMapStringNumberFactory, provideNonGenericTypeFactory);
+        .generatesSources(
+            provideMapStringNumberFactory,
+            provideNonGenericTypeFactory,
+            provideNonGenericTypeWithDepsFactory);
   }
 
   @Test public void providesMethodMultipleQualifiers() {
