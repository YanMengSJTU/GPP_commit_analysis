diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/MembersInjectionVisibilityComponent.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/MembersInjectionVisibilityComponent.java
new file mode 100644
index 000000000..85ce40aac
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/MembersInjectionVisibilityComponent.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.multipackage;
+
+import dagger.Component;
+import test.multipackage.a.AGrandchild;
+import test.multipackage.a.AModule;
+import test.multipackage.a.AParent;
+import test.multipackage.b.BChild;
+
+/**
+ * A component that tests members injection across packages and subclasses.
+ */
+@Component(modules = {AModule.class})
+public interface MembersInjectionVisibilityComponent {
+  void inject(AParent aParent);
+
+  void inject(BChild aChild);
+
+  void inject(AGrandchild aGrandchild);
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AGrandchild.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AGrandchild.java
new file mode 100644
index 000000000..8f0f1f39c
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AGrandchild.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.multipackage.a;
+
+import javax.inject.Inject;
+import test.multipackage.b.BChild;
+
+public class AGrandchild extends BChild {
+
+  @Inject APackagePrivateObject aGrandchildField;
+
+  private APackagePrivateObject aGrandchildMethod;
+
+  @Inject
+  void aGrandchildMethod(APackagePrivateObject aGrandchildMethod) {
+    this.aGrandchildMethod = aGrandchildMethod;
+  }
+
+  @Override
+  @Inject
+  protected void aParentMethod(APublicObject aParentMethod) {
+    super.aParentMethod(aParentMethod);
+  }
+
+  @Override
+  protected void aChildMethod(APublicObject aChildMethod) {
+    super.aChildMethod(aChildMethod);
+  }
+
+  public APackagePrivateObject aGrandchildField() {
+    return aGrandchildField;
+  }
+
+  public APackagePrivateObject aGrandchildMethod() {
+    return aGrandchildMethod;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/APackagePrivateObject.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/APackagePrivateObject.java
new file mode 100644
index 000000000..d60413331
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/APackagePrivateObject.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.multipackage.a;
+
+import javax.inject.Inject;
+
+class APackagePrivateObject {
+
+  @Inject
+  APackagePrivateObject() {}
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AParent.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AParent.java
new file mode 100644
index 000000000..4c91a6f26
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AParent.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.multipackage.a;
+
+import javax.inject.Inject;
+
+public class AParent {
+
+  @Inject APackagePrivateObject aParentField;
+
+  private APublicObject aParentMethod;
+
+  @Inject
+  protected void aParentMethod(APublicObject aParentMethod) {
+    this.aParentMethod = aParentMethod;
+  }
+
+  public APackagePrivateObject aParentField() {
+    return aParentField;
+  }
+
+  public APublicObject aParentMethod() {
+    return aParentMethod;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/APublicObject.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/APublicObject.java
new file mode 100644
index 000000000..90357f661
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/APublicObject.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.multipackage.a;
+
+import javax.inject.Inject;
+
+public class APublicObject {
+
+  @Inject
+  APublicObject() {}
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/b/BChild.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/b/BChild.java
new file mode 100644
index 000000000..188d1201f
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/b/BChild.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.multipackage.b;
+
+import javax.inject.Inject;
+import test.multipackage.a.AParent;
+import test.multipackage.a.APublicObject;
+
+public class BChild extends AParent {
+
+  @Inject BPackagePrivateObject aChildField;
+
+  private APublicObject aChildMethod;
+
+  @Inject
+  protected void aChildMethod(APublicObject aChildMethod) {
+    this.aChildMethod = aChildMethod;
+  }
+
+  @Override
+  protected void aParentMethod(APublicObject aParentMethod) {
+    super.aParentMethod(aParentMethod);
+  }
+
+  public BPackagePrivateObject aChildField() {
+    return aChildField;
+  }
+
+  public APublicObject aChildMethod() {
+    return aChildMethod;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/b/BPackagePrivateObject.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/b/BPackagePrivateObject.java
new file mode 100644
index 000000000..c397a02c8
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/b/BPackagePrivateObject.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.multipackage.b;
+
+import javax.inject.Inject;
+
+class BPackagePrivateObject {
+
+  @Inject
+  BPackagePrivateObject() {}
+}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/membersinject/MembersInjectTest.java b/compiler/src/it/functional-tests/src/test/java/test/membersinject/MembersInjectTest.java
index 1b382d8f7..d655c0f39 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/membersinject/MembersInjectTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/membersinject/MembersInjectTest.java
@@ -18,6 +18,13 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
+import test.multipackage.DaggerMembersInjectionVisibilityComponent;
+import test.multipackage.MembersInjectionVisibilityComponent;
+import test.multipackage.a.AGrandchild;
+import test.multipackage.a.AParent;
+import test.multipackage.b.BChild;
+
+import static com.google.common.truth.Truth.assertThat;
 
 @RunWith(JUnit4.class)
 public class MembersInjectTest {
@@ -42,4 +49,30 @@
     ChildOfPrimitiveIntArray childOfPrimitiveIntArray = new ChildOfPrimitiveIntArray();
     component.inject(childOfPrimitiveIntArray);
   }
+  
+  @Test
+  public void testMembersInject_overrides() {
+    MembersInjectionVisibilityComponent component =
+        DaggerMembersInjectionVisibilityComponent.create();
+    AParent aParent = new AParent();
+    component.inject(aParent);
+    assertThat(aParent.aParentField()).isNotNull();
+    assertThat(aParent.aParentMethod()).isNotNull();
+
+    BChild aChild = new BChild();
+    component.inject(aChild);
+    assertThat(aChild.aParentField()).isNotNull();
+    assertThat(aChild.aParentMethod()).isNull();
+    assertThat(aChild.aChildField()).isNotNull();
+    assertThat(aChild.aChildMethod()).isNotNull();
+
+    AGrandchild aGrandchild = new AGrandchild();
+    component.inject(aGrandchild);
+    assertThat(aGrandchild.aParentField()).isNotNull();
+    assertThat(aGrandchild.aParentMethod()).isNotNull();
+    assertThat(aGrandchild.aChildField()).isNotNull();
+    assertThat(aGrandchild.aChildMethod()).isNull();
+    assertThat(aGrandchild.aGrandchildField()).isNotNull();
+    assertThat(aGrandchild.aGrandchildMethod()).isNotNull();
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index de830cc8f..cf068bb43 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -61,12 +61,15 @@
 import dagger.producers.internal.SetProducer;
 import java.util.Collection;
 import java.util.EnumSet;
+import java.util.HashSet;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import javax.annotation.Generated;
 import javax.inject.Provider;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.Name;
@@ -75,6 +78,8 @@
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 import javax.tools.Diagnostic;
 import javax.tools.Diagnostic.Kind;
@@ -95,7 +100,8 @@
 import static dagger.internal.codegen.SourceFiles.factoryNameForProductionBinding;
 import static dagger.internal.codegen.SourceFiles.factoryNameForProvisionBinding;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
-import static dagger.internal.codegen.SourceFiles.membersInjectorNameForMembersInjectionBinding;
+import static dagger.internal.codegen.SourceFiles.indexDependenciesByUnresolvedKey;
+import static dagger.internal.codegen.SourceFiles.membersInjectorNameForType;
 import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
 import static dagger.internal.codegen.Util.getKeyTypeOfMap;
 import static dagger.internal.codegen.Util.getProvidedValueTypeOfMap;
@@ -114,8 +120,9 @@
 abstract class AbstractComponentWriter {
 
   // TODO(dpb): Make all these fields private after refactoring is complete.
-
+  protected final Elements elements;
   protected final Types types;
+  protected final Key.Factory keyFactory;
   protected final Kind nullableValidationType;
   protected final Set<JavaWriter> javaWriters = new LinkedHashSet<>();
   protected final ClassName name;
@@ -145,8 +152,15 @@
   protected final Map<TypeElement, MemberSelect> componentContributionFields = Maps.newHashMap();
 
   AbstractComponentWriter(
-      Types types, Diagnostic.Kind nullableValidationType, ClassName name, BindingGraph graph) {
+      Types types,
+      Elements elements,
+      Key.Factory keyFactory,
+      Diagnostic.Kind nullableValidationType,
+      ClassName name,
+      BindingGraph graph) {
     this.types = types;
+    this.elements = elements;
+    this.keyFactory = keyFactory;
     this.nullableValidationType = nullableValidationType;
     this.name = name;
     this.graph = graph;
@@ -521,7 +535,6 @@ private void addField(
 
   private void implementInterfaceMethods() {
     Set<MethodSignature> interfaceMethods = Sets.newHashSet();
-
     for (ComponentMethodDescriptor componentMethod :
         graph.componentDescriptor().componentMethods()) {
       if (componentMethod.dependencyRequest().isPresent()) {
@@ -858,7 +871,7 @@ private Snippet initializeFactoryForProvisionBinding(ProvisionBinding binding) {
             && !binding.bindingElement().getModifiers().contains(STATIC)) {
           parameters.add(getComponentContributionSnippet(binding.contributedBy().get()));
         }
-        parameters.addAll(getDependencyParameters(binding.implicitDependencies()));
+        parameters.addAll(getDependencyParameters(binding));
 
         Snippet factorySnippet =
             Snippet.format(
@@ -903,7 +916,7 @@ private Snippet initializeFactoryForProductionBinding(ProductionBinding binding)
         parameters.add(
             getComponentContributionSnippet(
                 graph.componentDescriptor().executorDependency().get()));
-        parameters.addAll(getProducerDependencyParameters(binding.dependencies()));
+        parameters.addAll(getProducerDependencyParameters(binding));
 
         return Snippet.format(
             "new %s(%s)",
@@ -918,54 +931,74 @@ private Snippet initializeMembersInjectorForBinding(MembersInjectionBinding bind
     switch (binding.injectionStrategy()) {
       case NO_OP:
         return Snippet.format("%s.noOp()", ClassName.fromClass(MembersInjectors.class));
-      case DELEGATE:
-        DependencyRequest parentInjectorRequest = binding.parentInjectorRequest().get();
-        return Snippet.format(
-            "%s.delegatingTo(%s)",
-            ClassName.fromClass(MembersInjectors.class),
-            getMemberSelectSnippet(parentInjectorRequest.bindingKey()));
       case INJECT_MEMBERS:
-        List<Snippet> parameters = getDependencyParameters(binding.implicitDependencies());
+        List<Snippet> parameters = getDependencyParameters(binding);
         return Snippet.format(
             "%s.create(%s)",
-            membersInjectorNameForMembersInjectionBinding(binding),
+            membersInjectorNameForType(binding.bindingElement()),
             Snippet.makeParametersSnippet(parameters));
       default:
         throw new AssertionError();
     }
   }
 
-  private List<Snippet> getDependencyParameters(Iterable<DependencyRequest> dependencies) {
+  private List<Snippet> getDependencyParameters(Binding binding) {
     ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
+    Set<Key> keysSeen = new HashSet<>();
     for (Collection<DependencyRequest> requestsForKey :
-        SourceFiles.indexDependenciesByUnresolvedKey(types, dependencies).asMap().values()) {
-      BindingKey key = Iterables.getOnlyElement(FluentIterable.from(requestsForKey)
-          .transform(new Function<DependencyRequest, BindingKey>() {
-            @Override public BindingKey apply(DependencyRequest request) {
-              return request.bindingKey();
-            }
-          })
-          .toSet());
-      if (bindingKeysWithDelegates.contains(key)) {
-        parameters.add(delegateFactoryVariableSnippet(key));
-      } else {
-        parameters.add(getMemberSelect(key).getSnippetWithRawTypeCastFor(name));
+        indexDependenciesByUnresolvedKey(types, binding.implicitDependencies()).asMap().values()) {
+      Set<BindingKey> requestedBindingKeys = new HashSet<>();
+      for (DependencyRequest dependencyRequest : requestsForKey) {
+        Element requestElement = dependencyRequest.requestElement();
+        TypeMirror typeMirror = typeMirrorAsMemberOf(binding.bindingTypeElement(), requestElement);
+        Key key = keyFactory.forQualifiedType(dependencyRequest.key().qualifier(), typeMirror);
+        if (keysSeen.add(key)) {
+          requestedBindingKeys.add(dependencyRequest.bindingKey());
+        }
+      }
+      if (!requestedBindingKeys.isEmpty()) {
+        BindingKey key = Iterables.getOnlyElement(requestedBindingKeys);
+        if (bindingKeysWithDelegates.contains(key)) {
+          parameters.add(delegateFactoryVariableSnippet(key));
+        } else {
+          parameters.add(getMemberSelect(key).getSnippetWithRawTypeCastFor(name));
+        }
       }
     }
     return parameters.build();
   }
 
-  private List<Snippet> getProducerDependencyParameters(
-      Iterable<DependencyRequest> dependencies) {
+  // TODO(dpb): Investigate use of asMemberOf here. Why aren't the dependency requests already
+  // resolved?
+  private TypeMirror typeMirrorAsMemberOf(TypeElement bindingTypeElement, Element requestElement) {
+    TypeMirror requestType = requestElement.asType();
+    if (requestType.getKind() == TypeKind.TYPEVAR) {
+      return types.asMemberOf(
+          MoreTypes.asDeclared(bindingTypeElement.asType()),
+          (requestElement.getKind() == ElementKind.PARAMETER)
+              ? MoreTypes.asElement(requestType)
+              : requestElement);
+    } else {
+      return requestType;
+    }
+  }
+
+  private List<Snippet> getProducerDependencyParameters(Binding binding) {
     ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
     for (Collection<DependencyRequest> requestsForKey :
-        SourceFiles.indexDependenciesByUnresolvedKey(types, dependencies).asMap().values()) {
-      BindingKey key = Iterables.getOnlyElement(FluentIterable.from(requestsForKey)
-          .transform(new Function<DependencyRequest, BindingKey>() {
-            @Override public BindingKey apply(DependencyRequest request) {
-              return request.bindingKey();
-            }
-          }));
+        SourceFiles.indexDependenciesByUnresolvedKey(types, binding.dependencies())
+            .asMap()
+            .values()) {
+      BindingKey key =
+          Iterables.getOnlyElement(
+              FluentIterable.from(requestsForKey)
+                  .transform(
+                      new Function<DependencyRequest, BindingKey>() {
+                        @Override
+                        public BindingKey apply(DependencyRequest request) {
+                          return request.bindingKey();
+                        }
+                      }));
       ResolvedBindings resolvedBindings = graph.resolvedBindings().get(key);
       Class<?> frameworkClass =
           DependencyRequestMapper.FOR_PRODUCER.getFrameworkClass(requestsForKey);
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index 2e5d869b1..7bd476a33 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -55,7 +55,7 @@
 import static dagger.internal.codegen.ComponentDescriptor.isComponentProductionMethod;
 import static dagger.internal.codegen.ComponentDescriptor.Kind.PRODUCTION_COMPONENT;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
-import static dagger.internal.codegen.MembersInjectionBinding.Strategy.DELEGATE;
+import static dagger.internal.codegen.MembersInjectionBinding.Strategy.INJECT_MEMBERS;
 import static dagger.internal.codegen.MembersInjectionBinding.Strategy.NO_OP;
 
 /**
@@ -350,9 +350,11 @@ private MembersInjectionBinding rollUpMembersInjectionBindings(Key key) {
         MembersInjectionBinding membersInjectionBinding =
             injectBindingRegistry.getOrFindMembersInjectionBinding(key);
 
-        if (membersInjectionBinding.injectionStrategy().equals(DELEGATE)) {
-          MembersInjectionBinding parentBinding = rollUpMembersInjectionBindings(
-              membersInjectionBinding.parentInjectorRequest().get().key());
+        if (membersInjectionBinding.parentInjectorRequest().isPresent()
+            && membersInjectionBinding.injectionStrategy().equals(INJECT_MEMBERS)) {
+          MembersInjectionBinding parentBinding =
+              rollUpMembersInjectionBindings(
+                  membersInjectionBinding.parentInjectorRequest().get().key());
           if (parentBinding.injectionStrategy().equals(NO_OP)) {
             return membersInjectionBinding.withoutParentInjectorRequest();
           }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index f79f0bc99..b5212f6bf 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -27,6 +27,7 @@
 import dagger.internal.codegen.writer.TypeName;
 import javax.annotation.processing.Filer;
 import javax.lang.model.element.Element;
+import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 import javax.tools.Diagnostic;
 
@@ -38,11 +39,20 @@
  */
 final class ComponentGenerator extends SourceFileGenerator<BindingGraph> {
   private final Types types;
+  private final Elements elements;
+  private final Key.Factory keyFactory;
   private final Diagnostic.Kind nullableValidationType;
 
-  ComponentGenerator(Filer filer, Types types, Diagnostic.Kind nullableValidationType) {
+  ComponentGenerator(
+      Filer filer,
+      Elements elements,
+      Types types,
+      Key.Factory keyFactory,
+      Diagnostic.Kind nullableValidationType) {
     super(filer);
     this.types = types;
+    this.elements = elements;
+    this.keyFactory = keyFactory;
     this.nullableValidationType = nullableValidationType;
   }
 
@@ -115,14 +125,14 @@ Snippet getSnippetWithRawTypeCastFor(ClassName usingClass) {
     }
 
     Snippet getSnippetFor(ClassName usingClass) {
-      return owningClass().equals(usingClass)
-          ? snippet()
-          : qualifiedSelectSnippet();
+      return owningClass().equals(usingClass) ? snippet() : qualifiedSelectSnippet();
     }
   }
 
   @Override
   ImmutableSet<JavaWriter> write(ClassName componentName, BindingGraph input) {
-    return new ComponentWriter(types, nullableValidationType, componentName, input).write();
+    return new ComponentWriter(
+            types, elements, keyFactory, nullableValidationType, componentName, input)
+        .write();
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index cea6fe232..9c6b7511d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -115,9 +115,9 @@ public SourceVersion getSupportedSourceVersion() {
     this.factoryGenerator =
         new FactoryGenerator(filer, DependencyRequestMapper.FOR_PROVIDER, nullableDiagnosticType);
     this.membersInjectorGenerator =
-        new MembersInjectorGenerator(filer, elements, types, DependencyRequestMapper.FOR_PROVIDER);
+        new MembersInjectorGenerator(filer, DependencyRequestMapper.FOR_PROVIDER);
     ComponentGenerator componentGenerator =
-        new ComponentGenerator(filer, types, nullableDiagnosticType);
+        new ComponentGenerator(filer, elements, types, keyFactory, nullableDiagnosticType);
     ProducerFactoryGenerator producerFactoryGenerator =
         new ProducerFactoryGenerator(filer, DependencyRequestMapper.FOR_PRODUCER);
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
index 8690b3967..5221cf0a2 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
@@ -23,6 +23,7 @@
 import dagger.internal.codegen.writer.MethodWriter;
 import javax.annotation.Generated;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 import javax.tools.Diagnostic.Kind;
 
@@ -37,8 +38,13 @@
 class ComponentWriter extends AbstractComponentWriter {
 
   ComponentWriter(
-      Types types, Kind nullableValidationType, ClassName name, BindingGraph graph) {
-    super(types, nullableValidationType, name, graph);
+      Types types,
+      Elements elements,
+      Key.Factory keyFactory,
+      Kind nullableValidationType,
+      ClassName name,
+      BindingGraph graph) {
+    super(types, elements, keyFactory, nullableValidationType, name, graph);
   }
 
   @Override
diff --git a/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java b/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
index ac4256701..b92cef796 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
@@ -24,7 +24,6 @@
 import dagger.internal.codegen.ContributionBinding.BindingType;
 import dagger.internal.codegen.writer.ClassName;
 import dagger.internal.codegen.writer.ParameterizedTypeName;
-import dagger.internal.codegen.writer.TypeName;
 import dagger.internal.codegen.writer.TypeNames;
 import dagger.producers.Producer;
 import javax.inject.Provider;
@@ -54,12 +53,12 @@ static FrameworkField createWithTypeFromKey(
         name.endsWith(suffix) ? name : name + suffix);
   }
 
-  static FrameworkField createForMapBindingContribution(
+  private static FrameworkField createForMapBindingContribution(
       Class<?> frameworkClass, BindingKey bindingKey, String name) {
     TypeMirror mapValueType =
         MoreTypes.asDeclared(bindingKey.key().type()).getTypeArguments().get(1);
     return new AutoValue_FrameworkField(frameworkClass,
-        TypeNames.forTypeMirror(mapValueType),
+        (ParameterizedTypeName) TypeNames.forTypeMirror(mapValueType),
         bindingKey,
         name);
   }
@@ -164,7 +163,7 @@ public String visitType(TypeElement e, Void p) {
   }
 
   abstract Class<?> frameworkClass();
-  abstract TypeName frameworkType();
+  abstract ParameterizedTypeName frameworkType();
   abstract BindingKey bindingKey();
   abstract String name();
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
index d6ed27961..b8e302e9a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
@@ -45,6 +45,7 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
+import static dagger.internal.codegen.SourceFiles.membersInjectorNameForType;
 
 /**
  * Maintains the collection of provision bindings from {@link Inject} constructors and members
@@ -194,8 +195,7 @@ private ProvisionBinding registerBinding(ProvisionBinding binding, boolean expli
    */
   private MembersInjectionBinding registerBinding(
       MembersInjectionBinding binding, boolean explicit) {
-    ClassName membersInjectorName =
-        SourceFiles.membersInjectorNameForMembersInjectionBinding(binding);
+    ClassName membersInjectorName = membersInjectorNameForType(binding.bindingTypeElement());
     if (binding.injectionSites().isEmpty()) {
       // empty members injection bindings are special and don't need source files.
       // so, we just pretend
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
index d11d7ef3e..1212e5aa2 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
@@ -24,11 +24,17 @@
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSortedSet;
-import com.google.common.collect.Ordering;
+import com.google.common.collect.LinkedHashMultimap;
+import com.google.common.collect.SetMultimap;
+import java.util.ArrayList;
+import java.util.Comparator;
+import java.util.HashSet;
+import java.util.List;
 import java.util.Set;
 import javax.inject.Inject;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.ElementVisitor;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
@@ -56,7 +62,7 @@
 @AutoValue
 abstract class MembersInjectionBinding extends Binding {
   @Override abstract TypeElement bindingElement();
-
+        
   /** The set of individual sites where {@link Inject} is applied. */
   abstract ImmutableSortedSet<InjectionSite> injectionSites();
 
@@ -64,18 +70,11 @@
 
   enum Strategy {
     NO_OP,
-    DELEGATE,
     INJECT_MEMBERS,
   }
 
   Strategy injectionStrategy() {
-    if (injectionSites().isEmpty()) {
-      return parentInjectorRequest().isPresent()
-          ? Strategy.DELEGATE
-          : Strategy.NO_OP;
-    } else {
-      return Strategy.INJECT_MEMBERS;
-    }
+    return injectionSites().isEmpty() ? Strategy.NO_OP : Strategy.INJECT_MEMBERS;
   }
 
   MembersInjectionBinding withoutParentInjectorRequest() {
@@ -90,27 +89,6 @@ MembersInjectionBinding withoutParentInjectorRequest() {
           Optional.<DependencyRequest>absent());
   }
 
-  private static final Ordering<InjectionSite> INJECTION_ORDERING =
-      new Ordering<InjectionSite>() {
-        @Override
-        public int compare(InjectionSite left, InjectionSite right) {
-          checkArgument(left.element().getEnclosingElement()
-              .equals(right.element().getEnclosingElement()));
-          return ComparisonChain.start()
-              // fields before methods
-              .compare(left.element().getKind(), right.element().getKind())
-              // then sort by whichever element comes first in the parent
-              // this isn't necessary, but makes the processor nice and predictable
-              .compare(targetIndexInEnclosing(left), targetIndexInEnclosing(right))
-              .result();
-        }
-
-        private int targetIndexInEnclosing(InjectionSite injectionSite)  {
-          return injectionSite.element().getEnclosingElement().getEnclosedElements()
-              .indexOf(injectionSite.element());
-        }
-      };
-
   @AutoValue
   abstract static class InjectionSite {
     enum Kind {
@@ -123,6 +101,14 @@ private int targetIndexInEnclosing(InjectionSite injectionSite)  {
     abstract Element element();
 
     abstract ImmutableSet<DependencyRequest> dependencies();
+    
+    protected int indexAmongSiblingMembers(InjectionSite injectionSite) {
+      return injectionSite
+          .element()
+          .getEnclosingElement()
+          .getEnclosedElements()
+          .indexOf(injectionSite.element());
+    }
   }
 
   static final class Factory {
@@ -139,33 +125,33 @@ private int targetIndexInEnclosing(InjectionSite injectionSite)  {
       this.dependencyRequestFactory = checkNotNull(dependencyRequestFactory);
     }
 
-    private InjectionSite injectionSiteForInjectMethod(ExecutableElement methodElement,
-        DeclaredType containingType) {
+    private InjectionSite injectionSiteForInjectMethod(
+        ExecutableElement methodElement, DeclaredType containingType) {
       checkNotNull(methodElement);
       checkArgument(methodElement.getKind().equals(ElementKind.METHOD));
-      checkArgument(isAnnotationPresent(methodElement, Inject.class));
       ExecutableType resolved =
           MoreTypes.asExecutable(types.asMemberOf(containingType, methodElement));
-      return new AutoValue_MembersInjectionBinding_InjectionSite(InjectionSite.Kind.METHOD,
+      return new AutoValue_MembersInjectionBinding_InjectionSite(
+          InjectionSite.Kind.METHOD,
           methodElement,
           dependencyRequestFactory.forRequiredResolvedVariables(
-              containingType,
-              methodElement.getParameters(),
-              resolved.getParameterTypes()));
+              containingType, methodElement.getParameters(), resolved.getParameterTypes()));
     }
 
-    private InjectionSite injectionSiteForInjectField(VariableElement fieldElement,
-        DeclaredType containingType) {
+    private InjectionSite injectionSiteForInjectField(
+        VariableElement fieldElement, DeclaredType containingType) {
       checkNotNull(fieldElement);
       checkArgument(fieldElement.getKind().equals(ElementKind.FIELD));
       checkArgument(isAnnotationPresent(fieldElement, Inject.class));
       TypeMirror resolved = types.asMemberOf(containingType, fieldElement);
-      return new AutoValue_MembersInjectionBinding_InjectionSite(InjectionSite.Kind.FIELD,
+      return new AutoValue_MembersInjectionBinding_InjectionSite(
+          InjectionSite.Kind.FIELD,
           fieldElement,
-          ImmutableSet.of(dependencyRequestFactory.forRequiredResolvedVariable(
-              containingType, fieldElement, resolved)));
+          ImmutableSet.of(
+              dependencyRequestFactory.forRequiredResolvedVariable(
+                  containingType, fieldElement, resolved)));
     }
-  
+
     /** Returns an unresolved version of this binding. */
     MembersInjectionBinding unresolve(MembersInjectionBinding binding) {
       checkState(binding.hasNonDefaultTypeParameters());
@@ -178,76 +164,146 @@ MembersInjectionBinding unresolve(MembersInjectionBinding binding) {
      * this will return a resolved binding, with the key & type resolved to the given type (using
      * {@link Types#asMemberOf(DeclaredType, Element)}).
      */
-    MembersInjectionBinding forInjectedType(DeclaredType type, Optional<TypeMirror> resolvedType) {
+    MembersInjectionBinding forInjectedType(
+        DeclaredType declaredType, Optional<TypeMirror> resolvedType) {
       // If the class this is injecting has some type arguments, resolve everything.
-      if (!type.getTypeArguments().isEmpty() && resolvedType.isPresent()) {
+      if (!declaredType.getTypeArguments().isEmpty() && resolvedType.isPresent()) {
         DeclaredType resolved = MoreTypes.asDeclared(resolvedType.get());
         // Validate that we're resolving from the correct type.
-        checkState(types.isSameType(types.erasure(resolved), types.erasure(type)),
+        checkState(
+            types.isSameType(types.erasure(resolved), types.erasure(declaredType)),
             "erased expected type: %s, erased actual type: %s",
-            types.erasure(resolved), types.erasure(type));
-        type = resolved;
-      }
-
-      TypeElement typeElement = MoreElements.asType(type.asElement());
-      final DeclaredType resolved = type;
-      ImmutableSortedSet.Builder<InjectionSite> injectionSitesBuilder =
-          ImmutableSortedSet.orderedBy(INJECTION_ORDERING);
-      for (Element enclosedElement : typeElement.getEnclosedElements()) {
-        injectionSitesBuilder.addAll(enclosedElement.accept(
-            new ElementKindVisitor6<Optional<InjectionSite>, Void>(
-                Optional.<InjectionSite>absent()) {
-                  @Override
-                  public Optional<InjectionSite> visitExecutableAsMethod(ExecutableElement e,
-                      Void p) {
-                    return isAnnotationPresent(e, Inject.class) && modifiersSupported(e)
-                        ? Optional.of(injectionSiteForInjectMethod(e, resolved))
-                        : Optional.<InjectionSite>absent();
-                  }
-
-                  @Override
-                  public Optional<InjectionSite> visitVariableAsField(VariableElement e, Void p) {
-                    return isAnnotationPresent(e, Inject.class) && modifiersSupported(e)
-                        ? Optional.of(injectionSiteForInjectField(e, resolved))
-                        : Optional.<InjectionSite>absent();
-                  }
-                }, null).asSet());
+            types.erasure(resolved),
+            types.erasure(declaredType));
+        declaredType = resolved;
       }
-      ImmutableSortedSet<InjectionSite> injectionSites = injectionSitesBuilder.build();
-
-      ImmutableSet<DependencyRequest> dependencies = FluentIterable.from(injectionSites)
-          .transformAndConcat(new Function<InjectionSite, Set<DependencyRequest>>() {
-            @Override public Set<DependencyRequest> apply(InjectionSite input) {
-              return input.dependencies();
-            }
-          })
-          .toSet();
+      ImmutableSortedSet<InjectionSite> injectionSites = getInjectionSites(declaredType);
+      ImmutableSet<DependencyRequest> dependencies =
+          FluentIterable.from(injectionSites)
+              .transformAndConcat(
+                  new Function<InjectionSite, Set<DependencyRequest>>() {
+                    @Override
+                    public Set<DependencyRequest> apply(InjectionSite input) {
+                      return input.dependencies();
+                    }
+                  })
+              .toSet();
 
       Optional<DependencyRequest> parentInjectorRequest =
-          MoreTypes.nonObjectSuperclass(types, elements, type)
-              .transform(new Function<DeclaredType, DependencyRequest>() {
-                @Override public DependencyRequest apply(DeclaredType input) {
-                  return dependencyRequestFactory.forMembersInjectedType(input);
-                }
-              });
-
-      Key key = keyFactory.forMembersInjectedType(type);
+          MoreTypes.nonObjectSuperclass(types, elements, declaredType)
+              .transform(
+                  new Function<DeclaredType, DependencyRequest>() {
+                    @Override
+                    public DependencyRequest apply(DeclaredType input) {
+                      return dependencyRequestFactory.forMembersInjectedType(input);
+                    }
+                  });
+
+      Key key = keyFactory.forMembersInjectedType(declaredType);
+      TypeElement typeElement = MoreElements.asType(declaredType.asElement());
       return new AutoValue_MembersInjectionBinding(
           key,
           dependencies,
-          new ImmutableSet.Builder<DependencyRequest>()
-              .addAll(parentInjectorRequest.asSet())
-              .addAll(dependencies)
-              .build(),
+          dependencies,
           findBindingPackage(key),
           hasNonDefaultTypeParameters(typeElement, key.type(), types),
           typeElement,
           injectionSites,
           parentInjectorRequest);
     }
-    
-    protected boolean modifiersSupported(Element e) {
-      return !e.getModifiers().contains(PRIVATE) && !e.getModifiers().contains(STATIC);
+
+    private ImmutableSortedSet<InjectionSite> getInjectionSites(DeclaredType declaredType) {
+      Set<InjectionSite> injectionSites = new HashSet<>();
+      final List<TypeElement> ancestors = new ArrayList<>();
+      SetMultimap<String, ExecutableElement> overriddenMethodMap = LinkedHashMultimap.create();
+      for (Optional<DeclaredType> currentType = Optional.of(declaredType);
+          currentType.isPresent();
+          currentType = MoreTypes.nonObjectSuperclass(types, elements, currentType.get())) {
+        final DeclaredType type = currentType.get();
+        ancestors.add(MoreElements.asType(type.asElement()));
+        for (Element enclosedElement : type.asElement().getEnclosedElements()) {
+          Optional<InjectionSite> maybeInjectionSite =
+              injectionSiteVisitor.visit(enclosedElement, type);
+          if (maybeInjectionSite.isPresent()) {
+            InjectionSite injectionSite = maybeInjectionSite.get();
+            if (shouldBeInjected(injectionSite.element(), overriddenMethodMap)) {
+              injectionSites.add(injectionSite);
+            }
+            if (injectionSite.kind() == InjectionSite.Kind.METHOD) {
+              ExecutableElement injectionSiteMethod =
+                  MoreElements.asExecutable(injectionSite.element());
+              overriddenMethodMap.put(
+                  injectionSiteMethod.getSimpleName().toString(), injectionSiteMethod);
+            }
+          }
+        }
+      }
+      return ImmutableSortedSet.copyOf(
+          new Comparator<InjectionSite>() {
+            @Override
+            public int compare(InjectionSite left, InjectionSite right) {
+              return ComparisonChain.start()
+                  // supertypes before subtypes
+                  .compare(
+                      ancestors.indexOf(right.element().getEnclosingElement()),
+                      ancestors.indexOf(left.element().getEnclosingElement()))
+                  // fields before methods
+                  .compare(left.element().getKind(), right.element().getKind())
+                  // then sort by whichever element comes first in the parent
+                  // this isn't necessary, but makes the processor nice and predictable
+                  .compare(
+                      left.indexAmongSiblingMembers(left), right.indexAmongSiblingMembers(right))
+                  .result();
+            }
+          },
+          injectionSites);
+    }
+
+    private boolean shouldBeInjected(
+        Element injectionSite, SetMultimap<String, ExecutableElement> overriddenMethodMap) {
+      if (!isAnnotationPresent(injectionSite, Inject.class)
+          || injectionSite.getModifiers().contains(PRIVATE)
+          || injectionSite.getModifiers().contains(STATIC)) {
+        return false;
+      }
+
+      if (injectionSite.getKind().isField()) { // Inject all fields (self and ancestors)
+        return true;
+      }
+
+      // For each method with the same name belonging to any descendant class, return false if any
+      // method has already overridden the injectionSite method. To decrease the number of methods
+      // that are checked, we store the already injected methods in a SetMultimap and only
+      // check the methods with the same name.
+      ExecutableElement injectionSiteMethod = MoreElements.asExecutable(injectionSite);
+      TypeElement injectionSiteType = MoreElements.asType(injectionSite.getEnclosingElement());
+      for (ExecutableElement method :
+          overriddenMethodMap.get(injectionSiteMethod.getSimpleName().toString())) {
+        if (elements.overrides(method, injectionSiteMethod, injectionSiteType)) {
+          return false;
+        }
+      }
+      return true;
     }
+
+    private final ElementVisitor<Optional<InjectionSite>, DeclaredType> injectionSiteVisitor =
+        new ElementKindVisitor6<Optional<InjectionSite>, DeclaredType>(
+            Optional.<InjectionSite>absent()) {
+          @Override
+          public Optional<InjectionSite> visitExecutableAsMethod(
+              ExecutableElement e, DeclaredType type) {
+            return Optional.of(injectionSiteForInjectMethod(e, type));
+          }
+
+          @Override
+          public Optional<InjectionSite> visitVariableAsField(
+              VariableElement e, DeclaredType type) {
+            return (isAnnotationPresent(e, Inject.class)
+                    && !e.getModifiers().contains(PRIVATE)
+                    && !e.getModifiers().contains(STATIC))
+                ? Optional.of(injectionSiteForInjectField(e, type))
+                : Optional.<InjectionSite>absent();
+          }
+        };
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
index c4d0db6cc..f7fcdee9d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
@@ -15,7 +15,8 @@
  */
 package dagger.internal.codegen;
 
-import com.google.auto.common.MoreTypes;
+import com.google.auto.common.MoreElements;
+import com.google.common.base.CaseFormat;
 import com.google.common.base.Function;
 import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
@@ -23,7 +24,6 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
 import dagger.MembersInjector;
 import dagger.internal.codegen.MembersInjectionBinding.InjectionSite;
@@ -33,31 +33,41 @@
 import dagger.internal.codegen.writer.FieldWriter;
 import dagger.internal.codegen.writer.JavaWriter;
 import dagger.internal.codegen.writer.MethodWriter;
+import dagger.internal.codegen.writer.Modifiable;
 import dagger.internal.codegen.writer.ParameterizedTypeName;
 import dagger.internal.codegen.writer.Snippet;
 import dagger.internal.codegen.writer.TypeName;
 import dagger.internal.codegen.writer.TypeNames;
 import dagger.internal.codegen.writer.TypeVariableName;
+import dagger.internal.codegen.writer.VariableWriter;
 import dagger.internal.codegen.writer.VoidName;
+import dagger.producers.Producer;
+import java.util.HashSet;
 import java.util.List;
-import java.util.Map;
 import java.util.Map.Entry;
+import java.util.Set;
 import javax.annotation.Generated;
 import javax.annotation.processing.Filer;
+import javax.inject.Provider;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeParameterElement;
+import javax.lang.model.type.ArrayType;
 import javax.lang.model.type.DeclaredType;
-import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
+import javax.lang.model.type.TypeVisitor;
+import javax.lang.model.util.SimpleTypeVisitor7;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.auto.common.MoreElements.getPackage;
 import static com.google.common.base.Preconditions.checkState;
+import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
+import static dagger.internal.codegen.SourceFiles.membersInjectorNameForType;
 import static dagger.internal.codegen.SourceFiles.parameterizedMembersInjectorNameForMembersInjectionBinding;
+import static dagger.internal.codegen.writer.Snippet.makeParametersSnippet;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.STATIC;
 
 /**
  * Generates {@link MembersInjector} implementations from {@link MembersInjectionBinding} instances.
@@ -66,24 +76,18 @@
  * @since 2.0
  */
 final class MembersInjectorGenerator extends SourceFileGenerator<MembersInjectionBinding> {
-  private final Elements elements;
-  private final Types types;
   private final DependencyRequestMapper dependencyRequestMapper;
 
   MembersInjectorGenerator(
       Filer filer,
-      Elements elements,
-      Types types,
       DependencyRequestMapper dependencyRequestMapper) {
     super(filer);
-    this.elements = checkNotNull(elements);
-    this.types = checkNotNull(types);
     this.dependencyRequestMapper = dependencyRequestMapper;
   }
 
   @Override
   ClassName nameGeneratedType(MembersInjectionBinding binding) {
-    return SourceFiles.membersInjectorNameForMembersInjectionBinding(binding);
+    return membersInjectorNameForType(binding.bindingElement());
   }
 
   @Override
@@ -102,11 +106,13 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
   Optional<? extends Element> getElementForErrorReporting(MembersInjectionBinding binding) {
     return Optional.of(binding.bindingElement());
   }
-
+  
   @Override
   ImmutableSet<JavaWriter> write(ClassName generatedTypeName, MembersInjectionBinding binding) {
+    Set<String> delegateMethods = new HashSet<>();
+
     // We don't want to write out resolved bindings -- we want to write out the generic version.
-    checkState(!binding.hasNonDefaultTypeParameters());
+    checkState(!binding.hasNonDefaultTypeParameters()); 
 
     TypeName injectedTypeName = TypeNames.forTypeMirror(binding.key().type());
     JavaWriter writer = JavaWriter.inPackage(generatedTypeName.packageName());
@@ -135,38 +141,12 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
         "  throw new NullPointerException(\"Cannot inject members into a null reference\");",
         "}"));
 
-    Optional<DeclaredType> supertype =
-        MoreTypes.nonObjectSuperclass(types, elements, MoreTypes.asDeclared(binding.key().type()));
-    if (supertype.isPresent()) {
-      ParameterizedTypeName supertypeMemebersInjectorType = ParameterizedTypeName.create(
-          MembersInjector.class, TypeNames.forTypeMirror(supertype.get()));
-      injectorWriter
-          .addField(supertypeMemebersInjectorType, "supertypeInjector")
-          .addModifiers(PRIVATE, FINAL);
-      constructorWriter.addParameter(supertypeMemebersInjectorType, "supertypeInjector");
-      constructorWriter.body()
-          .addSnippet("assert supertypeInjector != null;")
-          .addSnippet("this.supertypeInjector = supertypeInjector;");
-      injectMembersWriter.body().addSnippet("supertypeInjector.injectMembers(instance);");
-    }
-
     ImmutableMap<BindingKey, FrameworkField> fields =
         SourceFiles.generateBindingFieldsForDependencies(
             dependencyRequestMapper, ImmutableSet.copyOf(binding.dependencies()));
 
     ImmutableMap.Builder<BindingKey, FieldWriter> dependencyFieldsBuilder =
         ImmutableMap.builder();
-
-    for (Entry<BindingKey, FrameworkField> fieldEntry : fields.entrySet()) {
-      FrameworkField bindingField = fieldEntry.getValue();
-      TypeName fieldType = bindingField.frameworkType();
-      FieldWriter field = injectorWriter.addField(fieldType, bindingField.name());
-      field.addModifiers(PRIVATE, FINAL);
-      constructorWriter.addParameter(field.type(), field.name());
-      constructorWriter.body().addSnippet("assert %s != null;", field.name());
-      constructorWriter.body().addSnippet("this.%1$s = %1$s;", field.name());
-      dependencyFieldsBuilder.put(fieldEntry.getKey(), field);
-    }
     
     // We use a static create method so that generated components can avoid having
     // to refer to the generic types of the factory.
@@ -174,43 +154,245 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
     MethodWriter createMethodWriter = injectorWriter.addMethod(implementedType, "create");
     createMethodWriter.addTypeParameters(typeParameters);
     createMethodWriter.addModifiers(Modifier.PUBLIC, Modifier.STATIC);
-    Map<String, TypeName> params = constructorWriter.parameters();
-    for (Map.Entry<String, TypeName> param : params.entrySet()) {
-      createMethodWriter.addParameter(param.getValue(), param.getKey());      
+
+    boolean usesRawFrameworkTypes = false;
+    for (Entry<BindingKey, FrameworkField> fieldEntry : fields.entrySet()) {
+      BindingKey bindingKey = fieldEntry.getKey();
+      FrameworkField bindingField = fieldEntry.getValue();
+
+      // If the dependency type is not visible to this members injector, then use the raw framework
+      // type for the field.
+      boolean useRawFrameworkType =
+          !VISIBLE_TO_MEMBERS_INJECTOR.visit(bindingKey.key().type(), binding);
+
+      FieldWriter field =
+          injectorWriter.addField(
+              useRawFrameworkType
+                  ? bindingField.frameworkType().type()
+                  : bindingField.frameworkType(),
+              bindingField.name());
+
+      field.addModifiers(PRIVATE, FINAL);
+      VariableWriter constructorParameter =
+          constructorWriter.addParameter(field.type(), field.name());
+      VariableWriter createMethodParameter =
+          createMethodWriter.addParameter(constructorParameter.type(), constructorParameter.name());
+
+      // If we're using the raw type for the field, then suppress the injectMembers method's
+      // unchecked-type warning and the field's and the constructor and create-method's
+      // parameters' raw-type warnings.
+      if (useRawFrameworkType) {
+        usesRawFrameworkTypes = true;
+        suppressRawTypesWarning(field);
+        suppressRawTypesWarning(constructorParameter);
+        suppressRawTypesWarning(createMethodParameter);
+      }
+
+      constructorWriter.body().addSnippet("assert %s != null;", field.name());
+      constructorWriter.body().addSnippet("this.%1$s = %1$s;", field.name());
+      dependencyFieldsBuilder.put(bindingKey, field);
     }
-    createMethodWriter.body().addSnippet("  return new %s(%s);",
-        parameterizedMembersInjectorNameForMembersInjectionBinding(binding),
-        Joiner.on(", ").join(params.keySet()));
-    
-    ImmutableMap<BindingKey, FieldWriter> depedencyFields = dependencyFieldsBuilder.build();
+
+    createMethodWriter
+        .body()
+        .addSnippet(
+            "  return new %s(%s);",
+            parameterizedMembersInjectorNameForMembersInjectionBinding(binding),
+            Joiner.on(", ").join(constructorWriter.parameters().keySet()));
+
+    ImmutableMap<BindingKey, FieldWriter> dependencyFields = dependencyFieldsBuilder.build();
     for (InjectionSite injectionSite : binding.injectionSites()) {
-      switch (injectionSite.kind()) {
-        case FIELD:
-          DependencyRequest fieldDependency =
-              Iterables.getOnlyElement(injectionSite.dependencies());
-          FieldWriter singleField = depedencyFields.get(
-              fieldDependency.bindingKey());
-          injectMembersWriter.body().addSnippet("instance.%s = %s;",
-              injectionSite.element().getSimpleName(),
-              frameworkTypeUsageStatement(Snippet.format(singleField.name()),
-                  fieldDependency.kind()));
-          break;
-        case METHOD:
-          ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
-          for (DependencyRequest methodDependency : injectionSite.dependencies()) {
-            FieldWriter field = depedencyFields.get(
-                methodDependency.bindingKey());
-            parameters.add(frameworkTypeUsageStatement(Snippet.format(field.name()),
-                methodDependency.kind()));
-          }
-          injectMembersWriter.body().addSnippet("instance.%s(%s);",
-              injectionSite.element().getSimpleName(),
-              Snippet.makeParametersSnippet(parameters.build()));
-          break;
-        default:
-          throw new AssertionError();
+      injectMembersWriter
+          .body()
+          .addSnippet(
+              visibleToMembersInjector(binding, injectionSite.element())
+                  ? directInjectMemberSnippet(binding, dependencyFields, injectionSite)
+                  : delegateInjectMemberSnippet(dependencyFields, injectionSite));
+      if (!injectionSite.element().getModifiers().contains(PUBLIC)
+          && injectionSite.element().getEnclosingElement().equals(binding.bindingElement())
+          && delegateMethods.add(injectionSiteDelegateMethodName(injectionSite.element()))) {
+        writeInjectorMethodForSubclasses(
+            injectorWriter,
+            dependencyFields,
+            typeParameters,
+            injectedTypeName,
+            injectionSite.element(),
+            injectionSite.dependencies());
       }
     }
+    
+    if (usesRawFrameworkTypes) {
+      injectMembersWriter.annotate(SuppressWarnings.class).setValue("unchecked");
+    }
+
     return ImmutableSet.of(writer);
   }
+
+  /**
+   * Returns {@code true} if {@code element} is visible to the members injector for {@code binding}.
+   */
+  // TODO(dpb,gak): Make sure that all cases are covered here. E.g., what if element is public but
+  // enclosed in a package-private element?
+  private static boolean visibleToMembersInjector(
+      MembersInjectionBinding binding, Element element) {
+    return getPackage(element).equals(getPackage(binding.bindingElement()))
+        || element.getModifiers().contains(PUBLIC);
+  }
+
+  /**
+   * Returns a snippet that directly injects the instance's field or method.
+   */
+  private Snippet directInjectMemberSnippet(
+      MembersInjectionBinding binding,
+      ImmutableMap<BindingKey, FieldWriter> dependencyFields,
+      InjectionSite injectionSite) {
+    return Snippet.format(
+        injectionSite.element().getKind().isField() ? "%s.%s = %s;" : "%s.%s(%s);",
+        getInstanceSnippetWithPotentialCast(
+            injectionSite.element().getEnclosingElement(), binding.bindingElement()),
+        injectionSite.element().getSimpleName(),
+        makeParametersSnippet(
+            parameterSnippets(dependencyFields, injectionSite.dependencies(), true)));
+  }
+
+  /**
+   * Returns a snippet that injects the instance's field or method by calling a static method on the
+   * parent members injector class.
+   */
+  private Snippet delegateInjectMemberSnippet(
+      ImmutableMap<BindingKey, FieldWriter> dependencyFields, InjectionSite injectionSite) {
+    return Snippet.format(
+        "%s.%s(%s);",
+        membersInjectorNameForType(
+            MoreElements.asType(injectionSite.element().getEnclosingElement())),
+        injectionSiteDelegateMethodName(injectionSite.element()),
+        makeParametersSnippet(
+            new ImmutableList.Builder<Snippet>()
+                .add(Snippet.format("instance"))
+                .addAll(parameterSnippets(dependencyFields, injectionSite.dependencies(), false))
+                .build()));
+  }
+
+  /**
+   * Returns the parameters for injecting a member.
+   *
+   * @param passValue if {@code true}, each parameter snippet will be the result of converting the
+   *     field from the framework type ({@link Provider}, {@link Producer}, etc.) to the real value;
+   *     if {@code false}, each parameter snippet will be just the field
+   */
+  private ImmutableList<Snippet> parameterSnippets(
+      ImmutableMap<BindingKey, FieldWriter> dependencyFields,
+      ImmutableSet<DependencyRequest> dependencies,
+      boolean passValue) {
+    ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
+    for (DependencyRequest dependency : dependencies) {
+      Snippet fieldSnippet =
+          Snippet.format("%s", dependencyFields.get(dependency.bindingKey()).name());
+      parameters.add(
+          passValue ? frameworkTypeUsageStatement(fieldSnippet, dependency.kind()) : fieldSnippet);
+    }
+    return parameters.build();
+  }
+
+  private Snippet getInstanceSnippetWithPotentialCast(
+      Element injectionSiteElement, Element bindingElement) {
+    return (injectionSiteElement.equals(bindingElement))
+        ? Snippet.format("instance")
+        : Snippet.format("((%s)instance)", injectionSiteElement);
+  }
+
+  private String injectionSiteDelegateMethodName(Element injectionSiteElement) {
+    return "inject"
+        + CaseFormat.LOWER_CAMEL.to(
+            CaseFormat.UPPER_CAMEL, injectionSiteElement.getSimpleName().toString());
+  }
+
+  private void writeInjectorMethodForSubclasses(
+      ClassWriter injectorWriter,
+      ImmutableMap<BindingKey, FieldWriter> dependencyFields,
+      List<TypeVariableName> typeParameters,
+      TypeName injectedTypeName,
+      Element injectionElement,
+      ImmutableSet<DependencyRequest> dependencies) {
+    MethodWriter methodWriter =
+        injectorWriter.addMethod(VoidName.VOID, injectionSiteDelegateMethodName(injectionElement));
+    methodWriter.addModifiers(PUBLIC, STATIC);
+    methodWriter.addParameter(injectedTypeName, "instance");
+    methodWriter.addTypeParameters(typeParameters);
+    ImmutableList.Builder<Snippet> providedParameters = ImmutableList.builder();
+    Set<String> parameterNames = new HashSet<>();
+    for (DependencyRequest dependency : dependencies) {
+      FieldWriter field = dependencyFields.get(dependency.bindingKey());
+      VariableWriter parameter =
+          methodWriter.addParameter(
+              field.type(),
+              staticInjectMethodDependencyParameterName(parameterNames, dependency, field));
+      providedParameters.add(
+          frameworkTypeUsageStatement(Snippet.format("%s", parameter.name()), dependency.kind()));
+    }
+    if (injectionElement.getKind().isField()) {
+      methodWriter
+          .body()
+          .addSnippet(
+              "instance.%s = %s;",
+              injectionElement.getSimpleName(),
+              getOnlyElement(providedParameters.build()));
+    } else {
+      methodWriter
+          .body()
+          .addSnippet(
+              "instance.%s(%s);",
+              injectionElement.getSimpleName(),
+              makeParametersSnippet(providedParameters.build()));
+    }
+  }
+
+  /**
+   * Returns the static inject method parameter name for a dependency.
+   *
+   * @param parameterNames the parameter names used so far
+   * @param dependency the dependency
+   * @param field the field used to hold the framework type for the dependency
+   */
+  private String staticInjectMethodDependencyParameterName(
+      Set<String> parameterNames, DependencyRequest dependency, FieldWriter field) {
+    StringBuilder parameterName =
+        new StringBuilder(dependency.requestElement().getSimpleName().toString());
+    switch (dependency.kind()) {
+      case LAZY:
+      case INSTANCE:
+      case FUTURE:
+        String suffix = ((ParameterizedTypeName) field.type()).type().simpleName();
+        if (parameterName.length() <= suffix.length()
+            || !parameterName.substring(parameterName.length() - suffix.length()).equals(suffix)) {
+          parameterName.append(suffix);
+        }
+        break;
+
+      default:
+        break;
+    }
+    int baseLength = parameterName.length();
+    for (int i = 2; !parameterNames.add(parameterName.toString()); i++) {
+      parameterName.replace(baseLength, parameterName.length(), String.valueOf(i));
+    }
+    return parameterName.toString();
+  }
+
+  private void suppressRawTypesWarning(Modifiable modifiable) {
+    modifiable.annotate(SuppressWarnings.class).setValue("rawtypes");
+  }
+
+  private static final TypeVisitor<Boolean, MembersInjectionBinding> VISIBLE_TO_MEMBERS_INJECTOR =
+      new SimpleTypeVisitor7<Boolean, MembersInjectionBinding>(true) {
+        @Override
+        public Boolean visitArray(ArrayType t, MembersInjectionBinding p) {
+          return visit(t.getComponentType(), p);
+        }
+
+        @Override
+        public Boolean visitDeclared(DeclaredType t, MembersInjectionBinding p) {
+          return visibleToMembersInjector(p, t.asElement());
+        }
+      };
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index 57c815b23..890d3553b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -251,7 +251,7 @@ static ClassName factoryNameForProductionBinding(ProductionBinding binding) {
    */
   static TypeName parameterizedMembersInjectorNameForMembersInjectionBinding(
       MembersInjectionBinding binding) {
-    ClassName factoryName = membersInjectorNameForMembersInjectionBinding(binding);
+    ClassName factoryName = membersInjectorNameForType(binding.bindingElement());
     TypeName bindingName = TypeNames.forTypeMirror(binding.key().type());
     // If the binding is parameterized, parameterize the MembersInjector.
     if (bindingName instanceof ParameterizedTypeName) {
@@ -261,10 +261,11 @@ static TypeName parameterizedMembersInjectorNameForMembersInjectionBinding(
     return factoryName;
   }
 
-  static ClassName membersInjectorNameForMembersInjectionBinding(MembersInjectionBinding binding) {
-    ClassName injectedClassName = ClassName.fromTypeElement(binding.bindingElement());
-    return injectedClassName.topLevelClassName().peerNamed(
-        injectedClassName.classFileName() + "_MembersInjector");
+  static ClassName membersInjectorNameForType(TypeElement typeElement) {
+    ClassName injectedClassName = ClassName.fromTypeElement(typeElement);
+    return injectedClassName
+        .topLevelClassName()
+        .peerNamed(injectedClassName.classFileName() + "_MembersInjector");
   }
 
   private static String factoryPrefix(ProvisionBinding binding) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
index 908ee8eea..3aab845aa 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
@@ -58,6 +58,8 @@ public SubcomponentWriter(
       BindingGraph subgraph) {
     super(
         parent.types,
+        parent.elements,
+        parent.keyFactory,
         parent.nullableValidationType,
         parent.name.nestedClassNamed(subcomponentSimpleName(subgraph)),
         subgraph);
diff --git a/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java b/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
index 7ea0cd1f4..7925bd222 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
@@ -149,59 +149,57 @@ public void parentClass_injectedMembersInSupertype() {
         "interface TestComponent {",
         "  Child child();",
         "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.DaggerTestComponent",
-        "package test;",
-        "",
-        "import dagger.MembersInjector;",
-        "import dagger.internal.MembersInjectors;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class DaggerTestComponent implements TestComponent {",
-        "  private MembersInjector<Parent> parentMembersInjector;",
-        "  private MembersInjector<Child> childMembersInjector;",
-        "  private Provider<Child> childProvider;",
-        "",
-        "  private DaggerTestComponent(Builder builder) {",
-        "    assert builder != null;",
-        "    initialize(builder);",
-        "  }",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static TestComponent create() {",
-        "    return builder().build();",
-        "  }",
-        "",
-        "  private void initialize(final Builder builder) {",
-        "    this.parentMembersInjector = Parent_MembersInjector.create(Dep_Factory.create());",
-        "    this.childMembersInjector = MembersInjectors.delegatingTo(parentMembersInjector);",
-        "    this.childProvider = Child_Factory.create(childMembersInjector);",
-        "  }",
-        "",
-        "  @Override",
-        "  public Child child() {",
-        "    return childProvider.get();",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public TestComponent build() {",
-        "      return new DaggerTestComponent(this);",
-        "    }",
-        "  }",
-        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import dagger.MembersInjector;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  private MembersInjector<Child> childMembersInjector;",
+            "  private Provider<Child> childProvider;",
+            "",
+            "  private DaggerTestComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return builder().build();",
+            "  }",
+            "",
+            "  private void initialize(final Builder builder) {",
+            "    this.childMembersInjector = Child_MembersInjector.create(Dep_Factory.create());",
+            "    this.childProvider = Child_Factory.create(childMembersInjector);",
+            "  }",
+            "",
+            "  @Override",
+            "  public Child child() {",
+            "    return childProvider.get();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {}",
+            "",
+            "    public TestComponent build() {",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "  }",
+            "}");
     assertAbout(javaSources())
         .that(ImmutableList.of(childFile, parentFile, depFile, componentFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and().generatesSources(generatedComponent);
+        .and()
+        .generatesSources(generatedComponent);
   }
 
   @Test public void fieldAndMethodGenerics() {
@@ -217,7 +215,8 @@ public void parentClass_injectedMembersInSupertype() {
         "",
         " @Inject void register(B b) {}",
         "}");
-    JavaFileObject expected = JavaFileObjects.forSourceLines("test.GenericClass_MembersInjector",
+    JavaFileObject expected = JavaFileObjects.forSourceLines(
+        "test.GenericClass_MembersInjector",
         "package test;",
         "",
         "import dagger.MembersInjector;",
@@ -240,21 +239,33 @@ public void parentClass_injectedMembersInSupertype() {
         "  @Override",
         "  public void injectMembers(GenericClass<A, B> instance) {",
         "    if (instance == null) {",
-        "      throw new NullPointerException(\"Cannot inject members into a null reference\")",
+        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
         "    }",
         "    instance.a = aProvider.get();",
-        "    instance.register(bProvider.get())",
+        "    instance.register(bProvider.get());",
         "  }",
         "",
         "  public static <A, B> MembersInjector<GenericClass<A, B>> create(",
         "      Provider<A> aProvider, Provider<B> bProvider) {",
         "    return new GenericClass_MembersInjector<A, B>(aProvider, bProvider);",
         "  }",
+        "",
+        "  public static <A, B> void injectA(GenericClass<A, B> instance, Provider<A> aProvider) {",
+        "    instance.a = aProvider.get();",
+        "  }",
+        "",
+        "  public static <A, B> void injectRegister(",
+        "      GenericClass<A, B> instance, Provider<B> bProvider) {",
+        "    instance.register(bProvider.get());",
+        "  }",
+        "",
         "}");
-    assertAbout(javaSource()).that(file)
+    assertAbout(javaSource())
+        .that(file)
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and().generatesSources(expected);
+        .and()
+        .generatesSources(expected);
   }
 
   @Test public void subclassedGenericMembersInjectors() {
@@ -297,7 +308,8 @@ public void parentClass_injectedMembersInSupertype() {
         "",
         "  @Inject Child() {}",
         "}");
-    JavaFileObject expected = JavaFileObjects.forSourceLines("test.GenericClass_MembersInjector",
+    JavaFileObject expected = JavaFileObjects.forSourceLines(
+        "test.Child_MembersInjector",
         "package test;",
         "",
         "import dagger.MembersInjector;",
@@ -307,41 +319,51 @@ public void parentClass_injectedMembersInSupertype() {
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
         "public final class Child_MembersInjector<T>",
         "    implements MembersInjector<Child<T>> {",
-        "  private final MembersInjector<Parent<T, A>> supertypeInjector;",
-        "  private final Provider<A> aProvider;",
-        "  private final Provider<T> tProvider;",
+        "  private final Provider<T> tAndXProvider;",
+        "  private final Provider<A> aAndYProvider;",
+        "  private final Provider<A2> a2Provider;",
         "",
         "  public Child_MembersInjector(",
-        "      MembersInjector<Parent<T, A>> supertypeInjector, ",
-        "      Provider<A> aProvider, Provider<T> tProvider) {",
-        "    assert supertypeInjector != null;",
-        "    this.supertypeInjector = supertypeInjector;",
-        "    assert aProvider != null;",
-        "    this.aProvider = aProvider;",
-        "    assert tProvider != null;",
-        "    this.tProvider = tProvider;",
+        "      Provider<T> tAndXProvider, Provider<A> aAndYProvider, Provider<A2> a2Provider) {",
+        "    assert tAndXProvider != null;",
+        "    this.tAndXProvider = tAndXProvider;",
+        "    assert aAndYProvider != null;",
+        "    this.aAndYProvider = aAndYProvider;",
+        "    assert a2Provider != null;",
+        "    this.a2Provider = a2Provider;",
         "  }",
         "",
         "  @Override",
         "  public void injectMembers(Child<T> instance) {",
         "    if (instance == null) {",
-        "      throw new NullPointerException(\"Cannot inject members into a null reference\")",
+        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
         "    }",
-        "    supertypeInjector.injectMembers(instance);",
-        "    instance.a = aProvider.get();",
-        "    instance.t = tProvider.get();",
+        "    ((test.Parent) instance).x = tAndXProvider.get();",
+        "    ((test.Parent) instance).y = aAndYProvider.get();",
+        "    ((test.Parent) instance).a2 = a2Provider.get();",
+        "    instance.a = aAndYProvider.get();",
+        "    instance.t = tAndXProvider.get();",
         "  }",
         "",
         "  public static <T> MembersInjector<Child<T>> create(",
-        "      MembersInjector<Parent<T, A>> supertypeInjector, ",
-        "      Provider<A> aProvider, Provider<T> tProvider) {",
-        "    return new Child_MembersInjector<T>(supertypeInjector, aProvider, tProvider);",
+        "      Provider<T> tAndXProvider, Provider<A> aAndYProvider, Provider<A2> a2Provider) {",
+        "    return new Child_MembersInjector<T>(tAndXProvider, aAndYProvider, a2Provider);",
+        "  }",
+        "",
+        "  public static <T> void injectA(Child<T> instance, Provider<A> aProvider) {",
+        "    instance.a = aProvider.get();",
+        "  }",
+        "",
+        "  public static <T> void injectT(Child<T> instance, Provider<T> tProvider) {",
+        "    instance.t = tProvider.get();",
         "  }",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(a, a2, parent, child))
+    assertAbout(javaSources())
+        .that(ImmutableList.of(a, a2, parent, child))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and().generatesSources(expected);
+        .and()
+        .generatesSources(expected);
   }
 
   @Test public void fieldInjection() {
@@ -357,7 +379,8 @@ public void parentClass_injectedMembersInSupertype() {
         "  @Inject Lazy<String> lazyString;",
         "  @Inject Provider<String> stringProvider;",
         "}");
-    JavaFileObject expected = JavaFileObjects.forSourceLines("test.FieldInjection_MembersInjector",
+    JavaFileObject expected = JavaFileObjects.forSourceLines(
+        "test.FieldInjection_MembersInjector",
         "package test;",
         "",
         "import dagger.MembersInjector;",
@@ -366,9 +389,8 @@ public void parentClass_injectedMembersInSupertype() {
         "import javax.inject.Provider;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class FieldInjection_MembersInjector ",
+        "public final class FieldInjection_MembersInjector",
         "    implements MembersInjector<FieldInjection> {",
-        "",
         "  private final Provider<String> stringProvider;",
         "",
         "  public FieldInjection_MembersInjector(Provider<String> stringProvider) {",
@@ -376,7 +398,8 @@ public void parentClass_injectedMembersInSupertype() {
         "    this.stringProvider = stringProvider;",
         "  }",
         "",
-        "  @Override public void injectMembers(FieldInjection instance) {",
+        "  @Override",
+        "  public void injectMembers(FieldInjection instance) {",
         "    if (instance == null) {",
         "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
         "    }",
@@ -385,14 +408,31 @@ public void parentClass_injectedMembersInSupertype() {
         "    instance.stringProvider = stringProvider;",
         "  }",
         "",
-        "  public static MembersInjector<FieldInjection> create(",
-        "      Provider<String> stringProvider) {",
+        "  public static MembersInjector<FieldInjection> create(Provider<String> stringProvider) {",
         "    return new FieldInjection_MembersInjector(stringProvider);",
         "  }",
+        "",
+        "  public static void injectString(",
+        "      FieldInjection instance, Provider<String> stringProvider) {",
+        "    instance.string = stringProvider.get();",
+        "  }",
+        "",
+        "  public static void injectLazyString(",
+        "      FieldInjection instance, Provider<String> lazyStringProvider) {",
+        "    instance.lazyString = DoubleCheckLazy.create(lazyStringProvider);",
+        "  }",
+        "",
+        "  public static void injectStringProvider(",
+        "      FieldInjection instance, Provider<String> stringProvider) {",
+        "    instance.stringProvider = stringProvider;",
+        "  }",
         "}");
-    assertAbout(javaSource()).that(file).processedWith(new ComponentProcessor())
+    assertAbout(javaSource())
+        .that(file)
+        .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and().generatesSources(expected);
+        .and()
+        .generatesSources(expected);
   }
 
   @Test public void methodInjection() {
@@ -419,8 +459,8 @@ public void parentClass_injectedMembersInSupertype() {
         "import javax.inject.Provider;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class MethodInjection_MembersInjector ",
-        "    implements MembersInjector<MethodInjection> {",
+        "public final class MethodInjection_MembersInjector",
+        "     implements MembersInjector<MethodInjection> {",
         "",
         "  private final Provider<String> stringProvider;",
         "",
@@ -429,7 +469,8 @@ public void parentClass_injectedMembersInSupertype() {
         "    this.stringProvider = stringProvider;",
         "  }",
         "",
-        "  @Override public void injectMembers(MethodInjection instance) {",
+        "  @Override",
+        "  public void injectMembers(MethodInjection instance) {",
         "    if (instance == null) {",
         "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
         "    }",
@@ -443,14 +484,39 @@ public void parentClass_injectedMembersInSupertype() {
         "      Provider<String> stringProvider) {",
         "    return new MethodInjection_MembersInjector(stringProvider);",
         "  }",
+        "",
+        "  public static void injectNoArgs(MethodInjection instance) {",
+        "    instance.noArgs();",
+        "  }",
+        "",
+        "  public static void injectOneArg(",
+        "      MethodInjection instance, Provider<String> stringProvider) {",
+        "    instance.oneArg(stringProvider.get());",
+        "  }",
+        "",
+        "  public static void injectManyArgs(",
+        "      MethodInjection instance,",
+        "      Provider<String> stringProvider,",
+        "      Provider<String> lazyStringProvider,",
+        "      Provider<String> stringProvider2) {",
+        "    instance.manyArgs(",
+        "        stringProvider.get(),",
+        "        DoubleCheckLazy.create(lazyStringProvider),",
+        "        stringProvider2);",
+        "  }",
         "}");
-    assertAbout(javaSource()).that(file).processedWith(new ComponentProcessor())
+    assertAbout(javaSource())
+        .that(file)
+        .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and().generatesSources(expected);
+        .and()
+        .generatesSources(expected);
   }
 
-  @Test public void mixedMemberInjection() {
-    JavaFileObject file = JavaFileObjects.forSourceLines("test.MixedMemberInjection",
+  @Test
+  public void mixedMemberInjection() {
+    JavaFileObject file = JavaFileObjects.forSourceLines(
+        "test.MixedMemberInjection",
         "package test;",
         "",
         "import dagger.Lazy;",
@@ -472,13 +538,14 @@ public void parentClass_injectedMembersInSupertype() {
         "import javax.inject.Provider;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class MixedMemberInjection_MembersInjector ",
+        "public final class MixedMemberInjection_MembersInjector",
         "    implements MembersInjector<MixedMemberInjection> {",
         "",
         "  private final Provider<String> stringAndSProvider;",
         "  private final Provider<Object> objectAndOProvider;",
         "",
-        "  public MixedMemberInjection_MembersInjector(Provider<String> stringAndSProvider,",
+        "  public MixedMemberInjection_MembersInjector(",
+        "      Provider<String> stringAndSProvider,",
         "      Provider<Object> objectAndOProvider) {",
         "    assert stringAndSProvider != null;",
         "    this.stringAndSProvider = stringAndSProvider;",
@@ -486,7 +553,8 @@ public void parentClass_injectedMembersInSupertype() {
         "    this.objectAndOProvider = objectAndOProvider;",
         "  }",
         "",
-        "  @Override public void injectMembers(MixedMemberInjection instance) {",
+        "  @Override",
+        "  public void injectMembers(MixedMemberInjection instance) {",
         "    if (instance == null) {",
         "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
         "    }",
@@ -502,10 +570,32 @@ public void parentClass_injectedMembersInSupertype() {
         "    return new MixedMemberInjection_MembersInjector(",
         "        stringAndSProvider, objectAndOProvider);",
         "  }",
+        "  public static void injectString(",
+        "      MixedMemberInjection instance, Provider<String> stringProvider) {",
+        "    instance.string = stringProvider.get();",
+        "  }",
+        "",
+        "  public static void injectObject(",
+        "      MixedMemberInjection instance, Provider<Object> objectProvider) {",
+        "    instance.object = objectProvider.get();",
+        "  }",
+        "",
+        "  public static void injectSetString(",
+        "      MixedMemberInjection instance, Provider<String> sProvider) {",
+        "    instance.setString(sProvider.get());",
+        "  }",
+        "",
+        "  public static void injectSetObject(",
+        "      MixedMemberInjection instance, Provider<Object> oProvider) {",
+        "    instance.setObject(oProvider.get());",
+        "  }",
         "}");
-    assertAbout(javaSource()).that(file).processedWith(new ComponentProcessor())
+    assertAbout(javaSource())
+        .that(file)
+        .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and().generatesSources(expected);
+        .and()
+        .generatesSources(expected);
   }
 
   @Test public void injectConstructorAndMembersInjection() {
@@ -538,7 +628,8 @@ public void parentClass_injectedMembersInSupertype() {
         "    this.sProvider = sProvider;",
         "  }",
         "",
-        "  @Override public void injectMembers(AllInjections instance) {",
+        "  @Override",
+        "  public void injectMembers(AllInjections instance) {",
         "    if (instance == null) {",
         "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
         "    }",
@@ -547,10 +638,16 @@ public void parentClass_injectedMembersInSupertype() {
         "  }",
         "",
         "  public static MembersInjector<AllInjections> create(Provider<String> sProvider) {",
-        "    return new AllInjections_MembersInjector(sProvider);",
+        "      return new AllInjections_MembersInjector(sProvider);",
+        "  }",
+        "",
+        "  public static void injectS(AllInjections instance, Provider<String> sProvider) {",
+        "    instance.s = sProvider.get();",
         "  }",
         "}");
-    assertAbout(javaSource()).that(file).processedWith(new ComponentProcessor())
+    assertAbout(javaSource())
+        .that(file)
+        .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and()
         .generatesSources(expectedMembersInjector);
@@ -578,94 +675,99 @@ public void parentClass_injectedMembersInSupertype() {
         "import javax.inject.Provider;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class B_MembersInjector ",
-        "    implements MembersInjector<B> {",
-        "",
-        "  private final MembersInjector<A> supertypeInjector;",
+        "public final class B_MembersInjector implements MembersInjector<B> {",
         "  private final Provider<String> sProvider;",
         "",
-        "  public B_MembersInjector(MembersInjector<A> supertypeInjector,",
-        "      Provider<String> sProvider) {",
-        "    assert supertypeInjector != null;",
-        "    this.supertypeInjector = supertypeInjector;",
+        "  public B_MembersInjector(Provider<String> sProvider) {",
         "    assert sProvider != null;",
         "    this.sProvider = sProvider;",
         "  }",
         "",
-        "  @Override public void injectMembers(B instance) {",
+        "  @Override",
+        "  public void injectMembers(B instance) {",
         "    if (instance == null) {",
         "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
         "    }",
-        "    supertypeInjector.injectMembers(instance);",
         "    instance.s = sProvider.get();",
         "  }",
         "",
-        "  public static MembersInjector<B> create(",
-        "      MembersInjector<A> supertypeInjector,",
-        "      Provider<String> sProvider) {",
-        "    return new B_MembersInjector(supertypeInjector, sProvider);",
+        "  public static MembersInjector<B> create(Provider<String> sProvider) {",
+        "      return new B_MembersInjector(sProvider);",
+        "  }",
+        "  public static void injectS(B instance, Provider<String> sProvider) {",
+        "    instance.s = sProvider.get();",
         "  }",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(aFile, bFile))
+    assertAbout(javaSources())
+        .that(ImmutableList.of(aFile, bFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and().generatesSources(expectedMembersInjector);
+        .and()
+        .generatesSources(expectedMembersInjector);
   }
 
-  @Test public void simpleComponentWithNesting() {
-    JavaFileObject nestedTypesFile = JavaFileObjects.forSourceLines("test.OuterType",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Inject;",
-        "",
-        "final class OuterType {",
-        "  static class A {",
-        "    @Inject A() {}",
-        "  }",
-        "  static class B {",
-        "    @Inject A a;",
-        "  }",
-        "  @Component interface SimpleComponent {",
-        "    A a();",
-        "    void inject(B b);",
-        "  }",
-        "}");
+  @Test
+  public void simpleComponentWithNesting() {
+    JavaFileObject nestedTypesFile = JavaFileObjects.forSourceLines(
+          "test.OuterType",
+          "package test;",
+          "",
+          "import dagger.Component;",
+          "import javax.inject.Inject;",
+          "",
+          "final class OuterType {",
+          "  static class A {",
+          "    @Inject A() {}",
+          "  }",
+          "  static class B {",
+          "    @Inject A a;",
+          "  }",
+          "  @Component interface SimpleComponent {",
+          "    A a();",
+          "    void inject(B b);",
+          "  }",
+          "}");
     JavaFileObject bMembersInjector = JavaFileObjects.forSourceLines(
-        "test.OuterType$B_MembersInjector",
-        "package test;",
-        "",
-        "import dagger.MembersInjector;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "import test.OuterType.A;",
-        "import test.OuterType.B;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class OuterType$B_MembersInjector implements MembersInjector<B> {",
-        "  private final Provider<A> aProvider;",
-        "",
-        "  public OuterType$B_MembersInjector(Provider<A> aProvider) {",
-        "    assert aProvider != null;",
-        "    this.aProvider = aProvider;",
-        "  }",
-         "",
-        "  @Override",
-        "  public void injectMembers(B instance) {",
-        "    if (instance == null) {",
-        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
-        "    }",
-        "    instance.a = aProvider.get();",
-        "  }",
-        "",
-        "  public static MembersInjector<B> create(Provider<A> aProvider) {",
-        "    return new OuterType$B_MembersInjector(aProvider);",
-        "  }",
-        "}");
-    assertAbout(javaSources()).that(ImmutableList.of(nestedTypesFile))
+          "test.OuterType$B_MembersInjector",
+          "package test;",
+          "",
+          "import dagger.MembersInjector;",
+          "import javax.annotation.Generated;",
+          "import javax.inject.Provider;",
+          "import test.OuterType.A;",
+          "import test.OuterType.B;",
+          "",
+          "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+          "public final class OuterType$B_MembersInjector implements MembersInjector<B> {",
+          "  private final Provider<A> aProvider;",
+          "",
+          "  public OuterType$B_MembersInjector(Provider<A> aProvider) {",
+          "    assert aProvider != null;",
+          "    this.aProvider = aProvider;",
+          "  }",
+          "",
+          "  @Override",
+          "  public void injectMembers(B instance) {",
+          "    if (instance == null) {",
+          "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
+          "    }",
+          "    instance.a = aProvider.get();",
+          "  }",
+          "",
+          "  public static MembersInjector<B> create(Provider<A> aProvider) {",
+          "    return new OuterType$B_MembersInjector(aProvider);",
+          "  }",
+          "",
+          "  public static void injectA(B instance, Provider<A> aProvider) {",
+          "    instance.a = aProvider.get();",
+          "  }",
+          "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(nestedTypesFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and().generatesSources(bMembersInjector);
+        .and()
+        .generatesSources(bMembersInjector);
   }
 
   @Test
@@ -722,6 +824,10 @@ public void componentWithNestingAndGeneratedType() {
             "  public static MembersInjector<B> create(Provider<A> aProvider) {",
             "    return new OuterType$B_MembersInjector(aProvider);",
             "  }",
+            "",
+            "  public static void injectA(B instance, Provider<A> aProvider) {",
+            "    instance.a = aProvider.get();",
+            "  }",
             "}");
     assertAbout(javaSource())
         .that(nestedTypesFile)
diff --git a/compiler/src/test/java/dagger/internal/codegen/PackageProxyTest.java b/compiler/src/test/java/dagger/internal/codegen/PackageProxyTest.java
index 40ceb7ede..8df80d19b 100644
--- a/compiler/src/test/java/dagger/internal/codegen/PackageProxyTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/PackageProxyTest.java
@@ -184,62 +184,49 @@
         "interface TestComponent {",
         "  void injectA(A a);",
         "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.DaggerTestComponent",
-        "package test;",
-        "",
-        "import dagger.MembersInjector;",
-        "import foreign.B;",
-        "import foreign.B_MembersInjector;",
-        "import foreign.C_MembersInjector;",
-        "import foreign.DaggerTestComponent_PackageProxy;",
-        "import javax.annotation.Generated;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class DaggerTestComponent implements TestComponent {",
-        "  private MembersInjector<D> dMembersInjector;",
-        "  private final DaggerTestComponent_PackageProxy foreign_Proxy =",
-        "      new DaggerTestComponent_PackageProxy();",
-        "  private MembersInjector<B> bMembersInjector;",
-        "  private MembersInjector<A> aMembersInjector;",
-        "",
-        "  private DaggerTestComponent(Builder builder) {",
-        "    assert builder != null;",
-        "    initialize(builder);",
-        "  }",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static TestComponent create() {",
-        "    return builder().build();",
-        "  }",
-        "",
-        "  private void initialize(final Builder builder) {",
-        "    this.dMembersInjector = D_MembersInjector.create(NoDepClass_Factory.create());",
-        "    this.foreign_Proxy.cMembersInjector =",
-        "        C_MembersInjector.create(dMembersInjector, NoDepClass_Factory.create());",
-        "    this.bMembersInjector = B_MembersInjector.create(",
-        "        foreign_Proxy.cMembersInjector, NoDepClass_Factory.create());",
-        "    this.aMembersInjector = A_MembersInjector.create(",
-        "        bMembersInjector, NoDepClass_Factory.create());",
-        "  }",
-        "",
-        "  @Override",
-        "  public void injectA(A a) {",
-        "    aMembersInjector.injectMembers(a);",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public TestComponent build() {",
-        "      return new DaggerTestComponent(this);",
-        "    }",
-        "  }",
-        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import dagger.MembersInjector;",
+            "import javax.annotation.Generated;",
+            "",
+            "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  private MembersInjector<A> aMembersInjector;",
+            "",
+            "  private DaggerTestComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return builder().build();",
+            "  }",
+            "",
+            "  private void initialize(final Builder builder) {",
+            "     this.aMembersInjector = A_MembersInjector.create(NoDepClass_Factory.create());",
+            "  }",
+            "",
+            "  @Override",
+            "  public void injectA(A a) {",
+            "    aMembersInjector.injectMembers(a);",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public TestComponent build() {",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "  }",
+            "}");
     assert_().about(javaSources())
         .that(ImmutableList.of(
             noDepClassFile,
