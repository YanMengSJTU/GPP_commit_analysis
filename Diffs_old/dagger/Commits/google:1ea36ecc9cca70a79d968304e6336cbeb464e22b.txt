diff --git a/java/dagger/internal/codegen/ModuleKind.java b/java/dagger/internal/codegen/ModuleKind.java
index 91839d6de..ae169e3a1 100644
--- a/java/dagger/internal/codegen/ModuleKind.java
+++ b/java/dagger/internal/codegen/ModuleKind.java
@@ -99,13 +99,6 @@ AnnotationMirror getModuleAnnotation(TypeElement element) {
     return moduleAnnotation;
   }
 
-  /** Returns the annotation for binding methods on this type of module. */
-  // TODO(cgdecker): Validate how this is used... is it really correct? Producer modules can also
-  // have @Provides methods.
-  Class<? extends Annotation> methodAnnotation() {
-    return methodAnnotation;
-  }
-
   /** Returns the kinds of modules that a module of this kind is allowed to include. */
   ImmutableSet<ModuleKind> legalIncludedModuleKinds() {
     switch (this) {
diff --git a/java/dagger/internal/codegen/ModuleValidator.java b/java/dagger/internal/codegen/ModuleValidator.java
index 9f94bce3d..19609f1ca 100644
--- a/java/dagger/internal/codegen/ModuleValidator.java
+++ b/java/dagger/internal/codegen/ModuleValidator.java
@@ -17,7 +17,6 @@
 package dagger.internal.codegen;
 
 import static com.google.auto.common.AnnotationMirrors.getAnnotatedAnnotations;
-import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.auto.common.Visibility.PRIVATE;
 import static com.google.auto.common.Visibility.PUBLIC;
 import static com.google.auto.common.Visibility.effectiveVisibilityOfElement;
@@ -47,11 +46,9 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ListMultimap;
 import com.google.common.collect.Sets;
-import dagger.Binds;
 import dagger.Module;
 import dagger.Subcomponent;
 import dagger.model.BindingGraph;
-import dagger.multibindings.Multibinds;
 import dagger.producers.ProducerModule;
 import dagger.producers.ProductionSubcomponent;
 import java.lang.annotation.Annotation;
@@ -75,7 +72,6 @@
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.SimpleAnnotationValueVisitor8;
 import javax.lang.model.util.SimpleTypeVisitor8;
 
@@ -186,10 +182,6 @@ void addKnownModules(Collection<TypeElement> modules) {
     for (ExecutableElement moduleMethod : methodsIn(module.getEnclosedElements())) {
       if (anyBindingMethodValidator.isBindingMethod(moduleMethod)) {
         builder.addSubreport(anyBindingMethodValidator.validate(moduleMethod));
-      }
-      if (isAnyAnnotationPresent(
-          moduleMethod,
-          ImmutableSet.of(moduleKind.methodAnnotation(), Binds.class, Multibinds.class))) {
         bindingMethodsByName.put(moduleMethod.getSimpleName().toString(), moduleMethod);
         methodKinds.add(ModuleMethodKind.ofMethod(moduleMethod));
       }
@@ -215,17 +207,14 @@ void addKnownModules(Collection<TypeElement> modules) {
         EnumSet.of(ModuleMethodKind.ABSTRACT_DECLARATION, ModuleMethodKind.INSTANCE_BINDING))) {
       builder.addError(
           String.format(
-              "A @%s may not contain both non-static @%s methods and "
-                  + "abstract @Binds or @Multibinds declarations",
-              moduleKind.annotation().getSimpleName(),
-              moduleKind.methodAnnotation().getSimpleName()));
+              "A @%s may not contain both non-static and abstract binding methods",
+              moduleKind.annotation().getSimpleName()));
     }
 
     validateModuleVisibility(module, moduleKind, builder);
-    validateMethodsWithSameName(moduleKind, builder, bindingMethodsByName);
+    validateMethodsWithSameName(builder, bindingMethodsByName);
     if (module.getKind() != ElementKind.INTERFACE) {
-      validateProvidesOverrides(
-          module, moduleKind, builder, allMethodsByName, bindingMethodsByName);
+      validateBindingMethodOverrides(module, builder, allMethodsByName, bindingMethodsByName);
     }
     validateModifiers(module, builder);
     validateReferencedModules(module, moduleKind, visitedModules, builder);
@@ -357,7 +346,6 @@ private void validateModifiers(
   }
 
   private void validateMethodsWithSameName(
-      ModuleKind moduleKind,
       ValidationReport.Builder<TypeElement> builder,
       ListMultimap<String, ExecutableElement> bindingMethodsByName) {
     for (Entry<String, Collection<ExecutableElement>> entry :
@@ -366,8 +354,7 @@ private void validateMethodsWithSameName(
         for (ExecutableElement offendingMethod : entry.getValue()) {
           builder.addError(
               String.format(
-                  "Cannot have more than one @%s method with the same name in a single module",
-                  moduleKind.methodAnnotation().getSimpleName()),
+                  "Cannot have more than one binding method with the same name in a single module"),
               offendingMethod);
         }
       }
@@ -454,13 +441,12 @@ private void reportError(String format, Object... args) {
     return subreport.build();
   }
 
-  private void validateProvidesOverrides(
+  private void validateBindingMethodOverrides(
       TypeElement subject,
-      ModuleKind moduleKind,
       ValidationReport.Builder<TypeElement> builder,
       ListMultimap<String, ExecutableElement> allMethodsByName,
       ListMultimap<String, ExecutableElement> bindingMethodsByName) {
-    // For every @Provides method, confirm it overrides nothing *and* nothing overrides it.
+    // For every binding method, confirm it overrides nothing *and* nothing overrides it.
     // Consider the following hierarchy:
     // class Parent {
     //    @Provides Foo a() {}
@@ -473,41 +459,36 @@ private void validateProvidesOverrides(
     //    @Provides Foo c() {}
     // }
     // In each of those cases, we want to fail.  "a" is clear, "b" because Child is overriding
-    // a method marked @Provides in Parent, and "c" because Child is defining an @Provides
-    // method that overrides Parent.
+    // a binding method in Parent, and "c" because Child is defining a binding method that overrides
+    // Parent.
     TypeElement currentClass = subject;
     TypeMirror objectType = elements.getTypeElement(Object.class).asType();
     // We keep track of methods that failed so we don't spam with multiple failures.
     Set<ExecutableElement> failedMethods = Sets.newHashSet();
     while (!types.isSameType(currentClass.getSuperclass(), objectType)) {
       currentClass = MoreElements.asType(types.asElement(currentClass.getSuperclass()));
-      List<ExecutableElement> superclassMethods =
-          ElementFilter.methodsIn(currentClass.getEnclosedElements());
+      List<ExecutableElement> superclassMethods = methodsIn(currentClass.getEnclosedElements());
       for (ExecutableElement superclassMethod : superclassMethods) {
         String name = superclassMethod.getSimpleName().toString();
-        // For each method in the superclass, confirm our @Provides methods don't override it
-        for (ExecutableElement providesMethod : bindingMethodsByName.get(name)) {
-          if (!failedMethods.contains(providesMethod)
-              && elements.overrides(providesMethod, superclassMethod, subject)) {
-            failedMethods.add(providesMethod);
+        // For each method in the superclass, confirm our binding methods don't override it
+        for (ExecutableElement bindingMethod : bindingMethodsByName.get(name)) {
+          if (failedMethods.add(bindingMethod)
+              && elements.overrides(bindingMethod, superclassMethod, subject)) {
             builder.addError(
                 String.format(
-                    "@%s methods may not override another method. Overrides: %s",
-                    moduleKind.methodAnnotation().getSimpleName(),
+                    "Binding methods may not override another method. Overrides: %s",
                     methodSignatureFormatter.format(superclassMethod)),
-                providesMethod);
+                bindingMethod);
           }
         }
-        // For each @Provides method in superclass, confirm our methods don't override it.
-        if (isAnnotationPresent(superclassMethod, moduleKind.methodAnnotation())) {
+        // For each binding method in superclass, confirm our methods don't override it.
+        if (anyBindingMethodValidator.isBindingMethod(superclassMethod)) {
           for (ExecutableElement method : allMethodsByName.get(name)) {
-            if (!failedMethods.contains(method)
+            if (failedMethods.add(method)
                 && elements.overrides(method, superclassMethod, subject)) {
-              failedMethods.add(method);
               builder.addError(
                   String.format(
-                      "@%s methods may not be overridden in modules. Overrides: %s",
-                      moduleKind.methodAnnotation().getSimpleName(),
+                      "Binding methods may not be overridden in modules. Overrides: %s",
                       methodSignatureFormatter.format(superclassMethod)),
                   method);
             }
@@ -541,7 +522,7 @@ private void validateModuleVisibility(
         if (moduleVisibility.equals(PUBLIC)) {
           ImmutableSet<Element> nonPublicModules =
               moduleAnnotation.includes().stream()
-                  .filter(element -> effectiveVisibilityOfElement(element).compareTo(PUBLIC) < 0)
+                  .filter(element -> !effectiveVisibilityOfElement(element).equals(PUBLIC))
                   .collect(toImmutableSet());
           if (!nonPublicModules.isEmpty()) {
             reportBuilder.addError(
diff --git a/javatests/dagger/internal/codegen/ModuleFactoryGeneratorTest.java b/javatests/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
index f8b726e75..ac8285c6e 100644
--- a/javatests/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
+++ b/javatests/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
@@ -162,9 +162,8 @@ public void providesMethodReturnsProduced() {
         .withDeclaration("@Module class %s extends Parent { %s }")
         .withAdditionalSources(parent)
         .hasError(
-            String.format(
-                "@%s methods may not be overridden in modules. Overrides: %s",
-                "Provides", "@Provides String test.Parent.foo()"));
+            "Binding methods may not be overridden in modules. Overrides: "
+                + "@Provides String test.Parent.foo()");
   }
 
   @Test public void provideOverriddenByProvide() {
@@ -182,9 +181,8 @@ public void providesMethodReturnsProduced() {
         .withDeclaration("@Module class %s extends Parent { %s }")
         .withAdditionalSources(parent)
         .hasError(
-            String.format(
-                "@%s methods may not override another method. Overrides: %s",
-                "Provides", "@Provides String test.Parent.foo()"));
+            "Binding methods may not override another method. Overrides: "
+                + "@Provides String test.Parent.foo()");
   }
 
   @Test public void providesOverridesNonProvides() {
@@ -201,9 +199,8 @@ public void providesMethodReturnsProduced() {
         .withDeclaration("@Module class %s extends Parent { %s }")
         .withAdditionalSources(parent)
         .hasError(
-            String.format(
-                "@%s methods may not override another method. Overrides: %s",
-                "Provides", "String test.Parent.foo()"));
+            "Binding methods may not override another method. Overrides: "
+                + "String test.Parent.foo()");
   }
 
   @Test public void validatesIncludedModules() {
@@ -638,14 +635,12 @@ public void providesMethodReturnsProduced() {
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
-            formatErrorMessage(
-                "Cannot have more than one @%s method with the same name in a single module"))
+            "Cannot have more than one binding method with the same name in a single module")
         .inFile(moduleFile)
         .onLine(8);
     assertThat(compilation)
         .hadErrorContaining(
-            formatErrorMessage(
-                "Cannot have more than one @%s method with the same name in a single module"))
+            "Cannot have more than one binding method with the same name in a single module")
         .inFile(moduleFile)
         .onLine(12);
   }
@@ -1469,8 +1464,7 @@ public void bindsWithInstanceProvides() {
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
-            "A @Module may not contain both non-static @Provides methods and "
-                + "abstract @Binds or @Multibinds declarations");
+            "A @Module may not contain both non-static and abstract binding methods");
   }
 
   @Test
@@ -1479,8 +1473,7 @@ public void multibindsWithInstanceProvides() {
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
-            "A @Module may not contain both non-static @Provides methods and "
-                + "abstract @Binds or @Multibinds declarations");
+            "A @Module may not contain both non-static and abstract binding methods");
   }
 
   @Test
diff --git a/javatests/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java b/javatests/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
index df4da839a..40f7c03c1 100644
--- a/javatests/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
+++ b/javatests/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
@@ -187,7 +187,7 @@ public void producesProduced() {
         "  }",
         "}");
     String errorMessage =
-        "Cannot have more than one @Produces method with the same name in a single module";
+        "Cannot have more than one binding method with the same name in a single module";
     Compilation compilation = daggerCompiler().compile(moduleFile);
     assertThat(compilation).failed();
     assertThat(compilation).hadErrorContaining(errorMessage).inFile(moduleFile).onLine(8);
