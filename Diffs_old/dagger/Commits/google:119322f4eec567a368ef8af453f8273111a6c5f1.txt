diff --git a/compiler/src/main/java/dagger/internal/codegen/AnnotationMirrors.java b/compiler/src/main/java/dagger/internal/codegen/AnnotationMirrors.java
index e87afb0e1..64889e2fe 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AnnotationMirrors.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AnnotationMirrors.java
@@ -15,6 +15,7 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.Equivalence;
 import com.google.common.base.Predicate;
@@ -60,12 +61,12 @@
     return builder.build();
   }
 
-  static ImmutableList<TypeMirror> getAttributeAsListOfTypes(Elements elements,
-      AnnotationMirror annotationMirror, String attributeName) {
+  static ImmutableList<TypeMirror> getAttributeAsListOfTypes(AnnotationMirror annotationMirror,
+      String attributeName) {
     checkNotNull(annotationMirror);
     checkNotNull(attributeName);
     ImmutableMap<String, AnnotationValue> valueMap =
-        simplifyAnnotationValueMap(elements.getElementValuesWithDefaults(annotationMirror));
+        simplifyAnnotationValueMap(getAnnotationValuesWithDefaults(annotationMirror));
     ImmutableList.Builder<TypeMirror> builder = ImmutableList.builder();
 
     @SuppressWarnings("unchecked") // that's the whole point of this method
@@ -120,11 +121,22 @@ protected int doHash(AnnotationMirror annotation) {
   static Map<ExecutableElement, AnnotationValue> getAnnotationValuesWithDefaults(
       AnnotationMirror annotation) {
     Map<ExecutableElement, AnnotationValue> values = Maps.newLinkedHashMap();
+    Map<? extends ExecutableElement, ? extends AnnotationValue> declaredValues =
+        annotation.getElementValues();
     for (ExecutableElement method :
         ElementFilter.methodsIn(annotation.getAnnotationType().asElement().getEnclosedElements())) {
-      values.put(method, method.getDefaultValue());
+      // Must iterate and put in this order, to ensure consistency in generated code.
+      if (declaredValues.containsKey(method)) {
+        values.put(method, declaredValues.get(method));
+      } else if (method.getDefaultValue() != null) {
+        values.put(method, method.getDefaultValue());
+      } else {
+        throw new IllegalStateException(
+            "Unset annotation value without default should never happen: "
+            + MoreElements.asType(method.getEnclosingElement()).getQualifiedName()
+            + '.' + method.getSimpleName() + "()");
+      }
     }
-    values.putAll(annotation.getElementValues());
     return values;
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/Binding.java b/compiler/src/main/java/dagger/internal/codegen/Binding.java
index 1a88f1c2c..88ed8b6e2 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Binding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Binding.java
@@ -18,9 +18,20 @@
 import com.google.auto.common.MoreElements;
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableSet;
+import java.util.Set;
 import javax.lang.model.element.Element;
+import javax.lang.model.element.Name;
+import javax.lang.model.element.PackageElement;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.ArrayType;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.type.TypeVariable;
+import javax.lang.model.type.WildcardType;
 import javax.lang.model.util.SimpleElementVisitor6;
+import javax.lang.model.util.SimpleTypeVisitor6;
+
+import static javax.lang.model.element.Modifier.PUBLIC;
 
 /**
  * An abstract type for classes representing a Dagger binding.  Particularly, contains the
@@ -72,4 +83,53 @@ public TypeElement visitType(TypeElement e, Void p) {
    */
   abstract Optional<String> bindingPackage();
 
+  protected static Optional<String> findBindingPackage(Key bindingKey) {
+    Set<String> packages = nonPublicPackageUse(bindingKey.type());
+    switch (packages.size()) {
+      case 0:
+        return Optional.absent();
+      case 1:
+        return Optional.of(packages.iterator().next());
+      default:
+        throw new IllegalStateException();
+    }
+  }
+
+  private static Set<String> nonPublicPackageUse(TypeMirror typeMirror) {
+    ImmutableSet.Builder<String> packages = ImmutableSet.builder();
+    typeMirror.accept(new SimpleTypeVisitor6<Void, ImmutableSet.Builder<String>>() {
+      @Override
+      public Void visitArray(ArrayType t, ImmutableSet.Builder<String> p) {
+        return t.getComponentType().accept(this, p);
+      }
+
+      @Override
+      public Void visitDeclared(DeclaredType t, ImmutableSet.Builder<String> p) {
+        for (TypeMirror typeArgument : t.getTypeArguments()) {
+          typeArgument.accept(this, p);
+        }
+        // TODO(gak): address public nested types in non-public types
+        TypeElement typeElement = MoreElements.asType(t.asElement());
+        if (!typeElement.getModifiers().contains(PUBLIC)) {
+          PackageElement elementPackage = MoreElements.getPackage(typeElement);
+          Name qualifiedName = elementPackage.getQualifiedName();
+          p.add(qualifiedName.toString());
+        }
+        return null;
+      }
+
+      @Override
+      public Void visitWildcard(WildcardType t, ImmutableSet.Builder<String> p) {
+        if (t.getExtendsBound() != null) {
+          t.getExtendsBound().accept(this, p);
+        }
+        if (t.getSuperBound() != null) {
+          t.getSuperBound().accept(this, p);
+        }
+        return null;
+      }
+    }, packages);
+    return packages.build();
+  }
+
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index 39d2e3a98..9ec404d94 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -15,8 +15,6 @@
  */
 package dagger.internal.codegen;
 
-import static dagger.internal.codegen.ComponentDescriptor.isComponentProvisionMethod;
-
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Function;
@@ -35,6 +33,7 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
@@ -46,6 +45,8 @@
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.ComponentDescriptor.isComponentProvisionMethod;
+import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
 import static dagger.internal.codegen.ConfigurationAnnotations.getTransitiveModules;
 import static javax.lang.model.type.TypeKind.VOID;
@@ -103,6 +104,7 @@
 
     BindingGraph create(ComponentDescriptor componentDescriptor) {
       ImmutableSet.Builder<ProvisionBinding> explicitBindingsBuilder = ImmutableSet.builder();
+      AnnotationMirror componentAnnotation = componentDescriptor.componentAnnotation();
 
       // binding for the component itself
       ProvisionBinding componentBinding =
@@ -110,9 +112,8 @@ BindingGraph create(ComponentDescriptor componentDescriptor) {
       explicitBindingsBuilder.add(componentBinding);
 
       // Collect Component dependencies.
-      ImmutableSet<TypeElement> componentDependencyTypes = MoreTypes.asTypeElements(types,
-          ConfigurationAnnotations.getComponentDependencies(
-              elements, componentDescriptor.componentAnnotation()));
+      ImmutableSet<TypeElement> componentDependencyTypes =
+          MoreTypes.asTypeElements(types, getComponentDependencies(componentAnnotation));
       for (TypeElement componentDependency : componentDependencyTypes) {
         explicitBindingsBuilder.add(provisionBindingFactory.forComponent(componentDependency));
         List<ExecutableElement> dependencyMethods =
@@ -127,11 +128,10 @@ BindingGraph create(ComponentDescriptor componentDescriptor) {
 
       // Collect transitive modules provisions.
       ImmutableSet<TypeElement> moduleTypes =
-          MoreTypes.asTypeElements(types,
-              getComponentModules(elements, componentDescriptor.componentAnnotation()));
+          MoreTypes.asTypeElements(types, getComponentModules(componentAnnotation));
 
       ImmutableMap<TypeElement, ImmutableSet<TypeElement>> transitiveModules =
-          getTransitiveModules(elements, types, moduleTypes);
+          getTransitiveModules(types, moduleTypes);
       for (TypeElement module : transitiveModules.keySet()) {
         // traverse the modules, collect the bindings
         List<ExecutableElement> moduleMethods = methodsIn(elements.getAllMembers(module));
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index e1f8ae142..ddddf9cf0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -32,6 +32,7 @@
 import javax.lang.model.util.Types;
 
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
+import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
 import static dagger.internal.codegen.InjectionAnnotations.getScopeAnnotation;
 import static dagger.internal.codegen.Util.unwrapOptionalEquivalence;
 import static dagger.internal.codegen.Util.wrapOptionalInEquivalence;
@@ -95,8 +96,8 @@
     ComponentDescriptor create(TypeElement componentDefinitionType) {
       AnnotationMirror componentMirror =
           getAnnotationMirror(componentDefinitionType, Component.class).get();
-      ImmutableSet<TypeElement> componentDependencyTypes = MoreTypes.asTypeElements(types,
-          ConfigurationAnnotations.getComponentDependencies(elements, componentMirror));
+      ImmutableSet<TypeElement> componentDependencyTypes =
+          MoreTypes.asTypeElements(types, getComponentDependencies(componentMirror));
 
       ProvisionBinding componentBinding =
           provisionBindingFactory.forComponent(componentDefinitionType);
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index 69a4a0521..c3e874175 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -17,6 +17,7 @@
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
+import com.google.auto.value.AutoValue;
 import com.google.common.base.CaseFormat;
 import com.google.common.base.Function;
 import com.google.common.base.Functions;
@@ -127,6 +128,16 @@ ClassName nameGeneratedType(BindingGraph input) {
     return Optional.of(input.componentDescriptor().componentDefinitionType());
   }
 
+  @AutoValue
+  static abstract class ProxyClassAndField {
+    abstract ClassWriter proxyWriter();
+    abstract FieldWriter proxyFieldWriter();
+
+    static ProxyClassAndField create(ClassWriter proxyWriter, FieldWriter proxyFieldWriter) {
+      return new AutoValue_ComponentGenerator_ProxyClassAndField(proxyWriter, proxyFieldWriter);
+    }
+  }
+
   @Override
   ImmutableSet<JavaWriter> write(ClassName componentName, BindingGraph input) {
     ClassName componentDefinitionTypeName =
@@ -216,7 +227,7 @@ ClassName nameGeneratedType(BindingGraph input) {
         ImmutableMap.builder();
 
     ImmutableSet.Builder<JavaWriter> proxyWriters = ImmutableSet.builder();
-    Map<String, ClassWriter> packageProxies = Maps.newHashMap();
+    Map<String, ProxyClassAndField> packageProxies = Maps.newHashMap();
 
     for (Entry<Key, ResolvedBindings> resolvedBindingsEntry : input.resolvedBindings().entrySet()) {
       Key key = resolvedBindingsEntry.getKey();
@@ -267,24 +278,28 @@ ClassName nameGeneratedType(BindingGraph input) {
         fieldModifiers = EnumSet.of(PRIVATE);
       } else {
         // get or create the proxy
-        ClassWriter proxyClassWriter = packageProxies.get(bindingPackage);
-        if (proxyClassWriter == null) {
-          JavaWriter proxyWriter = JavaWriter.inPackage(bindingPackage);
-          proxyWriters.add(proxyWriter);
-          proxyClassWriter = proxyWriter.addClass(componentName.simpleName() + "__PackageProxy");
-          packageProxies.put(bindingPackage, proxyClassWriter);
+        ProxyClassAndField proxyClassAndField = packageProxies.get(bindingPackage);
+        if (proxyClassAndField == null) {
+          JavaWriter proxyJavaWriter = JavaWriter.inPackage(bindingPackage);
+          proxyWriters.add(proxyJavaWriter);
+          ClassWriter proxyWriter =
+              proxyJavaWriter.addClass(componentName.simpleName() + "__PackageProxy");
+          proxyWriter.annotate(Generated.class)
+              .setValue(ComponentProcessor.class.getCanonicalName());
+          proxyWriter.addModifiers(PUBLIC, FINAL);
+          // create the field for the proxy in the component
+          FieldWriter proxyFieldWriter =
+              componentWriter.addField(proxyWriter.name(), bindingPackage.replace('.', '_')
+                  + "_Proxy");
+          proxyFieldWriter.addModifiers(PRIVATE, FINAL);
+          proxyFieldWriter.setInitializer("new %s()", proxyWriter.name());
+          proxyClassAndField = ProxyClassAndField.create(proxyWriter, proxyFieldWriter);
+          packageProxies.put(bindingPackage, proxyClassAndField);
         }
-        proxyClassWriter.addModifiers(PUBLIC, FINAL);
-        // create the field for the proxy in the component
-        FieldWriter proxyField =
-            componentWriter.addField(proxyClassWriter.name(), bindingPackage.replace('.', '_')
-                + "_Proxy");
-        proxyField.addModifiers(PRIVATE, FINAL);
-        proxyField.setInitializer("new %s()", proxyClassWriter.name());
         // add the field for the member select
-        proxySelector = Optional.of(proxyField.name());
+        proxySelector = Optional.of(proxyClassAndField.proxyFieldWriter().name());
         // proxy gets the fields
-        classWithFields = proxyClassWriter;
+        classWithFields = proxyClassAndField.proxyWriter();
         // public fields in the proxy
         fieldModifiers = EnumSet.of(PUBLIC);
       }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index fb287dc75..b01d7ee54 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -76,9 +76,9 @@ public synchronized void init(ProcessingEnvironment processingEnv) {
     InjectConstructorValidator injectConstructorValidator = new InjectConstructorValidator();
     InjectFieldValidator injectFieldValidator = new InjectFieldValidator();
     InjectMethodValidator injectMethodValidator = new InjectMethodValidator();
-    ModuleValidator moduleValidator = new ModuleValidator(elements, types);
+    ModuleValidator moduleValidator = new ModuleValidator(types);
     ProvidesMethodValidator providesMethodValidator = new ProvidesMethodValidator(elements);
-    ComponentValidator componentValidator = new ComponentValidator(elements);
+    ComponentValidator componentValidator = new ComponentValidator();
     MapKeyValidator mapKeyValidator = new MapKeyValidator();
 
     Key.Factory keyFactory = new Key.Factory(types, elements);
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
index 6cf1ced26..5e15022ed 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
@@ -23,11 +23,11 @@
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.Elements;
 import javax.lang.model.util.SimpleTypeVisitor6;
 
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static com.google.common.base.Preconditions.checkState;
+import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
 import static javax.lang.model.element.ElementKind.CLASS;
 import static javax.lang.model.element.ElementKind.INTERFACE;
 import static javax.lang.model.element.Modifier.ABSTRACT;
@@ -38,14 +38,7 @@
  * @author Gregory Kick
  */
 final class ComponentValidator implements Validator<TypeElement> {
-  private final Elements elements;
-
-  ComponentValidator(Elements elements) {
-    this.elements = elements;
-  }
-
-  @Override
-  public ValidationReport<TypeElement> validate(final TypeElement subject) {
+  @Override public ValidationReport<TypeElement> validate(final TypeElement subject) {
     final ValidationReport.Builder<TypeElement> builder = ValidationReport.Builder.about(subject);
 
     if (!subject.getKind().equals(INTERFACE)
@@ -54,8 +47,7 @@
     }
 
     AnnotationMirror componentMirror = getAnnotationMirror(subject, Component.class).get();
-    ImmutableList<TypeMirror> moduleTypes =
-        ConfigurationAnnotations.getComponentModules(elements, componentMirror);
+    ImmutableList<TypeMirror> moduleTypes = getComponentModules(componentMirror);
 
     // TODO(gak): make unused modules an error
     for (TypeMirror moduleType : moduleTypes) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
index 75e401252..58d72fea6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
@@ -31,7 +31,6 @@
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
@@ -46,38 +45,30 @@
 final class ConfigurationAnnotations {
   private static final String MODULES_ATTRIBUTE = "modules";
 
-  static ImmutableList<TypeMirror> getComponentModules(Elements elements,
-      AnnotationMirror componentAnnotation) {
-    checkNotNull(elements);
+  static ImmutableList<TypeMirror> getComponentModules(AnnotationMirror componentAnnotation) {
     checkNotNull(componentAnnotation);
-    return getAttributeAsListOfTypes(elements, componentAnnotation, MODULES_ATTRIBUTE);
+    return getAttributeAsListOfTypes(componentAnnotation, MODULES_ATTRIBUTE);
   }
 
   private static final String DEPENDENCIES_ATTRIBUTE = "dependencies";
 
-  static ImmutableList<TypeMirror> getComponentDependencies(Elements elements,
-      AnnotationMirror componentAnnotation) {
-    checkNotNull(elements);
+  static ImmutableList<TypeMirror> getComponentDependencies(AnnotationMirror componentAnnotation) {
     checkNotNull(componentAnnotation);
-    return getAttributeAsListOfTypes(elements, componentAnnotation, DEPENDENCIES_ATTRIBUTE);
+    return getAttributeAsListOfTypes(componentAnnotation, DEPENDENCIES_ATTRIBUTE);
   }
 
   private static final String INCLUDES_ATTRIBUTE = "includes";
 
-  static ImmutableList<TypeMirror> getModuleIncludes(Elements elements,
-      AnnotationMirror moduleAnnotation) {
-    checkNotNull(elements);
+  static ImmutableList<TypeMirror> getModuleIncludes(AnnotationMirror moduleAnnotation) {
     checkNotNull(moduleAnnotation);
-    return getAttributeAsListOfTypes(elements, moduleAnnotation, INCLUDES_ATTRIBUTE);
+    return getAttributeAsListOfTypes(moduleAnnotation, INCLUDES_ATTRIBUTE);
   }
 
   private static final String INJECTS_ATTRIBUTE = "injects";
 
-  static ImmutableList<TypeMirror> getModuleInjects(Elements elements,
-      AnnotationMirror moduleAnnotation) {
-    checkNotNull(elements);
+  static ImmutableList<TypeMirror> getModuleInjects(AnnotationMirror moduleAnnotation) {
     checkNotNull(moduleAnnotation);
-    return getAttributeAsListOfTypes(elements, moduleAnnotation, INJECTS_ATTRIBUTE);
+    return getAttributeAsListOfTypes(moduleAnnotation, INJECTS_ATTRIBUTE);
   }
 
   static ImmutableSet<? extends AnnotationMirror> getMapKeys(Element element) {
@@ -90,7 +81,7 @@
    * is not annotated with {@link Module}, it is ignored.
    */
   static ImmutableMap<TypeElement, ImmutableSet<TypeElement>> getTransitiveModules(
-      Elements elements, Types types, ImmutableSet<TypeElement> seedModules) {
+      Types types, ImmutableSet<TypeElement> seedModules) {
     Queue<TypeElement> moduleQueue = Queues.newArrayDeque(seedModules);
     Map<TypeElement, ImmutableSet<TypeElement>> moduleElements = Maps.newLinkedHashMap();
     for (TypeElement moduleElement = moduleQueue.poll();
@@ -98,8 +89,8 @@
         moduleElement = moduleQueue.poll()) {
       Optional<AnnotationMirror> moduleMirror = getAnnotationMirror(moduleElement, Module.class);
       if (moduleMirror.isPresent()) {
-        ImmutableSet<TypeElement> moduleDependencies = MoreTypes.asTypeElements(types,
-            ConfigurationAnnotations.getModuleIncludes(elements, moduleMirror.get()));
+        ImmutableSet<TypeElement> moduleDependencies =
+            MoreTypes.asTypeElements(types, getModuleIncludes(moduleMirror.get()));
         moduleElements.put(moduleElement, moduleDependencies);
         for (TypeElement dependencyType : moduleDependencies) {
           if (!moduleElements.containsKey(dependencyType)) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
index afa771b36..9fd1e7d4c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
@@ -164,14 +164,15 @@ MembersInjectionBinding forInjectedType(TypeElement typeElement) {
             }
           });
 
+      Key key = keyFactory.forMembersInjectedType(typeElement.asType());
       return new AutoValue_MembersInjectionBinding(
-          keyFactory.forMembersInjectedType(typeElement.asType()),
+          key,
           dependencies,
           new ImmutableSet.Builder<DependencyRequest>()
               .addAll(dependencies)
               .addAll(parentInjectorRequest.asSet())
               .build(),
-          Optional.of(MoreElements.getPackage(typeElement).getQualifiedName().toString()),
+          findBindingPackage(key),
           typeElement,
           injectionSites,
           parentInjectorRequest);
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
index 00465243f..f84212aa4 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
@@ -15,7 +15,6 @@
  */
 package dagger.internal.codegen;
 
-import com.google.auto.common.MoreElements;
 import com.google.auto.common.Visibility;
 import com.google.common.base.Function;
 import com.google.common.base.Joiner;
@@ -33,13 +32,14 @@
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementFilter;
-import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
+import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.auto.common.Visibility.PRIVATE;
 import static com.google.auto.common.Visibility.PUBLIC;
 import static com.google.auto.common.Visibility.effectiveVisibilityOfElement;
+import static dagger.internal.codegen.ConfigurationAnnotations.getModuleIncludes;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_WITH_SAME_NAME;
 
 /**
@@ -49,11 +49,9 @@
  * @since 2.0
  */
 final class ModuleValidator implements Validator<TypeElement> {
-  private final Elements elements;
   private final Types types;
 
-  ModuleValidator(Elements elements, Types types) {
-    this.elements =  elements;
+  ModuleValidator(Types types) {
     this.types = types;
   }
 
@@ -100,20 +98,19 @@ private void validateModuleVisibility(final TypeElement moduleElement,
       case MEMBER:
       case TOP_LEVEL:
         if (moduleVisibility.equals(PUBLIC)) {
-          ImmutableSet<Element> nonPublicModules =
-              FluentIterable.from(ConfigurationAnnotations.getModuleIncludes(elements,
-                  MoreElements.getAnnotationMirror(moduleElement, Module.class).get()))
-                      .transform(new Function<TypeMirror, Element>() {
-                        @Override public Element apply(TypeMirror input) {
-                          return types.asElement(input);
-                        }
-                      })
-                      .filter(new Predicate<Element>() {
-                        @Override public boolean apply(Element input) {
-                          return effectiveVisibilityOfElement(input).compareTo(PUBLIC) < 0;
-                        }
-                      })
-                      .toSet();
+          ImmutableSet<Element> nonPublicModules = FluentIterable.from(getModuleIncludes(
+              getAnnotationMirror(moduleElement, Module.class).get()))
+                  .transform(new Function<TypeMirror, Element>() {
+                    @Override public Element apply(TypeMirror input) {
+                      return types.asElement(input);
+                    }
+                  })
+                  .filter(new Predicate<Element>() {
+                    @Override public boolean apply(Element input) {
+                      return effectiveVisibilityOfElement(input).compareTo(PUBLIC) < 0;
+                    }
+                  })
+                  .toSet();
           if (!nonPublicModules.isEmpty()) {
             reportBuilder.addItem(
                 String.format(
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index 46d83242a..25cd5879b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -32,16 +32,8 @@
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.Name;
-import javax.lang.model.element.PackageElement;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.ArrayType;
-import javax.lang.model.type.DeclaredType;
-import javax.lang.model.type.TypeMirror;
-import javax.lang.model.type.TypeVariable;
-import javax.lang.model.type.WildcardType;
 import javax.lang.model.util.Elements;
-import javax.lang.model.util.SimpleTypeVisitor6;
 import javax.lang.model.util.Types;
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
@@ -54,7 +46,6 @@
 import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
 import static javax.lang.model.element.ElementKind.FIELD;
 import static javax.lang.model.element.ElementKind.METHOD;
-import static javax.lang.model.element.Modifier.PUBLIC;
 
 /**
  * A value object representing the mechanism by which a {@link Key} can be provided. New instances
@@ -193,62 +184,6 @@ FactoryCreationStrategy factoryCreationStrategy() {
       this.dependencyRequestFactory = dependencyRequestFactory;
     }
 
-    private static Optional<String> findBindingPackage(Key providedKey) {
-      Set<String> packages = nonPublicPackageUse(providedKey.type());
-      switch (packages.size()) {
-        case 0:
-          return Optional.absent();
-        case 1:
-          return Optional.of(packages.iterator().next());
-        default:
-          throw new IllegalStateException();
-      }
-    }
-
-    private static Set<String> nonPublicPackageUse(TypeMirror typeMirror) {
-      ImmutableSet.Builder<String> packages = ImmutableSet.builder();
-      typeMirror.accept(new SimpleTypeVisitor6<Void, ImmutableSet.Builder<String>>() {
-        @Override
-        public Void visitArray(ArrayType t, ImmutableSet.Builder<String> p) {
-          return t.getComponentType().accept(this, p);
-        }
-
-        @Override
-        public Void visitDeclared(DeclaredType t, ImmutableSet.Builder<String> p) {
-          for (TypeMirror typeArgument : t.getTypeArguments()) {
-            typeArgument.accept(this, p);
-          }
-          // TODO(gak): address public nested types in non-public types
-          TypeElement typeElement = MoreElements.asType(t.asElement());
-          if (!typeElement.getModifiers().contains(PUBLIC)) {
-            PackageElement elementPackage = MoreElements.getPackage(typeElement);
-            Name qualifiedName = elementPackage.getQualifiedName();
-            p.add(qualifiedName.toString());
-          }
-          return null;
-        }
-
-        @Override
-        public Void visitTypeVariable(TypeVariable t, ImmutableSet.Builder<String> p) {
-          t.getLowerBound().accept(this, p);
-          t.getUpperBound().accept(this, p);
-          return null;
-        }
-
-        @Override
-        public Void visitWildcard(WildcardType t, ImmutableSet.Builder<String> p) {
-          if (t.getExtendsBound() != null) {
-            t.getExtendsBound().accept(this, p);
-          }
-          if (t.getSuperBound() != null) {
-            t.getSuperBound().accept(this, p);
-          }
-          return null;
-        }
-      }, packages);
-      return packages.build();
-    }
-
     ProvisionBinding forInjectConstructor(ExecutableElement constructorElement) {
       checkNotNull(constructorElement);
       checkArgument(constructorElement.getKind().equals(CONSTRUCTOR));
diff --git a/compiler/src/test/java/dagger/internal/codegen/PackageProxyTest.java b/compiler/src/test/java/dagger/internal/codegen/PackageProxyTest.java
index 6f799ece3..2fb63b9cf 100644
--- a/compiler/src/test/java/dagger/internal/codegen/PackageProxyTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/PackageProxyTest.java
@@ -12,7 +12,7 @@
 
 @RunWith(JUnit4.class)
 public class PackageProxyTest {
-  @Test public void testPackageProxy() {
+  @Test public void basicPackageProxy() {
     JavaFileObject noDepClassFile = JavaFileObjects.forSourceLines("foreign.NoDepClass",
         "package foreign;",
         "",
@@ -27,15 +27,23 @@
         "import javax.inject.Inject;",
         "",
         "public final class PublicClass {",
-        "  @Inject PublicClass(NonPublicClass dep1, NoDepClass dep2) {}",
+        "  @Inject PublicClass(NonPublicClass1 dep1, NonPublicClass2 dep2, NoDepClass dep3) {}",
         "}");
-    JavaFileObject nonPublicClassFile = JavaFileObjects.forSourceLines("foreign.NonPublicClass",
+    JavaFileObject nonPublicClass1File = JavaFileObjects.forSourceLines("foreign.NonPublicClass1",
         "package foreign;",
         "",
         "import javax.inject.Inject;",
         "",
-        "final class NonPublicClass {",
-        "  @Inject NonPublicClass(NoDepClass dep) {}",
+        "final class NonPublicClass1 {",
+        "  @Inject NonPublicClass1(NoDepClass dep) {}",
+        "}");
+    JavaFileObject nonPublicClass2File = JavaFileObjects.forSourceLines("foreign.NonPublicClass2",
+        "package foreign;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class NonPublicClass2 {",
+        "  @Inject NonPublicClass2(NoDepClass dep) {}",
         "}");
 
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
@@ -56,7 +64,8 @@
         "",
         "import foreign.Dagger_TestComponent__PackageProxy;",
         "import foreign.NoDepClass$$Factory;",
-        "import foreign.NonPublicClass$$Factory;",
+        "import foreign.NonPublicClass1$$Factory;",
+        "import foreign.NonPublicClass2$$Factory;",
         "import foreign.PublicClass;",
         "import foreign.PublicClass$$Factory;",
         "import javax.annotation.Generated;",
@@ -82,10 +91,14 @@
         "  }",
         "",
         "  private void initialize() {",
-        "    this.foreign_Proxy.nonPublicClassProvider =",
-        "        new NonPublicClass$$Factory(NoDepClass$$Factory.INSTANCE);",
+        "    this.foreign_Proxy.nonPublicClass1Provider =",
+        "        new NonPublicClass1$$Factory(NoDepClass$$Factory.INSTANCE);",
+        "    this.foreign_Proxy.nonPublicClass2Provider =",
+        "        new NonPublicClass2$$Factory(NoDepClass$$Factory.INSTANCE);",
         "    this.publicClassProvider = new PublicClass$$Factory(",
-        "        foreign_Proxy.nonPublicClassProvider, NoDepClass$$Factory.INSTANCE);",
+        "        foreign_Proxy.nonPublicClass1Provider,",
+        "        foreign_Proxy.nonPublicClass2Provider,",
+        "        NoDepClass$$Factory.INSTANCE);",
         "  }",
         "",
         "  @Override",
@@ -103,7 +116,138 @@
         "  }",
         "}");
     assert_().about(javaSources())
-        .that(ImmutableList.of(noDepClassFile, publicClassFile, nonPublicClassFile, componentFile))
+        .that(ImmutableList.of(
+            noDepClassFile,
+            publicClassFile,
+            nonPublicClass1File,
+            nonPublicClass2File,
+            componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
+
+  @Test public void memberInjectionPackageProxy() {
+    JavaFileObject noDepClassFile = JavaFileObjects.forSourceLines("test.NoDepClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "public final class NoDepClass {",
+        "  @Inject NoDepClass() {}",
+        "}");
+    JavaFileObject aClassFile = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "import foreign.B;",
+        "import javax.inject.Inject;",
+        "",
+        "final class A extends B {",
+        "  @Inject NoDepClass dep;",
+        "}");
+    JavaFileObject bClassFile = JavaFileObjects.forSourceLines("foreign.B",
+        "package foreign;",
+        "",
+        "import test.NoDepClass;",
+        "import javax.inject.Inject;",
+        "",
+        "public class B extends C {",
+        "  @Inject NoDepClass dep;",
+        "}");
+    JavaFileObject cClassFile = JavaFileObjects.forSourceLines("foreign.C",
+        "package foreign;",
+        "",
+        "import test.D;",
+        "import test.NoDepClass;",
+        "import javax.inject.Inject;",
+        "",
+        "class C extends D {",
+        "  @Inject NoDepClass dep;",
+        "}");
+    JavaFileObject dClassFile = JavaFileObjects.forSourceLines("test.D",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "public class D {",
+        "  @Inject NoDepClass dep;",
+        "}");
+
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface TestComponent {",
+        "  void injectA(A a);",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.Dagger_TestComponent",
+        "package test;",
+        "",
+        "import dagger.MembersInjector;",
+        "import foreign.B;",
+        "import foreign.B$$MembersInjector;",
+        "import foreign.C$$MembersInjector;",
+        "import foreign.Dagger_TestComponent__PackageProxy;",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class Dagger_TestComponent implements TestComponent {",
+        "  private MembersInjector<D> dMembersInjector;",
+        "  private final Dagger_TestComponent__PackageProxy foreign_Proxy =",
+        "      new Dagger_TestComponent__PackageProxy();",
+        "  private MembersInjector<B> bMembersInjector;",
+        "  private MembersInjector<A> aMembersInjector;",
+        "",
+        "  private Dagger_TestComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    initialize();",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static TestComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  private void initialize() {",
+        "    this.dMembersInjector = new D$$MembersInjector(NoDepClass$$Factory.INSTANCE);",
+        "    this.foreign_Proxy.cMembersInjector =",
+        "        new C$$MembersInjector(dMembersInjector, NoDepClass$$Factory.INSTANCE);",
+        "    this.bMembersInjector = new B$$MembersInjector(",
+        "        foreign_Proxy.cMembersInjector, NoDepClass$$Factory.INSTANCE);",
+        "    this.aMembersInjector = new A$$MembersInjector(",
+        "        bMembersInjector, NoDepClass$$Factory.INSTANCE);",
+        "  }",
+        "",
+        "  @Override",
+        "  public void injectA(A a) {",
+        "    aMembersInjector.injectMembers(a);",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public TestComponent build() {",
+        "      return new Dagger_TestComponent(this);",
+        "    }",
+        "  }",
+        "}");
+    assert_().about(javaSources())
+        .that(ImmutableList.of(
+            noDepClassFile,
+            aClassFile,
+            bClassFile,
+            cClassFile,
+            dClassFile,
+            componentFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(generatedComponent);
diff --git a/core/src/test/java/dagger/internal/SetFactoryTest.java b/core/src/test/java/dagger/internal/SetFactoryTest.java
index 8d78ec348..5f3edc7e3 100644
--- a/core/src/test/java/dagger/internal/SetFactoryTest.java
+++ b/core/src/test/java/dagger/internal/SetFactoryTest.java
@@ -105,7 +105,7 @@ public void iterationOrder() {
         integerSetProvider(Range.closed(5, 9)),
         integerSetProvider(Range.closed(3, 6)),
         integerSetProvider(Range.closed(0, 5)));
-    assert_().that(factory.get()).iteratesAs(5, 6, 7, 8, 9, 3, 4, 0, 1, 2);
+    assert_().that(factory.get()).containsExactly(5, 6, 7, 8, 9, 3, 4, 0, 1, 2).inOrder();
   }
 
   private static Provider<Set<Integer>> incrementingIntegerProvider(int seed) {
