diff --git a/compiler/src/it/functional-tests/pom.xml b/compiler/src/it/functional-tests/pom.xml
index 2b6ea007c..a7dbbc8b1 100644
--- a/compiler/src/it/functional-tests/pom.xml
+++ b/compiler/src/it/functional-tests/pom.xml
@@ -50,6 +50,10 @@ limitations under the License.
       <artifactId>truth</artifactId>
       <scope>test</scope>
     </dependency>
+    <dependency>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
+    </dependency>
   </dependencies>
   <build>
     <plugins>
diff --git a/compiler/src/it/functional-tests/src/main/java/test/A.java b/compiler/src/it/functional-tests/src/main/java/test/A.java
new file mode 100644
index 000000000..030f8556c
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/A.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import javax.inject.Inject;
+
+class A {
+  @Inject A() {}
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/B.java b/compiler/src/it/functional-tests/src/main/java/test/B.java
new file mode 100644
index 000000000..dec8e2e58
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/B.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import javax.inject.Inject;
+
+class B {
+  @Inject B() {}
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/BoundedGenericComponent.java b/compiler/src/it/functional-tests/src/main/java/test/BoundedGenericComponent.java
new file mode 100644
index 000000000..b30522f57
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/BoundedGenericComponent.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import dagger.Component;
+import java.util.ArrayList;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Set;
+
+@Component(modules = BoundedGenericModule.class)
+interface BoundedGenericComponent {
+  BoundedGenerics<Integer, ArrayList<String>, LinkedList<CharSequence>, Integer, List<Integer>>
+      bounds1();
+  BoundedGenerics<Double, LinkedList<String>, LinkedList<Comparable<String>>, Double, Set<Double>>
+      bounds2();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/BoundedGenericModule.java b/compiler/src/it/functional-tests/src/main/java/test/BoundedGenericModule.java
new file mode 100644
index 000000000..800125aa1
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/BoundedGenericModule.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import com.google.common.collect.Lists;
+import com.google.common.collect.Sets;
+import dagger.Module;
+import dagger.Provides;
+import java.util.ArrayList;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Set;
+
+@Module
+class BoundedGenericModule {
+
+  @Provides
+  Integer provideInteger() {
+    return 1;
+  }
+
+  @Provides
+  Double provideDouble() {
+    return 2d;
+  }
+
+  @Provides
+  ArrayList<String> provideArrayListString() {
+    return Lists.newArrayList("arrayListOfString");
+  }
+
+  @Provides
+  LinkedList<String> provideLinkedListString() {
+    return Lists.newLinkedList("linkedListOfString");
+  }
+
+  @Provides
+  LinkedList<CharSequence> provideLinkedListCharSeq() {
+    return Lists.<CharSequence>newLinkedList("linkedListOfCharSeq");
+  }
+
+  @Provides
+  @SuppressWarnings("unchecked")
+  LinkedList<Comparable<String>> provideArrayListOfComparableString() {
+    return Lists.<Comparable<String>>newLinkedList("arrayListOfComparableOfString");
+  }
+
+  @Provides
+  List<Integer> provideListOfInteger() {
+    return Lists.newArrayList(3);
+  }
+
+  @Provides
+  Set<Double> provideSetOfDouble() {
+    return Sets.newHashSet(4d);
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/BoundedGenerics.java b/compiler/src/it/functional-tests/src/main/java/test/BoundedGenerics.java
new file mode 100644
index 000000000..e26d64351
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/BoundedGenerics.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import java.util.List;
+import javax.inject.Inject;
+
+class BoundedGenerics<A extends Number & Comparable<? super A>, 
+      B extends List<? extends CharSequence>,
+      C extends List<? super String>,
+      D extends A,
+      E extends Iterable<D>> {
+  
+  final A a;
+  final B b;
+  final C c;
+  final D d;
+  final E e;
+  
+  @Inject BoundedGenerics(A a, B b, C c, D d, E e) {
+    this.a = a;
+    this.b = b;
+    this.c = c;
+    this.d = d;
+    this.e = e;
+  }
+
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/ComplexGenerics.java b/compiler/src/it/functional-tests/src/main/java/test/ComplexGenerics.java
new file mode 100644
index 000000000..e2e327494
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/ComplexGenerics.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import dagger.Lazy;
+import javax.inject.Inject;
+import javax.inject.Provider;
+
+class ComplexGenerics {
+  
+  final Generic2<Generic<A>> g2ga;
+  final Lazy<Generic2<Generic<A>>> g2gaLazy;
+  final Provider<Generic2<Generic<A>>> g2gaProvider;
+  final Generic2<Generic<B>> g2gb;
+  final Lazy<Generic2<Generic<B>>> g2gbLazy;
+  final Provider<Generic2<Generic<B>>> g2gbProvider;
+  final Generic2<A> g2a;
+  final Generic<Generic2<A>> gg2a;
+  final Generic<Generic2<B>> gg2b;
+  
+  @Inject ComplexGenerics(
+      Generic2<Generic<A>> g2ga,
+      Lazy<Generic2<Generic<A>>> g2gaLazy,
+      Provider<Generic2<Generic<A>>> g2gaProvider,
+      Generic2<Generic<B>> g2gb,
+      Lazy<Generic2<Generic<B>>> g2gbLazy,
+      Provider<Generic2<Generic<B>>> g2gbProvider,
+      Generic2<A> g2a,
+      Generic<Generic2<A>> gg2a,
+      Generic<Generic2<B>> gg2b) {
+    this.g2ga = g2ga;
+    this.g2gaLazy = g2gaLazy;
+    this.g2gaProvider = g2gaProvider;
+    this.g2gb = g2gb;
+    this.g2gbLazy = g2gbLazy;
+    this.g2gbProvider = g2gbProvider;
+    this.g2a = g2a;
+    this.gg2a = gg2a;
+    this.gg2b = gg2b;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/Generic.java b/compiler/src/it/functional-tests/src/main/java/test/Generic.java
new file mode 100644
index 000000000..ee1aa0992
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/Generic.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import javax.inject.Inject;
+
+public class Generic<T> {
+  final T t;
+
+  @Inject public Generic(T t) {
+    this.t = t;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/Generic2.java b/compiler/src/it/functional-tests/src/main/java/test/Generic2.java
new file mode 100644
index 000000000..4a56df3ec
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/Generic2.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import javax.inject.Inject;
+
+public class Generic2<T> {
+  final T t;
+
+  @Inject Generic2(T t) {
+    this.t = t;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/GenericChild.java b/compiler/src/it/functional-tests/src/main/java/test/GenericChild.java
new file mode 100644
index 000000000..5c65dc03e
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/GenericChild.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import javax.inject.Inject;
+
+class GenericChild<T> extends GenericParent<T, B> {
+  
+  A registeredA;
+  T registeredT;
+  
+  @Inject GenericChild() {}
+  
+  @Inject A a;
+  @Inject T t;
+  
+  @Inject void registerA(A a) { this.registeredA = a; }
+  @Inject void registerT(T t) { this.registeredT = t; }
+
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/GenericComponent.java b/compiler/src/it/functional-tests/src/main/java/test/GenericComponent.java
new file mode 100644
index 000000000..25a5f11cf
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/GenericComponent.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import test.sub.PublicSubclass;
+
+import test.sub.Exposed;
+import dagger.Component;
+
+@Component
+interface GenericComponent {
+  ReferencesGeneric referencesGeneric();
+  GenericDoubleReferences<A> doubleGenericA();
+  GenericDoubleReferences<B> doubleGenericB();
+  ComplexGenerics complexGenerics();
+  GenericNoDeps<A> noDepsA();
+  GenericNoDeps<B> noDepsB();
+  
+  void injectA(GenericChild<A> childA);
+  void injectB(GenericChild<B> childB);
+
+  Exposed exposed();
+  PublicSubclass publicSubclass();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/GenericDoubleReferences.java b/compiler/src/it/functional-tests/src/main/java/test/GenericDoubleReferences.java
new file mode 100644
index 000000000..6785c7c5f
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/GenericDoubleReferences.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import javax.inject.Inject;
+
+class GenericDoubleReferences<T> {
+  final T t;
+  final T t2;
+  final Thing a;
+  final Thing a2;
+
+  @Inject GenericDoubleReferences(T t, Thing a, T t2, Thing a2) {
+    this.t = t;
+    this.a = a;
+    this.t2 = t2;
+    this.a2 = a2;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/GenericNoDeps.java b/compiler/src/it/functional-tests/src/main/java/test/GenericNoDeps.java
new file mode 100644
index 000000000..e065f7926
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/GenericNoDeps.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import javax.inject.Inject;
+
+class GenericNoDeps<T> {
+  
+  @Inject GenericNoDeps() {}
+
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/GenericParent.java b/compiler/src/it/functional-tests/src/main/java/test/GenericParent.java
new file mode 100644
index 000000000..0e01f5f7e
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/GenericParent.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import javax.inject.Inject;
+
+class GenericParent<X, Y> {
+  
+  X registeredX;
+  Y registeredY;
+  B registeredB;
+  
+  
+  @Inject GenericParent() {}
+  
+  @Inject X x;
+  @Inject Y y;
+  @Inject B b;
+  
+  @Inject void registerX(X x) { this.registeredX = x; }
+  @Inject void registerY(Y y) { this.registeredY = y; }
+  @Inject void registerB(B b) { this.registeredB = b; }
+
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/ReferencesGeneric.java b/compiler/src/it/functional-tests/src/main/java/test/ReferencesGeneric.java
new file mode 100644
index 000000000..812c45d35
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/ReferencesGeneric.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import javax.inject.Inject;
+
+class ReferencesGeneric {
+  final Generic<A> genericA;
+  
+  @Inject ReferencesGeneric(Generic<A> genericA) {
+    this.genericA = genericA;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/ScopedGeneric.java b/compiler/src/it/functional-tests/src/main/java/test/ScopedGeneric.java
new file mode 100644
index 000000000..b07da6456
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/ScopedGeneric.java
@@ -0,0 +1,13 @@
+package test;
+
+import javax.inject.Inject;
+
+import javax.inject.Singleton;
+
+@Singleton
+class ScopedGeneric<T> { 
+  final T t;  
+  @Inject ScopedGeneric(T t) {
+    this.t = t;
+  }  
+}
\ No newline at end of file
diff --git a/compiler/src/it/functional-tests/src/main/java/test/SingletonGenericComponent.java b/compiler/src/it/functional-tests/src/main/java/test/SingletonGenericComponent.java
new file mode 100644
index 000000000..d26932a3d
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/SingletonGenericComponent.java
@@ -0,0 +1,14 @@
+package test;
+
+import dagger.Component;
+
+import javax.inject.Singleton;
+
+@Singleton
+@Component
+interface SingletonGenericComponent {
+  
+  ScopedGeneric<A> scopedGenericA();
+  ScopedGeneric<B> scopedGenericB();
+
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/sub/Exposed.java b/compiler/src/it/functional-tests/src/main/java/test/sub/Exposed.java
new file mode 100644
index 000000000..3d10ad924
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/sub/Exposed.java
@@ -0,0 +1,19 @@
+package test.sub;
+
+import test.Generic;
+import test.Generic2;
+import javax.inject.Inject;
+
+public class Exposed {
+  
+  @Inject public Generic2<PackagePrivate> gpp2;
+  @Inject public Generic2<PackagePrivateContainer.PublicEnclosed> gppc2;
+
+  public Generic<PackagePrivate> gpp;
+  public Generic<PackagePrivateContainer.PublicEnclosed> gppc;
+  
+  @Inject Exposed(Generic<PackagePrivate> gpp, Generic<PackagePrivateContainer.PublicEnclosed> gppc) {
+    this.gpp = gpp;
+    this.gppc = gppc;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/sub/PackagePrivate.java b/compiler/src/it/functional-tests/src/main/java/test/sub/PackagePrivate.java
new file mode 100644
index 000000000..9af646a50
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/sub/PackagePrivate.java
@@ -0,0 +1,7 @@
+package test.sub;
+
+import javax.inject.Inject;
+
+class PackagePrivate {  
+  @Inject PackagePrivate() {}
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/sub/PackagePrivateContainer.java b/compiler/src/it/functional-tests/src/main/java/test/sub/PackagePrivateContainer.java
new file mode 100644
index 000000000..765b01504
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/sub/PackagePrivateContainer.java
@@ -0,0 +1,9 @@
+package test.sub;
+
+import javax.inject.Inject;
+
+class PackagePrivateContainer {  
+  public static class PublicEnclosed {
+    @Inject PublicEnclosed() {}
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/sub/PublicSubclass.java b/compiler/src/it/functional-tests/src/main/java/test/sub/PublicSubclass.java
new file mode 100644
index 000000000..9c30852d5
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/sub/PublicSubclass.java
@@ -0,0 +1,11 @@
+package test.sub;
+
+import test.Generic;
+
+import javax.inject.Inject;
+
+public class PublicSubclass extends Generic<PackagePrivate> {
+  @Inject public PublicSubclass(PackagePrivate pp) {
+    super(pp);
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/sub/PublicSubclass2.java b/compiler/src/it/functional-tests/src/main/java/test/sub/PublicSubclass2.java
new file mode 100644
index 000000000..ddbbfce62
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/sub/PublicSubclass2.java
@@ -0,0 +1,11 @@
+package test.sub;
+
+import test.Generic;
+
+import javax.inject.Inject;
+
+public class PublicSubclass2 extends Generic<PackagePrivateContainer.PublicEnclosed> {
+  @Inject public PublicSubclass2(PackagePrivateContainer.PublicEnclosed pp) {
+    super(pp);
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/GenericTest.java b/compiler/src/it/functional-tests/src/test/java/test/GenericTest.java
new file mode 100644
index 000000000..b65d4f3aa
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/test/java/test/GenericTest.java
@@ -0,0 +1,140 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import test.sub.PublicSubclass;
+import test.sub.Exposed;
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertEquals;
+import java.util.ArrayList;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Set;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class GenericTest {
+
+  @Test public void testGenericComponentCreate() {
+    GenericComponent component = Dagger_GenericComponent.create();
+    assertThat(component).isNotNull();
+  }
+  
+  @Test public void testGenericSimpleReferences() {
+    GenericComponent component = Dagger_GenericComponent.create();
+    assertThat(component.referencesGeneric().genericA.t).isNotNull();    
+  }
+  
+  @Test public void testGenericDoubleReferences() {
+    GenericComponent component = Dagger_GenericComponent.create();
+    GenericDoubleReferences<A> doubleA = component.doubleGenericA();
+    assertThat(doubleA.a).isNotNull();
+    assertThat(doubleA.a2).isNotNull();
+    assertThat(doubleA.t).isNotNull();
+    assertThat(doubleA.t2).isNotNull();
+
+    GenericDoubleReferences<B> doubleB = component.doubleGenericB();
+    assertThat(doubleB.a).isNotNull();
+    assertThat(doubleB.a2).isNotNull();
+    assertThat(doubleB.t).isNotNull();
+    assertThat(doubleB.t2).isNotNull();
+  }
+  
+  @Test public void complexGenerics() {
+    GenericComponent component = Dagger_GenericComponent.create();
+    // validate these can be called w/o exceptions.
+    component.complexGenerics();
+  }
+  
+  @Test public void noDepsGenerics() {
+    GenericComponent component = Dagger_GenericComponent.create();
+    // validate these can be called w/o exceptions.
+    component.noDepsA();
+    component.noDepsB();
+  }
+  
+  @Test public void boundedGenerics() {
+    BoundedGenericModule expected = new BoundedGenericModule();
+    BoundedGenericComponent component = Dagger_BoundedGenericComponent.create();
+    BoundedGenerics<Integer, ArrayList<String>, LinkedList<CharSequence>, Integer, List<Integer>>
+        b1 = component.bounds1();
+    assertEquals(expected.provideInteger(), b1.a);
+    assertEquals(expected.provideArrayListString(), b1.b);
+    assertEquals(expected.provideLinkedListCharSeq(), b1.c);
+    assertEquals(expected.provideInteger(), b1.d);
+    assertEquals(expected.provideListOfInteger(), b1.e);
+
+    BoundedGenerics<Double, LinkedList<String>, LinkedList<Comparable<String>>, Double, Set<Double>>
+        b2 = component.bounds2();
+    assertEquals(expected.provideDouble(), b2.a);
+    assertEquals(expected.provideLinkedListString(), b2.b);
+    assertEquals(expected.provideArrayListOfComparableString(), b2.c);
+    assertEquals(expected.provideDouble(), b2.d);
+    assertEquals(expected.provideSetOfDouble(), b2.e);
+  }
+  
+  @Test public void membersInjections() {
+    GenericComponent component = Dagger_GenericComponent.create();
+    GenericChild<A> childA = new GenericChild<A>();
+    component.injectA(childA);
+    assertThat(childA.a).isNotNull();
+    assertThat(childA.b).isNotNull();
+    assertThat(childA.registeredA).isNotNull();
+    assertThat(childA.registeredB).isNotNull();
+    assertThat(childA.registeredT).isNotNull();
+    assertThat(childA.registeredX).isNotNull();
+    assertThat(childA.registeredY).isNotNull();
+    
+    GenericChild<B> childB = new GenericChild<B>();
+    component.injectB(childB);
+    assertThat(childB.a).isNotNull();
+    assertThat(childB.b).isNotNull();
+    assertThat(childB.registeredA).isNotNull();
+    assertThat(childB.registeredB).isNotNull();
+    assertThat(childB.registeredT).isNotNull();
+    assertThat(childB.registeredX).isNotNull();
+    assertThat(childB.registeredY).isNotNull();
+  }
+  
+  @Test public void packagePrivateTypeParameterDependencies() {
+    GenericComponent component = Dagger_GenericComponent.create();
+    Exposed exposed = component.exposed();
+    assertThat(exposed.gpp.t).isNotNull();
+    assertThat(exposed.gpp2).isNotNull();
+  }
+  
+  @SuppressWarnings("rawtypes")
+  @Test public void publicSubclassWithPackagePrivateTypeParameterOfSuperclass() {
+    GenericComponent component = Dagger_GenericComponent.create();
+    PublicSubclass publicSubclass = component.publicSubclass();
+    assertThat(((Generic)publicSubclass).t).isNotNull();
+  }
+  
+  @Test public void singletonScopesAppliesToEachResolvedType() {
+    SingletonGenericComponent component = Dagger_SingletonGenericComponent.create();
+    ScopedGeneric<A> a = component.scopedGenericA();
+    assertThat(a).isSameAs(component.scopedGenericA());
+    assertThat(a.t).isNotNull();
+    
+    ScopedGeneric<B> b = component.scopedGenericB();
+    assertThat(b).isSameAs(component.scopedGenericB());
+    assertThat(b.t).isNotNull();
+    
+    assertThat(a).isNotSameAs(b);
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/Binding.java b/compiler/src/main/java/dagger/internal/codegen/Binding.java
index ef52b04a9..22cae1c9f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Binding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Binding.java
@@ -128,6 +128,10 @@ public Void visitDeclared(DeclaredType t, ImmutableSet.Builder<String> p) {
           Name qualifiedName = elementPackage.getQualifiedName();
           p.add(qualifiedName.toString());
         }
+        // Also make sure enclosing types are visible, otherwise we're fooled by
+        // class Foo { public class Bar }
+        // (Note: we can't use t.getEnclosingType() because it doesn't work!)
+        typeElement.getEnclosingElement().asType().accept(this, p);
         return null;
       }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 2e859ab15..5770afb0e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -1,5 +1,30 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package dagger.internal.codegen;
 
+import static com.google.auto.common.MoreElements.getAnnotationMirror;
+import static com.google.auto.common.MoreTypes.isTypeOf;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
+import static dagger.internal.codegen.ErrorMessages.INDENT;
+import static dagger.internal.codegen.ErrorMessages.REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_FORMAT;
+import static dagger.internal.codegen.ErrorMessages.REQUIRES_PROVIDER_FORMAT;
+import static dagger.internal.codegen.ErrorMessages.stripCommonTypePrefixes;
+import static dagger.internal.codegen.InjectionAnnotations.getScopeAnnotation;
+
 import com.google.auto.common.AnnotationMirrors;
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
@@ -28,27 +53,13 @@
 import java.util.Set;
 import javax.inject.Singleton;
 import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.Modifier;
 import javax.lang.model.element.Name;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.SimpleTypeVisitor6;
 import javax.lang.model.util.Types;
 import javax.tools.Diagnostic;
 
-import static com.google.auto.common.MoreElements.getAnnotationMirror;
-import static com.google.auto.common.MoreTypes.isTypeOf;
-import static com.google.common.collect.Iterables.getOnlyElement;
-import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
-import static dagger.internal.codegen.ErrorMessages.INDENT;
-import static dagger.internal.codegen.ErrorMessages.REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_FORMAT;
-import static dagger.internal.codegen.ErrorMessages.REQUIRES_PROVIDER_FORMAT;
-import static dagger.internal.codegen.ErrorMessages.stripCommonTypePrefixes;
-import static dagger.internal.codegen.InjectionAnnotations.getScopeAnnotation;
-
 public class BindingGraphValidator implements Validator<BindingGraph> {
 
   private final Types types;
@@ -74,8 +85,6 @@
     validateDependencyScopes(subject, reportBuilder);
 
     for (DependencyRequest entryPoint : subject.entryPoints()) {
-      ResolvedBindings resolvedBinding = resolvedBindings.get(
-          BindingKey.forDependencyRequest(entryPoint));
       LinkedList<DependencyRequest> requestPath = Lists.newLinkedList();
       requestPath.push(entryPoint);
       traversalHelper(subject, requestPath, new Traverser() {
@@ -368,23 +377,9 @@ private void reportMissingBinding(
       Deque<DependencyRequest> requestPath, ValidationReport.Builder<BindingGraph> reportBuilder) {
     Key key = requestPath.peek().key();
     TypeMirror type = key.type();
+    // TODO(sameb): This excludes type variables from the error message right now.
     Name typeName = MoreElements.asType(types.asElement(type)).getQualifiedName();
-    boolean requiresProvidesMethod = type.accept(new SimpleTypeVisitor6<Boolean, Void>() {
-      @Override protected Boolean defaultAction(TypeMirror e, Void p) {
-        return true;
-      }
-
-      @Override public Boolean visitDeclared(DeclaredType type, Void ignored) {
-        // Note - this logic is also in InjectConstructorValidator but is woven into errors.
-        TypeElement typeElement = MoreElements.asType(type.asElement());
-        if (typeElement.getTypeParameters().isEmpty()
-            && typeElement.getKind().equals(ElementKind.CLASS)
-            && !typeElement.getModifiers().contains(Modifier.ABSTRACT)) {
-          return false;
-        }
-        return true;
-      }
-    }, null);
+    boolean requiresProvidesMethod = !key.isValidImplicitProvisionKey(types);
     StringBuilder errorMessage = new StringBuilder();
     if (requiresProvidesMethod) {
       errorMessage.append(String.format(REQUIRES_PROVIDER_FORMAT, typeName));
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index 251fccca3..68b122936 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -15,6 +15,25 @@
  */
 package dagger.internal.codegen;
 
+import static com.google.auto.common.MoreTypes.asDeclared;
+import static com.google.common.base.CaseFormat.LOWER_CAMEL;
+import static dagger.internal.codegen.Binding.bindingPackageFor;
+import static dagger.internal.codegen.ConfigurationAnnotations.getMapKeys;
+import static dagger.internal.codegen.ProvisionBinding.FactoryCreationStrategy.ENUM_INSTANCE;
+import static dagger.internal.codegen.ProvisionBinding.Kind.PROVISION;
+import static dagger.internal.codegen.ProvisionBinding.Kind.SYNTHETIC_PROVISON;
+import static dagger.internal.codegen.SourceFiles.factoryNameForProvisionBinding;
+import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
+import static dagger.internal.codegen.SourceFiles.membersInjectorNameForMembersInjectionBinding;
+import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.STATIC;
+import static javax.lang.model.element.NestingKind.MEMBER;
+import static javax.lang.model.element.NestingKind.TOP_LEVEL;
+import static javax.lang.model.type.TypeKind.VOID;
+
 import com.google.auto.common.AnnotationMirrors;
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
@@ -50,8 +69,10 @@
 import dagger.internal.codegen.writer.FieldWriter;
 import dagger.internal.codegen.writer.JavaWriter;
 import dagger.internal.codegen.writer.MethodWriter;
+import dagger.internal.codegen.writer.ParameterizedTypeName;
 import dagger.internal.codegen.writer.Snippet;
 import dagger.internal.codegen.writer.StringLiteral;
+import dagger.internal.codegen.writer.TypeName;
 import dagger.internal.codegen.writer.TypeNames;
 import dagger.internal.codegen.writer.TypeWriter;
 import dagger.internal.codegen.writer.VoidName;
@@ -78,29 +99,6 @@
 import javax.lang.model.util.ElementKindVisitor6;
 import javax.lang.model.util.SimpleAnnotationValueVisitor6;
 
-import static com.google.auto.common.MoreTypes.asDeclared;
-import static com.google.common.base.CaseFormat.LOWER_CAMEL;
-import static dagger.internal.codegen.Binding.bindingPackageFor;
-import static dagger.internal.codegen.ConfigurationAnnotations.getMapKeys;
-import static dagger.internal.codegen.DependencyRequest.Kind.MEMBERS_INJECTOR;
-import static dagger.internal.codegen.ProvisionBinding.FactoryCreationStrategy.ENUM_INSTANCE;
-import static dagger.internal.codegen.ProvisionBinding.Kind.COMPONENT;
-import static dagger.internal.codegen.ProvisionBinding.Kind.COMPONENT_PROVISION;
-import static dagger.internal.codegen.ProvisionBinding.Kind.INJECTION;
-import static dagger.internal.codegen.ProvisionBinding.Kind.PROVISION;
-import static dagger.internal.codegen.ProvisionBinding.Kind.SYNTHETIC_PROVISON;
-import static dagger.internal.codegen.SourceFiles.factoryNameForProvisionBinding;
-import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
-import static dagger.internal.codegen.SourceFiles.membersInjectorNameForMembersInjectionBinding;
-import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
-import static javax.lang.model.element.Modifier.FINAL;
-import static javax.lang.model.element.Modifier.PRIVATE;
-import static javax.lang.model.element.Modifier.PUBLIC;
-import static javax.lang.model.element.Modifier.STATIC;
-import static javax.lang.model.element.NestingKind.MEMBER;
-import static javax.lang.model.element.NestingKind.TOP_LEVEL;
-import static javax.lang.model.type.TypeKind.VOID;
-
 /**
  * Generates the implementation of the abstract types annotated with {@link Component}.
  *
@@ -228,6 +226,7 @@ static ProxyClassAndField create(ClassWriter proxyWriter, FieldWriter proxyField
         ImmutableMap.builder();
     ImmutableMap.Builder<ContributionBinding, Snippet> multibindingContributionSnippetsBuilder =
         ImmutableMap.builder();
+    ImmutableSet.Builder<BindingKey> enumBindingKeysBuilder = ImmutableSet.builder();
 
     ImmutableSet.Builder<JavaWriter> proxyWriters = ImmutableSet.builder();
     Map<String, ProxyClassAndField> packageProxies = Maps.newHashMap();
@@ -243,8 +242,9 @@ static ProxyClassAndField create(ClassWriter proxyWriter, FieldWriter proxyField
           ProvisionBinding provisionBinding = (ProvisionBinding) contributionBinding;
           if (provisionBinding.factoryCreationStrategy().equals(ENUM_INSTANCE)
               && !provisionBinding.scope().isPresent()) {
+            enumBindingKeysBuilder.add(bindingKey);
             // skip keys whose factories are enum instances and aren't scoped
-            memberSelectSnippetsBuilder.put(bindingKey, Snippet.format("%s.INSTANCE",
+            memberSelectSnippetsBuilder.put(bindingKey, Snippet.format("%s.create()",
                     factoryNameForProvisionBinding(provisionBinding)));
             continue;
           }
@@ -344,6 +344,7 @@ static ProxyClassAndField create(ClassWriter proxyWriter, FieldWriter proxyField
     ImmutableMap<BindingKey, Snippet> memberSelectSnippets = memberSelectSnippetsBuilder.build();
     ImmutableMap<ContributionBinding, Snippet> multibindingContributionSnippets =
         multibindingContributionSnippetsBuilder.build();
+    ImmutableSet<BindingKey> enumBindingKeys = enumBindingKeysBuilder.build();
 
     List<List<BindingKey>> partitions = Lists.partition(
         input.resolvedBindings().keySet().asList(), 100);
@@ -442,21 +443,44 @@ static ProxyClassAndField create(ClassWriter proxyWriter, FieldWriter proxyField
             interfaceMethod.annotate(Override.class);
             interfaceMethod.addModifiers(PUBLIC);
             BindingKey bindingKey = BindingKey.forDependencyRequest(interfaceRequest);
-            if (interfaceRequest.kind().equals(MEMBERS_INJECTOR)) {
-              Snippet membersInjectorName = memberSelectSnippets.get(bindingKey);
-              VariableElement parameter = Iterables.getOnlyElement(requestElement.getParameters());
-              Name parameterName = parameter.getSimpleName();
-              interfaceMethod.addParameter(
-                  TypeNames.forTypeMirror(parameter.asType()), parameterName.toString());
-              interfaceMethod.body()
-                  .addSnippet("%s.injectMembers(%s);", membersInjectorName, parameterName);
-              if (!requestElement.getReturnType().getKind().equals(VOID)) {
-                interfaceMethod.body().addSnippet("return %s;", parameterName);
-              }
-            } else {
-              interfaceMethod.body().addSnippet("return %s;",
-                  frameworkTypeUsageStatement(memberSelectSnippets.get(bindingKey),
-                      interfaceRequest.kind()));
+            switch(interfaceRequest.kind()) {
+              case MEMBERS_INJECTOR:
+                Snippet membersInjectorName = memberSelectSnippets.get(bindingKey);
+                VariableElement parameter = Iterables.getOnlyElement(requestElement.getParameters());
+                Name parameterName = parameter.getSimpleName();
+                interfaceMethod.addParameter(
+                    TypeNames.forTypeMirror(parameter.asType()), parameterName.toString());
+                interfaceMethod.body()
+                    .addSnippet("%s.injectMembers(%s);", membersInjectorName, parameterName);
+                if (!requestElement.getReturnType().getKind().equals(VOID)) {
+                  interfaceMethod.body().addSnippet("return %s;", parameterName);
+                }
+                break;
+              case INSTANCE:
+                if (enumBindingKeys.contains(bindingKey)
+                    && !MoreTypes.asDeclared(bindingKey.key().type())
+                            .getTypeArguments().isEmpty()) {
+                  // If using a parameterized enum type, then we need to store the factory
+                  // in a temporary variable, in order to help javac be able to infer
+                  // the generics of the Factory.create methods.
+                  TypeName factoryType = ParameterizedTypeName.create(Provider.class,
+                      TypeNames.forTypeMirror(requestElement.getReturnType()));
+                  interfaceMethod.body().addSnippet("%s factory = %s;", factoryType,
+                      memberSelectSnippets.get(bindingKey));
+                  interfaceMethod.body().addSnippet("return factory.get();");
+                  break;
+                }
+                // fall through in the else case.
+              case LAZY:
+              case PRODUCED:
+              case PRODUCER:
+              case PROVIDER:
+                interfaceMethod.body().addSnippet("return %s;",
+                    frameworkTypeUsageStatement(memberSelectSnippets.get(bindingKey),
+                        interfaceRequest.kind()));
+                break;
+              default:
+                throw new AssertionError();
             }
       }
     }
@@ -559,12 +583,13 @@ private Snippet initializeFactoryForBinding(ProvisionBinding binding,
       ImmutableMap<ExecutableElement, TypeElement> dependencyMethodIndex,
       Map<TypeElement, FieldWriter> contributionFields,
       ImmutableMap<BindingKey, Snippet> memberSelectSnippets) {
-    if (binding.bindingKind().equals(COMPONENT)) {
-      return Snippet.format("%s.<%s>create(this)",
-          ClassName.fromClass(InstanceFactory.class),
-          TypeNames.forTypeMirror(binding.key().type()));
-    } else if (binding.bindingKind().equals(COMPONENT_PROVISION)) {
-      return Snippet.format(Joiner.on('\n').join(
+    switch(binding.bindingKind()) {
+      case COMPONENT:
+        return Snippet.format("%s.<%s>create(this)",
+            ClassName.fromClass(InstanceFactory.class),
+            TypeNames.forTypeMirror(binding.key().type()));
+      case COMPONENT_PROVISION:
+        return Snippet.format(Joiner.on('\n').join(
           "new %s<%2$s>() {",
           "  @Override public %2$s get() {",
           "    return %3$s.%4$s();",
@@ -574,33 +599,44 @@ private Snippet initializeFactoryForBinding(ProvisionBinding binding,
           TypeNames.forTypeMirror(binding.key().type()),
           contributionFields.get(dependencyMethodIndex.get(binding.bindingElement())).name(),
           binding.bindingElement().getSimpleName().toString());
-    } else {
-      if (binding.bindingKind().equals(INJECTION) && binding.implicitDependencies().isEmpty()) {
-        return binding.scope().isPresent()
-            ? Snippet.format("%s.create(%s.INSTANCE)",
-                ClassName.fromClass(ScopedProvider.class),
-                factoryNameForProvisionBinding(binding))
-            : Snippet.format("%s.INSTANCE",
-                factoryNameForProvisionBinding(binding));
-      }
-      List<Snippet> parameters = Lists.newArrayListWithCapacity(binding.dependencies().size() + 1);
-      if (binding.bindingKind().equals(PROVISION)) {
-        parameters.add(Snippet.format(contributionFields.get(binding.bindingTypeElement()).name()));
-      }
-      if (binding.memberInjectionRequest().isPresent()) {
-        parameters.add(memberSelectSnippets.get(BindingKey.forDependencyRequest(
-            binding.memberInjectionRequest().get())));
-      }
-      parameters.addAll(getDependencyParameters(binding.dependencies(), memberSelectSnippets));
-
-      return binding.scope().isPresent()
-          ? Snippet.format("%s.create(new %s(%s))",
-              ClassName.fromClass(ScopedProvider.class),
-              factoryNameForProvisionBinding(binding),
-              Snippet.makeParametersSnippet(parameters))
-          : Snippet.format("new %s(%s)",
-              factoryNameForProvisionBinding(binding),
-              Snippet.makeParametersSnippet(parameters));
+      case INJECTION:
+      case PROVISION:
+        List<Snippet> parameters =
+            Lists.newArrayListWithCapacity(binding.dependencies().size() + 1);
+        if (binding.bindingKind().equals(PROVISION)) {
+          parameters.add(
+              Snippet.format(contributionFields.get(binding.bindingTypeElement()).name()));
+        }
+        if (binding.memberInjectionRequest().isPresent()) {
+          parameters.add(memberSelectSnippets.get(
+              BindingKey.forDependencyRequest(binding.memberInjectionRequest().get())));
+        }
+        parameters.addAll(getDependencyParameters(binding.dependencies(), memberSelectSnippets));
+
+        if (binding.bindingKind().equals(PROVISION)) {
+          // Factories from @Provides methods don't have .create() methods.
+          return binding.scope().isPresent()
+              ? Snippet.format("%s.create(new %s(%s))",
+                  ClassName.fromClass(ScopedProvider.class),
+                  factoryNameForProvisionBinding(binding),
+                  Snippet.makeParametersSnippet(parameters))
+              : Snippet.format("new %s(%s)",
+                  factoryNameForProvisionBinding(binding),
+                  Snippet.makeParametersSnippet(parameters));
+        } else {
+          // Factories from @Inject classes have .create() methods.
+          return binding.scope().isPresent()
+              ? Snippet.format("%s.create(%s.create(%s))",
+                  ClassName.fromClass(ScopedProvider.class),
+                  factoryNameForProvisionBinding(binding),
+                  Snippet.makeParametersSnippet(parameters))
+              : Snippet.format("%s.create(%s)",
+                  factoryNameForProvisionBinding(binding),
+                  Snippet.makeParametersSnippet(parameters));
+        }
+
+      default:
+        throw new AssertionError();
     }
   }
 
@@ -621,7 +657,7 @@ private static Snippet initializeMembersInjectorForBinding(
       List<Snippet> parameters = getDependencyParameters(
           Sets.union(binding.parentInjectorRequest().asSet(), binding.dependencies()),
           memberSelectSnippets);
-      return Snippet.format("new %s(%s)",
+      return Snippet.format("%s.create(%s)",
           membersInjectorNameForMembersInjectionBinding(binding),
           Snippet.makeParametersSnippet(parameters));
     }
@@ -631,8 +667,8 @@ private static Snippet initializeMembersInjectorForBinding(
       Iterable<DependencyRequest> dependencies,
       ImmutableMap<BindingKey, Snippet> memberSelectSnippets) {
     ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
-    for (BindingKey dependencyKey : SourceFiles.indexDependenciesByKey(dependencies).keySet()) {
-      parameters.add(memberSelectSnippets.get(dependencyKey));
+    for (BindingKey keys : SourceFiles.indexDependenciesByUnresolvedKey(dependencies).values()) {
+      parameters.add(memberSelectSnippets.get(keys));
     }
     return parameters.build();
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index e68ef156a..13ff2a036 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -15,8 +15,9 @@
  */
 package dagger.internal.codegen;
 
+import static javax.tools.Diagnostic.Kind.ERROR;
+
 import com.google.auto.common.BasicAnnotationProcessor;
-import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
 import com.google.auto.service.AutoService;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
@@ -35,8 +36,6 @@
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
-import static javax.tools.Diagnostic.Kind.ERROR;
-
 /**
  * The annotation processor responsible for generating the classes that drive the Dagger 2.0
  * implementation.
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
index ec07d6b4f..e9bad3855 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -15,6 +15,11 @@
  */
 package dagger.internal.codegen;
 
+import static com.google.auto.common.MoreTypes.isTypeOf;
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkState;
+
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Function;
 import com.google.common.base.Optional;
@@ -32,15 +37,11 @@
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 
-import static com.google.auto.common.MoreTypes.isTypeOf;
-import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
-
 /**
  * Represents a request for a key at an injection point. Parameters to {@link Inject} constructors
  * or {@link Provides} methods are examples of key requests.
@@ -77,6 +78,16 @@
       this.keyFactory = keyFactory;
     }
 
+    ImmutableSet<DependencyRequest> forRequiredResolvedVariables(
+        List<? extends VariableElement> variables, List<? extends TypeMirror> resolvedTypes) {
+      checkState(resolvedTypes.size() == variables.size());
+      ImmutableSet.Builder<DependencyRequest> builder = ImmutableSet.builder();
+      for (int i = 0; i < variables.size(); i++) {
+         builder.add(forRequiredResolvedVariable(variables.get(i), resolvedTypes.get(i)));
+      }
+      return builder.build();
+    }
+
     ImmutableSet<DependencyRequest> forRequiredVariables(
         List<? extends VariableElement> variables) {
       return FluentIterable.from(variables)
@@ -106,6 +117,14 @@ DependencyRequest forRequiredVariable(VariableElement variableElement) {
       return newDependencyRequest(variableElement, type, qualifier);
     }
 
+    DependencyRequest forRequiredResolvedVariable(VariableElement variableElement,
+        TypeMirror resolvedType) {
+      checkNotNull(variableElement);
+      checkNotNull(resolvedType);
+      Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(variableElement);
+      return newDependencyRequest(variableElement, resolvedType, qualifier);
+    }
+
     DependencyRequest forComponentProvisionMethod(ExecutableElement provisionMethod) {
       checkNotNull(provisionMethod);
       checkArgument(provisionMethod.getParameters().isEmpty(),
@@ -126,46 +145,57 @@ DependencyRequest forComponentMembersInjectionMethod(ExecutableElement membersIn
           membersInjectionMethod);
     }
 
-    DependencyRequest forMembersInjectedType(TypeElement type) {
+    DependencyRequest forMembersInjectedType(DeclaredType type) {
       return new AutoValue_DependencyRequest(Kind.MEMBERS_INJECTOR,
-          keyFactory.forMembersInjectedType(type.asType()),
-          type);
+          keyFactory.forMembersInjectedType(type),
+          type.asElement());
     }
 
     private DependencyRequest newDependencyRequest(Element requestElement, TypeMirror type,
         Optional<AnnotationMirror> qualifier) {
-      if (isTypeOf(Provider.class, type)) {
-        return new AutoValue_DependencyRequest(Kind.PROVIDER,
-            qualifiedTypeForParameter(qualifier, (DeclaredType) type),
+      KindAndType kindAndType = extractKindAndType(type);
+      if (kindAndType.kind() == Kind.MEMBERS_INJECTOR) {
+        checkArgument(!qualifier.isPresent());
+      }
+      return new AutoValue_DependencyRequest(kindAndType.kind(),
+            keyFactory.forQualifiedType(qualifier, kindAndType.type()),
             requestElement);
+    }
+    
+    @AutoValue
+    static abstract class KindAndType {
+      abstract Kind kind();
+      abstract TypeMirror type();
+    }
+    
+    /**
+     * Extracts the correct requesting type & kind out a request type. For example, if a user
+     * requests Provider<Foo>, this will return Kind.PROVIDER with "Foo".
+     */
+    static KindAndType extractKindAndType(TypeMirror type) {
+      // We must check TYPEVAR explicitly before the below checks because calling
+      // isTypeOf(..) on a TYPEVAR throws an exception (because it can't be
+      // represented as a Class).
+      if (type.getKind().equals(TypeKind.TYPEVAR)) {
+        return new AutoValue_DependencyRequest_Factory_KindAndType(Kind.INSTANCE, type);
+      } else if (isTypeOf(Provider.class, type)) {
+        return new AutoValue_DependencyRequest_Factory_KindAndType(Kind.PROVIDER,
+            Iterables.getOnlyElement(((DeclaredType)type).getTypeArguments()));
       } else if (isTypeOf(Lazy.class, type)) {
-        return new AutoValue_DependencyRequest(Kind.LAZY,
-            qualifiedTypeForParameter(qualifier, (DeclaredType) type),
-            requestElement);
+        return new AutoValue_DependencyRequest_Factory_KindAndType(Kind.LAZY,
+            Iterables.getOnlyElement(((DeclaredType)type).getTypeArguments()));
       } else if (isTypeOf(MembersInjector.class, type)) {
-        checkArgument(!qualifier.isPresent());
-        return new AutoValue_DependencyRequest(Kind.MEMBERS_INJECTOR,
-            qualifiedTypeForParameter(qualifier, (DeclaredType) type),
-            requestElement);
+        return new AutoValue_DependencyRequest_Factory_KindAndType(Kind.MEMBERS_INJECTOR,
+            Iterables.getOnlyElement(((DeclaredType)type).getTypeArguments()));
       } else if (isTypeOf(Producer.class, type)) {
-        return new AutoValue_DependencyRequest(Kind.PRODUCER,
-            qualifiedTypeForParameter(qualifier, (DeclaredType) type),
-            requestElement);
+        return new AutoValue_DependencyRequest_Factory_KindAndType(Kind.PRODUCER,
+            Iterables.getOnlyElement(((DeclaredType)type).getTypeArguments()));
       } else if (isTypeOf(Produced.class, type)) {
-        return new AutoValue_DependencyRequest(Kind.PRODUCED,
-            qualifiedTypeForParameter(qualifier, (DeclaredType) type),
-            requestElement);
+        return new AutoValue_DependencyRequest_Factory_KindAndType(Kind.PRODUCED,
+            Iterables.getOnlyElement(((DeclaredType)type).getTypeArguments()));
       } else {
-        return new AutoValue_DependencyRequest(Kind.INSTANCE,
-            keyFactory.forQualifiedType(qualifier, type),
-            requestElement);
+        return new AutoValue_DependencyRequest_Factory_KindAndType(Kind.INSTANCE, type);
       }
     }
-
-    private Key qualifiedTypeForParameter(
-        Optional<AnnotationMirror> qualifier, DeclaredType type) {
-      return keyFactory.forQualifiedType(qualifier,
-          Iterables.getOnlyElement(type.getTypeArguments()));
-    }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index 2cb303478..e76a01709 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -68,9 +68,6 @@
       "Dagger does not support injection into private constructors";
   static final String INJECT_CONSTRUCTOR_ON_INNER_CLASS =
       "@Inject constructors are invalid on inner classes";
-  static final String INJECT_CONSTRUCTOR_ON_GENERIC_CLASS =
-      "Generic types may not use @Inject constructors. "
-          + "Use a @Provides method to bind the type parameters.";
   static final String INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS =
       "@Inject is nonsense on the constructor of an abstract class";
     static final String QUALIFIER_ON_INJECT_CONSTRUCTOR =
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index 8136c4283..daa71b55a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -15,7 +15,20 @@
  */
 package dagger.internal.codegen;
 
+import static com.google.common.base.Preconditions.checkState;
+import static dagger.Provides.Type.SET;
+import static dagger.internal.codegen.ProvisionBinding.Kind.INJECTION;
+import static dagger.internal.codegen.ProvisionBinding.Kind.PROVISION;
+import static dagger.internal.codegen.SourceFiles.factoryNameForProvisionBinding;
+import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
+import static dagger.internal.codegen.SourceFiles.parameterizedFactoryNameForProvisionBinding;
+import static dagger.internal.codegen.writer.Snippet.makeParametersSnippet;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PUBLIC;
+
 import com.google.auto.common.MoreTypes;
+import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
@@ -34,24 +47,19 @@
 import dagger.internal.codegen.writer.Snippet;
 import dagger.internal.codegen.writer.TypeName;
 import dagger.internal.codegen.writer.TypeNames;
+import dagger.internal.codegen.writer.TypeVariableName;
 import dagger.internal.codegen.writer.TypeWriter;
 import java.util.Collections;
 import java.util.List;
+import java.util.Map;
 import javax.annotation.Generated;
 import javax.annotation.processing.Filer;
 import javax.inject.Inject;
 import javax.lang.model.element.Element;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeParameterElement;
 import javax.lang.model.type.TypeMirror;
 
-import static dagger.Provides.Type.SET;
-import static dagger.internal.codegen.ProvisionBinding.Kind.PROVISION;
-import static dagger.internal.codegen.SourceFiles.factoryNameForProvisionBinding;
-import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
-import static dagger.internal.codegen.writer.Snippet.makeParametersSnippet;
-import static javax.lang.model.element.Modifier.FINAL;
-import static javax.lang.model.element.Modifier.PRIVATE;
-import static javax.lang.model.element.Modifier.PUBLIC;
-
 /**
  * Generates {@link Factory} implementations from {@link ProvisionBinding} instances for
  * {@link Inject} constructors.
@@ -84,6 +92,9 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
 
   @Override
   ImmutableSet<JavaWriter> write(ClassName generatedTypeName, ProvisionBinding binding) {
+    // We don't want to write out resolved bindings -- we want to write out the generic version.
+    checkState(!binding.isResolved());
+
     TypeMirror keyType = binding.provisionType().equals(Type.MAP)
         ? Util.getProvidedValueTypeOfMap(MoreTypes.asDeclared(binding.key().type()))
         : binding.key().type();
@@ -92,15 +103,26 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
 
     final TypeWriter factoryWriter;
     final Optional<ConstructorWriter> constructorWriter;
+    List<TypeVariableName> typeParameters = Lists.newArrayList();
+    for (TypeParameterElement typeParameter : binding.bindingTypeElement().getTypeParameters()) {
+     typeParameters.add(TypeVariableName.fromTypeParameterElement(typeParameter));          
+    }
     switch (binding.factoryCreationStrategy()) {
       case ENUM_INSTANCE:
         EnumWriter enumWriter = writer.addEnum(generatedTypeName.simpleName());
         enumWriter.addConstant("INSTANCE");
         constructorWriter = Optional.absent();
         factoryWriter = enumWriter;
+        // If we have type parameters, then remove the parameters from our providedTypeName,
+        // since we'll be implementing an erased version of it.
+        if (!typeParameters.isEmpty()) {
+          factoryWriter.annotate(SuppressWarnings.class).setValue("rawtypes");
+          providedTypeName = ((ParameterizedTypeName)providedTypeName).type();
+        }
         break;
       case CLASS_CONSTRUCTOR:
         ClassWriter classWriter = writer.addClass(generatedTypeName.simpleName());
+        classWriter.addTypeParameters(typeParameters);
         classWriter.addModifiers(FINAL);
         constructorWriter = Optional.of(classWriter.addConstructor());
         constructorWriter.get().addModifiers(PUBLIC);
@@ -120,11 +142,11 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
 
     factoryWriter.annotate(Generated.class).setValue(ComponentProcessor.class.getName());
     factoryWriter.addModifiers(PUBLIC);
-    factoryWriter.addImplementedType(ParameterizedTypeName.create(
-        ClassName.fromClass(Factory.class),
-        providedTypeName));
+    factoryWriter.addImplementedType(
+        ParameterizedTypeName.create(ClassName.fromClass(Factory.class), providedTypeName));
+    
 
-    MethodWriter getMethodWriter = factoryWriter.addMethod(keyType, "get");
+    MethodWriter getMethodWriter = factoryWriter.addMethod(providedTypeName, "get");
     getMethodWriter.annotate(Override.class);
     getMethodWriter.addModifiers(PUBLIC);
 
@@ -151,6 +173,43 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
           .addSnippet("assert %s != null;", field.name())
           .addSnippet("this.%1$s = %1$s;", field.name());
     }
+    
+    // If constructing a factory for @Inject bindings, we use a static create method
+    // so that generated components can avoid having to refer to the generic types
+    // of the factory.  (Otherwise they may have visibility problems referring to the types.)
+    if (binding.bindingKind().equals(INJECTION)) {
+      // The return type is usually the same as the implementing type, except in the case
+      // of enums with type variables (where we cast).
+      TypeName returnType = ParameterizedTypeName.create(ClassName.fromClass(Factory.class),
+          TypeNames.forTypeMirror(keyType));
+      MethodWriter createMethodWriter = factoryWriter.addMethod(returnType, "create");
+      createMethodWriter.addTypeParameters(typeParameters);
+      createMethodWriter.addModifiers(Modifier.PUBLIC, Modifier.STATIC);
+      Map<String, TypeName> params = constructorWriter.isPresent()
+          ? constructorWriter.get().parameters() : ImmutableMap.<String, TypeName>of();
+      for (Map.Entry<String, TypeName> param : params.entrySet()) {
+        createMethodWriter.addParameter(param.getValue(), param.getKey());      
+      }
+      switch (binding.factoryCreationStrategy()) {
+        case ENUM_INSTANCE:
+          if (typeParameters.isEmpty()) {
+            createMethodWriter.body().addSnippet(" return INSTANCE;");
+          } else {
+            // We use an unsafe cast here because the types are different.
+            // It's safe because the type is never referenced anywhere.
+            createMethodWriter.annotate(SuppressWarnings.class).setValue("unchecked");
+            createMethodWriter.body().addSnippet(" return (Factory) INSTANCE;");
+          }
+          break;
+        case CLASS_CONSTRUCTOR:
+          createMethodWriter.body().addSnippet(" return new %s(%s);",
+              parameterizedFactoryNameForProvisionBinding(binding),
+              Joiner.on(", ").join(params.keySet()));
+          break;
+        default:
+          throw new AssertionError();
+      }
+    }
 
     List<Snippet> parameters = Lists.newArrayList();
     for (DependencyRequest dependency : binding.dependencies()) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
index ed4d2b835..9cda78c50 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
@@ -15,7 +15,13 @@
  */
 package dagger.internal.codegen;
 
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkState;
+
 import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
 import com.google.common.base.Optional;
 import com.google.common.base.Predicate;
 import com.google.common.collect.FluentIterable;
@@ -40,11 +46,6 @@
 import javax.lang.model.util.Types;
 import javax.tools.Diagnostic.Kind;
 
-import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
-import static com.google.common.base.Preconditions.checkState;
-
 /**
  * Maintains the collection of provision bindings from {@link Inject} constructors and members
  * injection bindings from {@link Inject} fields and methods known to the annotation processor.
@@ -62,7 +63,7 @@
   private final MembersInjectionBinding.Factory membersInjectionBindingFactory;
   private final MembersInjectorGenerator membersInjectorGenerator;
 
-  final class BindingsCollection<B extends Binding> {
+  final class BindingsCollection<B extends Binding & ResolvableBinding> {
     private final Map<Key, B> bindingsByKey = Maps.newLinkedHashMap();
     private final Deque<B> bindingsRequiringGeneration = Queues.newArrayDeque();
     private final Set<B> materializedBindings = Sets.newLinkedHashSet();
@@ -71,43 +72,69 @@ void generateBindings(SourceFileGenerator<B> generator) throws SourceFileGenerat
       for (B binding = bindingsRequiringGeneration.poll();
           binding != null;
           binding = bindingsRequiringGeneration.poll()) {
+        checkState(!binding.isResolved());
         generator.generate(binding);
         materializedBindings.add(binding);
       }
     }
 
+    /** Returns a previously cached binding. */
     B getBinding(Key key) {
       return bindingsByKey.get(key);
     }
 
-    B tryMaterializeBinding(B binding) {
-      if (canRegisterBinding(binding)) {
+    /** Caches the binding and pretends a binding is generated without actually generating it. */
+    B pretendBindingGenerated(B binding, ClassName factoryName) {
+      tryToCacheBinding(binding);
+      if (shouldGenerateBinding(binding, factoryName)) {
         materializedBindings.add(binding);
       }
       return binding;
     }
 
-    B tryRegisterBinding(B binding, boolean explicit) {
-      if (canRegisterBinding(binding)) {
+    /** Caches the binding and generates it if it needs generation. */
+    void tryRegisterBinding(B binding, ClassName factoryName, boolean explicit) {
+      tryToCacheBinding(binding);
+      tryToGenerateBinding(binding, factoryName, explicit);
+    }
+    
+    /**
+     * Tries to generate a binding, not generating if it already is generated. For resolved
+     * bindings, this will try to generate the unresolved version of the binding.
+     */
+    void tryToGenerateBinding(B binding, ClassName factoryName, boolean explicit) {
+      if (shouldGenerateBinding(binding, factoryName)) {
         bindingsRequiringGeneration.offer(binding);
         if (!explicit) {
           messager.printMessage(Kind.NOTE, String.format(
-              "Generating a MembersInjector for %s. "
+              "Generating a MembersInjector or Factory for %s. "
                     + "Prefer to run the dagger processor over that class instead.",
-              binding.key().type()));
+              types.erasure(binding.key().type()))); // erasure to strip <T> from msgs.
         }
       }
-      return binding;
     }
-
-    private boolean canRegisterBinding(B binding) {
-      Key key = binding.key();
-      Binding previousValue = bindingsByKey.put(key, binding);
-      checkState(previousValue == null || binding.equals(previousValue),
-          "couldn't register %s. %s was already registered for %s",
-          binding, previousValue, key);
-      return !materializedBindings.contains(binding)
+    
+    /** Returns true if the binding needs to be generated. */
+    private boolean shouldGenerateBinding(B binding, ClassName factoryName) {
+      return !binding.isResolved()
+          && elements.getTypeElement(factoryName.canonicalName()) == null
+          && !materializedBindings.contains(binding)
           && !bindingsRequiringGeneration.contains(binding);
+        
+    }
+
+    /** Caches the binding for future lookups by key. */
+    private void tryToCacheBinding(B binding) {
+      // We only cache resolved bindings or unresolved bindings w/o type arguments.
+      // Unresolved bindings w/ type arguments aren't valid for the object graph.
+      if (binding.isResolved()          
+          || binding.bindingTypeElement().getTypeParameters().isEmpty()) {        
+        Key key = binding.key();
+        Binding previousValue = bindingsByKey.put(key, binding);
+        checkState(previousValue == null || binding.equals(previousValue),
+            "couldn't register %s. %s was already registered for %s",
+            binding, previousValue, key);
+      }
     }
   }
 
@@ -149,25 +176,41 @@ MembersInjectionBinding registerBinding(MembersInjectionBinding binding) {
     return registerBinding(binding, true);
   }
 
+  /**
+   * Registers the binding for generation & later lookup. If the binding is resolved, we also
+   * attempt to register an unresolved version of it.
+   */
   private ProvisionBinding registerBinding(ProvisionBinding binding, boolean explicit) {
     ClassName factoryName = SourceFiles.factoryNameForProvisionBinding(binding);
-    if (elements.getTypeElement(factoryName.canonicalName()) == null) {
-      return provisionBindings.tryRegisterBinding(binding, explicit);
+    provisionBindings.tryRegisterBinding(binding, factoryName, explicit);
+    if (binding.isResolved()) {
+      provisionBindings.tryToGenerateBinding(provisionBindingFactory.unresolve(binding),
+          factoryName, explicit);
     }
     return binding;
   }
 
+  /**
+   * Registers the binding for generation & later lookup. If the binding is resolved, we also
+   * attempt to register an unresolved version of it.
+   */
   private MembersInjectionBinding registerBinding(
       MembersInjectionBinding binding, boolean explicit) {
+    ClassName membersInjectorName =
+        SourceFiles.membersInjectorNameForMembersInjectionBinding(binding);
     if (binding.injectionSites().isEmpty()) {
       // empty members injection bindings are special and don't need source files.
       // so, we just pretend
-      return membersInjectionBindings.tryMaterializeBinding(binding);
-    } else  {
-      ClassName membersInjectorName =
-          SourceFiles.membersInjectorNameForMembersInjectionBinding(binding);
-      if (elements.getTypeElement(membersInjectorName.canonicalName()) == null) {
-        return membersInjectionBindings.tryRegisterBinding(binding, explicit);
+      membersInjectionBindings.pretendBindingGenerated(binding, membersInjectorName);
+      if (binding.isResolved()) {
+        membersInjectionBindings.pretendBindingGenerated(
+            membersInjectionBindingFactory.unresolve(binding), membersInjectorName);
+      }
+    } else {
+      membersInjectionBindings.tryRegisterBinding(binding, membersInjectorName, explicit);
+      if (binding.isResolved()) {
+        membersInjectionBindings.tryToGenerateBinding(
+            membersInjectionBindingFactory.unresolve(binding), membersInjectorName, explicit);
       }
     }
     return binding;
@@ -175,13 +218,14 @@ private MembersInjectionBinding registerBinding(
 
   Optional<ProvisionBinding> getOrFindProvisionBinding(Key key) {
     checkNotNull(key);
-    if (key.qualifier().isPresent()) {
+    if (!key.isValidImplicitProvisionKey(types)) {
       return Optional.absent();
     }
     ProvisionBinding binding = provisionBindings.getBinding(key);
     if (binding != null) {
       return Optional.of(binding);
     }
+    
     // ok, let's see if we can find an @Inject constructor
     TypeElement element = MoreElements.asType(types.asElement(key.type()));
     List<ExecutableElement> constructors =
@@ -198,7 +242,7 @@ private MembersInjectionBinding registerBinding(
         return Optional.absent();
       case 1:
         ProvisionBinding constructorBinding = provisionBindingFactory.forInjectConstructor(
-            Iterables.getOnlyElement(injectConstructors));
+            Iterables.getOnlyElement(injectConstructors), Optional.of(key.type()));
         return Optional.of(registerBinding(constructorBinding, false));
       default:
         throw new IllegalStateException("Found multiple @Inject constructors: "
@@ -214,7 +258,7 @@ MembersInjectionBinding getOrFindMembersInjectionBinding(Key key) {
     if (binding != null) {
       return binding;
     }
-    TypeElement element = MoreElements.asType(types.asElement(key.type()));
-    return registerBinding(membersInjectionBindingFactory.forInjectedType(element), false);
+    return registerBinding(membersInjectionBindingFactory.forInjectedType(
+        MoreTypes.asDeclared(key.type()), Optional.of(key.type())), false);
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectConstructorValidator.java b/compiler/src/main/java/dagger/internal/codegen/InjectConstructorValidator.java
index fb91f3507..8d4be58c8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectConstructorValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectConstructorValidator.java
@@ -15,22 +15,8 @@
  */
 package dagger.internal.codegen;
 
-import com.google.auto.common.MoreElements;
-import com.google.common.base.Predicate;
-import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableSet;
-import java.util.Set;
-import javax.inject.Inject;
-import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.Modifier;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.element.VariableElement;
-import javax.lang.model.util.ElementFilter;
-
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static dagger.internal.codegen.ErrorMessages.INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS;
-import static dagger.internal.codegen.ErrorMessages.INJECT_CONSTRUCTOR_ON_GENERIC_CLASS;
 import static dagger.internal.codegen.ErrorMessages.INJECT_CONSTRUCTOR_ON_INNER_CLASS;
 import static dagger.internal.codegen.ErrorMessages.INJECT_INTO_PRIVATE_CLASS;
 import static dagger.internal.codegen.ErrorMessages.INJECT_ON_PRIVATE_CONSTRUCTOR;
@@ -44,6 +30,19 @@
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.STATIC;
 
+import com.google.auto.common.MoreElements;
+import com.google.common.base.Predicate;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableSet;
+import java.util.Set;
+import javax.inject.Inject;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.util.ElementFilter;
+
 /**
  * A {@link Validator} for {@link Inject} constructors.
  *
@@ -84,10 +83,6 @@
       builder.addItem(INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS, constructorElement);
     }
 
-    if (!enclosingElement.getTypeParameters().isEmpty()) {
-      builder.addItem(INJECT_CONSTRUCTOR_ON_GENERIC_CLASS, constructorElement);
-    }
-
     if (enclosingElement.getNestingKind().isNested()
         && !typeModifiers.contains(STATIC)) {
       builder.addItem(INJECT_CONSTRUCTOR_ON_INNER_CLASS, constructorElement);
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java
index a8cd537f7..faa69dc5f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java
@@ -16,7 +16,8 @@
 package dagger.internal.codegen;
 
 import com.google.auto.common.BasicAnnotationProcessor;
-import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
+import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.SetMultimap;
 import java.lang.annotation.Annotation;
@@ -25,8 +26,9 @@
 import javax.inject.Inject;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementKindVisitor6;
 
 /**
@@ -71,7 +73,7 @@ public void process(SetMultimap<Class<? extends Annotation>, Element> elementsBy
     // TODO(gak): add some error handling for bad source files
     final ImmutableSet.Builder<ProvisionBinding> provisions = ImmutableSet.builder();
     // TODO(gak): instead, we should collect reports by type and check later
-    final ImmutableSet.Builder<TypeElement> membersInjectedTypes = ImmutableSet.builder();
+    final ImmutableSet.Builder<DeclaredType> membersInjectedTypes = ImmutableSet.builder();
 
     for (Element injectElement : elementsByAnnotation.get(Inject.class)) {
       injectElement.accept(
@@ -85,7 +87,8 @@ public Void visitExecutableAsConstructor(
               report.printMessagesTo(messager);
 
               if (report.isClean()) {
-                provisions.add(provisionBindingFactory.forInjectConstructor(constructorElement));
+                provisions.add(provisionBindingFactory.forInjectConstructor(constructorElement,
+                    Optional.<TypeMirror>absent()));
               }
 
               return null;
@@ -98,7 +101,8 @@ public Void visitVariableAsField(VariableElement fieldElement, Void p) {
               report.printMessagesTo(messager);
 
               if (report.isClean()) {
-                membersInjectedTypes.add(MoreElements.asType(fieldElement.getEnclosingElement()));
+                membersInjectedTypes.add(
+                    MoreTypes.asDeclared(fieldElement.getEnclosingElement().asType()));
               }
 
               return null;
@@ -113,7 +117,7 @@ public Void visitExecutableAsMethod(ExecutableElement methodElement, Void p) {
 
               if (report.isClean()) {
                 membersInjectedTypes.add(
-                    MoreElements.asType(methodElement.getEnclosingElement()));
+                    MoreTypes.asDeclared(methodElement.getEnclosingElement().asType()));
               }
 
               return null;
@@ -121,9 +125,9 @@ public Void visitExecutableAsMethod(ExecutableElement methodElement, Void p) {
           }, null);
     }
 
-    for (TypeElement injectedType : membersInjectedTypes.build()) {
-      injectBindingRegistry.registerBinding(
-          membersInjectionBindingFactory.forInjectedType(injectedType));
+    for (DeclaredType injectedType : membersInjectedTypes.build()) {
+      injectBindingRegistry.registerBinding(membersInjectionBindingFactory.forInjectedType(
+          injectedType, Optional.<TypeMirror>absent()));
     }
 
     for (ProvisionBinding binding : provisions.build()) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index 5fff1b8b2..45d8e559e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -15,7 +15,17 @@
  */
 package dagger.internal.codegen;
 
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.codegen.ConfigurationAnnotations.getMapKeys;
+import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
+import static dagger.internal.codegen.Util.unwrapOptionalEquivalence;
+import static dagger.internal.codegen.Util.wrapOptionalInEquivalence;
+import static javax.lang.model.element.ElementKind.METHOD;
+import static javax.lang.model.type.TypeKind.DECLARED;
+
 import com.google.auto.common.AnnotationMirrors;
+import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
@@ -31,7 +41,9 @@
 import javax.inject.Provider;
 import javax.inject.Qualifier;
 import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.PrimitiveType;
@@ -41,16 +53,6 @@
 import javax.lang.model.util.SimpleTypeVisitor6;
 import javax.lang.model.util.Types;
 
-import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
-import static dagger.internal.codegen.ConfigurationAnnotations.getMapKeys;
-import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
-import static dagger.internal.codegen.Util.unwrapOptionalEquivalence;
-import static dagger.internal.codegen.Util.wrapOptionalInEquivalence;
-import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
-import static javax.lang.model.element.ElementKind.METHOD;
-import static javax.lang.model.type.TypeKind.DECLARED;
-
 /**
  * Represents a unique combination of {@linkplain TypeMirror type} and
  * {@linkplain Qualifier qualifier} to which binding can occur.
@@ -85,14 +87,54 @@ TypeMirror type() {
     return wrappedType().get();
   }
 
+  Key withType(TypeMirror newType) {
+    return new AutoValue_Key(wrappedQualifier(), MoreTypes.equivalence().wrap(newType));
+  }
+
   boolean isValidMembersInjectionKey() {
-    return !qualifier().isPresent()
-        && type().accept(new SimpleTypeVisitor6<Boolean, Void>(false) {
-          @Override
-          public Boolean visitDeclared(DeclaredType t, Void p) {
-            return t.getTypeArguments().isEmpty();
+    return !qualifier().isPresent();
+  }
+
+  /**
+   * Returns true if the key is valid as an implicit key (that is, if it's valid for a just-in-time
+   * binding by discovering an {@code @Inject} constructor).
+   */
+  boolean isValidImplicitProvisionKey(final Types types) {
+    // Qualifiers disqualify implicit provisioning.
+    if (qualifier().isPresent()) {
+      return false;
+    }
+
+    return type().accept(new SimpleTypeVisitor6<Boolean, Void>() {
+      @Override protected Boolean defaultAction(TypeMirror e, Void p) {
+        return false; // Only declared types are allowed.
+      }
+
+      @Override public Boolean visitDeclared(DeclaredType type, Void ignored) {
+        // Non-classes or abstract classes aren't allowed.
+        TypeElement element = MoreElements.asType(type.asElement());
+        if (!element.getKind().equals(ElementKind.CLASS)
+            || element.getModifiers().contains(Modifier.ABSTRACT)) {
+          return false;
+        }
+
+        // If the key has type arguments, validate that each type argument is declared.
+        // Otherwise the type argument may be a wildcard (or other type), and we can't
+        // resolve that to actual types.
+        for (TypeMirror arg : type.getTypeArguments()) {
+          if (arg.getKind() != TypeKind.DECLARED) {
+            return false;
           }
-        }, null);
+        }
+
+        // Also validate that the key is not the erasure of a generic type.
+        // If it is, that means the user referred to Foo<T> as just 'Foo',
+        // which we don't allow.  (This is a judgement call -- we *could*
+        // allow it and instantiate the type bounds... but we don't.)
+        return MoreTypes.asDeclared(element.asType()).getTypeArguments().isEmpty()
+            || !types.isSameType(types.erasure(element.asType()), type());
+      }
+    }, null);
   }
 
   @Override
@@ -227,12 +269,7 @@ Key forProducesMethod(ExecutableElement e) {
       }
     }
 
-    Key forInjectConstructor(ExecutableElement e) {
-      checkNotNull(e);
-      checkArgument(e.getKind().equals(CONSTRUCTOR));
-      checkArgument(!getQualifier(e).isPresent());
-      // Must use the enclosing element.  The return type is void for constructors(?!)
-      TypeMirror type = e.getEnclosingElement().asType();
+    Key forInjectConstructorWithResolvedType(TypeMirror type) {
       return new AutoValue_Key(
           Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
           MoreTypes.equivalence().wrap(type));
@@ -245,11 +282,9 @@ Key forComponent(TypeMirror type) {
     }
 
     Key forMembersInjectedType(TypeMirror type) {
-      // TODO(gak): handle the type of the MembersInjection<Foo> field better
-      // (instead of just erasing the key type)
       return new AutoValue_Key(
           Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
-          MoreTypes.equivalence().wrap(types.erasure(normalize(type))));
+          MoreTypes.equivalence().wrap(normalize(type)));
     }
 
     Key forQualifiedType(Optional<AnnotationMirror> qualifier, TypeMirror type) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
index 9fd1e7d4c..90a332301 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
@@ -15,7 +15,12 @@
  */
 package dagger.internal.codegen;
 
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkState;
 import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Function;
 import com.google.common.base.Optional;
@@ -31,16 +36,13 @@
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementKindVisitor6;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
-import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
-import static javax.lang.model.type.TypeKind.NONE;
-
 /**
  * Represents the full members injection of a particular type. This does not pay attention to
  * injected members on supertypes.
@@ -49,7 +51,7 @@
  * @since 2.0
  */
 @AutoValue
-abstract class MembersInjectionBinding extends Binding {
+abstract class MembersInjectionBinding extends Binding implements ResolvableBinding {
   @Override abstract TypeElement bindingElement();
 
   /** The set of individual sites where {@link Inject} is applied. */
@@ -106,25 +108,60 @@ private int targetIndexInEnclosing(InjectionSite injectionSite)  {
       this.dependencyRequestFactory = checkNotNull(dependencyRequestFactory);
     }
 
-    private InjectionSite injectionSiteForInjectMethod(ExecutableElement methodElement) {
+    private InjectionSite injectionSiteForInjectMethod(ExecutableElement methodElement,
+        DeclaredType containingType) {
       checkNotNull(methodElement);
       checkArgument(methodElement.getKind().equals(ElementKind.METHOD));
       checkArgument(isAnnotationPresent(methodElement, Inject.class));
+      ExecutableType resolved =
+          MoreTypes.asExecutable(types.asMemberOf(containingType, methodElement));
       return new AutoValue_MembersInjectionBinding_InjectionSite(InjectionSite.Kind.METHOD,
           methodElement,
-          dependencyRequestFactory.forRequiredVariables(methodElement.getParameters()));
+          dependencyRequestFactory.forRequiredResolvedVariables(
+              methodElement.getParameters(),
+              resolved.getParameterTypes()));
     }
 
-    private InjectionSite injectionSiteForInjectField(VariableElement fieldElement) {
+    private InjectionSite injectionSiteForInjectField(VariableElement fieldElement,
+        DeclaredType containingType) {
       checkNotNull(fieldElement);
       checkArgument(fieldElement.getKind().equals(ElementKind.FIELD));
       checkArgument(isAnnotationPresent(fieldElement, Inject.class));
+      TypeMirror resolved = types.asMemberOf(containingType, fieldElement);
       return new AutoValue_MembersInjectionBinding_InjectionSite(InjectionSite.Kind.FIELD,
           fieldElement,
-          ImmutableSet.of(dependencyRequestFactory.forRequiredVariable(fieldElement)));
+          ImmutableSet.of(
+              dependencyRequestFactory.forRequiredResolvedVariable(fieldElement, resolved)));
+    }
+    
+    
+    /** Returns an unresolved version of this binding. */
+    MembersInjectionBinding unresolve(MembersInjectionBinding binding) {
+      checkState(binding.isResolved());
+      DeclaredType unresolved = MoreTypes.asDeclared(binding.bindingElement().asType());
+      return forInjectedType(unresolved, Optional.<TypeMirror>absent());
     }
 
-    MembersInjectionBinding forInjectedType(TypeElement typeElement) {
+    /**
+     * Returns a MembersInjectionBinding for the given type. If {@code resolvedType} is present,
+     * this will return a {@link ResolvableBinding#isResolved() resolved} binding, with the key &
+     * type resolved to the given type (using {@link Types#asMemberOf(DeclaredType, Element)}).
+     */
+    MembersInjectionBinding forInjectedType(DeclaredType type, Optional<TypeMirror> resolvedType) {
+      boolean isResolved = false;
+      // If the class this is injecting has some type arguments, resolve everything.
+      if (!type.getTypeArguments().isEmpty() && resolvedType.isPresent()) {
+        DeclaredType resolved = MoreTypes.asDeclared(resolvedType.get());
+        // Validate that we're resolving from the correct type.
+        checkState(types.isSameType(types.erasure(resolved), types.erasure(type)),
+            "erased expected type: %s, erased actual type: %s",
+            types.erasure(resolved), types.erasure(type));
+        type = resolved;
+        isResolved = true;
+      }
+      
+      TypeElement typeElement = MoreElements.asType(type.asElement());
+      final DeclaredType resolved = type;
       ImmutableSortedSet.Builder<InjectionSite> injectionSitesBuilder =
           ImmutableSortedSet.orderedBy(INJECTION_ORDERING);
       for (Element enclosedElement : typeElement.getEnclosedElements()) {
@@ -135,14 +172,14 @@ MembersInjectionBinding forInjectedType(TypeElement typeElement) {
                   public Optional<InjectionSite> visitExecutableAsMethod(ExecutableElement e,
                       Void p) {
                     return isAnnotationPresent(e, Inject.class)
-                        ? Optional.of(injectionSiteForInjectMethod(e))
+                        ? Optional.of(injectionSiteForInjectMethod(e, resolved))
                         : Optional.<InjectionSite>absent();
                   }
 
                   @Override
                   public Optional<InjectionSite> visitVariableAsField(VariableElement e, Void p) {
                     return isAnnotationPresent(e, Inject.class)
-                        ? Optional.of(injectionSiteForInjectField(e))
+                        ? Optional.of(injectionSiteForInjectField(e, resolved))
                         : Optional.<InjectionSite>absent();
                   }
                 }, null).asSet());
@@ -157,15 +194,17 @@ MembersInjectionBinding forInjectedType(TypeElement typeElement) {
           })
           .toSet();
 
-      Optional<DependencyRequest> parentInjectorRequest = nonObjectSupertype(typeElement)
-          .transform(new Function<TypeElement, DependencyRequest>() {
-            @Override public DependencyRequest apply(TypeElement input) {
-              return dependencyRequestFactory.forMembersInjectedType(input);
-            }
-          });
+      Optional<DependencyRequest> parentInjectorRequest =
+          MoreTypes.nonObjectSuperclass(types, elements, type)
+              .transform(new Function<DeclaredType, DependencyRequest>() {
+                @Override public DependencyRequest apply(DeclaredType input) {
+                  return dependencyRequestFactory.forMembersInjectedType(input);
+                }
+              });
 
-      Key key = keyFactory.forMembersInjectedType(typeElement.asType());
+      Key key = keyFactory.forMembersInjectedType(type);
       return new AutoValue_MembersInjectionBinding(
+          isResolved,
           key,
           dependencies,
           new ImmutableSet.Builder<DependencyRequest>()
@@ -177,15 +216,5 @@ MembersInjectionBinding forInjectedType(TypeElement typeElement) {
           injectionSites,
           parentInjectorRequest);
     }
-
-    private Optional<TypeElement> nonObjectSupertype(TypeElement type) {
-      TypeMirror superclass = type.getSuperclass();
-      boolean nonObjectSuperclass = !superclass.getKind().equals(NONE)
-          && !types.isSameType(
-              elements.getTypeElement(Object.class.getCanonicalName()).asType(), superclass);
-      return nonObjectSuperclass
-          ? Optional.of(MoreElements.asType(types.asElement(superclass)))
-          : Optional.<TypeElement>absent();
-    }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
index c87f42442..eef8057e1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
@@ -15,7 +15,15 @@
  */
 package dagger.internal.codegen;
 
-import com.google.auto.common.MoreElements;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkState;
+import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
+import static dagger.internal.codegen.SourceFiles.parameterizedMembersInjectorNameForMembersInjectionBinding;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PUBLIC;
+
+import com.google.auto.common.MoreTypes;
 import com.google.common.base.Function;
 import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
@@ -24,6 +32,7 @@
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
+import com.google.common.collect.Lists;
 import dagger.MembersInjector;
 import dagger.internal.codegen.MembersInjectionBinding.InjectionSite;
 import dagger.internal.codegen.writer.ClassName;
@@ -35,22 +44,21 @@
 import dagger.internal.codegen.writer.ParameterizedTypeName;
 import dagger.internal.codegen.writer.Snippet;
 import dagger.internal.codegen.writer.TypeName;
+import dagger.internal.codegen.writer.TypeNames;
+import dagger.internal.codegen.writer.TypeVariableName;
 import dagger.internal.codegen.writer.VoidName;
+import java.util.List;
+import java.util.Map;
 import java.util.Map.Entry;
 import javax.annotation.Generated;
 import javax.annotation.processing.Filer;
 import javax.lang.model.element.Element;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.TypeMirror;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeParameterElement;
+import javax.lang.model.type.DeclaredType;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
-import static com.google.common.base.Preconditions.checkNotNull;
-import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
-import static javax.lang.model.element.Modifier.FINAL;
-import static javax.lang.model.element.Modifier.PRIVATE;
-import static javax.lang.model.element.Modifier.PUBLIC;
-
 /**
  * Generates {@link MembersInjector} implementations from {@link MembersInjectionBinding} instances.
  *
@@ -96,33 +104,42 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
   }
 
   @Override
-  ImmutableSet<JavaWriter> write(ClassName injectorClassName, MembersInjectionBinding binding) {
-    ClassName injectedClassName = ClassName.fromTypeElement(binding.bindingElement());
+  ImmutableSet<JavaWriter> write(ClassName generatedTypeName, MembersInjectionBinding binding) {
+    // We don't want to write out resolved bindings -- we want to write out the generic version.
+    checkState(!binding.isResolved());
 
-    JavaWriter writer = JavaWriter.inPackage(injectedClassName.packageName());
+    TypeName injectedTypeName = TypeNames.forTypeMirror(binding.key().type());
+    JavaWriter writer = JavaWriter.inPackage(generatedTypeName.packageName());
 
-    ClassWriter injectorWriter = writer.addClass(injectorClassName.simpleName());
+    ClassWriter injectorWriter = writer.addClass(generatedTypeName.simpleName());
+    List<TypeVariableName> typeParameters = Lists.newArrayList();
+    for (TypeParameterElement typeParameter : binding.bindingTypeElement().getTypeParameters()) {
+      typeParameters.add(TypeVariableName.fromTypeParameterElement(typeParameter));
+    }
+    injectorWriter.addTypeParameters(typeParameters);
     injectorWriter.annotate(Generated.class)
         .setValue(ComponentProcessor.class.getCanonicalName());
     injectorWriter.addModifiers(PUBLIC, FINAL);
-    injectorWriter.addImplementedType(
-        ParameterizedTypeName.create(MembersInjector.class, injectedClassName));
+    TypeName implementedType =
+        ParameterizedTypeName.create(MembersInjector.class, injectedTypeName);
+    injectorWriter.addImplementedType(implementedType);
 
     ConstructorWriter constructorWriter = injectorWriter.addConstructor();
     constructorWriter.addModifiers(PUBLIC);
     MethodWriter injectMembersWriter = injectorWriter.addMethod(VoidName.VOID, "injectMembers");
     injectMembersWriter.addModifiers(PUBLIC);
     injectMembersWriter.annotate(Override.class);
-    injectMembersWriter.addParameter(injectedClassName, "instance");
+    injectMembersWriter.addParameter(injectedTypeName, "instance");
     injectMembersWriter.body().addSnippet(Joiner.on('\n').join(
         "if (instance == null) {",
         "  throw new NullPointerException(\"Cannot inject members into a null reference\");",
         "}"));
 
-    Optional<TypeElement> supertype = supertype(binding.bindingElement());
+    Optional<DeclaredType> supertype =
+        MoreTypes.nonObjectSuperclass(types, elements, MoreTypes.asDeclared(binding.key().type()));
     if (supertype.isPresent()) {
       ParameterizedTypeName supertypeMemebersInjectorType = ParameterizedTypeName.create(
-          MembersInjector.class, ClassName.fromTypeElement(supertype.get()));
+          MembersInjector.class, TypeNames.forTypeMirror(supertype.get()));
       injectorWriter
           .addField(supertypeMemebersInjectorType, "supertypeInjector")
           .addModifiers(PRIVATE, FINAL);
@@ -150,6 +167,21 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
       constructorWriter.body().addSnippet("this.%1$s = %1$s;", field.name());
       dependencyFieldsBuilder.put(fieldEntry.getKey(), field);
     }
+    
+    // We use a static create method so that generated components can avoid having
+    // to refer to the generic types of the factory.
+    // (Otherwise they may have visibility problems referring to the types.)
+    MethodWriter createMethodWriter = injectorWriter.addMethod(implementedType, "create");
+    createMethodWriter.addTypeParameters(typeParameters);
+    createMethodWriter.addModifiers(Modifier.PUBLIC, Modifier.STATIC);
+    Map<String, TypeName> params = constructorWriter.parameters();
+    for (Map.Entry<String, TypeName> param : params.entrySet()) {
+      createMethodWriter.addParameter(param.getValue(), param.getKey());      
+    }
+    createMethodWriter.body().addSnippet("  return new %s(%s);",
+        parameterizedMembersInjectorNameForMembersInjectionBinding(binding),
+        Joiner.on(", ").join(params.keySet()));
+    
     ImmutableMap<BindingKey, FieldWriter> depedencyFields = dependencyFieldsBuilder.build();
     for (InjectionSite injectionSite : binding.injectionSites()) {
       switch (injectionSite.kind()) {
@@ -181,13 +213,4 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
     }
     return ImmutableSet.of(writer);
   }
-
-  private Optional<TypeElement> supertype(TypeElement type) {
-    TypeMirror superclass = type.getSuperclass();
-    boolean nonObjectSuperclass = !types.isSameType(
-        elements.getTypeElement(Object.class.getCanonicalName()).asType(), superclass);
-    return nonObjectSuperclass
-        ? Optional.of(MoreElements.asType(types.asElement(superclass)))
-        : Optional.<TypeElement>absent();
-  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index 99ab9e825..65af997aa 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -15,8 +15,22 @@
  */
 package dagger.internal.codegen;
 
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkState;
+import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
+import static dagger.internal.codegen.InjectionAnnotations.getScopeAnnotation;
+import static dagger.internal.codegen.ProvisionBinding.Kind.INJECTION;
+import static dagger.internal.codegen.Util.unwrapOptionalEquivalence;
+import static dagger.internal.codegen.Util.wrapOptionalInEquivalence;
+import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
+import static javax.lang.model.element.ElementKind.FIELD;
+import static javax.lang.model.element.ElementKind.METHOD;
+
 import com.google.auto.common.AnnotationMirrors;
 import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
 import com.google.common.base.Optional;
@@ -30,20 +44,12 @@
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.ExecutableType;
+import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
-import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
-import static dagger.internal.codegen.InjectionAnnotations.getScopeAnnotation;
-import static dagger.internal.codegen.ProvisionBinding.Kind.INJECTION;
-import static dagger.internal.codegen.Util.unwrapOptionalEquivalence;
-import static dagger.internal.codegen.Util.wrapOptionalInEquivalence;
-import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
-import static javax.lang.model.element.ElementKind.FIELD;
-import static javax.lang.model.element.ElementKind.METHOD;
-
 /**
  * A value object representing the mechanism by which a {@link Key} can be provided. New instances
  * should be created using an instance of the {@link Factory}.
@@ -52,7 +58,7 @@
  * @since 2.0
  */
 @AutoValue
-abstract class ProvisionBinding extends ContributionBinding {
+abstract class ProvisionBinding extends ContributionBinding implements ResolvableBinding {
   @Override
   ImmutableSet<DependencyRequest> implicitDependencies() {
     return new ImmutableSet.Builder<DependencyRequest>()
@@ -122,9 +128,10 @@ BindingType bindingType() {
   }
 
   FactoryCreationStrategy factoryCreationStrategy() {
-    return (bindingKind().equals(INJECTION) && implicitDependencies().isEmpty())
-        ? FactoryCreationStrategy.ENUM_INSTANCE
-        : FactoryCreationStrategy.CLASS_CONSTRUCTOR;
+    return (bindingKind().equals(INJECTION)
+          && implicitDependencies().isEmpty())
+          ? FactoryCreationStrategy.ENUM_INSTANCE
+          : FactoryCreationStrategy.CLASS_CONSTRUCTOR;
   }
 
   static final class Factory {
@@ -140,20 +147,55 @@ FactoryCreationStrategy factoryCreationStrategy() {
       this.keyFactory = keyFactory;
       this.dependencyRequestFactory = dependencyRequestFactory;
     }
+    
+    
+    /** Returns an unresolved version of this binding. */
+    ProvisionBinding unresolve(ProvisionBinding binding) {
+      checkState(binding.isResolved());
+      return forInjectConstructor((ExecutableElement) binding.bindingElement(),
+          Optional.<TypeMirror>absent());
+    }
 
-    ProvisionBinding forInjectConstructor(ExecutableElement constructorElement) {
+    /**
+     * Returns a ProvisionBinding for the given element. If {@code resolvedType} is present, this
+     * will return a {@link ResolvableBinding#isResolved() resolved} binding, with the key & type
+     * resolved to the given type (using {@link Types#asMemberOf(DeclaredType, Element)}).
+     */
+    ProvisionBinding forInjectConstructor(ExecutableElement constructorElement,
+        Optional<TypeMirror> resolvedType) {
       checkNotNull(constructorElement);
       checkArgument(constructorElement.getKind().equals(CONSTRUCTOR));
       checkArgument(isAnnotationPresent(constructorElement, Inject.class));
-      Key key = keyFactory.forInjectConstructor(constructorElement);
+      checkArgument(!getQualifier(constructorElement).isPresent());
+
+      boolean isResolved = false;
+      ExecutableType cxtorType = MoreTypes.asExecutable(constructorElement.asType());
+      DeclaredType enclosingCxtorType =
+          MoreTypes.asDeclared(constructorElement.getEnclosingElement().asType());
+      // If the class this is constructing has some type arguments, resolve everything.
+      if (!enclosingCxtorType.getTypeArguments().isEmpty() && resolvedType.isPresent()) {
+        DeclaredType resolved = MoreTypes.asDeclared(resolvedType.get());
+        // Validate that we're resolving from the correct type.
+        checkState(types.isSameType(types.erasure(resolved), types.erasure(enclosingCxtorType)),
+            "erased expected type: %s, erased actual type: %s",
+            types.erasure(resolved), types.erasure(enclosingCxtorType));
+        cxtorType = MoreTypes.asExecutable(types.asMemberOf(resolved, constructorElement));
+        enclosingCxtorType = resolved;
+        isResolved = true;
+      }
+
+      Key key = keyFactory.forInjectConstructorWithResolvedType(enclosingCxtorType);
       checkArgument(!key.qualifier().isPresent());
       ImmutableSet<DependencyRequest> dependencies =
-          dependencyRequestFactory.forRequiredVariables(constructorElement.getParameters());
-      Optional<DependencyRequest> membersInjectionRequest = membersInjectionRequest(
-          MoreElements.asType(constructorElement.getEnclosingElement()));
+          dependencyRequestFactory.forRequiredResolvedVariables(constructorElement.getParameters(),
+              cxtorType.getParameterTypes());
+      Optional<DependencyRequest> membersInjectionRequest =
+          membersInjectionRequest(enclosingCxtorType);
       Optional<AnnotationMirror> scope =
           getScopeAnnotation(constructorElement.getEnclosingElement());
+
       return new AutoValue_ProvisionBinding(
+          isResolved,
           key,
           constructorElement,
           dependencies,
@@ -167,12 +209,13 @@ ProvisionBinding forInjectConstructor(ExecutableElement constructorElement) {
     private static final ImmutableSet<ElementKind> MEMBER_KINDS =
         Sets.immutableEnumSet(METHOD, FIELD);
 
-    private Optional<DependencyRequest> membersInjectionRequest(TypeElement type) {
+    private Optional<DependencyRequest> membersInjectionRequest(DeclaredType type) {
+      TypeElement typeElement = MoreElements.asType(type.asElement());
       if (!types.isSameType(elements.getTypeElement(Object.class.getCanonicalName()).asType(),
-          type.getSuperclass())) {
+          typeElement.getSuperclass())) {
         return Optional.of(dependencyRequestFactory.forMembersInjectedType(type));
       }
-      for (Element enclosedElement : type.getEnclosedElements()) {
+      for (Element enclosedElement : typeElement.getEnclosedElements()) {
         if (MEMBER_KINDS.contains(enclosedElement.getKind())
             && (isAnnotationPresent(enclosedElement, Inject.class))) {
           return Optional.of(dependencyRequestFactory.forMembersInjectedType(type));
@@ -191,6 +234,7 @@ ProvisionBinding forProvidesMethod(ExecutableElement providesMethod) {
           dependencyRequestFactory.forRequiredVariables(providesMethod.getParameters());
       Optional<AnnotationMirror> scope = getScopeAnnotation(providesMethod);
       return new AutoValue_ProvisionBinding(
+          false /* not resolved */,
           key,
           providesMethod,
           dependencies,
@@ -208,6 +252,7 @@ ProvisionBinding forImplicitMapBinding(DependencyRequest explicitRequest,
       ImmutableSet<DependencyRequest> dependencies = ImmutableSet.of(implicitRequest);
       Optional<AnnotationMirror> scope = getScopeAnnotation(implicitRequest.requestElement());
       return new AutoValue_ProvisionBinding(
+          false /* not resolved */,
           explicitRequest.key(),
           implicitRequest.requestElement(),
           dependencies,
@@ -223,6 +268,7 @@ ProvisionBinding forComponent(TypeElement componentDefinitionType) {
       Component componentAnnotation = componentDefinitionType.getAnnotation(Component.class);
       checkArgument(componentAnnotation != null);
       return new AutoValue_ProvisionBinding(
+          false /* not resolved */,
           keyFactory.forComponent(componentDefinitionType.asType()),
           componentDefinitionType,
           ImmutableSet.<DependencyRequest>of(),
@@ -239,6 +285,7 @@ ProvisionBinding forComponentMethod(ExecutableElement componentMethod) {
       checkArgument(componentMethod.getParameters().isEmpty());
       Optional<AnnotationMirror> scope = getScopeAnnotation(componentMethod);
       return new AutoValue_ProvisionBinding(
+          false /* not resolved */,
           keyFactory.forComponentMethod(componentMethod),
           componentMethod,
           ImmutableSet.<DependencyRequest>of(),
diff --git a/compiler/src/main/java/dagger/internal/codegen/ResolvableBinding.java b/compiler/src/main/java/dagger/internal/codegen/ResolvableBinding.java
new file mode 100644
index 000000000..7dc52f78b
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ResolvableBinding.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+/**
+ * A Binding that can be resolved at request time. For example, a ProvisionBinding for
+ * {@code List<T>} might be resolved to {@code List<Foo>} or {@code List<Bar>}
+ * depending on how it's requested.
+ */
+interface ResolvableBinding {  
+  /**
+   * True if this represents a binding that refers to a type with parameters, and the
+   * parameters have been resolved based on a requesting key.
+   */
+  boolean isResolved();
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index fe87c5306..3b55716ad 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -13,6 +13,9 @@
  */
 package dagger.internal.codegen;
 
+import static com.google.common.base.CaseFormat.UPPER_CAMEL;
+import static com.google.common.base.Preconditions.checkState;
+
 import com.google.common.base.CaseFormat;
 import com.google.common.collect.ComparisonChain;
 import com.google.common.collect.FluentIterable;
@@ -20,18 +23,22 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Iterables;
+import com.google.common.collect.Maps;
 import com.google.common.collect.Ordering;
 import dagger.internal.DoubleCheckLazy;
+import dagger.internal.codegen.ContributionBinding.BindingType;
 import dagger.internal.codegen.writer.ClassName;
+import dagger.internal.codegen.writer.ParameterizedTypeName;
 import dagger.internal.codegen.writer.Snippet;
+import dagger.internal.codegen.writer.TypeName;
+import dagger.internal.codegen.writer.TypeNames;
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.Map;
 import java.util.Map.Entry;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
-
-import static com.google.common.base.CaseFormat.UPPER_CAMEL;
+import javax.lang.model.type.TypeMirror;
 
 /**
  * Utilities for generating files.
@@ -58,6 +65,49 @@ public int compare(DependencyRequest left, DependencyRequest right) {
     }
   };
 
+  /**
+   * A variant of {@link #indexDependenciesByKey} that maps from unresolved keys
+   * to resolved keys.  This is used when generating component's initialize()
+   * methods (and in members injectors) in order to instantiate dependent
+   * providers.  Consider a generic type of {@code Foo<T>} with a constructor
+   * of {@code Foo(T t, T t1, A a, A a1)}.  That will be collapsed to a factory
+   * taking a {@code Provider<T> tProvider, Provider<A> aProvider}. However,
+   * if it was referenced as {@code Foo<A>}, we need to make sure we still
+   * pass two providers.  Naively (if we just referenced by resolved BindingKey),
+   * we would have passed a single {@code aProvider}.
+   */
+  static ImmutableMap<BindingKey, BindingKey> indexDependenciesByUnresolvedKey(
+      Iterable<? extends DependencyRequest> dependencies) {
+    // We expect some duplicates while building, so not using ImmutableMap
+    Map<BindingKey, BindingKey> map = Maps.newLinkedHashMap();
+    for (DependencyRequest dependency : dependencies) {
+      BindingKey resolved = BindingKey.forDependencyRequest(dependency);
+      // To get the proper unresolved type, we have to extract the proper type from the
+      // request type again (because we're looking at the actual element's type).
+      TypeMirror unresolvedType =
+          DependencyRequest.Factory.extractKindAndType(dependency.requestElement().asType()).type();
+      BindingKey unresolved =
+          BindingKey.create(resolved.kind(), resolved.key().withType(unresolvedType));
+      BindingKey existingEntry = map.get(unresolved);
+      if (existingEntry == null) {
+        map.put(unresolved, resolved);
+      } else {
+        // If the entry exists in the map, it *must* be with the same resolved
+        // value.  Otherwise we have an unresolved key mapping to two different
+        // resolved keys!
+        checkState(existingEntry.equals(resolved));
+      }
+    }
+    return ImmutableMap.copyOf(map);
+  }
+
+  /**
+   * Allows dependency requests to be grouped by the key they're requesting.
+   * This is used by factory generation in order to minimize the number of parameters
+   * required in the case where a given key is requested more than once.  This expects
+   * unresolved dependency requests, otherwise we may generate factories based on
+   * a particular usage of a class as opposed to the generic types of the class.
+   */
   static ImmutableSetMultimap<BindingKey, DependencyRequest> indexDependenciesByKey(
       Iterable<? extends DependencyRequest> dependencies) {
     ImmutableSetMultimap.Builder<BindingKey, DependencyRequest> dependenciesByKeyBuilder =
@@ -153,6 +203,26 @@ static ClassName factoryNameForProvisionBinding(ProvisionBinding binding) {
     }
   }
 
+  /**
+   * Returns the factory name parameterized with the ProvisionBinding's parameters (if necessary).
+   */
+  static TypeName parameterizedFactoryNameForProvisionBinding(
+      ProvisionBinding binding) {
+    ClassName factoryName = factoryNameForProvisionBinding(binding);
+    // Only parameterize injection unique bindings.
+    // Other kinds generate unique factories that have no type parameters.
+    if (binding.bindingType() == BindingType.UNIQUE
+        && binding.bindingKind() == ProvisionBinding.Kind.INJECTION) {
+      TypeName bindingName = TypeNames.forTypeMirror(binding.key().type());
+      // If the binding is parameterized, parameterize the factory.
+      if (bindingName instanceof ParameterizedTypeName) {
+        return ParameterizedTypeName.create(factoryName,
+            ((ParameterizedTypeName) bindingName).parameters());
+      }
+    }
+    return factoryName;
+  }
+
   static ClassName factoryNameForProductionBinding(ProductionBinding binding) {
     TypeElement enclosingTypeElement = binding.bindingTypeElement();
     ClassName enclosingClassName = ClassName.fromTypeElement(enclosingTypeElement);
@@ -165,6 +235,21 @@ static ClassName factoryNameForProductionBinding(ProductionBinding binding) {
         throw new AssertionError();
     }
   }
+  
+  /**
+   * Returns the members injector's name parameterized with the binding's parameters (if necessary).
+   */
+  static TypeName parameterizedMembersInjectorNameForMembersInjectionBinding(
+      MembersInjectionBinding binding) {
+    ClassName factoryName = membersInjectorNameForMembersInjectionBinding(binding);
+    TypeName bindingName = TypeNames.forTypeMirror(binding.key().type());
+    // If the binding is parameterized, parameterize the MembersInjector.
+    if (bindingName instanceof ParameterizedTypeName) {
+      return ParameterizedTypeName.create(factoryName,
+          ((ParameterizedTypeName) bindingName).parameters());
+    }
+    return factoryName;
+  }
 
   static ClassName membersInjectorNameForMembersInjectionBinding(MembersInjectionBinding binding) {
     ClassName injectedClassName = ClassName.fromTypeElement(binding.bindingElement());
diff --git a/compiler/src/test/java/dagger/internal/codegen/BindingFieldTest.java b/compiler/src/test/java/dagger/internal/codegen/BindingFieldTest.java
index f18e90b0a..3dd73fc01 100644
--- a/compiler/src/test/java/dagger/internal/codegen/BindingFieldTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/BindingFieldTest.java
@@ -15,6 +15,8 @@
  */
 package dagger.internal.codegen;
 
+import static com.google.common.truth.Truth.assertThat;
+
 import com.google.common.collect.Iterables;
 import com.google.testing.compile.CompilationRule;
 import dagger.MembersInjector;
@@ -35,8 +37,6 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assertThat;
-
 /**
  * Test case for {@link FrameworkField}.
  */
@@ -61,7 +61,8 @@ private ExecutableElement getXConstructor() {
   }
 
   @Test public void frameworkType() {
-    Key key = keyFactory.forInjectConstructor(getXConstructor());
+    Key key = keyFactory.forInjectConstructorWithResolvedType(
+        getXConstructor().getEnclosingElement().asType());
     TypeName xClass = TypeNames.forTypeMirror(key.type());
     assertThat(FrameworkField.createWithTypeFromKey(Provider.class,
             BindingKey.create(BindingKey.Kind.CONTRIBUTION, key), "test")
@@ -76,7 +77,8 @@ private ExecutableElement getXConstructor() {
   }
 
   @Test public void nameSuffix() {
-    Key key = keyFactory.forInjectConstructor(getXConstructor());
+    Key key = keyFactory.forInjectConstructorWithResolvedType(
+        getXConstructor().getEnclosingElement().asType());
     assertThat(FrameworkField.createWithTypeFromKey(Provider.class,
             BindingKey.create(BindingKey.Kind.CONTRIBUTION, key), "foo").name())
         .isEqualTo("fooProvider");
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index ec07c0984..264e24bda 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -15,17 +15,18 @@
  */
 package dagger.internal.codegen;
 
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+
 import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.JavaFileObjects;
 import javax.tools.JavaFileObject;
+import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assertAbout;
-import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
-
 @RunWith(JUnit4.class)
 public class ComponentProcessorTest {
   @Test public void componentOnConcreteClass() {
@@ -138,17 +139,17 @@
         "",
         "  @Override",
         "  public SomeInjectableType someInjectableType() {",
-        "    return SomeInjectableType$$Factory.INSTANCE.get();",
+        "    return SomeInjectableType$$Factory.create().get();",
         "  }",
         "",
         "  @Override",
         "  public Lazy<SomeInjectableType> lazySomeInjectableType() {",
-        "    return DoubleCheckLazy.create(SomeInjectableType$$Factory.INSTANCE);",
+        "    return DoubleCheckLazy.create(SomeInjectableType$$Factory.create());",
         "  }",
         "",
         "  @Override",
         "  public Provider<SomeInjectableType> someInjectableTypeProvider() {",
-        "    return SomeInjectableType$$Factory.INSTANCE;",
+        "    return SomeInjectableType$$Factory.create();",
         "  }",
         "",
         "  public static final class Builder {",
@@ -221,7 +222,7 @@
         "",
         "  private void initialize() {",
         "    this.someInjectableTypeProvider =",
-        "        ScopedProvider.create(SomeInjectableType$$Factory.INSTANCE);",
+        "        ScopedProvider.create(SomeInjectableType$$Factory.create());",
         "  }",
         "",
         "  @Override",
@@ -273,48 +274,6 @@
         "    void inject(B b);",
         "  }",
         "}");
-    JavaFileObject aFactory = JavaFileObjects.forSourceLines(
-        "test.OuterType$A$$Factory",
-        "package test;",
-        "",
-        "import dagger.Factory;",
-        "import javax.annotation.Generated;",
-        "import test.OuterType.A;",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public enum OuterType$A$$Factory implements Factory<A> {",
-        "  INSTANCE;",
-        "",
-        "  @Override public A get() {",
-        "    return new A();",
-        "  }",
-        "}");
-    JavaFileObject bMembersInjector = JavaFileObjects.forSourceLines(
-        "test.OuterType$B$$MembersInjector",
-        "package test;",
-        "",
-        "import dagger.MembersInjector;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "import test.OuterType.A;",
-        "import test.OuterType.B;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class OuterType$B$$MembersInjector implements MembersInjector<B> {",
-        "  private final Provider<A> aProvider;",
-        "",
-        "  public OuterType$B$$MembersInjector(Provider<A> aProvider) {",
-        "    assert aProvider != null;",
-        "    this.aProvider = aProvider;",
-        "  }",
-         "",
-        "  @Override",
-        "  public void injectMembers(B instance) {",
-        "    if (instance == null) {",
-        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
-        "    }",
-        "    instance.a = aProvider.get();",
-        "  }",
-        "}");
 
     JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
         "test.Dagger_OuterType_SimpleComponent",
@@ -345,12 +304,12 @@
         "",
         "  private void initialize() {",
         "    this.bMembersInjector =",
-        "        new OuterType$B$$MembersInjector(OuterType$A$$Factory.INSTANCE);",
+        "        OuterType$B$$MembersInjector.create(OuterType$A$$Factory.create());",
         "  }",
         "",
         "  @Override",
         "  public A a() {",
-        "    return OuterType$A$$Factory.INSTANCE.get();",
+        "    return OuterType$A$$Factory.create().get();",
         "  }",
         "",
         "  @Override",
@@ -370,7 +329,7 @@
     assertAbout(javaSources()).that(ImmutableList.of(nestedTypesFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and().generatesSources(aFactory, bMembersInjector, generatedComponent);
+        .and().generatesSources(generatedComponent);
   }
 
   @Test public void componentWithModule() {
@@ -445,8 +404,8 @@
         "  }",
         "",
         "  private void initialize() {",
-        "    this.bProvider = new TestModule$$BFactory(testModule, C$$Factory.INSTANCE);",
-        "    this.aProvider = new A$$Factory(bProvider);",
+        "    this.bProvider = new TestModule$$BFactory(testModule, C$$Factory.create());",
+        "    this.aProvider = A$$Factory.create(bProvider);",
         "  }",
         "",
         "  @Override",
@@ -759,7 +718,7 @@
         "",
         "  private void initialize() {",
         "    this.someInjectedTypeMembersInjector =",
-        "        new SomeInjectedType$$MembersInjector(SomeInjectableType$$Factory.INSTANCE);",
+        "        SomeInjectedType$$MembersInjector.create(SomeInjectableType$$Factory.create());",
         "  }",
         "",
         "  @Override",
@@ -839,7 +798,7 @@
         "  private void initialize() {",
         "    this.simpleComponentProvider = InstanceFactory.<SimpleComponent>create(this);",
         "    this.someInjectableTypeProvider =",
-        "        new SomeInjectableType$$Factory(simpleComponentProvider);",
+        "        SomeInjectableType$$Factory.create(simpleComponentProvider);",
         "  }",
         "",
         "  @Override",
@@ -917,9 +876,9 @@
         "",
         "  private void initialize() {",
         "    this.someInjectedTypeMembersInjector =",
-        "        new SomeInjectedType$$MembersInjector(SomeInjectableType$$Factory.INSTANCE);",
+        "        SomeInjectedType$$MembersInjector.create(SomeInjectableType$$Factory.create());",
         "    this.someInjectedTypeProvider =",
-        "        new SomeInjectedType$$Factory(someInjectedTypeMembersInjector);",
+        "        SomeInjectedType$$Factory.create(someInjectedTypeMembersInjector);",
         "  }",
         "",
         "  @Override",
@@ -977,7 +936,7 @@
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
         "public final class Dagger_SimpleComponent implements SimpleComponent {",
-        "  private MembersInjector<AbstractGenericType> abstractGenericTypeMembersInjector;",
+        "  private MembersInjector<AbstractGenericType<String>> abstractGenericTypeMembersInjector;",
         "  private MembersInjector<SomeInjectableType> someInjectableTypeMembersInjector;",
         "  private Provider<SomeInjectableType> someInjectableTypeProvider;",
         "",
@@ -999,7 +958,7 @@
         "    this.someInjectableTypeMembersInjector = MembersInjectors.delegatingTo(",
         "        abstractGenericTypeMembersInjector);",
         "    this.someInjectableTypeProvider =",
-        "        new SomeInjectableType$$Factory(someInjectableTypeMembersInjector);",
+        "        SomeInjectableType$$Factory.create(someInjectableTypeMembersInjector);",
         "  }",
         "",
         "  @Override",
@@ -1094,7 +1053,7 @@
         "        return aComponent.a();",
         "      }",
         "    };",
-        "    this.bProvider = new B$$Factory(aProvider);",
+        "    this.bProvider = B$$Factory.create(aProvider);",
         "  }",
         "",
         "  @Override",
@@ -1336,9 +1295,9 @@
         "  }",
         "",
         "  private void initialize() {",
-        "    this.bProvider = new B$$Factory(C$$Factory.INSTANCE);",
-        "    this.aProvider = new A$$Factory(bProvider);",
-        "    this.xProvider = new X$$Factory(C$$Factory.INSTANCE);",
+        "    this.bProvider = B$$Factory.create(C$$Factory.create());",
+        "    this.aProvider = A$$Factory.create(bProvider);",
+        "    this.xProvider = X$$Factory.create(C$$Factory.create());",
         "  }",
         "",
         "  @Override",
@@ -1348,7 +1307,7 @@
         "",
         "  @Override",
         "  public C c() {",
-        "    return C$$Factory.INSTANCE.get();",
+        "    return C$$Factory.create().get();",
         "  }",
         "",
         "  @Override",
@@ -1441,7 +1400,7 @@
         "",
         "  @Override",
         "  public SomeInjectableType someInjectableType() {",
-        "    return SomeInjectableType$$Factory.INSTANCE.get();",
+        "    return SomeInjectableType$$Factory.create().get();",
         "  }",
         "",
         "  public static final class Builder {",
@@ -1529,7 +1488,7 @@
         "",
         "  @Override",
         "  public SomeInjectableType someInjectableType() {",
-        "    return SomeInjectableType$$Factory.INSTANCE.get();",
+        "    return SomeInjectableType$$Factory.create().get();",
         "  }",
         "",
         "  public static final class Builder {",
@@ -1547,4 +1506,230 @@
         .compilesWithoutError()
         .and().generatesSources(generatedComponent);
   }
+  
+  @Test public void wildcardGenericsRequiresAtProvides() {
+    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class A {",
+        "  @Inject A() {}",
+        "}");
+    JavaFileObject bFile = JavaFileObjects.forSourceLines("test.B",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "import javax.inject.Provider;",
+        "",
+        "final class B<T> {",
+        "  @Inject B(T t) {}",
+        "}");
+    JavaFileObject cFile = JavaFileObjects.forSourceLines("test.C",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "import javax.inject.Provider;",
+        "",
+        "final class C {",
+        "  @Inject C(B<? extends A> bA) {}",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Lazy;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface SimpleComponent {",
+        "  C c();",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(aFile, bFile, cFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("test.B cannot be provided without an @Provides-annotated method");
+  }
+  
+  @Test public void arrayGenericsRequiresAtProvides() {
+    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class A {",
+        "  @Inject A() {}",
+        "}");
+    JavaFileObject bFile = JavaFileObjects.forSourceLines("test.B",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "import javax.inject.Provider;",
+        "",
+        "final class B<T> {",
+        "  @Inject B(T t) {}",
+        "}");
+    JavaFileObject cFile = JavaFileObjects.forSourceLines("test.C",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "import javax.inject.Provider;",
+        "",
+        "final class C {",
+        "  @Inject C(B<Object[]> b) {}",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Lazy;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface SimpleComponent {",
+        "  C c();",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(aFile, bFile, cFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("test.B cannot be provided without an @Provides-annotated method");
+  }
+  
+  @Test public void rawTypeGenericsRequiresAtProvides() {
+    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class A {",
+        "  @Inject A() {}",
+        "}");
+    JavaFileObject bFile = JavaFileObjects.forSourceLines("test.B",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "import javax.inject.Provider;",
+        "",
+        "final class B<T> {",
+        "  @Inject B(T t) {}",
+        "}");
+    JavaFileObject cFile = JavaFileObjects.forSourceLines("test.C",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "import javax.inject.Provider;",
+        "",
+        "final class C {",
+        "  @Inject C(B b) {}",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Lazy;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface SimpleComponent {",
+        "  C c();",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(aFile, bFile, cFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("test.B cannot be provided without an @Provides-annotated method");
+  }
+ 
+  @Test
+  @Ignore // modify this test as necessary while debugging for your situation.
+  public void genericTestToLetMeDebugInEclipse() {
+    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+         "import javax.inject.Inject;",
+         "",
+         "public final class A {",
+         "  @Inject A() {}",
+         "}");
+     JavaFileObject bFile = JavaFileObjects.forSourceLines("test.B",
+         "package test;",
+         "",
+         "import javax.inject.Inject;",
+         "import javax.inject.Provider;",
+         "",
+         "public class B<T> {",
+         "  @Inject B() {}",
+         "}");
+     JavaFileObject dFile = JavaFileObjects.forSourceLines("test.sub.D",
+         "package test.sub;",
+         "",
+         "import javax.inject.Inject;",
+         "import javax.inject.Provider;",
+         "import test.B;",
+         "",
+         "public class D {",
+         "  @Inject D(B<A.InA> ba) {}",
+         "}");
+     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+         "package test;",
+         "",
+         "import dagger.Component;",
+         "import dagger.Lazy;",
+         "",
+         "import javax.inject.Provider;",
+         "",
+         "@Component",
+         "interface SimpleComponent {",
+         "  B<A> d();",
+         "  Provider<B<A>> d2();",
+         "}");
+     JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+         "test.Dagger_SimpleComponent",
+         "package test;",
+         "",
+         "import javax.annotation.Generated;",
+         "import javax.inject.Provider;",
+         "",
+         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+         "public final class Dagger_SimpleComponent implements SimpleComponent {",
+         "  private Provider<D> dProvider;",
+         "",
+         "  private Dagger_SimpleComponent(Builder builder) {",
+         "    assert builder != null;",
+         "    initialize();",
+         "  }",
+         "",
+         "  public static Builder builder() {",
+         "    return new Builder();",
+         "  }",
+         "",
+         "  public static SimpleComponent create() {",
+         "    return builder().build();",
+         "  }",
+         "",
+         "  private void initialize() {",
+         "    this.dProvider = new D$$Factory(B$$Factory.INSTANCE);",
+         "  }",
+         "",
+         "  @Override",
+         "  public D d() {",
+         "    return dProvider.get();",
+         "  }",
+         "",
+         "  public static final class Builder {",
+         "    private Builder() {",
+         "    }",
+         "",
+         "    public SimpleComponent build() {",
+         "      return new Dagger_SimpleComponent(this);",
+         "    }",
+         "  }",
+         "}");
+     assertAbout(javaSources()).that(ImmutableList.of(aFile, bFile, componentFile))
+         .processedWith(new ComponentProcessor())
+         .compilesWithoutError()
+         .and().generatesSources(generatedComponent);
+   }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
index cec4b5915..c48d49797 100644
--- a/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
@@ -15,21 +15,13 @@
  */
 package dagger.internal.codegen;
 
-import com.google.common.collect.ImmutableList;
-import com.google.testing.compile.JavaFileObjects;
-import javax.tools.JavaFileObject;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import static com.google.common.truth.Truth.assert_;
+import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.internal.codegen.ErrorMessages.ABSTRACT_INJECT_METHOD;
 import static dagger.internal.codegen.ErrorMessages.FINAL_INJECT_FIELD;
 import static dagger.internal.codegen.ErrorMessages.GENERIC_INJECT_METHOD;
 import static dagger.internal.codegen.ErrorMessages.INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS;
-import static dagger.internal.codegen.ErrorMessages.INJECT_CONSTRUCTOR_ON_GENERIC_CLASS;
 import static dagger.internal.codegen.ErrorMessages.INJECT_CONSTRUCTOR_ON_INNER_CLASS;
 import static dagger.internal.codegen.ErrorMessages.INJECT_ON_PRIVATE_CONSTRUCTOR;
 import static dagger.internal.codegen.ErrorMessages.MULTIPLE_INJECT_CONSTRUCTORS;
@@ -38,6 +30,12 @@
 import static dagger.internal.codegen.ErrorMessages.PRIVATE_INJECT_FIELD;
 import static dagger.internal.codegen.ErrorMessages.PRIVATE_INJECT_METHOD;
 import static dagger.internal.codegen.ErrorMessages.QUALIFIER_ON_INJECT_CONSTRUCTOR;
+import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
 @RunWith(JUnit4.class)
 // TODO(gak): add tests for generation in the default package.
@@ -80,7 +78,7 @@
         "class PrivateConstructor {",
         "  @Inject private PrivateConstructor() {}",
         "}");
-    assert_().about(javaSource()).that(file)
+    assertAbout(javaSource()).that(file)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(INJECT_ON_PRIVATE_CONSTRUCTOR).in(file).onLine(6);
@@ -97,7 +95,7 @@
         "    @Inject InnerClass() {}",
         "  }",
         "}");
-    assert_().about(javaSource()).that(file)
+    assertAbout(javaSource()).that(file)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(INJECT_CONSTRUCTOR_ON_INNER_CLASS).in(file).onLine(7);
@@ -112,7 +110,7 @@
         "abstract class AbstractClass {",
         "  @Inject AbstractClass() {}",
         "}");
-    assert_().about(javaSource()).that(file)
+    assertAbout(javaSource()).that(file)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS).in(file).onLine(6);
@@ -125,12 +123,319 @@
         "import javax.inject.Inject;",
         "",
         "class GenericClass<T> {",
+        "  @Inject GenericClass(T t) {}",
+        "}");
+    JavaFileObject expected = JavaFileObjects.forSourceLines("test.GenericClass$$Factory",
+        "package test;",
+        "",
+        "import dagger.Factory;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class GenericClass$$Factory<T> implements Factory<GenericClass<T>> {",
+        "  private final Provider<T> tProvider;",
+        "",
+        "  public GenericClass$$Factory(Provider<T> tProvider) {",
+        "    assert tProvider != null;",
+        "    this.tProvider = tProvider;",
+        "  }",
+        "",
+        "  @Override",
+        "  public GenericClass<T> get() {",
+        "    return new GenericClass<T>(tProvider.get());",
+        "  }",
+        "",
+        "  public static <T> Factory<GenericClass<T>> create(Provider<T> tProvider) {",
+        "    return new GenericClass$$Factory<T>(tProvider);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(file)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(expected);
+  }
+
+  @Test public void fieldAndMethodGenerics() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.GenericClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class GenericClass<A, B> {",
+        "  @Inject A a;",
+        "",
         "  @Inject GenericClass() {}",
+        "",
+        " @Inject void register(B b) {}",
         "}");
-    assert_().about(javaSource()).that(file)
+    JavaFileObject expected = JavaFileObjects.forSourceLines("test.GenericClass$$Factory",
+        "package test;",
+        "",
+        "import dagger.Factory;",
+        "import dagger.MembersInjector;",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class GenericClass$$Factory<A, B> implements Factory<GenericClass<A, B>> {",
+        "  private final MembersInjector<GenericClass<A, B>> membersInjector;",
+        "",
+        "  public GenericClass$$Factory(MembersInjector<GenericClass<A, B>> membersInjector) {",
+        "    assert membersInjector != null;",
+        "    this.membersInjector = membersInjector;",
+        "  }",
+        "",
+        "  @Override",
+        "  public GenericClass<A, B> get() {",
+        "    GenericClass<A, B> instance = new GenericClass<A, B>();",
+        "    membersInjector.injectMembers(instance);",
+        "    return instance;",
+        "  }",
+        "",
+        "  public static <A, B> Factory<GenericClass<A, B>> create(",
+        "      MembersInjector<GenericClass<A, B>> membersInjector) {",
+        "    return new GenericClass$$Factory<A, B>(membersInjector);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(file)
         .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(INJECT_CONSTRUCTOR_ON_GENERIC_CLASS).in(file).onLine(6);
+        .compilesWithoutError()
+        .and().generatesSources(expected);
+  }
+
+  @Test public void genericClassWithNoDependencies() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.GenericClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class GenericClass<T> {",
+        "  @Inject GenericClass() {}",
+        "}");
+    JavaFileObject expected = JavaFileObjects.forSourceLines("test.GenericClass$$Factory",
+        "package test;",
+        "",
+        "import dagger.Factory;",
+        "import javax.annotation.Generated;",
+        "",
+        "@SuppressWarnings(\"rawtypes\")",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public enum GenericClass$$Factory implements Factory<GenericClass> {",
+        "  INSTANCE;",
+        "",
+        "  @Override",
+        "  public GenericClass get() {",
+        "    return new GenericClass();",
+        "  }",
+        "",
+        "  @SuppressWarnings(\"unchecked\")",
+        "  public static <T> Factory<GenericClass<T>> create() {",
+        "    return (Factory) INSTANCE;",
+        "  }",
+        "",
+        "}");
+    assertAbout(javaSource()).that(file)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(expected);
+  }
+
+  @Test public void twoGenericTypes() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.GenericClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class GenericClass<A, B> {",
+        "  @Inject GenericClass(A a, B b) {}",
+        "}");
+    JavaFileObject expected = JavaFileObjects.forSourceLines("test.GenericClass$$Factory",
+        "package test;",
+        "",
+        "import dagger.Factory;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class GenericClass$$Factory<A, B> implements Factory<GenericClass<A, B>> {",
+        "  private final Provider<A> aProvider;",
+        "  private final Provider<B> bProvider;",
+        "",
+        "  public GenericClass$$Factory(Provider<A> aProvider, Provider<B> bProvider) {",
+        "    assert aProvider != null;",
+        "    this.aProvider = aProvider;",
+        "    assert bProvider != null;",
+        "    this.bProvider = bProvider;",
+        "  }",
+        "",
+        "  @Override",
+        "  public GenericClass<A, B> get() {",
+        "    return new GenericClass<A, B>(aProvider.get(), bProvider.get());",
+        "  }",
+        "",
+        "  public static <A, B> Factory<GenericClass<A, B>> create(",
+        "      Provider<A> aProvider, Provider<B> bProvider) {",
+        "    return new GenericClass$$Factory<A, B>(aProvider, bProvider);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(file)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(expected);
+  }
+  
+  @Test public void boundedGenerics() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.GenericClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "import java.util.List;",
+        "",
+        // TODO(sameb): Use A extends Number & Comparable<A> instead,
+        //     so we test intersection tests.  Unfortunately, that's flaky due to
+        //     some weirdness in which tools processor gets picked up by compile-testing.
+        "class GenericClass<A extends B,",
+        "    B extends List<? extends String>,",
+        "    C extends List<? super String>> {",
+        "  @Inject GenericClass(A a, B b, C c) {}",
+        "}");
+    JavaFileObject expected = JavaFileObjects.forSourceLines("test.GenericClass$$Factory",
+        "package test;",
+        "",
+        "import dagger.Factory;",
+        "import java.util.List;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class GenericClass$$Factory<A extends B,",
+        "        B extends List<? extends String>,",
+        "        C extends List<? super String>>",
+        "    implements Factory<GenericClass<A, B, C>> {",
+        "  private final Provider<A> aProvider;",
+        "  private final Provider<B> bProvider;",
+        "  private final Provider<C> cProvider;",
+        "",
+        "  public GenericClass$$Factory(Provider<A> aProvider,",
+        "      Provider<B> bProvider,",
+        "      Provider<C> cProvider) {",
+        "    assert aProvider != null;",
+        "    this.aProvider = aProvider;",
+        "    assert bProvider != null;",
+        "    this.bProvider = bProvider;",
+        "    assert cProvider != null;",
+        "    this.cProvider = cProvider;",
+        "  }",
+        "",
+        "  @Override",
+        "  public GenericClass<A, B, C> get() {",
+        "    return new GenericClass<A, B, C>(aProvider.get(), bProvider.get(), cProvider.get());",
+        "  }",
+        "",
+        "  public static <A extends B,",
+        "      B extends List<? extends String>,",
+        "      C extends List<? super String>> Factory<GenericClass<A, B, C>> create(",
+        "          Provider<A> aProvider, Provider<B> bProvider, Provider<C> cProvider) {",
+        "    return new GenericClass$$Factory<A, B, C>(aProvider, bProvider, cProvider);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(file)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(expected);
+  }
+
+  @Test public void multipleSameTypesWithGenericsAndQualifiersAndLazies() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.GenericClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "import javax.inject.Provider;",
+        "import dagger.Lazy;",
+        "",
+        "class GenericClass<A, B> {",
+        "  @Inject GenericClass(A a, A a2, Provider<A> pa, @QualifierA A qa, Lazy<A> la, ",
+        "                       String s, String s2, Provider<String> ps, ",
+        "                       @QualifierA String qs, Lazy<String> ls,",
+        "                       B b, B b2, Provider<B> pb, @QualifierA B qb, Lazy<B> lb) {}",
+        "}");
+    JavaFileObject expected = JavaFileObjects.forSourceLines("test.GenericClass$$Factory",
+        "package test;",
+        "",
+        "import dagger.Factory;",
+        "import dagger.internal.DoubleCheckLazy;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class GenericClass$$Factory<A, B> implements Factory<GenericClass<A, B>> {",
+        "  private final Provider<A> aAndA2AndPaAndLaProvider;",
+        "  private final Provider<A> qaProvider;",
+        "  private final Provider<String> sAndS2AndPsAndLsProvider;",
+        "  private final Provider<String> qsProvider;",
+        "  private final Provider<B> bAndB2AndPbAndLbProvider;",
+        "  private final Provider<B> qbProvider;",
+        "",
+        "  public GenericClass$$Factory(Provider<A> aAndA2AndPaAndLaProvider,",
+        "      Provider<A> qaProvider,", 
+        "      Provider<String> sAndS2AndPsAndLsProvider,",
+        "      Provider<String> qsProvider,",
+        "      Provider<B> bAndB2AndPbAndLbProvider,",
+        "      Provider<B> qbProvider) {",
+        "    assert aAndA2AndPaAndLaProvider != null;",
+        "    this.aAndA2AndPaAndLaProvider = aAndA2AndPaAndLaProvider;",
+        "    assert qaProvider != null;",
+        "    this.qaProvider = qaProvider;",
+        "    assert sAndS2AndPsAndLsProvider != null;",
+        "    this.sAndS2AndPsAndLsProvider = sAndS2AndPsAndLsProvider;",
+        "    assert qsProvider != null;",
+        "    this.qsProvider = qsProvider;",
+        "    assert bAndB2AndPbAndLbProvider != null;",
+        "    this.bAndB2AndPbAndLbProvider = bAndB2AndPbAndLbProvider;",
+        "    assert qbProvider != null;",
+        "    this.qbProvider = qbProvider;",
+        "  }",
+        "",
+        "  @Override",
+        "  public GenericClass<A, B> get() {",
+        "    return new GenericClass<A, B>(",
+        "      aAndA2AndPaAndLaProvider.get(),",
+        "      aAndA2AndPaAndLaProvider.get(),",
+        "      aAndA2AndPaAndLaProvider,",
+        "      qaProvider.get(),",
+        "      DoubleCheckLazy.create(aAndA2AndPaAndLaProvider),",
+        "      sAndS2AndPsAndLsProvider.get(),",
+        "      sAndS2AndPsAndLsProvider.get(),",
+        "      sAndS2AndPsAndLsProvider,",
+        "      qsProvider.get(),",
+        "      DoubleCheckLazy.create(sAndS2AndPsAndLsProvider),",
+        "      bAndB2AndPbAndLbProvider.get(),",
+        "      bAndB2AndPbAndLbProvider.get(),", 
+        "      bAndB2AndPbAndLbProvider,",
+        "      qbProvider.get(),",
+        "      DoubleCheckLazy.create(bAndB2AndPbAndLbProvider));",
+        "  }",
+        "",
+        "  public static <A, B> Factory<GenericClass<A, B>> create(",
+        "      Provider<A> aAndA2AndPaAndLaProvider,",
+        "      Provider<A> qaProvider,", 
+        "      Provider<String> sAndS2AndPsAndLsProvider,",
+        "      Provider<String> qsProvider,",
+        "      Provider<B> bAndB2AndPbAndLbProvider,",
+        "      Provider<B> qbProvider) {",
+        "    return new GenericClass$$Factory<A, B>(",
+        "        aAndA2AndPaAndLaProvider,",
+        "        qaProvider,",
+        "        sAndS2AndPsAndLsProvider,",
+        "        qsProvider,",
+        "        bAndB2AndPbAndLbProvider,",
+        "        qbProvider);",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(file, QUALIFIER_A))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(expected);
   }
 
   @Test public void multipleInjectConstructors() {
@@ -144,7 +449,7 @@
         "  TooManyInjectConstructors(int i) {}",
         "  @Inject TooManyInjectConstructors(String s) {}",
         "}");
-    assert_().about(javaSource()).that(file)
+    assertAbout(javaSource()).that(file)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(MULTIPLE_INJECT_CONSTRUCTORS).in(file).onLine(6)
@@ -160,7 +465,7 @@
         "class MultipleQualifierConstructorParam {",
         "  @Inject MultipleQualifierConstructorParam(@QualifierA @QualifierB String s) {}",
         "}");
-    assert_().about(javaSources()).that(ImmutableList.of(file, QUALIFIER_A, QUALIFIER_B))
+    assertAbout(javaSources()).that(ImmutableList.of(file, QUALIFIER_A, QUALIFIER_B))
         .processedWith(new ComponentProcessor()).failsToCompile()
         // for whatever reason, javac only reports the error once on the constructor
         .withErrorContaining(MULTIPLE_QUALIFIERS).in(file).onLine(6);
@@ -175,7 +480,7 @@
         "@ScopeA @ScopeB class MultipleScopeClass {",
         "  @Inject MultipleScopeClass() {}",
         "}");
-    assert_().about(javaSources()).that(ImmutableList.of(file, SCOPE_A, SCOPE_B))
+    assertAbout(javaSources()).that(ImmutableList.of(file, SCOPE_A, SCOPE_B))
         .processedWith(new ComponentProcessor()).failsToCompile()
         .withErrorContaining(MULTIPLE_SCOPES).in(file).onLine(5).atColumn(1)
         .and().withErrorContaining(MULTIPLE_SCOPES).in(file).onLine(5).atColumn(9);
@@ -193,7 +498,7 @@
         "  @QualifierB",
         "  MultipleScopeClass() {}",
         "}");
-    assert_().about(javaSources()).that(ImmutableList.of(file, QUALIFIER_A, QUALIFIER_B))
+    assertAbout(javaSources()).that(ImmutableList.of(file, QUALIFIER_A, QUALIFIER_B))
         .processedWith(new ComponentProcessor()).failsToCompile()
         .withErrorContaining(QUALIFIER_ON_INJECT_CONSTRUCTOR).in(file).onLine(7)
         .and().withErrorContaining(QUALIFIER_ON_INJECT_CONSTRUCTOR).in(file).onLine(8);
@@ -208,7 +513,7 @@
         "class FinalInjectField {",
         "  @Inject final String s;",
         "}");
-    assert_().about(javaSource()).that(file)
+    assertAbout(javaSource()).that(file)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(FINAL_INJECT_FIELD).in(file).onLine(6);
@@ -223,7 +528,7 @@
         "class PrivateInjectField {",
         "  @Inject private String s;",
         "}");
-    assert_().about(javaSource()).that(file)
+    assertAbout(javaSource()).that(file)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(PRIVATE_INJECT_FIELD).in(file).onLine(6);
@@ -238,7 +543,7 @@
         "class MultipleQualifierInjectField {",
         "  @Inject @QualifierA @QualifierB String s;",
         "}");
-    assert_().about(javaSources()).that(ImmutableList.of(file, QUALIFIER_A, QUALIFIER_B))
+    assertAbout(javaSources()).that(ImmutableList.of(file, QUALIFIER_A, QUALIFIER_B))
         .processedWith(new ComponentProcessor()).failsToCompile()
         .withErrorContaining(MULTIPLE_QUALIFIERS).in(file).onLine(6).atColumn(11)
         .and().withErrorContaining(MULTIPLE_QUALIFIERS).in(file).onLine(6).atColumn(23);
@@ -253,7 +558,7 @@
         "abstract class AbstractInjectMethod {",
         "  @Inject abstract void method();",
         "}");
-    assert_().about(javaSource()).that(file)
+    assertAbout(javaSource()).that(file)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(ABSTRACT_INJECT_METHOD).in(file).onLine(6);
@@ -268,7 +573,7 @@
         "class PrivateInjectMethod {",
         "  @Inject private void method();",
         "}");
-    assert_().about(javaSource()).that(file)
+    assertAbout(javaSource()).that(file)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(PRIVATE_INJECT_METHOD).in(file).onLine(6);
@@ -283,7 +588,7 @@
         "class AbstractInjectMethod {",
         "  @Inject <T> void method();",
         "}");
-    assert_().about(javaSource()).that(file)
+    assertAbout(javaSource()).that(file)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(GENERIC_INJECT_METHOD).in(file).onLine(6);
@@ -298,160 +603,13 @@
         "class MultipleQualifierMethodParam {",
         "  @Inject void method(@QualifierA @QualifierB String s) {}",
         "}");
-    assert_().about(javaSources()).that(ImmutableList.of(file, QUALIFIER_A, QUALIFIER_B))
+    assertAbout(javaSources()).that(ImmutableList.of(file, QUALIFIER_A, QUALIFIER_B))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         // for whatever reason, javac only reports the error once on the method
         .withErrorContaining(MULTIPLE_QUALIFIERS).in(file).onLine(6);
   }
 
-  @Test public void fieldInjection() {
-    JavaFileObject file = JavaFileObjects.forSourceLines("test.FieldInjection",
-        "package test;",
-        "",
-        "import dagger.Lazy;",
-        "import javax.inject.Inject;",
-        "import javax.inject.Provider;",
-        "",
-        "class FieldInjection {",
-        "  @Inject String string;",
-        "  @Inject Lazy<String> lazyString;",
-        "  @Inject Provider<String> stringProvider;",
-        "}");
-    JavaFileObject expected = JavaFileObjects.forSourceLines("test.FieldInjection$$MembersInjector",
-        "package test;",
-        "",
-        "import dagger.MembersInjector;",
-        "import dagger.internal.DoubleCheckLazy;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class FieldInjection$$MembersInjector ",
-        "    implements MembersInjector<FieldInjection> {",
-        "",
-        "  private final Provider<String> stringProvider;",
-        "",
-        "  public FieldInjection$$MembersInjector(Provider<String> stringProvider) {",
-        "    assert stringProvider != null;",
-        "    this.stringProvider = stringProvider;",
-        "  }",
-        "",
-        "  @Override public void injectMembers(FieldInjection instance) {",
-        "    if (instance == null) {",
-        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
-        "    }",
-        "    instance.string = stringProvider.get();",
-        "    instance.lazyString = DoubleCheckLazy.create(stringProvider);",
-        "    instance.stringProvider = stringProvider;",
-        "  }",
-        "}");
-    assert_().about(javaSource()).that(file).processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and().generatesSources(expected);
-  }
-
-  @Test public void methodInjection() {
-    JavaFileObject file = JavaFileObjects.forSourceLines("test.MethodInjection",
-        "package test;",
-        "",
-        "import dagger.Lazy;",
-        "import javax.inject.Inject;",
-        "import javax.inject.Provider;",
-        "",
-        "class MethodInjection {",
-        "  @Inject void noArgs() {}",
-        "  @Inject void oneArg(String string) {}",
-        "  @Inject void manyArgs(",
-        "      String string, Lazy<String> lazyString, Provider<String> stringProvider) {}",
-        "}");
-    JavaFileObject expected = JavaFileObjects.forSourceLines(
-        "test.MethodInjection$$MembersInjector",
-        "package test;",
-        "",
-        "import dagger.MembersInjector;",
-        "import dagger.internal.DoubleCheckLazy;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class MethodInjection$$MembersInjector ",
-        "    implements MembersInjector<MethodInjection> {",
-        "",
-        "  private final Provider<String> stringProvider;",
-        "",
-        "  public MethodInjection$$MembersInjector(Provider<String> stringProvider) {",
-        "    assert stringProvider != null;",
-        "    this.stringProvider = stringProvider;",
-        "  }",
-        "",
-        "  @Override public void injectMembers(MethodInjection instance) {",
-        "    if (instance == null) {",
-        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
-        "    }",
-        "    instance.noArgs();",
-        "    instance.oneArg(stringProvider.get());",
-        "    instance.manyArgs(stringProvider.get(), DoubleCheckLazy.create(stringProvider),",
-        "        stringProvider);",
-        "  }",
-        "}");
-    assert_().about(javaSource()).that(file).processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and().generatesSources(expected);
-  }
-
-  @Test public void mixedMemberInjection() {
-    JavaFileObject file = JavaFileObjects.forSourceLines("test.MixedMemberInjection",
-        "package test;",
-        "",
-        "import dagger.Lazy;",
-        "import javax.inject.Inject;",
-        "import javax.inject.Provider;",
-        "",
-        "class MixedMemberInjection {",
-        "  @Inject String string;",
-        "  @Inject void setString(String s) {}",
-        "  @Inject Object object;",
-        "  @Inject void setObject(Object o) {}",
-        "}");
-    JavaFileObject expected = JavaFileObjects.forSourceLines(
-        "test.MixedMemberInjection$$MembersInjector",
-        "package test;",
-        "",
-        "import dagger.MembersInjector;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class MixedMemberInjection$$MembersInjector ",
-        "    implements MembersInjector<MixedMemberInjection> {",
-        "",
-        "  private final Provider<String> stringAndSProvider;",
-        "  private final Provider<Object> objectAndOProvider;",
-        "",
-        "  public MixedMemberInjection$$MembersInjector(Provider<String> stringAndSProvider,",
-        "      Provider<Object> objectAndOProvider) {",
-        "    assert stringAndSProvider != null;",
-        "    this.stringAndSProvider = stringAndSProvider;",
-        "    assert objectAndOProvider != null;",
-        "    this.objectAndOProvider = objectAndOProvider;",
-        "  }",
-        "",
-        "  @Override public void injectMembers(MixedMemberInjection instance) {",
-        "    if (instance == null) {",
-        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
-        "    }",
-        "    instance.string = stringAndSProvider.get();",
-        "    instance.object = objectAndOProvider.get();",
-        "    instance.setString(stringAndSProvider.get());",
-        "    instance.setObject(objectAndOProvider.get());",
-        "  }",
-        "}");
-    assert_().about(javaSource()).that(file).processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and().generatesSources(expected);
-  }
-
   @Test public void injectConstructor() {
     JavaFileObject file = JavaFileObjects.forSourceLines("test.InjectConstructor",
         "package test;",
@@ -483,8 +641,12 @@
         "  @Override public InjectConstructor get() {",
         "    return new InjectConstructor(sProvider.get());",
         "  }",
+        "",
+        "  public static Factory<InjectConstructor> create(Provider<String> sProvider) {",
+        "    return new InjectConstructor$$Factory(sProvider);",
+        "  }",
         "}");
-    assert_().about(javaSource()).that(file).processedWith(new ComponentProcessor())
+    assertAbout(javaSource()).that(file).processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(expected);
   }
@@ -529,38 +691,17 @@
         "    membersInjector.injectMembers(instance);",
         "    return instance;",
         "  }",
-        "}");
-    JavaFileObject expectedMembersInjector = JavaFileObjects.forSourceLines(
-        "test.AllInjections$$MembersInjector",
-        "package test;",
         "",
-        "import dagger.MembersInjector;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class AllInjections$$MembersInjector ",
-        "    implements MembersInjector<AllInjections> {",
-        "",
-        "  private final Provider<String> sProvider;",
-        "",
-        "  public AllInjections$$MembersInjector(Provider<String> sProvider) {",
-        "    assert sProvider != null;",
-        "    this.sProvider = sProvider;",
-        "  }",
-        "",
-        "  @Override public void injectMembers(AllInjections instance) {",
-        "    if (instance == null) {",
-        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
-        "    }",
-        "    instance.s = sProvider.get();",
-        "    instance.s(sProvider.get());",
+        "  public static Factory<AllInjections> create(",
+        "      MembersInjector<AllInjections> membersInjector, ",
+        "      Provider<String> sProvider) {",
+        "    return new AllInjections$$Factory(membersInjector, sProvider);",
         "  }",
         "}");
-    assert_().about(javaSource()).that(file).processedWith(new ComponentProcessor())
+    assertAbout(javaSource()).that(file).processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and()
-        .generatesSources(expectedFactory, expectedMembersInjector);
+        .generatesSources(expectedFactory);
   }
 
   @Test public void supertypeRequiresMemberInjection() {
@@ -599,61 +740,15 @@
         "    membersInjector.injectMembers(instance);",
         "    return instance;",
         "  }",
-        "}");
-    assert_().about(javaSources()).that(ImmutableList.of(aFile, bFile))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and().generatesSources(expectedFactory);
-  }
-
-  @Test public void supertypeMembersInjection() {
-    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
-        "package test;",
-        "",
-        "class A {}");
-    JavaFileObject bFile = JavaFileObjects.forSourceLines("test.B",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "class B extends A {",
-        "  @Inject String s;",
-        "}");
-    JavaFileObject expectedMembersInjector = JavaFileObjects.forSourceLines(
-        "test.AllInjections$$MembersInjector",
-        "package test;",
-        "",
-        "import dagger.MembersInjector;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class B$$MembersInjector ",
-        "    implements MembersInjector<B> {",
-        "",
-        "  private final MembersInjector<A> supertypeInjector;",
-        "  private final Provider<String> sProvider;",
-        "",
-        "  public B$$MembersInjector(MembersInjector<A> supertypeInjector,",
-        "      Provider<String> sProvider) {",
-        "    assert supertypeInjector != null;",
-        "    this.supertypeInjector = supertypeInjector;",
-        "    assert sProvider != null;",
-        "    this.sProvider = sProvider;",
-        "  }",
         "",
-        "  @Override public void injectMembers(B instance) {",
-        "    if (instance == null) {",
-        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
-        "    }",
-        "    supertypeInjector.injectMembers(instance);",
-        "    instance.s = sProvider.get();",
+        "  public static Factory<B> create(MembersInjector<B> membersInjector) {",
+        "    return new B$$Factory(membersInjector);",
         "  }",
         "}");
-    assert_().about(javaSources()).that(ImmutableList.of(aFile, bFile))
+    assertAbout(javaSources()).that(ImmutableList.of(aFile, bFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and().generatesSources(expectedMembersInjector);
+        .and().generatesSources(expectedFactory);
   }
 
   @Test
@@ -690,8 +785,13 @@ public void wildcardDependency() {
         "  @Override public InjectConstructor get() {",
         "    return new InjectConstructor(objectsProvider.get());",
         "  }",
+        "",
+        "  public static Factory<InjectConstructor> create(",
+        "      Provider<List<? extends Object>> objectsProvider) {",
+        "    return new InjectConstructor$$Factory(objectsProvider);",
+        "  }",
         "}");
-    assert_().about(javaSource()).that(file).processedWith(new ComponentProcessor())
+    assertAbout(javaSource()).that(file).processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(expected);
   }
@@ -733,8 +833,13 @@ public void basicNameCollision() {
         "  @Override public InjectConstructor get() {",
         "    return new InjectConstructor(factoryProvider.get());",
         "  }",
+        "",
+        "  public static Factory<InjectConstructor> create(",
+        "      Provider<other.pkg.Factory> factoryProvider) {",
+        "    return new InjectConstructor$$Factory(factoryProvider);",
+        "  }",
         "}");
-    assert_().about(javaSources()).that(ImmutableList.of(factoryFile, file))
+    assertAbout(javaSources()).that(ImmutableList.of(factoryFile, file))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(expected);
@@ -780,8 +885,13 @@ public void nestedNameCollision() {
         "  @Override public InjectConstructor get() {",
         "    return new InjectConstructor(factoryProvider.get());",
         "  }",
+        "",
+        "  public static Factory<InjectConstructor> create(",
+        "      Provider<Outer.Factory> factoryProvider) {",
+        "    return new InjectConstructor$$Factory(factoryProvider);",
+        "  }",
         "}");
-    assert_().about(javaSources()).that(ImmutableList.of(factoryFile, file))
+    assertAbout(javaSources()).that(ImmutableList.of(factoryFile, file))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(expected);
@@ -833,8 +943,14 @@ public void samePackageNameCollision() {
         "  @Override public InjectConstructor get() {",
         "    return new InjectConstructor(otherPackageProvider.get(), samePackageProvider.get());",
         "  }",
+        "",
+        "  public static Factory<InjectConstructor> create(",
+        "      Provider<CommonName> otherPackageProvider,",
+        "      Provider<test.CommonName> samePackageProvider) {",
+        "    return new InjectConstructor$$Factory(otherPackageProvider, samePackageProvider);",
+        "  }",
         "}");
-    assert_().about(javaSources())
+    assertAbout(javaSources())
         .that(ImmutableList.of(samePackageInterface, differentPackageInterface, file))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
@@ -864,11 +980,59 @@ public void noDeps() {
         "  @Override public SimpleType get() {",
         "    return new SimpleType();",
         "  }",
+        "",
+        "  public static Factory<SimpleType> create() {",
+        "    return INSTANCE;",
+        "  }",
         "}");
-    assert_().about(javaSource())
+    assertAbout(javaSource())
         .that(simpleType)
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(factory);
   }
+
+  @Test public void simpleComponentWithNesting() {
+    JavaFileObject nestedTypesFile = JavaFileObjects.forSourceLines("test.OuterType",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import javax.inject.Inject;",
+        "",
+        "final class OuterType {",
+        "  static class A {",
+        "    @Inject A() {}",
+        "  }",
+        "  static class B {",
+        "    @Inject A a;",
+        "  }",
+        "  @Component interface SimpleComponent {",
+        "    A a();",
+        "    void inject(B b);",
+        "  }",
+        "}");
+    JavaFileObject aFactory = JavaFileObjects.forSourceLines(
+        "test.OuterType$A$$Factory",
+        "package test;",
+        "",
+        "import dagger.Factory;",
+        "import javax.annotation.Generated;",
+        "import test.OuterType.A;",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public enum OuterType$A$$Factory implements Factory<A> {",
+        "  INSTANCE;",
+        "",
+        "  @Override public A get() {",
+        "    return new A();",
+        "  }",
+        "",
+        "  public static Factory<A> create() {",
+        "    return INSTANCE;",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(nestedTypesFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(aFactory);
+  }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
index 02a85e3a4..dc6f755ff 100644
--- a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
@@ -15,6 +15,10 @@
  */
 package dagger.internal.codegen;
 
+import static com.google.common.truth.Truth.assertThat;
+import static dagger.Provides.Type.SET;
+import static dagger.Provides.Type.SET_VALUES;
+
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.Equivalence;
 import com.google.common.base.Optional;
@@ -42,10 +46,6 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assertThat;
-import static dagger.Provides.Type.SET;
-import static dagger.Provides.Type.SET_VALUES;
-
 /**
  * Tests {@link Key}.
  */
@@ -63,12 +63,13 @@
     this.keyFactory = new Key.Factory(types, elements);
   }
 
-  @Test public void forInjectConstructor() {
+  @Test public void forInjectConstructorWithResolvedType() {
     TypeElement typeElement =
         compilationRule.getElements().getTypeElement(InjectedClass.class.getCanonicalName());
     ExecutableElement constructor =
         Iterables.getOnlyElement(ElementFilter.constructorsIn(typeElement.getEnclosedElements()));
-    assertThat(keyFactory.forInjectConstructor(constructor))
+    assertThat(
+        keyFactory.forInjectConstructorWithResolvedType(constructor.getEnclosingElement().asType()))
         .isEqualTo(new AutoValue_Key(
             Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
             MoreTypes.equivalence().wrap(typeElement.asType())));
diff --git a/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java b/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
index 2c80a64b3..7382dd1b3 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
@@ -1,5 +1,23 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package dagger.internal.codegen;
 
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.JavaFileObjects;
 import javax.tools.JavaFileObject;
@@ -7,9 +25,6 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assert_;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
-
 @RunWith(JUnit4.class)
 public class MembersInjectionTest {
   @Test
@@ -68,7 +83,7 @@ public void parentClass_noInjectedMembers() {
         "  private void initialize() {",
         "    this.parentMembersInjector = MembersInjectors.noOp();",
         "    this.childMembersInjector = MembersInjectors.delegatingTo(parentMembersInjector);",
-        "    this.childProvider = new Child$$Factory(childMembersInjector);",
+        "    this.childProvider = Child$$Factory.create(childMembersInjector);",
         "  }",
         "",
         "  @Override",
@@ -85,7 +100,7 @@ public void parentClass_noInjectedMembers() {
         "    }",
         "  }",
         "}");
-    assert_().about(javaSources())
+    assertAbout(javaSources())
         .that(ImmutableList.of(childFile, parentFile, componentFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
@@ -157,9 +172,9 @@ public void parentClass_injectedMembersInSupertype() {
         "  }",
         "",
         "  private void initialize() {",
-        "    this.parentMembersInjector = new Parent$$MembersInjector(Dep$$Factory.INSTANCE);",
+        "    this.parentMembersInjector = Parent$$MembersInjector.create(Dep$$Factory.create());",
         "    this.childMembersInjector = MembersInjectors.delegatingTo(parentMembersInjector);",
-        "    this.childProvider = new Child$$Factory(childMembersInjector);",
+        "    this.childProvider = Child$$Factory.create(childMembersInjector);",
         "  }",
         "",
         "  @Override",
@@ -176,10 +191,474 @@ public void parentClass_injectedMembersInSupertype() {
         "    }",
         "  }",
         "}");
-    assert_().about(javaSources())
+    assertAbout(javaSources())
         .that(ImmutableList.of(childFile, parentFile, depFile, componentFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(generatedComponent);
   }
+
+  @Test public void fieldAndMethodGenerics() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.GenericClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class GenericClass<A, B> {",
+        "  @Inject A a;",
+        "",
+        "  @Inject GenericClass() {}",
+        "",
+        " @Inject void register(B b) {}",
+        "}");
+    JavaFileObject expected = JavaFileObjects.forSourceLines("test.GenericClass$$MembersInjector",
+        "package test;",
+        "",
+        "import dagger.MembersInjector;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class GenericClass$$MembersInjector<A, B>",
+        "    implements MembersInjector<GenericClass<A, B>> {",
+        "  private final Provider<A> aProvider;",
+        "  private final Provider<B> bProvider;",
+        "",
+        "  public GenericClass$$MembersInjector(Provider<A> aProvider, Provider<B> bProvider) {",
+        "    assert aProvider != null;",
+        "    this.aProvider = aProvider;",
+        "    assert bProvider != null;",
+        "    this.bProvider = bProvider;",
+        "  }",
+        "",
+        "  @Override",
+        "  public void injectMembers(GenericClass<A, B> instance) {",
+        "    if (instance == null) {",
+        "      throw new NullPointerException(\"Cannot inject members into a null reference\")",
+        "    }",
+        "    instance.a = aProvider.get();",
+        "    instance.register(bProvider.get())",
+        "  }",
+        "",
+        "  public static <A, B> MembersInjector<GenericClass<A, B>> create(",
+        "      Provider<A> aProvider, Provider<B> bProvider) {",
+        "    return new GenericClass$$MembersInjector<A, B>(aProvider, bProvider);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(file)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(expected);
+  }
+
+  @Test public void subclassedGenericMembersInjectors() {
+    JavaFileObject a = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class A {",
+        "  @Inject A() {}",
+        "}");
+    JavaFileObject a2 = JavaFileObjects.forSourceLines("test.A2",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class A2 {",
+        "  @Inject A2() {}",
+        "}");
+    JavaFileObject parent = JavaFileObjects.forSourceLines("test.Parent",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class Parent<X, Y> {",
+        "  @Inject X x;",
+        "  @Inject Y y;",
+        "  @Inject A2 a2;",
+        "",
+        "  @Inject Parent() {}",
+        "}");
+    JavaFileObject child = JavaFileObjects.forSourceLines("test.Child",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class Child<T> extends Parent<T, A> {",
+        "  @Inject A a;",
+        "  @Inject T t;",
+        "",
+        "  @Inject Child() {}",
+        "}");
+    JavaFileObject expected = JavaFileObjects.forSourceLines("test.GenericClass$$MembersInjector",
+        "package test;",
+        "",
+        "import dagger.MembersInjector;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class Child$$MembersInjector<T>",
+        "    implements MembersInjector<Child<T>> {",
+        "  private final MembersInjector<Parent<T, A>> supertypeInjector;",
+        "  private final Provider<A> aProvider;",
+        "  private final Provider<T> tProvider;",
+        "",
+        "  public Child$$MembersInjector(",
+        "      MembersInjector<Parent<T, A>> supertypeInjector, ",
+        "      Provider<A> aProvider, Provider<T> tProvider) {",
+        "    assert supertypeInjector != null;",
+        "    this.supertypeInjector = supertypeInjector;",
+        "    assert aProvider != null;",
+        "    this.aProvider = aProvider;",
+        "    assert tProvider != null;",
+        "    this.tProvider = tProvider;",
+        "  }",
+        "",
+        "  @Override",
+        "  public void injectMembers(Child<T> instance) {",
+        "    if (instance == null) {",
+        "      throw new NullPointerException(\"Cannot inject members into a null reference\")",
+        "    }",
+        "    supertypeInjector.injectMembers(instance);",
+        "    instance.a = aProvider.get();",
+        "    instance.t = tProvider.get();",
+        "  }",
+        "",
+        "  public static <T> MembersInjector<Child<T>> create(",
+        "      MembersInjector<Parent<T, A>> supertypeInjector, ",
+        "      Provider<A> aProvider, Provider<T> tProvider) {",
+        "    return new Child$$MembersInjector<T>(supertypeInjector, aProvider, tProvider);",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(a, a2, parent, child))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(expected);
+  }
+
+  @Test public void fieldInjection() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.FieldInjection",
+        "package test;",
+        "",
+        "import dagger.Lazy;",
+        "import javax.inject.Inject;",
+        "import javax.inject.Provider;",
+        "",
+        "class FieldInjection {",
+        "  @Inject String string;",
+        "  @Inject Lazy<String> lazyString;",
+        "  @Inject Provider<String> stringProvider;",
+        "}");
+    JavaFileObject expected = JavaFileObjects.forSourceLines("test.FieldInjection$$MembersInjector",
+        "package test;",
+        "",
+        "import dagger.MembersInjector;",
+        "import dagger.internal.DoubleCheckLazy;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class FieldInjection$$MembersInjector ",
+        "    implements MembersInjector<FieldInjection> {",
+        "",
+        "  private final Provider<String> stringProvider;",
+        "",
+        "  public FieldInjection$$MembersInjector(Provider<String> stringProvider) {",
+        "    assert stringProvider != null;",
+        "    this.stringProvider = stringProvider;",
+        "  }",
+        "",
+        "  @Override public void injectMembers(FieldInjection instance) {",
+        "    if (instance == null) {",
+        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
+        "    }",
+        "    instance.string = stringProvider.get();",
+        "    instance.lazyString = DoubleCheckLazy.create(stringProvider);",
+        "    instance.stringProvider = stringProvider;",
+        "  }",
+        "",
+        "  public static MembersInjector<FieldInjection> create(",
+        "      Provider<String> stringProvider) {",
+        "    return new FieldInjection$$MembersInjector(stringProvider);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(file).processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(expected);
+  }
+
+  @Test public void methodInjection() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.MethodInjection",
+        "package test;",
+        "",
+        "import dagger.Lazy;",
+        "import javax.inject.Inject;",
+        "import javax.inject.Provider;",
+        "",
+        "class MethodInjection {",
+        "  @Inject void noArgs() {}",
+        "  @Inject void oneArg(String string) {}",
+        "  @Inject void manyArgs(",
+        "      String string, Lazy<String> lazyString, Provider<String> stringProvider) {}",
+        "}");
+    JavaFileObject expected = JavaFileObjects.forSourceLines(
+        "test.MethodInjection$$MembersInjector",
+        "package test;",
+        "",
+        "import dagger.MembersInjector;",
+        "import dagger.internal.DoubleCheckLazy;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class MethodInjection$$MembersInjector ",
+        "    implements MembersInjector<MethodInjection> {",
+        "",
+        "  private final Provider<String> stringProvider;",
+        "",
+        "  public MethodInjection$$MembersInjector(Provider<String> stringProvider) {",
+        "    assert stringProvider != null;",
+        "    this.stringProvider = stringProvider;",
+        "  }",
+        "",
+        "  @Override public void injectMembers(MethodInjection instance) {",
+        "    if (instance == null) {",
+        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
+        "    }",
+        "    instance.noArgs();",
+        "    instance.oneArg(stringProvider.get());",
+        "    instance.manyArgs(stringProvider.get(), DoubleCheckLazy.create(stringProvider),",
+        "        stringProvider);",
+        "  }",
+        "",
+        "  public static MembersInjector<MethodInjection> create(",
+        "      Provider<String> stringProvider) {",
+        "    return new MethodInjection$$MembersInjector(stringProvider);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(file).processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(expected);
+  }
+
+  @Test public void mixedMemberInjection() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.MixedMemberInjection",
+        "package test;",
+        "",
+        "import dagger.Lazy;",
+        "import javax.inject.Inject;",
+        "import javax.inject.Provider;",
+        "",
+        "class MixedMemberInjection {",
+        "  @Inject String string;",
+        "  @Inject void setString(String s) {}",
+        "  @Inject Object object;",
+        "  @Inject void setObject(Object o) {}",
+        "}");
+    JavaFileObject expected = JavaFileObjects.forSourceLines(
+        "test.MixedMemberInjection$$MembersInjector",
+        "package test;",
+        "",
+        "import dagger.MembersInjector;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class MixedMemberInjection$$MembersInjector ",
+        "    implements MembersInjector<MixedMemberInjection> {",
+        "",
+        "  private final Provider<String> stringAndSProvider;",
+        "  private final Provider<Object> objectAndOProvider;",
+        "",
+        "  public MixedMemberInjection$$MembersInjector(Provider<String> stringAndSProvider,",
+        "      Provider<Object> objectAndOProvider) {",
+        "    assert stringAndSProvider != null;",
+        "    this.stringAndSProvider = stringAndSProvider;",
+        "    assert objectAndOProvider != null;",
+        "    this.objectAndOProvider = objectAndOProvider;",
+        "  }",
+        "",
+        "  @Override public void injectMembers(MixedMemberInjection instance) {",
+        "    if (instance == null) {",
+        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
+        "    }",
+        "    instance.string = stringAndSProvider.get();",
+        "    instance.object = objectAndOProvider.get();",
+        "    instance.setString(stringAndSProvider.get());",
+        "    instance.setObject(objectAndOProvider.get());",
+        "  }",
+        "",
+        "  public static MembersInjector<MixedMemberInjection> create(",
+        "      Provider<String> stringAndSProvider,",
+        "      Provider<Object> objectAndOProvider) {",
+        "    return new MixedMemberInjection$$MembersInjector(",
+        "        stringAndSProvider, objectAndOProvider);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(file).processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(expected);
+  }
+
+  @Test public void injectConstructorAndMembersInjection() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.AllInjections",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class AllInjections {",
+        "  @Inject String s;",
+        "  @Inject AllInjections(String s) {}",
+        "  @Inject void s(String s) {}",
+        "}");
+    JavaFileObject expectedMembersInjector = JavaFileObjects.forSourceLines(
+        "test.AllInjections$$MembersInjector",
+        "package test;",
+        "",
+        "import dagger.MembersInjector;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class AllInjections$$MembersInjector ",
+        "    implements MembersInjector<AllInjections> {",
+        "",
+        "  private final Provider<String> sProvider;",
+        "",
+        "  public AllInjections$$MembersInjector(Provider<String> sProvider) {",
+        "    assert sProvider != null;",
+        "    this.sProvider = sProvider;",
+        "  }",
+        "",
+        "  @Override public void injectMembers(AllInjections instance) {",
+        "    if (instance == null) {",
+        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
+        "    }",
+        "    instance.s = sProvider.get();",
+        "    instance.s(sProvider.get());",
+        "  }",
+        "",
+        "  public static MembersInjector<AllInjections> create(Provider<String> sProvider) {",
+        "    return new AllInjections$$MembersInjector(sProvider);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(file).processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(expectedMembersInjector);
+  }
+
+  @Test public void supertypeMembersInjection() {
+    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "class A {}");
+    JavaFileObject bFile = JavaFileObjects.forSourceLines("test.B",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class B extends A {",
+        "  @Inject String s;",
+        "}");
+    JavaFileObject expectedMembersInjector = JavaFileObjects.forSourceLines(
+        "test.AllInjections$$MembersInjector",
+        "package test;",
+        "",
+        "import dagger.MembersInjector;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class B$$MembersInjector ",
+        "    implements MembersInjector<B> {",
+        "",
+        "  private final MembersInjector<A> supertypeInjector;",
+        "  private final Provider<String> sProvider;",
+        "",
+        "  public B$$MembersInjector(MembersInjector<A> supertypeInjector,",
+        "      Provider<String> sProvider) {",
+        "    assert supertypeInjector != null;",
+        "    this.supertypeInjector = supertypeInjector;",
+        "    assert sProvider != null;",
+        "    this.sProvider = sProvider;",
+        "  }",
+        "",
+        "  @Override public void injectMembers(B instance) {",
+        "    if (instance == null) {",
+        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
+        "    }",
+        "    supertypeInjector.injectMembers(instance);",
+        "    instance.s = sProvider.get();",
+        "  }",
+        "",
+        "  public static MembersInjector<B> create(",
+        "      MembersInjector<A> supertypeInjector,",
+        "      Provider<String> sProvider) {",
+        "    return new B$$MembersInjector(supertypeInjector, sProvider);",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(aFile, bFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(expectedMembersInjector);
+  }
+
+  @Test public void simpleComponentWithNesting() {
+    JavaFileObject nestedTypesFile = JavaFileObjects.forSourceLines("test.OuterType",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import javax.inject.Inject;",
+        "",
+        "final class OuterType {",
+        "  static class A {",
+        "    @Inject A() {}",
+        "  }",
+        "  static class B {",
+        "    @Inject A a;",
+        "  }",
+        "  @Component interface SimpleComponent {",
+        "    A a();",
+        "    void inject(B b);",
+        "  }",
+        "}");
+    JavaFileObject bMembersInjector = JavaFileObjects.forSourceLines(
+        "test.OuterType$B$$MembersInjector",
+        "package test;",
+        "",
+        "import dagger.MembersInjector;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "import test.OuterType.A;",
+        "import test.OuterType.B;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class OuterType$B$$MembersInjector implements MembersInjector<B> {",
+        "  private final Provider<A> aProvider;",
+        "",
+        "  public OuterType$B$$MembersInjector(Provider<A> aProvider) {",
+        "    assert aProvider != null;",
+        "    this.aProvider = aProvider;",
+        "  }",
+         "",
+        "  @Override",
+        "  public void injectMembers(B instance) {",
+        "    if (instance == null) {",
+        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
+        "    }",
+        "    instance.a = aProvider.get();",
+        "  }",
+        "",
+        "  public static MembersInjector<B> create(Provider<A> aProvider) {",
+        "    return new OuterType$B$$MembersInjector(aProvider);",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(nestedTypesFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(bMembersInjector);
+  }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/PackageProxyTest.java b/compiler/src/test/java/dagger/internal/codegen/PackageProxyTest.java
index 2fb63b9cf..a2b8e297f 100644
--- a/compiler/src/test/java/dagger/internal/codegen/PackageProxyTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/PackageProxyTest.java
@@ -92,13 +92,13 @@
         "",
         "  private void initialize() {",
         "    this.foreign_Proxy.nonPublicClass1Provider =",
-        "        new NonPublicClass1$$Factory(NoDepClass$$Factory.INSTANCE);",
+        "        NonPublicClass1$$Factory.create(NoDepClass$$Factory.create());",
         "    this.foreign_Proxy.nonPublicClass2Provider =",
-        "        new NonPublicClass2$$Factory(NoDepClass$$Factory.INSTANCE);",
-        "    this.publicClassProvider = new PublicClass$$Factory(",
+        "        NonPublicClass2$$Factory.create(NoDepClass$$Factory.create());",
+        "    this.publicClassProvider = PublicClass$$Factory.create(",
         "        foreign_Proxy.nonPublicClass1Provider,",
         "        foreign_Proxy.nonPublicClass2Provider,",
-        "        NoDepClass$$Factory.INSTANCE);",
+        "        NoDepClass$$Factory.create());",
         "  }",
         "",
         "  @Override",
@@ -217,13 +217,13 @@
         "  }",
         "",
         "  private void initialize() {",
-        "    this.dMembersInjector = new D$$MembersInjector(NoDepClass$$Factory.INSTANCE);",
+        "    this.dMembersInjector = D$$MembersInjector.create(NoDepClass$$Factory.create());",
         "    this.foreign_Proxy.cMembersInjector =",
-        "        new C$$MembersInjector(dMembersInjector, NoDepClass$$Factory.INSTANCE);",
-        "    this.bMembersInjector = new B$$MembersInjector(",
-        "        foreign_Proxy.cMembersInjector, NoDepClass$$Factory.INSTANCE);",
-        "    this.aMembersInjector = new A$$MembersInjector(",
-        "        bMembersInjector, NoDepClass$$Factory.INSTANCE);",
+        "        C$$MembersInjector.create(dMembersInjector, NoDepClass$$Factory.create());",
+        "    this.bMembersInjector = B$$MembersInjector.create(",
+        "        foreign_Proxy.cMembersInjector, NoDepClass$$Factory.create());",
+        "    this.aMembersInjector = A$$MembersInjector.create(",
+        "        bMembersInjector, NoDepClass$$Factory.create());",
         "  }",
         "",
         "  @Override",
diff --git a/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java b/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
index 8ed583d10..427762409 100644
--- a/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
@@ -97,7 +97,7 @@
       "  private void initialize() {",
       "    this.primitiveIntProvider = new PrimitiveModule$$PrimitiveIntFactory(primitiveModule);",
       "    this.primitiveInjectableProvider =",
-      "        new PrimitiveInjectable$$Factory(primitiveIntProvider);",
+      "        PrimitiveInjectable$$Factory.create(primitiveIntProvider);",
       "  }",
       "",
       "  @Override",
