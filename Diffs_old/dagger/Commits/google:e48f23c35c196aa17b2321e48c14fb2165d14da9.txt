diff --git a/CHANGELOG.md b/CHANGELOG.md
index 3a38bfc00..2bb845ff5 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -4,6 +4,27 @@ Change Log
 Dagger 2 (Components)
 ---------------------
 
+### Version 2.2 *(2016-03-22)*
+  * `dagger.mapkeys` moved to `dagger.multibindings` and all `@MapKey`
+    implementations now correctly have `@Beta` applied
+  * Better error messages for multibindings
+  * Compiler bug fixes!
+
+### Version 2.1 *(2016-03-10)*
+
+  * Correctly handle `@Component`s that inject generated types
+  * Adds `@ProductionSubcomponent` and `@ProductionScope`
+  * Allow the production `Executor` to be bound with `@Production`
+  * Allow multiple scope annotations on components
+  * A component's subcomponents’ (and their subcomponents’) simple names no longer need to be unique
+  * Adds the ability to depend on subcomponent builders
+  * GWT Integration
+  * Producers monitoring
+  * Multibindings for producers
+  * Add common `@MapKey` annotations to `dagger.mapkeys`.  These annotations are
+    not, but should be marked `@Beta` (since the `@MapKey` itself is beta).
+  * Lots of bug fixes!
+
 ### Version 2.0.2 *(2015-11-03)*
 
 A patch release, most crucially including:
diff --git a/README.md b/README.md
index f9d182f6a..ed9db7ccb 100644
--- a/README.md
+++ b/README.md
@@ -1,49 +1,47 @@
-Dagger 2
-========
+# Dagger 2
 
 A fast dependency injector for Android and Java.
 
-About Google's Fork
--------------
+## About Google's Fork
 
-Dagger 2 is a compile-time evolution approach to dependency injection.  Taking the approach
-started in Dagger 1.x to its ultimate conclusion, Dagger 2.0 eliminates all reflection, and
-improves code clarity by removing the traditional ObjectGraph/Injector in favor of
-user-specified @Component interfaces. 
+Dagger 2 is a compile-time evolution approach to dependency injection.
+Taking the approach started in Dagger 1.x to its ultimate conclusion,
+Dagger 2.x eliminates all reflection, and improves code clarity by
+removing the traditional ObjectGraph/Injector in favor of user-specified
+`@Component` interfaces.
 
-This github project represents the Dagger 2 development stream.  The earlier 
-[project page][square] (Square, Inc's repository) represents the earlier 1.0 development stream.  
-Both versions have benefitted from strong involvement from Square, Google, and other contributors. 
+This github project represents the Dagger 2 development stream.  The earlier
+[project page][square] (Square, Inc's repository) represents the earlier 1.0
+development stream. Both versions have benefitted from strong involvement from
+Square, Google, and other contributors.
 
-## [Dagger 2's main documentation website can be found here.][website]
+> [Dagger 2's main documentation website can be found here.][website]
 
-Status
-------
+## Status
 
-  - ***Release Version:* 2.0.2**
-  - ***Snapshot Version:* 2.1-SNAPSHOT**
+  - ***Release Version:* 2.1**
+  - ***Snapshot Version:* 2.2-SNAPSHOT**
 
-Dagger is currently in active development, primarily internally at Google, with regular pushes
-to the open-source community.  Snapshot releases are auto-deployed to sonatype's central maven
-repository on a clean build with the version `2.1-SNAPSHOT`.
+Dagger is currently in active development, primarily internally at Google,
+with regular pushes to the open-source community. Snapshot releases are
+auto-deployed to sonatype's central maven repository on a clean build with
+the version `2.2-SNAPSHOT`.
 
-Documentation
--------------
+## Documentation
 
 You can [find the dagger documentation here][website] which has extended usage
 instructions and other useful information.  Substantial usage information can be
 found in the [API documentation][20api].
 
-You can also learn more from [the original proposal][proposal], 
+You can also learn more from [the original proposal][proposal],
 [this talk by Greg Kick][gaktalk], and on the dagger-discuss@googlegroups.com
-mailing list. 
+mailing list.
 
-Installation
---------
+## Installation
 
-You will need to include the `dagger-2.0.2.jar` in your application's runtime.
+You will need to include the `dagger-2.1.jar` in your application's runtime.
 In order to activate code generation and generate implementations to manage
-your graph you will need to include `dagger-compiler-2.0.2.jar` in your build
+your graph you will need to include `dagger-compiler-2.1.jar` in your build
 at compile time.
 
 In a Maven project, include the `dagger` artifact in the dependencies section
@@ -55,53 +53,56 @@ of your `pom.xml` and the `dagger-compiler` artifact as either an `optional` or
   <dependency>
     <groupId>com.google.dagger</groupId>
     <artifactId>dagger</artifactId>
-    <version>2.0.2</version>
+    <version>2.1</version>
   </dependency>
   <dependency>
     <groupId>com.google.dagger</groupId>
     <artifactId>dagger-compiler</artifactId>
-    <version>2.0.2</version>
+    <version>2.1</version>
     <optional>true</optional>
   </dependency>
 </dependencies>
 ```
 
-If you use the beta `dagger-producers` extension (which supplies parallelizable execution graphs),
-then add this to your maven configuration:
+If you use the beta `dagger-producers` extension (which supplies
+parallelizable execution graphs), then add this to your maven configuration:
 
 ```xml
 <dependencies>
   <dependency>
     <groupId>com.google.dagger</groupId>
     <artifactId>dagger-producers</artifactId>
-    <version>2.0-beta</version>
+    <version>2.1</version>
   </dependency>
 </dependencies>
 ```
 
 
-### Download 
+### Download
 
   * 2.x (google/dagger)
     * [Dagger 2.0 Documentation][website]
     * [Dagger 2.0 Javadocs][20api]
-    * [Dagger development Javadocs][latestapi] (from the `master` branch on GitHub)
+    * [Dagger development Javadocs][latestapi] (from the `master` branch
+      on GitHub)
     * [Google's Dagger project site on GitHub][project]
-    * <a href="https://plus.google.com/118328287768685565185" rel="publisher">Google+ Dagger Project Page</a>
+    * <a href="https://plus.google.com/118328287768685565185"
+         rel="publisher">Google+ Dagger Project Page</a>
     * [Google+ Dagger Users Community][community]
   * 1.x (square/dagger)
     * [Square's original Dagger project site on GitHub][square]
     * [Square Open Source Community][squarecommunity]
 
 
-If you do not use maven, gradle, ivy, or other build systems that consume maven-style binary
-artifacts, they can be downloaded directly via the [Maven Central Repository][mavensearch].
+If you do not use maven, gradle, ivy, or other build systems that consume
+maven-style binary artifacts, they can be downloaded directly via the
+[Maven Central Repository][mavensearch].
 
-Developer snapshots are available from [Sonatype's snapshot repository][dagger-snap], and
-are built on a clean build of the GitHub project's master branch.
+Developer snapshots are available from Sonatype's
+[snapshot repository][dagger-snap], and are built on a clean build of
+the GitHub project's master branch.
 
-License
--------
+## License
 
     Copyright 2012 Square, Inc.
     Copyright 2012 Google, Inc.
diff --git a/compiler/pom.xml b/compiler/pom.xml
index 69839a1e6..d8a74e902 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>com.google.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>2.1-SNAPSHOT</version>
+    <version>2.2-SNAPSHOT</version>
   </parent>
 
   <artifactId>dagger-compiler</artifactId>
@@ -45,6 +45,10 @@
       <groupId>com.google.auto</groupId>
       <artifactId>auto-common</artifactId>
     </dependency>
+    <dependency>
+      <groupId>com.google.errorprone</groupId>
+      <artifactId>error_prone_annotations</artifactId>
+    </dependency>
     <dependency>
       <groupId>com.google.guava</groupId>
       <artifactId>guava</artifactId>
@@ -66,7 +70,7 @@
     <dependency>
       <groupId>com.google.auto.value</groupId>
       <artifactId>auto-value</artifactId>
-      <version>1.0</version>
+      <version>1.1</version>
       <scope>provided</scope> <!-- to leave out of the all-deps jar -->
     </dependency>
 
diff --git a/compiler/src/it/functional-tests/pom.xml b/compiler/src/it/functional-tests/pom.xml
index 217e6167a..ae30d1571 100644
--- a/compiler/src/it/functional-tests/pom.xml
+++ b/compiler/src/it/functional-tests/pom.xml
@@ -22,7 +22,7 @@ limitations under the License.
   <parent>
     <groupId>com.google.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>2.1-SNAPSHOT</version>
+    <version>2.2-SNAPSHOT</version>
   </parent>
   <groupId>dagger.tests</groupId>
   <artifactId>functional-tests</artifactId>
diff --git a/compiler/src/it/functional-tests/src/main/java/test/BasicAbstractClassComponent.java b/compiler/src/it/functional-tests/src/main/java/test/BasicAbstractClassComponent.java
index 78f77dfb8..ad32e2a42 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/BasicAbstractClassComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/BasicAbstractClassComponent.java
@@ -21,7 +21,7 @@
  * This component tests behavior equivalent to {@link BasicComponent}, but as an abstract class
  * rather than an interface.
  */
-@Component(modules = PrimitivesModule.class)
+@Component(modules = {PrimitivesModule.class, NullableModule.class})
 abstract class BasicAbstractClassComponent implements BasicComponent {
   void throwAParty() {
     throw new RuntimeException("Paaarrrrrtaaaaaaaay!");
diff --git a/compiler/src/it/functional-tests/src/main/java/test/BasicComponent.java b/compiler/src/it/functional-tests/src/main/java/test/BasicComponent.java
index a04607dd4..b9b54d914 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/BasicComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/BasicComponent.java
@@ -19,8 +19,9 @@
 import dagger.Lazy;
 import dagger.MembersInjector;
 import javax.inject.Provider;
+import test.NullableModule.Nullable;
 
-@Component(modules = PrimitivesModule.class)
+@Component(modules = {PrimitivesModule.class, NullableModule.class})
 interface BasicComponent extends Injector<Thing> {
   byte getByte();
   char getChar();
@@ -74,6 +75,10 @@
   Provider<InjectedThing> injectedThingProvider();
   Lazy<InjectedThing> lazyInjectedThing();
   MembersInjector<InjectedThing> injectedThingMembersInjector();
+  
+  @Nullable Object nullObject();
+  Provider<Object> nullObjectProvider();
+  Lazy<Object> lazyNullObject();
 
   TypeWithInheritedMembersInjection typeWithInheritedMembersInjection();
   MembersInjector<TypeWithInheritedMembersInjection>
diff --git a/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java b/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java
index 92355088b..ca99abaa3 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java
@@ -16,7 +16,7 @@
 package test;
 
 import dagger.Component;
-import dagger.mapkeys.StringKey;
+import dagger.multibindings.StringKey;
 import java.util.Collection;
 import java.util.Map;
 import java.util.Set;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java b/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java
index 08433a988..b5ca08ed8 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java
@@ -18,10 +18,10 @@
 import dagger.Module;
 import dagger.Multibindings;
 import dagger.Provides;
-import dagger.mapkeys.ClassKey;
-import dagger.mapkeys.IntKey;
-import dagger.mapkeys.LongKey;
-import dagger.mapkeys.StringKey;
+import dagger.multibindings.ClassKey;
+import dagger.multibindings.IntKey;
+import dagger.multibindings.LongKey;
+import dagger.multibindings.StringKey;
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.util.Collection;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/NullableModule.java b/compiler/src/it/functional-tests/src/main/java/test/NullableModule.java
new file mode 100644
index 000000000..326401d00
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/NullableModule.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+final class NullableModule {
+  /**
+   * A {@code Nullable} that isn't {@link javax.annotation.Nullable}, to ensure that Dagger can be
+   * built without depending on JSR-305.
+   */
+  @interface Nullable {}
+
+  @Provides
+  @Nullable
+  static Object nullObject() {
+    return null;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/UnwrappedAnnotationKey.java b/compiler/src/it/functional-tests/src/main/java/test/UnwrappedAnnotationKey.java
index 21ed95841..d1a3b4863 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/UnwrappedAnnotationKey.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/UnwrappedAnnotationKey.java
@@ -16,7 +16,7 @@
 package test;
 
 import dagger.MapKey;
-import dagger.mapkeys.StringKey;
+import dagger.multibindings.StringKey;
 
 @MapKey(unwrapValue = true)
 @interface UnwrappedAnnotationKey {
diff --git a/compiler/src/it/functional-tests/src/main/java/test/WrappedAnnotationKey.java b/compiler/src/it/functional-tests/src/main/java/test/WrappedAnnotationKey.java
index 5d6e86dc7..7f0dbafab 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/WrappedAnnotationKey.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/WrappedAnnotationKey.java
@@ -16,8 +16,8 @@
 package test;
 
 import dagger.MapKey;
-import dagger.mapkeys.ClassKey;
-import dagger.mapkeys.StringKey;
+import dagger.multibindings.ClassKey;
+import dagger.multibindings.StringKey;
 
 @MapKey(unwrapValue = false)
 @interface WrappedAnnotationKey {
diff --git a/compiler/src/it/functional-tests/src/test/java/test/BasicTest.java b/compiler/src/it/functional-tests/src/test/java/test/BasicTest.java
index fe9c6afe9..4514457c1 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/BasicTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/BasicTest.java
@@ -113,4 +113,11 @@
   @Theory public void inheritedMembersInjection(BasicComponent basicComponent) {
     assertThat(basicComponent.typeWithInheritedMembersInjection().thing).isNotNull();
   }
+  
+  @Theory
+  public void nullableInjection(BasicComponent basicComponent) {
+    assertThat(basicComponent.nullObject()).isNull();
+    assertThat(basicComponent.nullObjectProvider().get()).isNull();
+    assertThat(basicComponent.lazyNullObject().get()).isNull();
+  }
 }
diff --git a/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java b/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
index e0ad8e651..a28110b91 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
@@ -15,8 +15,8 @@
 
 import com.google.auto.value.AutoAnnotation;
 import com.google.common.collect.ImmutableMap;
-import dagger.mapkeys.ClassKey;
-import dagger.mapkeys.StringKey;
+import dagger.multibindings.ClassKey;
+import dagger.multibindings.StringKey;
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.util.Map;
@@ -154,7 +154,7 @@ public void shortKeyMap() {
   @Test public void complexQualifierSet() {
     assertThat(multibindingComponent.complexQualifierStringSet()).containsExactly("foo");
   }
-  
+
   @Test
   public void emptySet() {
     assertThat(multibindingComponent.emptySet()).isEmpty();
diff --git a/compiler/src/it/producers-functional-tests/pom.xml b/compiler/src/it/producers-functional-tests/pom.xml
index a0d16498a..b8add885f 100644
--- a/compiler/src/it/producers-functional-tests/pom.xml
+++ b/compiler/src/it/producers-functional-tests/pom.xml
@@ -22,7 +22,7 @@ limitations under the License.
   <parent>
     <groupId>com.google.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>2.1-SNAPSHOT</version>
+    <version>2.2-SNAPSHOT</version>
   </parent>
   <groupId>dagger.tests</groupId>
   <artifactId>producers-functional-tests</artifactId>
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/SimpleProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/SimpleProducerModule.java
index 2d831ed7f..63500ca0c 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/SimpleProducerModule.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/SimpleProducerModule.java
@@ -19,6 +19,7 @@
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
 import com.google.common.util.concurrent.SettableFuture;
+import dagger.Lazy;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
 import dagger.producers.ProducerModule;
@@ -130,6 +131,15 @@ static String strWithArgsThrowingException(
     return Futures.immediateFuture("str with args throwing exception");
   }
 
+  @Produces
+  @Qual(12)
+  static String strWithFrameworkTypeArgs(
+      @Qual(1) int i, @Qual(1) Provider<Integer> iProvider, @Qual(1) Lazy<Integer> iLazy,
+      @Qual(2) int j, @Qual(2) Produced<Integer> jProduced, @Qual(2) Producer<Integer> jProducer,
+      @Qual(3) Produced<Integer> kProduced, @Qual(3) Producer<Integer> kProducer) {
+    return "str with framework type args";
+  }
+
   // Set bindings.
 
   @Produces(type = SET)
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingProducerModule.java
index d63da4d50..8e311f8fe 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingProducerModule.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingProducerModule.java
@@ -19,7 +19,7 @@
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.Multibindings;
-import dagger.mapkeys.IntKey;
+import dagger.multibindings.IntKey;
 import dagger.producers.Produced;
 import dagger.producers.ProducerModule;
 import dagger.producers.Produces;
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/SubcomponentsWithBoundExecutor.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/SubcomponentsWithBoundExecutor.java
index 0e0fae51d..138791826 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/SubcomponentsWithBoundExecutor.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/SubcomponentsWithBoundExecutor.java
@@ -124,6 +124,7 @@ static String fromChild(@FromParent String fromParent) {
     ListenableFuture<String> fromChild();
 
     GrandchildComponent.Builder newGrandchildComponentBuilder();
+    GrandchildComponentWithoutBuilder newGrandchildComponent();
 
     @ProductionSubcomponent.Builder
     interface Builder {
@@ -164,5 +165,11 @@ static String fromGranchild(@FromChild String fromChild) {
     }
   }
 
+  @ProductionSubcomponent(modules = GrandchildProducerModule.class)
+  interface GrandchildComponentWithoutBuilder {
+    @FromGrandchild
+    ListenableFuture<String> fromGrandchild();
+  }
+
   private SubcomponentsWithBoundExecutor() {}
 }
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/SubcomponentWithBoundExecutorTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/SubcomponentWithBoundExecutorTest.java
index 389a8d4b6..78cbadade 100644
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/SubcomponentWithBoundExecutorTest.java
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/SubcomponentWithBoundExecutorTest.java
@@ -23,6 +23,7 @@
 import producerstest.subcomponent.SubcomponentsWithBoundExecutor.ChildComponent;
 import producerstest.subcomponent.SubcomponentsWithBoundExecutor.ExecutorModule;
 import producerstest.subcomponent.SubcomponentsWithBoundExecutor.GrandchildComponent;
+import producerstest.subcomponent.SubcomponentsWithBoundExecutor.GrandchildComponentWithoutBuilder;
 import producerstest.subcomponent.SubcomponentsWithBoundExecutor.ParentComponent;
 import producerstest.subcomponent.SubcomponentsWithBoundExecutor.ParentProductionComponent;
 
@@ -72,6 +73,15 @@ public void topLevelComponent_grandchild() throws Exception {
     assertThat(executionCount.get()).isEqualTo(2);
   }
 
+  @Test
+  public void topLevelComponent_grandchildWithoutBuilder() throws Exception {
+    ChildComponent child = parentComponent.newChildComponentBuilder().build();
+    GrandchildComponentWithoutBuilder grandchild = child.newGrandchildComponent();
+    assertThat(grandchild.fromGrandchild().get()).isEqualTo("grandchild:child:parent");
+    assertThat(executorConstructionCount.get()).isEqualTo(1);
+    assertThat(executionCount.get()).isEqualTo(2);
+  }
+
   @Test
   public void topLevelProductionComponent_child() throws Exception {
     ChildComponent child = parentProductionComponent.newChildComponentBuilder().build();
@@ -88,4 +98,13 @@ public void topLevelProductionComponent_grandchild() throws Exception {
     assertThat(executorConstructionCount.get()).isEqualTo(1);
     assertThat(executionCount.get()).isEqualTo(3);
   }
+
+  @Test
+  public void topLevelProductionComponent_grandchildWithoutBuilder() throws Exception {
+    ChildComponent child = parentProductionComponent.newChildComponentBuilder().build();
+    GrandchildComponentWithoutBuilder grandchild = child.newGrandchildComponent();
+    assertThat(grandchild.fromGrandchild().get()).isEqualTo("grandchild:child:parentproduction");
+    assertThat(executorConstructionCount.get()).isEqualTo(1);
+    assertThat(executionCount.get()).isEqualTo(3);
+  }
 }
diff --git a/compiler/src/it/tck/pom.xml b/compiler/src/it/tck/pom.xml
index 34a018f7d..cc4b196cc 100644
--- a/compiler/src/it/tck/pom.xml
+++ b/compiler/src/it/tck/pom.xml
@@ -22,7 +22,7 @@ limitations under the License.
   <parent>
     <groupId>com.google.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>2.1-SNAPSHOT</version>
+    <version>2.2-SNAPSHOT</version>
   </parent>
   <groupId>dagger.tests</groupId>
   <artifactId>tck</artifactId>
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 68a78e783..2eb20921b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -62,6 +62,7 @@
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.PrimitiveType;
+import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.SimpleTypeVisitor6;
@@ -87,6 +88,7 @@
 import static dagger.internal.codegen.ContributionBinding.Kind.IS_SYNTHETIC_KIND;
 import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MULTIBOUND_MAP;
 import static dagger.internal.codegen.ContributionType.indexByContributionType;
+import static dagger.internal.codegen.ErrorMessages.CANNOT_INJECT_WILDCARD_TYPE;
 import static dagger.internal.codegen.ErrorMessages.CONTAINS_DEPENDENCY_CYCLE_FORMAT;
 import static dagger.internal.codegen.ErrorMessages.DUPLICATE_SIZE_LIMIT;
 import static dagger.internal.codegen.ErrorMessages.INDENT;
@@ -277,14 +279,13 @@ private void traverseRequest(
     }
 
     /**
-     * Validates that the set of bindings resolved is consistent with the type of the binding, and
-     * returns true if the bindings are valid.
+     * Reports errors if the set of bindings resolved is inconsistent with the type of the binding.
      */
-    private boolean validateResolvedBinding(
+    private void validateResolvedBinding(
         Deque<ResolvedRequest> path, ResolvedBindings resolvedBinding) {
       if (resolvedBinding.isEmpty()) {
         reportMissingBinding(path);
-        return false;
+        return;
       }
 
       switch (resolvedBinding.bindingKey().kind()) {
@@ -298,13 +299,13 @@ private boolean validateResolvedBinding(
           validateNullability(path.peek().request(), resolvedBinding.contributionBindings());
           if (resolvedBinding.contributionBindings().size() > 1) {
             reportDuplicateBindings(path);
-            return false;
+            return;
           }
           ContributionBinding contributionBinding = resolvedBinding.contributionBinding();
           if (contributionBinding.bindingType().equals(BindingType.PRODUCTION)
               && doesPathRequireProvisionOnly(path)) {
             reportProviderMayNotDependOnProducer(path);
-            return false;
+            return;
           }
           if (compilerOptions.usesProducers()) {
             Key productionImplementationExecutorKey =
@@ -317,7 +318,7 @@ private boolean validateResolvedBinding(
                 if (request.key().equals(productionExecutorKey)
                     || request.key().equals(productionImplementationExecutorKey)) {
                   reportDependsOnProductionExecutor(path);
-                  return false;
+                  return;
                 }
               }
             }
@@ -325,10 +326,8 @@ private boolean validateResolvedBinding(
           if (contributionBinding.bindingKind().equals(SYNTHETIC_MULTIBOUND_MAP)) {
             ImmutableSet<ContributionBinding> multibindings =
                 inlineSyntheticContributions(resolvedBinding).contributionBindings();
-            boolean duplicateMapKeys = reportIfDuplicateMapKeys(path, multibindings);
-            boolean inconsistentMapKeyAnnotationTypes =
-                reportIfInconsistentMapKeyAnnotationTypes(path, multibindings);
-            return !duplicateMapKeys && !inconsistentMapKeyAnnotationTypes;
+            validateMapKeySet(path, multibindings);
+            validateMapKeyAnnotationTypes(path, multibindings);
           }
           break;
         case MEMBERS_INJECTION:
@@ -340,13 +339,13 @@ private boolean validateResolvedBinding(
           }
           if (resolvedBinding.bindings().size() > 1) {
             reportDuplicateBindings(path);
-            return false;
+            return;
           }
-          return validateMembersInjectionBinding(getOnlyElement(resolvedBinding.bindings()), path);
+          validateMembersInjectionBinding(getOnlyElement(resolvedBinding.bindings()), path);
+          return;
         default:
           throw new AssertionError();
       }
-      return true;
     }
 
     /**
@@ -440,57 +439,49 @@ private void validateNullability(DependencyRequest request, Set<ContributionBind
     }
 
     /**
-     * Returns {@code true} (and reports errors) if {@code mapBindings} has more than one binding
-     * for the same map key.
+     * Reports errors if {@code mapBindings} has more than one binding for the same map key.
      */
-    private boolean reportIfDuplicateMapKeys(
+    private void validateMapKeySet(
         Deque<ResolvedRequest> path, Set<ContributionBinding> mapBindings) {
-      boolean hasDuplicateMapKeys = false;
       for (Collection<ContributionBinding> mapBindingsForMapKey :
           indexMapBindingsByMapKey(mapBindings).asMap().values()) {
         if (mapBindingsForMapKey.size() > 1) {
-          hasDuplicateMapKeys = true;
           reportDuplicateMapKeys(path, mapBindingsForMapKey);
         }
       }
-      return hasDuplicateMapKeys;
     }
 
     /**
-     * Returns {@code true} (and reports errors) if {@code mapBindings} uses more than one
-     * {@link MapKey} annotation type.
+     * Reports errors if {@code mapBindings} uses more than one {@link MapKey} annotation type.
      */
-    private boolean reportIfInconsistentMapKeyAnnotationTypes(
+    private void validateMapKeyAnnotationTypes(
         Deque<ResolvedRequest> path, Set<ContributionBinding> contributionBindings) {
       ImmutableSetMultimap<Equivalence.Wrapper<DeclaredType>, ContributionBinding>
           mapBindingsByAnnotationType = indexMapBindingsByAnnotationType(contributionBindings);
       if (mapBindingsByAnnotationType.keySet().size() > 1) {
         reportInconsistentMapKeyAnnotations(path, mapBindingsByAnnotationType);
-        return true;
       }
-      return false;
     }
 
     /**
-     * Validates a members injection binding, returning false (and reporting the error) if it wasn't
-     * valid.
+     * Reports errors if a members injection binding is invalid.
      */
-    private boolean validateMembersInjectionBinding(
+    private void validateMembersInjectionBinding(
         Binding binding, final Deque<ResolvedRequest> path) {
-      return binding
+      binding
           .key()
           .type()
           .accept(
-              new SimpleTypeVisitor6<Boolean, Void>() {
+              new SimpleTypeVisitor6<Void, Void>() {
                 @Override
-                protected Boolean defaultAction(TypeMirror e, Void p) {
+                protected Void defaultAction(TypeMirror e, Void p) {
                   reportBuilder.addError(
                       "Invalid members injection request.", path.peek().request().requestElement());
-                  return false;
+                  return null;
                 }
 
                 @Override
-                public Boolean visitDeclared(DeclaredType type, Void ignored) {
+                public Void visitDeclared(DeclaredType type, Void ignored) {
                   // If the key has type arguments, validate that each type argument is declared.
                   // Otherwise the type argument may be a wildcard (or other type), and we can't
                   // resolve that to actual types.  If the arg was an array, validate the type
@@ -552,7 +543,7 @@ public Boolean visitPrimitive(PrimitiveType t, Void p) {
                               type.toString(),
                               Joiner.on('\n').join(printableDependencyPath)),
                           path.peek().request().requestElement());
-                      return false;
+                      return null;
                     }
                   }
 
@@ -576,10 +567,8 @@ public Boolean visitPrimitive(PrimitiveType t, Void p) {
                             type.toString(),
                             Joiner.on('\n').join(printableDependencyPath)),
                         path.peek().request().requestElement());
-                    return false;
                   }
-
-                  return true; // valid
+                  return null;
                 }
               },
               null);
@@ -875,40 +864,59 @@ private void reportProviderMayNotDependOnProducer(Deque<ResolvedRequest> path) {
       reportBuilder.addError(errorMessage.toString(), path.getLast().request().requestElement());
     }
 
-    private void reportMissingBinding(Deque<ResolvedRequest> path) {
-      Key key = path.peek().request().key();
-      BindingKey bindingKey = path.peek().request().bindingKey();
-      boolean requiresContributionMethod = !key.isValidImplicitProvisionKey(types);
-      boolean requiresProvision = doesPathRequireProvisionOnly(path);
-      StringBuilder errorMessage = new StringBuilder();
-      String requiresErrorMessageFormat = requiresContributionMethod
-          ? requiresProvision
+    /**
+     * Descriptive portion of the error message for when the given request has no binding.
+     * Currently, the only other portions of the message are the dependency path, line number and
+     * filename. Not static because it uses the instance field types.
+     */
+    private StringBuilder requiresErrorMessageBase(Deque<ResolvedRequest> path) {
+      DependencyRequest request = path.peek().request();
+      Key key = request.key();
+      String requiresErrorMessageFormat;
+      // TODO(dpb): Check for wildcard injection somewhere else first?
+      if (key.type().getKind().equals(TypeKind.WILDCARD)) {
+        requiresErrorMessageFormat = CANNOT_INJECT_WILDCARD_TYPE;
+      } else {
+        boolean requiresProvision = doesPathRequireProvisionOnly(path);
+        if (!key.isValidImplicitProvisionKey(types)) {
+          requiresErrorMessageFormat = requiresProvision
               ? REQUIRES_PROVIDER_FORMAT
-              : REQUIRES_PROVIDER_OR_PRODUCER_FORMAT
-          : requiresProvision
+              : REQUIRES_PROVIDER_OR_PRODUCER_FORMAT;
+        } else {
+          requiresErrorMessageFormat = requiresProvision
               ? REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_FORMAT
               : REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_OR_PRODUCER_FORMAT;
-      errorMessage.append(String.format(requiresErrorMessageFormat, keyFormatter.format(key)));
+        }
+      }
+      StringBuilder errorMessage = new StringBuilder(
+          String.format(requiresErrorMessageFormat, keyFormatter.format(key)));
       if (key.isValidMembersInjectionKey()) {
         Optional<MembersInjectionBinding> membersInjectionBinding =
             injectBindingRegistry.getOrFindMembersInjectionBinding(key);
         if (membersInjectionBinding.isPresent()
             && !membersInjectionBinding.get().injectionSites().isEmpty()) {
-          errorMessage.append(" ").append(ErrorMessages.MEMBERS_INJECTION_DOES_NOT_IMPLY_PROVISION);
+          errorMessage.append(" ");
+          errorMessage.append(ErrorMessages.MEMBERS_INJECTION_DOES_NOT_IMPLY_PROVISION);
         }
       }
+      return errorMessage;
+    }
+
+    private void reportMissingBinding(Deque<ResolvedRequest> path) {
+      StringBuilder errorMessage = requiresErrorMessageBase(path);
       ImmutableList<String> printableDependencyPath =
           FluentIterable.from(path)
+              .filter(Predicates.not(SYNTHETIC_BINDING))
               .transform(REQUEST_FROM_RESOLVED_REQUEST)
               .transform(dependencyRequestFormatter)
               .filter(Predicates.not(Predicates.equalTo("")))
               .toList()
               .reverse();
-      for (String dependency :
-          printableDependencyPath.subList(1, printableDependencyPath.size())) {
+      for (String dependency : Iterables.skip(printableDependencyPath, 1)) {
         errorMessage.append('\n').append(dependency);
       }
-      for (String suggestion : MissingBindingSuggestions.forKey(topLevelGraph(), bindingKey)) {
+      for (String suggestion : MissingBindingSuggestions.forKey(topLevelGraph(),
+          path.peek().request().bindingKey())) {
         errorMessage.append('\n').append(suggestion);
       }
       reportBuilder.addError(errorMessage.toString(), path.getLast().request().requestElement());
@@ -1065,12 +1073,14 @@ private void reportCycle(
               CONTAINS_DEPENDENCY_CYCLE_FORMAT,
               componentType.getQualifiedName(),
               rootRequestElement.getSimpleName(),
-              Joiner.on("\n")
-                  .join(
-                      FluentIterable.from(requestPath)
-                          .transform(dependencyRequestFormatter)
-                          .filter(not(equalTo("")))
-                          .skip(1))),
+              FluentIterable.from(bindingPath) // TODO(dpb): Resolve with similar code above.
+                  .skip(1)
+                  .filter(Predicates.not(SYNTHETIC_BINDING))
+                  .transform(REQUEST_FROM_RESOLVED_REQUEST)
+                  .append(request)
+                  .transform(dependencyRequestFormatter)
+                  .filter(not(equalTo("")))
+                  .join(Joiner.on('\n'))),
           ERROR,
           rootRequestElement);
     }
@@ -1245,8 +1255,17 @@ static ResolvedRequest create(DependencyRequest request, BindingGraph graph) {
 
   private static final Function<ResolvedRequest, DependencyRequest> REQUEST_FROM_RESOLVED_REQUEST =
       new Function<ResolvedRequest, DependencyRequest>() {
-        @Override public DependencyRequest apply(ResolvedRequest resolvedRequest) {
+        @Override
+        public DependencyRequest apply(ResolvedRequest resolvedRequest) {
           return resolvedRequest.request();
         }
       };
+
+  private static final Predicate<ResolvedRequest> SYNTHETIC_BINDING =
+      new Predicate<ResolvedRequest>() {
+        @Override
+        public boolean apply(ResolvedRequest request) {
+          return request.binding().isSyntheticContribution();
+        }
+      };
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/CompilerOptions.java b/compiler/src/main/java/dagger/internal/codegen/CompilerOptions.java
index aa92fa5c5..88a806109 100644
--- a/compiler/src/main/java/dagger/internal/codegen/CompilerOptions.java
+++ b/compiler/src/main/java/dagger/internal/codegen/CompilerOptions.java
@@ -15,7 +15,9 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.value.AutoValue;
 import com.google.common.base.Ascii;
+import com.google.common.collect.ImmutableSet;
 import dagger.producers.Produces;
 import java.util.EnumSet;
 import java.util.Map;
@@ -25,54 +27,45 @@
 import javax.tools.Diagnostic;
 
 /** A collection of options that dictate how the compiler will run. */
-final class CompilerOptions {
-  private final boolean usesProducers;
-  private final Diagnostic.Kind nullableValidationKind;
-  private final Diagnostic.Kind privateMemberValidationKind;
-  private final Diagnostic.Kind staticMemberValidationKind;
-  private final ValidationType scopeCycleValidationType;
-
-  CompilerOptions(ProcessingEnvironment processingEnv, Elements elements) {
-    this(
-        elements.getTypeElement(Produces.class.getCanonicalName()) != null,
-        nullableValidationType(processingEnv).diagnosticKind().get(),
-        privateMemberValidationType(processingEnv).diagnosticKind().get(),
-        staticMemberValidationType(processingEnv).diagnosticKind().get(),
-        scopeValidationType(processingEnv));
+@AutoValue
+abstract class CompilerOptions {
+  abstract boolean usesProducers();
+  abstract boolean writeProducerNameInToken();
+  abstract Diagnostic.Kind nullableValidationKind();
+  abstract Diagnostic.Kind privateMemberValidationKind();
+  abstract Diagnostic.Kind staticMemberValidationKind();
+  abstract ValidationType scopeCycleValidationType();
+
+  static Builder builder() {
+    return new AutoValue_CompilerOptions.Builder();
   }
 
-  CompilerOptions(
-      boolean usesProducers,
-      Diagnostic.Kind nullableValidationKind,
-      Diagnostic.Kind privateMemberValidationKind,
-      Diagnostic.Kind staticMemberValidationKind,
-      ValidationType scopeCycleValidationType) {
-    this.usesProducers = usesProducers;
-    this.nullableValidationKind = nullableValidationKind;
-    this.privateMemberValidationKind = privateMemberValidationKind;
-    this.staticMemberValidationKind = staticMemberValidationKind;
-    this.scopeCycleValidationType = scopeCycleValidationType;
+  static CompilerOptions create(ProcessingEnvironment processingEnv, Elements elements) {
+    return builder()
+        .usesProducers(elements.getTypeElement(Produces.class.getCanonicalName()) != null)
+        .writeProducerNameInToken(
+            writeProducerNameInToken(processingEnv).equals(FeatureStatus.ENABLED))
+        .nullableValidationKind(nullableValidationType(processingEnv).diagnosticKind().get())
+        .privateMemberValidationKind(
+            privateMemberValidationType(processingEnv).diagnosticKind().get())
+        .staticMemberValidationKind(
+            staticMemberValidationType(processingEnv).diagnosticKind().get())
+        .scopeCycleValidationType(scopeValidationType(processingEnv))
+        .build();
   }
 
-  boolean usesProducers() {
-    return usesProducers;
+  @AutoValue.Builder
+  interface Builder {
+    Builder usesProducers(boolean usesProduces);
+    Builder writeProducerNameInToken(boolean writeProducerNameInToken);
+    Builder nullableValidationKind(Diagnostic.Kind kind);
+    Builder privateMemberValidationKind(Diagnostic.Kind kind);
+    Builder staticMemberValidationKind(Diagnostic.Kind kind);
+    Builder scopeCycleValidationType(ValidationType type);
+    CompilerOptions build();
   }
 
-  Diagnostic.Kind nullableValidationKind() {
-    return nullableValidationKind;
-  }
-
-  Diagnostic.Kind privateMemberValidationKind() {
-    return privateMemberValidationKind;
-  }
-
-  Diagnostic.Kind staticMemberValidationKind() {
-    return staticMemberValidationKind;
-  }
-
-  ValidationType scopeCycleValidationType() {
-    return scopeCycleValidationType;
-  }
+  static final String WRITE_PRODUCER_NAME_IN_TOKEN_KEY = "dagger.writeProducerNameInToken";
 
   static final String DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY =
       "dagger.disableInterComponentScopeValidation";
@@ -83,6 +76,21 @@ ValidationType scopeCycleValidationType() {
 
   static final String STATIC_MEMBER_VALIDATION_TYPE_KEY = "dagger.staticMemberValidation";
 
+  static final ImmutableSet<String> SUPPORTED_OPTIONS = ImmutableSet.of(
+        WRITE_PRODUCER_NAME_IN_TOKEN_KEY,
+        DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY,
+        NULLABLE_VALIDATION_KEY,
+        PRIVATE_MEMBER_VALIDATION_TYPE_KEY,
+        STATIC_MEMBER_VALIDATION_TYPE_KEY);
+
+  private static FeatureStatus writeProducerNameInToken(ProcessingEnvironment processingEnv) {
+    return valueOf(
+        processingEnv,
+        WRITE_PRODUCER_NAME_IN_TOKEN_KEY,
+        FeatureStatus.DISABLED,
+        EnumSet.allOf(FeatureStatus.class));
+  }
+
   private static ValidationType scopeValidationType(ProcessingEnvironment processingEnv) {
     return valueOf(
         processingEnv,
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index 2d1d98149..2060f199b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -27,6 +27,7 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
 import com.google.common.util.concurrent.ListenableFuture;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.squareup.javapoet.ClassName;
 import dagger.Component;
 import dagger.Lazy;
@@ -253,6 +254,7 @@ boolean isProducer() {
         .toSet();
   }
 
+  @CanIgnoreReturnValue
   private static Set<ModuleDescriptor> addTransitiveModules(
       Set<ModuleDescriptor> transitiveModules, ModuleDescriptor module) {
     if (transitiveModules.add(module)) {
@@ -593,6 +595,7 @@ private ComponentMethodDescriptor getDescriptorForComponentMethod(
           map.build(), buildMethod, element.getEnclosingElement().asType()));
     }
 
+    // TODO(beder): Remove the executor dependency when all clients have been updated.
     private Optional<TypeElement> createExecutorDependency(
         Kind componentKind, Optional<BuilderSpec> builderSpec) {
       if (!componentKind.isProducer()) {
@@ -600,10 +603,11 @@ private ComponentMethodDescriptor getDescriptorForComponentMethod(
       }
       TypeElement executorTypeElement = elements.getTypeElement(Executor.class.getCanonicalName());
       if (!builderSpec.isPresent()) {
-        // if there's no builder, we'll add an executor() method to the generated builder so it
-        // must be specified
-        // TODO(beder): Remove this behavior.
-        return Optional.of(executorTypeElement);
+        // if there's no builder on a component (not a subcomponent!), we'll add an executor()
+        // method to the generated builder so it must be specified
+        return componentKind.equals(Kind.PRODUCTION_COMPONENT)
+            ? Optional.of(executorTypeElement)
+            : Optional.<TypeElement>absent();
       }
       return builderSpec.get().methodMap().containsKey(executorTypeElement)
           ? Optional.of(executorTypeElement)
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index 90126f9db..3d439dd47 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -18,7 +18,6 @@
 import com.google.auto.common.BasicAnnotationProcessor;
 import com.google.auto.service.AutoService;
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableSet;
 import java.util.Set;
 import javax.annotation.processing.Filer;
 import javax.annotation.processing.Messager;
@@ -49,11 +48,7 @@ public SourceVersion getSupportedSourceVersion() {
 
   @Override
   public Set<String> getSupportedOptions() {
-    return ImmutableSet.of(
-        CompilerOptions.DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY,
-        CompilerOptions.NULLABLE_VALIDATION_KEY,
-        CompilerOptions.PRIVATE_MEMBER_VALIDATION_TYPE_KEY,
-        CompilerOptions.STATIC_MEMBER_VALIDATION_TYPE_KEY);
+    return CompilerOptions.SUPPORTED_OPTIONS;
   }
 
   @Override
@@ -63,7 +58,7 @@ public SourceVersion getSupportedSourceVersion() {
     Elements elements = processingEnv.getElementUtils();
     Filer filer = processingEnv.getFiler();
 
-    CompilerOptions compilerOptions = new CompilerOptions(processingEnv, elements);
+    CompilerOptions compilerOptions = CompilerOptions.create(processingEnv, elements);
 
     MethodSignatureFormatter methodSignatureFormatter = new MethodSignatureFormatter(types);
     HasSourceElementFormatter hasSourceElementFormatter =
@@ -99,7 +94,7 @@ public SourceVersion getSupportedSourceVersion() {
     ComponentGenerator componentGenerator =
         new ComponentGenerator(filer, elements, types, keyFactory, compilerOptions);
     ProducerFactoryGenerator producerFactoryGenerator =
-        new ProducerFactoryGenerator(filer, elements);
+        new ProducerFactoryGenerator(filer, elements, compilerOptions);
     MonitoringModuleGenerator monitoringModuleGenerator =
         new MonitoringModuleGenerator(filer, elements);
     ProductionExecutorModuleGenerator productionExecutorModuleGenerator =
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
index 0e5f1f240..bbebdee3c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
@@ -18,6 +18,7 @@
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.Optional;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.List;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
@@ -137,8 +138,9 @@ public String visitType(TypeElement e, Optional<AnnotationMirror> p) {
     }, qualifier);
   }
 
-  private StringBuilder appendParameter(VariableElement parameter, TypeMirror type,
-      StringBuilder builder) {
+  @CanIgnoreReturnValue
+  private StringBuilder appendParameter(
+      VariableElement parameter, TypeMirror type, StringBuilder builder) {
     return builder.append(type).append(' ').append(parameter.getSimpleName());
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index 3737805e0..17b57e416 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -95,6 +95,9 @@
   static final String INJECT_INTO_PRIVATE_CLASS =
       "Dagger does not support injection into private classes";
 
+  static final String CANNOT_INJECT_WILDCARD_TYPE =
+      "Dagger does not support injecting Provider<T>, Lazy<T> or Produced<T> when T is a wildcard "
+          + "type such as <%s>.";
   /*
    * Configuration errors
    *
diff --git a/compiler/src/main/java/dagger/internal/codegen/FeatureStatus.java b/compiler/src/main/java/dagger/internal/codegen/FeatureStatus.java
new file mode 100644
index 000000000..792d67e53
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/FeatureStatus.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+/** Allows options to control how features in component processing are enabled. */
+enum FeatureStatus {
+  ENABLED,
+  DISABLED;
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/FrameworkDependency.java b/compiler/src/main/java/dagger/internal/codegen/FrameworkDependency.java
index 57851cbf0..1b941e475 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FrameworkDependency.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FrameworkDependency.java
@@ -117,6 +117,19 @@
     return frameworkDependencies.build();
   }
 
+  /** Indexes {@code dependencies} by their {@link #dependencyRequests()}. */
+  static ImmutableMap<DependencyRequest, FrameworkDependency> indexByDependencyRequest(
+      Iterable<FrameworkDependency> dependencies) {
+    ImmutableMap.Builder<DependencyRequest, FrameworkDependency> frameworkDependencyMap =
+        ImmutableMap.builder();
+    for (FrameworkDependency dependency : dependencies) {
+      for (DependencyRequest request : dependency.dependencyRequests()) {
+        frameworkDependencyMap.put(request, dependency);
+      }
+    }
+    return frameworkDependencyMap.build();
+  }
+
   /**
    * Groups {@code binding}'s implicit dependencies by their binding key, using the dependency keys
    * from the {@link Binding#unresolved()} binding if it exists.
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
index 88b982588..3342df9b5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
@@ -24,6 +24,7 @@
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.squareup.javapoet.ClassName;
 import dagger.Component;
 import dagger.Provides;
@@ -183,21 +184,18 @@ void generateSourcesForRequiredBindings(FactoryGenerator factoryGenerator,
    * Registers the binding for generation and later lookup. If the binding is resolved, we also
    * attempt to register an unresolved version of it.
    */
-  private ProvisionBinding registerBinding(
-      ProvisionBinding binding, boolean warnIfNotAlreadyGenerated) {
+  private void registerBinding(ProvisionBinding binding, boolean warnIfNotAlreadyGenerated) {
     provisionBindings.tryRegisterBinding(binding, warnIfNotAlreadyGenerated);
     if (binding.unresolved().isPresent()) {
       provisionBindings.tryToGenerateBinding(binding.unresolved().get(), warnIfNotAlreadyGenerated);
     }
-    return binding;
   }
 
   /**
    * Registers the binding for generation and later lookup. If the binding is resolved, we also
    * attempt to register an unresolved version of it.
    */
-  private MembersInjectionBinding registerBinding(
-      MembersInjectionBinding binding, boolean warnIfNotAlreadyGenerated) {
+  private void registerBinding(MembersInjectionBinding binding, boolean warnIfNotAlreadyGenerated) {
     /*
      * We generate MembersInjector classes for types with @Inject constructors only if they have any
      * injection sites.
@@ -217,13 +215,14 @@ private MembersInjectionBinding registerBinding(
       membersInjectionBindings.tryToGenerateBinding(
           binding.unresolved().get(), warnIfNotAlreadyGenerated);
     }
-    return binding;
   }
 
+  @CanIgnoreReturnValue
   Optional<ProvisionBinding> tryRegisterConstructor(ExecutableElement constructorElement) {
     return tryRegisterConstructor(constructorElement, Optional.<TypeMirror>absent(), false);
   }
 
+  @CanIgnoreReturnValue
   private Optional<ProvisionBinding> tryRegisterConstructor(
       ExecutableElement constructorElement,
       Optional<TypeMirror> resolvedType,
@@ -250,10 +249,12 @@ private MembersInjectionBinding registerBinding(
     return Optional.absent();
   }
 
+  @CanIgnoreReturnValue
   Optional<MembersInjectionBinding> tryRegisterMembersInjectedType(TypeElement typeElement) {
     return tryRegisterMembersInjectedType(typeElement, Optional.<TypeMirror>absent(), false);
   }
 
+  @CanIgnoreReturnValue
   private Optional<MembersInjectionBinding> tryRegisterMembersInjectedType(
       TypeElement typeElement,
       Optional<TypeMirror> resolvedType,
@@ -279,6 +280,7 @@ private MembersInjectionBinding registerBinding(
     return Optional.absent();
   }
 
+  @CanIgnoreReturnValue
   Optional<ProvisionBinding> getOrFindProvisionBinding(Key key) {
     checkNotNull(key);
     if (!key.isValidImplicitProvisionKey(types)) {
@@ -321,6 +323,7 @@ public boolean apply(ExecutableElement constructor) {
    * Returns a {@link MembersInjectionBinding} for {@code key}. If none has been registered yet,
    * registers one, along with all necessary members injection bindings for superclasses.
    */
+  @CanIgnoreReturnValue
   Optional<MembersInjectionBinding> getOrFindMembersInjectionBinding(Key key) {
     checkNotNull(key);
     // TODO(gak): is checking the kind enough?
diff --git a/compiler/src/main/java/dagger/internal/codegen/JavaPoetSourceFileGenerator.java b/compiler/src/main/java/dagger/internal/codegen/JavaPoetSourceFileGenerator.java
index 0c7da456c..48bbb2816 100644
--- a/compiler/src/main/java/dagger/internal/codegen/JavaPoetSourceFileGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/JavaPoetSourceFileGenerator.java
@@ -104,7 +104,7 @@ private JavaFile buildJavaFile(
             .skipJavaLangImports(true);
     if (!generatedAnnotationAvailable) {
       javaFileBuilder.addFileComment(
-          "Generated by %s (%s).", ComponentProcessor.class.getName(), GENERATED_COMMENTS);
+          "Generated by $L ($L).", ComponentProcessor.class.getName(), GENERATED_COMMENTS);
     }
     return javaFileBuilder.build();
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index a1650b0b2..635cc5421 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -153,7 +153,7 @@ Key withoutBindingMethod() {
   }
 
   boolean isValidMembersInjectionKey() {
-    return !qualifier().isPresent();
+    return !qualifier().isPresent() && !type().getKind().equals(TypeKind.WILDCARD);
   }
 
   /**
@@ -535,10 +535,11 @@ Key forProductionImplementationExecutor() {
      * {@code Set<Produced<T>>}.
      */
     Optional<Key> implicitSetKeyFromProduced(Key possibleSetOfProducedKey) {
-      if (MoreTypes.isTypeOf(Set.class, possibleSetOfProducedKey.type())) {
+      if (MoreTypes.isType(possibleSetOfProducedKey.type())
+          && MoreTypes.isTypeOf(Set.class, possibleSetOfProducedKey.type())) {
         TypeMirror argType =
             MoreTypes.asDeclared(possibleSetOfProducedKey.type()).getTypeArguments().get(0);
-        if (MoreTypes.isTypeOf(Produced.class, argType)) {
+        if (MoreTypes.isType(argType) && MoreTypes.isTypeOf(Produced.class, argType)) {
           TypeMirror producedArgType = MoreTypes.asDeclared(argType).getTypeArguments().get(0);
           TypeMirror setType = types.getDeclaredType(getSetElement(), producedArgType);
           return Optional.of(possibleSetOfProducedKey.withType(types, setType));
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
index 476469a59..d76099bfb 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
@@ -20,6 +20,7 @@
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableList;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.MethodSpec;
@@ -38,14 +39,14 @@
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.SimpleTypeVisitor6;
 
-import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static com.squareup.javapoet.MethodSpec.constructorBuilder;
+import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static com.squareup.javapoet.TypeSpec.classBuilder;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.MapKeys.getMapKeyCreatorClassName;
 import static javax.lang.model.element.Modifier.FINAL;
-import static javax.lang.model.element.Modifier.PUBLIC;
 import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PUBLIC;
 import static javax.lang.model.element.Modifier.STATIC;
 import static javax.lang.model.util.ElementFilter.methodsIn;
 
@@ -150,6 +151,7 @@ private MethodSpec buildCreateMethod(
     return nestedAnnotationElements(annotationElement, new LinkedHashSet<TypeElement>());
   }
 
+  @CanIgnoreReturnValue
   private static Set<TypeElement> nestedAnnotationElements(
       TypeElement annotationElement, Set<TypeElement> annotationElements) {
     if (annotationElements.add(annotationElement)) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeyProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/MapKeyProcessingStep.java
index c4a264aa6..41c6a16f1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapKeyProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeyProcessingStep.java
@@ -36,7 +36,7 @@
 
 /**
  * The annotation processor responsible for validating the mapKey annotation and auto-generate
- * implementation of annotations marked with &#064MapKey where necessary.
+ * implementation of annotations marked with {@link MapKey @MapKey} where necessary.
  *
  * @author Chenying Hou
  * @since 2.0
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeys.java b/compiler/src/main/java/dagger/internal/codegen/MapKeys.java
index 5be196420..84a988f50 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapKeys.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeys.java
@@ -172,7 +172,7 @@ static CodeBlock getMapKeyExpression(Element bindingElement) {
    * when creating the value in a method body.
    *
    * <p>For example, inside an annotation, a nested array of {@code int}s is simply
-   * <code>{1, 2, 3}</code>, but in code it would have to be <code> new int[] {1, 2, 3}</code>.
+   * {@code {1, 2, 3}}, but in code it would have to be {@code new int[] {1, 2, 3}}.
    */
   private static class MapKeyExpression
       extends SimpleAnnotationValueVisitor6<CodeBlock, AnnotationValue> {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
index 1c4871e5b..781296236 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
@@ -22,6 +22,7 @@
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import dagger.Module;
 import dagger.Multibindings;
 import dagger.Provides;
@@ -196,6 +197,7 @@ ModuleDescriptor create(TypeElement moduleElement) {
           .or(getAnnotationMirror(moduleElement, ProducerModule.class));
     }
 
+    @CanIgnoreReturnValue
     private Set<ModuleDescriptor> collectIncludedModules(
         Set<ModuleDescriptor> includedModules, TypeElement moduleElement) {
       TypeMirror superclass = moduleElement.getSuperclass();
diff --git a/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleGenerator.java
index bb3794ca5..c72c616cd 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleGenerator.java
@@ -16,16 +16,16 @@
 package dagger.internal.codegen;
 
 import com.google.common.base.Optional;
-import com.google.common.collect.ImmutableSet;
 import com.squareup.javapoet.AnnotationSpec;
 import com.squareup.javapoet.ClassName;
-import com.squareup.javapoet.FieldSpec;
+import com.squareup.javapoet.MethodSpec;
 import com.squareup.javapoet.TypeSpec;
 import dagger.Module;
+import dagger.Multibindings;
 import dagger.Provides;
+import dagger.producers.ProductionScope;
 import dagger.producers.monitoring.ProductionComponentMonitor;
-import dagger.producers.monitoring.internal.MonitorCache;
-
+import dagger.producers.monitoring.internal.Monitors;
 import javax.annotation.processing.Filer;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
@@ -33,13 +33,12 @@
 
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static com.squareup.javapoet.TypeSpec.classBuilder;
-import static dagger.internal.codegen.AnnotationSpecs.PROVIDES_SET_VALUES;
 import static dagger.internal.codegen.TypeNames.SET_OF_FACTORIES;
 import static dagger.internal.codegen.TypeNames.providerOf;
-import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PUBLIC;
 import static javax.lang.model.element.Modifier.STATIC;
-import static javax.lang.model.element.Modifier.FINAL;
 
 /** Generates a monitoring module for use with production components. */
 final class MonitoringModuleGenerator extends JavaPoetSourceFileGenerator<TypeElement> {
@@ -65,27 +64,26 @@ ClassName nameGeneratedType(TypeElement componentElement) {
             .addAnnotation(
                 AnnotationSpec.builder(Module.class)
                     .build())
-            .addModifiers(PUBLIC, FINAL)
-
-            // TODO(beder): Replace this default set binding with EmptyCollections when it exists.
-            .addMethod(
-                methodBuilder("defaultSetOfFactories")
-                    .returns(SET_OF_FACTORIES)
-                    .addModifiers(STATIC)
-                    .addAnnotation(PROVIDES_SET_VALUES)
-                    .addStatement("return $T.of()", ClassName.get(ImmutableSet.class))
-                    .build())
-            .addField(
-                FieldSpec.builder(MonitorCache.class, "monitorCache", PRIVATE, FINAL)
-                    .initializer("new $T()", MonitorCache.class)
+            .addModifiers(FINAL)
+            .addType(
+                TypeSpec.interfaceBuilder("DefaultSetOfFactories")
+                    .addAnnotation(Multibindings.class)
+                    .addMethod(
+                        MethodSpec.methodBuilder("setOfFactories")
+                            .addModifiers(PUBLIC, ABSTRACT)
+                            .returns(SET_OF_FACTORIES)
+                            .build())
                     .build())
             .addMethod(
                 methodBuilder("monitor")
                     .returns(ProductionComponentMonitor.class)
+                    .addModifiers(STATIC)
                     .addAnnotation(Provides.class)
+                    .addAnnotation(ProductionScope.class)
                     .addParameter(providerOf(ClassName.get(componentElement.asType())), "component")
                     .addParameter(providerOf(SET_OF_FACTORIES), "factories")
-                    .addStatement("return monitorCache.monitor(component, factories)")
+                    .addStatement(
+                        "return $T.createMonitorForComponent(component, factories)", Monitors.class)
                     .build()));
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
index 9aa21f4ca..d1e5d3a8d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -70,9 +70,11 @@
  * @since 2.0
  */
 final class ProducerFactoryGenerator extends JavaPoetSourceFileGenerator<ProductionBinding> {
+  private final CompilerOptions compilerOptions;
 
-  ProducerFactoryGenerator(Filer filer, Elements elements) {
+  ProducerFactoryGenerator(Filer filer, Elements elements, CompilerOptions compilerOptions) {
     super(filer, elements);
+    this.compilerOptions = compilerOptions;
   }
 
   @Override
@@ -106,15 +108,13 @@ ClassName nameGeneratedType(ProductionBinding binding) {
         constructorBuilder()
             .addModifiers(PUBLIC)
             .addStatement(
-                "super($L, $T.create($T.class))",
+                "super($L, $L)",
                 fields.get(binding.monitorRequest().get().bindingKey()).name(),
-                PRODUCER_TOKEN,
-                generatedTypeName);
+                producerTokenConstruction(generatedTypeName, binding));
 
     if (!binding.bindingElement().getModifiers().contains(STATIC)) {
       TypeName moduleType = TypeName.get(binding.bindingTypeElement().asType());
-      addFieldAndConstructorParameter(
-          factoryBuilder, constructorBuilder, "module", moduleType);
+      addFieldAndConstructorParameter(factoryBuilder, constructorBuilder, "module", moduleType);
     }
 
     for (FrameworkField bindingField : fields.values()) {
@@ -123,19 +123,6 @@ ClassName nameGeneratedType(ProductionBinding binding) {
           factoryBuilder, constructorBuilder, bindingField.name(), fieldType);
     }
 
-    boolean returnsFuture =
-        binding.bindingKind().equals(ContributionBinding.Kind.FUTURE_PRODUCTION);
-    ImmutableList<DependencyRequest> asyncDependencies =
-        FluentIterable.from(binding.implicitDependencies())
-            .filter(
-                new Predicate<DependencyRequest>() {
-                  @Override
-                  public boolean apply(DependencyRequest dependency) {
-                    return isAsyncDependency(dependency);
-                  }
-                })
-            .toList();
-
     MethodSpec.Builder computeMethodBuilder =
         methodBuilder("compute")
             .returns(futureTypeName)
@@ -143,6 +130,7 @@ public boolean apply(DependencyRequest dependency) {
             .addModifiers(PROTECTED)
             .addParameter(ProducerMonitor.class, "monitor", FINAL);
 
+    ImmutableList<DependencyRequest> asyncDependencies = asyncDependencies(binding);
     for (DependencyRequest dependency : asyncDependencies) {
       TypeName futureType = listenableFutureOf(asyncDependencyType(dependency));
       CodeBlock futureAccess =
@@ -177,7 +165,6 @@ public boolean apply(DependencyRequest dependency) {
             getThrowsClause(binding.thrownTypes()),
             getInvocationCodeBlock(
                 generatedTypeName,
-                !returnsFuture,
                 binding,
                 providedTypeName,
                 futureTransform.parameterCodeBlocks()));
@@ -207,6 +194,40 @@ private static void addFieldAndConstructorParameter(
         .addStatement("this.$1L = $1L", variableName);
   }
 
+  /** Returns a list of dependencies that are generated asynchronously. */
+  private static ImmutableList<DependencyRequest> asyncDependencies(Binding binding) {
+    final ImmutableMap<DependencyRequest, FrameworkDependency> frameworkDependencies =
+        FrameworkDependency.indexByDependencyRequest(
+            FrameworkDependency.frameworkDependenciesForBinding(binding));
+    return FluentIterable.from(binding.implicitDependencies())
+        .filter(
+            new Predicate<DependencyRequest>() {
+              @Override
+              public boolean apply(DependencyRequest dependency) {
+                return isAsyncDependency(dependency)
+                    && frameworkDependencies
+                        .get(dependency)
+                        .frameworkClass()
+                        .equals(Producer.class);
+              }
+            })
+        .toList();
+  }
+
+  private CodeBlock producerTokenConstruction(
+      ClassName generatedTypeName, ProductionBinding binding) {
+    CodeBlock producerTokenArgs =
+        compilerOptions.writeProducerNameInToken()
+            ? CodeBlocks.format(
+                "$S",
+                String.format(
+                    "%s#%s",
+                    ClassName.get(binding.bindingTypeElement()),
+                    binding.bindingElement().getSimpleName()))
+            : CodeBlocks.format("$T.class", generatedTypeName);
+    return CodeBlocks.format("$T.create($L)", PRODUCER_TOKEN, producerTokenArgs);
+  }
+
   /** Returns a name of the variable representing this dependency's future. */
   private static String dependencyFutureName(DependencyRequest dependency) {
     return dependency.requestElement().getSimpleName() + "Future";
@@ -413,16 +434,15 @@ private static TypeName asyncDependencyType(DependencyRequest dependency) {
     ImmutableList.Builder<CodeBlock> codeBlocks = ImmutableList.builder();
     for (DependencyRequest dependency : binding.dependencies()) {
       if (isAsyncDependency(dependency)) {
-        codeBlocks.add(CodeBlocks.format(
-            "($T) $L.get($L)",
-            asyncDependencyType(dependency),
-            listArgName,
-            argIndex));
+        codeBlocks.add(
+            CodeBlocks.format(
+                "($T) $L.get($L)", asyncDependencyType(dependency), listArgName, argIndex));
         argIndex++;
       } else {
-        codeBlocks.add(frameworkTypeUsageStatement(
-            CodeBlocks.format("$L", fields.get(dependency.bindingKey()).name()),
-            dependency.kind()));
+        codeBlocks.add(
+            frameworkTypeUsageStatement(
+                CodeBlocks.format("$L", fields.get(dependency.bindingKey()).name()),
+                dependency.kind()));
       }
     }
     return codeBlocks.build();
@@ -432,24 +452,23 @@ private static TypeName asyncDependencyType(DependencyRequest dependency) {
    * Creates a code block for the invocation of the producer method from the module, which should be
    * used entirely within a method body.
    *
-   * @param wrapWithFuture If true, wraps the result of the call to the producer method
-   *        in an immediate future.
    * @param binding The binding to generate the invocation code block for.
    * @param providedTypeName The type name that should be provided by this producer.
    * @param parameterCodeBlocks The code blocks for all the parameters to the producer method.
    */
   private CodeBlock getInvocationCodeBlock(
       ClassName generatedTypeName,
-      boolean wrapWithFuture,
       ProductionBinding binding,
       TypeName providedTypeName,
       ImmutableList<CodeBlock> parameterCodeBlocks) {
-    CodeBlock moduleCodeBlock = CodeBlocks.format("$L.$L($L)",
-        binding.bindingElement().getModifiers().contains(STATIC)
-            ? CodeBlocks.format("$T", ClassName.get(binding.bindingTypeElement()))
-            : CodeBlocks.format("$T.this.module", generatedTypeName),
-        binding.bindingElement().getSimpleName(),
-        makeParametersCodeBlock(parameterCodeBlocks));
+    CodeBlock moduleCodeBlock =
+        CodeBlocks.format(
+            "$L.$L($L)",
+            binding.bindingElement().getModifiers().contains(STATIC)
+                ? CodeBlocks.format("$T", ClassName.get(binding.bindingTypeElement()))
+                : CodeBlocks.format("$T.this.module", generatedTypeName),
+            binding.bindingElement().getSimpleName(),
+            makeParametersCodeBlock(parameterCodeBlocks));
 
     // NOTE(beder): We don't worry about catching exceptions from the monitor methods themselves
     // because we'll wrap all monitoring in non-throwing monitors before we pass them to the
@@ -463,20 +482,16 @@ private CodeBlock getInvocationCodeBlock(
         valueCodeBlock =
             CodeBlocks.format("$T.createFutureSingletonSet($L)", PRODUCERS, moduleCodeBlock);
       } else {
-        valueCodeBlock =
-            CodeBlocks.format("$T.of($L)", IMMUTABLE_SET, moduleCodeBlock);
+        valueCodeBlock = CodeBlocks.format("$T.of($L)", IMMUTABLE_SET, moduleCodeBlock);
       }
     } else {
       valueCodeBlock = moduleCodeBlock;
     }
     CodeBlock returnCodeBlock =
-        wrapWithFuture
-            ? CodeBlocks.format(
-                "$T.<$T>immediateFuture($L)",
-                FUTURES,
-                providedTypeName,
-                valueCodeBlock)
-            : valueCodeBlock;
+        binding.bindingKind().equals(ContributionBinding.Kind.FUTURE_PRODUCTION)
+            ? valueCodeBlock
+            : CodeBlocks.format(
+                "$T.<$T>immediateFuture($L)", FUTURES, providedTypeName, valueCodeBlock);
     return CodeBlocks.format(
         Joiner.on('\n')
             .join(
diff --git a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
index 6eae6ccd3..90e07ea7e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
@@ -239,6 +239,14 @@ boolean isMultibindingContribution() {
         && contributionBinding().contributionType().isMultibinding();
   }
 
+  /**
+   * {@code true} if this is a {@linkplain ContributionBinding#isSyntheticBinding() synthetic}
+   * contribution.
+   */
+  boolean isSyntheticContribution() {
+    return contributionBindings().size() == 1 && contributionBinding().isSyntheticBinding();
+  }
+
   /**
    * Returns the single contribution binding.
    *
diff --git a/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java b/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java
index e17406755..97f47ecfd 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java
@@ -18,6 +18,8 @@
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableSet;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import javax.annotation.CheckReturnValue;
 import javax.annotation.processing.Messager;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
@@ -132,6 +134,7 @@ private static boolean isEnclosedIn(Element parent, Element child) {
     return new Builder<T>(subject);
   }
 
+  @CanIgnoreReturnValue
   static final class Builder<T extends Element> {
     private final T subject;
     private final ImmutableSet.Builder<Item> items = ImmutableSet.builder();
@@ -141,6 +144,7 @@ private Builder(T subject) {
       this.subject = subject;
     }
 
+    @CheckReturnValue
     T getSubject() {
       return subject;
     }
@@ -151,58 +155,47 @@ T getSubject() {
     }
 
     Builder<T> addError(String message) {
-      addItem(message, ERROR, subject, Optional.<AnnotationMirror>absent());
-      return this;
+      return addItem(message, ERROR, subject, Optional.<AnnotationMirror>absent());
     }
 
     Builder<T> addError(String message, Element element) {
-      addItem(message, ERROR, element, Optional.<AnnotationMirror>absent());
-      return this;
+      return addItem(message, ERROR, element, Optional.<AnnotationMirror>absent());
     }
 
     Builder<T> addError(String message, Element element, AnnotationMirror annotation) {
-      addItem(message, ERROR, element, Optional.of(annotation));
-      return this;
+      return addItem(message, ERROR, element, Optional.of(annotation));
     }
 
     Builder<T> addWarning(String message) {
-      addItem(message, WARNING, subject, Optional.<AnnotationMirror>absent());
-      return this;
+      return addItem(message, WARNING, subject, Optional.<AnnotationMirror>absent());
     }
 
     Builder<T> addWarning(String message, Element element) {
-      addItem(message, WARNING, element, Optional.<AnnotationMirror>absent());
-      return this;
+      return addItem(message, WARNING, element, Optional.<AnnotationMirror>absent());
     }
 
     Builder<T> addWarning(String message, Element element, AnnotationMirror annotation) {
-      addItem(message, WARNING, element, Optional.of(annotation));
-      return this;
+      return addItem(message, WARNING, element, Optional.of(annotation));
     }
 
     Builder<T> addNote(String message) {
-      addItem(message, NOTE, subject, Optional.<AnnotationMirror>absent());
-      return this;
+      return addItem(message, NOTE, subject, Optional.<AnnotationMirror>absent());
     }
 
     Builder<T> addNote(String message, Element element) {
-      addItem(message, NOTE, element, Optional.<AnnotationMirror>absent());
-      return this;
+      return addItem(message, NOTE, element, Optional.<AnnotationMirror>absent());
     }
 
     Builder<T> addNote(String message, Element element, AnnotationMirror annotation) {
-      addItem(message, NOTE, element, Optional.of(annotation));
-      return this;
+      return addItem(message, NOTE, element, Optional.of(annotation));
     }
 
     Builder<T> addItem(String message, Kind kind, Element element) {
-      addItem(message, kind, element, Optional.<AnnotationMirror>absent());
-      return this;
+      return addItem(message, kind, element, Optional.<AnnotationMirror>absent());
     }
 
     Builder<T> addItem(String message, Kind kind, Element element, AnnotationMirror annotation) {
-      addItem(message, kind, element, Optional.of(annotation));
-      return this;
+      return addItem(message, kind, element, Optional.of(annotation));
     }
 
     private Builder<T> addItem(String message, Kind kind, Element element,
@@ -216,6 +209,7 @@ T getSubject() {
       return this;
     }
 
+    @CheckReturnValue
     ValidationReport<T> build() {
       return new AutoValue_ValidationReport<T>(subject, items.build(), subreports.build());
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/package-info.java b/compiler/src/main/java/dagger/internal/codegen/package-info.java
new file mode 100644
index 000000000..ff764c87a
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/package-info.java
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+@CheckReturnValue
+package dagger.internal.codegen;
+
+import javax.annotation.CheckReturnValue;
diff --git a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
index e49c00d89..6fba4320c 100644
--- a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
@@ -312,10 +312,6 @@ public void cyclicDependencyNotBrokenByMapBinding() {
                 "          [parameter: test.Outer.A aParam]",
                 "      test.Outer.A.<init>(java.util.Map<java.lang.String,test.Outer.C> cMap)",
                 "          [parameter: java.util.Map<java.lang.String,test.Outer.C> cMap]",
-                "      test.Outer.A.<init>(java.util.Map<java.lang.String,test.Outer.C> cMap)",
-                "          [parameter: java.util.Map<java.lang.String,test.Outer.C> cMap]",
-                "      test.Outer.A.<init>(java.util.Map<java.lang.String,test.Outer.C> cMap)",
-                "          [parameter: java.util.Map<java.lang.String,test.Outer.C> cMap]",
                 "      test.Outer.CModule.c(test.Outer.C c)",
                 "          [parameter: test.Outer.C c]");
 
diff --git a/compiler/src/test/java/dagger/internal/codegen/MultibindingsValidatorTest.java b/compiler/src/test/java/dagger/internal/codegen/MultibindingsValidatorTest.java
index 9ec7469a5..91c908c73 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MultibindingsValidatorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MultibindingsValidatorTest.java
@@ -391,4 +391,34 @@ public void duplicateKeys() {
         .in(testModule)
         .onLine(29);
   }
+
+  @Test
+  public void attemptToInjectWildcardGenerics() {
+    JavaFileObject testComponent =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Lazy;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "interface TestComponent {",
+            "  Lazy<? extends Number> qualifiedNumberLazy();",
+            "  Provider<? super Number> qualifiedNumberProvider();",
+            "}");
+    assertAbout(javaSources())
+        .that(asList(testComponent))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("wildcard type")
+        .in(testComponent)
+        .onLine(9)
+        .and()
+        .withErrorContaining("wildcard type")
+        .in(testComponent)
+        .onLine(10);
+  }
+
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
index 4ef4f8100..f9ea63cfb 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
@@ -574,6 +574,86 @@ public void publicModuleNonPublicIncludes() {
         .generatesSources(factoryFile);
   }
 
+  @Test
+  public void singleProducesMethodNoArgsFutureWithProducerName() {
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import com.google.common.util.concurrent.Futures;",
+            "import com.google.common.util.concurrent.ListenableFuture;",
+            "import dagger.producers.ProducerModule;",
+            "import dagger.producers.Produces;",
+            "",
+            "@ProducerModule",
+            "final class TestModule {",
+            "  @Produces ListenableFuture<String> produceString() {",
+            "    return Futures.immediateFuture(\"\");",
+            "  }",
+            "}");
+    JavaFileObject factoryFile =
+        JavaFileObjects.forSourceLines(
+            "TestModule_ProduceStringFactory",
+            "package test;",
+            "",
+            "import com.google.common.util.concurrent.AsyncFunction;",
+            "import com.google.common.util.concurrent.Futures;",
+            "import com.google.common.util.concurrent.ListenableFuture;",
+            "import dagger.producers.internal.AbstractProducer;",
+            "import dagger.producers.monitoring.ProducerMonitor;",
+            "import dagger.producers.monitoring.ProducerToken;",
+            "import dagger.producers.monitoring.ProductionComponentMonitor;",
+            "import java.util.concurrent.Executor;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class TestModule_ProduceStringFactory extends AbstractProducer<String> {",
+            "  private final TestModule module;",
+            "  private final Provider<Executor> executorProvider;",
+            "  private final Provider<ProductionComponentMonitor> monitorProvider;",
+            "",
+            "  public TestModule_ProduceStringFactory(",
+            "      TestModule module,",
+            "      Provider<Executor> executorProvider,",
+            "      Provider<ProductionComponentMonitor> monitorProvider) {",
+            "    super(",
+            "        monitorProvider,",
+            "        ProducerToken.create(\"test.TestModule#produceString\"));",
+            "    assert module != null;",
+            "    this.module = module;",
+            "    assert executorProvider != null;",
+            "    this.executorProvider = executorProvider;",
+            "    assert monitorProvider != null;",
+            "    this.monitorProvider = monitorProvider;",
+            "  }",
+            "",
+            "  @Override protected ListenableFuture<String> compute(",
+            "      final ProducerMonitor monitor) {",
+            "    return Futures.transformAsync(",
+            "      Futures.<Void>immediateFuture(null),",
+            "      new AsyncFunction<Void, String>() {",
+            "        @Override public ListenableFuture<String> apply(Void ignoredVoidArg) {",
+            "          monitor.methodStarting();",
+            "          try {",
+            "            return TestModule_ProduceStringFactory.this.module.produceString();",
+            "          } finally {",
+            "            monitor.methodFinished();",
+            "          }",
+            "        }",
+            "      }, executorProvider.get());",
+            "  }",
+            "}");
+    assertAbout(javaSource())
+        .that(moduleFile)
+        .withCompilerOptions("-Adagger.writeProducerNameInToken=ENABLED")
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(factoryFile);
+  }
+
   private static final JavaFileObject QUALIFIER_A =
       JavaFileObjects.forSourceLines("test.QualifierA",
           "package test;",
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
index 9090fb58e..ffda289a7 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
@@ -259,7 +259,6 @@ public void dependsOnProductionExecutor() {
             "import dagger.producers.Producer;",
             "import dagger.producers.internal.Producers;",
             "import dagger.producers.monitoring.ProductionComponentMonitor;",
-            "import java.util.Set;",
             "import java.util.concurrent.Executor;",
             "import javax.annotation.Generated;",
             "import javax.inject.Provider;",
@@ -270,7 +269,6 @@ public void dependsOnProductionExecutor() {
             "  private Provider<Executor> simpleComponentProvider;",
             "  private Provider<Executor> executorProvider;",
             "  private Provider<TestClass.SimpleComponent> simpleComponentProvider2;",
-            "  private Provider<Set<ProductionComponentMonitor.Factory>> setOfFactoryProvider;",
             "  private Provider<ProductionComponentMonitor> monitorProvider;",
             "  private Provider<TestClass.B> bProvider;",
             "  private Producer<TestClass.A> aProducer;",
@@ -294,14 +292,11 @@ public void dependsOnProductionExecutor() {
             "                 .create(simpleComponentProvider));",
             "    this.simpleComponentProvider2 =",
             "        InstanceFactory.<TestClass.SimpleComponent>create(this);",
-            "    this.setOfFactoryProvider = SetFactory.create(",
-            "        TestClass$SimpleComponent_MonitoringModule_DefaultSetOfFactoriesFactory",
-            "            .create());",
             "    this.monitorProvider =",
-            "        TestClass$SimpleComponent_MonitoringModule_MonitorFactory.create(",
-            "            builder.testClass$SimpleComponent_MonitoringModule,",
-            "            simpleComponentProvider2,",
-            "            setOfFactoryProvider);",
+            "        ScopedProvider.create(",
+            "            TestClass$SimpleComponent_MonitoringModule_MonitorFactory.create(",
+            "                simpleComponentProvider2,",
+            "                SetFactory.<ProductionComponentMonitor.Factory>create());",
             "    this.bProvider = TestClass$BModule_BFactory.create(",
             "        builder.bModule, TestClass$C_Factory.create());",
             "    this.aProducer = new TestClass$AModule_AFactory(",
@@ -317,8 +312,6 @@ public void dependsOnProductionExecutor() {
             "  }",
             "",
             "  public static final class Builder {",
-            "    private TestClass$SimpleComponent_MonitoringModule",
-            "        testClass$SimpleComponent_MonitoringModule;",
             "    private TestClass.BModule bModule;",
             "    private TestClass.AModule aModule;",
             "    private Executor executor;",
@@ -327,10 +320,6 @@ public void dependsOnProductionExecutor() {
             "    }",
             "",
             "    public TestClass.SimpleComponent build() {",
-            "      if (testClass$SimpleComponent_MonitoringModule == null) {",
-            "        this.testClass$SimpleComponent_MonitoringModule =",
-            "            new TestClass$SimpleComponent_MonitoringModule();",
-            "      }",
             "      if (bModule == null) {",
             "        this.bModule = new TestClass.BModule();",
             "      }",
@@ -354,11 +343,11 @@ public void dependsOnProductionExecutor() {
             "      return this;",
             "    }",
             "",
+            "    @Deprecated",
             "    public Builder testClass$SimpleComponent_MonitoringModule(",
             "        TestClass$SimpleComponent_MonitoringModule",
             "        testClass$SimpleComponent_MonitoringModule) {",
-            "      this.testClass$SimpleComponent_MonitoringModule =",
-            "          Preconditions.checkNotNull(testClass$SimpleComponent_MonitoringModule);",
+            "      Preconditions.checkNotNull(testClass$SimpleComponent_MonitoringModule);",
             "      return this;",
             "    }",
             "",
diff --git a/core/pom.xml b/core/pom.xml
index 6baee3510..e51fc5a05 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.google.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>2.1-SNAPSHOT</version>
+    <version>2.2-SNAPSHOT</version>
   </parent>
 
   <artifactId>dagger</artifactId>
diff --git a/core/src/main/java/dagger/Component.java b/core/src/main/java/dagger/Component.java
index 7d724017e..452edb8a4 100644
--- a/core/src/main/java/dagger/Component.java
+++ b/core/src/main/java/dagger/Component.java
@@ -34,17 +34,15 @@
  * example, {@code @Component interface MyComponent {...}} will produce an implementation named
  * {@code DaggerMyComponent}.
  *
- * <a name="component-methods">
+ * <a name="component-methods"></a>
  * <h2>Component methods</h2>
- * </a>
  *
  * <p>Every type annotated with {@code @Component} must contain at least one abstract component
  * method. Component methods may have any name, but must have signatures that conform to either
  * {@linkplain Provider provision} or {@linkplain MembersInjector members-injection} contracts.
  *
- * <a name="provision-methods">
+ * <a name="provision-methods"></a>
  * <h3>Provision methods</h3>
- * </a>
  *
  * <p>Provision methods have no parameters and return an {@link Inject injected} or
  * {@link Provides provided} type. Each method may have a {@link Qualifier} annotation as well. The
@@ -65,9 +63,8 @@
  *   {@literal Lazy<SomeType>} getLazySomeType();
  * </code></pre>
  *
- * <a name="members-injection-methods">
+ * <a name="members-injection-methods"></a>
  * <h3>Members-injection methods</h3>
- * </a>
  *
  * <p>Members-injection methods have a single parameter and inject dependencies into each of the
  * {@link Inject}-annotated fields and methods of the passed instance. A members-injection method
@@ -103,9 +100,8 @@
  *   }
  * </code></pre>
  *
- * <a name="instantiation">
+ * <a name="instantiation"></a>
  * <h2>Instantiation</h2>
- * </a>
  *
  * <p>Component implementations are primarily instantiated via a generated
  * <a href="http://en.wikipedia.org/wiki/Builder_pattern">builder</a>. An instance of the builder
@@ -137,9 +133,8 @@
  * {@code SomeComponent.create()} and {@code SomeComponent.builder().build()} are both valid and
  * equivalent.
  *
- * <a name="scope">
+ * <a name="scope"></a>
  * <h2>Scope</h2>
- * </a>
  *
  * <p>Each Dagger component can be associated with a scope by annotating it with the
  * {@linkplain Scope scope annotation}. The component implementation ensures that there is only one
@@ -159,17 +154,15 @@
  * self-contained implementations, exiting a scope is as simple as dropping all references to the
  * component instance.
  *
- * <a name="component-relationships">
+ * <a name="component-relationships"></a>
  * <h2>Component relationships</h2>
- * </a>
  *
  * <p>While there is much utility in isolated components with purely unscoped bindings, many
  * applications will call for multiple components with multiple scopes to interact. Dagger provides
  * two mechanisms for relating components.
  *
- * <a name="subcomponents">
+ * <a name="subcomponents"></a>
  * <h3>Subcomponents</h3>
- * </a>
  *
  * <p>The simplest way to relate two components is by declaring a {@link Subcomponent}. A
  * subcomponent behaves exactly like a component, but has its implementation generated within
@@ -190,9 +183,8 @@
  *   }
  * </code></pre>
  *
- * <a name="component-dependencies">
+ * <a name="component-dependencies"></a>
  * <h3>Component dependencies</h3>
- * </a>
  *
  * <p>While subcomponents are the simplest way to compose subgraphs of bindings, subcomponents are
  * tightly coupled with the parents; they may use any binding defined by their ancestor component
diff --git a/core/src/main/java/dagger/Lazy.java b/core/src/main/java/dagger/Lazy.java
index e04cc03e3..075c5f405 100644
--- a/core/src/main/java/dagger/Lazy.java
+++ b/core/src/main/java/dagger/Lazy.java
@@ -21,10 +21,6 @@
  * the first call to {@code get()} and remembers that same value for all
  * subsequent calls to {@code get()}.
  *
- * <p>{@code null} is not a supported value.  Implementations of {@code Lazy}
- * are expected to throw {@link NullPointerException} if the computed value is
- * {@code null}.
- *
  * <h2>Example</h2>
  * The differences between <strong>direct injection</strong>, <strong>provider
  * injection</strong> and <strong>lazy injection</strong> are best demonstrated
@@ -148,8 +144,6 @@
   /**
    * Return the underlying value, computing the value if necessary. All calls to
    * the same {@code Lazy} instance will return the same result.
-   *
-   * @throws NullPointerException if the computed value is {@code null}.
    */
   T get();
 }
diff --git a/core/src/main/java/dagger/MapKey.java b/core/src/main/java/dagger/MapKey.java
index 106c00183..e65c99f62 100644
--- a/core/src/main/java/dagger/MapKey.java
+++ b/core/src/main/java/dagger/MapKey.java
@@ -54,7 +54,7 @@
  *
  * class SomeInjectedType {
  *   {@literal @}Inject
- *   SomeInjectedType(Map<SomeEnum, Integer> map) {
+ *   SomeInjectedType({@literal Map<SomeEnum, Integer>} map) {
  *     assert map.get(SomeEnum.FOO) == 2;
  *   }
  * }
@@ -89,7 +89,7 @@
  *
  * class SomeInjectedType {
  *   {@literal @}Inject
- *   SomeInjectedType(Map<MyMapKey, Integer> map) {
+ *   SomeInjectedType({@literal Map<MyMapKey, Integer>} map) {
  *     assert map.get(new MyMapKeyImpl("foo", MyEnum.BAR)) == 2;
  *   }
  * }
diff --git a/core/src/main/java/dagger/Provides.java b/core/src/main/java/dagger/Provides.java
index 7f7c591a7..264a8b016 100644
--- a/core/src/main/java/dagger/Provides.java
+++ b/core/src/main/java/dagger/Provides.java
@@ -29,7 +29,7 @@
  * method's return type is bound to its returned value. The {@linkplain Component component}
  * implementation will pass dependencies to the method as parameters.
  *
- * <h3>Nullability
+ * <h3>Nullability</h3>
  *
  * <p>Dagger forbids injecting {@code null} by default. Component implemenations that invoke
  * {@code @Provides} methods that return {@code null} will throw a {@link NullPointerException}
diff --git a/core/src/main/java/dagger/internal/Factory.java b/core/src/main/java/dagger/internal/Factory.java
index 3e2774cec..8451989ba 100644
--- a/core/src/main/java/dagger/internal/Factory.java
+++ b/core/src/main/java/dagger/internal/Factory.java
@@ -15,12 +15,13 @@
  */
 package dagger.internal;
 
+import dagger.Provides;
 import javax.inject.Inject;
 import javax.inject.Provider;
 import javax.inject.Scope;
 
 /**
- * An {@linkplain Scope unscoped} {@link Provider}. While a {@link Provider} <i>may<i> apply
+ * An {@linkplain Scope unscoped} {@link Provider}. While a {@link Provider} <i>may</i> apply
  * scoping semantics while providing an instance, a factory implementation is guaranteed to exercise
  * the binding logic ({@link Inject} constructors, {@link Provides} methods) upon each call to
  * {@link #get}.
diff --git a/core/src/main/java/dagger/mapkeys/StringKey.java b/core/src/main/java/dagger/mapkeys/StringKey.java
index 7455a9bc5..e283f4782 100644
--- a/core/src/main/java/dagger/mapkeys/StringKey.java
+++ b/core/src/main/java/dagger/mapkeys/StringKey.java
@@ -16,15 +16,23 @@
 package dagger.mapkeys;
 
 import dagger.MapKey;
+import dagger.internal.Beta;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Target;
 
 import static java.lang.annotation.ElementType.METHOD;
 
-/** A {@link MapKey} annotation for maps with {@link String} keys. */
+/**
+ * A {@link MapKey} annotation for maps with {@link String} keys.
+ *
+ * @deprecated This annotation is being replaced by {@link dagger.multibindings.StringKey}. Prefer
+ *     that annotation over this one.
+ */
+@Beta
 @Documented
 @Target(METHOD)
 @MapKey
+@Deprecated
 public @interface StringKey {
   String value();
-}
\ No newline at end of file
+}
diff --git a/core/src/main/java/dagger/mapkeys/ClassKey.java b/core/src/main/java/dagger/multibindings/ClassKey.java
similarity index 94%
rename from core/src/main/java/dagger/mapkeys/ClassKey.java
rename to core/src/main/java/dagger/multibindings/ClassKey.java
index 21497c681..52dc16d0d 100644
--- a/core/src/main/java/dagger/mapkeys/ClassKey.java
+++ b/core/src/main/java/dagger/multibindings/ClassKey.java
@@ -13,9 +13,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.mapkeys;
+package dagger.multibindings;
 
 import dagger.MapKey;
+import dagger.internal.Beta;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Target;
 
@@ -27,9 +28,10 @@
  * <p>If your map's keys can be constrained, consider using a custom annotation instead, with a
  * member whose type is {@code Class<? extends Something>}.
  */
+@Beta
 @Documented
 @Target(METHOD)
 @MapKey
 public @interface ClassKey {
   Class<?> value();
-}
\ No newline at end of file
+}
diff --git a/core/src/main/java/dagger/mapkeys/IntKey.java b/core/src/main/java/dagger/multibindings/IntKey.java
similarity index 93%
rename from core/src/main/java/dagger/mapkeys/IntKey.java
rename to core/src/main/java/dagger/multibindings/IntKey.java
index 011b49fe8..766f6dc99 100644
--- a/core/src/main/java/dagger/mapkeys/IntKey.java
+++ b/core/src/main/java/dagger/multibindings/IntKey.java
@@ -13,18 +13,20 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.mapkeys;
+package dagger.multibindings;
 
 import dagger.MapKey;
+import dagger.internal.Beta;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Target;
 
 import static java.lang.annotation.ElementType.METHOD;
 
 /** A {@link MapKey} annotation for maps with {@code int} keys. */
+@Beta
 @Documented
 @Target(METHOD)
 @MapKey
 public @interface IntKey {
   int value();
-}
\ No newline at end of file
+}
diff --git a/core/src/main/java/dagger/mapkeys/LongKey.java b/core/src/main/java/dagger/multibindings/LongKey.java
similarity index 93%
rename from core/src/main/java/dagger/mapkeys/LongKey.java
rename to core/src/main/java/dagger/multibindings/LongKey.java
index 183b74d02..9d9a40800 100644
--- a/core/src/main/java/dagger/mapkeys/LongKey.java
+++ b/core/src/main/java/dagger/multibindings/LongKey.java
@@ -13,18 +13,20 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.mapkeys;
+package dagger.multibindings;
 
 import dagger.MapKey;
+import dagger.internal.Beta;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Target;
 
 import static java.lang.annotation.ElementType.METHOD;
 
 /** A {@link MapKey} annotation for maps with {@code long} keys. */
+@Beta
 @Documented
 @Target(METHOD)
 @MapKey
 public @interface LongKey {
   long value();
-}
\ No newline at end of file
+}
diff --git a/core/src/main/java/dagger/multibindings/StringKey.java b/core/src/main/java/dagger/multibindings/StringKey.java
new file mode 100644
index 000000000..11dcbfaa6
--- /dev/null
+++ b/core/src/main/java/dagger/multibindings/StringKey.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.multibindings;
+
+import dagger.MapKey;
+import dagger.internal.Beta;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.METHOD;
+
+/** A {@link MapKey} annotation for maps with {@link String} keys. */
+@Beta
+@Documented
+@Target(METHOD)
+@MapKey
+public @interface StringKey {
+  String value();
+}
diff --git a/core/src/main/java/dagger/multibindings/package-info.java b/core/src/main/java/dagger/multibindings/package-info.java
new file mode 100644
index 000000000..26fe0830c
--- /dev/null
+++ b/core/src/main/java/dagger/multibindings/package-info.java
@@ -0,0 +1,17 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.multibindings;
diff --git a/examples/android-activity-graphs/pom.xml b/examples/android-activity-graphs/pom.xml
index 340c59c54..a51796a61 100644
--- a/examples/android-activity-graphs/pom.xml
+++ b/examples/android-activity-graphs/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.google.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>2.1-SNAPSHOT</version>
+    <version>2.2-SNAPSHOT</version>
   </parent>
 
   <artifactId>android-activity-graphs</artifactId>
diff --git a/examples/android-simple/pom.xml b/examples/android-simple/pom.xml
index fb934e6d6..19ce9932a 100644
--- a/examples/android-simple/pom.xml
+++ b/examples/android-simple/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.google.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>2.1-SNAPSHOT</version>
+    <version>2.2-SNAPSHOT</version>
   </parent>
 
   <artifactId>android-simple</artifactId>
diff --git a/examples/pom.xml b/examples/pom.xml
index eb4685aa0..406e8d7f6 100644
--- a/examples/pom.xml
+++ b/examples/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>com.google.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>2.1-SNAPSHOT</version>
+    <version>2.2-SNAPSHOT</version>
   </parent>
 
   <groupId>com.google.dagger.example</groupId>
diff --git a/examples/simple/pom.xml b/examples/simple/pom.xml
index 0be10b86d..e3e260f35 100644
--- a/examples/simple/pom.xml
+++ b/examples/simple/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.google.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>2.1-SNAPSHOT</version>
+    <version>2.2-SNAPSHOT</version>
   </parent>
 
   <artifactId>simple</artifactId>
diff --git a/gwt/pom.xml b/gwt/pom.xml
index 5629c581e..841372c40 100644
--- a/gwt/pom.xml
+++ b/gwt/pom.xml
@@ -22,7 +22,7 @@
   <parent>
     <groupId>com.google.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>2.1-SNAPSHOT</version>
+    <version>2.2-SNAPSHOT</version>
   </parent>
 
   <artifactId>dagger-gwt</artifactId>
diff --git a/pom.xml b/pom.xml
index c2b1fd922..0c73114ea 100644
--- a/pom.xml
+++ b/pom.xml
@@ -1,6 +1,7 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!--
- Copyright (C) 2012 Square, Inc.
+  Copyright (C) 2012 Google, Inc.
+  Copyright (C) 2012 Square, Inc.
 
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
@@ -26,7 +27,7 @@
   <groupId>com.google.dagger</groupId>
   <artifactId>dagger-parent</artifactId>
   <packaging>pom</packaging>
-  <version>2.1-SNAPSHOT</version>
+  <version>2.2-SNAPSHOT</version>
   <name>Dagger (Parent)</name>
   <description>A fast dependency injector for Android and Java.</description>
   <url>https://github.com/square/dagger</url>
@@ -45,13 +46,14 @@
     <!-- Compilation -->
     <java.version>1.7</java.version>
     <javax.inject.version>1</javax.inject.version>
-    <javax.annotation.version>2.0.1</javax.annotation.version>
+    <javax.annotation.version>3.0.1</javax.annotation.version>
     <javawriter.version>2.5.0</javawriter.version>
-    <auto.common.version>0.5</auto.common.version>
+    <auto.common.version>0.6</auto.common.version>
     <auto.factory.version>1.0-beta3</auto.factory.version>
     <auto.service.version>1.0-rc2</auto.service.version>
-    <auto.value.version>1.0</auto.value.version>
-    <guava.version>19.0-rc2</guava.version>
+    <auto.value.version>1.1</auto.value.version>
+    <errorprone.version>2.0.8</errorprone.version>
+    <guava.version>19.0</guava.version>
     <google.java.format.version>0.1-alpha</google.java.format.version>
 
 
@@ -59,7 +61,7 @@
     <compile-testing.version>0.9</compile-testing.version>
     <junit.version>4.11</junit.version>
     <mockito.version>1.9.5</mockito.version>
-    <truth.version>0.26</truth.version>
+    <truth.version>0.28</truth.version>
   </properties>
 
   <scm>
@@ -138,6 +140,11 @@
         <artifactId>auto-value</artifactId>
         <version>${auto.value.version}</version>
       </dependency>
+      <dependency>
+        <groupId>com.google.errorprone</groupId>
+        <artifactId>error_prone_annotations</artifactId>
+        <version>${errorprone.version}</version>
+      </dependency>
       <dependency>
         <groupId>junit</groupId>
         <artifactId>junit</artifactId>
diff --git a/producers/pom.xml b/producers/pom.xml
index edaeca428..da5e87e39 100644
--- a/producers/pom.xml
+++ b/producers/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.google.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>2.1-SNAPSHOT</version>
+    <version>2.2-SNAPSHOT</version>
   </parent>
 
   <artifactId>dagger-producers</artifactId>
diff --git a/producers/src/main/java/dagger/producers/Produced.java b/producers/src/main/java/dagger/producers/Produced.java
index ffc42316d..59af18274 100644
--- a/producers/src/main/java/dagger/producers/Produced.java
+++ b/producers/src/main/java/dagger/producers/Produced.java
@@ -60,7 +60,7 @@
   @Override
   public abstract boolean equals(Object o);
 
-  /** Returns an appropriate hash code to match {@link #equals). */
+  /** Returns an appropriate hash code to match {@link #equals(Object)}. */
   @Override
   public abstract int hashCode();
 
diff --git a/producers/src/main/java/dagger/producers/ProductionComponent.java b/producers/src/main/java/dagger/producers/ProductionComponent.java
index ec56d1576..3640dfe66 100644
--- a/producers/src/main/java/dagger/producers/ProductionComponent.java
+++ b/producers/src/main/java/dagger/producers/ProductionComponent.java
@@ -46,7 +46,7 @@
  * {@link Producer} of a type that is {@link Inject injected}, {@link Provides provided}, or
  * {@link Produces produced}. Each may have a {@link Qualifier} annotation as well. The following
  * are all valid production method declarations: <pre><code>
- *   ListenableFuture<SomeType> getSomeType();
+ *   {@literal ListenableFuture<SomeType>} getSomeType();
  *   {@literal Producer<Set<SomeType>>} getSomeTypes();
  *   {@literal @Response ListenableFuture<Html>} getResponse();
  * </code></pre>
@@ -123,4 +123,3 @@
   @Documented
   @interface Builder {}
 }
-
diff --git a/producers/src/main/java/dagger/producers/monitoring/ProducerMonitor.java b/producers/src/main/java/dagger/producers/monitoring/ProducerMonitor.java
index b59104286..402b566e9 100644
--- a/producers/src/main/java/dagger/producers/monitoring/ProducerMonitor.java
+++ b/producers/src/main/java/dagger/producers/monitoring/ProducerMonitor.java
@@ -76,8 +76,8 @@
    * Called when the producer's output is requested; that is, when the first method is called that
    * requires the production of this producer's output.
    *
-   * <p>Note that if a method depends on {@link Producer Producer<T>}, then this does not count as
-   * requesting {@code T}; that is only triggered by calling {@link Producer#get()}.
+   * <p>Note that if a method depends on {@code Producer<T>}, then this does not count as requesting
+   * {@code T}; that is only triggered by calling {@link Producer#get()}.
    *
    * <p>When multiple monitors are installed, the order that each monitor will call this method is
    * unspecified, but will remain consistent throughout the course of the execution of a component.
diff --git a/producers/src/main/java/dagger/producers/monitoring/ProducerTimingRecorder.java b/producers/src/main/java/dagger/producers/monitoring/ProducerTimingRecorder.java
index 071f32cb8..bdff4a198 100644
--- a/producers/src/main/java/dagger/producers/monitoring/ProducerTimingRecorder.java
+++ b/producers/src/main/java/dagger/producers/monitoring/ProducerTimingRecorder.java
@@ -28,7 +28,7 @@
  *
  * <p>All timings are measured at nanosecond precision, but not necessarily nanosecond resolution.
  * That is, timings will be reported in nanoseconds, but the timing source will not necessarily
- * update at nanosecond resolution. For example, {@link System#nanoTime()) would satisfy these
+ * update at nanosecond resolution. For example, {@link System#nanoTime()} would satisfy these
  * constraints.
  *
  * @author Jesse Beder
diff --git a/producers/src/main/java/dagger/producers/monitoring/ProducerToken.java b/producers/src/main/java/dagger/producers/monitoring/ProducerToken.java
index 5834206ee..311d951a9 100644
--- a/producers/src/main/java/dagger/producers/monitoring/ProducerToken.java
+++ b/producers/src/main/java/dagger/producers/monitoring/ProducerToken.java
@@ -16,15 +16,19 @@
 package dagger.producers.monitoring;
 
 import dagger.producers.Produces;
+import java.util.Objects;
+import javax.annotation.Nullable;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
 /** A token that represents an individual {@linkplain Produces producer method}. */
 public final class ProducerToken {
-  private final Class<?> classToken;
+  @Nullable private final Class<?> classToken;
+  @Nullable private final String methodName;
 
-  private ProducerToken(Class<?> classToken) {
+  private ProducerToken(@Nullable Class<?> classToken, @Nullable String methodName) {
     this.classToken = classToken;
+    this.methodName = methodName;
   }
 
   /**
@@ -34,7 +38,17 @@ private ProducerToken(Class<?> classToken) {
    * signature may change at any time.
    */
   public static ProducerToken create(Class<?> classToken) {
-    return new ProducerToken(checkNotNull(classToken));
+    return new ProducerToken(checkNotNull(classToken), null);
+  }
+
+  /**
+   * Creates a token for a producer method.
+   *
+   * <p><b>Do not use this!</b> This is intended to be called by generated code only, and its
+   * signature may change at any time.
+   */
+  public static ProducerToken create(String methodName) {
+    return new ProducerToken(null, checkNotNull(methodName));
   }
 
   /** Two tokens are equal if they represent the same method. */
@@ -44,21 +58,33 @@ public boolean equals(Object o) {
       return true;
     } else if (o instanceof ProducerToken) {
       ProducerToken that = (ProducerToken) o;
-      return this.classToken.equals(that.classToken);
+      return Objects.equals(this.classToken, that.classToken)
+          && Objects.equals(this.methodName, that.methodName);
     } else {
       return false;
     }
   }
 
-  /** Returns an appropriate hash code to match {@link #equals). */
+  /** Returns an appropriate hash code to match {@link #equals(Object)}. */
   @Override
   public int hashCode() {
-    return classToken.hashCode();
+    int h = 1;
+    h *= 1000003;
+    h ^= Objects.hashCode(this.classToken);
+    h *= 1000003;
+    h ^= Objects.hashCode(this.methodName);
+    return h;
   }
 
   /** Returns a representation of the method. */
   @Override
   public String toString() {
-    return classToken.toString();
+    if (methodName != null) {
+      return methodName;
+    } else if (classToken != null) {
+      return classToken.toString();
+    } else {
+      throw new IllegalStateException();
+    }
   }
 }
diff --git a/producers/src/main/java/dagger/producers/monitoring/internal/MonitorCache.java b/producers/src/main/java/dagger/producers/monitoring/internal/MonitorCache.java
deleted file mode 100644
index 681f2c0fc..000000000
--- a/producers/src/main/java/dagger/producers/monitoring/internal/MonitorCache.java
+++ /dev/null
@@ -1,62 +0,0 @@
-/*
- * Copyright (C) 2015 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.producers.monitoring.internal;
-
-import dagger.producers.monitoring.ProductionComponentMonitor;
-import java.util.Set;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-import javax.inject.Provider;
-
-/**
- * A class that provides a {@link ProductionComponentMonitor} for use in production components.
- *
- * <p>This caches the underlying the monitor, since we want a single instance for each component.
- */
-public final class MonitorCache {
-  private static final Logger logger = Logger.getLogger(MonitorCache.class.getName());
-
-  private volatile ProductionComponentMonitor monitor;
-
-  /**
-   * Returns the underlying monitor. This will only actually compute the monitor the first time it
-   * is called; subsequent calls will simply return the cached value, so the arguments to this
-   * method are ignored. It is expected (though not checked) that this method is called with
-   * equivalent arguments each time (like a {@link dagger.Provides @Provides} method would).
-   */
-  public ProductionComponentMonitor monitor(
-      Provider<?> componentProvider,
-      Provider<Set<ProductionComponentMonitor.Factory>> monitorFactorySetProvider) {
-    ProductionComponentMonitor result = monitor;
-    if (result == null) {
-      synchronized (this) {
-        result = monitor;
-        if (result == null) {
-          try {
-            ProductionComponentMonitor.Factory factory =
-                Monitors.delegatingProductionComponentMonitorFactory(
-                    monitorFactorySetProvider.get());
-            result = monitor = factory.create(componentProvider.get());
-          } catch (RuntimeException e) {
-            logger.log(Level.SEVERE, "RuntimeException while constructing monitor factories.", e);
-            result = monitor = ProductionComponentMonitor.noOp();
-          }
-        }
-      }
-    }
-    return result;
-  }
-}
diff --git a/producers/src/main/java/dagger/producers/monitoring/internal/Monitors.java b/producers/src/main/java/dagger/producers/monitoring/internal/Monitors.java
index 4d7d5b765..ce48907e8 100644
--- a/producers/src/main/java/dagger/producers/monitoring/internal/Monitors.java
+++ b/producers/src/main/java/dagger/producers/monitoring/internal/Monitors.java
@@ -21,6 +21,7 @@
 import dagger.producers.monitoring.ProducerToken;
 import dagger.producers.monitoring.ProductionComponentMonitor;
 import java.util.Collection;
+import java.util.Set;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 import javax.inject.Provider;
@@ -53,6 +54,23 @@
     }
   }
 
+  /**
+   * Creates a new monitor for the given component, from a set of monitor factories. This will not
+   * throw a {@link RuntimeException} or return null.
+   */
+  public static ProductionComponentMonitor createMonitorForComponent(
+      Provider<?> componentProvider,
+      Provider<Set<ProductionComponentMonitor.Factory>> monitorFactorySetProvider) {
+    try {
+      ProductionComponentMonitor.Factory factory =
+          delegatingProductionComponentMonitorFactory(monitorFactorySetProvider.get());
+      return factory.create(componentProvider.get());
+    } catch (RuntimeException e) {
+      logger.log(Level.SEVERE, "RuntimeException while constructing monitor factories.", e);
+      return ProductionComponentMonitor.noOp();
+    }
+  }
+
   /**
    * A component monitor that delegates to a single monitor, and catches and logs all exceptions
    * that the delegate throws.
