diff --git a/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java b/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java
index 66cfdd59c..41d6570c0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java
+++ b/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java
@@ -15,7 +15,9 @@
  */
 package dagger.internal.codegen;
 
+import com.google.common.base.Function;
 import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.ParameterSpec;
 import java.util.Iterator;
 
 final class CodeBlocks {
@@ -41,5 +43,13 @@ static CodeBlock join(Iterable<CodeBlock> codeBlocks, String delimiter) {
     return builder.build();
   }
 
+  static Function<ParameterSpec, CodeBlock> PARAMETER_NAME =
+      new Function<ParameterSpec, CodeBlock>() {
+          @Override
+          public CodeBlock apply(ParameterSpec input) {
+            return CodeBlocks.format("$N", input);
+          }
+      };
+
   private CodeBlocks() {}
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index d9d7dcff0..b41e4d5d5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -16,48 +16,47 @@
 package dagger.internal.codegen;
 
 import com.google.auto.common.MoreTypes;
-import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Lists;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.FieldSpec;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterSpec;
+import com.squareup.javapoet.ParameterizedTypeName;
+import com.squareup.javapoet.TypeName;
+import com.squareup.javapoet.TypeSpec;
+import com.squareup.javapoet.TypeVariableName;
 import dagger.internal.Factory;
-import dagger.internal.codegen.writer.ClassName;
-import dagger.internal.codegen.writer.ClassWriter;
-import dagger.internal.codegen.writer.ConstructorWriter;
-import dagger.internal.codegen.writer.EnumWriter;
-import dagger.internal.codegen.writer.FieldWriter;
-import dagger.internal.codegen.writer.JavaWriter;
-import dagger.internal.codegen.writer.MethodWriter;
-import dagger.internal.codegen.writer.ParameterizedTypeName;
-import dagger.internal.codegen.writer.Snippet;
-import dagger.internal.codegen.writer.StringLiteral;
-import dagger.internal.codegen.writer.TypeName;
-import dagger.internal.codegen.writer.TypeNames;
-import dagger.internal.codegen.writer.TypeVariableName;
-import dagger.internal.codegen.writer.TypeWriter;
 import java.util.Collections;
 import java.util.List;
-import java.util.Map;
-import javax.annotation.Generated;
 import javax.annotation.processing.Filer;
 import javax.inject.Inject;
 import javax.inject.Provider;
 import javax.lang.model.element.Element;
-import javax.lang.model.element.Modifier;
-import javax.lang.model.element.TypeParameterElement;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 import javax.tools.Diagnostic;
 
 import static com.google.common.base.Preconditions.checkState;
+import static com.squareup.javapoet.MethodSpec.constructorBuilder;
+import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static com.squareup.javapoet.TypeSpec.classBuilder;
+import static com.squareup.javapoet.TypeSpec.enumBuilder;
 import static dagger.Provides.Type.SET;
+import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_RAWTYPES;
+import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_UNCHECKED;
+import static dagger.internal.codegen.TypeNames.factoryOf;
+import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.ContributionBinding.Kind.PROVISION;
 import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD;
+import static dagger.internal.codegen.SourceFiles.bindingTypeElementTypeVariableNames;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
-import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
-import static dagger.internal.codegen.SourceFiles.parameterizedGeneratedTypeNameForBinding;
-import static dagger.internal.codegen.writer.Snippet.makeParametersSnippet;
+import static dagger.internal.codegen.SourceFiles.generateBindingFieldsForDependencies;
+import static dagger.internal.codegen.SourceFiles.javapoetGeneratedClassNameForBinding;
+import static dagger.internal.codegen.SourceFiles.javapoetParameterizedGeneratedTypeNameForBinding;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
@@ -70,7 +69,8 @@
  * @author Gregory Kick
  * @since 2.0
  */
-final class FactoryGenerator extends JavaWriterSourceFileGenerator<ProvisionBinding> {
+final class FactoryGenerator extends JavaPoetSourceFileGenerator<ProvisionBinding> {
+
   private final DependencyRequestMapper dependencyRequestMapper;
   private final Diagnostic.Kind nullableValidationType;
 
@@ -86,12 +86,7 @@
 
   @Override
   ClassName nameGeneratedType(ProvisionBinding binding) {
-    return generatedClassNameForBinding(binding);
-  }
-
-  @Override
-  Iterable<? extends Element> getOriginatingElements(ProvisionBinding binding) {
-    return ImmutableSet.of(binding.bindingElement());
+    return javapoetGeneratedClassNameForBinding(binding);
   }
 
   @Override
@@ -100,7 +95,7 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
   }
 
   @Override
-  ImmutableSet<JavaWriter> write(ClassName generatedTypeName, ProvisionBinding binding) {
+  Optional<TypeSpec.Builder> write(ClassName generatedTypeName, ProvisionBinding binding) {
     // We don't want to write out resolved bindings -- we want to write out the generic version.
     checkState(!binding.unresolved().isPresent());
 
@@ -108,167 +103,184 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
         binding.contributionType().equals(ContributionType.MAP)
             ? MapType.from(binding.key().type()).unwrappedValueType(Provider.class)
             : binding.key().type();
-    TypeName providedTypeName = TypeNames.forTypeMirror(keyType);
-    JavaWriter writer = JavaWriter.inPackage(generatedTypeName.packageName());
-
-    final TypeWriter factoryWriter;
-    final Optional<ConstructorWriter> constructorWriter;
-    List<TypeVariableName> typeParameters = Lists.newArrayList();
-    for (TypeParameterElement typeParameter : binding.bindingTypeElement().getTypeParameters()) {
-     typeParameters.add(TypeVariableName.fromTypeParameterElement(typeParameter));
-    }
+    TypeName providedTypeName = TypeName.get(keyType);
+    ParameterizedTypeName parameterizedFactoryName = factoryOf(providedTypeName);
+    Optional<ParameterizedTypeName> factoryOfRawTypeName = Optional.absent();
+    TypeSpec.Builder factoryBuilder;
+    Optional<MethodSpec.Builder> constructorBuilder = Optional.absent();
+    ImmutableList<TypeVariableName> typeParameters = bindingTypeElementTypeVariableNames(binding);
+    ImmutableMap<BindingKey, FrameworkField> fields =
+        generateBindingFieldsForDependencies(dependencyRequestMapper, binding);
     switch (binding.factoryCreationStrategy()) {
       case ENUM_INSTANCE:
-        EnumWriter enumWriter = writer.addEnum(generatedTypeName.simpleName());
-        enumWriter.addConstant("INSTANCE");
-        constructorWriter = Optional.absent();
-        factoryWriter = enumWriter;
+        factoryBuilder = enumBuilder(generatedTypeName.simpleName()).addEnumConstant("INSTANCE");
         // If we have type parameters, then remove the parameters from our providedTypeName,
         // since we'll be implementing an erased version of it.
         if (!typeParameters.isEmpty()) {
-          factoryWriter.annotate(SuppressWarnings.class).setValue("rawtypes");
-          providedTypeName = ((ParameterizedTypeName) providedTypeName).type();
+          factoryBuilder.addAnnotation(SUPPRESS_WARNINGS_RAWTYPES);
+          // TODO(ronshapiro): instead of reassigning, introduce an optional/second parameter
+          providedTypeName = ((ParameterizedTypeName) providedTypeName).rawType;
+          factoryOfRawTypeName = Optional.of(factoryOf(providedTypeName));
         }
         break;
       case CLASS_CONSTRUCTOR:
-        ClassWriter classWriter = writer.addClass(generatedTypeName.simpleName());
-        classWriter.addTypeParameters(typeParameters);
-        classWriter.addModifiers(FINAL);
-        constructorWriter = Optional.of(classWriter.addConstructor());
-        constructorWriter.get().addModifiers(PUBLIC);
-        factoryWriter = classWriter;
+        factoryBuilder =
+            classBuilder(generatedTypeName.simpleName())
+                .addTypeVariables(typeParameters)
+                .addModifiers(FINAL);
+        constructorBuilder = Optional.of(constructorBuilder().addModifiers(PUBLIC));
         if (binding.bindingKind().equals(PROVISION)
             && !binding.bindingElement().getModifiers().contains(STATIC)) {
-          TypeName enclosingType = TypeNames.forTypeMirror(binding.bindingTypeElement().asType());
-          factoryWriter.addField(enclosingType, "module").addModifiers(PRIVATE, FINAL);
-          constructorWriter.get().addParameter(enclosingType, "module");
-          constructorWriter.get().body()
-              .addSnippet("assert module != null;")
-              .addSnippet("this.module = module;");
+          addConstructorParameterAndTypeField(
+              TypeName.get(binding.bindingTypeElement().asType()),
+              "module",
+              factoryBuilder,
+              constructorBuilder.get());
+        }
+        for (FrameworkField bindingField : fields.values()) {
+          addConstructorParameterAndTypeField(
+              bindingField.javapoetFrameworkType(),
+              bindingField.name(),
+              factoryBuilder,
+              constructorBuilder.get());
         }
         break;
       default:
         throw new AssertionError();
     }
 
-    factoryWriter.addModifiers(PUBLIC);
-    factoryWriter.addImplementedType(
-        ParameterizedTypeName.create(ClassName.fromClass(Factory.class), providedTypeName));
-
-    MethodWriter getMethodWriter = factoryWriter.addMethod(providedTypeName, "get");
-    getMethodWriter.annotate(Override.class);
-    getMethodWriter.addModifiers(PUBLIC);
-
-    ImmutableMap<BindingKey, FrameworkField> fields =
-        SourceFiles.generateBindingFieldsForDependencies(dependencyRequestMapper, binding);
-
-    for (FrameworkField bindingField : fields.values()) {
-      TypeName fieldType = bindingField.frameworkType();
-      FieldWriter field = factoryWriter.addField(fieldType, bindingField.name());
-      field.addModifiers(PRIVATE, FINAL);
-      constructorWriter.get().addParameter(field.type(), field.name());
-      constructorWriter.get().body()
-          .addSnippet("assert %s != null;", field.name())
-          .addSnippet("this.%1$s = %1$s;", field.name());
-    }
+    factoryBuilder
+        .addModifiers(PUBLIC)
+        .addSuperinterface(factoryOfRawTypeName.or(parameterizedFactoryName));
 
     // If constructing a factory for @Inject or @Provides bindings, we use a static create method
     // so that generated components can avoid having to refer to the generic types
     // of the factory.  (Otherwise they may have visibility problems referring to the types.)
+    Optional<MethodSpec> createMethod;
     switch(binding.bindingKind()) {
       case INJECTION:
       case PROVISION:
         // The return type is usually the same as the implementing type, except in the case
         // of enums with type variables (where we cast).
-        TypeName returnType = ParameterizedTypeName.create(ClassName.fromClass(Factory.class),
-            TypeNames.forTypeMirror(keyType));
-        MethodWriter createMethodWriter = factoryWriter.addMethod(returnType, "create");
-        createMethodWriter.addTypeParameters(typeParameters);
-        createMethodWriter.addModifiers(Modifier.PUBLIC, Modifier.STATIC);
-        Map<String, TypeName> params = constructorWriter.isPresent()
-            ? constructorWriter.get().parameters() : ImmutableMap.<String, TypeName>of();
-        for (Map.Entry<String, TypeName> param : params.entrySet()) {
-          createMethodWriter.addParameter(param.getValue(), param.getKey());
-        }
+        MethodSpec.Builder createMethodBuilder =
+            methodBuilder("create")
+                .addModifiers(PUBLIC, STATIC)
+                .addTypeVariables(typeParameters)
+                .returns(parameterizedFactoryName);
+        List<ParameterSpec> params =
+            constructorBuilder.isPresent()
+                ? constructorBuilder.get().build().parameters : ImmutableList.<ParameterSpec>of();
+        createMethodBuilder.addParameters(params);
         switch (binding.factoryCreationStrategy()) {
           case ENUM_INSTANCE:
             if (typeParameters.isEmpty()) {
-              createMethodWriter.body().addSnippet("return INSTANCE;");
+              createMethodBuilder.addStatement("return INSTANCE");
             } else {
               // We use an unsafe cast here because the types are different.
               // It's safe because the type is never referenced anywhere.
-              createMethodWriter.annotate(SuppressWarnings.class).setValue("unchecked");
-              createMethodWriter.body().addSnippet("return (Factory) INSTANCE;");
+              createMethodBuilder.addStatement("return ($T) INSTANCE", TypeNames.FACTORY);
+              createMethodBuilder.addAnnotation(SUPPRESS_WARNINGS_UNCHECKED);
             }
             break;
+
           case CLASS_CONSTRUCTOR:
-            createMethodWriter.body().addSnippet("return new %s(%s);",
-                parameterizedGeneratedTypeNameForBinding(binding),
-                Joiner.on(", ").join(params.keySet()));
+            createMethodBuilder.addStatement(
+                "return new $T($L)",
+                javapoetParameterizedGeneratedTypeNameForBinding(binding),
+                makeParametersCodeBlock(
+                    Lists.transform(params, CodeBlocks.PARAMETER_NAME)));
             break;
           default:
             throw new AssertionError();
         }
+        createMethod = Optional.of(createMethodBuilder.build());
         break;
-      default: // do nothing.
+      default:
+        createMethod = Optional.absent();
     }
 
-    List<Snippet> parameters = Lists.newArrayList();
+    if (constructorBuilder.isPresent()) {
+      factoryBuilder.addMethod(constructorBuilder.get().build());
+    }
+
+    List<CodeBlock> parameters = Lists.newArrayList();
     for (DependencyRequest dependency : binding.dependencies()) {
-      parameters.add(frameworkTypeUsageStatement(
-          Snippet.format(fields.get(dependency.bindingKey()).name()), dependency.kind()));
+      parameters.add(
+          frameworkTypeUsageStatement(
+              CodeBlocks.format("$L", fields.get(dependency.bindingKey()).name()),
+              dependency.kind()));
     }
-    Snippet parametersSnippet = makeParametersSnippet(parameters);
+    CodeBlock parametersCodeBlock = makeParametersCodeBlock(parameters);
+
+    MethodSpec.Builder getMethodBuilder =
+        methodBuilder("get")
+            .returns(providedTypeName)
+            .addAnnotation(Override.class)
+            .addModifiers(PUBLIC);
 
     if (binding.bindingKind().equals(PROVISION)) {
-      Snippet providesMethodInvocation = Snippet.format("%s.%s(%s)",
-          binding.bindingElement().getModifiers().contains(STATIC)
-              ? ClassName.fromTypeElement(binding.bindingTypeElement())
-              : "module",
-          binding.bindingElement().getSimpleName(),
-          parametersSnippet);
+      CodeBlock.Builder providesMethodInvocationBuilder = CodeBlock.builder();
+      if (binding.bindingElement().getModifiers().contains(STATIC)) {
+        providesMethodInvocationBuilder.add("$T", ClassName.get(binding.bindingTypeElement()));
+      } else {
+        providesMethodInvocationBuilder.add("module");
+      }
+      providesMethodInvocationBuilder.add(
+          ".$L($L)", binding.bindingElement().getSimpleName(), parametersCodeBlock);
+      CodeBlock providesMethodInvocation = providesMethodInvocationBuilder.build();
 
       if (binding.provisionType().equals(SET)) {
-        TypeName paramTypeName = TypeNames.forTypeMirror(
+        TypeName paramTypeName = TypeName.get(
             MoreTypes.asDeclared(keyType).getTypeArguments().get(0));
         // TODO(cgruber): only be explicit with the parameter if paramType contains wildcards.
-        getMethodWriter.body().addSnippet("return %s.<%s>singleton(%s);",
-            ClassName.fromClass(Collections.class), paramTypeName, providesMethodInvocation);
+        getMethodBuilder.addStatement(
+            "return $T.<$T>singleton($L)",
+            Collections.class, paramTypeName, providesMethodInvocation);
       } else if (binding.nullableType().isPresent()
           || nullableValidationType.equals(Diagnostic.Kind.WARNING)) {
         if (binding.nullableType().isPresent()) {
-          getMethodWriter.annotate(
-              (ClassName) TypeNames.forTypeMirror(binding.nullableType().get()));
+          getMethodBuilder.addAnnotation((ClassName) TypeName.get(binding.nullableType().get()));
         }
-        getMethodWriter.body().addSnippet("return %s;", providesMethodInvocation);
+        getMethodBuilder.addStatement("return $L", providesMethodInvocation);
       } else {
-        StringLiteral failMsg =
-            StringLiteral.forValue(CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD);
-        getMethodWriter.body().addSnippet(Snippet.format(Joiner.on('\n').join(
-            "%s provided = %s;",
-            "if (provided == null) {",
-            "  throw new NullPointerException(%s);",
-            "}",
-            "return provided;"),
-            getMethodWriter.returnType(),
-            providesMethodInvocation,
-            failMsg));
+        String failMsg = CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD;
+        getMethodBuilder
+            .addStatement(
+                "$T provided = $L", getMethodBuilder.build().returnType, providesMethodInvocation)
+            .addCode("if (provided == null) { ")
+            .addStatement("throw new $T($S)", NullPointerException.class, failMsg)
+            .addCode("}")
+            .addStatement("return provided");
       }
     } else if (binding.membersInjectionRequest().isPresent()) {
-      getMethodWriter.body().addSnippet("%1$s instance = new %1$s(%2$s);",
-          providedTypeName, parametersSnippet);
-      getMethodWriter
-          .body()
-          .addSnippet(
-              "%s.injectMembers(instance);",
-              fields.get(binding.membersInjectionRequest().get().bindingKey()).name());
-      getMethodWriter.body().addSnippet("return instance;");
+      getMethodBuilder.addStatement(
+          "$1T instance = new $1T($2L)", providedTypeName, parametersCodeBlock);
+      getMethodBuilder.addStatement(
+          "$L.injectMembers(instance)",
+          fields.get(binding.membersInjectionRequest().get().bindingKey()).name());
+      getMethodBuilder.addStatement("return instance");
     } else {
-      getMethodWriter.body()
-          .addSnippet("return new %s(%s);", providedTypeName, parametersSnippet);
+      getMethodBuilder.addStatement("return new $T($L)", providedTypeName, parametersCodeBlock);
+    }
+
+    factoryBuilder.addMethod(getMethodBuilder.build());
+    if (createMethod.isPresent()) {
+      factoryBuilder.addMethod(createMethod.get());
     }
 
     // TODO(gak): write a sensible toString
-    return ImmutableSet.of(writer);
+    return Optional.of(factoryBuilder);
+  }
+
+  private void addConstructorParameterAndTypeField(
+      TypeName typeName,
+      String variableName,
+      TypeSpec.Builder factoryBuilder,
+      MethodSpec.Builder constructorBuilder) {
+    FieldSpec field = FieldSpec.builder(typeName, variableName, PRIVATE, FINAL).build();
+    factoryBuilder.addField(field);
+    ParameterSpec parameter = ParameterSpec.builder(typeName, variableName).build();
+    constructorBuilder.addParameter(parameter);
+    constructorBuilder.addCode("assert $1N != null; this.$2N = $1N;", parameter, field);
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
index 1228aebee..83c22eb9a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
@@ -21,7 +21,6 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Lists;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.FieldSpec;
@@ -43,7 +42,6 @@
 import javax.inject.Provider;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.Modifier;
-import javax.lang.model.element.TypeParameterElement;
 import javax.lang.model.type.ArrayType;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeVisitor;
@@ -55,6 +53,8 @@
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_RAWTYPES;
 import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_UNCHECKED;
+import static dagger.internal.codegen.TypeNames.membersInjectorOf;
+import static dagger.internal.codegen.SourceFiles.bindingTypeElementTypeVariableNames;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
 import static dagger.internal.codegen.SourceFiles.javapoetMembersInjectorNameForType;
 import static dagger.internal.codegen.SourceFiles.javapoetParameterizedGeneratedTypeNameForBinding;
@@ -98,19 +98,14 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
     // We don't want to write out resolved bindings -- we want to write out the generic version.
     checkState(!binding.unresolved().isPresent());
 
-    List<TypeVariableName> typeParameters = Lists.newArrayList();
-    for (TypeParameterElement typeParameter : binding.bindingTypeElement().getTypeParameters()) {
-      typeParameters.add(TypeVariableName.get(typeParameter));
-    }
-
+    ImmutableList<TypeVariableName> typeParameters = bindingTypeElementTypeVariableNames(binding);
     TypeSpec.Builder injectorTypeBuilder =
         TypeSpec.classBuilder(generatedTypeName.simpleName())
             .addModifiers(PUBLIC, FINAL)
             .addTypeVariables(typeParameters);
 
     TypeName injectedTypeName = TypeName.get(binding.key().type());
-    TypeName implementedType =
-        ParameterizedTypeName.get(ClassName.get(MembersInjector.class), injectedTypeName);
+    TypeName implementedType = membersInjectorOf(injectedTypeName);
     injectorTypeBuilder.addSuperinterface(implementedType);
 
     MethodSpec.Builder injectMembersBuilder =
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index f13be1eb7..b66b6b72b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -28,12 +28,12 @@
 import com.google.common.collect.Maps;
 import com.google.common.collect.Ordering;
 import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.TypeVariableName;
 import dagger.internal.DoubleCheckLazy;
 import dagger.internal.codegen.writer.ClassName;
 import dagger.internal.codegen.writer.ParameterizedTypeName;
 import dagger.internal.codegen.writer.Snippet;
 import dagger.internal.codegen.writer.TypeName;
-import dagger.internal.codegen.writer.TypeNames;
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.Map;
@@ -41,6 +41,7 @@
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.TypeParameterElement;
 import javax.lang.model.type.TypeMirror;
 
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
@@ -207,9 +208,7 @@ static CodeBlock frameworkTypeUsageStatement(
     switch (dependencyKind) {
       case LAZY:
         return CodeBlocks.format(
-            "$T.create($L)",
-            com.squareup.javapoet.ClassName.get(DoubleCheckLazy.class),
-            frameworkTypeMemberSelect);
+            "$T.create($L)", TypeNames.DOUBLE_CHECK_LAZY, frameworkTypeMemberSelect);
       case INSTANCE:
       case FUTURE:
         return CodeBlocks.format("$L.get()", frameworkTypeMemberSelect);
@@ -354,13 +353,13 @@ static TypeName parameterizedGeneratedTypeNameForBinding(Binding binding) {
     if (!typeMirror.isPresent()) {
       return ImmutableList.of();
     }
-    TypeName bindingTypeName = TypeNames.forTypeMirror(typeMirror.get());
+    TypeName bindingTypeName = dagger.internal.codegen.writer.TypeNames.forTypeMirror(typeMirror.get());
     return bindingTypeName instanceof ParameterizedTypeName
         ? ((ParameterizedTypeName) bindingTypeName).parameters()
         : ImmutableList.<TypeName>of();
   }
 
-  private static ImmutableList<com.squareup.javapoet.TypeName> javapoetBindingTypeParameters(
+  static ImmutableList<com.squareup.javapoet.TypeName> javapoetBindingTypeParameters(
       Binding binding) {
     Optional<TypeMirror> typeMirror = typeMirrorForBindingTypeParameters(binding);
     if (!typeMirror.isPresent()) {
@@ -417,5 +416,13 @@ private static String factoryPrefix(ContributionBinding binding) {
     }
   }
 
+  static ImmutableList<TypeVariableName> bindingTypeElementTypeVariableNames(Binding binding) {
+    ImmutableList.Builder<TypeVariableName> builder = ImmutableList.builder();
+    for (TypeParameterElement typeParameter : binding.bindingTypeElement().getTypeParameters()) {
+      builder.add(TypeVariableName.get(typeParameter));
+    }
+    return builder.build();
+  }
+
   private SourceFiles() {}
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/TypeNames.java b/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
new file mode 100644
index 000000000..c0135dccd
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.ParameterizedTypeName;
+import com.squareup.javapoet.TypeName;
+import dagger.MembersInjector;
+import dagger.internal.DoubleCheckLazy;
+import dagger.internal.Factory;
+
+/**
+ * Common names and convenience methods for JavaPoet {@link TypeName} usage.
+ */
+final class TypeNames {
+
+  static final ClassName DOUBLE_CHECK_LAZY = ClassName.get(DoubleCheckLazy.class);
+  static final ClassName FACTORY = ClassName.get(Factory.class);
+  static final ClassName MEMBERS_INJECTOR = ClassName.get(MembersInjector.class);
+
+  static ParameterizedTypeName membersInjectorOf(TypeName membersInjectorType) {
+    return ParameterizedTypeName.get(MEMBERS_INJECTOR, membersInjectorType);
+  }
+
+  static ParameterizedTypeName factoryOf(TypeName factoryType) {
+    return ParameterizedTypeName.get(FACTORY, factoryType);
+  }
+
+  private TypeNames() {}
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
index 6f95e93aa..a4429453e 100644
--- a/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
@@ -39,7 +39,7 @@
 import static dagger.internal.codegen.ErrorMessages.QUALIFIER_ON_INJECT_CONSTRUCTOR;
 import static dagger.internal.codegen.ErrorMessages.STATIC_INJECT_FIELD;
 import static dagger.internal.codegen.ErrorMessages.STATIC_INJECT_METHOD;
-import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION_JAVAPOET;
 
 @RunWith(JUnit4.class)
 // TODO(gak): add tests for generation in the default package.
@@ -136,7 +136,7 @@
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        GENERATED_ANNOTATION,
+        GENERATED_ANNOTATION_JAVAPOET,
         "public final class GenericClass_Factory<T> implements Factory<GenericClass<T>> {",
         "  private final Provider<T> tProvider;",
         "",
@@ -182,7 +182,7 @@
             "import dagger.internal.Factory;",
             "import javax.annotation.Generated;",
             "",
-            GENERATED_ANNOTATION,
+            GENERATED_ANNOTATION_JAVAPOET,
             "public final class GenericClass_Factory<A, B> implements Factory<GenericClass<A, B>> {",
             "  private final MembersInjector<GenericClass<A, B>> genericClassMembersInjector;",
             "",
@@ -226,7 +226,7 @@
         "import javax.annotation.Generated;",
         "",
         "@SuppressWarnings(\"rawtypes\")",
-        GENERATED_ANNOTATION,
+        GENERATED_ANNOTATION_JAVAPOET,
         "public enum GenericClass_Factory implements Factory<GenericClass> {",
         "  INSTANCE;",
         "",
@@ -263,7 +263,7 @@
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        GENERATED_ANNOTATION,
+        GENERATED_ANNOTATION_JAVAPOET,
         "public final class GenericClass_Factory<A, B> implements Factory<GenericClass<A, B>> {",
         "  private final Provider<A> aProvider;",
         "  private final Provider<B> bProvider;",
@@ -311,7 +311,7 @@
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        GENERATED_ANNOTATION,
+        GENERATED_ANNOTATION_JAVAPOET,
         "public final class GenericClass_Factory<A extends Number & Comparable<A>,",
         "        B extends List<? extends String>,",
         "        C extends List<? super String>>",
@@ -371,7 +371,7 @@
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        GENERATED_ANNOTATION,
+        GENERATED_ANNOTATION_JAVAPOET,
         "public final class GenericClass_Factory<A, B> implements Factory<GenericClass<A, B>> {",
         "  private final Provider<A> aAndA2AndPaAndLaProvider;",
         "  private final Provider<A> qaProvider;",
@@ -817,7 +817,7 @@
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        GENERATED_ANNOTATION,
+        GENERATED_ANNOTATION_JAVAPOET,
         "public final class InjectConstructor_Factory ",
         "    implements Factory<InjectConstructor> {",
         "",
@@ -862,7 +862,7 @@
             "import javax.annotation.Generated;",
             "import javax.inject.Provider;",
             "",
-            GENERATED_ANNOTATION,
+            GENERATED_ANNOTATION_JAVAPOET,
             "public final class AllInjections_Factory ",
             "    implements Factory<AllInjections> {",
             "",
@@ -918,7 +918,7 @@
             "import dagger.internal.Factory;",
             "import javax.annotation.Generated;",
             "",
-            GENERATED_ANNOTATION,
+            GENERATED_ANNOTATION_JAVAPOET,
             "public final class B_Factory implements Factory<B> {",
             "",
             "  private final MembersInjector<B> bMembersInjector;",
@@ -953,7 +953,7 @@ public void wildcardDependency() {
         "import javax.inject.Inject;",
         "",
         "class InjectConstructor {",
-        "  @Inject InjectConstructor(List<? extends Object> objects) {}",
+        "  @Inject InjectConstructor(List<?> objects) {}",
         "}");
     JavaFileObject expected = JavaFileObjects.forSourceLines(
         "test.InjectConstructor_Factory",
@@ -964,13 +964,13 @@ public void wildcardDependency() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        GENERATED_ANNOTATION,
+        GENERATED_ANNOTATION_JAVAPOET,
         "public final class InjectConstructor_Factory ",
         "    implements Factory<InjectConstructor> {",
         "",
-        "  private final Provider<List<? extends Object>> objectsProvider;",
+        "  private final Provider<List<?>> objectsProvider;",
         "",
-        "  public InjectConstructor_Factory(Provider<List<? extends Object>> objectsProvider) {",
+        "  public InjectConstructor_Factory(Provider<List<?>> objectsProvider) {",
         "    assert objectsProvider != null;",
         "    this.objectsProvider = objectsProvider;",
         "  }",
@@ -980,7 +980,7 @@ public void wildcardDependency() {
         "  }",
         "",
         "  public static Factory<InjectConstructor> create(",
-        "      Provider<List<? extends Object>> objectsProvider) {",
+        "      Provider<List<?>> objectsProvider) {",
         "    return new InjectConstructor_Factory(objectsProvider);",
         "  }",
         "}");
@@ -1012,7 +1012,7 @@ public void basicNameCollision() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        GENERATED_ANNOTATION,
+        GENERATED_ANNOTATION_JAVAPOET,
         "public final class InjectConstructor_Factory ",
         "    implements Factory<InjectConstructor> {",
         "",
@@ -1064,7 +1064,7 @@ public void nestedNameCollision() {
         "import javax.inject.Provider;",
         "import other.pkg.Outer;",
         "",
-        GENERATED_ANNOTATION,
+        GENERATED_ANNOTATION_JAVAPOET,
         "public final class InjectConstructor_Factory ",
         "    implements Factory<InjectConstructor> {",
         "",
@@ -1116,17 +1116,16 @@ public void samePackageNameCollision() {
         "import dagger.internal.Factory;",
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
-        "import other.pkg.CommonName;",
         "",
-        GENERATED_ANNOTATION,
+        GENERATED_ANNOTATION_JAVAPOET,
         "public final class InjectConstructor_Factory ",
         "    implements Factory<InjectConstructor> {",
         "",
-        "  private final Provider<CommonName> otherPackageProvider;",
-        "  private final Provider<test.CommonName> samePackageProvider;",
+        "  private final Provider<other.pkg.CommonName> otherPackageProvider;",
+        "  private final Provider<CommonName> samePackageProvider;",
         "",
-        "  public InjectConstructor_Factory(Provider<CommonName> otherPackageProvider,",
-        "      Provider<test.CommonName> samePackageProvider) {",
+        "  public InjectConstructor_Factory(Provider<other.pkg.CommonName> otherPackageProvider,",
+        "      Provider<CommonName> samePackageProvider) {",
         "    assert otherPackageProvider != null;",
         "    this.otherPackageProvider = otherPackageProvider;",
         "    assert samePackageProvider != null;",
@@ -1138,8 +1137,8 @@ public void samePackageNameCollision() {
         "  }",
         "",
         "  public static Factory<InjectConstructor> create(",
-        "      Provider<CommonName> otherPackageProvider,",
-        "      Provider<test.CommonName> samePackageProvider) {",
+        "      Provider<other.pkg.CommonName> otherPackageProvider,",
+        "      Provider<CommonName> samePackageProvider) {",
         "    return new InjectConstructor_Factory(otherPackageProvider, samePackageProvider);",
         "  }",
         "}");
@@ -1166,7 +1165,7 @@ public void noDeps() {
         "import dagger.internal.Factory;",
         "import javax.annotation.Generated;",
         "",
-        GENERATED_ANNOTATION,
+        GENERATED_ANNOTATION_JAVAPOET,
         "public enum SimpleType_Factory implements Factory<SimpleType> {",
         "  INSTANCE;",
         "",
@@ -1210,16 +1209,16 @@ public void noDeps() {
         "",
         "import dagger.internal.Factory;",
         "import javax.annotation.Generated;",
-        "import test.OuterType.A;",
-        GENERATED_ANNOTATION,
-        "public enum OuterType$A_Factory implements Factory<A> {",
+        "",
+        GENERATED_ANNOTATION_JAVAPOET,
+        "public enum OuterType$A_Factory implements Factory<OuterType.A> {",
         "  INSTANCE;",
         "",
-        "  @Override public A get() {",
-        "    return new A();",
+        "  @Override public OuterType.A get() {",
+        "    return new OuterType.A();",
         "  }",
         "",
-        "  public static Factory<A> create() {",
+        "  public static Factory<OuterType.A> create() {",
         "    return INSTANCE;",
         "  }",
         "}");
diff --git a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
index 432156efc..03184f8a3 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
@@ -38,7 +38,7 @@
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_SET_VALUES_RETURN_SET;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_THROWS;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_OR_PRODUCES_METHOD_MULTIPLE_QUALIFIERS;
-import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION_JAVAPOET;
 
 @RunWith(JUnit4.class)
 public class ModuleFactoryGeneratorTest {
@@ -374,7 +374,7 @@ private String formatModuleErrorMessage(String msg) {
         "import dagger.internal.Factory;",
         "import javax.annotation.Generated;",
         "",
-        GENERATED_ANNOTATION,
+        GENERATED_ANNOTATION_JAVAPOET,
         "public final class TestModule_ProvideStringFactory implements Factory<String> {",
         "  private final TestModule module;",
         "",
@@ -420,7 +420,7 @@ private String formatModuleErrorMessage(String msg) {
         "import dagger.internal.Factory;",
         "import javax.annotation.Generated;",
         "",
-        GENERATED_ANNOTATION,
+        GENERATED_ANNOTATION_JAVAPOET,
         "public final class TestModule_ProvideStringFactory implements Factory<String> {",
         "  private final TestModule module;",
         "",
@@ -461,7 +461,7 @@ private String formatModuleErrorMessage(String msg) {
         "import dagger.internal.Factory;",
         "import javax.annotation.Generated;",
         "",
-        GENERATED_ANNOTATION,
+        GENERATED_ANNOTATION_JAVAPOET,
         "public final class TestModule_ProvideStringFactory implements Factory<String> {",
         "  private final TestModule module;",
         "",
@@ -545,7 +545,7 @@ private String formatModuleErrorMessage(String msg) {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        GENERATED_ANNOTATION,
+        GENERATED_ANNOTATION_JAVAPOET,
         "public final class TestModule_ProvideObjectsFactory implements Factory<List<Object>> {",
         "  private final TestModule module;",
         "  private final Provider<Object> aProvider;",
@@ -616,7 +616,7 @@ private String formatModuleErrorMessage(String msg) {
         "import java.util.Set;",
         "import javax.annotation.Generated;",
         "",
-        GENERATED_ANNOTATION,
+        GENERATED_ANNOTATION_JAVAPOET,
         "public final class TestModule_ProvideStringFactory implements Factory<Set<String>> {",
         "  private final TestModule module;",
         "",
@@ -667,7 +667,7 @@ private String formatModuleErrorMessage(String msg) {
         "import java.util.Set;",
         "import javax.annotation.Generated;",
         "",
-        GENERATED_ANNOTATION,
+        GENERATED_ANNOTATION_JAVAPOET,
         "public final class TestModule_ProvideWildcardListFactory implements "
             + "Factory<Set<List<List<?>>>> {",
         "  private final TestModule module;",
@@ -714,7 +714,7 @@ private String formatModuleErrorMessage(String msg) {
         "import java.util.Set;",
         "import javax.annotation.Generated;",
         "",
-        GENERATED_ANNOTATION,
+        GENERATED_ANNOTATION_JAVAPOET,
         "public final class TestModule_ProvideStringsFactory implements Factory<Set<String>> {",
         "  private final TestModule module;",
         "",
@@ -1003,7 +1003,7 @@ public void genericSubclassedModule() {
             "import javax.annotation.Generated;",
             "import javax.inject.Provider;",
             "",
-            GENERATED_ANNOTATION,
+            GENERATED_ANNOTATION_JAVAPOET,
             "public final class ParentModule_ProvideListBFactory<A extends CharSequence,",
             "    B, C extends Number & Comparable<C>> implements Factory<List<B>> {",
             "  private final ParentModule<A, B, C> module;",
@@ -1042,7 +1042,7 @@ public void genericSubclassedModule() {
             "import javax.annotation.Generated;",
             "import javax.inject.Provider;",
             "",
-            GENERATED_ANNOTATION,
+            GENERATED_ANNOTATION_JAVAPOET,
             "public final class ParentModule_ProvideBElementFactory<A extends CharSequence,",
             "    B, C extends Number & Comparable<C>> implements Factory<Set<B>> {",
             "  private final ParentModule<A, B, C> module;",
@@ -1075,7 +1075,7 @@ public void genericSubclassedModule() {
             "import javax.annotation.Generated;",
             "import javax.inject.Provider;",
             "",
-            GENERATED_ANNOTATION,
+            GENERATED_ANNOTATION_JAVAPOET,
             "public final class ParentModule_ProvideBEntryFactory<A extends CharSequence,",
             "    B, C extends Number & Comparable<C>> implements Factory<B>> {",
             "  private final ParentModule<A, B, C> module;",
@@ -1110,7 +1110,7 @@ public void genericSubclassedModule() {
         "import dagger.internal.Factory;",
         "import javax.annotation.Generated;",
         "",
-        GENERATED_ANNOTATION,
+        GENERATED_ANNOTATION_JAVAPOET,
         "public final class ChildNumberModule_ProvideNumberFactory implements Factory<Number> {",
         "  private final ChildNumberModule module;",
         "",
@@ -1139,7 +1139,7 @@ public void genericSubclassedModule() {
         "import dagger.internal.Factory;",
         "import javax.annotation.Generated;",
         "",
-        GENERATED_ANNOTATION,
+        GENERATED_ANNOTATION_JAVAPOET,
         "public final class ChildIntegerModule_ProvideIntegerFactory",
         "    implements Factory<Integer> {",
         "  private final ChildIntegerModule module;",
