diff --git a/java/dagger/internal/codegen/ModuleValidator.java b/java/dagger/internal/codegen/ModuleValidator.java
index 19609f1ca..ae3160413 100644
--- a/java/dagger/internal/codegen/ModuleValidator.java
+++ b/java/dagger/internal/codegen/ModuleValidator.java
@@ -66,7 +66,6 @@
 import javax.inject.Singleton;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
-import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
@@ -520,26 +519,48 @@ private void validateModuleVisibility(
       case MEMBER:
       case TOP_LEVEL:
         if (moduleVisibility.equals(PUBLIC)) {
-          ImmutableSet<Element> nonPublicModules =
-              moduleAnnotation.includes().stream()
-                  .filter(element -> !effectiveVisibilityOfElement(element).equals(PUBLIC))
-                  .collect(toImmutableSet());
-          if (!nonPublicModules.isEmpty()) {
+          ImmutableSet<TypeElement> invalidVisibilityIncludes =
+              getModuleIncludesWithInvalidVisibility(moduleAnnotation);
+          if (!invalidVisibilityIncludes.isEmpty()) {
             reportBuilder.addError(
                 String.format(
-                    "This module is public, but it includes non-public "
-                        + "(or effectively non-public) modules. "
-                        + "Either reduce the visibility of this module or make %s public.",
-                    formatListForErrorMessage(nonPublicModules.asList())),
+                    "This module is public, but it includes non-public (or effectively non-public) "
+                        + "modules (%s) that have non-static, non-abstract binding methods. Either "
+                        + "reduce the visibility of this module, make the included modules "
+                        + "public, or make all of the binding methods on the included modules "
+                        + "abstract or static.",
+                    formatListForErrorMessage(invalidVisibilityIncludes.asList())),
                 moduleElement);
           }
         }
-        break;
-      default:
-        throw new AssertionError();
     }
   }
 
+  private ImmutableSet<TypeElement> getModuleIncludesWithInvalidVisibility(
+      ModuleAnnotation moduleAnnotation) {
+    return moduleAnnotation.includes().stream()
+        .filter(include -> !effectiveVisibilityOfElement(include).equals(PUBLIC))
+        .filter(this::requiresModuleInstance)
+        .collect(toImmutableSet());
+  }
+
+  /**
+   * Returns {@code true} if a module instance is needed for any of the binding methods on the
+   * given {@code module}. This is the case when the module has any binding methods that are neither
+   * {@code abstract} nor {@code static}.
+   */
+  private boolean requiresModuleInstance(TypeElement module) {
+    // Note elements.getAllMembers(module) rather than module.getEnclosedElements() here: we need to
+    // include binding methods declared in supertypes because unlike most other validations being
+    // done in this class, which assume that supertype binding methods will be validated in a
+    // separate call to the validator since the supertype itself must be a @Module, we need to look
+    // at all the binding methods in the module's type hierarchy here.
+    return methodsIn(elements.getAllMembers(module)).stream()
+        .filter(method -> anyBindingMethodValidator.isBindingMethod(method))
+        .map(ExecutableElement::getModifiers)
+        .anyMatch(modifiers -> !modifiers.contains(ABSTRACT) && !modifiers.contains(STATIC));
+  }
+
   private void validateNoScopeAnnotationsOnModuleElement(
       TypeElement module, ModuleKind moduleKind, ValidationReport.Builder<TypeElement> report) {
     for (AnnotationMirror scope : getAnnotatedAnnotations(module, Scope.class)) {
diff --git a/javatests/dagger/functional/modules/ModuleIncludesTest.java b/javatests/dagger/functional/modules/ModuleIncludesTest.java
new file mode 100644
index 000000000..38f7d9795
--- /dev/null
+++ b/javatests/dagger/functional/modules/ModuleIncludesTest.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2019 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.modules;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import dagger.Component;
+import dagger.functional.modules.subpackage.PublicModule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public final class ModuleIncludesTest {
+
+  @Component(modules = PublicModule.class)
+  interface TestComponent {
+    Object object();
+  }
+
+  @Test
+  public void publicModuleIncludingPackagePrivateModuleThatDoesNotRequireInstance() {
+    TestComponent component = DaggerModuleIncludesTest_TestComponent.create();
+    assertThat(component.object()).isEqualTo("foo42");
+  }
+}
diff --git a/javatests/dagger/functional/modules/subpackage/PackagePrivateModule.java b/javatests/dagger/functional/modules/subpackage/PackagePrivateModule.java
new file mode 100644
index 000000000..66852d7d4
--- /dev/null
+++ b/javatests/dagger/functional/modules/subpackage/PackagePrivateModule.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2019 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.modules.subpackage;
+
+import dagger.Binds;
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+abstract class PackagePrivateModule {
+  @Binds
+  abstract Object bindObject(String string);
+
+  @Provides
+  static String provideString(int i) {
+    return "foo" + i;
+  }
+}
diff --git a/javatests/dagger/functional/modules/subpackage/PublicModule.java b/javatests/dagger/functional/modules/subpackage/PublicModule.java
new file mode 100644
index 000000000..7c5fd29a9
--- /dev/null
+++ b/javatests/dagger/functional/modules/subpackage/PublicModule.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2019 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.modules.subpackage;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module(includes = PackagePrivateModule.class)
+public abstract class PublicModule {
+  @Provides
+  static int provideInt() {
+    return 42;
+  }
+}
diff --git a/javatests/dagger/internal/codegen/ModuleFactoryGeneratorTest.java b/javatests/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
index 5ffec3a91..50c41edb0 100644
--- a/javatests/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
+++ b/javatests/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
@@ -753,25 +753,37 @@ public void publicModuleNonPublicIncludes() {
         "import dagger.Module;",
         "",
         "@Module(includes = {",
-        "    NonPublicModule1.class, OtherPublicModule.class, NonPublicModule2.class",
+        "    BadNonPublicModule.class, OtherPublicModule.class, OkNonPublicModule.class",
         "})",
         "public final class PublicModule {",
         "}");
-    JavaFileObject nonPublicModule1File = JavaFileObjects.forSourceLines("test.NonPublicModule1",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "",
-        "@Module",
-        "final class NonPublicModule1 {",
-        "}");
-    JavaFileObject nonPublicModule2File = JavaFileObjects.forSourceLines("test.NonPublicModule2",
+    JavaFileObject badNonPublicModuleFile =
+        JavaFileObjects.forSourceLines(
+            "test.BadNonPublicModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "final class BadNonPublicModule {",
+            "  @Provides",
+            "  int provideInt() {",
+            "    return 42;",
+            "  }",
+            "}");
+    JavaFileObject okNonPublicModuleFile = JavaFileObjects.forSourceLines("test.OkNonPublicModule",
         "package test;",
         "",
         "import dagger.Module;",
+        "import dagger.Provides;",
         "",
         "@Module",
-        "final class NonPublicModule2 {",
+        "final class OkNonPublicModule {",
+        "  @Provides",
+        "  static String provideString() {",
+        "    return \"foo\";",
+        "  }",
         "}");
     JavaFileObject otherPublicModuleFile = JavaFileObjects.forSourceLines("test.OtherPublicModule",
         "package test;",
@@ -785,16 +797,16 @@ public void publicModuleNonPublicIncludes() {
         daggerCompiler()
             .compile(
                 publicModuleFile,
-                nonPublicModule1File,
-                nonPublicModule2File,
+                badNonPublicModuleFile,
+                okNonPublicModuleFile,
                 otherPublicModuleFile);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
-            "This module is public, but it includes non-public "
-                + "(or effectively non-public) modules. "
-                + "Either reduce the visibility of this module or make "
-                + "test.NonPublicModule1 and test.NonPublicModule2 public.")
+            "This module is public, but it includes non-public (or effectively non-public) modules "
+                + "(test.BadNonPublicModule) that have non-static, non-abstract binding methods. "
+                + "Either reduce the visibility of this module, make the included modules public, "
+                + "or make all of the binding methods on the included modules abstract or static.")
         .inFile(publicModuleFile)
         .onLine(8);
   }
diff --git a/javatests/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java b/javatests/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
index ad73f6850..0b6ef8f58 100644
--- a/javatests/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
+++ b/javatests/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
@@ -256,6 +256,8 @@ public void includesNonModule() {
             "X is listed as a module, but is not annotated with one of @Module, @ProducerModule");
   }
 
+  // TODO(ronshapiro): merge this with the equivalent test in ModuleFactoryGeneratorTest and make it
+  // parameterized
   @Test
   public void publicModuleNonPublicIncludes() {
     JavaFileObject publicModuleFile = JavaFileObjects.forSourceLines("test.PublicModule",
@@ -264,25 +266,37 @@ public void publicModuleNonPublicIncludes() {
         "import dagger.producers.ProducerModule;",
         "",
         "@ProducerModule(includes = {",
-        "    NonPublicModule1.class, OtherPublicModule.class, NonPublicModule2.class",
+        "    BadNonPublicModule.class, OtherPublicModule.class, OkNonPublicModule.class",
         "})",
         "public final class PublicModule {",
         "}");
-    JavaFileObject nonPublicModule1File = JavaFileObjects.forSourceLines("test.NonPublicModule1",
-        "package test;",
-        "",
-        "import dagger.producers.ProducerModule;",
-        "",
-        "@ProducerModule",
-        "final class NonPublicModule1 {",
-        "}");
-    JavaFileObject nonPublicModule2File = JavaFileObjects.forSourceLines("test.NonPublicModule2",
+    JavaFileObject badNonPublicModuleFile =
+        JavaFileObjects.forSourceLines(
+            "test.BadNonPublicModule",
+            "package test;",
+            "",
+            "import dagger.producers.ProducerModule;",
+            "import dagger.producers.Produces;",
+            "",
+            "@ProducerModule",
+            "final class BadNonPublicModule {",
+            "  @Produces",
+            "  int produceInt() {",
+            "    return 42;",
+            "  }",
+            "}");
+    JavaFileObject okNonPublicModuleFile = JavaFileObjects.forSourceLines("test.OkNonPublicModule",
         "package test;",
         "",
         "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
         "",
         "@ProducerModule",
-        "final class NonPublicModule2 {",
+        "final class OkNonPublicModule {",
+        "  @Produces",
+        "  static String produceString() {",
+        "    return \"foo\";",
+        "  }",
         "}");
     JavaFileObject otherPublicModuleFile = JavaFileObjects.forSourceLines("test.OtherPublicModule",
         "package test;",
@@ -296,16 +310,16 @@ public void publicModuleNonPublicIncludes() {
         daggerCompiler()
             .compile(
                 publicModuleFile,
-                nonPublicModule1File,
-                nonPublicModule2File,
+                badNonPublicModuleFile,
+                okNonPublicModuleFile,
                 otherPublicModuleFile);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
-            "This module is public, but it includes non-public "
-                + "(or effectively non-public) modules. "
-                + "Either reduce the visibility of this module or make "
-                + "test.NonPublicModule1 and test.NonPublicModule2 public.")
+            "This module is public, but it includes non-public (or effectively non-public) modules "
+                + "(test.BadNonPublicModule) that have non-static, non-abstract binding methods. "
+                + "Either reduce the visibility of this module, make the included modules public, "
+                + "or make all of the binding methods on the included modules abstract or static.")
         .inFile(publicModuleFile)
         .onLine(8);
   }
