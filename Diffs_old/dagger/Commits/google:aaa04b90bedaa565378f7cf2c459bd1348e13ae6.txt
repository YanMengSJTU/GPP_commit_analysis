diff --git a/core/src/main/java/dagger/internal/DoubleCheck.java b/core/src/main/java/dagger/internal/DoubleCheck.java
index 73d4ee6a3..0dd73b50b 100644
--- a/core/src/main/java/dagger/internal/DoubleCheck.java
+++ b/core/src/main/java/dagger/internal/DoubleCheck.java
@@ -26,6 +26,7 @@
  */
 public final class DoubleCheck<T> implements Provider<T>, Lazy<T> {
   private static final Object UNINITIALIZED = new Object();
+  private static final Object INITIALIZING = new Object();
 
   private volatile Provider<T> provider;
   private volatile Object instance = UNINITIALIZED;
@@ -39,14 +40,19 @@ private DoubleCheck(Provider<T> provider) {
   @Override
   public T get() {
     Object result = instance;
-    if (result == UNINITIALIZED) {
+    if (result == UNINITIALIZED | result == INITIALIZING) {
       synchronized (this) {
         result = instance;
         if (result == UNINITIALIZED) {
+          /* Here we set the instance to INITIALIZING so that we can check for the case that the
+           * delegate provider is part of a chain of circular dependencies. */
+          instance = INITIALIZING;
           instance = result = provider.get();
           /* Null out the reference to the provider. We are never going to need it again, so we
            * can make it eligible for GC. */
           provider = null;
+        } else if (result == INITIALIZING) {
+          throw new IllegalStateException("get() was called in a circular dependency");
         }
       }
     }
diff --git a/core/src/test/java/dagger/internal/DoubleCheckTest.java b/core/src/test/java/dagger/internal/DoubleCheckTest.java
index 280dccf25..252a788ad 100644
--- a/core/src/test/java/dagger/internal/DoubleCheckTest.java
+++ b/core/src/test/java/dagger/internal/DoubleCheckTest.java
@@ -27,6 +27,7 @@
 import java.util.concurrent.Executors;
 import java.util.concurrent.Future;
 import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicReference;
 import javax.inject.Provider;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -126,4 +127,20 @@ public Object get() {
       return new Object();
     }
   }
+
+  @Test public void reentranceThrowsIllegalStateException() {
+    final AtomicReference<Provider<Object>> doubleCheckReference =
+        new AtomicReference<Provider<Object>>();
+    Provider<Object> doubleCheck = DoubleCheck.provider(new Provider<Object>() {
+      @Override
+      public Object get() {
+        return doubleCheckReference.get().get();
+      }
+    });
+    doubleCheckReference.set(doubleCheck);
+    try {
+      doubleCheck.get();
+      fail();
+    } catch (IllegalStateException expected) {}
+  }
 }
