diff --git a/compiler/pom.xml b/compiler/pom.xml
index 69839a1e6..84ef8b545 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -45,6 +45,10 @@
       <groupId>com.google.auto</groupId>
       <artifactId>auto-common</artifactId>
     </dependency>
+    <dependency>
+      <groupId>com.google.errorprone</groupId>
+      <artifactId>error_prone_annotations</artifactId>
+    </dependency>
     <dependency>
       <groupId>com.google.guava</groupId>
       <artifactId>guava</artifactId>
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 68a78e783..cb0ec0859 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -277,14 +277,13 @@ private void traverseRequest(
     }
 
     /**
-     * Validates that the set of bindings resolved is consistent with the type of the binding, and
-     * returns true if the bindings are valid.
+     * Reports errors if the set of bindings resolved is inconsistent with the type of the binding.
      */
-    private boolean validateResolvedBinding(
+    private void validateResolvedBinding(
         Deque<ResolvedRequest> path, ResolvedBindings resolvedBinding) {
       if (resolvedBinding.isEmpty()) {
         reportMissingBinding(path);
-        return false;
+        return;
       }
 
       switch (resolvedBinding.bindingKey().kind()) {
@@ -298,13 +297,13 @@ private boolean validateResolvedBinding(
           validateNullability(path.peek().request(), resolvedBinding.contributionBindings());
           if (resolvedBinding.contributionBindings().size() > 1) {
             reportDuplicateBindings(path);
-            return false;
+            return;
           }
           ContributionBinding contributionBinding = resolvedBinding.contributionBinding();
           if (contributionBinding.bindingType().equals(BindingType.PRODUCTION)
               && doesPathRequireProvisionOnly(path)) {
             reportProviderMayNotDependOnProducer(path);
-            return false;
+            return;
           }
           if (compilerOptions.usesProducers()) {
             Key productionImplementationExecutorKey =
@@ -317,7 +316,7 @@ private boolean validateResolvedBinding(
                 if (request.key().equals(productionExecutorKey)
                     || request.key().equals(productionImplementationExecutorKey)) {
                   reportDependsOnProductionExecutor(path);
-                  return false;
+                  return;
                 }
               }
             }
@@ -325,10 +324,8 @@ private boolean validateResolvedBinding(
           if (contributionBinding.bindingKind().equals(SYNTHETIC_MULTIBOUND_MAP)) {
             ImmutableSet<ContributionBinding> multibindings =
                 inlineSyntheticContributions(resolvedBinding).contributionBindings();
-            boolean duplicateMapKeys = reportIfDuplicateMapKeys(path, multibindings);
-            boolean inconsistentMapKeyAnnotationTypes =
-                reportIfInconsistentMapKeyAnnotationTypes(path, multibindings);
-            return !duplicateMapKeys && !inconsistentMapKeyAnnotationTypes;
+            validateMapKeySet(path, multibindings);
+            validateMapKeyAnnotationTypes(path, multibindings);
           }
           break;
         case MEMBERS_INJECTION:
@@ -340,13 +337,13 @@ private boolean validateResolvedBinding(
           }
           if (resolvedBinding.bindings().size() > 1) {
             reportDuplicateBindings(path);
-            return false;
+            return;
           }
-          return validateMembersInjectionBinding(getOnlyElement(resolvedBinding.bindings()), path);
+          validateMembersInjectionBinding(getOnlyElement(resolvedBinding.bindings()), path);
+          return;
         default:
           throw new AssertionError();
       }
-      return true;
     }
 
     /**
@@ -440,57 +437,49 @@ private void validateNullability(DependencyRequest request, Set<ContributionBind
     }
 
     /**
-     * Returns {@code true} (and reports errors) if {@code mapBindings} has more than one binding
-     * for the same map key.
+     * Reports errors if {@code mapBindings} has more than one binding for the same map key.
      */
-    private boolean reportIfDuplicateMapKeys(
+    private void validateMapKeySet(
         Deque<ResolvedRequest> path, Set<ContributionBinding> mapBindings) {
-      boolean hasDuplicateMapKeys = false;
       for (Collection<ContributionBinding> mapBindingsForMapKey :
           indexMapBindingsByMapKey(mapBindings).asMap().values()) {
         if (mapBindingsForMapKey.size() > 1) {
-          hasDuplicateMapKeys = true;
           reportDuplicateMapKeys(path, mapBindingsForMapKey);
         }
       }
-      return hasDuplicateMapKeys;
     }
 
     /**
-     * Returns {@code true} (and reports errors) if {@code mapBindings} uses more than one
-     * {@link MapKey} annotation type.
+     * Reports errors if {@code mapBindings} uses more than one {@link MapKey} annotation type.
      */
-    private boolean reportIfInconsistentMapKeyAnnotationTypes(
+    private void validateMapKeyAnnotationTypes(
         Deque<ResolvedRequest> path, Set<ContributionBinding> contributionBindings) {
       ImmutableSetMultimap<Equivalence.Wrapper<DeclaredType>, ContributionBinding>
           mapBindingsByAnnotationType = indexMapBindingsByAnnotationType(contributionBindings);
       if (mapBindingsByAnnotationType.keySet().size() > 1) {
         reportInconsistentMapKeyAnnotations(path, mapBindingsByAnnotationType);
-        return true;
       }
-      return false;
     }
 
     /**
-     * Validates a members injection binding, returning false (and reporting the error) if it wasn't
-     * valid.
+     * Reports errors if a members injection binding is invalid.
      */
-    private boolean validateMembersInjectionBinding(
+    private void validateMembersInjectionBinding(
         Binding binding, final Deque<ResolvedRequest> path) {
-      return binding
+      binding
           .key()
           .type()
           .accept(
-              new SimpleTypeVisitor6<Boolean, Void>() {
+              new SimpleTypeVisitor6<Void, Void>() {
                 @Override
-                protected Boolean defaultAction(TypeMirror e, Void p) {
+                protected Void defaultAction(TypeMirror e, Void p) {
                   reportBuilder.addError(
                       "Invalid members injection request.", path.peek().request().requestElement());
-                  return false;
+                  return null;
                 }
 
                 @Override
-                public Boolean visitDeclared(DeclaredType type, Void ignored) {
+                public Void visitDeclared(DeclaredType type, Void ignored) {
                   // If the key has type arguments, validate that each type argument is declared.
                   // Otherwise the type argument may be a wildcard (or other type), and we can't
                   // resolve that to actual types.  If the arg was an array, validate the type
@@ -552,7 +541,7 @@ public Boolean visitPrimitive(PrimitiveType t, Void p) {
                               type.toString(),
                               Joiner.on('\n').join(printableDependencyPath)),
                           path.peek().request().requestElement());
-                      return false;
+                      return null;
                     }
                   }
 
@@ -576,10 +565,8 @@ public Boolean visitPrimitive(PrimitiveType t, Void p) {
                             type.toString(),
                             Joiner.on('\n').join(printableDependencyPath)),
                         path.peek().request().requestElement());
-                    return false;
                   }
-
-                  return true; // valid
+                  return null;
                 }
               },
               null);
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index 2d1d98149..23b88dc4e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -27,6 +27,7 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
 import com.google.common.util.concurrent.ListenableFuture;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.squareup.javapoet.ClassName;
 import dagger.Component;
 import dagger.Lazy;
@@ -253,6 +254,7 @@ boolean isProducer() {
         .toSet();
   }
 
+  @CanIgnoreReturnValue
   private static Set<ModuleDescriptor> addTransitiveModules(
       Set<ModuleDescriptor> transitiveModules, ModuleDescriptor module) {
     if (transitiveModules.add(module)) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
index 0e5f1f240..bbebdee3c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
@@ -18,6 +18,7 @@
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.Optional;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.List;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
@@ -137,8 +138,9 @@ public String visitType(TypeElement e, Optional<AnnotationMirror> p) {
     }, qualifier);
   }
 
-  private StringBuilder appendParameter(VariableElement parameter, TypeMirror type,
-      StringBuilder builder) {
+  @CanIgnoreReturnValue
+  private StringBuilder appendParameter(
+      VariableElement parameter, TypeMirror type, StringBuilder builder) {
     return builder.append(type).append(' ').append(parameter.getSimpleName());
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
index 88b982588..3342df9b5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
@@ -24,6 +24,7 @@
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.squareup.javapoet.ClassName;
 import dagger.Component;
 import dagger.Provides;
@@ -183,21 +184,18 @@ void generateSourcesForRequiredBindings(FactoryGenerator factoryGenerator,
    * Registers the binding for generation and later lookup. If the binding is resolved, we also
    * attempt to register an unresolved version of it.
    */
-  private ProvisionBinding registerBinding(
-      ProvisionBinding binding, boolean warnIfNotAlreadyGenerated) {
+  private void registerBinding(ProvisionBinding binding, boolean warnIfNotAlreadyGenerated) {
     provisionBindings.tryRegisterBinding(binding, warnIfNotAlreadyGenerated);
     if (binding.unresolved().isPresent()) {
       provisionBindings.tryToGenerateBinding(binding.unresolved().get(), warnIfNotAlreadyGenerated);
     }
-    return binding;
   }
 
   /**
    * Registers the binding for generation and later lookup. If the binding is resolved, we also
    * attempt to register an unresolved version of it.
    */
-  private MembersInjectionBinding registerBinding(
-      MembersInjectionBinding binding, boolean warnIfNotAlreadyGenerated) {
+  private void registerBinding(MembersInjectionBinding binding, boolean warnIfNotAlreadyGenerated) {
     /*
      * We generate MembersInjector classes for types with @Inject constructors only if they have any
      * injection sites.
@@ -217,13 +215,14 @@ private MembersInjectionBinding registerBinding(
       membersInjectionBindings.tryToGenerateBinding(
           binding.unresolved().get(), warnIfNotAlreadyGenerated);
     }
-    return binding;
   }
 
+  @CanIgnoreReturnValue
   Optional<ProvisionBinding> tryRegisterConstructor(ExecutableElement constructorElement) {
     return tryRegisterConstructor(constructorElement, Optional.<TypeMirror>absent(), false);
   }
 
+  @CanIgnoreReturnValue
   private Optional<ProvisionBinding> tryRegisterConstructor(
       ExecutableElement constructorElement,
       Optional<TypeMirror> resolvedType,
@@ -250,10 +249,12 @@ private MembersInjectionBinding registerBinding(
     return Optional.absent();
   }
 
+  @CanIgnoreReturnValue
   Optional<MembersInjectionBinding> tryRegisterMembersInjectedType(TypeElement typeElement) {
     return tryRegisterMembersInjectedType(typeElement, Optional.<TypeMirror>absent(), false);
   }
 
+  @CanIgnoreReturnValue
   private Optional<MembersInjectionBinding> tryRegisterMembersInjectedType(
       TypeElement typeElement,
       Optional<TypeMirror> resolvedType,
@@ -279,6 +280,7 @@ private MembersInjectionBinding registerBinding(
     return Optional.absent();
   }
 
+  @CanIgnoreReturnValue
   Optional<ProvisionBinding> getOrFindProvisionBinding(Key key) {
     checkNotNull(key);
     if (!key.isValidImplicitProvisionKey(types)) {
@@ -321,6 +323,7 @@ public boolean apply(ExecutableElement constructor) {
    * Returns a {@link MembersInjectionBinding} for {@code key}. If none has been registered yet,
    * registers one, along with all necessary members injection bindings for superclasses.
    */
+  @CanIgnoreReturnValue
   Optional<MembersInjectionBinding> getOrFindMembersInjectionBinding(Key key) {
     checkNotNull(key);
     // TODO(gak): is checking the kind enough?
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
index 476469a59..d76099bfb 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
@@ -20,6 +20,7 @@
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableList;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.MethodSpec;
@@ -38,14 +39,14 @@
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.SimpleTypeVisitor6;
 
-import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static com.squareup.javapoet.MethodSpec.constructorBuilder;
+import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static com.squareup.javapoet.TypeSpec.classBuilder;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.MapKeys.getMapKeyCreatorClassName;
 import static javax.lang.model.element.Modifier.FINAL;
-import static javax.lang.model.element.Modifier.PUBLIC;
 import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PUBLIC;
 import static javax.lang.model.element.Modifier.STATIC;
 import static javax.lang.model.util.ElementFilter.methodsIn;
 
@@ -150,6 +151,7 @@ private MethodSpec buildCreateMethod(
     return nestedAnnotationElements(annotationElement, new LinkedHashSet<TypeElement>());
   }
 
+  @CanIgnoreReturnValue
   private static Set<TypeElement> nestedAnnotationElements(
       TypeElement annotationElement, Set<TypeElement> annotationElements) {
     if (annotationElements.add(annotationElement)) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
index 1c4871e5b..781296236 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
@@ -22,6 +22,7 @@
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import dagger.Module;
 import dagger.Multibindings;
 import dagger.Provides;
@@ -196,6 +197,7 @@ ModuleDescriptor create(TypeElement moduleElement) {
           .or(getAnnotationMirror(moduleElement, ProducerModule.class));
     }
 
+    @CanIgnoreReturnValue
     private Set<ModuleDescriptor> collectIncludedModules(
         Set<ModuleDescriptor> includedModules, TypeElement moduleElement) {
       TypeMirror superclass = moduleElement.getSuperclass();
diff --git a/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java b/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java
index e17406755..97f47ecfd 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java
@@ -18,6 +18,8 @@
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableSet;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import javax.annotation.CheckReturnValue;
 import javax.annotation.processing.Messager;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
@@ -132,6 +134,7 @@ private static boolean isEnclosedIn(Element parent, Element child) {
     return new Builder<T>(subject);
   }
 
+  @CanIgnoreReturnValue
   static final class Builder<T extends Element> {
     private final T subject;
     private final ImmutableSet.Builder<Item> items = ImmutableSet.builder();
@@ -141,6 +144,7 @@ private Builder(T subject) {
       this.subject = subject;
     }
 
+    @CheckReturnValue
     T getSubject() {
       return subject;
     }
@@ -151,58 +155,47 @@ T getSubject() {
     }
 
     Builder<T> addError(String message) {
-      addItem(message, ERROR, subject, Optional.<AnnotationMirror>absent());
-      return this;
+      return addItem(message, ERROR, subject, Optional.<AnnotationMirror>absent());
     }
 
     Builder<T> addError(String message, Element element) {
-      addItem(message, ERROR, element, Optional.<AnnotationMirror>absent());
-      return this;
+      return addItem(message, ERROR, element, Optional.<AnnotationMirror>absent());
     }
 
     Builder<T> addError(String message, Element element, AnnotationMirror annotation) {
-      addItem(message, ERROR, element, Optional.of(annotation));
-      return this;
+      return addItem(message, ERROR, element, Optional.of(annotation));
     }
 
     Builder<T> addWarning(String message) {
-      addItem(message, WARNING, subject, Optional.<AnnotationMirror>absent());
-      return this;
+      return addItem(message, WARNING, subject, Optional.<AnnotationMirror>absent());
     }
 
     Builder<T> addWarning(String message, Element element) {
-      addItem(message, WARNING, element, Optional.<AnnotationMirror>absent());
-      return this;
+      return addItem(message, WARNING, element, Optional.<AnnotationMirror>absent());
     }
 
     Builder<T> addWarning(String message, Element element, AnnotationMirror annotation) {
-      addItem(message, WARNING, element, Optional.of(annotation));
-      return this;
+      return addItem(message, WARNING, element, Optional.of(annotation));
     }
 
     Builder<T> addNote(String message) {
-      addItem(message, NOTE, subject, Optional.<AnnotationMirror>absent());
-      return this;
+      return addItem(message, NOTE, subject, Optional.<AnnotationMirror>absent());
     }
 
     Builder<T> addNote(String message, Element element) {
-      addItem(message, NOTE, element, Optional.<AnnotationMirror>absent());
-      return this;
+      return addItem(message, NOTE, element, Optional.<AnnotationMirror>absent());
     }
 
     Builder<T> addNote(String message, Element element, AnnotationMirror annotation) {
-      addItem(message, NOTE, element, Optional.of(annotation));
-      return this;
+      return addItem(message, NOTE, element, Optional.of(annotation));
     }
 
     Builder<T> addItem(String message, Kind kind, Element element) {
-      addItem(message, kind, element, Optional.<AnnotationMirror>absent());
-      return this;
+      return addItem(message, kind, element, Optional.<AnnotationMirror>absent());
     }
 
     Builder<T> addItem(String message, Kind kind, Element element, AnnotationMirror annotation) {
-      addItem(message, kind, element, Optional.of(annotation));
-      return this;
+      return addItem(message, kind, element, Optional.of(annotation));
     }
 
     private Builder<T> addItem(String message, Kind kind, Element element,
@@ -216,6 +209,7 @@ T getSubject() {
       return this;
     }
 
+    @CheckReturnValue
     ValidationReport<T> build() {
       return new AutoValue_ValidationReport<T>(subject, items.build(), subreports.build());
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/package-info.java b/compiler/src/main/java/dagger/internal/codegen/package-info.java
new file mode 100644
index 000000000..ff764c87a
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/package-info.java
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+@CheckReturnValue
+package dagger.internal.codegen;
+
+import javax.annotation.CheckReturnValue;
diff --git a/pom.xml b/pom.xml
index c2b1fd922..59baacfa3 100644
--- a/pom.xml
+++ b/pom.xml
@@ -51,6 +51,7 @@
     <auto.factory.version>1.0-beta3</auto.factory.version>
     <auto.service.version>1.0-rc2</auto.service.version>
     <auto.value.version>1.0</auto.value.version>
+    <errorprone.version>2.0.8</errorprone.version>
     <guava.version>19.0-rc2</guava.version>
     <google.java.format.version>0.1-alpha</google.java.format.version>
 
@@ -138,6 +139,11 @@
         <artifactId>auto-value</artifactId>
         <version>${auto.value.version}</version>
       </dependency>
+      <dependency>
+        <groupId>com.google.errorprone</groupId>
+        <artifactId>error_prone_annotations</artifactId>
+        <version>${errorprone.version}</version>
+      </dependency>
       <dependency>
         <groupId>junit</groupId>
         <artifactId>junit</artifactId>
