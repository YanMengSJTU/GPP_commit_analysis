diff --git a/.gitignore b/.gitignore
index 7de7142f7..f05f56746 100644
--- a/.gitignore
+++ b/.gitignore
@@ -27,5 +27,3 @@ obj
 .DS_Store
 
 dependency-reduced-pom.xml
-
-test_runs/
diff --git a/compiler/pom.xml b/compiler/pom.xml
index 72252f1dd..cd68d9c2a 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -66,8 +66,8 @@
     <dependency>
       <groupId>com.google.auto.value</groupId>
       <artifactId>auto-value</artifactId>
-      <scope>provided</scope> <!-- to leave out of the all-deps jar -->
       <version>1.0</version>
+      <scope>provided</scope> <!-- to leave out of the all-deps jar -->
     </dependency>
 
     <dependency>
@@ -160,6 +160,7 @@
         </executions>
       </plugin>
       <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-shade-plugin</artifactId>
         <version>2.3</version>
         <executions>
diff --git a/compiler/src/it/functional-tests/pom.xml b/compiler/src/it/functional-tests/pom.xml
index ce3dd4e62..217e6167a 100644
--- a/compiler/src/it/functional-tests/pom.xml
+++ b/compiler/src/it/functional-tests/pom.xml
@@ -48,14 +48,12 @@ limitations under the License.
       <artifactId>javax.inject-tck</artifactId>
     </dependency>
     <dependency>
-      <!-- For map-bindings -->
       <groupId>com.google.auto.value</groupId>
       <artifactId>auto-value</artifactId>
       <version>${auto.value.version}</version>
       <scope>provided</scope> <!-- to leave out of the all-deps jar -->
     </dependency>
     <dependency>
-      <!-- For map-bindings -->
       <groupId>com.google.auto.factory</groupId>
       <artifactId>auto-factory</artifactId>
       <version>${auto.factory.version}</version>
diff --git a/compiler/src/it/functional-tests/src/main/java/test/GenericParent.java b/compiler/src/it/functional-tests/src/main/java/test/GenericParent.java
index 0e01f5f7e..c50e3451b 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/GenericParent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/GenericParent.java
@@ -16,22 +16,24 @@
 package test;
 
 import javax.inject.Inject;
+import javax.inject.Provider;
 
 class GenericParent<X, Y> {
   
-  X registeredX;
+  Provider<X> registeredX;
   Y registeredY;
   B registeredB;
   
-  
   @Inject GenericParent() {}
   
-  @Inject X x;
+  @Inject Provider<X> x;
   @Inject Y y;
   @Inject B b;
   
-  @Inject void registerX(X x) { this.registeredX = x; }
+  @Inject
+  void registerX(Provider<X> x) {
+    this.registeredX = x;
+  }
   @Inject void registerY(Y y) { this.registeredY = y; }
   @Inject void registerB(B b) { this.registeredB = b; }
-
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java b/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java
index ac0624f83..92355088b 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java
@@ -50,4 +50,23 @@
   Map<StringKey, String> unwrappedAnnotationKeyMap();
   Map<WrappedAnnotationKey, String> wrappedAnnotationKeyMap();
   @Named("complexQualifier") Set<String> complexQualifierStringSet();
+  Set<Object> emptySet();
+
+  @Named("complexQualifier")
+  Set<Object> emptyQualifiedSet();
+
+  Map<String, Object> emptyMap();
+
+  @Named("complexQualifier")
+  Map<String, Object> emptyQualifiedMap();
+
+  Set<CharSequence> maybeEmptySet();
+
+  @Named("complexQualifier")
+  Set<CharSequence> maybeEmptyQualifiedSet();
+
+  Map<String, CharSequence> maybeEmptyMap();
+
+  @Named("complexQualifier")
+  Map<String, CharSequence> maybeEmptyQualifiedMap();
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java b/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java
index 4a7577e76..08433a988 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java
@@ -16,6 +16,7 @@
 package test;
 
 import dagger.Module;
+import dagger.Multibindings;
 import dagger.Provides;
 import dagger.mapkeys.ClassKey;
 import dagger.mapkeys.IntKey;
@@ -178,4 +179,53 @@ static String valueForWrappedAnnotationKeyFoo() {
   static String valueForComplexQualifierSet() {
     return "foo";
   }
+
+  @Provides(type = SET)
+  static CharSequence setContribution() {
+    return "foo";
+  }
+
+  @Provides(type = SET)
+  @Named("complexQualifier")
+  static CharSequence qualifiedSetContribution() {
+    return "qualified foo";
+  }
+
+  @Provides(type = MAP)
+  @StringKey("key")
+  static CharSequence mapContribution() {
+    return "foo value";
+  }
+
+  @Provides(type = MAP)
+  @Named("complexQualifier")
+  @StringKey("key")
+  static CharSequence qualifiedMapContribution() {
+    return "qualified foo value";
+  }
+
+  interface EmptiesSupertype {
+    Set<Object> emptySet();
+
+    Map<String, Object> emptyMap();
+
+    Set<CharSequence> maybeEmptySet();
+
+    Map<String, CharSequence> maybeEmptyMap();
+  }
+
+  @Multibindings
+  interface Empties extends EmptiesSupertype {
+    @Named("complexQualifier")
+    Set<Object> emptyQualifiedSet();
+
+    @Named("complexQualifier")
+    Map<String, Object> emptyQualifiedMap();
+
+    @Named("complexQualifier")
+    Set<CharSequence> maybeEmptyQualifiedSet();
+
+    @Named("complexQualifier")
+    Map<String, CharSequence> maybeEmptyQualifiedMap();
+  }
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildMultibindingModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildMultibindingModule.java
deleted file mode 100644
index ae02b9e6f..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildMultibindingModule.java
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Copyright (C) 2015 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package test.subcomponent;
-
-import dagger.Module;
-import dagger.Provides;
-import dagger.mapkeys.StringKey;
-
-import static dagger.Provides.Type.MAP;
-import static dagger.Provides.Type.SET;
-
-@Module
-class ChildMultibindingModule {
-
-  @Provides(type = SET)
-  static Object childObject() {
-    return "object provided by child";
-  }
-
-  @Provides(type = MAP)
-  @StringKey("child key")
-  static Object childKeyObject() {
-    return "object in child";
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/MultibindingSubcomponents.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/MultibindingSubcomponents.java
new file mode 100644
index 000000000..612096417
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/MultibindingSubcomponents.java
@@ -0,0 +1,202 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import dagger.Component;
+import dagger.Module;
+import dagger.Provides;
+import dagger.Subcomponent;
+import dagger.mapkeys.StringKey;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Set;
+import javax.inject.Inject;
+
+import static dagger.Provides.Type.MAP;
+import static dagger.Provides.Type.SET;
+
+final class MultibindingSubcomponents {
+
+  /** Multibindings for this type are bound only in the parent component. */
+  enum BoundInParent {
+    INSTANCE;
+  }
+
+  /** Multibindings for this type are bound only in the child component. */
+  enum BoundInChild {
+    INSTANCE;
+  }
+
+  /** Multibindings for this type are bound in the parent component and the child component. */
+  enum BoundInParentAndChild {
+    IN_PARENT,
+    IN_CHILD;
+  }
+
+  static final class RequiresMultibindings<T> {
+    private final Set<T> set;
+    private final Map<String, T> map;
+
+    @Inject
+    RequiresMultibindings(Set<T> set, Map<String, T> map) {
+      this.set = set;
+      this.map = map;
+    }
+
+    Set<T> set() {
+      return set;
+    }
+
+    Map<String, T> map() {
+      return map;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+      return obj instanceof RequiresMultibindings<?>
+          && set.equals(((RequiresMultibindings<?>) obj).set)
+          && map.equals(((RequiresMultibindings<?>) obj).map);
+    }
+
+    @Override
+    public int hashCode() {
+      return Objects.hash(set, map);
+    }
+
+    @Override
+    public String toString() {
+      return String.format(
+          "%s{set=%s, map=%s}", RequiresMultibindings.class.getSimpleName(), set, map);
+    }
+  }
+
+  @Module
+  static final class ParentMultibindingModule {
+
+    @Provides(type = SET)
+    static BoundInParent onlyInParentElement() {
+      return BoundInParent.INSTANCE;
+    }
+
+    @Provides(type = MAP)
+    @StringKey("parent key")
+    static BoundInParent onlyInParentEntry() {
+      return BoundInParent.INSTANCE;
+    }
+
+    @Provides(type = SET)
+    static BoundInParentAndChild inParentAndChildElement() {
+      return BoundInParentAndChild.IN_PARENT;
+    }
+
+    @Provides(type = MAP)
+    @StringKey("parent key")
+    static BoundInParentAndChild inParentAndChildEntry() {
+      return BoundInParentAndChild.IN_PARENT;
+    }
+
+    @Provides(type = SET)
+    static RequiresMultibindings<BoundInParentAndChild>
+        requiresMultibindingsInParentAndChildElement(
+            RequiresMultibindings<BoundInParentAndChild> requiresMultibindingsInParentAndChild) {
+      return requiresMultibindingsInParentAndChild;
+    }
+  }
+
+  @Module
+  static final class ChildMultibindingModule {
+
+    @Provides(type = SET)
+    static BoundInParentAndChild inParentAndChildElement() {
+      return BoundInParentAndChild.IN_CHILD;
+    }
+
+    @Provides(type = MAP)
+    @StringKey("child key")
+    static BoundInParentAndChild inParentAndChildEntry() {
+      return BoundInParentAndChild.IN_CHILD;
+    }
+
+    @Provides(type = SET)
+    static BoundInChild onlyInChildElement() {
+      return BoundInChild.INSTANCE;
+    }
+
+    @Provides(type = MAP)
+    @StringKey("child key")
+    static BoundInChild onlyInChildEntry() {
+      return BoundInChild.INSTANCE;
+    }
+  }
+
+  interface ProvidesBoundInParent {
+    RequiresMultibindings<BoundInParent> requiresMultibindingsBoundInParent();
+  }
+
+  interface ProvidesBoundInChild {
+    RequiresMultibindings<BoundInChild> requiresMultibindingsBoundInChild();
+  }
+
+  interface ProvidesBoundInParentAndChild {
+    RequiresMultibindings<BoundInParentAndChild> requiresMultibindingsBoundInParentAndChild();
+  }
+
+  interface ProvidesSetOfRequiresMultibindings {
+    Set<RequiresMultibindings<BoundInParentAndChild>> setOfRequiresMultibindingsInParentAndChild();
+  }
+
+  interface ParentWithProvision extends ProvidesBoundInParent, ProvidesBoundInParentAndChild {}
+
+  interface HasChildWithProvision {
+    ChildWithProvision childWithProvision();
+  }
+
+  interface HasChildWithoutProvision {
+    ChildWithoutProvision childWithoutProvision();
+  }
+
+  @Component(modules = ParentMultibindingModule.class)
+  interface ParentWithoutProvisionHasChildWithoutProvision extends HasChildWithoutProvision {}
+
+  @Component(modules = ParentMultibindingModule.class)
+  interface ParentWithoutProvisionHasChildWithProvision extends HasChildWithProvision {}
+
+  @Component(modules = ParentMultibindingModule.class)
+  interface ParentWithProvisionHasChildWithoutProvision
+      extends ParentWithProvision, HasChildWithoutProvision {}
+
+  @Component(modules = ParentMultibindingModule.class)
+  interface ParentWithProvisionHasChildWithProvision
+      extends ParentWithProvision, HasChildWithProvision {}
+
+  @Subcomponent(modules = ChildMultibindingModule.class)
+  interface ChildWithoutProvision {
+    Grandchild grandchild();
+  }
+
+  @Subcomponent(modules = ChildMultibindingModule.class)
+  interface ChildWithProvision
+      extends ProvidesBoundInParent, ProvidesBoundInParentAndChild, ProvidesBoundInChild,
+          ProvidesSetOfRequiresMultibindings {
+
+    Grandchild grandchild();
+  }
+
+  @Subcomponent
+  interface Grandchild
+      extends ProvidesBoundInParent, ProvidesBoundInParentAndChild, ProvidesBoundInChild,
+          ProvidesSetOfRequiresMultibindings {}
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponentWithoutMultibindings.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponentWithoutMultibindings.java
deleted file mode 100644
index 3d4431ca9..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponentWithoutMultibindings.java
+++ /dev/null
@@ -1,23 +0,0 @@
-/*
- * Copyright (C) 2015 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package test.subcomponent;
-
-import dagger.Component;
-
-@Component(modules = ParentMultibindingModule.class)
-interface ParentComponentWithoutMultibindings {
-  ChildComponentWithMultibindings childComponent();
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentMultibindingModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentMultibindingModule.java
deleted file mode 100644
index e4ec173de..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentMultibindingModule.java
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
- * Copyright (C) 2015 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package test.subcomponent;
-
-import dagger.Module;
-import dagger.Provides;
-import dagger.mapkeys.StringKey;
-
-import static dagger.Provides.Type.MAP;
-import static dagger.Provides.Type.SET;
-
-@Module
-class ParentMultibindingModule {
-
-  @Provides(type = SET)
-  static Object provideObject() {
-    return "object provided by parent";
-  }
-
-  @Provides(type = SET)
-  static String provideString() {
-    return "string provided by parent";
-  }
-
-  @Provides(type = SET)
-  static RequiresMultiboundObjects requiresMultiboundObjects(
-      RequiresMultiboundObjects requiresMultiboundObjects) {
-    return requiresMultiboundObjects;
-  }
-
-  @Provides(type = MAP)
-  @StringKey("parent key")
-  static String parentKeyString() {
-    return "string in parent";
-  }
-
-  @Provides(type = MAP)
-  @StringKey("parent key")
-  static Object parentKeyObject() {
-    return "object in parent";
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresMultibindingsInChild.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresMultibindingsInChild.java
deleted file mode 100644
index 4ec0469de..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresMultibindingsInChild.java
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- * Copyright (C) 2015 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package test.subcomponent;
-
-import java.util.Set;
-import javax.inject.Inject;
-
-class RequiresMultibindingsInChild extends RequiresMultibindingsInParent {
-
-  @Inject
-  RequiresMultibindingsInChild(
-      RequiresMultiboundObjects requiresMultiboundObjects,
-      RequiresMultiboundStrings requiresMultiboundStrings,
-      Set<RequiresMultiboundObjects> setOfRequiresMultiboundObjects) {
-    super(requiresMultiboundObjects, requiresMultiboundStrings, setOfRequiresMultiboundObjects);
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresMultibindingsInParent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresMultibindingsInParent.java
deleted file mode 100644
index a48d38bfa..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresMultibindingsInParent.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Copyright (C) 2015 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package test.subcomponent;
-
-import java.util.Set;
-import javax.inject.Inject;
-
-class RequiresMultibindingsInParent {
-  private final RequiresMultiboundObjects requiresMultiboundObjects;
-  private final RequiresMultiboundStrings requiresMultiboundStrings;
-  private final Set<RequiresMultiboundObjects> setOfRequiresMultiboundObjects;
-
-  @Inject
-  RequiresMultibindingsInParent(
-      RequiresMultiboundObjects requiresMultiboundObjects,
-      RequiresMultiboundStrings requiresMultiboundStrings,
-      Set<RequiresMultiboundObjects> setOfRequiresMultiboundObjects) {
-    this.requiresMultiboundObjects = requiresMultiboundObjects;
-    this.requiresMultiboundStrings = requiresMultiboundStrings;
-    this.setOfRequiresMultiboundObjects = setOfRequiresMultiboundObjects;
-  }
-
-  RequiresMultiboundObjects requiresMultiboundObjects() {
-    return requiresMultiboundObjects;
-  }
-
-  RequiresMultiboundStrings requiresMultiboundStrings() {
-    return requiresMultiboundStrings;
-  }
-
-  Set<RequiresMultiboundObjects> setOfRequiresMultiboundObjects() {
-    return setOfRequiresMultiboundObjects;
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresMultiboundObjects.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresMultiboundObjects.java
deleted file mode 100644
index d787153e3..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresMultiboundObjects.java
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Copyright (C) 2015 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package test.subcomponent;
-
-import java.util.Map;
-import java.util.Set;
-import javax.inject.Inject;
-
-class RequiresMultiboundObjects {
-  private final Set<Object> setOfObjects;
-  private final Map<String, Object> mapOfObjects;
-
-  @Inject
-  RequiresMultiboundObjects(Set<Object> setOfObjects, Map<String, Object> mapOfObjects) {
-    this.setOfObjects = setOfObjects;
-    this.mapOfObjects = mapOfObjects;
-  }
-
-  Set<Object> setOfObjects() {
-    return setOfObjects;
-  }
-
-  Map<String, Object> mapOfObjects() {
-    return mapOfObjects;
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresMultiboundStrings.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresMultiboundStrings.java
deleted file mode 100644
index 410bdf2c0..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresMultiboundStrings.java
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Copyright (C) 2015 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package test.subcomponent;
-
-import java.util.Map;
-import java.util.Set;
-import javax.inject.Inject;
-
-class RequiresMultiboundStrings {
-  private final Set<String> setOfStrings;
-  private final Map<String, String> mapOfStrings;
-
-  @Inject
-  RequiresMultiboundStrings(Set<String> setOfStrings, Map<String, String> mapOfStrings) {
-    this.setOfStrings = setOfStrings;
-    this.mapOfStrings = mapOfStrings;
-  }
-
-  Set<String> setOfStrings() {
-    return setOfStrings;
-  }
-
-  Map<String, String> mapOfStrings() {
-    return mapOfStrings;
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java b/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
index 1b7e30233..e0ad8e651 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
@@ -154,6 +154,47 @@ public void shortKeyMap() {
   @Test public void complexQualifierSet() {
     assertThat(multibindingComponent.complexQualifierStringSet()).containsExactly("foo");
   }
+  
+  @Test
+  public void emptySet() {
+    assertThat(multibindingComponent.emptySet()).isEmpty();
+  }
+
+  @Test
+  public void emptyQualifiedSet() {
+    assertThat(multibindingComponent.emptyQualifiedSet()).isEmpty();
+  }
+
+  @Test
+  public void emptyMap() {
+    assertThat(multibindingComponent.emptyMap()).isEmpty();
+  }
+
+  @Test
+  public void emptyQualifiedMap() {
+    assertThat(multibindingComponent.emptyQualifiedMap()).isEmpty();
+  }
+
+  @Test
+  public void maybeEmptySet() {
+    assertThat(multibindingComponent.maybeEmptySet()).containsExactly("foo");
+  }
+
+  @Test
+  public void maybeEmptyQualifiedSet() {
+    assertThat(multibindingComponent.maybeEmptyQualifiedSet()).containsExactly("qualified foo");
+  }
+
+  @Test
+  public void maybeEmptyMap() {
+    assertThat(multibindingComponent.maybeEmptyMap()).containsEntry("key", "foo value");
+  }
+
+  @Test
+  public void maybeEmptyQualifiedMap() {
+    assertThat(multibindingComponent.maybeEmptyQualifiedMap())
+        .containsEntry("key", "qualified foo value");
+  }
 
   @AutoAnnotation
   static StringKey testStringKey(String value) {
diff --git a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentMultibindingsTest.java b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentMultibindingsTest.java
index f57a77831..99ca1cd44 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentMultibindingsTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentMultibindingsTest.java
@@ -15,75 +15,225 @@
  */
 package test.subcomponent;
 
-import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
-import java.util.Collection;
+import com.google.common.collect.ImmutableSet;
+import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
-import org.junit.runners.Parameterized.Parameters;
-
-import static com.google.common.collect.Iterables.getOnlyElement;
-import static com.google.common.truth.Truth.assertWithMessage;
-
-@RunWith(Parameterized.class)
+import org.junit.runners.JUnit4;
+import test.subcomponent.MultibindingSubcomponents.BoundInChild;
+import test.subcomponent.MultibindingSubcomponents.BoundInParent;
+import test.subcomponent.MultibindingSubcomponents.BoundInParentAndChild;
+import test.subcomponent.MultibindingSubcomponents.ParentWithProvisionHasChildWithProvision;
+import test.subcomponent.MultibindingSubcomponents.ParentWithProvisionHasChildWithoutProvision;
+import test.subcomponent.MultibindingSubcomponents.ParentWithoutProvisionHasChildWithProvision;
+import test.subcomponent.MultibindingSubcomponents.ParentWithoutProvisionHasChildWithoutProvision;
+import test.subcomponent.MultibindingSubcomponents.RequiresMultibindings;
+
+import static com.google.common.truth.Truth.assertThat;
+
+@RunWith(JUnit4.class)
 public class SubcomponentMultibindingsTest {
 
-  @Parameters(name = "{0}")
-  public static Collection<Object[]> parameters() {
-    return ImmutableList.of(
-        new Object[] {DaggerParentComponentWithMultibindings.create()},
-        new Object[] {DaggerParentComponentWithoutMultibindings.create()});
+  private static final RequiresMultibindings<BoundInParent> BOUND_IN_PARENT =
+      new RequiresMultibindings<>(
+          ImmutableSet.of(BoundInParent.INSTANCE),
+          ImmutableMap.of("parent key", BoundInParent.INSTANCE));
+
+  private static final RequiresMultibindings<BoundInChild> BOUND_IN_CHILD =
+      new RequiresMultibindings<>(
+          ImmutableSet.of(BoundInChild.INSTANCE),
+          ImmutableMap.of("child key", BoundInChild.INSTANCE));
+
+  private static final RequiresMultibindings<BoundInParentAndChild> BOUND_IN_PARENT_AND_CHILD =
+      new RequiresMultibindings<>(
+          ImmutableSet.of(BoundInParentAndChild.IN_PARENT, BoundInParentAndChild.IN_CHILD),
+          ImmutableMap.of(
+              "parent key", BoundInParentAndChild.IN_PARENT,
+              "child key", BoundInParentAndChild.IN_CHILD));
+
+  private static final RequiresMultibindings<BoundInParentAndChild>
+      BOUND_IN_PARENT_AND_CHILD_PROVIDED_BY_PARENT =
+          new RequiresMultibindings<>(
+              ImmutableSet.of(BoundInParentAndChild.IN_PARENT),
+              ImmutableMap.of("parent key", BoundInParentAndChild.IN_PARENT));
+
+  private ParentWithoutProvisionHasChildWithoutProvision
+      parentWithoutProvisionHasChildWithoutProvision;
+  private ParentWithoutProvisionHasChildWithProvision parentWithoutProvisionHasChildWithProvision;
+  private ParentWithProvisionHasChildWithoutProvision parentWithProvisionHasChildWithoutProvision;
+  private ParentWithProvisionHasChildWithProvision parentWithProvisionHasChildWithProvision;
+
+  @Before
+  public void setUp() {
+    parentWithoutProvisionHasChildWithoutProvision =
+        DaggerMultibindingSubcomponents_ParentWithoutProvisionHasChildWithoutProvision.create();
+    parentWithoutProvisionHasChildWithProvision =
+        DaggerMultibindingSubcomponents_ParentWithoutProvisionHasChildWithProvision.create();
+    parentWithProvisionHasChildWithoutProvision =
+        DaggerMultibindingSubcomponents_ParentWithProvisionHasChildWithoutProvision.create();
+    parentWithProvisionHasChildWithProvision =
+        DaggerMultibindingSubcomponents_ParentWithProvisionHasChildWithProvision.create();
   }
 
-  private ParentComponentWithoutMultibindings parent;
-
-  public SubcomponentMultibindingsTest(ParentComponentWithoutMultibindings parentComponent) {
-    this.parent = parentComponent;
+  @Test
+  public void testParentWithoutProvisionHasChildWithoutProvision() {
+    // Child
+    assertThat(
+            parentWithoutProvisionHasChildWithoutProvision
+                .childWithoutProvision()
+                .grandchild()
+                .requiresMultibindingsBoundInParent())
+        .isEqualTo(BOUND_IN_PARENT);
+
+    // Grandchild
+    assertThat(
+            parentWithoutProvisionHasChildWithoutProvision
+                .childWithoutProvision()
+                .grandchild()
+                .requiresMultibindingsBoundInParentAndChild())
+        .isEqualTo(BOUND_IN_PARENT_AND_CHILD);
+    assertThat(
+            parentWithoutProvisionHasChildWithoutProvision
+                .childWithoutProvision()
+                .grandchild()
+                .requiresMultibindingsBoundInChild())
+        .isEqualTo(BOUND_IN_CHILD);
+
+    assertThat(
+            parentWithoutProvisionHasChildWithoutProvision
+                .childWithoutProvision()
+                .grandchild()
+                .setOfRequiresMultibindingsInParentAndChild())
+        .containsExactly(BOUND_IN_PARENT_AND_CHILD);
   }
 
   @Test
-  public void testMultibindingsInSubcomponents() {
-    RequiresMultibindingsInChild requiresMultibindingsInChild =
-        parent.childComponent().requiresMultibindingsInChild();
-
-    assertWithMessage("requiresMultiboundObjects.setOfObjects")
-        .that(requiresMultibindingsInChild.requiresMultiboundObjects().setOfObjects())
-        .containsExactly("object provided by parent", "object provided by child");
-
-    assertWithMessage("requiresMultiboundObjects.mapOfObjects")
-        .that(requiresMultibindingsInChild.requiresMultiboundObjects().mapOfObjects())
-        .isEqualTo(
-            ImmutableMap.of("parent key", "object in parent", "child key", "object in child"));
-
-    assertWithMessage("requiresMultiboundStrings")
-        .that(requiresMultibindingsInChild.requiresMultiboundStrings().setOfStrings())
-        .containsExactly("string provided by parent");
-
-    assertWithMessage("requiresMultiboundStrings.mapOfStrings")
-        .that(requiresMultibindingsInChild.requiresMultiboundStrings().mapOfStrings())
-        .isEqualTo(ImmutableMap.of("parent key", "string in parent"));
+  public void testParentWithoutProvisionHasChildWithProvision() {
+    // Child
+    assertThat(
+            parentWithoutProvisionHasChildWithProvision
+                .childWithProvision()
+                .grandchild()
+                .requiresMultibindingsBoundInParent())
+        .isEqualTo(BOUND_IN_PARENT);
+
+    // Grandchild
+    assertThat(
+            parentWithoutProvisionHasChildWithProvision
+                .childWithProvision()
+                .grandchild()
+                .requiresMultibindingsBoundInParentAndChild())
+        .isEqualTo(BOUND_IN_PARENT_AND_CHILD);
+    assertThat(
+            parentWithoutProvisionHasChildWithProvision
+                .childWithProvision()
+                .grandchild()
+                .requiresMultibindingsBoundInChild())
+        .isEqualTo(BOUND_IN_CHILD);
+
+    assertThat(
+            parentWithoutProvisionHasChildWithProvision
+                .childWithProvision()
+                .grandchild()
+                .setOfRequiresMultibindingsInParentAndChild())
+        .containsExactly(BOUND_IN_PARENT_AND_CHILD);
   }
 
   @Test
-  public void testOverriddenMultibindingsInSubcomponents() {
-    RequiresMultibindingsInChild requiresMultibindingsInChild =
-        parent.childComponent().requiresMultibindingsInChild();
-
-    assertWithMessage("setOfRequiresMultiboundObjects")
-        .that(requiresMultibindingsInChild.setOfRequiresMultiboundObjects())
-        .hasSize(1);
-
-    RequiresMultiboundObjects onlyElementInMultiboundRequiresMultiboundObjects =
-        getOnlyElement(requiresMultibindingsInChild.setOfRequiresMultiboundObjects());
-
-    assertWithMessage("setOfRequiresMultiboundObjects[only].setOfObjects")
-        .that(onlyElementInMultiboundRequiresMultiboundObjects.setOfObjects())
-        .containsExactly("object provided by parent", "object provided by child");
+  public void testParentWithProvisionHasChildWithoutProvision() {
+    // Parent
+    assertThat(parentWithProvisionHasChildWithoutProvision.requiresMultibindingsBoundInParent())
+        .isEqualTo(BOUND_IN_PARENT);
+
+    assertThat(
+            parentWithProvisionHasChildWithoutProvision
+                .requiresMultibindingsBoundInParentAndChild())
+        .isEqualTo(BOUND_IN_PARENT_AND_CHILD_PROVIDED_BY_PARENT);
+
+    // Grandchild
+    assertThat(
+            parentWithProvisionHasChildWithoutProvision
+                .childWithoutProvision()
+                .grandchild()
+                .requiresMultibindingsBoundInParent())
+        .isEqualTo(BOUND_IN_PARENT);
+    assertThat(
+            parentWithProvisionHasChildWithoutProvision
+                .childWithoutProvision()
+                .grandchild()
+                .requiresMultibindingsBoundInChild())
+        .isEqualTo(BOUND_IN_CHILD);
+
+    assertThat(
+            parentWithProvisionHasChildWithoutProvision
+                .childWithoutProvision()
+                .grandchild()
+                .requiresMultibindingsBoundInParentAndChild())
+        .isEqualTo(BOUND_IN_PARENT_AND_CHILD);
+
+    assertThat(
+            parentWithProvisionHasChildWithoutProvision
+                .childWithoutProvision()
+                .grandchild()
+                .setOfRequiresMultibindingsInParentAndChild())
+        .containsExactly(BOUND_IN_PARENT_AND_CHILD);
+  }
 
-    assertWithMessage("setOfRequiresMultiboundObjects[only].mapOfObjects")
-        .that(onlyElementInMultiboundRequiresMultiboundObjects.mapOfObjects())
-        .isEqualTo(
-            ImmutableMap.of("parent key", "object in parent", "child key", "object in child"));
+  @Test
+  public void testParentWithProvisionHasChildWithProvision() {
+    // Parent
+    assertThat(parentWithProvisionHasChildWithProvision.requiresMultibindingsBoundInParent())
+        .isEqualTo(BOUND_IN_PARENT);
+
+    // Child
+    assertThat(
+            parentWithProvisionHasChildWithProvision
+                .childWithProvision()
+                .requiresMultibindingsBoundInParent())
+        .isEqualTo(BOUND_IN_PARENT);
+    assertThat(
+            parentWithProvisionHasChildWithProvision
+                .childWithProvision()
+                .requiresMultibindingsBoundInChild())
+        .isEqualTo(BOUND_IN_CHILD);
+    assertThat(
+            parentWithProvisionHasChildWithProvision
+                .childWithProvision()
+                .requiresMultibindingsBoundInParentAndChild())
+        .isEqualTo(BOUND_IN_PARENT_AND_CHILD);
+
+    assertThat(
+            parentWithProvisionHasChildWithProvision
+                .childWithProvision()
+                .setOfRequiresMultibindingsInParentAndChild())
+        .containsExactly(BOUND_IN_PARENT_AND_CHILD);
+
+    // Grandchild
+    assertThat(
+            parentWithProvisionHasChildWithProvision
+                .childWithProvision()
+                .grandchild()
+                .requiresMultibindingsBoundInParent())
+        .isEqualTo(BOUND_IN_PARENT);
+    assertThat(
+            parentWithProvisionHasChildWithProvision
+                .childWithProvision()
+                .grandchild()
+                .requiresMultibindingsBoundInChild())
+        .isEqualTo(BOUND_IN_CHILD);
+    assertThat(
+            parentWithProvisionHasChildWithProvision
+                .childWithProvision()
+                .grandchild()
+                .requiresMultibindingsBoundInParentAndChild())
+        .isEqualTo(BOUND_IN_PARENT_AND_CHILD);
+
+    assertThat(
+            parentWithProvisionHasChildWithProvision
+                .childWithProvision()
+                .grandchild()
+                .setOfRequiresMultibindingsInParentAndChild())
+        .containsExactly(BOUND_IN_PARENT_AND_CHILD);
   }
 }
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/ResponseProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/ResponseProducerModule.java
index 0ef2ae886..02fa7e91f 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/ResponseProducerModule.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/ResponseProducerModule.java
@@ -17,18 +17,40 @@
 
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
+import dagger.Lazy;
+import dagger.producers.Produced;
+import dagger.producers.Producer;
 import dagger.producers.ProducerModule;
 import dagger.producers.Produces;
+import javax.inject.Provider;
+import javax.inject.Qualifier;
 
 @ProducerModule(includes = ResponseModule.class)
 final class ResponseProducerModule {
+  @Qualifier
+  @interface RequestsProducerAndProduced {}
+
   @Produces
   static ListenableFuture<String> greeting() {
     return Futures.immediateFuture("Hello");
   }
 
   @Produces
-  static Response response(String greeting, Request request, int requestNumber) {
+  @RequestsProducerAndProduced
+  static ListenableFuture<String> intermediateGreeting(
+      // TODO(beder): Allow Producer and Provider of the same type (which would force the binding
+      // to be a provision binding), and add validation for that.
+      String greeting,
+      Producer<String> greetingProducer,
+      Produced<String> greetingProduced,
+      Provider<Integer> requestNumberProvider,
+      Lazy<Integer> requestNumberLazy) {
+    return greetingProducer.get();
+  }
+
+  @Produces
+  static Response response(
+      @RequestsProducerAndProduced String greeting, Request request, int requestNumber) {
     return new Response(String.format("%s, %s #%d!", greeting, request.name(), requestNumber));
   }
 }
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/monitoring/MonitoringTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/monitoring/MonitoringTest.java
index 3efb2b5b1..375c90a19 100644
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/monitoring/MonitoringTest.java
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/monitoring/MonitoringTest.java
@@ -84,6 +84,9 @@ public void basicMonitoring() throws Exception {
     ProducerMonitor requestDataMonitor = entries.get(2).getValue();
 
     InOrder inOrder = inOrder(requestDataMonitor, callServer1Monitor, callServer2Monitor);
+    inOrder.verify(callServer2Monitor).requested();
+    inOrder.verify(callServer1Monitor).requested();
+    inOrder.verify(requestDataMonitor).requested();
     inOrder.verify(requestDataMonitor).methodStarting();
     inOrder.verify(requestDataMonitor).methodFinished();
     inOrder.verify(requestDataMonitor).succeeded("Hello, World!");
@@ -124,6 +127,9 @@ public void basicMonitoringWithFailure() throws Exception {
     ProducerMonitor requestDataMonitor = entries.get(2).getValue();
 
     InOrder inOrder = inOrder(requestDataMonitor, callServer1Monitor, callServer2Monitor);
+    inOrder.verify(callServer2Monitor).requested();
+    inOrder.verify(callServer1Monitor).requested();
+    inOrder.verify(requestDataMonitor).requested();
     inOrder.verify(requestDataMonitor).methodStarting();
     inOrder.verify(requestDataMonitor).methodFinished();
     inOrder.verify(requestDataMonitor).succeeded("Hello, World!");
diff --git a/compiler/src/it/tck/pom.xml b/compiler/src/it/tck/pom.xml
new file mode 100644
index 000000000..34a018f7d
--- /dev/null
+++ b/compiler/src/it/tck/pom.xml
@@ -0,0 +1,87 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+Copyright (C) 2014 Google, Inc.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+-->
+<project
+    xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+  <parent>
+    <groupId>com.google.dagger</groupId>
+    <artifactId>dagger-parent</artifactId>
+    <version>2.1-SNAPSHOT</version>
+  </parent>
+  <groupId>dagger.tests</groupId>
+  <artifactId>tck</artifactId>
+  <name>TCK</name>
+  <dependencies>
+    <dependency>
+      <groupId>com.google.dagger</groupId>
+      <artifactId>dagger</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.google.dagger</groupId>
+      <artifactId>dagger-compiler</artifactId>
+      <version>${project.version}</version>
+      <optional>true</optional>
+    </dependency>
+    <dependency>
+      <groupId>javax.inject</groupId>
+      <artifactId>javax.inject-tck</artifactId>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+  <build>
+    <plugins>
+      <plugin>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <version>3.1</version>
+        <configuration>
+          <source>1.7</source>
+          <target>1.7</target>
+          <compilerArgs>
+            <arg>-Adagger.privateMemberValidation=warning</arg>
+            <arg>-Adagger.staticMemberValidation=warning</arg>
+          </compilerArgs>
+        </configuration>
+      </plugin>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-checkstyle-plugin</artifactId>
+        <version>2.10</version>
+        <configuration>
+          <failsOnError>false</failsOnError>
+          <consoleOutput>true</consoleOutput>
+          <configLocation>../../../../checkstyle.xml</configLocation>
+        </configuration>
+        <executions>
+          <execution>
+            <phase>compile</phase>
+            <goals>
+              <goal>checkstyle</goal>
+            </goals>
+          </execution>
+        </executions>
+      </plugin>
+    </plugins>
+  </build>
+</project>
diff --git a/compiler/src/it/functional-tests/src/main/java/test/tck/CarModule.java b/compiler/src/it/tck/src/main/java/test/tck/CarModule.java
similarity index 93%
rename from compiler/src/it/functional-tests/src/main/java/test/tck/CarModule.java
rename to compiler/src/it/tck/src/main/java/test/tck/CarModule.java
index bc7851739..31a8006e1 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/tck/CarModule.java
+++ b/compiler/src/it/tck/src/main/java/test/tck/CarModule.java
@@ -23,7 +23,7 @@
 @Module
 class CarModule {
   @Provides
-  Car provideConvertible(Convertible convertible) {
+  static Car provideConvertible(Convertible convertible) {
     return convertible;
   }
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/tck/CarShop.java b/compiler/src/it/tck/src/main/java/test/tck/CarShop.java
similarity index 100%
rename from compiler/src/it/functional-tests/src/main/java/test/tck/CarShop.java
rename to compiler/src/it/tck/src/main/java/test/tck/CarShop.java
diff --git a/compiler/src/it/functional-tests/src/main/java/test/tck/EngineModule.java b/compiler/src/it/tck/src/main/java/test/tck/EngineModule.java
similarity index 94%
rename from compiler/src/it/functional-tests/src/main/java/test/tck/EngineModule.java
rename to compiler/src/it/tck/src/main/java/test/tck/EngineModule.java
index 577fb5b70..61c100bae 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/tck/EngineModule.java
+++ b/compiler/src/it/tck/src/main/java/test/tck/EngineModule.java
@@ -24,7 +24,7 @@
 @Module
 public class EngineModule {
   @Provides
-  Engine provideEngine(MembersInjector<V8Engine> injector) {
+  static Engine provideEngine(MembersInjector<V8Engine> injector) {
     // This is provided because V8Engine has no @Inject constructor and Dagger requires an @Inject
     // constructor, however this is a TCK supplied class that we prefer to leave unmodified.
     V8Engine engine = new V8Engine();
diff --git a/compiler/src/it/functional-tests/src/main/java/test/tck/FuelTankModule.java b/compiler/src/it/tck/src/main/java/test/tck/FuelTankModule.java
similarity index 95%
rename from compiler/src/it/functional-tests/src/main/java/test/tck/FuelTankModule.java
rename to compiler/src/it/tck/src/main/java/test/tck/FuelTankModule.java
index 931556cfe..f412e664e 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/tck/FuelTankModule.java
+++ b/compiler/src/it/tck/src/main/java/test/tck/FuelTankModule.java
@@ -22,7 +22,7 @@
 @Module
 class FuelTankModule {
   @Provides
-  FuelTank provideFuelTank() {
+  static FuelTank provideFuelTank() {
     return new FuelTank();
   }
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/tck/SeatModule.java b/compiler/src/it/tck/src/main/java/test/tck/SeatModule.java
similarity index 94%
rename from compiler/src/it/functional-tests/src/main/java/test/tck/SeatModule.java
rename to compiler/src/it/tck/src/main/java/test/tck/SeatModule.java
index 5c6b72988..b02f218bb 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/tck/SeatModule.java
+++ b/compiler/src/it/tck/src/main/java/test/tck/SeatModule.java
@@ -25,7 +25,7 @@
 class SeatModule {
   @Provides
   @Drivers
-  Seat provideSeat(DriversSeat seat) {
+  static Seat provideSeat(DriversSeat seat) {
     return seat;
   }
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/tck/TireModule.java b/compiler/src/it/tck/src/main/java/test/tck/TireModule.java
similarity index 94%
rename from compiler/src/it/functional-tests/src/main/java/test/tck/TireModule.java
rename to compiler/src/it/tck/src/main/java/test/tck/TireModule.java
index 914a6d6ec..f41852025 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/tck/TireModule.java
+++ b/compiler/src/it/tck/src/main/java/test/tck/TireModule.java
@@ -25,7 +25,7 @@
 class TireModule {
   @Provides
   @Named("spare")
-  Tire provideTire(SpareTire sparetire) {
+  static Tire provideTire(SpareTire sparetire) {
     return sparetire;
   }
 }
diff --git a/compiler/src/it/functional-tests/src/test/java/test/tck/TckTest.java b/compiler/src/it/tck/src/test/java/test/tck/TckTest.java
similarity index 100%
rename from compiler/src/it/functional-tests/src/test/java/test/tck/TckTest.java
rename to compiler/src/it/tck/src/test/java/test/tck/TckTest.java
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentProcessingStep.java
deleted file mode 100644
index 578fb5ffa..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentProcessingStep.java
+++ /dev/null
@@ -1,117 +0,0 @@
-/*
- * Copyright (C) 2015 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
-import com.google.auto.common.MoreElements;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.SetMultimap;
-import java.lang.annotation.Annotation;
-import javax.annotation.processing.Messager;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.TypeElement;
-
-/**
- * A {@link ProcessingStep} that is responsible for dealing with a component or production component
- * as part of the {@link ComponentProcessor}.
- */
-abstract class AbstractComponentProcessingStep implements ProcessingStep {
-
-  private final Class<? extends Annotation> componentAnnotation;
-  private final Messager messager;
-  private final ComponentHierarchyValidator componentHierarchyValidator;
-  private final BindingGraphValidator bindingGraphValidator;
-  private final ComponentDescriptor.Factory componentDescriptorFactory;
-  private final BindingGraph.Factory bindingGraphFactory;
-  private final ComponentGenerator componentGenerator;
-
-  AbstractComponentProcessingStep(
-      Class<? extends Annotation> componentAnnotation,
-      Messager messager,
-      ComponentHierarchyValidator componentHierarchyValidator,
-      BindingGraphValidator bindingGraphValidator,
-      ComponentDescriptor.Factory componentDescriptorFactory,
-      BindingGraph.Factory bindingGraphFactory,
-      ComponentGenerator componentGenerator) {
-    this.componentAnnotation = componentAnnotation;
-    this.messager = messager;
-    this.componentHierarchyValidator = componentHierarchyValidator;
-    this.bindingGraphValidator = bindingGraphValidator;
-    this.componentDescriptorFactory = componentDescriptorFactory;
-    this.bindingGraphFactory = bindingGraphFactory;
-    this.componentGenerator = componentGenerator;
-  }
-
-  @Override
-  public final ImmutableSet<Element> process(
-      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
-    ImmutableSet.Builder<Element> rejectedElements = ImmutableSet.builder();
-    ComponentElementValidator componentElementValidator =
-        componentElementValidator(elementsByAnnotation);
-    for (Element element : elementsByAnnotation.get(componentAnnotation)) {
-      TypeElement componentTypeElement = MoreElements.asType(element);
-      try {
-        if (componentElementValidator.validateComponent(componentTypeElement, messager)) {
-          ComponentDescriptor componentDescriptor =
-              componentDescriptorFactory.forComponent(componentTypeElement);
-          ValidationReport<TypeElement> hierarchyReport =
-              componentHierarchyValidator.validate(componentDescriptor);
-          hierarchyReport.printMessagesTo(messager);
-          if (hierarchyReport.isClean()) {
-            BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor);
-            ValidationReport<TypeElement> graphReport =
-                bindingGraphValidator.validate(bindingGraph);
-            graphReport.printMessagesTo(messager);
-            if (graphReport.isClean()) {
-              generateComponent(bindingGraph);
-            }
-          }
-        }
-      } catch (TypeNotPresentException e) {
-        rejectedElements.add(componentTypeElement);
-      }
-    }
-    return rejectedElements.build();
-  }
-
-  private void generateComponent(BindingGraph bindingGraph) {
-    try {
-      componentGenerator.generate(bindingGraph);
-    } catch (SourceFileGenerationException e) {
-      e.printMessageTo(messager);
-    }
-  }
-
-  /**
-   * Returns an object that can validate a type element annotated with the component type.
-   */
-  protected abstract ComponentElementValidator componentElementValidator(
-      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation);
-
-  /**
-   * Validates a component type element.
-   */
-  protected static abstract class ComponentElementValidator {
-    /**
-     * Validates a component type element. Prints any messages about the element to
-     * {@code messager}.
-     *
-     * @throws TypeNotPresentException if any type required to validate the component cannot be
-     *     found
-     */
-    abstract boolean validateComponent(TypeElement componentTypeElement, Messager messager);
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index db890b246..581aab618 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -52,20 +52,18 @@
 import dagger.internal.codegen.writer.TypeName;
 import dagger.internal.codegen.writer.TypeNames;
 import dagger.internal.codegen.writer.VoidName;
+import dagger.producers.Produced;
 import dagger.producers.Producer;
 import dagger.producers.internal.Producers;
 import dagger.producers.internal.SetOfProducedProducer;
 import dagger.producers.internal.SetProducer;
 import java.util.Collection;
 import java.util.HashMap;
-import java.util.HashSet;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import javax.inject.Provider;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Name;
 import javax.lang.model.element.TypeElement;
@@ -79,19 +77,15 @@
 import javax.tools.Diagnostic;
 import javax.tools.Diagnostic.Kind;
 
-import static com.google.auto.common.MoreTypes.asDeclared;
 import static com.google.common.base.CaseFormat.LOWER_CAMEL;
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
 import static com.google.common.base.Preconditions.checkState;
-import static com.google.common.collect.Iterables.any;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.DELEGATED;
 import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.INITIALIZED;
 import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.UNINITIALIZED;
-import static dagger.internal.codegen.Binding.bindingPackageFor;
 import static dagger.internal.codegen.ComponentGenerator.MemberSelect.staticMethodInvocationWithCast;
 import static dagger.internal.codegen.ComponentGenerator.MemberSelect.staticSelect;
-import static dagger.internal.codegen.ContributionBinding.contributionTypeFor;
 import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.ENUM_INSTANCE;
 import static dagger.internal.codegen.ContributionBinding.Kind.PROVISION;
 import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD;
@@ -102,9 +96,6 @@
 import static dagger.internal.codegen.SourceFiles.indexDependenciesByUnresolvedKey;
 import static dagger.internal.codegen.SourceFiles.membersInjectorNameForType;
 import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
-import static dagger.internal.codegen.Util.getKeyTypeOfMap;
-import static dagger.internal.codegen.Util.getProvidedValueTypeOfMap;
-import static dagger.internal.codegen.Util.isMapWithNonProvidedValues;
 import static dagger.internal.codegen.writer.Snippet.makeParametersSnippet;
 import static dagger.internal.codegen.writer.Snippet.memberSelectSnippet;
 import static dagger.internal.codegen.writer.Snippet.nullCheck;
@@ -128,6 +119,7 @@
   protected final Set<JavaWriter> javaWriters = new LinkedHashSet<>();
   protected final ClassName name;
   protected final BindingGraph graph;
+  protected final ImmutableMap<ComponentDescriptor, String> subcomponentImplNames;
   private final Map<BindingKey, InitializationState> initializationStates = new HashMap<>();
   private final Map<Binding, InitializationState> contributionInitializationStates =
       new HashMap<>();
@@ -158,13 +150,15 @@
       Key.Factory keyFactory,
       Diagnostic.Kind nullableValidationType,
       ClassName name,
-      BindingGraph graph) {
+      BindingGraph graph,
+      ImmutableMap<ComponentDescriptor, String> subcomponentImplNames) {
     this.types = types;
     this.elements = elements;
     this.keyFactory = keyFactory;
     this.nullableValidationType = nullableValidationType;
     this.name = name;
     this.graph = graph;
+    this.subcomponentImplNames = subcomponentImplNames;
   }
 
   protected final TypeElement componentDefinitionType() {
@@ -460,48 +454,40 @@ private void addFields() {
 
   private void addField(ResolvedBindings resolvedBindings) {
     BindingKey bindingKey = resolvedBindings.bindingKey();
-
-    // No field needed if there are no owned bindings.
-    if (resolvedBindings.ownedBindings().isEmpty()) {
-      return;
-    }
     
-    // No field needed for bindings with no dependencies or state.
+    // If the binding can be satisfied with a static method call without dependencies or state,
+    // no field is necessary.
     Optional<MemberSelect> staticMemberSelect = staticMemberSelect(resolvedBindings);
     if (staticMemberSelect.isPresent()) {
       memberSelectSnippets.put(bindingKey, staticMemberSelect.get());
       return;
     }
+    
+    // No field needed if there are no owned bindings.
+    if (resolvedBindings.ownedBindings().isEmpty()) {
+      return;
+    }
 
-    Optional<String> bindingPackage = bindingPackageFor(resolvedBindings.bindings());
+    Optional<String> bindingPackage = resolvedBindings.bindingPackage();
     boolean useRawType = bindingPackage.isPresent()
         && !bindingPackage.get().equals(name.packageName());
-    if (bindingKey.kind().equals(BindingKey.Kind.CONTRIBUTION)) {
-      ImmutableSet<ContributionBinding> contributionBindings =
-          resolvedBindings.contributionBindings();
-      if (ContributionBinding.contributionTypeFor(contributionBindings).isMultibinding()) {
-        // note that here we rely on the order of the resolved bindings being from parent to child
-        // otherwise, the numbering wouldn't work
-        int contributionNumber = 0;
-        for (ContributionBinding contributionBinding : contributionBindings) {
-          if (!contributionBinding.isSyntheticBinding()) {
-            contributionNumber++;
-            if (resolvedBindings.ownedContributionBindings().contains(contributionBinding)) {
-              FrameworkField contributionBindingField =
-                  FrameworkField.createForSyntheticContributionBinding(
-                      contributionNumber, contributionBinding);
-              FieldWriter contributionField =
-                  addFrameworkField(useRawType, contributionBindingField);
-
-              ImmutableList<String> contributionSelectTokens =
-                  new ImmutableList.Builder<String>()
-                      .add(contributionField.name())
-                      .build();
-              multibindingContributionSnippets.put(
-                  contributionBinding,
-                  MemberSelect.instanceSelect(name, memberSelectSnippet(contributionSelectTokens)));
-            }
-          }
+    if (resolvedBindings.isMultibindings()) {
+      // note that here we rely on the order of the resolved bindings being from parent to child
+      // otherwise, the numbering wouldn't work
+      int contributionNumber = 0;
+      for (ContributionBinding contributionBinding : resolvedBindings.contributionBindings()) {
+        contributionNumber++;
+        if (resolvedBindings.ownedContributionBindings().contains(contributionBinding)) {
+          FrameworkField contributionBindingField =
+              FrameworkField.createForSyntheticContributionBinding(
+                  contributionNumber, contributionBinding);
+          FieldWriter contributionField = addFrameworkField(useRawType, contributionBindingField);
+
+          ImmutableList<String> contributionSelectTokens =
+              ImmutableList.of(contributionField.name());
+          multibindingContributionSnippets.put(
+              contributionBinding,
+              MemberSelect.instanceSelect(name, memberSelectSnippet(contributionSelectTokens)));
         }
       }
     }
@@ -542,13 +528,27 @@ private FieldWriter addFrameworkField(boolean useRawType,
   private Optional<MemberSelect> staticMemberSelect(ResolvedBindings resolvedBindings) {
     switch (resolvedBindings.bindingKey().kind()) {
       case CONTRIBUTION:
+        if (resolvedBindings.isMultibindings()
+            && resolvedBindings.contributionBindings().isEmpty()) {
+          switch (resolvedBindings.contributionType()) {
+            case MAP:
+              return Optional.of(emptyMapProviderFactoryStaticMemberSelect());
+
+            case SET:
+              return Optional.of(emptySetFactoryStaticMemberSelect(resolvedBindings));
+
+            case UNIQUE:
+            default:
+              throw new AssertionError("Multibindings must be map or set, not " + resolvedBindings);
+          }
+        }
         if (resolvedBindings.contributionBindings().size() != 1) {
           return Optional.absent();
         }
         ContributionBinding contributionBinding =
             getOnlyElement(resolvedBindings.contributionBindings());
         if (contributionBinding.contributionType().isMultibinding()
-            || !(contributionBinding.bindingType().equals(Binding.Type.PROVISION))) {
+            || !contributionBinding.bindingType().equals(BindingType.PROVISION)) {
           return Optional.absent();
         }
         if (contributionBinding.factoryCreationStrategy().equals(ENUM_INSTANCE)
@@ -578,6 +578,48 @@ private FieldWriter addFrameworkField(boolean useRawType,
     return Optional.absent();
   }
 
+  /**
+   * A static member select for a call to {@link MapProviderFactory#empty()}.
+   */
+  private MemberSelect emptyMapProviderFactoryStaticMemberSelect() {
+    return staticMethodInvocationWithCast(
+        ClassName.fromClass(MapProviderFactory.class),
+        Snippet.format("empty()"),
+        ClassName.fromClass(MapProviderFactory.class));
+  }
+
+  /**
+   * A static member select for a call to {@code F.create()} where {@code F} is either
+   * {@link SetFactory}, {@link SetProducer}, or {@link SetOfProducedProducer}, depending on the
+   * set bindings.
+   */
+  private MemberSelect emptySetFactoryStaticMemberSelect(ResolvedBindings setBindings) {
+    ClassName setFactoryClassName = setFactoryClassName(setBindings);
+    return staticMethodInvocationWithCast(
+        setFactoryClassName, Snippet.format("create()"), setFactoryClassName);
+  }
+
+  /**
+   * Returns a {@link Set} factory class name appropriate for the set bindings.
+   *
+   * <ul>
+   * <li>{@link SetFactory} for provision bindings.
+   * <li>{@link SetProducer} for production bindings for {@code Set<T>}.
+   * <li>{@link SetOfProducedProducer} for production bindings for {@code Set<Produced<T>>}.
+   * </ul>
+   */
+  private ClassName setFactoryClassName(ResolvedBindings setBindings) {
+    if (setBindings.bindingType().equals(BindingType.PROVISION)) {
+      return ClassName.fromClass(SetFactory.class);
+    } else {
+      SetType setType = SetType.from(setBindings.bindingKey().key().type());
+      return ClassName.fromClass(
+          setType.elementsAreTypeOf(Produced.class)
+              ? SetOfProducedProducer.class
+              : SetProducer.class);
+    }
+  }
+
   private void implementInterfaceMethods() {
     Set<MethodSignature> interfaceMethods = Sets.newHashSet();
     for (ComponentMethodDescriptor componentMethod :
@@ -721,7 +763,7 @@ private Snippet initializeFrameworkType(BindingKey bindingKey) {
     
     switch (bindingKey.kind()) {
       case CONTRIBUTION:
-        switch (contributionTypeFor(resolvedBindings.contributionBindings())) {
+        switch (resolvedBindings.contributionType()) {
           case SET:
             return initializeSetMultibindings(resolvedBindings);
           case MAP:
@@ -760,16 +802,10 @@ private Snippet initializeSetMultibindings(ResolvedBindings resolvedBindings) {
       }
       parameterSnippets.add(snippet);
     }
-    Class<?> factoryClass =
-        Iterables.all(resolvedBindings.contributionBindings(), Binding.Type.PROVISION)
-            ? SetFactory.class
-            : Util.isSetOfProduced(resolvedBindings.bindingKey().key().type())
-                ? SetOfProducedProducer.class
-                : SetProducer.class;
     Snippet initializeSetSnippet =
         Snippet.format(
             "%s.create(%s)",
-            ClassName.fromClass(factoryClass),
+            setFactoryClassName(resolvedBindings),
             makeParametersSnippet(parameterSnippets.build()));
     initializationSnippets.add(
         initializeMember(resolvedBindings.bindingKey(), initializeSetSnippet));
@@ -780,14 +816,15 @@ private Snippet initializeSetMultibindings(ResolvedBindings resolvedBindings) {
   private Snippet initializeMapMultibindings(ResolvedBindings resolvedBindings) {
     ImmutableList.Builder<Snippet> initializationSnippets = ImmutableList.builder();
 
-    if (any(resolvedBindings.contributionBindings(), Binding.Type.PRODUCTION)) {
+    if (Iterables.any(
+        resolvedBindings.contributionBindings(), BindingType.isOfType(BindingType.PRODUCTION))) {
       // TODO(beder): Implement producer map bindings.
       throw new IllegalStateException("producer map bindings not implemented yet");
     }
     for (ContributionBinding binding : resolvedBindings.contributionBindings()) {
       Optional<MemberSelect> multibindingContributionSnippet =
           getMultibindingContributionSnippet(binding);
-      if (!isMapWithNonProvidedValues(binding.key().type())
+      if (MapType.from(binding.key().type()).valuesAreTypeOf(Provider.class)
           && multibindingContributionSnippet.isPresent()
           && multibindingContributionSnippet.get().owningClass().equals(name)) {
         initializationSnippets.add(
@@ -798,9 +835,7 @@ private Snippet initializeMapMultibindings(ResolvedBindings resolvedBindings) {
       }
     }
     initializationSnippets.add(
-        initializeMember(
-            resolvedBindings.bindingKey(),
-            initializeMapBinding(resolvedBindings.contributionBindings())));
+        initializeMember(resolvedBindings.bindingKey(), initializeMapBinding(resolvedBindings)));
 
     return Snippet.concat(initializationSnippets.build());
   }
@@ -810,7 +845,7 @@ private Snippet initializeUniqueContributionBinding(ResolvedBindings resolvedBin
 
     ContributionBinding binding = getOnlyElement(resolvedBindings.ownedContributionBindings());
     if (!binding.factoryCreationStrategy().equals(ENUM_INSTANCE) || binding.scope().isPresent()) {
-      initializationSnippets.add(initializeDelegateFactories(binding));
+      initializationSnippets.add(initializeDelegateFactoriesForUninitializedDependencies(binding));
       initializationSnippets.add(
           initializeMember(
               resolvedBindings.bindingKey(), initializeFactoryForContributionBinding(binding)));
@@ -824,7 +859,7 @@ private Snippet initializeMembersInjectionBinding(ResolvedBindings resolvedBindi
 
     MembersInjectionBinding binding = resolvedBindings.membersInjectionBinding().get();
     if (!binding.injectionStrategy().equals(MembersInjectionBinding.Strategy.NO_OP)) {
-      initializationSnippets.add(initializeDelegateFactories(binding));
+      initializationSnippets.add(initializeDelegateFactoriesForUninitializedDependencies(binding));
       initializationSnippets.add(
           initializeMember(
               resolvedBindings.bindingKey(), initializeMembersInjectorForBinding(binding)));
@@ -833,16 +868,17 @@ private Snippet initializeMembersInjectionBinding(ResolvedBindings resolvedBindi
     return Snippet.concat(initializationSnippets.build());
   }
 
-  private Snippet initializeDelegateFactories(Binding binding) {
+  /**
+   * Initializes delegate factories for any dependencies of {@code binding} that are uninitialized
+   * because of a dependency cycle.
+   */
+  private Snippet initializeDelegateFactoriesForUninitializedDependencies(Binding binding) {
     ImmutableList.Builder<Snippet> initializationSnippets = ImmutableList.builder();
 
-    for (Collection<DependencyRequest> requestsForKey :
-        indexDependenciesByUnresolvedKey(types, binding.dependencies()).asMap().values()) {
-      BindingKey dependencyKey =
-          Iterables.getOnlyElement(
-              FluentIterable.from(requestsForKey)
-                  .transform(DependencyRequest.BINDING_KEY_FUNCTION)
-                  .toSet());
+    for (BindingKey dependencyKey :
+        FluentIterable.from(binding.implicitDependencies())
+            .transform(DependencyRequest.BINDING_KEY_FUNCTION)
+            .toSet()) {
       if (!getMemberSelect(dependencyKey).staticMember()
           && getInitializationState(dependencyKey).equals(UNINITIALIZED)) {
         initializationSnippets.add(
@@ -970,7 +1006,8 @@ private Snippet initializeFactoryForContributionBinding(ContributionBinding bind
               && !binding.bindingElement().getModifiers().contains(STATIC)) {
             parameters.add(getComponentContributionSnippet(binding.contributedBy().get()));
           }
-          parameters.addAll(getDependencyParameters(binding));
+          parameters.addAll(
+              getDependencyParameterSnippets(binding, DependencyRequestMapper.FOR_PROVIDER));
 
           Snippet factorySnippet =
               Snippet.format(
@@ -1016,13 +1053,25 @@ private Snippet initializeFactoryForContributionBinding(ContributionBinding bind
           parameters.add(
               getComponentContributionSnippet(
                   graph.componentDescriptor().executorDependency().get()));
-          parameters.addAll(getProducerDependencyParameters(binding));
+          parameters.addAll(
+              getDependencyParameterSnippets(binding, DependencyRequestMapper.FOR_PRODUCER));
 
           return Snippet.format(
               "new %s(%s)",
               generatedClassNameForBinding(binding),
               Snippet.makeParametersSnippet(parameters));
         }
+        
+      case SYNTHETIC_MAP:
+        checkState(
+            MapType.isMap(binding.key().type()),
+            "Expected synthetic binding to be for a map: %s",
+            binding);
+        return Snippet.format(
+            "%s.create(%s)",
+            ClassName.fromClass(MapFactory.class),
+            getMemberSelect(getOnlyElement(binding.dependencies()).bindingKey())
+                .getSnippetWithRawTypeCastFor(name));
 
       default:
         throw new AssertionError();
@@ -1040,7 +1089,8 @@ private Snippet initializeMembersInjectorForBinding(MembersInjectionBinding bind
       case NO_OP:
         return Snippet.format("%s.noOp()", ClassName.fromClass(MembersInjectors.class));
       case INJECT_MEMBERS:
-        List<Snippet> parameters = getDependencyParameters(binding);
+        List<Snippet> parameters =
+            getDependencyParameterSnippets(binding, DependencyRequestMapper.FOR_PROVIDER);
         return Snippet.format(
             "%s.create(%s)",
             membersInjectorNameForType(binding.bindingElement()),
@@ -1050,89 +1100,49 @@ private Snippet initializeMembersInjectorForBinding(MembersInjectionBinding bind
     }
   }
 
-  private List<Snippet> getDependencyParameters(Binding binding) {
-    ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
-    Set<Key> keysSeen = new HashSet<>();
-    for (Collection<DependencyRequest> requestsForKey :
-        indexDependenciesByUnresolvedKey(types, binding.implicitDependencies()).asMap().values()) {
-      Set<BindingKey> requestedBindingKeys = new HashSet<>();
-      for (DependencyRequest dependencyRequest : requestsForKey) {
-        Element requestElement = dependencyRequest.requestElement();
-        TypeMirror typeMirror = typeMirrorAsMemberOf(binding.bindingTypeElement(), requestElement);
-        Key key = keyFactory.forQualifiedType(dependencyRequest.key().qualifier(), typeMirror);
-        if (keysSeen.add(key)) {
-          requestedBindingKeys.add(dependencyRequest.bindingKey());
-        }
-      }
-      if (!requestedBindingKeys.isEmpty()) {
-        BindingKey key = Iterables.getOnlyElement(requestedBindingKeys);
-        parameters.add(getMemberSelect(key).getSnippetWithRawTypeCastFor(name));
-      }
-    }
-    return parameters.build();
-  }
-
-  // TODO(dpb): Investigate use of asMemberOf here. Why aren't the dependency requests already
-  // resolved?
-  private TypeMirror typeMirrorAsMemberOf(TypeElement bindingTypeElement, Element requestElement) {
-    TypeMirror requestType = requestElement.asType();
-    if (requestType.getKind() == TypeKind.TYPEVAR) {
-      return types.asMemberOf(
-          MoreTypes.asDeclared(bindingTypeElement.asType()),
-          (requestElement.getKind() == ElementKind.PARAMETER)
-              ? MoreTypes.asElement(requestType)
-              : requestElement);
-    } else {
-      return requestType;
-    }
-  }
-
-  private List<Snippet> getProducerDependencyParameters(Binding binding) {
+  /**
+   * The snippets that represent factory arguments for the dependencies of a binding.
+   */
+  private List<Snippet> getDependencyParameterSnippets(
+      Binding binding, DependencyRequestMapper dependencyRequestMapper) {
     ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
-    for (Collection<DependencyRequest> requestsForKey :
-        SourceFiles.indexDependenciesByUnresolvedKey(types, binding.implicitDependencies())
-            .asMap()
-            .values()) {
-      BindingKey key = Iterables.getOnlyElement(FluentIterable.from(requestsForKey)
-          .transform(DependencyRequest.BINDING_KEY_FUNCTION));
-      ResolvedBindings resolvedBindings = graph.resolvedBindings().get(key);
-      Class<?> frameworkClass =
-          DependencyRequestMapper.FOR_PRODUCER.getFrameworkClass(requestsForKey);
-      if (FrameworkField.frameworkClassForResolvedBindings(resolvedBindings).equals(Provider.class)
-          && frameworkClass.equals(Producer.class)) {
+    for (Collection<DependencyRequest> dependencyRequestsForUnresolvedKey :
+        indexDependenciesByUnresolvedKey(binding).asMap().values()) {
+      BindingKey requestedKey =
+          Iterables.getOnlyElement(
+              FluentIterable.from(dependencyRequestsForUnresolvedKey)
+                  .transform(DependencyRequest.BINDING_KEY_FUNCTION)
+                  .toSet());
+      ResolvedBindings resolvedBindings = graph.resolvedBindings().get(requestedKey);
+      Snippet frameworkSnippet = getMemberSelect(requestedKey).getSnippetWithRawTypeCastFor(name);
+      if (resolvedBindings.frameworkClass().equals(Provider.class)
+          && dependencyRequestMapper
+              .getFrameworkClass(dependencyRequestsForUnresolvedKey)
+              .equals(Producer.class)) {
         parameters.add(
             Snippet.format(
                 "%s.producerFromProvider(%s)",
                 ClassName.fromClass(Producers.class),
-                getMemberSelectSnippet(key)));
+                frameworkSnippet));
       } else {
-        parameters.add(getMemberSelectSnippet(key));
+        parameters.add(frameworkSnippet);
       }
     }
     return parameters.build();
   }
 
-  private Snippet initializeMapBinding(Set<ContributionBinding> bindings) {
-    // Get type information from the first binding.
-    ContributionBinding firstBinding = bindings.iterator().next();
-    DeclaredType mapType = asDeclared(firstBinding.key().type());
-
-    if (isMapWithNonProvidedValues(mapType)) {
-      return Snippet.format(
-          "%s.create(%s)",
-          ClassName.fromClass(MapFactory.class),
-          getMemberSelectSnippet(getOnlyElement(firstBinding.dependencies()).bindingKey()));
-    }
-
-    ImmutableList.Builder<dagger.internal.codegen.writer.Snippet> snippets =
-        ImmutableList.builder();
-    snippets.add(Snippet.format("%s.<%s, %s>builder(%d)",
-        ClassName.fromClass(MapProviderFactory.class),
-        TypeNames.forTypeMirror(getKeyTypeOfMap(mapType)),
-        TypeNames.forTypeMirror(getProvidedValueTypeOfMap(mapType)), // V of Map<K, Provider<V>>
-        bindings.size()));
+  private Snippet initializeMapBinding(ResolvedBindings resolvedBindings) {
+    MapType mapType = MapType.from(resolvedBindings.bindingKey().key().type());
+    ImmutableList.Builder<Snippet> snippets = ImmutableList.builder();
+    snippets.add(
+        Snippet.format(
+            "%s.<%s, %s>builder(%d)",
+            ClassName.fromClass(MapProviderFactory.class),
+            TypeNames.forTypeMirror(mapType.keyType()),
+            TypeNames.forTypeMirror(mapType.unwrappedValueType(Provider.class)),
+            resolvedBindings.contributionBindings().size()));
 
-    for (ContributionBinding binding : bindings) {
+    for (ContributionBinding binding : resolvedBindings.contributionBindings()) {
       snippets.add(
           Snippet.format(
               "    .put(%s, %s)",
diff --git a/compiler/src/main/java/dagger/internal/codegen/Binding.java b/compiler/src/main/java/dagger/internal/codegen/Binding.java
index 0a6b84052..26d3b61d4 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Binding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Binding.java
@@ -17,17 +17,15 @@
 
 import com.google.auto.common.MoreElements;
 import com.google.common.base.Optional;
-import com.google.common.base.Predicate;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Lists;
-import dagger.MembersInjector;
-import dagger.producers.Producer;
+import dagger.internal.codegen.BindingType.HasBindingType;
+import dagger.internal.codegen.Key.HasKey;
+import dagger.internal.codegen.SourceElement.HasSourceElement;
 import java.util.List;
 import java.util.Set;
-import javax.inject.Provider;
 import javax.lang.model.element.Element;
-import javax.lang.model.element.ElementVisitor;
 import javax.lang.model.element.Name;
 import javax.lang.model.element.PackageElement;
 import javax.lang.model.element.TypeElement;
@@ -36,7 +34,6 @@
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.type.WildcardType;
-import javax.lang.model.util.SimpleElementVisitor6;
 import javax.lang.model.util.SimpleTypeVisitor6;
 import javax.lang.model.util.Types;
 
@@ -51,52 +48,7 @@
  * @author Gregory Kick
  * @since 2.0
  */
-abstract class Binding {
-  
-  /**
-   * The subtype of this binding.
-   */
-  enum Type implements Predicate<Binding> {
-    /** A binding with this type is a {@link ProvisionBinding}. */
-    PROVISION(Provider.class),
-    /** A binding with this type is a {@link MembersInjectionBinding}. */
-    MEMBERS_INJECTION(MembersInjector.class),
-    /** A binding with this type is a {@link ProductionBinding}. */
-    PRODUCTION(Producer.class),
-    ;
-    
-    private final Class<?> frameworkClass;
-    
-    private Type(Class<?> frameworkClass) {
-      this.frameworkClass = frameworkClass;
-    }
-    
-    /**
-     * Returns the framework class associated with bindings of this type.
-     */
-    Class<?> frameworkClass() {
-      return frameworkClass;
-    }
-
-    BindingKey.Kind bindingKeyKind() {
-      switch (this) {
-        case MEMBERS_INJECTION:
-          return BindingKey.Kind.MEMBERS_INJECTION;
-        case PROVISION:
-        case PRODUCTION:
-          return BindingKey.Kind.CONTRIBUTION;
-        default:
-          throw new AssertionError();
-      }
-    }
-
-    @Override
-    public boolean apply(Binding binding) {
-      return this.equals(binding.bindingType());
-    }
-  }
-
-  abstract Binding.Type bindingType();
+abstract class Binding implements HasBindingType, HasKey, HasSourceElement {
 
   /**
    * Returns the framework class associated with this binding.
@@ -105,50 +57,20 @@ public boolean apply(Binding binding) {
     return bindingType().frameworkClass();
   }
 
-  static Optional<String> bindingPackageFor(Iterable<? extends Binding> bindings) {
-    ImmutableSet.Builder<String> bindingPackagesBuilder = ImmutableSet.builder();
-    for (Binding binding : bindings) {
-      bindingPackagesBuilder.addAll(binding.bindingPackage().asSet());
-    }
-    ImmutableSet<String> bindingPackages = bindingPackagesBuilder.build();
-    switch (bindingPackages.size()) {
-      case 0:
-        return Optional.absent();
-      case 1:
-        return Optional.of(bindingPackages.iterator().next());
-      default:
-        throw new IllegalArgumentException();
-    }
-  }
-
   /** The {@link Key} that is provided by this binding. */
-  protected abstract Key key();
-
-  BindingKey bindingKey() {
-    return BindingKey.create(bindingType().bindingKeyKind(), key());
-  }
+  @Override
+  public abstract Key key();
 
   /** Returns the {@link Element} instance that is responsible for declaring the binding. */
-  abstract Element bindingElement();
+  Element bindingElement() {
+    return sourceElement().element();
+  }
 
   /** The type enclosing the binding {@link #bindingElement()}. */
   TypeElement bindingTypeElement() {
-    return BINDING_TYPE_ELEMENT.visit(bindingElement());
+    return sourceElement().enclosingTypeElement();
   }
 
-  private static final ElementVisitor<TypeElement, Void> BINDING_TYPE_ELEMENT =
-      new SimpleElementVisitor6<TypeElement, Void>() {
-        @Override
-        protected TypeElement defaultAction(Element e, Void p) {
-          return visit(e.getEnclosingElement());
-        }
-
-        @Override
-        public TypeElement visitType(TypeElement e, Void p) {
-          return e;
-        }
-      };
-
   /**
    * The explicit set of {@link DependencyRequest dependencies} required to satisfy this binding.
    */
@@ -220,10 +142,11 @@ public Void visitWildcard(WildcardType t, ImmutableSet.Builder<String> p) {
   }
 
   /**
-   * Returns true if this is a binding for a key that has a different type parameter list than the
-   * element it's providing.
+   * if this binding's key's type parameters are different from those of the
+   * {@link #bindingTypeElement()}, this is the binding for the {@link #bindingTypeElement()}'s
+   * unresolved type.
    */
-  abstract boolean hasNonDefaultTypeParameters();
+  abstract Optional<? extends Binding> unresolved();
 
   /**
    * The scope of this binding.
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index b95143803..fffec346c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -33,14 +33,13 @@
 import com.google.common.collect.TreeTraverser;
 import dagger.Component;
 import dagger.Subcomponent;
-import dagger.internal.codegen.Binding.Type;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
-import dagger.producers.Producer;
 import dagger.producers.ProductionComponent;
 import java.util.ArrayDeque;
 import java.util.Collection;
 import java.util.Deque;
 import java.util.HashSet;
+import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
@@ -56,19 +55,16 @@
 import javax.lang.model.util.Elements;
 
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
+import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Predicates.in;
 import static com.google.common.base.Verify.verify;
-import static com.google.common.collect.Iterables.any;
-import static com.google.common.collect.Sets.union;
-import static dagger.internal.codegen.BindingKey.Kind.CONTRIBUTION;
 import static dagger.internal.codegen.ComponentDescriptor.isComponentContributionMethod;
 import static dagger.internal.codegen.ComponentDescriptor.isComponentProductionMethod;
 import static dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor.isOfKind;
 import static dagger.internal.codegen.ComponentDescriptor.ComponentMethodKind.SUBCOMPONENT_BUILDER;
 import static dagger.internal.codegen.ComponentDescriptor.Kind.PRODUCTION_COMPONENT;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
-import static dagger.internal.codegen.MembersInjectionBinding.Strategy.INJECT_MEMBERS;
-import static dagger.internal.codegen.MembersInjectionBinding.Strategy.NO_OP;
+import static dagger.internal.codegen.Key.indexByKey;
 import static javax.lang.model.element.Modifier.STATIC;
 
 /**
@@ -125,9 +121,7 @@
             new Function<ResolvedBindings, Set<ContributionBinding>>() {
               @Override
               public Set<ContributionBinding> apply(ResolvedBindings input) {
-                return (input.bindingKey().kind().equals(CONTRIBUTION))
-                    ? input.contributionBindings()
-                    : ImmutableSet.<ContributionBinding>of();
+                return input.contributionBindings();
               }
             })
         .transformAndConcat(
@@ -145,6 +139,22 @@
         .toSet();
   }
 
+  /**
+   * Returns the {@link ComponentDescriptor}s for this component and its subcomponents.
+   */
+  ImmutableSet<ComponentDescriptor> componentDescriptors() {
+    return SUBGRAPH_TRAVERSER
+        .preOrderTraversal(this)
+        .transform(
+            new Function<BindingGraph, ComponentDescriptor>() {
+              @Override
+              public ComponentDescriptor apply(BindingGraph graph) {
+                return graph.componentDescriptor();
+              }
+            })
+        .toSet();
+  }
+
   ImmutableSet<TypeElement> availableDependencies() {
     return new ImmutableSet.Builder<TypeElement>()
         .addAll(componentDescriptor().transitiveModuleTypes())
@@ -217,18 +227,21 @@ private BindingGraph create(
                 componentDescriptor.componentDefinitionType()));
       }
 
-      // Collect transitive module bindings.
+      ImmutableSet.Builder<MultibindingDeclaration> multibindingDeclarations =
+          ImmutableSet.builder();
+
+      // Collect transitive module bindings and multibinding declarations.
       for (ModuleDescriptor moduleDescriptor : componentDescriptor.transitiveModules()) {
-        for (ContributionBinding binding : moduleDescriptor.bindings()) {
-          explicitBindingsBuilder.add(binding);
-        }
+        explicitBindingsBuilder.addAll(moduleDescriptor.bindings());
+        multibindingDeclarations.addAll(moduleDescriptor.multibindingDeclarations());
       }
 
       Resolver requestResolver =
           new Resolver(
               parentResolver,
               componentDescriptor,
-              explicitBindingsByKey(explicitBindingsBuilder.build()));
+              indexByKey(explicitBindingsBuilder.build()),
+              indexByKey(multibindingDeclarations.build()));
       for (ComponentMethodDescriptor componentMethod : componentDescriptor.componentMethods()) {
         Optional<DependencyRequest> componentMethodRequest = componentMethod.dependencyRequest();
         if (componentMethodRequest.isPresent()) {
@@ -260,30 +273,24 @@ private BindingGraph create(
           requestResolver.getOwnedModules());
     }
 
-    private <B extends ContributionBinding> ImmutableSetMultimap<Key, B> explicitBindingsByKey(
-        Iterable<? extends B> bindings) {
-      // Multimaps.index() doesn't do ImmutableSetMultimaps.
-      ImmutableSetMultimap.Builder<Key, B> builder = ImmutableSetMultimap.builder();
-      for (B binding : bindings) {
-        builder.put(binding.key(), binding);
-      }
-      return builder.build();
-    }
-
     private final class Resolver {
       final Optional<Resolver> parentResolver;
       final ComponentDescriptor componentDescriptor;
       final ImmutableSetMultimap<Key, ContributionBinding> explicitBindings;
       final ImmutableSet<ContributionBinding> explicitBindingsSet;
+      final ImmutableSetMultimap<Key, MultibindingDeclaration> multibindingDeclarations;
       final Map<BindingKey, ResolvedBindings> resolvedBindings;
       final Deque<BindingKey> cycleStack = new ArrayDeque<>();
       final Cache<BindingKey, Boolean> dependsOnLocalMultibindingsCache =
           CacheBuilder.newBuilder().<BindingKey, Boolean>build();
+      final Cache<Binding, Boolean> bindingDependsOnLocalMultibindingsCache =
+          CacheBuilder.newBuilder().<Binding, Boolean>build();
 
       Resolver(
           Optional<Resolver> parentResolver,
           ComponentDescriptor componentDescriptor,
-          ImmutableSetMultimap<Key, ContributionBinding> explicitBindings) {
+          ImmutableSetMultimap<Key, ContributionBinding> explicitBindings,
+          ImmutableSetMultimap<Key, MultibindingDeclaration> multibindingDeclarations) {
         assert parentResolver != null;
         this.parentResolver = parentResolver;
         assert componentDescriptor != null;
@@ -291,172 +298,165 @@ private BindingGraph create(
         assert explicitBindings != null;
         this.explicitBindings = explicitBindings;
         this.explicitBindingsSet = ImmutableSet.copyOf(explicitBindings.values());
+        assert multibindingDeclarations != null;
+        this.multibindingDeclarations = multibindingDeclarations;
         this.resolvedBindings = Maps.newLinkedHashMap();
       }
 
       /**
-       * Looks up the bindings associated with a given dependency request and returns them.
+       * Returns the bindings that satisfy a given dependency request.
        *
-       * <p>Requests for {@code Map<K, V>} for which there are only bindings for
-       * {@code Map<K, Provider<V>>} will resolve to a single implicit binding for the latter map
-       * (and similarly for {@link Producer}s).
+       * <p>For {@link BindingKey.Kind#CONTRIBUTION} requests, returns all of:
+       * <ul>
+       * <li>All explicit bindings for the requested key.
+       * <li>All explicit bindings for {@code Set<T>} if the requested key's type is
+       *     {@code Set<Produced<T>>}.
+       * <li>A synthetic binding that depends on {@code Map<K, Producer<V>>} if the requested key's
+       *     type is {@code Map<K, V>} and there are some explicit bindings for
+       *     {@code Map<K, Producer<V>>}.
+       * <li>A synthetic binding that depends on {@code Map<K, Provider<V>>} if the requested key's
+       *     type is {@code Map<K, V>} and there are some explicit bindings for
+       *     {@code Map<K, Provider<V>>} but no explicit bindings for {@code Map<K, Producer<V>>}.
+       * <li>An implicit {@link Inject @Inject}-annotated constructor binding if there is one and
+       *     there are no explicit bindings or synthetic bindings.
+       * </ul>
        *
-       * <p>If there are no explicit bindings for a contribution, looks for implicit
-       * {@link Inject @Inject}-annotated constructor types.
+       * <p>For {@link BindingKey.Kind#MEMBERS_INJECTION} requests, returns the
+       * {@link MembersInjectionBinding} for the type.
        */
       ResolvedBindings lookUpBindings(DependencyRequest request) {
         BindingKey bindingKey = request.bindingKey();
         switch (bindingKey.kind()) {
           case CONTRIBUTION:
-            // First, check for explicit keys (those from modules and components)
-            ImmutableSet<ContributionBinding> explicitBindingsForKey =
-                getExplicitBindings(bindingKey.key());
-
-            // If the key is Map<K, V>, get its implicit binding keys, which are either
-            // Map<K, Provider<V>> or Map<K, Producer<V>>, and grab their explicit bindings.
-            Optional<Key> mapProviderKey = keyFactory.implicitMapProviderKeyFrom(bindingKey.key());
-            ImmutableSet.Builder<ContributionBinding> explicitMapBindingsBuilder =
+            Set<ContributionBinding> contributionBindings = new LinkedHashSet<>();
+            ImmutableSet.Builder<MultibindingDeclaration> multibindingDeclarationsBuilder =
                 ImmutableSet.builder();
-            if (mapProviderKey.isPresent()) {
-              explicitMapBindingsBuilder.addAll(getExplicitBindings(mapProviderKey.get()));
-            }
 
-            Optional<Key> mapProducerKey = keyFactory.implicitMapProducerKeyFrom(bindingKey.key());
-            if (mapProducerKey.isPresent()) {
-              explicitMapBindingsBuilder.addAll(getExplicitBindings(mapProducerKey.get()));
-            }
-            ImmutableSet<ContributionBinding> explicitMapBindings =
-                explicitMapBindingsBuilder.build();
-
-            // If the key is Set<Produced<T>>, then we look up bindings by the alternate key Set<T>.
-            Optional<Key> setKeyFromProduced =
-                keyFactory.implicitSetKeyFromProduced(bindingKey.key());
-            ImmutableSet<ContributionBinding> explicitSetBindings =
-                setKeyFromProduced.isPresent()
-                    ? getExplicitBindings(setKeyFromProduced.get())
-                    : ImmutableSet.<ContributionBinding>of();
-
-            if (!explicitBindingsForKey.isEmpty() || !explicitSetBindings.isEmpty()) {
-              /* If there are any explicit bindings for this key, then combine those with any
-               * conflicting Map<K, Provider<V>> bindings and let the validator fail. */
-              ImmutableSetMultimap.Builder<ComponentDescriptor, ContributionBinding> bindings =
-                  ImmutableSetMultimap.builder();
-              for (ContributionBinding binding :
-                  union(explicitBindingsForKey, union(explicitSetBindings, explicitMapBindings))) {
-                bindings.put(getOwningComponent(request, binding), binding);
-              }
-              return ResolvedBindings.forContributionBindings(
-                  bindingKey, componentDescriptor, bindings.build());
-            } else if (any(explicitMapBindings, Binding.Type.PRODUCTION)) {
-              /* If this binding is for Map<K, V> and there are no explicit Map<K, V> bindings but
-               * some explicit Map<K, Producer<V>> bindings, then this binding must have only the
-               * implicit dependency on Map<K, Producer<V>>. */
-              return ResolvedBindings.forContributionBindings(
-                  bindingKey,
-                  componentDescriptor,
+            // Add explicit bindings and declarations (those from modules and components).
+            contributionBindings.addAll(getExplicitBindings(bindingKey.key()));
+            multibindingDeclarationsBuilder.addAll(getMultibindingDeclarations(bindingKey.key()));
+
+            // If the key is Set<Produced<T>>, then add explicit bindings and declarations for
+            // Set<T>.
+            Optional<Key> implicitSetKey = keyFactory.implicitSetKeyFromProduced(bindingKey.key());
+            contributionBindings.addAll(getExplicitBindings(implicitSetKey));
+            multibindingDeclarationsBuilder.addAll(getMultibindingDeclarations(implicitSetKey));
+
+            ImmutableSet<MultibindingDeclaration> multibindingDeclarations =
+                multibindingDeclarationsBuilder.build();
+
+            // If the key is Map<K, V>, get its map-of-framework-type binding keys, which are either
+            // Map<K, Provider<V>> or Map<K, Producer<V>>, and grab their explicit bindings and
+            // declarations.
+            Optional<Key> implicitMapProviderKey =
+                keyFactory.implicitMapProviderKeyFrom(bindingKey.key());
+            ImmutableSet<ContributionBinding> explicitProviderMapBindings =
+                getExplicitBindings(implicitMapProviderKey);
+            ImmutableSet<MultibindingDeclaration> explicitProviderMultibindingDeclarations =
+                getMultibindingDeclarations(implicitMapProviderKey);
+
+            Optional<Key> implicitMapProducerKey =
+                keyFactory.implicitMapProducerKeyFrom(bindingKey.key());
+            ImmutableSet<ContributionBinding> explicitProducerMapBindings =
+                getExplicitBindings(implicitMapProducerKey);
+            ImmutableSet<MultibindingDeclaration> explicitProducerMultibindingDeclarations =
+                getMultibindingDeclarations(implicitMapProducerKey);
+
+            if (!explicitProducerMapBindings.isEmpty()
+                || !explicitProducerMultibindingDeclarations.isEmpty()) {
+              /* If the binding key is Map<K, V>, and there are some explicit Map<K, Producer<V>>
+               * bindings or multibinding declarations, then add the synthetic binding that depends
+               * on Map<K, Producer<V>>. */
+              contributionBindings.add(
                   productionBindingFactory.implicitMapOfProducerBinding(request));
-            } else if (any(explicitMapBindings, Binding.Type.PROVISION)) {
-              /* If this binding is for Map<K, V> and there are no explicit Map<K, V> bindings but
-               * some explicit Map<K, Provider<V>> bindings, then this binding must have only the
-               * implicit dependency on Map<K, Provider<V>>. */
-              return ResolvedBindings.forContributionBindings(
-                  bindingKey,
-                  componentDescriptor,
+            } else if (!explicitProviderMapBindings.isEmpty()
+                || !explicitProviderMultibindingDeclarations.isEmpty()) {
+              /* If the binding key is Map<K, V>, and there are some explicit Map<K, Provider<V>>
+               * bindings or multibinding declarations but no explicit Map<K, Producer<V>> bindings
+               * or multibinding declarations, then add the synthetic binding that depends on
+               * Map<K, Provider<V>>. */
+              contributionBindings.add(
                   provisionBindingFactory.implicitMapOfProviderBinding(request));
-            } else {
-              /* If there are no explicit bindings at all, look for an implicit @Inject-constructed
-               * binding. */
-              Optional<ProvisionBinding> provisionBinding =
-                  injectBindingRegistry.getOrFindProvisionBinding(bindingKey.key());
-              ComponentDescriptor owningComponent =
-                  provisionBinding.isPresent()
-                          && isResolvedInParent(request, provisionBinding.get())
-                          && !shouldOwnParentBinding(request, provisionBinding.get())
-                      ? getOwningResolver(provisionBinding.get()).get().componentDescriptor
-                      : componentDescriptor;
-              return ResolvedBindings.forContributionBindings(
-                  bindingKey,
-                  componentDescriptor,
-                  ImmutableSetMultimap.<ComponentDescriptor, ContributionBinding>builder()
-                      .putAll(owningComponent, provisionBinding.asSet())
-                      .build());
             }
 
+            /* If there are no explicit or synthetic bindings or multibinding declarations, use an
+             * implicit @Inject- constructed binding if there is one. */
+            if (contributionBindings.isEmpty() && multibindingDeclarations.isEmpty()) {
+              contributionBindings.addAll(
+                  injectBindingRegistry.getOrFindProvisionBinding(bindingKey.key()).asSet());
+            }
+
+            return ResolvedBindings.forContributionBindings(
+                bindingKey,
+                componentDescriptor,
+                indexBindingsByOwningComponent(request, ImmutableSet.copyOf(contributionBindings)),
+                multibindingDeclarations);
+
           case MEMBERS_INJECTION:
             // no explicit deps for members injection, so just look it up
             return ResolvedBindings.forMembersInjectionBinding(
-                bindingKey, componentDescriptor, rollUpMembersInjectionBindings(bindingKey.key()));
+                bindingKey,
+                componentDescriptor,
+                injectBindingRegistry.getOrFindMembersInjectionBinding(bindingKey.key()));
           default:
             throw new AssertionError();
         }
       }
 
+      private ImmutableSetMultimap<ComponentDescriptor, ContributionBinding>
+          indexBindingsByOwningComponent(
+              DependencyRequest request, Iterable<? extends ContributionBinding> bindings) {
+        ImmutableSetMultimap.Builder<ComponentDescriptor, ContributionBinding> index =
+            ImmutableSetMultimap.builder();
+        for (ContributionBinding binding : bindings) {
+          index.put(getOwningComponent(request, binding), binding);
+        }
+        return index.build();
+      }
+
       /**
-       * If {@code binding} should be owned by a parent component, resolves the binding in that
-       * component's resolver and returns that component. Otherwise returns the component for this
-       * resolver.
+       * Returns the component that "owns" {@code binding}.
+       *
+       * <p>If {@code binding} is bound in an ancestor component, resolves {@code request} in this
+       * component's parent. Returns the ancestor component in which it is bound, unless
+       * {@code binding} depends on local multibindings, in which case returns this component.
+       *
+       * <p>If {@code binding} is not bound in an ancestor component, simply returns this component.
        */
       private ComponentDescriptor getOwningComponent(
           DependencyRequest request, ContributionBinding binding) {
-        return isResolvedInParent(request, binding) && !shouldOwnParentBinding(request, binding)
+        return isResolvedInParent(request, binding)
+                && !new MultibindingDependencies().dependsOnLocalMultibindings(binding)
             ? getOwningResolver(binding).get().componentDescriptor
             : componentDescriptor;
       }
 
       /**
-       * Returns {@code true} if {@code binding} is owned by a parent resolver. If so, calls
-       * {@link #resolve(DependencyRequest) resolve(request)} on that resolver.
+       * Returns {@code true} if {@code binding} is owned by an ancestor. If so,
+       * {@linkplain #resolve(DependencyRequest) resolves} the request in this component's parent.
+       * Don't resolve directly in the owning component in case it depends on multibindings in any
+       * of its descendants.
        */
       private boolean isResolvedInParent(DependencyRequest request, ContributionBinding binding) {
         Optional<Resolver> owningResolver = getOwningResolver(binding);
         if (owningResolver.isPresent() && !owningResolver.get().equals(this)) {
-          owningResolver.get().resolve(request);
+          parentResolver.get().resolve(request);
           return true;
         } else {
           return false;
         }
       }
 
-      /**
-       * Returns {@code true} if {@code binding}, which was previously resolved by a parent
-       * resolver, should be moved into this resolver's bindings for {@code request} because it is
-       * unscoped and {@linkplain #dependsOnLocalMultibindings(ResolvedBindings) depends on local
-       * multibindings}, or {@code false} if it can satisfy {@code request} as an inherited binding.
-       */
-      private boolean shouldOwnParentBinding(
-          DependencyRequest request, ContributionBinding binding) {
-        return !binding.scope().isPresent()
-            && dependsOnLocalMultibindings(
-                getPreviouslyResolvedBindings(request.bindingKey()).get());
-      }
-
-      private MembersInjectionBinding rollUpMembersInjectionBindings(Key key) {
-        MembersInjectionBinding membersInjectionBinding =
-            injectBindingRegistry.getOrFindMembersInjectionBinding(key);
-
-        if (membersInjectionBinding.parentInjectorRequest().isPresent()
-            && membersInjectionBinding.injectionStrategy().equals(INJECT_MEMBERS)) {
-          MembersInjectionBinding parentBinding =
-              rollUpMembersInjectionBindings(
-                  membersInjectionBinding.parentInjectorRequest().get().key());
-          if (parentBinding.injectionStrategy().equals(NO_OP)) {
-            return membersInjectionBinding.withoutParentInjectorRequest();
-          }
-        }
-
-        return membersInjectionBinding;
-      }
-
-      private Optional<Resolver> getOwningResolver(ContributionBinding provisionBinding) {
+      private Optional<Resolver> getOwningResolver(ContributionBinding binding) {
         for (Resolver requestResolver : getResolverLineage().reverse()) {
-          if (requestResolver.explicitBindingsSet.contains(provisionBinding)) {
+          if (requestResolver.explicitBindingsSet.contains(binding)) {
             return Optional.of(requestResolver);
           }
         }
 
         // look for scope separately.  we do this for the case where @Singleton can appear twice
         // in the † compatibility mode
-        Scope bindingScope = provisionBinding.scope();
+        Scope bindingScope = binding.scope();
         if (bindingScope.isPresent()) {
           for (Resolver requestResolver : getResolverLineage().reverse()) {
             if (bindingScope.equals(requestResolver.componentDescriptor.scope())) {
@@ -478,6 +478,10 @@ private MembersInjectionBinding rollUpMembersInjectionBindings(Key key) {
         return ImmutableList.copyOf(Lists.reverse(resolverList));
       }
 
+      /**
+       * Returns the explicit {@link ContributionBinding}s that match the {@code requestKey} from
+       * this and all ancestor resolvers.
+       */
       private ImmutableSet<ContributionBinding> getExplicitBindings(Key requestKey) {
         ImmutableSet.Builder<ContributionBinding> explicitBindingsForKey = ImmutableSet.builder();
         for (Resolver resolver : getResolverLineage()) {
@@ -486,6 +490,32 @@ private MembersInjectionBinding rollUpMembersInjectionBindings(Key key) {
         return explicitBindingsForKey.build();
       }
 
+      private ImmutableSet<ContributionBinding> getExplicitBindings(Optional<Key> optionalKey) {
+        return optionalKey.isPresent()
+            ? getExplicitBindings(optionalKey.get())
+            : ImmutableSet.<ContributionBinding>of();
+      }
+
+      /**
+       * Returns the {@link MultibindingDeclaration}s that match the {@code key} from this and all
+       * ancestor resolvers.
+       */
+      private ImmutableSet<MultibindingDeclaration> getMultibindingDeclarations(Key key) {
+        ImmutableSet.Builder<MultibindingDeclaration> multibindingDeclarations =
+            ImmutableSet.builder();
+        for (Resolver resolver : getResolverLineage()) {
+          multibindingDeclarations.addAll(resolver.multibindingDeclarations.get(key));
+        }
+        return multibindingDeclarations.build();
+      }
+
+      private ImmutableSet<MultibindingDeclaration> getMultibindingDeclarations(
+          Optional<Key> optionalKey) {
+        return optionalKey.isPresent()
+            ? getMultibindingDeclarations(optionalKey.get())
+            : ImmutableSet.<MultibindingDeclaration>of();
+      }
+
       private Optional<ResolvedBindings> getPreviouslyResolvedBindings(
           final BindingKey bindingKey) {
         Optional<ResolvedBindings> result = Optional.fromNullable(resolvedBindings.get(bindingKey));
@@ -517,10 +547,8 @@ void resolve(DependencyRequest request) {
         // have to resolve it in this subcomponent so that it sees the local contributions. If it
         // does not, then we can stop resolving it in this subcomponent and rely on the
         // supercomponent resolution.
-        Optional<ResolvedBindings> bindingsPreviouslyResolvedInParent =
-            getPreviouslyResolvedBindings(bindingKey);
-        if (bindingsPreviouslyResolvedInParent.isPresent()
-            && !dependsOnLocalMultibindings(bindingsPreviouslyResolvedInParent.get())) {
+        if (getPreviouslyResolvedBindings(bindingKey).isPresent()
+            && !new MultibindingDependencies().dependsOnLocalMultibindings(bindingKey)) {
           return;
         }
 
@@ -538,59 +566,6 @@ void resolve(DependencyRequest request) {
         }
       }
 
-      /**
-       * Returns {@code true} if {@code previouslyResolvedBindings} is multibindings with
-       * contributions declared within this (sub)component's modules, or if any of its unscoped
-       * provision-dependencies depend on such local multibindings.
-       *
-       * <p>We don't care about scoped dependencies or production bindings because they will never
-       * depend on multibindings with contributions from subcomponents.
-       */
-      private boolean dependsOnLocalMultibindings(ResolvedBindings previouslyResolvedBindings) {
-        return dependsOnLocalMultibindings(previouslyResolvedBindings, new HashSet<BindingKey>());
-      }
-
-      private boolean dependsOnLocalMultibindings(
-          final ResolvedBindings previouslyResolvedBindings, final Set<BindingKey> cycleChecker) {
-        // Don't recur infinitely if there are valid cycles in the dependency graph.
-        if (!cycleChecker.add(previouslyResolvedBindings.bindingKey())) {
-          return false;
-        }
-        try {
-          return dependsOnLocalMultibindingsCache.get(
-              previouslyResolvedBindings.bindingKey(),
-              new Callable<Boolean>() {
-                @Override
-                public Boolean call() {
-                  if (previouslyResolvedBindings.isMultibindings()
-                      && hasLocalContributions(previouslyResolvedBindings)) {
-                    return true;
-                  }
-
-                  for (Binding binding : previouslyResolvedBindings.bindings()) {
-                    if (!binding.scope().isPresent()
-                        && !binding.bindingType().equals(Type.PRODUCTION)) {
-                      for (DependencyRequest dependency : binding.implicitDependencies()) {
-                        if (dependsOnLocalMultibindings(
-                            getPreviouslyResolvedBindings(dependency.bindingKey()).get(),
-                            cycleChecker)) {
-                          return true;
-                        }
-                      }
-                    }
-                  }
-                  return false;
-                }
-              });
-        } catch (ExecutionException e) {
-          throw new AssertionError(e);
-        }
-      }
-
-      private boolean hasLocalContributions(ResolvedBindings resolvedBindings) {
-        return !explicitBindings.get(resolvedBindings.bindingKey().key()).isEmpty();
-      }
-
       ImmutableMap<BindingKey, ResolvedBindings> getResolvedBindings() {
         ImmutableMap.Builder<BindingKey, ResolvedBindings> resolvedBindingsBuilder =
             ImmutableMap.builder();
@@ -622,6 +597,93 @@ private boolean hasLocalContributions(ResolvedBindings resolvedBindings) {
         return Sets.difference(componentDescriptor.transitiveModules(), getInheritedModules())
             .immutableCopy();
       }
+
+      private final class MultibindingDependencies {
+        private final Set<BindingKey> cycleChecker = new HashSet<>();
+
+        /**
+         * Returns {@code true} if {@code bindingKey} previously resolved to multibindings with
+         * contributions declared within this component's modules, or if any of its unscoped
+         * dependencies depend on such local multibindings.
+         *
+         * <p>We don't care about scoped dependencies because they will never depend on
+         * multibindings with contributions from subcomponents.
+         *
+         * @throws IllegalArgumentException if {@link #getPreviouslyResolvedBindings(BindingKey)} is
+         *     absent
+         */
+        boolean dependsOnLocalMultibindings(final BindingKey bindingKey) {
+          checkArgument(
+              getPreviouslyResolvedBindings(bindingKey).isPresent(),
+              "no previously resolved bindings in %s for %s",
+              Resolver.this,
+              bindingKey);
+          // Don't recur infinitely if there are valid cycles in the dependency graph.
+          if (!cycleChecker.add(bindingKey)) {
+            return false;
+          }
+          try {
+            return dependsOnLocalMultibindingsCache.get(
+                bindingKey,
+                new Callable<Boolean>() {
+                  @Override
+                  public Boolean call() {
+                    ResolvedBindings previouslyResolvedBindings =
+                        getPreviouslyResolvedBindings(bindingKey).get();
+                    if (isMultibindingsWithLocalContributions(previouslyResolvedBindings)) {
+                      return true;
+                    }
+
+                    for (Binding binding : previouslyResolvedBindings.bindings()) {
+                      if (dependsOnLocalMultibindings(binding)) {
+                        return true;
+                      }
+                    }
+                    return false;
+                  }
+                });
+          } catch (ExecutionException e) {
+            throw new AssertionError(e);
+          }
+        }
+
+        /**
+         * Returns {@code true} if {@code binding} is unscoped and depends on multibindings with
+         * contributions declared within this component's modules, or if any of its unscoped
+         * dependencies depend on such local multibindings.
+         *
+         * <p>We don't care about scoped dependencies because they will never depend on
+         * multibindings with contributions from subcomponents.
+         */
+        boolean dependsOnLocalMultibindings(final Binding binding) {
+          try {
+            return bindingDependsOnLocalMultibindingsCache.get(
+                binding,
+                new Callable<Boolean>() {
+                  @Override
+                  public Boolean call() {
+                    if (!binding.scope().isPresent()
+                        // TODO(beder): Figure out what happens with production subcomponents.
+                        && !binding.bindingType().equals(BindingType.PRODUCTION)) {
+                      for (DependencyRequest dependency : binding.implicitDependencies()) {
+                        if (dependsOnLocalMultibindings(dependency.bindingKey())) {
+                          return true;
+                        }
+                      }
+                    }
+                    return false;
+                  }
+                });
+          } catch (ExecutionException e) {
+            throw new AssertionError(e);
+          }
+        }
+
+        private boolean isMultibindingsWithLocalContributions(ResolvedBindings resolvedBindings) {
+          return resolvedBindings.isMultibindings()
+              && explicitBindings.containsKey(resolvedBindings.key());
+        }
+      }
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index f8010c301..d4c3b391b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -40,7 +40,7 @@
 import dagger.MapKey;
 import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
-import dagger.internal.codegen.ContributionBinding.ContributionType;
+import dagger.internal.codegen.SourceElement.HasSourceElement;
 import dagger.internal.codegen.writer.TypeNames;
 import java.util.ArrayDeque;
 import java.util.Arrays;
@@ -51,6 +51,7 @@
 import java.util.Iterator;
 import java.util.LinkedHashSet;
 import java.util.Map;
+import java.util.Queue;
 import java.util.Set;
 import javax.inject.Provider;
 import javax.lang.model.element.AnnotationMirror;
@@ -74,8 +75,6 @@
 import static com.google.common.base.Predicates.in;
 import static com.google.common.base.Predicates.not;
 import static com.google.common.base.Verify.verify;
-import static com.google.common.collect.Iterables.all;
-import static com.google.common.collect.Iterables.any;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static com.google.common.collect.Iterables.indexOf;
 import static com.google.common.collect.Iterables.skip;
@@ -85,6 +84,8 @@
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
 import static dagger.internal.codegen.ContributionBinding.indexMapBindingsByAnnotationType;
 import static dagger.internal.codegen.ContributionBinding.indexMapBindingsByMapKey;
+import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MAP;
+import static dagger.internal.codegen.ContributionType.indexByContributionType;
 import static dagger.internal.codegen.ErrorMessages.DUPLICATE_SIZE_LIMIT;
 import static dagger.internal.codegen.ErrorMessages.INDENT;
 import static dagger.internal.codegen.ErrorMessages.MEMBERS_INJECTION_WITH_UNBOUNDED_TYPE;
@@ -97,11 +98,6 @@
 import static dagger.internal.codegen.ErrorMessages.nullableToNonNullable;
 import static dagger.internal.codegen.ErrorMessages.stripCommonTypePrefixes;
 import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
-import static dagger.internal.codegen.Util.getKeyTypeOfMap;
-import static dagger.internal.codegen.Util.getProvidedValueTypeOfMap;
-import static dagger.internal.codegen.Util.getValueTypeOfMap;
-import static dagger.internal.codegen.Util.isMapWithNonProvidedValues;
-import static dagger.internal.codegen.Util.isMapWithProvidedValues;
 import static javax.tools.Diagnostic.Kind.ERROR;
 import static javax.tools.Diagnostic.Kind.WARNING;
 
@@ -111,28 +107,31 @@
   private final InjectBindingRegistry injectBindingRegistry;
   private final ValidationType scopeCycleValidationType;
   private final Diagnostic.Kind nullableValidationType;
-  private final ContributionBindingFormatter contributionBindingFormatter;
+  private final HasSourceElementFormatter hasSourceElementFormatter;
   private final MethodSignatureFormatter methodSignatureFormatter;
   private final DependencyRequestFormatter dependencyRequestFormatter;
   private final KeyFormatter keyFormatter;
+  private final Key.Factory keyFactory;
 
   BindingGraphValidator(
       Types types,
       InjectBindingRegistry injectBindingRegistry,
       ValidationType scopeCycleValidationType,
       Diagnostic.Kind nullableValidationType,
-      ContributionBindingFormatter contributionBindingFormatter,
+      HasSourceElementFormatter hasSourceElementFormatter,
       MethodSignatureFormatter methodSignatureFormatter,
       DependencyRequestFormatter dependencyRequestFormatter,
-      KeyFormatter keyFormatter) {
+      KeyFormatter keyFormatter,
+      Key.Factory keyFactory) {
     this.types = types;
     this.injectBindingRegistry = injectBindingRegistry;
     this.scopeCycleValidationType = scopeCycleValidationType;
     this.nullableValidationType = nullableValidationType;
-    this.contributionBindingFormatter = contributionBindingFormatter;
+    this.hasSourceElementFormatter = hasSourceElementFormatter;
     this.methodSignatureFormatter = methodSignatureFormatter;
     this.dependencyRequestFormatter = dependencyRequestFormatter;
     this.keyFormatter = keyFormatter;
+    this.keyFactory = keyFactory;
   }
 
   private class Validation {
@@ -277,7 +276,7 @@ private void traverseRequest(
      */
     private boolean validateResolvedBinding(
         Deque<ResolvedRequest> path, ResolvedBindings resolvedBinding) {
-      if (resolvedBinding.bindings().isEmpty()) {
+      if (resolvedBinding.isEmpty()) {
         reportMissingBinding(path);
         return false;
       }
@@ -286,28 +285,30 @@ private boolean validateResolvedBinding(
         case CONTRIBUTION:
           ImmutableSet<ContributionBinding> contributionBindings =
               resolvedBinding.contributionBindings();
-          if (any(contributionBindings, Binding.Type.MEMBERS_INJECTION)) {
-            throw new IllegalArgumentException(
+          if (Iterables.any(
+              resolvedBinding.bindings(), BindingType.isOfType(BindingType.MEMBERS_INJECTION))) {
+            // TODO(dpb): How could this ever happen, even in an invalid graph?
+            throw new AssertionError(
                 "contribution binding keys should never have members injection bindings");
           }
           if (!validateNullability(path.peek().request(), contributionBindings)) {
             return false;
           }
-          if (any(contributionBindings, Binding.Type.PRODUCTION)
+          if (Iterables.any(contributionBindings, BindingType.isOfType(BindingType.PRODUCTION))
               && doesPathRequireProvisionOnly(path)) {
             reportProviderMayNotDependOnProducer(path);
             return false;
           }
-          if (contributionBindings.size() <= 1) {
-            return true;
-          }
-          ImmutableListMultimap<ContributionType, ContributionBinding> contributionsByType =
-              ContributionBinding.contributionTypesFor(contributionBindings);
-          if (contributionsByType.keySet().size() > 1) {
+          ImmutableSet<ContributionType> contributionTypes =
+              declarationsByType(resolvedBinding).keySet();
+          if (contributionTypes.size() > 1) {
             reportMultipleBindingTypes(path);
             return false;
           }
-          switch (getOnlyElement(contributionsByType.keySet())) {
+          if (contributionBindings.size() <= 1) {
+            return true;
+          }
+          switch (getOnlyElement(contributionTypes)) {
             case UNIQUE:
               reportDuplicateBindings(path);
               return false;
@@ -323,8 +324,10 @@ private boolean validateResolvedBinding(
           }
           break;
         case MEMBERS_INJECTION:
-          if (!all(resolvedBinding.bindings(), Binding.Type.MEMBERS_INJECTION)) {
-            throw new IllegalArgumentException(
+          if (!Iterables.all(
+              resolvedBinding.bindings(), BindingType.isOfType(BindingType.MEMBERS_INJECTION))) {
+            // TODO(dpb): How could this ever happen, even in an invalid graph?
+            throw new AssertionError(
                 "members injection binding keys should never have contribution bindings");
           }
           if (resolvedBinding.bindings().size() > 1) {
@@ -338,6 +341,72 @@ private boolean validateResolvedBinding(
       return true;
     }
 
+    /**
+     * Returns an object that contains all the same bindings as {@code resolvedBindings}, except
+     * that any {@link #SYNTHETIC_MAP} {@link ContributionBinding}s are replaced by the contribution
+     * bindings and multibinding declarations of their dependencies.
+     *
+     * <p>For example, if:
+     *
+     * <ul>
+     * <li>The bindings for {@code key1} are {@code A} and {@code B}, with multibinding declaration
+     *     {@code X}.
+     * <li>{@code B} is a synthetic binding with a dependency on {@code key2}.
+     * <li>The bindings for {@code key2} are {@code C} and {@code D}, with multibinding declaration
+     *     {@code Y}.
+     * </ul>
+     *
+     * then {@code inlineSyntheticBindings(bindingsForKey1)} has bindings {@code A}, {@code C}, and
+     * {@code D}, with multibinding declarations {@code X} and {@code Y}.
+     *
+     * <p>The replacement is repeated until none of the bindings are synthetic.
+     */
+    private ResolvedBindings inlineSyntheticContributions(ResolvedBindings resolvedBinding) {
+      if (!Iterables.any(
+          resolvedBinding.contributionBindings(), ContributionBinding.isOfKind(SYNTHETIC_MAP))) {
+        return resolvedBinding;
+      }
+      
+      ImmutableSetMultimap.Builder<ComponentDescriptor, ContributionBinding> contributions =
+          ImmutableSetMultimap.builder();
+      ImmutableSet.Builder<MultibindingDeclaration> multibindingDeclarations =
+          ImmutableSet.builder();
+
+      Queue<Map.Entry<ComponentDescriptor, ContributionBinding>> contributionQueue =
+          new ArrayDeque<>(resolvedBinding.allContributionBindings().entries());
+
+      for (Map.Entry<ComponentDescriptor, ContributionBinding> bindingEntry =
+              contributionQueue.poll();
+          bindingEntry != null;
+          bindingEntry = contributionQueue.poll()) {
+        ContributionBinding binding = bindingEntry.getValue();
+        if (binding.bindingKind().equals(SYNTHETIC_MAP)) {
+          BindingKey syntheticBindingDependency =
+              getOnlyElement(binding.dependencies()).bindingKey();
+          ResolvedBindings dependencyBindings =
+              subject.resolvedBindings().get(syntheticBindingDependency);
+          multibindingDeclarations.addAll(dependencyBindings.multibindingDeclarations());
+          contributionQueue.addAll(dependencyBindings.allContributionBindings().entries());
+        } else {
+          contributions.put(bindingEntry);
+        }
+      }
+      return ResolvedBindings.forContributionBindings(
+          resolvedBinding.bindingKey(),
+          resolvedBinding.owningComponent(),
+          contributions.build(),
+          multibindingDeclarations.build());
+    }
+
+    private ImmutableListMultimap<ContributionType, HasSourceElement> declarationsByType(
+        ResolvedBindings resolvedBinding) {
+      ResolvedBindings inlined = inlineSyntheticContributions(resolvedBinding);
+      return new ImmutableListMultimap.Builder<ContributionType, HasSourceElement>()
+          .putAll(indexByContributionType(inlined.contributionBindings()))
+          .putAll(indexByContributionType(inlined.multibindingDeclarations()))
+          .build();
+    }
+
     /** Ensures that if the request isn't nullable, then each contribution is also not nullable. */
     private boolean validateNullability(
         DependencyRequest request, Set<ContributionBinding> bindings) {
@@ -356,7 +425,7 @@ private boolean validateNullability(
       for (ContributionBinding binding : bindings) {
         if (binding.nullableType().isPresent()) {
           reportBuilder.addItem(
-              nullableToNonNullable(typeName, contributionBindingFormatter.format(binding))
+              nullableToNonNullable(typeName, hasSourceElementFormatter.format(binding))
                   + "\n at: "
                   + dependencyRequestFormatter.format(request),
               nullableValidationType,
@@ -717,34 +786,33 @@ void validateComponentScope() {
       Scope componentScope = subject.componentDescriptor().scope();
       ImmutableSet.Builder<String> incompatiblyScopedMethodsBuilder = ImmutableSet.builder();
       for (ResolvedBindings bindings : resolvedBindings.values()) {
-        if (bindings.bindingKey().kind().equals(BindingKey.Kind.CONTRIBUTION)) {
-          for (ContributionBinding contributionBinding : bindings.ownedContributionBindings()) {
-            Scope bindingScope = contributionBinding.scope();
-            if (bindingScope.isPresent() && !bindingScope.equals(componentScope)) {
-              // Scoped components cannot reference bindings to @Provides methods or @Inject
-              // types decorated by a different scope annotation. Unscoped components cannot
-              // reference to scoped @Provides methods or @Inject types decorated by any
-              // scope annotation.
-              switch (contributionBinding.bindingKind()) {
-                case PROVISION:
-                  ExecutableElement provisionMethod =
-                      MoreElements.asExecutable(contributionBinding.bindingElement());
-                  incompatiblyScopedMethodsBuilder.add(
-                      methodSignatureFormatter.format(provisionMethod));
-                  break;
-                case INJECTION:
-                  incompatiblyScopedMethodsBuilder.add(
-                      bindingScope.getReadableSource()
-                          + " class "
-                          + contributionBinding.bindingTypeElement().getQualifiedName());
-                  break;
-                default:
-                  throw new IllegalStateException();
-              }
+        for (ContributionBinding contributionBinding : bindings.ownedContributionBindings()) {
+          Scope bindingScope = contributionBinding.scope();
+          if (bindingScope.isPresent() && !bindingScope.equals(componentScope)) {
+            // Scoped components cannot reference bindings to @Provides methods or @Inject
+            // types decorated by a different scope annotation. Unscoped components cannot
+            // reference to scoped @Provides methods or @Inject types decorated by any
+            // scope annotation.
+            switch (contributionBinding.bindingKind()) {
+              case PROVISION:
+                ExecutableElement provisionMethod =
+                    MoreElements.asExecutable(contributionBinding.bindingElement());
+                incompatiblyScopedMethodsBuilder.add(
+                    methodSignatureFormatter.format(provisionMethod));
+                break;
+              case INJECTION:
+                incompatiblyScopedMethodsBuilder.add(
+                    bindingScope.getReadableSource()
+                        + " class "
+                        + contributionBinding.bindingTypeElement().getQualifiedName());
+                break;
+              default:
+                throw new IllegalStateException();
             }
           }
         }
       }
+
       ImmutableSet<String> incompatiblyScopedMethods = incompatiblyScopedMethodsBuilder.build();
       if (!incompatiblyScopedMethods.isEmpty()) {
         TypeElement componentType = subject.componentDescriptor().componentDefinitionType();
@@ -825,42 +893,30 @@ private void reportDuplicateBindings(Deque<ResolvedRequest> path) {
       StringBuilder builder = new StringBuilder();
       new Formatter(builder)
           .format(ErrorMessages.DUPLICATE_BINDINGS_FOR_KEY_FORMAT, formatRootRequestKey(path));
-      for (ContributionBinding binding :
-          Iterables.limit(resolvedBinding.contributionBindings(), DUPLICATE_SIZE_LIMIT)) {
-        builder.append('\n').append(INDENT).append(contributionBindingFormatter.format(binding));
-      }
-      int numberOfOtherBindings =
-          resolvedBinding.contributionBindings().size() - DUPLICATE_SIZE_LIMIT;
-      if (numberOfOtherBindings > 0) {
-        builder.append('\n').append(INDENT)
-            .append("and ").append(numberOfOtherBindings).append(" other");
-      }
-      if (numberOfOtherBindings > 1) {
-        builder.append('s');
-      }
+      hasSourceElementFormatter.formatIndentedList(
+          builder,
+          inlineSyntheticContributions(resolvedBinding).contributionBindings(),
+          1,
+          DUPLICATE_SIZE_LIMIT);
       reportBuilder.addError(builder.toString(), path.getLast().request().requestElement());
     }
 
     @SuppressWarnings("resource") // Appendable is a StringBuilder.
     private void reportMultipleBindingTypes(Deque<ResolvedRequest> path) {
-      ResolvedBindings resolvedBinding = path.peek().binding();
       StringBuilder builder = new StringBuilder();
       new Formatter(builder)
           .format(ErrorMessages.MULTIPLE_BINDING_TYPES_FOR_KEY_FORMAT, formatRootRequestKey(path));
-      ImmutableListMultimap<ContributionType, ContributionBinding> bindingsByType =
-          ContributionBinding.contributionTypesFor(resolvedBinding.contributionBindings());
+      ResolvedBindings resolvedBinding = path.peek().binding();
+      ImmutableListMultimap<ContributionType, HasSourceElement> declarationsByType =
+          declarationsByType(resolvedBinding);
       for (ContributionType type :
-          Ordering.natural().immutableSortedCopy(bindingsByType.keySet())) {
+          Ordering.natural().immutableSortedCopy(declarationsByType.keySet())) {
         builder.append(INDENT);
-        builder.append(formatBindingType(type));
-        builder.append(" bindings:\n");
-        for (ContributionBinding binding : bindingsByType.get(type)) {
-          builder
-              .append(INDENT)
-              .append(INDENT)
-              .append(contributionBindingFormatter.format(binding))
-              .append('\n');
-        }
+        builder.append(formatContributionType(type));
+        builder.append(" bindings and declarations:");
+        hasSourceElementFormatter.formatIndentedList(
+            builder, declarationsByType.get(type), 2, DUPLICATE_SIZE_LIMIT);
+        builder.append('\n');
       }
       reportBuilder.addError(builder.toString(), path.getLast().request().requestElement());
     }
@@ -869,7 +925,7 @@ private void reportDuplicateMapKeys(
         Deque<ResolvedRequest> path, Collection<ContributionBinding> mapBindings) {
       StringBuilder builder = new StringBuilder();
       builder.append(duplicateMapKeysError(formatRootRequestKey(path)));
-      appendBindings(builder, mapBindings, 1);
+      hasSourceElementFormatter.formatIndentedList(builder, mapBindings, 1, DUPLICATE_SIZE_LIMIT);
       reportBuilder.addError(builder.toString(), path.getLast().request().requestElement());
     }
 
@@ -890,7 +946,7 @@ private void reportInconsistentMapKeyAnnotations(
             .append(annotationType)
             .append(':');
 
-        appendBindings(builder, bindings, 2);
+        hasSourceElementFormatter.formatIndentedList(builder, bindings, 2, DUPLICATE_SIZE_LIMIT);
       }
       reportBuilder.addError(builder.toString(), path.getLast().request().requestElement());
     }
@@ -964,11 +1020,11 @@ private boolean cycleHasProviderOrLazy(ImmutableList<DependencyRequest> cycle) {
             return true;
 
           case INSTANCE:
-            if (isMapWithProvidedValues(dependencyRequest.key().type())) {
+            TypeMirror type = dependencyRequest.key().type();
+            if (MapType.isMap(type) && MapType.from(type).valuesAreTypeOf(Provider.class)) {
               return true;
-            } else {
-              break;
             }
+            break;
 
           default:
             break;
@@ -985,20 +1041,10 @@ private boolean cycleHasProviderOrLazy(ImmutableList<DependencyRequest> cycle) {
      */
     private boolean isImplicitProviderMapForValueMap(
         DependencyRequest maybeProviderMapRequest, DependencyRequest maybeValueMapRequest) {
-      TypeMirror maybeProviderMapRequestType = maybeProviderMapRequest.key().type();
-      TypeMirror maybeValueMapRequestType = maybeValueMapRequest.key().type();
-      return maybeProviderMapRequest
-              .key()
-              .wrappedQualifier()
-              .equals(maybeValueMapRequest.key().wrappedQualifier())
-          && isMapWithProvidedValues(maybeProviderMapRequestType)
-          && isMapWithNonProvidedValues(maybeValueMapRequestType)
-          && types.isSameType(
-              getKeyTypeOfMap(asDeclared(maybeProviderMapRequestType)),
-              getKeyTypeOfMap(asDeclared(maybeValueMapRequestType)))
-          && types.isSameType(
-              getProvidedValueTypeOfMap(asDeclared(maybeProviderMapRequestType)),
-              getValueTypeOfMap(asDeclared(maybeValueMapRequestType)));
+      Optional<Key> implicitProviderMapKey =
+          keyFactory.implicitMapProviderKeyFrom(maybeValueMapRequest.key());
+      return implicitProviderMapKey.isPresent()
+          && implicitProviderMapKey.get().equals(maybeProviderMapRequest.key());
     }
   }
 
@@ -1085,7 +1131,7 @@ private boolean doesPathRequireProvisionOnly(Deque<ResolvedRequest> path) {
     final DependencyRequest request = iterator.next().request();
     ResolvedRequest previousResolvedRequest = iterator.next();
     return FluentIterable.from(previousResolvedRequest.binding().bindings())
-        .filter(Binding.Type.PROVISION)
+        .filter(BindingType.isOfType(BindingType.PROVISION))
         .filter(
             new Predicate<Binding>() {
               @Override
@@ -1096,7 +1142,7 @@ public boolean apply(Binding binding) {
         .toSet();
   }
 
-  private String formatBindingType(ContributionType type) {
+  private String formatContributionType(ContributionType type) {
     switch (type) {
       case MAP:
         return "Map";
@@ -1113,28 +1159,6 @@ private String formatRootRequestKey(Deque<ResolvedRequest> path) {
     return keyFormatter.format(path.peek().request().key());
   }
 
-  private void appendBindings(
-      StringBuilder builder, Collection<ContributionBinding> bindings, int indentLevel) {
-    for (ContributionBinding binding : Iterables.limit(bindings, DUPLICATE_SIZE_LIMIT)) {
-      builder.append('\n');
-      for (int i = 0; i < indentLevel; i++) {
-        builder.append(INDENT);
-      }
-      builder.append(contributionBindingFormatter.format(binding));
-    }
-    int numberOfOtherBindings = bindings.size() - DUPLICATE_SIZE_LIMIT;
-    if (numberOfOtherBindings > 0) {
-      builder.append('\n');
-      for (int i = 0; i < indentLevel; i++) {
-        builder.append(INDENT);
-      }
-      builder.append("and ").append(numberOfOtherBindings).append(" other");
-    }
-    if (numberOfOtherBindings > 1) {
-      builder.append('s');
-    }
-  }
-
   @AutoValue
   abstract static class ResolvedRequest {
     abstract DependencyRequest request();
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingType.java b/compiler/src/main/java/dagger/internal/codegen/BindingType.java
new file mode 100644
index 000000000..8d2a1d6c5
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingType.java
@@ -0,0 +1,69 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.base.Function;
+import com.google.common.base.Predicate;
+import com.google.common.base.Predicates;
+import dagger.MembersInjector;
+import dagger.producers.Producer;
+import javax.inject.Provider;
+
+/**
+ * Whether a binding or declaration is for provision, production, or a {@link MembersInjector}.
+ */
+enum BindingType {
+  /** A binding with this type is a {@link ProvisionBinding}. */
+  PROVISION(Provider.class),
+
+  /** A binding with this type is a {@link MembersInjectionBinding}. */
+  MEMBERS_INJECTION(MembersInjector.class),
+
+  /** A binding with this type is a {@link ProductionBinding}. */
+  PRODUCTION(Producer.class),
+  ;
+
+  /** An object that is associated with a {@link BindingType}. */
+  interface HasBindingType {
+    /** The binding type of this object. */
+    BindingType bindingType();
+  }
+
+  private final Class<?> frameworkClass;
+
+  private BindingType(Class<?> frameworkClass) {
+    this.frameworkClass = frameworkClass;
+  }
+
+  /** The framework class associated with bindings of this type. */
+  Class<?> frameworkClass() {
+    return frameworkClass;
+  }
+
+  /** A predicate that passes for {@link HasBindingType}s with a given type. */
+  static Predicate<HasBindingType> isOfType(BindingType type) {
+    return Predicates.compose(Predicates.equalTo(type), BINDING_TYPE);
+  }
+
+  /** A function that returns {@link HasBindingType#bindingType()}. */
+  static Function<HasBindingType, BindingType> BINDING_TYPE =
+      new Function<HasBindingType, BindingType>() {
+        @Override
+        public BindingType apply(HasBindingType hasBindingType) {
+          return hasBindingType.bindingType();
+        }
+      };
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java b/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java
index ba96ebfd3..fb9515486 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java
@@ -51,21 +51,22 @@
 class BuilderValidator {
   private final Elements elements;
   private final Types types;
-  private final ComponentDescriptor.Kind componentType;
 
-  BuilderValidator(Elements elements, Types types, ComponentDescriptor.Kind componentType) {
+  BuilderValidator(Elements elements, Types types) {
     this.elements = elements;
     this.types = types;
-    this.componentType = componentType;
   }
 
   public ValidationReport<TypeElement> validate(TypeElement subject) {
     ValidationReport.Builder<TypeElement> builder = ValidationReport.about(subject);
 
+    ComponentDescriptor.Kind componentKind =
+        ComponentDescriptor.Kind.forAnnotatedBuilderElement(subject).get();
+
     Element componentElement = subject.getEnclosingElement();
-    ErrorMessages.ComponentBuilderMessages msgs = ErrorMessages.builderMsgsFor(componentType);
-    Class<? extends Annotation> componentAnnotation = componentType.annotationType();
-    Class<? extends Annotation> builderAnnotation = componentType.builderAnnotationType();
+    ErrorMessages.ComponentBuilderMessages msgs = ErrorMessages.builderMsgsFor(componentKind);
+    Class<? extends Annotation> componentAnnotation = componentKind.annotationType();
+    Class<? extends Annotation> builderAnnotation = componentKind.builderAnnotationType();
     checkArgument(subject.getAnnotation(builderAnnotation) != null);
 
     if (!isAnnotationPresent(componentElement, componentAnnotation)) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index 650fb9dcc..608a8dd56 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -18,12 +18,14 @@
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
+import com.google.common.base.Function;
 import com.google.common.base.Optional;
 import com.google.common.base.Predicate;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Sets;
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.Component;
 import dagger.Lazy;
@@ -99,6 +101,25 @@
       return Optional.fromNullable(getOnlyElement(kinds, null));
     }
 
+    /**
+     * Returns the kind of an annotated element if it is annotated with one of the
+     * {@linkplain #builderAnnotationType() annotation types}.
+     *
+     * @throws IllegalArgumentException if the element is annotated with more than one of the
+     *     annotation types
+     */
+    static Optional<Kind> forAnnotatedBuilderElement(TypeElement element) {
+      Set<Kind> kinds = EnumSet.noneOf(Kind.class);
+      for (Kind kind : values()) {
+        if (MoreElements.isAnnotationPresent(element, kind.builderAnnotationType())) {
+          kinds.add(kind);
+        }
+      }
+      checkArgument(
+          kinds.size() <= 1, "%s cannot be annotated with more than one of %s", element, kinds);
+      return Optional.fromNullable(getOnlyElement(kinds, null));
+    }
+
     Kind(
         Class<? extends Annotation> annotationType,
         Class<? extends Annotation> builderType,
@@ -116,9 +137,58 @@
       return builderType;
     }
 
+    ImmutableSet<ModuleDescriptor.Kind> moduleKinds() {
+      switch (this) {
+        case COMPONENT:
+        case SUBCOMPONENT:
+          return Sets.immutableEnumSet(ModuleDescriptor.Kind.MODULE);
+        case PRODUCTION_COMPONENT:
+          return Sets.immutableEnumSet(
+              ModuleDescriptor.Kind.MODULE, ModuleDescriptor.Kind.PRODUCER_MODULE);
+        default:
+          throw new AssertionError(this);
+      }
+    }
+
+    ImmutableSet<Kind> subcomponentKinds() {
+      switch (this) {
+        case COMPONENT:
+        case SUBCOMPONENT:
+          return ImmutableSet.of(SUBCOMPONENT);
+        case PRODUCTION_COMPONENT:
+          return ImmutableSet.of();
+        default:
+          throw new AssertionError();
+      }
+    }
+
     boolean isTopLevel() {
       return isTopLevel;
     }
+
+    private static final Function<Kind, Class<? extends Annotation>> TO_ANNOTATION_TYPE =
+        new Function<Kind, Class<? extends Annotation>>() {
+          @Override
+          public Class<? extends Annotation> apply(Kind kind) {
+            return kind.annotationType();
+          }
+        };
+
+    static Function<Kind, Class<? extends Annotation>> toAnnotationType() {
+      return TO_ANNOTATION_TYPE;
+    }
+
+    private static final Function<Kind, Class<? extends Annotation>> TO_BUILDER_ANNOTATION_TYPE =
+        new Function<Kind, Class<? extends Annotation>>() {
+          @Override
+          public Class<? extends Annotation> apply(Kind kind) {
+            return kind.builderAnnotationType();
+          }
+        };
+
+    static Function<Kind, Class<? extends Annotation>> toBuilderAnnotationType() {
+      return TO_BUILDER_ANNOTATION_TYPE;
+    }
   }
 
   abstract Kind kind();
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index 72e761cbf..ecb2cfd20 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -49,7 +49,7 @@
       Types types,
       Key.Factory keyFactory,
       Diagnostic.Kind nullableValidationType) {
-    super(filer);
+    super(filer, elements);
     this.types = types;
     this.elements = elements;
     this.keyFactory = keyFactory;
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
index 39b21ca32..fdc53d569 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
@@ -17,115 +17,160 @@
 
 import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
 import com.google.auto.common.MoreElements;
+import com.google.common.base.Predicates;
+import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Maps;
+import com.google.common.collect.Multimaps;
 import com.google.common.collect.SetMultimap;
 import dagger.Component;
 import dagger.Subcomponent;
 import dagger.internal.codegen.ComponentDescriptor.Factory;
 import dagger.internal.codegen.ComponentValidator.ComponentValidationReport;
+import dagger.producers.ProductionComponent;
 import java.lang.annotation.Annotation;
 import java.util.Map;
 import java.util.Set;
 import javax.annotation.processing.Messager;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
+import javax.tools.Diagnostic.Kind;
 
 /**
- * A {@link ProcessingStep} that is responsible for dealing with the {@link Component} annotation
+ * A {@link ProcessingStep} that is responsible for dealing with a component or production component
  * as part of the {@link ComponentProcessor}.
  *
  * @author Gregory Kick
  */
-final class ComponentProcessingStep extends AbstractComponentProcessingStep {
+final class ComponentProcessingStep implements ProcessingStep {
+  private final ComponentDescriptor.Kind componentKind;
   private final Messager messager;
   private final ComponentValidator componentValidator;
   private final ComponentValidator subcomponentValidator;
-  private final BuilderValidator componentBuilderValidator;
-  private final BuilderValidator subcomponentBuilderValidator;
+  private final BuilderValidator builderValidator;
+  private final ComponentHierarchyValidator componentHierarchyValidator;
+  private final BindingGraphValidator bindingGraphValidator;
+  private final ComponentDescriptor.Factory componentDescriptorFactory;
+  private final BindingGraph.Factory bindingGraphFactory;
+  private final ComponentGenerator componentGenerator;
 
   ComponentProcessingStep(
+      ComponentDescriptor.Kind componentKind,
       Messager messager,
       ComponentValidator componentValidator,
       ComponentValidator subcomponentValidator,
-      BuilderValidator componentBuilderValidator,
-      BuilderValidator subcomponentBuilderValidator,
+      BuilderValidator builderValidator,
       ComponentHierarchyValidator componentHierarchyValidator,
       BindingGraphValidator bindingGraphValidator,
       Factory componentDescriptorFactory,
       BindingGraph.Factory bindingGraphFactory,
       ComponentGenerator componentGenerator) {
-    super(
-        Component.class,
-        messager,
-        componentHierarchyValidator,
-        bindingGraphValidator,
-        componentDescriptorFactory,
-        bindingGraphFactory,
-        componentGenerator);
+    this.componentKind = componentKind;
     this.messager = messager;
     this.componentValidator = componentValidator;
     this.subcomponentValidator = subcomponentValidator;
-    this.componentBuilderValidator = componentBuilderValidator;
-    this.subcomponentBuilderValidator = subcomponentBuilderValidator;
+    this.builderValidator = builderValidator;
+    this.componentHierarchyValidator = componentHierarchyValidator;
+    this.bindingGraphValidator = bindingGraphValidator;
+    this.componentDescriptorFactory = componentDescriptorFactory;
+    this.bindingGraphFactory = bindingGraphFactory;
+    this.componentGenerator = componentGenerator;
   }
 
   @Override
   public Set<Class<? extends Annotation>> annotations() {
-    return ImmutableSet.<Class<? extends Annotation>>of(Component.class, Component.Builder.class,
-        Subcomponent.class, Subcomponent.Builder.class);
+    return ImmutableSet.of(
+        Component.class,
+        Component.Builder.class,
+        ProductionComponent.class,
+        ProductionComponent.Builder.class,
+        Subcomponent.class,
+        Subcomponent.Builder.class);
   }
 
   @Override
-  protected ComponentElementValidator componentElementValidator(
+  public final ImmutableSet<Element> process(
       SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
-    final Map<Element, ValidationReport<TypeElement>> builderReportsByComponent =
-        processComponentBuilders(elementsByAnnotation.get(Component.Builder.class));
-    final Set<Element> subcomponentBuilderElements =
-        elementsByAnnotation.get(Subcomponent.Builder.class);
-    final Map<Element, ValidationReport<TypeElement>> builderReportsBySubcomponent =
-        processSubcomponentBuilders(subcomponentBuilderElements);
-    final Set<Element> subcomponentElements = elementsByAnnotation.get(Subcomponent.class);
-    final Map<Element, ValidationReport<TypeElement>> reportsBySubcomponent =
+    ImmutableSet.Builder<Element> rejectedElements = ImmutableSet.builder();
+
+    Map<Element, ValidationReport<TypeElement>> builderReportsByComponent =
+        processBuilders(elementsByAnnotation.get(componentKind.builderAnnotationType()));
+    Set<Element> subcomponentBuilderElements =
+        getElementsFromAnnotations(
+            elementsByAnnotation,
+            FluentIterable.from(componentKind.subcomponentKinds())
+                .transform(ComponentDescriptor.Kind.toBuilderAnnotationType())
+                .toSet());
+    Map<Element, ValidationReport<TypeElement>> builderReportsBySubcomponent =
+        processBuilders(subcomponentBuilderElements);
+    Set<Element> subcomponentElements =
+        getElementsFromAnnotations(
+            elementsByAnnotation,
+            FluentIterable.from(componentKind.subcomponentKinds())
+                .transform(ComponentDescriptor.Kind.toAnnotationType())
+                .toSet());
+    Map<Element, ValidationReport<TypeElement>> reportsBySubcomponent =
         processSubcomponents(subcomponentElements, subcomponentBuilderElements);
-    return new ComponentElementValidator() {
-      @Override
-      boolean validateComponent(TypeElement componentTypeElement, Messager messager) {
+
+    for (Element element : elementsByAnnotation.get(componentKind.annotationType())) {
+      TypeElement componentTypeElement = MoreElements.asType(element);
+      try {
         ComponentValidationReport validationReport =
             componentValidator.validate(
                 componentTypeElement, subcomponentElements, subcomponentBuilderElements);
         validationReport.report().printMessagesTo(messager);
-        return isClean(
+        if (isClean(
             validationReport,
             builderReportsByComponent,
             reportsBySubcomponent,
-            builderReportsBySubcomponent);
+            builderReportsBySubcomponent)) {
+          ComponentDescriptor componentDescriptor =
+              componentDescriptorFactory.forComponent(componentTypeElement);
+          ValidationReport<TypeElement> hierarchyReport =
+              componentHierarchyValidator.validate(componentDescriptor);
+          hierarchyReport.printMessagesTo(messager);
+          if (hierarchyReport.isClean()) {
+            BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor);
+            ValidationReport<TypeElement> graphReport =
+                bindingGraphValidator.validate(bindingGraph);
+            graphReport.printMessagesTo(messager);
+            if (graphReport.isClean()) {
+              generateComponent(bindingGraph);
+            }
+          }
+        }
+      } catch (TypeNotPresentException e) {
+        rejectedElements.add(componentTypeElement);
       }
-    };
+    }
+    return rejectedElements.build();
   }
 
-  private Map<Element, ValidationReport<TypeElement>> processComponentBuilders(
-      Set<? extends Element> componentBuilderElements) {
-    Map<Element, ValidationReport<TypeElement>> builderReportsByComponent = Maps.newHashMap();
-    for (Element element : componentBuilderElements) {
-      ValidationReport<TypeElement> report =
-          componentBuilderValidator.validate(MoreElements.asType(element));
-      report.printMessagesTo(messager);
-      builderReportsByComponent.put(element.getEnclosingElement(), report);
+  private void generateComponent(BindingGraph bindingGraph) {
+    try {
+      componentGenerator.generate(bindingGraph);
+    } catch (SourceFileGenerationException e) {
+      e.printMessageTo(messager);
     }
-    return builderReportsByComponent;
   }
 
-  private Map<Element, ValidationReport<TypeElement>> processSubcomponentBuilders(
-      Set<? extends Element> subcomponentBuilderElements) {
-    Map<Element, ValidationReport<TypeElement>> builderReportsBySubcomponent = Maps.newHashMap();
-    for (Element element : subcomponentBuilderElements) {
+  private ImmutableSet<Element> getElementsFromAnnotations(
+      final SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation,
+      ImmutableSet<Class<? extends Annotation>> annotations) {
+    return ImmutableSet.copyOf(
+        Multimaps.filterKeys(elementsByAnnotation, Predicates.in(annotations)).values());
+  }
+
+  private Map<Element, ValidationReport<TypeElement>> processBuilders(
+      Set<? extends Element> builderElements) {
+    Map<Element, ValidationReport<TypeElement>> builderReportsByComponent = Maps.newHashMap();
+    for (Element element : builderElements) {
       ValidationReport<TypeElement> report =
-          subcomponentBuilderValidator.validate(MoreElements.asType(element));
+          builderValidator.validate(MoreElements.asType(element));
       report.printMessagesTo(messager);
-      builderReportsBySubcomponent.put(element, report);
+      builderReportsByComponent.put(element.getEnclosingElement(), report);
     }
-    return builderReportsBySubcomponent;
+    return builderReportsByComponent;
   }
 
   private Map<Element, ValidationReport<TypeElement>> processSubcomponents(
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index c35058ba3..369fb7c49 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -20,11 +20,6 @@
 import com.google.common.base.Ascii;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
-import dagger.Module;
-import dagger.Provides;
-import dagger.producers.ProducerModule;
-import dagger.producers.Produces;
-import java.lang.annotation.Annotation;
 import java.util.EnumSet;
 import java.util.Map;
 import java.util.Set;
@@ -70,7 +65,7 @@ public SourceVersion getSupportedSourceVersion() {
   }
 
   @Override
-  protected Iterable<ProcessingStep> initSteps() {
+  protected Iterable<? extends ProcessingStep> initSteps() {
     Messager messager = processingEnv.getMessager();
     Types types = processingEnv.getTypeUtils();
     Elements elements = processingEnv.getElementUtils();
@@ -80,8 +75,8 @@ public SourceVersion getSupportedSourceVersion() {
         nullableValidationType(processingEnv).diagnosticKind().get();
 
     MethodSignatureFormatter methodSignatureFormatter = new MethodSignatureFormatter(types);
-    ContributionBindingFormatter contributionBindingFormatter =
-        new ContributionBindingFormatter(methodSignatureFormatter);
+    HasSourceElementFormatter hasSourceElementFormatter =
+        new HasSourceElementFormatter(methodSignatureFormatter);
     DependencyRequestFormatter dependencyRequestFormatter = new DependencyRequestFormatter(types);
     KeyFormatter keyFormatter = new KeyFormatter();
 
@@ -93,47 +88,34 @@ public SourceVersion getSupportedSourceVersion() {
         privateMemberValidationType(processingEnv).diagnosticKind().get(),
         staticMemberValidationType(processingEnv).diagnosticKind().get());
     ModuleValidator moduleValidator =
-        new ModuleValidator(
-            types,
-            elements,
-            methodSignatureFormatter,
-            Module.class,
-            ImmutableList.<Class<? extends Annotation>>of(Module.class),
-            Provides.class);
-    ProvidesMethodValidator providesMethodValidator = new ProvidesMethodValidator(elements);
-    BuilderValidator componentBuilderValidator =
-        new BuilderValidator(elements, types, ComponentDescriptor.Kind.COMPONENT);
-    BuilderValidator subcomponentBuilderValidator =
-        new BuilderValidator(elements, types, ComponentDescriptor.Kind.SUBCOMPONENT);
-    ComponentValidator subcomponentValidator = ComponentValidator.createForSubcomponent(elements,
-        types, moduleValidator, subcomponentBuilderValidator);
-    ComponentValidator componentValidator = ComponentValidator.createForComponent(elements, types,
-        moduleValidator, subcomponentValidator, subcomponentBuilderValidator);
+        new ModuleValidator(types, elements, methodSignatureFormatter);
+    BuilderValidator builderValidator = new BuilderValidator(elements, types);
+    ComponentValidator subcomponentValidator =
+        ComponentValidator.createForSubcomponent(
+            elements, types, moduleValidator, builderValidator);
+    ComponentValidator componentValidator =
+        ComponentValidator.createForComponent(
+            elements, types, moduleValidator, subcomponentValidator, builderValidator);
     MapKeyValidator mapKeyValidator = new MapKeyValidator();
-    ModuleValidator producerModuleValidator =
-        new ModuleValidator(
-            types,
-            elements,
-            methodSignatureFormatter,
-            ProducerModule.class,
-            ImmutableList.of(Module.class, ProducerModule.class),
-            Produces.class);
-    ProducesMethodValidator producesMethodValidator = new ProducesMethodValidator(elements);
-    ProductionComponentValidator productionComponentValidator = new ProductionComponentValidator();
-    BuilderValidator productionComponentBuilderValidator =
-        new BuilderValidator(elements, types, ComponentDescriptor.Kind.PRODUCTION_COMPONENT);
+    ProvidesMethodValidator providesMethodValidator = new ProvidesMethodValidator(elements, types);
+    ProducesMethodValidator producesMethodValidator = new ProducesMethodValidator(elements, types);
 
     Key.Factory keyFactory = new Key.Factory(types, elements);
 
+    MultibindingsValidator multibindingsValidator =
+        new MultibindingsValidator(elements, keyFactory, keyFormatter, methodSignatureFormatter);
+
     this.factoryGenerator =
-        new FactoryGenerator(filer, DependencyRequestMapper.FOR_PROVIDER, nullableDiagnosticType);
+        new FactoryGenerator(
+            filer, elements, DependencyRequestMapper.FOR_PROVIDER, nullableDiagnosticType);
     this.membersInjectorGenerator =
-        new MembersInjectorGenerator(filer, DependencyRequestMapper.FOR_PROVIDER);
+        new MembersInjectorGenerator(filer, elements, DependencyRequestMapper.FOR_PROVIDER);
     ComponentGenerator componentGenerator =
         new ComponentGenerator(filer, elements, types, keyFactory, nullableDiagnosticType);
     ProducerFactoryGenerator producerFactoryGenerator =
-        new ProducerFactoryGenerator(filer, DependencyRequestMapper.FOR_PRODUCER);
-    MonitoringModuleGenerator monitoringModuleGenerator = new MonitoringModuleGenerator(filer);
+        new ProducerFactoryGenerator(filer, elements, DependencyRequestMapper.FOR_PRODUCER);
+    MonitoringModuleGenerator monitoringModuleGenerator =
+        new MonitoringModuleGenerator(filer, elements);
 
     DependencyRequest.Factory dependencyRequestFactory =
         new DependencyRequest.Factory(elements, keyFactory);
@@ -141,6 +123,8 @@ public SourceVersion getSupportedSourceVersion() {
         new ProvisionBinding.Factory(elements, types, keyFactory, dependencyRequestFactory);
     ProductionBinding.Factory productionBindingFactory =
         new ProductionBinding.Factory(types, keyFactory, dependencyRequestFactory);
+    MultibindingDeclaration.Factory multibindingDeclarationFactory =
+        new MultibindingDeclaration.Factory(elements, types, keyFactory);
 
     MembersInjectionBinding.Factory membersInjectionBindingFactory =
         new MembersInjectionBinding.Factory(elements, types, keyFactory, dependencyRequestFactory);
@@ -148,8 +132,12 @@ public SourceVersion getSupportedSourceVersion() {
     this.injectBindingRegistry = new InjectBindingRegistry(
         elements, types, messager, provisionBindingFactory, membersInjectionBindingFactory);
 
-    ModuleDescriptor.Factory moduleDescriptorFactory = new ModuleDescriptor.Factory(
-        elements, provisionBindingFactory, productionBindingFactory);
+    ModuleDescriptor.Factory moduleDescriptorFactory =
+        new ModuleDescriptor.Factory(
+            elements,
+            provisionBindingFactory,
+            productionBindingFactory,
+            multibindingDeclarationFactory);
 
     ComponentDescriptor.Factory componentDescriptorFactory = new ComponentDescriptor.Factory(
         elements, types, dependencyRequestFactory, moduleDescriptorFactory);
@@ -162,7 +150,7 @@ public SourceVersion getSupportedSourceVersion() {
             provisionBindingFactory,
             productionBindingFactory);
 
-    MapKeyGenerator mapKeyGenerator = new MapKeyGenerator(filer);
+    MapKeyGenerator mapKeyGenerator = new MapKeyGenerator(filer, elements);
     ComponentHierarchyValidator componentHierarchyValidator = new ComponentHierarchyValidator();
     BindingGraphValidator bindingGraphValidator =
         new BindingGraphValidator(
@@ -170,12 +158,13 @@ public SourceVersion getSupportedSourceVersion() {
             injectBindingRegistry,
             scopeValidationType(processingEnv),
             nullableDiagnosticType,
-            contributionBindingFormatter,
+            hasSourceElementFormatter,
             methodSignatureFormatter,
             dependencyRequestFormatter,
-            keyFormatter);
+            keyFormatter,
+            keyFactory);
 
-    return ImmutableList.<ProcessingStep>of(
+    return ImmutableList.of(
         new MapKeyProcessingStep(messager, types, mapKeyValidator, mapKeyGenerator),
         new InjectProcessingStep(
             messager,
@@ -186,6 +175,7 @@ public SourceVersion getSupportedSourceVersion() {
             membersInjectionBindingFactory,
             injectBindingRegistry),
         new MonitoringModuleProcessingStep(messager, monitoringModuleGenerator),
+        new MultibindingsProcessingStep(messager, multibindingsValidator),
         new ModuleProcessingStep(
             messager,
             moduleValidator,
@@ -193,11 +183,11 @@ public SourceVersion getSupportedSourceVersion() {
             provisionBindingFactory,
             factoryGenerator),
         new ComponentProcessingStep(
+            ComponentDescriptor.Kind.COMPONENT,
             messager,
             componentValidator,
             subcomponentValidator,
-            componentBuilderValidator,
-            subcomponentBuilderValidator,
+            builderValidator,
             componentHierarchyValidator,
             bindingGraphValidator,
             componentDescriptorFactory,
@@ -205,14 +195,16 @@ public SourceVersion getSupportedSourceVersion() {
             componentGenerator),
         new ProducerModuleProcessingStep(
             messager,
-            producerModuleValidator,
+            moduleValidator,
             producesMethodValidator,
             productionBindingFactory,
             producerFactoryGenerator),
-        new ProductionComponentProcessingStep(
+        new ComponentProcessingStep(
+            ComponentDescriptor.Kind.PRODUCTION_COMPONENT,
             messager,
-            productionComponentValidator,
-            productionComponentBuilderValidator,
+            componentValidator,
+            subcomponentValidator,
+            builderValidator,
             componentHierarchyValidator,
             bindingGraphValidator,
             componentDescriptorFactory,
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
index a9e82a8cf..0be4686a9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
@@ -19,6 +19,7 @@
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Optional;
+import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
@@ -26,8 +27,7 @@
 import com.google.common.collect.Multimap;
 import com.google.common.collect.Sets;
 import dagger.Component;
-import dagger.Module;
-import dagger.Subcomponent;
+import dagger.producers.ProductionComponent;
 import java.lang.annotation.Annotation;
 import java.util.Collection;
 import java.util.List;
@@ -56,14 +56,14 @@
 import static javax.lang.model.type.TypeKind.VOID;
 
 /**
- * Performs superficial validation of the contract of the {@link Component} annotation.
+ * Performs superficial validation of the contract of the {@link Component} and
+ * {@link ProductionComponent} annotations.
  *
  * @author Gregory Kick
  */
 final class ComponentValidator {
   private final Elements elements;
   private final Types types;
-  private final ComponentDescriptor.Kind componentType;
   private final ModuleValidator moduleValidator;
   private final ComponentValidator subcomponentValidator;
   private final BuilderValidator subcomponentBuilderValidator;
@@ -74,7 +74,6 @@ private ComponentValidator(Elements elements,
       BuilderValidator subcomponentBuilderValidator) {
     this.elements = elements;
     this.types = types;
-    this.componentType = ComponentDescriptor.Kind.SUBCOMPONENT;
     this.moduleValidator = moduleValidator;
     this.subcomponentValidator = this;
     this.subcomponentBuilderValidator = subcomponentBuilderValidator;
@@ -87,7 +86,6 @@ private ComponentValidator(Elements elements,
       BuilderValidator subcomponentBuilderValidator) {
     this.elements = elements;
     this.types = types;
-    this.componentType = ComponentDescriptor.Kind.COMPONENT;
     this.moduleValidator = moduleValidator;
     this.subcomponentValidator = subcomponentValidator;
     this.subcomponentBuilderValidator = subcomponentBuilderValidator;
@@ -98,21 +96,15 @@ static ComponentValidator createForComponent(Elements elements,
       ModuleValidator moduleValidator,
       ComponentValidator subcomponentValidator,
       BuilderValidator subcomponentBuilderValidator) {
-    return new ComponentValidator(elements,
-        types,
-        moduleValidator,
-        subcomponentValidator,
-        subcomponentBuilderValidator);
+    return new ComponentValidator(
+        elements, types, moduleValidator, subcomponentValidator, subcomponentBuilderValidator);
   }
 
   static ComponentValidator createForSubcomponent(Elements elements,
       Types types,
       ModuleValidator moduleValidator,
       BuilderValidator subcomponentBuilderValidator) {
-    return new ComponentValidator(elements,
-        types,
-        moduleValidator,
-        subcomponentBuilderValidator);
+    return new ComponentValidator(elements, types, moduleValidator, subcomponentBuilderValidator);
   }
 
   @AutoValue
@@ -130,20 +122,23 @@ public ComponentValidationReport validate(final TypeElement subject,
       Set<? extends Element> validatedSubcomponentBuilders) {
     ValidationReport.Builder<TypeElement> builder = ValidationReport.about(subject);
 
+    ComponentDescriptor.Kind componentKind =
+        ComponentDescriptor.Kind.forAnnotatedElement(subject).get();
+
     if (!subject.getKind().equals(INTERFACE)
         && !(subject.getKind().equals(CLASS) && subject.getModifiers().contains(ABSTRACT))) {
       builder.addError(
           String.format(
               "@%s may only be applied to an interface or abstract class",
-              componentType.annotationType().getSimpleName()),
+              componentKind.annotationType().getSimpleName()),
           subject);
     }
 
     ImmutableList<DeclaredType> builders =
-        enclosedBuilders(subject, componentType.builderAnnotationType());
+        enclosedBuilders(subject, componentKind.builderAnnotationType());
     if (builders.size() > 1) {
       builder.addError(
-          String.format(ErrorMessages.builderMsgsFor(componentType).moreThanOne(), builders),
+          String.format(ErrorMessages.builderMsgsFor(componentKind).moreThanOne(), builders),
           subject);
     }
 
@@ -164,12 +159,23 @@ public ComponentValidationReport validate(final TypeElement subject,
         // abstract methods are ones we have to implement, so they each need to be validated
         // first, check the return type.  if it's a subcomponent, validate that method as such.
         Optional<AnnotationMirror> subcomponentAnnotation =
-            checkForAnnotation(returnType, Subcomponent.class);
+            checkForAnnotations(
+                returnType,
+                FluentIterable.from(componentKind.subcomponentKinds())
+                    .transform(ComponentDescriptor.Kind.toAnnotationType())
+                    .toSet());
         Optional<AnnotationMirror> subcomponentBuilderAnnotation =
-            checkForAnnotation(returnType, Subcomponent.Builder.class);
+            checkForAnnotations(
+                returnType,
+                FluentIterable.from(componentKind.subcomponentKinds())
+                    .transform(ComponentDescriptor.Kind.toBuilderAnnotationType())
+                    .toSet());
         if (subcomponentAnnotation.isPresent()) {
           referencedSubcomponents.put(MoreTypes.asElement(returnType), method);
-          validateSubcomponentMethod(builder,
+          validateSubcomponentMethod(
+              builder,
+              ComponentDescriptor.Kind.forAnnotatedElement(MoreTypes.asTypeElement(returnType))
+                  .get(),
               method,
               parameters,
               parameterTypes,
@@ -224,9 +230,10 @@ public ComponentValidationReport validate(final TypeElement subject,
     }
 
     AnnotationMirror componentMirror =
-        getAnnotationMirror(subject, componentType.annotationType()).get();
+        getAnnotationMirror(subject, componentKind.annotationType()).get();
     ImmutableList<TypeMirror> moduleTypes = getComponentModules(componentMirror);
-    moduleValidator.validateReferencedModules(subject, builder, moduleTypes);
+    moduleValidator.validateReferencedModules(
+        subject, builder, moduleTypes, componentKind.moduleKinds());
 
     // Make sure we validate any subcomponents we're referencing, unless we know we validated
     // them already in this pass.
@@ -247,7 +254,9 @@ public ComponentValidationReport validate(final TypeElement subject,
         builder.build());
   }
 
-  private void validateSubcomponentMethod(final ValidationReport.Builder<TypeElement> builder,
+  private void validateSubcomponentMethod(
+      final ValidationReport.Builder<TypeElement> builder,
+      final ComponentDescriptor.Kind subcomponentKind,
       ExecutableElement method,
       List<? extends VariableElement> parameters,
       List<? extends TypeMirror> parameterTypes,
@@ -268,18 +277,26 @@ private void validateSubcomponentMethod(final ValidationReport.Builder<TypeEleme
     for (int i = 0; i < parameterTypes.size(); i++) {
       VariableElement parameter = parameters.get(i);
       TypeMirror parameterType = parameterTypes.get(i);
-      Optional<TypeElement> moduleType = parameterType.accept(
-          new SimpleTypeVisitor6<Optional<TypeElement>, Void>() {
-            @Override protected Optional<TypeElement> defaultAction(TypeMirror e, Void p) {
-              return Optional.absent();
-            }
+      Optional<TypeElement> moduleType =
+          parameterType.accept(
+              new SimpleTypeVisitor6<Optional<TypeElement>, Void>() {
+                @Override
+                protected Optional<TypeElement> defaultAction(TypeMirror e, Void p) {
+                  return Optional.absent();
+                }
 
-            @Override public Optional<TypeElement> visitDeclared(DeclaredType t, Void p) {
-              return MoreElements.isAnnotationPresent(t.asElement(), Module.class)
-                  ? Optional.of(MoreTypes.asTypeElement(t))
-                  : Optional.<TypeElement>absent();
-            }
-          }, null);
+                @Override
+                public Optional<TypeElement> visitDeclared(DeclaredType t, Void p) {
+                  for (ModuleDescriptor.Kind moduleKind : subcomponentKind.moduleKinds()) {
+                    if (MoreElements.isAnnotationPresent(
+                        t.asElement(), moduleKind.moduleAnnotation())) {
+                      return Optional.of(MoreTypes.asTypeElement(t));
+                    }
+                  }
+                  return Optional.absent();
+                }
+              },
+              null);
       if (moduleType.isPresent()) {
         if (variableTypes.contains(moduleType.get())) {
           builder.addError(
@@ -328,18 +345,27 @@ private void validateSubcomponentBuilderMethod(ValidationReport.Builder<TypeElem
     }
   }
 
-  private Optional<AnnotationMirror> checkForAnnotation(TypeMirror type,
-      final Class<? extends Annotation> annotation) {
-    return type.accept(new SimpleTypeVisitor6<Optional<AnnotationMirror>, Void>() {
-      @Override
-      protected Optional<AnnotationMirror> defaultAction(TypeMirror e, Void p) {
-        return Optional.absent();
-      }
+  private Optional<AnnotationMirror> checkForAnnotations(
+      TypeMirror type, final Set<Class<? extends Annotation>> annotations) {
+    return type.accept(
+        new SimpleTypeVisitor6<Optional<AnnotationMirror>, Void>() {
+          @Override
+          protected Optional<AnnotationMirror> defaultAction(TypeMirror e, Void p) {
+            return Optional.absent();
+          }
 
-      @Override
-      public Optional<AnnotationMirror> visitDeclared(DeclaredType t, Void p) {
-        return MoreElements.getAnnotationMirror(t.asElement(), annotation);
-      }
-    }, null);
+          @Override
+          public Optional<AnnotationMirror> visitDeclared(DeclaredType t, Void p) {
+            for (Class<? extends Annotation> annotation : annotations) {
+              Optional<AnnotationMirror> mirror =
+                  MoreElements.getAnnotationMirror(t.asElement(), annotation);
+              if (mirror.isPresent()) {
+                return mirror;
+              }
+            }
+            return Optional.absent();
+          }
+        },
+        null);
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
index 5221cf0a2..aeab5a746 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
@@ -15,13 +15,25 @@
  */
 package dagger.internal.codegen;
 
+import com.google.common.base.Function;
+import com.google.common.base.Joiner;
 import com.google.common.base.Predicate;
+import com.google.common.base.Splitter;
+import com.google.common.collect.ImmutableBiMap;
+import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.Iterables;
+import com.google.common.collect.Multimaps;
 import dagger.internal.codegen.writer.ClassName;
 import dagger.internal.codegen.writer.ClassWriter;
 import dagger.internal.codegen.writer.JavaWriter;
 import dagger.internal.codegen.writer.MethodWriter;
+import java.util.Collection;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
 import javax.annotation.Generated;
+import javax.lang.model.element.Name;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
@@ -35,7 +47,7 @@
 /**
  * Creates the implementation class for a component.
  */
-class ComponentWriter extends AbstractComponentWriter {
+final class ComponentWriter extends AbstractComponentWriter {
 
   ComponentWriter(
       Types types,
@@ -44,7 +56,89 @@
       Kind nullableValidationType,
       ClassName name,
       BindingGraph graph) {
-    super(types, elements, keyFactory, nullableValidationType, name, graph);
+    super(
+        types,
+        elements,
+        keyFactory,
+        nullableValidationType,
+        name,
+        graph,
+        new UniqueSubcomponentNamesGenerator(graph).generate());
+  }
+
+  /**
+   * Generates a map of unique simple names for all subcomponents, keyed by their {@link
+   * ComponentDescriptor}.
+   */
+  private static class UniqueSubcomponentNamesGenerator {
+
+    private static final Splitter QUALIFIED_NAME_SPLITTER = Splitter.on('.');
+    private static final Joiner QUALIFIED_NAME_JOINER = Joiner.on('_');
+
+    private final BindingGraph graph;
+    private final ImmutableListMultimap<String, ComponentDescriptor>
+        componentDescriptorsBySimpleName;
+    private final ImmutableListMultimap<ComponentDescriptor, String> componentQualifiedNamePieces;
+
+    private UniqueSubcomponentNamesGenerator(BindingGraph graph) {
+      this.graph = graph;
+      componentDescriptorsBySimpleName =
+          Multimaps.index(
+              graph.componentDescriptors(),
+              new Function<ComponentDescriptor, String>() {
+                @Override
+                public String apply(ComponentDescriptor componentDescriptor) {
+                  return componentDescriptor.componentDefinitionType().getSimpleName().toString();
+                }
+              });
+      componentQualifiedNamePieces = qualifiedNames(graph.componentDescriptors());
+    }
+
+    private ImmutableBiMap<ComponentDescriptor, String> generate() {
+      Map<ComponentDescriptor, String> subcomponentImplSimpleNames = new LinkedHashMap<>();
+      for (Entry<String, Collection<ComponentDescriptor>> componentEntry :
+          componentDescriptorsBySimpleName.asMap().entrySet()) {
+        Collection<ComponentDescriptor> components = componentEntry.getValue();
+        subcomponentImplSimpleNames.putAll(disambiguateConflictingSimpleNames(components));
+      }
+      subcomponentImplSimpleNames.remove(graph.componentDescriptor());
+      return ImmutableBiMap.copyOf(subcomponentImplSimpleNames);
+    }
+
+    private ImmutableBiMap<ComponentDescriptor, String> disambiguateConflictingSimpleNames(
+        Collection<ComponentDescriptor> components) {
+      Map<String, ComponentDescriptor> generatedSimpleNames = new LinkedHashMap<>();
+      // The ending condition is when there is a unique simple name generated for every element
+      // in components. The sizes should be equivalent (with one generated name per component).
+      for (int levels = 0; generatedSimpleNames.size() != components.size(); levels++) {
+        generatedSimpleNames.clear();
+        for (ComponentDescriptor component : components) {
+          List<String> pieces = componentQualifiedNamePieces.get(component);
+          String simpleName =
+              QUALIFIED_NAME_JOINER.join(
+                      pieces.subList(Math.max(0, pieces.size() - levels - 1), pieces.size()))
+                  + "Impl";
+          ComponentDescriptor conflict = generatedSimpleNames.put(simpleName, component);
+          if (conflict != null) {
+            // if the map previously contained an entry for the same simple name, stop early since
+            // 2+ subcomponent descriptors will have the same simple name
+            break;
+          }
+        }
+      }
+      return ImmutableBiMap.copyOf(generatedSimpleNames).inverse();
+    }
+
+    private static ImmutableListMultimap<ComponentDescriptor, String> qualifiedNames(
+        Iterable<ComponentDescriptor> componentDescriptors) {
+      ImmutableListMultimap.Builder<ComponentDescriptor, String> builder =
+          ImmutableListMultimap.builder();
+      for (ComponentDescriptor component : componentDescriptors) {
+        Name qualifiedName = component.componentDefinitionType().getQualifiedName();
+        builder.putAll(component, QUALIFIED_NAME_SPLITTER.split(qualifiedName));
+      }
+      return builder.build();
+    }
   }
 
   @Override
@@ -53,7 +147,6 @@ protected ClassWriter createComponentClass() {
     javaWriters.add(javaWriter);
 
     ClassWriter componentWriter = javaWriter.addClass(name.simpleName());
-    componentWriter.annotate(Generated.class).setValue(ComponentProcessor.class.getCanonicalName());
     componentWriter.addModifiers(PUBLIC, FINAL);
     componentWriter.setSupertype(componentDefinitionType());
     return componentWriter;
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
index 831943f2a..dbe84067d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
@@ -21,19 +21,16 @@
 import com.google.common.base.Function;
 import com.google.common.base.Optional;
 import com.google.common.base.Predicate;
-import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.ImmutableSetMultimap;
-import com.google.common.collect.Iterables;
 import com.google.common.collect.Multimaps;
-import com.google.common.collect.Ordering;
 import com.google.common.collect.Sets;
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.Component;
 import dagger.MapKey;
 import dagger.Provides;
+import dagger.internal.codegen.ContributionType.HasContributionType;
 import dagger.producers.Produces;
 import dagger.producers.ProductionComponent;
-import java.util.EnumSet;
 import java.util.Set;
 import javax.inject.Inject;
 import javax.lang.model.element.AnnotationMirror;
@@ -41,8 +38,6 @@
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
 
-import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static dagger.internal.codegen.MapKeys.getMapKey;
 import static dagger.internal.codegen.MapKeys.unwrapValue;
 import static javax.lang.model.element.Modifier.STATIC;
@@ -54,8 +49,8 @@
  * @author Jesse Beder
  * @since 2.0
  */
-abstract class ContributionBinding extends Binding {
-  
+abstract class ContributionBinding extends Binding implements HasContributionType {
+
   @Override
   Set<DependencyRequest> implicitDependencies() {
     // Optimization: If we don't need the memberInjectionRequest, don't create more objects.
@@ -66,33 +61,6 @@
       return Sets.union(membersInjectionRequest().asSet(), dependencies());
     }
   }
-
-  static enum ContributionType {
-    /** Represents map bindings. */
-    MAP,
-    /** Represents set bindings. */
-    SET,
-    /** Represents a valid non-collection binding. */
-    UNIQUE;
-
-    boolean isMultibinding() {
-      return !this.equals(UNIQUE);
-    }
-  }
-
-  ContributionType contributionType() {
-    switch (provisionType()) {
-      case SET:
-      case SET_VALUES:
-        return ContributionType.SET;
-      case MAP:
-        return ContributionType.MAP;
-      case UNIQUE:
-        return ContributionType.UNIQUE;
-      default:
-        throw new AssertionError("Unknown provision type: " + provisionType());
-    }
-  }
   
   /** Returns the type that specifies this' nullability, absent if not nullable. */
   abstract Optional<DeclaredType> nullableType();
@@ -103,14 +71,16 @@ ContributionType contributionType() {
    * binding's enclosed element, as this will return the subclass whereas the enclosed element will
    * be the superclass.
    */
-  abstract Optional<TypeElement> contributedBy();
+  Optional<TypeElement> contributedBy() {
+    return sourceElement().contributedBy();
+  }
 
   /**
    * Returns whether this binding is synthetic, i.e., not explicitly tied to code, but generated
    * implicitly by the framework.
    */
   boolean isSyntheticBinding() {
-    return bindingKind().equals(Kind.SYNTHETIC);
+    return bindingKind().equals(Kind.SYNTHETIC_MAP);
   }
 
   /** If this provision requires members injection, this will be the corresponding request. */
@@ -122,10 +92,10 @@ boolean isSyntheticBinding() {
    */
   enum Kind {
     /**
-     * A binding that is not explicitly tied to an element, but generated implicitly by the
-     * framework.
+     * The synthetic binding for {@code Map<K, V>} that depends on either
+     * {@code Map<K, Provider<V>>} or {@code Map<K, Producer<V>>}.
      */
-    SYNTHETIC,
+    SYNTHETIC_MAP,
 
     // Provision kinds
 
@@ -182,6 +152,11 @@ public boolean apply(ContributionBinding binding) {
   /** The provision type that was used to bind the key. */
   abstract Provides.Type provisionType();
 
+  @Override
+  public ContributionType contributionType() {
+    return ContributionType.forProvisionType(provisionType());
+  }
+
   /**
    * The strategy for getting an instance of a factory for a {@link ContributionBinding}.
    */
@@ -214,41 +189,6 @@ FactoryCreationStrategy factoryCreationStrategy() {
     }
   }
 
-  /**
-   * Returns the {@link ContributionType}s represented by a given {@link ContributionBinding}
-   * collection.
-   */
-  static <B extends ContributionBinding>
-      ImmutableListMultimap<ContributionType, B> contributionTypesFor(
-          Iterable<? extends B> bindings) {
-    ImmutableListMultimap.Builder<ContributionType, B> builder = ImmutableListMultimap.builder();
-    builder.orderKeysBy(Ordering.<ContributionType>natural());
-    for (B binding : bindings) {
-      builder.put(binding.contributionType(), binding);
-    }
-    return builder.build();
-  }
-
-  /**
-   * Returns a single {@link ContributionType} represented by a given collection of
-   * {@link ContributionBinding}s.
-   *
-   * @throws IllegalArgumentException if the given bindings are not all of one type
-   */
-  static ContributionType contributionTypeFor(Iterable<ContributionBinding> bindings) {
-    checkNotNull(bindings);
-    checkArgument(!Iterables.isEmpty(bindings), "no bindings");
-    Set<ContributionType> types = EnumSet.noneOf(ContributionType.class);
-    for (ContributionBinding binding : bindings) {
-      types.add(binding.contributionType());
-    }
-    if (types.size() > 1) {
-      throw new IllegalArgumentException(
-          String.format(ErrorMessages.MULTIPLE_CONTRIBUTION_TYPES_FORMAT, types));
-    }
-    return Iterables.getOnlyElement(types);
-  }
-
   /**
    * Indexes map-multibindings by map key (the result of calling
    * {@link AnnotationValue#getValue()} on a single member or the whole {@link AnnotationMirror}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionBindingFormatter.java b/compiler/src/main/java/dagger/internal/codegen/ContributionBindingFormatter.java
deleted file mode 100644
index 0d267619b..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/ContributionBindingFormatter.java
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import com.google.common.base.Optional;
-
-import static com.google.auto.common.MoreElements.asExecutable;
-import static com.google.auto.common.MoreTypes.asDeclared;
-
-/**
- * Formats a {@link ContributionBinding} into a {@link String} suitable for use in error messages.
- *
- * @author Christian Gruber
- * @since 2.0
- */
-final class ContributionBindingFormatter extends Formatter<ContributionBinding> {
-  private final MethodSignatureFormatter methodSignatureFormatter;
-  
-  ContributionBindingFormatter(MethodSignatureFormatter methodSignatureFormatter) { 
-    this.methodSignatureFormatter = methodSignatureFormatter;
-  }
-
-  @Override public String format(ContributionBinding binding) {
-    switch (binding.bindingKind()) {
-      case COMPONENT_PROVISION:
-      case COMPONENT_PRODUCTION:
-        return methodSignatureFormatter.format(asExecutable(binding.bindingElement()));
-
-      case PROVISION:
-      case SUBCOMPONENT_BUILDER:
-      case IMMEDIATE:
-      case FUTURE_PRODUCTION:
-        return methodSignatureFormatter.format(
-            asExecutable(binding.bindingElement()),
-            Optional.of(asDeclared(binding.contributedBy().get().asType())));
-
-      default:
-        throw new UnsupportedOperationException(
-            "Not yet supporting " + binding.bindingKind() + " binding types.");
-    }
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionType.java b/compiler/src/main/java/dagger/internal/codegen/ContributionType.java
new file mode 100644
index 000000000..a1033932a
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionType.java
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.base.Function;
+import com.google.common.collect.ImmutableListMultimap;
+import com.google.common.collect.Multimaps;
+
+/**
+ * Whether a binding or declaration is for a unique contribution or a map or set multibinding.
+ */
+enum ContributionType {
+  /** Represents map bindings. */
+  MAP,
+  /** Represents set bindings. */
+  SET,
+  /** Represents a valid non-collection binding. */
+  UNIQUE,
+  ;
+
+  /**
+   * An object that is associated with a {@link ContributionType}.
+   */
+  interface HasContributionType {
+
+    /** The contribution type of this object. */
+    ContributionType contributionType();
+  }
+
+  /**
+   * {@code true} if this is for a multibinding.
+   */
+  boolean isMultibinding() {
+    return !this.equals(UNIQUE);
+  }
+
+  /** The contribution type for a given provision type. */
+  static ContributionType forProvisionType(dagger.Provides.Type provisionType) {
+    switch (provisionType) {
+      case SET:
+      case SET_VALUES:
+        return SET;
+      case MAP:
+        return MAP;
+      case UNIQUE:
+        return UNIQUE;
+      default:
+        throw new AssertionError("Unknown provision type: " + provisionType);
+    }
+  }
+
+  /** Indexes objects by their contribution type. */
+  static <T extends HasContributionType>
+      ImmutableListMultimap<ContributionType, T> indexByContributionType(
+          Iterable<T> haveContributionTypes) {
+    return Multimaps.index(
+        haveContributionTypes,
+        new Function<HasContributionType, ContributionType>() {
+          @Override
+          public ContributionType apply(HasContributionType hasContributionType) {
+            return hasContributionType.contributionType();
+          }
+        });
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
index 49fcd9c9b..453215667 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -39,10 +39,12 @@
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.ErrorType;
 import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
+import javax.lang.model.util.SimpleTypeVisitor7;
 
 import static com.google.auto.common.MoreTypes.isTypeOf;
 import static com.google.common.base.Preconditions.checkArgument;
@@ -71,26 +73,43 @@
   enum Kind {
     /** A default request for an instance.  E.g.: {@code Blah} */
     INSTANCE,
+    
     /** A request for a {@link Provider}.  E.g.: {@code Provider<Blah>} */
-    PROVIDER,
+    PROVIDER(Provider.class),
+    
     /** A request for a {@link Lazy}.  E.g.: {@code Lazy<Blah>} */
-    LAZY,
+    LAZY(Lazy.class),
+    
     /** A request for a {@link MembersInjector}.  E.g.: {@code MembersInjector<Blah>} */
-    MEMBERS_INJECTOR,
+    MEMBERS_INJECTOR(MembersInjector.class),
+    
     /** A request for a {@link Producer}.  E.g.: {@code Producer<Blah>} */
-    PRODUCER,
+    PRODUCER(Producer.class),
+    
     /** A request for a {@link Produced}.  E.g.: {@code Produced<Blah>} */
-    PRODUCED,
+    PRODUCED(Produced.class),
+    
     /**
      * A request for a {@link ListenableFuture}.  E.g.: {@code ListenableFuture<Blah>}.
      * These can only be requested by component interfaces.
      */
     FUTURE,
+    ;
+
+    final Optional<Class<?>> frameworkClass;
+
+    Kind(Class<?> frameworkClass) {
+      this.frameworkClass = Optional.<Class<?>>of(frameworkClass);
+    }
+
+    Kind() {
+      this.frameworkClass = Optional.absent();
+    }
   }
 
   abstract Kind kind();
   abstract Key key();
-
+  
   BindingKey bindingKey() {
     switch (kind()) {
       case INSTANCE:
@@ -329,40 +348,44 @@ private DependencyRequest newDependencyRequest(
     }
 
     /**
-     * Extracts the correct requesting type & kind out a request type. For example, if a user
-     * requests {@code Provider<Foo>}, this will return ({@link Kind#PROVIDER}, {@code Foo}).
+     * Extracts the dependency request type and kind from the type of a dependency request element.
+     * For example, if a user requests {@code Provider<Foo>}, this will return
+     * ({@link Kind#PROVIDER}, {@code Foo}).
      *
      * @throws TypeNotPresentException if {@code type}'s kind is {@link TypeKind#ERROR}, which may
      *     mean that the type will be generated in a later round of processing
      */
     static KindAndType extractKindAndType(TypeMirror type) {
-      if (type.getKind().equals(TypeKind.ERROR)) {
-        throw new TypeNotPresentException(type.toString(), null);
-      }
+      return type.accept(
+          new SimpleTypeVisitor7<KindAndType, Void>() {
+            @Override
+            public KindAndType visitError(ErrorType errorType, Void p) {
+              throw new TypeNotPresentException(errorType.toString(), null);
+            }
 
-      // We must check TYPEVAR explicitly before the below checks because calling
-      // isTypeOf(..) on a TYPEVAR throws an exception (because it can't be
-      // represented as a Class).
-      if (type.getKind().equals(TypeKind.TYPEVAR)) {
-        return new AutoValue_DependencyRequest_Factory_KindAndType(Kind.INSTANCE, type);
-      } else if (isTypeOf(Provider.class, type)) {
-        return new AutoValue_DependencyRequest_Factory_KindAndType(Kind.PROVIDER,
-            Iterables.getOnlyElement(((DeclaredType) type).getTypeArguments()));
-      } else if (isTypeOf(Lazy.class, type)) {
-        return new AutoValue_DependencyRequest_Factory_KindAndType(Kind.LAZY,
-            Iterables.getOnlyElement(((DeclaredType) type).getTypeArguments()));
-      } else if (isTypeOf(MembersInjector.class, type)) {
-        return new AutoValue_DependencyRequest_Factory_KindAndType(Kind.MEMBERS_INJECTOR,
-            Iterables.getOnlyElement(((DeclaredType) type).getTypeArguments()));
-      } else if (isTypeOf(Producer.class, type)) {
-        return new AutoValue_DependencyRequest_Factory_KindAndType(Kind.PRODUCER,
-            Iterables.getOnlyElement(((DeclaredType) type).getTypeArguments()));
-      } else if (isTypeOf(Produced.class, type)) {
-        return new AutoValue_DependencyRequest_Factory_KindAndType(Kind.PRODUCED,
-            Iterables.getOnlyElement(((DeclaredType) type).getTypeArguments()));
-      } else {
-        return new AutoValue_DependencyRequest_Factory_KindAndType(Kind.INSTANCE, type);
-      }
+            @Override
+            public KindAndType visitExecutable(ExecutableType executableType, Void p) {
+              return executableType.getReturnType().accept(this, null);
+            }
+
+            @Override
+            public KindAndType visitDeclared(DeclaredType declaredType, Void p) {
+              for (Kind kind : Kind.values()) {
+                if (kind.frameworkClass.isPresent()
+                    && isTypeOf(kind.frameworkClass.get(), declaredType)) {
+                  return new AutoValue_DependencyRequest_Factory_KindAndType(
+                      kind, Iterables.getOnlyElement(declaredType.getTypeArguments()));
+                }
+              }
+              return defaultAction(declaredType, p);
+            }
+
+            @Override
+            protected KindAndType defaultAction(TypeMirror otherType, Void p) {
+              return new AutoValue_DependencyRequest_Factory_KindAndType(Kind.INSTANCE, otherType);
+            }
+          },
+          null);
     }
 
     static DeclaredType getEnclosingType(Element element) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyVariableNamer.java b/compiler/src/main/java/dagger/internal/codegen/DependencyVariableNamer.java
index 5ba5635cd..b12a854d9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyVariableNamer.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyVariableNamer.java
@@ -16,6 +16,7 @@
 package dagger.internal.codegen;
 
 import com.google.common.base.Ascii;
+import com.google.common.base.CaseFormat;
 import com.google.common.base.Function;
 import dagger.Lazy;
 import javax.inject.Provider;
@@ -37,12 +38,15 @@ public String apply(DependencyRequest dependency) {
       return dependency.overriddenVariableName().get();
     }
     String variableName = dependency.requestElement().getSimpleName().toString();
+    if (Ascii.isUpperCase(variableName.charAt(0))) {
+      variableName = toLowerCamel(variableName);
+    }
     switch (dependency.kind()) {
       case INSTANCE:
         return variableName;
       case LAZY:
         return variableName.startsWith("lazy") && !variableName.equals("lazy")
-            ? Ascii.toLowerCase(variableName.charAt(4)) + variableName.substring(5)
+            ? toLowerCamel(variableName.substring(4))
             : variableName;
       case PROVIDER:
         return variableName.endsWith("Provider") && !variableName.equals("Provider")
@@ -54,7 +58,7 @@ public String apply(DependencyRequest dependency) {
             : variableName;
       case PRODUCED:
         return variableName.startsWith("produced") && !variableName.equals("produced")
-            ? Ascii.toLowerCase(variableName.charAt(8)) + variableName.substring(9)
+            ? toLowerCamel(variableName.substring(8))
             : variableName;
       case PRODUCER:
         return variableName.endsWith("Producer") && !variableName.equals("Producer")
@@ -64,4 +68,8 @@ public String apply(DependencyRequest dependency) {
         throw new AssertionError();
     }
   }
+
+  private String toLowerCamel(String name) {
+    return CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL, name);
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index 1f52aca98..f18318572 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -15,6 +15,7 @@
  */
 package dagger.internal.codegen;
 
+import dagger.Multibindings;
 import dagger.Provides;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
@@ -112,6 +113,9 @@ static String inconsistentMapKeyAnnotationsError(String key) {
   static final String PROVIDES_METHOD_RETURN_TYPE =
       "@Provides methods must either return a primitive, an array or a declared type.";
 
+  static final String PROVIDES_METHOD_THROWS =
+      "@Provides methods may only throw unchecked exceptions";
+
   static final String PRODUCES_METHOD_RETURN_TYPE =
       "@Produces methods must either return a primitive, an array or a declared type, or a"
       + " ListenableFuture of one of those types.";
@@ -128,6 +132,9 @@ static String inconsistentMapKeyAnnotationsError(String key) {
   static final String PRODUCES_METHOD_SET_VALUES_RETURN_SET =
       "@Produces methods of type set values must return a Set or ListenableFuture of Set";
 
+  static final String PRODUCES_METHOD_THROWS =
+      "@Produces methods may only throw unchecked exceptions or exceptions subclassing Exception";
+
   static final String BINDING_METHOD_MUST_RETURN_A_VALUE =
       "@%s methods must return a value (not void).";
 
@@ -189,7 +196,7 @@ static String inconsistentMapKeyAnnotationsError(String key) {
       "More than one binding present of different types %s";
 
   static final String MULTIPLE_BINDING_TYPES_FOR_KEY_FORMAT =
-      "%s has incompatible bindings:\n";
+      "%s has incompatible bindings or declarations:\n";
 
   static final String PROVIDER_ENTRY_POINT_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT =
       "%s is a provision entry-point, which cannot depend on a production.";
@@ -387,6 +394,30 @@ String moreThanOneRefToSubcomponent() {
     }
   }
 
+  /** Error messages related to {@link Multibindings @Multibindings}. */
+  static final class MultibindingsMessages {
+    static final String MUST_BE_INTERFACE = "@Multibindings can be applied only to interfaces";
+
+    static final String MUST_NOT_HAVE_TYPE_PARAMETERS =
+        "@Multibindings types must not have type parameters";
+
+    static final String MUST_BE_IN_MODULE =
+        "@Multibindings types must be nested within a @Module or @ProducerModule";
+
+    static final String METHOD_MUST_RETURN_MAP_OR_SET =
+        "@Multibindings methods must return Map<K, V> or Set<T>";
+
+    static final String TOO_MANY_QUALIFIERS =
+        "Cannot use more than one @Qualifier on a method in an @Multibindings type";
+
+    static String tooManyMethodsForKey(String formattedKey) {
+      return String.format(
+          "Too many @Multibindings methods for %s", stripCommonTypePrefixes(formattedKey));
+    }
+
+    private MultibindingsMessages() {}
+  }
+
   /**
    * A regular expression to match a small list of specific packages deemed to
    * be unhelpful to display in fully qualified types in error messages.
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index a0a48c81e..65419786a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -21,8 +21,6 @@
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Lists;
-import dagger.MembersInjector;
-import dagger.Provides.Type;
 import dagger.internal.Factory;
 import dagger.internal.codegen.writer.ClassName;
 import dagger.internal.codegen.writer.ClassWriter;
@@ -44,10 +42,12 @@
 import javax.annotation.Generated;
 import javax.annotation.processing.Filer;
 import javax.inject.Inject;
+import javax.inject.Provider;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeParameterElement;
 import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
 import javax.tools.Diagnostic;
 
 import static com.google.common.base.Preconditions.checkState;
@@ -74,9 +74,12 @@
   private final DependencyRequestMapper dependencyRequestMapper;
   private final Diagnostic.Kind nullableValidationType;
 
-  FactoryGenerator(Filer filer, DependencyRequestMapper dependencyRequestMapper,
+  FactoryGenerator(
+      Filer filer,
+      Elements elements,
+      DependencyRequestMapper dependencyRequestMapper,
       Diagnostic.Kind nullableValidationType) {
-    super(filer);
+    super(filer, elements);
     this.dependencyRequestMapper = dependencyRequestMapper;
     this.nullableValidationType = nullableValidationType;
   }
@@ -99,11 +102,12 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
   @Override
   ImmutableSet<JavaWriter> write(ClassName generatedTypeName, ProvisionBinding binding) {
     // We don't want to write out resolved bindings -- we want to write out the generic version.
-    checkState(!binding.hasNonDefaultTypeParameters());
+    checkState(!binding.unresolved().isPresent());
 
-    TypeMirror keyType = binding.provisionType().equals(Type.MAP)
-        ? Util.getProvidedValueTypeOfMap(MoreTypes.asDeclared(binding.key().type()))
-        : binding.key().type();
+    TypeMirror keyType =
+        binding.contributionType().equals(ContributionType.MAP)
+            ? MapType.from(binding.key().type()).unwrappedValueType(Provider.class)
+            : binding.key().type();
     TypeName providedTypeName = TypeNames.forTypeMirror(keyType);
     JavaWriter writer = JavaWriter.inPackage(generatedTypeName.packageName());
 
@@ -147,7 +151,6 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
         throw new AssertionError();
     }
 
-    factoryWriter.annotate(Generated.class).setValue(ComponentProcessor.class.getName());
     factoryWriter.addModifiers(PUBLIC);
     factoryWriter.addImplementedType(
         ParameterizedTypeName.create(ClassName.fromClass(Factory.class), providedTypeName));
@@ -156,19 +159,8 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
     getMethodWriter.annotate(Override.class);
     getMethodWriter.addModifiers(PUBLIC);
 
-    if (binding.membersInjectionRequest().isPresent()) {
-      ParameterizedTypeName membersInjectorType = ParameterizedTypeName.create(
-          MembersInjector.class, providedTypeName);
-      factoryWriter.addField(membersInjectorType, "membersInjector").addModifiers(PRIVATE, FINAL);
-      constructorWriter.get().addParameter(membersInjectorType, "membersInjector");
-      constructorWriter.get().body()
-          .addSnippet("assert membersInjector != null;")
-          .addSnippet("this.membersInjector = membersInjector;");
-    }
-
     ImmutableMap<BindingKey, FrameworkField> fields =
-        SourceFiles.generateBindingFieldsForDependencies(
-            dependencyRequestMapper, binding.dependencies());
+        SourceFiles.generateBindingFieldsForDependencies(dependencyRequestMapper, binding);
 
     for (FrameworkField bindingField : fields.values()) {
       TypeName fieldType = bindingField.frameworkType();
@@ -265,7 +257,11 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
     } else if (binding.membersInjectionRequest().isPresent()) {
       getMethodWriter.body().addSnippet("%1$s instance = new %1$s(%2$s);",
           providedTypeName, parametersSnippet);
-      getMethodWriter.body().addSnippet("membersInjector.injectMembers(instance);");
+      getMethodWriter
+          .body()
+          .addSnippet(
+              "%s.injectMembers(instance);",
+              fields.get(binding.membersInjectionRequest().get().bindingKey()).name());
       getMethodWriter.body().addSnippet("return instance;");
     } else {
       getMethodWriter.body()
diff --git a/compiler/src/main/java/dagger/internal/codegen/Formatter.java b/compiler/src/main/java/dagger/internal/codegen/Formatter.java
index 880b78705..93f88bee1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Formatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Formatter.java
@@ -16,6 +16,10 @@
 package dagger.internal.codegen;
 
 import com.google.common.base.Function;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.Iterables;
+
+import static dagger.internal.codegen.ErrorMessages.INDENT;
 
 /**
  * A formatter which transforms an instance of a particular type into a string
@@ -45,4 +49,48 @@
   @Override final public String apply(T object) {
     return format(object);
   }
+
+  /**
+   * Formats {@code items}, one per line.
+   */
+  public void formatIndentedList(
+      StringBuilder builder, Iterable<? extends T> items, int indentLevel) {
+    formatIndentedList(builder, indentLevel, items, ImmutableList.<T>of());
+  }
+
+  /**
+   * Formats {@code items}, one per line. Stops after {@code limit} items.
+   */
+  public void formatIndentedList(
+      StringBuilder builder, Iterable<? extends T> items, int indentLevel, int limit) {
+    formatIndentedList(
+        builder, indentLevel, Iterables.limit(items, limit), Iterables.skip(items, limit));
+  }
+
+  private void formatIndentedList(
+      StringBuilder builder,
+      int indentLevel,
+      Iterable<? extends T> firstItems,
+      Iterable<? extends T> restOfItems) {
+    for (T item : firstItems) {
+      builder.append('\n');
+      appendIndent(builder, indentLevel);
+      builder.append(format(item));
+    }
+    int numberOfOtherItems = Iterables.size(restOfItems);
+    if (numberOfOtherItems > 0) {
+      builder.append('\n');
+      appendIndent(builder, indentLevel);
+      builder.append("and ").append(numberOfOtherItems).append(" other");
+    }
+    if (numberOfOtherItems > 1) {
+      builder.append('s');
+    }
+  }
+
+  private void appendIndent(StringBuilder builder, int indentLevel) {
+    for (int i = 0; i < indentLevel; i++) {
+      builder.append(INDENT);
+    }
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java b/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
index 38e8f026a..13950bc9b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
@@ -15,23 +15,17 @@
  */
 package dagger.internal.codegen;
 
-import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.CaseFormat;
-import com.google.common.collect.ImmutableSet;
-import dagger.MembersInjector;
 import dagger.internal.codegen.writer.ClassName;
 import dagger.internal.codegen.writer.ParameterizedTypeName;
 import dagger.internal.codegen.writer.TypeNames;
 import javax.lang.model.element.ElementVisitor;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementKindVisitor6;
 
-import static com.google.common.collect.Iterables.any;
 import static com.google.common.collect.Iterables.getOnlyElement;
-import static dagger.internal.codegen.ContributionBinding.contributionTypeFor;
 
 /**
  * A value object that represents a field used by Dagger-generated code.
@@ -40,26 +34,20 @@
  * @since 2.0
  */
 @AutoValue
+// TODO(gak): Reexamine the this class and how consistently we're using it and its creation methods.
 abstract class FrameworkField {
-  // TODO(gak): reexamine the this class and how consistently we're using it and its creation
-  // methods
-  static FrameworkField createWithTypeFromKey(
-      Class<?> frameworkClass, BindingKey bindingKey, String name) {
+  static FrameworkField createWithTypeFromKey(Class<?> frameworkClass, Key key, String name) {
     String suffix = frameworkClass.getSimpleName();
-    ParameterizedTypeName frameworkType = ParameterizedTypeName.create(
-        ClassName.fromClass(frameworkClass),
-        TypeNames.forTypeMirror(bindingKey.key().type()));
-    return new AutoValue_FrameworkField(frameworkClass, frameworkType, bindingKey,
-        name.endsWith(suffix) ? name : name + suffix);
+    ParameterizedTypeName frameworkType =
+        ParameterizedTypeName.create(
+            ClassName.fromClass(frameworkClass), TypeNames.forTypeMirror(key.type()));
+    return new AutoValue_FrameworkField(
+        frameworkType, name.endsWith(suffix) ? name : name + suffix);
   }
 
-  private static FrameworkField createForMapBindingContribution(
-      Class<?> frameworkClass, BindingKey bindingKey, String name) {
-    TypeMirror mapValueType =
-        MoreTypes.asDeclared(bindingKey.key().type()).getTypeArguments().get(1);
-    return new AutoValue_FrameworkField(frameworkClass,
-        (ParameterizedTypeName) TypeNames.forTypeMirror(mapValueType),
-        bindingKey,
+  private static FrameworkField createForMapBindingContribution(Key key, String name) {
+    return new AutoValue_FrameworkField(
+        (ParameterizedTypeName) TypeNames.forTypeMirror(MapType.from(key.type()).valueType()),
         name);
   }
 
@@ -68,8 +56,7 @@ static FrameworkField createForSyntheticContributionBinding(
     switch (contributionBinding.contributionType()) {
       case MAP:
         return createForMapBindingContribution(
-            contributionBinding.frameworkClass(),
-            contributionBinding.bindingKey(),
+            contributionBinding.key(),
             KeyVariableNamer.INSTANCE.apply(contributionBinding.key())
                 + "Contribution"
                 + contributionNumber);
@@ -78,7 +65,7 @@ static FrameworkField createForSyntheticContributionBinding(
       case UNIQUE:
         return createWithTypeFromKey(
             contributionBinding.frameworkClass(),
-            contributionBinding.bindingKey(),
+            contributionBinding.key(),
             KeyVariableNamer.INSTANCE.apply(contributionBinding.key())
                 + "Contribution"
                 + contributionNumber);
@@ -88,42 +75,22 @@ static FrameworkField createForSyntheticContributionBinding(
   }
 
   static FrameworkField createForResolvedBindings(ResolvedBindings resolvedBindings) {
+    return createWithTypeFromKey(
+        resolvedBindings.frameworkClass(),
+        resolvedBindings.bindingKey().key(),
+        frameworkFieldName(resolvedBindings));
+  }
+
+  private static String frameworkFieldName(ResolvedBindings resolvedBindings) {
     BindingKey bindingKey = resolvedBindings.bindingKey();
-    switch (bindingKey.kind()) {
-      case CONTRIBUTION:
-        ImmutableSet<ContributionBinding> contributionBindings =
-            resolvedBindings.contributionBindings();
-        switch (contributionTypeFor(contributionBindings)) {
-          case SET:
-          case MAP:
-            return createWithTypeFromKey(
-                FrameworkField.frameworkClassForResolvedBindings(resolvedBindings),
-                bindingKey,
-                KeyVariableNamer.INSTANCE.apply(bindingKey.key()));
-          case UNIQUE:
-            ContributionBinding binding = getOnlyElement(contributionBindings);
-            return createWithTypeFromKey(
-                FrameworkField.frameworkClassForResolvedBindings(resolvedBindings),
-                bindingKey,
-                BINDING_ELEMENT_NAME.visit(binding.bindingElement()));
-          default:
-            throw new AssertionError();
-        }
-      case MEMBERS_INJECTION:
-        return createWithTypeFromKey(
-            MembersInjector.class,
-            bindingKey,
-            CaseFormat.UPPER_CAMEL.to(
-                CaseFormat.LOWER_CAMEL,
-                resolvedBindings
-                    .membersInjectionBinding()
-                    .get()
-                    .bindingElement()
-                    .getSimpleName()
-                    .toString()));
-      default:
-        throw new AssertionError();
+    if (bindingKey.kind().equals(BindingKey.Kind.CONTRIBUTION)
+        && resolvedBindings.contributionType().equals(ContributionType.UNIQUE)) {
+      ContributionBinding binding = getOnlyElement(resolvedBindings.contributionBindings());
+      if (!binding.bindingKind().equals(ContributionBinding.Kind.SYNTHETIC_MAP)) {
+        return BINDING_ELEMENT_NAME.visit(binding.bindingElement());
+      }
     }
+    return KeyVariableNamer.INSTANCE.apply(bindingKey.key());
   }
 
   private static final ElementVisitor<String, Void> BINDING_ELEMENT_NAME =
@@ -145,21 +112,6 @@ public String visitType(TypeElement e, Void p) {
         }
       };
 
-  static Class<?> frameworkClassForResolvedBindings(ResolvedBindings resolvedBindings) {
-    switch (resolvedBindings.bindingKey().kind()) {
-      case CONTRIBUTION:
-        return any(resolvedBindings.contributionBindings(), Binding.Type.PRODUCTION)
-            ? Binding.Type.PRODUCTION.frameworkClass()
-            : Binding.Type.PROVISION.frameworkClass();
-      case MEMBERS_INJECTION:
-        return MembersInjector.class;
-      default:
-        throw new AssertionError();
-    }
-  }
-
-  abstract Class<?> frameworkClass();
   abstract ParameterizedTypeName frameworkType();
-  abstract BindingKey bindingKey();
   abstract String name();
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/HasSourceElementFormatter.java b/compiler/src/main/java/dagger/internal/codegen/HasSourceElementFormatter.java
new file mode 100644
index 000000000..d73930aee
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/HasSourceElementFormatter.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
+import com.google.common.base.Optional;
+import dagger.internal.codegen.SourceElement.HasSourceElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeKind;
+
+import static com.google.common.base.Preconditions.checkArgument;
+
+/**
+ * Formats a {@link HasSourceElement} into a {@link String} suitable for use in error messages.
+ */
+final class HasSourceElementFormatter extends Formatter<HasSourceElement> {
+  private final MethodSignatureFormatter methodSignatureFormatter;
+
+  HasSourceElementFormatter(MethodSignatureFormatter methodSignatureFormatter) {
+    this.methodSignatureFormatter = methodSignatureFormatter;
+  }
+
+  @Override
+  public String format(HasSourceElement hasElement) {
+    SourceElement sourceElement = hasElement.sourceElement();
+    checkArgument(
+        sourceElement.element().asType().getKind().equals(TypeKind.EXECUTABLE),
+        "Not yet supporting nonexecutable elements: %s",
+        hasElement);
+
+    Optional<TypeElement> contributedBy = sourceElement.contributedBy();
+    return methodSignatureFormatter.format(
+        MoreElements.asExecutable(sourceElement.element()),
+        contributedBy.isPresent()
+            ? Optional.of(MoreTypes.asDeclared(contributedBy.get().asType()))
+            : Optional.<DeclaredType>absent());
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
index f7ca429f3..70c548c97 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
@@ -16,7 +16,6 @@
 package dagger.internal.codegen;
 
 import com.google.auto.common.MoreElements;
-import com.google.auto.common.MoreTypes;
 import com.google.common.base.Optional;
 import com.google.common.base.Predicate;
 import com.google.common.collect.FluentIterable;
@@ -29,23 +28,24 @@
 import dagger.internal.codegen.writer.ClassName;
 import java.util.ArrayDeque;
 import java.util.Deque;
-import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import javax.annotation.processing.Messager;
 import javax.inject.Inject;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 import javax.tools.Diagnostic.Kind;
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.auto.common.MoreTypes.asDeclared;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
+import static dagger.internal.codegen.MembersInjectionBinding.Strategy.INJECT_MEMBERS;
 import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
+import static javax.lang.model.util.ElementFilter.constructorsIn;
 
 /**
  * Maintains the collection of provision bindings from {@link Inject} constructors and members
@@ -71,7 +71,7 @@ void generateBindings(SourceFileGenerator<B> generator) throws SourceFileGenerat
       for (B binding = bindingsRequiringGeneration.poll();
           binding != null;
           binding = bindingsRequiringGeneration.poll()) {
-        checkState(!binding.hasNonDefaultTypeParameters());
+        checkState(!binding.unresolved().isPresent());
         generator.generate(binding);
         materializedBindingKeys.add(binding.key());
       }
@@ -86,19 +86,19 @@ B getBinding(Key key) {
     }
 
     /** Caches the binding and generates it if it needs generation. */
-    void tryRegisterBinding(B binding, ClassName factoryName, boolean explicit) {
+    void tryRegisterBinding(B binding, ClassName factoryName, boolean warnIfNotAlreadyGenerated) {
       tryToCacheBinding(binding);
-      tryToGenerateBinding(binding, factoryName, explicit);
+      tryToGenerateBinding(binding, factoryName, warnIfNotAlreadyGenerated);
     }
 
     /**
      * Tries to generate a binding, not generating if it already is generated. For resolved
      * bindings, this will try to generate the unresolved version of the binding.
      */
-    void tryToGenerateBinding(B binding, ClassName factoryName, boolean explicit) {
+    void tryToGenerateBinding(B binding, ClassName factoryName, boolean warnIfNotAlreadyGenerated) {
       if (shouldGenerateBinding(binding, factoryName)) {
         bindingsRequiringGeneration.offer(binding);
-        if (!explicit) {
+        if (warnIfNotAlreadyGenerated) {
           messager.printMessage(Kind.NOTE, String.format(
               "Generating a MembersInjector or Factory for %s. "
                     + "Prefer to run the dagger processor over that class instead.",
@@ -109,7 +109,7 @@ void tryToGenerateBinding(B binding, ClassName factoryName, boolean explicit) {
 
     /** Returns true if the binding needs to be generated. */
     private boolean shouldGenerateBinding(B binding, ClassName factoryName) {
-      return !binding.hasNonDefaultTypeParameters()
+      return !binding.unresolved().isPresent()
           && elements.getTypeElement(factoryName.canonicalName()) == null
           && !materializedBindingKeys.contains(binding.key())
           && !bindingsRequiringGeneration.contains(binding);
@@ -120,7 +120,7 @@ private boolean shouldGenerateBinding(B binding, ClassName factoryName) {
     private void tryToCacheBinding(B binding) {
       // We only cache resolved bindings or unresolved bindings w/o type arguments.
       // Unresolved bindings w/ type arguments aren't valid for the object graph.
-      if (binding.hasNonDefaultTypeParameters()
+      if (binding.unresolved().isPresent()
           || binding.bindingTypeElement().getTypeParameters().isEmpty()) {
         Key key = binding.key();
         Binding previousValue = bindingsByKey.put(key, binding);
@@ -159,38 +159,54 @@ void generateSourcesForRequiredBindings(FactoryGenerator factoryGenerator,
   }
 
   ProvisionBinding registerBinding(ProvisionBinding binding) {
-    return registerBinding(binding, true);
+    return registerBinding(binding, false);
   }
 
   MembersInjectionBinding registerBinding(MembersInjectionBinding binding) {
-    return registerBinding(binding, true);
+    return registerBinding(binding, false);
   }
 
   /**
-   * Registers the binding for generation & later lookup. If the binding is resolved, we also
+   * Registers the binding for generation and later lookup. If the binding is resolved, we also
    * attempt to register an unresolved version of it.
    */
-  private ProvisionBinding registerBinding(ProvisionBinding binding, boolean explicit) {
+  private ProvisionBinding registerBinding(
+      ProvisionBinding binding, boolean warnIfNotAlreadyGenerated) {
     ClassName factoryName = generatedClassNameForBinding(binding);
-    provisionBindings.tryRegisterBinding(binding, factoryName, explicit);
-    if (binding.hasNonDefaultTypeParameters()) {
-      provisionBindings.tryToGenerateBinding(provisionBindingFactory.unresolve(binding),
-          factoryName, explicit);
+    provisionBindings.tryRegisterBinding(binding, factoryName, warnIfNotAlreadyGenerated);
+    if (binding.unresolved().isPresent()) {
+      provisionBindings.tryToGenerateBinding(
+          binding.unresolved().get(), factoryName, warnIfNotAlreadyGenerated);
     }
     return binding;
   }
 
   /**
-   * Registers the binding for generation & later lookup. If the binding is resolved, we also
+   * Registers the binding for generation and later lookup. If the binding is resolved, we also
    * attempt to register an unresolved version of it.
    */
   private MembersInjectionBinding registerBinding(
-      MembersInjectionBinding binding, boolean explicit) {
+      MembersInjectionBinding binding, boolean warnIfNotAlreadyGenerated) {
+    /*
+     * We generate MembersInjector classes for types with @Inject constructors only if they have any
+     * injection sites.
+     *
+     * We generate MembersInjector classes for types without @Inject constructors only if they have
+     * local (non-inherited) injection sites.
+     *
+     * Warn only when registering bindings post-hoc for those types.
+     */
+    warnIfNotAlreadyGenerated =
+        warnIfNotAlreadyGenerated
+            && (!injectedConstructors(binding.bindingElement()).isEmpty()
+                ? !binding.injectionSites().isEmpty()
+                : binding.hasLocalInjectionSites());
     ClassName membersInjectorName = generatedClassNameForBinding(binding);
-    membersInjectionBindings.tryRegisterBinding(binding, membersInjectorName, explicit);
-    if (binding.hasNonDefaultTypeParameters()) {
+    membersInjectionBindings.tryRegisterBinding(
+        binding, membersInjectorName, warnIfNotAlreadyGenerated);
+    if (binding.unresolved().isPresent()) {
       membersInjectionBindings.tryToGenerateBinding(
-          membersInjectionBindingFactory.unresolve(binding), membersInjectorName, explicit);
+          binding.unresolved().get(), membersInjectorName, warnIfNotAlreadyGenerated);
     }
     return binding;
   }
@@ -207,28 +223,38 @@ private MembersInjectionBinding registerBinding(
 
     // ok, let's see if we can find an @Inject constructor
     TypeElement element = MoreElements.asType(types.asElement(key.type()));
-    List<ExecutableElement> constructors =
-        ElementFilter.constructorsIn(element.getEnclosedElements());
-    ImmutableSet<ExecutableElement> injectConstructors = FluentIterable.from(constructors)
-        .filter(new Predicate<ExecutableElement>() {
-          @Override public boolean apply(ExecutableElement input) {
-            return isAnnotationPresent(input, Inject.class);
-          }
-        }).toSet();
+    ImmutableSet<ExecutableElement> injectConstructors = injectedConstructors(element);
     switch (injectConstructors.size()) {
       case 0:
         // No constructor found.
         return Optional.absent();
       case 1:
-        ProvisionBinding constructorBinding = provisionBindingFactory.forInjectConstructor(
-            Iterables.getOnlyElement(injectConstructors), Optional.of(key.type()));
-        return Optional.of(registerBinding(constructorBinding, false));
+        ProvisionBinding constructorBinding =
+            provisionBindingFactory.forInjectConstructor(
+                Iterables.getOnlyElement(injectConstructors), Optional.of(key.type()));
+        return Optional.of(registerBinding(constructorBinding, true));
       default:
         throw new IllegalStateException("Found multiple @Inject constructors: "
             + injectConstructors);
     }
   }
 
+  private ImmutableSet<ExecutableElement> injectedConstructors(TypeElement element) {
+    return FluentIterable.from(constructorsIn(element.getEnclosedElements()))
+        .filter(
+            new Predicate<ExecutableElement>() {
+              @Override
+              public boolean apply(ExecutableElement constructor) {
+                return isAnnotationPresent(constructor, Inject.class);
+              }
+            })
+        .toSet();
+  }
+
+  /**
+   * Returns a {@link MembersInjectionBinding} for {@code key}. If none has been registered yet,
+   * registers one, along with all necessary members injection bindings for superclasses.
+   */
   MembersInjectionBinding getOrFindMembersInjectionBinding(Key key) {
     checkNotNull(key);
     // TODO(gak): is checking the kind enough?
@@ -237,7 +263,14 @@ MembersInjectionBinding getOrFindMembersInjectionBinding(Key key) {
     if (binding != null) {
       return binding;
     }
-    return registerBinding(membersInjectionBindingFactory.forInjectedType(
-        MoreTypes.asDeclared(key.type()), Optional.of(key.type())), false);
+    MembersInjectionBinding newBinding =
+        membersInjectionBindingFactory.forInjectedType(
+            asDeclared(key.type()), Optional.of(key.type()));
+    registerBinding(newBinding, true);
+    if (newBinding.parentKey().isPresent()
+        && newBinding.injectionStrategy().equals(INJECT_MEMBERS)) {
+      getOrFindMembersInjectionBinding(newBinding.parentKey().get());
+    }
+    return newBinding;
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index f0bd3a04f..042edc5e9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -20,10 +20,15 @@
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
+import com.google.common.base.Equivalence.Wrapper;
+import com.google.common.base.Function;
 import com.google.common.base.MoreObjects;
 import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Iterables;
+import com.google.common.collect.Multimaps;
 import com.google.common.util.concurrent.ListenableFuture;
+import dagger.Multibindings;
 import dagger.Provides;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
@@ -52,8 +57,6 @@
 import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
 import static dagger.internal.codegen.MapKeys.getMapKey;
 import static dagger.internal.codegen.MapKeys.getUnwrappedMapKeyType;
-import static dagger.internal.codegen.Util.unwrapOptionalEquivalence;
-import static dagger.internal.codegen.Util.wrapOptionalInEquivalence;
 import static javax.lang.model.element.ElementKind.METHOD;
 
 /**
@@ -64,6 +67,13 @@
  */
 @AutoValue
 abstract class Key {
+  
+  /** An object that is associated with a {@link Key}. */
+  interface HasKey {
+    /** The key associated with this object. */
+    Key key();
+  }
+
   /**
    * A {@link javax.inject.Qualifier} annotation that provides a unique namespace prefix
    * for the type of this key.
@@ -155,6 +165,42 @@ public String toString() {
         .toString();
   }
 
+  /**
+   * Indexes {@code haveKeys} by {@link HasKey#key()}.
+   */
+  static <T extends HasKey> ImmutableSetMultimap<Key, T> indexByKey(Iterable<T> haveKeys) {
+    return ImmutableSetMultimap.copyOf(
+        Multimaps.index(
+            haveKeys,
+            new Function<HasKey, Key>() {
+              @Override
+              public Key apply(HasKey hasKey) {
+                return hasKey.key();
+              }
+            }));
+  }
+
+  /**
+   * Wraps an {@link Optional} of a type in an {@code Optional} of a {@link Wrapper} for that type.
+   */
+  private static <T> Optional<Equivalence.Wrapper<T>> wrapOptionalInEquivalence(
+      Equivalence<T> equivalence, Optional<T> optional) {
+    return optional.isPresent()
+        ? Optional.of(equivalence.wrap(optional.get()))
+        : Optional.<Equivalence.Wrapper<T>>absent();
+  }
+
+  /**
+   * Unwraps an {@link Optional} of a {@link Wrapper} into an {@code Optional} of the underlying
+   * type.
+   */
+  private static <T> Optional<T> unwrapOptionalEquivalence(
+      Optional<Equivalence.Wrapper<T>> wrappedOptional) {
+    return wrappedOptional.isPresent()
+        ? Optional.of(wrappedOptional.get().get())
+        : Optional.<T>absent();
+  }
+
   static final class Factory {
     private final Types types;
     private final Elements elements;
@@ -227,7 +273,7 @@ Key forProvidesMethod(ExecutableType executableType, ExecutableElement method) {
       return forMethod(method, keyType);
     }
 
-    // TODO(user): Reconcile this method with forProvidesMethod when Provides.Type and
+    // TODO(beder): Reconcile this method with forProvidesMethod when Provides.Type and
     // Produces.Type are no longer different.
     Key forProducesMethod(ExecutableType executableType, ExecutableElement method) {
       checkNotNull(method);
@@ -248,6 +294,28 @@ Key forProducesMethod(ExecutableType executableType, ExecutableElement method) {
               Optional.of(producesAnnotation.type()));
       return forMethod(method, keyType);
     }
+    
+    /**
+     * Returns the key for a method in a {@link Multibindings @Multibindings} interface.
+     *
+     * The key's type is either {@code Set<T>} or {@code Map<K, F<V>>}, where {@code F} is either
+     * {@link Provider} or {@link Producer}, depending on {@code bindingType}.
+     */
+    Key forMultibindingsMethod(
+        BindingType bindingType, ExecutableType executableType, ExecutableElement method) {
+      checkArgument(method.getKind().equals(METHOD), "%s must be a method", method);
+      TypeElement factoryType =
+          elements.getTypeElement(bindingType.frameworkClass().getCanonicalName());
+      TypeMirror returnType = normalize(types, executableType.getReturnType());
+      TypeMirror keyType =
+          MapType.isMap(returnType)
+              ? mapOfFrameworkType(
+                  MapType.from(returnType).keyType(),
+                  factoryType,
+                  MapType.from(returnType).valueType())
+              : returnType;
+      return forMethod(method, keyType);
+    }
 
     private TypeMirror providesOrProducesKeyType(
         TypeMirror returnType,
@@ -262,10 +330,10 @@ private TypeMirror providesOrProducesKeyType(
         case SET:
           return types.getDeclaredType(getSetElement(), returnType);
         case MAP:
-          return mapOfFactoryType(
-              method,
-              returnType,
-              providesType.isPresent() ? getProviderElement() : getProducerElement());
+          return mapOfFrameworkType(
+              mapKeyType(method),
+              providesType.isPresent() ? getProviderElement() : getProducerElement(),
+              returnType);
         case SET_VALUES:
           // TODO(gak): do we want to allow people to use "covariant return" here?
           checkArgument(MoreTypes.isType(returnType) && MoreTypes.isTypeOf(Set.class, returnType));
@@ -275,11 +343,13 @@ private TypeMirror providesOrProducesKeyType(
       }
     }
 
-    private TypeMirror mapOfFactoryType(
-        ExecutableElement method, TypeMirror valueType, TypeElement factoryType) {
-      TypeMirror mapKeyType = mapKeyType(method);
-      TypeMirror mapValueFactoryType = types.getDeclaredType(factoryType, valueType);
-      return types.getDeclaredType(getMapElement(), mapKeyType, mapValueFactoryType);
+    /**
+     * Returns {@code Map<KeyType, FrameworkType<ValueType>>}.
+     */
+    private TypeMirror mapOfFrameworkType(
+        TypeMirror keyType, TypeElement frameworkType, TypeMirror valueType) {
+      return types.getDeclaredType(
+          getMapElement(), keyType, types.getDeclaredType(frameworkType, valueType));
     }
 
     private TypeMirror mapKeyType(ExecutableElement method) {
@@ -342,22 +412,20 @@ Key forQualifiedType(Optional<AnnotationMirror> qualifier, TypeMirror type) {
      * {@code Map<K, V>}.
      */
     private Optional<Key> maybeWrapMapValue(Key possibleMapKey, Class<?> wrappingClass) {
-      if (MoreTypes.isTypeOf(Map.class, possibleMapKey.type())) {
-        DeclaredType declaredMapType = MoreTypes.asDeclared(possibleMapKey.type());
-        TypeMirror mapValueType = Util.getValueTypeOfMap(declaredMapType);
-        if (!MoreTypes.isTypeOf(wrappingClass, mapValueType)) {
-          TypeMirror keyType = Util.getKeyTypeOfMap(declaredMapType);
+      if (MapType.isMap(possibleMapKey.type())) {
+        MapType mapType = MapType.from(possibleMapKey.type());
+        if (!mapType.valuesAreTypeOf(wrappingClass)) {
           TypeElement wrappingElement = getClassElement(wrappingClass);
           if (wrappingElement == null) {
             // This target might not be compiled with Producers, so wrappingClass might not have an
             // associated element.
             return Optional.absent();
           }
-          DeclaredType wrappedType = types.getDeclaredType(wrappingElement, mapValueType);
-          TypeMirror mapType = types.getDeclaredType(getMapElement(), keyType, wrappedType);
-          return Optional.<Key>of(new AutoValue_Key(
-              possibleMapKey.wrappedQualifier(),
-              MoreTypes.equivalence().wrap(mapType)));
+          DeclaredType wrappedValueType =
+              types.getDeclaredType(wrappingElement, mapType.valueType());
+          TypeMirror wrappedMapType =
+              types.getDeclaredType(getMapElement(), mapType.keyType(), wrappedValueType);
+          return Optional.of(possibleMapKey.withType(types, wrappedMapType));
         }
       }
       return Optional.absent();
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
index 8d72e5e48..432f8f578 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
@@ -32,13 +32,13 @@
 import dagger.internal.codegen.writer.TypeWriter;
 import java.util.LinkedHashSet;
 import java.util.Set;
-import javax.annotation.Generated;
 import javax.annotation.processing.Filer;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
+import javax.lang.model.util.Elements;
 import javax.lang.model.util.SimpleTypeVisitor6;
 
 import static dagger.internal.codegen.MapKeys.getMapKeyCreatorClassName;
@@ -90,8 +90,8 @@ static MapKeyCreatorSpecification unwrappedMapKeyWithAnnotationValue(
     }
   }
 
-  MapKeyGenerator(Filer filer) {
-    super(filer);
+  MapKeyGenerator(Filer filer, Elements elements) {
+    super(filer, elements);
   }
 
   @Override
@@ -115,7 +115,6 @@ ClassName nameGeneratedType(MapKeyCreatorSpecification mapKeyCreatorType) {
       ClassName generatedTypeName, MapKeyCreatorSpecification mapKeyCreatorType) {
     JavaWriter writer = JavaWriter.inPackage(generatedTypeName.packageName());
     TypeWriter mapKeyCreatorWriter = writer.addClass(generatedTypeName.simpleName());
-    mapKeyCreatorWriter.annotate(Generated.class).setValue(ComponentProcessor.class.getName());
     mapKeyCreatorWriter.addModifiers(PUBLIC, FINAL);
 
     for (TypeElement annotationElement :
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapType.java b/compiler/src/main/java/dagger/internal/codegen/MapType.java
new file mode 100644
index 000000000..5c0faf820
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/MapType.java
@@ -0,0 +1,115 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreTypes;
+import com.google.auto.value.AutoValue;
+import com.google.common.base.Equivalence;
+import java.util.Map;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
+
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkState;
+
+/**
+ * Information about a {@link Map} {@link TypeMirror}.
+ */
+@AutoValue
+abstract class MapType {
+  /**
+   * The map type itself, wrapped using {@link MoreTypes#equivalence()}. Use
+   * {@link #declaredMapType()} instead.
+   */
+  protected abstract Equivalence.Wrapper<DeclaredType> wrappedDeclaredMapType();
+
+  /**
+   * The map type itself.
+   */
+  DeclaredType declaredMapType() {
+    return wrappedDeclaredMapType().get();
+  }
+
+  /**
+   * {@code true} if the map type is the raw {@link Map} type.
+   */
+  boolean isRawType() {
+    return declaredMapType().getTypeArguments().isEmpty();
+  }
+
+  /**
+   * The map key type.
+   * 
+   * @throws IllegalStateException if {@link #isRawType()} is true.
+   */
+  TypeMirror keyType() {
+    checkState(!isRawType());
+    return declaredMapType().getTypeArguments().get(0);
+  }
+
+  /**
+   * The map value type.
+   * 
+   * @throws IllegalStateException if {@link #isRawType()} is true.
+   */
+  TypeMirror valueType() {
+    checkState(!isRawType());
+    return declaredMapType().getTypeArguments().get(1);
+  }
+
+  /**
+   * {@code true} if {@link #valueType()} is a {@code clazz}.
+   * 
+   * @throws IllegalStateException if {@link #isRawType()} is true.
+   */
+  boolean valuesAreTypeOf(Class<?> clazz) {
+    return MoreTypes.isType(valueType()) && MoreTypes.isTypeOf(clazz, valueType());
+  }
+
+  /**
+   * {@code V} if {@link #valueType()} is a {@code WrappingClass<V>}.
+   *
+   * @throws IllegalStateException if {@link #isRawType()} is true or {@link #valueType()} is not a
+   *     {@code WrappingClass<V>}
+   * @throws IllegalArgumentException if {@code wrappingClass} does not have exactly one type
+   *     parameter
+   */
+  TypeMirror unwrappedValueType(Class<?> wrappingClass) {
+    checkArgument(
+        wrappingClass.getTypeParameters().length == 1,
+        "%s must have exactly one type parameter",
+        wrappingClass);
+    checkState(valuesAreTypeOf(wrappingClass));
+    return MoreTypes.asDeclared(valueType()).getTypeArguments().get(0);
+  }
+
+  /**
+   * {@code true} if {@code type} is a {@link Map} type.
+   */
+  static boolean isMap(TypeMirror type) {
+    return MoreTypes.isType(type) && MoreTypes.isTypeOf(Map.class, type);
+  }
+
+  /**
+   * Returns a {@link MapType} for {@code type}.
+   *
+   * @throws IllegalArgumentException if {@code type} is not a {@link Map} type
+   */
+  static MapType from(TypeMirror type) {
+    checkArgument(isMap(type), "%s is not a Map", type);
+    return new AutoValue_MapType(MoreTypes.equivalence().wrap(MoreTypes.asDeclared(type)));
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
index 7fbcf115d..53d15ee8d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
@@ -20,6 +20,7 @@
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Function;
 import com.google.common.base.Optional;
+import com.google.common.base.Predicate;
 import com.google.common.collect.ComparisonChain;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
@@ -53,20 +54,34 @@
 import static javax.lang.model.element.Modifier.STATIC;
 
 /**
- * Represents the full members injection of a particular type. This does not pay attention to
- * injected members on supertypes.
+ * Represents the full members injection of a particular type.
  *
  * @author Gregory Kick
  * @since 2.0
  */
 @AutoValue
 abstract class MembersInjectionBinding extends Binding {
-  @Override abstract TypeElement bindingElement();
-        
+  @Override
+  abstract Optional<MembersInjectionBinding> unresolved();
+
+  @Override
+  TypeElement bindingElement() {
+    return MoreElements.asType(super.bindingElement());
+  }
+
+  @Override
+  Set<DependencyRequest> implicitDependencies() {
+    return dependencies();
+  }
+
   /** The set of individual sites where {@link Inject} is applied. */
   abstract ImmutableSortedSet<InjectionSite> injectionSites();
 
-  abstract Optional<DependencyRequest> parentInjectorRequest();
+  /**
+   * The {@link Key} for the non-object superclass of {@link #bindingElement()}. Absent if
+   * {@link #bindingElement()} is a direct subclass of {@link Object}. 
+   */
+  abstract Optional<Key> parentKey();
 
   enum Strategy {
     NO_OP,
@@ -77,21 +92,23 @@ Strategy injectionStrategy() {
     return injectionSites().isEmpty() ? Strategy.NO_OP : Strategy.INJECT_MEMBERS;
   }
 
-  MembersInjectionBinding withoutParentInjectorRequest() {
-    return new AutoValue_MembersInjectionBinding(
-          key(),
-          dependencies(),
-          implicitDependencies(),
-          bindingPackage(),
-          hasNonDefaultTypeParameters(),
-          bindingElement(),
-          injectionSites(),
-          Optional.<DependencyRequest>absent());
+  @Override
+  public BindingType bindingType() {
+    return BindingType.MEMBERS_INJECTION;
   }
 
-  @Override
-  protected Binding.Type bindingType() {
-    return Binding.Type.MEMBERS_INJECTION;
+  /**
+   * Returns {@code true} if any of this binding's injection sites are directly on the bound type.
+   */
+  boolean hasLocalInjectionSites() {
+    return FluentIterable.from(injectionSites())
+        .anyMatch(
+            new Predicate<InjectionSite>() {
+              @Override
+              public boolean apply(InjectionSite injectionSite) {
+                return injectionSite.element().getEnclosingElement().equals(bindingElement());
+              }
+            });
   }
 
   @AutoValue
@@ -157,13 +174,6 @@ private InjectionSite injectionSiteForInjectField(
                   containingType, fieldElement, resolved)));
     }
 
-    /** Returns an unresolved version of this binding. */
-    MembersInjectionBinding unresolve(MembersInjectionBinding binding) {
-      checkState(binding.hasNonDefaultTypeParameters());
-      DeclaredType unresolved = MoreTypes.asDeclared(binding.bindingElement().asType());
-      return forInjectedType(unresolved, Optional.<TypeMirror>absent());
-    }
-
     /** Returns true if the type has some injected members in itself or any of its super classes. */
     boolean hasInjectedMembers(DeclaredType declaredType) {
       return !getInjectionSites(declaredType).isEmpty();
@@ -199,27 +209,30 @@ MembersInjectionBinding forInjectedType(
                   })
               .toSet();
 
-      Optional<DependencyRequest> parentInjectorRequest =
+      Optional<Key> parentKey =
           MoreTypes.nonObjectSuperclass(types, elements, declaredType)
               .transform(
-                  new Function<DeclaredType, DependencyRequest>() {
+                  new Function<DeclaredType, Key>() {
                     @Override
-                    public DependencyRequest apply(DeclaredType input) {
-                      return dependencyRequestFactory.forMembersInjectedType(input);
+                    public Key apply(DeclaredType superclass) {
+                      return keyFactory.forMembersInjectedType(superclass);
                     }
                   });
 
       Key key = keyFactory.forMembersInjectedType(declaredType);
       TypeElement typeElement = MoreElements.asType(declaredType.asElement());
       return new AutoValue_MembersInjectionBinding(
+          SourceElement.forElement(typeElement),
           key,
           dependencies,
-          dependencies,
           findBindingPackage(key),
-          hasNonDefaultTypeParameters(typeElement, key.type(), types),
-          typeElement,
+          hasNonDefaultTypeParameters(typeElement, key.type(), types)
+              ? Optional.of(
+                  forInjectedType(
+                      MoreTypes.asDeclared(typeElement.asType()), Optional.<TypeMirror>absent()))
+              : Optional.<MembersInjectionBinding>absent(),
           injectionSites,
-          parentInjectorRequest);
+          parentKey);
     }
 
     private ImmutableSortedSet<InjectionSite> getInjectionSites(DeclaredType declaredType) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
index 3694d2e81..46d913437 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
@@ -55,6 +55,7 @@
 import javax.lang.model.type.ArrayType;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeVisitor;
+import javax.lang.model.util.Elements;
 import javax.lang.model.util.SimpleTypeVisitor7;
 
 import static com.google.auto.common.MoreElements.getPackage;
@@ -79,9 +80,8 @@
   private final DependencyRequestMapper dependencyRequestMapper;
 
   MembersInjectorGenerator(
-      Filer filer,
-      DependencyRequestMapper dependencyRequestMapper) {
-    super(filer);
+      Filer filer, Elements elements, DependencyRequestMapper dependencyRequestMapper) {
+    super(filer, elements);
     this.dependencyRequestMapper = dependencyRequestMapper;
   }
 
@@ -116,7 +116,7 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
     Set<String> delegateMethods = new HashSet<>();
 
     // We don't want to write out resolved bindings -- we want to write out the generic version.
-    checkState(!binding.hasNonDefaultTypeParameters()); 
+    checkState(!binding.unresolved().isPresent());
 
     TypeName injectedTypeName = TypeNames.forTypeMirror(binding.key().type());
     JavaWriter writer = JavaWriter.inPackage(generatedTypeName.packageName());
@@ -127,8 +127,6 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
       typeParameters.add(TypeVariableName.fromTypeParameterElement(typeParameter));
     }
     injectorWriter.addTypeParameters(typeParameters);
-    injectorWriter.annotate(Generated.class)
-        .setValue(ComponentProcessor.class.getCanonicalName());
     injectorWriter.addModifiers(PUBLIC, FINAL);
     TypeName implementedType =
         ParameterizedTypeName.create(MembersInjector.class, injectedTypeName);
@@ -146,8 +144,7 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
         "}"));
 
     ImmutableMap<BindingKey, FrameworkField> fields =
-        SourceFiles.generateBindingFieldsForDependencies(
-            dependencyRequestMapper, ImmutableSet.copyOf(binding.dependencies()));
+        SourceFiles.generateBindingFieldsForDependencies(dependencyRequestMapper, binding);
 
     ImmutableMap.Builder<BindingKey, FieldWriter> dependencyFieldsBuilder =
         ImmutableMap.builder();
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
index c938af2c3..e423f55ee 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
@@ -1,14 +1,34 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Function;
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
 import dagger.Module;
+import dagger.Multibindings;
 import dagger.Provides;
 import dagger.producers.ProducerModule;
 import dagger.producers.Produces;
+import java.lang.annotation.Annotation;
+import java.util.EnumSet;
 import java.util.LinkedHashSet;
 import java.util.Set;
 import javax.lang.model.element.AnnotationMirror;
@@ -19,12 +39,14 @@
 
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Verify.verify;
 import static dagger.internal.codegen.ConfigurationAnnotations.getModuleIncludes;
 import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
 import static javax.lang.model.type.TypeKind.DECLARED;
 import static javax.lang.model.type.TypeKind.NONE;
 import static javax.lang.model.util.ElementFilter.methodsIn;
+import static javax.lang.model.util.ElementFilter.typesIn;
 
 @AutoValue
 abstract class ModuleDescriptor {
@@ -43,6 +65,11 @@
   abstract ImmutableSet<ModuleDescriptor> includedModules();
 
   abstract ImmutableSet<ContributionBinding> bindings();
+  
+  /**
+   * The multibinding declarations contained in this module.
+   */
+  abstract ImmutableSet<MultibindingDeclaration> multibindingDeclarations();
 
   enum DefaultCreationStrategy {
     PASSED,
@@ -51,18 +78,74 @@
 
   abstract DefaultCreationStrategy defaultCreationStrategy();
 
+  enum Kind {
+    MODULE(
+        Module.class, Provides.class, ImmutableSet.of(Module.class)),
+    PRODUCER_MODULE(
+        ProducerModule.class,
+        Produces.class,
+        ImmutableSet.of(Module.class, ProducerModule.class));
+
+    private final Class<? extends Annotation> moduleAnnotation;
+    private final Class<? extends Annotation> methodAnnotation;
+    private final ImmutableSet<? extends Class<? extends Annotation>> includesTypes;
+
+    /**
+     * Returns the kind of an annotated element if it is annotated with one of the
+     * {@linkplain #moduleAnnotation() annotation types}.
+     *
+     * @throws IllegalArgumentException if the element is annotated with more than one of the
+     *     annotation types
+     */
+    static Optional<Kind> forAnnotatedElement(TypeElement element) {
+      Set<Kind> kinds = EnumSet.noneOf(Kind.class);
+      for (Kind kind : values()) {
+        if (MoreElements.isAnnotationPresent(element, kind.moduleAnnotation())) {
+          kinds.add(kind);
+        }
+      }
+      checkArgument(
+          kinds.size() <= 1, "%s cannot be annotated with more than one of %s", element, kinds);
+      return Optional.fromNullable(Iterables.getOnlyElement(kinds, null));
+    }
+
+    Kind(
+        Class<? extends Annotation> moduleAnnotation,
+        Class<? extends Annotation> methodAnnotation,
+        ImmutableSet<? extends Class<? extends Annotation>> includesTypes) {
+      this.moduleAnnotation = moduleAnnotation;
+      this.methodAnnotation = methodAnnotation;
+      this.includesTypes = includesTypes;
+    }
+
+    Class<? extends Annotation> moduleAnnotation() {
+      return moduleAnnotation;
+    }
+
+    Class<? extends Annotation> methodAnnotation() {
+      return methodAnnotation;
+    }
+
+    ImmutableSet<? extends Class<? extends Annotation>> includesTypes() {
+      return includesTypes;
+    }
+  }
+
   static final class Factory {
     private final Elements elements;
     private final ProvisionBinding.Factory provisionBindingFactory;
     private final ProductionBinding.Factory productionBindingFactory;
+    private final MultibindingDeclaration.Factory multibindingDeclarationFactory;
 
     Factory(
         Elements elements,
         ProvisionBinding.Factory provisionBindingFactory,
-        ProductionBinding.Factory productionBindingFactory) {
+        ProductionBinding.Factory productionBindingFactory,
+        MultibindingDeclaration.Factory multibindingDeclarationFactory) {
       this.elements = elements;
       this.provisionBindingFactory = provisionBindingFactory;
       this.productionBindingFactory = productionBindingFactory;
+      this.multibindingDeclarationFactory = multibindingDeclarationFactory;
     }
 
     ModuleDescriptor create(TypeElement moduleElement) {
@@ -79,6 +162,15 @@ ModuleDescriptor create(TypeElement moduleElement) {
               productionBindingFactory.forProducesMethod(moduleMethod, moduleElement.asType()));
         }
       }
+      
+      ImmutableSet.Builder<MultibindingDeclaration> multibindingDeclarations =
+          ImmutableSet.builder();
+      for (TypeElement memberType : typesIn(elements.getAllMembers(moduleElement))) {
+        if (isAnnotationPresent(memberType, Multibindings.class)) {
+          multibindingDeclarations.addAll(
+              multibindingDeclarationFactory.forDeclaredInterface(memberType));
+        }
+      }
 
       DefaultCreationStrategy defaultCreationStrategy =
           (componentCanMakeNewInstances(moduleElement)
@@ -92,6 +184,7 @@ ModuleDescriptor create(TypeElement moduleElement) {
           ImmutableSet.copyOf(
               collectIncludedModules(new LinkedHashSet<ModuleDescriptor>(), moduleElement)),
           bindings.build(),
+          multibindingDeclarations.build(),
           defaultCreationStrategy);
     }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
index 8b0c9a217..9bb5fd1b5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
@@ -70,46 +70,37 @@
 final class ModuleValidator {
   private final Types types;
   private final Elements elements;
-  private final Class<? extends Annotation> moduleClass;
-  private final ImmutableList<Class<? extends Annotation>> includedModuleClasses;
-  private final Class<? extends Annotation> methodClass;
   private final MethodSignatureFormatter methodSignatureFormatter;
 
   ModuleValidator(
-      Types types,
-      Elements elements,
-      MethodSignatureFormatter methodSignatureFormatter,
-      Class<? extends Annotation> moduleClass,
-      ImmutableList<Class<? extends Annotation>> includedModuleClasses,
-      Class<? extends Annotation> methodClass) {
+      Types types, Elements elements, MethodSignatureFormatter methodSignatureFormatter) {
     this.types = types;
     this.elements = elements;
-    this.moduleClass = moduleClass;
-    this.includedModuleClasses = includedModuleClasses;
-    this.methodClass = methodClass;
     this.methodSignatureFormatter = methodSignatureFormatter;
   }
 
   ValidationReport<TypeElement> validate(final TypeElement subject) {
     final ValidationReport.Builder<TypeElement> builder = ValidationReport.about(subject);
+    ModuleDescriptor.Kind moduleKind = ModuleDescriptor.Kind.forAnnotatedElement(subject).get();
 
     List<ExecutableElement> moduleMethods = ElementFilter.methodsIn(subject.getEnclosedElements());
     ListMultimap<String, ExecutableElement> allMethodsByName = ArrayListMultimap.create();
     ListMultimap<String, ExecutableElement> bindingMethodsByName = ArrayListMultimap.create();
     for (ExecutableElement moduleMethod : moduleMethods) {
-      if (isAnnotationPresent(moduleMethod, methodClass)) {
+      if (isAnnotationPresent(moduleMethod, moduleKind.methodAnnotation())) {
         bindingMethodsByName.put(moduleMethod.getSimpleName().toString(), moduleMethod);
       }
       allMethodsByName.put(moduleMethod.getSimpleName().toString(), moduleMethod);
     }
 
-    validateModuleVisibility(subject, builder);
-    validateMethodsWithSameName(builder, bindingMethodsByName);
+    validateModuleVisibility(subject, moduleKind, builder);
+    validateMethodsWithSameName(moduleKind, builder, bindingMethodsByName);
     if (subject.getKind() != ElementKind.INTERFACE) {
-      validateProvidesOverrides(subject, builder, allMethodsByName, bindingMethodsByName);
+      validateProvidesOverrides(
+          subject, moduleKind, builder, allMethodsByName, bindingMethodsByName);
     }
     validateModifiers(subject, builder);
-    validateReferencedModules(subject, builder);
+    validateReferencedModules(subject, moduleKind, builder);
 
     // TODO(gak): port the dagger 1 module validation?
     return builder.build();
@@ -125,6 +116,7 @@ private void validateModifiers(
   }
 
   private void validateMethodsWithSameName(
+      ModuleDescriptor.Kind moduleKind,
       ValidationReport.Builder<TypeElement> builder,
       ListMultimap<String, ExecutableElement> bindingMethodsByName) {
     for (Entry<String, Collection<ExecutableElement>> entry :
@@ -132,7 +124,8 @@ private void validateMethodsWithSameName(
       if (entry.getValue().size() > 1) {
         for (ExecutableElement offendingMethod : entry.getValue()) {
           builder.addError(
-              String.format(BINDING_METHOD_WITH_SAME_NAME, methodClass.getSimpleName()),
+              String.format(
+                  BINDING_METHOD_WITH_SAME_NAME, moduleKind.methodAnnotation().getSimpleName()),
               offendingMethod);
         }
       }
@@ -140,11 +133,27 @@ private void validateMethodsWithSameName(
   }
 
   private void validateReferencedModules(
-      TypeElement subject, ValidationReport.Builder<TypeElement> builder) {
+      TypeElement subject,
+      ModuleDescriptor.Kind moduleKind,
+      ValidationReport.Builder<TypeElement> builder) {
     // Validate that all the modules we include are valid for inclusion.
-    AnnotationMirror mirror = getAnnotationMirror(subject, moduleClass).get();
+    AnnotationMirror mirror = getAnnotationMirror(subject, moduleKind.moduleAnnotation()).get();
     ImmutableList<TypeMirror> includedTypes = getModuleIncludes(mirror);
-    validateReferencedModules(subject,  builder, includedTypes);
+    validateReferencedModules(subject, builder, includedTypes, ImmutableSet.of(moduleKind));
+  }
+
+  private static ImmutableSet<? extends Class<? extends Annotation>> includedModuleClasses(
+      ImmutableSet<ModuleDescriptor.Kind> validModuleKinds) {
+    return FluentIterable.from(validModuleKinds)
+        .transformAndConcat(
+            new Function<ModuleDescriptor.Kind, Set<? extends Class<? extends Annotation>>>() {
+              @Override
+              public Set<? extends Class<? extends Annotation>> apply(
+                  ModuleDescriptor.Kind moduleKind) {
+                return moduleKind.includesTypes();
+              }
+            })
+        .toSet();
   }
 
   /**
@@ -153,7 +162,11 @@ private void validateReferencedModules(
   void validateReferencedModules(
       final TypeElement subject,
       final ValidationReport.Builder<TypeElement> builder,
-      ImmutableList<TypeMirror> includedTypes) {
+      ImmutableList<TypeMirror> includedTypes,
+      ImmutableSet<ModuleDescriptor.Kind> validModuleKinds) {
+    final ImmutableSet<? extends Class<? extends Annotation>> includedModuleClasses =
+        includedModuleClasses(validModuleKinds);
+
     for (TypeMirror includedType : includedTypes) {
       includedType.accept(
           new SimpleTypeVisitor6<Void, Void>() {
@@ -215,6 +228,7 @@ public String apply(
 
   private void validateProvidesOverrides(
       TypeElement subject,
+      ModuleDescriptor.Kind moduleKind,
       ValidationReport.Builder<TypeElement> builder,
       ListMultimap<String, ExecutableElement> allMethodsByName,
       ListMultimap<String, ExecutableElement> bindingMethodsByName) {
@@ -251,13 +265,13 @@ private void validateProvidesOverrides(
             builder.addError(
                 String.format(
                     PROVIDES_METHOD_OVERRIDES_ANOTHER,
-                    methodClass.getSimpleName(),
+                    moduleKind.methodAnnotation().getSimpleName(),
                     methodSignatureFormatter.format(superclassMethod)),
                 providesMethod);
           }
         }
         // For each @Provides method in superclass, confirm our methods don't override it.
-        if (isAnnotationPresent(superclassMethod, methodClass)) {
+        if (isAnnotationPresent(superclassMethod, moduleKind.methodAnnotation())) {
           for (ExecutableElement method : allMethodsByName.get(name)) {
             if (!failedMethods.contains(method)
                 && elements.overrides(method, superclassMethod, subject)) {
@@ -265,7 +279,7 @@ private void validateProvidesOverrides(
               builder.addError(
                   String.format(
                       METHOD_OVERRIDES_PROVIDES_METHOD,
-                      methodClass.getSimpleName(),
+                      moduleKind.methodAnnotation().getSimpleName(),
                       methodSignatureFormatter.format(superclassMethod)),
                   method);
             }
@@ -276,7 +290,9 @@ private void validateProvidesOverrides(
     }
   }
 
-  private void validateModuleVisibility(final TypeElement moduleElement,
+  private void validateModuleVisibility(
+      final TypeElement moduleElement,
+      ModuleDescriptor.Kind moduleKind,
       final ValidationReport.Builder<?> reportBuilder) {
     Visibility moduleVisibility = Visibility.ofElement(moduleElement);
     if (moduleVisibility.equals(PRIVATE)) {
@@ -293,18 +309,24 @@ private void validateModuleVisibility(final TypeElement moduleElement,
       case MEMBER:
       case TOP_LEVEL:
         if (moduleVisibility.equals(PUBLIC)) {
-          ImmutableSet<Element> nonPublicModules = FluentIterable.from(getModuleIncludes(
-              getAnnotationMirror(moduleElement, moduleClass).get()))
-                  .transform(new Function<TypeMirror, Element>() {
-                    @Override public Element apply(TypeMirror input) {
-                      return types.asElement(input);
-                    }
-                  })
-                  .filter(new Predicate<Element>() {
-                    @Override public boolean apply(Element input) {
-                      return effectiveVisibilityOfElement(input).compareTo(PUBLIC) < 0;
-                    }
-                  })
+          ImmutableSet<Element> nonPublicModules =
+              FluentIterable.from(
+                      getModuleIncludes(
+                          getAnnotationMirror(moduleElement, moduleKind.moduleAnnotation()).get()))
+                  .transform(
+                      new Function<TypeMirror, Element>() {
+                        @Override
+                        public Element apply(TypeMirror input) {
+                          return types.asElement(input);
+                        }
+                      })
+                  .filter(
+                      new Predicate<Element>() {
+                        @Override
+                        public boolean apply(Element input) {
+                          return effectiveVisibilityOfElement(input).compareTo(PUBLIC) < 0;
+                        }
+                      })
                   .toSet();
           if (!nonPublicModules.isEmpty()) {
             reportBuilder.addError(
diff --git a/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleGenerator.java
index a4e020b32..c6b3344da 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleGenerator.java
@@ -35,6 +35,7 @@
 import javax.inject.Provider;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.util.Elements;
 
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.STATIC;
@@ -46,8 +47,8 @@
       ParameterizedTypeName.create(
           Set.class, ClassName.fromClass(ProductionComponentMonitor.Factory.class));
 
-  MonitoringModuleGenerator(Filer filer) {
-    super(filer);
+  MonitoringModuleGenerator(Filer filer, Elements elements) {
+    super(filer, elements);
   }
 
   @Override
@@ -69,7 +70,6 @@ ClassName nameGeneratedType(TypeElement componentElement) {
   ImmutableSet<JavaWriter> write(ClassName generatedTypeName, TypeElement componentElement) {
     JavaWriter writer = JavaWriter.inPackage(generatedTypeName.packageName());
     ClassWriter classWriter = writer.addClass(generatedTypeName.simpleName());
-    classWriter.annotate(Generated.class).setValue(ComponentProcessor.class.getName());
     classWriter.annotate(Module.class);
     classWriter.addModifiers(FINAL);
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/MultibindingDeclaration.java b/compiler/src/main/java/dagger/internal/codegen/MultibindingDeclaration.java
new file mode 100644
index 000000000..e708e35e9
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/MultibindingDeclaration.java
@@ -0,0 +1,160 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreTypes;
+import com.google.auto.value.AutoValue;
+import com.google.common.collect.ImmutableSet;
+import dagger.Module;
+import dagger.Multibindings;
+import dagger.internal.codegen.BindingType.HasBindingType;
+import dagger.internal.codegen.ContributionType.HasContributionType;
+import dagger.internal.codegen.Key.HasKey;
+import dagger.internal.codegen.SourceElement.HasSourceElement;
+import dagger.producers.Producer;
+import dagger.producers.ProducerModule;
+import java.util.Map;
+import java.util.Set;
+import javax.inject.Provider;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.ExecutableType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+
+import static com.google.auto.common.MoreElements.getLocalAndInheritedMethods;
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.base.Preconditions.checkArgument;
+import static javax.lang.model.element.ElementKind.INTERFACE;
+
+/**
+ * A declaration that a multibinding with a certain key is available to be injected in a component
+ * even if the component has no multibindings for that key. Identified by a map- or set-returning
+ * method in a {@link Multibindings @Multibindings}-annotated interface nested within a module.
+ */
+@AutoValue
+abstract class MultibindingDeclaration
+    implements HasBindingType, HasKey, HasSourceElement, HasContributionType {
+
+  /**
+   * The method in a {@link Multibindings @Multibindings} interface that declares that this map or
+   * set is available to be injected.
+   */
+  @Override
+  public abstract SourceElement sourceElement();
+
+  /**
+   * The map or set key whose availability is declared. For maps, this will be {@code Map<K, F<V>>},
+   * where {@code F} is either {@link Provider} or {@link Producer}. For sets, this will be
+   * {@code Set<T>}.
+   */
+  @Override
+  public abstract Key key();
+
+  /**
+   * {@link ContributionType#SET} if the declared type is a {@link Set}, or
+   * {@link ContributionType#MAP} if it is a {@link Map}.
+   */
+  @Override
+  public abstract ContributionType contributionType();
+
+  /**
+   * {@link BindingType#PROVISION} if the {@link Multibindings @Multibindings}-annotated interface
+   * is nested in a {@link Module @Module}, or {@link BindingType#PROVISION} if it is nested in a
+   * {@link ProducerModule @ProducerModule}.
+   */
+  @Override
+  public abstract BindingType bindingType();
+
+  /**
+   * A factory for {@link MultibindingDeclaration}s.
+   */
+  static final class Factory {
+    private final Elements elements;
+    private final Types types;
+    private final Key.Factory keyFactory;
+    private final TypeElement objectElement;
+
+    Factory(Elements elements, Types types, Key.Factory keyFactory) {
+      this.elements = elements;
+      this.types = types;
+      this.keyFactory = keyFactory;
+      this.objectElement = elements.getTypeElement(Object.class.getCanonicalName());
+    }
+
+    /**
+     * Creates multibinding declarations for each method in a
+     * {@link Multibindings @Multibindings}-annotated interface.
+     */
+    ImmutableSet<MultibindingDeclaration> forDeclaredInterface(TypeElement interfaceElement) {
+      checkArgument(interfaceElement.getKind().equals(INTERFACE));
+      checkArgument(isAnnotationPresent(interfaceElement, Multibindings.class));
+      BindingType bindingType = bindingType(interfaceElement);
+      DeclaredType interfaceType = MoreTypes.asDeclared(interfaceElement.asType());
+
+      ImmutableSet.Builder<MultibindingDeclaration> declarations = ImmutableSet.builder();
+      for (ExecutableElement method : getLocalAndInheritedMethods(interfaceElement, elements)) {
+        if (!method.getEnclosingElement().equals(objectElement)) {
+          ExecutableType methodType =
+              MoreTypes.asExecutable(types.asMemberOf(interfaceType, method));
+          declarations.add(forDeclaredMethod(bindingType, method, methodType, interfaceElement));
+        }
+      }
+      return declarations.build();
+    }
+
+    private BindingType bindingType(TypeElement interfaceElement) {
+      if (isAnnotationPresent(interfaceElement.getEnclosingElement(), Module.class)) {
+        return BindingType.PROVISION;
+      } else if (isAnnotationPresent(
+          interfaceElement.getEnclosingElement(), ProducerModule.class)) {
+        return BindingType.PRODUCTION;
+      } else {
+        throw new IllegalArgumentException(
+            "Expected " + interfaceElement + " to be nested in a @Module or @ProducerModule");
+      }
+    }
+
+    private MultibindingDeclaration forDeclaredMethod(
+        BindingType bindingType,
+        ExecutableElement method,
+        ExecutableType methodType,
+        TypeElement interfaceElement) {
+      TypeMirror returnType = methodType.getReturnType();
+      checkArgument(
+          SetType.isSet(returnType) || MapType.isMap(returnType),
+          "%s must return a set or map",
+          method);
+      return new AutoValue_MultibindingDeclaration(
+          SourceElement.forElement(method, interfaceElement),
+          keyFactory.forMultibindingsMethod(bindingType, methodType, method),
+          contributionType(returnType),
+          bindingType);
+    }
+
+    private ContributionType contributionType(TypeMirror returnType) {
+      if (MapType.isMap(returnType)) {
+        return ContributionType.MAP;
+      } else if (SetType.isSet(returnType)) {
+        return ContributionType.SET;
+      } else {
+        throw new IllegalArgumentException("Must be Map or Set: " + returnType);
+      }
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/MultibindingsProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/MultibindingsProcessingStep.java
new file mode 100644
index 000000000..db14a695b
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/MultibindingsProcessingStep.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.SetMultimap;
+import dagger.Multibindings;
+import java.lang.annotation.Annotation;
+import java.util.Set;
+import javax.annotation.processing.Messager;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
+
+import static javax.lang.model.util.ElementFilter.typesIn;
+
+/**
+ * Processes elements annotated with {@link Multibindings @Multibindings}.
+ */
+class MultibindingsProcessingStep implements ProcessingStep {
+  private final Messager messager;
+  private final MultibindingsValidator multibindingsValidator;
+
+  MultibindingsProcessingStep(Messager messager, MultibindingsValidator multibindingsValidator) {
+    this.messager = messager;
+    this.multibindingsValidator = multibindingsValidator;
+  }
+
+  @Override
+  public Set<? extends Class<? extends Annotation>> annotations() {
+    return ImmutableSet.of(Multibindings.class);
+  }
+
+  @Override
+  public Set<Element> process(
+      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+    for (TypeElement element : typesIn(elementsByAnnotation.values())) {
+      multibindingsValidator.validate(element).printMessagesTo(messager);
+    }
+    return ImmutableSet.of();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/MultibindingsValidator.java b/compiler/src/main/java/dagger/internal/codegen/MultibindingsValidator.java
new file mode 100644
index 000000000..d68e1dec3
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/MultibindingsValidator.java
@@ -0,0 +1,165 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreTypes;
+import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableListMultimap;
+import com.google.common.collect.ImmutableSet;
+import dagger.Module;
+import dagger.Multibindings;
+import dagger.producers.Produced;
+import dagger.producers.Producer;
+import dagger.producers.ProducerModule;
+import java.util.Collection;
+import java.util.Map;
+import javax.inject.Provider;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+
+import static com.google.auto.common.MoreElements.getLocalAndInheritedMethods;
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.auto.common.MoreTypes.asExecutable;
+import static dagger.internal.codegen.ErrorMessages.DUPLICATE_SIZE_LIMIT;
+import static dagger.internal.codegen.ErrorMessages.MultibindingsMessages.METHOD_MUST_RETURN_MAP_OR_SET;
+import static dagger.internal.codegen.ErrorMessages.MultibindingsMessages.MUST_BE_INTERFACE;
+import static dagger.internal.codegen.ErrorMessages.MultibindingsMessages.MUST_BE_IN_MODULE;
+import static dagger.internal.codegen.ErrorMessages.MultibindingsMessages.MUST_NOT_HAVE_TYPE_PARAMETERS;
+import static dagger.internal.codegen.ErrorMessages.MultibindingsMessages.TOO_MANY_QUALIFIERS;
+import static dagger.internal.codegen.ErrorMessages.MultibindingsMessages.tooManyMethodsForKey;
+import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
+import static javax.lang.model.element.ElementKind.INTERFACE;
+
+/**
+ * A {@linkplain ValidationReport validator} for {@link Multibindings @Multibindings}-annotated
+ * types.
+ */
+final class MultibindingsValidator {
+  private final Elements elements;
+  private final Key.Factory keyFactory;
+  private final KeyFormatter keyFormatter;
+  private final MethodSignatureFormatter methodSignatureFormatter;
+  private final TypeElement objectElement;
+
+  MultibindingsValidator(
+      Elements elements,
+      Key.Factory keyFactory,
+      KeyFormatter keyFormatter,
+      MethodSignatureFormatter methodSignatureFormatter) {
+    this.elements = elements;
+    this.keyFactory = keyFactory;
+    this.keyFormatter = keyFormatter;
+    this.methodSignatureFormatter = methodSignatureFormatter;
+    this.objectElement = elements.getTypeElement(Object.class.getCanonicalName());
+  }
+
+  /**
+   * Returns a report containing validation errors for a
+   * {@link Multibindings @Multibindings}-annotated type.
+   */
+  public ValidationReport<TypeElement> validate(TypeElement multibindingsType) {
+    ValidationReport.Builder<TypeElement> validation = ValidationReport.about(multibindingsType);
+    if (!multibindingsType.getKind().equals(INTERFACE)) {
+      validation.addError(MUST_BE_INTERFACE, multibindingsType);
+    }
+    if (!multibindingsType.getTypeParameters().isEmpty()) {
+      validation.addError(MUST_NOT_HAVE_TYPE_PARAMETERS, multibindingsType);
+    }
+    Optional<BindingType> bindingType = bindingType(multibindingsType);
+    if (!bindingType.isPresent()) {
+      validation.addError(MUST_BE_IN_MODULE, multibindingsType);
+    }
+
+    ImmutableListMultimap.Builder<Key, ExecutableElement> methodsByKey =
+        ImmutableListMultimap.builder();
+    for (ExecutableElement method : getLocalAndInheritedMethods(multibindingsType, elements)) {
+      // Skip methods in Object.
+      if (method.getEnclosingElement().equals(objectElement)) {
+        continue;
+      }
+      if (!isPlainMap(method.getReturnType()) && !isPlainSet(method.getReturnType())) {
+        validation.addError(METHOD_MUST_RETURN_MAP_OR_SET, method);
+        continue;
+      }
+      ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(method);
+      if (qualifiers.size() > 1) {
+        for (AnnotationMirror qualifier : qualifiers) {
+          validation.addError(TOO_MANY_QUALIFIERS, method, qualifier);
+        }
+        continue;
+      }
+      if (bindingType.isPresent()) {
+        methodsByKey.put(
+            keyFactory.forMultibindingsMethod(
+                bindingType.get(), asExecutable(method.asType()), method),
+            method);
+      }
+    }
+    for (Map.Entry<Key, Collection<ExecutableElement>> entry :
+        methodsByKey.build().asMap().entrySet()) {
+      Collection<ExecutableElement> methods = entry.getValue();
+      if (methods.size() > 1) {
+        Key key = entry.getKey();
+        validation.addError(tooManyMultibindingsMethodsForKey(key, methods), multibindingsType);
+      }
+    }
+    return validation.build();
+  }
+
+  private String tooManyMultibindingsMethodsForKey(Key key, Collection<ExecutableElement> methods) {
+    StringBuilder builder = new StringBuilder(tooManyMethodsForKey(keyFormatter.format(key)));
+    builder.append(':');
+    methodSignatureFormatter.formatIndentedList(builder, methods, 1, DUPLICATE_SIZE_LIMIT);
+    return builder.toString();
+  }
+
+  private Optional<BindingType> bindingType(TypeElement multibindingsType) {
+    if (isAnnotationPresent(multibindingsType.getEnclosingElement(), Module.class)) {
+      return Optional.of(BindingType.PROVISION);
+    } else if (isAnnotationPresent(multibindingsType.getEnclosingElement(), ProducerModule.class)) {
+      return Optional.of(BindingType.PRODUCTION);
+    } else {
+      return Optional.<BindingType>absent();
+    }
+  }
+
+  private boolean isPlainMap(TypeMirror returnType) {
+    if (!MapType.isMap(returnType)) {
+      return false;
+    }
+    MapType mapType = MapType.from(returnType);
+    return !mapType.isRawType()
+        && MoreTypes.isType(mapType.valueType()) // No wildcards.
+        && !mapType.valuesAreTypeOf(Provider.class)
+        && !mapType.valuesAreTypeOf(Producer.class)
+        && !mapType.valuesAreTypeOf(Produced.class);
+  }
+
+  private boolean isPlainSet(TypeMirror returnType) {
+    if (!SetType.isSet(returnType)) {
+      return false;
+    }
+    SetType setType = SetType.from(returnType);
+    return !setType.isRawType()
+        && MoreTypes.isType(setType.elementType()) // No wildcards.
+        && !setType.elementsAreTypeOf(Provider.class)
+        && !setType.elementsAreTypeOf(Producer.class)
+        && !setType.elementsAreTypeOf(Produced.class);
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
index 90a0337bd..154372b77 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -15,7 +15,6 @@
  */
 package dagger.internal.codegen;
 
-import com.google.auto.common.MoreTypes;
 import com.google.common.base.Function;
 import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
@@ -52,6 +51,7 @@
 import javax.annotation.processing.Filer;
 import javax.lang.model.element.Element;
 import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
 
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
 import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
@@ -71,8 +71,9 @@
 final class ProducerFactoryGenerator extends SourceFileGenerator<ProductionBinding> {
   private final DependencyRequestMapper dependencyRequestMapper;
 
-  ProducerFactoryGenerator(Filer filer, DependencyRequestMapper dependencyRequestMapper) {
-    super(filer);
+  ProducerFactoryGenerator(
+      Filer filer, Elements elements, DependencyRequestMapper dependencyRequestMapper) {
+    super(filer, elements);
     this.dependencyRequestMapper = dependencyRequestMapper;
   }
 
@@ -93,9 +94,10 @@ ClassName nameGeneratedType(ProductionBinding binding) {
 
   @Override
   ImmutableSet<JavaWriter> write(ClassName generatedTypeName, ProductionBinding binding) {
-    TypeMirror keyType = binding.productionType().equals(Type.MAP)
-        ? Util.getProvidedValueTypeOfMap(MoreTypes.asDeclared(binding.key().type()))
-        : binding.key().type();
+    TypeMirror keyType =
+        binding.productionType().equals(Type.MAP)
+            ? MapType.from(binding.key().type()).unwrappedValueType(Producer.class)
+            : binding.key().type();
     TypeName providedTypeName = TypeNames.forTypeMirror(keyType);
     TypeName futureTypeName = ParameterizedTypeName.create(
         ClassName.fromClass(ListenableFuture.class), providedTypeName);
@@ -106,8 +108,7 @@ ClassName nameGeneratedType(ProductionBinding binding) {
     constructorWriter.addModifiers(PUBLIC);
 
     ImmutableMap<BindingKey, FrameworkField> fields =
-        SourceFiles.generateBindingFieldsForDependencies(
-            dependencyRequestMapper, binding.implicitDependencies());
+        SourceFiles.generateBindingFieldsForDependencies(dependencyRequestMapper, binding);
 
     constructorWriter
         .body()
@@ -133,7 +134,6 @@ ClassName nameGeneratedType(ProductionBinding binding) {
         .addSnippet("assert executor != null;")
         .addSnippet("this.executor = executor;");
 
-    factoryWriter.annotate(Generated.class).setValue(ComponentProcessor.class.getName());
     factoryWriter.addModifiers(PUBLIC);
     factoryWriter.addModifiers(FINAL);
     factoryWriter.setSuperclass(
@@ -176,9 +176,9 @@ public boolean apply(DependencyRequest dependency) {
       computeMethodWriter
           .body()
           .addSnippet(
-              "%s %sFuture = %s;",
+              "%s %s = %s;",
               futureType,
-              name,
+              dependencyFutureName(dependency),
               dependency.kind().equals(DependencyRequest.Kind.PRODUCED)
                   ? Snippet.format(
                       "%s.createFutureProduced(%s)",
@@ -220,6 +220,11 @@ public boolean apply(DependencyRequest dependency) {
     return ImmutableSet.of(writer);
   }
 
+  /** Returns a name of the variable representing this dependency's future. */
+  private static String dependencyFutureName(DependencyRequest dependency) {
+    return dependency.requestElement().getSimpleName() + "Future";
+  }
+
   /** Represents the transformation of an input future by a producer method. */
   abstract static class FutureTransform {
     protected final ImmutableMap<BindingKey, FrameworkField> fields;
@@ -312,7 +317,7 @@ String applyArgName() {
 
     @Override
     Snippet futureSnippet() {
-      return Snippet.format("%s", fields.get(asyncDependency.bindingKey()).name() + "Future");
+      return Snippet.format("%s", dependencyFutureName(asyncDependency));
     }
 
     @Override
@@ -363,12 +368,11 @@ Snippet futureSnippet() {
           ClassName.fromClass(Object.class),
           makeParametersSnippet(
               FluentIterable.from(asyncDependencies)
-                  .transform(DependencyRequest.BINDING_KEY_FUNCTION)
                   .transform(
-                      new Function<BindingKey, Snippet>() {
+                      new Function<DependencyRequest, Snippet>() {
                         @Override
-                        public Snippet apply(BindingKey bindingKey) {
-                          return Snippet.format("%s", fields.get(bindingKey).name() + "Future");
+                        public Snippet apply(DependencyRequest dependency) {
+                          return Snippet.format("%s", dependencyFutureName(dependency));
                         }
                       })));
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
index b0b4df1cc..62079a625 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
@@ -47,6 +47,7 @@
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_RAW_FUTURE;
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_RETURN_TYPE;
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_SET_VALUES_RETURN_SET;
+import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_THROWS;
 import static dagger.internal.codegen.MapKeys.getMapKeys;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.PRIVATE;
@@ -54,19 +55,23 @@
 import static javax.lang.model.type.TypeKind.DECLARED;
 import static javax.lang.model.type.TypeKind.VOID;
 
+import javax.lang.model.util.Types;
+
 /**
  * A {@linkplain ValidationReport validator} for {@link Produces} methods.
  *
  * @author Jesse Beder
  * @since 2.0
  */
-// TODO(user): Consider unifying this with the ProvidesMethodValidator after Provides.Type and
+// TODO(beder): Consider unifying this with the ProvidesMethodValidator after Provides.Type and
 // Produces.Type are reconciled.
 final class ProducesMethodValidator {
   private final Elements elements;
+  private final Types types;
 
-  ProducesMethodValidator(Elements elements) {
+  ProducesMethodValidator(Elements elements, Types types) {
     this.elements = checkNotNull(elements);
+    this.types = checkNotNull(types);
   }
 
   private TypeElement getSetElement() {
@@ -105,6 +110,15 @@ private TypeElement getSetElement() {
           formatErrorMessage(BINDING_METHOD_MUST_RETURN_A_VALUE), producesMethodElement);
     }
 
+    TypeMirror exceptionType = elements.getTypeElement(Exception.class.getCanonicalName()).asType();
+    TypeMirror errorType = elements.getTypeElement(Error.class.getCanonicalName()).asType();
+    for (TypeMirror thrownType : producesMethodElement.getThrownTypes()) {
+      if (!types.isSubtype(thrownType, exceptionType) && !types.isSubtype(thrownType, errorType)) {
+        builder.addError(PRODUCES_METHOD_THROWS, producesMethodElement);
+        break;
+      }
+    }
+
     // check mapkey is right
     if (!producesAnnotation.type().equals(Produces.Type.MAP)
         && !getMapKeys(producesMethodElement).isEmpty()) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
index 1666fbf8c..391d804e4 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
@@ -26,7 +26,6 @@
 import dagger.producers.Produces;
 import java.util.Set;
 import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeKind;
@@ -48,8 +47,13 @@
 abstract class ProductionBinding extends ContributionBinding {
 
   @Override
-  Binding.Type bindingType() {
-    return Binding.Type.PRODUCTION;
+  public BindingType bindingType() {
+    return BindingType.PRODUCTION;
+  }
+
+  @Override
+  Optional<ProductionBinding> unresolved() {
+    return Optional.absent();
   }
 
   @Override
@@ -76,21 +80,6 @@
   /** If this production requires a monitor, this will be the corresponding request. */
   abstract Optional<DependencyRequest> monitorRequest();
 
-  @Override
-  ContributionType contributionType() {
-    switch (productionType()) {
-      case SET:
-      case SET_VALUES:
-        return ContributionType.SET;
-      case MAP:
-        return ContributionType.MAP;
-      case UNIQUE:
-        return ContributionType.UNIQUE;
-      default:
-        throw new AssertionError("Unknown production type: " + productionType());
-    }
-  }
-
   static final class Factory {
     private final Types types;
     private final Key.Factory keyFactory;
@@ -125,13 +114,11 @@ ProductionBinding forProducesMethod(
           ? Kind.FUTURE_PRODUCTION
           : Kind.IMMEDIATE;
       return new AutoValue_ProductionBinding(
+          SourceElement.forElement(producesMethod, MoreTypes.asTypeElement(declaredContainer)),
           key,
-          producesMethod,
           dependencies,
           findBindingPackage(key),
-          false,
           ConfigurationAnnotations.getNullableType(producesMethod),
-          Optional.of(MoreTypes.asTypeElement(declaredContainer)),
           Optional.<DependencyRequest>absent(),
           kind,
           producesAnnotation.type(),
@@ -149,16 +136,14 @@ ProductionBinding implicitMapOfProducerBinding(DependencyRequest mapOfValueReque
           dependencyRequestFactory.forImplicitMapBinding(
               mapOfValueRequest, implicitMapOfProducerKey.get());
       return new AutoValue_ProductionBinding(
+          SourceElement.forElement(implicitMapOfProducerRequest.requestElement()),
           mapOfValueRequest.key(),
-          implicitMapOfProducerRequest.requestElement(),
           ImmutableSet.of(implicitMapOfProducerRequest),
           findBindingPackage(mapOfValueRequest.key()),
-          false,
           Optional.<DeclaredType>absent(),
-          Optional.<TypeElement>absent(),
           Optional.<DependencyRequest>absent(),
-          Kind.SYNTHETIC,
-          Produces.Type.MAP,
+          Kind.SYNTHETIC_MAP,
+          Produces.Type.UNIQUE,
           ImmutableList.<TypeMirror>of(),
           Optional.<DependencyRequest>absent());
     }
@@ -169,13 +154,11 @@ ProductionBinding forComponentMethod(ExecutableElement componentMethod) {
       checkArgument(componentMethod.getParameters().isEmpty());
       checkArgument(MoreTypes.isTypeOf(ListenableFuture.class, componentMethod.getReturnType()));
       return new AutoValue_ProductionBinding(
+          SourceElement.forElement(componentMethod),
           keyFactory.forProductionComponentMethod(componentMethod),
-          componentMethod,
           ImmutableSet.<DependencyRequest>of(),
           Optional.<String>absent(),
-          false,
           Optional.<DeclaredType>absent(),
-          Optional.<TypeElement>absent(),
           Optional.<DependencyRequest>absent(),
           Kind.COMPONENT_PRODUCTION,
           Produces.Type.UNIQUE,
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionComponentProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ProductionComponentProcessingStep.java
deleted file mode 100644
index 0581b1bb1..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionComponentProcessingStep.java
+++ /dev/null
@@ -1,103 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
-import com.google.auto.common.MoreElements;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Maps;
-import com.google.common.collect.SetMultimap;
-import dagger.producers.ProductionComponent;
-import java.lang.annotation.Annotation;
-import java.util.Map;
-import java.util.Set;
-import javax.annotation.processing.Messager;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.TypeElement;
-
-/**
- * A {@link ProcessingStep} that is responsible for dealing with the {@link ProductionComponent}
- * annotation as part of the {@link ComponentProcessor}.
- *
- * @author Jesse Beder
- */
-final class ProductionComponentProcessingStep extends AbstractComponentProcessingStep {
-  private final Messager messager;
-  private final ProductionComponentValidator componentValidator;
-  private final BuilderValidator componentBuilderValidator;
-
-  ProductionComponentProcessingStep(
-      Messager messager,
-      ProductionComponentValidator componentValidator,
-      BuilderValidator componentBuilderValidator,
-      ComponentHierarchyValidator componentHierarchyValidator,
-      BindingGraphValidator bindingGraphValidator,
-      ComponentDescriptor.Factory componentDescriptorFactory,
-      BindingGraph.Factory bindingGraphFactory,
-      ComponentGenerator componentGenerator) {
-    super(
-        ProductionComponent.class,
-        messager,
-        componentHierarchyValidator,
-        bindingGraphValidator,
-        componentDescriptorFactory,
-        bindingGraphFactory,
-        componentGenerator);
-    this.messager = messager;
-    this.componentValidator = componentValidator;
-    this.componentBuilderValidator = componentBuilderValidator;
-  }
-
-  @Override
-  public Set<Class<? extends Annotation>> annotations() {
-    return ImmutableSet.<Class<? extends Annotation>>of(
-        ProductionComponent.class, ProductionComponent.Builder.class);
-  }
-
-  // TODO(beder): Move common logic into the AbstractComponentProcessingStep when implementing
-  // production subcomponents.
-  @Override
-  protected ComponentElementValidator componentElementValidator(
-      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
-    final Map<Element, ValidationReport<TypeElement>> builderReportsByComponent =
-        processComponentBuilders(elementsByAnnotation.get(ProductionComponent.Builder.class));
-    return new ComponentElementValidator() {
-      @Override
-      boolean validateComponent(TypeElement componentTypeElement, Messager messager) {
-        ValidationReport<TypeElement> validationReport =
-            componentValidator.validate(componentTypeElement);
-        validationReport.printMessagesTo(messager);
-        if (!validationReport.isClean()) {
-          return false;
-        }
-        ValidationReport<?> builderReport = builderReportsByComponent.get(componentTypeElement);
-        return builderReport == null || builderReport.isClean();
-      }
-    };
-  }
-
-  private Map<Element, ValidationReport<TypeElement>> processComponentBuilders(
-      Set<? extends Element> componentBuilderElements) {
-    Map<Element, ValidationReport<TypeElement>> builderReportsByComponent = Maps.newHashMap();
-    for (Element element : componentBuilderElements) {
-      ValidationReport<TypeElement> report =
-          componentBuilderValidator.validate(MoreElements.asType(element));
-      report.printMessagesTo(messager);
-      builderReportsByComponent.put(element.getEnclosingElement(), report);
-    }
-    return builderReportsByComponent;
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionComponentValidator.java b/compiler/src/main/java/dagger/internal/codegen/ProductionComponentValidator.java
deleted file mode 100644
index 2e2291d34..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionComponentValidator.java
+++ /dev/null
@@ -1,85 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import com.google.auto.common.MoreElements;
-import com.google.common.collect.ImmutableList;
-import dagger.Module;
-import dagger.producers.ProducerModule;
-import dagger.producers.ProductionComponent;
-import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.DeclaredType;
-import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.SimpleTypeVisitor6;
-
-import static com.google.auto.common.MoreElements.getAnnotationMirror;
-import static com.google.common.base.Preconditions.checkState;
-import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
-import static javax.lang.model.element.ElementKind.CLASS;
-import static javax.lang.model.element.ElementKind.INTERFACE;
-import static javax.lang.model.element.Modifier.ABSTRACT;
-
-/**
- * Performs superficial validation of the contract of the {@link ProductionComponent} annotation.
- *
- * @author Jesse Beder
- */
-final class ProductionComponentValidator {
-  ValidationReport<TypeElement> validate(final TypeElement subject) {
-    final ValidationReport.Builder<TypeElement> builder = ValidationReport.about(subject);
-
-    if (!subject.getKind().equals(INTERFACE)
-        && !(subject.getKind().equals(CLASS) && subject.getModifiers().contains(ABSTRACT))) {
-      builder.addError(
-          "@ProductionComponent may only be applied to an interface or abstract class", subject);
-    }
-
-    AnnotationMirror componentMirror =
-        getAnnotationMirror(subject, ProductionComponent.class).get();
-    ImmutableList<TypeMirror> moduleTypes = getComponentModules(componentMirror);
-
-    // TODO(gak): make unused modules an error
-    for (TypeMirror moduleType : moduleTypes) {
-      moduleType.accept(
-          new SimpleTypeVisitor6<Void, Void>() {
-            @Override
-            protected Void defaultAction(TypeMirror mirror, Void p) {
-              builder.addError(mirror + " is not a valid module type.", subject);
-              return null;
-            }
-
-            @Override
-            public Void visitDeclared(DeclaredType t, Void p) {
-              checkState(t.getTypeArguments().isEmpty());
-              TypeElement moduleElement = MoreElements.asType(t.asElement());
-              if (!getAnnotationMirror(moduleElement, Module.class).isPresent()
-                  && !getAnnotationMirror(moduleElement, ProducerModule.class).isPresent()) {
-                builder.addError(
-                    moduleElement.getQualifiedName()
-                        + " is listed as a module, but is not annotated with @Module or"
-                        + " @ProducerModule",
-                    subject);
-              }
-              return null;
-            }
-          },
-          null);
-    }
-
-    return builder.build();
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
index e9c8b1629..094511611 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
@@ -44,6 +44,7 @@
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_NO_MAP_KEY;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_RETURN_TYPE;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_SET_VALUES_RETURN_SET;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_THROWS;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_OR_PRODUCES_METHOD_MULTIPLE_QUALIFIERS;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
 import static dagger.internal.codegen.MapKeys.getMapKeys;
@@ -53,6 +54,8 @@
 import static javax.lang.model.type.TypeKind.DECLARED;
 import static javax.lang.model.type.TypeKind.VOID;
 
+import javax.lang.model.util.Types;
+
 /**
  * A {@linkplain ValidationReport validator} for {@link Provides} methods.
  *
@@ -61,9 +64,11 @@
  */
 final class ProvidesMethodValidator {
   private final Elements elements;
+  private final Types types;
 
-  ProvidesMethodValidator(Elements elements) {
+  ProvidesMethodValidator(Elements elements, Types types) {
     this.elements = checkNotNull(elements);
+    this.types = checkNotNull(types);
   }
 
   private TypeElement getSetElement() {
@@ -102,6 +107,17 @@ private TypeElement getSetElement() {
           formatErrorMessage(BINDING_METHOD_MUST_RETURN_A_VALUE), providesMethodElement);
     }
 
+    TypeMirror runtimeExceptionType =
+        elements.getTypeElement(RuntimeException.class.getCanonicalName()).asType();
+    TypeMirror errorType = elements.getTypeElement(Error.class.getCanonicalName()).asType();
+    for (TypeMirror thrownType : providesMethodElement.getThrownTypes()) {
+      if (!types.isSubtype(thrownType, runtimeExceptionType)
+          && !types.isSubtype(thrownType, errorType)) {
+        builder.addError(PROVIDES_METHOD_THROWS, providesMethodElement);
+        break;
+      }
+    }
+
     // check mapkey is right
     if (!providesAnnotation.type().equals(Provides.Type.MAP)
         && !getMapKeys(providesMethodElement).isEmpty()) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index b2ac74fb3..7b2fb5d8e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -54,15 +54,18 @@
  */
 @AutoValue
 abstract class ProvisionBinding extends ContributionBinding {
-  
+
   @Override
-  Binding.Type bindingType() {
-    return Binding.Type.PROVISION;
+  public BindingType bindingType() {
+    return BindingType.PROVISION;
   }
-  
+
   @Override
-  abstract Scope scope();
+  abstract Optional<ProvisionBinding> unresolved();
 
+  @Override
+  abstract Scope scope();
+  
   static final class Factory {
     private final Elements elements;
     private final Types types;
@@ -77,13 +80,6 @@
       this.dependencyRequestFactory = dependencyRequestFactory;
     }
 
-    /** Returns an unresolved version of this binding. */
-    ProvisionBinding unresolve(ProvisionBinding binding) {
-      checkState(binding.hasNonDefaultTypeParameters());
-      return forInjectConstructor((ExecutableElement) binding.bindingElement(),
-          Optional.<TypeMirror>absent());
-    }
-
     /**
      * Returns a ProvisionBinding for the given element. If {@code resolvedType} is present, this
      * will return a resolved binding, with the key & type resolved to the given type (using
@@ -124,16 +120,17 @@ ProvisionBinding forInjectConstructor(ExecutableElement constructorElement,
           MoreElements.asType(constructorElement.getEnclosingElement());
 
       return new AutoValue_ProvisionBinding(
+          SourceElement.forElement(constructorElement),
           key,
-          constructorElement,
           dependencies,
           findBindingPackage(key),
-          hasNonDefaultTypeParameters(bindingTypeElement, key.type(), types),
           Optional.<DeclaredType>absent(),
-          Optional.<TypeElement>absent(),
           membersInjectionRequest,
           Kind.INJECTION,
           Provides.Type.UNIQUE,
+          hasNonDefaultTypeParameters(bindingTypeElement, key.type(), types)
+              ? Optional.of(forInjectConstructor(constructorElement, Optional.<TypeMirror>absent()))
+              : Optional.<ProvisionBinding>absent(),
           scope);
     }
 
@@ -172,19 +169,18 @@ ProvisionBinding forProvidesMethod(ExecutableElement providesMethod, TypeMirror
               resolvedMethod.getParameterTypes());
       Scope scope = Scope.scopeOf(providesMethod);
       return new AutoValue_ProvisionBinding(
+          SourceElement.forElement(providesMethod, MoreTypes.asTypeElement(declaredContainer)),
           key,
-          providesMethod,
           dependencies,
           findBindingPackage(key),
-          false /* no non-default parameter types */,
           ConfigurationAnnotations.getNullableType(providesMethod),
-          Optional.of(MoreTypes.asTypeElement(declaredContainer)),
           Optional.<DependencyRequest>absent(),
           Kind.PROVISION,
           providesAnnotation.type(),
+          Optional.<ProvisionBinding>absent(),
           scope);
     }
-
+    
     ProvisionBinding implicitMapOfProviderBinding(DependencyRequest mapOfValueRequest) {
       checkNotNull(mapOfValueRequest);
       Optional<Key> implicitMapOfProviderKey =
@@ -197,32 +193,30 @@ ProvisionBinding implicitMapOfProviderBinding(DependencyRequest mapOfValueReques
           dependencyRequestFactory.forImplicitMapBinding(
               mapOfValueRequest, implicitMapOfProviderKey.get());
       return new AutoValue_ProvisionBinding(
+          SourceElement.forElement(implicitMapOfProviderRequest.requestElement()),
           mapOfValueRequest.key(),
-          implicitMapOfProviderRequest.requestElement(),
           ImmutableSet.of(implicitMapOfProviderRequest),
           findBindingPackage(mapOfValueRequest.key()),
-          false /* no non-default parameter types */,
           Optional.<DeclaredType>absent(),
-          Optional.<TypeElement>absent(),
           Optional.<DependencyRequest>absent(),
-          Kind.SYNTHETIC,
-          Provides.Type.MAP,
+          Kind.SYNTHETIC_MAP,
+          Provides.Type.UNIQUE,
+          Optional.<ProvisionBinding>absent(),
           scopeOf(implicitMapOfProviderRequest.requestElement()));
     }
 
     ProvisionBinding forComponent(TypeElement componentDefinitionType) {
       checkNotNull(componentDefinitionType);
       return new AutoValue_ProvisionBinding(
+          SourceElement.forElement(componentDefinitionType),
           keyFactory.forComponent(componentDefinitionType.asType()),
-          componentDefinitionType,
           ImmutableSet.<DependencyRequest>of(),
           Optional.<String>absent(),
-          false /* no non-default parameter types */,
           Optional.<DeclaredType>absent(),
-          Optional.<TypeElement>absent(),
           Optional.<DependencyRequest>absent(),
           Kind.COMPONENT,
           Provides.Type.UNIQUE,
+          Optional.<ProvisionBinding>absent(),
           Scope.unscoped());
     }
 
@@ -232,16 +226,15 @@ ProvisionBinding forComponentMethod(ExecutableElement componentMethod) {
       checkArgument(componentMethod.getParameters().isEmpty());
       Scope scope = Scope.scopeOf(componentMethod);
       return new AutoValue_ProvisionBinding(
+          SourceElement.forElement(componentMethod),
           keyFactory.forComponentMethod(componentMethod),
-          componentMethod,
           ImmutableSet.<DependencyRequest>of(),
           Optional.<String>absent(),
-          false /* no non-default parameter types */,
           ConfigurationAnnotations.getNullableType(componentMethod),
-          Optional.<TypeElement>absent(),
           Optional.<DependencyRequest>absent(),
           Kind.COMPONENT_PROVISION,
           Provides.Type.UNIQUE,
+          Optional.<ProvisionBinding>absent(),
           scope);
     }
 
@@ -252,16 +245,15 @@ ProvisionBinding forSubcomponentBuilderMethod(
       checkArgument(subcomponentBuilderMethod.getParameters().isEmpty());
       DeclaredType declaredContainer = asDeclared(contributedBy.asType());
       return new AutoValue_ProvisionBinding(
+          SourceElement.forElement(subcomponentBuilderMethod, contributedBy),
           keyFactory.forSubcomponentBuilderMethod(subcomponentBuilderMethod, declaredContainer),
-          subcomponentBuilderMethod,
           ImmutableSet.<DependencyRequest>of(),
           Optional.<String>absent(),
-          false /* no non-default parameter types */,
           Optional.<DeclaredType>absent(),
-          Optional.of(contributedBy),
           Optional.<DependencyRequest>absent(),
           Kind.SUBCOMPONENT_BUILDER,
           Provides.Type.UNIQUE,
+          Optional.<ProvisionBinding>absent(),
           Scope.unscoped());
     }
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
index 024097ef0..62b102245 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
@@ -18,15 +18,24 @@
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Optional;
 import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Multimap;
+import dagger.MembersInjector;
+import dagger.internal.codegen.BindingType.HasBindingType;
+import dagger.internal.codegen.ContributionType.HasContributionType;
+import dagger.internal.codegen.Key.HasKey;
+import dagger.internal.codegen.SourceElement.HasSourceElement;
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkState;
-import static dagger.internal.codegen.ContributionBinding.contributionTypeFor;
+import static com.google.common.collect.Iterables.concat;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.ContributionType.indexByContributionType;
+import static dagger.internal.codegen.ErrorMessages.MULTIPLE_CONTRIBUTION_TYPES_FORMAT;
 
 /**
  * The collection of bindings that have been resolved for a binding key.
@@ -34,7 +43,7 @@
  * @author Gregory Kick
  */
 @AutoValue
-abstract class ResolvedBindings {
+abstract class ResolvedBindings implements HasBindingType, HasContributionType, HasKey {
   /**
    * The binding key for which the {@link #bindings()} have been resolved.
    */
@@ -63,6 +72,17 @@
    */
   abstract ImmutableMap<ComponentDescriptor, MembersInjectionBinding> allMembersInjectionBindings();
 
+  @Override
+  public Key key() {
+    return bindingKey().key();
+  }
+  
+  /**
+   * The multibinding declarations for {@link #bindingKey()}. If {@link #bindingKey()}'s kind is not
+   * {@link BindingKey.Kind#CONTRIBUTION}, this is empty.
+   */
+  abstract ImmutableSet<MultibindingDeclaration> multibindingDeclarations();
+  
   /**
    * All bindings for {@link #bindingKey()}, regardless of in which component they were resolved.
    */
@@ -79,6 +99,13 @@
     }
   }
 
+  /**
+   * {@code true} if there are no {@link #bindings()} or {@link #multibindingDeclarations()}.
+   */
+  boolean isEmpty() {
+    return bindings().isEmpty() && multibindingDeclarations().isEmpty();
+  }
+
   /**
    * All bindings for {@link #bindingKey()} that were resolved in {@link #owningComponent()}.
    */
@@ -96,35 +123,26 @@
   }
 
   /**
-   * All contribution bindings, regardless of owning component.
-   *
-   * @throws IllegalStateException if {@link #bindingKey()} is not a
-   * {@link BindingKey.Kind#CONTRIBUTION}.
+   * All contribution bindings, regardless of owning component. Empty if this is a members-injection
+   * binding.
    */
   ImmutableSet<ContributionBinding> contributionBindings() {
-    checkState(bindingKey().kind().equals(BindingKey.Kind.CONTRIBUTION));
     return ImmutableSet.copyOf(allContributionBindings().values());
   }
 
   /**
-   * The contribution bindings that were resolved in {@link #owningComponent()}.
-   *
-   * @throws IllegalStateException if {@link #bindingKey()} is not a
-   * {@link BindingKey.Kind#CONTRIBUTION}.
+   * The contribution bindings that were resolved in {@link #owningComponent()}. Empty if this is a
+   * members-injection binding.
    */
   ImmutableSet<ContributionBinding> ownedContributionBindings() {
-    checkState(bindingKey().kind().equals(BindingKey.Kind.CONTRIBUTION));
     return allContributionBindings().get(owningComponent());
   }
 
   /**
-   * The members-injection binding, regardless of owning component.
-   *
-   * @throws IllegalStateException if {@link #bindingKey()} is not a
-   * {@link BindingKey.Kind#MEMBERS_INJECTION}.
+   * The members-injection binding, regardless of owning component. Empty if these are contribution
+   * bindings.
    */
   Optional<MembersInjectionBinding> membersInjectionBinding() {
-    checkState(bindingKey().kind().equals(BindingKey.Kind.MEMBERS_INJECTION));
     ImmutableSet<MembersInjectionBinding> membersInjectionBindings =
         FluentIterable.from(allMembersInjectionBindings().values()).toSet();
     return membersInjectionBindings.isEmpty()
@@ -133,13 +151,10 @@
   }
 
   /**
-   * The members-injection binding that was resolved in {@link #owningComponent()}.
-   *
-   * @throws IllegalStateException if {@link #bindingKey()} is not a
-   * {@link BindingKey.Kind#MEMBERS_INJECTION}.
+   * The members-injection binding that was resolved in {@link #owningComponent()}. Empty if these
+   * are contribution bindings.
    */
   Optional<MembersInjectionBinding> ownedMembersInjectionBinding() {
-    checkState(bindingKey().kind().equals(BindingKey.Kind.MEMBERS_INJECTION));
     return Optional.fromNullable(allMembersInjectionBindings().get(owningComponent()));
   }
 
@@ -149,13 +164,15 @@
   static ResolvedBindings forContributionBindings(
       BindingKey bindingKey,
       ComponentDescriptor owningComponent,
-      Multimap<ComponentDescriptor, ? extends ContributionBinding> contributionBindings) {
+      Multimap<ComponentDescriptor, ? extends ContributionBinding> contributionBindings,
+      Iterable<MultibindingDeclaration> multibindings) {
     checkArgument(bindingKey.kind().equals(BindingKey.Kind.CONTRIBUTION));
     return new AutoValue_ResolvedBindings(
         bindingKey,
         owningComponent,
         ImmutableSetMultimap.<ComponentDescriptor, ContributionBinding>copyOf(contributionBindings),
-        ImmutableMap.<ComponentDescriptor, MembersInjectionBinding>of());
+        ImmutableMap.<ComponentDescriptor, MembersInjectionBinding>of(),
+        ImmutableSet.copyOf(multibindings));
   }
 
   /**
@@ -170,7 +187,8 @@ static ResolvedBindings forContributionBindings(
         owningComponent,
         ImmutableSetMultimap.<ComponentDescriptor, ContributionBinding>builder()
             .putAll(owningComponent, ownedContributionBindings)
-            .build());
+            .build(),
+        ImmutableSet.<MultibindingDeclaration>of());
   }
 
   /**
@@ -185,7 +203,8 @@ static ResolvedBindings forMembersInjectionBinding(
         bindingKey,
         owningComponent,
         ImmutableSetMultimap.<ComponentDescriptor, ContributionBinding>of(),
-        ImmutableMap.of(owningComponent, ownedMembersInjectionBinding));
+        ImmutableMap.of(owningComponent, ownedMembersInjectionBinding),
+        ImmutableSet.<MultibindingDeclaration>of());
   }
 
   /**
@@ -196,7 +215,8 @@ static ResolvedBindings noBindings(BindingKey bindingKey, ComponentDescriptor ow
         bindingKey,
         owningComponent,
         ImmutableSetMultimap.<ComponentDescriptor, ContributionBinding>of(),
-        ImmutableMap.<ComponentDescriptor, MembersInjectionBinding>of());
+        ImmutableMap.<ComponentDescriptor, MembersInjectionBinding>of(),
+        ImmutableSet.<MultibindingDeclaration>of());
   }
 
   /**
@@ -205,24 +225,112 @@ static ResolvedBindings noBindings(BindingKey bindingKey, ComponentDescriptor ow
    */
   ResolvedBindings asInheritedIn(ComponentDescriptor owningComponent) {
     return new AutoValue_ResolvedBindings(
-        bindingKey(), owningComponent, allContributionBindings(), allMembersInjectionBindings());
+        bindingKey(),
+        owningComponent,
+        allContributionBindings(),
+        allMembersInjectionBindings(),
+        multibindingDeclarations());
   }
 
   /**
    * {@code true} if this is a multibindings contribution.
    */
   boolean isMultibindings() {
-    return bindingKey().kind().equals(BindingKey.Kind.CONTRIBUTION)
-        && !contributionBindings().isEmpty()
-        && contributionTypeFor(contributionBindings()).isMultibinding();
+    return !(contributionBindings().isEmpty() && multibindingDeclarations().isEmpty())
+        && contributionType().isMultibinding();
   }
 
   /**
    * {@code true} if this is a unique contribution binding.
    */
   boolean isUniqueContribution() {
-    return bindingKey().kind().equals(BindingKey.Kind.CONTRIBUTION)
-        && !contributionBindings().isEmpty()
-        && !contributionTypeFor(contributionBindings()).isMultibinding();
+    return !contributionBindings().isEmpty() && !contributionType().isMultibinding();
+  }
+
+  /**
+   * The binding type for all {@link #bindings()} and {@link #multibindingDeclarations()}.
+   *
+   * @throws IllegalStateException if {@link #isEmpty()} or the binding types conflict
+   */
+  @Override
+  public BindingType bindingType() {
+    checkState(!isEmpty(), "empty bindings for %s", bindingKey());
+    ImmutableSet<BindingType> bindingTypes =
+        FluentIterable.from(concat(bindings(), multibindingDeclarations()))
+            .transform(BindingType.BINDING_TYPE)
+            .toSet();
+    checkState(bindingTypes.size() == 1, "conflicting binding types: %s", this);
+    return getOnlyElement(bindingTypes);
+  }
+
+  /**
+   * The contribution type for these bindings.
+   *
+   * @throws IllegalStateException if {@link #isEmpty()} or the contribution types conflict
+   */
+  @Override
+  public ContributionType contributionType() {
+    ImmutableSet<ContributionType> types = contributionTypes();
+    checkState(!types.isEmpty(), "no bindings or declarations for %s", bindingKey());
+    checkState(types.size() == 1, MULTIPLE_CONTRIBUTION_TYPES_FORMAT, types);
+    return getOnlyElement(types);
+  }
+
+  /**
+   * The contribution types represented by {@link #contributionBindings()} and
+   * {@link #multibindingDeclarations()}.
+   */
+  ImmutableSet<ContributionType> contributionTypes() {
+    return bindingsAndDeclarationsByContributionType().keySet();
+  }
+
+  /**
+   * The {@link #contributionBindings()} and {@link #multibindingDeclarations()}, indexed by
+   * {@link ContributionType}.
+   */
+  ImmutableListMultimap<ContributionType, HasSourceElement>
+      bindingsAndDeclarationsByContributionType() {
+    return new ImmutableListMultimap.Builder<ContributionType, HasSourceElement>()
+        .putAll(indexByContributionType(contributionBindings()))
+        .putAll(indexByContributionType(multibindingDeclarations()))
+        .build();
+  }
+
+  /**
+   * The name of the package in which these bindings must be managed, for
+   * example if a binding references non-public types.
+   * 
+   * @throws IllegalArgumentException if the bindings must be managed in more than one package
+   */
+  Optional<String> bindingPackage() {
+    ImmutableSet.Builder<String> bindingPackagesBuilder = ImmutableSet.builder();
+    for (Binding binding : bindings()) {
+      bindingPackagesBuilder.addAll(binding.bindingPackage().asSet());
+    }
+    ImmutableSet<String> bindingPackages = bindingPackagesBuilder.build();
+    switch (bindingPackages.size()) {
+      case 0:
+        return Optional.absent();
+      case 1:
+        return Optional.of(bindingPackages.iterator().next());
+      default:
+        throw new IllegalArgumentException();
+    }
+  }
+
+  /**
+   * The framework class associated with these bindings.
+   */
+  Class<?> frameworkClass() {
+    switch (bindingKey().kind()) {
+      case CONTRIBUTION:
+        return Iterables.any(contributionBindings(), BindingType.isOfType(BindingType.PRODUCTION))
+            ? BindingType.PRODUCTION.frameworkClass()
+            : BindingType.PROVISION.frameworkClass();
+      case MEMBERS_INJECTION:
+        return MembersInjector.class;
+      default:
+        throw new AssertionError();
+    }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/SetType.java b/compiler/src/main/java/dagger/internal/codegen/SetType.java
new file mode 100644
index 000000000..23e95c7f7
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/SetType.java
@@ -0,0 +1,99 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreTypes;
+import com.google.auto.value.AutoValue;
+import com.google.common.base.Equivalence;
+import java.util.Set;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
+
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkState;
+
+/**
+ * Information about a {@link Set} {@link TypeMirror}.
+ */
+@AutoValue
+abstract class SetType {
+  /**
+   * The set type itself, wrapped using {@link MoreTypes#equivalence()}. Use
+   * {@link #declaredSetType()} instead.
+   */
+  protected abstract Equivalence.Wrapper<DeclaredType> wrappedDeclaredSetType();
+  
+  /**
+   * The set type itself.
+   */
+  DeclaredType declaredSetType() {
+    return wrappedDeclaredSetType().get();
+  }
+
+  /**
+   * {@code true} if the set type is the raw {@link Set} type.
+   */
+  boolean isRawType() {
+    return declaredSetType().getTypeArguments().isEmpty();
+  }
+
+  /**
+   * The element type.
+   */
+  TypeMirror elementType() {
+    return declaredSetType().getTypeArguments().get(0);
+  }
+
+  /**
+   * {@code true} if {@link #elementType()} is a {@code clazz}.
+   */
+  boolean elementsAreTypeOf(Class<?> clazz) {
+    return MoreTypes.isType(elementType()) && MoreTypes.isTypeOf(clazz, elementType());
+  }
+
+  /**
+   * {@code T} if {@link #elementType()} is a {@code WrappingClass<T>}.
+   *
+   * @throws IllegalStateException if {@link #elementType()} is not a {@code WrappingClass<T>}
+   * @throws IllegalArgumentException if {@code wrappingClass} does not have exactly one type
+   *     parameter
+   */
+  TypeMirror unwrappedElementType(Class<?> wrappingClass) {
+    checkArgument(
+        wrappingClass.getTypeParameters().length == 1,
+        "%s must have exactly one type parameter",
+        wrappingClass);
+    checkState(elementsAreTypeOf(wrappingClass));
+    return MoreTypes.asDeclared(elementType()).getTypeArguments().get(0);
+  }
+
+  /**
+   * {@code true} if {@code type} is a {@link Set} type.
+   */
+  static boolean isSet(TypeMirror type) {
+    return MoreTypes.isType(type) && MoreTypes.isTypeOf(Set.class, type);
+  }
+
+  /**
+   * Returns a {@link SetType} for {@code type}.
+   *
+   * @throws IllegalArgumentException if {@code type} is not a {@link Set} type
+   */
+  static SetType from(TypeMirror type) {
+    checkArgument(isSet(type), "%s must be a Set", type);
+    return new AutoValue_SetType(MoreTypes.equivalence().wrap(MoreTypes.asDeclared(type)));
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceElement.java b/compiler/src/main/java/dagger/internal/codegen/SourceElement.java
new file mode 100644
index 000000000..29949629b
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceElement.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.value.AutoValue;
+import com.google.common.base.Optional;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementVisitor;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.util.SimpleElementVisitor6;
+
+/**
+ * An {@link Element}, optionally contributed by a subtype of the type that encloses it.
+ */
+@AutoValue
+abstract class SourceElement {
+
+  /** An object that has a {@link SourceElement}. */
+  interface HasSourceElement {
+    /** The source element associated with this object. */
+    SourceElement sourceElement();
+  }
+
+  /** The {@link Element} instance.. */
+  abstract Element element();
+
+  /**
+   * The concrete class that contributed the {@link #element()}, if different from
+   * {@link #enclosingTypeElement()}.
+   */
+  abstract Optional<TypeElement> contributedBy();
+
+  /** The type enclosing the {@link #element()}. */
+  TypeElement enclosingTypeElement() {
+    return BINDING_TYPE_ELEMENT.visit(element());
+  }
+
+  private static final ElementVisitor<TypeElement, Void> BINDING_TYPE_ELEMENT =
+      new SimpleElementVisitor6<TypeElement, Void>() {
+        @Override
+        protected TypeElement defaultAction(Element e, Void p) {
+          return visit(e.getEnclosingElement());
+        }
+
+        @Override
+        public TypeElement visitType(TypeElement e, Void p) {
+          return e;
+        }
+      };
+
+  static SourceElement forElement(Element element) {
+    return new AutoValue_SourceElement(element, Optional.<TypeElement>absent());
+  }
+
+  static SourceElement forElement(Element element, TypeElement contributedBy) {
+    return new AutoValue_SourceElement(element, Optional.of(contributedBy));
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java
index 4b6efc0ea..4dc35ca2a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java
@@ -27,6 +27,7 @@
 import java.io.IOException;
 import javax.annotation.processing.Filer;
 import javax.lang.model.element.Element;
+import javax.lang.model.util.Elements;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
@@ -41,9 +42,11 @@
  */
 abstract class SourceFileGenerator<T> {
   private final Filer filer;
+  private final boolean generatedAnnotationAvailable;
 
-  SourceFileGenerator(Filer filer) {
+  SourceFileGenerator(Filer filer, Elements elements) {
     this.filer = checkNotNull(filer);
+    generatedAnnotationAvailable = elements.getTypeElement("javax.annotation.Generated") != null;
   }
 
   final void generate(T input) throws SourceFileGenerationException {
@@ -53,6 +56,7 @@ final void generate(T input) throws SourceFileGenerationException {
     try {
       ImmutableSet<JavaWriter> writers = write(generatedTypeName, input);
       for (JavaWriter javaWriter : writers) {
+        javaWriter.markGenerated(generatedAnnotationAvailable);
         try {
           javaWriter.file(filer, originatingElements);
         } catch (IOException e) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index 7ad0acbc4..d5612ccaf 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -14,6 +14,8 @@
 package dagger.internal.codegen;
 
 import com.google.common.base.CaseFormat;
+import com.google.common.base.Function;
+import com.google.common.base.Functions;
 import com.google.common.collect.ComparisonChain;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
@@ -21,6 +23,7 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Iterables;
+import com.google.common.collect.Maps;
 import com.google.common.collect.Ordering;
 import dagger.internal.DoubleCheckLazy;
 import dagger.internal.codegen.writer.ClassName;
@@ -32,10 +35,10 @@
 import java.util.Iterator;
 import java.util.Map;
 import java.util.Map.Entry;
+import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.Types;
 
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
 import static com.google.common.base.Preconditions.checkArgument;
@@ -66,71 +69,77 @@ public int compare(DependencyRequest left, DependencyRequest right) {
   };
 
   /**
-   * A variant of {@link #indexDependenciesByKey} that maps from unresolved keys
-   * to requests.  This is used when generating component's initialize()
-   * methods (and in members injectors) in order to instantiate dependent
-   * providers.  Consider a generic type of {@code Foo<T>} with a constructor
-   * of {@code Foo(T t, T t1, A a, A a1)}.  That will be collapsed to a factory
-   * taking a {@code Provider<T> tProvider, Provider<A> aProvider}. However,
-   * if it was referenced as {@code Foo<A>}, we need to make sure we still
-   * pass two providers.  Naively (if we just referenced by resolved BindingKey),
-   * we would have passed a single {@code aProvider}.
+   * Groups {@code binding}'s implicit dependencies by their binding key, using the dependency keys
+   * from the {@link Binding#unresolved()} binding if it exists.
+   *
+   * <p>Consider a generic type {@code Foo<T>} with a constructor {@code Foo(T t, T t1, A a, A a1)}.
+   * Its factory's {@code create} method should take only two parameters:
+   * {@code create(Provider<T> tProvider, Provider<A> aProvider)}. However, if the component
+   * initializes a factory for {@code Foo<A>}, it really has only one dependency:
+   * both arguments should be the same {@code Provider<A>}. In order to get the right number of
+   * arguments, we have to index resolved binding's dependencies by their keys in the unresolved
+   * version of the binding.
    */
-  // TODO(user): Refactor these indexing methods so that the binding itself knows what sort of
-  // binding keys and framework classes that it needs.
+  // TODO(dpb): Move this to DependencyRequest.
   static ImmutableSetMultimap<BindingKey, DependencyRequest> indexDependenciesByUnresolvedKey(
-      Types types, Iterable<? extends DependencyRequest> dependencies) {
-    ImmutableSetMultimap.Builder<BindingKey, DependencyRequest> dependenciesByKeyBuilder =
-        new ImmutableSetMultimap.Builder<BindingKey, DependencyRequest>()
-            .orderValuesBy(DEPENDENCY_ORDERING);
-    for (DependencyRequest dependency : dependencies) {
-      BindingKey resolved = dependency.bindingKey();
-      // To get the proper unresolved type, we have to extract the proper type from the
-      // request type again (because we're looking at the actual element's type).
-      TypeMirror unresolvedType =
-          DependencyRequest.Factory.extractKindAndType(dependency.requestElement().asType()).type();
-      BindingKey unresolved =
-          BindingKey.create(resolved.kind(), resolved.key().withType(types, unresolvedType));
-      dependenciesByKeyBuilder.put(unresolved, dependency);
+      Binding binding) {
+    // If the binding is already fully resolved, just index the dependencies by binding key.
+    if (!binding.unresolved().isPresent()) {
+      return indexDependenciesByKey(binding, Functions.<DependencyRequest>identity());
     }
-    return dependenciesByKeyBuilder.build();
+    
+    // Index the unresolved dependencies, replacing each one with its resolved version by looking it
+    // up by request element.
+    final ImmutableMap<Element, DependencyRequest> resolvedDependencies =
+        Maps.uniqueIndex(
+            binding.implicitDependencies(),
+            new Function<DependencyRequest, Element>() {
+              @Override
+              public Element apply(DependencyRequest dependencyRequest) {
+                return dependencyRequest.requestElement();
+              }
+            });
+    return indexDependenciesByKey(
+        binding.unresolved().get(),
+        new Function<DependencyRequest, DependencyRequest>() {
+          @Override
+          public DependencyRequest apply(DependencyRequest unresolvedRequest) {
+            return resolvedDependencies.get(unresolvedRequest.requestElement());
+          }
+        });
   }
 
   /**
-   * Allows dependency requests to be grouped by the key they're requesting.
-   * This is used by factory generation in order to minimize the number of parameters
-   * required in the case where a given key is requested more than once.  This expects
-   * unresolved dependency requests, otherwise we may generate factories based on
-   * a particular usage of a class as opposed to the generic types of the class.
+   * Groups a binding's dependency requests by their binding key.
+   *
+   * @param transformer applied to each dependency before inserting into the multimap
    */
-  static ImmutableSetMultimap<BindingKey, DependencyRequest> indexDependenciesByKey(
-      Iterable<? extends DependencyRequest> dependencies) {
+  private static ImmutableSetMultimap<BindingKey, DependencyRequest> indexDependenciesByKey(
+      Binding binding, Function<DependencyRequest, DependencyRequest> transformer) {
     ImmutableSetMultimap.Builder<BindingKey, DependencyRequest> dependenciesByKeyBuilder =
-        new ImmutableSetMultimap.Builder<BindingKey, DependencyRequest>()
-            .orderValuesBy(DEPENDENCY_ORDERING);
-    for (DependencyRequest dependency : dependencies) {
-      dependenciesByKeyBuilder.put(dependency.bindingKey(), dependency);
+        ImmutableSetMultimap.builder();
+    for (DependencyRequest dependency : binding.implicitDependencies()) {
+      dependenciesByKeyBuilder.put(dependency.bindingKey(), transformer.apply(dependency));
     }
-    return dependenciesByKeyBuilder.build();
+    return dependenciesByKeyBuilder.orderValuesBy(DEPENDENCY_ORDERING).build();
   }
 
   /**
-   * This method generates names and keys for the framework classes necessary for all of the
-   * bindings. It is responsible for the following:
+   * Generates names and keys for the factory class fields needed to hold the framework classes for
+   * all of the dependencies of {@code binding}. It is responsible for choosing a name that
+   *
    * <ul>
-   * <li>Choosing a name that associates the binding with all of the dependency requests for this
-   * type.
-   * <li>Choosing a name that is <i>probably</i> associated with the type being bound.
-   * <li>Ensuring that no two bindings end up with the same name.
+   * <li>represents all of the dependency requests for this key
+   * <li>is <i>probably</i> associated with the type being bound
+   * <li>is unique within the class
    * </ul>
    *
-   * @return Returns the mapping from {@link BindingKey} to field, sorted by the name of the field.
+   * @param binding must be an unresolved binding (type parameters must match its type element's)
    */
   static ImmutableMap<BindingKey, FrameworkField> generateBindingFieldsForDependencies(
-      DependencyRequestMapper dependencyRequestMapper,
-      Iterable<? extends DependencyRequest> dependencies) {
+      DependencyRequestMapper dependencyRequestMapper, Binding binding) {
     ImmutableSetMultimap<BindingKey, DependencyRequest> dependenciesByKey =
-        indexDependenciesByKey(dependencies);
+        indexDependenciesByUnresolvedKey(binding);
     Map<BindingKey, Collection<DependencyRequest>> dependenciesByKeyMap =
         dependenciesByKey.asMap();
     ImmutableMap.Builder<BindingKey, FrameworkField> bindingFields = ImmutableMap.builder();
@@ -143,12 +152,13 @@ public int compare(DependencyRequest left, DependencyRequest right) {
       // collect together all of the names that we would want to call the provider
       ImmutableSet<String> dependencyNames =
           FluentIterable.from(requests).transform(new DependencyVariableNamer()).toSet();
-
+    
       if (dependencyNames.size() == 1) {
         // if there's only one name, great! use it!
         String name = Iterables.getOnlyElement(dependencyNames);
-        bindingFields.put(bindingKey,
-            FrameworkField.createWithTypeFromKey(frameworkClass, bindingKey, name));
+        bindingFields.put(
+            bindingKey,
+            FrameworkField.createWithTypeFromKey(frameworkClass, bindingKey.key(), name));
       } else {
         // in the event that a field is being used for a bunch of deps with different names,
         // add all the names together with "And"s in the middle. E.g.: stringAndS
@@ -159,8 +169,10 @@ public int compare(DependencyRequest left, DependencyRequest right) {
           compositeNameBuilder.append("And").append(
               CaseFormat.LOWER_CAMEL.to(UPPER_CAMEL, namesIterator.next()));
         }
-        bindingFields.put(bindingKey, FrameworkField.createWithTypeFromKey(
-            frameworkClass, bindingKey, compositeNameBuilder.toString()));
+        bindingFields.put(
+            bindingKey,
+            FrameworkField.createWithTypeFromKey(
+                frameworkClass, bindingKey.key(), compositeNameBuilder.toString()));
       }
     }
     return bindingFields.build();
diff --git a/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
index 128766872..507e4aaf1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
@@ -47,7 +47,7 @@
 /**
  * Creates the nested implementation class for a subcomponent.
  */
-class SubcomponentWriter extends AbstractComponentWriter {
+final class SubcomponentWriter extends AbstractComponentWriter {
 
   private AbstractComponentWriter parent;
   private ExecutableElement subcomponentFactoryMethod;
@@ -61,16 +61,18 @@ public SubcomponentWriter(
         parent.elements,
         parent.keyFactory,
         parent.nullableValidationType,
-        parent.name.nestedClassNamed(subcomponentSimpleName(subgraph)),
-        subgraph);
+        subcomponentName(parent, subgraph),
+        subgraph,
+        parent.subcomponentImplNames);
     this.parent = parent;
     this.subcomponentFactoryMethod = subcomponentFactoryMethod;
   }
 
-  private static String subcomponentSimpleName(BindingGraph subgraph) {
-    return subgraph.componentDescriptor().componentDefinitionType().getSimpleName() + "Impl";
+  private static ClassName subcomponentName(AbstractComponentWriter parent, BindingGraph subgraph) {
+    return parent.name.nestedClassNamed(
+        parent.subcomponentImplNames.get(subgraph.componentDescriptor()));
   }
-  
+
   @Override
   protected InitializationState getInitializationState(BindingKey bindingKey) {
     InitializationState initializationState = super.getInitializationState(bindingKey);
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index 8c1aba399..1b941ceab 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -16,26 +16,15 @@
  */
 package dagger.internal.codegen;
 
-import com.google.auto.common.MoreTypes;
-import com.google.common.base.Equivalence;
-import com.google.common.base.Equivalence.Wrapper;
-import com.google.common.base.Optional;
+import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
-import dagger.producers.Produced;
-import java.util.Map;
-import java.util.Set;
-import javax.inject.Provider;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.DeclaredType;
-import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 
 import static com.google.auto.common.MoreElements.getLocalAndInheritedMethods;
-import static com.google.auto.common.MoreTypes.asDeclared;
-import static com.google.common.base.Preconditions.checkState;
+import static com.google.auto.common.MoreElements.hasModifiers;
 import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.PRIVATE;
@@ -45,92 +34,6 @@
  * Utilities for handling types in annotation processors
  */
 final class Util {
-  /**
-   * Returns the {@code V} type for a {@link Map} type like {@code Map<K, Provider<V>>} if the map
-   * includes such a construction
-   */
-  public static TypeMirror getProvidedValueTypeOfMap(DeclaredType mapType) {
-    checkState(MoreTypes.isTypeOf(Map.class, mapType), "%s is not a Map.", mapType);
-    return asDeclared(mapType.getTypeArguments().get(1)).getTypeArguments().get(0);
-  }
-
-  // TODO(cgruber): Consider an object that holds and exposes the various parts of a Map type.
-  /**
-   * returns the value type for a {@link Map} type like Map<K, V>}.
-   */
-  public static TypeMirror getValueTypeOfMap(DeclaredType mapType) {
-    checkState(MoreTypes.isTypeOf(Map.class, mapType), "%s is not a Map.", mapType);
-    return mapType.getTypeArguments().get(1);
-  }
-
-  /**
-   * Returns the key type for a {@link Map} type like Map<K, Provider<V>>}
-   */
-  public static TypeMirror getKeyTypeOfMap(DeclaredType mapType) {
-    checkState(MoreTypes.isTypeOf(Map.class, mapType), "%s is not a Map.", mapType);
-    return mapType.getTypeArguments().get(0);
-  }
-
-  /**
-   * Returns true if {@code type} is a {@link Map} whose value type is not a {@link Provider}.
-   */
-  public static boolean isMapWithNonProvidedValues(TypeMirror type) {
-    return MoreTypes.isType(type)
-        && MoreTypes.isTypeOf(Map.class, type)
-        && !MoreTypes.isTypeOf(Provider.class, asDeclared(type).getTypeArguments().get(1));
-  }
-
-  /**
-   * Returns true if {@code type} is a {@link Map} whose value type is a {@link Provider}.
-   */
-  public static boolean isMapWithProvidedValues(TypeMirror type) {
-    return MoreTypes.isType(type)
-        && MoreTypes.isTypeOf(Map.class, type)
-        && MoreTypes.isTypeOf(Provider.class, asDeclared(type).getTypeArguments().get(1));
-  }
-
-  /** Returns true if {@code type} is a {@code Set<Produced<T>>}. */
-  static boolean isSetOfProduced(TypeMirror type) {
-    return MoreTypes.isType(type)
-        && MoreTypes.isTypeOf(Set.class, type)
-        && MoreTypes.isTypeOf(Produced.class, MoreTypes.asDeclared(type).getTypeArguments().get(0));
-  }
-
-  /**
-   * Wraps an {@link Optional} of a type in an {@code Optional} of a {@link Wrapper} for that type.
-   */
-  static <T> Optional<Equivalence.Wrapper<T>> wrapOptionalInEquivalence(
-      Equivalence<T> equivalence, Optional<T> optional) {
-    return optional.isPresent()
-        ? Optional.of(equivalence.wrap(optional.get()))
-        : Optional.<Equivalence.Wrapper<T>>absent();
-  }
-
-  /**
-   * Unwraps an {@link Optional} of a {@link Wrapper} into an {@code Optional} of the underlying
-   * type.
-   */
-  static <T> Optional<T> unwrapOptionalEquivalence(
-      Optional<Equivalence.Wrapper<T>> wrappedOptional) {
-    return wrappedOptional.isPresent()
-        ? Optional.of(wrappedOptional.get().get())
-        : Optional.<T>absent();
-  }
-
-  private static boolean requiresEnclosingInstance(TypeElement typeElement) {
-    switch (typeElement.getNestingKind()) {
-      case TOP_LEVEL:
-        return false;
-      case MEMBER:
-        return !typeElement.getModifiers().contains(STATIC);
-      case ANONYMOUS:
-      case LOCAL:
-        return true;
-      default:
-        throw new AssertionError("TypeElement cannot have nesting kind: "
-            + typeElement.getNestingKind());
-    }
-  }
 
   /**
    * Returns true if and only if a component can instantiate new instances (typically of a module)
@@ -169,16 +72,26 @@ static boolean componentCanMakeNewInstances(TypeElement typeElement) {
     return false;
   }
 
+  private static boolean requiresEnclosingInstance(TypeElement typeElement) {
+    switch (typeElement.getNestingKind()) {
+      case TOP_LEVEL:
+        return false;
+      case MEMBER:
+        return !typeElement.getModifiers().contains(STATIC);
+      case ANONYMOUS:
+      case LOCAL:
+        return true;
+      default:
+        throw new AssertionError(
+            "TypeElement cannot have nesting kind: " + typeElement.getNestingKind());
+    }
+  }
+
   static ImmutableSet<ExecutableElement> getUnimplementedMethods(
       Elements elements, TypeElement type) {
-    ImmutableSet.Builder<ExecutableElement> unimplementedMethods = ImmutableSet.builder();
-    Set<ExecutableElement> methods = getLocalAndInheritedMethods(type, elements);
-    for (ExecutableElement method : methods) {
-      if (method.getModifiers().contains(Modifier.ABSTRACT)) {
-        unimplementedMethods.add(method);
-      }
-    }
-    return unimplementedMethods.build();
+    return FluentIterable.from(getLocalAndInheritedMethods(type, elements))
+        .filter(hasModifiers(ABSTRACT))
+        .toSet();
   }
 
   private Util() {}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/AnnotationWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/AnnotationWriter.java
index 8dbf27bc3..9ffab1871 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/AnnotationWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/AnnotationWriter.java
@@ -20,6 +20,7 @@
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
 import java.io.IOException;
+import java.util.Iterator;
 import java.util.Map.Entry;
 import java.util.Set;
 import java.util.SortedMap;
@@ -59,12 +60,17 @@ public Appendable write(Appendable appendable, Context context) throws IOExcepti
     annotationName.write(appendable, context);
     if (!memberMap.isEmpty()) {
       appendable.append('(');
-      if (memberMap.size() == 1) {
-        Entry<String, Writable> onlyEntry = Iterables.getOnlyElement(memberMap.entrySet());
-        if (!onlyEntry.getKey().equals("value")) {
-          appendable.append(onlyEntry.getKey()).append(" = ");
+      boolean singleEntry = memberMap.size() == 1;
+      Iterator<Entry<String, Writable>> iterator = memberMap.entrySet().iterator();
+      while (iterator.hasNext()) {
+        Entry<String, Writable> member = iterator.next();
+        if (!singleEntry || !member.getKey().equals("value")) {
+          appendable.append(member.getKey()).append(" = ");
+        }
+        member.getValue().write(appendable, context);
+        if (iterator.hasNext()) {
+          appendable.append(",");
         }
-        onlyEntry.getValue().write(appendable, context);
       }
       appendable.append(')');
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java
index 5977371ac..674dd621e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java
@@ -30,6 +30,7 @@
 import com.google.common.io.CharSource;
 import com.google.googlejavaformat.java.Formatter;
 import com.google.googlejavaformat.java.FormatterException;
+import dagger.internal.codegen.ComponentProcessor;
 import dagger.internal.codegen.writer.Writable.Context;
 import java.io.IOException;
 import java.io.Writer;
@@ -37,6 +38,7 @@
 import java.util.Deque;
 import java.util.List;
 import java.util.Set;
+import javax.annotation.Generated;
 import javax.annotation.processing.Filer;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.PackageElement;
@@ -101,6 +103,12 @@ public InterfaceWriter addInterface(String simpleName) {
     return writer;
   }
 
+  public void markGenerated(boolean generatedAnnotationAvailable) {
+    for (TypeWriter typeWriter : typeWriters) {
+      typeWriter.markGenerated(generatedAnnotationAvailable);
+    }
+  }
+
   public <A extends Appendable> A write(A appendable) throws IOException {
     if (!packageName.isEmpty()) {
       appendable.append("package ").append(packageName).append(";\n\n");
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/Modifiable.java b/compiler/src/main/java/dagger/internal/codegen/writer/Modifiable.java
index bb4c6ffd9..91072baf6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/Modifiable.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/Modifiable.java
@@ -17,17 +17,25 @@
 
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
+import dagger.internal.codegen.ComponentProcessor;
 import dagger.internal.codegen.writer.Writable.Context;
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.util.EnumSet;
 import java.util.List;
 import java.util.Set;
+import javax.annotation.Generated;
 import javax.lang.model.element.Modifier;
 
 public abstract class Modifiable {
+
+  private static final String GENERATED_COMMENTS = "https://google.github.io/dagger";
+
   final Set<Modifier> modifiers;
   final List<AnnotationWriter> annotations;
+  // This is not intended to be widely used; handling comments should be deferred to
+  // when Javapoet is adopted
+  private String generatedComment;
 
   Modifiable() {
     this.modifiers = EnumSet.noneOf(Modifier.class);
@@ -52,6 +60,18 @@ public AnnotationWriter annotate(Class<? extends Annotation> annotation) {
     return annotate(ClassName.fromClass(annotation));
   }
 
+  public void markGenerated(boolean generatedAnnotationAvailable) {
+    if (generatedAnnotationAvailable) {
+      AnnotationWriter annotation = annotate(Generated.class);
+      annotation.setValue(ComponentProcessor.class.getName());
+      annotation.setMember("comments", GENERATED_COMMENTS);
+    } else {
+      generatedComment =
+          String.format(
+              "// Generated by %s (%s).", ComponentProcessor.class.getName(), GENERATED_COMMENTS);
+    }
+  }
+
   Appendable writeModifiers(Appendable appendable) throws IOException {
     for (Modifier modifier : modifiers) {
       appendable.append(modifier.toString()).append(' ');
@@ -63,6 +83,9 @@ Appendable writeAnnotations(Appendable appendable, Context context) throws IOExc
     for (AnnotationWriter annotationWriter : annotations) {
       annotationWriter.write(appendable, context).append('\n');
     }
+    if (generatedComment != null) {
+      appendable.append(generatedComment).append('\n');
+    }
     return appendable;
   }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/BindingFieldTest.java b/compiler/src/test/java/dagger/internal/codegen/BindingFieldTest.java
index eaaa595d3..b8349156d 100644
--- a/compiler/src/test/java/dagger/internal/codegen/BindingFieldTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/BindingFieldTest.java
@@ -64,26 +64,21 @@ private ExecutableElement getXConstructor() {
     Key key = keyFactory.forInjectConstructorWithResolvedType(
         getXConstructor().getEnclosingElement().asType());
     TypeName xClass = TypeNames.forTypeMirror(key.type());
-    assertThat(FrameworkField.createWithTypeFromKey(Provider.class,
-            BindingKey.create(BindingKey.Kind.CONTRIBUTION, key), "test")
-        .frameworkType())
-        .isEqualTo(ParameterizedTypeName.create(
-            ClassName.fromClass(Provider.class), xClass));
-    assertThat(FrameworkField.createWithTypeFromKey(MembersInjector.class,
-            BindingKey.create(BindingKey.Kind.MEMBERS_INJECTION, key), "test")
-        .frameworkType())
-        .isEqualTo(ParameterizedTypeName.create(
-            ClassName.fromClass(MembersInjector.class), xClass));
+    assertThat(FrameworkField.createWithTypeFromKey(Provider.class, key, "test").frameworkType())
+        .isEqualTo(ParameterizedTypeName.create(ClassName.fromClass(Provider.class), xClass));
+    assertThat(
+            FrameworkField.createWithTypeFromKey(MembersInjector.class, key, "test")
+                .frameworkType())
+        .isEqualTo(
+            ParameterizedTypeName.create(ClassName.fromClass(MembersInjector.class), xClass));
   }
 
   @Test public void nameSuffix() {
     Key key = keyFactory.forInjectConstructorWithResolvedType(
         getXConstructor().getEnclosingElement().asType());
-    assertThat(FrameworkField.createWithTypeFromKey(Provider.class,
-            BindingKey.create(BindingKey.Kind.CONTRIBUTION, key), "foo").name())
+    assertThat(FrameworkField.createWithTypeFromKey(Provider.class, key, "foo").name())
         .isEqualTo("fooProvider");
-    assertThat(FrameworkField.createWithTypeFromKey(Provider.class,
-            BindingKey.create(BindingKey.Kind.CONTRIBUTION, key), "fooProvider").name())
+    assertThat(FrameworkField.createWithTypeFromKey(Provider.class, key, "fooProvider").name())
         .isEqualTo("fooProvider");
 
   }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java
index cf0e69d33..e3adecc8a 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java
@@ -25,6 +25,7 @@
 import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 
 /** Tests for {@link dagger.Component.Builder} */
 @RunWith(JUnit4.class)
@@ -66,7 +67,7 @@ public void testEmptyBuilder() {
         "import javax.annotation.Generated;",
         "import test.SimpleComponent",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class DaggerSimpleComponent implements SimpleComponent {",
         "  private DaggerSimpleComponent(Builder builder) {",
         "    assert builder != null;",
@@ -139,7 +140,7 @@ public void testUsesBuildAndSetterNames() {
         "import javax.inject.Provider;",
         "import test.TestComponent;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class DaggerTestComponent implements TestComponent {",
         "  private Provider<String> stringProvider;",
         "",
@@ -241,7 +242,7 @@ public void testIgnoresModulesNotInApi() {
         "import javax.inject.Provider;",
         "import test.TestComponent;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class DaggerTestComponent implements TestComponent {",
         "  private Provider<String> stringProvider;",
         "  private Provider<Integer> integerProvider;",
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index 28e3b4570..aefaf1275 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -15,17 +15,27 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreElements;
 import com.google.common.base.Joiner;
+import com.google.common.base.Predicate;
+import com.google.common.base.Predicates;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Sets;
 import com.google.testing.compile.JavaFileObjects;
+import dagger.MembersInjector;
 import dagger.internal.codegen.writer.StringLiteral;
 import java.io.IOException;
 import java.io.Writer;
+import java.lang.annotation.Annotation;
 import java.util.Set;
 import javax.annotation.processing.AbstractProcessor;
+import javax.annotation.processing.ProcessingEnvironment;
 import javax.annotation.processing.Processor;
 import javax.annotation.processing.RoundEnvironment;
+import javax.inject.Inject;
+import javax.lang.model.SourceVersion;
+import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
 import javax.tools.JavaFileObject;
 import org.junit.Ignore;
@@ -37,6 +47,7 @@
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.internal.codegen.ErrorMessages.REFERENCED_MODULES_MUST_NOT_BE_ABSTRACT;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 import static javax.tools.StandardLocation.SOURCE_OUTPUT;
 
 @RunWith(JUnit4.class)
@@ -217,7 +228,7 @@ private void checkCannotReferToModuleOfType(String moduleType) {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class DaggerSimpleComponent implements SimpleComponent {",
         "  private DaggerSimpleComponent(Builder builder) {",
         "    assert builder != null;",
@@ -302,7 +313,7 @@ private void checkCannotReferToModuleOfType(String moduleType) {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class DaggerSimpleComponent implements SimpleComponent {",
         "  private Provider<SomeInjectableType> someInjectableTypeProvider;",
         "",
@@ -385,7 +396,7 @@ private void checkCannotReferToModuleOfType(String moduleType) {
         "import test.OuterType.B;",
         "import test.OuterType.SimpleComponent;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class DaggerOuterType_SimpleComponent implements SimpleComponent {",
         "  private MembersInjector<B> bMembersInjector;",
         "",
@@ -484,7 +495,7 @@ private void checkCannotReferToModuleOfType(String moduleType) {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class DaggerTestComponent implements TestComponent {",
         "  private Provider<B> bProvider;",
         "  private Provider<A> aProvider;",
@@ -619,7 +630,7 @@ private void checkCannotReferToModuleOfType(String moduleType) {
         "",
         "import javax.annotation.Generated;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class DaggerTestComponent implements TestComponent {",
         "",
         "  private DaggerTestComponent(Builder builder) {",
@@ -844,7 +855,7 @@ public void subcomponentOmitsInheritedBindings() {
             "import javax.annotation.Generated;",
             "import javax.inject.Provider;",
             "",
-            "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+            GENERATED_ANNOTATION,
             "public final class DaggerParent implements Parent {",
             "  private Provider<Set<Object>> setOfObjectContribution1Provider;",
             "  private Provider<Set<Object>> setOfObjectProvider;",
@@ -1014,7 +1025,7 @@ public void subcomponentOmitsInheritedBindings() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class DaggerTestComponent implements TestComponent {",
         "  private Provider<Set<String>> setOfStringContribution1Provider;",
         "  private Provider<Set<String>> setOfStringContribution2Provider;",
@@ -1127,7 +1138,7 @@ public void subcomponentOmitsInheritedBindings() {
         "import dagger.MembersInjector;",
         "import javax.annotation.Generated;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class DaggerSimpleComponent implements SimpleComponent {",
         "  private MembersInjector<SomeInjectedType> someInjectedTypeMembersInjector;",
         "",
@@ -1206,7 +1217,7 @@ public void subcomponentOmitsInheritedBindings() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class DaggerSimpleComponent implements SimpleComponent {",
         "  private Provider<SimpleComponent> simpleComponentProvider;",
         "  private Provider<SomeInjectableType> someInjectableTypeProvider;",
@@ -1286,7 +1297,7 @@ public void subcomponentOmitsInheritedBindings() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class DaggerSimpleComponent implements SimpleComponent {",
         "  private MembersInjector<SomeInjectedType> someInjectedTypeMembersInjector;",
         "  private Provider<SomeInjectedType> someInjectedTypeProvider;",
@@ -1365,7 +1376,7 @@ public void subcomponentOmitsInheritedBindings() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class DaggerSimpleComponent implements SimpleComponent {",
         "  private Provider<SomeInjectableType> someInjectableTypeProvider;",
         "",
@@ -1458,7 +1469,7 @@ public void subcomponentOmitsInheritedBindings() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class DaggerBComponent implements BComponent {",
         "  private Provider<A> aProvider;",
         "  private Provider<B> bProvider;",
@@ -1575,7 +1586,7 @@ public void subcomponentOmitsInheritedBindings() {
         "import other.test.TestModule;",
         "import other.test.TestModule_AFactory;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class DaggerTestComponent implements TestComponent {",
         "  private Provider<test.A> aProvider;",
         "  private Provider<A> aProvider1;",
@@ -1704,7 +1715,7 @@ public void subcomponentOmitsInheritedBindings() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class DaggerTestComponent implements TestComponent {",
         "  private Provider<B> bProvider;",
         "  private Provider<A> aProvider;",
@@ -1811,7 +1822,7 @@ public void subcomponentOmitsInheritedBindings() {
         "",
         "import javax.annotation.Generated;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class DaggerSimpleComponent implements SimpleComponent {",
         "  private DaggerSimpleComponent(Builder builder) {",
         "    assert builder != null;",
@@ -1900,7 +1911,7 @@ public void subcomponentOmitsInheritedBindings() {
         "",
         "import javax.annotation.Generated;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class DaggerSimpleComponent implements SimpleComponent {",
         "  private DaggerSimpleComponent(Builder builder) {",
         "    assert builder != null;",
@@ -2108,7 +2119,7 @@ public void genericTestToLetMeDebugInEclipse() {
          "import javax.annotation.Generated;",
          "import javax.inject.Provider;",
          "",
-         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+         GENERATED_ANNOTATION,
          "public final class DaggerSimpleComponent implements SimpleComponent {",
          "  private Provider<D> dProvider;",
          "",
@@ -2150,6 +2161,197 @@ public void genericTestToLetMeDebugInEclipse() {
          .and().generatesSources(generatedComponent);
    }
 
+  /**
+   * We warn when generating a {@link MembersInjector} for a type post-hoc (i.e., if Dagger wasn't
+   * invoked when compiling the type). But Dagger only generates {@link MembersInjector}s for types
+   * with {@link Inject @Inject} constructors if they have any injection sites, and it only
+   * generates them for types without {@link Inject @Inject} constructors if they have local
+   * (non-inherited) injection sites. So make sure we warn in only those cases where running the
+   * Dagger processor actually generates a {@link MembersInjector}.
+   */
+  @Test
+  public void unprocessedMembersInjectorNotes() {
+    assertAbout(javaSources())
+        .that(
+            ImmutableList.of(
+                JavaFileObjects.forSourceLines(
+                    "test.TestComponent",
+                    "package test;",
+                    "",
+                    "import dagger.Component;",
+                    "",
+                    "@Component(modules = TestModule.class)",
+                    "interface TestComponent {",
+                    "  void inject(test.inject.NoInjectMemberNoConstructor object);",
+                    "  void inject(test.inject.NoInjectMemberWithConstructor object);",
+                    "  void inject(test.inject.LocalInjectMemberNoConstructor object);",
+                    "  void inject(test.inject.LocalInjectMemberWithConstructor object);",
+                    "  void inject(test.inject.ParentInjectMemberNoConstructor object);",
+                    "  void inject(test.inject.ParentInjectMemberWithConstructor object);",
+                    "}"),
+                JavaFileObjects.forSourceLines(
+                    "test.TestModule",
+                    "package test;",
+                    "",
+                    "import dagger.Module;",
+                    "import dagger.Provides;",
+                    "",
+                    "@Module",
+                    "class TestModule {",
+                    "  @Provides static Object object() {",
+                    "    return \"object\";",
+                    "  }",
+                    "}"),
+                JavaFileObjects.forSourceLines(
+                    "test.inject.NoInjectMemberNoConstructor",
+                    "package test.inject;",
+                    "",
+                    "public class NoInjectMemberNoConstructor {",
+                    "}"),
+                JavaFileObjects.forSourceLines(
+                    "test.inject.NoInjectMemberWithConstructor",
+                    "package test.inject;",
+                    "",
+                    "import javax.inject.Inject;",
+                    "",
+                    "public class NoInjectMemberWithConstructor {",
+                    "  @Inject NoInjectMemberWithConstructor() {}",
+                    "}"),
+                JavaFileObjects.forSourceLines(
+                    "test.inject.LocalInjectMemberNoConstructor",
+                    "package test.inject;",
+                    "",
+                    "import javax.inject.Inject;",
+                    "",
+                    "public class LocalInjectMemberNoConstructor {",
+                    "  @Inject Object object;",
+                    "}"),
+                JavaFileObjects.forSourceLines(
+                    "test.inject.LocalInjectMemberWithConstructor",
+                    "package test.inject;",
+                    "",
+                    "import javax.inject.Inject;",
+                    "",
+                    "public class LocalInjectMemberWithConstructor {",
+                    "  @Inject LocalInjectMemberWithConstructor() {}",
+                    "  @Inject Object object;",
+                    "}"),
+                JavaFileObjects.forSourceLines(
+                    "test.inject.ParentInjectMemberNoConstructor",
+                    "package test.inject;",
+                    "",
+                    "import javax.inject.Inject;",
+                    "",
+                    "public class ParentInjectMemberNoConstructor",
+                    "    extends LocalInjectMemberNoConstructor {}"),
+                JavaFileObjects.forSourceLines(
+                    "test.inject.ParentInjectMemberWithConstructor",
+                    "package test.inject;",
+                    "",
+                    "import javax.inject.Inject;",
+                    "",
+                    "public class ParentInjectMemberWithConstructor",
+                    "    extends LocalInjectMemberNoConstructor {",
+                    "  @Inject ParentInjectMemberWithConstructor() {}",
+                    "}")))
+        .processedWith(
+            new ElementFilteringComponentProcessor(
+                Predicates.not(
+                    new Predicate<Element>() {
+                      @Override
+                      public boolean apply(Element element) {
+                        return MoreElements.getPackage(element)
+                            .getQualifiedName()
+                            .toString()
+                            .equals("test.inject");
+                      }
+                    })))
+        .compilesWithoutError();
+        /* TODO(b/23108801): Uncomment when compilesWithoutWarnings() is implemented.
+        .compilesWithoutWarnings()
+        .withNoteContaining(
+            "Generating a MembersInjector or Factory for "
+                + "test.inject.LocalInjectMemberNoConstructor. "
+                + "Prefer to run the dagger processor over that class instead.")
+        .and()
+        .withNoteContaining(
+            "Generating a MembersInjector or Factory for "
+                + "test.inject.LocalInjectMemberWithConstructor. "
+                + "Prefer to run the dagger processor over that class instead.")
+        .and()
+        .withNoteContaining(
+            "Generating a MembersInjector or Factory for "
+                + "test.inject.ParentInjectMemberWithConstructor. "
+                + "Prefer to run the dagger processor over that class instead.")
+        .and()
+        .withNoteCount(3);
+         */
+  }
+
+  /**
+   * A {@link ComponentProcessor} that excludes elements using a {@link Predicate}.
+   */
+  private static final class ElementFilteringComponentProcessor extends AbstractProcessor {
+    private final ComponentProcessor componentProcessor = new ComponentProcessor();
+    private final Predicate<? super Element> filter;
+
+    /**
+     * Creates a {@link ComponentProcessor} that only processes elements that match {@code filter}.
+     */
+    public ElementFilteringComponentProcessor(Predicate<? super Element> filter) {
+      this.filter = filter;
+    }
+
+    @Override
+    public synchronized void init(ProcessingEnvironment processingEnv) {
+      super.init(processingEnv);
+      componentProcessor.init(processingEnv);
+    }
+
+    @Override
+    public Set<String> getSupportedAnnotationTypes() {
+      return componentProcessor.getSupportedAnnotationTypes();
+    }
+
+    @Override
+    public SourceVersion getSupportedSourceVersion() {
+      return componentProcessor.getSupportedSourceVersion();
+    }
+
+    @Override
+    public boolean process(
+        Set<? extends TypeElement> annotations, final RoundEnvironment roundEnv) {
+      return componentProcessor.process(
+          annotations,
+          new RoundEnvironment() {
+            @Override
+            public boolean processingOver() {
+              return roundEnv.processingOver();
+            }
+
+            @Override
+            public Set<? extends Element> getRootElements() {
+              return Sets.filter(roundEnv.getRootElements(), filter);
+            }
+
+            @Override
+            public Set<? extends Element> getElementsAnnotatedWith(Class<? extends Annotation> a) {
+              return Sets.filter(roundEnv.getElementsAnnotatedWith(a), filter);
+            }
+
+            @Override
+            public Set<? extends Element> getElementsAnnotatedWith(TypeElement a) {
+              return Sets.filter(roundEnv.getElementsAnnotatedWith(a), filter);
+            }
+
+            @Override
+            public boolean errorRaised() {
+              return roundEnv.errorRaised();
+            }
+          });
+    }
+  }
+
   /**
    * A simple {@link Processor} that generates one source file.
    */
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponentWithMultibindings.java b/compiler/src/test/java/dagger/internal/codegen/GeneratedLines.java
similarity index 64%
rename from compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponentWithMultibindings.java
rename to compiler/src/test/java/dagger/internal/codegen/GeneratedLines.java
index 46fe8835c..08473a98f 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponentWithMultibindings.java
+++ b/compiler/src/test/java/dagger/internal/codegen/GeneratedLines.java
@@ -13,11 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package test.subcomponent;
+package dagger.internal.codegen;
 
-import dagger.Component;
-
-@Component(modules = ParentMultibindingModule.class)
-interface ParentComponentWithMultibindings extends ParentComponentWithoutMultibindings {
-  RequiresMultibindingsInParent requiresMultibindingsInParent();
+/**
+ * Common lines outputted during code generation.
+ */
+public final class GeneratedLines {
+  public static final String GENERATED_ANNOTATION =
+      "@Generated("
+          + "comments = \"https://google.github.io/dagger\", "
+          + "value = \"dagger.internal.codegen.ComponentProcessor\")";
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
index 6001ea713..bc00e1e6d 100644
--- a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
@@ -476,7 +476,7 @@ public void falsePositiveCyclicDependencyIndirectionDetected() {
         .compilesWithoutError();
         //.compilesWithoutWarning(); //TODO(cgruber)
   }
-  
+
   @Test public void duplicateExplicitBindings_ProvidesAndComponentProvision() {
     JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
         "package test;",
@@ -560,7 +560,7 @@ public void falsePositiveCyclicDependencyIndirectionDetected() {
         .failsToCompile()
         .withErrorContaining(expectedError).in(component).onLine(24);
   }
-  
+
   @Test public void duplicateExplicitBindings_MultipleProvisionTypes() {
     JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
         "package test;",
@@ -611,27 +611,108 @@ public void falsePositiveCyclicDependencyIndirectionDetected() {
         "}");
 
     String expectedSetError =
-        "java.util.Set<java.lang.String> has incompatible bindings:\n"
-            + "      Set bindings:\n"
+        "java.util.Set<java.lang.String> has incompatible bindings or declarations:\n"
+            + "      Set bindings and declarations:\n"
             + "          @Provides(type=SET) String test.Outer.TestModule1.stringSetElement()\n"
-            + "      Unique bindings:\n"
+            + "      Unique bindings and declarations:\n"
             + "          @Provides Set<String> test.Outer.TestModule2.stringSet()";
 
     String expectedMapError =
-        "java.util.Map<java.lang.String,java.lang.String> has incompatible bindings:\n"
-            + "      Map bindings:\n"
+        "java.util.Map<java.lang.String,java.lang.String> has incompatible bindings "
+            + "or declarations:\n"
+            + "      Map bindings and declarations:\n"
             + "          @Provides(type=MAP) @test.Outer.StringKey(\"foo\") String"
             + " test.Outer.TestModule1.stringMapEntry()\n"
-            + "      Unique bindings:\n"
+            + "      Unique bindings and declarations:\n"
             + "          @Provides Map<String,String> test.Outer.TestModule2.stringMap()";
 
-    assertAbout(javaSource()).that(component)
+    assertAbout(javaSource())
+        .that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedSetError)
+        .in(component)
+        .onLine(43)
+        .and()
+        .withErrorContaining(expectedMapError)
+        .in(component)
+        .onLine(44);
+  }
+
+  @Test
+  public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.Outer",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Multibindings;",
+            "import dagger.Provides;",
+            "import java.util.HashMap;",
+            "import java.util.HashSet;",
+            "import java.util.Map;",
+            "import java.util.Set;",
+            "",
+            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+            "import static dagger.Provides.Type.MAP;",
+            "import static dagger.Provides.Type.SET;",
+            "",
+            "final class Outer {",
+            "  @Module",
+            "  static class TestModule1 {",
+            "    @Multibindings",
+            "    interface Empties {",
+            "      Map<String, String> stringMap();",
+            "      Set<String> stringSet();",
+            "    }",
+            "  }",
+            "",
+            "  @Module",
+            "  static class TestModule2 {",
+            "    @Provides Set<String> stringSet() { return new HashSet<String>(); }",
+            "",
+            "    @Provides Map<String, String> stringMap() {",
+            "      return new HashMap<String, String>();",
+            "    }",
+            "  }",
+            "",
+            "  @Component(modules = { TestModule1.class, TestModule2.class })",
+            "  interface TestComponent {",
+            "    Set<String> getStringSet();",
+            "    Map<String, String> getStringMap();",
+            "  }",
+            "}");
+
+    String expectedSetError =
+        "java.util.Set<java.lang.String> has incompatible bindings or declarations:\n"
+            + "      Set bindings and declarations:\n"
+            + "          Set<String> test.Outer.TestModule1.Empties.stringSet()\n"
+            + "      Unique bindings and declarations:\n"
+            + "          @Provides Set<String> test.Outer.TestModule2.stringSet()";
+
+    String expectedMapError =
+        "java.util.Map<java.lang.String,java.lang.String> has incompatible bindings "
+            + "or declarations:\n"
+            + "      Map bindings and declarations:\n"
+            + "          Map<String,String> test.Outer.TestModule1.Empties.stringMap()\n"
+            + "      Unique bindings and declarations:\n"
+            + "          @Provides Map<String,String> test.Outer.TestModule2.stringMap()";
+
+    assertAbout(javaSource())
+        .that(component)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(expectedSetError).in(component).onLine(43)
-        .and().withErrorContaining(expectedMapError).in(component).onLine(44);
+        .withErrorContaining(expectedSetError)
+        .in(component)
+        .onLine(37)
+        .and()
+        .withErrorContaining(expectedMapError)
+        .in(component)
+        .onLine(38);
   }
-  
+
   @Test public void duplicateBindings_TruncateAfterLimit() {
     JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
         "package test;",
@@ -1140,4 +1221,148 @@ public void falsePositiveCyclicDependencyIndirectionDetected() {
         .and()
         .withErrorContaining(shortErrorMessage).in(shortLifetime);
   }
+
+  @Test
+  @Ignore("This bug should be fixed")
+  public void subcomponentBindingConflictsWithParent() {
+    JavaFileObject parentChildConflict =
+        JavaFileObjects.forSourceLines(
+            "test.ParentChildConflict",
+            "package test;",
+            "",
+            "import javax.inject.Qualifier;",
+            "",
+            "@Qualifier @interface ParentChildConflict {}");
+    JavaFileObject parentGrandchildConflict =
+        JavaFileObjects.forSourceLines(
+            "test.ParentGrandchildConflict",
+            "package test;",
+            "",
+            "import javax.inject.Qualifier;",
+            "",
+            "@Qualifier @interface ParentGrandchildConflict {}");
+    JavaFileObject childGrandchildConflict =
+        JavaFileObjects.forSourceLines(
+            "test.ChildGrandchildConflict",
+            "package test;",
+            "",
+            "import javax.inject.Qualifier;",
+            "",
+            "@Qualifier @interface ChildGrandchildConflict {}");
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "test.Parent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Component(modules = Parent.ParentModule.class)",
+            "interface Parent {",
+            "  @ParentChildConflict Object object();",
+            "  @ParentGrandchildConflict Object object();",
+            "",
+            "  Child child();",
+            "",
+            "  @Module",
+            "  static class ParentModule {",
+            "    @Provides @ParentChildConflict static Object parentChildConflict() {",
+            "      return \"parent\";",
+            "    }",
+            "",
+            "    @Provides @ParentChildConflict static Object parentGrandchildConflict() {",
+            "      return \"parent\";",
+            "    }",
+            "  }",
+            "}");
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = Child.ChildModule.class)",
+            "interface Child {",
+            "  @ParentChildConflict Object object();",
+            "  @ChildGrandchildConflict Object object();",
+            "",
+            "  Grandchild grandchild();",
+            "",
+            "  @Module",
+            "  static class ChildModule {",
+            "    @Provides @ParentChildConflict static Object parentChildConflict() {",
+            "      return \"child\";",
+            "    }",
+            "",
+            "    @Provides @ChildGrandchildConflict static Object childGrandchildConflict() {",
+            "      return \"child\";",
+            "    }",
+            "  }",
+            "}");
+    JavaFileObject grandchild =
+        JavaFileObjects.forSourceLines(
+            "test.Grandchild",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = Grandchild.GrandchildModule.class)",
+            "interface Grandchild {",
+            "  Object object();",
+            "",
+            "  @Module",
+            "  static class GrandchildModule {",
+            "    @Provides @ParentGrandchildConflict static Object parentGrandchildConflict() {",
+            "      return \"grandchild\";",
+            "    }",
+            "",
+            "    @Provides @ChildGrandchildConflict static Object childGrandchildConflict() {",
+            "      return \"grandchild\";",
+            "    }",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(
+            ImmutableList.of(
+                parentChildConflict,
+                parentGrandchildConflict,
+                childGrandchildConflict,
+                parent,
+                child,
+                grandchild))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "@ParentChildConflict Object is rebound in test.Child:\n"
+                + "      @Provides @ParentChildConflict Object"
+                + " test.Parent.ParentModule.parentChildConflict()\n"
+                + "      @Provides @ParentChildConflict Object"
+                + " test.Child.ChildModule.parentChildConflict()\n")
+        .in(parent)
+        .onLine(12)
+        .and()
+        .withErrorContaining(
+            "@ParentGrandchildConflict Object is rebound in test.Grandchild:\n"
+                + "      @Provides @ParentGrandchildConflict Object"
+                + " test.Parent.ParentModule.parentGrandchildConflict()\n"
+                + "      @Provides @ParentGrandchildConflict Object"
+                + " test.Grandchild.GrandchildModule.parentGrandchildConflict()\n")
+        .in(parent)
+        .onLine(12)
+        .and()
+        .withErrorContaining(
+            "@ChildGrandchildConflict Object is rebound in test.Grandchild:\n"
+                + "      @Provides @ChildGrandchildConflict Object"
+                + " test.Child.ChildModule.childGrandchildConflict()\n"
+                + "      @Provides @ChildGrandchildConflict Object"
+                + " test.Grandchild.GrandchildModule.childGrandchildConflict()\n")
+        .in(child)
+        .onLine(12);
+  }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/InaccessibleTypeTest.java b/compiler/src/test/java/dagger/internal/codegen/InaccessibleTypeTest.java
index 635592214..9983c5674 100644
--- a/compiler/src/test/java/dagger/internal/codegen/InaccessibleTypeTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/InaccessibleTypeTest.java
@@ -24,6 +24,7 @@
 
 import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 
 @RunWith(JUnit4.class)
 public class InaccessibleTypeTest {
@@ -85,7 +86,7 @@
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class DaggerTestComponent implements TestComponent {",
         "  @SuppressWarnings(\"rawtypes\")",
         "  private Provider nonPublicClass1Provider;",
@@ -210,7 +211,7 @@
             "import dagger.MembersInjector;",
             "import javax.annotation.Generated;",
             "",
-            "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+            GENERATED_ANNOTATION,
             "public final class DaggerTestComponent implements TestComponent {",
             "  private MembersInjector<A> aMembersInjector;",
             "",
diff --git a/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
index ca0494e47..3e8fde831 100644
--- a/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
@@ -39,6 +39,7 @@
 import static dagger.internal.codegen.ErrorMessages.QUALIFIER_ON_INJECT_CONSTRUCTOR;
 import static dagger.internal.codegen.ErrorMessages.STATIC_INJECT_FIELD;
 import static dagger.internal.codegen.ErrorMessages.STATIC_INJECT_METHOD;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 
 @RunWith(JUnit4.class)
 // TODO(gak): add tests for generation in the default package.
@@ -135,7 +136,7 @@
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class GenericClass_Factory<T> implements Factory<GenericClass<T>> {",
         "  private final Provider<T> tProvider;",
         "",
@@ -172,34 +173,37 @@
         "",
         " @Inject void register(B b) {}",
         "}");
-    JavaFileObject expected = JavaFileObjects.forSourceLines("test.GenericClass_Factory",
-        "package test;",
-        "",
-        "import dagger.MembersInjector;",
-        "import dagger.internal.Factory;",
-        "import javax.annotation.Generated;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class GenericClass_Factory<A, B> implements Factory<GenericClass<A, B>> {",
-        "  private final MembersInjector<GenericClass<A, B>> membersInjector;",
-        "",
-        "  public GenericClass_Factory(MembersInjector<GenericClass<A, B>> membersInjector) {",
-        "    assert membersInjector != null;",
-        "    this.membersInjector = membersInjector;",
-        "  }",
-        "",
-        "  @Override",
-        "  public GenericClass<A, B> get() {",
-        "    GenericClass<A, B> instance = new GenericClass<A, B>();",
-        "    membersInjector.injectMembers(instance);",
-        "    return instance;",
-        "  }",
-        "",
-        "  public static <A, B> Factory<GenericClass<A, B>> create(",
-        "      MembersInjector<GenericClass<A, B>> membersInjector) {",
-        "    return new GenericClass_Factory<A, B>(membersInjector);",
-        "  }",
-        "}");
+    JavaFileObject expected =
+        JavaFileObjects.forSourceLines(
+            "test.GenericClass_Factory",
+            "package test;",
+            "",
+            "import dagger.MembersInjector;",
+            "import dagger.internal.Factory;",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class GenericClass_Factory<A, B> implements Factory<GenericClass<A, B>> {",
+            "  private final MembersInjector<GenericClass<A, B>> genericClassMembersInjector;",
+            "",
+            "  public GenericClass_Factory(",
+            "      MembersInjector<GenericClass<A, B>> genericClassMembersInjector) {",
+            "    assert genericClassMembersInjector != null;",
+            "    this.genericClassMembersInjector = genericClassMembersInjector;",
+            "  }",
+            "",
+            "  @Override",
+            "  public GenericClass<A, B> get() {",
+            "    GenericClass<A, B> instance = new GenericClass<A, B>();",
+            "    genericClassMembersInjector.injectMembers(instance);",
+            "    return instance;",
+            "  }",
+            "",
+            "  public static <A, B> Factory<GenericClass<A, B>> create(",
+            "      MembersInjector<GenericClass<A, B>> genericClassMembersInjector) {",
+            "    return new GenericClass_Factory<A, B>(genericClassMembersInjector);",
+            "  }",
+            "}");
     assertAbout(javaSource()).that(file)
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
@@ -222,7 +226,7 @@
         "import javax.annotation.Generated;",
         "",
         "@SuppressWarnings(\"rawtypes\")",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public enum GenericClass_Factory implements Factory<GenericClass> {",
         "  INSTANCE;",
         "",
@@ -259,7 +263,7 @@
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class GenericClass_Factory<A, B> implements Factory<GenericClass<A, B>> {",
         "  private final Provider<A> aProvider;",
         "  private final Provider<B> bProvider;",
@@ -307,7 +311,7 @@
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class GenericClass_Factory<A extends Number & Comparable<A>,",
         "        B extends List<? extends String>,",
         "        C extends List<? super String>>",
@@ -367,7 +371,7 @@
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class GenericClass_Factory<A, B> implements Factory<GenericClass<A, B>> {",
         "  private final Provider<A> aAndA2AndPaAndLaProvider;",
         "  private final Provider<A> qaProvider;",
@@ -717,7 +721,7 @@
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class InjectConstructor_Factory ",
         "    implements Factory<InjectConstructor> {",
         "",
@@ -752,42 +756,44 @@
         "  @Inject AllInjections(String s) {}",
         "  @Inject void s(String s) {}",
         "}");
-    JavaFileObject expectedFactory = JavaFileObjects.forSourceLines(
-        "test.AllInjections_Factory",
-        "package test;",
-        "",
-        "import dagger.MembersInjector;",
-        "import dagger.internal.Factory;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class AllInjections_Factory ",
-        "    implements Factory<AllInjections> {",
-        "",
-        "  private final MembersInjector<AllInjections> membersInjector;",
-        "  private final Provider<String> sProvider;",
-        "",
-        "  public AllInjections_Factory(MembersInjector<AllInjections> membersInjector, ",
-        "      Provider<String> sProvider) {",
-        "    assert membersInjector != null;",
-        "    this.membersInjector = membersInjector;",
-        "    assert sProvider != null;",
-        "    this.sProvider = sProvider;",
-        "  }",
-        "",
-        "  @Override public AllInjections get() {",
-        "    AllInjections instance = new AllInjections(sProvider.get());",
-        "    membersInjector.injectMembers(instance);",
-        "    return instance;",
-        "  }",
-        "",
-        "  public static Factory<AllInjections> create(",
-        "      MembersInjector<AllInjections> membersInjector, ",
-        "      Provider<String> sProvider) {",
-        "    return new AllInjections_Factory(membersInjector, sProvider);",
-        "  }",
-        "}");
+    JavaFileObject expectedFactory =
+        JavaFileObjects.forSourceLines(
+            "test.AllInjections_Factory",
+            "package test;",
+            "",
+            "import dagger.MembersInjector;",
+            "import dagger.internal.Factory;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class AllInjections_Factory ",
+            "    implements Factory<AllInjections> {",
+            "",
+            "  private final MembersInjector<AllInjections> allInjectionsMembersInjector;",
+            "  private final Provider<String> sProvider;",
+            "",
+            "  public AllInjections_Factory(",
+            "      MembersInjector<AllInjections> allInjectionsMembersInjector, ",
+            "      Provider<String> sProvider) {",
+            "    assert allInjectionsMembersInjector != null;",
+            "    this.allInjectionsMembersInjector = allInjectionsMembersInjector;",
+            "    assert sProvider != null;",
+            "    this.sProvider = sProvider;",
+            "  }",
+            "",
+            "  @Override public AllInjections get() {",
+            "    AllInjections instance = new AllInjections(sProvider.get());",
+            "    allInjectionsMembersInjector.injectMembers(instance);",
+            "    return instance;",
+            "  }",
+            "",
+            "  public static Factory<AllInjections> create(",
+            "      MembersInjector<AllInjections> allInjectionsMembersInjector, ",
+            "      Provider<String> sProvider) {",
+            "    return new AllInjections_Factory(allInjectionsMembersInjector, sProvider);",
+            "  }",
+            "}");
     assertAbout(javaSource()).that(file).processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and()
@@ -807,34 +813,35 @@
         "class B extends A {",
         "  @Inject B() {}",
         "}");
-    JavaFileObject expectedFactory = JavaFileObjects.forSourceLines(
-        "test.B_Factory",
-        "package test;",
-        "",
-        "import dagger.MembersInjector;",
-        "import dagger.internal.Factory;",
-        "import javax.annotation.Generated;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class B_Factory implements Factory<B> {",
-        "",
-        "  private final MembersInjector<B> membersInjector;",
-        "",
-        "  public B_Factory(MembersInjector<B> membersInjector) {",
-        "    assert membersInjector != null;",
-        "    this.membersInjector = membersInjector;",
-        "  }",
-        "",
-        "  @Override public B get() {",
-        "    B instance = new B();",
-        "    membersInjector.injectMembers(instance);",
-        "    return instance;",
-        "  }",
-        "",
-        "  public static Factory<B> create(MembersInjector<B> membersInjector) {",
-        "    return new B_Factory(membersInjector);",
-        "  }",
-        "}");
+    JavaFileObject expectedFactory =
+        JavaFileObjects.forSourceLines(
+            "test.B_Factory",
+            "package test;",
+            "",
+            "import dagger.MembersInjector;",
+            "import dagger.internal.Factory;",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class B_Factory implements Factory<B> {",
+            "",
+            "  private final MembersInjector<B> bMembersInjector;",
+            "",
+            "  public B_Factory(MembersInjector<B> bMembersInjector) {",
+            "    assert bMembersInjector != null;",
+            "    this.bMembersInjector = bMembersInjector;",
+            "  }",
+            "",
+            "  @Override public B get() {",
+            "    B instance = new B();",
+            "    bMembersInjector.injectMembers(instance);",
+            "    return instance;",
+            "  }",
+            "",
+            "  public static Factory<B> create(MembersInjector<B> bMembersInjector) {",
+            "    return new B_Factory(bMembersInjector);",
+            "  }",
+            "}");
     assertAbout(javaSources()).that(ImmutableList.of(aFile, bFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
@@ -861,7 +868,7 @@ public void wildcardDependency() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class InjectConstructor_Factory ",
         "    implements Factory<InjectConstructor> {",
         "",
@@ -909,7 +916,7 @@ public void basicNameCollision() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class InjectConstructor_Factory ",
         "    implements Factory<InjectConstructor> {",
         "",
@@ -961,7 +968,7 @@ public void nestedNameCollision() {
         "import javax.inject.Provider;",
         "import other.pkg.Outer;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class InjectConstructor_Factory ",
         "    implements Factory<InjectConstructor> {",
         "",
@@ -1015,7 +1022,7 @@ public void samePackageNameCollision() {
         "import javax.inject.Provider;",
         "import other.pkg.CommonName;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class InjectConstructor_Factory ",
         "    implements Factory<InjectConstructor> {",
         "",
@@ -1063,7 +1070,7 @@ public void noDeps() {
         "import dagger.internal.Factory;",
         "import javax.annotation.Generated;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public enum SimpleType_Factory implements Factory<SimpleType> {",
         "  INSTANCE;",
         "",
@@ -1108,7 +1115,7 @@ public void noDeps() {
         "import dagger.internal.Factory;",
         "import javax.annotation.Generated;",
         "import test.OuterType.A;",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public enum OuterType$A_Factory implements Factory<A> {",
         "  INSTANCE;",
         "",
diff --git a/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
index 9e1b6dccd..ab2212722 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
@@ -25,6 +25,7 @@
 
 import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 
 @RunWith(JUnit4.class)
 public class MapBindingComponentProcessorTest {
@@ -117,7 +118,7 @@ public void mapBindingsWithEnumKey() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class DaggerTestComponent implements TestComponent {",
         "  private Provider<Handler> mapOfPathEnumAndProviderOfHandlerContribution1;",
         "  private Provider<Handler> mapOfPathEnumAndProviderOfHandlerContribution2;",
@@ -277,7 +278,7 @@ public void mapBindingsWithStringKey() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class DaggerTestComponent implements TestComponent {",
         "  private Provider<Handler> mapOfStringAndProviderOfHandlerContribution1;",
         "  private Provider<Handler> mapOfStringAndProviderOfHandlerContribution2;",
@@ -444,7 +445,7 @@ public void mapBindingsWithWrappedKey() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class DaggerTestComponent implements TestComponent {",
         "  private Provider<Handler> mapOfWrappedClassKeyAndProviderOfHandlerContribution1;",
         "  private Provider<Handler> mapOfWrappedClassKeyAndProviderOfHandlerContribution2;",
@@ -616,7 +617,7 @@ public void mapBindingsWithNonProviderValue() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class DaggerTestComponent implements TestComponent {",
         "  private Provider<Handler> mapOfPathEnumAndProviderOfHandlerContribution1;",
         "  private Provider<Handler> mapOfPathEnumAndProviderOfHandlerContribution2;",
@@ -742,7 +743,7 @@ public void injectMapWithoutMapBinding() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class DaggerTestComponent implements TestComponent {",
         "  private Provider<Map<String, String>> provideAMapProvider;",
         "",
diff --git a/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
index 191ee6c12..c20383ffd 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
@@ -25,6 +25,7 @@
 
 import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 
 @RunWith(JUnit4.class)
 public class MapKeyProcessorTest {
@@ -57,7 +58,7 @@ public void mapKeyCreatorFile() {
             "import com.google.auto.value.AutoAnnotation;",
             "import javax.annotation.Generated;",
             "",
-            "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+            GENERATED_ANNOTATION,
             "public final class PathKeyCreator {",
             "  @AutoAnnotation",
             "  public static PathKey createPathKey(PathEnum value, String relativePath) {",
@@ -104,7 +105,7 @@ public void nestedMapKeyCreatorFile() {
             "import javax.annotation.Generated;",
             "import test.Container.PathKey",
             "",
-            "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+            GENERATED_ANNOTATION,
             "public final class Container$PathKeyCreator {",
             "  @AutoAnnotation",
             "  public static PathKey createPathKey(PathEnum value, String relativePath) {",
@@ -206,7 +207,7 @@ public void mapKeyComponentFileWithDisorderedKeyField() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class DaggerTestComponent implements TestComponent {",
         "  private Provider<Handler> mapOfPathKeyAndProviderOfHandlerContribution1;",
         "  private Provider<Handler> mapOfPathKeyAndProviderOfHandlerContribution2;",
@@ -382,7 +383,7 @@ public void mapKeyComponentFileWithDefaultField() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class DaggerTestComponent implements TestComponent {",
         "  private Provider<Handler> mapOfPathKeyAndProviderOfHandlerContribution1;",
         "  private Provider<Handler> mapOfPathKeyAndProviderOfHandlerContribution2;",
diff --git a/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java b/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
index 52be72ae9..6d6d767f7 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
@@ -33,6 +33,7 @@
 import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 import static javax.tools.StandardLocation.CLASS_OUTPUT;
 
 @RunWith(JUnit4.class)
@@ -71,7 +72,7 @@ public void parentClass_noInjectedMembers() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class DaggerTestComponent implements TestComponent {",
         "  private Provider<Child> childProvider;",
         "",
@@ -160,7 +161,7 @@ public void parentClass_injectedMembersInSupertype() {
             "import javax.annotation.Generated;",
             "import javax.inject.Provider;",
             "",
-            "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+            GENERATED_ANNOTATION,
             "public final class DaggerTestComponent implements TestComponent {",
             "  private MembersInjector<Child> childMembersInjector;",
             "  private Provider<Child> childProvider;",
@@ -226,7 +227,7 @@ public void parentClass_injectedMembersInSupertype() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class GenericClass_MembersInjector<A, B>",
         "    implements MembersInjector<GenericClass<A, B>> {",
         "  private final Provider<A> aProvider;",
@@ -319,7 +320,7 @@ public void parentClass_injectedMembersInSupertype() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class Child_MembersInjector<T>",
         "    implements MembersInjector<Child<T>> {",
         "  private final Provider<T> tAndXProvider;",
@@ -391,7 +392,7 @@ public void parentClass_injectedMembersInSupertype() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class FieldInjection_MembersInjector",
         "    implements MembersInjector<FieldInjection> {",
         "  private final Provider<String> stringProvider;",
@@ -461,7 +462,7 @@ public void parentClass_injectedMembersInSupertype() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class MethodInjection_MembersInjector",
         "     implements MembersInjector<MethodInjection> {",
         "",
@@ -540,7 +541,7 @@ public void mixedMemberInjection() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class MixedMemberInjection_MembersInjector",
         "    implements MembersInjector<MixedMemberInjection> {",
         "",
@@ -620,7 +621,7 @@ public void mixedMemberInjection() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class AllInjections_MembersInjector ",
         "    implements MembersInjector<AllInjections> {",
         "",
@@ -677,7 +678,7 @@ public void mixedMemberInjection() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class B_MembersInjector implements MembersInjector<B> {",
         "  private final Provider<String> sProvider;",
         "",
@@ -740,7 +741,7 @@ public void simpleComponentWithNesting() {
           "import test.OuterType.A;",
           "import test.OuterType.B;",
           "",
-          "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
           "public final class OuterType$B_MembersInjector implements MembersInjector<B> {",
           "  private final Provider<A> aProvider;",
           "",
@@ -807,7 +808,7 @@ public void componentWithNestingAndGeneratedType() {
             "import test.OuterType.A;",
             "import test.OuterType.B;",
             "",
-            "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+            GENERATED_ANNOTATION,
             "public final class OuterType$B_MembersInjector implements MembersInjector<B> {",
             "  private final Provider<A> aProvider;",
             "",
diff --git a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
index 72248e0c7..8cd99733a 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
@@ -36,7 +36,9 @@
 import static dagger.internal.codegen.ErrorMessages.MODULES_WITH_TYPE_PARAMS_MUST_BE_ABSTRACT;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_RETURN_TYPE;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_SET_VALUES_RETURN_SET;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_THROWS;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_OR_PRODUCES_METHOD_MULTIPLE_QUALIFIERS;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 
 @RunWith(JUnit4.class)
 public class ModuleFactoryGeneratorTest {
@@ -372,7 +374,7 @@ private String formatModuleErrorMessage(String msg) {
         "import dagger.internal.Factory;",
         "import javax.annotation.Generated;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class TestModule_ProvideStringFactory implements Factory<String> {",
         "  private final TestModule module;",
         "",
@@ -418,7 +420,7 @@ private String formatModuleErrorMessage(String msg) {
         "import dagger.internal.Factory;",
         "import javax.annotation.Generated;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class TestModule_ProvideStringFactory implements Factory<String> {",
         "  private final TestModule module;",
         "",
@@ -459,7 +461,7 @@ private String formatModuleErrorMessage(String msg) {
         "import dagger.internal.Factory;",
         "import javax.annotation.Generated;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class TestModule_ProvideStringFactory implements Factory<String> {",
         "  private final TestModule module;",
         "",
@@ -543,7 +545,7 @@ private String formatModuleErrorMessage(String msg) {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class TestModule_ProvideObjectsFactory implements Factory<List<Object>> {",
         "  private final TestModule module;",
         "  private final Provider<Object> aProvider;",
@@ -614,7 +616,7 @@ private String formatModuleErrorMessage(String msg) {
         "import java.util.Set;",
         "import javax.annotation.Generated;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class TestModule_ProvideStringFactory implements Factory<Set<String>> {",
         "  private final TestModule module;",
         "",
@@ -665,7 +667,7 @@ private String formatModuleErrorMessage(String msg) {
         "import java.util.Set;",
         "import javax.annotation.Generated;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class TestModule_ProvideWildcardListFactory implements "
             + "Factory<Set<List<List<?>>>> {",
         "  private final TestModule module;",
@@ -712,7 +714,7 @@ private String formatModuleErrorMessage(String msg) {
         "import java.util.Set;",
         "import javax.annotation.Generated;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class TestModule_ProvideStringsFactory implements Factory<Set<String>> {",
         "  private final TestModule module;",
         "",
@@ -764,6 +766,39 @@ private String formatModuleErrorMessage(String msg) {
         .in(moduleFile).onLine(12);
   }
 
+  @Test
+  public void producesMethodThrowsChecked() {
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "final class TestModule {",
+            "  @Provides int i() throws Exception {",
+            "    return 0;",
+            "  }",
+            "",
+            "  @Provides String s() throws Throwable {",
+            "    return \"\";",
+            "  }",
+            "}");
+    assertAbout(javaSource())
+        .that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(formatErrorMessage(PROVIDES_METHOD_THROWS))
+        .in(moduleFile)
+        .onLine(8)
+        .and()
+        .withErrorContaining(formatErrorMessage(PROVIDES_METHOD_THROWS))
+        .in(moduleFile)
+        .onLine(12);
+  }
+
   @Test
   public void providedTypes() {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
@@ -953,7 +988,7 @@ public void genericSubclassedModule() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class ParentModule_ProvideListBFactory<A extends CharSequence,",
         "    B, C extends Number & Comparable<C>> implements Factory<List<B>> {",
         "  private final ParentModule<A, B, C> module;",
@@ -988,7 +1023,7 @@ public void genericSubclassedModule() {
         "import dagger.internal.Factory;",
         "import javax.annotation.Generated;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class ChildNumberModule_ProvideNumberFactory implements Factory<Number> {",
         "  private final ChildNumberModule module;",
         "",
@@ -1017,7 +1052,7 @@ public void genericSubclassedModule() {
         "import dagger.internal.Factory;",
         "import javax.annotation.Generated;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class ChildIntegerModule_ProvideIntegerFactory",
         "    implements Factory<Integer> {",
         "  private final ChildIntegerModule module;",
diff --git a/compiler/src/test/java/dagger/internal/codegen/MultibindingsValidatorTest.java b/compiler/src/test/java/dagger/internal/codegen/MultibindingsValidatorTest.java
new file mode 100644
index 000000000..9ec7469a5
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/MultibindingsValidatorTest.java
@@ -0,0 +1,394 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static java.util.Arrays.asList;
+
+@RunWith(JUnit4.class)
+public class MultibindingsValidatorTest {
+
+  private static final JavaFileObject SOME_QUALIFIER =
+      JavaFileObjects.forSourceLines(
+          "test.SomeQualifier",
+          "package test;",
+          "",
+          "import javax.inject.Qualifier;",
+          "",
+          "@Qualifier",
+          "@interface SomeQualifier {}");
+
+  private static final JavaFileObject OTHER_QUALIFIER =
+      JavaFileObjects.forSourceLines(
+          "test.OtherQualifier",
+          "package test;",
+          "",
+          "import javax.inject.Qualifier;",
+          "",
+          "@Qualifier",
+          "@interface OtherQualifier {}");
+
+  @Test
+  public void abstractClass() {
+    JavaFileObject testModule =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Multibindings;",
+            "import java.util.Map;",
+            "import java.util.Set;",
+            "",
+            "@Module",
+            "class TestModule {",
+            "  @Multibindings",
+            "  static abstract class Empties {",
+            "    abstract Set<Object> emptySet();",
+            "    @SomeQualifier abstract Set<Object> emptyQualifiedSet();",
+            "    abstract Map<String, Object> emptyMap();",
+            "    @SomeQualifier abstract Map<String, Object> emptyQualifiedMap();",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(asList(testModule, SOME_QUALIFIER))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("@Multibindings can be applied only to interfaces")
+        .in(testModule)
+        .onLine(11);
+  }
+
+  @Test
+  public void concreteClass() {
+    JavaFileObject testModule =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Multibindings;",
+            "import java.util.Map;",
+            "import java.util.Set;",
+            "",
+            "@Module",
+            "class TestModule {",
+            "  @Multibindings",
+            "  static class Empties {",
+            "    Set<Object> emptySet() { return null; }",
+            "    @SomeQualifier Set<Object> emptyQualifiedSet() { return null; }",
+            "    Map<String, Object> emptyMap() { return null; }",
+            "    @SomeQualifier Map<String, Object> emptyQualifiedMap() { return null; }",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(asList(testModule, SOME_QUALIFIER))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("@Multibindings can be applied only to interfaces")
+        .in(testModule)
+        .onLine(11);
+  }
+
+  @Test
+  public void interfaceHasTypeParameters() {
+    JavaFileObject testModule =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Multibindings;",
+            "import java.util.Map;",
+            "import java.util.Set;",
+            "",
+            "@Module",
+            "class TestModule {",
+            "  @Multibindings",
+            "  interface Empties<T> {",
+            "    Set<T> emptySet();",
+            "    @SomeQualifier Set<T> emptyQualifiedSet();",
+            "    Map<String, T> emptyMap();",
+            "    @SomeQualifier Map<String, T> emptyQualifiedMap();",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(asList(testModule, SOME_QUALIFIER))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("@Multibindings types must not have type parameters")
+        .in(testModule)
+        .onLine(11);
+  }
+
+  @Test
+  public void topLevel() {
+    JavaFileObject testInterface =
+        JavaFileObjects.forSourceLines(
+            "test.TestInterface",
+            "package test;",
+            "",
+            "import dagger.Multibindings;",
+            "import java.util.Map;",
+            "import java.util.Set;",
+            "",
+            "@Multibindings",
+            "interface Empties {",
+            "  Set<Object> emptySet();",
+            "  @SomeQualifier Set<Object> emptyQualifiedSet();",
+            "  Map<String, Object> emptyMap();",
+            "  @SomeQualifier Map<String, Object> emptyQualifiedMap();",
+            "}");
+    assertAbout(javaSources())
+        .that(asList(testInterface, SOME_QUALIFIER))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "@Multibindings types must be nested within a @Module or @ProducerModule")
+        .in(testInterface)
+        .onLine(8);
+  }
+
+  @Test
+  public void notWithinModule() {
+    JavaFileObject testModule =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Multibindings;",
+            "import java.util.Map;",
+            "import java.util.Set;",
+            "",
+            "class TestModule {",
+            "  @Multibindings",
+            "  interface Empties {",
+            "    Set<Object> emptySet();",
+            "    @SomeQualifier Set<Object> emptyQualifiedSet();",
+            "    Map<String, Object> emptyMap();",
+            "    @SomeQualifier Map<String, Object> emptyQualifiedMap();",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(asList(testModule, SOME_QUALIFIER))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "@Multibindings types must be nested within a @Module or @ProducerModule")
+        .in(testModule)
+        .onLine(9);
+  }
+
+  @Test
+  public void badMethods() {
+    JavaFileObject testModule =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Multibindings;",
+            "import dagger.producers.Produced;",
+            "import dagger.producers.Producer;",
+            "import java.util.Map;",
+            "import java.util.Set;",
+            "import javax.inject.Provider;",
+            "",
+            "@Module",
+            "class TestModule {",
+            "  @Multibindings",
+            "  interface Empties {",
+            "    void voidMethod();",
+            "    int primitive();",
+            "    Map rawMap();",
+            "    Map<?, ?> wildcardMap();",
+            "    Map<String, Provider<Object>> providerMap();",
+            "    Map<String, Producer<Object>> producerMap();",
+            "    Map<String, Produced<Object>> producedMap();",
+            "    Set rawSet();",
+            "    Set<?> wildcardSet();",
+            "    Set<Provider<Object>> providerSet();",
+            "    Set<Producer<Object>> producerSet();",
+            "    Set<Produced<Object>> producedSet();",
+            "    @SomeQualifier @OtherQualifier Set<Object> tooManyQualifiersSet();",
+            "    @SomeQualifier @OtherQualifier Map<String, Object> tooManyQualifiersMap();",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(asList(testModule, SOME_QUALIFIER, OTHER_QUALIFIER))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("@Multibindings methods must return Map<K, V> or Set<T>")
+        .in(testModule)
+        .onLine(15)
+        .and()
+        .withErrorContaining("@Multibindings methods must return Map<K, V> or Set<T>")
+        .in(testModule)
+        .onLine(16)
+        .and()
+        .withErrorContaining("@Multibindings methods must return Map<K, V> or Set<T>")
+        .in(testModule)
+        .onLine(17)
+        .and()
+        .withErrorContaining("@Multibindings methods must return Map<K, V> or Set<T>")
+        .in(testModule)
+        .onLine(18)
+        .and()
+        .withErrorContaining("@Multibindings methods must return Map<K, V> or Set<T>")
+        .in(testModule)
+        .onLine(19)
+        .and()
+        .withErrorContaining("@Multibindings methods must return Map<K, V> or Set<T>")
+        .in(testModule)
+        .onLine(20)
+        .and()
+        .withErrorContaining("@Multibindings methods must return Map<K, V> or Set<T>")
+        .in(testModule)
+        .onLine(21)
+        .and()
+        .withErrorContaining("@Multibindings methods must return Map<K, V> or Set<T>")
+        .in(testModule)
+        .onLine(22)
+        .and()
+        .withErrorContaining("@Multibindings methods must return Map<K, V> or Set<T>")
+        .in(testModule)
+        .onLine(23)
+        .and()
+        .withErrorContaining("@Multibindings methods must return Map<K, V> or Set<T>")
+        .in(testModule)
+        .onLine(24)
+        .and()
+        .withErrorContaining("@Multibindings methods must return Map<K, V> or Set<T>")
+        .in(testModule)
+        .onLine(25)
+        .and()
+        .withErrorContaining("@Multibindings methods must return Map<K, V> or Set<T>")
+        .in(testModule)
+        .onLine(26)
+        .and()
+        .withErrorContaining(
+            "Cannot use more than one @Qualifier on a method in an @Multibindings type")
+        .in(testModule)
+        .onLine(27)
+        .and()
+        .withErrorContaining(
+            "Cannot use more than one @Qualifier on a method in an @Multibindings type")
+        .in(testModule)
+        .onLine(28);
+  }
+
+  @Test
+  public void badMethodsOnSupertype() {
+    JavaFileObject testModule =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Multibindings;",
+            "import dagger.producers.Produced;",
+            "import dagger.producers.Producer;",
+            "import java.util.Map;",
+            "import java.util.Set;",
+            "import javax.inject.Provider;",
+            "",
+            "@Module",
+            "class TestModule {",
+            "  interface BaseEmpties {",
+            "    void voidMethod();",
+            "  }",
+            "",
+            "  @Multibindings",
+            "  interface Empties extends BaseEmpties {}",
+            "}");
+    assertAbout(javaSources())
+        .that(asList(testModule, SOME_QUALIFIER, OTHER_QUALIFIER))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "[test.TestModule.BaseEmpties.voidMethod()] "
+                + "@Multibindings methods must return Map<K, V> or Set<T>")
+        .in(testModule)
+        .onLine(18);
+  }
+
+  @Test
+  public void duplicateKeys() {
+    JavaFileObject testModule =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Multibindings;",
+            "import java.util.Map;",
+            "import java.util.Set;",
+            "",
+            "@Module",
+            "class TestModule {",
+            "  @Multibindings",
+            "  interface EmptySets {",
+            "    Set<Object> emptySet();",
+            "    Set<Object> emptySet2();",
+            "  }",
+            "",
+            "  @Multibindings",
+            "  interface EmptyQualifiedSets {",
+            "    @SomeQualifier Set<Object> emptyQualifiedSet();",
+            "    @SomeQualifier Set<Object> emptyQualifiedSet2();",
+            "  }",
+            "",
+            "  @Multibindings",
+            "  interface EmptyMaps {",
+            "    Map<String, Object> emptyMap();",
+            "    Map<String, Object> emptyMap2();",
+            "  }",
+            "",
+            "  @Multibindings",
+            "  interface EmptyQualifiedMaps {",
+            "    @SomeQualifier Map<String, Object> emptyQualifiedMap();",
+            "    @SomeQualifier Map<String, Object> emptyQualifiedMap2();",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(asList(testModule, SOME_QUALIFIER))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("Too many @Multibindings methods for Set<Object>:")
+        .in(testModule)
+        .onLine(11)
+        .and()
+        .withErrorContaining("Too many @Multibindings methods for @test.SomeQualifier Set<Object>:")
+        .in(testModule)
+        .onLine(17)
+        .and()
+        .withErrorContaining("Too many @Multibindings methods for Map<String,Provider<Object>>:")
+        .in(testModule)
+        .onLine(23)
+        .and()
+        .withErrorContaining(
+            "Too many @Multibindings methods for @test.SomeQualifier Map<String,Provider<Object>>:")
+        .in(testModule)
+        .onLine(29);
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
index f9c287859..dd9e53863 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
@@ -36,7 +36,9 @@
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_RAW_FUTURE;
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_RETURN_TYPE;
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_SET_VALUES_RETURN_SET;
+import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_THROWS;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_OR_PRODUCES_METHOD_MULTIPLE_QUALIFIERS;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 
 @RunWith(JUnit4.class)
 public class ProducerModuleFactoryGeneratorTest {
@@ -339,6 +341,32 @@ private String formatModuleErrorMessage(String msg) {
         .and().withErrorContaining(errorMessage).in(moduleFile).onLine(12);
   }
 
+  @Test
+  public void producesMethodThrowsThrowable() {
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.producers.ProducerModule;",
+            "import dagger.producers.Produces;",
+            "",
+            "@ProducerModule",
+            "final class TestModule {",
+            "  @Produces int produceInt() throws Throwable {",
+            "    return 0;",
+            "  }",
+            "",
+            "}");
+    assertAbout(javaSource())
+        .that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(PRODUCES_METHOD_THROWS)
+        .in(moduleFile)
+        .onLine(8);
+  }
+
   @Test
   public void privateModule() {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.Enclosing",
@@ -482,7 +510,7 @@ public void publicModuleNonPublicIncludes() {
             "import javax.annotation.Generated;",
             "import javax.inject.Provider;",
             "",
-            "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+            GENERATED_ANNOTATION,
             "public final class TestModule_ProduceStringFactory extends AbstractProducer<String> {",
             "  private final TestModule module;",
             "  private final Executor executor;",
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
index a8e39b28a..1437e6f8a 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
@@ -23,6 +23,7 @@
 
 import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 
 @RunWith(JUnit4.class)
 public class ProductionComponentProcessorTest {
@@ -78,10 +79,11 @@
         "",
         "@ProductionComponent(modules = Object.class)",
         "interface NotAComponent {}");
-    assertAbout(javaSource()).that(componentFile)
+    assertAbout(javaSource())
+        .that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining("is not annotated with @Module or @ProducerModule");
+        .withErrorContaining("is not annotated with one of @Module, @ProducerModule");
   }
 
   @Test public void simpleComponent() {
@@ -145,7 +147,7 @@
             "import test.TestClass.BModule;",
             "import test.TestClass.SimpleComponent;",
             "",
-            "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+            GENERATED_ANNOTATION,
             "public final class DaggerTestClass_SimpleComponent implements SimpleComponent {",
             "  private Provider<SimpleComponent> simpleComponentProvider;",
             "  private Provider<Set<Factory>> setOfFactoryContribution1Provider;",
diff --git a/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java
index d47c32839..76287e946 100644
--- a/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java
@@ -24,6 +24,7 @@
 
 import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 
 @RunWith(JUnit4.class)
 public final class SubcomponentValidationTest {
@@ -340,14 +341,14 @@ public void delegateFactoryNotCreatedForSubcomponentWhenProviderExistsInParent()
 
     JavaFileObject componentGeneratedFile =
         JavaFileObjects.forSourceLines(
-            "DaggerParentComponent",
+            "test.DaggerParentComponent",
             "package test;",
             "",
             "import dagger.MembersInjector;",
             "import javax.annotation.Generated;",
             "import javax.inject.Provider;",
             "",
-            "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+            GENERATED_ANNOTATION,
             "public final class DaggerParentComponent implements ParentComponent {",
             "  private MembersInjector<Dep1> dep1MembersInjector;",
             "  private Provider<Dep1> dep1Provider;",
@@ -446,4 +447,376 @@ public void delegateFactoryNotCreatedForSubcomponentWhenProviderExistsInParent()
         .and()
         .generatesSources(componentGeneratedFile);
   }
+
+  @Test
+  public void multipleSubcomponentsWithSameSimpleNamesCanExistInSameComponent() {
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "test.ParentComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface ParentComponent {",
+            "  Foo.Sub newFooSubcomponent();",
+            "  NoConflict newNoConflictSubcomponent();",
+            "}");
+    JavaFileObject foo =
+        JavaFileObjects.forSourceLines(
+            "test.Foo",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "interface Foo {",
+            "  @Subcomponent interface Sub {",
+            "    Bar.Sub newBarSubcomponent();",
+            "  }",
+            "}");
+    JavaFileObject bar =
+        JavaFileObjects.forSourceLines(
+            "test.Bar",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "interface Bar {",
+            "  @Subcomponent interface Sub {",
+            "    test.subpackage.Sub newSubcomponentInSubpackage();",
+            "  }",
+            "}");
+    JavaFileObject baz =
+        JavaFileObjects.forSourceLines(
+            "test.subpackage.Sub",
+            "package test.subpackage;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent public interface Sub {}");
+    JavaFileObject noConflict =
+        JavaFileObjects.forSourceLines(
+            "test.NoConflict",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent interface NoConflict {}");
+
+    JavaFileObject componentGeneratedFile =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerParentComponent",
+            "package test;",
+            "",
+            "import javax.annotation.Generated;",
+            "import test.Bar.Sub;",
+            "import test.Foo;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerParentComponent implements ParentComponent {",
+            "  private DaggerParentComponent(Builder builder) {",
+            "    assert builder != null;",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static ParentComponent create() {",
+            "    return builder().build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Foo.Sub newFooSubcomponent() {",
+            "    return new Foo_SubImpl();",
+            "  }",
+            "",
+            "  @Override",
+            "  public NoConflict newNoConflictSubcomponent() {",
+            "    return new NoConflictImpl();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {}",
+            "",
+            "    public ParentComponent build() {",
+            "      return new DaggerParentComponent(this);",
+            "    }",
+            "  }",
+            "",
+            "  private final class Foo_SubImpl implements Foo.Sub {",
+            "",
+            "    @Override",
+            "    public Sub newBarSubcomponent() {",
+            "      return new Bar_SubImpl();",
+            "    }",
+            "",
+            "    private final class Bar_SubImpl implements Sub {",
+            "",
+            "      @Override",
+            "      public test.subpackage.Sub newSubcomponentInSubpackage() {",
+            "        return new subpackage_SubImpl();",
+            "      }",
+            "",
+            "      private final class subpackage_SubImpl implements test.subpackage.Sub {}",
+            "    }",
+            "  }",
+            "  private final class NoConflictImpl implements NoConflict {}",
+            "}");
+
+    assertAbout(javaSources())
+        .that(ImmutableList.of(parent, foo, bar, baz, noConflict))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(componentGeneratedFile);
+  }
+
+  @Test
+  public void subcomponentSimpleNamesDisambiguated() {
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "test.ParentComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface ParentComponent {",
+            "  Sub newSubcomponent();",
+            "}");
+    JavaFileObject sub =
+        JavaFileObjects.forSourceLines(
+            "test.Sub",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent interface Sub {",
+            "  test.deep.many.levels.that.match.test.Sub newDeepSubcomponent();",
+            "}");
+    JavaFileObject deepSub =
+        JavaFileObjects.forSourceLines(
+            "test.deep.many.levels.that.match.test.Sub",
+            "package test.deep.many.levels.that.match.test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent public interface Sub {}");
+
+    JavaFileObject componentGeneratedFile =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerParentComponent",
+            "package test;",
+            "",
+            "import javax.annotation.Generated;",
+            "import test.deep.many.levels.that.match.test.Sub;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerParentComponent implements ParentComponent {",
+            "  private DaggerParentComponent(Builder builder) {",
+            "    assert builder != null;",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static ParentComponent create() {",
+            "    return builder().build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public test.Sub newSubcomponent() {",
+            "    return new test_SubImpl();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {}",
+            "",
+            "    public ParentComponent build() {",
+            "      return new DaggerParentComponent(this);",
+            "    }",
+            "  }",
+            "",
+            "  private final class test_SubImpl implements test.Sub {",
+            "",
+            "    @Override",
+            "    public Sub newDeepSubcomponent() {",
+            "      return new match_test_SubImpl();",
+            "    }",
+            "",
+            "    private final class match_test_SubImpl implements Sub {}",
+            "  }",
+            "}");
+
+    assertAbout(javaSources())
+        .that(ImmutableList.of(parent, sub, deepSub))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(componentGeneratedFile);
+  }
+
+  @Test
+  public void subcomponentImplNameUsesFullyQualifiedClassNameIfNecessary() {
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "test.ParentComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface ParentComponent {",
+            "  top1.a.b.c.d.E.F.Sub top1();",
+            "  top2.a.b.c.d.E.F.Sub top2();",
+            "}");
+    JavaFileObject top1 =
+        JavaFileObjects.forSourceLines(
+            "top1.a.b.c.d.E",
+            "package top1.a.b.c.d;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "public interface E {",
+            "  interface F {",
+            "    @Subcomponent interface Sub {}",
+            "  }",
+            "}");
+    JavaFileObject top2 =
+        JavaFileObjects.forSourceLines(
+            "top2.a.b.c.d.E",
+            "package top2.a.b.c.d;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "public interface E {",
+            "  interface F {",
+            "    @Subcomponent interface Sub {}",
+            "  }",
+            "}");
+
+    JavaFileObject componentGeneratedFile =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerParentComponent",
+            "package test;",
+            "",
+            "import javax.annotation.Generated;",
+            "import top1.a.b.c.d.E.F.Sub;",
+            "import top2.a.b.c.d.E.F;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerParentComponent implements ParentComponent {",
+            "  private DaggerParentComponent(Builder builder) {",
+            "    assert builder != null;",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static ParentComponent create() {",
+            "    return builder().build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Sub top1() {",
+            "    return new top1_a_b_c_d_E_F_SubImpl();",
+            "  }",
+            "",
+            "  @Override",
+            "  public F.Sub top2() {",
+            "    return new top2_a_b_c_d_E_F_SubImpl();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {}",
+            "",
+            "    public ParentComponent build() {",
+            "      return new DaggerParentComponent(this);",
+            "    }",
+            "  }",
+            "",
+            "  private final class top1_a_b_c_d_E_F_SubImpl implements Sub {}",
+            "  private final class top2_a_b_c_d_E_F_SubImpl implements F.Sub {}",
+            "}");
+
+    assertAbout(javaSources())
+        .that(ImmutableList.of(parent, top1, top2))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(componentGeneratedFile);
+  }
+
+  @Test
+  public void parentComponentNameShouldNotBeDisambiguatedWhenItConflictsWithASubcomponent() {
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "test.ParentComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface C {",
+            "  test.Foo.C newFooC();",
+            "}");
+    JavaFileObject subcomponentWithSameSimpleNameAsParent =
+        JavaFileObjects.forSourceLines(
+            "test.Foo",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "interface Foo {",
+            "  @Subcomponent interface C {}",
+            "}");
+
+    JavaFileObject componentGeneratedFile =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerParentComponent",
+            "package test;",
+            "",
+            "import javax.annotation.Generated;",
+            "import test.Foo.C;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerC implements test.C {",
+            "  private DaggerC(Builder builder) {",
+            "    assert builder != null;",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static test.C create() {",
+            "    return builder().build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public C newFooC() {",
+            "    return new Foo_CImpl();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {}",
+            "",
+            "    public test.C build() {",
+            "      return new DaggerC(this);",
+            "    }",
+            "  }",
+            "",
+            "  private final class Foo_CImpl implements C {}",
+            "}");
+
+    assertAbout(javaSources())
+        .that(ImmutableList.of(parent, subcomponentWithSameSimpleNameAsParent))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(componentGeneratedFile);
+  }
 }
diff --git a/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java b/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
index 58fa26307..e4c662fc5 100644
--- a/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
@@ -25,6 +25,7 @@
 
 import static com.google.common.truth.Truth.assert_;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 import static java.util.Arrays.asList;
 
 @RunWith(JUnit4.class)
@@ -74,7 +75,7 @@
       "import javax.annotation.Generated;",
       "import javax.inject.Provider;",
       "",
-      "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+      GENERATED_ANNOTATION,
       "public final class DaggerPrimitiveComponent implements PrimitiveComponent {",
       "  private Provider<Integer> primitiveIntProvider;",
       "  private Provider<PrimitiveInjectable> primitiveInjectableProvider;",
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildComponentWithMultibindings.java b/core/src/main/java/dagger/Multibindings.java
similarity index 71%
rename from compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildComponentWithMultibindings.java
rename to core/src/main/java/dagger/Multibindings.java
index 9ed266aec..d02d4177b 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildComponentWithMultibindings.java
+++ b/core/src/main/java/dagger/Multibindings.java
@@ -13,11 +13,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package test.subcomponent;
+package dagger;
 
-import dagger.Subcomponent;
+import dagger.internal.Beta;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Target;
 
-@Subcomponent(modules = ChildMultibindingModule.class)
-interface ChildComponentWithMultibindings {
-  RequiresMultibindingsInChild requiresMultibindingsInChild();
-}
+import static java.lang.annotation.ElementType.TYPE;
+
+@Documented
+@Target(TYPE)
+@Beta
+public @interface Multibindings {}
diff --git a/core/src/main/java/dagger/internal/DoubleCheckLazy.java b/core/src/main/java/dagger/internal/DoubleCheckLazy.java
index d0f102896..8257c3beb 100644
--- a/core/src/main/java/dagger/internal/DoubleCheckLazy.java
+++ b/core/src/main/java/dagger/internal/DoubleCheckLazy.java
@@ -40,7 +40,6 @@ private DoubleCheckLazy(Provider<T> provider) {
   @SuppressWarnings("unchecked") // cast only happens when result comes from the factory
   @Override
   public T get() {
-    // to suppress it.
     Object result = instance;
     if (result == UNINITIALIZED) {
       synchronized (this) {
diff --git a/core/src/main/java/dagger/internal/MapProviderFactory.java b/core/src/main/java/dagger/internal/MapProviderFactory.java
index 00c0fd33a..b5c96e702 100644
--- a/core/src/main/java/dagger/internal/MapProviderFactory.java
+++ b/core/src/main/java/dagger/internal/MapProviderFactory.java
@@ -15,6 +15,7 @@
  */
 package dagger.internal;
 
+import java.util.Collections;
 import java.util.LinkedHashMap;
 import java.util.Map;
 import javax.inject.Provider;
@@ -31,6 +32,9 @@
  *
  */
 public final class MapProviderFactory<K, V> implements Factory<Map<K, Provider<V>>> {
+  private static final MapProviderFactory<Object, Object> EMPTY =
+      new MapProviderFactory<Object, Object>(Collections.<Object, Provider<Object>>emptyMap());
+
   private final Map<K, Provider<V>> contributingMap;
 
   /**
@@ -40,7 +44,15 @@
     return new Builder<K, V>(size);
   }
 
-  private MapProviderFactory(LinkedHashMap<K, Provider<V>> contributingMap) {
+  /**
+   * Returns a factory of an empty map.
+   */
+  @SuppressWarnings("unchecked") // safe contravariant cast
+  public static <K, V> MapProviderFactory<K, V> empty() {
+    return (MapProviderFactory<K, V>) EMPTY;
+  }
+
+  private MapProviderFactory(Map<K, Provider<V>> contributingMap) {
     this.contributingMap = unmodifiableMap(contributingMap);
   }
 
diff --git a/pom.xml b/pom.xml
index 1d702c6db..18bb74aca 100644
--- a/pom.xml
+++ b/pom.xml
@@ -46,16 +46,16 @@
     <javax.inject.version>1</javax.inject.version>
     <javax.annotation.version>2.0.1</javax.annotation.version>
     <javawriter.version>2.5.0</javawriter.version>
-    <auto.common.version>1.0-SNAPSHOT</auto.common.version>
+    <auto.common.version>0.5</auto.common.version>
     <auto.factory.version>1.0-beta3</auto.factory.version>
     <auto.service.version>1.0-rc2</auto.service.version>
     <auto.value.version>1.0</auto.value.version>
     <guava.version>19.0-rc2</guava.version>
-    <google.java.format.version>0.1-SNAPSHOT</google.java.format.version>
+    <google.java.format.version>0.1-alpha</google.java.format.version>
 
 
     <!-- Test Dependencies -->
-    <compile-testing.version>1.0-SNAPSHOT</compile-testing.version>
+    <compile-testing.version>0.8</compile-testing.version>
     <junit.version>4.11</junit.version>
     <mockito.version>1.9.5</mockito.version>
     <truth.version>0.26</truth.version>
diff --git a/producers/src/main/java/dagger/producers/ProductionComponent.java b/producers/src/main/java/dagger/producers/ProductionComponent.java
index 8ccdb4433..f3f7db027 100644
--- a/producers/src/main/java/dagger/producers/ProductionComponent.java
+++ b/producers/src/main/java/dagger/producers/ProductionComponent.java
@@ -35,7 +35,7 @@
  *
  * <p>Each {@link Produces} method that contributes to the component will be called at most once per
  * component instance, no matter how many times that binding is used as a dependency.
- * TODO(user): Decide on how scope works for producers.
+ * TODO(beder): Decide on how scope works for producers.
  *
  * <h2>Component methods</h2>
  *
@@ -119,3 +119,4 @@
   @Documented
   @interface Builder {}
 }
+
diff --git a/producers/src/main/java/dagger/producers/internal/AbstractProducer.java b/producers/src/main/java/dagger/producers/internal/AbstractProducer.java
index f7e8ec0e5..8c4fe0b40 100644
--- a/producers/src/main/java/dagger/producers/internal/AbstractProducer.java
+++ b/producers/src/main/java/dagger/producers/internal/AbstractProducer.java
@@ -60,6 +60,7 @@ protected AbstractProducer(
         result = instance;
         if (result == null) {
           ProducerMonitor monitor = monitorProvider.get().producerMonitorFor(token);
+          monitor.requested();
           instance = result = compute(monitor);
           if (result == null) {
             throw new NullPointerException("compute returned null");
diff --git a/producers/src/main/java/dagger/producers/internal/Producers.java b/producers/src/main/java/dagger/producers/internal/Producers.java
index 4156e99e0..499de2a50 100644
--- a/producers/src/main/java/dagger/producers/internal/Producers.java
+++ b/producers/src/main/java/dagger/producers/internal/Producers.java
@@ -45,7 +45,7 @@
    * cancelling the input future will trigger the resulting future to succeed with a failing
    * {@code Produced}.
    */
-  // TODO(user): Document what happens with an InterruptedException after you figure out how to
+  // TODO(beder): Document what happens with an InterruptedException after you figure out how to
   // trigger one in a test.
   public static <T> ListenableFuture<Produced<T>> createFutureProduced(ListenableFuture<T> future) {
     return Futures.catchingAsync(
diff --git a/producers/src/main/java/dagger/producers/monitoring/ProducerMonitor.java b/producers/src/main/java/dagger/producers/monitoring/ProducerMonitor.java
index 20551c3db..5d46cf235 100644
--- a/producers/src/main/java/dagger/producers/monitoring/ProducerMonitor.java
+++ b/producers/src/main/java/dagger/producers/monitoring/ProducerMonitor.java
@@ -18,6 +18,7 @@
 import com.google.common.util.concurrent.FutureCallback;
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.Producer;
 import dagger.producers.Produces;
 
 /**
@@ -26,6 +27,7 @@
  *
  * <p>The lifecycle of the monitor, under normal conditions, is:
  * <ul>
+ *   <li>{@link #requested()}
  *   <li>{@link #methodStarting()}
  *   <li>The method is called
  *   <li>{@link #methodFinished()}
@@ -46,6 +48,24 @@
  * immediately with the failed input's exception. If more than one input fails, an arbitrary failed
  * input's exception is used.
  *
+ * <p>For example, given an entry point A that depends on B, which depends on C, when the entry
+ * point A is called, this will trigger the following sequence of events, assuming all methods and
+ * futures complete successfully:
+ * <ul>
+ *   <li>A requested
+ *   <li>B requested
+ *   <li>C requested
+ *   <li>C methodStarting
+ *   <li>C methodFinished
+ *   <li>C succeeded
+ *   <li>B methodStarting
+ *   <li>B methodFinished
+ *   <li>B succeeded
+ *   <li>A methodStarting
+ *   <li>A methodFinished
+ *   <li>A succeeded
+ * </ul>
+ *
  * <p>If any of the monitor's methods throw, then the exception will be logged and processing will
  * continue unaffected.
  *
@@ -53,18 +73,30 @@
  */
 public abstract class ProducerMonitor {
   /**
-   * Called when the producer method is about to start executing.
+   * Called when the producer's output is requested; that is, when the first method is called that
+   * requires the production of this producer's output.
+   *
+   * <p>Note that if a method depends on {@link Producer Producer<T>}, then this does not count as
+   * requesting {@code T}; that is only triggered by calling {@link Producer#get()}.
    *
    * <p>When multiple monitors are installed, the order that each monitor will call this method is
    * unspecified, but will remain consistent throughout the course of the execution of a component.
    */
+  public void requested() {}
+
+  /**
+   * Called when the producer method is about to start executing.
+   *
+   * <p>When multiple monitors are installed, calls to this method will be in the reverse order from
+   * calls to {@link #requested()}.
+   */
   public void methodStarting() {}
 
   /**
    * Called when the producer method has finished executing.
    *
    * <p>When multiple monitors are installed, calls to this method will be in the reverse order from
-   * calls to {@link #methodStarting()}.
+   * calls to {@link #requested()}.
    */
   public void methodFinished() {}
 
@@ -72,7 +104,7 @@ public void methodFinished() {}
    * Called when the producer’s future has completed successfully with a value.
    *
    * <p>When multiple monitors are installed, calls to this method will be in the reverse order from
-   * calls to {@link #methodStarting()}.
+   * calls to {@link #requested()}.
    */
   public void succeeded(Object o) {}
 
@@ -80,7 +112,7 @@ public void succeeded(Object o) {}
    * Called when the producer's future has failed with an exception.
    *
    * <p>When multiple monitors are installed, calls to this method will be in the reverse order from
-   * calls to {@link #methodStarting()}.
+   * calls to {@link #requested()}.
    */
   public void failed(Throwable t) {}
 
diff --git a/producers/src/main/java/dagger/producers/monitoring/ProducerTimingRecorder.java b/producers/src/main/java/dagger/producers/monitoring/ProducerTimingRecorder.java
new file mode 100644
index 000000000..071f32cb8
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/monitoring/ProducerTimingRecorder.java
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.monitoring;
+
+import dagger.producers.Produces;
+import dagger.producers.ProductionComponent;
+
+/**
+ * A hook for recording the timing of the execution of individual
+ * {@linkplain Produces producer methods}. See {@link ProductionComponentTimingRecorder} for how to
+ * install these monitors.
+ *
+ * <p>If any of the recorder's methods throw, then the exception will be logged and processing will
+ * continue unaffected.
+ *
+ * <p>All timings are measured at nanosecond precision, but not necessarily nanosecond resolution.
+ * That is, timings will be reported in nanoseconds, but the timing source will not necessarily
+ * update at nanosecond resolution. For example, {@link System#nanoTime()) would satisfy these
+ * constraints.
+ *
+ * @author Jesse Beder
+ */
+public abstract class ProducerTimingRecorder {
+  /**
+   * Reports that the producer method has finished executing with the given statistics.
+   *
+   * <p>If the producer was skipped due to any of its inputs failing, then this will not be called.
+   *
+   * @param startedNanos the wall-clock time, in nanoseconds, when the producer method started
+   *     executing, measured from when the first method on the
+   *     {@linkplain ProductionComponent production component} was called.
+   * @param durationNanos the wall-clock time, in nanoseconds, that the producer method took to
+   *     execute.
+   */
+  public void recordMethod(long startedNanos, long durationNanos) {}
+
+  /**
+   * Reports that the producer's future has succeeded with the given statistics.
+   *
+   * <p>If the producer was skipped due to any of its inputs failing, then this will not be called.
+   *
+   * @param latencyNanos the wall-clock time, in nanoseconds, of the producer's latency, measured
+   *     from when the producer method started to when the future finished.
+   */
+  public void recordSuccess(long latencyNanos) {}
+
+  /**
+   * Reports that the producer's future has failed with the given statistics.
+   *
+   * @param exception the exception that the future failed with.
+   * @param latencyNanos the wall-clock time, in nanoseconds, of the producer's latency, measured
+   *     from when the producer method started to when the future finished.
+   */
+  public void recordFailure(Throwable exception, long latencyNanos) {}
+
+  /**
+   * Reports that the producer was skipped because one of its inputs failed.
+   *
+   * @param exception the exception that its input failed with. If multiple inputs failed, this
+   *    exception will be chosen arbitrarily from the input failures.
+   */
+  public void recordSkip(Throwable exception) {}
+
+  /** Returns a producer recorder that does nothing. */
+  public static ProducerTimingRecorder noOp() {
+    return NO_OP;
+  }
+
+  private static final ProducerTimingRecorder NO_OP = new ProducerTimingRecorder() {};
+}
diff --git a/producers/src/main/java/dagger/producers/monitoring/ProductionComponentTimingRecorder.java b/producers/src/main/java/dagger/producers/monitoring/ProductionComponentTimingRecorder.java
new file mode 100644
index 000000000..debe06d9a
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/monitoring/ProductionComponentTimingRecorder.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.monitoring;
+
+import dagger.producers.Produces;
+import dagger.producers.ProductionComponent;
+
+/**
+ * A hook for recording timing of the execution of
+ * {@linkplain ProductionComponent production components}. To install a
+ * {@code ProductionComponentTimingRecorder}, contribute to a set binding of
+ * {@code ProductionComponentTimingRecorder.Factory}, and include the {@code TimingMonitorModule} to
+ * the component. The factory will be asked to create one timing recorder for the component, and the
+ * resulting instance will be used to create individual timing recorders for producers.
+ *
+ * <p>If any of these methods throw, then the exception will be logged, and the framework will act
+ * as though a no-op timing recorder was returned.
+ *
+ * @author Jesse Beder
+ */
+public interface ProductionComponentTimingRecorder {
+  /** Returns a timing recorder for an individual {@linkplain Produces producer method}. */
+  ProducerTimingRecorder producerTimingRecorderFor(ProducerToken token);
+
+  public interface Factory {
+    /** Creates a component-specific timing recorder when the component is created. */
+    ProductionComponentTimingRecorder create(Object component);
+  }
+}
diff --git a/producers/src/main/java/dagger/producers/monitoring/TimingProducerMonitor.java b/producers/src/main/java/dagger/producers/monitoring/TimingProducerMonitor.java
new file mode 100644
index 000000000..a4bfa17c1
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/monitoring/TimingProducerMonitor.java
@@ -0,0 +1,69 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.monitoring;
+
+import com.google.common.base.Stopwatch;
+import com.google.common.base.Ticker;
+
+import static java.util.concurrent.TimeUnit.NANOSECONDS;
+
+/**
+ * A monitor that measures the timing of the execution of a producer method, and logs those timings
+ * with the given recorder.
+ */
+final class TimingProducerMonitor extends ProducerMonitor {
+  private final ProducerTimingRecorder recorder;
+  private final Stopwatch stopwatch;
+  private final Stopwatch componentStopwatch;
+  private long startNanos = -1;
+
+  TimingProducerMonitor(
+      ProducerTimingRecorder recorder, Ticker ticker, Stopwatch componentStopwatch) {
+    this.recorder = recorder;
+    this.stopwatch = Stopwatch.createUnstarted(ticker);
+    this.componentStopwatch = componentStopwatch;
+  }
+
+  @Override
+  public void methodStarting() {
+    startNanos = componentStopwatch.elapsed(NANOSECONDS);
+    stopwatch.start();
+  }
+
+  @Override
+  public void methodFinished() {
+    // TODO(beder): Is a system ticker the appropriate way to track CPU time? Should we use
+    // ThreadCpuTicker instead?
+    long durationNanos = stopwatch.elapsed(NANOSECONDS);
+    recorder.recordMethod(startNanos, durationNanos);
+  }
+
+  @Override
+  public void succeeded(Object o) {
+    long latencyNanos = stopwatch.elapsed(NANOSECONDS);
+    recorder.recordSuccess(latencyNanos);
+  }
+
+  @Override
+  public void failed(Throwable t) {
+    if (stopwatch.isRunning()) {
+      long latencyNanos = stopwatch.elapsed(NANOSECONDS);
+      recorder.recordFailure(t, latencyNanos);
+    } else {
+      recorder.recordSkip(t);
+    }
+  }
+}
diff --git a/producers/src/main/java/dagger/producers/monitoring/TimingProductionComponentMonitor.java b/producers/src/main/java/dagger/producers/monitoring/TimingProductionComponentMonitor.java
new file mode 100644
index 000000000..e6ae829a3
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/monitoring/TimingProductionComponentMonitor.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.monitoring;
+
+import com.google.common.base.Stopwatch;
+import com.google.common.base.Ticker;
+
+/**
+ * A monitor that measures the timing of the execution of a production component, and logs those
+ * timings with the given recorder.
+ *
+ * <p>This assumes that the given recorders do not throw or return null; for example, by using
+ * {@link TimingRecorders#delegatingProductionComponentTimingRecorderFactory}.
+ */
+final class TimingProductionComponentMonitor implements ProductionComponentMonitor {
+  private final ProductionComponentTimingRecorder recorder;
+  private final Ticker ticker;
+  private final Stopwatch stopwatch;
+
+  TimingProductionComponentMonitor(ProductionComponentTimingRecorder recorder, Ticker ticker) {
+    this.recorder = recorder;
+    this.ticker = ticker;
+    this.stopwatch = Stopwatch.createStarted(ticker);
+  }
+
+  @Override
+  public ProducerMonitor producerMonitorFor(ProducerToken token) {
+    return new TimingProducerMonitor(recorder.producerTimingRecorderFor(token), ticker, stopwatch);
+  }
+
+  static final class Factory implements ProductionComponentMonitor.Factory {
+    private final ProductionComponentTimingRecorder.Factory recorderFactory;
+    private final Ticker ticker;
+
+    Factory(ProductionComponentTimingRecorder.Factory recorderFactory) {
+      this(recorderFactory, Ticker.systemTicker());
+    }
+
+    Factory(ProductionComponentTimingRecorder.Factory recorderFactory, Ticker ticker) {
+      this.recorderFactory = recorderFactory;
+      this.ticker = ticker;
+    }
+
+    @Override
+    public ProductionComponentMonitor create(Object component) {
+      return new TimingProductionComponentMonitor(recorderFactory.create(component), ticker);
+    }
+  }
+}
diff --git a/producers/src/main/java/dagger/producers/monitoring/TimingRecorders.java b/producers/src/main/java/dagger/producers/monitoring/TimingRecorders.java
new file mode 100644
index 000000000..842a55a36
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/monitoring/TimingRecorders.java
@@ -0,0 +1,343 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.monitoring;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.Iterables;
+import java.util.Collection;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+/**
+ * Utility methods relating to timing.
+ *
+ * @author Jesse Beder
+ */
+final class TimingRecorders {
+  private static final Logger logger = Logger.getLogger(TimingRecorders.class.getName());
+
+  /**
+   * Returns a timing recorder factory that delegates to the given factories, and ensures that any
+   * method called on this object, even transitively, does not throw a {@link RuntimeException} or
+   * return null.
+   *
+   * <p>If the delegate recorders throw an {@link Error}, then that will escape this recorder
+   * implementation. Errors are treated as unrecoverable conditions, and may cause the entire
+   * component's execution to fail.
+   */
+  static ProductionComponentTimingRecorder.Factory
+      delegatingProductionComponentTimingRecorderFactory(
+          Collection<ProductionComponentTimingRecorder.Factory> factories) {
+    switch (factories.size()) {
+      case 0:
+        return noOpProductionComponentTimingRecorderFactory();
+      case 1:
+        return new NonThrowingProductionComponentTimingRecorder.Factory(
+            Iterables.getOnlyElement(factories));
+      default:
+        return new DelegatingProductionComponentTimingRecorder.Factory(factories);
+    }
+  }
+
+  /**
+   * A component recorder that delegates to a single recorder, and catches and logs all exceptions
+   * that the delegate throws.
+   */
+  private static final class NonThrowingProductionComponentTimingRecorder
+      implements ProductionComponentTimingRecorder {
+    private final ProductionComponentTimingRecorder delegate;
+
+    NonThrowingProductionComponentTimingRecorder(ProductionComponentTimingRecorder delegate) {
+      this.delegate = delegate;
+    }
+
+    @Override
+    public ProducerTimingRecorder producerTimingRecorderFor(ProducerToken token) {
+      try {
+        ProducerTimingRecorder recorder = delegate.producerTimingRecorderFor(token);
+        return recorder == null
+            ? ProducerTimingRecorder.noOp()
+            : new NonThrowingProducerTimingRecorder(recorder);
+      } catch (RuntimeException e) {
+        logProducerTimingRecorderForException(e, delegate, token);
+        return ProducerTimingRecorder.noOp();
+      }
+    }
+
+    static final class Factory implements ProductionComponentTimingRecorder.Factory {
+      private final ProductionComponentTimingRecorder.Factory delegate;
+
+      Factory(ProductionComponentTimingRecorder.Factory delegate) {
+        this.delegate = delegate;
+      }
+
+      @Override
+      public ProductionComponentTimingRecorder create(Object component) {
+        try {
+          ProductionComponentTimingRecorder recorder = delegate.create(component);
+          return recorder == null
+              ? noOpProductionComponentTimingRecorder()
+              : new NonThrowingProductionComponentTimingRecorder(recorder);
+        } catch (RuntimeException e) {
+          logCreateException(e, delegate, component);
+          return noOpProductionComponentTimingRecorder();
+        }
+      }
+    }
+  }
+
+  /**
+   * A producer recorder that delegates to a single recorder, and catches and logs all exceptions
+   * that the delegate throws.
+   */
+  private static final class NonThrowingProducerTimingRecorder extends ProducerTimingRecorder {
+    private final ProducerTimingRecorder delegate;
+
+    NonThrowingProducerTimingRecorder(ProducerTimingRecorder delegate) {
+      this.delegate = delegate;
+    }
+
+    @Override
+    public void recordMethod(long startedNanos, long durationNanos) {
+      try {
+        delegate.recordMethod(startedNanos, durationNanos);
+      } catch (RuntimeException e) {
+        logProducerTimingRecorderMethodException(e, delegate, "recordMethod");
+      }
+    }
+
+    @Override
+    public void recordSuccess(long latencyNanos) {
+      try {
+        delegate.recordSuccess(latencyNanos);
+      } catch (RuntimeException e) {
+        logProducerTimingRecorderMethodException(e, delegate, "recordSuccess");
+      }
+    }
+
+    @Override
+    public void recordFailure(Throwable exception, long latencyNanos) {
+      try {
+        delegate.recordFailure(exception, latencyNanos);
+      } catch (RuntimeException e) {
+        logProducerTimingRecorderMethodException(e, delegate, "recordFailure");
+      }
+    }
+
+    @Override
+    public void recordSkip(Throwable exception) {
+      try {
+        delegate.recordSkip(exception);
+      } catch (RuntimeException e) {
+        logProducerTimingRecorderMethodException(e, delegate, "recordSkip");
+      }
+    }
+  }
+
+  /**
+   * A component recorder that delegates to several recorders, and catches and logs all exceptions
+   * that the delegates throw.
+   */
+  private static final class DelegatingProductionComponentTimingRecorder
+      implements ProductionComponentTimingRecorder {
+    private final ImmutableList<ProductionComponentTimingRecorder> delegates;
+
+    DelegatingProductionComponentTimingRecorder(
+        ImmutableList<ProductionComponentTimingRecorder> delegates) {
+      this.delegates = delegates;
+    }
+
+    @Override
+    public ProducerTimingRecorder producerTimingRecorderFor(ProducerToken token) {
+      ImmutableList.Builder<ProducerTimingRecorder> recordersBuilder = ImmutableList.builder();
+      for (ProductionComponentTimingRecorder delegate : delegates) {
+        try {
+          ProducerTimingRecorder recorder = delegate.producerTimingRecorderFor(token);
+          if (recorder != null) {
+            recordersBuilder.add(recorder);
+          }
+        } catch (RuntimeException e) {
+          logProducerTimingRecorderForException(e, delegate, token);
+        }
+      }
+      ImmutableList<ProducerTimingRecorder> recorders = recordersBuilder.build();
+      switch (recorders.size()) {
+        case 0:
+          return ProducerTimingRecorder.noOp();
+        case 1:
+          return new NonThrowingProducerTimingRecorder(Iterables.getOnlyElement(recorders));
+        default:
+          return new DelegatingProducerTimingRecorder(recorders);
+      }
+    }
+
+    static final class Factory implements ProductionComponentTimingRecorder.Factory {
+      private final ImmutableList<? extends ProductionComponentTimingRecorder.Factory> delegates;
+
+      Factory(Iterable<? extends ProductionComponentTimingRecorder.Factory> delegates) {
+        this.delegates = ImmutableList.copyOf(delegates);
+      }
+
+      @Override
+      public ProductionComponentTimingRecorder create(Object component) {
+        ImmutableList.Builder<ProductionComponentTimingRecorder> recordersBuilder =
+            ImmutableList.builder();
+        for (ProductionComponentTimingRecorder.Factory delegate : delegates) {
+          try {
+            ProductionComponentTimingRecorder recorder = delegate.create(component);
+            if (recorder != null) {
+              recordersBuilder.add(recorder);
+            }
+          } catch (RuntimeException e) {
+            logCreateException(e, delegate, component);
+          }
+        }
+        ImmutableList<ProductionComponentTimingRecorder> recorders = recordersBuilder.build();
+        switch (recorders.size()) {
+          case 0:
+            return noOpProductionComponentTimingRecorder();
+          case 1:
+            return new NonThrowingProductionComponentTimingRecorder(
+                Iterables.getOnlyElement(recorders));
+          default:
+            return new DelegatingProductionComponentTimingRecorder(recorders);
+        }
+      }
+    }
+  }
+
+  /**
+   * A producer recorder that delegates to several recorders, and catches and logs all exceptions
+   * that the delegates throw.
+   */
+  private static final class DelegatingProducerTimingRecorder extends ProducerTimingRecorder {
+    private final ImmutableList<ProducerTimingRecorder> delegates;
+
+    DelegatingProducerTimingRecorder(ImmutableList<ProducerTimingRecorder> delegates) {
+      this.delegates = delegates;
+    }
+
+    @Override
+    public void recordMethod(long startedNanos, long durationNanos) {
+      for (ProducerTimingRecorder delegate : delegates) {
+        try {
+          delegate.recordMethod(startedNanos, durationNanos);
+        } catch (RuntimeException e) {
+          logProducerTimingRecorderMethodException(e, delegate, "recordMethod");
+        }
+      }
+    }
+
+    @Override
+    public void recordSuccess(long latencyNanos) {
+      for (ProducerTimingRecorder delegate : delegates) {
+        try {
+          delegate.recordSuccess(latencyNanos);
+        } catch (RuntimeException e) {
+          logProducerTimingRecorderMethodException(e, delegate, "recordSuccess");
+        }
+      }
+    }
+
+    @Override
+    public void recordFailure(Throwable exception, long latencyNanos) {
+      for (ProducerTimingRecorder delegate : delegates) {
+        try {
+          delegate.recordFailure(exception, latencyNanos);
+        } catch (RuntimeException e) {
+          logProducerTimingRecorderMethodException(e, delegate, "recordFailure");
+        }
+      }
+    }
+
+    @Override
+    public void recordSkip(Throwable exception) {
+      for (ProducerTimingRecorder delegate : delegates) {
+        try {
+          delegate.recordSkip(exception);
+        } catch (RuntimeException e) {
+          logProducerTimingRecorderMethodException(e, delegate, "recordSkip");
+        }
+      }
+    }
+  }
+
+  /** Returns a recorder factory that returns no-op component recorders. */
+  public static ProductionComponentTimingRecorder.Factory
+      noOpProductionComponentTimingRecorderFactory() {
+    return NO_OP_PRODUCTION_COMPONENT_TIMING_RECORDER_FACTORY;
+  }
+
+  /** Returns a component recorder that returns no-op producer recorders. */
+  public static ProductionComponentTimingRecorder noOpProductionComponentTimingRecorder() {
+    return NO_OP_PRODUCTION_COMPONENT_TIMING_RECORDER;
+  }
+
+  private static final ProductionComponentTimingRecorder.Factory
+      NO_OP_PRODUCTION_COMPONENT_TIMING_RECORDER_FACTORY =
+          new ProductionComponentTimingRecorder.Factory() {
+            @Override
+            public ProductionComponentTimingRecorder create(Object component) {
+              return noOpProductionComponentTimingRecorder();
+            }
+          };
+
+  private static final ProductionComponentTimingRecorder
+      NO_OP_PRODUCTION_COMPONENT_TIMING_RECORDER =
+          new ProductionComponentTimingRecorder() {
+            @Override
+            public ProducerTimingRecorder producerTimingRecorderFor(ProducerToken token) {
+              return ProducerTimingRecorder.noOp();
+            }
+          };
+
+  private static void logCreateException(
+      RuntimeException e, ProductionComponentTimingRecorder.Factory factory, Object component) {
+    logger.log(
+        Level.SEVERE,
+        "RuntimeException while calling ProductionComponentTimingRecorder.Factory.create on"
+            + " factory "
+            + factory
+            + " with component "
+            + component,
+        e);
+  }
+
+  private static void logProducerTimingRecorderForException(
+      RuntimeException e, ProductionComponentTimingRecorder recorder, ProducerToken token) {
+    logger.log(
+        Level.SEVERE,
+        "RuntimeException while calling ProductionComponentTimingRecorder.producerTimingRecorderFor"
+            + "on recorder "
+            + recorder
+            + " with token "
+            + token,
+        e);
+  }
+
+  private static void logProducerTimingRecorderMethodException(
+      RuntimeException e, ProducerTimingRecorder recorder, String method) {
+    logger.log(
+        Level.SEVERE,
+        "RuntimeException while calling ProducerTimingRecorder."
+            + method
+            + " on recorder "
+            + recorder,
+        e);
+  }
+
+  private TimingRecorders() {}
+}
diff --git a/producers/src/main/java/dagger/producers/monitoring/internal/Monitors.java b/producers/src/main/java/dagger/producers/monitoring/internal/Monitors.java
index f27ce37b1..d0ff778f0 100644
--- a/producers/src/main/java/dagger/producers/monitoring/internal/Monitors.java
+++ b/producers/src/main/java/dagger/producers/monitoring/internal/Monitors.java
@@ -110,6 +110,15 @@ public ProductionComponentMonitor create(Object component) {
       this.delegate = delegate;
     }
 
+    @Override
+    public void requested() {
+      try {
+        delegate.requested();
+      } catch (RuntimeException e) {
+        logProducerMonitorMethodException(e, delegate, "requested");
+      }
+    }
+
     @Override
     public void methodStarting() {
       try {
@@ -225,6 +234,17 @@ public ProductionComponentMonitor create(Object component) {
       this.delegates = delegates;
     }
 
+    @Override
+    public void requested() {
+      for (ProducerMonitor delegate : delegates) {
+        try {
+          delegate.requested();
+        } catch (RuntimeException e) {
+          logProducerMonitorMethodException(e, delegate, "requested");
+        }
+      }
+    }
+
     @Override
     public void methodStarting() {
       for (ProducerMonitor delegate : delegates) {
diff --git a/producers/src/test/java/dagger/producers/internal/AbstractProducerTest.java b/producers/src/test/java/dagger/producers/internal/AbstractProducerTest.java
index 923ea70a1..6cb6bdbcc 100644
--- a/producers/src/test/java/dagger/producers/internal/AbstractProducerTest.java
+++ b/producers/src/test/java/dagger/producers/internal/AbstractProducerTest.java
@@ -94,6 +94,7 @@ public void monitor_success() throws Exception {
 
     ListenableFuture<Integer> future = producer.get();
     assertThat(future.isDone()).isFalse();
+    verify(monitor).requested();
     verify(monitor).addCallbackTo(any(ListenableFuture.class));
     delegateFuture.set(-42);
     assertThat(future.get()).isEqualTo(-42);
@@ -108,6 +109,7 @@ public void monitor_failure() throws Exception {
 
     ListenableFuture<Integer> future = producer.get();
     assertThat(future.isDone()).isFalse();
+    verify(monitor).requested();
     verify(monitor).addCallbackTo(any(ListenableFuture.class));
     Throwable t = new RuntimeException("monkey");
     delegateFuture.setException(t);
diff --git a/producers/src/test/java/dagger/producers/monitoring/TimingProductionComponentMonitorTest.java b/producers/src/test/java/dagger/producers/monitoring/TimingProductionComponentMonitorTest.java
new file mode 100644
index 000000000..bceecf1aa
--- /dev/null
+++ b/producers/src/test/java/dagger/producers/monitoring/TimingProductionComponentMonitorTest.java
@@ -0,0 +1,119 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.monitoring;
+
+import com.google.common.testing.FakeTicker;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.when;
+
+@RunWith(JUnit4.class)
+public final class TimingProductionComponentMonitorTest {
+  private static final class ProducerClassA {}
+
+  private static final class ProducerClassB {}
+
+  @Mock private ProductionComponentTimingRecorder.Factory productionComponentTimingRecorderFactory;
+  @Mock private ProductionComponentTimingRecorder productionComponentTimingRecorder;
+  @Mock private ProducerTimingRecorder producerTimingRecorderA;
+  @Mock private ProducerTimingRecorder producerTimingRecorderB;
+
+  private FakeTicker ticker;
+  private ProductionComponentMonitor.Factory monitorFactory;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    when(productionComponentTimingRecorderFactory.create(any(Object.class)))
+        .thenReturn(productionComponentTimingRecorder);
+    when(
+            productionComponentTimingRecorder.producerTimingRecorderFor(
+                ProducerToken.create(ProducerClassA.class)))
+        .thenReturn(producerTimingRecorderA);
+    when(
+            productionComponentTimingRecorder.producerTimingRecorderFor(
+                ProducerToken.create(ProducerClassB.class)))
+        .thenReturn(producerTimingRecorderB);
+    ticker = new FakeTicker();
+    monitorFactory =
+        new TimingProductionComponentMonitor.Factory(
+            productionComponentTimingRecorderFactory, ticker);
+  }
+
+  @Test
+  public void normalExecution_success() {
+    ProductionComponentMonitor monitor = monitorFactory.create(new Object());
+    ProducerMonitor producerMonitorA =
+        monitor.producerMonitorFor(ProducerToken.create(ProducerClassA.class));
+    ticker.advance(5000222);
+    producerMonitorA.methodStarting();
+    ticker.advance(1333);
+    producerMonitorA.methodFinished();
+    ticker.advance(40000555);
+    ProducerMonitor producerMonitorB =
+        monitor.producerMonitorFor(ProducerToken.create(ProducerClassB.class));
+    producerMonitorB.methodStarting();
+    ticker.advance(2000777);
+    producerMonitorA.succeeded(new Object());
+    ticker.advance(3000999);
+    producerMonitorB.methodFinished();
+    ticker.advance(100000222);
+    producerMonitorB.succeeded(new Object());
+
+    verify(producerTimingRecorderA).recordMethod(5000222, 1333);
+    verify(producerTimingRecorderA).recordSuccess(1333 + 40000555 + 2000777);
+    verify(producerTimingRecorderB).recordMethod(5000222 + 1333 + 40000555, 2000777 + 3000999);
+    verify(producerTimingRecorderB).recordSuccess(2000777 + 3000999 + 100000222);
+    verifyNoMoreInteractions(producerTimingRecorderA, producerTimingRecorderB);
+  }
+
+  @Test
+  public void normalExecution_failure() {
+    Throwable failureA = new RuntimeException("monkey");
+    Throwable failureB = new RuntimeException("gorilla");
+    ProductionComponentMonitor monitor = monitorFactory.create(new Object());
+    ProducerMonitor producerMonitorA =
+        monitor.producerMonitorFor(ProducerToken.create(ProducerClassA.class));
+    ticker.advance(5000222);
+    producerMonitorA.methodStarting();
+    ticker.advance(1333);
+    producerMonitorA.methodFinished();
+    ticker.advance(40000555);
+    ProducerMonitor producerMonitorB =
+        monitor.producerMonitorFor(ProducerToken.create(ProducerClassB.class));
+    producerMonitorB.methodStarting();
+    ticker.advance(2000777);
+    producerMonitorA.failed(failureA);
+    ticker.advance(3000999);
+    producerMonitorB.methodFinished();
+    ticker.advance(100000222);
+    producerMonitorB.failed(failureB);
+
+    verify(producerTimingRecorderA).recordMethod(5000222, 1333);
+    verify(producerTimingRecorderA).recordFailure(failureA, 1333 + 40000555 + 2000777);
+    verify(producerTimingRecorderB).recordMethod(5000222 + 1333 + 40000555, 2000777 + 3000999);
+    verify(producerTimingRecorderB).recordFailure(failureB, 2000777 + 3000999 + 100000222);
+    verifyNoMoreInteractions(producerTimingRecorderA, producerTimingRecorderB);
+  }
+}
diff --git a/producers/src/test/java/dagger/producers/monitoring/TimingRecordersTest.java b/producers/src/test/java/dagger/producers/monitoring/TimingRecordersTest.java
new file mode 100644
index 000000000..cf54d9670
--- /dev/null
+++ b/producers/src/test/java/dagger/producers/monitoring/TimingRecordersTest.java
@@ -0,0 +1,358 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.monitoring;
+
+import com.google.common.collect.ImmutableList;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.InOrder;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.doThrow;
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.when;
+
+@RunWith(JUnit4.class)
+public final class TimingRecordersTest {
+  @Mock
+  private ProductionComponentTimingRecorder.Factory mockProductionComponentTimingRecorderFactory;
+
+  @Mock private ProductionComponentTimingRecorder mockProductionComponentTimingRecorder;
+  @Mock private ProducerTimingRecorder mockProducerTimingRecorder;
+
+  @Mock
+  private ProductionComponentTimingRecorder.Factory mockProductionComponentTimingRecorderFactoryA;
+
+  @Mock
+  private ProductionComponentTimingRecorder.Factory mockProductionComponentTimingRecorderFactoryB;
+
+  @Mock
+  private ProductionComponentTimingRecorder.Factory mockProductionComponentTimingRecorderFactoryC;
+
+  @Mock private ProductionComponentTimingRecorder mockProductionComponentTimingRecorderA;
+  @Mock private ProductionComponentTimingRecorder mockProductionComponentTimingRecorderB;
+  @Mock private ProductionComponentTimingRecorder mockProductionComponentTimingRecorderC;
+  @Mock private ProducerTimingRecorder mockProducerTimingRecorderA;
+  @Mock private ProducerTimingRecorder mockProducerTimingRecorderB;
+  @Mock private ProducerTimingRecorder mockProducerTimingRecorderC;
+
+  @Before
+  public void initMocks() {
+    MockitoAnnotations.initMocks(this);
+  }
+
+  @Test
+  public void zeroRecordersReturnsNoOp() {
+    ProductionComponentTimingRecorder.Factory factory =
+        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
+            ImmutableList.<ProductionComponentTimingRecorder.Factory>of());
+    assertThat(factory).isSameAs(TimingRecorders.noOpProductionComponentTimingRecorderFactory());
+  }
+
+  @Test
+  public void singleRecorder_nullProductionComponentTimingRecorder() {
+    when(mockProductionComponentTimingRecorderFactory.create(any(Object.class))).thenReturn(null);
+    ProductionComponentTimingRecorder.Factory factory =
+        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
+            ImmutableList.of(mockProductionComponentTimingRecorderFactory));
+    assertThat(factory.create(new Object()))
+        .isSameAs(TimingRecorders.noOpProductionComponentTimingRecorder());
+  }
+
+  @Test
+  public void singleRecorder_throwingProductionComponentTimingRecorderFactory() {
+    when(mockProductionComponentTimingRecorderFactory.create(any(Object.class)))
+        .thenThrow(new RuntimeException("monkey"));
+    ProductionComponentTimingRecorder.Factory factory =
+        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
+            ImmutableList.of(mockProductionComponentTimingRecorderFactory));
+    assertThat(factory.create(new Object()))
+        .isSameAs(TimingRecorders.noOpProductionComponentTimingRecorder());
+  }
+
+  @Test
+  public void singleRecorder_nullProducerTimingRecorder() {
+    when(mockProductionComponentTimingRecorderFactory.create(any(Object.class)))
+        .thenReturn(mockProductionComponentTimingRecorder);
+    when(mockProductionComponentTimingRecorder.producerTimingRecorderFor(any(ProducerToken.class)))
+        .thenReturn(null);
+    ProductionComponentTimingRecorder.Factory factory =
+        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
+            ImmutableList.of(mockProductionComponentTimingRecorderFactory));
+    ProductionComponentTimingRecorder recorder = factory.create(new Object());
+    assertThat(recorder.producerTimingRecorderFor(ProducerToken.create(Object.class)))
+        .isSameAs(ProducerTimingRecorder.noOp());
+  }
+
+  @Test
+  public void singleRecorder_throwingProductionComponentTimingRecorder() {
+    when(mockProductionComponentTimingRecorderFactory.create(any(Object.class)))
+        .thenReturn(mockProductionComponentTimingRecorder);
+    when(mockProductionComponentTimingRecorder.producerTimingRecorderFor(any(ProducerToken.class)))
+        .thenThrow(new RuntimeException("monkey"));
+    ProductionComponentTimingRecorder.Factory factory =
+        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
+            ImmutableList.of(mockProductionComponentTimingRecorderFactory));
+    ProductionComponentTimingRecorder recorder = factory.create(new Object());
+    assertThat(recorder.producerTimingRecorderFor(ProducerToken.create(Object.class)))
+        .isSameAs(ProducerTimingRecorder.noOp());
+  }
+
+  @Test
+  public void singleRecorder_normalProducerTimingRecorderSuccess() {
+    setUpNormalSingleRecorder();
+    ProductionComponentTimingRecorder.Factory factory =
+        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
+            ImmutableList.of(mockProductionComponentTimingRecorderFactory));
+    ProductionComponentTimingRecorder recorder = factory.create(new Object());
+    ProducerTimingRecorder producerTimingRecorder =
+        recorder.producerTimingRecorderFor(ProducerToken.create(Object.class));
+    producerTimingRecorder.recordMethod(15, 42);
+    producerTimingRecorder.recordSuccess(100);
+
+    InOrder order = inOrder(mockProducerTimingRecorder);
+    order.verify(mockProducerTimingRecorder).recordMethod(15, 42);
+    order.verify(mockProducerTimingRecorder).recordSuccess(100);
+    verifyNoMoreInteractions(mockProducerTimingRecorder);
+  }
+
+  @Test
+  public void singleRecorder_normalProducerTimingRecorderFailure() {
+    setUpNormalSingleRecorder();
+    ProductionComponentTimingRecorder.Factory factory =
+        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
+            ImmutableList.of(mockProductionComponentTimingRecorderFactory));
+    ProductionComponentTimingRecorder recorder = factory.create(new Object());
+    ProducerTimingRecorder producerTimingRecorder =
+        recorder.producerTimingRecorderFor(ProducerToken.create(Object.class));
+    Throwable t = new RuntimeException("monkey");
+    producerTimingRecorder.recordMethod(15, 42);
+    producerTimingRecorder.recordFailure(t, 100);
+
+    InOrder order = inOrder(mockProducerTimingRecorder);
+    order.verify(mockProducerTimingRecorder).recordMethod(15, 42);
+    order.verify(mockProducerTimingRecorder).recordFailure(t, 100);
+    verifyNoMoreInteractions(mockProducerTimingRecorder);
+  }
+
+  @Test
+  public void singleRecorder_throwingProducerTimingRecorderSuccess() {
+    setUpNormalSingleRecorder();
+    doThrow(new RuntimeException("monkey"))
+        .when(mockProducerTimingRecorder)
+        .recordMethod(any(Long.class), any(Long.class));
+    doThrow(new RuntimeException("monkey"))
+        .when(mockProducerTimingRecorder)
+        .recordSuccess(any(Long.class));
+    ProductionComponentTimingRecorder.Factory factory =
+        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
+            ImmutableList.of(mockProductionComponentTimingRecorderFactory));
+    ProductionComponentTimingRecorder recorder = factory.create(new Object());
+    ProducerTimingRecorder producerTimingRecorder =
+        recorder.producerTimingRecorderFor(ProducerToken.create(Object.class));
+    producerTimingRecorder.recordMethod(15, 42);
+    producerTimingRecorder.recordSuccess(100);
+
+    InOrder order = inOrder(mockProducerTimingRecorder);
+    order.verify(mockProducerTimingRecorder).recordMethod(15, 42);
+    order.verify(mockProducerTimingRecorder).recordSuccess(100);
+    verifyNoMoreInteractions(mockProducerTimingRecorder);
+  }
+
+  @Test
+  public void multipleRecorders_nullProductionComponentTimingRecorders() {
+    when(mockProductionComponentTimingRecorderFactoryA.create(any(Object.class))).thenReturn(null);
+    when(mockProductionComponentTimingRecorderFactoryB.create(any(Object.class))).thenReturn(null);
+    when(mockProductionComponentTimingRecorderFactoryC.create(any(Object.class))).thenReturn(null);
+    ProductionComponentTimingRecorder.Factory factory =
+        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
+            ImmutableList.of(
+                mockProductionComponentTimingRecorderFactoryA,
+                mockProductionComponentTimingRecorderFactoryB,
+                mockProductionComponentTimingRecorderFactoryC));
+    assertThat(factory.create(new Object()))
+        .isSameAs(TimingRecorders.noOpProductionComponentTimingRecorder());
+  }
+
+  @Test
+  public void multipleRecorders_throwingProductionComponentTimingRecorderFactories() {
+    when(mockProductionComponentTimingRecorderFactoryA.create(any(Object.class)))
+        .thenThrow(new RuntimeException("monkey"));
+    when(mockProductionComponentTimingRecorderFactoryB.create(any(Object.class)))
+        .thenThrow(new RuntimeException("monkey"));
+    when(mockProductionComponentTimingRecorderFactoryC.create(any(Object.class)))
+        .thenThrow(new RuntimeException("monkey"));
+    ProductionComponentTimingRecorder.Factory factory =
+        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
+            ImmutableList.of(
+                mockProductionComponentTimingRecorderFactoryA,
+                mockProductionComponentTimingRecorderFactoryB,
+                mockProductionComponentTimingRecorderFactoryC));
+    assertThat(factory.create(new Object()))
+        .isSameAs(TimingRecorders.noOpProductionComponentTimingRecorder());
+  }
+
+  @Test
+  public void multipleRecorders_someNullProductionComponentTimingRecorders() {
+    when(mockProductionComponentTimingRecorderFactoryA.create(any(Object.class)))
+        .thenReturn(mockProductionComponentTimingRecorderA);
+    when(mockProductionComponentTimingRecorderFactoryB.create(any(Object.class))).thenReturn(null);
+    when(mockProductionComponentTimingRecorderFactoryC.create(any(Object.class))).thenReturn(null);
+    when(mockProductionComponentTimingRecorderA.producerTimingRecorderFor(any(ProducerToken.class)))
+        .thenReturn(mockProducerTimingRecorderA);
+    ProductionComponentTimingRecorder.Factory factory =
+        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
+            ImmutableList.of(
+                mockProductionComponentTimingRecorderFactoryA,
+                mockProductionComponentTimingRecorderFactoryB,
+                mockProductionComponentTimingRecorderFactoryC));
+    ProductionComponentTimingRecorder recorder = factory.create(new Object());
+    ProducerTimingRecorder producerTimingRecorder =
+        recorder.producerTimingRecorderFor(ProducerToken.create(Object.class));
+
+    producerTimingRecorder.recordMethod(15, 42);
+    producerTimingRecorder.recordSuccess(100);
+
+    InOrder order = inOrder(mockProducerTimingRecorderA);
+    order.verify(mockProducerTimingRecorderA).recordMethod(15, 42);
+    order.verify(mockProducerTimingRecorderA).recordSuccess(100);
+    verifyNoMoreInteractions(mockProducerTimingRecorderA);
+  }
+
+  @Test
+  public void multipleRecorders_someThrowingProductionComponentTimingRecorderFactories() {
+    when(mockProductionComponentTimingRecorderFactoryA.create(any(Object.class)))
+        .thenReturn(mockProductionComponentTimingRecorderA);
+    when(mockProductionComponentTimingRecorderFactoryB.create(any(Object.class)))
+        .thenThrow(new RuntimeException("monkey"));
+    when(mockProductionComponentTimingRecorderFactoryC.create(any(Object.class)))
+        .thenThrow(new RuntimeException("monkey"));
+    when(mockProductionComponentTimingRecorderA.producerTimingRecorderFor(any(ProducerToken.class)))
+        .thenReturn(mockProducerTimingRecorderA);
+    ProductionComponentTimingRecorder.Factory factory =
+        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
+            ImmutableList.of(
+                mockProductionComponentTimingRecorderFactoryA,
+                mockProductionComponentTimingRecorderFactoryB,
+                mockProductionComponentTimingRecorderFactoryC));
+    ProductionComponentTimingRecorder recorder = factory.create(new Object());
+    ProducerTimingRecorder producerTimingRecorder =
+        recorder.producerTimingRecorderFor(ProducerToken.create(Object.class));
+
+    producerTimingRecorder.recordMethod(15, 42);
+    producerTimingRecorder.recordSuccess(100);
+
+    InOrder order = inOrder(mockProducerTimingRecorderA);
+    order.verify(mockProducerTimingRecorderA).recordMethod(15, 42);
+    order.verify(mockProducerTimingRecorderA).recordSuccess(100);
+    verifyNoMoreInteractions(mockProducerTimingRecorderA);
+  }
+
+  @Test
+  public void multipleRecorders_normalProductionComponentTimingRecorderSuccess() {
+    setUpNormalMultipleRecorders();
+    ProductionComponentTimingRecorder.Factory factory =
+        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
+            ImmutableList.of(
+                mockProductionComponentTimingRecorderFactoryA,
+                mockProductionComponentTimingRecorderFactoryB,
+                mockProductionComponentTimingRecorderFactoryC));
+    ProductionComponentTimingRecorder recorder = factory.create(new Object());
+    ProducerTimingRecorder producerTimingRecorder =
+        recorder.producerTimingRecorderFor(ProducerToken.create(Object.class));
+
+    producerTimingRecorder.recordMethod(15, 42);
+    producerTimingRecorder.recordSuccess(100);
+
+    InOrder order =
+        inOrder(
+            mockProducerTimingRecorderA, mockProducerTimingRecorderB, mockProducerTimingRecorderC);
+    order.verify(mockProducerTimingRecorderA).recordMethod(15, 42);
+    order.verify(mockProducerTimingRecorderB).recordMethod(15, 42);
+    order.verify(mockProducerTimingRecorderC).recordMethod(15, 42);
+    order.verify(mockProducerTimingRecorderA).recordSuccess(100);
+    order.verify(mockProducerTimingRecorderB).recordSuccess(100);
+    order.verify(mockProducerTimingRecorderC).recordSuccess(100);
+    verifyNoMoreInteractions(
+        mockProducerTimingRecorderA, mockProducerTimingRecorderB, mockProducerTimingRecorderC);
+  }
+
+  @Test
+  public void multipleRecorders_someThrowingProducerTimingRecordersSuccess() {
+    setUpNormalMultipleRecorders();
+    doThrow(new RuntimeException("monkey"))
+        .when(mockProducerTimingRecorderA)
+        .recordMethod(any(Long.class), any(Long.class));
+    doThrow(new RuntimeException("monkey"))
+        .when(mockProducerTimingRecorderB)
+        .recordSuccess(any(Long.class));
+    doThrow(new RuntimeException("monkey"))
+        .when(mockProducerTimingRecorderC)
+        .recordMethod(any(Long.class), any(Long.class));
+    ProductionComponentTimingRecorder.Factory factory =
+        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
+            ImmutableList.of(
+                mockProductionComponentTimingRecorderFactoryA,
+                mockProductionComponentTimingRecorderFactoryB,
+                mockProductionComponentTimingRecorderFactoryC));
+    ProductionComponentTimingRecorder recorder = factory.create(new Object());
+    ProducerTimingRecorder producerTimingRecorder =
+        recorder.producerTimingRecorderFor(ProducerToken.create(Object.class));
+
+    producerTimingRecorder.recordMethod(15, 42);
+    producerTimingRecorder.recordSuccess(100);
+
+    InOrder order =
+        inOrder(
+            mockProducerTimingRecorderA, mockProducerTimingRecorderB, mockProducerTimingRecorderC);
+    order.verify(mockProducerTimingRecorderA).recordMethod(15, 42);
+    order.verify(mockProducerTimingRecorderB).recordMethod(15, 42);
+    order.verify(mockProducerTimingRecorderC).recordMethod(15, 42);
+    order.verify(mockProducerTimingRecorderA).recordSuccess(100);
+    order.verify(mockProducerTimingRecorderB).recordSuccess(100);
+    order.verify(mockProducerTimingRecorderC).recordSuccess(100);
+    verifyNoMoreInteractions(
+        mockProducerTimingRecorderA, mockProducerTimingRecorderB, mockProducerTimingRecorderC);
+  }
+
+  private void setUpNormalSingleRecorder() {
+    when(mockProductionComponentTimingRecorderFactory.create(any(Object.class)))
+        .thenReturn(mockProductionComponentTimingRecorder);
+    when(mockProductionComponentTimingRecorder.producerTimingRecorderFor(any(ProducerToken.class)))
+        .thenReturn(mockProducerTimingRecorder);
+  }
+
+  private void setUpNormalMultipleRecorders() {
+    when(mockProductionComponentTimingRecorderFactoryA.create(any(Object.class)))
+        .thenReturn(mockProductionComponentTimingRecorderA);
+    when(mockProductionComponentTimingRecorderFactoryB.create(any(Object.class)))
+        .thenReturn(mockProductionComponentTimingRecorderB);
+    when(mockProductionComponentTimingRecorderFactoryC.create(any(Object.class)))
+        .thenReturn(mockProductionComponentTimingRecorderC);
+    when(mockProductionComponentTimingRecorderA.producerTimingRecorderFor(any(ProducerToken.class)))
+        .thenReturn(mockProducerTimingRecorderA);
+    when(mockProductionComponentTimingRecorderB.producerTimingRecorderFor(any(ProducerToken.class)))
+        .thenReturn(mockProducerTimingRecorderB);
+    when(mockProductionComponentTimingRecorderC.producerTimingRecorderFor(any(ProducerToken.class)))
+        .thenReturn(mockProducerTimingRecorderC);
+  }
+}
diff --git a/producers/src/test/java/dagger/producers/monitoring/internal/MonitorsTest.java b/producers/src/test/java/dagger/producers/monitoring/internal/MonitorsTest.java
index e7f42746b..224d8e0b6 100644
--- a/producers/src/test/java/dagger/producers/monitoring/internal/MonitorsTest.java
+++ b/producers/src/test/java/dagger/producers/monitoring/internal/MonitorsTest.java
@@ -121,11 +121,13 @@ public void singleMonitor_normalProducerMonitorSuccess() {
     ProducerMonitor producerMonitor =
         monitor.producerMonitorFor(ProducerToken.create(Object.class));
     Object o = new Object();
+    producerMonitor.requested();
     producerMonitor.methodStarting();
     producerMonitor.methodFinished();
     producerMonitor.succeeded(o);
 
     InOrder order = inOrder(mockProducerMonitor);
+    order.verify(mockProducerMonitor).requested();
     order.verify(mockProducerMonitor).methodStarting();
     order.verify(mockProducerMonitor).methodFinished();
     order.verify(mockProducerMonitor).succeeded(o);
@@ -142,11 +144,13 @@ public void singleMonitor_normalProducerMonitorFailure() {
     ProducerMonitor producerMonitor =
         monitor.producerMonitorFor(ProducerToken.create(Object.class));
     Throwable t = new RuntimeException("monkey");
+    producerMonitor.requested();
     producerMonitor.methodStarting();
     producerMonitor.methodFinished();
     producerMonitor.failed(t);
 
     InOrder order = inOrder(mockProducerMonitor);
+    order.verify(mockProducerMonitor).requested();
     order.verify(mockProducerMonitor).methodStarting();
     order.verify(mockProducerMonitor).methodFinished();
     order.verify(mockProducerMonitor).failed(t);
@@ -156,6 +160,7 @@ public void singleMonitor_normalProducerMonitorFailure() {
   @Test
   public void singleMonitor_throwingProducerMonitorSuccess() {
     setUpNormalSingleMonitor();
+    doThrow(new RuntimeException("monkey")).when(mockProducerMonitor).requested();
     doThrow(new RuntimeException("monkey")).when(mockProducerMonitor).methodStarting();
     doThrow(new RuntimeException("monkey")).when(mockProducerMonitor).methodFinished();
     doThrow(new RuntimeException("monkey")).when(mockProducerMonitor).succeeded(any(Object.class));
@@ -166,11 +171,13 @@ public void singleMonitor_throwingProducerMonitorSuccess() {
     ProducerMonitor producerMonitor =
         monitor.producerMonitorFor(ProducerToken.create(Object.class));
     Object o = new Object();
+    producerMonitor.requested();
     producerMonitor.methodStarting();
     producerMonitor.methodFinished();
     producerMonitor.succeeded(o);
 
     InOrder order = inOrder(mockProducerMonitor);
+    order.verify(mockProducerMonitor).requested();
     order.verify(mockProducerMonitor).methodStarting();
     order.verify(mockProducerMonitor).methodFinished();
     order.verify(mockProducerMonitor).succeeded(o);
@@ -180,6 +187,7 @@ public void singleMonitor_throwingProducerMonitorSuccess() {
   @Test
   public void singleMonitor_throwingProducerMonitorFailure() {
     setUpNormalSingleMonitor();
+    doThrow(new RuntimeException("monkey")).when(mockProducerMonitor).requested();
     doThrow(new RuntimeException("monkey")).when(mockProducerMonitor).methodStarting();
     doThrow(new RuntimeException("monkey")).when(mockProducerMonitor).methodFinished();
     doThrow(new RuntimeException("monkey")).when(mockProducerMonitor).failed(any(Throwable.class));
@@ -190,11 +198,13 @@ public void singleMonitor_throwingProducerMonitorFailure() {
     ProducerMonitor producerMonitor =
         monitor.producerMonitorFor(ProducerToken.create(Object.class));
     Throwable t = new RuntimeException("gorilla");
+    producerMonitor.requested();
     producerMonitor.methodStarting();
     producerMonitor.methodFinished();
     producerMonitor.failed(t);
 
     InOrder order = inOrder(mockProducerMonitor);
+    order.verify(mockProducerMonitor).requested();
     order.verify(mockProducerMonitor).methodStarting();
     order.verify(mockProducerMonitor).methodFinished();
     order.verify(mockProducerMonitor).failed(t);
@@ -254,11 +264,13 @@ public void multipleMonitors_someNullProductionComponentMonitors() {
         monitor.producerMonitorFor(ProducerToken.create(Object.class));
 
     Object o = new Object();
+    producerMonitor.requested();
     producerMonitor.methodStarting();
     producerMonitor.methodFinished();
     producerMonitor.succeeded(o);
 
     InOrder order = inOrder(mockProducerMonitorA);
+    order.verify(mockProducerMonitorA).requested();
     order.verify(mockProducerMonitorA).methodStarting();
     order.verify(mockProducerMonitorA).methodFinished();
     order.verify(mockProducerMonitorA).succeeded(o);
@@ -288,11 +300,13 @@ public void multipleMonitors_someThrowingProductionComponentMonitorFactories() {
         monitor.producerMonitorFor(ProducerToken.create(Object.class));
 
     Object o = new Object();
+    producerMonitor.requested();
     producerMonitor.methodStarting();
     producerMonitor.methodFinished();
     producerMonitor.succeeded(o);
 
     InOrder order = inOrder(mockProducerMonitorA);
+    order.verify(mockProducerMonitorA).requested();
     order.verify(mockProducerMonitorA).methodStarting();
     order.verify(mockProducerMonitorA).methodFinished();
     order.verify(mockProducerMonitorA).succeeded(o);
@@ -313,11 +327,15 @@ public void multipleMonitors_normalProductionComponentMonitorSuccess() {
         monitor.producerMonitorFor(ProducerToken.create(Object.class));
 
     Object o = new Object();
+    producerMonitor.requested();
     producerMonitor.methodStarting();
     producerMonitor.methodFinished();
     producerMonitor.succeeded(o);
 
     InOrder order = inOrder(mockProducerMonitorA, mockProducerMonitorB, mockProducerMonitorC);
+    order.verify(mockProducerMonitorA).requested();
+    order.verify(mockProducerMonitorB).requested();
+    order.verify(mockProducerMonitorC).requested();
     order.verify(mockProducerMonitorA).methodStarting();
     order.verify(mockProducerMonitorB).methodStarting();
     order.verify(mockProducerMonitorC).methodStarting();
@@ -344,11 +362,15 @@ public void multipleMonitors_normalProductionComponentMonitorFailure() {
         monitor.producerMonitorFor(ProducerToken.create(Object.class));
 
     Throwable t = new RuntimeException("chimpanzee");
+    producerMonitor.requested();
     producerMonitor.methodStarting();
     producerMonitor.methodFinished();
     producerMonitor.failed(t);
 
     InOrder order = inOrder(mockProducerMonitorA, mockProducerMonitorB, mockProducerMonitorC);
+    order.verify(mockProducerMonitorA).requested();
+    order.verify(mockProducerMonitorB).requested();
+    order.verify(mockProducerMonitorC).requested();
     order.verify(mockProducerMonitorA).methodStarting();
     order.verify(mockProducerMonitorB).methodStarting();
     order.verify(mockProducerMonitorC).methodStarting();
@@ -364,6 +386,7 @@ public void multipleMonitors_normalProductionComponentMonitorFailure() {
   @Test
   public void multipleMonitors_someThrowingProducerMonitorsSuccess() {
     setUpNormalMultipleMonitors();
+    doThrow(new RuntimeException("monkey")).when(mockProducerMonitorA).requested();
     doThrow(new RuntimeException("monkey")).when(mockProducerMonitorA).methodStarting();
     doThrow(new RuntimeException("monkey")).when(mockProducerMonitorB).methodFinished();
     doThrow(new RuntimeException("monkey")).when(mockProducerMonitorC).succeeded(any(Object.class));
@@ -378,11 +401,15 @@ public void multipleMonitors_someThrowingProducerMonitorsSuccess() {
         monitor.producerMonitorFor(ProducerToken.create(Object.class));
 
     Object o = new Object();
+    producerMonitor.requested();
     producerMonitor.methodStarting();
     producerMonitor.methodFinished();
     producerMonitor.succeeded(o);
 
     InOrder order = inOrder(mockProducerMonitorA, mockProducerMonitorB, mockProducerMonitorC);
+    order.verify(mockProducerMonitorA).requested();
+    order.verify(mockProducerMonitorB).requested();
+    order.verify(mockProducerMonitorC).requested();
     order.verify(mockProducerMonitorA).methodStarting();
     order.verify(mockProducerMonitorB).methodStarting();
     order.verify(mockProducerMonitorC).methodStarting();
@@ -398,6 +425,7 @@ public void multipleMonitors_someThrowingProducerMonitorsSuccess() {
   @Test
   public void multipleMonitors_someThrowingProducerMonitorsFailure() {
     setUpNormalMultipleMonitors();
+    doThrow(new RuntimeException("monkey")).when(mockProducerMonitorA).requested();
     doThrow(new RuntimeException("monkey")).when(mockProducerMonitorA).methodStarting();
     doThrow(new RuntimeException("monkey")).when(mockProducerMonitorB).methodFinished();
     doThrow(new RuntimeException("monkey")).when(mockProducerMonitorC).failed(any(Throwable.class));
@@ -412,11 +440,15 @@ public void multipleMonitors_someThrowingProducerMonitorsFailure() {
         monitor.producerMonitorFor(ProducerToken.create(Object.class));
 
     Throwable t = new RuntimeException("chimpanzee");
+    producerMonitor.requested();
     producerMonitor.methodStarting();
     producerMonitor.methodFinished();
     producerMonitor.failed(t);
 
     InOrder order = inOrder(mockProducerMonitorA, mockProducerMonitorB, mockProducerMonitorC);
+    order.verify(mockProducerMonitorA).requested();
+    order.verify(mockProducerMonitorB).requested();
+    order.verify(mockProducerMonitorC).requested();
     order.verify(mockProducerMonitorA).methodStarting();
     order.verify(mockProducerMonitorB).methodStarting();
     order.verify(mockProducerMonitorC).methodStarting();
