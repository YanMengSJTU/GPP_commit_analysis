diff --git a/compiler/src/main/java/dagger/internal/codegen/AnnotationMirrors.java b/compiler/src/main/java/dagger/internal/codegen/AnnotationMirrors.java
index e87afb0e1..64889e2fe 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AnnotationMirrors.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AnnotationMirrors.java
@@ -15,6 +15,7 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.Equivalence;
 import com.google.common.base.Predicate;
@@ -60,12 +61,12 @@
     return builder.build();
   }
 
-  static ImmutableList<TypeMirror> getAttributeAsListOfTypes(Elements elements,
-      AnnotationMirror annotationMirror, String attributeName) {
+  static ImmutableList<TypeMirror> getAttributeAsListOfTypes(AnnotationMirror annotationMirror,
+      String attributeName) {
     checkNotNull(annotationMirror);
     checkNotNull(attributeName);
     ImmutableMap<String, AnnotationValue> valueMap =
-        simplifyAnnotationValueMap(elements.getElementValuesWithDefaults(annotationMirror));
+        simplifyAnnotationValueMap(getAnnotationValuesWithDefaults(annotationMirror));
     ImmutableList.Builder<TypeMirror> builder = ImmutableList.builder();
 
     @SuppressWarnings("unchecked") // that's the whole point of this method
@@ -120,11 +121,22 @@ protected int doHash(AnnotationMirror annotation) {
   static Map<ExecutableElement, AnnotationValue> getAnnotationValuesWithDefaults(
       AnnotationMirror annotation) {
     Map<ExecutableElement, AnnotationValue> values = Maps.newLinkedHashMap();
+    Map<? extends ExecutableElement, ? extends AnnotationValue> declaredValues =
+        annotation.getElementValues();
     for (ExecutableElement method :
         ElementFilter.methodsIn(annotation.getAnnotationType().asElement().getEnclosedElements())) {
-      values.put(method, method.getDefaultValue());
+      // Must iterate and put in this order, to ensure consistency in generated code.
+      if (declaredValues.containsKey(method)) {
+        values.put(method, declaredValues.get(method));
+      } else if (method.getDefaultValue() != null) {
+        values.put(method, method.getDefaultValue());
+      } else {
+        throw new IllegalStateException(
+            "Unset annotation value without default should never happen: "
+            + MoreElements.asType(method.getEnclosingElement()).getQualifiedName()
+            + '.' + method.getSimpleName() + "()");
+      }
     }
-    values.putAll(annotation.getElementValues());
     return values;
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index 39d2e3a98..9ec404d94 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -15,8 +15,6 @@
  */
 package dagger.internal.codegen;
 
-import static dagger.internal.codegen.ComponentDescriptor.isComponentProvisionMethod;
-
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Function;
@@ -35,6 +33,7 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
@@ -46,6 +45,8 @@
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.ComponentDescriptor.isComponentProvisionMethod;
+import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
 import static dagger.internal.codegen.ConfigurationAnnotations.getTransitiveModules;
 import static javax.lang.model.type.TypeKind.VOID;
@@ -103,6 +104,7 @@
 
     BindingGraph create(ComponentDescriptor componentDescriptor) {
       ImmutableSet.Builder<ProvisionBinding> explicitBindingsBuilder = ImmutableSet.builder();
+      AnnotationMirror componentAnnotation = componentDescriptor.componentAnnotation();
 
       // binding for the component itself
       ProvisionBinding componentBinding =
@@ -110,9 +112,8 @@ BindingGraph create(ComponentDescriptor componentDescriptor) {
       explicitBindingsBuilder.add(componentBinding);
 
       // Collect Component dependencies.
-      ImmutableSet<TypeElement> componentDependencyTypes = MoreTypes.asTypeElements(types,
-          ConfigurationAnnotations.getComponentDependencies(
-              elements, componentDescriptor.componentAnnotation()));
+      ImmutableSet<TypeElement> componentDependencyTypes =
+          MoreTypes.asTypeElements(types, getComponentDependencies(componentAnnotation));
       for (TypeElement componentDependency : componentDependencyTypes) {
         explicitBindingsBuilder.add(provisionBindingFactory.forComponent(componentDependency));
         List<ExecutableElement> dependencyMethods =
@@ -127,11 +128,10 @@ BindingGraph create(ComponentDescriptor componentDescriptor) {
 
       // Collect transitive modules provisions.
       ImmutableSet<TypeElement> moduleTypes =
-          MoreTypes.asTypeElements(types,
-              getComponentModules(elements, componentDescriptor.componentAnnotation()));
+          MoreTypes.asTypeElements(types, getComponentModules(componentAnnotation));
 
       ImmutableMap<TypeElement, ImmutableSet<TypeElement>> transitiveModules =
-          getTransitiveModules(elements, types, moduleTypes);
+          getTransitiveModules(types, moduleTypes);
       for (TypeElement module : transitiveModules.keySet()) {
         // traverse the modules, collect the bindings
         List<ExecutableElement> moduleMethods = methodsIn(elements.getAllMembers(module));
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index e1f8ae142..ddddf9cf0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -32,6 +32,7 @@
 import javax.lang.model.util.Types;
 
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
+import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
 import static dagger.internal.codegen.InjectionAnnotations.getScopeAnnotation;
 import static dagger.internal.codegen.Util.unwrapOptionalEquivalence;
 import static dagger.internal.codegen.Util.wrapOptionalInEquivalence;
@@ -95,8 +96,8 @@
     ComponentDescriptor create(TypeElement componentDefinitionType) {
       AnnotationMirror componentMirror =
           getAnnotationMirror(componentDefinitionType, Component.class).get();
-      ImmutableSet<TypeElement> componentDependencyTypes = MoreTypes.asTypeElements(types,
-          ConfigurationAnnotations.getComponentDependencies(elements, componentMirror));
+      ImmutableSet<TypeElement> componentDependencyTypes =
+          MoreTypes.asTypeElements(types, getComponentDependencies(componentMirror));
 
       ProvisionBinding componentBinding =
           provisionBindingFactory.forComponent(componentDefinitionType);
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index fb287dc75..b01d7ee54 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -76,9 +76,9 @@ public synchronized void init(ProcessingEnvironment processingEnv) {
     InjectConstructorValidator injectConstructorValidator = new InjectConstructorValidator();
     InjectFieldValidator injectFieldValidator = new InjectFieldValidator();
     InjectMethodValidator injectMethodValidator = new InjectMethodValidator();
-    ModuleValidator moduleValidator = new ModuleValidator(elements, types);
+    ModuleValidator moduleValidator = new ModuleValidator(types);
     ProvidesMethodValidator providesMethodValidator = new ProvidesMethodValidator(elements);
-    ComponentValidator componentValidator = new ComponentValidator(elements);
+    ComponentValidator componentValidator = new ComponentValidator();
     MapKeyValidator mapKeyValidator = new MapKeyValidator();
 
     Key.Factory keyFactory = new Key.Factory(types, elements);
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
index 6cf1ced26..5e15022ed 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
@@ -23,11 +23,11 @@
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.Elements;
 import javax.lang.model.util.SimpleTypeVisitor6;
 
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static com.google.common.base.Preconditions.checkState;
+import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
 import static javax.lang.model.element.ElementKind.CLASS;
 import static javax.lang.model.element.ElementKind.INTERFACE;
 import static javax.lang.model.element.Modifier.ABSTRACT;
@@ -38,14 +38,7 @@
  * @author Gregory Kick
  */
 final class ComponentValidator implements Validator<TypeElement> {
-  private final Elements elements;
-
-  ComponentValidator(Elements elements) {
-    this.elements = elements;
-  }
-
-  @Override
-  public ValidationReport<TypeElement> validate(final TypeElement subject) {
+  @Override public ValidationReport<TypeElement> validate(final TypeElement subject) {
     final ValidationReport.Builder<TypeElement> builder = ValidationReport.Builder.about(subject);
 
     if (!subject.getKind().equals(INTERFACE)
@@ -54,8 +47,7 @@
     }
 
     AnnotationMirror componentMirror = getAnnotationMirror(subject, Component.class).get();
-    ImmutableList<TypeMirror> moduleTypes =
-        ConfigurationAnnotations.getComponentModules(elements, componentMirror);
+    ImmutableList<TypeMirror> moduleTypes = getComponentModules(componentMirror);
 
     // TODO(gak): make unused modules an error
     for (TypeMirror moduleType : moduleTypes) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
index 75e401252..58d72fea6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
@@ -31,7 +31,6 @@
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
@@ -46,38 +45,30 @@
 final class ConfigurationAnnotations {
   private static final String MODULES_ATTRIBUTE = "modules";
 
-  static ImmutableList<TypeMirror> getComponentModules(Elements elements,
-      AnnotationMirror componentAnnotation) {
-    checkNotNull(elements);
+  static ImmutableList<TypeMirror> getComponentModules(AnnotationMirror componentAnnotation) {
     checkNotNull(componentAnnotation);
-    return getAttributeAsListOfTypes(elements, componentAnnotation, MODULES_ATTRIBUTE);
+    return getAttributeAsListOfTypes(componentAnnotation, MODULES_ATTRIBUTE);
   }
 
   private static final String DEPENDENCIES_ATTRIBUTE = "dependencies";
 
-  static ImmutableList<TypeMirror> getComponentDependencies(Elements elements,
-      AnnotationMirror componentAnnotation) {
-    checkNotNull(elements);
+  static ImmutableList<TypeMirror> getComponentDependencies(AnnotationMirror componentAnnotation) {
     checkNotNull(componentAnnotation);
-    return getAttributeAsListOfTypes(elements, componentAnnotation, DEPENDENCIES_ATTRIBUTE);
+    return getAttributeAsListOfTypes(componentAnnotation, DEPENDENCIES_ATTRIBUTE);
   }
 
   private static final String INCLUDES_ATTRIBUTE = "includes";
 
-  static ImmutableList<TypeMirror> getModuleIncludes(Elements elements,
-      AnnotationMirror moduleAnnotation) {
-    checkNotNull(elements);
+  static ImmutableList<TypeMirror> getModuleIncludes(AnnotationMirror moduleAnnotation) {
     checkNotNull(moduleAnnotation);
-    return getAttributeAsListOfTypes(elements, moduleAnnotation, INCLUDES_ATTRIBUTE);
+    return getAttributeAsListOfTypes(moduleAnnotation, INCLUDES_ATTRIBUTE);
   }
 
   private static final String INJECTS_ATTRIBUTE = "injects";
 
-  static ImmutableList<TypeMirror> getModuleInjects(Elements elements,
-      AnnotationMirror moduleAnnotation) {
-    checkNotNull(elements);
+  static ImmutableList<TypeMirror> getModuleInjects(AnnotationMirror moduleAnnotation) {
     checkNotNull(moduleAnnotation);
-    return getAttributeAsListOfTypes(elements, moduleAnnotation, INJECTS_ATTRIBUTE);
+    return getAttributeAsListOfTypes(moduleAnnotation, INJECTS_ATTRIBUTE);
   }
 
   static ImmutableSet<? extends AnnotationMirror> getMapKeys(Element element) {
@@ -90,7 +81,7 @@
    * is not annotated with {@link Module}, it is ignored.
    */
   static ImmutableMap<TypeElement, ImmutableSet<TypeElement>> getTransitiveModules(
-      Elements elements, Types types, ImmutableSet<TypeElement> seedModules) {
+      Types types, ImmutableSet<TypeElement> seedModules) {
     Queue<TypeElement> moduleQueue = Queues.newArrayDeque(seedModules);
     Map<TypeElement, ImmutableSet<TypeElement>> moduleElements = Maps.newLinkedHashMap();
     for (TypeElement moduleElement = moduleQueue.poll();
@@ -98,8 +89,8 @@
         moduleElement = moduleQueue.poll()) {
       Optional<AnnotationMirror> moduleMirror = getAnnotationMirror(moduleElement, Module.class);
       if (moduleMirror.isPresent()) {
-        ImmutableSet<TypeElement> moduleDependencies = MoreTypes.asTypeElements(types,
-            ConfigurationAnnotations.getModuleIncludes(elements, moduleMirror.get()));
+        ImmutableSet<TypeElement> moduleDependencies =
+            MoreTypes.asTypeElements(types, getModuleIncludes(moduleMirror.get()));
         moduleElements.put(moduleElement, moduleDependencies);
         for (TypeElement dependencyType : moduleDependencies) {
           if (!moduleElements.containsKey(dependencyType)) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
index 00465243f..f84212aa4 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
@@ -15,7 +15,6 @@
  */
 package dagger.internal.codegen;
 
-import com.google.auto.common.MoreElements;
 import com.google.auto.common.Visibility;
 import com.google.common.base.Function;
 import com.google.common.base.Joiner;
@@ -33,13 +32,14 @@
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementFilter;
-import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
+import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.auto.common.Visibility.PRIVATE;
 import static com.google.auto.common.Visibility.PUBLIC;
 import static com.google.auto.common.Visibility.effectiveVisibilityOfElement;
+import static dagger.internal.codegen.ConfigurationAnnotations.getModuleIncludes;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_WITH_SAME_NAME;
 
 /**
@@ -49,11 +49,9 @@
  * @since 2.0
  */
 final class ModuleValidator implements Validator<TypeElement> {
-  private final Elements elements;
   private final Types types;
 
-  ModuleValidator(Elements elements, Types types) {
-    this.elements =  elements;
+  ModuleValidator(Types types) {
     this.types = types;
   }
 
@@ -100,20 +98,19 @@ private void validateModuleVisibility(final TypeElement moduleElement,
       case MEMBER:
       case TOP_LEVEL:
         if (moduleVisibility.equals(PUBLIC)) {
-          ImmutableSet<Element> nonPublicModules =
-              FluentIterable.from(ConfigurationAnnotations.getModuleIncludes(elements,
-                  MoreElements.getAnnotationMirror(moduleElement, Module.class).get()))
-                      .transform(new Function<TypeMirror, Element>() {
-                        @Override public Element apply(TypeMirror input) {
-                          return types.asElement(input);
-                        }
-                      })
-                      .filter(new Predicate<Element>() {
-                        @Override public boolean apply(Element input) {
-                          return effectiveVisibilityOfElement(input).compareTo(PUBLIC) < 0;
-                        }
-                      })
-                      .toSet();
+          ImmutableSet<Element> nonPublicModules = FluentIterable.from(getModuleIncludes(
+              getAnnotationMirror(moduleElement, Module.class).get()))
+                  .transform(new Function<TypeMirror, Element>() {
+                    @Override public Element apply(TypeMirror input) {
+                      return types.asElement(input);
+                    }
+                  })
+                  .filter(new Predicate<Element>() {
+                    @Override public boolean apply(Element input) {
+                      return effectiveVisibilityOfElement(input).compareTo(PUBLIC) < 0;
+                    }
+                  })
+                  .toSet();
           if (!nonPublicModules.isEmpty()) {
             reportBuilder.addItem(
                 String.format(
