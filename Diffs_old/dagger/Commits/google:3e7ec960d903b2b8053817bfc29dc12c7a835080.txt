diff --git a/.travis.yml b/.travis.yml
index 2420f9823..9f3fd4807 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -2,21 +2,17 @@ language: java
 
 jdk:
   - oraclejdk7
-  - openjdk7 
+  - openjdk7
 
 before_install:
-  - sudo apt-get update -qq
-  - if [ `uname -m` = x86_64 ]; then sudo apt-get install -qq --force-yes libgd2-xpm ia32-libs ia32-libs-multiarch; fi
-  - wget http://dl.google.com/android/android-sdk_r21.0.1-linux.tgz
-  - echo "Installing android SDK into ${PWD}/android-sdk-linux"
-  - tar -xzf android-sdk_r21.0.1-linux.tgz
-  - export ANDROID_HOME=${PWD}/android-sdk-linux
-  - export PATH=${PATH}:${ANDROID_HOME}/tools:${ANDROID_HOME}/platform-tools
-  - android update sdk --filter platform-tools,android-16 --no-ui --force
+  - sudo apt-get install -qq libstdc++6:i386 lib32z1
+  - export COMPONENTS=build-tools-19.0.1,android-16
+  - curl -L https://raw.github.com/embarkmobile/android-sdk-installer/version-1/android-sdk-installer | bash /dev/stdin --install=$COMPONENTS
+  - source ~/.android-sdk-installer/env
 
 install: mvn install clean --fail-never --quiet -DskipTests=true -Dinvoker.skip=true
 
-script: mvn verify 
+script: mvn verify
 
 notifications:
   email: false
diff --git a/CHANGELOG.md b/CHANGELOG.md
index b2e20e941..957840eca 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,6 +1,20 @@
 Change Log
 ==========
 
+Version 1.2.0 *(2013-12-13)*
+----------------------------
+
+ * Numerous performance improvements in both the compiler and runtime.
+   * Use more efficient `String` concatenation.
+   * Module adapters are now stateless.
+   * Use read/write locks over global locks.
+   * Reflective constructor invocation is now cached with `Class.newInstance`.
+   * Avoid re-linking all bindings when calling `.plus()`.
+ * Set bindings are now unioned when calling `.plus()`.
+ * Fix: Tolerate missing type information during compilation by deferring writing
+   module adapters.
+
+
 Version 1.1.0 *(2013-08-05)*
 ----------------------------
 
diff --git a/checkstyle.xml b/checkstyle.xml
index 233aeecf1..016f64f47 100644
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -59,7 +59,6 @@
             <property name="processJavadoc" value="true"/>
         </module>
 
-
         <!-- Checks for Size Violations.                    -->
         <!-- See http://checkstyle.sf.net/config_sizes.html -->
         <module name="LineLength">
@@ -68,7 +67,6 @@
         <module name="MethodLength">
             <property name="max" value="200"/>
         </module>
-
         <!--module name="ParameterNumber"/-->
 
 
diff --git a/compiler/pom.xml b/compiler/pom.xml
index ee261a4f2..42bce62b3 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>com.google.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.1.1-SNAPSHOT</version>
+    <version>1.2.1-SNAPSHOT</version>
   </parent>
 
   <artifactId>dagger-compiler</artifactId>
@@ -43,7 +43,6 @@
     <dependency>
       <groupId>com.google.guava</groupId>
       <artifactId>guava</artifactId>
-      <version>15.0</version>
     </dependency>
 
     <dependency>
@@ -66,13 +65,11 @@
     <dependency>
       <groupId>com.google.testing.compile</groupId>
       <artifactId>compile-testing</artifactId>
-      <version>0.3</version>
       <scope>test</scope>
     </dependency>
     <dependency>
       <groupId>org.truth0</groupId>
       <artifactId>truth</artifactId>
-      <version>0.13</version>
       <scope>test</scope>
     </dependency>
   </dependencies>
@@ -131,6 +128,24 @@
           </execution>
         </executions>
       </plugin>
+
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-assembly-plugin</artifactId>
+        <configuration>
+          <descriptorRefs>
+            <descriptorRef>jar-with-dependencies</descriptorRef>
+          </descriptorRefs>
+        </configuration>
+        <executions>
+          <execution>
+            <phase>package</phase>
+            <goals>
+              <goal>single</goal>
+            </goals>
+          </execution>
+        </executions>
+      </plugin>
     </plugins>
   </build>
 </project>
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphVisualizer.java b/compiler/src/main/java/dagger/internal/codegen/GraphVisualizer.java
index bfa9418c7..a0fe29ce7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GraphVisualizer.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GraphVisualizer.java
@@ -19,11 +19,11 @@
 import java.io.IOException;
 import java.util.Comparator;
 import java.util.HashSet;
-import java.util.TreeSet;
 import java.util.LinkedHashMap;
 import java.util.Map;
 import java.util.Set;
 import java.util.TreeMap;
+import java.util.TreeSet;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
@@ -125,7 +125,7 @@ String shortName(String key) {
     return result.toString();
   }
 
-  /** A Comparator for BindingsGroup so we can insure a consistent ordering of output. */
+  /** A Comparator for Bindings so we can insure a consistent ordering of output. */
   private static class BindingComparator implements Comparator<Binding<?>> {
     @Override
     public int compare(Binding<?> left, Binding<?> right) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
index bdba0f461..e2d74f2e5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
@@ -488,7 +488,7 @@ private void generateProvidesAdapter(JavaWriter writer, ExecutableElement provid
       writer.beginMethod("void", "getDependencies", EnumSet.of(PUBLIC), setOfBindings,
           "getBindings", setOfBindings, "injectMembersBindings");
       for (Element parameter : parameters) {
-        writer.emitStatement("getBindings.add(%s)", parameter.getSimpleName().toString());
+        writer.emitStatement("getBindings.add(%s)", parameterName(parameter));
       }
       writer.endMethod();
     }
@@ -502,7 +502,7 @@ private void generateProvidesAdapter(JavaWriter writer, ExecutableElement provid
     for (Element parameter : parameters) {
       if (!first) args.append(", ");
       else first = false;
-      args.append(String.format("%s.get()", parameter.getSimpleName().toString()));
+      args.append(String.format("%s.get()", parameterName(parameter)));
     }
     writer.emitStatement("return module.%s(%s)", methodName, args.toString());
     writer.endMethod();
diff --git a/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java b/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java
index 17c3904a4..59aff69f6 100644
--- a/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java
@@ -48,8 +48,8 @@
             "  private static final Class<?>[] STATIC_INJECTIONS = {};",
             "  private static final Class<?>[] INCLUDES = {};",
             "  public Basic$AModule$$ModuleAdapter() {",
-            "    super(Basic.AModule.class, INJECTS, STATIC_INJECTIONS, false, INCLUDES, true,",
-            "      false);",
+            "    super(Basic.AModule.class, INJECTS, STATIC_INJECTIONS, false, INCLUDES,",
+            "      true, false);",
             "  }",
             "  @Override public Basic.AModule newModule() {",
             "    return new Basic.AModule();",
diff --git a/compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java b/compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java
new file mode 100644
index 000000000..3bf7a9611
--- /dev/null
+++ b/compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java
@@ -0,0 +1,261 @@
+/*
+ * Copyright (C) 2013 Google Inc.
+ * Copyright (C) 2013 Square Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.tests.integration.codegen;
+
+import com.google.common.base.Joiner;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
+import static java.util.Arrays.asList;
+import static org.truth0.Truth.ASSERT;
+
+@RunWith(JUnit4.class)
+public final class ModuleAdapterGenerationTest {
+  /**
+   * Shows current behavior for a {@link dagger.Provides provides method}
+   * used to supply an injected ctor parameter.
+   *
+   * <ul>
+   *   <li>{@code ProvidesAdapter} invokes the module's provides method on
+   *   {@code get}</li>
+   *   <li>On {@code getBindings}, the above is newed up and linked to its type
+   *   key.
+   *   <li>{@code InjectAdapter} contains a field for the parameter binding,
+   *   referenced in {@code getDependencies} and set on {@code attach}</li>
+   *   <li>On {@code get}, the injected constructor is called with the value of
+   *   {@link dagger.internal.Binding#get}</li>
+   * </ul>
+   */
+  @Test public void providerForCtorInjection() {
+    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Field", Joiner.on("\n").join(
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "class Field {",
+        "  static class A { final String name; @Inject A(String name) { this.name = name; }}",
+        "  @Module(injects = { A.class, String.class })",
+        "  static class AModule { @Provides String name() { return \"foo\"; }}",
+        "}"));
+
+    JavaFileObject expectedModuleAdapter =
+        JavaFileObjects.forSourceString("Field$AModule$$ModuleAdapter", Joiner.on("\n").join(
+        "import dagger.internal.BindingsGroup;",
+        "import dagger.internal.ModuleAdapter;",
+        "import dagger.internal.ProvidesBinding;",
+        "import javax.inject.Provider;",
+        "public final class Field$AModule$$ModuleAdapter",
+        "    extends ModuleAdapter<Field.AModule> {",
+        "  private static final String[] INJECTS = ",
+        "      {\"members/Field$A\", \"members/java.lang.String\"};",
+        "  private static final Class<?>[] STATIC_INJECTIONS = {};",
+        "  private static final Class<?>[] INCLUDES = {};",
+        "  public Field$AModule$$ModuleAdapter() {",
+        "    super(Field.AModule.class, INJECTS, STATIC_INJECTIONS, false, INCLUDES, true, false);",
+        "  }",
+        "  @Override public Field.AModule newModule() {",
+        "    return new Field.AModule();",
+        "  }",
+        "  @Override public void getBindings(BindingsGroup bindings, Field.AModule module) {",
+        "    bindings.contributeProvidesBinding(\"java.lang.String\",",
+        "        new NameProvidesAdapter(module));", // eager new!
+        "  }",
+        "  public static final class NameProvidesAdapter", // corresponds to method name
+        "      extends ProvidesBinding<String> implements Provider<String> {",
+        "    private final Field.AModule module;",
+        "    public NameProvidesAdapter(Field.AModule module) {",
+        "      super(\"java.lang.String\", NOT_SINGLETON, \"Field.AModule\", \"name\");",
+        "      this.module = module;",
+        "      setLibrary(false);",
+        "    }",
+        "    @Override public String get() {",
+        "      return module.name();", // corresponds to @Provides method
+        "    }",
+        "  }",
+        "}"));
+
+    JavaFileObject expectedInjectAdapter =
+        JavaFileObjects.forSourceString("Field$A$$InjectAdapter", Joiner.on("\n").join(
+            "import dagger.internal.Binding;",
+            "import dagger.internal.Linker;",
+            "import java.util.Set;",
+            "import javax.inject.Provider;",
+            "public final class Field$A$$InjectAdapter",
+            "    extends Binding<Field.A> implements Provider<Field.A> {",
+            "  private Binding<String> name;", // for ctor
+            "  public Field$A$$InjectAdapter() {",
+            "    super(\"Field$A\", \"members/Field$A\", NOT_SINGLETON, Field.A.class);",
+            "  }",
+            "  @Override @SuppressWarnings(\"unchecked\")",
+            "  public void attach(Linker linker) {",
+            "    name = (Binding<String>)linker.requestBinding(", // binding key is not a class
+            "      \"java.lang.String\", Field.A.class, getClass().getClassLoader());",
+            "  }",
+            "  @Override public void getDependencies(",
+            "      Set<Binding<?>> getBindings, Set<Binding<?>> injectMembersBindings) {",
+            "    getBindings.add(name);", // name is added to dependencies
+            "  }",
+            "  @Override public Field.A get() {",
+            "    Field.A result = new Field.A(name.get());", // adds ctor param
+            "    return result;",
+            "  }",
+            "}"));
+
+    ASSERT.about(javaSource()).that(sourceFile).processedWith(daggerProcessors())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(expectedModuleAdapter, expectedInjectAdapter);
+
+  }
+
+  @Test public void injectsMembersInjectedAndProvidedAndConstructedTypes() {
+    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Field", Joiner.on("\n").join(
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "class Field {",
+        "  static class A { final String name; @Inject A(String name) { this.name = name; }}",
+        "  static class B { @Inject String name; }",
+        "  @Module(injects = { A.class, String.class, B.class })",
+        "  static class AModule { @Provides String name() { return \"foo\"; }}",
+        "}"));
+
+    JavaFileObject expectedModuleAdapter =
+        JavaFileObjects.forSourceString("Field$AModule$$ModuleAdapter", Joiner.on("\n").join(
+        "import dagger.internal.BindingsGroup;",
+        "import dagger.internal.ModuleAdapter;",
+        "import dagger.internal.ProvidesBinding;",
+        "import javax.inject.Provider;",
+        "public final class Field$AModule$$ModuleAdapter extends ModuleAdapter<Field.AModule> {",
+        "  private static final String[] INJECTS = ",
+        "      {\"members/Field$A\", \"members/java.lang.String\", \"members/Field$B\"};",
+        "  private static final Class<?>[] STATIC_INJECTIONS = {};",
+        "  private static final Class<?>[] INCLUDES = {};",
+        "  public Field$AModule$$ModuleAdapter() {",
+        "    super(Field.AModule.class, INJECTS, STATIC_INJECTIONS, false, INCLUDES, true, false);",
+        "  }",
+        "  @Override public Field.AModule newModule() {",
+        "    return new Field.AModule();",
+        "  }",
+        "  @Override public void getBindings(BindingsGroup bindings, Field.AModule module) {",
+        "    bindings.contributeProvidesBinding(\"java.lang.String\",",
+        "        new NameProvidesAdapter(module));", // eager new!
+        "  }",
+        "  public static final class NameProvidesAdapter", // corresponds to method name
+        "      extends ProvidesBinding<String> implements Provider<String> {",
+        "    private final Field.AModule module;",
+        "    public NameProvidesAdapter(Field.AModule module) {",
+        "      super(\"java.lang.String\", NOT_SINGLETON, \"Field.AModule\", \"name\");",
+        "      this.module = module;",
+        "      setLibrary(false);",
+        "    }",
+        "    @Override public String get() {",
+        "      return module.name();", // corresponds to @Provides method
+        "    }",
+        "  }",
+        "}"));
+
+    JavaFileObject expectedInjectAdapterA =
+        JavaFileObjects.forSourceString("Field$A$$InjectAdapter", Joiner.on("\n").join(
+            "import dagger.internal.Binding;",
+            "import dagger.internal.Linker;",
+            "import java.util.Set;",
+            "import javax.inject.Provider;",
+            "public final class Field$A$$InjectAdapter",
+            "    extends Binding<Field.A> implements Provider<Field.A> {",
+            "  private Binding<String> name;", // For Constructor.
+            "  public Field$A$$InjectAdapter() {",
+            "    super(\"Field$A\", \"members/Field$A\", NOT_SINGLETON, Field.A.class);",
+            "  }",
+            "  @Override @SuppressWarnings(\"unchecked\")",
+            "  public void attach(Linker linker) {",
+            "    name = (Binding<String>)linker.requestBinding(",
+            "      \"java.lang.String\", Field.A.class, getClass().getClassLoader());",
+            "  }",
+            "  @Override public void getDependencies(",
+            "      Set<Binding<?>> getBindings, Set<Binding<?>> injectMembersBindings) {",
+            "    getBindings.add(name);", // Name is added to dependencies.
+            "  }",
+            "  @Override public Field.A get() {",
+            "    Field.A result = new Field.A(name.get());", // Adds constructor parameter.
+            "    return result;",
+            "  }",
+            "}"));
+
+    JavaFileObject expectedInjectAdapterB =
+        JavaFileObjects.forSourceString("Field$B$$InjectAdapter", Joiner.on("\n").join(
+            "import dagger.MembersInjector;",
+            "import dagger.internal.Binding;",
+            "import dagger.internal.Linker;",
+            "import java.util.Set;",
+            "import javax.inject.Provider;",
+            "public final class Field$B$$InjectAdapter",
+            "    extends Binding<Field.B> implements Provider<Field.B>, MembersInjector<Field.B> {",
+            "  private Binding<String> name;", // For field.
+            "  public Field$B$$InjectAdapter() {",
+            "    super(\"Field$B\", \"members/Field$B\", NOT_SINGLETON, Field.B.class);",
+            "  }",
+            "  @Override @SuppressWarnings(\"unchecked\")",
+            "  public void attach(Linker linker) {",
+            "    name = (Binding<String>)linker.requestBinding(",
+            "      \"java.lang.String\", Field.B.class, getClass().getClassLoader());",
+            "  }",
+            "  @Override public void getDependencies(",
+            "      Set<Binding<?>> getBindings, Set<Binding<?>> injectMembersBindings) {",
+            "    injectMembersBindings.add(name);", // Name is added to dependencies.
+            "  }",
+            "  @Override public Field.B get() {",
+            "    Field.B result = new Field.B();",
+            "    injectMembers(result);",
+            "    return result;",
+            "  }",
+            "  @Override public void injectMembers(Field.B object) {",
+            "    object.name = name.get();", // Inject field.
+            "  }",
+            "}"));
+    ASSERT.about(javaSource()).that(sourceFile).processedWith(daggerProcessors())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(expectedModuleAdapter, expectedInjectAdapterA, expectedInjectAdapterB);
+  }
+
+
+  @Test public void providesHasParameterNamedModule() {
+    JavaFileObject a = JavaFileObjects.forSourceString("A", Joiner.on("\n").join(
+        "import javax.inject.Inject;",
+        "class A { @Inject A(){ }}"));
+    JavaFileObject b = JavaFileObjects.forSourceString("B", Joiner.on("\n").join(
+        "import javax.inject.Inject;",
+        "class B { @Inject B(){ }}"));
+
+    JavaFileObject module = JavaFileObjects.forSourceString("BModule", Joiner.on("\n").join(
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "@Module(injects = B.class)",
+        "class BModule { @Provides B b(A module) { return new B(); }}"));
+
+    ASSERT.about(javaSources()).that(asList(a, b, module)).processedWith(daggerProcessors())
+        .compilesWithoutError();
+  }
+
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/PrimitiveInjectionTest.java b/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
similarity index 98%
rename from compiler/src/test/java/dagger/internal/codegen/PrimitiveInjectionTest.java
rename to compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
index adeea2a75..5f7451c6b 100644
--- a/compiler/src/test/java/dagger/internal/codegen/PrimitiveInjectionTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.codegen;
+package dagger.tests.integration.operation;
 
 import dagger.Module;
 import dagger.ObjectGraph;
diff --git a/compiler/src/test/java/dagger/tests/integration/operation/SimpleInjectionTest.java b/compiler/src/test/java/dagger/tests/integration/operation/SimpleInjectionTest.java
new file mode 100644
index 000000000..994c7800b
--- /dev/null
+++ b/compiler/src/test/java/dagger/tests/integration/operation/SimpleInjectionTest.java
@@ -0,0 +1,90 @@
+/**
+ * Copyright (C) 2013 Google, Inc.
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.tests.integration.operation;
+
+import dagger.Module;
+import dagger.ObjectGraph;
+import dagger.Provides;
+import javax.inject.Inject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static org.truth0.Truth.ASSERT;
+
+@RunWith(JUnit4.class)
+public final class SimpleInjectionTest {
+  static abstract class AbstractFoo {
+    @Inject String blah;
+  }
+
+  static class Foo extends AbstractFoo { }
+
+  @Module(injects = Foo.class)
+  static class FooModule {
+    @Provides String string() { return "blah"; }
+  }
+
+  @Module(injects = Foo.class)
+  static class ProvidingFooModule {
+    @Provides String string() { return "blah"; }
+    @Provides Foo foo(String blah) {
+      Foo foo = new Foo();
+      foo.blah = blah;
+      return foo;
+    }
+  }
+
+  @Test public void memberInject_WithoutProvidesMethod() {
+    Foo foo = new Foo();
+    ObjectGraph.create(FooModule.class).inject(foo);
+    ASSERT.that(foo.blah).equals("blah");
+  }
+
+  @Test public void membersInject_WithProvidesMethod() {
+    Foo foo = new Foo();
+    ObjectGraph.create(ProvidingFooModule.class).inject(foo);
+    ASSERT.that(foo.blah).equals("blah");
+  }
+
+  @Test public void get_WithProvidesMethod() {
+    Foo foo = ObjectGraph.create(ProvidingFooModule.class).get(Foo.class);
+    ASSERT.that(foo.blah).equals("blah");
+  }
+
+  static class Bar { }
+
+  @Module(injects = Bar.class)
+  static class BarModule {
+  }
+
+  @Test public void membersInject_WithNonInjectable() {
+    Bar bar = new Bar();
+    ObjectGraph.create(BarModule.class).inject(bar);
+  }
+
+  @Module(injects = Bar.class)
+  static class ProvidingBarModule {
+    @Provides public Bar bar() { return new Bar(); }
+  }
+
+  @Test public void membersInject_WithProvidedNonInjectable() {
+    Bar bar = ObjectGraph.create(ProvidingBarModule.class).get(Bar.class);
+    ASSERT.that(bar).isNotNull();
+  }
+
+}
diff --git a/core/pom.xml b/core/pom.xml
index d09c41e2a..9e4eae409 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.google.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.1.1-SNAPSHOT</version>
+    <version>1.2.1-SNAPSHOT</version>
   </parent>
 
   <artifactId>dagger</artifactId>
diff --git a/core/src/main/java/dagger/ObjectGraph.java b/core/src/main/java/dagger/ObjectGraph.java
index e5d542833..a1736d2b8 100644
--- a/core/src/main/java/dagger/ObjectGraph.java
+++ b/core/src/main/java/dagger/ObjectGraph.java
@@ -184,8 +184,8 @@ private static ObjectGraph makeGraph(DaggerObjectGraph base, Loader plugin, Obje
           BindingsGroup addTo = moduleAdapter.overrides ? overrideBindings : baseBindings;
           moduleAdapter.getBindings(addTo, loadedModule.getValue());
         } catch (IllegalArgumentException e) {
-          throw new IllegalArgumentException(moduleAdapter.moduleClass.getSimpleName()
-              + " is an overriding module and cannot contribute set bindings.");
+          throw new IllegalArgumentException(
+              moduleAdapter.moduleClass.getSimpleName() + ": " + e.getMessage(), e);
         }
       }
 
diff --git a/core/src/main/java/dagger/internal/BindingsGroup.java b/core/src/main/java/dagger/internal/BindingsGroup.java
index 4bd21b735..861f7de86 100644
--- a/core/src/main/java/dagger/internal/BindingsGroup.java
+++ b/core/src/main/java/dagger/internal/BindingsGroup.java
@@ -16,7 +16,7 @@
  */
 package dagger.internal;
 
-import java.util.HashMap;
+import java.util.LinkedHashMap;
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Set;
@@ -26,7 +26,7 @@
  * the initial set of bindings for a graph (from provides methods).
  */
 public abstract class BindingsGroup {
-  private final Map<String, Binding<?>> bindings = new HashMap<String, Binding<?>>();
+  private final Map<String, Binding<?>> bindings = new LinkedHashMap<String, Binding<?>>();
 
   public abstract Binding<?> contributeSetBinding(String key, SetBinding<?> value);
 
diff --git a/core/src/main/java/dagger/internal/Keys.java b/core/src/main/java/dagger/internal/Keys.java
index 0a2a78759..fb65cc67b 100644
--- a/core/src/main/java/dagger/internal/Keys.java
+++ b/core/src/main/java/dagger/internal/Keys.java
@@ -35,7 +35,7 @@
  *       qualified by the annotation.
  *   <li>{@code members/com.square.Foo}: injects members of Foo.
  * </ol>
- * BindingsGroup from {@code @Provides} methods are of the first two types. BindingsGroup
+ * Bindings from {@code @Provides} methods are of the first two types. BindingsGroup
  * created from {@code @Inject}-annotated members of a class are of the first
  * and last types.
  */
diff --git a/core/src/main/java/dagger/internal/Linker.java b/core/src/main/java/dagger/internal/Linker.java
index bea961eda..795a59e5a 100644
--- a/core/src/main/java/dagger/internal/Linker.java
+++ b/core/src/main/java/dagger/internal/Linker.java
@@ -16,13 +16,13 @@
 package dagger.internal;
 
 import dagger.internal.Binding.InvalidBindingException;
+import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Collections;
+import java.util.Deque;
 import java.util.HashMap;
-import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
-import java.util.Queue;
 import java.util.Set;
 
 /**
@@ -38,8 +38,8 @@
    */
   private final Linker base;
 
-  /** BindingsGroup requiring a call to attach(). May contain deferred bindings. */
-  private final Queue<Binding<?>> toLink = new LinkedList<Binding<?>>();
+  /** Bindings requiring a call to attach(). May contain deferred bindings. */
+  private final Deque<Binding<?>> toLink = new ArrayDeque<Binding<?>>();
 
   /** True unless calls to requestBinding() were unable to satisfy the binding. */
   private boolean attachSuccess = true;
@@ -139,18 +139,18 @@ public void linkRequested() {
           continue; // A binding for this key has since been linked.
         }
         try {
-          Binding<?> jitBinding =
-              createJitBinding(key, binding.requiredBy, deferred.classLoader, mustHaveInjections);
-          jitBinding.setLibrary(binding.library());
-          jitBinding.setDependedOn(binding.dependedOn());
+          Binding<?> resolvedBinding =
+              createBinding(key, binding.requiredBy, deferred.classLoader, mustHaveInjections);
+          resolvedBinding.setLibrary(binding.library());
+          resolvedBinding.setDependedOn(binding.dependedOn());
           // Fail if the type of binding we got wasn't capable of what was requested.
-          if (!key.equals(jitBinding.provideKey) && !key.equals(jitBinding.membersKey)) {
+          if (!key.equals(resolvedBinding.provideKey) && !key.equals(resolvedBinding.membersKey)) {
             throw new IllegalStateException("Unable to create binding for " + key);
           }
           // Enqueue the JIT binding so its own dependencies can be linked.
-          Binding<?> scopedJitBinding = scope(jitBinding);
-          toLink.add(scopedJitBinding);
-          putBinding(scopedJitBinding);
+          Binding<?> scopedBinding = scope(resolvedBinding);
+          toLink.add(scopedBinding);
+          putBinding(scopedBinding);
         } catch (InvalidBindingException e) {
           addError(e.type + " " + e.getMessage() + " required by " + binding.requiredBy);
           bindings.put(key, Binding.UNRESOLVED);
@@ -196,16 +196,17 @@ private void assertLockHeld() {
   }
 
   /**
-   * Creates a just-in-time binding for the key in {@code deferred}. The type of binding
+   * Returns a binding for the key in {@code deferred}. The type of binding
    * to be created depends on the key's type:
    * <ul>
    *   <li>Injections of {@code Provider<Foo>}, {@code MembersInjector<Bar>}, and
    *       {@code Lazy<Blah>} will delegate to the bindings of {@code Foo}, {@code Bar}, and
    *       {@code Blah} respectively.
-   *   <li>Injections of other types will use the injectable constructors of those classes.
+   *   <li>Injections of raw types will use the injectable constructors of those classes.
+   *   <li>Any other injection types require @Provides bindings and will error out.
    * </ul>
    */
-  private Binding<?> createJitBinding(String key, Object requiredBy, ClassLoader classLoader,
+  private Binding<?> createBinding(String key, Object requiredBy, ClassLoader classLoader,
       boolean mustHaveInjections) {
     String builtInBindingsKey = Keys.getBuiltInBindingsKey(key);
     if (builtInBindingsKey != null) {
@@ -217,12 +218,14 @@ private void assertLockHeld() {
     }
 
     String className = Keys.getClassName(key);
-    if (className != null && !Keys.isAnnotated(key)) {
-      Binding<?> binding =
-          plugin.getAtInjectBinding(key, className, classLoader, mustHaveInjections);
-      if (binding != null) {
-        return binding;
-      }
+    if (className == null || Keys.isAnnotated(key)) {
+      // Cannot jit-bind annotated keys or generic types.
+      throw new IllegalArgumentException(key);
+    }
+    Binding<?> binding =
+        plugin.getAtInjectBinding(key, className, classLoader, mustHaveInjections);
+    if (binding != null) {
+      return binding;
     }
     throw new InvalidBindingException(className, "could not be bound with key " + key);
   }
diff --git a/core/src/main/java/dagger/internal/SetBinding.java b/core/src/main/java/dagger/internal/SetBinding.java
index 92d02adf6..af3729061 100644
--- a/core/src/main/java/dagger/internal/SetBinding.java
+++ b/core/src/main/java/dagger/internal/SetBinding.java
@@ -103,7 +103,8 @@ public int size() {
   @Override public Set<T> get() {
     List<T> result = new ArrayList<T>();
     for (SetBinding<T> setBinding = this; setBinding != null; setBinding = setBinding.parent) {
-      for (Binding<?> contributor : setBinding.contributors) {
+      for (int i = 0, size = setBinding.contributors.size(); i < size; i++) {
+        Binding<?> contributor = setBinding.contributors.get(i);
         Object contribution = contributor.get(); // Let runtime exceptions through.
         if (contributor.provideKey.equals(provideKey)) {
           result.addAll((Set<T>) contribution);
@@ -130,11 +131,11 @@ public int size() {
     boolean first = true;
     StringBuilder builder = new StringBuilder("SetBinding[");
     for (SetBinding<T> setBinding = this; setBinding != null; setBinding = setBinding.parent) {
-      for (Binding<?> contributor : setBinding.contributors) {
+      for (int i = 0, size = setBinding.contributors.size(); i < size; i++) {
         if (!first) {
           builder.append(",");
         }
-        builder.append(contributor);
+        builder.append(setBinding.contributors.get(i));
         first = false;
       }
     }
diff --git a/core/src/test/java/dagger/ExtensionWithSetBindingsTest.java b/core/src/test/java/dagger/ExtensionWithSetBindingsTest.java
index 30b4929b0..2a629536c 100644
--- a/core/src/test/java/dagger/ExtensionWithSetBindingsTest.java
+++ b/core/src/test/java/dagger/ExtensionWithSetBindingsTest.java
@@ -28,6 +28,7 @@
 import static dagger.Provides.Type.SET;
 import static org.fest.assertions.Assertions.assertThat;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 @RunWith(JUnit4.class)
@@ -56,6 +57,16 @@
     @Provides(type=SET) @Singleton Integer provideD() { return counter.getAndIncrement(); }
   }
 
+  @Module
+  static class EmptyModule {
+  }
+
+  @Module(library = true)
+  static class DuplicateModule {
+    @Provides @Singleton String provideFoo() { return "foo"; }
+    @Provides @Singleton String provideBar() { return "bar"; }
+  }
+
   @Test public void basicInjectionWithExtension() {
     ObjectGraph root = ObjectGraph.createWith(new TestingLoader(), new RootModule());
     RealSingleton rs = root.get(RealSingleton.class);
@@ -81,8 +92,16 @@
       ObjectGraph.createWith(new TestingLoader(), new RootModule()).plus(new TestModule());
       fail("Should throw exception.");
     } catch (IllegalArgumentException e) {
-      assertEquals("TestModule is an overriding module and cannot contribute set bindings.",
-          e.getMessage());
+      assertEquals("TestModule: Module overrides cannot contribute set bindings.", e.getMessage());
+    }
+  }
+
+  @Test public void duplicateBindingsInSecondaryModule() {
+    try {
+      ObjectGraph.createWith(new TestingLoader(), new EmptyModule(), new DuplicateModule());
+      fail("Should throw exception.");
+    } catch (IllegalArgumentException e) {
+      assertTrue(e.getMessage().startsWith("DuplicateModule: Duplicate"));
     }
   }
 }
diff --git a/examples/android-activity-graphs/pom.xml b/examples/android-activity-graphs/pom.xml
index a1e95163d..fa533d1a4 100644
--- a/examples/android-activity-graphs/pom.xml
+++ b/examples/android-activity-graphs/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.google.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.1.1-SNAPSHOT</version>
+    <version>1.2.1-SNAPSHOT</version>
   </parent>
 
   <artifactId>android-activity-graphs</artifactId>
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ActivityModule.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ActivityModule.java
index 465d66d5d..2f9587c05 100644
--- a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ActivityModule.java
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ActivityModule.java
@@ -33,7 +33,7 @@
         HomeActivity.class,
         HomeFragment.class
     },
-    complete = false,
+    addsTo = AndroidModule.class,
     library = true
 )
 public class ActivityModule {
diff --git a/examples/android-simple/pom.xml b/examples/android-simple/pom.xml
index 6b6109817..9f81e748f 100644
--- a/examples/android-simple/pom.xml
+++ b/examples/android-simple/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.google.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.1.1-SNAPSHOT</version>
+    <version>1.2.1-SNAPSHOT</version>
   </parent>
 
   <artifactId>android-simple</artifactId>
diff --git a/examples/pom.xml b/examples/pom.xml
index 6364c821a..6b19aa96a 100644
--- a/examples/pom.xml
+++ b/examples/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>com.google.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.1.1-SNAPSHOT</version>
+    <version>1.2.1-SNAPSHOT</version>
   </parent>
 
   <groupId>com.google.dagger.example</groupId>
@@ -70,7 +70,7 @@
         <plugin>
           <groupId>com.jayway.maven.plugins.android.generation2</groupId>
           <artifactId>android-maven-plugin</artifactId>
-          <version>3.6.0</version>
+          <version>3.8.0</version>
           <configuration>
             <sdk>
               <platform>16</platform>
diff --git a/examples/simple/pom.xml b/examples/simple/pom.xml
index 42c25ac8b..319cc45ad 100644
--- a/examples/simple/pom.xml
+++ b/examples/simple/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.google.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.1.1-SNAPSHOT</version>
+    <version>1.2.1-SNAPSHOT</version>
   </parent>
 
   <artifactId>simple</artifactId>
diff --git a/pom.xml b/pom.xml
index 258b35773..78c4f5d18 100644
--- a/pom.xml
+++ b/pom.xml
@@ -26,10 +26,10 @@
   <groupId>com.google.dagger</groupId>
   <artifactId>dagger-parent</artifactId>
   <packaging>pom</packaging>
-  <version>1.1.1-SNAPSHOT</version>
+  <version>1.2.1-SNAPSHOT</version>
   <name>Dagger (Parent)</name>
-  <description>A JSR-330 dependency injector for Android and Java.</description>
-  <url>https://github.com/google/dagger</url>
+  <description>A fast dependency injector for Android and Java.</description>
+  <url>https://github.com/square/dagger</url>
 
   <modules>
     <module>compiler</module>
@@ -43,11 +43,14 @@
     <!-- Compilation -->
     <java.version>1.6</java.version>
     <javax.inject.version>1</javax.inject.version>
-    <javawriter.version>2.1.1</javawriter.version>
+    <javawriter.version>2.3.0</javawriter.version>
+    <guava.version>15.0</guava.version>
 
     <!-- Test Dependencies -->
     <junit.version>4.10</junit.version>
     <fest.version>1.4</fest.version>
+    <truth.version>0.13</truth.version>
+    <compile-testing.version>0.4</compile-testing.version>
   </properties>
 
   <scm>
@@ -86,6 +89,11 @@
         <artifactId>javawriter</artifactId>
         <version>${javawriter.version}</version>
       </dependency>
+      <dependency>
+        <groupId>com.google.guava</groupId>
+        <artifactId>guava</artifactId>
+        <version>${guava.version}</version>
+      </dependency>
       <dependency>
         <groupId>junit</groupId>
         <artifactId>junit</artifactId>
@@ -96,6 +104,16 @@
         <artifactId>fest-assert</artifactId>
         <version>${fest.version}</version>
       </dependency>
+      <dependency>
+        <groupId>com.google.testing.compile</groupId>
+        <artifactId>compile-testing</artifactId>
+        <version>${compile-testing.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>org.truth0</groupId>
+        <artifactId>truth</artifactId>
+        <version>${truth.version}</version>
+      </dependency>
     </dependencies>
   </dependencyManagement>
 
