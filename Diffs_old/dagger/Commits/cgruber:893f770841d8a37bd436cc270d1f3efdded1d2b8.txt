diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/Subcomponents.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/Subcomponents.java
index 3ebd6078d..b998c5a3d 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/Subcomponents.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/Subcomponents.java
@@ -51,7 +51,7 @@ static String fromParent() {
   interface ParentComponent {
     InjectsChildBuilder injectsChildBuilder();
 
-    ChildComponent.Builder newChildComponentBuilder();
+    ChildComponentWithExecutor.Builder newChildComponentBuilder();
   }
 
   @ProducerModule
@@ -84,23 +84,36 @@ static String fromChild(@FromParent String fromParent) {
 
     GrandchildComponent.Builder newGrandchildComponentBuilder();
 
+    @ProductionSubcomponent.Builder
+    interface Builder {
+      ChildComponent build();
+    }
+  }
+
+  @ProductionSubcomponent(modules = ChildProducerModule.class)
+  interface ChildComponentWithExecutor {
+    @FromChild
+    ListenableFuture<String> fromChild();
+
+    GrandchildComponent.Builder newGrandchildComponentBuilder();
+
     @ProductionSubcomponent.Builder
     interface Builder {
       Builder executor(Executor executor);
 
-      ChildComponent build();
+      ChildComponentWithExecutor build();
     }
   }
 
   static final class InjectsChildBuilder {
-    private final Provider<ChildComponent.Builder> childBuilder;
+    private final Provider<ChildComponentWithExecutor.Builder> childBuilder;
 
     @Inject
-    InjectsChildBuilder(Provider<ChildComponent.Builder> childBuilder) {
+    InjectsChildBuilder(Provider<ChildComponentWithExecutor.Builder> childBuilder) {
       this.childBuilder = childBuilder;
     }
 
-    ChildComponent.Builder childBuilder() {
+    ChildComponentWithExecutor.Builder childBuilder() {
       return childBuilder.get();
     }
   }
@@ -121,8 +134,6 @@ static String fromGranchild(@FromChild String fromChild) {
 
     @ProductionSubcomponent.Builder
     interface Builder {
-      Builder executor(Executor executor);
-
       GrandchildComponent build();
     }
   }
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/SubcomponentsWithBoundExecutor.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/SubcomponentsWithBoundExecutor.java
new file mode 100644
index 000000000..0e0fae51d
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/SubcomponentsWithBoundExecutor.java
@@ -0,0 +1,168 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.subcomponent;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.Component;
+import dagger.Module;
+import dagger.Provides;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import dagger.producers.Production;
+import dagger.producers.ProductionComponent;
+import dagger.producers.ProductionSubcomponent;
+import java.util.concurrent.Executor;
+import java.util.concurrent.atomic.AtomicInteger;
+import javax.inject.Inject;
+import javax.inject.Provider;
+import javax.inject.Qualifier;
+
+final class SubcomponentsWithBoundExecutor {
+  @Qualifier
+  @interface FromParent {}
+
+  @Qualifier
+  @interface FromChild {}
+
+  @Qualifier
+  @interface FromGrandchild {}
+
+  static final class CountingExecutor implements Executor {
+    private final AtomicInteger executionCount;
+
+    CountingExecutor(AtomicInteger executionCount) {
+      this.executionCount = executionCount;
+    }
+
+    @Override
+    public void execute(Runnable runnable) {
+      executionCount.incrementAndGet();
+      runnable.run();
+    }
+  }
+
+  @Module
+  static final class ExecutorModule {
+    private final AtomicInteger constructionCount;
+    private final AtomicInteger executionCount;
+
+    ExecutorModule(AtomicInteger constructionCount, AtomicInteger executionCount) {
+      this.constructionCount = constructionCount;
+      this.executionCount = executionCount;
+    }
+
+    @Provides
+    @Production
+    Executor executor() {
+      constructionCount.incrementAndGet();
+      return new CountingExecutor(executionCount);
+    }
+  }
+
+  @Module
+  static final class ParentModule {
+    @Provides
+    @FromParent
+    static String fromParent() {
+      return "parent";
+    }
+  }
+
+  @Component(modules = {ParentModule.class, ExecutorModule.class})
+  interface ParentComponent {
+    InjectsChildBuilder injectsChildBuilder();
+
+    ChildComponent.Builder newChildComponentBuilder();
+  }
+
+  @ProducerModule
+  static final class ParentProducerModule {
+    @Produces
+    @FromParent
+    static String fromParent() {
+      return "parentproduction";
+    }
+  }
+
+  @ProductionComponent(modules = {ParentProducerModule.class, ExecutorModule.class})
+  interface ParentProductionComponent {
+    ChildComponent.Builder newChildComponentBuilder();
+
+    @ProductionComponent.Builder
+    interface Builder {
+      Builder executorModule(ExecutorModule executorModule);
+
+      ParentProductionComponent build();
+    }
+  }
+
+  @ProducerModule
+  static final class ChildProducerModule {
+    @Produces
+    @FromChild
+    static String fromChild(@FromParent String fromParent) {
+      return "child:" + fromParent;
+    }
+  }
+
+  @ProductionSubcomponent(modules = ChildProducerModule.class)
+  interface ChildComponent {
+    @FromChild
+    ListenableFuture<String> fromChild();
+
+    GrandchildComponent.Builder newGrandchildComponentBuilder();
+
+    @ProductionSubcomponent.Builder
+    interface Builder {
+      ChildComponent build();
+    }
+  }
+
+  static final class InjectsChildBuilder {
+    private final Provider<ChildComponent.Builder> childBuilder;
+
+    @Inject
+    InjectsChildBuilder(Provider<ChildComponent.Builder> childBuilder) {
+      this.childBuilder = childBuilder;
+    }
+
+    ChildComponent.Builder childBuilder() {
+      return childBuilder.get();
+    }
+  }
+
+  @ProducerModule
+  static final class GrandchildProducerModule {
+    @Produces
+    @FromGrandchild
+    static String fromGranchild(@FromChild String fromChild) {
+      return "grandchild:" + fromChild;
+    }
+  }
+
+  @ProductionSubcomponent(modules = GrandchildProducerModule.class)
+  interface GrandchildComponent {
+    @FromGrandchild
+    ListenableFuture<String> fromGrandchild();
+
+    @ProductionSubcomponent.Builder
+    interface Builder {
+      GrandchildComponent build();
+    }
+  }
+
+  private SubcomponentsWithBoundExecutor() {}
+}
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/ProducerFactoryTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/ProducerFactoryTest.java
index 9a5602990..67d47ead5 100644
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/ProducerFactoryTest.java
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/ProducerFactoryTest.java
@@ -1,18 +1,18 @@
 /*
-* Copyright (C) 2015 Google, Inc.
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package producerstest;
 
 import com.google.common.util.concurrent.ListenableFuture;
@@ -23,6 +23,7 @@
 import dagger.producers.monitoring.ProducerToken;
 import dagger.producers.monitoring.ProductionComponentMonitor;
 import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Executor;
 import javax.inject.Provider;
 import org.junit.Before;
 import org.junit.Test;
@@ -43,6 +44,7 @@
 public class ProducerFactoryTest {
   @Mock private ProductionComponentMonitor componentMonitor;
   private ProducerMonitor monitor;
+  private Provider<Executor> executorProvider;
   private Provider<ProductionComponentMonitor> componentMonitorProvider;
 
   @Before
@@ -50,6 +52,14 @@ public void setUpMocks() {
     MockitoAnnotations.initMocks(this);
     monitor = Mockito.mock(ProducerMonitor.class, Mockito.CALLS_REAL_METHODS);
     when(componentMonitor.producerMonitorFor(any(ProducerToken.class))).thenReturn(monitor);
+    // TODO(beder): Use Providers.of when available.
+    executorProvider =
+        new Provider<Executor>() {
+          @Override
+          public Executor get() {
+            return MoreExecutors.directExecutor();
+          }
+        };
     componentMonitorProvider =
         new Provider<ProductionComponentMonitor>() {
           @Override
@@ -63,8 +73,7 @@ public ProductionComponentMonitor get() {
   public void noArgMethod() throws Exception {
     ProducerToken token = ProducerToken.create(SimpleProducerModule_StrFactory.class);
     Producer<String> producer =
-        new SimpleProducerModule_StrFactory(
-            MoreExecutors.directExecutor(), componentMonitorProvider);
+        new SimpleProducerModule_StrFactory(executorProvider, componentMonitorProvider);
     assertThat(producer.get().get()).isEqualTo("str");
     InOrder order = inOrder(componentMonitor, monitor);
     order.verify(componentMonitor).producerMonitorFor(token);
@@ -74,12 +83,13 @@ public void noArgMethod() throws Exception {
     order.verifyNoMoreInteractions();
   }
 
-  @Test public void singleArgMethod() throws Exception {
+  @Test
+  public void singleArgMethod() throws Exception {
     SettableFuture<Integer> intFuture = SettableFuture.create();
     Producer<Integer> intProducer = producerOfFuture(intFuture);
     Producer<String> producer =
         new SimpleProducerModule_StrWithArgFactory(
-            MoreExecutors.directExecutor(), componentMonitorProvider, intProducer);
+            executorProvider, componentMonitorProvider, intProducer);
     assertThat(producer.get().isDone()).isFalse();
     intFuture.set(42);
     assertThat(producer.get().get()).isEqualTo("str with arg");
@@ -94,7 +104,7 @@ public void successMonitor() throws Exception {
     Producer<SettableFuture<String>> strFutureProducer = producerOfFuture(strFutureFuture);
     Producer<String> producer =
         new SimpleProducerModule_SettableFutureStrFactory(
-            MoreExecutors.directExecutor(), componentMonitorProvider, strFutureProducer);
+            executorProvider, componentMonitorProvider, strFutureProducer);
     assertThat(producer.get().isDone()).isFalse();
 
     InOrder order = inOrder(componentMonitor, monitor);
@@ -121,7 +131,7 @@ public void failureMonitor() throws Exception {
     Producer<SettableFuture<String>> strFutureProducer = producerOfFuture(strFutureFuture);
     Producer<String> producer =
         new SimpleProducerModule_SettableFutureStrFactory(
-            MoreExecutors.directExecutor(), componentMonitorProvider, strFutureProducer);
+            executorProvider, componentMonitorProvider, strFutureProducer);
     assertThat(producer.get().isDone()).isFalse();
 
     InOrder order = inOrder(componentMonitor, monitor);
@@ -151,7 +161,7 @@ public void failureMonitorDueToThrowingProducer() throws Exception {
 
     Producer<String> producer =
         new SimpleProducerModule_ThrowingProducerFactory(
-            MoreExecutors.directExecutor(), componentMonitorProvider);
+            executorProvider, componentMonitorProvider);
     assertThat(producer.get().isDone()).isTrue();
 
     InOrder order = inOrder(componentMonitor, monitor);
@@ -172,12 +182,13 @@ public void failureMonitorDueToThrowingProducer() throws Exception {
 
   @Test(expected = NullPointerException.class)
   public void nullComponentMonitorProvider() throws Exception {
-    new SimpleProducerModule_StrFactory(MoreExecutors.directExecutor(), null);
+    new SimpleProducerModule_StrFactory(executorProvider, null);
   }
 
   private static <T> Producer<T> producerOfFuture(final ListenableFuture<T> future) {
     return new Producer<T>() {
-      @Override public ListenableFuture<T> get() {
+      @Override
+      public ListenableFuture<T> get() {
         return future;
       }
     };
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/SubcomponentTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/SubcomponentTest.java
index ef15bdd23..ddd43403e 100644
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/SubcomponentTest.java
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/SubcomponentTest.java
@@ -23,6 +23,7 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 import producerstest.subcomponent.Subcomponents.ChildComponent;
+import producerstest.subcomponent.Subcomponents.ChildComponentWithExecutor;
 import producerstest.subcomponent.Subcomponents.GrandchildComponent;
 import producerstest.subcomponent.Subcomponents.ParentComponent;
 import producerstest.subcomponent.Subcomponents.ParentProductionComponent;
@@ -33,7 +34,7 @@
   public void topLevelComponent_child() throws Exception {
     Executor executor = MoreExecutors.directExecutor();
     ParentComponent parent = DaggerSubcomponents_ParentComponent.create();
-    ChildComponent child = parent.newChildComponentBuilder().executor(executor).build();
+    ChildComponentWithExecutor child = parent.newChildComponentBuilder().executor(executor).build();
     assertThat(child.fromChild().get()).isEqualTo("child:parent");
   }
 
@@ -41,7 +42,8 @@ public void topLevelComponent_child() throws Exception {
   public void topLevelComponent_injectsChildBuilder() throws Exception {
     Executor executor = MoreExecutors.directExecutor();
     ParentComponent parent = DaggerSubcomponents_ParentComponent.create();
-    ChildComponent child = parent.injectsChildBuilder().childBuilder().executor(executor).build();
+    ChildComponentWithExecutor child =
+        parent.injectsChildBuilder().childBuilder().executor(executor).build();
     assertThat(child.fromChild().get()).isEqualTo("child:parent");
   }
 
@@ -49,9 +51,8 @@ public void topLevelComponent_injectsChildBuilder() throws Exception {
   public void topLevelComponent_grandchild() throws Exception {
     Executor executor = MoreExecutors.directExecutor();
     ParentComponent parent = DaggerSubcomponents_ParentComponent.create();
-    ChildComponent child = parent.newChildComponentBuilder().executor(executor).build();
-    GrandchildComponent grandchild =
-        child.newGrandchildComponentBuilder().executor(executor).build();
+    ChildComponentWithExecutor child = parent.newChildComponentBuilder().executor(executor).build();
+    GrandchildComponent grandchild = child.newGrandchildComponentBuilder().build();
     assertThat(grandchild.fromGrandchild().get()).isEqualTo("grandchild:child:parent");
   }
 
@@ -60,7 +61,7 @@ public void topLevelProductionComponent_child() throws Exception {
     Executor executor = MoreExecutors.directExecutor();
     ParentProductionComponent parent =
         DaggerSubcomponents_ParentProductionComponent.builder().executor(executor).build();
-    ChildComponent child = parent.newChildComponentBuilder().executor(executor).build();
+    ChildComponent child = parent.newChildComponentBuilder().build();
     assertThat(child.fromChild().get()).isEqualTo("child:parentproduction");
   }
 
@@ -69,9 +70,8 @@ public void topLevelProductionComponent_grandchild() throws Exception {
     Executor executor = MoreExecutors.directExecutor();
     ParentProductionComponent parent =
         DaggerSubcomponents_ParentProductionComponent.builder().executor(executor).build();
-    ChildComponent child = parent.newChildComponentBuilder().executor(executor).build();
-    GrandchildComponent grandchild =
-        child.newGrandchildComponentBuilder().executor(executor).build();
+    ChildComponent child = parent.newChildComponentBuilder().build();
+    GrandchildComponent grandchild = child.newGrandchildComponentBuilder().build();
     assertThat(grandchild.fromGrandchild().get()).isEqualTo("grandchild:child:parentproduction");
   }
 }
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/SubcomponentWithBoundExecutorTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/SubcomponentWithBoundExecutorTest.java
new file mode 100644
index 000000000..389a8d4b6
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/SubcomponentWithBoundExecutorTest.java
@@ -0,0 +1,91 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.subcomponent;
+
+import java.util.concurrent.atomic.AtomicInteger;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import producerstest.subcomponent.SubcomponentsWithBoundExecutor.ChildComponent;
+import producerstest.subcomponent.SubcomponentsWithBoundExecutor.ExecutorModule;
+import producerstest.subcomponent.SubcomponentsWithBoundExecutor.GrandchildComponent;
+import producerstest.subcomponent.SubcomponentsWithBoundExecutor.ParentComponent;
+import producerstest.subcomponent.SubcomponentsWithBoundExecutor.ParentProductionComponent;
+
+import static com.google.common.truth.Truth.assertThat;
+
+@RunWith(JUnit4.class)
+public final class SubcomponentWithBoundExecutorTest {
+  private ParentComponent parentComponent;
+  private ParentProductionComponent parentProductionComponent;
+  private final AtomicInteger executorConstructionCount = new AtomicInteger();
+  private final AtomicInteger executionCount = new AtomicInteger();
+
+  @Before
+  public void setUp() {
+    parentComponent =
+        DaggerSubcomponentsWithBoundExecutor_ParentComponent.builder()
+            .executorModule(new ExecutorModule(executorConstructionCount, executionCount))
+            .build();
+    parentProductionComponent =
+        DaggerSubcomponentsWithBoundExecutor_ParentProductionComponent.builder()
+            .executorModule(new ExecutorModule(executorConstructionCount, executionCount))
+            .build();
+  }
+
+  @Test
+  public void topLevelComponent_child() throws Exception {
+    ChildComponent child = parentComponent.newChildComponentBuilder().build();
+    assertThat(child.fromChild().get()).isEqualTo("child:parent");
+    assertThat(executorConstructionCount.get()).isEqualTo(1);
+    assertThat(executionCount.get()).isEqualTo(1);
+  }
+
+  @Test
+  public void topLevelComponent_injectsChildBuilder() throws Exception {
+    ChildComponent child = parentComponent.injectsChildBuilder().childBuilder().build();
+    assertThat(child.fromChild().get()).isEqualTo("child:parent");
+    assertThat(executorConstructionCount.get()).isEqualTo(1);
+    assertThat(executionCount.get()).isEqualTo(1);
+  }
+
+  @Test
+  public void topLevelComponent_grandchild() throws Exception {
+    ChildComponent child = parentComponent.newChildComponentBuilder().build();
+    GrandchildComponent grandchild = child.newGrandchildComponentBuilder().build();
+    assertThat(grandchild.fromGrandchild().get()).isEqualTo("grandchild:child:parent");
+    assertThat(executorConstructionCount.get()).isEqualTo(1);
+    assertThat(executionCount.get()).isEqualTo(2);
+  }
+
+  @Test
+  public void topLevelProductionComponent_child() throws Exception {
+    ChildComponent child = parentProductionComponent.newChildComponentBuilder().build();
+    assertThat(child.fromChild().get()).isEqualTo("child:parentproduction");
+    assertThat(executorConstructionCount.get()).isEqualTo(1);
+    assertThat(executionCount.get()).isEqualTo(2);
+  }
+
+  @Test
+  public void topLevelProductionComponent_grandchild() throws Exception {
+    ChildComponent child = parentProductionComponent.newChildComponentBuilder().build();
+    GrandchildComponent grandchild = child.newGrandchildComponentBuilder().build();
+    assertThat(grandchild.fromGrandchild().get()).isEqualTo("grandchild:child:parentproduction");
+    assertThat(executorConstructionCount.get()).isEqualTo(1);
+    assertThat(executionCount.get()).isEqualTo(3);
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 1f130da49..3c37f1a99 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -932,6 +932,14 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
               : factoryCreate;
         }
 
+      case EXECUTOR_DEPENDENCY:
+        return CodeBlocks.format(
+            "$T.<$T>create($L)",
+            INSTANCE_FACTORY,
+            bindingKeyTypeName,
+            getComponentContributionExpression(
+                graph.componentDescriptor().executorDependency().get()));
+
       case COMPONENT_PRODUCTION:
         {
           TypeElement bindingTypeElement =
@@ -962,9 +970,6 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
           if (!binding.bindingElement().getModifiers().contains(STATIC)) {
             arguments.add(getComponentContributionExpression(binding.bindingTypeElement()));
           }
-          arguments.add(
-              getComponentContributionExpression(
-                  graph.componentDescriptor().executorDependency().get()));
           arguments.addAll(getDependencyArguments(binding));
 
           return CodeBlocks.format(
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index 1a627649c..869af2334 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -197,6 +197,12 @@ private BindingGraph create(
       TypeElement componentDefinitionType = componentDescriptor.componentDefinitionType();
       explicitBindingsBuilder.add(provisionBindingFactory.forComponent(componentDefinitionType));
 
+      // immediate binding for the executor, if it's provided to the builder
+      if (componentDescriptor.executorDependency().isPresent()) {
+        explicitBindingsBuilder.add(
+            provisionBindingFactory.forExecutorDependency(componentDefinitionType));
+      }
+
       // Collect Component dependencies.
       Optional<AnnotationMirror> componentMirror =
           getAnnotationMirror(componentDefinitionType, Component.class)
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 1aac416ca..d26f02736 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -108,6 +108,7 @@
 
   private final Elements elements;
   private final Types types;
+  private final CompilerOptions options;
   private final InjectBindingRegistry injectBindingRegistry;
   private final ValidationType scopeCycleValidationType;
   private final Diagnostic.Kind nullableValidationType;
@@ -120,6 +121,7 @@
   BindingGraphValidator(
       Elements elements,
       Types types,
+      CompilerOptions options,
       InjectBindingRegistry injectBindingRegistry,
       ValidationType scopeCycleValidationType,
       Diagnostic.Kind nullableValidationType,
@@ -130,6 +132,7 @@
       Key.Factory keyFactory) {
     this.elements = elements;
     this.types = types;
+    this.options = options;
     this.injectBindingRegistry = injectBindingRegistry;
     this.scopeCycleValidationType = scopeCycleValidationType;
     this.nullableValidationType = nullableValidationType;
@@ -310,6 +313,22 @@ private boolean validateResolvedBinding(
             reportProviderMayNotDependOnProducer(path);
             return false;
           }
+          if (options.usesProducers()) {
+            Key productionImplementationExecutorKey =
+                keyFactory.forProductionImplementationExecutor();
+            // only forbid depending on the production executor if it's not the Dagger-specific
+            // binding to the implementation
+            if (!contributionBinding.key().equals(productionImplementationExecutorKey)) {
+              Key productionExecutorKey = keyFactory.forProductionExecutor();
+              for (DependencyRequest request : contributionBinding.dependencies()) {
+                if (request.key().equals(productionExecutorKey)
+                    || request.key().equals(productionImplementationExecutorKey)) {
+                  reportDependsOnProductionExecutor(path);
+                  return false;
+                }
+              }
+            }
+          }
           if (contributionBinding.bindingKind().equals(SYNTHETIC_MULTIBOUND_MAP)) {
             ImmutableSet<ContributionBinding> multibindings =
                 inlineSyntheticContributions(resolvedBinding).contributionBindings();
@@ -903,6 +922,14 @@ private void reportMissingBinding(Deque<ResolvedRequest> path) {
       reportBuilder.addError(errorMessage.toString(), path.getLast().request().requestElement());
     }
 
+    @SuppressWarnings("resource") // Appendable is a StringBuilder.
+    private void reportDependsOnProductionExecutor(Deque<ResolvedRequest> path) {
+      StringBuilder builder = new StringBuilder();
+      new Formatter(builder)
+          .format(ErrorMessages.DEPENDS_ON_PRODUCTION_EXECUTOR_FORMAT, formatRootRequestKey(path));
+      reportBuilder.addError(builder.toString(), path.getLast().request().requestElement());
+    }
+
     @SuppressWarnings("resource") // Appendable is a StringBuilder.
     private void reportDuplicateBindings(Deque<ResolvedRequest> path) {
       ResolvedBindings resolvedBinding = path.peek().binding();
diff --git a/compiler/src/main/java/dagger/internal/codegen/CompilerOptions.java b/compiler/src/main/java/dagger/internal/codegen/CompilerOptions.java
new file mode 100644
index 000000000..f1bfc84db
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/CompilerOptions.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import dagger.producers.Produces;
+import javax.lang.model.util.Elements;
+
+/** A collection of options that dictate how the compiler will run. */
+final class CompilerOptions {
+  private final boolean usesProducers;
+
+  CompilerOptions(Elements elements) {
+    this.usesProducers = elements.getTypeElement(Produces.class.getCanonicalName()) != null;
+  }
+
+  boolean usesProducers() {
+    return usesProducers;
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index df6be5233..2d1d98149 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -420,11 +420,6 @@ private ComponentDescriptor create(
         }
       }
 
-      Optional<TypeElement> executorDependency =
-          kind.isProducer()
-              ? Optional.of(elements.getTypeElement(Executor.class.getCanonicalName()))
-              : Optional.<TypeElement>absent();
-
       ImmutableSet.Builder<ModuleDescriptor> modules = ImmutableSet.builder();
       for (TypeMirror moduleIncludesType : getComponentModules(componentMirror)) {
         modules.add(moduleDescriptorFactory.create(MoreTypes.asTypeElement(moduleIncludesType)));
@@ -435,6 +430,7 @@ private ComponentDescriptor create(
               && (parentKind.get().equals(Kind.COMPONENT)
                   || parentKind.get().equals(Kind.SUBCOMPONENT)))) {
         modules.add(descriptorForMonitoringModule(componentDefinitionType));
+        modules.add(descriptorForProductionExecutorModule(componentDefinitionType));
       }
 
       ImmutableSet<ExecutableElement> unimplementedMethods =
@@ -481,12 +477,14 @@ private ComponentDescriptor create(
           : enclosedBuilders(componentDefinitionType, kind.builderAnnotationType());
       Optional<DeclaredType> builderType =
           Optional.fromNullable(getOnlyElement(enclosedBuilders, null));
+      Optional<BuilderSpec> builderSpec = createBuilderSpec(builderType);
 
       ImmutableSet<Scope> scopes = Scope.scopesOf(componentDefinitionType);
       if (kind.isProducer()) {
         scopes = FluentIterable.from(scopes).append(Scope.productionScope(elements)).toSet();
       }
 
+      Optional<TypeElement> executorDependency = createExecutorDependency(kind, builderSpec);
       return new AutoValue_ComponentDescriptor(
           kind,
           componentMirror,
@@ -498,7 +496,7 @@ private ComponentDescriptor create(
           scopes,
           subcomponentDescriptors.build(),
           componentMethodsBuilder.build(),
-          createBuilderSpec(builderType));
+          builderSpec);
     }
 
     private ComponentMethodDescriptor getDescriptorForComponentMethod(
@@ -595,6 +593,23 @@ private ComponentMethodDescriptor getDescriptorForComponentMethod(
           map.build(), buildMethod, element.getEnclosingElement().asType()));
     }
 
+    private Optional<TypeElement> createExecutorDependency(
+        Kind componentKind, Optional<BuilderSpec> builderSpec) {
+      if (!componentKind.isProducer()) {
+        return Optional.absent();
+      }
+      TypeElement executorTypeElement = elements.getTypeElement(Executor.class.getCanonicalName());
+      if (!builderSpec.isPresent()) {
+        // if there's no builder, we'll add an executor() method to the generated builder so it
+        // must be specified
+        // TODO(beder): Remove this behavior.
+        return Optional.of(executorTypeElement);
+      }
+      return builderSpec.get().methodMap().containsKey(executorTypeElement)
+          ? Optional.of(executorTypeElement)
+          : Optional.<TypeElement>absent();
+    }
+
     /**
      * Returns a descriptor for a generated module that handles monitoring for production
      * components. This module is generated in the {@link MonitoringModuleProcessingStep}.
@@ -612,6 +627,27 @@ private ModuleDescriptor descriptorForMonitoringModule(TypeElement componentDefi
       }
       return moduleDescriptorFactory.create(monitoringModule);
     }
+
+    /**
+     * Returns a descriptor for a generated module that handles the producer executor for production
+     * components. This module is generated in the {@link ProductionExecutorModuleProcessingStep}.
+     *
+     * @throws TypeNotPresentException if the module has not been generated yet. This will cause the
+     *     processor to retry in a later processing round.
+     */
+    // TODO(beder): Replace this with a single class when the producers client library exists.
+    private ModuleDescriptor descriptorForProductionExecutorModule(
+        TypeElement componentDefinitionType) {
+      ClassName productionExecutorModuleName =
+          SourceFiles.generatedProductionExecutorModuleName(componentDefinitionType);
+      String generatedProductionExecutorModuleName = productionExecutorModuleName.toString();
+      TypeElement productionExecutorModule =
+          elements.getTypeElement(generatedProductionExecutorModuleName);
+      if (productionExecutorModule == null) {
+        throw new TypeNotPresentException(generatedProductionExecutorModuleName, null);
+      }
+      return moduleDescriptorFactory.create(productionExecutorModule);
+    }
   }
 
   static boolean isComponentContributionMethod(Elements elements, ExecutableElement method) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index 9574883f4..9064f09a8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -71,6 +71,9 @@ public SourceVersion getSupportedSourceVersion() {
     Elements elements = processingEnv.getElementUtils();
     Filer filer = processingEnv.getFiler();
 
+    CompilerOptions options = new CompilerOptions(elements);
+
+    // TODO(beder): Move these diagnostic options to CompilerOptions.
     Diagnostic.Kind nullableDiagnosticType =
         nullableValidationType(processingEnv).diagnosticKind().get();
 
@@ -115,6 +118,8 @@ public SourceVersion getSupportedSourceVersion() {
         new ProducerFactoryGenerator(filer, elements);
     MonitoringModuleGenerator monitoringModuleGenerator =
         new MonitoringModuleGenerator(filer, elements);
+    ProductionExecutorModuleGenerator productionExecutorModuleGenerator =
+        new ProductionExecutorModuleGenerator(filer, elements);
 
     DependencyRequest.Factory dependencyRequestFactory =
         new DependencyRequest.Factory(elements, keyFactory);
@@ -163,6 +168,7 @@ public SourceVersion getSupportedSourceVersion() {
         new BindingGraphValidator(
             elements,
             types,
+            options,
             injectBindingRegistry,
             scopeValidationType(processingEnv),
             nullableDiagnosticType,
@@ -176,6 +182,7 @@ public SourceVersion getSupportedSourceVersion() {
         new MapKeyProcessingStep(messager, types, mapKeyValidator, mapKeyGenerator),
         new InjectProcessingStep(injectBindingRegistry),
         new MonitoringModuleProcessingStep(messager, monitoringModuleGenerator),
+        new ProductionExecutorModuleProcessingStep(messager, productionExecutorModuleGenerator),
         new MultibindingsProcessingStep(messager, multibindingsValidator),
         new ModuleProcessingStep(
             messager,
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
index 71cb38afd..6aec6a795 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
@@ -142,6 +142,13 @@ public Kind apply(ContributionBinding binding) {
      */
     SUBCOMPONENT_BUILDER,
 
+    /**
+     * The executor provided in a builder for a production component. This executor is used to
+     * schedule producer methods, and its specification on the component builder is to provide an
+     * implicit provision for it.
+     */
+    EXECUTOR_DEPENDENCY,
+
     // Production kinds
 
     /** A {@link Produces}-annotated method that doesn't return a {@link ListenableFuture}. */
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
index f0a726a91..cbc579105 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -342,6 +342,17 @@ DependencyRequest forMembersInjectedType(DeclaredType type) {
           Optional.<String>absent());
     }
 
+    DependencyRequest forProductionImplementationExecutor() {
+      Key key = keyFactory.forProductionImplementationExecutor();
+      return new AutoValue_DependencyRequest(
+          Kind.PROVIDER,
+          key,
+          MoreTypes.asElement(key.type()),
+          MoreTypes.asDeclared(key.type()),
+          false /* doesn't allow null */,
+          Optional.<String>absent());
+    }
+
     DependencyRequest forProductionComponentMonitorProvider() {
       TypeElement element = elements.getTypeElement(AbstractProducer.class.getCanonicalName());
       for (ExecutableElement constructor : constructorsIn(element.getEnclosedElements())) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index e9d110a06..3737805e0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -203,6 +203,9 @@ static String inconsistentMapKeyAnnotationsError(String key) {
 
   static final String PROVIDER_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT =
       "%s is a provision, which cannot depend on a production.";
+  
+  static final String DEPENDS_ON_PRODUCTION_EXECUTOR_FORMAT =
+      "%s may not depend on the production executor.";
 
   static final String REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_FORMAT =
       "%s cannot be provided without an @Inject constructor or from an @Provides-annotated method.";
diff --git a/compiler/src/main/java/dagger/internal/codegen/HasSourceElementFormatter.java b/compiler/src/main/java/dagger/internal/codegen/HasSourceElementFormatter.java
index d73930aee..9441f7172 100644
--- a/compiler/src/main/java/dagger/internal/codegen/HasSourceElementFormatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/HasSourceElementFormatter.java
@@ -21,9 +21,8 @@
 import dagger.internal.codegen.SourceElement.HasSourceElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
-import javax.lang.model.type.TypeKind;
 
-import static com.google.common.base.Preconditions.checkArgument;
+import static dagger.internal.codegen.ErrorMessages.stripCommonTypePrefixes;
 
 /**
  * Formats a {@link HasSourceElement} into a {@link String} suitable for use in error messages.
@@ -38,16 +37,19 @@
   @Override
   public String format(HasSourceElement hasElement) {
     SourceElement sourceElement = hasElement.sourceElement();
-    checkArgument(
-        sourceElement.element().asType().getKind().equals(TypeKind.EXECUTABLE),
-        "Not yet supporting nonexecutable elements: %s",
-        hasElement);
-
-    Optional<TypeElement> contributedBy = sourceElement.contributedBy();
-    return methodSignatureFormatter.format(
-        MoreElements.asExecutable(sourceElement.element()),
-        contributedBy.isPresent()
-            ? Optional.of(MoreTypes.asDeclared(contributedBy.get().asType()))
-            : Optional.<DeclaredType>absent());
+    switch (sourceElement.element().asType().getKind()) {
+      case EXECUTABLE:
+        Optional<TypeElement> contributedBy = sourceElement.contributedBy();
+        return methodSignatureFormatter.format(
+            MoreElements.asExecutable(sourceElement.element()),
+            contributedBy.isPresent()
+                ? Optional.of(MoreTypes.asDeclared(contributedBy.get().asType()))
+                : Optional.<DeclaredType>absent());
+      case DECLARED:
+        return stripCommonTypePrefixes(sourceElement.element().asType().toString());
+      default:
+        throw new IllegalArgumentException(
+            "Formatting unsupported for element: " + sourceElement.element());
+    }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index af635fcba..a1650b0b2 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -32,9 +32,12 @@
 import dagger.Provides;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
+import dagger.producers.Production;
 import dagger.producers.Produces;
+import dagger.producers.internal.ProductionImplementation;
 import java.util.Map;
 import java.util.Set;
+import java.util.concurrent.Executor;
 import javax.inject.Provider;
 import javax.inject.Qualifier;
 import javax.lang.model.element.AnnotationMirror;
@@ -67,7 +70,7 @@
  */
 @AutoValue
 abstract class Key {
-  
+
   /** An object that is associated with a {@link Key}. */
   interface HasKey {
     /** The key associated with this object. */
@@ -91,7 +94,7 @@
    * logical equality, so {@link MoreTypes#equivalence()} wraps this type.
    */
   abstract Equivalence.Wrapper<TypeMirror> wrappedType();
-  
+
   /**
    * For multibinding contributions, this is the binding method element. Each multibound map and set
    * is represented by a
@@ -344,7 +347,7 @@ Key forProducesMethod(SourceElement sourceElement) {
           ? key
           : key.withBindingMethod(sourceElement);
     }
-    
+
     /**
      * Returns the key for a method in a {@link Multibindings @Multibindings} interface.
      *
@@ -444,6 +447,18 @@ Key forQualifiedType(Optional<AnnotationMirror> qualifier, TypeMirror type) {
           Optional.<SourceElement>absent());
     }
 
+    Key forProductionExecutor() {
+      return forQualifiedType(
+          Optional.of(SimpleAnnotationMirror.of(getClassElement(Production.class))),
+          getClassElement(Executor.class).asType());
+    }
+
+    Key forProductionImplementationExecutor() {
+      return forQualifiedType(
+          Optional.of(SimpleAnnotationMirror.of(getClassElement(ProductionImplementation.class))),
+          getClassElement(Executor.class).asType());
+    }
+
     /**
      * Optionally extract a {@link Key} for the underlying provision binding(s) if such a
      * valid key can be inferred from the given key.  Specifically, if the key represents a
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
index eb36e983f..9aa21f4ca 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -48,7 +48,6 @@
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
 import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
 import static dagger.internal.codegen.TypeNames.ASYNC_FUNCTION;
-import static dagger.internal.codegen.TypeNames.EXECUTOR;
 import static dagger.internal.codegen.TypeNames.FUTURES;
 import static dagger.internal.codegen.TypeNames.IMMUTABLE_SET;
 import static dagger.internal.codegen.TypeNames.PRODUCERS;
@@ -118,8 +117,6 @@ ClassName nameGeneratedType(ProductionBinding binding) {
           factoryBuilder, constructorBuilder, "module", moduleType);
     }
 
-    addFieldAndConstructorParameter(factoryBuilder, constructorBuilder, "executor", EXECUTOR);
-
     for (FrameworkField bindingField : fields.values()) {
       TypeName fieldType = bindingField.frameworkType();
       addFieldAndConstructorParameter(
@@ -185,7 +182,7 @@ public boolean apply(DependencyRequest dependency) {
                 providedTypeName,
                 futureTransform.parameterCodeBlocks()));
     computeMethodBuilder.addStatement(
-        "return $T.transformAsync($L, $L, executor)",
+        "return $T.transformAsync($L, $L, executorProvider.get())",
         FUTURES,
         futureTransform.futureCodeBlock(),
         transformCodeBlock);
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
index ab8a5d33f..4630567f0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
@@ -64,10 +64,12 @@ public BindingType bindingType() {
   @Override
   Set<DependencyRequest> implicitDependencies() {
     // Similar optimizations to ContributionBinding.implicitDependencies().
-    if (!monitorRequest().isPresent()) {
+    if (!executorRequest().isPresent() && !monitorRequest().isPresent()) {
       return super.implicitDependencies();
     } else {
-      return Sets.union(monitorRequest().asSet(), super.implicitDependencies());
+      return Sets.union(
+          Sets.union(executorRequest().asSet(), monitorRequest().asSet()),
+          super.implicitDependencies());
     }
   }
 
@@ -77,6 +79,9 @@ public BindingType bindingType() {
   /** Returns the list of types in the throws clause of the method. */
   abstract ImmutableList<? extends TypeMirror> thrownTypes();
 
+  /** If this production requires an executor, this will be the corresponding request. */
+  abstract Optional<DependencyRequest> executorRequest();
+
   /** If this production requires a monitor, this will be the corresponding request. */
   abstract Optional<DependencyRequest> monitorRequest();
 
@@ -106,6 +111,8 @@ ProductionBinding forProducesMethod(
               MoreTypes.asDeclared(contributedBy.asType()),
               producesMethod.getParameters(),
               resolvedMethod.getParameterTypes());
+      DependencyRequest executorRequest =
+          dependencyRequestFactory.forProductionImplementationExecutor();
       DependencyRequest monitorRequest =
           dependencyRequestFactory.forProductionComponentMonitorProvider();
       Kind kind = MoreTypes.isTypeOf(ListenableFuture.class, producesMethod.getReturnType())
@@ -121,6 +128,7 @@ ProductionBinding forProducesMethod(
           kind,
           producesAnnotation.type(),
           ImmutableList.copyOf(producesMethod.getThrownTypes()),
+          Optional.of(executorRequest),
           Optional.of(monitorRequest));
     }
 
@@ -143,6 +151,7 @@ ProductionBinding implicitMapOfProducerBinding(DependencyRequest mapOfValueReque
           Kind.SYNTHETIC_MAP,
           Produces.Type.UNIQUE,
           ImmutableList.<TypeMirror>of(),
+          Optional.<DependencyRequest>absent(),
           Optional.<DependencyRequest>absent());
     }
 
@@ -162,6 +171,7 @@ ProductionBinding syntheticMultibinding(
           Kind.forMultibindingRequest(request),
           Produces.Type.UNIQUE,
           ImmutableList.<TypeMirror>of(),
+          Optional.<DependencyRequest>absent(),
           Optional.<DependencyRequest>absent());
     }
 
@@ -180,6 +190,7 @@ ProductionBinding forComponentMethod(ExecutableElement componentMethod) {
           Kind.COMPONENT_PRODUCTION,
           Produces.Type.UNIQUE,
           ImmutableList.copyOf(componentMethod.getThrownTypes()),
+          Optional.<DependencyRequest>absent(),
           Optional.<DependencyRequest>absent());
     }
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionExecutorModuleGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ProductionExecutorModuleGenerator.java
new file mode 100644
index 000000000..1b8e5ab6d
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionExecutorModuleGenerator.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.base.Optional;
+import com.squareup.javapoet.AnnotationSpec;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.ParameterSpec;
+import com.squareup.javapoet.TypeSpec;
+import dagger.Module;
+import dagger.Provides;
+import dagger.producers.Production;
+import dagger.producers.ProductionScope;
+import dagger.producers.internal.ProductionImplementation;
+
+import java.util.concurrent.Executor;
+
+import javax.annotation.processing.Filer;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.util.Elements;
+
+import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static com.squareup.javapoet.TypeSpec.classBuilder;
+import static javax.lang.model.element.Modifier.STATIC;
+import static javax.lang.model.element.Modifier.FINAL;
+
+/** Generates a producer executor module for use with production components. */
+// TODO(beder): Replace this with a single class when the producers client library exists.
+final class ProductionExecutorModuleGenerator extends JavaPoetSourceFileGenerator<TypeElement> {
+
+  ProductionExecutorModuleGenerator(Filer filer, Elements elements) {
+    super(filer, elements);
+  }
+
+  @Override
+  ClassName nameGeneratedType(TypeElement componentElement) {
+    return SourceFiles.generatedProductionExecutorModuleName(componentElement);
+  }
+
+  @Override
+  Optional<? extends Element> getElementForErrorReporting(TypeElement componentElement) {
+    return Optional.of(componentElement);
+  }
+
+  @Override
+  Optional<TypeSpec.Builder> write(ClassName generatedTypeName, TypeElement componentElement) {
+    return Optional.of(
+        classBuilder(generatedTypeName.simpleName())
+            .addAnnotation(
+                AnnotationSpec.builder(Module.class)
+                    .build())
+            .addModifiers(FINAL)
+            .addMethod(
+                methodBuilder("executor")
+                    .returns(Executor.class)
+                    .addModifiers(STATIC)
+                    .addAnnotation(Provides.class)
+                    .addAnnotation(ProductionScope.class)
+                    .addAnnotation(ProductionImplementation.class)
+                    .addParameter(
+                        ParameterSpec.builder(Executor.class, "executor")
+                            .addAnnotation(Production.class)
+                            .build())
+                    .addStatement("return executor")
+                    .build()));
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionExecutorModuleProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ProductionExecutorModuleProcessingStep.java
new file mode 100644
index 000000000..24a728738
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionExecutorModuleProcessingStep.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
+import com.google.auto.common.MoreElements;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.SetMultimap;
+import dagger.producers.ProductionComponent;
+import dagger.producers.ProductionSubcomponent;
+import java.lang.annotation.Annotation;
+import java.util.Set;
+import javax.annotation.processing.Messager;
+import javax.lang.model.element.Element;
+
+/**
+ * A processing step that is responsible for generating a special module for a
+ * {@link ProductionComponent} or {@link ProductionSubcomponent}.
+ */
+final class ProductionExecutorModuleProcessingStep implements ProcessingStep {
+  private final Messager messager;
+  private final ProductionExecutorModuleGenerator productionExecutorModuleGenerator;
+
+  ProductionExecutorModuleProcessingStep(
+      Messager messager, ProductionExecutorModuleGenerator productionExecutorModuleGenerator) {
+    this.messager = messager;
+    this.productionExecutorModuleGenerator = productionExecutorModuleGenerator;
+  }
+
+  @Override
+  public Set<? extends Class<? extends Annotation>> annotations() {
+    return ImmutableSet.of(ProductionComponent.class, ProductionSubcomponent.class);
+  }
+
+  @Override
+  public Set<Element> process(
+      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+    for (Element element : elementsByAnnotation.values()) {
+      try {
+        productionExecutorModuleGenerator.generate(MoreElements.asType(element));
+      } catch (SourceFileGenerationException e) {
+        e.printMessageTo(messager);
+      }
+    }
+    return ImmutableSet.of();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index 3e23fd74a..aa08f5c2e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -22,6 +22,7 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
 import dagger.Provides;
+import java.util.concurrent.Executor;
 import javax.inject.Inject;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
@@ -272,5 +273,21 @@ ProvisionBinding forSubcomponentBuilderMethod(
           Optional.<ProvisionBinding>absent(),
           Optional.<Scope>absent());
     }
+
+    ProvisionBinding forExecutorDependency(TypeElement componentElement) {
+      TypeElement executorElement = elements.getTypeElement(Executor.class.getCanonicalName());
+      checkNotNull(executorElement);
+      return new AutoValue_ProvisionBinding(
+          SourceElement.forElement(componentElement),
+          keyFactory.forProductionExecutor(),
+          ImmutableSet.<DependencyRequest>of(),
+          Optional.<String>absent(),
+          Optional.<DeclaredType>absent(),
+          Optional.<DependencyRequest>absent(),
+          Kind.EXECUTOR_DEPENDENCY,
+          Provides.Type.UNIQUE,
+          Optional.<ProvisionBinding>absent(),
+          Optional.<Scope>absent());
+    }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index 0e3e6e6fd..acd56f102 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -255,6 +255,10 @@ static ClassName generatedMonitoringModuleName(
     return siblingClassName(componentElement, "_MonitoringModule");
   }
 
+  static ClassName generatedProductionExecutorModuleName(TypeElement componentElement) {
+    return siblingClassName(componentElement, "_ProductionExecutorModule");
+  }
+
   // TODO(ronshapiro): when JavaPoet migration is complete, replace the duplicated code
   // which could use this.
   private static ClassName siblingClassName(TypeElement typeElement, String suffix) {
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
index 0e7e6124a..4ef4f8100 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
@@ -532,20 +532,20 @@ public void publicModuleNonPublicIncludes() {
             GENERATED_ANNOTATION,
             "public final class TestModule_ProduceStringFactory extends AbstractProducer<String> {",
             "  private final TestModule module;",
-            "  private final Executor executor;",
+            "  private final Provider<Executor> executorProvider;",
             "  private final Provider<ProductionComponentMonitor> monitorProvider;",
             "",
             "  public TestModule_ProduceStringFactory(",
             "      TestModule module,",
-            "      Executor executor,",
+            "      Provider<Executor> executorProvider,",
             "      Provider<ProductionComponentMonitor> monitorProvider) {",
             "    super(",
             "        monitorProvider,",
             "        ProducerToken.create(TestModule_ProduceStringFactory.class));",
             "    assert module != null;",
             "    this.module = module;",
-            "    assert executor != null;",
-            "    this.executor = executor;",
+            "    assert executorProvider != null;",
+            "    this.executorProvider = executorProvider;",
             "    assert monitorProvider != null;",
             "    this.monitorProvider = monitorProvider;",
             "  }",
@@ -563,7 +563,7 @@ public void publicModuleNonPublicIncludes() {
             "            monitor.methodFinished();",
             "          }",
             "        }",
-            "      }, executor);",
+            "      }, executorProvider.get());",
             "  }",
             "}");
     assertAbout(javaSource())
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
index c645056a5..3db6dc00f 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
@@ -15,6 +15,7 @@
  */
 package dagger.internal.codegen;
 
+import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.JavaFileObjects;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
@@ -23,6 +24,7 @@
 
 import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 
 @RunWith(JUnit4.class)
@@ -86,6 +88,125 @@
         .withErrorContaining("is not annotated with one of @Module, @ProducerModule");
   }
 
+  @Test
+  public void builderWithExecutorAndProvidedExecutor() {
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.ExecutorModule",
+            "package test;",
+            "",
+            "import com.google.common.util.concurrent.MoreExecutors;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.producers.Production;",
+            "import java.util.concurrent.Executor;",
+            "",
+            "@Module",
+            "final class ExecutorModule {",
+            "  @Provides @Production Executor executor() {",
+            "    return MoreExecutors.directExecutor();",
+            "  }",
+            "}");
+    JavaFileObject producerModuleFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleModule",
+            "package test;",
+            "",
+            "import dagger.producers.ProducerModule;",
+            "import dagger.producers.Produces;",
+            "",
+            "@ProducerModule",
+            "final class SimpleModule {",
+            "  @Produces String str() {",
+            "    return \"\";",
+            "  }",
+            "}");
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import com.google.common.util.concurrent.ListenableFuture;",
+            "import dagger.producers.ProductionComponent;",
+            "import java.util.concurrent.Executor;",
+            "",
+            "@ProductionComponent(modules = {ExecutorModule.class, SimpleModule.class})",
+            "interface SimpleComponent {",
+            "  ListenableFuture<String> str();",
+            "",
+            "  @ProductionComponent.Builder",
+            "  interface Builder {",
+            "    Builder executor(Executor executor);",
+            "    SimpleComponent build();",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(moduleFile, producerModuleFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("is bound multiple times");
+  }
+
+  @Test
+  public void dependsOnProductionExecutor() {
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.ExecutorModule",
+            "package test;",
+            "",
+            "import com.google.common.util.concurrent.MoreExecutors;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.producers.Production;",
+            "import java.util.concurrent.Executor;",
+            "",
+            "@Module",
+            "final class ExecutorModule {",
+            "  @Provides @Production Executor executor() {",
+            "    return MoreExecutors.directExecutor();",
+            "  }",
+            "}");
+    JavaFileObject producerModuleFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleModule",
+            "package test;",
+            "",
+            "import dagger.producers.ProducerModule;",
+            "import dagger.producers.Produces;",
+            "import dagger.producers.Production;",
+            "import java.util.concurrent.Executor;",
+            "",
+            "@ProducerModule",
+            "final class SimpleModule {",
+            "  @Produces String str(@Production Executor executor) {",
+            "    return \"\";",
+            "  }",
+            "}");
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import com.google.common.util.concurrent.ListenableFuture;",
+            "import dagger.producers.ProductionComponent;",
+            "import java.util.concurrent.Executor;",
+            "",
+            "@ProductionComponent(modules = {ExecutorModule.class, SimpleModule.class})",
+            "interface SimpleComponent {",
+            "  ListenableFuture<String> str();",
+            "",
+            "  @ProductionComponent.Builder",
+            "  interface Builder {",
+            "    SimpleComponent build();",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(moduleFile, producerModuleFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("may not depend on the production executor");
+  }
+
   @Test public void simpleComponent() {
     JavaFileObject component = JavaFileObjects.forSourceLines("test.TestClass",
         "package test;",
@@ -132,6 +253,7 @@
             "",
             "import com.google.common.util.concurrent.ListenableFuture;",
             "import dagger.internal.InstanceFactory;",
+            "import dagger.internal.ScopedProvider;",
             "import dagger.internal.SetFactory;",
             "import dagger.producers.Producer;",
             "import dagger.producers.internal.Producers;",
@@ -144,7 +266,9 @@
             GENERATED_ANNOTATION,
             "public final class DaggerTestClass_SimpleComponent",
             "    implements TestClass.SimpleComponent {",
-            "  private Provider<TestClass.SimpleComponent> simpleComponentProvider;",
+            "  private Provider<Executor> simpleComponentProvider;",
+            "  private Provider<Executor> executorProvider;",
+            "  private Provider<TestClass.SimpleComponent> simpleComponentProvider2;",
             "  private Provider<Set<ProductionComponentMonitor.Factory>> setOfFactoryProvider;",
             "  private Provider<ProductionComponentMonitor> monitorProvider;",
             "  private Provider<TestClass.B> bProvider;",
@@ -161,7 +285,13 @@
             "",
             "  @SuppressWarnings(\"unchecked\")",
             "  private void initialize(final Builder builder) {",
-            "    this.simpleComponentProvider = ",
+            "    this.simpleComponentProvider =",
+            "        InstanceFactory.<Executor>create(builder.executor);",
+            "     this.executorProvider =",
+            "         ScopedProvider.create(",
+            "             TestClass$SimpleComponent_ProductionExecutorModule_ExecutorFactory.create(",
+            "                 simpleComponentProvider));",
+            "    this.simpleComponentProvider2 =",
             "        InstanceFactory.<TestClass.SimpleComponent>create(this);",
             "    this.setOfFactoryProvider = SetFactory.create(",
             "        TestClass$SimpleComponent_MonitoringModule_DefaultSetOfFactoriesFactory",
@@ -169,13 +299,13 @@
             "    this.monitorProvider =",
             "        TestClass$SimpleComponent_MonitoringModule_MonitorFactory.create(",
             "            builder.testClass$SimpleComponent_MonitoringModule,",
-            "            simpleComponentProvider,",
+            "            simpleComponentProvider2,",
             "            setOfFactoryProvider);",
             "    this.bProvider = TestClass$BModule_BFactory.create(",
             "        builder.bModule, TestClass$C_Factory.create());",
             "    this.aProducer = new TestClass$AModule_AFactory(",
             "        builder.aModule,",
-            "        builder.executor,",
+            "        executorProvider,",
             "        monitorProvider,",
             "        Producers.producerFromProvider(bProvider));",
             "  }",
@@ -240,6 +370,16 @@
             "      return this;",
             "    }",
             "",
+            "    @Deprecated",
+            "    public Builder testClass$SimpleComponent_ProductionExecutorModule(",
+            "        TestClass$SimpleComponent_ProductionExecutorModule",
+            "        testClass$SimpleComponent_ProductionExecutorModule) {",
+            "      if (testClass$SimpleComponent_ProductionExecutorModule == null) {",
+            "        throw new NullPointerException();",
+            "      }",
+            "      return this;",
+            "    }",
+            "",
             "    public Builder executor(Executor executor) {",
             "      if (executor == null) {",
             "        throw new NullPointerException();",
diff --git a/producers/src/main/java/dagger/producers/Production.java b/producers/src/main/java/dagger/producers/Production.java
new file mode 100644
index 000000000..2ecdec809
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/Production.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers;
+
+import dagger.internal.Beta;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import javax.inject.Qualifier;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Qualifies a type that will be provided to the framework for use internally.
+ *
+ * <p>The only type that may be so qualified is {@link java.util.concurrent.Executor}. In this case,
+ * the resulting executor is used to schedule {@linkplain Produces producer methods} in a
+ * {@link ProductionComponent} or {@link ProductionSubcomponent}.
+ */
+@Documented
+@Retention(RUNTIME)
+@Qualifier
+@Beta
+public @interface Production {}
diff --git a/producers/src/main/java/dagger/producers/ProductionComponent.java b/producers/src/main/java/dagger/producers/ProductionComponent.java
index f3f7db027..ec56d1576 100644
--- a/producers/src/main/java/dagger/producers/ProductionComponent.java
+++ b/producers/src/main/java/dagger/producers/ProductionComponent.java
@@ -64,6 +64,13 @@
  * {@link com.google.common.util.concurrent.Futures#transform}.
  * <!-- TODO(beder): Explain this more thoroughly, and update the javadocs of those utilities. -->
  *
+ * <h2>Executor</h2>
+ *
+ * <p>The component must include a binding for <code>{@literal @}Production Executor</code>;
+ * this binding will be called exactly once, and the provided executor will be used by the framework
+ * to schedule all producer methods (for this component, and any {@link ProductionSubcomponent} it
+ * may have.
+ *
  * @author Jesse Beder
  */
 @Documented
@@ -90,8 +97,6 @@
    *      (This is typically the {@code build()} method.)
    * <li> All other abstract methods must take a single argument and must return void,
    *      the builder type, or a supertype of the builder.
-   * <li> There <b>must</b> be an abstract method whose parameter is
-   *      {@link java.util.concurrent.Executor}.
    * <li> Each component dependency <b>must</b> have an abstract setter method.
    * <li> Each module dependency that Dagger can't instantiate itself (i.e., the module
    *      doesn't have a visible no-args constructor) <b>must</b> have an abstract setter method.
@@ -109,7 +114,6 @@
    *   {@literal @}ProductionComponent.Builder
    *   interface Builder {
    *     MyComponent build();
-   *     Builder executor(Executor executor);
    *     Builder backendModule(BackendModule bm);
    *     Builder frontendModule(FrontendModule fm);
    *   }
diff --git a/producers/src/main/java/dagger/producers/ProductionSubcomponent.java b/producers/src/main/java/dagger/producers/ProductionSubcomponent.java
index 2832fcf65..1eecca1b3 100644
--- a/producers/src/main/java/dagger/producers/ProductionSubcomponent.java
+++ b/producers/src/main/java/dagger/producers/ProductionSubcomponent.java
@@ -30,6 +30,10 @@
  * {@link ProductionComponent}, or {@link ProductionSubcomponent}. The details of how to associate a
  * subcomponent with a parent are described in the documentation for {@link Component}.
  *
+ * <p>The executor for a production subcomponent is supplied by binding
+ * <code>{@literal @}Production Executor</code>, similar to {@link ProductionComponent}. Note that
+ * this binding may be in an ancestor component.
+ *
  * @author Jesse Beder
  */
 @Retention(RUNTIME) // Allows runtimes to have specialized behavior interoperating with Dagger.
diff --git a/producers/src/main/java/dagger/producers/internal/ProductionImplementation.java b/producers/src/main/java/dagger/producers/internal/ProductionImplementation.java
new file mode 100644
index 000000000..b5cfa927a
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/internal/ProductionImplementation.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.internal;
+
+import dagger.internal.Beta;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import javax.inject.Qualifier;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Qualifies a type that will be used as an internal implementation detail in the framework.
+ *
+ * <p>This is only intended to be used by the framework. It is the internal counterpart to
+ * {@link dagger.producers.Production}.
+ */
+@Documented
+@Retention(RUNTIME)
+@Qualifier
+@Beta
+public @interface ProductionImplementation {}
