diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index fbdef346f..8d6fcad95 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -37,6 +37,7 @@
 import java.util.List;
 import java.util.Map.Entry;
 import java.util.Queue;
+import java.util.Set;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
@@ -191,6 +192,8 @@ ComponentDescriptor create(TypeElement componentDefinitionType)
 
       ImmutableSetMultimap<Key, ProvisionBinding> explicitBindings = bindingIndexBuilder.build();
 
+      Set<MethodSignature> interfaceMethods = Sets.newHashSet();
+
       ImmutableList.Builder<DependencyRequest> interfaceRequestsBuilder = ImmutableList.builder();
 
       Deque<DependencyRequest> requestsToResolve = Queues.newArrayDeque();
@@ -198,24 +201,28 @@ ComponentDescriptor create(TypeElement componentDefinitionType)
       for (ExecutableElement componentMethod
           : ElementFilter.methodsIn(elements.getAllMembers(componentDefinitionType))) {
         if (componentMethod.getModifiers().contains(ABSTRACT)) {
-          List<? extends VariableElement> parameters = componentMethod.getParameters();
-          switch (parameters.size()) {
-            case 0:
-              // provision method
-              DependencyRequest provisionRequest =
-                  dependencyRequestFactory.forComponentProvisionMethod(componentMethod);
-              interfaceRequestsBuilder.add(provisionRequest);
-              requestsToResolve.addLast(provisionRequest);
-              break;
-            case 1:
-              // members injection method
-              DependencyRequest membersInjectionRequest =
-                  dependencyRequestFactory.forComponentMembersInjectionMethod(componentMethod);
-              interfaceRequestsBuilder.add(membersInjectionRequest);
-              requestsToResolve.addLast(membersInjectionRequest);
-              break;
-            default:
-              throw new IllegalStateException();
+          MethodSignature signature = MethodSignature.fromExecutableElement(componentMethod);
+          if (!interfaceMethods.contains(signature)) {
+            List<? extends VariableElement> parameters = componentMethod.getParameters();
+            switch (parameters.size()) {
+              case 0:
+                // provision method
+                DependencyRequest provisionRequest =
+                dependencyRequestFactory.forComponentProvisionMethod(componentMethod);
+                interfaceRequestsBuilder.add(provisionRequest);
+                requestsToResolve.addLast(provisionRequest);
+                break;
+              case 1:
+                // members injection method
+                DependencyRequest membersInjectionRequest =
+                dependencyRequestFactory.forComponentMembersInjectionMethod(componentMethod);
+                interfaceRequestsBuilder.add(membersInjectionRequest);
+                requestsToResolve.addLast(membersInjectionRequest);
+                break;
+              default:
+                throw new IllegalStateException();
+            }
+            interfaceMethods.add(signature);
           }
         }
       }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MethodSignature.java b/compiler/src/main/java/dagger/internal/codegen/MethodSignature.java
new file mode 100644
index 000000000..d45fd8758
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/MethodSignature.java
@@ -0,0 +1,34 @@
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreTypes;
+import com.google.auto.value.AutoValue;
+import com.google.common.base.Equivalence;
+import com.google.common.collect.ImmutableList;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeMirror;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+
+@AutoValue
+abstract class MethodSignature {
+  abstract String name();
+  abstract ImmutableList<Equivalence.Wrapper<TypeMirror>> parameterTypes();
+  abstract ImmutableList<Equivalence.Wrapper<TypeMirror>> thrownTypes();
+
+  static MethodSignature fromExecutableElement(ExecutableElement method) {
+    checkNotNull(method);
+    ImmutableList.Builder<Equivalence.Wrapper<TypeMirror>> parameters = ImmutableList.builder();
+    ImmutableList.Builder<Equivalence.Wrapper<TypeMirror>> thrownTypes = ImmutableList.builder();
+    for (VariableElement parameter : method.getParameters()) {
+      parameters.add(MoreTypes.equivalence().wrap(parameter.asType()));
+    }
+    for (TypeMirror thrownType : method.getThrownTypes()) {
+      thrownTypes.add(MoreTypes.equivalence().wrap(thrownType));
+    }
+    return new AutoValue_MethodSignature(
+        method.getSimpleName().toString(),
+        parameters.build(),
+        thrownTypes.build());
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index c3b0e963f..382f70c1d 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -1242,4 +1242,93 @@
         .compilesWithoutError()
         .and().generatesSources(generatedComponent);
   }
+
+  @Test public void simpleComponent_redundantCompoentMethod() {
+    JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class SomeInjectableType {",
+        "  @Inject SomeInjectableType() {}",
+        "}");
+    JavaFileObject componentSupertypeAFile = JavaFileObjects.forSourceLines("test.SupertypeA",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Lazy;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface SupertypeA {",
+        "  SomeInjectableType someInjectableType();",
+        "}");
+    JavaFileObject componentSupertypeBFile = JavaFileObjects.forSourceLines("test.SupertypeB",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Lazy;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface SupertypeB {",
+        "  SomeInjectableType someInjectableType();",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Lazy;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface SimpleComponent extends SupertypeA, SupertypeB {",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.Dagger_SimpleComponent",
+        "package test;",
+        "",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class Dagger_SimpleComponent implements SimpleComponent {",
+        "  private final Provider<SomeInjectableType> someInjectableTypeProvider;",
+        "",
+        "  private Dagger_SimpleComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    this.someInjectableTypeProvider = new SomeInjectableType$$Factory();",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static SimpleComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  @Override",
+        "  public SomeInjectableType someInjectableType() {",
+        "    return someInjectableTypeProvider.get();",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public SimpleComponent build() {",
+        "      return new Dagger_SimpleComponent(this);",
+        "    }",
+        "  }",
+        "}");
+    assert_().about(javaSources()).that(ImmutableList.of(
+            injectableTypeFile, componentSupertypeAFile, componentSupertypeBFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
 }
