diff --git a/compiler/src/it/functional-tests/src/test/java/test/membersinject/MembersInjectTest.java b/compiler/src/it/functional-tests/src/test/java/test/membersinject/MembersInjectTest.java
index 82c67e381..e6e42c142 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/membersinject/MembersInjectTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/membersinject/MembersInjectTest.java
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *  http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 0a7828496..795a5e185 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -49,7 +49,6 @@
 import static dagger.internal.codegen.SourceFiles.simpleVariableName;
 import static dagger.internal.codegen.TypeNames.DELEGATE_FACTORY;
 import static dagger.internal.codegen.TypeNames.DOUBLE_CHECK;
-import static dagger.internal.codegen.TypeNames.FACTORY;
 import static dagger.internal.codegen.TypeNames.INSTANCE_FACTORY;
 import static dagger.internal.codegen.TypeNames.LISTENABLE_FUTURE;
 import static dagger.internal.codegen.TypeNames.MAP_FACTORY;
@@ -1128,13 +1127,16 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
           return CodeBlock.of(
               Joiner.on('\n')
                   .join(
-                      "new $1T<$2T>() {",
+                      "new $1L<$2T>() {",
                       "  private final $5T $6L = $3L;",
                       "  $4L@Override public $2T get() {",
                       "    $7L",
                       "  }",
                       "}"),
-              /* 1 */ FACTORY,
+              // TODO(ronshapiro): Until we remove Factory, fully qualify the import so it doesn't
+              // conflict with anyone that has Factory as an inner type of a component (like
+              // AndroidInjector.Factory
+              /* 1 */ "dagger.internal.Factory",
               /* 2 */ bindingKeyTypeName,
               /* 3 */ getComponentContributionExpression(
                   ComponentRequirement.forDependency(dependencyType.asType())),
@@ -1153,12 +1155,14 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
         return CodeBlock.of(
             Joiner.on('\n')
                 .join(
-                    "new $1T<$2T>() {",
+                    "new $1L<$2T>() {",
                     "  @Override public $2T get() {",
                     "    return new $3LBuilder();",
                     "  }",
                     "}"),
-            /* 1 */ FACTORY,
+            // TODO(ronshapiro): Until we remove Factory, fully qualify the import so it doesn't
+            // conflict with dagger.android.ActivityInjector.Factory
+            /* 1 */ "dagger.internal.Factory",
             /* 2 */ bindingKeyTypeName,
             /* 3 */ subcomponentName);
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java b/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java
index 7156cc4cd..41a023488 100644
--- a/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java
+++ b/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java
@@ -16,9 +16,12 @@
 
 package dagger.internal.codegen;
 
+import static dagger.internal.codegen.TypeNames.rawTypeName;
 import static java.util.stream.StreamSupport.stream;
 
+import com.google.auto.common.MoreElements;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.CodeBlock.Builder;
 import com.squareup.javapoet.TypeName;
@@ -141,7 +144,11 @@ static CodeBlock stringLiteral(String toWrap) {
   /** Returns a javadoc {@literal @link} tag that poins to the given {@link ExecutableElement}. */
   static CodeBlock javadocLinkTo(ExecutableElement executableElement) {
     CodeBlock.Builder builder =
-        CodeBlock.builder().add("{@link $T#", executableElement.getEnclosingElement());
+        CodeBlock.builder()
+            .add(
+                "{@link $T#",
+                rawTypeName(
+                    ClassName.get(MoreElements.asType(executableElement.getEnclosingElement()))));
     switch (executableElement.getKind()) {
       case METHOD:
         builder.add("$L", executableElement.getSimpleName());
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index 69f2523bd..74e1b9e57 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -1665,7 +1665,6 @@ public void testDefaultPackage() {
             "test.DaggerBComponent",
             "package test;",
             "",
-            "import dagger.internal.Factory;",
             "import dagger.internal.Preconditions;",
             "import javax.annotation.Generated;",
             "import javax.inject.Provider;",
@@ -1686,7 +1685,7 @@ public void testDefaultPackage() {
             "",
             "  @SuppressWarnings(\"unchecked\")",
             "  private void initialize(final Builder builder) {",
-            "    this.aProvider = new Factory<A>() {",
+            "    this.aProvider = new dagger.internal.Factory<A>() {",
             "      private final AComponent aComponent = builder.aComponent;",
             "      @Override public A get() {",
             "        return Preconditions.checkNotNull(aComponent.a(), " + NPE_LITERAL + ");",
diff --git a/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java
index d79d65e41..976864df8 100644
--- a/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java
@@ -881,7 +881,6 @@ public void subcomponentBuilderNamesShouldNotConflict() {
             "test.DaggerC",
             "package test;",
             "",
-            "import dagger.internal.Factory;",
             "import javax.annotation.Generated;",
             "import javax.inject.Provider;",
             "",
@@ -907,7 +906,7 @@ public void subcomponentBuilderNamesShouldNotConflict() {
             "  @SuppressWarnings(\"unchecked\")",
             "  private void initialize(final Builder builder) {",
             "    this.fooBuilderProvider = ",
-            "        new Factory<C.Foo.Sub.Builder>() {",
+            "        new dagger.internal.Factory<C.Foo.Sub.Builder>() {",
             "          @Override",
             "          public C.Foo.Sub.Builder get() {",
             "            return new Foo_SubBuilder();",
@@ -915,7 +914,7 @@ public void subcomponentBuilderNamesShouldNotConflict() {
             "        };",
             "",
             "    this.barBuilderProvider = ",
-            "        new Factory<C.Bar.Sub.Builder>() {",
+            "        new dagger.internal.Factory<C.Bar.Sub.Builder>() {",
             "          @Override",
             "          public C.Bar.Sub.Builder get() {",
             "            return new Bar_SubBuilder();",
diff --git a/core/src/main/java/dagger/internal/Preconditions.java b/core/src/main/java/dagger/internal/Preconditions.java
index 7ac5026cc..99e180530 100644
--- a/core/src/main/java/dagger/internal/Preconditions.java
+++ b/core/src/main/java/dagger/internal/Preconditions.java
@@ -50,6 +50,36 @@
     return reference;
   }
 
+  /**
+   * Ensures that an object reference passed as a parameter to the calling method is not null.
+   *
+   * @param reference an object reference
+   * @param errorMessageTemplate a template for the exception message should the check fail. The
+   *     message is formed by replacing the single {@code %s} placeholder in the template with
+   *     {@code errorMessageArg}.
+   * @param errorMessageArg the argument to be substituted into the message template. Converted to a
+   *     string using {@link String#valueOf(Object)}.
+   * @return the non-null reference that was validated
+   * @throws NullPointerException if {@code reference} is null
+   * @throws IllegalArgumentException if {@code errorMessageTemplate} doesn't contain exactly one
+   *     "%s"
+   */
+  public static <T> T checkNotNull(
+      T reference, String errorMessageTemplate, Object errorMessageArg) {
+    if (reference == null) {
+      // Poor-persons version of String.format, which is not GWT-compatible
+      if (!errorMessageTemplate.contains("%s")) {
+        throw new IllegalArgumentException("errorMessageTemplate has no format specifiers");
+      }
+      if (errorMessageTemplate.indexOf("%s") != errorMessageTemplate.lastIndexOf("%s")) {
+        throw new IllegalArgumentException(
+            "errorMessageTemplate has more than one format specifier");
+      }
+      throw new NullPointerException(
+          errorMessageTemplate.replaceFirst("%s", String.valueOf(errorMessageArg)));
+    }
+    return reference;
+  }
+
   private Preconditions() {}
 }
-
diff --git a/java/dagger/android/ActivityKey.java b/java/dagger/android/ActivityKey.java
new file mode 100644
index 000000000..2fe7aeeee
--- /dev/null
+++ b/java/dagger/android/ActivityKey.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import static java.lang.annotation.ElementType.METHOD;
+
+import android.app.Activity;
+import dagger.MapKey;
+import dagger.internal.Beta;
+import java.lang.annotation.Target;
+
+/** {@link MapKey} annotation to key bindings by a type of an {@link Activity}. */
+@Beta
+@MapKey
+@Target(METHOD)
+public @interface ActivityKey {
+  Class<? extends Activity> value();
+}
diff --git a/java/dagger/android/AndroidInjection.java b/java/dagger/android/AndroidInjection.java
new file mode 100644
index 000000000..2a6554565
--- /dev/null
+++ b/java/dagger/android/AndroidInjection.java
@@ -0,0 +1,123 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import static dagger.internal.Preconditions.checkNotNull;
+
+import android.app.Activity;
+import android.app.Application;
+import android.app.Fragment;
+import android.util.Log;
+import dagger.internal.Beta;
+
+/** Injects core Android types. */
+@Beta
+public final class AndroidInjection {
+  private static final String TAG = "dagger.android";
+
+  /**
+   * Injects {@code activity} if an associated {@link AndroidInjector.Factory} implementation can be
+   * found, otherwise throws an {@link IllegalArgumentException}.
+   *
+   * @throws RuntimeException if the {@link Application} doesn't implement {@link
+   *     HasDispatchingActivityInjector}, or if no {@code AndroidInjector.Factory<Activity, ?>} is
+   *     bound for {@code activity}.
+   */
+  public static void inject(Activity activity) {
+    checkNotNull(activity, "activity");
+    Application application = activity.getApplication();
+    if (!(application instanceof HasDispatchingActivityInjector)) {
+      throw new RuntimeException(
+          String.format(
+              "%s does not implement %s",
+              application.getClass().getCanonicalName(),
+              HasDispatchingActivityInjector.class.getCanonicalName()));
+    }
+
+    DispatchingAndroidInjector<Activity> activityInjector =
+        ((HasDispatchingActivityInjector) application).activityInjector();
+    checkNotNull(
+        activityInjector,
+        "%s.activityInjector() returned null",
+        application.getClass().getCanonicalName());
+
+    activityInjector.inject(activity);
+  }
+
+  /**
+   * Injects {@code fragment} if an associated {@link AndroidInjector.Factory} implementation can be
+   * found, otherwise throws an {@link IllegalArgumentException}.
+   *
+   * <p>Uses the following algorithm to find the appropriate {@code
+   * DispatchingAndroidInjector<Fragment>} to inject {@code fragment}:
+   *
+   * <ol>
+   *   <li>Walks the parent-fragment hierarchy to find the a fragment that implements {@link
+   *       HasDispatchingFragmentInjector}, and if none do
+   *   <li>Uses the {@code fragment}'s {@link Fragment#getActivity() activity} if it implements
+   *       {@link HasDispatchingFragmentInjector}, and if not
+   *   <li>Uses the {@link android.app.Application} if it implements {@link
+   *       HasDispatchingFragmentInjector}.
+   * </ol>
+   *
+   * If none of them implement {@link HasDispatchingFragmentInjector}, a {@link
+   * IllegalArgumentException} is thrown.
+   *
+   * @throws IllegalArgumentException if no {@code AndroidInjector.Factory<Fragment, ?>} is bound
+   *     for {@code fragment}.
+   */
+  public static void inject(Fragment fragment) {
+    checkNotNull(fragment, "fragment");
+    HasDispatchingFragmentInjector hasDispatchingFragmentInjector =
+        findHasFragmentInjector(fragment);
+    Log.d(
+        TAG,
+        String.format(
+            "An injector for %s was found in %s",
+            fragment.getClass().getCanonicalName(),
+            hasDispatchingFragmentInjector.getClass().getCanonicalName()));
+
+    DispatchingAndroidInjector<Fragment> fragmentInjector =
+        hasDispatchingFragmentInjector.fragmentInjector();
+    checkNotNull(
+        fragmentInjector,
+        "%s.fragmentInjector() returned null",
+        hasDispatchingFragmentInjector.getClass().getCanonicalName());
+
+    fragmentInjector.inject(fragment);
+  }
+
+  private static HasDispatchingFragmentInjector findHasFragmentInjector(Fragment fragment) {
+    Fragment parentFragment = fragment;
+    while ((parentFragment = parentFragment.getParentFragment()) != null) {
+      if (parentFragment instanceof HasDispatchingFragmentInjector) {
+        return (HasDispatchingFragmentInjector) parentFragment;
+      }
+    }
+    Activity activity = fragment.getActivity();
+    if (activity instanceof HasDispatchingFragmentInjector) {
+      return (HasDispatchingFragmentInjector) activity;
+    }
+    if (activity.getApplication() instanceof HasDispatchingFragmentInjector) {
+      return (HasDispatchingFragmentInjector) activity.getApplication();
+    }
+    throw new IllegalArgumentException(
+        String.format("No injector was found for %s", fragment.getClass().getCanonicalName()));
+  }
+
+  private AndroidInjection() {}
+}
diff --git a/java/dagger/android/AndroidInjectionModule.java b/java/dagger/android/AndroidInjectionModule.java
new file mode 100644
index 000000000..d7d7de15a
--- /dev/null
+++ b/java/dagger/android/AndroidInjectionModule.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import android.app.Activity;
+import android.app.Fragment;
+import dagger.Module;
+import dagger.internal.Beta;
+import dagger.multibindings.Multibinds;
+import java.util.Map;
+
+/**
+ * Contains bindings to ensure the usability of {@code dagger.android} framework classes. This
+ * module should be installed in the component that is used to inject the {@link
+ * android.app.Application} class.
+ */
+@Beta
+@Module
+public abstract class AndroidInjectionModule {
+  @Multibinds
+  abstract Map<Class<? extends Activity>, AndroidInjector.Factory<Activity, ?>>
+      activityInjectorFactories();
+
+  @Multibinds
+  abstract Map<Class<? extends Fragment>, AndroidInjector.Factory<Fragment, ?>>
+      fragmentInjectorFactories();
+
+  private AndroidInjectionModule() {}
+}
diff --git a/java/dagger/android/AndroidInjector.java b/java/dagger/android/AndroidInjector.java
new file mode 100644
index 000000000..8bab214a1
--- /dev/null
+++ b/java/dagger/android/AndroidInjector.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import dagger.BindsInstance;
+import dagger.internal.Beta;
+
+/**
+ * Performs members-injection for a concrete subtype of a <a
+ * href="https://developer.android.com/guide/components/index.html">core Android type</a> (e.g.,
+ * {@link android.app.Activity} or {@link android.app.Fragment}).
+ *
+ * <p>Commonly implemented by {@link dagger.Subcomponent}-annotated types whose {@link
+ * dagger.Subcomponent.Builder} extends {@link Builder}.
+ *
+ * @param <T> a concrete subtype of a core Android type
+ * @see AndroidInjection
+ * @see DispatchingAndroidInjector
+ */
+@Beta
+public interface AndroidInjector<T> {
+
+  /** Injects the members of {@code instance}. */
+  void inject(T instance);
+
+  /**
+   * Creates {@link AndroidInjector}s for a concrete subtype of a core Android type.
+   *
+   * @param <A> a core Android type
+   * @param <T> the concrete subtype of {@code I} to be injected
+   */
+  interface Factory<A, T extends A> {
+    /**
+     * Creates an {@link AndroidInjector} for {@code instance}. This should be the same instance
+     * that will be passed to {@link #inject(Object)}.
+     */
+    AndroidInjector<T> create(A instance);
+  }
+
+  /**
+   * An adapter that lets the common {@link dagger.Subcomponent.Builder} pattern implement {@link
+   * Factory}.
+   *
+   * @param <A> a core Android type
+   * @param <T> the concrete subtype of {@code I} to be injected
+   */
+  abstract class Builder<A, T extends A> implements AndroidInjector.Factory<A, T> {
+    @Override
+    public final AndroidInjector<T> create(A instance) {
+      seedInstance(instance);
+      return build();
+    }
+
+    /**
+     * Provides {@code instance} to be used in the binding graph of the built {@link
+     * AndroidInjector}. By default, this is used as a {@link BindsInstance} method, but it may be
+     * overridden to provide any modules which need a reference to the activity.
+     *
+     * <p>This should be the same instance that will be passed to {@link #inject(Object)}.
+     */
+    @BindsInstance
+    public abstract void seedInstance(A instance);
+
+    /** Returns a newly-constructed {@link AndroidInjector}. */
+    public abstract AndroidInjector<T> build();
+  }
+}
diff --git a/java/dagger/android/AndroidManifest.xml b/java/dagger/android/AndroidManifest.xml
new file mode 100644
index 000000000..fcd14263c
--- /dev/null
+++ b/java/dagger/android/AndroidManifest.xml
@@ -0,0 +1,19 @@
+<!--
+ Copyright (C) 2016 The Dagger Authors.
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="dagger.android">
+  <uses-sdk android:minSdkVersion="14" android:targetSdkVersion="24" />
+</manifest>
diff --git a/java/dagger/android/BUILD b/java/dagger/android/BUILD
index 9533d1717..dfa81d414 100644
--- a/java/dagger/android/BUILD
+++ b/java/dagger/android/BUILD
@@ -29,9 +29,11 @@ android_library(
     name = "android",
     srcs = glob(["*.java"]),
     javacopts = PRE_JAVA_8_INFERENCE_OPTS + JAVA_6_SOURCE_LEVEL + DOCLINT_HTML_AND_SYNTAX + DOCLINT_REFERENCES,
+    manifest = "AndroidManifest.xml",
     deps = [
         "//:dagger_with_compiler",
         "//third_party:auto_value",
         "@androidsdk//com.android.support:support-annotations-25.0.0",
+        "@androidsdk//com.android.support:support-v4-25.0.0",
     ],
 )
diff --git a/java/dagger/android/DaggerActivity.java b/java/dagger/android/DaggerActivity.java
new file mode 100644
index 000000000..d9f68911d
--- /dev/null
+++ b/java/dagger/android/DaggerActivity.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import android.app.Activity;
+import android.app.Fragment;
+import android.os.Bundle;
+import dagger.internal.Beta;
+import javax.inject.Inject;
+
+/**
+ * An {@link Activity} that injects its members in {@link #onCreate(Bundle)} and can be used to
+ * inject {@link Fragment}s attached to it.
+ */
+@Beta
+public abstract class DaggerActivity extends Activity implements HasDispatchingFragmentInjector {
+
+  @Inject DispatchingAndroidInjector<Fragment> fragmentInjector;
+
+  @Override
+  protected void onCreate(Bundle savedInstanceState) {
+    super.onCreate(savedInstanceState);
+    AndroidInjection.inject(this);
+  }
+
+  @Override
+  public DispatchingAndroidInjector<Fragment> fragmentInjector() {
+    return fragmentInjector;
+  }
+}
diff --git a/java/dagger/android/DaggerFragment.java b/java/dagger/android/DaggerFragment.java
new file mode 100644
index 000000000..d48438231
--- /dev/null
+++ b/java/dagger/android/DaggerFragment.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import android.app.Fragment;
+import android.content.Context;
+import dagger.internal.Beta;
+import javax.inject.Inject;
+
+/**
+ * A {@link Fragment} that injects its members in {@link #onAttach(Context)} and can be used to
+ * inject child {@link Fragment}s attached to it. Note that when this fragment gets reattached, its
+ * members will be injected again.
+ */
+@Beta
+public abstract class DaggerFragment extends Fragment implements HasDispatchingFragmentInjector {
+
+  @Inject DispatchingAndroidInjector<Fragment> childFragmentInjector;
+
+  @Override
+  public void onAttach(Context context) {
+    super.onAttach(context);
+    AndroidInjection.inject(this);
+  }
+
+  @Override
+  public DispatchingAndroidInjector<Fragment> fragmentInjector() {
+    return childFragmentInjector;
+  }
+}
diff --git a/java/dagger/android/DispatchingAndroidInjector.java b/java/dagger/android/DispatchingAndroidInjector.java
new file mode 100644
index 000000000..38132a2c0
--- /dev/null
+++ b/java/dagger/android/DispatchingAndroidInjector.java
@@ -0,0 +1,134 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import static dagger.internal.Preconditions.checkNotNull;
+
+import android.app.Activity;
+import android.app.Fragment;
+import dagger.internal.Beta;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import javax.inject.Inject;
+import javax.inject.Provider;
+
+/**
+ * Performs members-injection on instances of core Android types (e.g. {@link Activity}, {@link
+ * Fragment}) that are constructed by the Android framework and not by Dagger. This class relies on
+ * an injected mapping from each concrete class to an {@link AndroidInjector.Factory} for an {@link
+ * AndroidInjector} of that class. Each concrete class must have its own entry in the map, even if
+ * it extends another class which is already present in the map. Calls {@link Object#getClass()} on
+ * the instance in order to find the appropriate {@link AndroidInjector.Factory}.
+ *
+ * @param <T> the core Android type to be injected
+ */
+@Beta
+public final class DispatchingAndroidInjector<T> {
+  private static final String NO_SUPERTYPES_BOUND_FORMAT =
+      "No injector factory bound for Class<%s>";
+  private static final String SUPERTYPES_BOUND_FORMAT =
+      "No injector factory bound for Class<%1$s>. Injector factories were bound for supertypes "
+          + "of %1$s: %2$s. Did you mean to bind an injector factory for the subtype?";
+
+  private final Map<Class<? extends T>, Provider<AndroidInjector.Factory<T, ?>>> injectorFactories;
+
+  @Inject
+  DispatchingAndroidInjector(
+      Map<Class<? extends T>, Provider<AndroidInjector.Factory<T, ?>>> injectorFactories) {
+    this.injectorFactories = injectorFactories;
+  }
+
+  /**
+   * Attempts to perform members-injection on {@code instance}, returning {@code true} if
+   * successful, {@code false} otherwise.
+   *
+   * @throws InvalidInjectorBindingException if the injector factory bound for a class does not
+   *     inject instances of that class
+   */
+  public boolean maybeInject(T instance) {
+    Provider<AndroidInjector.Factory<T, ?>> factoryProvider =
+        injectorFactories.get(instance.getClass());
+    if (factoryProvider == null) {
+      return false;
+    }
+
+    AndroidInjector.Factory<T, ?> factory = factoryProvider.get();
+    AndroidInjector<?> wildcardInjector =
+        checkNotNull(
+            factory.create(instance),
+            "%s.create(I) should not return null.",
+            factory.getClass().getCanonicalName());
+    @SuppressWarnings("unchecked")
+    AndroidInjector<T> injector = (AndroidInjector<T>) wildcardInjector;
+
+    try {
+      injector.inject(instance);
+      return true;
+    } catch (ClassCastException e) {
+      throw new InvalidInjectorBindingException(
+          String.format(
+              "%s does not implement AndroidInjector<%s>",
+              injector.getClass().getCanonicalName(), instance.getClass().getCanonicalName()),
+          e);
+    }
+  }
+
+  /**
+   * Performs members-injection on {@code instance}.
+   *
+   * @throws InvalidInjectorBindingException if the injector factory bound for a class does not
+   *     inject instances of that class
+   * @throws IllegalArgumentException if no {@link AndroidInjector.Factory} is bound for {@code
+   *     instance}
+   */
+  public void inject(T instance) {
+    boolean wasInjected = maybeInject(instance);
+    if (!wasInjected) {
+      throw new IllegalArgumentException(errorMessageSuggestions(instance));
+    }
+  }
+
+  /**
+   * Exception thrown if an incorrect binding is made for a {@link AndroidInjector.Factory}. If you
+   * see this exception, make sure the value in your {@code @ActivityKey(YourActivity.class)} or
+   * {@code @FragmentKey(YourFragment.class)} matches the type argument of the injector factory.
+   */
+  @Beta
+  public static final class InvalidInjectorBindingException extends RuntimeException {
+    InvalidInjectorBindingException(String message, ClassCastException cause) {
+      super(message, cause);
+    }
+  }
+
+  /** Returns an error message with the class names that are supertypes of {@code instance}. */
+  private String errorMessageSuggestions(T instance) {
+    List<String> suggestions = new ArrayList<String>();
+    for (Class<? extends T> activityClass : injectorFactories.keySet()) {
+      if (activityClass.isInstance(instance)) {
+        suggestions.add(activityClass.getCanonicalName());
+      }
+    }
+    Collections.sort(suggestions);
+
+    return String.format(
+        suggestions.isEmpty() ? NO_SUPERTYPES_BOUND_FORMAT : SUPERTYPES_BOUND_FORMAT,
+        instance.getClass().getCanonicalName(),
+        suggestions);
+  }
+}
diff --git a/java/dagger/android/FragmentKey.java b/java/dagger/android/FragmentKey.java
new file mode 100644
index 000000000..5f27e3f01
--- /dev/null
+++ b/java/dagger/android/FragmentKey.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import static java.lang.annotation.ElementType.METHOD;
+
+import android.app.Fragment;
+import dagger.MapKey;
+import dagger.internal.Beta;
+import java.lang.annotation.Target;
+
+/** {@link MapKey} annotation to key bindings by a type of a {@link Fragment}. */
+@Beta
+@MapKey
+@Target(METHOD)
+public @interface FragmentKey {
+  Class<? extends Fragment> value();
+}
diff --git a/java/dagger/android/HasDispatchingActivityInjector.java b/java/dagger/android/HasDispatchingActivityInjector.java
new file mode 100644
index 000000000..680139d89
--- /dev/null
+++ b/java/dagger/android/HasDispatchingActivityInjector.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import android.app.Activity;
+import dagger.internal.Beta;
+
+/** Provides a {@link DispatchingAndroidInjector} of {@link Activity}s. */
+@Beta
+public interface HasDispatchingActivityInjector {
+
+  /** Returns a {@link DispatchingAndroidInjector} of {@link Activity}s. */
+  DispatchingAndroidInjector<Activity> activityInjector();
+}
diff --git a/java/dagger/android/HasDispatchingFragmentInjector.java b/java/dagger/android/HasDispatchingFragmentInjector.java
new file mode 100644
index 000000000..f7d223a76
--- /dev/null
+++ b/java/dagger/android/HasDispatchingFragmentInjector.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import android.app.Fragment;
+import dagger.internal.Beta;
+
+/** Provides a {@link DispatchingAndroidInjector} of {@link Fragment}s. */
+@Beta
+public interface HasDispatchingFragmentInjector {
+
+  /** Returns a {@link DispatchingAndroidInjector} of {@link Fragment}s. */
+  DispatchingAndroidInjector<Fragment> fragmentInjector();
+}
diff --git a/java/dagger/android/support/AndroidManifest.xml b/java/dagger/android/support/AndroidManifest.xml
new file mode 100644
index 000000000..fc31038b6
--- /dev/null
+++ b/java/dagger/android/support/AndroidManifest.xml
@@ -0,0 +1,22 @@
+<!--
+  ~ Copyright (C) 2017 The Dagger Authors.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~ http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+  package="dagger.android.support">
+
+  <uses-sdk
+    android:minSdkVersion="14"
+    android:targetSdkVersion="24"/>
+</manifest>
diff --git a/java/dagger/android/support/AndroidSupportInjection.java b/java/dagger/android/support/AndroidSupportInjection.java
new file mode 100644
index 000000000..4fac2e62d
--- /dev/null
+++ b/java/dagger/android/support/AndroidSupportInjection.java
@@ -0,0 +1,94 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support;
+
+import static dagger.internal.Preconditions.checkNotNull;
+
+import android.app.Activity;
+import android.support.v4.app.Fragment;
+import android.util.Log;
+import dagger.android.DispatchingAndroidInjector;
+import dagger.internal.Beta;
+
+/** Injects core Android types from support libraries. */
+@Beta
+public final class AndroidSupportInjection {
+  private static final String TAG = "dagger.android.support";
+
+  /**
+   * Injects {@code fragment} if an associated {@link dagger.android.AndroidInjector.Factory}
+   * implementation can be found, otherwise throws an {@link IllegalArgumentException}.
+   *
+   * <p>Uses the following algorithm to find the appropriate {@code
+   * DispatchingAndroidInjector<Fragment>} to inject {@code fragment}:
+   *
+   * <ol>
+   *   <li>Walks the parent-fragment hierarchy to find the a fragment that implements {@link
+   *       HasDispatchingFragmentInjector}, and if none do
+   *   <li>Uses the {@code fragment}'s {@link Fragment#getActivity() activity} if it implements
+   *       {@link HasDispatchingFragmentInjector}, and if not
+   *   <li>Uses the {@link android.app.Application} if it implements {@link
+   *       HasDispatchingFragmentInjector}.
+   * </ol>
+   *
+   * If none of them implement {@link HasDispatchingFragmentInjector}, a {@link
+   * IllegalArgumentException} is thrown.
+   *
+   * @throws IllegalArgumentException if no {@code AndroidInjector.Factory<Fragment, ?>} is bound
+   *     for {@code fragment}.
+   */
+  public static void inject(Fragment fragment) {
+    checkNotNull(fragment, "fragment");
+    HasDispatchingFragmentInjector hasDispatchingFragmentInjector =
+        findHasFragmentInjector(fragment);
+    Log.d(
+        TAG,
+        String.format(
+            "An injector for %s was found in %s",
+            fragment.getClass().getCanonicalName(),
+            hasDispatchingFragmentInjector.getClass().getCanonicalName()));
+
+    DispatchingAndroidInjector<Fragment> fragmentInjector =
+        hasDispatchingFragmentInjector.fragmentInjector();
+    checkNotNull(
+        fragmentInjector,
+        "%s.fragmentInjector() returned null",
+        hasDispatchingFragmentInjector.getClass().getCanonicalName());
+
+    fragmentInjector.inject(fragment);
+  }
+
+  private static HasDispatchingFragmentInjector findHasFragmentInjector(Fragment fragment) {
+    Fragment parentFragment = fragment;
+    while ((parentFragment = parentFragment.getParentFragment()) != null) {
+      if (parentFragment instanceof HasDispatchingFragmentInjector) {
+        return (HasDispatchingFragmentInjector) parentFragment;
+      }
+    }
+    Activity activity = fragment.getActivity();
+    if (activity instanceof HasDispatchingFragmentInjector) {
+      return (HasDispatchingFragmentInjector) activity;
+    }
+    if (activity.getApplication() instanceof HasDispatchingFragmentInjector) {
+      return (HasDispatchingFragmentInjector) activity.getApplication();
+    }
+    throw new IllegalArgumentException(
+        String.format("No injector was found for %s", fragment.getClass().getCanonicalName()));
+  }
+
+  private AndroidSupportInjection() {}
+}
diff --git a/java/dagger/android/support/AndroidSupportInjectionModule.java b/java/dagger/android/support/AndroidSupportInjectionModule.java
new file mode 100644
index 000000000..ab12c3f11
--- /dev/null
+++ b/java/dagger/android/support/AndroidSupportInjectionModule.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support;
+
+import android.app.Activity;
+import android.app.Fragment;
+import dagger.Module;
+import dagger.android.AndroidInjector;
+import dagger.internal.Beta;
+import dagger.multibindings.Multibinds;
+import java.util.Map;
+
+/**
+ * Configures bindings to ensure the usability of {@code dagger.android} and {@code
+ * dagger.android.support} framework classes. This module should be installed in the root-most
+ * component which will use these types.
+ */
+@Beta
+@Module
+public abstract class AndroidSupportInjectionModule {
+  @Multibinds
+  abstract Map<Class<? extends Activity>, AndroidInjector.Factory<Activity, ?>>
+      activityInjectorFactories();
+
+  @Multibinds
+  abstract Map<Class<? extends Fragment>, AndroidInjector.Factory<Fragment, ?>>
+      fragmentInjectorFactories();
+
+  private AndroidSupportInjectionModule() {}
+}
diff --git a/java/dagger/android/support/BUILD b/java/dagger/android/support/BUILD
new file mode 100644
index 000000000..07f5656f8
--- /dev/null
+++ b/java/dagger/android/support/BUILD
@@ -0,0 +1,34 @@
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+# Description:
+#   Public Dagger API for Android that interacts with the Android support libraries
+
+package(default_visibility = ["//:src"])
+
+load("//:build_defs.bzl", "JAVA_6_SOURCE_LEVEL", "PRE_JAVA_8_INFERENCE_OPTS")
+
+android_library(
+    name = "support",
+    srcs = glob(["*.java"]),
+    javacopts = PRE_JAVA_8_INFERENCE_OPTS + JAVA_6_SOURCE_LEVEL,
+    manifest = "AndroidManifest.xml",
+    deps = [
+        "//:dagger_with_compiler",
+        "//java/dagger/android",
+        "@androidsdk//com.android.support:appcompat-v7-25.0.0",
+        "@androidsdk//com.android.support:support-annotations-25.0.0",
+        "@androidsdk//com.android.support:support-v4-25.0.0",
+    ],
+)
diff --git a/java/dagger/android/support/DaggerAppCompatActivity.java b/java/dagger/android/support/DaggerAppCompatActivity.java
new file mode 100644
index 000000000..6cfba5317
--- /dev/null
+++ b/java/dagger/android/support/DaggerAppCompatActivity.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support;
+
+import android.os.Bundle;
+import android.support.v4.app.Fragment;
+import android.support.v7.app.AppCompatActivity;
+import dagger.android.AndroidInjection;
+import dagger.android.DispatchingAndroidInjector;
+import dagger.internal.Beta;
+import javax.inject.Inject;
+
+/**
+ * An {@link AppCompatActivity} that injects its members in {@link #onCreate(Bundle)} and can be
+ * used to inject {@link Fragment}s attached to it.
+ */
+@Beta
+public abstract class DaggerAppCompatActivity extends AppCompatActivity
+    implements HasDispatchingFragmentInjector {
+
+  @Inject DispatchingAndroidInjector<Fragment> fragmentInjector;
+
+  @Override
+  protected void onCreate(Bundle savedInstanceState) {
+    super.onCreate(savedInstanceState);
+    AndroidInjection.inject(this);
+  }
+
+  @Override
+  public DispatchingAndroidInjector<Fragment> fragmentInjector() {
+    return fragmentInjector;
+  }
+}
diff --git a/java/dagger/android/support/DaggerFragment.java b/java/dagger/android/support/DaggerFragment.java
new file mode 100644
index 000000000..8ceace046
--- /dev/null
+++ b/java/dagger/android/support/DaggerFragment.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support;
+
+import android.content.Context;
+import android.support.v4.app.Fragment;
+import dagger.android.DispatchingAndroidInjector;
+import dagger.internal.Beta;
+import javax.inject.Inject;
+
+/**
+ * A {@link Fragment} that injects its members in {@link #onAttach(Context)} and can be used to
+ * inject child {@link Fragment}s attached to it. Note that when this fragment gets reattached, its
+ * members will be injected again.
+ */
+@Beta
+public abstract class DaggerFragment extends Fragment implements HasDispatchingFragmentInjector {
+
+  @Inject DispatchingAndroidInjector<Fragment> childFragmentInjector;
+
+  @Override
+  public void onAttach(Context context) {
+    super.onAttach(context);
+    AndroidSupportInjection.inject(this);
+  }
+
+  @Override
+  public DispatchingAndroidInjector<Fragment> fragmentInjector() {
+    return childFragmentInjector;
+  }
+}
diff --git a/java/dagger/android/support/FragmentKey.java b/java/dagger/android/support/FragmentKey.java
new file mode 100644
index 000000000..a5ecda4d7
--- /dev/null
+++ b/java/dagger/android/support/FragmentKey.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support;
+
+import static java.lang.annotation.ElementType.METHOD;
+
+import android.support.v4.app.Fragment;
+import dagger.MapKey;
+import dagger.internal.Beta;
+import java.lang.annotation.Target;
+
+/** {@link MapKey} annotation to key bindings by a type of a {@link Fragment}. */
+@Beta
+@MapKey
+@Target(METHOD)
+public @interface FragmentKey {
+  Class<? extends Fragment> value();
+}
diff --git a/java/dagger/android/support/HasDispatchingFragmentInjector.java b/java/dagger/android/support/HasDispatchingFragmentInjector.java
new file mode 100644
index 000000000..08d87808b
--- /dev/null
+++ b/java/dagger/android/support/HasDispatchingFragmentInjector.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support;
+
+import android.support.v4.app.Fragment;
+import dagger.android.DispatchingAndroidInjector;
+import dagger.internal.Beta;
+
+/** Provides a {@link DispatchingAndroidInjector} of {@link Fragment}s. */
+@Beta
+public interface HasDispatchingFragmentInjector {
+
+  /** Returns a {@link DispatchingAndroidInjector} of {@link Fragment}s. */
+  DispatchingAndroidInjector<Fragment> fragmentInjector();
+}
diff --git a/javatests/dagger/android/AndroidInjectionTest.java b/javatests/dagger/android/AndroidInjectionTest.java
new file mode 100644
index 000000000..a9eb315c4
--- /dev/null
+++ b/javatests/dagger/android/AndroidInjectionTest.java
@@ -0,0 +1,209 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+import android.app.Activity;
+import android.app.Application;
+import android.app.Fragment;
+import com.google.common.collect.ImmutableMap;
+import org.robolectric.RobolectricTestRunner;
+import dagger.android.AndroidInjector.Factory;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
+import org.robolectric.util.FragmentTestUtil;
+
+@Config(manifest = Config.NONE)
+@RunWith(RobolectricTestRunner.class)
+public final class AndroidInjectionTest {
+
+  // Most positive tests are performed in javatests/dagger/android/support/functional, but
+  // Robolectric's support for framework fragments is lacking, so we supplement those tests here:
+  public static class InjectableFragment extends Fragment {
+    String tag;
+  }
+
+  private static DispatchingAndroidInjector<Fragment> dispatchingFragmentInjector(String tag) {
+    return new DispatchingAndroidInjector<>(
+        ImmutableMap.of(
+            InjectableFragment.class,
+            () ->
+                new Factory<Fragment, InjectableFragment>() {
+                  @Override
+                  public AndroidInjector<InjectableFragment> create(Fragment fragment) {
+                    return f -> f.tag = tag;
+                  }
+                }));
+  }
+
+  public static class ApplicationInjectsFragment extends Application
+      implements HasDispatchingFragmentInjector {
+    @Override
+    public DispatchingAndroidInjector<Fragment> fragmentInjector() {
+      return dispatchingFragmentInjector("injected by app");
+    }
+  }
+
+  @Config(manifest = Config.NONE, application = ApplicationInjectsFragment.class)
+  @Test
+  public void fragmentInjectedByApplication() {
+    Activity activity = Robolectric.setupActivity(Activity.class);
+    InjectableFragment fragment = new InjectableFragment();
+    activity.getFragmentManager().beginTransaction().add(fragment, "tag").commit();
+
+    AndroidInjection.inject(fragment);
+
+    assertThat(fragment.tag).isEqualTo("injected by app");
+  }
+
+  public static class ActivityInjectsFragment extends Activity
+      implements HasDispatchingFragmentInjector {
+    @Override
+    public DispatchingAndroidInjector<Fragment> fragmentInjector() {
+      return dispatchingFragmentInjector("injected by activity");
+    }
+  }
+
+  @Config(manifest = Config.NONE, application = ApplicationInjectsFragment.class)
+  @Test
+  public void fragmentInjectedByActivity() {
+    ActivityInjectsFragment activity = Robolectric.setupActivity(ActivityInjectsFragment.class);
+    InjectableFragment fragment = new InjectableFragment();
+    activity.getFragmentManager().beginTransaction().add(fragment, "tag").commit();
+
+    AndroidInjection.inject(fragment);
+
+    assertThat(fragment.tag).isEqualTo("injected by activity");
+  }
+
+  public static class ParentFragmentInjectsChildFragment extends Fragment
+      implements HasDispatchingFragmentInjector {
+    @Override
+    public DispatchingAndroidInjector<Fragment> fragmentInjector() {
+      return dispatchingFragmentInjector("injected by parent fragment");
+    }
+  }
+
+  @Config(manifest = Config.NONE, application = ApplicationInjectsFragment.class)
+  @Test
+  public void fragmentInjectedByParentFragment() {
+    ActivityInjectsFragment activity = Robolectric.setupActivity(ActivityInjectsFragment.class);
+    ParentFragmentInjectsChildFragment parentFragment = new ParentFragmentInjectsChildFragment();
+    InjectableFragment childFragment = new InjectableFragment();
+
+    activity.getFragmentManager().beginTransaction().add(parentFragment, "tag").commit();
+    parentFragment
+        .getChildFragmentManager()
+        .beginTransaction()
+        .add(childFragment, "child-tag")
+        .commit();
+    AndroidInjection.inject(childFragment);
+
+    assertThat(childFragment.tag).isEqualTo("injected by parent fragment");
+  }
+
+  @Test
+  public void injectActivity_applicationDoesntImplementHasDispatchingActivityInjector() {
+    Activity activity = Robolectric.setupActivity(Activity.class);
+
+    try {
+      AndroidInjection.inject(activity);
+      fail();
+    } catch (Exception e) {
+      assertThat(e)
+          .hasMessageThat()
+          .contains("Application does not implement dagger.android.HasDispatchingActivityInjector");
+    }
+  }
+
+  @Test
+  public void injectFragment_hasDispatchingFragmentInjectorNotFound() {
+    Fragment fragment = new Fragment();
+    FragmentTestUtil.startFragment(fragment);
+
+    try {
+      AndroidInjection.inject(fragment);
+      fail();
+    } catch (Exception e) {
+      assertThat(e).hasMessageThat().contains("No injector was found");
+    }
+  }
+
+  private static class ApplicationReturnsNull extends Application
+      implements HasDispatchingActivityInjector, HasDispatchingFragmentInjector {
+    @Override
+    public DispatchingAndroidInjector<Activity> activityInjector() {
+      return null;
+    }
+
+    @Override
+    public DispatchingAndroidInjector<Fragment> fragmentInjector() {
+      return null;
+    }
+  }
+
+  @Test
+  @Config(manifest = Config.NONE, application = ApplicationReturnsNull.class)
+  public void dispatchingAndroidInjector_returnsNull() {
+    Activity activity = Robolectric.setupActivity(Activity.class);
+
+    try {
+      AndroidInjection.inject(activity);
+      fail();
+    } catch (Exception e) {
+      assertThat(e).hasMessageThat().contains("activityInjector() returned null");
+    }
+  }
+
+  @Test
+  @Config(manifest = Config.NONE, application = ApplicationReturnsNull.class)
+  public void dispatchingFragmentInjector_returnsNull() {
+    Fragment fragment = new Fragment();
+    FragmentTestUtil.startFragment(fragment);
+
+    try {
+      AndroidInjection.inject(fragment);
+      fail();
+    } catch (Exception e) {
+      assertThat(e).hasMessageThat().contains("fragmentInjector() returned null");
+    }
+  }
+
+  @Test
+  public void injectActivity_nullInput() {
+    try {
+      AndroidInjection.inject((Activity) null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessageThat().contains("activity");
+    }
+  }
+
+  @Test
+  public void injectFragment_nullInput() {
+    try {
+      AndroidInjection.inject((Fragment) null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessageThat().contains("fragment");
+    }
+  }
+}
diff --git a/javatests/dagger/android/BUILD b/javatests/dagger/android/BUILD
new file mode 100644
index 000000000..cf47d8be9
--- /dev/null
+++ b/javatests/dagger/android/BUILD
@@ -0,0 +1,34 @@
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+# Description:
+#   Tests for Dagger's Android integrations
+
+package(default_visibility = ["//:src"])
+
+load("//:build_defs.bzl", "DOCLINT_HTML_AND_SYNTAX")
+load("//:test_defs.bzl", "GenRobolectricTests")
+
+GenRobolectricTests(
+    name = "android_tests",
+    srcs = glob(["*.java"]),
+    javacopts = DOCLINT_HTML_AND_SYNTAX,
+    deps = [
+        "//:dagger_with_compiler",
+        "//java/dagger/android",
+        "//third_party:guava",
+        "//third_party:junit",
+        "//third_party:truth",
+    ],
+)
diff --git a/javatests/dagger/android/DispatchingAndroidInjectorTest.java b/javatests/dagger/android/DispatchingAndroidInjectorTest.java
new file mode 100644
index 000000000..69f94ec29
--- /dev/null
+++ b/javatests/dagger/android/DispatchingAndroidInjectorTest.java
@@ -0,0 +1,102 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+import android.app.Activity;
+import org.robolectric.RobolectricTestRunner;
+import dagger.android.DispatchingAndroidInjector.InvalidInjectorBindingException;
+import java.util.HashMap;
+import java.util.Map;
+import javax.inject.Provider;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
+
+@Config(manifest = Config.NONE)
+@RunWith(RobolectricTestRunner.class)
+public final class DispatchingAndroidInjectorTest {
+  private DispatchingAndroidInjector<Activity> dispatchingAndroidInjector;
+
+  @Before
+  public void setup() {
+    Map<Class<? extends Activity>, Provider<AndroidInjector.Factory<Activity, ?>>>
+        injectorFactories = new HashMap<>();
+    injectorFactories.put(FooActivity.class, FooInjector.Factory::new);
+    injectorFactories.put(ReturnsNullActivity.class, () -> null);
+    injectorFactories.put(WrongActivity.class, FooInjector.Factory::new);
+    dispatchingAndroidInjector = new DispatchingAndroidInjector<>(injectorFactories);
+  }
+
+  @Test
+  public void maybeInject_returnsTrue_ifMatchingInjectorExists() {
+    FooActivity fooActivity = Robolectric.setupActivity(FooActivity.class);
+    assertThat(dispatchingAndroidInjector.maybeInject(fooActivity)).isTrue();
+  }
+
+  @Test
+  public void maybeInject_returnsFalse_ifNoMatchingInjectorExists() {
+    BarActivity barActivity = Robolectric.setupActivity(BarActivity.class);
+    assertThat(dispatchingAndroidInjector.maybeInject(barActivity)).isFalse();
+  }
+
+  @Test
+  public void throwsIfFactoryCreateReturnsNull() {
+    ReturnsNullActivity returnsNullActivity = Robolectric.setupActivity(ReturnsNullActivity.class);
+
+    try {
+      dispatchingAndroidInjector.maybeInject(returnsNullActivity);
+      fail("Expected NullPointerException");
+    } catch (NullPointerException expected) {
+    }
+  }
+
+  @Test
+  public void throwsIfClassMismatched() {
+    WrongActivity wrongActivity = Robolectric.setupActivity(WrongActivity.class);
+
+    try {
+      dispatchingAndroidInjector.maybeInject(wrongActivity);
+      fail("Expected InvalidInjectorBindingException");
+    } catch (InvalidInjectorBindingException expected) {
+    }
+  }
+
+  static class FooActivity extends Activity {}
+
+  static class BarActivity extends Activity {}
+
+  static class ReturnsNullActivity extends Activity {}
+
+  static class WrongActivity extends Activity {}
+
+  static class FooInjector implements AndroidInjector<FooActivity> {
+    @Override
+    public void inject(FooActivity instance) {}
+
+    static class Factory implements AndroidInjector.Factory<Activity, FooActivity> {
+      @Override
+      public AndroidInjector<FooActivity> create(Activity activity) {
+        return new FooInjector();
+      }
+    }
+  }
+}
diff --git a/javatests/dagger/android/support/AndroidSupportInjectionTest.java b/javatests/dagger/android/support/AndroidSupportInjectionTest.java
new file mode 100644
index 000000000..b5835b853
--- /dev/null
+++ b/javatests/dagger/android/support/AndroidSupportInjectionTest.java
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+import android.app.Application;
+import android.support.v4.app.Fragment;
+import org.robolectric.RobolectricTestRunner;
+import dagger.android.DispatchingAndroidInjector;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadows.support.v4.SupportFragmentTestUtil;
+
+@Config(manifest = Config.NONE)
+@RunWith(RobolectricTestRunner.class)
+public final class AndroidSupportInjectionTest {
+  @Test
+  public void injectFragment_simpleApplication() {
+    Fragment fragment = new Fragment();
+    SupportFragmentTestUtil.startFragment(fragment);
+
+    try {
+      AndroidSupportInjection.inject(fragment);
+      fail();
+    } catch (Exception e) {
+      assertThat(e).hasMessageThat().contains("No injector was found");
+    }
+  }
+
+  private static class ApplicationReturnsNull extends Application
+      implements HasDispatchingFragmentInjector {
+    @Override
+    public DispatchingAndroidInjector<Fragment> fragmentInjector() {
+      return null;
+    }
+  }
+
+  @Test
+  @Config(manifest = Config.NONE, application = ApplicationReturnsNull.class)
+  public void dispatchingFragmentInjector_returnsNull() {
+    Fragment fragment = new Fragment();
+    SupportFragmentTestUtil.startFragment(fragment);
+
+    try {
+      AndroidSupportInjection.inject(fragment);
+      fail();
+    } catch (Exception e) {
+      assertThat(e).hasMessageThat().contains("fragmentInjector() returned null");
+    }
+  }
+
+  @Test
+  public void injectFragment_nullInput() {
+    try {
+      AndroidSupportInjection.inject(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessageThat().contains("fragment");
+    }
+  }
+}
diff --git a/javatests/dagger/android/support/BUILD b/javatests/dagger/android/support/BUILD
new file mode 100644
index 000000000..c194709bf
--- /dev/null
+++ b/javatests/dagger/android/support/BUILD
@@ -0,0 +1,37 @@
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+# Description:
+#   Tests for Dagger's Android and Support library integrations
+
+package(default_visibility = ["//:src"])
+
+load("//:build_defs.bzl", "DOCLINT_HTML_AND_SYNTAX")
+load("//:test_defs.bzl", "GenRobolectricTests")
+
+GenRobolectricTests(
+    name = "android-support-tests",
+    srcs = glob(["*.java"]),
+    javacopts = DOCLINT_HTML_AND_SYNTAX,
+    deps = [
+        "//:dagger_with_compiler",
+        "//java/dagger/android",
+        "//java/dagger/android/support",
+        "//third_party:guava",
+        "//third_party:junit",
+        "//third_party:truth",
+        "@androidsdk//com.android.support:appcompat-v7-25.0.0",
+        "@androidsdk//com.android.support:support-v4-25.0.0",
+    ],
+)
diff --git a/javatests/dagger/android/support/functional/AllControllersAreDirectChildrenOfApplication.java b/javatests/dagger/android/support/functional/AllControllersAreDirectChildrenOfApplication.java
new file mode 100644
index 000000000..63a940f79
--- /dev/null
+++ b/javatests/dagger/android/support/functional/AllControllersAreDirectChildrenOfApplication.java
@@ -0,0 +1,133 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support.functional;
+
+import android.app.Activity;
+import android.app.Application;
+import android.support.v4.app.Fragment;
+import dagger.Binds;
+import dagger.Component;
+import dagger.Module;
+import dagger.Provides;
+import dagger.Subcomponent;
+import dagger.android.ActivityKey;
+import dagger.android.AndroidInjector;
+import dagger.android.DispatchingAndroidInjector;
+import dagger.android.HasDispatchingActivityInjector;
+import dagger.android.support.FragmentKey;
+import dagger.multibindings.IntoMap;
+import dagger.multibindings.IntoSet;
+import javax.inject.Inject;
+
+public final class AllControllersAreDirectChildrenOfApplication extends Application
+    implements HasDispatchingActivityInjector {
+  @Inject DispatchingAndroidInjector<Activity> activityInjector;
+
+  @Override
+  public void onCreate() {
+    super.onCreate();
+    DaggerAllControllersAreDirectChildrenOfApplication_ApplicationComponent.create().inject(this);
+  }
+
+  @Override
+  public DispatchingAndroidInjector<Activity> activityInjector() {
+    return activityInjector;
+  }
+
+  @Component(modules = ApplicationComponent.ApplicationModule.class)
+  interface ApplicationComponent {
+    void inject(AllControllersAreDirectChildrenOfApplication application);
+
+    @Module(
+      subcomponents = {
+        ActivitySubcomponent.class,
+        ParentFragmentSubcomponent.class,
+        ChildFragmentSubcomponent.class
+      }
+    )
+    abstract class ApplicationModule {
+      @Provides
+      @IntoSet
+      static Class<?> addToComponentHierarchy() {
+        return ApplicationComponent.class;
+      }
+
+      @Binds
+      @IntoMap
+      @ActivityKey(TestActivity.class)
+      abstract AndroidInjector.Factory<Activity, ?> bindFactoryForTestActivity(
+          ActivitySubcomponent.Builder builder);
+
+      @Binds
+      @IntoMap
+      @FragmentKey(TestParentFragment.class)
+      abstract AndroidInjector.Factory<Fragment, ?> bindFactoryForParentFragment(
+          ParentFragmentSubcomponent.Builder builder);
+
+      @Binds
+      @IntoMap
+      @FragmentKey(TestChildFragment.class)
+      abstract AndroidInjector.Factory<Fragment, ?> bindFactoryForChildFragment(
+          ChildFragmentSubcomponent.Builder builder);
+    }
+
+    @Subcomponent(modules = ActivitySubcomponent.ActivityModule.class)
+    interface ActivitySubcomponent extends AndroidInjector<TestActivity> {
+      @Module
+      abstract class ActivityModule {
+        @Provides
+        @IntoSet
+        static Class<?> addToComponentHierarchy() {
+          return ActivitySubcomponent.class;
+        }
+      }
+
+      @Subcomponent.Builder
+      abstract class Builder extends AndroidInjector.Builder<Activity, TestActivity> {}
+    }
+
+    @Subcomponent(modules = ParentFragmentSubcomponent.ParentFragmentModule.class)
+    interface ParentFragmentSubcomponent extends AndroidInjector<TestParentFragment> {
+      @Module
+      abstract class ParentFragmentModule {
+        @Provides
+        @IntoSet
+        static Class<?> addToComponentHierarchy() {
+          return ParentFragmentSubcomponent.class;
+        }
+      }
+
+      @Subcomponent.Builder
+      abstract class Builder extends AndroidInjector.Builder<Fragment, TestParentFragment> {}
+    }
+
+    @Subcomponent(modules = ChildFragmentSubcomponent.ChildFragmentModule.class)
+    interface ChildFragmentSubcomponent extends AndroidInjector<TestChildFragment> {
+      @Module
+      abstract class ChildFragmentModule {
+        @Provides
+        @IntoSet
+        static Class<?> addToComponentHierarchy() {
+          return ChildFragmentSubcomponent.class;
+        }
+      }
+
+      @Subcomponent.Builder
+      abstract class Builder extends AndroidInjector.Builder<Fragment, TestChildFragment> {}
+    }
+  }
+}
diff --git a/javatests/dagger/android/support/functional/AndroidManifest.xml b/javatests/dagger/android/support/functional/AndroidManifest.xml
new file mode 100644
index 000000000..1ace8cb8f
--- /dev/null
+++ b/javatests/dagger/android/support/functional/AndroidManifest.xml
@@ -0,0 +1,24 @@
+<!--
+  ~ Copyright (C) 2017 The Dagger Authors.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~ http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+  package="dagger.android.support.functional">
+
+  <application android:theme="@style/Theme.AppCompat">
+    <activity android:name="dagger.android.support.functional.ParentOfFragmentActivity"/>
+    <activity android:name="dagger.android.support.functional.SiblingOfFragmentActivity"/>
+    <activity android:name="dagger.android.support.functional.InjectedWithoutSubcomponentActivity"/>
+  </application>
+</manifest>
diff --git a/javatests/dagger/android/support/functional/BUILD b/javatests/dagger/android/support/functional/BUILD
new file mode 100644
index 000000000..ee7a3050f
--- /dev/null
+++ b/javatests/dagger/android/support/functional/BUILD
@@ -0,0 +1,52 @@
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+# Description:
+#   Functional test code for Dagger-Android
+
+package(default_visibility = ["//:src"])
+
+android_library(
+    name = "functional",
+    srcs = glob(
+        ["*.java"],
+        exclude = ["*Test.java"],
+    ),
+    manifest = "AndroidManifest.xml",
+    resource_files = glob(["res/**"]),
+    deps = [
+        "//:dagger_with_compiler",
+        "//java/dagger/android",
+        "//java/dagger/android/support",
+        "//third_party:guava",
+        "@androidsdk//com.android.support:appcompat-v7-25.0.0",
+        "@androidsdk//com.android.support:support-v4-25.0.0",
+    ],
+)
+
+load("//:test_defs.bzl", "GenRobolectricTests")
+
+GenRobolectricTests(
+    name = "functional_tests",
+    srcs = glob(["*Test.java"]),
+    deps = [
+        ":functional",
+        "//:dagger_with_compiler",
+        "//java/dagger/android",
+        "//java/dagger/android/support",
+        "//third_party:junit",
+        "//third_party:truth",
+        "@androidsdk//com.android.support:support-v4-25.0.0",
+    ],
+)
diff --git a/javatests/dagger/android/support/functional/ComponentStructureFollowsControllerStructureApplication.java b/javatests/dagger/android/support/functional/ComponentStructureFollowsControllerStructureApplication.java
new file mode 100644
index 000000000..98f931548
--- /dev/null
+++ b/javatests/dagger/android/support/functional/ComponentStructureFollowsControllerStructureApplication.java
@@ -0,0 +1,128 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support.functional;
+
+import android.app.Activity;
+import android.app.Application;
+import android.support.v4.app.Fragment;
+import dagger.Binds;
+import dagger.Component;
+import dagger.Module;
+import dagger.Provides;
+import dagger.Subcomponent;
+import dagger.android.ActivityKey;
+import dagger.android.AndroidInjector;
+import dagger.android.DispatchingAndroidInjector;
+import dagger.android.HasDispatchingActivityInjector;
+import dagger.android.support.FragmentKey;
+import dagger.multibindings.IntoMap;
+import dagger.multibindings.IntoSet;
+import javax.inject.Inject;
+
+public final class ComponentStructureFollowsControllerStructureApplication extends Application
+    implements HasDispatchingActivityInjector {
+  @Inject DispatchingAndroidInjector<Activity> activityInjector;
+
+  @Override
+  public void onCreate() {
+    super.onCreate();
+    DaggerComponentStructureFollowsControllerStructureApplication_ApplicationComponent.create()
+        .inject(this);
+  }
+
+  @Override
+  public DispatchingAndroidInjector<Activity> activityInjector() {
+    return activityInjector;
+  }
+
+  @Component(modules = ApplicationComponent.ApplicationModule.class)
+  interface ApplicationComponent {
+    void inject(ComponentStructureFollowsControllerStructureApplication application);
+
+    @Module(subcomponents = ActivitySubcomponent.class)
+    abstract class ApplicationModule {
+      @Provides
+      @IntoSet
+      static Class<?> addToComponentHierarchy() {
+        return ApplicationComponent.class;
+      }
+
+      @Binds
+      @IntoMap
+      @ActivityKey(TestActivity.class)
+      abstract AndroidInjector.Factory<Activity, ?> bindFactoryForTestActivity(
+          ActivitySubcomponent.Builder builder);
+    }
+
+    @Subcomponent(modules = ActivitySubcomponent.ActivityModule.class)
+    interface ActivitySubcomponent extends AndroidInjector<TestActivity> {
+      @Module(subcomponents = ParentFragmentSubcomponent.class)
+      abstract class ActivityModule {
+        @Provides
+        @IntoSet
+        static Class<?> addToComponentHierarchy() {
+          return ActivitySubcomponent.class;
+        }
+
+        @Binds
+        @IntoMap
+        @FragmentKey(TestParentFragment.class)
+        abstract AndroidInjector.Factory<Fragment, ?> bindFactoryForParentFragment(
+            ParentFragmentSubcomponent.Builder builder);
+      }
+
+      @Subcomponent.Builder
+      abstract class Builder extends AndroidInjector.Builder<Activity, TestActivity> {}
+
+      @Subcomponent(modules = ParentFragmentSubcomponent.ParentFragmentModule.class)
+      interface ParentFragmentSubcomponent extends AndroidInjector<TestParentFragment> {
+        @Module(subcomponents = ChildFragmentSubcomponent.class)
+        abstract class ParentFragmentModule {
+          @Provides
+          @IntoSet
+          static Class<?> addToComponentHierarchy() {
+            return ParentFragmentSubcomponent.class;
+          }
+
+          @Binds
+          @IntoMap
+          @FragmentKey(TestChildFragment.class)
+          abstract AndroidInjector.Factory<Fragment, ?> bindFactoryForChildFragment(
+              ChildFragmentSubcomponent.Builder builder);
+        }
+
+        @Subcomponent.Builder
+        abstract class Builder extends AndroidInjector.Builder<Fragment, TestParentFragment> {}
+
+        @Subcomponent(modules = ChildFragmentSubcomponent.ChildFragmentModule.class)
+        interface ChildFragmentSubcomponent extends AndroidInjector<TestChildFragment> {
+          @Module
+          abstract class ChildFragmentModule {
+            @Provides
+            @IntoSet
+            static Class<?> addToComponentHierarchy() {
+              return ChildFragmentSubcomponent.class;
+            }
+          }
+
+          @Subcomponent.Builder
+          abstract class Builder extends AndroidInjector.Builder<Fragment, TestChildFragment> {}
+        }
+      }
+    }
+  }
+}
diff --git a/javatests/dagger/android/support/functional/InjectorsTest.java b/javatests/dagger/android/support/functional/InjectorsTest.java
new file mode 100644
index 000000000..0aa42c9c1
--- /dev/null
+++ b/javatests/dagger/android/support/functional/InjectorsTest.java
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support.functional;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import org.robolectric.RobolectricTestRunner;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+public class InjectorsTest {
+  private static final String MANIFEST =
+      "//javatests/dagger/android/support/functional"
+          + ":functional/AndroidManifest.xml";
+  private TestActivity activity;
+  private TestParentFragment parentFragment;
+  private TestChildFragment childFragment;
+
+  @Before
+  public void setUp() {
+    activity = Robolectric.setupActivity(TestActivity.class);
+    parentFragment =
+        (TestParentFragment)
+            activity.getSupportFragmentManager().findFragmentByTag("parent-fragment");
+    childFragment =
+        (TestChildFragment)
+            parentFragment.getChildFragmentManager().findFragmentByTag("child-fragment");
+  }
+
+  @Test
+  @Config(
+    manifest = MANIFEST,
+    application = ComponentStructureFollowsControllerStructureApplication.class
+  )
+  public void componentStructureFollowsControllerStructure() {
+    assertThat(activity.componentHierarchy)
+        .containsExactly(
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent.class,
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent
+                .ActivitySubcomponent.class);
+    assertThat(parentFragment.componentHierarchy)
+        .containsExactly(
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent.class,
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent
+                .ActivitySubcomponent.class,
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent
+                .ActivitySubcomponent.ParentFragmentSubcomponent.class);
+    assertThat(childFragment.componentHierarchy)
+        .containsExactly(
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent.class,
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent
+                .ActivitySubcomponent.class,
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent
+                .ActivitySubcomponent.ParentFragmentSubcomponent.class,
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent
+                .ActivitySubcomponent.ParentFragmentSubcomponent.ChildFragmentSubcomponent.class);
+  }
+
+  @Test
+  @Config(manifest = MANIFEST, application = AllControllersAreDirectChildrenOfApplication.class)
+  public void AllControllersAreDirectChildrenOfApplication() {
+    assertThat(activity.componentHierarchy)
+        .containsExactly(
+            AllControllersAreDirectChildrenOfApplication.ApplicationComponent.class,
+            AllControllersAreDirectChildrenOfApplication.ApplicationComponent.ActivitySubcomponent
+                .class);
+    assertThat(parentFragment.componentHierarchy)
+        .containsExactly(
+            AllControllersAreDirectChildrenOfApplication.ApplicationComponent.class,
+            AllControllersAreDirectChildrenOfApplication.ApplicationComponent
+                .ParentFragmentSubcomponent.class);
+    assertThat(childFragment.componentHierarchy)
+        .containsExactly(
+            AllControllersAreDirectChildrenOfApplication.ApplicationComponent.class,
+            AllControllersAreDirectChildrenOfApplication.ApplicationComponent
+                .ChildFragmentSubcomponent.class);
+  }
+}
diff --git a/javatests/dagger/android/support/functional/TestActivity.java b/javatests/dagger/android/support/functional/TestActivity.java
new file mode 100644
index 000000000..c4fda4293
--- /dev/null
+++ b/javatests/dagger/android/support/functional/TestActivity.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support.functional;
+
+import android.os.Bundle;
+import dagger.android.support.DaggerAppCompatActivity;
+import java.util.Set;
+import javax.inject.Inject;
+
+public final class TestActivity extends DaggerAppCompatActivity {
+  @Inject Set<Class<?>> componentHierarchy;
+
+  @Override
+  protected void onCreate(Bundle savedInstanceState) {
+    super.onCreate(savedInstanceState);
+
+    setContentView(R.layout.activity_layout);
+
+    getSupportFragmentManager()
+        .beginTransaction()
+        .add(new TestParentFragment(), "parent-fragment")
+        .commit();
+  }
+}
diff --git a/javatests/dagger/android/support/functional/TestChildFragment.java b/javatests/dagger/android/support/functional/TestChildFragment.java
new file mode 100644
index 000000000..781c57809
--- /dev/null
+++ b/javatests/dagger/android/support/functional/TestChildFragment.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support.functional;
+
+import dagger.android.support.DaggerFragment;
+import java.util.Set;
+import javax.inject.Inject;
+
+public final class TestChildFragment extends DaggerFragment {
+  @Inject Set<Class<?>> componentHierarchy;
+}
diff --git a/javatests/dagger/android/support/functional/TestParentFragment.java b/javatests/dagger/android/support/functional/TestParentFragment.java
new file mode 100644
index 000000000..6d2d6f47d
--- /dev/null
+++ b/javatests/dagger/android/support/functional/TestParentFragment.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support.functional;
+
+import android.content.Context;
+import dagger.android.support.DaggerFragment;
+import java.util.Set;
+import javax.inject.Inject;
+
+public final class TestParentFragment extends DaggerFragment {
+  @Inject Set<Class<?>> componentHierarchy;
+
+  @Override
+  public void onAttach(Context context) {
+    super.onAttach(context);
+    getChildFragmentManager()
+        .beginTransaction()
+        .add(new TestChildFragment(), "child-fragment")
+        .commit();
+  }
+}
diff --git a/javatests/dagger/android/support/functional/res/layout/activity_layout.xml b/javatests/dagger/android/support/functional/res/layout/activity_layout.xml
new file mode 100644
index 000000000..d886d971d
--- /dev/null
+++ b/javatests/dagger/android/support/functional/res/layout/activity_layout.xml
@@ -0,0 +1,21 @@
+<!--
+  ~ Copyright (C) 2016 The Dagger Authors.
+  ~
+  ~  Licensed under the Apache License, Version 2.0 (the "License");
+  ~  you may not use this file except in compliance with the License.
+  ~  You may obtain a copy of the License at
+  ~
+  ~  http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~  Unless required by applicable law or agreed to in writing, software
+  ~  distributed under the License is distributed on an "AS IS" BASIS,
+  ~  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~  See the License for the specific language governing permissions and
+  ~  limitations under the License.
+  -->
+
+<FrameLayout
+  xmlns:android="http://schemas.android.com/apk/res/android"
+  android:id="@+id/fragment_container"
+  android:layout_width="match_parent"
+  android:layout_height="match_parent" />
