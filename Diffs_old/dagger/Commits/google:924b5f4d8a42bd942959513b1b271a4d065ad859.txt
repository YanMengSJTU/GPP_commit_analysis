diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index 7bd476a33..e3ec68126 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -51,6 +51,7 @@
 import javax.lang.model.util.Elements;
 
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
+import static com.google.common.base.Verify.verify;
 import static dagger.internal.codegen.ComponentDescriptor.isComponentContributionMethod;
 import static dagger.internal.codegen.ComponentDescriptor.isComponentProductionMethod;
 import static dagger.internal.codegen.ComponentDescriptor.Kind.PRODUCTION_COMPONENT;
@@ -168,7 +169,7 @@ private BindingGraph create(Optional<RequestResolver> parentResolver,
 
       RequestResolver requestResolver = new RequestResolver(
           parentResolver,
-          componentDescriptor.wrappedScope(),
+          componentDescriptor,
           explicitBindingsByKey(explicitProvisionBindingsBuilder.build()),
           explicitBindingsByKey(explicitProductionBindingsBuilder.build()));
       for (ComponentMethodDescriptor componentMethod : componentDescriptor.componentMethods()) {
@@ -186,6 +187,14 @@ private BindingGraph create(Optional<RequestResolver> parentResolver,
             create(Optional.of(requestResolver), subcomponentEntry.getValue()));
       }
 
+      for (ResolvedBindings resolvedBindings : requestResolver.getResolvedBindings().values()) {
+        verify(
+            resolvedBindings.owningComponent().equals(componentDescriptor),
+            "%s is not owned by %s",
+            resolvedBindings,
+            componentDescriptor);
+      }
+
       return new AutoValue_BindingGraph(
           componentDescriptor,
           requestResolver.getResolvedBindings(),
@@ -204,7 +213,7 @@ private BindingGraph create(Optional<RequestResolver> parentResolver,
 
     private final class RequestResolver {
       final Optional<RequestResolver> parentResolver;
-      final Optional<Equivalence.Wrapper<AnnotationMirror>> targetScope;
+      final ComponentDescriptor componentDescriptor;
       final ImmutableSetMultimap<Key, ProvisionBinding> explicitProvisionBindings;
       final ImmutableSet<ProvisionBinding> explicitProvisionBindingsSet;
       final ImmutableSetMultimap<Key, ProductionBinding> explicitProductionBindings;
@@ -213,14 +222,15 @@ private BindingGraph create(Optional<RequestResolver> parentResolver,
       final Cache<BindingKey, Boolean> dependsOnLocalMultibindingsCache =
           CacheBuilder.newBuilder().<BindingKey, Boolean>build();
 
-      RequestResolver(Optional<RequestResolver> parentResolver,
-          Optional<Equivalence.Wrapper<AnnotationMirror>> targetScope,
+      RequestResolver(
+          Optional<RequestResolver> parentResolver,
+          ComponentDescriptor componentDescriptor,
           ImmutableSetMultimap<Key, ProvisionBinding> explicitProvisionBindings,
           ImmutableSetMultimap<Key, ProductionBinding> explicitProductionBindings) {
         assert parentResolver != null;
         this.parentResolver = parentResolver;
-        assert targetScope != null;
-        this.targetScope = targetScope;
+        assert componentDescriptor != null;
+        this.componentDescriptor = componentDescriptor;
         assert explicitProvisionBindings != null;
         this.explicitProvisionBindings = explicitProvisionBindings;
         this.explicitProvisionBindingsSet = ImmutableSet.copyOf(explicitProvisionBindings.values());
@@ -263,17 +273,21 @@ ResolvedBindings lookUpBindings(DependencyRequest request) {
               // we have some explicit binding for this key, so we collect all explicit implicit map
               // bindings that might conflict with this and let the validator sort it out
               ImmutableSet.Builder<ContributionBinding> ownedBindings = ImmutableSet.builder();
-              ImmutableSet.Builder<ContributionBinding> inheritedBindings = ImmutableSet.builder();
+              ImmutableSetMultimap.Builder<ComponentDescriptor, ContributionBinding>
+                  inheritedBindings = ImmutableSetMultimap.builder();
               for (ProvisionBinding provisionBinding :
                   Sets.union(explicitProvisionBindingsForKey, explicitMapProvisionBindings)) {
                 if (isResolvedInParent(request, provisionBinding)
                     && !shouldOwnParentBinding(request, provisionBinding)) {
-                  inheritedBindings.add(provisionBinding);
+                  inheritedBindings.put(
+                      getOwningResolver(provisionBinding).get().componentDescriptor,
+                      provisionBinding);
                 } else {
                   ownedBindings.add(provisionBinding);
                 }
               }
               return ResolvedBindings.create(bindingKey,
+                  componentDescriptor,
                   ownedBindings
                       .addAll(explicitProductionBindingsForKey)
                       .addAll(explicitMapProductionBindings)
@@ -285,14 +299,18 @@ ResolvedBindings lookUpBindings(DependencyRequest request) {
                 // must be considered an implicit ProductionBinding
                 DependencyRequest implicitRequest =
                     dependencyRequestFactory.forImplicitMapBinding(request, mapProducerKey.get());
-                return ResolvedBindings.create(bindingKey,
+                return ResolvedBindings.create(
+                    bindingKey,
+                    componentDescriptor,
                     productionBindingFactory.forImplicitMapBinding(request, implicitRequest));
               } else if (!explicitMapProvisionBindings.isEmpty()) {
                 // if there are Map<K, Provider<V>> bindings, then it'll be an implicit
                 // ProvisionBinding
                 DependencyRequest implicitRequest =
                     dependencyRequestFactory.forImplicitMapBinding(request, mapProviderKey.get());
-                return ResolvedBindings.create(bindingKey,
+                return ResolvedBindings.create(
+                    bindingKey,
+                    componentDescriptor,
                     provisionBindingFactory.forImplicitMapBinding(request, implicitRequest));
               } else {
                 // no explicit binding, look it up.
@@ -302,17 +320,27 @@ ResolvedBindings lookUpBindings(DependencyRequest request) {
                   if (isResolvedInParent(request, provisionBinding.get())
                       && !shouldOwnParentBinding(request, provisionBinding.get())) {
                     return ResolvedBindings.create(
-                        bindingKey, ImmutableSet.<Binding>of(), provisionBinding.asSet());
+                        bindingKey,
+                        componentDescriptor,
+                        ImmutableSet.<Binding>of(),
+                        ImmutableSetMultimap.of(
+                            getOwningResolver(provisionBinding.get()).get().componentDescriptor,
+                            provisionBinding.get()));
                   }
                 }
                 return ResolvedBindings.create(
-                    bindingKey, provisionBinding.asSet(), ImmutableSet.<Binding>of());
+                    bindingKey,
+                    componentDescriptor,
+                    provisionBinding.asSet(),
+                    ImmutableSetMultimap.<ComponentDescriptor, Binding>of());
               }
             }
           case MEMBERS_INJECTION:
             // no explicit deps for members injection, so just look it up
             return ResolvedBindings.create(
-                bindingKey, rollUpMembersInjectionBindings(bindingKey.key()));
+                bindingKey,
+                componentDescriptor,
+                rollUpMembersInjectionBindings(bindingKey.key()));
           default:
             throw new AssertionError();
         }
@@ -376,7 +404,7 @@ private MembersInjectionBinding rollUpMembersInjectionBindings(Key key) {
             provisionBinding.wrappedScope();
         if (bindingScope.isPresent()) {
           for (RequestResolver requestResolver : getResolverLineage().reverse()) {
-            if (bindingScope.equals(requestResolver.targetScope)) {
+            if (bindingScope.equals(requestResolver.componentDescriptor.wrappedScope())) {
               return Optional.of(requestResolver);
             }
           }
@@ -537,7 +565,8 @@ private boolean isScoped(Binding binding) {
                   .values();
           for (ResolvedBindings resolvedInParent : bindingsResolvedInParent) {
             resolvedBindingsBuilder.put(
-                resolvedInParent.bindingKey(), resolvedInParent.asInherited());
+                resolvedInParent.bindingKey(),
+                resolvedInParent.asInheritedIn(componentDescriptor));
           }
         }
         return resolvedBindingsBuilder.build();
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 3ddf36c45..b957f9363 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -30,6 +30,7 @@
 import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Ordering;
@@ -917,12 +918,12 @@ private boolean isImplicitProviderMapForValueMap(
               getValueTypeOfMap(asDeclared(maybeValueMapRequestType)));
     }
   }
-  
+
   private boolean suppressCycleWarnings(Element requestElement) {
     SuppressWarnings suppressions = requestElement.getAnnotation(SuppressWarnings.class);
     return suppressions != null && Arrays.asList(suppressions.value()).contains("dependency-cycle");
   }
-  
+
   private boolean suppressCycleWarnings(ImmutableList<DependencyRequest> pathElements) {
     for (DependencyRequest dependencyRequest : pathElements) {
       if (suppressCycleWarnings(dependencyRequest.requestElement())) {
@@ -1049,7 +1050,9 @@ static ResolvedRequest create(DependencyRequest request, BindingGraph graph) {
       return new AutoValue_BindingGraphValidator_ResolvedRequest(request,
           resolvedBindings == null
               ? ResolvedBindings.create(bindingKey,
-                  ImmutableSet.<Binding>of(), ImmutableSet.<Binding>of())
+                  graph.componentDescriptor(),
+                  ImmutableSet.<Binding>of(),
+                  ImmutableSetMultimap.<ComponentDescriptor, Binding>of())
               : resolvedBindings);
     }
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
index 609f034c5..7ef4deb92 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
@@ -17,6 +17,8 @@
 
 import com.google.auto.value.AutoValue;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ImmutableSetMultimap;
+import com.google.common.collect.Multimap;
 import java.util.Set;
 
 import static com.google.common.base.Preconditions.checkState;
@@ -30,28 +32,38 @@
 @AutoValue
 abstract class ResolvedBindings {
   abstract BindingKey bindingKey();
+  abstract ComponentDescriptor owningComponent();
   abstract ImmutableSet<? extends Binding> ownedBindings();
-  abstract ImmutableSet<? extends Binding> bindings();
+  abstract ImmutableSetMultimap<ComponentDescriptor, ? extends Binding> inheritedBindings();
 
   static ResolvedBindings create(
       BindingKey bindingKey,
+      ComponentDescriptor owningComponent,
       Set<? extends Binding> ownedBindings,
-      Set<? extends Binding> inheritedBindings) {
-    ImmutableSet<Binding> immutableOwnedBindings = ImmutableSet.<Binding>copyOf(ownedBindings);
+      Multimap<ComponentDescriptor, ? extends Binding> inheritedBindings) {
     return new AutoValue_ResolvedBindings(
-        bindingKey,
-        immutableOwnedBindings,
-        ImmutableSet.<Binding>builder()
-        .addAll(inheritedBindings)
-        .addAll(immutableOwnedBindings)
-        .build());
+            bindingKey,
+            owningComponent,
+            ImmutableSet.copyOf(ownedBindings),
+            ImmutableSetMultimap.copyOf(inheritedBindings));
   }
 
   static ResolvedBindings create(
       BindingKey bindingKey,
+      ComponentDescriptor owningComponent,
       Binding... ownedBindings) {
-    ImmutableSet<Binding> bindings = ImmutableSet.copyOf(ownedBindings);
-    return new AutoValue_ResolvedBindings(bindingKey, bindings, bindings);
+    return new AutoValue_ResolvedBindings(
+        bindingKey,
+        owningComponent,
+        ImmutableSet.copyOf(ownedBindings),
+        ImmutableSetMultimap.<ComponentDescriptor, Binding>of());
+  }
+
+  ImmutableSet<? extends Binding> bindings() {
+     return new ImmutableSet.Builder<Binding>()
+         .addAll(ownedBindings())
+         .addAll(inheritedBindings().values())
+         .build();
   }
 
   @SuppressWarnings("unchecked")  // checked by validator
@@ -63,23 +75,34 @@ static ResolvedBindings create(
   @SuppressWarnings("unchecked")  // checked by validator
   ImmutableSet<? extends ContributionBinding> contributionBindings() {
     checkState(bindingKey().kind().equals(BindingKey.Kind.CONTRIBUTION));
-    return (ImmutableSet<? extends ContributionBinding>) bindings();
+    return new ImmutableSet.Builder<ContributionBinding>()
+        .addAll((Iterable<? extends ContributionBinding>) ownedBindings())
+        .addAll((Iterable<? extends ContributionBinding>) inheritedBindings().values())
+        .build();
   }
 
   @SuppressWarnings("unchecked")  // checked by validator
   ImmutableSet<? extends MembersInjectionBinding> membersInjectionBindings() {
     checkState(bindingKey().kind().equals(BindingKey.Kind.MEMBERS_INJECTION));
-    return (ImmutableSet<? extends MembersInjectionBinding>) bindings();
+    return new ImmutableSet.Builder<MembersInjectionBinding>()
+        .addAll((Iterable<? extends MembersInjectionBinding>) ownedBindings())
+        .addAll((Iterable<? extends MembersInjectionBinding>) inheritedBindings().values())
+        .build();
   }
 
   /**
    * Returns a {@code ResolvedBindings} with the same {@link #bindingKey()} and {@link #bindings()}
    * as this one, but no {@link #ownedBindings()}.
    */
-  ResolvedBindings asInherited() {
-    return ownedBindings().isEmpty()
-        ? this
-        : ResolvedBindings.create(bindingKey(), ImmutableSet.<Binding>of(), bindings());
+  ResolvedBindings asInheritedIn(ComponentDescriptor owningComponent) {
+    return ResolvedBindings.create(
+            bindingKey(),
+            owningComponent,
+            ImmutableSet.<Binding>of(),
+            new ImmutableSetMultimap.Builder<ComponentDescriptor, Binding>()
+                .putAll(inheritedBindings())
+                .putAll(owningComponent, ownedBindings())
+                .build());
   }
 
   /**
