diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/ChildComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/ChildComponent.java
deleted file mode 100644
index badb7cac6..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/ChildComponent.java
+++ /dev/null
@@ -1,14 +0,0 @@
-
-
-package test.subcomponent.repeat;
-
-import dagger.Subcomponent;
-
-import java.util.Set;
-
-@Subcomponent(modules = RepeatedModule.class)
-interface ChildComponent {
-  String getString();
-  Set<String> getMultiboundStrings();
-  OnlyUsedInChild getOnlyUsedInChild();
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/ParentComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/ParentComponent.java
index 91df02cc3..f0af00237 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/ParentComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/ParentComponent.java
@@ -1,19 +1,39 @@
+/*
+ * Copyright (C) 2015 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package test.subcomponent.repeat;
 
 import dagger.Component;
-
 import java.util.Set;
 
 @Component(modules = RepeatedModule.class)
 interface ParentComponent {
+  Object state();
+
   String getString();
   Set<String> getMultiboundStrings();
   OnlyUsedInParent getOnlyUsedInParent();
 
-  ChildComponent newChildComponent();
+  SubcomponentWithRepeatedModule.Builder newChildComponentBuilder();
+
+  SubcomponentWithoutRepeatedModule newChildComponentWithoutRepeatedModule();
 
   @Component.Builder
   interface Builder {
+    Builder repeatedModule(RepeatedModule repeatedModule);
+
     ParentComponent build();
   }
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/RepeatedModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/RepeatedModule.java
index 508a41b56..d0997513d 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/RepeatedModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/RepeatedModule.java
@@ -1,25 +1,51 @@
+/*
+ * Copyright (C) 2015 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package test.subcomponent.repeat;
 
-import static dagger.Provides.Type.SET;
-
 import dagger.Module;
 import dagger.Provides;
 
+import static dagger.Provides.Type.SET;
+
 @Module
 final class RepeatedModule {
-  @Provides String provideString() {
+  private final Object state = new Object();
+
+  @Provides
+  Object state() {
+    return state;
+  }
+
+  @Provides
+  static String provideString() {
     return "a string";
   }
 
-  @Provides(type = SET) String contributeString() {
+  @Provides(type = SET)
+  static String contributeString() {
     return "a string in a set";
   }
 
-  @Provides OnlyUsedInParent provideOnlyUsedInParent() {
+  @Provides
+  static OnlyUsedInParent provideOnlyUsedInParent() {
     return new OnlyUsedInParent() {};
   }
 
-  @Provides OnlyUsedInChild provideOnlyUsedInChild() {
+  @Provides
+  static OnlyUsedInChild provideOnlyUsedInChild() {
     return new OnlyUsedInChild() {};
   }
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/SubcomponentWithRepeatedModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/SubcomponentWithRepeatedModule.java
new file mode 100644
index 000000000..9e97d7bd3
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/SubcomponentWithRepeatedModule.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2015 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent.repeat;
+
+import dagger.Subcomponent;
+import java.util.Set;
+
+@Subcomponent(modules = RepeatedModule.class)
+interface SubcomponentWithRepeatedModule {
+  Object state();
+
+  String getString();
+  Set<String> getMultiboundStrings();
+  OnlyUsedInChild getOnlyUsedInChild();
+
+  @Subcomponent.Builder
+  interface Builder {
+    Builder repeatedModule(RepeatedModule repeatedModule);
+
+    SubcomponentWithRepeatedModule build();
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/SubcomponentWithoutRepeatedModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/SubcomponentWithoutRepeatedModule.java
new file mode 100644
index 000000000..e63c9a0ae
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/SubcomponentWithoutRepeatedModule.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent.repeat;
+
+import dagger.Subcomponent;
+
+@Subcomponent
+interface SubcomponentWithoutRepeatedModule {
+  SubcomponentWithRepeatedModule.Builder newGrandchildBuilder();
+}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/repeat/RepeatedModuleTest.java b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/repeat/RepeatedModuleTest.java
new file mode 100644
index 000000000..7e92371bf
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/repeat/RepeatedModuleTest.java
@@ -0,0 +1,82 @@
+/*
+ * Copyright (C) 2015 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent.repeat;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+@RunWith(JUnit4.class)
+public final class RepeatedModuleTest {
+  private ParentComponent parentComponent;
+
+  @Before
+  public void initializeParentComponent() {
+    this.parentComponent = DaggerParentComponent.builder().build();
+  }
+
+  @Test
+  public void repeatedModuleHasSameStateInSubcomponent() {
+    SubcomponentWithRepeatedModule childComponent =
+        parentComponent.newChildComponentBuilder().build();
+    assertThat(parentComponent.state()).isSameAs(childComponent.state());
+  }
+
+  @Test
+  public void repeatedModuleHasSameStateInGrandchildSubcomponent() {
+    SubcomponentWithoutRepeatedModule childComponent =
+        parentComponent.newChildComponentWithoutRepeatedModule();
+    SubcomponentWithRepeatedModule grandchildComponent =
+        childComponent.newGrandchildBuilder().build();
+    assertThat(parentComponent.state()).isSameAs(grandchildComponent.state());
+  }
+
+  @Test
+  public void repeatedModuleBuilderThrowsInSubcomponent() {
+    SubcomponentWithRepeatedModule.Builder childComponentBuilder =
+        parentComponent.newChildComponentBuilder();
+    try {
+      childComponentBuilder.repeatedModule(new RepeatedModule());
+      fail();
+    } catch (UnsupportedOperationException expected) {
+      assertThat(expected)
+          .hasMessage(
+              "test.subcomponent.repeat.RepeatedModule cannot be set "
+                  + "because it is inherited from the enclosing component");
+    }
+  }
+
+  @Test
+  public void repeatedModuleBuilderThrowsInGrandchildSubcomponent() {
+    SubcomponentWithoutRepeatedModule childComponent =
+        parentComponent.newChildComponentWithoutRepeatedModule();
+    SubcomponentWithRepeatedModule.Builder grandchildComponentBuilder =
+        childComponent.newGrandchildBuilder();
+    try {
+      grandchildComponentBuilder.repeatedModule(new RepeatedModule());
+      fail();
+    } catch (UnsupportedOperationException expected) {
+      assertThat(expected)
+          .hasMessage(
+              "test.subcomponent.repeat.RepeatedModule cannot be set "
+                  + "because it is inherited from the enclosing component");
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentProcessingStep.java
index f78d1ac0d..fe8a53624 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentProcessingStep.java
@@ -31,6 +31,7 @@
 abstract class AbstractComponentProcessingStep implements ProcessingStep {
 
   private final Messager messager;
+  private final ComponentHierarchyValidator componentHierarchyValidator;
   private final BindingGraphValidator bindingGraphValidator;
   private final ComponentDescriptor.Factory componentDescriptorFactory;
   private final BindingGraph.Factory bindingGraphFactory;
@@ -38,11 +39,13 @@
 
   AbstractComponentProcessingStep(
       Messager messager,
+      ComponentHierarchyValidator componentHierarchyValidator,
       BindingGraphValidator bindingGraphValidator,
       ComponentDescriptor.Factory componentDescriptorFactory,
       BindingGraph.Factory bindingGraphFactory,
       ComponentGenerator componentGenerator) {
     this.messager = messager;
+    this.componentHierarchyValidator = componentHierarchyValidator;
     this.bindingGraphValidator = bindingGraphValidator;
     this.componentDescriptorFactory = componentDescriptorFactory;
     this.bindingGraphFactory = bindingGraphFactory;
@@ -57,14 +60,19 @@
       try {
         ComponentDescriptor componentDescriptor =
             componentDescriptorFactory.forComponent(componentTypeElement);
-        BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor);
-        ValidationReport<TypeElement> graphReport = bindingGraphValidator.validate(bindingGraph);
-        graphReport.printMessagesTo(messager);
-        if (graphReport.isClean()) {
-          try {
-            componentGenerator.generate(bindingGraph);
-          } catch (SourceFileGenerationException e) {
-            e.printMessageTo(messager);
+        ValidationReport<TypeElement> hierarchyReport =
+            componentHierarchyValidator.validate(componentDescriptor);
+        hierarchyReport.printMessagesTo(messager);
+        if (hierarchyReport.isClean()) {
+          BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor);
+          ValidationReport<TypeElement> graphReport = bindingGraphValidator.validate(bindingGraph);
+          graphReport.printMessagesTo(messager);
+          if (graphReport.isClean()) {
+            try {
+              componentGenerator.generate(bindingGraph);
+            } catch (SourceFileGenerationException e) {
+              e.printMessageTo(messager);
+            }
           }
         }
       } catch (TypeNotPresentException e) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 212ac5cc1..9f876d60a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -75,6 +75,7 @@
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Types;
 import javax.tools.Diagnostic;
 import javax.tools.Diagnostic.Kind;
@@ -112,7 +113,6 @@
  * Creates the implementation class for a component or subcomponent.
  */
 abstract class AbstractComponentWriter {
-
   // TODO(dpb): Make all these fields private after refactoring is complete.
 
   protected final Types types;
@@ -267,8 +267,9 @@ protected void addBuilder() {
       // Note: we don't use the specBuildMethod.getReturnType() as the return type
       // because it might be a type variable.  We make use of covariant returns to allow
       // us to return the component type, which will always be valid.
-      buildMethod = builderWriter.addMethod(componentDefinitionTypeName(),
-          specBuildMethod.getSimpleName().toString());
+      buildMethod =
+          builderWriter.addMethod(
+              componentDefinitionTypeName(), specBuildMethod.getSimpleName().toString());
       buildMethod.annotate(Override.class);
     } else {
       buildMethod = builderWriter.addMethod(componentDefinitionTypeName(), "build");
@@ -285,36 +286,30 @@ protected void addBuilder() {
       builderField.addModifiers(PRIVATE);
       builderFieldsBuilder.put(contributionElement, builderField);
       if (componentCanMakeNewInstances(contributionElement)) {
-        buildMethod.body()
+        buildMethod
+            .body()
             .addSnippet("if (%s == null) {", builderField.name())
-            .addSnippet("  this.%s = new %s();",
-                builderField.name(), ClassName.fromTypeElement(contributionElement))
+            .addSnippet(
+                "  this.%s = new %s();",
+                builderField.name(),
+                ClassName.fromTypeElement(contributionElement))
             .addSnippet("}");
       } else {
-        buildMethod.body()
+        buildMethod
+            .body()
             .addSnippet("if (%s == null) {", builderField.name())
-            .addSnippet("  throw new IllegalStateException(\"%s must be set\");",
-                builderField.name())
+            .addSnippet(
+                "  throw new IllegalStateException(\"%s must be set\");", builderField.name())
             .addSnippet("}");
       }
+
       MethodWriter builderMethod;
-      boolean returnsVoid = false;
       if (builderSpec.isPresent()) {
         ExecutableElement method = builderSpec.get().methodMap().get(contributionElement);
         if (method == null) { // no method in the API, nothing to write out.
           continue;
         }
-        // If the return type is void, we add a method with the void return type.
-        // Otherwise we use the builderWriter and take advantage of covariant returns
-        // (so that we don't have to worry about setter methods that return type variables).
-        if (method.getReturnType().getKind().equals(TypeKind.VOID)) {
-          returnsVoid = true;
-          builderMethod =
-              builderWriter.addMethod(method.getReturnType(), method.getSimpleName().toString());
-        } else {
-          builderMethod = builderWriter.addMethod(builderWriter, method.getSimpleName().toString());
-        }
-        builderMethod.annotate(Override.class);
+        builderMethod = addBuilderMethodFromSpec(builderWriter, method);
       } else {
         builderMethod = builderWriter.addMethod(builderWriter, contributionName);
       }
@@ -323,20 +318,60 @@ protected void addBuilder() {
       //  but makes generated code prettier.)
       builderMethod.addModifiers(PUBLIC);
       builderMethod.addParameter(contributionElement, contributionName);
-      builderMethod.body()
+      builderMethod
+          .body()
           .addSnippet("if (%s == null) {", contributionName)
-          .addSnippet("  throw new NullPointerException(%s);",
-              StringLiteral.forValue(contributionName))
+          .addSnippet(
+              "  throw new NullPointerException(%s);", StringLiteral.forValue(contributionName))
           .addSnippet("}")
           .addSnippet("this.%s = %s;", builderField.name(), contributionName);
-      if (!returnsVoid) {
+      if (!builderMethod.returnType().equals(VoidName.VOID)) {
         builderMethod.body().addSnippet("return this;");
       }
     }
+
+    if (builderSpec.isPresent()) {
+      /* We know that the graph is properly formed because it passed validation, so all
+       * component requirements that are in the builder spec but _not_ owned by the component must
+       * be inherited. */
+      for (TypeElement inheritedRequirement :
+          Sets.difference(builderSpec.get().methodMap().keySet(), graph.componentRequirements())) {
+        MethodWriter builderMethod =
+            addBuilderMethodFromSpec(
+                builderWriter, builderSpec.get().methodMap().get(inheritedRequirement));
+        builderMethod.addModifiers(PUBLIC);
+        builderMethod.addParameter(inheritedRequirement, simpleVariableName(inheritedRequirement));
+        builderMethod
+            .body()
+            .addSnippet(
+                "throw new %s(%s.format(%s, %s.class.getCanonicalName()));",
+                ClassName.fromClass(UnsupportedOperationException.class),
+                ClassName.fromClass(String.class),
+                StringLiteral.forValue(
+                    "%s cannot be set because it is inherited from the enclosing component"),
+                ClassName.fromTypeElement(inheritedRequirement));
+      }
+    }
+
     builderFields = builderFieldsBuilder.build();
     buildMethod.body().addSnippet("return new %s(this);", name);
   }
 
+  private MethodWriter addBuilderMethodFromSpec(
+      ClassWriter builderWriter, ExecutableElement method) {
+    String methodName = method.getSimpleName().toString();
+    TypeMirror returnType = method.getReturnType();
+    // If the return type is void, we add a method with the void return type.
+    // Otherwise we use the builderWriter and take advantage of covariant returns
+    // (so that we don't have to worry about setter methods that return type variables).
+    MethodWriter builderMethod =
+        returnType.getKind().equals(TypeKind.VOID)
+            ? builderWriter.addMethod(returnType, methodName)
+            : builderWriter.addMethod(builderWriter, methodName);
+    builderMethod.annotate(Override.class);
+    return builderMethod;
+  }
+
   /**
    * Creates the builder class.
    */
@@ -362,8 +397,7 @@ private void addFields() {
     }
 
     memberSelectSnippets = ImmutableMap.copyOf(memberSelectSnippetsBuilder);
-    multibindingContributionSnippets =
-        ImmutableMap.copyOf(multibindingContributionSnippetsBuilder);
+    multibindingContributionSnippets = ImmutableMap.copyOf(multibindingContributionSnippetsBuilder);
     enumBindingKeys = enumBindingKeysBuilder.build();
   }
 
@@ -412,8 +446,8 @@ private void addField(
         proxyWriter.addModifiers(PUBLIC, FINAL);
         // create the field for the proxy in the component
         FieldWriter proxyFieldWriter =
-            componentWriter.addField(proxyWriter.name(),
-                bindingPackage.replace('.', '_') + "_Proxy");
+            componentWriter.addField(
+                proxyWriter.name(), bindingPackage.replace('.', '_') + "_Proxy");
         proxyFieldWriter.addModifiers(PRIVATE, FINAL);
         proxyFieldWriter.setInitializer("new %s()", proxyWriter.name());
         proxyClassAndField = ProxyClassAndField.create(proxyWriter, proxyFieldWriter);
@@ -465,10 +499,11 @@ private void addField(
         classWithFields.addField(bindingField.frameworkType(), bindingField.name());
     frameworkField.addModifiers(fieldModifiers);
 
-    ImmutableList<String> memberSelectTokens = new ImmutableList.Builder<String>()
-        .addAll(proxySelector.asSet())
-        .add(frameworkField.name())
-        .build();
+    ImmutableList<String> memberSelectTokens =
+        new ImmutableList.Builder<String>()
+            .addAll(proxySelector.asSet())
+            .add(frameworkField.name())
+            .build();
     memberSelectSnippetsBuilder.put(
         bindingKey,
         MemberSelect.instanceSelect(name, Snippet.memberSelectSnippet(memberSelectTokens)));
@@ -534,10 +569,12 @@ private void implementInterfaceMethods() {
             requestElement.getSimpleName().toString(), requestType);
         if (!interfaceMethods.contains(signature)) {
           interfaceMethods.add(signature);
-          MethodWriter interfaceMethod = requestType.getReturnType().getKind().equals(VOID)
-              ? componentWriter.addMethod(VoidName.VOID, requestElement.getSimpleName().toString())
-              : componentWriter.addMethod(requestType.getReturnType(),
-                  requestElement.getSimpleName().toString());
+          MethodWriter interfaceMethod =
+              requestType.getReturnType().getKind().equals(VOID)
+                  ? componentWriter.addMethod(
+                      VoidName.VOID, requestElement.getSimpleName().toString())
+                  : componentWriter.addMethod(
+                      requestType.getReturnType(), requestElement.getSimpleName().toString());
           interfaceMethod.annotate(Override.class);
           interfaceMethod.addModifiers(PUBLIC);
           BindingKey bindingKey = interfaceRequest.bindingKey();
@@ -575,8 +612,9 @@ private void implementInterfaceMethods() {
                 // If using a parameterized enum type, then we need to store the factory
                 // in a temporary variable, in order to help javac be able to infer
                 // the generics of the Factory.create methods.
-                TypeName factoryType = ParameterizedTypeName.create(Provider.class,
-                    TypeNames.forTypeMirror(requestType.getReturnType()));
+                TypeName factoryType =
+                    ParameterizedTypeName.create(
+                        Provider.class, TypeNames.forTypeMirror(requestType.getReturnType()));
                 interfaceMethod
                     .body()
                     .addSnippet(
@@ -653,13 +691,16 @@ private void initializeFrameworkTypes() {
                   }
                   parameterSnippets.add(snippet);
                 }
-                Snippet initializeSetSnippet = Snippet.format("%s.create(%s)",
-                    hasOnlyProvisions
-                        ? ClassName.fromClass(SetFactory.class)
-                        : ClassName.fromClass(SetProducer.class),
-                    Snippet.makeParametersSnippet(parameterSnippets.build()));
-                initializeMethod.body().addSnippet("this.%s = %s;",
-                    memberSelectSnippet, initializeSetSnippet);
+                Snippet initializeSetSnippet =
+                    Snippet.format(
+                        "%s.create(%s)",
+                        hasOnlyProvisions
+                            ? ClassName.fromClass(SetFactory.class)
+                            : ClassName.fromClass(SetProducer.class),
+                        Snippet.makeParametersSnippet(parameterSnippets.build()));
+                initializeMethod
+                    .body()
+                    .addSnippet("this.%s = %s;", memberSelectSnippet, initializeSetSnippet);
                 break;
               case MAP:
                 if (Sets.filter(bindings, Predicates.instanceOf(ProductionBinding.class))
@@ -673,14 +714,21 @@ private void initializeFrameworkTypes() {
                     if (!isMapWithNonProvidedValues(provisionBinding.key().type())
                         && multibindingContributionSnippet.isPresent()
                         && multibindingContributionSnippet.get().owningClass().equals(name)) {
-                      initializeMethod.body().addSnippet("this.%s = %s;",
-                          multibindingContributionSnippet.get().getSnippetFor(name),
-                          initializeFactoryForProvisionBinding(provisionBinding));
+                      initializeMethod
+                          .body()
+                          .addSnippet(
+                              "this.%s = %s;",
+                              multibindingContributionSnippet.get().getSnippetFor(name),
+                              initializeFactoryForProvisionBinding(provisionBinding));
                     }
                   }
                   if (!provisionBindings.isEmpty()) {
-                    initializeMethod.body().addSnippet("this.%s = %s;",
-                        memberSelectSnippet, initializeMapBinding(provisionBindings));
+                    initializeMethod
+                        .body()
+                        .addSnippet(
+                            "this.%s = %s;",
+                            memberSelectSnippet,
+                            initializeMapBinding(provisionBindings));
                   }
                 } else {
                   // TODO(beder): Implement producer map bindings.
@@ -695,15 +743,21 @@ private void initializeFrameworkTypes() {
                     initializeDelegateFactories(binding, initializeMethod);
                     if (!provisionBinding.factoryCreationStrategy().equals(ENUM_INSTANCE)
                         || provisionBinding.scope().isPresent()) {
-                      initializeMethod.body().addSnippet("this.%s = %s;",
-                          memberSelectSnippet,
-                          initializeFactoryForProvisionBinding(provisionBinding));
+                      initializeMethod
+                          .body()
+                          .addSnippet(
+                              "this.%s = %s;",
+                              memberSelectSnippet,
+                              initializeFactoryForProvisionBinding(provisionBinding));
                     }
                   } else if (binding instanceof ProductionBinding) {
                     ProductionBinding productionBinding = (ProductionBinding) binding;
-                    initializeMethod.body().addSnippet("this.%s = %s;",
-                        memberSelectSnippet,
-                        initializeFactoryForProductionBinding(productionBinding));
+                    initializeMethod
+                        .body()
+                        .addSnippet(
+                            "this.%s = %s;",
+                            memberSelectSnippet,
+                            initializeFactoryForProductionBinding(productionBinding));
                   } else {
                     throw new AssertionError();
                   }
@@ -714,8 +768,8 @@ private void initializeFrameworkTypes() {
             }
             break;
           case MEMBERS_INJECTION:
-            MembersInjectionBinding binding = Iterables.getOnlyElement(
-                resolvedBindings.membersInjectionBindings());
+            MembersInjectionBinding binding =
+                Iterables.getOnlyElement(resolvedBindings.membersInjectionBindings());
             if (!binding.injectionStrategy().equals(MembersInjectionBinding.Strategy.NO_OP)) {
               initializeDelegateFactories(binding, initializeMethod);
               initializeMethod
@@ -732,7 +786,9 @@ private void initializeFrameworkTypes() {
         bindingKeysWithInitializedProviders.add(bindingKey);
       }
       for (BindingKey key : bindingKeysWithDelegates) {
-        initializeMethod.body().addSnippet(
+        initializeMethod
+            .body()
+            .addSnippet(
                 "%s.setDelegatedProvider(%s);",
                 delegateFactoryVariableSnippet(key),
                 getMemberSelectSnippet(key));
@@ -747,15 +803,15 @@ private void initializeDelegateFactories(Binding binding, MethodWriter initializ
             .values()) {
       BindingKey dependencyKey =
           Iterables.getOnlyElement(
-                  FluentIterable.from(requestsForKey)
-                      .transform(
-                          new Function<DependencyRequest, BindingKey>() {
-                            @Override
-                            public BindingKey apply(DependencyRequest request) {
-                              return request.bindingKey();
-                            }
-                          })
-                      .toSet());
+              FluentIterable.from(requestsForKey)
+                  .transform(
+                      new Function<DependencyRequest, BindingKey>() {
+                        @Override
+                        public BindingKey apply(DependencyRequest request) {
+                          return request.bindingKey();
+                        }
+                      })
+                  .toSet());
       if (!getMemberSelect(dependencyKey).staticMember()
           && !isProviderInitialized(dependencyKey)
           && !bindingKeysWithDelegates.contains(dependencyKey)) {
@@ -801,9 +857,10 @@ private Snippet initializeFactoryForProvisionBinding(ProvisionBinding binding) {
             graph.componentDescriptor().dependencyMethodIndex().get(binding.bindingElement());
         if (binding.nullableType().isPresent()
             || nullableValidationType.equals(Diagnostic.Kind.WARNING)) {
-          Snippet nullableSnippet = binding.nullableType().isPresent()
-              ? Snippet.format("@%s ", TypeNames.forTypeMirror(binding.nullableType().get()))
-              : Snippet.format("");
+          Snippet nullableSnippet =
+              binding.nullableType().isPresent()
+                  ? Snippet.format("@%s ", TypeNames.forTypeMirror(binding.nullableType().get()))
+                  : Snippet.format("");
           return Snippet.format(
               Joiner.on('\n')
                   .join(
@@ -939,13 +996,17 @@ private Snippet initializeMembersInjectorForBinding(MembersInjectionBinding bind
     ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
     for (Collection<DependencyRequest> requestsForKey :
         SourceFiles.indexDependenciesByUnresolvedKey(types, dependencies).asMap().values()) {
-      BindingKey key = Iterables.getOnlyElement(FluentIterable.from(requestsForKey)
-          .transform(new Function<DependencyRequest, BindingKey>() {
-            @Override public BindingKey apply(DependencyRequest request) {
-              return request.bindingKey();
-            }
-          })
-          .toSet());
+      BindingKey key =
+          Iterables.getOnlyElement(
+              FluentIterable.from(requestsForKey)
+                  .transform(
+                      new Function<DependencyRequest, BindingKey>() {
+                        @Override
+                        public BindingKey apply(DependencyRequest request) {
+                          return request.bindingKey();
+                        }
+                      })
+                  .toSet());
       if (bindingKeysWithDelegates.contains(key)) {
         parameters.add(delegateFactoryVariableSnippet(key));
       } else {
@@ -955,22 +1016,24 @@ private Snippet initializeMembersInjectorForBinding(MembersInjectionBinding bind
     return parameters.build();
   }
 
-  private List<Snippet> getProducerDependencyParameters(
-      Iterable<DependencyRequest> dependencies) {
+  private List<Snippet> getProducerDependencyParameters(Iterable<DependencyRequest> dependencies) {
     ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
     for (Collection<DependencyRequest> requestsForKey :
         SourceFiles.indexDependenciesByUnresolvedKey(types, dependencies).asMap().values()) {
-      BindingKey key = Iterables.getOnlyElement(FluentIterable.from(requestsForKey)
-          .transform(new Function<DependencyRequest, BindingKey>() {
-            @Override public BindingKey apply(DependencyRequest request) {
-              return request.bindingKey();
-            }
-          }));
+      BindingKey key =
+          Iterables.getOnlyElement(
+              FluentIterable.from(requestsForKey)
+                  .transform(
+                      new Function<DependencyRequest, BindingKey>() {
+                        @Override
+                        public BindingKey apply(DependencyRequest request) {
+                          return request.bindingKey();
+                        }
+                      }));
       ResolvedBindings resolvedBindings = graph.resolvedBindings().get(key);
       Class<?> frameworkClass =
           DependencyRequestMapper.FOR_PRODUCER.getFrameworkClass(requestsForKey);
-      if (FrameworkField.frameworkClassForResolvedBindings(resolvedBindings)
-              .equals(Provider.class)
+      if (FrameworkField.frameworkClassForResolvedBindings(resolvedBindings).equals(Provider.class)
           && frameworkClass.equals(Producer.class)) {
         parameters.add(
             Snippet.format(
@@ -1021,4 +1084,3 @@ private static String simpleVariableName(TypeElement typeElement) {
     return UPPER_CAMEL.to(LOWER_CAMEL, typeElement.getSimpleName().toString());
   }
 }
-
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index 2e5d869b1..8ec742f63 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -18,19 +18,19 @@
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
-import com.google.common.base.Function;
 import com.google.common.base.Optional;
 import com.google.common.cache.Cache;
 import com.google.common.cache.CacheBuilder;
+import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
-import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
 import dagger.Component;
+import dagger.Subcomponent;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.producers.ProductionComponent;
 import java.util.ArrayDeque;
@@ -69,6 +69,22 @@
   abstract ImmutableMap<BindingKey, ResolvedBindings> resolvedBindings();
   abstract ImmutableMap<ExecutableElement, BindingGraph> subgraphs();
 
+  /**
+   * Returns the set of modules that are owned by this graph regardless of whether or not any of
+   * their bindings are used in this graph. For graphs representing top-level {@link Component
+   * components}, this set will be the same as
+   * {@linkplain ComponentDescriptor#transitiveModules the component's transitive modules}. For
+   * {@linkplain Subcomponent subcomponents}, this set will be the transitive modules that are not
+   * owned by any of their ancestors.
+   */
+  abstract ImmutableSet<ModuleDescriptor> ownedModules();
+
+  ImmutableSet<TypeElement> ownedModuleTypes() {
+    return FluentIterable.from(ownedModules())
+        .transform(ModuleDescriptor.getModuleElement())
+        .toSet();
+  }
+
   /**
    * Returns the set of types necessary to implement the component, but are not part of the injected
    * graph.  This includes modules, component dependencies and an {@link Executor} in the case of
@@ -76,13 +92,15 @@
    */
   ImmutableSet<TypeElement> componentRequirements() {
     return new ImmutableSet.Builder<TypeElement>()
-        .addAll(Iterables.transform(
-            componentDescriptor().transitiveModules(),
-            new Function<ModuleDescriptor, TypeElement>() {
-              @Override public TypeElement apply(ModuleDescriptor input) {
-                return input.moduleElement();
-              }
-            }))
+        .addAll(ownedModuleTypes())
+        .addAll(componentDescriptor().dependencies())
+        .addAll(componentDescriptor().executorDependency().asSet())
+        .build();
+  }
+
+  ImmutableSet<TypeElement> availableDependencies() {
+    return new ImmutableSet.Builder<TypeElement>()
+        .addAll(componentDescriptor().transitiveModuleTypes())
         .addAll(componentDescriptor().dependencies())
         .addAll(componentDescriptor().executorDependency().asSet())
         .build();
@@ -111,11 +129,11 @@
     }
 
     BindingGraph create(ComponentDescriptor componentDescriptor) {
-      return create(Optional.<RequestResolver>absent(), componentDescriptor);
+      return create(Optional.<Resolver>absent(), componentDescriptor);
     }
 
-    private BindingGraph create(Optional<RequestResolver> parentResolver,
-        ComponentDescriptor componentDescriptor) {
+    private BindingGraph create(
+        Optional<Resolver> parentResolver, ComponentDescriptor componentDescriptor) {
       ImmutableSet.Builder<ProvisionBinding> explicitProvisionBindingsBuilder =
           ImmutableSet.builder();
       ImmutableSet.Builder<ProductionBinding> explicitProductionBindingsBuilder =
@@ -166,11 +184,12 @@ private BindingGraph create(Optional<RequestResolver> parentResolver,
         }
       }
 
-      RequestResolver requestResolver = new RequestResolver(
-          parentResolver,
-          componentDescriptor.wrappedScope(),
-          explicitBindingsByKey(explicitProvisionBindingsBuilder.build()),
-          explicitBindingsByKey(explicitProductionBindingsBuilder.build()));
+      Resolver requestResolver =
+          new Resolver(
+              parentResolver,
+              componentDescriptor,
+              explicitBindingsByKey(explicitProvisionBindingsBuilder.build()),
+              explicitBindingsByKey(explicitProductionBindingsBuilder.build()));
       for (ComponentMethodDescriptor componentMethod : componentDescriptor.componentMethods()) {
         Optional<DependencyRequest> componentMethodRequest = componentMethod.dependencyRequest();
         if (componentMethodRequest.isPresent()) {
@@ -180,16 +199,18 @@ private BindingGraph create(Optional<RequestResolver> parentResolver,
 
       ImmutableMap.Builder<ExecutableElement, BindingGraph> subgraphsBuilder =
           ImmutableMap.builder();
-      for (Entry<ExecutableElement, ComponentDescriptor> subcomponentEntry :
+      for (Entry<ComponentMethodDescriptor, ComponentDescriptor> subcomponentEntry :
           componentDescriptor.subcomponents().entrySet()) {
-        subgraphsBuilder.put(subcomponentEntry.getKey(),
+        subgraphsBuilder.put(
+            subcomponentEntry.getKey().methodElement(),
             create(Optional.of(requestResolver), subcomponentEntry.getValue()));
       }
 
       return new AutoValue_BindingGraph(
           componentDescriptor,
           requestResolver.getResolvedBindings(),
-          subgraphsBuilder.build());
+          subgraphsBuilder.build(),
+          requestResolver.getOwnedModules());
     }
 
     private <B extends ContributionBinding> ImmutableSetMultimap<Key, B> explicitBindingsByKey(
@@ -202,9 +223,9 @@ private BindingGraph create(Optional<RequestResolver> parentResolver,
       return builder.build();
     }
 
-    private final class RequestResolver {
-      final Optional<RequestResolver> parentResolver;
-      final Optional<Equivalence.Wrapper<AnnotationMirror>> targetScope;
+    private final class Resolver {
+      final Optional<Resolver> parentResolver;
+      final ComponentDescriptor componentDescriptor;
       final ImmutableSetMultimap<Key, ProvisionBinding> explicitProvisionBindings;
       final ImmutableSet<ProvisionBinding> explicitProvisionBindingsSet;
       final ImmutableSetMultimap<Key, ProductionBinding> explicitProductionBindings;
@@ -213,14 +234,15 @@ private BindingGraph create(Optional<RequestResolver> parentResolver,
       final Cache<BindingKey, Boolean> dependsOnLocalMultibindingsCache =
           CacheBuilder.newBuilder().<BindingKey, Boolean>build();
 
-      RequestResolver(Optional<RequestResolver> parentResolver,
-          Optional<Equivalence.Wrapper<AnnotationMirror>> targetScope,
+      Resolver(
+          Optional<Resolver> parentResolver,
+          ComponentDescriptor componentDescriptor,
           ImmutableSetMultimap<Key, ProvisionBinding> explicitProvisionBindings,
           ImmutableSetMultimap<Key, ProductionBinding> explicitProductionBindings) {
         assert parentResolver != null;
         this.parentResolver = parentResolver;
-        assert targetScope != null;
-        this.targetScope = targetScope;
+        assert componentDescriptor != null;
+        this.componentDescriptor = componentDescriptor;
         assert explicitProvisionBindings != null;
         this.explicitProvisionBindings = explicitProvisionBindings;
         this.explicitProvisionBindingsSet = ImmutableSet.copyOf(explicitProvisionBindings.values());
@@ -324,7 +346,7 @@ ResolvedBindings lookUpBindings(DependencyRequest request) {
        */
       private boolean isResolvedInParent(
           DependencyRequest request, ProvisionBinding provisionBinding) {
-        Optional<RequestResolver> owningResolver = getOwningResolver(provisionBinding);
+        Optional<Resolver> owningResolver = getOwningResolver(provisionBinding);
         if (owningResolver.isPresent() && !owningResolver.get().equals(this)) {
           owningResolver.get().resolve(request);
           return true;
@@ -361,8 +383,8 @@ private MembersInjectionBinding rollUpMembersInjectionBindings(Key key) {
         return membersInjectionBinding;
       }
 
-      private Optional<RequestResolver> getOwningResolver(ProvisionBinding provisionBinding) {
-        for (RequestResolver requestResolver : getResolverLineage().reverse()) {
+      private Optional<Resolver> getOwningResolver(ProvisionBinding provisionBinding) {
+        for (Resolver requestResolver : getResolverLineage().reverse()) {
           if (requestResolver.explicitProvisionBindingsSet.contains(provisionBinding)) {
             return Optional.of(requestResolver);
           }
@@ -373,8 +395,8 @@ private MembersInjectionBinding rollUpMembersInjectionBindings(Key key) {
         Optional<Equivalence.Wrapper<AnnotationMirror>> bindingScope =
             provisionBinding.wrappedScope();
         if (bindingScope.isPresent()) {
-          for (RequestResolver requestResolver : getResolverLineage().reverse()) {
-            if (bindingScope.equals(requestResolver.targetScope)) {
+          for (Resolver requestResolver : getResolverLineage().reverse()) {
+            if (bindingScope.equals(requestResolver.componentDescriptor.wrappedScope())) {
               return Optional.of(requestResolver);
             }
           }
@@ -383,9 +405,9 @@ private MembersInjectionBinding rollUpMembersInjectionBindings(Key key) {
       }
 
       /** Returns the resolver lineage from parent to child. */
-      private ImmutableList<RequestResolver> getResolverLineage() {
-        List<RequestResolver> resolverList = Lists.newArrayList();
-        for (Optional<RequestResolver> currentResolver = Optional.of(this);
+      private ImmutableList<Resolver> getResolverLineage() {
+        List<Resolver> resolverList = Lists.newArrayList();
+        for (Optional<Resolver> currentResolver = Optional.of(this);
             currentResolver.isPresent();
             currentResolver = currentResolver.get().parentResolver) {
           resolverList.add(currentResolver.get());
@@ -395,18 +417,16 @@ private MembersInjectionBinding rollUpMembersInjectionBindings(Key key) {
 
       private ImmutableSet<ProvisionBinding> getExplicitProvisionBindings(Key requestKey) {
         ImmutableSet.Builder<ProvisionBinding> explicitBindingsForKey = ImmutableSet.builder();
-        for (RequestResolver resolver : getResolverLineage()) {
-          explicitBindingsForKey.addAll(
-              resolver.explicitProvisionBindings.get(requestKey));
+        for (Resolver resolver : getResolverLineage()) {
+          explicitBindingsForKey.addAll(resolver.explicitProvisionBindings.get(requestKey));
         }
         return explicitBindingsForKey.build();
       }
 
       private ImmutableSet<ProductionBinding> getExplicitProductionBindings(Key requestKey) {
         ImmutableSet.Builder<ProductionBinding> explicitBindingsForKey = ImmutableSet.builder();
-        for (RequestResolver resolver : getResolverLineage()) {
-          explicitBindingsForKey.addAll(
-              resolver.explicitProductionBindings.get(requestKey));
+        for (Resolver resolver : getResolverLineage()) {
+          explicitBindingsForKey.addAll(resolver.explicitProductionBindings.get(requestKey));
         }
         return explicitBindingsForKey.build();
       }
@@ -540,6 +560,20 @@ private boolean isScoped(Binding binding) {
         }
         return resolvedBindingsBuilder.build();
       }
+
+      ImmutableSet<ModuleDescriptor> getInheritedModules() {
+        return parentResolver.isPresent()
+            ? Sets.union(
+                    parentResolver.get().getInheritedModules(),
+                    parentResolver.get().componentDescriptor.transitiveModules())
+                .immutableCopy()
+            : ImmutableSet.<ModuleDescriptor>of();
+      }
+
+      ImmutableSet<ModuleDescriptor> getOwnedModules() {
+        return Sets.difference(componentDescriptor.transitiveModules(), getInheritedModules())
+            .immutableCopy();
+      }
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 3ddf36c45..0f940cfc8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -544,19 +544,22 @@ private void validateBuilders() {
         return;
       }
 
-      Set<TypeElement> allDependents = subject.componentRequirements();
-      Set<TypeElement> requiredDependents =
-          Sets.filter(allDependents, new Predicate<TypeElement>() {
-            @Override public boolean apply(TypeElement input) {
-              return !Util.componentCanMakeNewInstances(input);
-            }
-          });
+      Set<TypeElement> availableDependencies = subject.availableDependencies();
+      Set<TypeElement> requiredDependencies =
+          Sets.filter(
+              availableDependencies,
+              new Predicate<TypeElement>() {
+                @Override
+                public boolean apply(TypeElement input) {
+                  return !Util.componentCanMakeNewInstances(input);
+                }
+              });
       final BuilderSpec spec = componentDesc.builderSpec().get();
       Map<TypeElement, ExecutableElement> allSetters = spec.methodMap();
 
       ErrorMessages.ComponentBuilderMessages msgs =
           ErrorMessages.builderMsgsFor(subject.componentDescriptor().kind());
-      Set<TypeElement> extraSetters = Sets.difference(allSetters.keySet(), allDependents);
+      Set<TypeElement> extraSetters = Sets.difference(allSetters.keySet(), availableDependencies);
       if (!extraSetters.isEmpty()) {
         Collection<ExecutableElement> excessMethods =
             Maps.filterKeys(allSetters, Predicates.in(extraSetters)).values();
@@ -570,7 +573,7 @@ private void validateBuilders() {
             String.format(msgs.extraSetters(), formatted), spec.builderDefinitionType());
       }
 
-      Set<TypeElement> missingSetters = Sets.difference(requiredDependents, allSetters.keySet());
+      Set<TypeElement> missingSetters = Sets.difference(requiredDependencies, allSetters.keySet());
       if (!missingSetters.isEmpty()) {
         reportBuilder.addError(
             String.format(msgs.missingSetters(), missingSetters), spec.builderDefinitionType());
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index 2f20482d5..dcb33aa95 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -21,6 +21,7 @@
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
 import com.google.common.base.Optional;
+import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
@@ -28,6 +29,7 @@
 import dagger.Component;
 import dagger.Lazy;
 import dagger.MembersInjector;
+import dagger.Module;
 import dagger.Subcomponent;
 import dagger.producers.ProductionComponent;
 import java.lang.annotation.Annotation;
@@ -85,7 +87,7 @@
     /**
      * Returns the kind of an annotated element if it is annotated with one of the
      * {@linkplain #annotationType() annotation types}.
-     * 
+     *
      * @throws IllegalArgumentException if the element is annotated with more than one of the
      *     annotation types
      */
@@ -138,8 +140,20 @@ boolean isTopLevel() {
    */
   abstract ImmutableSet<TypeElement> dependencies();
 
+  /**
+   * The set of {@link ModuleDescriptor modules} declared directly in {@link Component#modules}.
+   * Use {@link #transitiveModules} to get the full set of modules available upon traversing
+   * {@link Module#includes}.
+   */
   abstract ImmutableSet<ModuleDescriptor> modules();
 
+  /**
+   * Returns the set of {@link ModuleDescriptor modules} declared in {@link Component#modules} and
+   * those reachable by traversing {@link Module#includes}.
+   *
+   * <p>Note that for subcomponents this <em>will not</em> include descriptors for any modules that
+   * are declared in parent components.
+   */
   ImmutableSet<ModuleDescriptor> transitiveModules() {
     Set<ModuleDescriptor> transitiveModules = new LinkedHashSet<>();
     for (ModuleDescriptor module : modules()) {
@@ -148,6 +162,12 @@ boolean isTopLevel() {
     return ImmutableSet.copyOf(transitiveModules);
   }
 
+  ImmutableSet<TypeElement> transitiveModuleTypes() {
+    return FluentIterable.from(transitiveModules())
+        .transform(ModuleDescriptor.getModuleElement())
+        .toSet();
+  }
+
   private static Set<ModuleDescriptor> addTransitiveModules(
       Set<ModuleDescriptor> transitiveModules, ModuleDescriptor module) {
     if (transitiveModules.add(module)) {
@@ -184,7 +204,7 @@ boolean isTopLevel() {
    */
   abstract Optional<Equivalence.Wrapper<AnnotationMirror>> wrappedScope();
 
-  abstract ImmutableMap<ExecutableElement, ComponentDescriptor> subcomponents();
+  abstract ImmutableMap<ComponentMethodDescriptor, ComponentDescriptor> subcomponents();
 
   abstract ImmutableSet<ComponentMethodDescriptor> componentMethods();
 
@@ -285,7 +305,7 @@ private ComponentDescriptor create(TypeElement componentDefinitionType, Kind kin
       ImmutableSet.Builder<ComponentMethodDescriptor> componentMethodsBuilder =
           ImmutableSet.builder();
 
-      ImmutableMap.Builder<ExecutableElement, ComponentDescriptor> subcomponentDescriptors =
+      ImmutableMap.Builder<ComponentMethodDescriptor, ComponentDescriptor> subcomponentDescriptors =
           ImmutableMap.builder();
       for (ExecutableElement componentMethod : unimplementedMethods) {
         ExecutableType resolvedMethod =
@@ -295,13 +315,18 @@ private ComponentDescriptor create(TypeElement componentDefinitionType, Kind kin
         componentMethodsBuilder.add(componentMethodDescriptor);
         switch (componentMethodDescriptor.kind()) {
           case SUBCOMPONENT:
-            subcomponentDescriptors.put(componentMethod,
-                create(MoreElements.asType(MoreTypes.asElement(resolvedMethod.getReturnType())),
+            subcomponentDescriptors.put(
+                componentMethodDescriptor,
+                create(
+                    MoreElements.asType(MoreTypes.asElement(resolvedMethod.getReturnType())),
                     Kind.SUBCOMPONENT));
             break;
           case SUBCOMPONENT_BUILDER:
-            subcomponentDescriptors.put(componentMethod, create(MoreElements.asType(
-                MoreTypes.asElement(resolvedMethod.getReturnType()).getEnclosingElement()),
+            subcomponentDescriptors.put(
+                componentMethodDescriptor,
+                create(
+                    MoreElements.asType(
+                        MoreTypes.asElement(resolvedMethod.getReturnType()).getEnclosingElement()),
                     Kind.SUBCOMPONENT));
             break;
           default: // nothing special to do for other methods.
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentHierarchyValidator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentHierarchyValidator.java
new file mode 100644
index 000000000..8fb4191a5
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentHierarchyValidator.java
@@ -0,0 +1,115 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreTypes;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Sets;
+import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
+import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
+import java.util.Map;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+
+import static com.google.common.base.Functions.constant;
+
+/**
+ * Validates the relationships between parent components and subcomponents.
+ */
+final class ComponentHierarchyValidator {
+  ValidationReport<TypeElement> validate(ComponentDescriptor componentDescriptor) {
+    return validateSubcomponentMethods(
+        componentDescriptor,
+        Maps.toMap(
+            componentDescriptor.transitiveModuleTypes(),
+            constant(componentDescriptor.componentDefinitionType())));
+  }
+
+  private ValidationReport<TypeElement> validateSubcomponentMethods(
+      ComponentDescriptor componentDescriptor,
+      Map<TypeElement, TypeElement> existingModuleToOwners) {
+    ValidationReport.Builder<TypeElement> reportBuilder =
+        ValidationReport.about(componentDescriptor.componentDefinitionType());
+    for (Map.Entry<ComponentMethodDescriptor, ComponentDescriptor> subcomponentEntry :
+        componentDescriptor.subcomponents().entrySet()) {
+      ComponentMethodDescriptor subcomponentMethodDescriptor = subcomponentEntry.getKey();
+      ComponentDescriptor subcomponentDescriptor = subcomponentEntry.getValue();
+      // validate the way that we create subcomponents
+      switch (subcomponentMethodDescriptor.kind()) {
+        case SUBCOMPONENT:
+          for (VariableElement factoryMethodParameter :
+              subcomponentMethodDescriptor.methodElement().getParameters()) {
+            TypeElement origininatingComponent =
+                existingModuleToOwners.get(
+                    MoreTypes.asTypeElement(factoryMethodParameter.asType()));
+            if (origininatingComponent != null) {
+              /* Factory method tries to pass a module that is already present in the parent.
+               * This is an error. */
+              reportBuilder.addError(
+                  String.format(
+                      "This module is present in %s. Subcomponents cannot use an instance of a "
+                          + "module that differs from its parent.",
+                      origininatingComponent.getQualifiedName()),
+                  factoryMethodParameter);
+            }
+          }
+          break;
+        case SUBCOMPONENT_BUILDER:
+          BuilderSpec subcomponentBuilderSpec = subcomponentDescriptor.builderSpec().get();
+          for (Map.Entry<TypeElement, ExecutableElement> builderMethodEntry :
+              subcomponentBuilderSpec.methodMap().entrySet()) {
+            TypeElement origininatingComponent =
+                existingModuleToOwners.get(builderMethodEntry.getKey());
+            if (origininatingComponent != null) {
+              /* A subcomponent builder allows you to pass a module that is already present in the
+               * parent.  This can't be an error because it might be valid in _other_ components, so
+               * we warn here. */
+              ExecutableElement builderMethodElement = builderMethodEntry.getValue();
+              /* TODO(gak): consider putting this on the builder method directly if it's in the
+               * component being compiled */
+              reportBuilder.addWarning(
+                  String.format(
+                      "This module is present in %s. Subcomponents cannot use an instance of a "
+                          + "module that differs from its parent. The implementation of %s "
+                          + "in this component will throw %s.",
+                      origininatingComponent.getQualifiedName(),
+                      builderMethodElement.getSimpleName(),
+                      UnsupportedOperationException.class.getSimpleName()),
+                  builderMethodElement);
+            }
+          }
+          break;
+        default:
+          throw new AssertionError();
+      }
+      reportBuilder.addSubreport(
+          validateSubcomponentMethods(
+              subcomponentDescriptor,
+              new ImmutableMap.Builder<TypeElement, TypeElement>()
+                  .putAll(existingModuleToOwners)
+                  .putAll(
+                      Maps.toMap(
+                          Sets.difference(
+                              subcomponentDescriptor.transitiveModuleTypes(),
+                              existingModuleToOwners.keySet()),
+                          constant(subcomponentDescriptor.componentDefinitionType())))
+                  .build()));
+    }
+    return reportBuilder.build();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
index c9c8d5514..93128f58f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
@@ -50,12 +50,14 @@
       ComponentValidator subcomponentValidator,
       BuilderValidator componentBuilderValidator,
       BuilderValidator subcomponentBuilderValidator,
+      ComponentHierarchyValidator componentHierarchyValidator,
       BindingGraphValidator bindingGraphValidator,
       Factory componentDescriptorFactory,
       BindingGraph.Factory bindingGraphFactory,
       ComponentGenerator componentGenerator) {
     super(
         messager,
+        componentHierarchyValidator,
         bindingGraphValidator,
         componentDescriptorFactory,
         bindingGraphFactory,
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index cea6fe232..b4e535a82 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -148,23 +148,21 @@ public SourceVersion getSupportedSourceVersion() {
         productionBindingFactory);
 
     MapKeyGenerator mapKeyGenerator = new MapKeyGenerator(filer);
-    BindingGraphValidator bindingGraphValidator = new BindingGraphValidator(
-        types,
-        injectBindingRegistry,
-        scopeValidationType(processingEnv),
-        nullableDiagnosticType,
-        provisionBindingFormatter,
-        productionBindingFormatter,
-        methodSignatureFormatter,
-        dependencyRequestFormatter,
-        keyFormatter);
+    ComponentHierarchyValidator componentHierarchyValidator = new ComponentHierarchyValidator();
+    BindingGraphValidator bindingGraphValidator =
+        new BindingGraphValidator(
+            types,
+            injectBindingRegistry,
+            scopeValidationType(processingEnv),
+            nullableDiagnosticType,
+            provisionBindingFormatter,
+            productionBindingFormatter,
+            methodSignatureFormatter,
+            dependencyRequestFormatter,
+            keyFormatter);
 
     return ImmutableList.<ProcessingStep>of(
-        new MapKeyProcessingStep(
-            messager,
-            types,
-            mapKeyValidator,
-            mapKeyGenerator),
+        new MapKeyProcessingStep(messager, types, mapKeyValidator, mapKeyGenerator),
         new InjectProcessingStep(
             messager,
             injectConstructorValidator,
@@ -185,6 +183,7 @@ public SourceVersion getSupportedSourceVersion() {
             subcomponentValidator,
             componentBuilderValidator,
             subcomponentBuilderValidator,
+            componentHierarchyValidator,
             bindingGraphValidator,
             componentDescriptorFactory,
             bindingGraphFactory,
@@ -198,6 +197,7 @@ public SourceVersion getSupportedSourceVersion() {
         new ProductionComponentProcessingStep(
             messager,
             productionComponentValidator,
+            componentHierarchyValidator,
             bindingGraphValidator,
             componentDescriptorFactory,
             bindingGraphFactory,
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionComponentProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ProductionComponentProcessingStep.java
index c7cd790b8..c7bd2cc8c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionComponentProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionComponentProcessingStep.java
@@ -39,12 +39,14 @@
   ProductionComponentProcessingStep(
       Messager messager,
       ProductionComponentValidator componentValidator,
+      ComponentHierarchyValidator componentHierarchyValidator,
       BindingGraphValidator bindingGraphValidator,
       ComponentDescriptor.Factory componentDescriptorFactory,
       BindingGraph.Factory bindingGraphFactory,
       ComponentGenerator componentGenerator) {
     super(
         messager,
+        componentHierarchyValidator,
         bindingGraphValidator,
         componentDescriptorFactory,
         bindingGraphFactory,
diff --git a/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java b/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java
index f79ec7562..e17406755 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java
@@ -21,6 +21,8 @@
 import javax.annotation.processing.Messager;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.util.SimpleElementVisitor6;
 import javax.tools.Diagnostic;
 import javax.tools.Diagnostic.Kind;
 
@@ -78,7 +80,7 @@ void printMessagesTo(Messager messager) {
           messager.printMessage(item.kind(), item.message(), item.element());
         }
       } else {
-        String message = String.format("[%s] %s", item.element(), item.message());
+        String message = String.format("[%s] %s", elementString(item.element()), item.message());
         if (item.annotation().isPresent()) {
           messager.printMessage(item.kind(), message, subject(), item.annotation().get());
         } else {
@@ -91,6 +93,22 @@ void printMessagesTo(Messager messager) {
     }
   }
 
+  private static String elementString(Element element) {
+    return element.accept(
+        new SimpleElementVisitor6<String, Void>() {
+          @Override
+          protected String defaultAction(Element e, Void p) {
+            return e.toString();
+          }
+
+          @Override
+          public String visitExecutable(ExecutableElement e, Void p) {
+            return e.getEnclosingElement().accept(this, null) + '.' + e.toString();
+          }
+        },
+        null);
+  }
+
   private static boolean isEnclosedIn(Element parent, Element child) {
     Element current = child;
     while (current != null) {
diff --git a/compiler/src/test/java/dagger/internal/codegen/RepeatedModuleValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/RepeatedModuleValidationTest.java
new file mode 100644
index 000000000..aa560b835
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/RepeatedModuleValidationTest.java
@@ -0,0 +1,121 @@
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+
+@RunWith(JUnit4.class)
+public class RepeatedModuleValidationTest {
+  private static final JavaFileObject MODULE_FILE =
+      JavaFileObjects.forSourceLines(
+          "test.TestModule",
+          "package test;",
+          "",
+          "import dagger.Module;",
+          "",
+          "@Module",
+          "final class TestModule {}");
+
+  @Test
+  public void moduleRepeatedInSubcomponentFactoryMethod() {
+    JavaFileObject subcomponentFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestSubcomponent",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = TestModule.class)",
+            "interface TestSubcomponent {",
+            "}");
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  TestSubcomponent newTestSubcomponent(TestModule module);",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(MODULE_FILE, subcomponentFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("This module is present in test.TestComponent.")
+        .in(componentFile)
+        .onLine(7)
+        .atColumn(51);
+  }
+
+  @Test
+  public void moduleRepeatedInSubcomponentBuilderMethod() {
+    JavaFileObject subcomponentFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestSubcomponent",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = TestModule.class)",
+            "interface TestSubcomponent {",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Builder testModule(TestModule testModule);",
+            "    TestSubcomponent build();",
+            "  }",
+            "}");
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  TestSubcomponent.Builder newTestSubcomponentBuilder();",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(MODULE_FILE, subcomponentFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError();
+    // TOOD(gak): assert about the warning when we have that ability
+  }
+
+  @Test
+  public void moduleRepeatedButNotPassed() {
+    JavaFileObject subcomponentFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestSubcomponent",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = TestModule.class)",
+            "interface TestSubcomponent {",
+            "}");
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  TestSubcomponent newTestSubcomponent();",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(MODULE_FILE, subcomponentFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError();
+  }
+}
