diff --git a/compiler/src/it/tck/pom.xml b/compiler/src/it/tck/pom.xml
index 7b02a6ffd..3bf297956 100644
--- a/compiler/src/it/tck/pom.xml
+++ b/compiler/src/it/tck/pom.xml
@@ -61,6 +61,7 @@ limitations under the License.
           <compilerArgs>
             <arg>-Adagger.privateMemberValidation=warning</arg>
             <arg>-Adagger.staticMemberValidation=warning</arg>
+            <arg>-Adagger.ignorePrivateAndStaticInjectionForComponent=enabled</arg>
           </compilerArgs>
         </configuration>
       </plugin>
diff --git a/compiler/src/main/java/dagger/internal/codegen/Accessibility.java b/compiler/src/main/java/dagger/internal/codegen/Accessibility.java
index d8c5d2369..0ce9230b0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Accessibility.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Accessibility.java
@@ -15,6 +15,7 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreElements;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
@@ -141,6 +142,12 @@ static boolean isElementAccessibleFrom(Element element, final String packageName
     return element.accept(new ElementAccessibilityVisitor(packageName), null);
   }
 
+  /** Returns true if the given element can be referenced from other code in its own package. */
+  static boolean isElementAccessibleFromOwnPackage(Element element) {
+    return isElementAccessibleFrom(
+        element, MoreElements.getPackage(element).getQualifiedName().toString());
+  }
+
   private static final class ElementAccessibilityVisitor
       extends SimpleElementVisitor6<Boolean, Void> {
     final String packageName;
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 3aadd6a3d..a926f8016 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -84,6 +84,7 @@
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
 import static dagger.internal.codegen.ContributionBinding.indexMapBindingsByAnnotationType;
 import static dagger.internal.codegen.ContributionBinding.indexMapBindingsByMapKey;
+import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
 import static dagger.internal.codegen.ContributionBinding.Kind.IS_SYNTHETIC_KIND;
 import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MULTIBOUND_MAP;
 import static dagger.internal.codegen.ContributionType.indexByContributionType;
@@ -102,6 +103,7 @@
 import static dagger.internal.codegen.ErrorMessages.stripCommonTypePrefixes;
 import static dagger.internal.codegen.Scope.reusableScope;
 import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
+import static javax.lang.model.type.TypeKind.DECLARED;
 import static javax.tools.Diagnostic.Kind.ERROR;
 
 public class BindingGraphValidator {
@@ -109,6 +111,7 @@
   private final Elements elements;
   private final Types types;
   private final CompilerOptions compilerOptions;
+  private final InjectValidator injectValidator;
   private final InjectBindingRegistry injectBindingRegistry;
   private final BindingDeclarationFormatter bindingDeclarationFormatter;
   private final MethodSignatureFormatter methodSignatureFormatter;
@@ -120,6 +123,7 @@
       Elements elements,
       Types types,
       CompilerOptions compilerOptions,
+      InjectValidator injectValidator,
       InjectBindingRegistry injectBindingRegistry,
       BindingDeclarationFormatter bindingDeclarationFormatter,
       MethodSignatureFormatter methodSignatureFormatter,
@@ -129,6 +133,7 @@
     this.elements = elements;
     this.types = types;
     this.compilerOptions = compilerOptions;
+    this.injectValidator = injectValidator;
     this.injectBindingRegistry = injectBindingRegistry;
     this.bindingDeclarationFormatter = bindingDeclarationFormatter;
     this.methodSignatureFormatter = methodSignatureFormatter;
@@ -385,6 +390,17 @@ private void validateResolvedBinding(DependencyPath path) {
             reportDuplicateBindings(path);
             return;
           }
+          ContributionBinding binding =
+              Iterables.getOnlyElement(resolvedBinding.contributionBindings());
+          if (binding.bindingKind().equals(INJECTION)) {
+            TypeMirror type = resolvedBinding.bindingKey().key().type();
+            ValidationReport<TypeElement> report =
+                injectValidator.validateType(MoreTypes.asTypeElement(type));
+            if (!report.isClean()) {
+              reportBuilder.addSubreport(report);
+              return;
+            }
+          }
           ContributionBinding contributionBinding = resolvedBinding.contributionBinding();
           if (contributionBinding.bindingType().equals(BindingType.PRODUCTION)
               && doesPathRequireProvisionOnly(path)) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/CompilerOptions.java b/compiler/src/main/java/dagger/internal/codegen/CompilerOptions.java
index 88a806109..a57092df7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/CompilerOptions.java
+++ b/compiler/src/main/java/dagger/internal/codegen/CompilerOptions.java
@@ -34,6 +34,7 @@
   abstract Diagnostic.Kind nullableValidationKind();
   abstract Diagnostic.Kind privateMemberValidationKind();
   abstract Diagnostic.Kind staticMemberValidationKind();
+  abstract boolean ignorePrivateAndStaticInjectionForComponent();
   abstract ValidationType scopeCycleValidationType();
 
   static Builder builder() {
@@ -50,6 +51,9 @@ static CompilerOptions create(ProcessingEnvironment processingEnv, Elements elem
             privateMemberValidationType(processingEnv).diagnosticKind().get())
         .staticMemberValidationKind(
             staticMemberValidationType(processingEnv).diagnosticKind().get())
+        .ignorePrivateAndStaticInjectionForComponent(
+            ignorePrivateAndStaticInjectionForComponent(processingEnv)
+                .equals(FeatureStatus.DISABLED))
         .scopeCycleValidationType(scopeValidationType(processingEnv))
         .build();
   }
@@ -61,6 +65,8 @@ static CompilerOptions create(ProcessingEnvironment processingEnv, Elements elem
     Builder nullableValidationKind(Diagnostic.Kind kind);
     Builder privateMemberValidationKind(Diagnostic.Kind kind);
     Builder staticMemberValidationKind(Diagnostic.Kind kind);
+    Builder ignorePrivateAndStaticInjectionForComponent(
+        boolean ignorePrivateAndStaticInjectionForComponent);
     Builder scopeCycleValidationType(ValidationType type);
     CompilerOptions build();
   }
@@ -76,12 +82,23 @@ static CompilerOptions create(ProcessingEnvironment processingEnv, Elements elem
 
   static final String STATIC_MEMBER_VALIDATION_TYPE_KEY = "dagger.staticMemberValidation";
 
+  /**
+   * If true, Dagger will generate factories and components even if some members-injected types
+   * have private or static {@code @Inject}-annotated members.
+   *
+   * <p>This defaults to false, and should only ever be enabled by the TCK tests. Disabling this
+   * validation could lead to generating code that does not compile.
+   */
+  static final String IGNORE_PRIVATE_AND_STATIC_INJECTION_FOR_COMPONENT =
+      "dagger.ignorePrivateAndStaticInjectionForComponent";
+
   static final ImmutableSet<String> SUPPORTED_OPTIONS = ImmutableSet.of(
         WRITE_PRODUCER_NAME_IN_TOKEN_KEY,
         DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY,
         NULLABLE_VALIDATION_KEY,
         PRIVATE_MEMBER_VALIDATION_TYPE_KEY,
-        STATIC_MEMBER_VALIDATION_TYPE_KEY);
+        STATIC_MEMBER_VALIDATION_TYPE_KEY,
+        IGNORE_PRIVATE_AND_STATIC_INJECTION_FOR_COMPONENT);
 
   private static FeatureStatus writeProducerNameInToken(ProcessingEnvironment processingEnv) {
     return valueOf(
@@ -123,6 +140,15 @@ private static ValidationType staticMemberValidationType(ProcessingEnvironment p
         EnumSet.of(ValidationType.ERROR, ValidationType.WARNING));
   }
 
+  private static FeatureStatus ignorePrivateAndStaticInjectionForComponent(
+      ProcessingEnvironment processingEnv) {
+    return valueOf(
+        processingEnv,
+        IGNORE_PRIVATE_AND_STATIC_INJECTION_FOR_COMPONENT,
+        FeatureStatus.DISABLED,
+        EnumSet.allOf(FeatureStatus.class));
+  }
+
   private static <T extends Enum<T>> T valueOf(
       ProcessingEnvironment processingEnv, String key, T defaultValue, Set<T> validValues) {
     Map<String, String> options = processingEnv.getOptions();
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index 219c68865..13a0b908b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -67,7 +67,8 @@ public SourceVersion getSupportedSourceVersion() {
         new DependencyRequestFormatter(types, elements);
     KeyFormatter keyFormatter = new KeyFormatter(methodSignatureFormatter);
 
-    InjectValidator injectValidator = new InjectValidator(compilerOptions);
+    InjectValidator injectValidator = new InjectValidator(types, elements, compilerOptions);
+    InjectValidator injectValidatorWhenGeneratingCode = injectValidator.whenGeneratingCode();
     ModuleValidator moduleValidator =
         new ModuleValidator(types, elements, methodSignatureFormatter);
     BuilderValidator builderValidator = new BuilderValidator(elements, types);
@@ -87,8 +88,10 @@ public SourceVersion getSupportedSourceVersion() {
     MultibindingsValidator multibindingsValidator =
         new MultibindingsValidator(elements, keyFactory, keyFormatter, methodSignatureFormatter);
 
-    this.factoryGenerator = new FactoryGenerator(filer, elements, compilerOptions);
-    this.membersInjectorGenerator = new MembersInjectorGenerator(filer, elements);
+    this.factoryGenerator =
+        new FactoryGenerator(filer, elements, compilerOptions, injectValidatorWhenGeneratingCode);
+    this.membersInjectorGenerator =
+        new MembersInjectorGenerator(filer, elements, injectValidatorWhenGeneratingCode);
     ComponentGenerator componentGenerator =
         new ComponentGenerator(filer, elements, types, keyFactory, compilerOptions);
     ProducerFactoryGenerator producerFactoryGenerator =
@@ -149,6 +152,7 @@ public SourceVersion getSupportedSourceVersion() {
             elements,
             types,
             compilerOptions,
+            injectValidatorWhenGeneratingCode,
             injectBindingRegistry,
             bindingDeclarationFormatter,
             methodSignatureFormatter,
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index 6ecf713e6..6e695e9c8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -78,6 +78,8 @@
       "@Qualifier annotations are not allowed on @Inject constructors.";
   static final String SCOPE_ON_INJECT_CONSTRUCTOR =
       "@Scope annotations are not allowed on @Inject constructors. Annotate the class instead.";
+  static final String CHECKED_EXCEPTIONS_ON_CONSTRUCTORS =
+      "Dagger does not support checked exceptions on @Inject constructors.";
 
   /* fields */
   static final String PRIVATE_INJECT_FIELD =
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index 19e3a6669..1880faf19 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -72,10 +72,16 @@
 final class FactoryGenerator extends SourceFileGenerator<ProvisionBinding> {
 
   private final CompilerOptions compilerOptions;
+  private final InjectValidator injectValidator;
 
-  FactoryGenerator(Filer filer, Elements elements, CompilerOptions compilerOptions) {
+  FactoryGenerator(
+      Filer filer,
+      Elements elements,
+      CompilerOptions compilerOptions,
+      InjectValidator injectValidator) {
     super(filer, elements);
     this.compilerOptions = compilerOptions;
+    this.injectValidator = injectValidator;
   }
 
   @Override
@@ -93,6 +99,11 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
     // We don't want to write out resolved bindings -- we want to write out the generic version.
     checkState(!binding.unresolved().isPresent());
 
+    if (binding.bindingKind().equals(INJECTION)
+        && !injectValidator.isValidType(binding.factoryType())) {
+      return Optional.absent();
+    }
+
     TypeName providedTypeName = TypeName.get(binding.factoryType());
     ParameterizedTypeName parameterizedFactoryName = factoryOf(providedTypeName);
     Optional<ParameterizedTypeName> factoryOfRawTypeName = Optional.absent();
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
index 45cb39d6a..77f52af40 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
@@ -262,7 +262,8 @@ private void registerBinding(MembersInjectionBinding binding, boolean warnIfNotA
       return Optional.of(cachedBinding);
     }
 
-    ValidationReport<TypeElement> report = injectValidator.validateType(typeElement);
+    ValidationReport<TypeElement> report =
+        injectValidator.validateMembersInjectionType(typeElement);
     report.printMessagesTo(messager);
     if (report.isClean()) {
       MembersInjectionBinding binding =
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectValidator.java b/compiler/src/main/java/dagger/internal/codegen/InjectValidator.java
index 6a6ce3e90..a6b4f0e0c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectValidator.java
@@ -17,6 +17,7 @@
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
+import com.google.common.base.Optional;
 import com.google.common.base.Predicate;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
@@ -30,9 +31,14 @@
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementFilter;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+import javax.tools.Diagnostic;
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static dagger.internal.codegen.Accessibility.isElementAccessibleFromOwnPackage;
 import static dagger.internal.codegen.ErrorMessages.ABSTRACT_INJECT_METHOD;
+import static dagger.internal.codegen.ErrorMessages.CHECKED_EXCEPTIONS_ON_CONSTRUCTORS;
 import static dagger.internal.codegen.ErrorMessages.FINAL_INJECT_FIELD;
 import static dagger.internal.codegen.ErrorMessages.GENERIC_INJECT_METHOD;
 import static dagger.internal.codegen.ErrorMessages.INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS;
@@ -55,6 +61,7 @@
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.STATIC;
+import static javax.lang.model.type.TypeKind.DECLARED;
 
 /**
  * A {@linkplain ValidationReport validator} for {@link Inject}-annotated elements and the types
@@ -64,10 +71,34 @@
  * @since 2.0
  */
 final class InjectValidator {
-  private CompilerOptions compilerOptions;
+  private final Types types;
+  private final Elements elements;
+  private final CompilerOptions compilerOptions;
+  private final Optional<Diagnostic.Kind> privateAndStaticInjectionDiagnosticKind;
 
-  InjectValidator(CompilerOptions compilerOptions) {
+  InjectValidator(Types types, Elements elements, CompilerOptions compilerOptions) {
+    this(types, elements, compilerOptions, Optional.<Diagnostic.Kind>absent());
+  }
+
+  private InjectValidator(
+      Types types,
+      Elements elements,
+      CompilerOptions compilerOptions,
+      Optional<Diagnostic.Kind> privateAndStaticInjectionDiagnosticKind) {
+    this.types = types;
+    this.elements = elements;
     this.compilerOptions = compilerOptions;
+    this.privateAndStaticInjectionDiagnosticKind = privateAndStaticInjectionDiagnosticKind;
+  }
+
+  /**
+   * Returns a new validator that performs the same validation as this one, but is strict about
+   * rejecting optionally-specified JSR 330 behavior that Dagger doesn't support.
+   */
+  InjectValidator whenGeneratingCode() {
+    return compilerOptions.ignorePrivateAndStaticInjectionForComponent()
+        ? new InjectValidator(types, elements, compilerOptions, Optional.of(Diagnostic.Kind.ERROR))
+        : this;
   }
 
   ValidationReport<TypeElement> validateConstructor(ExecutableElement constructorElement) {
@@ -97,12 +128,22 @@
       }
     }
 
+    if (throwsCheckedExceptions(constructorElement)) {
+      builder.addItem(
+          CHECKED_EXCEPTIONS_ON_CONSTRUCTORS,
+          privateAndStaticInjectionDiagnosticKind.or(compilerOptions.privateMemberValidationKind()),
+          constructorElement);
+    }
+
     TypeElement enclosingElement =
         MoreElements.asType(constructorElement.getEnclosingElement());
     Set<Modifier> typeModifiers = enclosingElement.getModifiers();
 
-    if (typeModifiers.contains(PRIVATE)) {
-      builder.addError(INJECT_INTO_PRIVATE_CLASS, constructorElement);
+    if (!Accessibility.isElementAccessibleFromOwnPackage(enclosingElement)) {
+      builder.addItem(
+          INJECT_INTO_PRIVATE_CLASS,
+          privateAndStaticInjectionDiagnosticKind.or(compilerOptions.privateMemberValidationKind()),
+          constructorElement);
     }
 
     if (typeModifiers.contains(ABSTRACT)) {
@@ -137,7 +178,7 @@
     return builder.build();
   }
 
- ValidationReport<VariableElement> validateField(VariableElement fieldElement) {
+  private ValidationReport<VariableElement> validateField(VariableElement fieldElement) {
     ValidationReport.Builder<VariableElement> builder = ValidationReport.about(fieldElement);
     Set<Modifier> modifiers = fieldElement.getModifiers();
     if (modifiers.contains(FINAL)) {
@@ -146,14 +187,18 @@
 
     if (modifiers.contains(PRIVATE)) {
       builder.addItem(
-          PRIVATE_INJECT_FIELD, compilerOptions.privateMemberValidationKind(), fieldElement);
+          PRIVATE_INJECT_FIELD,
+          privateAndStaticInjectionDiagnosticKind.or(compilerOptions.privateMemberValidationKind()),
+          fieldElement);
     }
 
     if (modifiers.contains(STATIC)) {
       builder.addItem(
-          STATIC_INJECT_FIELD, compilerOptions.staticMemberValidationKind(), fieldElement);
+          STATIC_INJECT_FIELD,
+          privateAndStaticInjectionDiagnosticKind.or(compilerOptions.staticMemberValidationKind()),
+          fieldElement);
     }
- 
+
     ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(fieldElement);
     if (qualifiers.size() > 1) {
       for (AnnotationMirror qualifier : qualifiers) {
@@ -168,7 +213,7 @@
     return builder.build();
   }
 
-  ValidationReport<ExecutableElement> validateMethod(ExecutableElement methodElement) {
+  private ValidationReport<ExecutableElement> validateMethod(ExecutableElement methodElement) {
     ValidationReport.Builder<ExecutableElement> builder = ValidationReport.about(methodElement);
     Set<Modifier> modifiers = methodElement.getModifiers();
     if (modifiers.contains(ABSTRACT)) {
@@ -177,12 +222,16 @@
 
     if (modifiers.contains(PRIVATE)) {
       builder.addItem(
-          PRIVATE_INJECT_METHOD, compilerOptions.privateMemberValidationKind(), methodElement);
+          PRIVATE_INJECT_METHOD,
+          privateAndStaticInjectionDiagnosticKind.or(compilerOptions.privateMemberValidationKind()),
+          methodElement);
     }
 
     if (modifiers.contains(STATIC)) {
       builder.addItem(
-          STATIC_INJECT_METHOD, compilerOptions.staticMemberValidationKind(), methodElement);
+          STATIC_INJECT_METHOD,
+          privateAndStaticInjectionDiagnosticKind.or(compilerOptions.staticMemberValidationKind()),
+          methodElement);
     }
 
     if (!methodElement.getTypeParameters().isEmpty()) {
@@ -204,12 +253,14 @@
     return builder.build();
   }
 
-  ValidationReport<TypeElement> validateType(TypeElement typeElement) {
+  ValidationReport<TypeElement> validateMembersInjectionType(TypeElement typeElement) {
     // TODO(beder): This element might not be currently compiled, so this error message could be
     // left in limbo. Find an appropriate way to display the error message in that case.
     ValidationReport.Builder<TypeElement> builder = ValidationReport.about(typeElement);
+    boolean hasInjectedMembers = false;
     for (VariableElement element : ElementFilter.fieldsIn(typeElement.getEnclosedElements())) {
       if (MoreElements.isAnnotationPresent(element, Inject.class)) {
+        hasInjectedMembers = true;
         ValidationReport<VariableElement> report = validateField(element);
         if (!report.isClean()) {
           builder.addSubreport(report);
@@ -218,12 +269,21 @@
     }
     for (ExecutableElement element : ElementFilter.methodsIn(typeElement.getEnclosedElements())) {
       if (MoreElements.isAnnotationPresent(element, Inject.class)) {
+        hasInjectedMembers = true;
         ValidationReport<ExecutableElement> report = validateMethod(element);
         if (!report.isClean()) {
           builder.addSubreport(report);
         }
       }
     }
+    // We can't use MembersInjectionBinding.Factory#hasInjectedMembers because that assumes this
+    // binding already validates, so we just check it again here.
+    if (hasInjectedMembers && !isElementAccessibleFromOwnPackage(typeElement)) {
+      builder.addItem(
+          INJECT_INTO_PRIVATE_CLASS,
+          privateAndStaticInjectionDiagnosticKind.or(compilerOptions.privateMemberValidationKind()),
+          typeElement);
+    }
     TypeMirror superclass = typeElement.getSuperclass();
     if (!superclass.getKind().equals(TypeKind.NONE)) {
       ValidationReport<TypeElement> report = validateType(MoreTypes.asTypeElement(superclass));
@@ -233,4 +293,44 @@
     }
     return builder.build();
   }
+
+  ValidationReport<TypeElement> validateType(TypeElement typeElement) {
+    ValidationReport.Builder<TypeElement> builder = ValidationReport.about(typeElement);
+    ValidationReport<TypeElement> membersInjectionReport =
+        validateMembersInjectionType(typeElement);
+    if (!membersInjectionReport.isClean()) {
+      builder.addSubreport(membersInjectionReport);
+    }
+    for (ExecutableElement element :
+        ElementFilter.constructorsIn(typeElement.getEnclosedElements())) {
+      if (isAnnotationPresent(element, Inject.class)) {
+        ValidationReport<TypeElement> report = validateConstructor(element);
+        if (!report.isClean()) {
+          builder.addSubreport(report);
+        }
+      }
+    }
+    return builder.build();
+  }
+
+  boolean isValidType(TypeMirror type) {
+    if (!type.getKind().equals(DECLARED)) {
+      return true;
+    }
+    return validateType(MoreTypes.asTypeElement(type)).isClean();
+  }
+
+  /** Returns true if the given method element declares a checked exception. */
+  private boolean throwsCheckedExceptions(ExecutableElement methodElement) {
+    TypeMirror runtimeExceptionType =
+        elements.getTypeElement(RuntimeException.class.getCanonicalName()).asType();
+    TypeMirror errorType = elements.getTypeElement(Error.class.getCanonicalName()).asType();
+    for (TypeMirror thrownType : methodElement.getThrownTypes()) {
+      if (!types.isSubtype(thrownType, runtimeExceptionType)
+          && !types.isSubtype(thrownType, errorType)) {
+        return true;
+      }
+    }
+    return false;
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
index 1310365c9..dc2c28ee8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
@@ -74,9 +74,11 @@
  * @since 2.0
  */
 final class MembersInjectorGenerator extends SourceFileGenerator<MembersInjectionBinding> {
+  private final InjectValidator injectValidator;
 
-  MembersInjectorGenerator(Filer filer, Elements elements) {
+  MembersInjectorGenerator(Filer filer, Elements elements, InjectValidator injectValidator) {
     super(filer, elements);
+    this.injectValidator = injectValidator;
   }
 
   @Override
@@ -95,6 +97,9 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
     if (binding.injectionSites().isEmpty()) {
       return Optional.absent();
     }
+    if (!injectValidator.isValidType(binding.key().type())) {
+      return Optional.absent();
+    }
     // We don't want to write out resolved bindings -- we want to write out the generic version.
     checkState(!binding.unresolved().isPresent());
 
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index d0ec03b68..23bb551d5 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -165,6 +165,35 @@
             "@Provides List<Integer> test.AnotherModule.provideListOfInteger()");
   }
 
+  @Test public void privateNestedClassWithWarningThatIsAnErrorInComponent() {
+    JavaFileObject outerClass = JavaFileObjects.forSourceLines("test.OuterClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class OuterClass {",
+        "  @Inject OuterClass(InnerClass innerClass) {}",
+        "",
+        "  private static final class InnerClass {",
+        "    @Inject InnerClass() {}",
+        "  }",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.BadComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "interface BadComponent {",
+        "  OuterClass outerClass();",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(outerClass, componentFile))
+        .withCompilerOptions("-Adagger.privateMemberValidation=WARNING")
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("Dagger does not support injection into private classes");
+  }
+
   @Test public void simpleComponent() {
     JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
         "package test;",
diff --git a/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
index ccfd6117e..7237812f7 100644
--- a/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
@@ -26,10 +26,12 @@
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.internal.codegen.ErrorMessages.ABSTRACT_INJECT_METHOD;
+import static dagger.internal.codegen.ErrorMessages.CHECKED_EXCEPTIONS_ON_CONSTRUCTORS;
 import static dagger.internal.codegen.ErrorMessages.FINAL_INJECT_FIELD;
 import static dagger.internal.codegen.ErrorMessages.GENERIC_INJECT_METHOD;
 import static dagger.internal.codegen.ErrorMessages.INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS;
 import static dagger.internal.codegen.ErrorMessages.INJECT_CONSTRUCTOR_ON_INNER_CLASS;
+import static dagger.internal.codegen.ErrorMessages.INJECT_INTO_PRIVATE_CLASS;
 import static dagger.internal.codegen.ErrorMessages.INJECT_ON_PRIVATE_CONSTRUCTOR;
 import static dagger.internal.codegen.ErrorMessages.MULTIPLE_INJECT_CONSTRUCTORS;
 import static dagger.internal.codegen.ErrorMessages.MULTIPLE_QUALIFIERS;
@@ -510,6 +512,114 @@
         .and().withErrorContaining(QUALIFIER_ON_INJECT_CONSTRUCTOR).in(file).onLine(8);
   }
 
+  @Test public void injectConstructorWithCheckedExceptionsError() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.CheckedExceptionClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class CheckedExceptionClass {",
+        "  @Inject CheckedExceptionClass() throws Exception {}",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(file))
+        .processedWith(new ComponentProcessor()).failsToCompile()
+        .withErrorContaining(CHECKED_EXCEPTIONS_ON_CONSTRUCTORS).in(file).onLine(6);
+  }
+
+  @Test public void injectConstructorWithCheckedExceptionsWarning() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.CheckedExceptionClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class CheckedExceptionClass {",
+        "  @Inject CheckedExceptionClass() throws Exception {}",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(file))
+        .withCompilerOptions("-Adagger.privateMemberValidation=WARNING")
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .withWarningContaining(CHECKED_EXCEPTIONS_ON_CONSTRUCTORS).in(file).onLine(6);
+  }
+
+  @Test public void privateInjectClassError() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.OuterClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class OuterClass {",
+        "  private static final class InnerClass {",
+        "    @Inject InnerClass() {}",
+        "  }",
+        "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(file))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(INJECT_INTO_PRIVATE_CLASS).in(file).onLine(7);
+  }
+
+  @Test public void privateInjectClassWarning() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.OuterClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class OuterClass {",
+        "  private static final class InnerClass {",
+        "    @Inject InnerClass() {}",
+        "  }",
+        "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(file))
+        .withCompilerOptions("-Adagger.privateMemberValidation=WARNING")
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .withWarningContaining(INJECT_INTO_PRIVATE_CLASS).in(file).onLine(7);
+  }
+
+  @Test public void nestedInPrivateInjectClassError() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.OuterClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class OuterClass {",
+        "  private static final class MiddleClass {",
+        "    static final class InnerClass {",
+        "      @Inject InnerClass() {}",
+        "    }",
+        "  }",
+        "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(file))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(INJECT_INTO_PRIVATE_CLASS).in(file).onLine(8);
+  }
+
+  @Test public void nestedInPrivateInjectClassWarning() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.OuterClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class OuterClass {",
+        "  private static final class MiddleClass {",
+        "    static final class InnerClass {",
+        "      @Inject InnerClass() {}",
+        "    }",
+        "  }",
+        "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(file))
+        .withCompilerOptions("-Adagger.privateMemberValidation=WARNING")
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .withWarningContaining(INJECT_INTO_PRIVATE_CLASS).in(file).onLine(8);
+  }
+
   @Test public void finalInjectField() {
     JavaFileObject file = JavaFileObjects.forSourceLines("test.FinalInjectField",
         "package test;",
diff --git a/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java b/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
index b14e913de..f30368611 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
@@ -33,6 +33,7 @@
 import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.ErrorMessages.INJECT_INTO_PRIVATE_CLASS;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 import static javax.tools.StandardLocation.CLASS_OUTPUT;
 
@@ -1025,4 +1026,59 @@ public void fieldInjectionForShadowedMember() {
         .compilesWithoutError()
         .and().generatesSources(expectedMembersInjector);
   }
+
+  @Test public void privateNestedClassError() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.OuterClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class OuterClass {",
+        "  private static final class InnerClass {",
+        "    @Inject int field;",
+        "  }",
+        "}");
+    assertAbout(javaSource())
+        .that(file)
+        .processedWith(new ComponentProcessor()).failsToCompile()
+        .withErrorContaining(INJECT_INTO_PRIVATE_CLASS).in(file).onLine(6);
+  }
+
+  @Test public void privateNestedClassWarning() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.OuterClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class OuterClass {",
+        "  private static final class InnerClass {",
+        "    @Inject int field;",
+        "  }",
+        "}");
+    assertAbout(javaSource())
+        .that(file)
+        .withCompilerOptions("-Adagger.privateMemberValidation=WARNING")
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .withWarningContaining(INJECT_INTO_PRIVATE_CLASS).in(file).onLine(6);
+  }
+
+  @Test public void privateSuperclassIsOkIfNotInjectedInto() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.OuterClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class OuterClass {",
+        "  private static class BaseClass {}",
+        "",
+        "  static final class DerivedClass extends BaseClass {",
+        "    @Inject int field;",
+        "  }",
+        "}");
+    assertAbout(javaSource())
+        .that(file)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError();
+  }
 }
