diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 95b01f38b..d9d48b6e4 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -76,7 +76,6 @@
 import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_UNCHECKED;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.ENUM_INSTANCE;
-import static dagger.internal.codegen.ContributionBinding.Kind.PROVISION;
 import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD;
 import static dagger.internal.codegen.FrameworkDependency.frameworkDependenciesForBinding;
 import static dagger.internal.codegen.MapKeys.getMapKeyExpression;
@@ -117,7 +116,6 @@
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
-import static javax.lang.model.element.Modifier.STATIC;
 import static javax.lang.model.type.TypeKind.DECLARED;
 import static javax.lang.model.type.TypeKind.VOID;
 
@@ -936,14 +934,11 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
 
       case COMPONENT_PROVISION:
         {
-          TypeElement bindingTypeElement =
-              graph.componentDescriptor().dependencyMethodIndex().get(binding.bindingElement());
-          String localFactoryVariable = simpleVariableName(bindingTypeElement);
+          TypeElement dependencyType = dependencyTypeForBinding(binding);
+          String dependencyVariable = simpleVariableName(dependencyType);
           CodeBlock callFactoryMethod =
               CodeBlock.of(
-                  "$L.$L()",
-                  localFactoryVariable,
-                  binding.bindingElement().getSimpleName().toString());
+                  "$L.$L()", dependencyVariable, binding.bindingElement().get().getSimpleName());
           // TODO(sameb): This throws a very vague NPE right now.  The stack trace doesn't
           // help to figure out what the method or return type is.  If we include a string
           // of the return type or method name in the error message, that can defeat obfuscation.
@@ -969,10 +964,10 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
                       "}"),
               /* 1 */ FACTORY,
               /* 2 */ bindingKeyTypeName,
-              /* 3 */ getComponentContributionExpression(bindingTypeElement),
+              /* 3 */ getComponentContributionExpression(dependencyType),
               /* 4 */ nullableAnnotation(binding.nullableType()),
-              /* 5 */ TypeName.get(bindingTypeElement.asType()),
-              /* 6 */ localFactoryVariable,
+              /* 5 */ TypeName.get(dependencyType.asType()),
+              /* 6 */ dependencyVariable,
               /* 7 */ getMethodBody);
         }
 
@@ -987,15 +982,14 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
                     "}"),
             /* 1 */ FACTORY,
             /* 2 */ bindingKeyTypeName,
-            /* 3 */ binding.bindingElement().getSimpleName().toString());
+            /* 3 */ binding.bindingElement().get().getSimpleName());
 
       case INJECTION:
       case PROVISION:
         {
           List<CodeBlock> arguments =
               Lists.newArrayListWithCapacity(binding.dependencies().size() + 1);
-          if (binding.bindingKind().equals(PROVISION)
-              && !binding.bindingElement().getModifiers().contains(STATIC)) {
+          if (binding.requiresModuleInstance()) {
             arguments.add(getComponentContributionExpression(binding.contributingModule().get()));
           }
           arguments.addAll(getDependencyArguments(binding));
@@ -1012,8 +1006,7 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
 
       case COMPONENT_PRODUCTION:
         {
-          TypeElement bindingTypeElement =
-              graph.componentDescriptor().dependencyMethodIndex().get(binding.bindingElement());
+          TypeElement dependencyType = dependencyTypeForBinding(binding);
           return CodeBlock.of(
               Joiner.on('\n')
                   .join(
@@ -1026,10 +1019,10 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
               /* 1 */ PRODUCER,
               /* 2 */ TypeName.get(binding.key().type()),
               /* 3 */ LISTENABLE_FUTURE,
-              /* 4 */ getComponentContributionExpression(bindingTypeElement),
-              /* 5 */ binding.bindingElement().getSimpleName().toString(),
-              /* 6 */ TypeName.get(bindingTypeElement.asType()),
-              /* 7 */ simpleVariableName(bindingTypeElement));
+              /* 4 */ getComponentContributionExpression(dependencyType),
+              /* 5 */ binding.bindingElement().get().getSimpleName(),
+              /* 6 */ TypeName.get(dependencyType.asType()),
+              /* 7 */ simpleVariableName(dependencyType));
         }
 
       case IMMEDIATE:
@@ -1037,8 +1030,8 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
         {
           List<CodeBlock> arguments =
               Lists.newArrayListWithCapacity(binding.implicitDependencies().size() + 2);
-          if (!binding.bindingElement().getModifiers().contains(STATIC)) {
-            arguments.add(getComponentContributionExpression(binding.bindingTypeElement()));
+          if (binding.requiresModuleInstance()) {
+            arguments.add(getComponentContributionExpression(binding.contributingModule().get()));
           }
           arguments.addAll(getDependencyArguments(binding));
 
@@ -1065,6 +1058,10 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
     }
   }
 
+  private TypeElement dependencyTypeForBinding(ContributionBinding binding) {
+    return graph.componentDescriptor().dependencyMethodIndex().get(binding.bindingElement().get());
+  }
+
   private CodeBlock decorateForScope(CodeBlock factoryCreate, Scope scope) {
       return CodeBlock.of(
           "$T.provider($L)",
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingDeclaration.java b/compiler/src/main/java/dagger/internal/codegen/BindingDeclaration.java
index 7fe894edc..f71c83287 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingDeclaration.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingDeclaration.java
@@ -15,59 +15,54 @@
  */
 package dagger.internal.codegen;
 
-import com.google.auto.common.MoreElements;
 import com.google.common.base.Function;
 import com.google.common.base.Optional;
 import com.google.common.base.Predicate;
 import dagger.internal.codegen.Key.HasKey;
 import java.util.Set;
 import javax.lang.model.element.Element;
-import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.DeclaredType;
 
-import static dagger.internal.codegen.Util.AS_DECLARED_TYPE;
 import static dagger.internal.codegen.Util.ENCLOSING_TYPE_ELEMENT;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.STATIC;
 
 /** An object that declares or specifies a binding. */
 abstract class BindingDeclaration implements HasKey {
 
-  /** The {@link Element} that declares the binding. */
-  abstract Element bindingElement();
-
   /**
-   * The {@link ExecutableElement} that declares the binding. Equivalent to
-   * {@code MoreElements.asExecutable(bindingElement())}.
-   *
-   * @throws IllegalStateException if {@link #bindingElement()} is not an executable element
+   * The {@link Element} that declares the binding. Absent for bindings without identifying
+   * declarations.
    */
-  ExecutableElement bindingElementAsExecutable() {
-    try {
-      return MoreElements.asExecutable(bindingElement());
-    } catch (IllegalArgumentException e) {
-      throw new IllegalStateException(e);
-    }
-  }
+  abstract Optional<Element> bindingElement();
 
-  /** The type enclosing the {@link #bindingElement()}. */
-  TypeElement bindingTypeElement() {
-    return ENCLOSING_TYPE_ELEMENT.visit(bindingElement());
+  /**
+   * The type enclosing the {@link #bindingElement()}, or {@link Optional#absent()} if {@link
+   * #bindingElement()} is absent.
+   */
+  Optional<TypeElement> bindingTypeElement() {
+    return bindingElement()
+        .transform(
+            new Function<Element, TypeElement>() {
+              @Override
+              public TypeElement apply(Element element) {
+                return element.accept(ENCLOSING_TYPE_ELEMENT, null);
+              }
+            });
   }
-
+  
   /**
-   * The installed module class that contributed the {@link #bindingElement()}. May be a subclass
-   * of the class that contains {@link #bindingElement()}.
+   * The installed module class that contributed the {@link #bindingElement()}. May be a subclass of
+   * the class that contains {@link #bindingElement()}. Absent if {@link #bindingElement()} is
+   * absent.
    */
   abstract Optional<TypeElement> contributingModule();
 
   /**
-   * The type of {@link #contributingModule()}.
+   * A function that returns a singleton set containing the {@link #contributingModule()} for
+   * binding declarations that have one, and an empty set for those that don't.
    */
-  Optional<DeclaredType> contributingModuleType() {
-    return contributingModule().transform(AS_DECLARED_TYPE);
-  }
-
   static final Function<BindingDeclaration, Set<TypeElement>> CONTRIBUTING_MODULE =
       new Function<BindingDeclaration, Set<TypeElement>>() {
         @Override
@@ -76,12 +71,39 @@ TypeElement bindingTypeElement() {
         }
       };
 
-  static Predicate<BindingDeclaration> bindingElementHasModifier(final Modifier modifier) {
-    return new Predicate<BindingDeclaration>() {
-      @Override
-      public boolean apply(BindingDeclaration bindingDeclaration) {
-        return bindingDeclaration.bindingElement().getModifiers().contains(modifier);
-      }
-    };
+  /**
+   * {@code true} if {@link #contributingModule()} is present and this is a nonabstract instance
+   * method.
+   */
+  boolean requiresModuleInstance() {
+    if (!bindingElement().isPresent() || !contributingModule().isPresent()) {
+      return false;
+    }
+    Set<Modifier> modifiers = bindingElement().get().getModifiers();
+    return !modifiers.contains(ABSTRACT) && !modifiers.contains(STATIC);
   }
+
+  /**
+   * A predicate that passes for binding declarations for which {@link #requiresModuleInstance()} is
+   * {@code true}.
+   */
+  static final Predicate<BindingDeclaration> REQUIRES_MODULE_INSTANCE =
+      new Predicate<BindingDeclaration>() {
+        @Override
+        public boolean apply(BindingDeclaration bindingDeclaration) {
+          return bindingDeclaration.requiresModuleInstance();
+        }
+      };
+
+  /**
+   * A predicate that passes for binding declarations for which {@link #bindingElement()} is
+   * present.
+   */
+  static final Predicate<BindingDeclaration> HAS_BINDING_ELEMENT =
+      new Predicate<BindingDeclaration>() {
+        @Override
+        public boolean apply(BindingDeclaration bindingDeclaration) {
+          return bindingDeclaration.bindingElement().isPresent();
+        }
+      };
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingDeclarationFormatter.java b/compiler/src/main/java/dagger/internal/codegen/BindingDeclarationFormatter.java
index d682ea486..221881821 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingDeclarationFormatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingDeclarationFormatter.java
@@ -15,7 +15,12 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreElements;
+import javax.lang.model.element.Element;
+
+import static com.google.common.base.Preconditions.checkArgument;
 import static dagger.internal.codegen.ErrorMessages.stripCommonTypePrefixes;
+import static dagger.internal.codegen.Util.AS_DECLARED_TYPE;
 
 /**
  * Formats a {@link BindingDeclaration} into a {@link String} suitable for use in error messages.
@@ -29,16 +34,20 @@
 
   @Override
   public String format(BindingDeclaration bindingDeclaration) {
-    switch (bindingDeclaration.bindingElement().asType().getKind()) {
+    checkArgument(
+        bindingDeclaration.bindingElement().isPresent(),
+        "Cannot format bindings without source elements: %s",
+        bindingDeclaration);
+    Element bindingElement = bindingDeclaration.bindingElement().get();
+    switch (bindingElement.asType().getKind()) {
       case EXECUTABLE:
         return methodSignatureFormatter.format(
-            bindingDeclaration.bindingElementAsExecutable(),
-            bindingDeclaration.contributingModuleType());
+            MoreElements.asExecutable(bindingElement),
+            bindingDeclaration.contributingModule().transform(AS_DECLARED_TYPE));
       case DECLARED:
-        return stripCommonTypePrefixes(bindingDeclaration.bindingElement().asType().toString());
+        return stripCommonTypePrefixes(bindingElement.asType().toString());
       default:
-        throw new IllegalArgumentException(
-            "Formatting unsupported for element: " + bindingDeclaration.bindingElement());
+        throw new IllegalArgumentException("Formatting unsupported for element: " + bindingElement);
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index ee00ed823..a2bdf2fe9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -79,7 +79,6 @@
 import static dagger.internal.codegen.Key.indexByKey;
 import static dagger.internal.codegen.Scope.reusableScope;
 import static javax.lang.model.element.Modifier.ABSTRACT;
-import static javax.lang.model.element.Modifier.STATIC;
 
 /**
  * The canonical representation of a full-resolved graph.
@@ -129,8 +128,7 @@
         .preOrderTraversal(this)
         .transformAndConcat(RESOLVED_BINDINGS)
         .transformAndConcat(ResolvedBindings.CONTRIBUTION_BINDINGS)
-        .filter(not(BindingDeclaration.bindingElementHasModifier(STATIC)))
-        .filter(not(BindingDeclaration.bindingElementHasModifier(ABSTRACT)))
+        .filter(BindingDeclaration.REQUIRES_MODULE_INSTANCE)
         .transformAndConcat(BindingDeclaration.CONTRIBUTING_MODULE)
         .filter(in(ownedModuleTypes()))
         .append(componentDescriptor().dependencies())
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 0f4e64ed4..8ac7dd89b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -72,6 +72,7 @@
 import static com.google.auto.common.MoreTypes.asDeclared;
 import static com.google.auto.common.MoreTypes.asExecutable;
 import static com.google.auto.common.MoreTypes.asTypeElements;
+import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.base.Predicates.equalTo;
 import static com.google.common.base.Predicates.in;
@@ -81,6 +82,7 @@
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static com.google.common.collect.Iterables.indexOf;
 import static com.google.common.collect.Maps.filterKeys;
+import static dagger.internal.codegen.BindingDeclaration.HAS_BINDING_ELEMENT;
 import static dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor.isOfKind;
 import static dagger.internal.codegen.ComponentDescriptor.ComponentMethodKind.PRODUCTION_SUBCOMPONENT;
 import static dagger.internal.codegen.ComponentDescriptor.ComponentMethodKind.SUBCOMPONENT;
@@ -88,8 +90,6 @@
 import static dagger.internal.codegen.ContributionBinding.indexMapBindingsByAnnotationType;
 import static dagger.internal.codegen.ContributionBinding.indexMapBindingsByMapKey;
 import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
-import static dagger.internal.codegen.ContributionBinding.Kind.IS_SYNTHETIC_KIND;
-import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_DELEGATE_BINDING;
 import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MULTIBOUND_MAP;
 import static dagger.internal.codegen.ContributionType.indexByContributionType;
 import static dagger.internal.codegen.ErrorMessages.CANNOT_INJECT_WILDCARD_TYPE;
@@ -425,10 +425,7 @@ private void validateResolvedBindings(DependencyPath path) {
             }
           }
           if (contributionBinding.bindingKind().equals(SYNTHETIC_MULTIBOUND_MAP)) {
-            ImmutableSet<ContributionBinding> multibindings =
-                inlineSyntheticNondelegateContributions(resolvedBindings).contributionBindings();
-            validateMapKeySet(path, multibindings);
-            validateMapKeyAnnotationTypes(path, multibindings);
+            validateMapKeys(path, contributionBinding);
           }
           break;
         case MEMBERS_INJECTION:
@@ -451,32 +448,28 @@ private void validateResolvedBindings(DependencyPath path) {
 
     /**
      * Returns an object that contains all the same bindings as {@code resolvedBindings}, except
-     * that any synthetic {@link ContributionBinding}s are replaced by the contribution bindings and
-     * multibinding declarations of their dependencies.
+     * that any {@link ContributionBinding}s without {@linkplain Binding#bindingElement() binding
+     * elements} are replaced by the contribution bindings and multibinding declarations of their
+     * dependencies.
      *
      * <p>For example, if:
      *
      * <ul>
      * <li>The bindings for {@code key1} are {@code A} and {@code B}, with multibinding declaration
      *     {@code X}.
-     * <li>{@code B} is a synthetic binding with a dependency on {@code key2}.
+     * <li>{@code B} is a binding without a binding element that has a dependency on {@code key2}.
      * <li>The bindings for {@code key2} are {@code C} and {@code D}, with multibinding declaration
      *     {@code Y}.
      * </ul>
      *
-     * then {@code inlineSyntheticNondelegateContributions(bindingsForKey1)} has bindings {@code A},
-     * {@code C}, and {@code D}, with multibinding declarations {@code X} and {@code Y}.
+     * then {@code inlineContributionsWithoutBindingElements(bindingsForKey1)} has bindings {@code
+     * A}, {@code C}, and {@code D}, with multibinding declarations {@code X} and {@code Y}.
      *
-     * <p>The replacement is repeated until none of the bindings are synthetic.
+     * <p>The replacement is repeated until all of the bindings have elements.
      */
-    // TODO(dpb): The actual operation we want is to inline bindings without real binding elements.
-    // Delegate bindings are the first example of synthetic bindings that have real binding elements
-    // and nonsynthetic dependencies.
-    private ResolvedBindings inlineSyntheticNondelegateContributions(
+    private ResolvedBindings inlineContributionsWithoutBindingElements(
         ResolvedBindings resolvedBinding) {
-      if (!FluentIterable.from(resolvedBinding.contributionBindings())
-          .transform(ContributionBinding.KIND)
-          .anyMatch(IS_SYNTHETIC_KIND)) {
+      if (Iterables.all(resolvedBinding.bindings(), HAS_BINDING_ELEMENT)) {
         return resolvedBinding;
       }
 
@@ -494,13 +487,12 @@ private ResolvedBindings inlineSyntheticNondelegateContributions(
             queued.allContributionBindings().entries()) {
           BindingGraph owningGraph = validationForComponent(bindingEntry.getKey()).subject;
           ContributionBinding binding = bindingEntry.getValue();
-          if (binding.isSyntheticBinding()
-              && !binding.bindingKind().equals(SYNTHETIC_DELEGATE_BINDING)) {
+          if (binding.bindingElement().isPresent()) {
+            contributions.put(bindingEntry);
+          } else {
             for (DependencyRequest dependency : binding.dependencies()) {
               queue.add(owningGraph.resolvedBindings().get(dependency.bindingKey()));
             }
-          } else {
-            contributions.put(bindingEntry);
           }
         }
       }
@@ -513,7 +505,7 @@ private ResolvedBindings inlineSyntheticNondelegateContributions(
 
     private ImmutableListMultimap<ContributionType, BindingDeclaration> declarationsByType(
         ResolvedBindings resolvedBinding) {
-      ResolvedBindings inlined = inlineSyntheticNondelegateContributions(resolvedBinding);
+      ResolvedBindings inlined = inlineContributionsWithoutBindingElements(resolvedBinding);
       return new ImmutableListMultimap.Builder<ContributionType, BindingDeclaration>()
           .putAll(indexByContributionType(inlined.contributionBindings()))
           .putAll(indexByContributionType(inlined.multibindingDeclarations()))
@@ -545,6 +537,23 @@ private void validateNullability(DependencyRequest request, Set<ContributionBind
       }
     }
 
+    private void validateMapKeys(
+        DependencyPath path, ContributionBinding binding) {
+      checkArgument(binding.bindingKind().equals(SYNTHETIC_MULTIBOUND_MAP),
+          "binding must be a synthetic multibound map: %s",
+          binding);
+      ImmutableSet.Builder<ContributionBinding> multibindingContributionsBuilder =
+          ImmutableSet.builder();
+      for (DependencyRequest dependency : binding.dependencies()) {
+        multibindingContributionsBuilder.add(
+            subject.resolvedBindings().get(dependency.bindingKey()).contributionBinding());
+      }
+      ImmutableSet<ContributionBinding> multibindingContributions =
+          multibindingContributionsBuilder.build();
+      validateMapKeySet(path, multibindingContributions);
+      validateMapKeyAnnotationTypes(path, multibindingContributions);
+    }
+
     /**
      * Reports errors if {@code mapBindings} has more than one binding for the same map key.
      */
@@ -904,13 +913,13 @@ void validateComponentScope() {
               case PROVISION:
                 incompatiblyScopedMethodsBuilder.add(
                     methodSignatureFormatter.format(
-                        contributionBinding.bindingElementAsExecutable()));
+                        MoreElements.asExecutable(contributionBinding.bindingElement().get())));
                 break;
               case INJECTION:
                 incompatiblyScopedMethodsBuilder.add(
                     bindingScope.get().getReadableSource()
                         + " class "
-                        + contributionBinding.bindingTypeElement().getQualifiedName());
+                        + contributionBinding.bindingTypeElement().get().getQualifiedName());
                 break;
               default:
                 throw new IllegalStateException();
@@ -1032,7 +1041,7 @@ private void reportDuplicateBindings(DependencyPath path) {
       new Formatter(builder)
           .format(ErrorMessages.DUPLICATE_BINDINGS_FOR_KEY_FORMAT, formatRootRequestKey(path));
       ImmutableSet<ContributionBinding> duplicateBindings =
-          inlineSyntheticNondelegateContributions(resolvedBindings).contributionBindings();
+          inlineContributionsWithoutBindingElements(resolvedBindings).contributionBindings();
       bindingDeclarationFormatter.formatIndentedList(
           builder, duplicateBindings, 1, DUPLICATE_SIZE_LIMIT);
       owningReportBuilder(duplicateBindings).addError(builder.toString(), path.entryPointElement());
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
index 472c7115a..c9114f733 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
@@ -50,7 +50,6 @@
 import static dagger.internal.codegen.ContributionType.SET;
 import static dagger.internal.codegen.MapKeys.unwrapValue;
 import static dagger.internal.codegen.MoreAnnotationMirrors.unwrapOptionalEquivalence;
-import static javax.lang.model.element.Modifier.STATIC;
 
 /**
  * An abstract class for a value object representing the mechanism by which a {@link Key} can be
@@ -239,7 +238,7 @@ FactoryCreationStrategy factoryCreationStrategy() {
       case SYNTHETIC_DELEGATE_BINDING:
         return DELEGATE;
       case PROVISION:
-        return implicitDependencies().isEmpty() && bindingElement().getModifiers().contains(STATIC)
+        return implicitDependencies().isEmpty() && !requiresModuleInstance()
             ? ENUM_INSTANCE
             : CLASS_CONSTRUCTOR;
       case INJECTION:
diff --git a/compiler/src/main/java/dagger/internal/codegen/DelegateDeclaration.java b/compiler/src/main/java/dagger/internal/codegen/DelegateDeclaration.java
index f4653b538..77f8cfa02 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DelegateDeclaration.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DelegateDeclaration.java
@@ -24,6 +24,7 @@
 import dagger.Binds;
 import dagger.internal.codegen.ContributionType.HasContributionType;
 import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.ExecutableType;
@@ -67,7 +68,7 @@ DelegateDeclaration create(
       return new AutoValue_DelegateDeclaration(
           ContributionType.fromBindingMethod(bindsMethod),
           keyFactory.forBindsMethod(bindsMethod, contributingElement),
-          bindsMethod,
+          Optional.<Element>of(bindsMethod),
           Optional.of(contributingElement),
           delegateRequest,
           wrapOptionalInEquivalence(getMapKey(bindsMethod)));
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index 276c0447c..228fe3154 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -38,7 +38,7 @@
 import javax.lang.model.util.Elements;
 import javax.tools.Diagnostic;
 
-import static com.google.common.base.Preconditions.checkState;
+import static com.google.common.base.Preconditions.checkArgument;
 import static com.squareup.javapoet.MethodSpec.constructorBuilder;
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static com.squareup.javapoet.TypeSpec.classBuilder;
@@ -90,13 +90,14 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
 
   @Override
   Optional<? extends Element> getElementForErrorReporting(ProvisionBinding binding) {
-    return Optional.of(binding.bindingElement());
+    return binding.bindingElement();
   }
 
   @Override
   Optional<TypeSpec.Builder> write(ClassName generatedTypeName, ProvisionBinding binding) {
     // We don't want to write out resolved bindings -- we want to write out the generic version.
-    checkState(!binding.unresolved().isPresent());
+    checkArgument(!binding.unresolved().isPresent());
+    checkArgument(binding.bindingElement().isPresent());
 
     if (binding.bindingKind().equals(INJECTION)
         && !injectValidator.isValidType(binding.factoryType())) {
@@ -128,14 +129,11 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
         break;
       case CLASS_CONSTRUCTOR:
         factoryBuilder =
-            classBuilder(generatedTypeName)
-                .addTypeVariables(typeParameters)
-                .addModifiers(FINAL);
+            classBuilder(generatedTypeName).addTypeVariables(typeParameters).addModifiers(FINAL);
         constructorBuilder = Optional.of(constructorBuilder().addModifiers(PUBLIC));
-        if (binding.bindingKind().equals(PROVISION)
-            && !binding.bindingElement().getModifiers().contains(STATIC)) {
+        if (binding.requiresModuleInstance()) {
           addConstructorParameterAndTypeField(
-              TypeName.get(binding.bindingTypeElement().asType()),
+              TypeName.get(binding.bindingTypeElement().get().asType()),
               "module",
               factoryBuilder,
               constructorBuilder.get());
@@ -228,13 +226,14 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
 
     if (binding.bindingKind().equals(PROVISION)) {
       CodeBlock.Builder providesMethodInvocationBuilder = CodeBlock.builder();
-      if (binding.bindingElement().getModifiers().contains(STATIC)) {
-        providesMethodInvocationBuilder.add("$T", ClassName.get(binding.bindingTypeElement()));
-      } else {
+      if (binding.requiresModuleInstance()) {
         providesMethodInvocationBuilder.add("module");
+      } else {
+        providesMethodInvocationBuilder.add(
+            "$T", ClassName.get(binding.bindingTypeElement().get()));
       }
       providesMethodInvocationBuilder.add(
-          ".$L($L)", binding.bindingElement().getSimpleName(), parametersCodeBlock);
+          ".$L($L)", binding.bindingElement().get().getSimpleName(), parametersCodeBlock);
       CodeBlock providesMethodInvocation = providesMethodInvocationBuilder.build();
 
       if (binding.nullableType().isPresent()
diff --git a/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java b/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
index b7fb2b135..f23ccf38f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
@@ -91,8 +91,8 @@ private static TypeMirror fieldValueType(ResolvedBindings resolvedBindings) {
   private static String frameworkFieldName(ResolvedBindings resolvedBindings) {
     if (resolvedBindings.bindingKey().kind().equals(BindingKey.Kind.CONTRIBUTION)) {
       ContributionBinding binding = resolvedBindings.contributionBinding();
-      if (!binding.isSyntheticBinding()) {
-        return BINDING_ELEMENT_NAME.visit(binding.bindingElement(), binding);
+      if (binding.bindingElement().isPresent()) {
+        return BINDING_ELEMENT_NAME.visit(binding.bindingElement().get(), binding);
       }
     }
     return BindingVariableNamer.name(resolvedBindings.binding());
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
index ee94329d0..1e8422242 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
@@ -133,7 +133,7 @@ private void tryToCacheBinding(B binding) {
       // We only cache resolved bindings or unresolved bindings w/o type arguments.
       // Unresolved bindings w/ type arguments aren't valid for the object graph.
       if (binding.unresolved().isPresent()
-          || binding.bindingTypeElement().getTypeParameters().isEmpty()) {
+          || binding.bindingTypeElement().get().getTypeParameters().isEmpty()) {
         Key key = binding.key();
         Binding previousValue = bindingsByKey.put(key, binding);
         checkState(previousValue == null || binding.equals(previousValue),
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
index 2854eb519..a3d3bbae2 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
@@ -61,13 +61,16 @@
  */
 @AutoValue
 abstract class MembersInjectionBinding extends Binding {
+  @Override
+  Optional<Element> bindingElement() {
+    return Optional.<Element>of(membersInjectedType());
+  }
+
+  abstract TypeElement membersInjectedType();
+
   @Override
   abstract Optional<MembersInjectionBinding> unresolved();
 
-  TypeElement membersInjectedType() {
-    return MoreElements.asType(bindingElement());
-  }
-  
   @Override
   Optional<TypeElement> contributingModule() {
     return Optional.absent();
@@ -225,9 +228,9 @@ public Key apply(DeclaredType superclass) {
       Key key = keyFactory.forMembersInjectedType(declaredType);
       TypeElement typeElement = MoreElements.asType(declaredType.asElement());
       return new AutoValue_MembersInjectionBinding(
-          typeElement,
           key,
           dependencies,
+          typeElement,
           hasNonDefaultTypeParameters(typeElement, key.type(), types)
               ? Optional.of(
                   forInjectedType(
diff --git a/compiler/src/main/java/dagger/internal/codegen/MultibindingDeclaration.java b/compiler/src/main/java/dagger/internal/codegen/MultibindingDeclaration.java
index 9bb8b1636..5a3ae304d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MultibindingDeclaration.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MultibindingDeclaration.java
@@ -146,7 +146,7 @@ private MultibindingDeclaration forDeclaredMethod(
           "%s must return a set or map",
           method);
       return new AutoValue_MultibindingDeclaration(
-          method,
+          Optional.<Element>of(method),
           Optional.of(contributingType),
           keyFactory.forMultibindsMethod(bindingType, methodType, method),
           contributionType(returnType),
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
index 38ef0ad51..2b7023d83 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -35,6 +35,7 @@
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 
+import static com.google.common.base.Preconditions.checkArgument;
 import static com.squareup.javapoet.ClassName.OBJECT;
 import static com.squareup.javapoet.MethodSpec.constructorBuilder;
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
@@ -56,7 +57,6 @@
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PROTECTED;
 import static javax.lang.model.element.Modifier.PUBLIC;
-import static javax.lang.model.element.Modifier.STATIC;
 
 /**
  * Generates {@link Producer} implementations from {@link ProductionBinding} instances.
@@ -79,11 +79,13 @@ ClassName nameGeneratedType(ProductionBinding binding) {
 
   @Override
   Optional<? extends Element> getElementForErrorReporting(ProductionBinding binding) {
-    return Optional.of(binding.bindingElement());
+    return binding.bindingElement();
   }
 
   @Override
   Optional<TypeSpec.Builder> write(ClassName generatedTypeName, ProductionBinding binding) {
+    checkArgument(binding.bindingElement().isPresent());
+
     TypeName providedTypeName = TypeName.get(binding.factoryType());
     TypeName futureTypeName = listenableFutureOf(providedTypeName);
 
@@ -103,8 +105,8 @@ ClassName nameGeneratedType(ProductionBinding binding) {
                 fields.get(binding.monitorRequest().get().bindingKey()).name(),
                 producerTokenConstruction(generatedTypeName, binding));
 
-    if (!binding.bindingElement().getModifiers().contains(STATIC)) {
-      TypeName moduleType = TypeName.get(binding.bindingTypeElement().asType());
+    if (binding.requiresModuleInstance()) {
+      TypeName moduleType = TypeName.get(binding.bindingTypeElement().get().asType());
       addFieldAndConstructorParameter(factoryBuilder, constructorBuilder, "module", moduleType);
     }
 
@@ -215,8 +217,8 @@ private CodeBlock producerTokenConstruction(
                 "$S",
                 String.format(
                     "%s#%s",
-                    ClassName.get(binding.bindingTypeElement()),
-                    binding.bindingElement().getSimpleName()))
+                    ClassName.get(binding.bindingTypeElement().get()),
+                    binding.bindingElement().get().getSimpleName()))
             : CodeBlock.of("$T.class", generatedTypeName);
     return CodeBlock.of("$T.create($L)", PRODUCER_TOKEN, producerTokenArgs);
   }
@@ -457,10 +459,10 @@ private CodeBlock getInvocationCodeBlock(
     CodeBlock moduleCodeBlock =
         CodeBlock.of(
             "$L.$L($L)",
-            binding.bindingElement().getModifiers().contains(STATIC)
-                ? CodeBlock.of("$T", ClassName.get(binding.bindingTypeElement()))
-                : CodeBlock.of("$T.this.module", generatedTypeName),
-            binding.bindingElement().getSimpleName(),
+            binding.requiresModuleInstance()
+                ? CodeBlock.of("$T.this.module", generatedTypeName)
+                : CodeBlock.of("$T", ClassName.get(binding.bindingTypeElement().get())),
+            binding.bindingElement().get().getSimpleName(),
             makeParametersCodeBlock(parameterCodeBlocks));
 
     // NOTE(beder): We don't worry about catching exceptions from the monitor methods themselves
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
index bfe8a099d..f27f6bef9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
@@ -162,7 +162,6 @@ ProductionBinding syntheticMapOfValuesOrProducedBinding(
               requestForMapOfValuesOrProduced, mapOfProducersKey.get());
       return ProductionBinding.builder()
           .contributionType(ContributionType.UNIQUE)
-          .bindingElement(requestForMapOfProducers.requestElement())
           .key(requestForMapOfValuesOrProduced.key())
           .dependencies(requestForMapOfProducers)
           .bindingKind(Kind.SYNTHETIC_MAP)
@@ -179,7 +178,6 @@ ProductionBinding syntheticMultibinding(
         DependencyRequest request, Iterable<ContributionBinding> multibindingContributions) {
       return ProductionBinding.builder()
           .contributionType(ContributionType.UNIQUE)
-          .bindingElement(request.requestElement())
           .key(request.key())
           .dependencies(
               dependencyRequestFactory.forMultibindingContributions(
@@ -206,7 +204,7 @@ ProductionBinding delegate(
         DelegateDeclaration delegateDeclaration, ProductionBinding delegateBinding) {
       return ProductionBinding.builder()
           .contributionType(delegateDeclaration.contributionType())
-          .bindingElement(delegateDeclaration.bindingElement())
+          .bindingElement(delegateDeclaration.bindingElement().get())
           .contributingModule(delegateDeclaration.contributingModule().get())
           .key(keyFactory.forDelegateBinding(delegateDeclaration, Producer.class))
           .dependencies(delegateDeclaration.delegateRequest())
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index 6d43149b1..532778e0c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -209,13 +209,9 @@ ProvisionBinding syntheticMapOfValuesBinding(DependencyRequest requestForMapOfVa
               requestForMapOfValues, mapOfProvidersKey.get());
       return ProvisionBinding.builder()
           .contributionType(ContributionType.UNIQUE)
-          .bindingElement(requestForMapOfProviders.requestElement())
           .key(requestForMapOfValues.key())
           .dependencies(requestForMapOfProviders)
-          .wrappedMapKey(
-              wrapOptionalInEquivalence(getMapKey(requestForMapOfProviders.requestElement())))
           .bindingKind(Kind.SYNTHETIC_MAP)
-          .scope(Scope.uniqueScopeOf(requestForMapOfProviders.requestElement()))
           .build();
     }
 
@@ -229,13 +225,11 @@ ProvisionBinding syntheticMultibinding(
         DependencyRequest request, Iterable<ContributionBinding> multibindingContributions) {
       return ProvisionBinding.builder()
           .contributionType(ContributionType.UNIQUE)
-          .bindingElement(request.requestElement())
           .key(request.key())
           .dependencies(
               dependencyRequestFactory.forMultibindingContributions(
                   request, multibindingContributions))
           .bindingKind(Kind.forMultibindingRequest(request))
-          .scope(Scope.uniqueScopeOf(request.requestElement()))
           .build();
     }
 
@@ -282,14 +276,14 @@ ProvisionBinding delegate(
         DelegateDeclaration delegateDeclaration, ProvisionBinding delegate) {
       return ProvisionBinding.builder()
           .contributionType(delegateDeclaration.contributionType())
-          .bindingElement(delegateDeclaration.bindingElement())
+          .bindingElement(delegateDeclaration.bindingElement().get())
           .contributingModule(delegateDeclaration.contributingModule().get())
           .key(keyFactory.forDelegateBinding(delegateDeclaration, Provider.class))
           .dependencies(delegateDeclaration.delegateRequest())
           .nullableType(delegate.nullableType())
           .wrappedMapKey(delegateDeclaration.wrappedMapKey())
           .bindingKind(Kind.SYNTHETIC_DELEGATE_BINDING)
-          .scope(Scope.uniqueScopeOf(delegateDeclaration.bindingElement()))
+          .scope(Scope.uniqueScopeOf(delegateDeclaration.bindingElement().get()))
           .build();
     }
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
index 9bb8d3df3..76ff8a72c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
@@ -20,7 +20,6 @@
 import com.google.common.base.Optional;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
@@ -35,7 +34,6 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.collect.Iterables.getOnlyElement;
-import static dagger.internal.codegen.ContributionType.indexByContributionType;
 
 /**
  * The collection of bindings that have been resolved for a binding key. For valid graphs, contains
@@ -288,38 +286,12 @@ public BindingType bindingType() {
   /**
    * The contribution type for these bindings.
    *
-   * @throws IllegalStateException if {@link #isEmpty()} or the contribution types conflict
+   * @throws IllegalStateException if there is not exactly one element in {@link
+   *     #contributionBindings()}, which will never happen for contributions in valid graphs
    */
   @Override
   public ContributionType contributionType() {
-    ImmutableSet<ContributionType> types = contributionTypes();
-    checkState(!types.isEmpty(), "no bindings or declarations for %s", bindingKey());
-    checkState(
-        types.size() == 1,
-        "More than one binding present of different types for %s: %s",
-        bindingKey(),
-        bindingsAndDeclarationsByContributionType());
-    return getOnlyElement(types);
-  }
-
-  /**
-   * The contribution types represented by {@link #contributionBindings()} and
-   * {@link #multibindingDeclarations()}.
-   */
-  ImmutableSet<ContributionType> contributionTypes() {
-    return bindingsAndDeclarationsByContributionType().keySet();
-  }
-
-  /**
-   * The {@link #contributionBindings()} and {@link #multibindingDeclarations()}, indexed by
-   * {@link ContributionType}.
-   */
-  ImmutableListMultimap<ContributionType, BindingDeclaration>
-      bindingsAndDeclarationsByContributionType() {
-    return new ImmutableListMultimap.Builder<ContributionType, BindingDeclaration>()
-        .putAll(indexByContributionType(contributionBindings()))
-        .putAll(indexByContributionType(multibindingDeclarations()))
-        .build();
+    return contributionBinding().contributionType();
   }
 
   /**
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index ac455d3a0..8fda68942 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -147,8 +147,8 @@ static ClassName generatedClassNameForBinding(Binding binding) {
       case PROVISION:
       case PRODUCTION:
         ContributionBinding contribution = (ContributionBinding) binding;
-        checkArgument(!contribution.isSyntheticBinding());
-        ClassName enclosingClassName = ClassName.get(contribution.bindingTypeElement());
+        checkArgument(contribution.bindingTypeElement().isPresent());
+        ClassName enclosingClassName = ClassName.get(contribution.bindingTypeElement().get());
         switch (contribution.bindingKind()) {
           case INJECTION:
           case PROVISION:
@@ -203,7 +203,7 @@ static TypeName parameterizedGeneratedTypeNameForBinding(
             // the module, not the types of the binding.
             // Consider: Module<A, B, C> { @Provides List<B> provideB(B b) { .. }}
             // The binding is just parameterized on <B>, but we need all of <A, B, C>.
-            return Optional.of(contributionBinding.bindingTypeElement().asType());
+            return Optional.of(contributionBinding.bindingTypeElement().get().asType());
 
           case IMMEDIATE:
           case FUTURE_PRODUCTION:
@@ -267,7 +267,7 @@ private static String factoryPrefix(ContributionBinding binding) {
       case IMMEDIATE:
       case FUTURE_PRODUCTION:
         return CaseFormat.LOWER_CAMEL.to(
-            UPPER_CAMEL, binding.bindingElement().getSimpleName().toString());
+            UPPER_CAMEL, binding.bindingElement().get().getSimpleName().toString());
 
       default:
         throw new IllegalArgumentException();
@@ -276,7 +276,8 @@ private static String factoryPrefix(ContributionBinding binding) {
 
   static ImmutableList<TypeVariableName> bindingTypeElementTypeVariableNames(Binding binding) {
     ImmutableList.Builder<TypeVariableName> builder = ImmutableList.builder();
-    for (TypeParameterElement typeParameter : binding.bindingTypeElement().getTypeParameters()) {
+    for (TypeParameterElement typeParameter :
+        binding.bindingTypeElement().get().getTypeParameters()) {
       builder.add(TypeVariableName.get(typeParameter));
     }
     return builder.build();
