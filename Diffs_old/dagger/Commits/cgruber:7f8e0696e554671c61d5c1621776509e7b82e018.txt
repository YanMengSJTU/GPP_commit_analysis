diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index 169e1f903..4c9a9af3f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -113,14 +113,15 @@ static String inconsistentMapKeyAnnotationsError(String key) {
   }
 
   static final String PROVIDES_METHOD_RETURN_TYPE =
-      "@Provides methods must either return a primitive, an array or a declared type.";
+      "@Provides methods must either return a primitive, an array, a type variable, or a declared"
+          + " type.";
 
   static final String PROVIDES_METHOD_THROWS =
       "@Provides methods may only throw unchecked exceptions";
 
   static final String PRODUCES_METHOD_RETURN_TYPE =
-      "@Produces methods must either return a primitive, an array or a declared type, or a"
-      + " ListenableFuture of one of those types.";
+      "@Produces methods must either return a primitive, an array, a type variable, or a declared"
+          + " type, or a ListenableFuture of one of those types.";
 
   static final String PRODUCES_METHOD_RAW_FUTURE =
       "@Produces methods cannot return a raw ListenableFuture.";
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
index c558ef545..61420df59 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
@@ -54,6 +54,7 @@
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.type.TypeKind.ARRAY;
 import static javax.lang.model.type.TypeKind.DECLARED;
+import static javax.lang.model.type.TypeKind.TYPEVAR;
 import static javax.lang.model.type.TypeKind.VOID;
 
 import javax.lang.model.util.Types;
@@ -202,7 +203,10 @@ private String formatModuleErrorMessage(String msg) {
   private void validateKeyType(ValidationReport.Builder<? extends Element> reportBuilder,
       TypeMirror type) {
     TypeKind kind = type.getKind();
-    if (!(kind.isPrimitive() || kind.equals(DECLARED) || kind.equals(ARRAY))) {
+    if (!(kind.isPrimitive()
+        || kind.equals(DECLARED)
+        || kind.equals(ARRAY)
+        || kind.equals(TYPEVAR))) {
       reportBuilder.addError(PROVIDES_METHOD_RETURN_TYPE, reportBuilder.getSubject());
     }
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index 6701a5d84..f13be1eb7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -321,9 +321,6 @@ static TypeName parameterizedGeneratedTypeNameForBinding(Binding binding) {
       case PROVISION:
       case PRODUCTION:
         ContributionBinding contributionBinding = (ContributionBinding) binding;
-        if (contributionBinding.contributionType().isMultibinding()) {
-          return Optional.absent();
-        }
         switch (contributionBinding.bindingKind()) {
           case INJECTION:
             return Optional.of(contributionBinding.key().type());
diff --git a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
index ebef1ff89..432156efc 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
@@ -930,24 +930,38 @@ public void publicModuleNonPublicIncludes() {
 
   @Test
   public void genericSubclassedModule() {
-    JavaFileObject parent = JavaFileObjects.forSourceLines("test.ParentModule",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import java.util.List;",
-        "import java.util.ArrayList;",
-        "",
-        "@Module",
-        "abstract class ParentModule<A extends CharSequence,",
-        "                            B,",
-        "                            C extends Number & Comparable<C>> {",
-        "  @Provides List<B> provideListB(B b) {",
-        "    List<B> list = new ArrayList<B>();",
-        "    list.add(b);",
-        "    return list;",
-        "  }",
-        "}");
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "test.ParentModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.mapkeys.StringKey;",
+            "import java.util.List;",
+            "import java.util.ArrayList;",
+            "",
+            "import static dagger.Provides.Type.MAP;",
+            "import static dagger.Provides.Type.SET;",
+            "",
+            "@Module",
+            "abstract class ParentModule<A extends CharSequence,",
+            "                            B,",
+            "                            C extends Number & Comparable<C>> {",
+            "  @Provides List<B> provideListB(B b) {",
+            "    List<B> list = new ArrayList<B>();",
+            "    list.add(b);",
+            "    return list;",
+            "  }",
+            "",
+            "  @Provides(type = SET) B provideBElement(B b) {",
+            "    return b;",
+            "  }",
+            "",
+            "  @Provides(type = MAP) @StringKey(\"b\") B provideBEntry(B b) {",
+            "    return b;",
+            "  }",
+            "}");
     JavaFileObject numberChild = JavaFileObjects.forSourceLines("test.ChildNumberModule",
         "package test;",
         "",
@@ -979,43 +993,116 @@ public void genericSubclassedModule() {
         "  List<Number> numberList();",
         "  List<Integer> integerList();",
         "}");
-    JavaFileObject listBFactory = JavaFileObjects.forSourceLines(
-        "test.ParentModule_ProvidesListBFactory",
-        "package test;",
-        "",
-        "import dagger.internal.Factory;",
-        "import java.util.List;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class ParentModule_ProvideListBFactory<A extends CharSequence,",
-        "    B, C extends Number & Comparable<C>> implements Factory<List<B>> {",
-        "  private final ParentModule<A, B, C> module;",
-        "  private final Provider<B> bProvider;",
-        "",
-        "  public ParentModule_ProvideListBFactory(",
-        "        ParentModule<A, B, C> module, Provider<B> bProvider) {",
-        "    assert module != null;",
-        "    this.module = module;",
-        "    assert bProvider != null;",
-        "    this.bProvider = bProvider;",
-        "  }",
-        "",
-        "  @Override",
-        "  public List<B> get() {  ",
-        "    List<B> provided = module.provideListB(bProvider.get());",
-        "    if (provided == null) {",
-        "      throw new NullPointerException(" + NPE_LITERAL + ");",
-        "    }",
-        "    return provided;",
-        "  }",
-        "",
-        "  public static <A extends CharSequence, B, C extends Number & Comparable<C>>",
-        "      Factory<List<B>> create(ParentModule<A, B, C> module, Provider<B> bProvider) {",
-        "    return new ParentModule_ProvideListBFactory<A, B, C>(module, bProvider);",
-        "  }",
-        "}");
+    JavaFileObject listBFactory =
+        JavaFileObjects.forSourceLines(
+            "test.ParentModule_ProvideListBFactory",
+            "package test;",
+            "",
+            "import dagger.internal.Factory;",
+            "import java.util.List;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class ParentModule_ProvideListBFactory<A extends CharSequence,",
+            "    B, C extends Number & Comparable<C>> implements Factory<List<B>> {",
+            "  private final ParentModule<A, B, C> module;",
+            "  private final Provider<B> bProvider;",
+            "",
+            "  public ParentModule_ProvideListBFactory(",
+            "        ParentModule<A, B, C> module, Provider<B> bProvider) {",
+            "    assert module != null;",
+            "    this.module = module;",
+            "    assert bProvider != null;",
+            "    this.bProvider = bProvider;",
+            "  }",
+            "",
+            "  @Override",
+            "  public List<B> get() {  ",
+            "    List<B> provided = module.provideListB(bProvider.get());",
+            "    if (provided == null) {",
+            "      throw new NullPointerException(" + NPE_LITERAL + ");",
+            "    }",
+            "    return provided;",
+            "  }",
+            "",
+            "  public static <A extends CharSequence, B, C extends Number & Comparable<C>>",
+            "      Factory<List<B>> create(ParentModule<A, B, C> module, Provider<B> bProvider) {",
+            "    return new ParentModule_ProvideListBFactory<A, B, C>(module, bProvider);",
+            "  }",
+            "}");
+    JavaFileObject bElementFactory =
+        JavaFileObjects.forSourceLines(
+            "test.ParentModule_ProvideBElementFactory",
+            "package test;",
+            "",
+            "import dagger.internal.Factory;",
+            "import java.util.Collections;",
+            "import java.util.Set;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class ParentModule_ProvideBElementFactory<A extends CharSequence,",
+            "    B, C extends Number & Comparable<C>> implements Factory<Set<B>> {",
+            "  private final ParentModule<A, B, C> module;",
+            "  private final Provider<B> bProvider;",
+            "",
+            "  public ParentModule_ProvideBElementFactory(",
+            "        ParentModule<A, B, C> module, Provider<B> bProvider) {",
+            "    assert module != null;",
+            "    this.module = module;",
+            "    assert bProvider != null;",
+            "    this.bProvider = bProvider;",
+            "  }",
+            "",
+            "  @Override",
+            "  public Set<B> get() {  ",
+            "    return Collections.<B>singleton(module.provideBElement(bProvider.get()));",
+            "  }",
+            "",
+            "  public static <A extends CharSequence, B, C extends Number & Comparable<C>>",
+            "      Factory<Set<B>> create(ParentModule<A, B, C> module, Provider<B> bProvider) {",
+            "    return new ParentModule_ProvideBElementFactory<A, B, C>(module, bProvider);",
+            "  }",
+            "}");
+    JavaFileObject bEntryFactory =
+        JavaFileObjects.forSourceLines(
+            "test.ParentModule_ProvideBEntryFactory",
+            "package test;",
+            "",
+            "import dagger.internal.Factory;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class ParentModule_ProvideBEntryFactory<A extends CharSequence,",
+            "    B, C extends Number & Comparable<C>> implements Factory<B>> {",
+            "  private final ParentModule<A, B, C> module;",
+            "  private final Provider<B> bProvider;",
+            "",
+            "  public ParentModule_ProvideBEntryFactory(",
+            "        ParentModule<A, B, C> module, Provider<B> bProvider) {",
+            "    assert module != null;",
+            "    this.module = module;",
+            "    assert bProvider != null;",
+            "    this.bProvider = bProvider;",
+            "  }",
+            "",
+            "  @Override",
+            "  public B get() {  ",
+            "    B provided = module.provideBEntry(bProvider.get());",
+            "    if (provided == null) {",
+            "      throw new NullPointerException(" + NPE_LITERAL + ");",
+            "    }",
+            "    return provided;",
+            "  }",
+            "",
+            "  public static <A extends CharSequence, B, C extends Number & Comparable<C>>",
+            "      Factory<B> create(ParentModule<A, B, C> module, Provider<B> bProvider) {",
+            "    return new ParentModule_ProvideBEntryFactory<A, B, C>(module, bProvider);",
+            "  }",
+            "}");
     JavaFileObject numberFactory = JavaFileObjects.forSourceLines(
         "test.ChildNumberModule_ProvideNumberFactory",
         "package test;",
@@ -1075,10 +1162,13 @@ public void genericSubclassedModule() {
         "    return new ChildIntegerModule_ProvideIntegerFactory(module);",
         "  }",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(parent, numberChild, integerChild, component))
+    assertAbout(javaSources())
+        .that(ImmutableList.of(parent, numberChild, integerChild, component))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and().generatesSources(listBFactory, numberFactory, integerFactory);
+        .and()
+        .generatesSources(
+            listBFactory, bElementFactory, bEntryFactory, numberFactory, integerFactory);
   }
 
   @Test public void providesMethodMultipleQualifiers() {
