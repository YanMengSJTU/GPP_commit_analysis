diff --git a/compiler/src/main/java/dagger/internal/codegen/AnnotationSpecs.java b/compiler/src/main/java/dagger/internal/codegen/AnnotationSpecs.java
index db7b9cf2f..d4772f3a5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AnnotationSpecs.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AnnotationSpecs.java
@@ -16,6 +16,8 @@
 package dagger.internal.codegen;
 
 import com.squareup.javapoet.AnnotationSpec;
+import com.squareup.javapoet.ClassName;
+import dagger.Provides;
 
 final class AnnotationSpecs {
 
@@ -26,5 +28,10 @@ private static AnnotationSpec suppressWarnings(String value) {
     return AnnotationSpec.builder(SuppressWarnings.class).addMember("value", "$S", value).build();
   }
 
+  static final AnnotationSpec PROVIDES_SET_VALUES =
+      AnnotationSpec.builder(Provides.class)
+          .addMember("type", "$T.SET_VALUES", ClassName.get(Provides.Type.class))
+          .build();
+
   private AnnotationSpecs() {}
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index 000abf14e..5d929868f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -27,6 +27,7 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
 import com.google.common.util.concurrent.ListenableFuture;
+import com.squareup.javapoet.ClassName;
 import dagger.Component;
 import dagger.Lazy;
 import dagger.MembersInjector;
@@ -582,8 +583,9 @@ private ComponentMethodDescriptor getDescriptorForComponentMethod(
      *     processor to retry in a later processing round.
      */
     private ModuleDescriptor descriptorForMonitoringModule(TypeElement componentDefinitionType) {
-      String generatedMonitorModuleName =
-          SourceFiles.generatedMonitoringModuleName(componentDefinitionType).canonicalName();
+      ClassName monitoringModuleName =
+          SourceFiles.generatedMonitoringModuleName(componentDefinitionType);
+      String generatedMonitorModuleName = monitoringModuleName.toString();
       TypeElement monitoringModule = elements.getTypeElement(generatedMonitorModuleName);
       if (monitoringModule == null) {
         throw new TypeNotPresentException(generatedMonitorModuleName, null);
diff --git a/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleGenerator.java
index f5f33af1b..20b45fd53 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleGenerator.java
@@ -17,35 +17,30 @@
 
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableSet;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.FieldSpec;
+import com.squareup.javapoet.TypeSpec;
 import dagger.Module;
 import dagger.Provides;
-import dagger.internal.codegen.writer.ClassName;
-import dagger.internal.codegen.writer.ClassWriter;
-import dagger.internal.codegen.writer.FieldWriter;
-import dagger.internal.codegen.writer.JavaWriter;
-import dagger.internal.codegen.writer.MethodWriter;
-import dagger.internal.codegen.writer.ParameterizedTypeName;
-import dagger.internal.codegen.writer.TypeName;
 import dagger.producers.monitoring.ProductionComponentMonitor;
 import dagger.producers.monitoring.internal.MonitorCache;
 
-import java.util.Set;
-import javax.annotation.Generated;
 import javax.annotation.processing.Filer;
-import javax.inject.Provider;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.util.Elements;
 
+import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static com.squareup.javapoet.TypeSpec.classBuilder;
+import static dagger.internal.codegen.AnnotationSpecs.PROVIDES_SET_VALUES;
+import static dagger.internal.codegen.TypeNames.SET_OF_FACTORIES;
+import static dagger.internal.codegen.TypeNames.providerOf;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.STATIC;
 import static javax.lang.model.element.Modifier.FINAL;
 
 /** Generates a monitoring module for use with production components. */
-final class MonitoringModuleGenerator extends JavaWriterSourceFileGenerator<TypeElement> {
-  private static final TypeName SET_OF_FACTORIES =
-      ParameterizedTypeName.create(
-          Set.class, ClassName.fromClass(ProductionComponentMonitor.Factory.class));
+final class MonitoringModuleGenerator extends JavaPoetSourceFileGenerator<TypeElement> {
 
   MonitoringModuleGenerator(Filer filer, Elements elements) {
     super(filer, elements);
@@ -56,44 +51,41 @@ ClassName nameGeneratedType(TypeElement componentElement) {
     return SourceFiles.generatedMonitoringModuleName(componentElement);
   }
 
-  @Override
-  Iterable<? extends Element> getOriginatingElements(TypeElement componentElement) {
-    return ImmutableSet.of(componentElement);
-  }
-
   @Override
   Optional<? extends Element> getElementForErrorReporting(TypeElement componentElement) {
     return Optional.of(componentElement);
   }
 
   @Override
-  ImmutableSet<JavaWriter> write(ClassName generatedTypeName, TypeElement componentElement) {
-    JavaWriter writer = JavaWriter.inPackage(generatedTypeName.packageName());
-    ClassWriter classWriter = writer.addClass(generatedTypeName.simpleName());
-    classWriter.annotate(Module.class);
-    classWriter.addModifiers(FINAL);
+  Optional<TypeSpec.Builder> write(ClassName generatedTypeName, TypeElement componentElement) {
+    return Optional.of(
+        classBuilder(generatedTypeName.simpleName())
+            .addAnnotation(Module.class)
+            .addModifiers(FINAL)
 
-    // TODO(beder): Replace this default set binding with EmptyCollections when it exists.
-    MethodWriter emptySetBindingMethod =
-        classWriter.addMethod(SET_OF_FACTORIES, "defaultSetOfFactories");
-    emptySetBindingMethod.addModifiers(STATIC);
-    emptySetBindingMethod.annotate(Provides.class).setMember("type", Provides.Type.SET_VALUES);
-    emptySetBindingMethod
-        .body()
-        .addSnippet("return %s.of();", ClassName.fromClass(ImmutableSet.class));
+            // TODO(beder): Replace this default set binding with EmptyCollections when it exists.
+            .addMethod(
+                methodBuilder("defaultSetOfFactories")
+                    .returns(SET_OF_FACTORIES)
+                    .addModifiers(STATIC)
+                    .addAnnotation(PROVIDES_SET_VALUES)
+                    .addStatement("return $T.of()", ClassName.get(ImmutableSet.class))
+                    .build())
 
-    FieldWriter providerField = classWriter.addField(MonitorCache.class, "monitorCache");
-    providerField.addModifiers(PRIVATE, FINAL);
-    providerField.setInitializer("new %s()", ClassName.fromClass(MonitorCache.class));
-    MethodWriter monitorMethod = classWriter.addMethod(ProductionComponentMonitor.class, "monitor");
-    monitorMethod.annotate(Provides.class);
-    monitorMethod.addParameter(
-        ParameterizedTypeName.create(Provider.class, ClassName.fromTypeElement(componentElement)),
-        "component");
-    monitorMethod.addParameter(
-        ParameterizedTypeName.create(Provider.class, SET_OF_FACTORIES), "factories");
-    monitorMethod.body().addSnippet("return monitorCache.monitor(component, factories);");
+            .addField(
+                FieldSpec.builder(MonitorCache.class, "monitorCache", PRIVATE, FINAL)
+                    .initializer("new $T()", MonitorCache.class)
+                    .build())
 
-    return ImmutableSet.of(writer);
+            .addMethod(
+                methodBuilder("monitor")
+                    .returns(ProductionComponentMonitor.class)
+                    .addAnnotation(Provides.class)
+                    .addParameter(
+                        providerOf(ClassName.get(componentElement.asType())),
+                        "component")
+                    .addParameter(providerOf(SET_OF_FACTORIES), "factories")
+                    .addStatement("return monitorCache.monitor(component, factories)")
+                    .build()));
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index b66b6b72b..f7b2f8ee9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -18,6 +18,7 @@
 import com.google.common.base.Functions;
 import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
+import com.google.common.base.Splitter;
 import com.google.common.collect.ComparisonChain;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
@@ -34,8 +35,11 @@
 import dagger.internal.codegen.writer.ParameterizedTypeName;
 import dagger.internal.codegen.writer.Snippet;
 import dagger.internal.codegen.writer.TypeName;
+import dagger.internal.codegen.writer.TypeNames;
+import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Iterator;
+import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
 import javax.lang.model.element.Element;
@@ -46,6 +50,7 @@
 
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
 import static com.google.common.base.Preconditions.checkArgument;
+import static dagger.internal.codegen.TypeNames.DOUBLE_CHECK_LAZY;
 
 /**
  * Utilities for generating files.
@@ -208,7 +213,7 @@ static CodeBlock frameworkTypeUsageStatement(
     switch (dependencyKind) {
       case LAZY:
         return CodeBlocks.format(
-            "$T.create($L)", TypeNames.DOUBLE_CHECK_LAZY, frameworkTypeMemberSelect);
+            "$T.create($L)", DOUBLE_CHECK_LAZY, frameworkTypeMemberSelect);
       case INSTANCE:
       case FUTURE:
         return CodeBlocks.format("$L.get()", frameworkTypeMemberSelect);
@@ -382,22 +387,24 @@ static ClassName membersInjectorNameForType(TypeElement typeElement) {
 
   static com.squareup.javapoet.ClassName javapoetMembersInjectorNameForType(
       TypeElement typeElement) {
-    com.squareup.javapoet.ClassName injectedClassName =
-        com.squareup.javapoet.ClassName.get(typeElement);
-    return injectedClassName
-        .topLevelClassName()
-        .peerClass(classFileName(injectedClassName) + "_MembersInjector");
+    return siblingClassName(typeElement,  "_MembersInjector");
   }
 
   static String classFileName(com.squareup.javapoet.ClassName className) {
     return CLASS_FILE_NAME_JOINER.join(className.simpleNames());
   }
 
-  static ClassName generatedMonitoringModuleName(TypeElement componentElement) {
-    ClassName componentName = ClassName.fromTypeElement(componentElement);
-    return componentName
-        .topLevelClassName()
-        .peerNamed(componentName.classFileName() + "_MonitoringModule");
+  static com.squareup.javapoet.ClassName generatedMonitoringModuleName(
+      TypeElement componentElement) {
+    return siblingClassName(componentElement, "_MonitoringModule");
+  }
+
+  // TODO(ronshapiro): when JavaPoet migration is complete, replace the duplicated code which could
+  // use this.
+  private static com.squareup.javapoet.ClassName siblingClassName(
+      TypeElement typeElement, String suffix) {
+    com.squareup.javapoet.ClassName className = com.squareup.javapoet.ClassName.get(typeElement);
+    return className.topLevelClassName().peerClass(classFileName(className) + suffix);
   }
 
   private static String factoryPrefix(ContributionBinding binding) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/TypeNames.java b/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
index c0135dccd..d51a78b09 100644
--- a/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
+++ b/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
@@ -21,16 +21,27 @@
 import dagger.MembersInjector;
 import dagger.internal.DoubleCheckLazy;
 import dagger.internal.Factory;
+import dagger.producers.monitoring.ProductionComponentMonitor;
+import java.util.Set;
+import javax.inject.Provider;
 
 /**
  * Common names and convenience methods for JavaPoet {@link TypeName} usage.
  */
 final class TypeNames {
 
+  static final TypeName SET_OF_FACTORIES =
+      ParameterizedTypeName.get(
+          ClassName.get(Set.class), ClassName.get(ProductionComponentMonitor.Factory.class));
+  static final ClassName PROVIDER = ClassName.get(Provider.class);
   static final ClassName DOUBLE_CHECK_LAZY = ClassName.get(DoubleCheckLazy.class);
   static final ClassName FACTORY = ClassName.get(Factory.class);
   static final ClassName MEMBERS_INJECTOR = ClassName.get(MembersInjector.class);
 
+  static ParameterizedTypeName providerOf(TypeName typeName) {
+    return ParameterizedTypeName.get(PROVIDER, typeName);
+  }
+
   static ParameterizedTypeName membersInjectorOf(TypeName membersInjectorType) {
     return ParameterizedTypeName.get(MEMBERS_INJECTOR, membersInjectorType);
   }
