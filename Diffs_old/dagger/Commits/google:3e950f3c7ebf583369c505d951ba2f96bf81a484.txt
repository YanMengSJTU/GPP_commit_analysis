diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingField.java b/compiler/src/main/java/dagger/internal/codegen/BindingField.java
new file mode 100644
index 000000000..87fa69d74
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingField.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.value.AutoValue;
+import dagger.MembersInjector;
+import dagger.internal.codegen.writer.ClassName;
+import dagger.internal.codegen.writer.ParameterizedTypeName;
+import dagger.internal.codegen.writer.TypeNames;
+import dagger.producers.Producer;
+import javax.inject.Provider;
+
+/**
+ * A value object that represents a field for a binding in a generated source file.
+ *
+ *  @author Jesse Beder
+ *  @since 2.0
+ */
+@AutoValue
+abstract class BindingField {
+  static BindingField create(
+      Class<?> frameworkClass, BindingKey bindingKey, String name) {
+    String suffix = frameworkClass.getSimpleName();
+    return new AutoValue_BindingField(frameworkClass, bindingKey,
+        name.endsWith(suffix) ? name : name + suffix);
+  }
+
+  ParameterizedTypeName frameworkType() {
+    return ParameterizedTypeName.create(
+        ClassName.fromClass(frameworkClass()),
+        TypeNames.forTypeMirror(bindingKey().key().type()));
+  }
+
+  abstract Class<?> frameworkClass();
+  abstract BindingKey bindingKey();
+  abstract String name();
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index b5194a9ff..07ccb5160 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -44,6 +44,7 @@
 import javax.lang.model.util.Types;
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.ComponentDescriptor.isComponentProvisionMethod;
@@ -63,7 +64,7 @@
   abstract ComponentDescriptor componentDescriptor();
   abstract ImmutableSet<DependencyRequest> entryPoints();
   abstract ImmutableMap<TypeElement, ImmutableSet<TypeElement>> transitiveModules();
-  abstract ImmutableMap<FrameworkKey, ResolvedBindings> resolvedBindings();
+  abstract ImmutableMap<BindingKey, ResolvedBindings> resolvedBindings();
 
   @AutoValue
   abstract static class ResolvedBindings {
@@ -77,44 +78,36 @@
       MISSING,
     }
 
-    abstract FrameworkKey.Kind kind();
+    abstract BindingKey bindingKey();
     abstract State state();
-    abstract ImmutableSet<ProvisionBinding> internalProvisionBindings();
-    abstract ImmutableSet<MembersInjectionBinding> internalMembersInjectionBindings();
+    abstract ImmutableSet<? extends Binding> bindings();
 
-    static ResolvedBindings createForProvisionBindings(
-        State state, ImmutableSet<ProvisionBinding> provisionBindings) {
-      return new AutoValue_BindingGraph_ResolvedBindings(
-          FrameworkKey.Kind.PROVIDER, state, provisionBindings,
-          ImmutableSet.<MembersInjectionBinding>of());
+    static ResolvedBindings createForContributionBindings(
+        BindingKey bindingKey,
+        State state,
+        ImmutableSet<? extends ContributionBinding> bindings) {
+      checkArgument(bindingKey.kind().equals(BindingKey.Kind.CONTRIBUTION));
+      return new AutoValue_BindingGraph_ResolvedBindings(bindingKey, state, bindings);
     }
 
     static ResolvedBindings createForMembersInjectionBindings(
-        State state, ImmutableSet<MembersInjectionBinding> membersInjectionBindings) {
-      return new AutoValue_BindingGraph_ResolvedBindings(
-          FrameworkKey.Kind.MEMBERS_INJECTOR, state, ImmutableSet.<ProvisionBinding>of(),
-          membersInjectionBindings);
+        BindingKey bindingKey,
+        State state,
+        ImmutableSet<? extends MembersInjectionBinding> bindings) {
+      checkArgument(bindingKey.kind().equals(BindingKey.Kind.MEMBERS_INJECTION));
+      return new AutoValue_BindingGraph_ResolvedBindings(bindingKey, state, bindings);
     }
 
-    ImmutableSet<? extends Binding> bindings() {
-      switch (kind()) {
-        case PROVIDER:
-          return internalProvisionBindings();
-        case MEMBERS_INJECTOR:
-          return internalMembersInjectionBindings();
-        default:
-          throw new AssertionError();
-      }
-    }
-
-    ImmutableSet<ProvisionBinding> provisionBindings() {
-      checkState(kind() == FrameworkKey.Kind.PROVIDER);
-      return internalProvisionBindings();
+    @SuppressWarnings("unchecked")  // checked by constructor
+    ImmutableSet<? extends ContributionBinding> contributionBindings() {
+      checkState(bindingKey().kind().equals(BindingKey.Kind.CONTRIBUTION));
+      return (ImmutableSet<? extends ContributionBinding>) bindings();
     }
 
-    ImmutableSet<MembersInjectionBinding> membersInjectionBindings() {
-      checkState(kind() == FrameworkKey.Kind.MEMBERS_INJECTOR);
-      return internalMembersInjectionBindings();
+    @SuppressWarnings("unchecked")  // checked by constructor
+    ImmutableSet<? extends MembersInjectionBinding> membersInjectionBindings() {
+      checkState(bindingKey().kind().equals(BindingKey.Kind.MEMBERS_INJECTION));
+      return (ImmutableSet<? extends MembersInjectionBinding>) bindings();
     }
   }
 
@@ -123,22 +116,19 @@ static ResolvedBindings createForMembersInjectionBindings(
     private final Types types;
     private final InjectBindingRegistry injectBindingRegistry;
     private final Key.Factory keyFactory;
-    private final DependencyRequestMapper dependencyRequestMapper;
     private final DependencyRequest.Factory dependencyRequestFactory;
     private final ProvisionBinding.Factory provisionBindingFactory;
 
     Factory(Elements elements,
         Types types,
         InjectBindingRegistry injectBindingRegistry,
-        dagger.internal.codegen.Key.Factory keyFactory,
-        dagger.internal.codegen.DependencyRequestMapper dependencyRequestMapper,
-        dagger.internal.codegen.DependencyRequest.Factory dependencyRequestFactory,
-        dagger.internal.codegen.ProvisionBinding.Factory provisionBindingFactory) {
+        Key.Factory keyFactory,
+        DependencyRequest.Factory dependencyRequestFactory,
+        ProvisionBinding.Factory provisionBindingFactory) {
       this.elements = elements;
       this.types = types;
       this.injectBindingRegistry = injectBindingRegistry;
       this.keyFactory = keyFactory;
-      this.dependencyRequestMapper = dependencyRequestMapper;
       this.dependencyRequestFactory = dependencyRequestFactory;
       this.provisionBindingFactory = provisionBindingFactory;
     }
@@ -241,8 +231,8 @@ private boolean isComponentMembersInjectionMethod(ExecutableElement method) {
 
     private final class RequestResolver {
       final ImmutableSetMultimap<Key, ProvisionBinding> explicitBindings;
-      final Map<FrameworkKey, ResolvedBindings> resolvedBindings;
-      final Deque<FrameworkKey> cycleStack = Queues.newArrayDeque();
+      final Map<BindingKey, ResolvedBindings> resolvedBindings;
+      final Deque<BindingKey> cycleStack = Queues.newArrayDeque();
 
       RequestResolver(ImmutableSetMultimap<Key, ProvisionBinding> explicitBindings) {
         assert explicitBindings != null;
@@ -252,20 +242,20 @@ private boolean isComponentMembersInjectionMethod(ExecutableElement method) {
 
       State resolve(DependencyRequest request) {
         Key requestKey = request.key();
-        FrameworkKey frameworkKey = dependencyRequestMapper.getFrameworkKey(request);
+        BindingKey bindingKey = BindingKey.forDependencyRequest(request);
 
-        ResolvedBindings previouslyResolvedBinding = resolvedBindings.get(frameworkKey);
+        ResolvedBindings previouslyResolvedBinding = resolvedBindings.get(bindingKey);
         if (previouslyResolvedBinding != null) {
           return previouslyResolvedBinding.state();
         }
 
-        if (cycleStack.contains(frameworkKey)) {
+        if (cycleStack.contains(bindingKey)) {
           // return malformed, but don't add a resolved binding.
           // the original request will add it with all of the other resolved deps
           return State.CYCLE;
         }
 
-        cycleStack.push(frameworkKey);
+        cycleStack.push(bindingKey);
         try {
           switch (request.kind()) {
             case INSTANCE:
@@ -284,8 +274,9 @@ State resolve(DependencyRequest request) {
                   ProvisionBinding implicitBinding =
                       provisionBindingFactory.forImplicitMapBinding(request, implicitRequest);
                   State implicitState = resolve(implicitRequest);
-                  resolvedBindings.put(frameworkKey,
-                      ResolvedBindings.createForProvisionBindings(
+                  resolvedBindings.put(bindingKey,
+                      ResolvedBindings.createForContributionBindings(
+                          bindingKey,
                           implicitState.equals(State.COMPLETE) ? State.COMPLETE : State.INCOMPLETE,
                           ImmutableSet.of(implicitBinding)));
                   return State.COMPLETE;
@@ -297,16 +288,17 @@ State resolve(DependencyRequest request) {
                     // found a binding, resolve its deps and then mark it resolved
                     State bindingState =
                         resolveDependencies(provisionBinding.get().implicitDependencies());
-                    resolvedBindings.put(frameworkKey,
-                        ResolvedBindings.createForProvisionBindings(
+                    resolvedBindings.put(bindingKey,
+                        ResolvedBindings.createForContributionBindings(
+                            bindingKey,
                             bindingState,
                             ImmutableSet.copyOf(provisionBinding.asSet())));
                     return bindingState;
                   } else {
                     // no explicit binding, no inject binding.  it's missing
-                    resolvedBindings.put(frameworkKey,
-                        ResolvedBindings.createForProvisionBindings(
-                            State.MISSING, ImmutableSet.<ProvisionBinding>of()));
+                    resolvedBindings.put(bindingKey,
+                        ResolvedBindings.createForContributionBindings(
+                            bindingKey, State.MISSING, ImmutableSet.<ProvisionBinding>of()));
                     return State.MISSING;
                   }
                 }
@@ -337,22 +329,26 @@ State resolve(DependencyRequest request) {
                   ImmutableListMultimap<BindingType, ProvisionBinding> bindingsByType =
                       ProvisionBinding.bindingTypesFor(explicitBindingsForKey);
                   if (bindingsByType.keySet().size() > 1) {
-                    resolvedBindings.put(frameworkKey,
-                        ResolvedBindings.createForProvisionBindings(
+                    resolvedBindings.put(bindingKey,
+                        ResolvedBindings.createForContributionBindings(
+                            bindingKey,
                             State.MULTIPLE_BINDING_TYPES,
                             explicitBindingsForKey));
                     return State.MULTIPLE_BINDING_TYPES;
                   } else if (getOnlyElement(bindingsByType.keySet()).equals(BindingType.UNIQUE)) {
-                    resolvedBindings.put(frameworkKey,
-                        ResolvedBindings.createForProvisionBindings(
+                    resolvedBindings.put(bindingKey,
+                        ResolvedBindings.createForContributionBindings(
+                            bindingKey,
                             State.DUPLICATE_BINDINGS,
                             explicitBindingsForKey));
                     return State.DUPLICATE_BINDINGS;
                   }
                 }
-                resolvedBindings.put(frameworkKey,
-                    ResolvedBindings.createForProvisionBindings(
-                        bindingState, explicitBindingsForKey));
+                resolvedBindings.put(bindingKey,
+                    ResolvedBindings.createForContributionBindings(
+                        bindingKey,
+                        bindingState,
+                        explicitBindingsForKey));
                 return bindingState;
               }
             case MEMBERS_INJECTOR:
@@ -361,10 +357,8 @@ State resolve(DependencyRequest request) {
                   injectBindingRegistry.getOrFindMembersInjectionBinding(requestKey);
               State bindingState =
                   resolveDependencies(membersInjectionBinding.implicitDependencies());
-              resolvedBindings.put(frameworkKey,
-                  ResolvedBindings.createForMembersInjectionBindings(
-                      bindingState,
-                      ImmutableSet.of(membersInjectionBinding)));
+              resolvedBindings.put(bindingKey, ResolvedBindings.createForMembersInjectionBindings(
+                  bindingKey, bindingState, ImmutableSet.of(membersInjectionBinding)));
               return bindingState;
             default:
               throw new AssertionError();
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 628855278..859649f11 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -53,31 +53,28 @@
   private final Types types;
   private final InjectBindingRegistry injectBindingRegistry;
   private final ScopeCycleValidation disableInterComponentScopeCycles;
-  private final DependencyRequestMapper dependencyRequestMapper;
 
   BindingGraphValidator(
       Types types,
       InjectBindingRegistry injectBindingRegistry,
-      ScopeCycleValidation disableInterComponentScopeCycles,
-      DependencyRequestMapper dependencyRequestMapper) {
+      ScopeCycleValidation disableInterComponentScopeCycles) {
     this.types = types;
     this.injectBindingRegistry = injectBindingRegistry;
     this.disableInterComponentScopeCycles = disableInterComponentScopeCycles;
-    this.dependencyRequestMapper = dependencyRequestMapper;
   }
 
   @Override
   public ValidationReport<BindingGraph> validate(final BindingGraph subject) {
     final ValidationReport.Builder<BindingGraph> reportBuilder =
         ValidationReport.Builder.about(subject);
-    ImmutableMap<FrameworkKey, ResolvedBindings> resolvedBindings = subject.resolvedBindings();
+    ImmutableMap<BindingKey, ResolvedBindings> resolvedBindings = subject.resolvedBindings();
 
     validateComponentScope(subject, reportBuilder, resolvedBindings);
     validateDependencyScopes(subject, reportBuilder);
 
     for (DependencyRequest entryPoint : subject.entryPoints()) {
       ResolvedBindings resolvedBinding = resolvedBindings.get(
-          dependencyRequestMapper.getFrameworkKey(entryPoint));
+          BindingKey.forDependencyRequest(entryPoint));
       if (!resolvedBinding.state().equals(State.COMPLETE)) {
         LinkedList<DependencyRequest> requestPath = Lists.newLinkedList();
         requestPath.push(entryPoint);
@@ -256,33 +253,36 @@ private void validateScopeHierarchy(TypeElement rootComponent,
    */
   void validateComponentScope(final BindingGraph subject,
       final ValidationReport.Builder<BindingGraph> reportBuilder,
-      ImmutableMap<FrameworkKey, ResolvedBindings> resolvedBindings) {
+      ImmutableMap<BindingKey, ResolvedBindings> resolvedBindings) {
     Optional<Equivalence.Wrapper<AnnotationMirror>> componentScope =
         subject.componentDescriptor().wrappedScope();
     ImmutableSet.Builder<String> incompatiblyScopedMethodsBuilder = ImmutableSet.builder();
     for (ResolvedBindings bindings : resolvedBindings.values()) {
-      if (bindings.kind().equals(FrameworkKey.Kind.PROVIDER)) {
-        for (ProvisionBinding provisionBinding : bindings.provisionBindings()) {
-          if (provisionBinding.scope().isPresent()
-              && !componentScope.equals(provisionBinding.wrappedScope())) {
-            // Scoped components cannot reference bindings to @Provides methods or @Inject
-            // types decorated by a different scope annotation. Unscoped components cannot
-            // reference to scoped @Provides methods or @Inject types decorated by any
-            // scope annotation.
-            switch (provisionBinding.bindingKind()) {
-              case PROVISION:
-                ExecutableElement provisionMethod =
-                    MoreElements.asExecutable(provisionBinding.bindingElement());
-                incompatiblyScopedMethodsBuilder.add(
-                    MethodSignatureFormatter.instance().format(provisionMethod));
-                break;
-              case INJECTION:
-                incompatiblyScopedMethodsBuilder.add(
-                    stripCommonTypePrefixes(provisionBinding.scope().get().toString()) + " class "
-                        + provisionBinding.bindingTypeElement().getQualifiedName());
-                break;
-              default:
-                throw new IllegalStateException();
+      if (bindings.bindingKey().kind().equals(BindingKey.Kind.CONTRIBUTION)) {
+        for (ContributionBinding contributionBinding : bindings.contributionBindings()) {
+          if (contributionBinding instanceof ProvisionBinding) {
+            ProvisionBinding provisionBinding = (ProvisionBinding) contributionBinding;
+            if (provisionBinding.scope().isPresent()
+                && !componentScope.equals(provisionBinding.wrappedScope())) {
+              // Scoped components cannot reference bindings to @Provides methods or @Inject
+              // types decorated by a different scope annotation. Unscoped components cannot
+              // reference to scoped @Provides methods or @Inject types decorated by any
+              // scope annotation.
+              switch (provisionBinding.bindingKind()) {
+                case PROVISION:
+                  ExecutableElement provisionMethod =
+                      MoreElements.asExecutable(provisionBinding.bindingElement());
+                  incompatiblyScopedMethodsBuilder.add(
+                      MethodSignatureFormatter.instance().format(provisionMethod));
+                  break;
+                case INJECTION:
+                  incompatiblyScopedMethodsBuilder.add(stripCommonTypePrefixes(
+                      provisionBinding.scope().get().toString()) + " class "
+                          + provisionBinding.bindingTypeElement().getQualifiedName());
+                  break;
+                default:
+                  throw new IllegalStateException();
+              }
             }
           }
         }
@@ -444,7 +444,7 @@ boolean visitResolvedBinding(Deque<DependencyRequest> requestPath, ResolvedBindi
   private void traversalHelper(BindingGraph graph, Deque<DependencyRequest> requestPath,
       Traverser traverser) {
     ResolvedBindings resolvedBinding = graph.resolvedBindings().get(
-        dependencyRequestMapper.getFrameworkKey(requestPath.peek()));
+        BindingKey.forDependencyRequest(requestPath.peek()));
     ImmutableSet<DependencyRequest> allDeps =
         FluentIterable.from(resolvedBinding.bindings())
             .transformAndConcat(
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingKey.java b/compiler/src/main/java/dagger/internal/codegen/BindingKey.java
new file mode 100644
index 000000000..ed599e267
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingKey.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.value.AutoValue;
+
+/**
+ * A value object that pairs a {@link Key} with the style of its binding (i.e., whether it's a
+ * members injector or normal contribution).
+ *
+ *  @author Gregory Kick
+ *  @since 2.0
+ */
+@AutoValue
+abstract class BindingKey {
+  /** The style of binding that makes a {@link Key} available. */
+  enum Kind {
+    CONTRIBUTION, MEMBERS_INJECTION;
+  }
+
+  static BindingKey forDependencyRequest(DependencyRequest request) {
+    switch (request.kind()) {
+      case INSTANCE:
+      case LAZY:
+      case PROVIDER:
+      case PRODUCER:
+      case PRODUCED:
+        return BindingKey.create(Kind.CONTRIBUTION, request.key());
+      case MEMBERS_INJECTOR:
+        return BindingKey.create(Kind.MEMBERS_INJECTION, request.key());
+      default:
+        throw new AssertionError();
+    }
+  }
+
+  static BindingKey create(Kind kind, Key key) {
+    return new AutoValue_BindingKey(kind, key);
+  }
+
+  abstract Kind kind();
+  abstract Key key();
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index c7fede923..24f3e15af 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -34,6 +34,7 @@
 import dagger.Component;
 import dagger.Factory;
 import dagger.MapKey;
+import dagger.MembersInjector;
 import dagger.internal.InstanceFactory;
 import dagger.internal.MapFactory;
 import dagger.internal.MapProviderFactory;
@@ -105,11 +106,8 @@
  * @since 2.0
  */
 final class ComponentGenerator extends SourceFileGenerator<BindingGraph> {
-  private final DependencyRequestMapper dependencyRequestMapper;
-
-  ComponentGenerator(Filer filer, DependencyRequestMapper dependencyRequestMapper) {
+  ComponentGenerator(Filer filer) {
     super(filer);
-    this.dependencyRequestMapper = dependencyRequestMapper;
   }
 
   @Override
@@ -161,8 +159,8 @@ static ProxyClassAndField create(ClassWriter proxyWriter, FieldWriter proxyField
     builderFactoryMethod.addModifiers(PUBLIC, STATIC);
     builderFactoryMethod.body().addSnippet("return new %s();", builderWriter.name());
 
-    ImmutableMap<FrameworkKey, String> frameworkTypeNames =
-        generateFrameworkTypeNames(input);
+    ImmutableMap<BindingKey, BindingField> bindingFields =
+        generateBindingFields(input);
 
     // the full set of types that calling code uses to construct a component instance
     ImmutableMap<TypeElement, String> componentContributionNames =
@@ -227,27 +225,30 @@ static ProxyClassAndField create(ClassWriter proxyWriter, FieldWriter proxyField
       }
     }
 
-    ImmutableMap.Builder<FrameworkKey, Snippet> memberSelectSnippetsBuilder =
+    ImmutableMap.Builder<BindingKey, Snippet> memberSelectSnippetsBuilder =
         ImmutableMap.builder();
 
     ImmutableSet.Builder<JavaWriter> proxyWriters = ImmutableSet.builder();
     Map<String, ProxyClassAndField> packageProxies = Maps.newHashMap();
 
-    for (Entry<FrameworkKey, ResolvedBindings> resolvedBindingsEntry :
+    for (Entry<BindingKey, ResolvedBindings> resolvedBindingsEntry :
         input.resolvedBindings().entrySet()) {
-      FrameworkKey frameworkKey = resolvedBindingsEntry.getKey();
+      BindingKey bindingKey = resolvedBindingsEntry.getKey();
       ResolvedBindings resolvedBindings = resolvedBindingsEntry.getValue();
 
       if (resolvedBindings.bindings().size() == 1
-          && frameworkKey.kind().equals(FrameworkKey.Kind.PROVIDER)) {
-        ProvisionBinding provisionBinding =
-            Iterables.getOnlyElement(resolvedBindings.provisionBindings());
-        if (provisionBinding.factoryCreationStrategy().equals(ENUM_INSTANCE)
-            && !provisionBinding.scope().isPresent()) {
-          // skip keys whose factories are enum instances and aren't scoped
-          memberSelectSnippetsBuilder.put(frameworkKey, Snippet.format("%s.INSTANCE",
-              factoryNameForProvisionBinding(provisionBinding)));
-          continue;
+          && bindingKey.kind().equals(BindingKey.Kind.CONTRIBUTION)) {
+        ContributionBinding contributionBinding =
+            Iterables.getOnlyElement(resolvedBindings.contributionBindings());
+        if (contributionBinding instanceof ProvisionBinding) {
+          ProvisionBinding provisionBinding = (ProvisionBinding) contributionBinding;
+          if (provisionBinding.factoryCreationStrategy().equals(ENUM_INSTANCE)
+              && !provisionBinding.scope().isPresent()) {
+            // skip keys whose factories are enum instances and aren't scoped
+            memberSelectSnippetsBuilder.put(bindingKey, Snippet.format("%s.INSTANCE",
+                    factoryNameForProvisionBinding(provisionBinding)));
+            continue;
+          }
         }
       }
 
@@ -309,17 +310,17 @@ static ProxyClassAndField create(ClassWriter proxyWriter, FieldWriter proxyField
         fieldModifiers = EnumSet.of(PUBLIC);
       }
 
-      String fieldName = frameworkTypeNames.get(frameworkKey);
-      TypeName frameworkTypeName = frameworkKey.frameworkType();
+      BindingField bindingField = bindingFields.get(bindingKey);
+      TypeName frameworkTypeName = bindingField.frameworkType();
 
-      FieldWriter frameworkField = classWithFields.addField(frameworkTypeName, fieldName);
+      FieldWriter frameworkField = classWithFields.addField(frameworkTypeName, bindingField.name());
       frameworkField.addModifiers(fieldModifiers);
 
       ImmutableList<String> memberSelectTokens = new ImmutableList.Builder<String>()
           .addAll(proxySelector.asSet())
           .add(frameworkField.name())
           .build();
-      memberSelectSnippetsBuilder.put(frameworkKey,
+      memberSelectSnippetsBuilder.put(bindingKey,
           Snippet.memberSelectSnippet(memberSelectTokens));
     }
 
@@ -332,9 +333,9 @@ static ProxyClassAndField create(ClassWriter proxyWriter, FieldWriter proxyField
       factoryMethod.body().addSnippet("return builder().build();");
     }
 
-    ImmutableMap<FrameworkKey, Snippet> memberSelectSnippets = memberSelectSnippetsBuilder.build();
+    ImmutableMap<BindingKey, Snippet> memberSelectSnippets = memberSelectSnippetsBuilder.build();
 
-    List<List<FrameworkKey>> partitions = Lists.partition(
+    List<List<BindingKey>> partitions = Lists.partition(
         input.resolvedBindings().keySet().asList(), 100);
     for (int i = 0; i < partitions.size(); i++) {
       MethodWriter initializeMethod =
@@ -343,12 +344,16 @@ static ProxyClassAndField create(ClassWriter proxyWriter, FieldWriter proxyField
       initializeMethod.addModifiers(PRIVATE);
       constructorWriter.body().addSnippet("%s();", initializeMethod.name());
 
-      for (FrameworkKey frameworkKey : partitions.get(i)) {
-        Snippet memberSelectSnippet = memberSelectSnippets.get(frameworkKey);
-        switch (frameworkKey.kind()) {
-          case PROVIDER:
-            Set<ProvisionBinding> bindings =
-                input.resolvedBindings().get(frameworkKey).provisionBindings();
+      for (BindingKey bindingKey : partitions.get(i)) {
+        Snippet memberSelectSnippet = memberSelectSnippets.get(bindingKey);
+        switch (bindingKey.kind()) {
+          case CONTRIBUTION:
+            @SuppressWarnings("unchecked")  // checked during validation
+            ImmutableSet<ProvisionBinding> bindings =
+                (ImmutableSet<ProvisionBinding>) input.resolvedBindings()
+                .get(bindingKey)
+                .contributionBindings();
+
             BindingType bindingsType = ProvisionBinding.bindingTypeFor(bindings);
             switch (bindingsType) {
               case SET:
@@ -390,13 +395,12 @@ static ProxyClassAndField create(ClassWriter proxyWriter, FieldWriter proxyField
                 throw new IllegalStateException();
             }
             break;
-          case MEMBERS_INJECTOR:
+          case MEMBERS_INJECTION:
             MembersInjectionBinding binding = Iterables.getOnlyElement(
-                input.resolvedBindings().get(frameworkKey).membersInjectionBindings());
+                input.resolvedBindings().get(bindingKey).membersInjectionBindings());
             initializeMethod.body().addSnippet("this.%s = %s;",
                 memberSelectSnippet,
-                initializeMembersInjectorForBinding(
-                    dependencyRequestMapper, binding, memberSelectSnippets));
+                initializeMembersInjectorForBinding(binding, memberSelectSnippets));
             break;
           default:
             throw new AssertionError();
@@ -418,9 +422,9 @@ static ProxyClassAndField create(ClassWriter proxyWriter, FieldWriter proxyField
                     requestElement.getSimpleName().toString());
             interfaceMethod.annotate(Override.class);
             interfaceMethod.addModifiers(PUBLIC);
-            FrameworkKey frameworkKey = dependencyRequestMapper.getFrameworkKey(interfaceRequest);
+            BindingKey bindingKey = BindingKey.forDependencyRequest(interfaceRequest);
             if (interfaceRequest.kind().equals(MEMBERS_INJECTOR)) {
-              Snippet membersInjectorName = memberSelectSnippets.get(frameworkKey);
+              Snippet membersInjectorName = memberSelectSnippets.get(bindingKey);
               VariableElement parameter = Iterables.getOnlyElement(requestElement.getParameters());
               Name parameterName = parameter.getSimpleName();
               interfaceMethod.addParameter(
@@ -432,7 +436,7 @@ static ProxyClassAndField create(ClassWriter proxyWriter, FieldWriter proxyField
               }
             } else {
               interfaceMethod.body().addSnippet("return %s;",
-                  frameworkTypeUsageStatement(memberSelectSnippets.get(frameworkKey),
+                  frameworkTypeUsageStatement(memberSelectSnippets.get(bindingKey),
                       interfaceRequest.kind()));
             }
       }
@@ -444,27 +448,34 @@ static ProxyClassAndField create(ClassWriter proxyWriter, FieldWriter proxyField
         .build();
   }
 
-  private ImmutableMap<FrameworkKey, String> generateFrameworkTypeNames(BindingGraph graph) {
-    ImmutableMap.Builder<FrameworkKey, String> names = ImmutableMap.builder();
-    for (Entry<FrameworkKey, ResolvedBindings> entry : graph.resolvedBindings().entrySet()) {
-      FrameworkKey frameworkKey = entry.getKey();
-      switch (frameworkKey.kind()) {
-        case PROVIDER:
+  private ImmutableMap<BindingKey, BindingField> generateBindingFields(BindingGraph graph) {
+    ImmutableMap.Builder<BindingKey, BindingField> fields = ImmutableMap.builder();
+    for (Entry<BindingKey, ResolvedBindings> entry : graph.resolvedBindings().entrySet()) {
+      BindingKey bindingKey = entry.getKey();
+      switch (bindingKey.kind()) {
+        case CONTRIBUTION:
+          @SuppressWarnings("unchecked")  // checked during validation
           ImmutableSet<ProvisionBinding> bindingsForKey =
-              entry.getValue().provisionBindings();
+              (ImmutableSet<ProvisionBinding>) entry.getValue().contributionBindings();
           BindingType bindingsType = ProvisionBinding.bindingTypeFor(bindingsForKey);
           switch (bindingsType) {
             case SET:
-              names.put(frameworkKey,
-                  new KeyVariableNamer().apply(frameworkKey.key()) + "Provider");
+              fields.put(bindingKey, BindingField.create(
+                  Provider.class,
+                  bindingKey,
+                  new KeyVariableNamer().apply(bindingKey.key())));
               break;
             case MAP:
-              names.put(frameworkKey,
-                  new KeyVariableNamer().apply(frameworkKey.key()) + "Provider");
+              fields.put(bindingKey, BindingField.create(
+                  Provider.class,
+                  bindingKey,
+                  new KeyVariableNamer().apply(bindingKey.key())));
               break;
             case UNIQUE:
               ProvisionBinding binding = Iterables.getOnlyElement(bindingsForKey);
-              names.put(frameworkKey,
+              fields.put(bindingKey, BindingField.create(
+                  Provider.class,
+                  bindingKey,
                   binding.bindingElement().accept(new ElementKindVisitor6<String, Void>() {
                     @Override
                     public String visitExecutableAsConstructor(ExecutableElement e, Void p) {
@@ -481,28 +492,31 @@ public String visitType(TypeElement e, Void p) {
                       return CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL,
                           e.getSimpleName().toString());
                     }
-                  }, null) + "Provider");
+                  }, null)));
               break;
             default:
               throw new AssertionError();
           }
           break;
-        case MEMBERS_INJECTOR:
-          names.put(frameworkKey, CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL,
-              Iterables.getOnlyElement(entry.getValue().bindings())
-                  .bindingElement().getSimpleName().toString()) + "MembersInjector");
+        case MEMBERS_INJECTION:
+          fields.put(bindingKey, BindingField.create(
+              MembersInjector.class,
+              bindingKey,
+              CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL,
+                  Iterables.getOnlyElement(entry.getValue().bindings())
+                  .bindingElement().getSimpleName().toString())));
           break;
         default:
           throw new AssertionError();
       }
     }
-    return names.build();
+    return fields.build();
   }
 
   private Snippet initializeFactoryForBinding(ProvisionBinding binding,
       ImmutableMap<ExecutableElement, TypeElement> dependencyMethodIndex,
       Map<TypeElement, FieldWriter> contributionFields,
-      ImmutableMap<FrameworkKey, Snippet> memberSelectSnippets) {
+      ImmutableMap<BindingKey, Snippet> memberSelectSnippets) {
     if (binding.bindingKind().equals(COMPONENT)) {
       return Snippet.format("%s.<%s>create(this)",
           ClassName.fromClass(InstanceFactory.class),
@@ -532,11 +546,10 @@ private Snippet initializeFactoryForBinding(ProvisionBinding binding,
         parameters.add(Snippet.format(contributionFields.get(binding.bindingTypeElement()).name()));
       }
       if (binding.memberInjectionRequest().isPresent()) {
-        parameters.add(memberSelectSnippets.get(dependencyRequestMapper.getFrameworkKey(
+        parameters.add(memberSelectSnippets.get(BindingKey.forDependencyRequest(
             binding.memberInjectionRequest().get())));
       }
-      parameters.addAll(getDependencyParameters(
-          dependencyRequestMapper, binding.dependencies(), memberSelectSnippets));
+      parameters.addAll(getDependencyParameters(binding.dependencies(), memberSelectSnippets));
 
       return binding.scope().isPresent()
           ? Snippet.format("%s.create(new %s(%s))",
@@ -550,23 +563,20 @@ private Snippet initializeFactoryForBinding(ProvisionBinding binding,
   }
 
   private static Snippet initializeMembersInjectorForBinding(
-      DependencyRequestMapper dependencyRequestMapper,
       MembersInjectionBinding binding,
-      ImmutableMap<FrameworkKey, Snippet> memberSelectSnippets) {
+      ImmutableMap<BindingKey, Snippet> memberSelectSnippets) {
     if (binding.injectionSites().isEmpty()) {
       if (binding.parentInjectorRequest().isPresent()) {
         DependencyRequest parentInjectorRequest = binding.parentInjectorRequest().get();
         return Snippet.format("%s.delegatingTo(%s)",
             ClassName.fromClass(MembersInjectors.class),
-            memberSelectSnippets.get(
-                dependencyRequestMapper.getFrameworkKey(parentInjectorRequest)));
+            memberSelectSnippets.get(BindingKey.forDependencyRequest(parentInjectorRequest)));
       } else {
         return Snippet.format("%s.noOp()",
             ClassName.fromClass(MembersInjectors.class));
       }
     } else {
       List<Snippet> parameters = getDependencyParameters(
-          dependencyRequestMapper,
           Sets.union(binding.parentInjectorRequest().asSet(), binding.dependencies()),
           memberSelectSnippets);
       return Snippet.format("new %s(%s)",
@@ -576,12 +586,10 @@ private static Snippet initializeMembersInjectorForBinding(
   }
 
   private static List<Snippet> getDependencyParameters(
-      DependencyRequestMapper dependencyRequestMapper,
       Iterable<DependencyRequest> dependencies,
-      ImmutableMap<FrameworkKey, Snippet> memberSelectSnippets) {
+      ImmutableMap<BindingKey, Snippet> memberSelectSnippets) {
     ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
-    for (FrameworkKey dependencyKey :
-         SourceFiles.indexDependenciesByKey(dependencyRequestMapper, dependencies).keySet()) {
+    for (BindingKey dependencyKey : SourceFiles.indexDependenciesByKey(dependencies).keySet()) {
       parameters.add(memberSelectSnippets.get(dependencyKey));
     }
     return parameters.build();
@@ -590,7 +598,7 @@ private static Snippet initializeMembersInjectorForBinding(
   private Snippet initializeMapBinding(
       Map<TypeElement, FieldWriter> contributionFields,
       ImmutableMap<ExecutableElement, TypeElement> dependencyMethodIndex,
-      ImmutableMap<FrameworkKey, Snippet> memberSelectSnippets,
+      ImmutableMap<BindingKey, Snippet> memberSelectSnippets,
       Set<ProvisionBinding> bindings) {
     Iterator<ProvisionBinding> iterator = bindings.iterator();
     // get type information from first binding in iterator
@@ -598,7 +606,7 @@ private Snippet initializeMapBinding(
     if (isNonProviderMap(firstBinding)) {
       return Snippet.format("%s.create(%s)",
           ClassName.fromClass(MapFactory.class),
-          memberSelectSnippets.get(dependencyRequestMapper.getFrameworkKey(
+          memberSelectSnippets.get(BindingKey.forDependencyRequest(
               Iterables.getOnlyElement(firstBinding.dependencies()))));
     } else {
       DeclaredType mapType = asDeclared(firstBinding.key().type());
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index 7908beb92..34b2f7d38 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -83,8 +83,7 @@ public SourceVersion getSupportedSourceVersion() {
         new FactoryGenerator(filer, DependencyRequestMapper.FOR_PROVIDER);
     MembersInjectorGenerator membersInjectorGenerator =
         new MembersInjectorGenerator(filer, elements, types, DependencyRequestMapper.FOR_PROVIDER);
-    ComponentGenerator componentGenerator =
-        new ComponentGenerator(filer, DependencyRequestMapper.FOR_PROVIDER);
+    ComponentGenerator componentGenerator = new ComponentGenerator(filer);
     ProducerFactoryGenerator producerFactoryGenerator =
         new ProducerFactoryGenerator(filer, DependencyRequestMapper.FOR_PRODUCER);
 
@@ -106,15 +105,14 @@ public SourceVersion getSupportedSourceVersion() {
         new ComponentDescriptor.Factory(elements, types);
 
     BindingGraph.Factory bindingGraphFactory = new BindingGraph.Factory(
-        elements, types, injectBindingRegistry, keyFactory, DependencyRequestMapper.FOR_PROVIDER,
+        elements, types, injectBindingRegistry, keyFactory,
         dependencyRequestFactory, provisionBindingFactory);
 
     MapKeyGenerator mapKeyGenerator = new MapKeyGenerator(filer);
     BindingGraphValidator bindingGraphValidator = new BindingGraphValidator(
         types,
         injectBindingRegistry,
-        disableInterComponentScopeValidation(processingEnv),
-        DependencyRequestMapper.FOR_PROVIDER);
+        disableInterComponentScopeValidation(processingEnv));
 
     return ImmutableList.<ProcessingStep>of(
         new MapKeyProcessingStep(
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestMapper.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestMapper.java
index 6657af157..c0deb49b2 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestMapper.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestMapper.java
@@ -15,33 +15,29 @@
  */
 package dagger.internal.codegen;
 
-import com.google.auto.value.AutoValue;
 import dagger.MembersInjector;
-import dagger.internal.codegen.writer.ClassName;
-import dagger.internal.codegen.writer.ParameterizedTypeName;
-import dagger.internal.codegen.writer.TypeNames;
 import dagger.producers.Producer;
 import javax.inject.Provider;
 
 /**
- * A mapper for associated a {@link DependencyRequest} to a {@link FrameworkKey}, dependent on the
- * type of code to be generated (e.g., for {@link Provider} or {@link Producer}).
+ * A mapper for associating a {@link DependencyRequest} to a framework class, dependent on
+ * the type of code to be generated (e.g., for {@link Provider} or {@link Producer}).
  *
  *  @author Jesse Beder
  *  @since 2.0
  */
 abstract class DependencyRequestMapper {
-  abstract FrameworkKey getFrameworkKey(DependencyRequest request);
+  abstract Class<?> getFrameworkClass(DependencyRequest request);
 
   private static final class MapperForProvider extends DependencyRequestMapper {
-    @Override public FrameworkKey getFrameworkKey(DependencyRequest request) {
+    @Override public Class<?> getFrameworkClass(DependencyRequest request) {
       switch (request.kind()) {
         case INSTANCE:
         case PROVIDER:
         case LAZY:
-          return FrameworkKey.create(FrameworkKey.Kind.PROVIDER, request.key());
+          return Provider.class;
         case MEMBERS_INJECTOR:
-          return FrameworkKey.create(FrameworkKey.Kind.MEMBERS_INJECTOR, request.key());
+          return MembersInjector.class;
         case PRODUCED:
         case PRODUCER:
           throw new IllegalArgumentException();
@@ -54,17 +50,17 @@
   static final DependencyRequestMapper FOR_PROVIDER = new MapperForProvider();
 
   private static final class MapperForProducer extends DependencyRequestMapper {
-    @Override public FrameworkKey getFrameworkKey(DependencyRequest request) {
+    @Override public Class<?> getFrameworkClass(DependencyRequest request) {
       switch (request.kind()) {
         case INSTANCE:
         case PRODUCED:
         case PRODUCER:
-          return FrameworkKey.create(FrameworkKey.Kind.PRODUCER, request.key());
+          return Producer.class;
         case PROVIDER:
         case LAZY:
-          return FrameworkKey.create(FrameworkKey.Kind.PROVIDER, request.key());
+          return Provider.class;
         case MEMBERS_INJECTOR:
-          return FrameworkKey.create(FrameworkKey.Kind.MEMBERS_INJECTOR, request.key());
+          return MembersInjector.class;
         default:
           throw new AssertionError();
       }
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index d6e5038e5..40808e009 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -37,7 +37,6 @@
 import dagger.internal.codegen.writer.TypeWriter;
 import java.util.Collections;
 import java.util.List;
-import java.util.Map.Entry;
 import javax.annotation.Generated;
 import javax.annotation.processing.Filer;
 import javax.inject.Inject;
@@ -139,13 +138,13 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
           .addSnippet("this.membersInjector = membersInjector;");
     }
 
-    ImmutableMap<FrameworkKey, String> names =
-        SourceFiles.generateFrameworkReferenceNamesForDependencies(
+    ImmutableMap<BindingKey, BindingField> fields =
+        SourceFiles.generateBindingFieldsForDependencies(
             dependencyRequestMapper, binding.dependencies());
 
-    for (Entry<FrameworkKey, String> nameEntry : names.entrySet()) {
-      ParameterizedTypeName fieldType = nameEntry.getKey().frameworkType();
-      FieldWriter field = factoryWriter.addField(fieldType, nameEntry.getValue());
+    for (BindingField bindingField : fields.values()) {
+      ParameterizedTypeName fieldType = bindingField.frameworkType();
+      FieldWriter field = factoryWriter.addField(fieldType, bindingField.name());
       field.addModifiers(PRIVATE, FINAL);
       constructorWriter.get().addParameter(field.type(), field.name());
       constructorWriter.get().body()
@@ -156,7 +155,7 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
     List<Snippet> parameters = Lists.newArrayList();
     for (DependencyRequest dependency : binding.dependencies()) {
       parameters.add(frameworkTypeUsageStatement(
-          Snippet.format(names.get(dependencyRequestMapper.getFrameworkKey(dependency))),
+          Snippet.format(fields.get(BindingKey.forDependencyRequest(dependency)).name()),
           dependency.kind()));
     }
     Snippet parametersSnippet = makeParametersSnippet(parameters);
diff --git a/compiler/src/main/java/dagger/internal/codegen/FrameworkKey.java b/compiler/src/main/java/dagger/internal/codegen/FrameworkKey.java
deleted file mode 100644
index 3c61e27d7..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/FrameworkKey.java
+++ /dev/null
@@ -1,80 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import com.google.auto.value.AutoValue;
-import dagger.MembersInjector;
-import dagger.internal.codegen.writer.ClassName;
-import dagger.internal.codegen.writer.ParameterizedTypeName;
-import dagger.internal.codegen.writer.TypeNames;
-import dagger.producers.Producer;
-import javax.inject.Provider;
-
-/**
- * A value object that pairs a {@link Key} with a framework class (e.g.: {@link Provider},
- * {@link MembersInjector}) related to that key.
- *
- *  @author Gregory Kick
- *  @since 2.0
- */
-@AutoValue
-abstract class FrameworkKey {
-  /**
-   * The aspect of the framework for which a {@link Key} is an identifier. Particularly, whether a
-   * key is for a {@link Provider} or a {@link MembersInjector}.
-   */
-  enum Kind {
-    PROVIDER(Provider.class),
-    MEMBERS_INJECTOR(MembersInjector.class),
-    PRODUCER(Producer.class),
-    ;
-
-    private final Class<?> frameworkClass;
-
-    Kind(Class<?> frameworkClass) {
-      this.frameworkClass = frameworkClass;
-    }
-
-    Class<?> frameworkClass() {
-      return frameworkClass;
-    }
-  }
-
-  static FrameworkKey create(Kind kind, Key key) {
-    return new AutoValue_FrameworkKey(kind, key);
-  }
-
-  ParameterizedTypeName frameworkType() {
-    return ParameterizedTypeName.create(
-        ClassName.fromClass(kind().frameworkClass()), TypeNames.forTypeMirror(key().type()));
-  }
-
-  abstract Kind kind();
-  abstract Key key();
-
-  String defaultSuffix() {
-    switch (kind()) {
-      case PROVIDER:
-        return "Provider";
-      case MEMBERS_INJECTOR:
-        return "MembersInjector";
-      case PRODUCER:
-        return "Producer";
-      default:
-        throw new AssertionError();
-    }
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
index 3d3f700f4..5a66043e7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
@@ -132,30 +132,31 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
       injectMembersWriter.body().addSnippet("supertypeInjector.injectMembers(instance);");
     }
 
-    ImmutableMap<FrameworkKey, String> names =
-        SourceFiles.generateFrameworkReferenceNamesForDependencies(
+    ImmutableMap<BindingKey, BindingField> fields =
+        SourceFiles.generateBindingFieldsForDependencies(
             dependencyRequestMapper, ImmutableSet.copyOf(binding.dependencies()));
 
-    ImmutableMap.Builder<FrameworkKey, FieldWriter> dependencyFieldsBuilder =
+    ImmutableMap.Builder<BindingKey, FieldWriter> dependencyFieldsBuilder =
         ImmutableMap.builder();
 
-    for (Entry<FrameworkKey, String> nameEntry : names.entrySet()) {
-      ParameterizedTypeName fieldType = nameEntry.getKey().frameworkType();
-      FieldWriter field = injectorWriter.addField(fieldType, nameEntry.getValue());
+    for (Entry<BindingKey, BindingField> fieldEntry : fields.entrySet()) {
+      BindingField bindingField = fieldEntry.getValue();
+      ParameterizedTypeName fieldType = bindingField.frameworkType();
+      FieldWriter field = injectorWriter.addField(fieldType, bindingField.name());
       field.addModifiers(PRIVATE, FINAL);
       constructorWriter.addParameter(field.type(), field.name());
       constructorWriter.body().addSnippet("assert %s != null;", field.name());
       constructorWriter.body().addSnippet("this.%1$s = %1$s;", field.name());
-      dependencyFieldsBuilder.put(nameEntry.getKey(), field);
+      dependencyFieldsBuilder.put(fieldEntry.getKey(), field);
     }
-    ImmutableMap<FrameworkKey, FieldWriter> depedencyFields = dependencyFieldsBuilder.build();
+    ImmutableMap<BindingKey, FieldWriter> depedencyFields = dependencyFieldsBuilder.build();
     for (InjectionSite injectionSite : binding.injectionSites()) {
       switch (injectionSite.kind()) {
         case FIELD:
           DependencyRequest fieldDependency =
               Iterables.getOnlyElement(injectionSite.dependencies());
           FieldWriter singleField = depedencyFields.get(
-              dependencyRequestMapper.getFrameworkKey(fieldDependency));
+              BindingKey.forDependencyRequest(fieldDependency));
           injectMembersWriter.body().addSnippet("instance.%s = %s;",
               injectionSite.element().getSimpleName(),
               frameworkTypeUsageStatement(Snippet.format(singleField.name()),
@@ -165,7 +166,7 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
           ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
           for (DependencyRequest methodDependency : injectionSite.dependencies()) {
             FieldWriter field = depedencyFields.get(
-                dependencyRequestMapper.getFrameworkKey(methodDependency));
+                BindingKey.forDependencyRequest(methodDependency));
             parameters.add(frameworkTypeUsageStatement(Snippet.format(field.name()),
                 methodDependency.kind()));
           }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
index cbdd4405d..56acf0a54 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -126,13 +126,13 @@ ClassName nameGeneratedType(ProductionBinding binding) {
     getMethodWriter.annotate(Override.class);
     getMethodWriter.addModifiers(PUBLIC);
 
-    final ImmutableMap<FrameworkKey, String> names =
-        SourceFiles.generateFrameworkReferenceNamesForDependencies(
+    final ImmutableMap<BindingKey, BindingField> fields =
+        SourceFiles.generateBindingFieldsForDependencies(
             dependencyRequestMapper, binding.dependencies());
 
-    for (Entry<FrameworkKey, String> nameEntry : names.entrySet()) {
-      ParameterizedTypeName fieldType = nameEntry.getKey().frameworkType();
-      FieldWriter field = factoryWriter.addField(fieldType, nameEntry.getValue());
+    for (BindingField bindingField : fields.values()) {
+      ParameterizedTypeName fieldType = bindingField.frameworkType();
+      FieldWriter field = factoryWriter.addField(fieldType, bindingField.name());
       field.addModifiers(PRIVATE, FINAL);
       constructorWriter.addParameter(field.type(), field.name());
       constructorWriter.body()
@@ -154,7 +154,7 @@ ClassName nameGeneratedType(ProductionBinding binding) {
       ParameterizedTypeName futureType = ParameterizedTypeName.create(
           ClassName.fromClass(ListenableFuture.class),
           asyncDependencyType(dependency));
-      String name = names.get(dependencyRequestMapper.getFrameworkKey(dependency));
+      String name = fields.get(BindingKey.forDependencyRequest(dependency)).name();
       Snippet futureAccess = Snippet.format("%s.get()", name);
       getMethodWriter.body().addSnippet("%s %sFuture = %s;",
           futureType,
@@ -169,7 +169,7 @@ ClassName nameGeneratedType(ProductionBinding binding) {
       ImmutableList.Builder<Snippet> parameterSnippets = ImmutableList.builder();
       for (DependencyRequest dependency : binding.dependencies()) {
         parameterSnippets.add(frameworkTypeUsageStatement(
-            Snippet.format(names.get(dependencyRequestMapper.getFrameworkKey(dependency))),
+            Snippet.format(fields.get(BindingKey.forDependencyRequest(dependency)).name()),
             dependency.kind()));
       }
       Snippet invocationSnippet = getInvocationSnippet(binding, parameterSnippets.build());
@@ -199,7 +199,7 @@ ClassName nameGeneratedType(ProductionBinding binding) {
       if (asyncDependencies.size() == 1) {
         DependencyRequest asyncDependency = Iterables.getOnlyElement(asyncDependencies);
         futureSnippet = Snippet.format("%s",
-            names.get(dependencyRequestMapper.getFrameworkKey(asyncDependency)) + "Future");
+            fields.get(BindingKey.forDependencyRequest(asyncDependency)).name() + "Future");
         String argName = asyncDependency.requestElement().getSimpleName().toString();
         ImmutableList.Builder<Snippet> parameterSnippets = ImmutableList.builder();
         for (DependencyRequest dependency : binding.dependencies()) {
@@ -209,7 +209,7 @@ ClassName nameGeneratedType(ProductionBinding binding) {
             parameterSnippets.add(Snippet.format("%s", argName));
           } else {
             parameterSnippets.add(frameworkTypeUsageStatement(
-                Snippet.format(names.get(dependencyRequestMapper.getFrameworkKey(dependency))),
+                Snippet.format(fields.get(BindingKey.forDependencyRequest(dependency)).name()),
                 dependency.kind()));
           }
         }
@@ -234,11 +234,11 @@ ClassName nameGeneratedType(ProductionBinding binding) {
                 .from(asyncDependencies)
                 .transform(new Function<DependencyRequest, String>() {
                   @Override public String apply(DependencyRequest dependency) {
-                    return names.get(dependencyRequestMapper.getFrameworkKey(dependency))
+                    return fields.get(BindingKey.forDependencyRequest(dependency)).name()
                         + "Future";
                   }
                 })));
-        ImmutableList<Snippet> parameterSnippets = getParameterSnippets(binding, names, "args");
+        ImmutableList<Snippet> parameterSnippets = getParameterSnippets(binding, fields, "args");
         Snippet invocationSnippet = getInvocationSnippet(binding, parameterSnippets);
         ParameterizedTypeName listOfObject = ParameterizedTypeName.create(
             ClassName.fromClass(List.class), ClassName.fromClass(Object.class));
@@ -289,7 +289,7 @@ private TypeName asyncDependencyType(DependencyRequest dependency) {
   }
 
   private ImmutableList<Snippet> getParameterSnippets(ProductionBinding binding,
-      ImmutableMap<FrameworkKey, String> names,
+      ImmutableMap<BindingKey, BindingField> fields,
       String listArgName) {
     int argIndex = 0;
     ImmutableList.Builder<Snippet> snippets = ImmutableList.builder();
@@ -303,7 +303,7 @@ private TypeName asyncDependencyType(DependencyRequest dependency) {
         argIndex++;
       } else {
         snippets.add(frameworkTypeUsageStatement(
-            Snippet.format(names.get(dependencyRequestMapper.getFrameworkKey(dependency))),
+            Snippet.format(fields.get(BindingKey.forDependencyRequest(dependency)).name()),
             dependency.kind()));
       }
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index 3d6b8ef07..26c170d38 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -28,7 +28,6 @@
 import java.util.Iterator;
 import java.util.Map;
 import java.util.Map.Entry;
-import javax.inject.Provider;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 
@@ -59,54 +58,54 @@ public int compare(DependencyRequest left, DependencyRequest right) {
     }
   };
 
-  static ImmutableSetMultimap<FrameworkKey, DependencyRequest> indexDependenciesByKey(
-      DependencyRequestMapper dependencyRequestMapper,
+  static ImmutableSetMultimap<BindingKey, DependencyRequest> indexDependenciesByKey(
       Iterable<? extends DependencyRequest> dependencies) {
-    ImmutableSetMultimap.Builder<FrameworkKey, DependencyRequest> dependenciesByKeyBuilder =
-        new ImmutableSetMultimap.Builder<FrameworkKey, DependencyRequest>().orderValuesBy(
+    ImmutableSetMultimap.Builder<BindingKey, DependencyRequest> dependenciesByKeyBuilder =
+        new ImmutableSetMultimap.Builder<BindingKey, DependencyRequest>().orderValuesBy(
             DEPENDENCY_ORDERING);
     for (DependencyRequest dependency : dependencies) {
       dependenciesByKeyBuilder.put(
-          dependencyRequestMapper.getFrameworkKey(dependency), dependency);
+          BindingKey.forDependencyRequest(dependency), dependency);
     }
     return dependenciesByKeyBuilder.build();
   }
 
   /**
-   * This method generates names for the {@link Provider} references necessary for all of the
+   * This method generates names and keys for the framework classes necessary for all of the
    * bindings. It is responsible for the following:
    * <ul>
-   * <li>Choosing a name that associates the provider with all of the dependency requests for this
+   * <li>Choosing a name that associates the binding with all of the dependency requests for this
    * type.
-   * <li>Choosing a name that is <i>probably</i> associated with the type being provided.
-   * <li>Ensuring that no two providers end up with the same name.
+   * <li>Choosing a name that is <i>probably</i> associated with the type being bound.
+   * <li>Ensuring that no two bindings end up with the same name.
    * </ul>
    *
-   * @return Returns the mapping from {@link Key} to provider name sorted by the name of the
-   *         provider.
+   * @return Returns the mapping from {@link BindingKey} to field, sorted by the name of the field.
    */
-  static ImmutableMap<FrameworkKey, String> generateFrameworkReferenceNamesForDependencies(
+  static ImmutableMap<BindingKey, BindingField> generateBindingFieldsForDependencies(
       DependencyRequestMapper dependencyRequestMapper,
       Iterable<? extends DependencyRequest> dependencies) {
-    ImmutableSetMultimap<FrameworkKey, DependencyRequest> dependenciesByKey =
-        indexDependenciesByKey(dependencyRequestMapper, dependencies);
-    Map<FrameworkKey, Collection<DependencyRequest>> dependenciesByKeyMap =
+    ImmutableSetMultimap<BindingKey, DependencyRequest> dependenciesByKey =
+        indexDependenciesByKey(dependencies);
+    Map<BindingKey, Collection<DependencyRequest>> dependenciesByKeyMap =
         dependenciesByKey.asMap();
-    ImmutableMap.Builder<FrameworkKey, String> providerNames = ImmutableMap.builder();
-    for (Entry<FrameworkKey, Collection<DependencyRequest>> entry
+    ImmutableMap.Builder<BindingKey, BindingField> bindingFields = ImmutableMap.builder();
+    for (Entry<BindingKey, Collection<DependencyRequest>> entry
         : dependenciesByKeyMap.entrySet()) {
-      FrameworkKey frameworkKey = entry.getKey();
-      String suffix = frameworkKey.defaultSuffix();
+      BindingKey bindingKey = entry.getKey();
+      Collection<DependencyRequest> requests = entry.getValue();
+      Class<?> frameworkClass =
+          dependencyRequestMapper.getFrameworkClass(requests.iterator().next());
       // collect together all of the names that we would want to call the provider
       ImmutableSet<String> dependencyNames =
-          FluentIterable.from(entry.getValue()).transform(new DependencyVariableNamer()).toSet();
+          FluentIterable.from(requests).transform(new DependencyVariableNamer()).toSet();
 
       if (dependencyNames.size() == 1) {
         // if there's only one name, great! use it!
         String name = Iterables.getOnlyElement(dependencyNames);
-        providerNames.put(frameworkKey, name.endsWith(suffix) ? name : name + suffix);
+        bindingFields.put(bindingKey, BindingField.create(frameworkClass, bindingKey, name));
       } else {
-        // in the event that a provider is being used for a bunch of deps with different names,
+        // in the event that a field is being used for a bunch of deps with different names,
         // add all the names together with "And"s in the middle. E.g.: stringAndS
         Iterator<String> namesIterator = dependencyNames.iterator();
         String first = namesIterator.next();
@@ -115,10 +114,11 @@ public int compare(DependencyRequest left, DependencyRequest right) {
           compositeNameBuilder.append("And").append(
               CaseFormat.LOWER_CAMEL.to(UPPER_CAMEL, namesIterator.next()));
         }
-        providerNames.put(frameworkKey, compositeNameBuilder.append(suffix).toString());
+        bindingFields.put(bindingKey, BindingField.create(
+            frameworkClass, bindingKey, compositeNameBuilder.toString()));
       }
     }
-    return providerNames.build();
+    return bindingFields.build();
   }
 
   static Snippet frameworkTypeUsageStatement(Snippet frameworkTypeMemberSelect,
diff --git a/compiler/src/test/java/dagger/internal/codegen/FrameworkKeyTest.java b/compiler/src/test/java/dagger/internal/codegen/BindingFieldTest.java
similarity index 73%
rename from compiler/src/test/java/dagger/internal/codegen/FrameworkKeyTest.java
rename to compiler/src/test/java/dagger/internal/codegen/BindingFieldTest.java
index ead0488d2..1e07849ab 100644
--- a/compiler/src/test/java/dagger/internal/codegen/FrameworkKeyTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/BindingFieldTest.java
@@ -38,10 +38,10 @@
 import static com.google.common.truth.Truth.assertThat;
 
 /**
- * Test case for {@link FrameworkKey}.
+ * Test case for {@link BindingField}.
  */
 @RunWith(JUnit4.class)
-public class FrameworkKeyTest {
+public class BindingFieldTest {
   @Rule public CompilationRule compilationRule = new CompilationRule();
 
   private Elements elements;
@@ -63,14 +63,30 @@ private ExecutableElement getXConstructor() {
   @Test public void frameworkType() {
     Key key = keyFactory.forInjectConstructor(getXConstructor());
     TypeName xClass = TypeNames.forTypeMirror(key.type());
-    assertThat(FrameworkKey.create(FrameworkKey.Kind.PROVIDER, key).frameworkType())
+    assertThat(BindingField.create(Provider.class,
+            BindingKey.create(BindingKey.Kind.CONTRIBUTION, key), "test")
+        .frameworkType())
         .isEqualTo(ParameterizedTypeName.create(
             ClassName.fromClass(Provider.class), xClass));
-    assertThat(FrameworkKey.create(FrameworkKey.Kind.MEMBERS_INJECTOR, key).frameworkType())
+    assertThat(BindingField.create(MembersInjector.class,
+            BindingKey.create(BindingKey.Kind.MEMBERS_INJECTION, key), "test")
+        .frameworkType())
         .isEqualTo(ParameterizedTypeName.create(
             ClassName.fromClass(MembersInjector.class), xClass));
   }
 
+  @Test public void nameSuffix() {
+    Key key = keyFactory.forInjectConstructor(getXConstructor());
+    TypeName xClass = TypeNames.forTypeMirror(key.type());
+    assertThat(BindingField.create(Provider.class,
+            BindingKey.create(BindingKey.Kind.CONTRIBUTION, key), "foo").name())
+        .isEqualTo("fooProvider");
+    assertThat(BindingField.create(Provider.class,
+            BindingKey.create(BindingKey.Kind.CONTRIBUTION, key), "fooProvider").name())
+        .isEqualTo("fooProvider");
+
+  }
+
   static final class X {
     @Inject X() {}
   }
diff --git a/compiler/src/test/java/dagger/internal/codegen/DependencyRequestMapperTest.java b/compiler/src/test/java/dagger/internal/codegen/DependencyRequestMapperTest.java
index f839ceaf7..8b5fd3a79 100644
--- a/compiler/src/test/java/dagger/internal/codegen/DependencyRequestMapperTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/DependencyRequestMapperTest.java
@@ -21,8 +21,6 @@
 import dagger.MembersInjector;
 import dagger.Module;
 import dagger.Provides;
-import dagger.internal.codegen.writer.ClassName;
-import dagger.internal.codegen.writer.ParameterizedTypeName;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
 import dagger.producers.ProducerModule;
@@ -32,7 +30,6 @@
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
-import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
@@ -105,30 +102,30 @@ private DependencyRequest dependencyRequestForProduced() {
 
   @Test public void forProvider() {
     DependencyRequestMapper mapper = DependencyRequestMapper.FOR_PROVIDER;
-    assertThat(mapper.getFrameworkKey(dependencyRequestForInstance()).kind())
-        .isEqualTo(FrameworkKey.Kind.PROVIDER);
-    assertThat(mapper.getFrameworkKey(dependencyRequestForLazy()).kind())
-        .isEqualTo(FrameworkKey.Kind.PROVIDER);
-    assertThat(mapper.getFrameworkKey(dependencyRequestForProvider()).kind())
-        .isEqualTo(FrameworkKey.Kind.PROVIDER);
-    assertThat(mapper.getFrameworkKey(dependencyRequestForMembersInjector()).kind())
-        .isEqualTo(FrameworkKey.Kind.MEMBERS_INJECTOR);
+    assertThat(mapper.getFrameworkClass(dependencyRequestForInstance()))
+        .isEqualTo(Provider.class);
+    assertThat(mapper.getFrameworkClass(dependencyRequestForLazy()))
+        .isEqualTo(Provider.class);
+    assertThat(mapper.getFrameworkClass(dependencyRequestForProvider()))
+        .isEqualTo(Provider.class);
+    assertThat(mapper.getFrameworkClass(dependencyRequestForMembersInjector()))
+        .isEqualTo(MembersInjector.class);
   }
 
   @Test public void forProducer() {
     DependencyRequestMapper mapper = DependencyRequestMapper.FOR_PRODUCER;
-    assertThat(mapper.getFrameworkKey(dependencyRequestForInstance()).kind())
-        .isEqualTo(FrameworkKey.Kind.PRODUCER);
-    assertThat(mapper.getFrameworkKey(dependencyRequestForLazy()).kind())
-        .isEqualTo(FrameworkKey.Kind.PROVIDER);
-    assertThat(mapper.getFrameworkKey(dependencyRequestForProvider()).kind())
-        .isEqualTo(FrameworkKey.Kind.PROVIDER);
-    assertThat(mapper.getFrameworkKey(dependencyRequestForMembersInjector()).kind())
-        .isEqualTo(FrameworkKey.Kind.MEMBERS_INJECTOR);
-    assertThat(mapper.getFrameworkKey(dependencyRequestForProducer()).kind())
-        .isEqualTo(FrameworkKey.Kind.PRODUCER);
-    assertThat(mapper.getFrameworkKey(dependencyRequestForProduced()).kind())
-        .isEqualTo(FrameworkKey.Kind.PRODUCER);
+    assertThat(mapper.getFrameworkClass(dependencyRequestForInstance()))
+        .isEqualTo(Producer.class);
+    assertThat(mapper.getFrameworkClass(dependencyRequestForLazy()))
+        .isEqualTo(Provider.class);
+    assertThat(mapper.getFrameworkClass(dependencyRequestForProvider()))
+        .isEqualTo(Provider.class);
+    assertThat(mapper.getFrameworkClass(dependencyRequestForMembersInjector()))
+        .isEqualTo(MembersInjector.class);
+    assertThat(mapper.getFrameworkClass(dependencyRequestForProducer()))
+        .isEqualTo(Producer.class);
+    assertThat(mapper.getFrameworkClass(dependencyRequestForProduced()))
+        .isEqualTo(Producer.class);
   }
 
   @Module(library = true)
