diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index ad57c475b..847e85d4c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -1123,7 +1123,7 @@ private void reportCycle(
         DependencyRequest dependencyRequest = cycle.get(i);
         switch (dependencyRequest.kind()) {
           case PROVIDER:
-            if (isImplicitProviderMapForValueMap(dependencyRequest, cycle.get(i - 1))) {
+            if (isDependencyOfSyntheticMap(dependencyRequest, cycle.get(i - 1))) {
               i++; // Skip the Provider requests in the Map<K, Provider<V>> too.
             } else {
               providers.add(dependencyRequest);
@@ -1149,16 +1149,19 @@ private void reportCycle(
     }
 
     /**
-     * Returns {@code true} if {@code maybeValueMapRequest}'s key type is {@code Map<K, V>} and
-     * {@code maybeProviderMapRequest}'s key type is {@code Map<K, Provider<V>>}, and both keys have
-     * the same qualifier.
+     * Returns {@code true} if {@code request} is a request for {@code Map<K, Provider<V>>} or
+     * {@code Map<K, Producer<V>>} from a synthetic binding for {@code Map<K, V>} or
+     * {@code Map<K, Produced<V>>}.
      */
-    private boolean isImplicitProviderMapForValueMap(
-        DependencyRequest maybeProviderMapRequest, DependencyRequest maybeValueMapRequest) {
-      Optional<Key> implicitProviderMapKey =
-          keyFactory.implicitMapProviderKeyFrom(maybeValueMapRequest.key());
-      return implicitProviderMapKey.isPresent()
-          && implicitProviderMapKey.get().equals(maybeProviderMapRequest.key());
+    // TODO(dpb): Make this check more explicit.
+    private boolean isDependencyOfSyntheticMap(
+        DependencyRequest request, DependencyRequest requestForPreviousBinding) {
+      // Synthetic map dependencies share the same request element as the previous request.
+      return request.requestElement().equals(requestForPreviousBinding.requestElement())
+          && Sets.union(
+                  keyFactory.implicitMapProviderKeyFrom(requestForPreviousBinding.key()).asSet(),
+                  keyFactory.implicitMapProducerKeyFrom(requestForPreviousBinding.key()).asSet())
+              .contains(request.key());
     }
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
index cbc579105..8866cb570 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -18,6 +18,7 @@
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
+import com.google.common.base.Equivalence;
 import com.google.common.base.Function;
 import com.google.common.base.Optional;
 import com.google.common.collect.FluentIterable;
@@ -50,7 +51,7 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
-import static javax.lang.model.type.TypeKind.DECLARED;
+import static com.google.common.collect.Iterables.getOnlyElement;
 import static javax.lang.model.util.ElementFilter.constructorsIn;
 
 /**
@@ -132,7 +133,11 @@ BindingKey bindingKey() {
    * Returns the possibly resolved type that contained the requesting element. For members injection
    * requests, this is the type itself.
    */
-  abstract DeclaredType enclosingType();
+  DeclaredType enclosingType() {
+    return wrappedEnclosingType().get();
+  }
+
+  abstract Equivalence.Wrapper<DeclaredType> wrappedEnclosingType();
 
   /** Returns true if this request allows null objects. */
   abstract boolean isNullable();
@@ -196,7 +201,7 @@ DependencyRequest forImplicitMapBinding(
           Kind.PROVIDER,
           mapOfFactoryKey,
           mapOfValueRequest.requestElement(),
-          mapOfValueRequest.enclosingType(),
+          mapOfValueRequest.wrappedEnclosingType(),
           false /* doesn't allow null */,
           Optional.<String>absent());
     }
@@ -207,23 +212,35 @@ DependencyRequest forImplicitMapBinding(
      */
     DependencyRequest forMultibindingContribution(
         DependencyRequest request, ContributionBinding multibindingContribution) {
-      checkArgument(
-          multibindingContribution.contributionType().isMultibinding(),
-          "multibindingContribution must be a multibinding: %s",
-          multibindingContribution);
       checkArgument(
           multibindingContribution.key().bindingMethod().isPresent(),
           "multibindingContribution's key must have a binding method identifier: %s",
           multibindingContribution);
       return new AutoValue_DependencyRequest(
-          Kind.PROVIDER,
+          multibindingContributionRequestKind(multibindingContribution),
           multibindingContribution.key(),
           request.requestElement(),
-          request.enclosingType(),
+          request.wrappedEnclosingType(),
           false /* doesn't allow null */,
           Optional.<String>absent());
     }
 
+    private Kind multibindingContributionRequestKind(ContributionBinding multibindingContribution) {
+      switch (multibindingContribution.contributionType()) {
+        case MAP:
+          return multibindingContribution.bindingType().equals(BindingType.PRODUCTION)
+              ? Kind.PRODUCER
+              : Kind.PROVIDER;
+        case SET:
+          return Kind.INSTANCE;
+        case UNIQUE:
+          throw new IllegalArgumentException(
+              "multibindingContribution must be a multibinding: " + multibindingContribution);
+        default:
+          throw new AssertionError(multibindingContribution.toString());
+      }
+    }
+
     /**
      * Creates dependency requests, with the same element as {@code request}, for each individual
      * multibinding contribution in {@code multibindingContributions}.
@@ -293,7 +310,7 @@ DependencyRequest forComponentProductionMethod(ExecutableElement productionMetho
             keyFactory.forQualifiedType(
                 qualifier, Iterables.getOnlyElement(((DeclaredType) type).getTypeArguments())),
             productionMethod,
-            container,
+            MoreTypes.equivalence().wrap(container),
             false /* doesn't allow null */,
             Optional.<String>absent());
       } else {
@@ -310,26 +327,19 @@ DependencyRequest forComponentMembersInjectionMethod(ExecutableElement membersIn
           InjectionAnnotations.getQualifier(membersInjectionMethod);
       checkArgument(!qualifier.isPresent());
       TypeMirror returnType = membersInjectionMethodType.getReturnType();
-      if (returnType.getKind().equals(DECLARED)
-          && MoreTypes.isTypeOf(MembersInjector.class, returnType)) {
-        return new AutoValue_DependencyRequest(
-            Kind.MEMBERS_INJECTOR,
-            keyFactory.forMembersInjectedType(
-                Iterables.getOnlyElement(((DeclaredType) returnType).getTypeArguments())),
-            membersInjectionMethod,
-            getEnclosingType(membersInjectionMethod),
-            false /* doesn't allow null */,
-            Optional.<String>absent());
-      } else {
-        return new AutoValue_DependencyRequest(
-            Kind.MEMBERS_INJECTOR,
-            keyFactory.forMembersInjectedType(
-                Iterables.getOnlyElement(membersInjectionMethodType.getParameterTypes())),
-            membersInjectionMethod,
-            getEnclosingType(membersInjectionMethod),
-            false /* doesn't allow null */,
-            Optional.<String>absent());
-      }
+      Equivalence.Wrapper<DeclaredType> container =
+          MoreTypes.equivalence().wrap(getEnclosingType(membersInjectionMethod));
+      TypeMirror membersInjectedType =
+          MoreTypes.isType(returnType) && MoreTypes.isTypeOf(MembersInjector.class, returnType)
+              ? getOnlyElement(MoreTypes.asDeclared(returnType).getTypeArguments())
+              : getOnlyElement(membersInjectionMethodType.getParameterTypes());
+      return new AutoValue_DependencyRequest(
+          Kind.MEMBERS_INJECTOR,
+          keyFactory.forMembersInjectedType(membersInjectedType),
+          membersInjectionMethod,
+          container,
+          false /* doesn't allow null */,
+          Optional.<String>absent());
     }
 
     DependencyRequest forMembersInjectedType(DeclaredType type) {
@@ -337,7 +347,7 @@ DependencyRequest forMembersInjectedType(DeclaredType type) {
           Kind.MEMBERS_INJECTOR,
           keyFactory.forMembersInjectedType(type),
           type.asElement(),
-          type,
+          MoreTypes.equivalence().wrap(type),
           false /* doesn't allow null */,
           Optional.<String>absent());
     }
@@ -348,7 +358,7 @@ DependencyRequest forProductionImplementationExecutor() {
           Kind.PROVIDER,
           key,
           MoreTypes.asElement(key.type()),
-          MoreTypes.asDeclared(key.type()),
+          MoreTypes.equivalence().wrap(MoreTypes.asDeclared(key.type())),
           false /* doesn't allow null */,
           Optional.<String>absent());
     }
@@ -383,7 +393,7 @@ private DependencyRequest newDependencyRequest(
           kindAndType.kind(),
           keyFactory.forQualifiedType(qualifier, kindAndType.type()),
           requestElement,
-          container,
+          MoreTypes.equivalence().wrap(container),
           allowsNull,
           name);
     }
diff --git a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
index 73b581993..dd31751cb 100644
--- a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
@@ -324,6 +324,68 @@ public void cyclicDependencyNotBrokenByMapBinding() {
         .onLine(25);
   }
 
+  @Test
+  public void cyclicDependencyWithSetBinding() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.Outer",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import java.util.Set;",
+            "import javax.inject.Inject;",
+            "",
+            "final class Outer {",
+            "  static class A {",
+            "    @Inject A(Set<C> cSet) {}",
+            "  }",
+            "",
+            "  static class B {",
+            "    @Inject B(A aParam) {}",
+            "  }",
+            "",
+            "  static class C {",
+            "    @Inject C(B bParam) {}",
+            "  }",
+            "",
+            "  @Component(modules = CModule.class)",
+            "  interface CComponent {",
+            "    C getC();",
+            "  }",
+            "",
+            "  @Module",
+            "  static class CModule {",
+            "    @Provides(type = Provides.Type.SET)",
+            "    static C c(C c) {",
+            "      return c;",
+            "    }",
+            "  }",
+            "}");
+
+    String expectedError =
+        Joiner.on('\n')
+            .join(
+                "test.Outer.CComponent.getC() contains a dependency cycle:",
+                "      test.Outer.C.<init>(test.Outer.B bParam)",
+                "          [parameter: test.Outer.B bParam]",
+                "      test.Outer.B.<init>(test.Outer.A aParam)",
+                "          [parameter: test.Outer.A aParam]",
+                "      test.Outer.A.<init>(java.util.Set<test.Outer.C> cSet)",
+                "          [parameter: java.util.Set<test.Outer.C> cSet]",
+                "      test.Outer.CModule.c(test.Outer.C c)",
+                "          [parameter: test.Outer.C c]");
+
+    assertAbout(javaSource())
+        .that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedError)
+        .in(component)
+        .onLine(24);
+  }
+
   @Test
   public void falsePositiveCyclicDependencyIndirectionDetected() {
     JavaFileObject component =
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java
index 145e856f2..399fb758f 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java
@@ -15,6 +15,7 @@
  */
 package dagger.internal.codegen;
 
+import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.JavaFileObjects;
 import java.util.Arrays;
 import javax.tools.JavaFileObject;
@@ -268,4 +269,87 @@ public void monitoringDependsOnProduction() {
         .in(component)
         .onLine(36);
   }
+  
+  @Test
+  public void cycleNotBrokenByMap() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "TestComponent",
+            "import com.google.common.util.concurrent.ListenableFuture;",
+            "import dagger.producers.ProductionComponent;",
+            "",
+            "@ProductionComponent(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  ListenableFuture<String> string();",
+            "}");
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "TestModule",
+            "import dagger.producers.ProducerModule;",
+            "import dagger.producers.Produces;",
+            "import dagger.multibindings.StringKey;",
+            "import java.util.Map;",
+            "import static dagger.producers.Produces.Type.MAP;",
+            "",
+            "@ProducerModule",
+            "final class TestModule {",
+            "  @Produces static String string(Map<String, String> map) {",
+            "    return \"string\";",
+            "  }",
+            "",
+            "  @Produces(type = MAP) @StringKey(\"key\")",
+            "  static String entry(String string) {",
+            "    return string;",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(component, module))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("cycle")
+        .in(component)
+        .onLine(6);
+  }
+
+  @Test
+  public void cycleNotBrokenByProducerMap() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "TestComponent",
+            "import com.google.common.util.concurrent.ListenableFuture;",
+            "import dagger.producers.ProductionComponent;",
+            "",
+            "@ProductionComponent(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  ListenableFuture<String> string();",
+            "}");
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "TestModule",
+            "import dagger.producers.Producer;",
+            "import dagger.producers.ProducerModule;",
+            "import dagger.producers.Produces;",
+            "import dagger.multibindings.StringKey;",
+            "import java.util.Map;",
+            "import static dagger.producers.Produces.Type.MAP;",
+            "",
+            "@ProducerModule",
+            "final class TestModule {",
+            "  @Produces static String string(Map<String, Producer<String>> map) {",
+            "    return \"string\";",
+            "  }",
+            "",
+            "  @Produces(type = MAP) @StringKey(\"key\")",
+            "  static String entry(String string) {",
+            "    return string;",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(component, module))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("cycle")
+        .in(component)
+        .onLine(6);
+  }
 }
