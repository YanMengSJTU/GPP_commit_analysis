diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index b78e8d26b..e21aa8e53 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -67,11 +67,7 @@ public SourceVersion getSupportedSourceVersion() {
         new DependencyRequestFormatter(types, elements);
     KeyFormatter keyFormatter = new KeyFormatter(methodSignatureFormatter);
 
-    InjectConstructorValidator injectConstructorValidator = new InjectConstructorValidator();
-    InjectFieldValidator injectFieldValidator = new InjectFieldValidator(compilerOptions);
-    InjectMethodValidator injectMethodValidator = new InjectMethodValidator(compilerOptions);
-    MembersInjectedTypeValidator membersInjectedTypeValidator =
-        new MembersInjectedTypeValidator(injectFieldValidator, injectMethodValidator);
+    InjectValidator injectValidator = new InjectValidator(compilerOptions);
     ModuleValidator moduleValidator =
         new ModuleValidator(types, elements, methodSignatureFormatter);
     BuilderValidator builderValidator = new BuilderValidator(elements, types);
@@ -122,8 +118,7 @@ public SourceVersion getSupportedSourceVersion() {
             elements,
             types,
             messager,
-            injectConstructorValidator,
-            membersInjectedTypeValidator,
+            injectValidator,
             keyFactory,
             provisionBindingFactory,
             membersInjectionBindingFactory);
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
index 212b08dba..013c7af18 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
@@ -62,8 +62,7 @@
   private final Elements elements;
   private final Types types;
   private final Messager messager;
-  private final InjectConstructorValidator injectConstructorValidator;
-  private final MembersInjectedTypeValidator membersInjectedTypeValidator;
+  private final InjectValidator injectValidator;
   private final Key.Factory keyFactory;
   private final ProvisionBinding.Factory provisionBindingFactory;
   private final MembersInjectionBinding.Factory membersInjectionBindingFactory;
@@ -153,16 +152,14 @@ private void tryToCacheBinding(B binding) {
       Elements elements,
       Types types,
       Messager messager,
-      InjectConstructorValidator injectConstructorValidator,
-      MembersInjectedTypeValidator membersInjectedTypeValidator,
+      InjectValidator injectValidator,
       Key.Factory keyFactory,
       ProvisionBinding.Factory provisionBindingFactory,
       MembersInjectionBinding.Factory membersInjectionBindingFactory) {
     this.elements = elements;
     this.types = types;
     this.messager = messager;
-    this.injectConstructorValidator = injectConstructorValidator;
-    this.membersInjectedTypeValidator = membersInjectedTypeValidator;
+    this.injectValidator = injectValidator;
     this.keyFactory = keyFactory;
     this.provisionBindingFactory = provisionBindingFactory;
     this.membersInjectionBindingFactory = membersInjectionBindingFactory;
@@ -234,7 +231,7 @@ private void registerBinding(MembersInjectionBinding binding, boolean warnIfNotA
       return Optional.of(cachedBinding);
     }
 
-    ValidationReport<TypeElement> report = injectConstructorValidator.validate(constructorElement);
+    ValidationReport<TypeElement> report = injectValidator.validateConstructor(constructorElement);
     report.printMessagesTo(messager);
     if (report.isClean()) {
       ProvisionBinding binding =
@@ -265,7 +262,7 @@ private void registerBinding(MembersInjectionBinding binding, boolean warnIfNotA
       return Optional.of(cachedBinding);
     }
 
-    ValidationReport<TypeElement> report = membersInjectedTypeValidator.validate(typeElement);
+    ValidationReport<TypeElement> report = injectValidator.validateType(typeElement);
     report.printMessagesTo(messager);
     if (report.isClean()) {
       MembersInjectionBinding binding =
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectFieldValidator.java b/compiler/src/main/java/dagger/internal/codegen/InjectFieldValidator.java
deleted file mode 100644
index 198ae7136..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/InjectFieldValidator.java
+++ /dev/null
@@ -1,78 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import com.google.common.collect.ImmutableSet;
-import java.util.Set;
-import javax.inject.Inject;
-import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.Modifier;
-import javax.lang.model.element.VariableElement;
-
-import static dagger.internal.codegen.ErrorMessages.FINAL_INJECT_FIELD;
-import static dagger.internal.codegen.ErrorMessages.MULTIPLE_QUALIFIERS;
-import static dagger.internal.codegen.ErrorMessages.PRIVATE_INJECT_FIELD;
-import static dagger.internal.codegen.ErrorMessages.STATIC_INJECT_FIELD;
-import static dagger.internal.codegen.ErrorMessages.provisionMayNotDependOnProducerType;
-import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
-import static javax.lang.model.element.Modifier.FINAL;
-import static javax.lang.model.element.Modifier.PRIVATE;
-import static javax.lang.model.element.Modifier.STATIC;
-
-/**
- * A {@linkplain ValidationReport validator} for {@link Inject} fields.
- *
- * @author Gregory Kick
- * @since 2.0
- */
-final class InjectFieldValidator {
-  private CompilerOptions compilerOptions;
-
-  public InjectFieldValidator(CompilerOptions compilerOptions) {
-    this.compilerOptions = compilerOptions;
-  }
-
-  ValidationReport<VariableElement> validate(VariableElement fieldElement) {
-    ValidationReport.Builder<VariableElement> builder = ValidationReport.about(fieldElement);
-    Set<Modifier> modifiers = fieldElement.getModifiers();
-    if (modifiers.contains(FINAL)) {
-      builder.addError(FINAL_INJECT_FIELD, fieldElement);
-    }
-
-    if (modifiers.contains(PRIVATE)) {
-      builder.addItem(
-          PRIVATE_INJECT_FIELD, compilerOptions.privateMemberValidationKind(), fieldElement);
-    }
-
-    if (modifiers.contains(STATIC)) {
-      builder.addItem(
-          STATIC_INJECT_FIELD, compilerOptions.staticMemberValidationKind(), fieldElement);
-    }
-    
-    ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(fieldElement);
-    if (qualifiers.size() > 1) {
-      for (AnnotationMirror qualifier : qualifiers) {
-        builder.addError(MULTIPLE_QUALIFIERS, fieldElement, qualifier);
-      }
-    }
-
-    if (FrameworkTypes.isProducerType(fieldElement.asType())) {
-      builder.addError(provisionMayNotDependOnProducerType(fieldElement.asType()), fieldElement);
-    }
-
-    return builder.build();
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/InjectMethodValidator.java
deleted file mode 100644
index 3ad6e7d74..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/InjectMethodValidator.java
+++ /dev/null
@@ -1,85 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import com.google.common.collect.ImmutableSet;
-import java.util.Set;
-import javax.inject.Inject;
-import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.Modifier;
-import javax.lang.model.element.VariableElement;
-
-import static dagger.internal.codegen.ErrorMessages.ABSTRACT_INJECT_METHOD;
-import static dagger.internal.codegen.ErrorMessages.GENERIC_INJECT_METHOD;
-import static dagger.internal.codegen.ErrorMessages.MULTIPLE_QUALIFIERS;
-import static dagger.internal.codegen.ErrorMessages.PRIVATE_INJECT_METHOD;
-import static dagger.internal.codegen.ErrorMessages.STATIC_INJECT_METHOD;
-import static dagger.internal.codegen.ErrorMessages.provisionMayNotDependOnProducerType;
-import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
-import static javax.lang.model.element.Modifier.ABSTRACT;
-import static javax.lang.model.element.Modifier.PRIVATE;
-import static javax.lang.model.element.Modifier.STATIC;
-
-/**
- * A {@linkplain ValidationReport validator} for {@link Inject} methods.
- *
- * @author Gregory Kick
- * @since 2.0
- */
-final class InjectMethodValidator {
-  private CompilerOptions compilerOptions;
-
-  public InjectMethodValidator(CompilerOptions compilerOptions) {
-    this.compilerOptions = compilerOptions;
-  }
-
-  ValidationReport<ExecutableElement> validate(ExecutableElement methodElement) {
-    ValidationReport.Builder<ExecutableElement> builder = ValidationReport.about(methodElement);
-    Set<Modifier> modifiers = methodElement.getModifiers();
-    if (modifiers.contains(ABSTRACT)) {
-      builder.addError(ABSTRACT_INJECT_METHOD, methodElement);
-    }
-
-    if (modifiers.contains(PRIVATE)) {
-      builder.addItem(
-          PRIVATE_INJECT_METHOD, compilerOptions.privateMemberValidationKind(), methodElement);
-    }
-    
-    if (modifiers.contains(STATIC)) {
-      builder.addItem(
-          STATIC_INJECT_METHOD, compilerOptions.staticMemberValidationKind(), methodElement);
-    }
-
-    if (!methodElement.getTypeParameters().isEmpty()) {
-      builder.addError(GENERIC_INJECT_METHOD, methodElement);
-    }
-
-    for (VariableElement parameter : methodElement.getParameters()) {
-      ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(parameter);
-      if (qualifiers.size() > 1) {
-        for (AnnotationMirror qualifier : qualifiers) {
-          builder.addError(MULTIPLE_QUALIFIERS, methodElement, qualifier);
-        }
-      }
-      if (FrameworkTypes.isProducerType(parameter.asType())) {
-        builder.addError(provisionMayNotDependOnProducerType(parameter.asType()), parameter);
-      }
-    }
-
-    return builder.build();
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectConstructorValidator.java b/compiler/src/main/java/dagger/internal/codegen/InjectValidator.java
similarity index 50%
rename from compiler/src/main/java/dagger/internal/codegen/InjectConstructorValidator.java
rename to compiler/src/main/java/dagger/internal/codegen/InjectValidator.java
index dceeb52c8..6a6ce3e90 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectConstructorValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectValidator.java
@@ -16,6 +16,7 @@
 package dagger.internal.codegen;
 
 import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
 import com.google.common.base.Predicate;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
@@ -26,9 +27,14 @@
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementFilter;
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static dagger.internal.codegen.ErrorMessages.ABSTRACT_INJECT_METHOD;
+import static dagger.internal.codegen.ErrorMessages.FINAL_INJECT_FIELD;
+import static dagger.internal.codegen.ErrorMessages.GENERIC_INJECT_METHOD;
 import static dagger.internal.codegen.ErrorMessages.INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS;
 import static dagger.internal.codegen.ErrorMessages.INJECT_CONSTRUCTOR_ON_INNER_CLASS;
 import static dagger.internal.codegen.ErrorMessages.INJECT_INTO_PRIVATE_CLASS;
@@ -36,23 +42,35 @@
 import static dagger.internal.codegen.ErrorMessages.MULTIPLE_INJECT_CONSTRUCTORS;
 import static dagger.internal.codegen.ErrorMessages.MULTIPLE_QUALIFIERS;
 import static dagger.internal.codegen.ErrorMessages.MULTIPLE_SCOPES;
+import static dagger.internal.codegen.ErrorMessages.PRIVATE_INJECT_FIELD;
+import static dagger.internal.codegen.ErrorMessages.PRIVATE_INJECT_METHOD;
+import static dagger.internal.codegen.ErrorMessages.provisionMayNotDependOnProducerType;
 import static dagger.internal.codegen.ErrorMessages.QUALIFIER_ON_INJECT_CONSTRUCTOR;
 import static dagger.internal.codegen.ErrorMessages.SCOPE_ON_INJECT_CONSTRUCTOR;
-import static dagger.internal.codegen.ErrorMessages.provisionMayNotDependOnProducerType;
+import static dagger.internal.codegen.ErrorMessages.STATIC_INJECT_FIELD;
+import static dagger.internal.codegen.ErrorMessages.STATIC_INJECT_METHOD;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
 import static dagger.internal.codegen.InjectionAnnotations.getScopes;
 import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.STATIC;
 
 /**
- * A {@linkplain ValidationReport validator} for {@link Inject} constructors.
+ * A {@linkplain ValidationReport validator} for {@link Inject}-annotated elements and the types
+ * that contain them.
  *
  * @author Gregory Kick
  * @since 2.0
  */
-final class InjectConstructorValidator {
-  ValidationReport<TypeElement> validate(ExecutableElement constructorElement) {
+final class InjectValidator {
+  private CompilerOptions compilerOptions;
+
+  InjectValidator(CompilerOptions compilerOptions) {
+    this.compilerOptions = compilerOptions;
+  }
+
+  ValidationReport<TypeElement> validateConstructor(ExecutableElement constructorElement) {
     ValidationReport.Builder<TypeElement> builder =
         ValidationReport.about(MoreElements.asType(constructorElement.getEnclosingElement()));
     if (constructorElement.getModifiers().contains(PRIVATE)) {
@@ -118,4 +136,101 @@
 
     return builder.build();
   }
+
+ ValidationReport<VariableElement> validateField(VariableElement fieldElement) {
+    ValidationReport.Builder<VariableElement> builder = ValidationReport.about(fieldElement);
+    Set<Modifier> modifiers = fieldElement.getModifiers();
+    if (modifiers.contains(FINAL)) {
+      builder.addError(FINAL_INJECT_FIELD, fieldElement);
+    }
+
+    if (modifiers.contains(PRIVATE)) {
+      builder.addItem(
+          PRIVATE_INJECT_FIELD, compilerOptions.privateMemberValidationKind(), fieldElement);
+    }
+
+    if (modifiers.contains(STATIC)) {
+      builder.addItem(
+          STATIC_INJECT_FIELD, compilerOptions.staticMemberValidationKind(), fieldElement);
+    }
+ 
+    ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(fieldElement);
+    if (qualifiers.size() > 1) {
+      for (AnnotationMirror qualifier : qualifiers) {
+        builder.addError(MULTIPLE_QUALIFIERS, fieldElement, qualifier);
+      }
+    }
+
+    if (FrameworkTypes.isProducerType(fieldElement.asType())) {
+      builder.addError(provisionMayNotDependOnProducerType(fieldElement.asType()), fieldElement);
+    }
+
+    return builder.build();
+  }
+
+  ValidationReport<ExecutableElement> validateMethod(ExecutableElement methodElement) {
+    ValidationReport.Builder<ExecutableElement> builder = ValidationReport.about(methodElement);
+    Set<Modifier> modifiers = methodElement.getModifiers();
+    if (modifiers.contains(ABSTRACT)) {
+      builder.addError(ABSTRACT_INJECT_METHOD, methodElement);
+    }
+
+    if (modifiers.contains(PRIVATE)) {
+      builder.addItem(
+          PRIVATE_INJECT_METHOD, compilerOptions.privateMemberValidationKind(), methodElement);
+    }
+
+    if (modifiers.contains(STATIC)) {
+      builder.addItem(
+          STATIC_INJECT_METHOD, compilerOptions.staticMemberValidationKind(), methodElement);
+    }
+
+    if (!methodElement.getTypeParameters().isEmpty()) {
+      builder.addError(GENERIC_INJECT_METHOD, methodElement);
+    }
+
+    for (VariableElement parameter : methodElement.getParameters()) {
+      ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(parameter);
+      if (qualifiers.size() > 1) {
+        for (AnnotationMirror qualifier : qualifiers) {
+          builder.addError(MULTIPLE_QUALIFIERS, methodElement, qualifier);
+        }
+      }
+      if (FrameworkTypes.isProducerType(parameter.asType())) {
+        builder.addError(provisionMayNotDependOnProducerType(parameter.asType()), parameter);
+      }
+    }
+
+    return builder.build();
+  }
+
+  ValidationReport<TypeElement> validateType(TypeElement typeElement) {
+    // TODO(beder): This element might not be currently compiled, so this error message could be
+    // left in limbo. Find an appropriate way to display the error message in that case.
+    ValidationReport.Builder<TypeElement> builder = ValidationReport.about(typeElement);
+    for (VariableElement element : ElementFilter.fieldsIn(typeElement.getEnclosedElements())) {
+      if (MoreElements.isAnnotationPresent(element, Inject.class)) {
+        ValidationReport<VariableElement> report = validateField(element);
+        if (!report.isClean()) {
+          builder.addSubreport(report);
+        }
+      }
+    }
+    for (ExecutableElement element : ElementFilter.methodsIn(typeElement.getEnclosedElements())) {
+      if (MoreElements.isAnnotationPresent(element, Inject.class)) {
+        ValidationReport<ExecutableElement> report = validateMethod(element);
+        if (!report.isClean()) {
+          builder.addSubreport(report);
+        }
+      }
+    }
+    TypeMirror superclass = typeElement.getSuperclass();
+    if (!superclass.getKind().equals(TypeKind.NONE)) {
+      ValidationReport<TypeElement> report = validateType(MoreTypes.asTypeElement(superclass));
+      if (!report.isClean()) {
+        builder.addSubreport(report);
+      }
+    }
+    return builder.build();
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectedTypeValidator.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectedTypeValidator.java
deleted file mode 100644
index 1508db4b2..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectedTypeValidator.java
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * Copyright (C) 2015 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import com.google.auto.common.MoreElements;
-import com.google.auto.common.MoreTypes;
-import javax.inject.Inject;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.element.VariableElement;
-import javax.lang.model.type.TypeKind;
-import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.ElementFilter;
-
-/** Validates the {@code @Inject} fields and methods in a class and its superclasses. */
-final class MembersInjectedTypeValidator {
-  private final InjectFieldValidator fieldValidator;
-  private final InjectMethodValidator methodValidator;
-
-  MembersInjectedTypeValidator(
-      InjectFieldValidator fieldValidator, InjectMethodValidator methodValidator) {
-    this.fieldValidator = fieldValidator;
-    this.methodValidator = methodValidator;
-  }
-
-  ValidationReport<TypeElement> validate(TypeElement typeElement) {
-    // TODO(beder): This element might not be currently compiled, so this error message could be
-    // left in limbo. Find an appropriate way to display the error message in that case.
-    ValidationReport.Builder<TypeElement> builder = ValidationReport.about(typeElement);
-    for (VariableElement element : ElementFilter.fieldsIn(typeElement.getEnclosedElements())) {
-      if (MoreElements.isAnnotationPresent(element, Inject.class)) {
-        ValidationReport<VariableElement> report = fieldValidator.validate(element);
-        if (!report.isClean()) {
-          builder.addSubreport(report);
-        }
-      }
-    }
-    for (ExecutableElement element : ElementFilter.methodsIn(typeElement.getEnclosedElements())) {
-      if (MoreElements.isAnnotationPresent(element, Inject.class)) {
-        ValidationReport<ExecutableElement> report = methodValidator.validate(element);
-        if (!report.isClean()) {
-          builder.addSubreport(report);
-        }
-      }
-    }
-    TypeMirror superclass = typeElement.getSuperclass();
-    if (!superclass.getKind().equals(TypeKind.NONE)) {
-      ValidationReport<TypeElement> report = validate(MoreTypes.asTypeElement(superclass));
-      if (!report.isClean()) {
-        builder.addSubreport(report);
-      }
-    }
-    return builder.build();
-  }
-}
