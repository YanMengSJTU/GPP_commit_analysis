diff --git a/java/dagger/internal/codegen/Binding.java b/java/dagger/internal/codegen/Binding.java
index e475e6d61..c0f6b71e3 100644
--- a/java/dagger/internal/codegen/Binding.java
+++ b/java/dagger/internal/codegen/Binding.java
@@ -118,7 +118,7 @@ final FrameworkType frameworkType() {
    * union of {@link #explicitDependencies()} and {@link #implicitDependencies()}. This returns an
    * unmodifiable set.
    */
-  ImmutableSet<DependencyRequest> dependencies() {
+  final ImmutableSet<DependencyRequest> dependencies() {
     return dependencies.get();
   }
 
@@ -164,7 +164,7 @@ final FrameworkType frameworkType() {
   /* TODO(dpb): The stable-order postcondition is actually hard to verify in code for two equal
    * instances of Binding, because it really depends on the order of the binding's dependencies,
    * and two equal instances of Binding may have the same dependencies in a different order. */
-  ImmutableList<FrameworkDependency> frameworkDependencies() {
+  final ImmutableList<FrameworkDependency> frameworkDependencies() {
     return frameworkDependencies.get();
   }
 
@@ -212,7 +212,7 @@ static DependencyAssociation create(
    * multiple times if the {@linkplain Binding#unresolved() unresolved} binding requires it. If that
    * distinction is not important, the entries can be merged into a single mapping.
    */
-  ImmutableList<DependencyAssociation> dependencyAssociations() {
+  final ImmutableList<DependencyAssociation> dependencyAssociations() {
     return dependencyAssociations.get();
   }
 
@@ -236,7 +236,8 @@ static DependencyAssociation create(
    * Returns the mapping from each {@linkplain #dependencies dependency} to its associated {@link
    * FrameworkDependency}.
    */
-  ImmutableMap<DependencyRequest, FrameworkDependency> dependenciesToFrameworkDependenciesMap() {
+  final ImmutableMap<DependencyRequest, FrameworkDependency>
+      dependenciesToFrameworkDependenciesMap() {
     return frameworkDependenciesMap.get();
   }
 
diff --git a/java/dagger/internal/codegen/BindingDeclaration.java b/java/dagger/internal/codegen/BindingDeclaration.java
index c65d29180..c9520cde0 100644
--- a/java/dagger/internal/codegen/BindingDeclaration.java
+++ b/java/dagger/internal/codegen/BindingDeclaration.java
@@ -49,7 +49,7 @@
    * The type enclosing the {@link #bindingElement()}, or {@link Optional#empty()} if {@link
    * #bindingElement()} is empty.
    */
-  Optional<TypeElement> bindingTypeElement() {
+  final Optional<TypeElement> bindingTypeElement() {
     return bindingElement().map(DaggerElements::closestEnclosingTypeElement);
   }
   
diff --git a/java/dagger/internal/codegen/ContributionBinding.java b/java/dagger/internal/codegen/ContributionBinding.java
index c4119860a..0958bc8c0 100644
--- a/java/dagger/internal/codegen/ContributionBinding.java
+++ b/java/dagger/internal/codegen/ContributionBinding.java
@@ -68,7 +68,7 @@ final Object mapKey() {
   }
 
   /** If {@link #bindingElement()} is a method that returns a primitive type, returns that type. */
-  Optional<TypeMirror> contributedPrimitiveType() {
+  final Optional<TypeMirror> contributedPrimitiveType() {
     return bindingElement()
         .filter(bindingElement -> bindingElement instanceof ExecutableElement)
         .map(bindingElement -> MoreElements.asExecutable(bindingElement).getReturnType())
@@ -102,7 +102,7 @@ public final boolean isNullable() {
    *
    * <p>All other bindings use the {@link FactoryCreationStrategy#CLASS_CONSTRUCTOR} strategy.
    */
-  FactoryCreationStrategy factoryCreationStrategy() {
+  final FactoryCreationStrategy factoryCreationStrategy() {
     switch (kind()) {
       case DELEGATE:
         return DELEGATE;
