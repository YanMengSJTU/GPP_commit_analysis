diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index bdba18940..bb280b488 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -82,7 +82,7 @@ public synchronized void init(ProcessingEnvironment processingEnv) {
     DependencyRequest.Factory dependencyRequestFactory =
         new DependencyRequest.Factory(elements, types);
     ProvisionBinding.Factory provisionBindingFactory =
-        new ProvisionBinding.Factory(keyFactory, dependencyRequestFactory);
+        new ProvisionBinding.Factory(elements, types, keyFactory, dependencyRequestFactory);
     InjectionSite.Factory injectionSiteFactory =
         new InjectionSite.Factory(dependencyRequestFactory);
     ComponentDescriptor.Factory componentDescriptorFactory =
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
index 51655087d..f65289bed 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
@@ -26,6 +26,7 @@
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
 
+import com.google.auto.common.MoreElements;
 import com.google.common.base.Function;
 import com.google.common.base.Functions;
 import com.google.common.base.Joiner;
@@ -33,6 +34,7 @@
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableBiMap;
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSortedSet;
 import com.google.common.collect.Iterables;
@@ -57,7 +59,9 @@
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.Name;
+import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
@@ -108,11 +112,18 @@ void write(ClassName injectorClassName, JavaWriter writer, MembersInjectionBindi
     writer.emitPackage(injectedClassName.packageName());
 
     ImmutableSet<DependencyRequest> dependencies = binding.dependencySet();
+    Optional<TypeElement> supertype = supertype(binding.injectedType());
 
     List<ClassName> importsBuilder = new ArrayList<ClassName>();
     importsBuilder.addAll(collectImportsFromDependencies(injectorClassName, dependencies));
     importsBuilder.add(ClassName.fromClass(MembersInjector.class));
     importsBuilder.add(ClassName.fromClass(Generated.class));
+    if (supertype.isPresent()) {
+      ClassName supertypeClassName = ClassName.fromTypeElement(supertype.get());
+      if (!supertypeClassName.packageName().equals(injectorClassName.packageName())) {
+        importsBuilder.add(supertypeClassName);
+      }
+    }
     ImmutableSortedSet<String> imports = FluentIterable.from(importsBuilder)
         .transform(Functions.toStringFunction())
         .toSortedSet(Ordering.natural());
@@ -128,15 +139,16 @@ void write(ClassName injectorClassName, JavaWriter writer, MembersInjectionBindi
         .beginType(injectorClassName.simpleName(), "class", EnumSet.of(FINAL), null,
             membersInjectorType);
 
-
     final ImmutableBiMap<Key, String> providerNames =
         generateProviderNamesForDependencies(dependencies);
 
+    writeSupertypeInjectorField(writer, supertype);
+
     // Add the fields
     writeProviderFields(writer, providerNames);
 
     // Add the constructor
-    writeConstructor(writer, providerNames);
+    writeConstructor(writer, supertype, providerNames);
 
     // @Override public void injectMembers(Blah instance)
     writer.emitAnnotation(Override.class)
@@ -149,6 +161,10 @@ void write(ClassName injectorClassName, JavaWriter writer, MembersInjectionBindi
             "throw new NullPointerException(\"Cannot inject members into a null reference\")")
         .endControlFlow();
 
+    if (supertype.isPresent()) {
+      writer.emitStatement("supertypeInjector.injectMembers(instance)");
+    }
+
     for (InjectionSite injectionSite : binding.injectionSites()) {
       switch (injectionSite.kind()) {
         case FIELD:
@@ -179,6 +195,23 @@ void write(ClassName injectorClassName, JavaWriter writer, MembersInjectionBindi
     writer.endType();
   }
 
+  private Optional<TypeElement> supertype(TypeElement type) {
+    TypeMirror superclass = type.getSuperclass();
+    boolean nonObjectSuperclass = !types.isSameType(
+        elements.getTypeElement(Object.class.getCanonicalName()).asType(), superclass);
+    return nonObjectSuperclass
+        ? Optional.of(MoreElements.asType(types.asElement(superclass)))
+        : Optional.<TypeElement>absent();
+  }
+
+  private void writeSupertypeInjectorField(JavaWriter writer, Optional<TypeElement> supertype)
+      throws IOException {
+    if (supertype.isPresent()) {
+      writer.emitField(type(MembersInjector.class, supertype.get().getQualifiedName().toString()),
+          "supertypeInjector", EnumSet.of(PRIVATE, FINAL));
+    }
+  }
+
   private void writeProviderFields(JavaWriter writer, ImmutableBiMap<Key, String> providerNames)
       throws IOException {
     for (Entry<Key, String> providerEntry : providerNames.entrySet()) {
@@ -191,11 +224,21 @@ private void writeProviderFields(JavaWriter writer, ImmutableBiMap<Key, String>
     writer.emitEmptyLine();
   }
 
-  private void writeConstructor(JavaWriter writer, ImmutableBiMap<Key, String> providerNames)
-      throws IOException {
+  private void writeConstructor(JavaWriter writer, Optional<TypeElement> supertype,
+      ImmutableBiMap<Key, String> providerNames) throws IOException {
+    ImmutableMap.Builder<String, String> variableMapBuilder = ImmutableMap.builder();
+    if (supertype.isPresent()) {
+      variableMapBuilder.put("supertypeInjector",
+          type(MembersInjector.class, supertype.get().getQualifiedName().toString()));
+    }
+    variableMapBuilder.putAll(providersAsVariableMap(providerNames));
     writer.beginConstructor(EnumSet.noneOf(Modifier.class),
-        flattenVariableMap(providersAsVariableMap(providerNames)),
+        flattenVariableMap(variableMapBuilder.build()),
         ImmutableList.<String>of());
+    if (supertype.isPresent()) {
+      writer.emitStatement("assert %s != null", "supertypeInjector");
+      writer.emitStatement("this.%1$s = %1$s", "supertypeInjector");
+    }
     for (String providerName : providerNames.values()) {
       writer.emitStatement("assert %s != null", providerName);
       writer.emitStatement("this.%1$s = %1$s", providerName);
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index 5be75d01b..f017d866c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -43,6 +43,8 @@
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
 
 /**
  * A value object representing the mechanism by which a {@link Key} can be provided. New instances
@@ -102,10 +104,15 @@ static boolean isSetBindingCollection(Iterable<ProvisionBinding> bindings) {
   }
 
   static final class Factory {
+    private final Elements elements;
+    private final Types types;
     private final Key.Factory keyFactory;
     private final DependencyRequest.Factory dependencyRequestFactory;
 
-    Factory(Key.Factory keyFactory, DependencyRequest.Factory dependencyRequestFactory) {
+    Factory(Elements elements, Types types, Key.Factory keyFactory,
+        DependencyRequest.Factory dependencyRequestFactory) {
+      this.elements = elements;
+      this.types = types;
       this.keyFactory = keyFactory;
       this.dependencyRequestFactory = dependencyRequestFactory;
     }
@@ -130,7 +137,11 @@ ProvisionBinding forInjectConstructor(ExecutableElement constructorElement) {
     private static final ImmutableSet<ElementKind> MEMBER_KINDS =
         Sets.immutableEnumSet(METHOD, FIELD);
 
-    private static boolean requiresMemeberInjection(TypeElement type) {
+    private boolean requiresMemeberInjection(TypeElement type) {
+      if (!types.isSameType(elements.getTypeElement(Object.class.getCanonicalName()).asType(),
+          type.getSuperclass())) {
+        return true;
+      }
       for (Element enclosedElement : type.getEnclosedElements()) {
         if (MEMBER_KINDS.contains(enclosedElement.getKind())
             && (enclosedElement.getAnnotation(Inject.class) != null)) {
diff --git a/compiler/src/test/java/dagger/internal/codegen/InjectProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/InjectProcessorTest.java
index 329e5dc48..335d82a37 100644
--- a/compiler/src/test/java/dagger/internal/codegen/InjectProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/InjectProcessorTest.java
@@ -529,4 +529,96 @@
         .and()
         .generatesSources(expectedFactory, expectedMembersInjector);
   }
+
+  @Test public void supertypeRequiresMemberInjection() {
+    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "class A {}");
+    JavaFileObject bFile = JavaFileObjects.forSourceLines("test.B",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class B extends A {",
+        "  @Inject B() {}",
+        "}");
+    JavaFileObject expectedFactory = JavaFileObjects.forSourceLines(
+        "test.B$$Factory",
+        "package test;",
+        "",
+        "import dagger.Factory;",
+        "import dagger.MembersInjector;",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class B$$Factory implements Factory<B> {",
+        "",
+        "  private final MembersInjector<B> membersInjector;",
+        "",
+        "  public B$$Factory(MembersInjector<B> membersInjector) {",
+        "    assert membersInjector != null;",
+        "    this.membersInjector = membersInjector;",
+        "  }",
+        "",
+        "  @Override public B get() {",
+        "    B instance = new B();",
+        "    membersInjector.injectMembers(instance);",
+        "    return instance;",
+        "  }",
+        "}");
+    ASSERT.about(javaSources()).that(ImmutableList.of(aFile, bFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(expectedFactory);
+  }
+
+  @Test public void supertypeMembersInjection() {
+    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "class A {}");
+    JavaFileObject bFile = JavaFileObjects.forSourceLines("test.B",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class B extends A {",
+        "  @Inject String s;",
+        "}");
+    JavaFileObject expectedMembersInjector = JavaFileObjects.forSourceLines(
+        "test.AllInjections$$MembersInjector",
+        "package test;",
+        "",
+        "import dagger.MembersInjector;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "final class B$$MembersInjector ",
+        "    implements MembersInjector<B> {",
+        "",
+        "  private final MembersInjector<A> supertypeInjector;",
+        "  private final Provider<String> sProvider;",
+        "",
+        "  B$$MembersInjector(MembersInjector<A> supertypeInjector, Provider<String> sProvider) {",
+        "    assert supertypeInjector != null;",
+        "    this.supertypeInjector = supertypeInjector;",
+        "    assert sProvider != null;",
+        "    this.sProvider = sProvider;",
+        "  }",
+        "",
+        "  @Override public void injectMembers(B instance) {",
+        "    if (instance == null) {",
+        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
+        "    }",
+        "    supertypeInjector.injectMembers(instance);",
+        "    instance.s = sProvider.get();",
+        "  }",
+        "}");
+    ASSERT.about(javaSources()).that(ImmutableList.of(aFile, bFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(expectedMembersInjector);
+  }
 }
