diff --git a/compiler/pom.xml b/compiler/pom.xml
index 870a331dd..3411d1fc0 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -99,7 +99,7 @@
     <dependency>
       <groupId>com.squareup</groupId>
       <artifactId>javapoet</artifactId>
-      <version>1.6.1</version>
+      <version>1.7.0</version>
     </dependency>
     <dependency>
       <groupId>org.mockito</groupId>
diff --git a/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java b/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java
index ca99abaa3..8be16eb25 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java
@@ -25,10 +25,7 @@
 import test.sub.ContributionsModule;
 
 @Component(
-  modules = {
-    MultibindingModule.class,
-    ContributionsModule.class
-  },
+  modules = {MultibindingModule.class, MultibindsModule.class, ContributionsModule.class},
   dependencies = MultibindingDependency.class
 )
 interface MultibindingComponent {
diff --git a/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponentWithMultibindingsInterface.java b/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponentWithMultibindingsInterface.java
new file mode 100644
index 000000000..37f59b10b
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponentWithMultibindingsInterface.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import dagger.Component;
+import dagger.Multibindings;
+import test.sub.ContributionsModule;
+
+/**
+ * A component used to test multibindings that use {@link Multibindings @Multibindings}-annotated
+ * nested interfaces to declare multibindings.
+ */
+@Component(
+  modules = {
+    MultibindingModule.class,
+    MultibindingsInterfaceModule.class,
+    ContributionsModule.class
+  },
+  dependencies = MultibindingDependency.class
+)
+interface MultibindingComponentWithMultibindingsInterface extends MultibindingComponent {}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java b/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java
index 2519ba792..8562983a0 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java
@@ -16,9 +16,9 @@
 package test;
 
 import dagger.Module;
-import dagger.Multibindings;
 import dagger.Provides;
 import dagger.multibindings.ClassKey;
+import dagger.multibindings.ElementsIntoSet;
 import dagger.multibindings.IntKey;
 import dagger.multibindings.IntoMap;
 import dagger.multibindings.IntoSet;
@@ -33,10 +33,6 @@
 import javax.inject.Named;
 import javax.inject.Provider;
 
-import static dagger.Provides.Type.MAP;
-import static dagger.Provides.Type.SET;
-import static dagger.Provides.Type.SET_VALUES;
-
 @Module
 class MultibindingModule {
   @Provides
@@ -46,7 +42,8 @@ static String provideFooKey(@SuppressWarnings("unused") double doubleDependency)
     return "foo value";
   }
 
-  @Provides(type = MAP)
+  @Provides
+  @IntoMap
   @StringKey("foo @Provides(type)")
   static String provideFooProvidesTypeKey(@SuppressWarnings("unused") double doubleDependency) {
     return "foo @Provides(type) value";
@@ -85,12 +82,14 @@ static int provideSixToSet() {
     return 6;
   }
 
-  @Provides(type = SET)
+  @Provides
+  @IntoSet
   static int provideIntoSetWithProvidesType() {
     return -100;
   }
 
-  @Provides(type = SET_VALUES)
+  @Provides
+  @ElementsIntoSet
   static Set<Integer> provideElementsIntoSetWithProvidesType() {
     Set<Integer> set = new HashSet<>();
     set.add(-101);
@@ -252,29 +251,4 @@ static CharSequence mapContribution() {
   static CharSequence qualifiedMapContribution() {
     return "qualified foo value";
   }
-
-  interface EmptiesSupertype {
-    Set<Object> emptySet();
-
-    Map<String, Object> emptyMap();
-
-    Set<CharSequence> maybeEmptySet();
-
-    Map<String, CharSequence> maybeEmptyMap();
-  }
-
-  @Multibindings
-  interface Empties extends EmptiesSupertype {
-    @Named("complexQualifier")
-    Set<Object> emptyQualifiedSet();
-
-    @Named("complexQualifier")
-    Map<String, Object> emptyQualifiedMap();
-
-    @Named("complexQualifier")
-    Set<CharSequence> maybeEmptyQualifiedSet();
-
-    @Named("complexQualifier")
-    Map<String, CharSequence> maybeEmptyQualifiedMap();
-  }
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/MultibindingsInterfaceModule.java b/compiler/src/it/functional-tests/src/main/java/test/MultibindingsInterfaceModule.java
new file mode 100644
index 000000000..b9219ff1f
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/MultibindingsInterfaceModule.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import dagger.Module;
+import dagger.Multibindings;
+import java.util.Map;
+import java.util.Set;
+import javax.inject.Named;
+
+/**
+ * A module that uses a {@link Multibindings @Multibindings}-annotated nested interface to declare
+ * multibindings.
+ */
+@Module
+final class MultibindingsInterfaceModule {
+
+  interface EmptiesSupertype {
+    Set<Object> emptySet();
+
+    Map<String, Object> emptyMap();
+
+    Set<CharSequence> set();
+
+    Map<String, CharSequence> map();
+  }
+
+  @Multibindings
+  interface Empties extends EmptiesSupertype {
+    @Named("complexQualifier")
+    Set<Object> emptyQualifiedSet();
+
+    @Named("complexQualifier")
+    Map<String, Object> emptyQualifiedMap();
+
+    @Named("complexQualifier")
+    Set<CharSequence> qualifiedSet();
+
+    @Named("complexQualifier")
+    Map<String, CharSequence> qualifiedMap();
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/MultibindsModule.java b/compiler/src/it/functional-tests/src/main/java/test/MultibindsModule.java
new file mode 100644
index 000000000..8b193c96d
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/MultibindsModule.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import dagger.Module;
+import dagger.multibindings.Multibinds;
+import java.util.Map;
+import java.util.Set;
+import javax.inject.Named;
+
+/**
+ * A module that uses {@link Multibinds @Multibinds}-annotated abstract methods to declare
+ * multibindings.
+ */
+@Module
+abstract class MultibindsModule {
+
+  @Multibinds
+  abstract Set<Object> emptySet();
+
+  @Multibinds
+  abstract Map<String, Object> emptyMap();
+
+  @Multibinds
+  abstract Set<CharSequence> set();
+
+  @Multibinds
+  abstract Map<String, CharSequence> map();
+
+  @Multibinds
+  @Named("complexQualifier")
+  abstract Set<Object> emptyQualifiedSet();
+
+  @Multibinds
+  @Named("complexQualifier")
+  abstract Map<String, Object> emptyQualifiedMap();
+
+  @Multibinds
+  @Named("complexQualifier")
+  abstract Set<CharSequence> qualifiedSet();
+
+  @Multibinds
+  @Named("complexQualifier")
+  abstract Map<String, CharSequence> qualifiedMap();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/FooComponent.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/FooComponent.java
index 3c884159f..62da35da5 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/multipackage/FooComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/FooComponent.java
@@ -19,6 +19,7 @@
 import dagger.Component;
 import java.util.Set;
 import test.multipackage.a.AModule;
+import test.multipackage.a.UsesInaccessible;
 import test.multipackage.sub.FooChildComponent;
 
 /**
@@ -39,4 +40,6 @@
   Set<String> setOfString();
 
   FooChildComponent fooChildComponent();
+
+  UsesInaccessible usesInaccessible();
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AModule.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AModule.java
index 01208d919..cede7c36a 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AModule.java
@@ -18,7 +18,13 @@
 
 import dagger.Module;
 import dagger.Provides;
+import dagger.multibindings.ElementsIntoSet;
+import dagger.multibindings.IntoMap;
 import dagger.multibindings.IntoSet;
+import dagger.multibindings.StringKey;
+import java.util.HashSet;
+import java.util.Set;
+import javax.inject.Inject;
 
 @Module
 public final class AModule {
@@ -27,4 +33,28 @@
   static String provideString() {
     return "a";
   }
+
+  @Provides
+  @IntoSet
+  static Inaccessible provideInaccessible(Inaccessible inaccessible) {
+    return inaccessible;
+  }
+
+  @Provides
+  @ElementsIntoSet
+  static Set<Inaccessible> provideSetOfInaccessibles() {
+    return new HashSet<>();
+  }
+
+  @Provides
+  @IntoMap
+  @StringKey("inaccessible")
+  static Inaccessible provideInaccessibleToMap(Inaccessible inaccessible) {
+    return inaccessible;
+  }
+
+  static class Inaccessible {
+    @Inject Inaccessible() {}
+  }
+
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/UsesInaccessible.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/UsesInaccessible.java
new file mode 100644
index 000000000..8dab62c78
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/UsesInaccessible.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.multipackage.a;
+
+import java.util.Map;
+import java.util.Set;
+
+import javax.inject.Inject;
+
+import test.multipackage.a.AModule.Inaccessible;
+
+@SuppressWarnings("unused")
+public class UsesInaccessible {
+  @Inject
+  UsesInaccessible(
+      Inaccessible inaccessible,
+      Set<Inaccessible> inaccessibleSet,
+      Map<String, Inaccessible> inaccessibleMap) {}
+}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java b/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
index 33b9aed38..c17260ad9 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
@@ -14,6 +14,7 @@
 package test;
 
 import com.google.auto.value.AutoAnnotation;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import dagger.multibindings.ClassKey;
 import dagger.multibindings.StringKey;
@@ -21,25 +22,45 @@
 import java.math.BigInteger;
 import java.util.Map;
 import javax.inject.Provider;
-import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
 
 import static com.google.common.truth.Truth.assertThat;
 
-@RunWith(JUnit4.class)
+@RunWith(Parameterized.class)
 public class MultibindingTest {
-  private MultibindingComponent multibindingComponent;
 
-  @Before public void setUp() {
-    multibindingComponent = DaggerMultibindingComponent.builder()
-        .multibindingDependency(new MultibindingDependency() {
-          @Override public double doubleDependency() {
-            return 0.0;
+  private static final MultibindingDependency MULTIBINDING_DEPENDENCY =
+      new MultibindingDependency() {
+        @Override
+        public double doubleDependency() {
+          return 0.0;
+        }
+      };
+
+  @Parameters(name = "{0}")
+  public static Iterable<Object[]> parameters() {
+    return ImmutableList.copyOf(
+        new Object[][] {
+          {
+            DaggerMultibindingComponent.builder()
+                .multibindingDependency(MULTIBINDING_DEPENDENCY)
+                .build()
+          },
+          {
+            DaggerMultibindingComponentWithMultibindingsInterface.builder()
+                .multibindingDependency(MULTIBINDING_DEPENDENCY)
+                .build()
           }
-        })
-        .build();
+        });
+  }
+
+  private final MultibindingComponent multibindingComponent;
+
+  public MultibindingTest(MultibindingComponent multibindingComponent) {
+    this.multibindingComponent = multibindingComponent;
   }
 
   @Test public void map() {
diff --git a/compiler/src/it/tck/pom.xml b/compiler/src/it/tck/pom.xml
index 7b02a6ffd..3bf297956 100644
--- a/compiler/src/it/tck/pom.xml
+++ b/compiler/src/it/tck/pom.xml
@@ -61,6 +61,7 @@ limitations under the License.
           <compilerArgs>
             <arg>-Adagger.privateMemberValidation=warning</arg>
             <arg>-Adagger.staticMemberValidation=warning</arg>
+            <arg>-Adagger.ignorePrivateAndStaticInjectionForComponent=enabled</arg>
           </compilerArgs>
         </configuration>
       </plugin>
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 58f54084f..15845651c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -516,7 +516,14 @@ private FieldSpec addFrameworkField(
   }
 
   private boolean useRawType(ResolvedBindings resolvedBindings) {
-    Optional<String> bindingPackage = resolvedBindings.bindingPackage();
+    return useRawType(resolvedBindings.bindingPackage());
+  }
+
+  private boolean useRawType(Binding binding) {
+    return useRawType(binding.bindingPackage());
+  }
+
+  private boolean useRawType(Optional<String> bindingPackage) {
     return bindingPackage.isPresent() && !bindingPackage.get().equals(name.packageName());
   }
 
@@ -778,6 +785,8 @@ private void initializeFrameworkTypes() {
 
   private Optional<CodeBlock> initializeContributionBinding(BindingKey bindingKey) {
     ContributionBinding binding = graph.resolvedBindings().get(bindingKey).contributionBinding();
+    /* We have some duplication in the branches below b/c initializeDeferredDependencies must be
+     * called before we get the code block that initializes the member. */
     switch (binding.factoryCreationStrategy()) {
       case DELEGATE:
         CodeBlock delegatingCodeBlock = CodeBlock.of(
@@ -787,11 +796,14 @@ private void initializeFrameworkTypes() {
                 Iterables.getOnlyElement(binding.dependencies()).bindingKey())
                     .getExpressionFor(name));
         return Optional.of(
-            initializeMember(
-                bindingKey,
-                binding.scope().isPresent()
-                    ? decorateForScope(delegatingCodeBlock, binding.scope().get())
-                    : delegatingCodeBlock));
+            CodeBlocks.concat(
+                ImmutableList.of(
+                    initializeDeferredDependencies(binding),
+                    initializeMember(
+                        bindingKey,
+                        binding.scope().isPresent()
+                            ? decorateForScope(delegatingCodeBlock, binding.scope().get())
+                            : delegatingCodeBlock))));
       case ENUM_INSTANCE:
         if (!binding.scope().isPresent()) {
           return Optional.absent();
@@ -1084,8 +1096,7 @@ private CodeBlock initializeMembersInjectorForBinding(MembersInjectionBinding bi
   /**
    * The expressions that represent factory arguments for the dependencies of a binding.
    */
-  private ImmutableList<CodeBlock> getDependencyArguments(
-      Binding binding) {
+  private ImmutableList<CodeBlock> getDependencyArguments(Binding binding) {
     ImmutableList.Builder<CodeBlock> parameters = ImmutableList.builder();
     for (FrameworkDependency frameworkDependency : frameworkDependenciesForBinding(binding)) {
       parameters.add(getDependencyArgument(frameworkDependency));
@@ -1108,10 +1119,49 @@ private CodeBlock getDependencyArgument(FrameworkDependency frameworkDependency)
   }
 
   private CodeBlock initializeFactoryForSetMultibinding(ContributionBinding binding) {
-    return CodeBlock.of(
-        "$T.create($L)",
-        setFactoryClassName(binding.bindingType(), binding.key()),
-        makeParametersCodeBlock(getDependencyArguments(binding)));
+    CodeBlock.Builder builder =
+        CodeBlock.builder().add("$T.", setFactoryClassName(binding.bindingType(), binding.key()));
+    boolean useRawTypes = useRawType(binding);
+    if (!useRawTypes) {
+      SetType setType = SetType.from(binding.key().type());
+      builder.add(
+          "<$T>",
+          setType.elementsAreTypeOf(Produced.class)
+              ? setType.unwrappedElementType(Produced.class)
+              : setType.elementType());
+    }
+    int individualProviders = 0;
+    int setProviders = 0;
+    CodeBlock.Builder builderMethodCalls = CodeBlock.builder();
+    for (FrameworkDependency frameworkDependency : frameworkDependenciesForBinding(binding)) {
+      ContributionType contributionType =
+          graph.resolvedBindings().get(frameworkDependency.bindingKey()).contributionType();
+      String methodName;
+      switch (contributionType) {
+        case SET:
+          individualProviders++;
+          methodName = "add";
+          break;
+        case SET_VALUES:
+          setProviders++;
+          methodName = "addSet";
+          break;
+        default:
+          throw new AssertionError(frameworkDependency + " is not a set multibinding");
+      }
+
+      builderMethodCalls.add(
+          ".$L$L($L)",
+          methodName,
+          frameworkDependency.frameworkClass().getSimpleName(),
+          potentiallyCast(
+              useRawTypes,
+              frameworkDependency.frameworkClass(),
+              getDependencyArgument(frameworkDependency)));
+    }
+    builder.add("builder($L, $L)", individualProviders, setProviders);
+    builder.add(builderMethodCalls.build());
+    return builder.add(".build()").build();
   }
 
   private CodeBlock initializeFactoryForMapMultibinding(ContributionBinding binding) {
@@ -1120,14 +1170,15 @@ private CodeBlock initializeFactoryForMapMultibinding(ContributionBinding bindin
 
     ImmutableList.Builder<CodeBlock> codeBlocks = ImmutableList.builder();
     MapType mapType = MapType.from(binding.key().type());
-    codeBlocks.add(
-        CodeBlock.of(
-            "$T.<$T, $T>builder($L)",
-            frameworkMapFactoryClassName(binding.bindingType()),
-            TypeName.get(mapType.keyType()),
-            TypeName.get(
-                mapType.unwrappedValueType(binding.bindingType().frameworkClass())),
-            frameworkDependencies.size()));
+    CodeBlock.Builder builderCall =
+        CodeBlock.builder().add("$T.", frameworkMapFactoryClassName(binding.bindingType()));
+    boolean useRawTypes = useRawType(binding);
+    if (!useRawTypes) {
+      builderCall.add("<$T, $T>", TypeName.get(mapType.keyType()),
+          TypeName.get(mapType.unwrappedValueType(binding.bindingType().frameworkClass())));
+    }
+    builderCall.add("builder($L)", frameworkDependencies.size());
+    codeBlocks.add(builderCall.build());
 
     for (FrameworkDependency frameworkDependency : frameworkDependencies) {
       BindingKey bindingKey = frameworkDependency.bindingKey();
@@ -1136,14 +1187,24 @@ private CodeBlock initializeFactoryForMapMultibinding(ContributionBinding bindin
       codeBlocks.add(
           CodeBlock.of(
               ".put($L, $L)",
-              getMapKeyExpression(contributionBinding.bindingElement()),
-              getDependencyArgument(frameworkDependency)));
+              getMapKeyExpression(contributionBinding.mapKey().get()),
+              potentiallyCast(
+                  useRawTypes,
+                  frameworkDependency.frameworkClass(),
+                  getDependencyArgument(frameworkDependency))));
     }
     codeBlocks.add(CodeBlock.of(".build()"));
 
     return CodeBlocks.concat(codeBlocks.build());
   }
 
+  private CodeBlock potentiallyCast(boolean shouldCast, Class<?> classToCast, CodeBlock notCasted) {
+    if (!shouldCast) {
+      return notCasted;
+    }
+    return CodeBlock.of("($T) $L", classToCast, notCasted);
+  }
+
   private static String simpleVariableName(TypeElement typeElement) {
     return UPPER_CAMEL.to(LOWER_CAMEL, typeElement.getSimpleName().toString());
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Accessibility.java b/compiler/src/main/java/dagger/internal/codegen/Accessibility.java
index d8c5d2369..0ce9230b0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Accessibility.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Accessibility.java
@@ -15,6 +15,7 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreElements;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
@@ -141,6 +142,12 @@ static boolean isElementAccessibleFrom(Element element, final String packageName
     return element.accept(new ElementAccessibilityVisitor(packageName), null);
   }
 
+  /** Returns true if the given element can be referenced from other code in its own package. */
+  static boolean isElementAccessibleFromOwnPackage(Element element) {
+    return isElementAccessibleFrom(
+        element, MoreElements.getPackage(element).getQualifiedName().toString());
+  }
+
   private static final class ElementAccessibilityVisitor
       extends SimpleElementVisitor6<Boolean, Void> {
     final String packageName;
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index 8d91101d7..b27fac745 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -490,20 +490,25 @@ ResolvedBindings lookUpBindings(DependencyRequest request) {
       }
 
       /**
-       * Returns the component that "owns" {@code binding}.
+       * Returns the component that should contain the framework field for {@code binding}.
        *
-       * <p>If {@code binding} is bound in an ancestor component, resolves {@code request} in this
-       * component's parent. Returns the ancestor component in which it is bound, unless
-       * {@code binding} depends on local multibindings, in which case returns this component.
+       * <p>If {@code binding} is either not bound in an ancestor component or depends on
+       * multibinding contributions in this component, returns this component.
        *
-       * <p>If {@code binding} is not bound in an ancestor component, simply returns this component.
+       * <p>Otherwise, resolves {@code request} in this component's parent in order to resolve any
+       * multibinding contributions in the parent, and returns the parent-resolved
+       * {@link ResolvedBindings#owningComponent(ContributionBinding)}.
        */
       private ComponentDescriptor getOwningComponent(
           DependencyRequest request, ContributionBinding binding) {
-        return isResolvedInParent(request, binding)
-                && !new MultibindingDependencies().dependsOnLocalMultibindings(binding)
-            ? getOwningResolver(binding).get().componentDescriptor
-            : componentDescriptor;
+        if (isResolvedInParent(request, binding)
+            && !new MultibindingDependencies().dependsOnLocalMultibindings(binding)) {
+          ResolvedBindings parentResolvedBindings =
+              parentResolver.get().resolvedBindings.get(request.bindingKey());
+          return parentResolvedBindings.owningComponent(binding);
+        } else {
+          return componentDescriptor;
+        }
       }
 
       /**
@@ -675,18 +680,19 @@ void resolve(DependencyRequest request) {
          * 2. If there are any explicit bindings in this component, they may conflict with those in
          *    the supercomponent, so resolve them here so that conflicts can be caught.
          */
-        if (getPreviouslyResolvedBindings(bindingKey).isPresent()
-            && !new MultibindingDependencies().dependsOnLocalMultibindings(bindingKey)
-            && getExplicitBindings(bindingKey.key()).isEmpty()) {
+        if (getPreviouslyResolvedBindings(bindingKey).isPresent()) {
           /* Resolve in the parent in case there are multibinding contributions or conflicts in some
            * component between this one and the previously-resolved one. */
           parentResolver.get().resolve(request);
-          /* Cache the inherited parent component's bindings in case resolving at the parent found
-           * bindings in some component between this one and the previously-resolved one. */
-          ResolvedBindings inheritedBindings =
-              getPreviouslyResolvedBindings(bindingKey).get().asInheritedIn(componentDescriptor);
-          resolvedBindings.put(bindingKey, inheritedBindings);
-          return;
+          if (!new MultibindingDependencies().dependsOnLocalMultibindings(bindingKey)
+              && getExplicitBindings(bindingKey.key()).isEmpty()) {
+            /* Cache the inherited parent component's bindings in case resolving at the parent found
+             * bindings in some component between this one and the previously-resolved one. */
+            ResolvedBindings inheritedBindings =
+                getPreviouslyResolvedBindings(bindingKey).get().asInheritedIn(componentDescriptor);
+            resolvedBindings.put(bindingKey, inheritedBindings);
+            return;
+          }
         }
 
         cycleStack.push(bindingKey);
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 3aadd6a3d..f2a96204f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -84,6 +84,7 @@
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
 import static dagger.internal.codegen.ContributionBinding.indexMapBindingsByAnnotationType;
 import static dagger.internal.codegen.ContributionBinding.indexMapBindingsByMapKey;
+import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
 import static dagger.internal.codegen.ContributionBinding.Kind.IS_SYNTHETIC_KIND;
 import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MULTIBOUND_MAP;
 import static dagger.internal.codegen.ContributionType.indexByContributionType;
@@ -104,11 +105,13 @@
 import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
 import static javax.tools.Diagnostic.Kind.ERROR;
 
-public class BindingGraphValidator {
+/** Reports errors in the shape of the binding graph. */
+final class BindingGraphValidator {
 
   private final Elements elements;
   private final Types types;
   private final CompilerOptions compilerOptions;
+  private final InjectValidator injectValidator;
   private final InjectBindingRegistry injectBindingRegistry;
   private final BindingDeclarationFormatter bindingDeclarationFormatter;
   private final MethodSignatureFormatter methodSignatureFormatter;
@@ -120,6 +123,7 @@
       Elements elements,
       Types types,
       CompilerOptions compilerOptions,
+      InjectValidator injectValidator,
       InjectBindingRegistry injectBindingRegistry,
       BindingDeclarationFormatter bindingDeclarationFormatter,
       MethodSignatureFormatter methodSignatureFormatter,
@@ -129,6 +133,7 @@
     this.elements = elements;
     this.types = types;
     this.compilerOptions = compilerOptions;
+    this.injectValidator = injectValidator;
     this.injectBindingRegistry = injectBindingRegistry;
     this.bindingDeclarationFormatter = bindingDeclarationFormatter;
     this.methodSignatureFormatter = methodSignatureFormatter;
@@ -139,7 +144,7 @@
 
   /** A dependency path from an entry point. */
   static final class DependencyPath {
-    final Deque<ResolvedRequest> requestPath = new ArrayDeque<>();
+    private final Deque<ResolvedRequest> requestPath = new ArrayDeque<>();
     private final LinkedHashMultiset<BindingKey> keyPath = LinkedHashMultiset.create();
     private final Set<DependencyRequest> resolvedRequests = new HashSet<>();
 
@@ -220,12 +225,19 @@ int size() {
       return requestPath.size();
     }
 
-    /** The nonsynthetic dependency requests in this path, starting with the entry point. */
-    FluentIterable<DependencyRequest> nonsyntheticRequests() {
-      return FluentIterable.from(requestPath)
-          .filter(Predicates.not(new PreviousBindingWasSynthetic()))
-          .transform(REQUEST_FROM_RESOLVED_REQUEST);
+    /** The dependency requests in this path, starting with the entry point. */
+    FluentIterable<DependencyRequest> requests() {
+      return FluentIterable.from(requestPath).transform(REQUEST_FROM_RESOLVED_REQUEST);
     }
+
+    private static final Function<ResolvedRequest, DependencyRequest>
+        REQUEST_FROM_RESOLVED_REQUEST =
+            new Function<ResolvedRequest, DependencyRequest>() {
+              @Override
+              public DependencyRequest apply(ResolvedRequest resolvedRequest) {
+                return resolvedRequest.request();
+              }
+            };
   }
 
   private final class Validation {
@@ -385,6 +397,17 @@ private void validateResolvedBinding(DependencyPath path) {
             reportDuplicateBindings(path);
             return;
           }
+          ContributionBinding binding =
+              Iterables.getOnlyElement(resolvedBinding.contributionBindings());
+          if (binding.bindingKind().equals(INJECTION)) {
+            TypeMirror type = resolvedBinding.bindingKey().key().type();
+            ValidationReport<TypeElement> report =
+                injectValidator.validateType(MoreTypes.asTypeElement(type));
+            if (!report.isClean()) {
+              reportBuilder.addSubreport(report);
+              return;
+            }
+          }
           ContributionBinding contributionBinding = resolvedBinding.contributionBinding();
           if (contributionBinding.bindingType().equals(BindingType.PRODUCTION)
               && doesPathRequireProvisionOnly(path)) {
@@ -1289,24 +1312,4 @@ static ResolvedRequest create(DependencyRequest request, BindingGraph graph) {
               : resolvedBindings);
     }
   }
-
-  private static final Function<ResolvedRequest, DependencyRequest> REQUEST_FROM_RESOLVED_REQUEST =
-      new Function<ResolvedRequest, DependencyRequest>() {
-        @Override
-        public DependencyRequest apply(ResolvedRequest resolvedRequest) {
-          return resolvedRequest.request();
-        }
-      };
-
-  private static final class PreviousBindingWasSynthetic implements Predicate<ResolvedRequest> {
-    private ResolvedBindings previousBinding;
-
-    @Override
-    public boolean apply(ResolvedRequest resolvedRequest) {
-      boolean previousBindingWasSynthetic =
-          previousBinding != null && previousBinding.isSyntheticContribution();
-      previousBinding = resolvedRequest.binding();
-      return previousBindingWasSynthetic;
-    }
-  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingMethodValidator.java
new file mode 100644
index 000000000..3d4837705
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingMethodValidator.java
@@ -0,0 +1,476 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.base.Function;
+import com.google.common.base.Joiner;
+import com.google.common.cache.CacheBuilder;
+import com.google.common.cache.CacheLoader;
+import com.google.common.cache.LoadingCache;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Lists;
+import dagger.MapKey;
+import dagger.Provides;
+import dagger.multibindings.ElementsIntoSet;
+import dagger.multibindings.IntoMap;
+import dagger.producers.Produces;
+import java.lang.annotation.Annotation;
+import javax.annotation.OverridingMethodsMustInvokeSuper;
+import javax.annotation.processing.Messager;
+import javax.inject.Qualifier;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+
+import static com.google.auto.common.MoreElements.getAnnotationMirror;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_ABSTRACT;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MULTIPLE_QUALIFIERS;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_RETURN_A_VALUE;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_ABSTRACT;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_IN_MODULE;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_MAP_HAS_MAP_KEY;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_PRIVATE;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_RETURN_TYPE;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_SET_VALUES_RAW_SET;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_SET_VALUES_RETURN_SET;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_THROWS;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_THROWS_ANY;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_THROWS_CHECKED;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_TYPE_PARAMETER;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_MULTIPLE_MAP_KEY;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_NO_MAP_KEY;
+import static dagger.internal.codegen.ErrorMessages.MULTIBINDING_ANNOTATION_CONFLICTS_WITH_BINDING_ANNOTATION_ENUM;
+import static dagger.internal.codegen.ErrorMessages.MULTIPLE_MULTIBINDING_ANNOTATIONS_ON_METHOD;
+import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
+import static dagger.internal.codegen.MapKeys.getMapKeys;
+import static dagger.internal.codegen.Util.isAnyAnnotationPresent;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.type.TypeKind.ARRAY;
+import static javax.lang.model.type.TypeKind.DECLARED;
+import static javax.lang.model.type.TypeKind.TYPEVAR;
+import static javax.lang.model.type.TypeKind.VOID;
+
+/** A validator for methods that represent binding declarations. */
+abstract class BindingMethodValidator {
+
+  private final Elements elements;
+  private final Types types;
+  private final Class<? extends Annotation> methodAnnotation;
+  private final ImmutableSet<Class<? extends Annotation>> enclosingElementAnnotations;
+  private final Abstractness abstractness;
+  private final ExceptionSuperclass exceptionSuperclass;
+  private final LoadingCache<ExecutableElement, ValidationReport<ExecutableElement>> cache =
+      CacheBuilder.newBuilder()
+          .build(
+              new CacheLoader<ExecutableElement, ValidationReport<ExecutableElement>>() {
+                @Override
+                public ValidationReport<ExecutableElement> load(ExecutableElement method) {
+                  ValidationReport.Builder<ExecutableElement> builder =
+                      ValidationReport.about(method);
+                  checkMethod(builder);
+                  return builder.build();
+                }
+              });
+
+  /**
+   * Creates a validator object.
+   *
+   * @param methodAnnotation the annotation on a method that identifies it as a binding method
+   * @param enclosingElementAnnotation the method must be declared in a class or interface annotated
+   *     with this annotation
+   */
+  protected BindingMethodValidator(
+      Elements elements,
+      Types types,
+      Class<? extends Annotation> methodAnnotation,
+      Class<? extends Annotation> enclosingElementAnnotation,
+      Abstractness abstractness,
+      ExceptionSuperclass exceptionSuperclass) {
+    this(
+        elements,
+        types,
+        methodAnnotation,
+        ImmutableSet.of(enclosingElementAnnotation),
+        abstractness,
+        exceptionSuperclass);
+  }
+
+  /**
+   * Creates a validator object.
+   *
+   * @param methodAnnotation the annotation on a method that identifies it as a binding method
+   * @param enclosingElementAnnotations the method must be declared in a class or interface
+   *     annotated with one of these annotations
+   */
+  protected BindingMethodValidator(
+      Elements elements,
+      Types types,
+      Class<? extends Annotation> methodAnnotation,
+      Iterable<? extends Class<? extends Annotation>> enclosingElementAnnotations,
+      Abstractness abstractness,
+      ExceptionSuperclass exceptionSuperclass) {
+    this.elements = elements;
+    this.types = types;
+    this.methodAnnotation = methodAnnotation;
+    this.enclosingElementAnnotations =
+        ImmutableSet.<Class<? extends Annotation>>copyOf(enclosingElementAnnotations);
+    this.abstractness = abstractness;
+    this.exceptionSuperclass = exceptionSuperclass;
+  }
+  
+  /** The annotation that identifies methods validated by this object. */
+  Class<? extends Annotation> methodAnnotation() {
+    return methodAnnotation;
+  }
+
+  /** Returns a {@link ValidationReport} for {@code method}. */
+  final ValidationReport<ExecutableElement> validate(ExecutableElement method) {
+    return cache.getUnchecked(method);
+  }
+
+  /** Prints validation reports to {@code messager}, and returns valid methods. */
+  final ImmutableSet<ExecutableElement> validate(
+      Messager messager, Iterable<? extends ExecutableElement> methods) {
+    ImmutableSet.Builder<ExecutableElement> validMethods = ImmutableSet.builder();
+    for (ExecutableElement method : methods) {
+      ValidationReport<ExecutableElement> report = validate(method);
+      report.printMessagesTo(messager);
+      if (report.isClean()) {
+        validMethods.add(method);
+      }
+    }
+    return validMethods.build();
+  }
+
+  /** Checks the method for validity. Adds errors to {@code builder}. */
+  @OverridingMethodsMustInvokeSuper
+  protected void checkMethod(ValidationReport.Builder<ExecutableElement> builder) {
+    checkEnclosingElement(builder);
+    checkTypeParameters(builder);
+    checkNotPrivate(builder);
+    checkAbstractness(builder);
+    checkReturnType(builder);
+    checkThrows(builder);
+    checkQualifiers(builder);
+    checkMapKeys(builder);
+    checkMultibindings(builder);
+  }
+
+  /**
+   * Adds an error if the method is not declared in a class or interface annotated with one of the
+   * {@link #enclosingElementAnnotations}.
+   */
+  // TODO(b/28861722): Make private once @Multibindings is deleted.
+  protected void checkEnclosingElement(ValidationReport.Builder<ExecutableElement> builder) {
+    if (!isAnyAnnotationPresent(
+        builder.getSubject().getEnclosingElement(), enclosingElementAnnotations)) {
+      builder.addError(
+          formatErrorMessage(
+              BINDING_METHOD_NOT_IN_MODULE,
+              FluentIterable.from(enclosingElementAnnotations)
+                  .transform(
+                      new Function<Class<?>, String>() {
+                        @Override
+                        public String apply(Class<?> clazz) {
+                          return clazz.getSimpleName();
+                        }
+                      })
+                  .join(Joiner.on(" or @"))));
+    }
+  }
+
+  /** Adds an error if the method is generic. */
+  private void checkTypeParameters(ValidationReport.Builder<ExecutableElement> builder) {
+    if (!builder.getSubject().getTypeParameters().isEmpty()) {
+      builder.addError(formatErrorMessage(BINDING_METHOD_TYPE_PARAMETER));
+    }
+  }
+
+  /** Adds an error if the method is private. */
+  private void checkNotPrivate(ValidationReport.Builder<ExecutableElement> builder) {
+    if (builder.getSubject().getModifiers().contains(PRIVATE)) {
+      builder.addError(formatErrorMessage(BINDING_METHOD_PRIVATE));
+    }
+  }
+
+  /** Adds an error if the method is abstract but must not be, or is not and must be. */
+  private void checkAbstractness(ValidationReport.Builder<ExecutableElement> builder) {
+    boolean isAbstract = builder.getSubject().getModifiers().contains(ABSTRACT);
+    switch (abstractness) {
+      case MUST_BE_ABSTRACT:
+        if (!isAbstract) {
+          builder.addError(formatErrorMessage(BINDING_METHOD_NOT_ABSTRACT));
+        }
+        break;
+
+      case MUST_BE_CONCRETE:
+        if (isAbstract) {
+          builder.addError(formatErrorMessage(BINDING_METHOD_ABSTRACT));
+        }
+        break;
+
+      default:
+        throw new AssertionError();
+    }
+  }
+
+  /**
+   * Adds an error if the return type is not appropriate for the method.
+   *
+   * <p>Adds an error if the method doesn't return a primitive, array, declared type, or type
+   * variable.
+   *
+   * <p>If the method is not a multibinding contribution, adds an error if it returns a framework
+   * type.
+   *
+   * <p>If the method is a {@link ElementsIntoSet @ElementsIntoSet} or {@code SET_VALUES}
+   * contribution, adds an error if the method doesn't return a {@code Set<T>} for some {@code T}
+   */
+  protected void checkReturnType(ValidationReport.Builder<ExecutableElement> builder) {
+    switch (ContributionType.fromBindingMethod(builder.getSubject())) {
+      case UNIQUE:
+        /* Validate that a unique binding is not attempting to bind a framework type. This
+         * validation is only appropriate for unique bindings because multibindings may collect
+         * framework types.  E.g. Set<Provider<Foo>> is perfectly reasonable. */
+        checkFrameworkType(builder);
+        // fall through
+
+      case SET:
+      case MAP:
+        checkKeyType(builder, builder.getSubject().getReturnType());
+        break;
+
+      case SET_VALUES:
+        checkSetValuesType(builder);
+        break;
+
+      default:
+        throw new AssertionError();
+    }
+  }
+
+  /**
+   * Adds an error if {@code keyType} is not a primitive, declared type, array, or type variable.
+   */
+  protected void checkKeyType(
+      ValidationReport.Builder<ExecutableElement> builder, TypeMirror keyType) {
+    TypeKind kind = keyType.getKind();
+    if (kind.equals(VOID)) {
+      builder.addError(formatErrorMessage(BINDING_METHOD_MUST_RETURN_A_VALUE));
+    } else if (!(kind.isPrimitive()
+        || kind.equals(DECLARED)
+        || kind.equals(ARRAY)
+        || kind.equals(TYPEVAR))) {
+      builder.addError(badReturnTypeMessage());
+    }
+  }
+
+  /** The error message when a non-{@code void} binding method returns a bad type. */
+  protected String badReturnTypeMessage() {
+    return formatErrorMessage(BINDING_METHOD_RETURN_TYPE);
+  }
+
+  /**
+   * Adds an error if an {@link ElementsIntoSet @ElementsIntoSet} or {@code SET_VALUES} method
+   * doesn't return a {@code Set<T>} for a reasonable {@code T}.
+   */
+  // TODO(gak): should we allow "covariant return" for set values?
+  protected void checkSetValuesType(ValidationReport.Builder<ExecutableElement> builder) {
+    checkSetValuesType(builder, builder.getSubject().getReturnType());
+  }
+
+  /** Adds an error if {@code type} is not a a {@code Set<T>} for a reasonable {@code T}. */
+  protected final void checkSetValuesType(
+      ValidationReport.Builder<ExecutableElement> builder, TypeMirror type) {
+    if (!SetType.isSet(type)) {
+      builder.addError(badSetValuesTypeMessage());
+    } else {
+      SetType setType = SetType.from(type);
+      if (setType.isRawType()) {
+        builder.addError(formatErrorMessage(BINDING_METHOD_SET_VALUES_RAW_SET));
+      } else {
+        checkKeyType(builder, setType.elementType());
+      }
+    }
+  }
+
+  /**
+   * Adds an error if the method declares throws anything but an {@link Error} or an appropriate
+   * subtype of {@link Exception}.
+   */
+  private void checkThrows(ValidationReport.Builder<ExecutableElement> builder) {
+    exceptionSuperclass.checkThrows(this, builder);
+  }
+
+  /** Adds an error if the method has more than one {@linkplain Qualifier qualifier} annotation. */
+  protected void checkQualifiers(ValidationReport.Builder<ExecutableElement> builder) {
+    ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(builder.getSubject());
+    if (qualifiers.size() > 1) {
+      for (AnnotationMirror qualifier : qualifiers) {
+        builder.addError(BINDING_METHOD_MULTIPLE_QUALIFIERS, builder.getSubject(), qualifier);
+      }
+    }
+  }
+
+  /**
+   * Adds an error if an {@link IntoMap @IntoMap} or {@code MAP} method doesn't have exactly one
+   * {@link MapKey @MapKey} annotation, or if a method that is neither {@link IntoMap @IntoMap} nor
+   * {@code MAP} has any.
+   */
+  protected void checkMapKeys(ValidationReport.Builder<ExecutableElement> builder) {
+    ImmutableSet<? extends AnnotationMirror> mapKeys = getMapKeys(builder.getSubject());
+    if (ContributionType.fromBindingMethod(builder.getSubject()).equals(ContributionType.MAP)) {
+      switch (mapKeys.size()) {
+        case 0:
+          builder.addError(formatErrorMessage(BINDING_METHOD_WITH_NO_MAP_KEY));
+          break;
+        case 1:
+          break;
+        default:
+          builder.addError(formatErrorMessage(BINDING_METHOD_WITH_MULTIPLE_MAP_KEY));
+          break;
+      }
+    } else if (!mapKeys.isEmpty()) {
+      builder.addError(formatErrorMessage(BINDING_METHOD_NOT_MAP_HAS_MAP_KEY));
+    }
+  }
+
+  /**
+   * Adds errors if the method has more than one {@linkplain MultibindingAnnotations multibinding
+   * annotation} or if it has a multibinding annotation and its {@link Provides} or {@link Produces}
+   * annotation has a {@code type} parameter.
+   */
+  protected void checkMultibindings(ValidationReport.Builder<ExecutableElement> builder) {
+    ImmutableSet<AnnotationMirror> multibindingAnnotations =
+        MultibindingAnnotations.forMethod(builder.getSubject());
+    if (multibindingAnnotations.size() > 1) {
+      for (AnnotationMirror annotation : multibindingAnnotations) {
+        builder.addError(
+            formatErrorMessage(MULTIPLE_MULTIBINDING_ANNOTATIONS_ON_METHOD),
+            builder.getSubject(),
+            annotation);
+      }
+    }
+
+    AnnotationMirror bindingAnnotationMirror =
+        getAnnotationMirror(builder.getSubject(), methodAnnotation).get();
+    boolean usesProvidesType = false;
+    for (ExecutableElement member : bindingAnnotationMirror.getElementValues().keySet()) {
+      usesProvidesType |= member.getSimpleName().contentEquals("type");
+    }
+    if (usesProvidesType && !multibindingAnnotations.isEmpty()) {
+      builder.addError(
+          formatErrorMessage(MULTIBINDING_ANNOTATION_CONFLICTS_WITH_BINDING_ANNOTATION_ENUM),
+          builder.getSubject());
+    }
+  }
+
+  /** Adds an error if the method returns a {@linkplain FrameworkTypes framework type}. */
+  protected void checkFrameworkType(ValidationReport.Builder<ExecutableElement> builder) {
+    if (FrameworkTypes.isFrameworkType(builder.getSubject().getReturnType())) {
+      builder.addError(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES));
+    }
+  }
+
+  /**
+   * Formats an error message whose first {@code %s} parameter should be replaced with the simple
+   * name of the method annotation.
+   */
+  protected String formatErrorMessage(String format, Object... otherParameters) {
+    return otherParameters.length == 0
+        ? String.format(format, methodAnnotation.getSimpleName())
+        : String.format(
+            format, Lists.asList(methodAnnotation.getSimpleName(), otherParameters).toArray());
+  }
+
+  /**
+   * The error message when an {@link ElementsIntoSet @ElementsIntoSet} or {@code SET_VALUES} method
+   * returns a bad type.
+   */
+  protected String badSetValuesTypeMessage() {
+    return formatErrorMessage(BINDING_METHOD_SET_VALUES_RETURN_SET);
+  }
+
+  /** An abstract/concrete restriction on methods. */
+  protected enum Abstractness {
+    MUST_BE_ABSTRACT,
+    MUST_BE_CONCRETE
+  }
+
+  /**
+   * The exception class that all {@code throws}-declared throwables must extend, other than
+   * {@link Error}.
+   */
+  protected enum ExceptionSuperclass {
+    /** Methods may not declare any throwable types. */
+    NONE {
+      @Override
+      protected void checkThrows(
+          BindingMethodValidator validator, ValidationReport.Builder<ExecutableElement> builder) {
+        if (!builder.getSubject().getThrownTypes().isEmpty()) {
+          builder.addError(validator.formatErrorMessage(BINDING_METHOD_THROWS_ANY));
+          return;
+        }
+      }
+    },
+
+    /** Methods may throw checked or unchecked exceptions or errors. */
+    EXCEPTION(Exception.class, BINDING_METHOD_THROWS),
+
+    /** Methods may throw unchecked exceptions or errors. */
+    RUNTIME_EXCEPTION(RuntimeException.class, BINDING_METHOD_THROWS_CHECKED),
+    ;
+
+    private final Class<? extends Exception> superclass;
+    private final String errorMessage;
+
+    private ExceptionSuperclass() {
+      this(null, null);
+    }
+
+    private ExceptionSuperclass(Class<? extends Exception> superclass, String errorMessage) {
+      this.superclass = superclass;
+      this.errorMessage = errorMessage;
+    }
+
+    /**
+     * Adds an error if the method declares throws anything but an {@link Error} or an appropriate
+     * subtype of {@link Exception}.
+     *
+     * <p>This method is overridden in {@link #NONE}.
+     */
+    protected void checkThrows(
+        BindingMethodValidator validator, ValidationReport.Builder<ExecutableElement> builder) {
+      TypeMirror exceptionSupertype =
+          validator.elements.getTypeElement(superclass.getCanonicalName()).asType();
+      TypeMirror errorType =
+          validator.elements.getTypeElement(Error.class.getCanonicalName()).asType();
+      for (TypeMirror thrownType : builder.getSubject().getThrownTypes()) {
+        if (!validator.types.isSubtype(thrownType, exceptionSupertype)
+            && !validator.types.isSubtype(thrownType, errorType)) {
+          builder.addError(validator.formatErrorMessage(errorMessage));
+          break;
+        }
+      }
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindsMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindsMethodValidator.java
index 700f35c5b..369f424eb 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindsMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindsMethodValidator.java
@@ -15,113 +15,70 @@
  */
 package dagger.internal.codegen;
 
-import com.google.common.cache.CacheBuilder;
-import com.google.common.cache.CacheLoader;
-import com.google.common.cache.LoadingCache;
-import com.google.common.collect.Iterables;
+import com.google.common.collect.ImmutableSet;
 import dagger.Binds;
 import dagger.Module;
 import dagger.producers.ProducerModule;
 import java.util.List;
-import java.util.Set;
-import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.Modifier;
 import javax.lang.model.element.VariableElement;
-import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
-import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_IN_MODULE;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_TYPE_PARAMETER;
-import static dagger.internal.codegen.ErrorMessages.BINDS_METHOD_NOT_ABSTRACT;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.BindingMethodValidator.Abstractness.MUST_BE_ABSTRACT;
+import static dagger.internal.codegen.BindingMethodValidator.ExceptionSuperclass.RUNTIME_EXCEPTION;
 import static dagger.internal.codegen.ErrorMessages.BINDS_METHOD_ONE_ASSIGNABLE_PARAMETER;
-import static dagger.internal.codegen.Validation.validateMethodQualifiers;
-import static dagger.internal.codegen.Validation.validateReturnType;
-import static dagger.internal.codegen.Validation.validateUncheckedThrows;
-import static javax.lang.model.element.Modifier.ABSTRACT;
 
 /**
- * A {@linkplain ValidationReport validator} for {@link Bind} methods.
+ * A validator for {@link Binds} methods.
  */
-final class BindsMethodValidator {
-  private final Elements elements;
+final class BindsMethodValidator extends BindingMethodValidator {
   private final Types types;
-  private final LoadingCache<ExecutableElement, ValidationReport<ExecutableElement>>
-      validationCache;
 
   BindsMethodValidator(Elements elements, Types types) {
-    this.elements = checkNotNull(elements);
+    super(
+        elements,
+        types,
+        Binds.class,
+        ImmutableSet.of(Module.class, ProducerModule.class),
+        MUST_BE_ABSTRACT,
+        RUNTIME_EXCEPTION);
     this.types = checkNotNull(types);
-    this.validationCache = CacheBuilder.newBuilder().build(new ValidationLoader());
   }
 
-  private final class ValidationLoader
-      extends CacheLoader<ExecutableElement, ValidationReport<ExecutableElement>> {
-    @Override
-    public ValidationReport<ExecutableElement> load(ExecutableElement bindsMethodElement) {
-      ValidationReport.Builder<ExecutableElement> builder =
-          ValidationReport.about(bindsMethodElement);
-
-      checkArgument(isAnnotationPresent(bindsMethodElement, Binds.class));
-
-      Element enclosingElement = bindsMethodElement.getEnclosingElement();
-      if (!isAnnotationPresent(enclosingElement, Module.class)
-          && !isAnnotationPresent(enclosingElement, ProducerModule.class)) {
-        builder.addError(
-            formatErrorMessage(
-                BINDING_METHOD_NOT_IN_MODULE,
-                String.format(
-                    // the first @ is in the format string
-                    "%s or @%s",
-                    Module.class.getSimpleName(),
-                    ProducerModule.class.getSimpleName())),
-            bindsMethodElement);
-      }
-
-      if (!bindsMethodElement.getTypeParameters().isEmpty()) {
-        builder.addError(formatErrorMessage(BINDING_METHOD_TYPE_PARAMETER), bindsMethodElement);
-      }
-
-      Set<Modifier> modifiers = bindsMethodElement.getModifiers();
-      if (!modifiers.contains(ABSTRACT)) {
-        builder.addError(formatErrorMessage(BINDS_METHOD_NOT_ABSTRACT), bindsMethodElement);
-      }
-      TypeMirror returnType = bindsMethodElement.getReturnType();
-      validateReturnType(Binds.class, builder, returnType);
-
-      List<? extends VariableElement> parameters = bindsMethodElement.getParameters();
-      if (parameters.size() == 1) {
-        VariableElement parameter = Iterables.getOnlyElement(parameters);
-        if (!types.isAssignable(parameter.asType(), returnType)) {
-          builder.addError(
-              formatErrorMessage(BINDS_METHOD_ONE_ASSIGNABLE_PARAMETER), bindsMethodElement);
-        }
-      } else {
-        builder.addError(
-            formatErrorMessage(BINDS_METHOD_ONE_ASSIGNABLE_PARAMETER), bindsMethodElement);
-      }
-
-      validateUncheckedThrows(elements, types, bindsMethodElement, Binds.class, builder);
-
-      validateMethodQualifiers(builder, bindsMethodElement);
+  @Override
+  protected void checkMethod(ValidationReport.Builder<ExecutableElement> builder) {
+    super.checkMethod(builder);
+    checkParameters(builder);
+  }
 
-      return builder.build();
-    }
+  @Override // TODO(dpb, ronshapiro): When @Binds methods support multibindings, stop overriding.
+  protected void checkReturnType(ValidationReport.Builder<ExecutableElement> builder) {
+    checkFrameworkType(builder);
+    checkKeyType(builder, builder.getSubject().getReturnType());
   }
 
-  ValidationReport<ExecutableElement> validate(ExecutableElement bindsMethodElement) {
-    return validationCache.getUnchecked(bindsMethodElement);
+  @Override // TODO(dpb, ronshapiro): When @Binds methods support multibindings, stop overriding.
+  protected void checkMapKeys(ValidationReport.Builder<ExecutableElement> builder) {
+    // no-op
   }
 
-  private String formatErrorMessage(String msg) {
-    return String.format(msg, Binds.class.getSimpleName());
+  @Override // TODO(dpb, ronshapiro): When @Binds methods support multibindings, stop overriding.
+  protected void checkMultibindings(ValidationReport.Builder<ExecutableElement> builder) {
+    // no-op
   }
 
-  private String formatErrorMessage(String msg, String parameter) {
-    return String.format(msg, Binds.class.getSimpleName(), parameter);
+  private void checkParameters(ValidationReport.Builder<ExecutableElement> builder) {
+    List<? extends VariableElement> parameters = builder.getSubject().getParameters();
+    if (parameters.size() == 1) {
+      VariableElement parameter = getOnlyElement(parameters);
+      if (!types.isAssignable(parameter.asType(), builder.getSubject().getReturnType())) {
+        builder.addError(formatErrorMessage(BINDS_METHOD_ONE_ASSIGNABLE_PARAMETER));
+      }
+    } else {
+      builder.addError(formatErrorMessage(BINDS_METHOD_ONE_ASSIGNABLE_PARAMETER));
+    }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java b/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java
index fb9515486..e50bc2018 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java
@@ -198,7 +198,7 @@ private void error(
       Object[] newArgs = new Object[extraArgs.length + 1];
       newArgs[0] = method;
       System.arraycopy(extraArgs, 0, newArgs, 1, extraArgs.length);
-      builder.addError(String.format(inheritedError, newArgs), builder.getSubject());
+      builder.addError(String.format(inheritedError, newArgs));
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/CompilerOptions.java b/compiler/src/main/java/dagger/internal/codegen/CompilerOptions.java
index 88a806109..a57092df7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/CompilerOptions.java
+++ b/compiler/src/main/java/dagger/internal/codegen/CompilerOptions.java
@@ -34,6 +34,7 @@
   abstract Diagnostic.Kind nullableValidationKind();
   abstract Diagnostic.Kind privateMemberValidationKind();
   abstract Diagnostic.Kind staticMemberValidationKind();
+  abstract boolean ignorePrivateAndStaticInjectionForComponent();
   abstract ValidationType scopeCycleValidationType();
 
   static Builder builder() {
@@ -50,6 +51,9 @@ static CompilerOptions create(ProcessingEnvironment processingEnv, Elements elem
             privateMemberValidationType(processingEnv).diagnosticKind().get())
         .staticMemberValidationKind(
             staticMemberValidationType(processingEnv).diagnosticKind().get())
+        .ignorePrivateAndStaticInjectionForComponent(
+            ignorePrivateAndStaticInjectionForComponent(processingEnv)
+                .equals(FeatureStatus.DISABLED))
         .scopeCycleValidationType(scopeValidationType(processingEnv))
         .build();
   }
@@ -61,6 +65,8 @@ static CompilerOptions create(ProcessingEnvironment processingEnv, Elements elem
     Builder nullableValidationKind(Diagnostic.Kind kind);
     Builder privateMemberValidationKind(Diagnostic.Kind kind);
     Builder staticMemberValidationKind(Diagnostic.Kind kind);
+    Builder ignorePrivateAndStaticInjectionForComponent(
+        boolean ignorePrivateAndStaticInjectionForComponent);
     Builder scopeCycleValidationType(ValidationType type);
     CompilerOptions build();
   }
@@ -76,12 +82,23 @@ static CompilerOptions create(ProcessingEnvironment processingEnv, Elements elem
 
   static final String STATIC_MEMBER_VALIDATION_TYPE_KEY = "dagger.staticMemberValidation";
 
+  /**
+   * If true, Dagger will generate factories and components even if some members-injected types
+   * have private or static {@code @Inject}-annotated members.
+   *
+   * <p>This defaults to false, and should only ever be enabled by the TCK tests. Disabling this
+   * validation could lead to generating code that does not compile.
+   */
+  static final String IGNORE_PRIVATE_AND_STATIC_INJECTION_FOR_COMPONENT =
+      "dagger.ignorePrivateAndStaticInjectionForComponent";
+
   static final ImmutableSet<String> SUPPORTED_OPTIONS = ImmutableSet.of(
         WRITE_PRODUCER_NAME_IN_TOKEN_KEY,
         DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY,
         NULLABLE_VALIDATION_KEY,
         PRIVATE_MEMBER_VALIDATION_TYPE_KEY,
-        STATIC_MEMBER_VALIDATION_TYPE_KEY);
+        STATIC_MEMBER_VALIDATION_TYPE_KEY,
+        IGNORE_PRIVATE_AND_STATIC_INJECTION_FOR_COMPONENT);
 
   private static FeatureStatus writeProducerNameInToken(ProcessingEnvironment processingEnv) {
     return valueOf(
@@ -123,6 +140,15 @@ private static ValidationType staticMemberValidationType(ProcessingEnvironment p
         EnumSet.of(ValidationType.ERROR, ValidationType.WARNING));
   }
 
+  private static FeatureStatus ignorePrivateAndStaticInjectionForComponent(
+      ProcessingEnvironment processingEnv) {
+    return valueOf(
+        processingEnv,
+        IGNORE_PRIVATE_AND_STATIC_INJECTION_FOR_COMPONENT,
+        FeatureStatus.DISABLED,
+        EnumSet.allOf(FeatureStatus.class));
+  }
+
   private static <T extends Enum<T>> T valueOf(
       ProcessingEnvironment processingEnv, String key, T defaultValue, Set<T> validValues) {
     Map<String, String> options = processingEnv.getOptions();
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index 219c68865..5fae068e6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -26,6 +26,9 @@
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
+import static dagger.internal.codegen.ModuleProcessingStep.moduleProcessingStep;
+import static dagger.internal.codegen.ModuleProcessingStep.producerModuleProcessingStep;
+
 /**
  * The annotation processor responsible for generating the classes that drive the Dagger 2.0
  * implementation.
@@ -67,7 +70,8 @@ public SourceVersion getSupportedSourceVersion() {
         new DependencyRequestFormatter(types, elements);
     KeyFormatter keyFormatter = new KeyFormatter(methodSignatureFormatter);
 
-    InjectValidator injectValidator = new InjectValidator(compilerOptions);
+    InjectValidator injectValidator = new InjectValidator(types, elements, compilerOptions);
+    InjectValidator injectValidatorWhenGeneratingCode = injectValidator.whenGeneratingCode();
     ModuleValidator moduleValidator =
         new ModuleValidator(types, elements, methodSignatureFormatter);
     BuilderValidator builderValidator = new BuilderValidator(elements, types);
@@ -81,14 +85,25 @@ public SourceVersion getSupportedSourceVersion() {
     ProvidesMethodValidator providesMethodValidator = new ProvidesMethodValidator(elements, types);
     ProducesMethodValidator producesMethodValidator = new ProducesMethodValidator(elements, types);
     BindsMethodValidator bindsMethodValidator = new BindsMethodValidator(elements, types);
+    MultibindsMethodValidator multibindsMethodValidator =
+        new MultibindsMethodValidator(elements, types);
+    MultibindingsMethodValidator multibindingsMethodValidator =
+        new MultibindingsMethodValidator(elements, types);
 
     Key.Factory keyFactory = new Key.Factory(types, elements);
 
     MultibindingsValidator multibindingsValidator =
-        new MultibindingsValidator(elements, keyFactory, keyFormatter, methodSignatureFormatter);
+        new MultibindingsValidator(
+            elements,
+            keyFactory,
+            keyFormatter,
+            methodSignatureFormatter,
+            multibindingsMethodValidator);
 
-    this.factoryGenerator = new FactoryGenerator(filer, elements, compilerOptions);
-    this.membersInjectorGenerator = new MembersInjectorGenerator(filer, elements);
+    this.factoryGenerator =
+        new FactoryGenerator(filer, elements, compilerOptions, injectValidatorWhenGeneratingCode);
+    this.membersInjectorGenerator =
+        new MembersInjectorGenerator(filer, elements, injectValidatorWhenGeneratingCode);
     ComponentGenerator componentGenerator =
         new ComponentGenerator(filer, elements, types, keyFactory, compilerOptions);
     ProducerFactoryGenerator producerFactoryGenerator =
@@ -149,6 +164,7 @@ public SourceVersion getSupportedSourceVersion() {
             elements,
             types,
             compilerOptions,
+            injectValidatorWhenGeneratingCode,
             injectBindingRegistry,
             bindingDeclarationFormatter,
             methodSignatureFormatter,
@@ -163,13 +179,14 @@ public SourceVersion getSupportedSourceVersion() {
         new ProductionExecutorModuleProcessingStep(messager, productionExecutorModuleGenerator),
         new MultibindingsProcessingStep(messager, multibindingsValidator),
         new MultibindingAnnotationsProcessingStep(messager),
-        new ModuleProcessingStep(
+        moduleProcessingStep(
             messager,
             moduleValidator,
-            providesMethodValidator,
             provisionBindingFactory,
+            factoryGenerator,
+            providesMethodValidator,
             bindsMethodValidator,
-            factoryGenerator),
+            multibindsMethodValidator),
         new ComponentProcessingStep(
             ComponentDescriptor.Kind.COMPONENT,
             messager,
@@ -181,13 +198,14 @@ public SourceVersion getSupportedSourceVersion() {
             componentDescriptorFactory,
             bindingGraphFactory,
             componentGenerator),
-        new ProducerModuleProcessingStep(
+        producerModuleProcessingStep(
             messager,
             moduleValidator,
+            productionBindingFactory,
+            producerFactoryGenerator,
             producesMethodValidator,
             bindsMethodValidator,
-            productionBindingFactory,
-            producerFactoryGenerator),
+            multibindsMethodValidator),
         new ComponentProcessingStep(
             ComponentDescriptor.Kind.PRODUCTION_COMPONENT,
             messager,
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
index 5ebf68472..27b6c7442 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
@@ -37,11 +37,12 @@
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
 
 import static com.google.common.collect.Sets.immutableEnumSet;
 import static dagger.internal.codegen.ContributionBinding.Kind.IS_SYNTHETIC_KIND;
-import static dagger.internal.codegen.MapKeys.getMapKey;
 import static dagger.internal.codegen.MapKeys.unwrapValue;
+import static dagger.internal.codegen.MoreAnnotationMirrors.unwrapOptionalEquivalence;
 import static javax.lang.model.element.Modifier.STATIC;
 
 /**
@@ -89,6 +90,12 @@ public Kind apply(ContributionBinding binding) {
   /** If this provision requires members injection, this will be the corresponding request. */
   abstract Optional<DependencyRequest> membersInjectionRequest();
 
+  abstract Optional<Equivalence.Wrapper<AnnotationMirror>> wrappedMapKey();
+
+  final Optional<AnnotationMirror> mapKey() {
+    return unwrapOptionalEquivalence(wrappedMapKey());
+  }
+
   /**
    * The kind of contribution this binding represents. Defines which elements can specify this kind
    * of contribution.
@@ -114,7 +121,7 @@ public Kind apply(ContributionBinding binding) {
 
     /**
      * A binding (provision or production) that delegates from requests for one key to another.
-     * These are the bindings that satisfy {@code @Bind} declarations.
+     * These are the bindings that satisfy {@code @Binds} declarations.
      */
     SYNTHETIC_DELEGATE_BINDING,
 
@@ -229,6 +236,25 @@ FactoryCreationStrategy factoryCreationStrategy() {
     }
   }
 
+  /**
+   * The {@link TypeMirror type} for the {@code Factory<T>} or {@code Producer<T>} which is created
+   * for this binding. Uses the binding's key, V in the came of {@code Map<K, FrameworkClass<V>>>},
+   * and E {@code Set<E>} for {@link dagger.multibindings.IntoSet @IntoSet} methods.
+   */
+  final TypeMirror factoryType() {
+    switch (contributionType()) {
+      case MAP:
+        return MapType.from(key().type()).unwrappedValueType(frameworkClass());
+      case SET:
+        return SetType.from(key().type()).elementType();
+      case SET_VALUES:
+      case UNIQUE:
+        return key().type();
+      default:
+        throw new AssertionError();
+    }
+  }
+
   /**
    * Indexes map-multibindings by map key (the result of calling
    * {@link AnnotationValue#getValue()} on a single member or the whole {@link AnnotationMirror}
@@ -242,7 +268,7 @@ FactoryCreationStrategy factoryCreationStrategy() {
             new Function<ContributionBinding, Object>() {
               @Override
               public Object apply(ContributionBinding mapBinding) {
-                AnnotationMirror mapKey = getMapKey(mapBinding.bindingElement()).get();
+                AnnotationMirror mapKey = mapBinding.mapKey().get();
                 Optional<? extends AnnotationValue> unwrappedValue = unwrapValue(mapKey);
                 return unwrappedValue.isPresent() ? unwrappedValue.get().getValue() : mapKey;
               }
@@ -261,7 +287,7 @@ public Object apply(ContributionBinding mapBinding) {
               @Override
               public Equivalence.Wrapper<DeclaredType> apply(ContributionBinding mapBinding) {
                 return MoreTypes.equivalence()
-                    .wrap(getMapKey(mapBinding.bindingElement()).get().getAnnotationType());
+                    .wrap(mapBinding.mapKey().get().getAnnotationType());
               }
             }));
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionType.java b/compiler/src/main/java/dagger/internal/codegen/ContributionType.java
index b5966695a..98c363560 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ContributionType.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionType.java
@@ -26,7 +26,6 @@
 import javax.lang.model.element.ExecutableElement;
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static com.google.common.base.Preconditions.checkArgument;
 
 /**
  * Whether a binding or declaration is for a unique contribution or a map or set multibinding.
@@ -95,9 +94,6 @@ private static ContributionType forProductionType(Produces.Type productionType)
    * ProvidesMethodValidator} and {@link ProducesMethodValidator} validate correctness on their own.
    */
   static ContributionType fromBindingMethod(ExecutableElement method) {
-    checkArgument(
-        isAnnotationPresent(method, Provides.class)
-            || isAnnotationPresent(method, Produces.class));
     if (isAnnotationPresent(method, IntoMap.class)) {
       return ContributionType.MAP;
     } else if (isAnnotationPresent(method, IntoSet.class)) {
@@ -111,7 +107,7 @@ static ContributionType fromBindingMethod(ExecutableElement method) {
     } else if (isAnnotationPresent(method, Produces.class)) {
       return forProductionType(method.getAnnotation(Produces.class).type());
     } else {
-      throw new AssertionError();
+      return ContributionType.UNIQUE;
     }
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/DelegateDeclaration.java b/compiler/src/main/java/dagger/internal/codegen/DelegateDeclaration.java
index b7dc1076e..a6872f5e8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DelegateDeclaration.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DelegateDeclaration.java
@@ -31,7 +31,7 @@
 import static dagger.internal.codegen.ContributionType.UNIQUE;
 
 /**
- * The declaration for a delegate binding established by a {@link Bind} method.
+ * The declaration for a delegate binding established by a {@link Binds} method.
  */
 @AutoValue
 abstract class DelegateDeclaration extends BindingDeclaration implements HasContributionType {
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
index 3dff2bf99..3cdf9832e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -20,6 +20,7 @@
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Function;
 import com.google.common.base.Optional;
+import com.google.common.base.Predicate;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
@@ -160,6 +161,18 @@ BindingKey bindingKey() {
    * use a name derived from {@link #requestElement}.
    */
   abstract Optional<String> overriddenVariableName();
+  
+  /** {@code true} if this is a synthetic request, which should not appear in dependency traces. */
+  abstract boolean isSynthetic();
+
+  /** A predicate that passes for synthetic requests. */
+  static final Predicate<DependencyRequest> IS_SYNTHETIC =
+      new Predicate<DependencyRequest>() {
+        @Override
+        public boolean apply(DependencyRequest request) {
+          return request.isSynthetic();
+        }
+      };
 
   /**
    * Factory for {@link DependencyRequest}s.
@@ -215,7 +228,8 @@ DependencyRequest forImplicitMapBinding(
           mapOfFactoryKey,
           mapOfValueRequest.requestElement(),
           false /* doesn't allow null */,
-          Optional.<String>absent());
+          Optional.<String>absent(),
+          true /* synthetic */);
     }
 
     /**
@@ -233,7 +247,8 @@ DependencyRequest forMultibindingContribution(
           multibindingContribution.key(),
           request.requestElement(),
           false /* doesn't allow null */,
-          Optional.<String>absent());
+          Optional.<String>absent(),
+          true /* synthetic */);
     }
 
     private Kind multibindingContributionRequestKind(ContributionBinding multibindingContribution) {
@@ -319,7 +334,8 @@ DependencyRequest forComponentProductionMethod(ExecutableElement productionMetho
                 qualifier, Iterables.getOnlyElement(((DeclaredType) type).getTypeArguments())),
             productionMethod,
             false /* doesn't allow null */,
-            Optional.<String>absent());
+            Optional.<String>absent(),
+            false /* not synthetic */);
       } else {
         return newDependencyRequest(productionMethod, type, qualifier, Optional.<String>absent());
       }
@@ -342,7 +358,8 @@ DependencyRequest forComponentMembersInjectionMethod(ExecutableElement membersIn
           keyFactory.forMembersInjectedType(membersInjectedType),
           membersInjectionMethod,
           false /* doesn't allow null */,
-          Optional.<String>absent());
+          Optional.<String>absent(),
+          false /* not synthetic */);
     }
 
     DependencyRequest forMembersInjectedType(DeclaredType type) {
@@ -351,7 +368,8 @@ DependencyRequest forMembersInjectedType(DeclaredType type) {
           keyFactory.forMembersInjectedType(type),
           type.asElement(),
           false /* doesn't allow null */,
-          Optional.<String>absent());
+          Optional.<String>absent(),
+          false /* not synthetic */);
     }
 
     DependencyRequest forProductionImplementationExecutor() {
@@ -361,7 +379,8 @@ DependencyRequest forProductionImplementationExecutor() {
           key,
           MoreTypes.asElement(key.type()),
           false /* doesn't allow null */,
-          Optional.<String>absent());
+          Optional.<String>absent(),
+          false /* not synthetic */);
     }
 
     DependencyRequest forProductionComponentMonitorProvider() {
@@ -394,11 +413,12 @@ private DependencyRequest newDependencyRequest(
           keyFactory.forQualifiedType(qualifier, kindAndType.type()),
           requestElement,
           allowsNull,
-          name);
+          name,
+          false /* not synthetic */);
     }
 
     @AutoValue
-    static abstract class KindAndType {
+    abstract static class KindAndType {
       abstract Kind kind();
       abstract TypeMirror type();
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
index cd783be2a..9c3c65b92 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
@@ -72,13 +72,14 @@
   /**
    * A string representation of the dependency trace, starting with the
    * {@linkplain DependencyPath#currentDependencyRequest() current request} and ending with the
-   * entry point.
+   * entry point, excluding {@linkplain DependencyRequest#isSynthetic() synthetic} requests.
    */
   String toDependencyTrace(DependencyPath dependencyPath) {
     return Joiner.on('\n')
         .join(
             dependencyPath
-                .nonsyntheticRequests()
+                .requests()
+                .filter(Predicates.not(DependencyRequest.IS_SYNTHETIC))
                 .transform(this)
                 .filter(Predicates.not(Predicates.equalTo("")))
                 .toList()
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index 6ecf713e6..8b07e58c9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -18,6 +18,7 @@
 import com.google.auto.common.MoreTypes;
 import dagger.Multibindings;
 import dagger.Provides;
+import dagger.multibindings.Multibinds;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 import javax.lang.model.element.AnnotationMirror;
@@ -78,6 +79,8 @@
       "@Qualifier annotations are not allowed on @Inject constructors.";
   static final String SCOPE_ON_INJECT_CONSTRUCTOR =
       "@Scope annotations are not allowed on @Inject constructors. Annotate the class instead.";
+  static final String CHECKED_EXCEPTIONS_ON_CONSTRUCTORS =
+      "Dagger does not support checked exceptions on @Inject constructors.";
 
   /* fields */
   static final String PRIVATE_INJECT_FIELD =
@@ -122,8 +125,7 @@ static String inconsistentMapKeyAnnotationsError(String key) {
       "@Reusable cannot be applied to components or subcomponents.";
 
   static final String BINDING_METHOD_RETURN_TYPE =
-      "@%s methods must either return a primitive, an array, a type variable, or a declared"
-          + " type.";
+      "@%s methods must return a primitive, an array, a type variable, or a declared type.";
 
   static final String BINDING_METHOD_THROWS_CHECKED =
       "@%s methods may only throw unchecked exceptions";
@@ -132,8 +134,8 @@ static String inconsistentMapKeyAnnotationsError(String key) {
       "@Nullable on @Produces methods does not do anything.";
 
   static final String PRODUCES_METHOD_RETURN_TYPE =
-      "@Produces methods must either return a primitive, an array, a type variable, or a declared"
-          + " type, or a ListenableFuture of one of those types.";
+      "@Produces methods must return a primitive, an array, a type variable, or a declared type, "
+          + "or a ListenableFuture of one of those types.";
 
   static final String PRODUCES_METHOD_RAW_FUTURE =
       "@Produces methods cannot return a raw ListenableFuture.";
@@ -141,14 +143,18 @@ static String inconsistentMapKeyAnnotationsError(String key) {
   static final String BINDING_METHOD_SET_VALUES_RAW_SET =
       "@%s methods of type set values cannot return a raw Set";
 
-  static final String PROVIDES_METHOD_SET_VALUES_RETURN_SET =
-      "@Provides methods of type set values must return a Set";
+  static final String BINDING_METHOD_SET_VALUES_RETURN_SET =
+      "@%s methods of type set values must return a Set";
 
   static final String PRODUCES_METHOD_SET_VALUES_RETURN_SET =
       "@Produces methods of type set values must return a Set or ListenableFuture of Set";
 
-  static final String PRODUCES_METHOD_THROWS =
-      "@Produces methods may only throw unchecked exceptions or exceptions subclassing Exception";
+  static final String PRODUCES_METHOD_SCOPE = "@Produces methods may not have scope annotations.";
+
+  static final String BINDING_METHOD_THROWS =
+      "@%s methods may only throw unchecked exceptions or exceptions subclassing Exception";
+
+  static final String BINDING_METHOD_THROWS_ANY = "@%s methods may not throw";
 
   static final String BINDING_METHOD_MUST_RETURN_A_VALUE =
       "@%s methods must return a value (not void).";
@@ -158,7 +164,7 @@ static String inconsistentMapKeyAnnotationsError(String key) {
 
   static final String BINDING_METHOD_ABSTRACT = "@%s methods cannot be abstract";
 
-  static final String BINDS_METHOD_NOT_ABSTRACT = "@Binds methods must be abstract";
+  static final String BINDING_METHOD_NOT_ABSTRACT = "@%s methods must be abstract";
 
   static final String BINDING_METHOD_PRIVATE = "@%s methods cannot be private";
 
@@ -184,8 +190,8 @@ static String inconsistentMapKeyAnnotationsError(String key) {
       "Cannot have more than one @%s method with the same name in a single module";
 
   static final String INCOMPATIBLE_MODULE_METHODS =
-      "A @%1$s may contain non-static @%2$s methods or @Binds methods,"
-          + " but not both at the same time.  (Static @%2$s may be used with either.)";
+      "A @%1$s may not contain both non-static @%2$s methods and abstract @Binds or @Multibinds "
+          + "declarations";
 
   static final String MODULES_WITH_TYPE_PARAMS_MUST_BE_ABSTRACT =
       "Modules with type parameters must be abstract";
@@ -476,12 +482,6 @@ String moreThanOneRefToSubcomponent() {
     static final String MUST_BE_IN_MODULE =
         "@Multibindings types must be nested within a @Module or @ProducerModule";
 
-    static final String METHOD_MUST_RETURN_MAP_OR_SET =
-        "@Multibindings methods must return Map<K, V> or Set<T>";
-
-    static final String TOO_MANY_QUALIFIERS =
-        "Cannot use more than one @Qualifier on a method in an @Multibindings type";
-
     static String tooManyMethodsForKey(String formattedKey) {
       return String.format(
           "Too many @Multibindings methods for %s", stripCommonTypePrefixes(formattedKey));
@@ -489,6 +489,21 @@ static String tooManyMethodsForKey(String formattedKey) {
 
     private MultibindingsMessages() {}
   }
+  
+  /**
+   * Error messages related to {@link Multibinds @Multibinds} methods and methods in
+   * {@link Multibindings} interfaces.
+   */
+  static final class MultibindsMessages {
+    static final String METHOD_MUST_RETURN_MAP_OR_SET =
+        "@%s methods must return Map<K, V> or Set<T>";
+
+    static final String NO_MAP_KEY = "@%s methods must not have a @MapKey annotation";
+
+    static final String PARAMETERS = "@%s methods cannot have parameters";
+
+    private MultibindsMessages() {}
+  }
 
   /**
    * A regular expression to match a small list of specific packages deemed to
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index cb2a5141e..9817dd052 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -15,7 +15,6 @@
  */
 package dagger.internal.codegen;
 
-import com.google.auto.common.MoreTypes;
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
@@ -32,13 +31,10 @@
 import dagger.internal.Factory;
 import dagger.internal.MembersInjectors;
 import dagger.internal.Preconditions;
-import java.util.Collections;
 import java.util.List;
 import javax.annotation.processing.Filer;
 import javax.inject.Inject;
-import javax.inject.Provider;
 import javax.lang.model.element.Element;
-import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 import javax.tools.Diagnostic;
 
@@ -53,7 +49,6 @@
 import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.ENUM_INSTANCE;
 import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
 import static dagger.internal.codegen.ContributionBinding.Kind.PROVISION;
-import static dagger.internal.codegen.ContributionType.SET;
 import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD;
 import static dagger.internal.codegen.SourceFiles.bindingTypeElementTypeVariableNames;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
@@ -76,10 +71,16 @@
 final class FactoryGenerator extends SourceFileGenerator<ProvisionBinding> {
 
   private final CompilerOptions compilerOptions;
+  private final InjectValidator injectValidator;
 
-  FactoryGenerator(Filer filer, Elements elements, CompilerOptions compilerOptions) {
+  FactoryGenerator(
+      Filer filer,
+      Elements elements,
+      CompilerOptions compilerOptions,
+      InjectValidator injectValidator) {
     super(filer, elements);
     this.compilerOptions = compilerOptions;
+    this.injectValidator = injectValidator;
   }
 
   @Override
@@ -97,11 +98,12 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
     // We don't want to write out resolved bindings -- we want to write out the generic version.
     checkState(!binding.unresolved().isPresent());
 
-    TypeMirror keyType =
-        binding.contributionType().equals(ContributionType.MAP)
-            ? MapType.from(binding.key().type()).unwrappedValueType(Provider.class)
-            : binding.key().type();
-    TypeName providedTypeName = TypeName.get(keyType);
+    if (binding.bindingKind().equals(INJECTION)
+        && !injectValidator.isValidType(binding.factoryType())) {
+      return Optional.absent();
+    }
+
+    TypeName providedTypeName = TypeName.get(binding.factoryType());
     ParameterizedTypeName parameterizedFactoryName = factoryOf(providedTypeName);
     Optional<ParameterizedTypeName> factoryOfRawTypeName = Optional.absent();
     TypeSpec.Builder factoryBuilder;
@@ -235,14 +237,7 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
           ".$L($L)", binding.bindingElement().getSimpleName(), parametersCodeBlock);
       CodeBlock providesMethodInvocation = providesMethodInvocationBuilder.build();
 
-      if (binding.contributionType().equals(SET)) {
-        TypeName paramTypeName = TypeName.get(
-            MoreTypes.asDeclared(keyType).getTypeArguments().get(0));
-        // TODO(cgruber): only be explicit with the parameter if paramType contains wildcards.
-        getMethodBuilder.addStatement(
-            "return $T.<$T>singleton($L)",
-            Collections.class, paramTypeName, providesMethodInvocation);
-      } else if (binding.nullableType().isPresent()
+      if (binding.nullableType().isPresent()
           || compilerOptions.nullableValidationKind().equals(Diagnostic.Kind.WARNING)) {
         if (binding.nullableType().isPresent()) {
           getMethodBuilder.addAnnotation((ClassName) TypeName.get(binding.nullableType().get()));
diff --git a/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java b/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
index 14e732c65..3d1951809 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
@@ -29,8 +29,17 @@
 import javax.lang.model.util.ElementKindVisitor6;
 
 /**
- * A field that holds a {@link javax.inject.Provider}, {@link dagger.producers.Producer}, or other
- * framework type.
+ * A value object that represents a field in the generated Component class.
+ *
+ * <p>Examples:
+ * <ul>
+ *   <li>{@code Provider<String>}
+ *   <li>{@code Producer<Widget>}
+ *   <li>{@code Provider<Map<SomeMapKey, MapValue>>}.
+ * </ul>
+ *
+ * @author Jesse Beder
+ * @since 2.0
  */
 @AutoValue
 abstract class FrameworkField {
@@ -65,11 +74,18 @@ static FrameworkField forResolvedBindings(
   }
 
   private static TypeMirror fieldValueType(ResolvedBindings resolvedBindings) {
-    return resolvedBindings.isMultibindingContribution()
-            && resolvedBindings.contributionType().equals(ContributionType.MAP)
-        ? MapType.from(resolvedBindings.key().type())
-            .unwrappedValueType(resolvedBindings.frameworkClass())
-        : resolvedBindings.key().type();
+    if (resolvedBindings.isMultibindingContribution()) {
+      switch (resolvedBindings.contributionType()) {
+        case MAP:
+          return MapType.from(resolvedBindings.key().type())
+              .unwrappedValueType(resolvedBindings.frameworkClass());
+        case SET:
+          return SetType.from((resolvedBindings.key().type())).elementType();
+        default:
+          // do nothing
+      }
+    }
+    return resolvedBindings.key().type();
   }
 
   private static String frameworkFieldName(ResolvedBindings resolvedBindings) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
index 45cb39d6a..77f52af40 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
@@ -262,7 +262,8 @@ private void registerBinding(MembersInjectionBinding binding, boolean warnIfNotA
       return Optional.of(cachedBinding);
     }
 
-    ValidationReport<TypeElement> report = injectValidator.validateType(typeElement);
+    ValidationReport<TypeElement> report =
+        injectValidator.validateMembersInjectionType(typeElement);
     report.printMessagesTo(messager);
     if (report.isClean()) {
       MembersInjectionBinding binding =
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectValidator.java b/compiler/src/main/java/dagger/internal/codegen/InjectValidator.java
index 6a6ce3e90..a6b4f0e0c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectValidator.java
@@ -17,6 +17,7 @@
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
+import com.google.common.base.Optional;
 import com.google.common.base.Predicate;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
@@ -30,9 +31,14 @@
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementFilter;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+import javax.tools.Diagnostic;
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static dagger.internal.codegen.Accessibility.isElementAccessibleFromOwnPackage;
 import static dagger.internal.codegen.ErrorMessages.ABSTRACT_INJECT_METHOD;
+import static dagger.internal.codegen.ErrorMessages.CHECKED_EXCEPTIONS_ON_CONSTRUCTORS;
 import static dagger.internal.codegen.ErrorMessages.FINAL_INJECT_FIELD;
 import static dagger.internal.codegen.ErrorMessages.GENERIC_INJECT_METHOD;
 import static dagger.internal.codegen.ErrorMessages.INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS;
@@ -55,6 +61,7 @@
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.STATIC;
+import static javax.lang.model.type.TypeKind.DECLARED;
 
 /**
  * A {@linkplain ValidationReport validator} for {@link Inject}-annotated elements and the types
@@ -64,10 +71,34 @@
  * @since 2.0
  */
 final class InjectValidator {
-  private CompilerOptions compilerOptions;
+  private final Types types;
+  private final Elements elements;
+  private final CompilerOptions compilerOptions;
+  private final Optional<Diagnostic.Kind> privateAndStaticInjectionDiagnosticKind;
 
-  InjectValidator(CompilerOptions compilerOptions) {
+  InjectValidator(Types types, Elements elements, CompilerOptions compilerOptions) {
+    this(types, elements, compilerOptions, Optional.<Diagnostic.Kind>absent());
+  }
+
+  private InjectValidator(
+      Types types,
+      Elements elements,
+      CompilerOptions compilerOptions,
+      Optional<Diagnostic.Kind> privateAndStaticInjectionDiagnosticKind) {
+    this.types = types;
+    this.elements = elements;
     this.compilerOptions = compilerOptions;
+    this.privateAndStaticInjectionDiagnosticKind = privateAndStaticInjectionDiagnosticKind;
+  }
+
+  /**
+   * Returns a new validator that performs the same validation as this one, but is strict about
+   * rejecting optionally-specified JSR 330 behavior that Dagger doesn't support.
+   */
+  InjectValidator whenGeneratingCode() {
+    return compilerOptions.ignorePrivateAndStaticInjectionForComponent()
+        ? new InjectValidator(types, elements, compilerOptions, Optional.of(Diagnostic.Kind.ERROR))
+        : this;
   }
 
   ValidationReport<TypeElement> validateConstructor(ExecutableElement constructorElement) {
@@ -97,12 +128,22 @@
       }
     }
 
+    if (throwsCheckedExceptions(constructorElement)) {
+      builder.addItem(
+          CHECKED_EXCEPTIONS_ON_CONSTRUCTORS,
+          privateAndStaticInjectionDiagnosticKind.or(compilerOptions.privateMemberValidationKind()),
+          constructorElement);
+    }
+
     TypeElement enclosingElement =
         MoreElements.asType(constructorElement.getEnclosingElement());
     Set<Modifier> typeModifiers = enclosingElement.getModifiers();
 
-    if (typeModifiers.contains(PRIVATE)) {
-      builder.addError(INJECT_INTO_PRIVATE_CLASS, constructorElement);
+    if (!Accessibility.isElementAccessibleFromOwnPackage(enclosingElement)) {
+      builder.addItem(
+          INJECT_INTO_PRIVATE_CLASS,
+          privateAndStaticInjectionDiagnosticKind.or(compilerOptions.privateMemberValidationKind()),
+          constructorElement);
     }
 
     if (typeModifiers.contains(ABSTRACT)) {
@@ -137,7 +178,7 @@
     return builder.build();
   }
 
- ValidationReport<VariableElement> validateField(VariableElement fieldElement) {
+  private ValidationReport<VariableElement> validateField(VariableElement fieldElement) {
     ValidationReport.Builder<VariableElement> builder = ValidationReport.about(fieldElement);
     Set<Modifier> modifiers = fieldElement.getModifiers();
     if (modifiers.contains(FINAL)) {
@@ -146,14 +187,18 @@
 
     if (modifiers.contains(PRIVATE)) {
       builder.addItem(
-          PRIVATE_INJECT_FIELD, compilerOptions.privateMemberValidationKind(), fieldElement);
+          PRIVATE_INJECT_FIELD,
+          privateAndStaticInjectionDiagnosticKind.or(compilerOptions.privateMemberValidationKind()),
+          fieldElement);
     }
 
     if (modifiers.contains(STATIC)) {
       builder.addItem(
-          STATIC_INJECT_FIELD, compilerOptions.staticMemberValidationKind(), fieldElement);
+          STATIC_INJECT_FIELD,
+          privateAndStaticInjectionDiagnosticKind.or(compilerOptions.staticMemberValidationKind()),
+          fieldElement);
     }
- 
+
     ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(fieldElement);
     if (qualifiers.size() > 1) {
       for (AnnotationMirror qualifier : qualifiers) {
@@ -168,7 +213,7 @@
     return builder.build();
   }
 
-  ValidationReport<ExecutableElement> validateMethod(ExecutableElement methodElement) {
+  private ValidationReport<ExecutableElement> validateMethod(ExecutableElement methodElement) {
     ValidationReport.Builder<ExecutableElement> builder = ValidationReport.about(methodElement);
     Set<Modifier> modifiers = methodElement.getModifiers();
     if (modifiers.contains(ABSTRACT)) {
@@ -177,12 +222,16 @@
 
     if (modifiers.contains(PRIVATE)) {
       builder.addItem(
-          PRIVATE_INJECT_METHOD, compilerOptions.privateMemberValidationKind(), methodElement);
+          PRIVATE_INJECT_METHOD,
+          privateAndStaticInjectionDiagnosticKind.or(compilerOptions.privateMemberValidationKind()),
+          methodElement);
     }
 
     if (modifiers.contains(STATIC)) {
       builder.addItem(
-          STATIC_INJECT_METHOD, compilerOptions.staticMemberValidationKind(), methodElement);
+          STATIC_INJECT_METHOD,
+          privateAndStaticInjectionDiagnosticKind.or(compilerOptions.staticMemberValidationKind()),
+          methodElement);
     }
 
     if (!methodElement.getTypeParameters().isEmpty()) {
@@ -204,12 +253,14 @@
     return builder.build();
   }
 
-  ValidationReport<TypeElement> validateType(TypeElement typeElement) {
+  ValidationReport<TypeElement> validateMembersInjectionType(TypeElement typeElement) {
     // TODO(beder): This element might not be currently compiled, so this error message could be
     // left in limbo. Find an appropriate way to display the error message in that case.
     ValidationReport.Builder<TypeElement> builder = ValidationReport.about(typeElement);
+    boolean hasInjectedMembers = false;
     for (VariableElement element : ElementFilter.fieldsIn(typeElement.getEnclosedElements())) {
       if (MoreElements.isAnnotationPresent(element, Inject.class)) {
+        hasInjectedMembers = true;
         ValidationReport<VariableElement> report = validateField(element);
         if (!report.isClean()) {
           builder.addSubreport(report);
@@ -218,12 +269,21 @@
     }
     for (ExecutableElement element : ElementFilter.methodsIn(typeElement.getEnclosedElements())) {
       if (MoreElements.isAnnotationPresent(element, Inject.class)) {
+        hasInjectedMembers = true;
         ValidationReport<ExecutableElement> report = validateMethod(element);
         if (!report.isClean()) {
           builder.addSubreport(report);
         }
       }
     }
+    // We can't use MembersInjectionBinding.Factory#hasInjectedMembers because that assumes this
+    // binding already validates, so we just check it again here.
+    if (hasInjectedMembers && !isElementAccessibleFromOwnPackage(typeElement)) {
+      builder.addItem(
+          INJECT_INTO_PRIVATE_CLASS,
+          privateAndStaticInjectionDiagnosticKind.or(compilerOptions.privateMemberValidationKind()),
+          typeElement);
+    }
     TypeMirror superclass = typeElement.getSuperclass();
     if (!superclass.getKind().equals(TypeKind.NONE)) {
       ValidationReport<TypeElement> report = validateType(MoreTypes.asTypeElement(superclass));
@@ -233,4 +293,44 @@
     }
     return builder.build();
   }
+
+  ValidationReport<TypeElement> validateType(TypeElement typeElement) {
+    ValidationReport.Builder<TypeElement> builder = ValidationReport.about(typeElement);
+    ValidationReport<TypeElement> membersInjectionReport =
+        validateMembersInjectionType(typeElement);
+    if (!membersInjectionReport.isClean()) {
+      builder.addSubreport(membersInjectionReport);
+    }
+    for (ExecutableElement element :
+        ElementFilter.constructorsIn(typeElement.getEnclosedElements())) {
+      if (isAnnotationPresent(element, Inject.class)) {
+        ValidationReport<TypeElement> report = validateConstructor(element);
+        if (!report.isClean()) {
+          builder.addSubreport(report);
+        }
+      }
+    }
+    return builder.build();
+  }
+
+  boolean isValidType(TypeMirror type) {
+    if (!type.getKind().equals(DECLARED)) {
+      return true;
+    }
+    return validateType(MoreTypes.asTypeElement(type)).isClean();
+  }
+
+  /** Returns true if the given method element declares a checked exception. */
+  private boolean throwsCheckedExceptions(ExecutableElement methodElement) {
+    TypeMirror runtimeExceptionType =
+        elements.getTypeElement(RuntimeException.class.getCanonicalName()).asType();
+    TypeMirror errorType = elements.getTypeElement(Error.class.getCanonicalName()).asType();
+    for (TypeMirror thrownType : methodElement.getThrownTypes()) {
+      if (!types.isSubtype(thrownType, runtimeExceptionType)
+          && !types.isSubtype(thrownType, errorType)) {
+        return true;
+      }
+    }
+    return false;
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index f955b31ea..c67d374d8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -20,7 +20,6 @@
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
-import com.google.common.base.Equivalence.Wrapper;
 import com.google.common.base.Function;
 import com.google.common.base.MoreObjects;
 import com.google.common.base.Optional;
@@ -30,6 +29,7 @@
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.Binds;
 import dagger.Multibindings;
+import dagger.multibindings.Multibinds;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
 import dagger.producers.Production;
@@ -60,6 +60,8 @@
 import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
 import static dagger.internal.codegen.MapKeys.getMapKey;
 import static dagger.internal.codegen.MapKeys.getUnwrappedMapKeyType;
+import static dagger.internal.codegen.MoreAnnotationMirrors.unwrapOptionalEquivalence;
+import static dagger.internal.codegen.MoreAnnotationMirrors.wrapOptionalInEquivalence;
 import static javax.lang.model.element.ElementKind.METHOD;
 
 /**
@@ -242,27 +244,6 @@ public Key apply(HasKey hasKey) {
             }));
   }
 
-  /**
-   * Wraps an {@link Optional} of a type in an {@code Optional} of a {@link Wrapper} for that type.
-   */
-  private static <T> Optional<Equivalence.Wrapper<T>> wrapOptionalInEquivalence(
-      Equivalence<T> equivalence, Optional<T> optional) {
-    return optional.isPresent()
-        ? Optional.of(equivalence.wrap(optional.get()))
-        : Optional.<Equivalence.Wrapper<T>>absent();
-  }
-
-  /**
-   * Unwraps an {@link Optional} of a {@link Wrapper} into an {@code Optional} of the underlying
-   * type.
-   */
-  private static <T> Optional<T> unwrapOptionalEquivalence(
-      Optional<Equivalence.Wrapper<T>> wrappedOptional) {
-    return wrappedOptional.isPresent()
-        ? Optional.of(wrappedOptional.get().get())
-        : Optional.<T>absent();
-  }
-
   static final class Factory {
     private final Types types;
     private final Elements elements;
@@ -350,12 +331,13 @@ private Key forProvidesOrProducesMethod(
     }
 
     /**
-     * Returns the key for a method in a {@link Multibindings @Multibindings} interface.
+     * Returns the key for a {@link Multibinds @Multibinds} method or a method in a
+     * {@link Multibindings @Multibindings} interface.
      *
      * The key's type is either {@code Set<T>} or {@code Map<K, F<V>>}, where {@code F} is either
      * {@link Provider} or {@link Producer}, depending on {@code bindingType}.
      */
-    Key forMultibindingsMethod(
+    Key forMultibindsMethod(
         BindingType bindingType, ExecutableType executableType, ExecutableElement method) {
       checkArgument(method.getKind().equals(METHOD), "%s must be a method", method);
       TypeElement factoryType =
@@ -416,7 +398,7 @@ private TypeMirror mapKeyType(ExecutableElement method) {
 
     private Key forMethod(ExecutableElement method, TypeMirror keyType) {
       return new AutoValue_Key(
-          wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), getQualifier(method)),
+          wrapOptionalInEquivalence(getQualifier(method)),
           MoreTypes.equivalence().wrap(keyType),
           Optional.<BindingMethodIdentifier>absent());
     }
@@ -444,7 +426,7 @@ Key forMembersInjectedType(TypeMirror type) {
 
     Key forQualifiedType(Optional<AnnotationMirror> qualifier, TypeMirror type) {
       return new AutoValue_Key(
-          wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), qualifier),
+          wrapOptionalInEquivalence(qualifier),
           MoreTypes.equivalence().wrap(normalize(types, type)),
           Optional.<BindingMethodIdentifier>absent());
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeys.java b/compiler/src/main/java/dagger/internal/codegen/MapKeys.java
index 099397369..00ae1d337 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapKeys.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeys.java
@@ -20,8 +20,8 @@
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
-import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.TypeName;
 import dagger.MapKey;
 import java.util.List;
@@ -62,11 +62,11 @@
    * @throws IllegalArgumentException if the element is annotated with more than one {@code MapKey}
    *     annotation
    */
-  static Optional<? extends AnnotationMirror> getMapKey(Element bindingElement) {
+  static Optional<AnnotationMirror> getMapKey(Element bindingElement) {
     ImmutableSet<? extends AnnotationMirror> mapKeys = getMapKeys(bindingElement);
     return mapKeys.isEmpty()
         ? Optional.<AnnotationMirror>absent()
-        : Optional.of(getOnlyElement(mapKeys));
+        : Optional.<AnnotationMirror>of(getOnlyElement(mapKeys));
   }
 
   /**
@@ -150,8 +150,7 @@ public static ClassName getMapKeyCreatorClassName(TypeElement mapKeyType) {
    * @throws IllegalStateException if {@code bindingElement} is not annotated with a {@code MapKey}
    *     annotation
    */
-  static CodeBlock getMapKeyExpression(Element bindingElement) {
-    AnnotationMirror mapKey = getMapKey(bindingElement).get();
+  static CodeBlock getMapKeyExpression(AnnotationMirror mapKey) {
     ClassName mapKeyCreator =
         getMapKeyCreatorClassName(MoreTypes.asTypeElement(mapKey.getAnnotationType()));
     Optional<? extends AnnotationValue> unwrappedValue = unwrapValue(mapKey);
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
index 1310365c9..dc2c28ee8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
@@ -74,9 +74,11 @@
  * @since 2.0
  */
 final class MembersInjectorGenerator extends SourceFileGenerator<MembersInjectionBinding> {
+  private final InjectValidator injectValidator;
 
-  MembersInjectorGenerator(Filer filer, Elements elements) {
+  MembersInjectorGenerator(Filer filer, Elements elements, InjectValidator injectValidator) {
     super(filer, elements);
+    this.injectValidator = injectValidator;
   }
 
   @Override
@@ -95,6 +97,9 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
     if (binding.injectionSites().isEmpty()) {
       return Optional.absent();
     }
+    if (!injectValidator.isValidType(binding.key().type())) {
+      return Optional.absent();
+    }
     // We don't want to write out resolved bindings -- we want to write out the generic version.
     checkState(!binding.unresolved().isPresent());
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
index a4e645ec3..c875d23c7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
@@ -27,6 +27,7 @@
 import dagger.Module;
 import dagger.Multibindings;
 import dagger.Provides;
+import dagger.multibindings.Multibinds;
 import dagger.producers.ProducerModule;
 import dagger.producers.Produces;
 import java.lang.annotation.Annotation;
@@ -168,6 +169,8 @@ ModuleDescriptor create(TypeElement moduleElement) {
 
       ImmutableSet.Builder<ContributionBinding> bindings = ImmutableSet.builder();
       ImmutableSet.Builder<DelegateDeclaration> delegates = ImmutableSet.builder();
+      ImmutableSet.Builder<MultibindingDeclaration> multibindingDeclarations =
+          ImmutableSet.builder();
       for (ExecutableElement moduleMethod : methodsIn(elements.getAllMembers(moduleElement))) {
         if (isAnnotationPresent(moduleMethod, Provides.class)) {
           bindings.add(provisionBindingFactory.forProvidesMethod(moduleMethod, moduleElement));
@@ -178,14 +181,16 @@ ModuleDescriptor create(TypeElement moduleElement) {
         if (isAnnotationPresent(moduleMethod, Binds.class)) {
           delegates.add(bindingDelegateDeclarationFactory.create(moduleMethod, moduleElement));
         }
+        if (isAnnotationPresent(moduleMethod, Multibinds.class)) {
+          multibindingDeclarations.add(
+              multibindingDeclarationFactory.forMultibindsMethod(moduleMethod, moduleElement));
+        }
       }
 
-      ImmutableSet.Builder<MultibindingDeclaration> multibindingDeclarations =
-          ImmutableSet.builder();
       for (TypeElement memberType : typesIn(elements.getAllMembers(moduleElement))) {
         if (isAnnotationPresent(memberType, Multibindings.class)) {
           multibindingDeclarations.addAll(
-              multibindingDeclarationFactory.forDeclaredInterface(memberType));
+              multibindingDeclarationFactory.forMultibindingsInterface(memberType));
         }
       }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
index 4e095b944..33fd0b82b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
@@ -15,16 +15,14 @@
  */
 package dagger.internal.codegen;
 
-import com.google.auto.common.BasicAnnotationProcessor;
-import com.google.auto.common.MoreElements;
-import com.google.common.base.Function;
-import com.google.common.collect.FluentIterable;
+import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.SetMultimap;
 import com.google.common.collect.Sets;
-import dagger.Binds;
 import dagger.Module;
 import dagger.Provides;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
 import java.lang.annotation.Annotation;
 import java.util.List;
 import java.util.Set;
@@ -32,107 +30,138 @@
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.util.ElementFilter;
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static javax.lang.model.element.ElementKind.METHOD;
+import static dagger.internal.codegen.Util.elementsWithAnnotation;
+import static javax.lang.model.util.ElementFilter.methodsIn;
+import static javax.lang.model.util.ElementFilter.typesIn;
 
 /**
- * An annotation processor for generating Dagger implementation code based on the {@link Module}
- * (and {@link Provides}) annotation.
+ * A {@link ProcessingStep} that validates module classes and generates factories for binding
+ * methods.
  *
- * @author Gregory Kick
- * @since 2.0
+ * @param <B> the type of binding created from methods
  */
-final class ModuleProcessingStep implements BasicAnnotationProcessor.ProcessingStep {
+final class ModuleProcessingStep<B extends Binding> implements ProcessingStep {
+
+  /**
+   * A {@link ProcessingStep} for {@link Module @Module} classes that generates factories for
+   * {@link Provides @Provides} methods.
+   */
+  static ModuleProcessingStep<ProvisionBinding> moduleProcessingStep(
+      Messager messager,
+      ModuleValidator moduleValidator,
+      final ProvisionBinding.Factory provisionBindingFactory,
+      FactoryGenerator factoryGenerator,
+      ProvidesMethodValidator providesMethodValidator,
+      BindsMethodValidator bindsMethodValidator,
+      MultibindsMethodValidator multibindsMethodValidator) {
+    return new ModuleProcessingStep<>(
+        messager,
+        Module.class,
+        moduleValidator,
+        Provides.class,
+        new ModuleMethodBindingFactory<ProvisionBinding>() {
+          @Override
+          public ProvisionBinding bindingForModuleMethod(
+              ExecutableElement method, TypeElement module) {
+            return provisionBindingFactory.forProvidesMethod(method, module);
+          }
+        },
+        factoryGenerator,
+        ImmutableSet.of(providesMethodValidator, bindsMethodValidator, multibindsMethodValidator));
+  }
+
+  /**
+   * A {@link ProcessingStep} for {@link ProducerModule @ProducerModule} classes that generates
+   * factories for {@link Produces @Produces} methods.
+   */
+  static ModuleProcessingStep<ProductionBinding> producerModuleProcessingStep(
+      Messager messager,
+      ModuleValidator moduleValidator,
+      final ProductionBinding.Factory productionBindingFactory,
+      ProducerFactoryGenerator producerFactoryGenerator,
+      ProducesMethodValidator producesMethodValidator,
+      BindsMethodValidator bindsMethodValidator,
+      MultibindsMethodValidator multibindsMethodValidator) {
+    return new ModuleProcessingStep<>(
+        messager,
+        ProducerModule.class,
+        moduleValidator,
+        Produces.class,
+        new ModuleMethodBindingFactory<ProductionBinding>() {
+          @Override
+          public ProductionBinding bindingForModuleMethod(
+              ExecutableElement method, TypeElement module) {
+            return productionBindingFactory.forProducesMethod(method, module);
+          }
+        },
+        producerFactoryGenerator,
+        ImmutableSet.of(producesMethodValidator, bindsMethodValidator, multibindsMethodValidator));
+  }
+
   private final Messager messager;
+  private final Class<? extends Annotation> moduleAnnotation;
   private final ModuleValidator moduleValidator;
-  private final ProvidesMethodValidator providesMethodValidator;
-  private final BindsMethodValidator bindsMethodValidator;
-  private final ProvisionBinding.Factory provisionBindingFactory;
-  private final FactoryGenerator factoryGenerator;
-  private final Set<Element> processedModuleElements = Sets.newLinkedHashSet();
+  private final Class<? extends Annotation> factoryMethodAnnotation;
+  private final ModuleMethodBindingFactory<B> moduleMethodBindingFactory;
+  private final SourceFileGenerator<B> factoryGenerator;
+  private final ImmutableSet<? extends BindingMethodValidator> methodValidators;
+  private final Set<TypeElement> processedModuleElements = Sets.newLinkedHashSet();
 
+  /**
+   * Creates a new processing step.
+   *
+   * @param moduleAnnotation the annotation on the module class
+   * @param factoryMethodAnnotation the annotation on methods that need factories
+   * @param methodValidators validators for binding methods
+   */
   ModuleProcessingStep(
       Messager messager,
+      Class<? extends Annotation> moduleAnnotation,
       ModuleValidator moduleValidator,
-      ProvidesMethodValidator providesMethodValidator,
-      ProvisionBinding.Factory provisionBindingFactory,
-      BindsMethodValidator bindsMethodValidator,
-      FactoryGenerator factoryGenerator) {
+      Class<? extends Annotation> factoryMethodAnnotation,
+      ModuleMethodBindingFactory<B> moduleMethodBindingFactory,
+      SourceFileGenerator<B> factoryGenerator,
+      Iterable<? extends BindingMethodValidator> methodValidators) {
     this.messager = messager;
+    this.moduleAnnotation = moduleAnnotation;
     this.moduleValidator = moduleValidator;
-    this.providesMethodValidator = providesMethodValidator;
-    this.bindsMethodValidator = bindsMethodValidator;
-    this.provisionBindingFactory = provisionBindingFactory;
+    this.factoryMethodAnnotation = factoryMethodAnnotation;
+    this.moduleMethodBindingFactory = moduleMethodBindingFactory;
     this.factoryGenerator = factoryGenerator;
+    this.methodValidators = ImmutableSet.copyOf(methodValidators);
   }
 
   @Override
-  public Set<Class<? extends Annotation>> annotations() {
-    return ImmutableSet.of(Module.class, Provides.class, Binds.class);
+  public Set<? extends Class<? extends Annotation>> annotations() {
+    ImmutableSet.Builder<Class<? extends Annotation>> annotations = ImmutableSet.builder();
+    annotations.add(moduleAnnotation);
+    for (BindingMethodValidator validator : methodValidators) {
+      annotations.add(validator.methodAnnotation());
+    }
+    return annotations.build();
   }
 
   @Override
   public Set<Element> process(
       SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
-    // first, check and collect all provides methods
-    ImmutableSet<ExecutableElement> validProvidesMethods =
-        validateProvidesMethods(elementsByAnnotation);
-
-    // second, check and collect all bind methods
-    ImmutableSet<ExecutableElement> validBindsMethods = validateBindsMethods(elementsByAnnotation);
+    ImmutableSet<ExecutableElement> validMethods = validMethods(elementsByAnnotation);
 
     // process each module
-    for (Element moduleElement :
-        Sets.difference(elementsByAnnotation.get(Module.class), processedModuleElements)) {
-      ValidationReport<TypeElement> report =
-          moduleValidator.validate(MoreElements.asType(moduleElement));
+    for (TypeElement moduleElement :
+        Sets.difference(
+            typesIn(elementsByAnnotation.get(moduleAnnotation)), processedModuleElements)) {
+      ValidationReport<TypeElement> report = moduleValidator.validate(moduleElement);
       report.printMessagesTo(messager);
 
       if (report.isClean()) {
-        ImmutableSet.Builder<ExecutableElement> moduleProvidesMethodsBuilder =
-            ImmutableSet.builder();
-        ImmutableSet.Builder<ExecutableElement> moduleBindsMethodsBuilder =
-            ImmutableSet.builder();
-        List<ExecutableElement> moduleMethods =
-            ElementFilter.methodsIn(moduleElement.getEnclosedElements());
-        for (ExecutableElement methodElement : moduleMethods) {
-          if (isAnnotationPresent(methodElement, Provides.class)) {
-            moduleProvidesMethodsBuilder.add(methodElement);
-          }
-          if (isAnnotationPresent(methodElement, Binds.class)) {
-            moduleBindsMethodsBuilder.add(methodElement);
-          }
-        }
-        ImmutableSet<ExecutableElement> moduleProvidesMethods =
-            moduleProvidesMethodsBuilder.build();
-        ImmutableSet<ExecutableElement> moduleBindsMethods =
-            moduleBindsMethodsBuilder.build();
-
-        if (Sets.difference(moduleProvidesMethods, validProvidesMethods).isEmpty()
-            && Sets.difference(moduleBindsMethods, validBindsMethods).isEmpty()) {
-          // all of the provides and bind methods in this module are valid!
-          // time to generate some factories!
-          ImmutableSet<ProvisionBinding> bindings =
-              FluentIterable.from(moduleProvidesMethods)
-                  .transform(
-                      new Function<ExecutableElement, ProvisionBinding>() {
-                        @Override
-                        public ProvisionBinding apply(ExecutableElement providesMethod) {
-                          return provisionBindingFactory.forProvidesMethod(
-                              providesMethod,
-                              MoreElements.asType(providesMethod.getEnclosingElement()));
-                        }
-                      })
-                  .toSet();
-
-          try {
-            for (ProvisionBinding binding : bindings) {
-              factoryGenerator.generate(binding);
-            }
-          } catch (SourceFileGenerationException e) {
-            e.printMessageTo(messager);
+        List<ExecutableElement> moduleMethods = methodsIn(moduleElement.getEnclosedElements());
+        if (moduleMethodsAreValid(validMethods, moduleMethods)) {
+          for (ExecutableElement method :
+              elementsWithAnnotation(moduleMethods, factoryMethodAnnotation)) {
+            generateFactory(
+                moduleMethodBindingFactory.bindingForModuleMethod(method, moduleElement));
           }
         }
       }
@@ -141,40 +170,45 @@ public ProvisionBinding apply(ExecutableElement providesMethod) {
     return ImmutableSet.of();
   }
 
-  /* TODO(gak): Add an interface for Validators and combine these two methods and the ones in
-   * ProducerModuleProcessingStep */
-
-  private ImmutableSet<ExecutableElement> validateBindsMethods(
+  /** The binding methods that are valid according to their validator. */
+  private ImmutableSet<ExecutableElement> validMethods(
       SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
-    ImmutableSet.Builder<ExecutableElement> validBindsMethodsBuilder = ImmutableSet.builder();
-    for (Element bindElement : elementsByAnnotation.get(Binds.class)) {
-      if (bindElement.getKind().equals(METHOD)) {
-        ExecutableElement bindsMethodElement = (ExecutableElement) bindElement;
-        ValidationReport<ExecutableElement> methodReport =
-            bindsMethodValidator.validate(bindsMethodElement);
-        methodReport.printMessagesTo(messager);
-        if (methodReport.isClean()) {
-          validBindsMethodsBuilder.add(bindsMethodElement);
-        }
-      }
+    ImmutableSet.Builder<ExecutableElement> validMethods = ImmutableSet.builder();
+    for (BindingMethodValidator validator : methodValidators) {
+      validMethods.addAll(
+          validator.validate(
+              messager, methodsIn(elementsByAnnotation.get(validator.methodAnnotation()))));
     }
-    return validBindsMethodsBuilder.build();
+    return validMethods.build();
   }
 
-  private ImmutableSet<ExecutableElement> validateProvidesMethods(
-      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
-    ImmutableSet.Builder<ExecutableElement> validProvidesMethodsBuilder = ImmutableSet.builder();
-    for (Element providesElement : elementsByAnnotation.get(Provides.class)) {
-      if (providesElement.getKind().equals(METHOD)) {
-        ExecutableElement providesMethodElement = (ExecutableElement) providesElement;
-        ValidationReport<ExecutableElement> methodReport =
-            providesMethodValidator.validate(providesMethodElement);
-        methodReport.printMessagesTo(messager);
-        if (methodReport.isClean()) {
-          validProvidesMethodsBuilder.add(providesMethodElement);
+  /**
+   * {@code true} if all {@code moduleMethods} that are annotated with a binding method annotation
+   * are in {@code validMethods}.
+   */
+  private boolean moduleMethodsAreValid(
+      ImmutableSet<ExecutableElement> validMethods, Iterable<ExecutableElement> moduleMethods) {
+    for (ExecutableElement methodElement : moduleMethods) {
+      if (!validMethods.contains(methodElement)) {
+        for (BindingMethodValidator validator : methodValidators) {
+          if (isAnnotationPresent(methodElement, validator.methodAnnotation())) {
+            return false;
+          }
         }
       }
     }
-    return validProvidesMethodsBuilder.build();
+    return true;
+  }
+
+  private void generateFactory(B binding) {
+    try {
+      factoryGenerator.generate(binding);
+    } catch (SourceFileGenerationException e) {
+      e.printMessageTo(messager);
+    }
+  }
+
+  private interface ModuleMethodBindingFactory<B extends Binding> {
+    B bindingForModuleMethod(ExecutableElement method, TypeElement module);
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
index 4d56bbe7d..b11da4c46 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
@@ -28,6 +28,7 @@
 import com.google.common.collect.Sets;
 import dagger.Binds;
 import dagger.Module;
+import dagger.multibindings.Multibinds;
 import dagger.producers.ProducerModule;
 import java.lang.annotation.Annotation;
 import java.util.Collection;
@@ -61,6 +62,7 @@
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_OVERRIDES_ANOTHER;
 import static dagger.internal.codegen.ErrorMessages.REFERENCED_MODULE_MUST_NOT_HAVE_TYPE_PARAMS;
 import static dagger.internal.codegen.ErrorMessages.REFERENCED_MODULE_NOT_ANNOTATED;
+import static dagger.internal.codegen.Util.isAnyAnnotationPresent;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.STATIC;
 
@@ -92,14 +94,11 @@
 
     Set<ModuleMethodKind> methodKinds = EnumSet.noneOf(ModuleMethodKind.class);
     for (ExecutableElement moduleMethod : moduleMethods) {
-      if (isAnnotationPresent(moduleMethod, moduleKind.methodAnnotation())) {
+      if (isAnyAnnotationPresent(
+          moduleMethod,
+          ImmutableSet.of(moduleKind.methodAnnotation(), Binds.class, Multibinds.class))) {
         bindingMethodsByName.put(moduleMethod.getSimpleName().toString(), moduleMethod);
-        methodKinds.add(
-            moduleMethod.getModifiers().contains(STATIC)
-                ? ModuleMethodKind.STATIC_BINDING
-                : ModuleMethodKind.INSTANCE_BINDING);
-      } else if (isAnnotationPresent(moduleMethod, Binds.class)) {
-        methodKinds.add(ModuleMethodKind.ABSTRACT_DECLARATION);
+        methodKinds.add(ModuleMethodKind.ofMethod(moduleMethod));
       }
       allMethodsByName.put(moduleMethod.getSimpleName().toString(), moduleMethod);
     }
@@ -130,6 +129,17 @@
     ABSTRACT_DECLARATION,
     INSTANCE_BINDING,
     STATIC_BINDING,
+    ;
+
+    static ModuleMethodKind ofMethod(ExecutableElement moduleMethod) {
+      if (moduleMethod.getModifiers().contains(STATIC)) {
+        return STATIC_BINDING;
+      } else if (moduleMethod.getModifiers().contains(ABSTRACT)) {
+        return ABSTRACT_DECLARATION;
+      } else {
+        return INSTANCE_BINDING;
+      }
+    }
   }
 
   private void validateModifiers(
diff --git a/compiler/src/main/java/dagger/internal/codegen/MoreAnnotationMirrors.java b/compiler/src/main/java/dagger/internal/codegen/MoreAnnotationMirrors.java
new file mode 100644
index 000000000..e81076af4
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/MoreAnnotationMirrors.java
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.AnnotationMirrors;
+import com.google.common.base.Equivalence;
+import com.google.common.base.Optional;
+import javax.lang.model.element.AnnotationMirror;
+
+/**
+ * A utility class for working with {@link AnnotationMirror} instances, similar to {@link
+ * AnnotationMirrors}.
+ */
+final class MoreAnnotationMirrors {
+
+  private MoreAnnotationMirrors() {}
+
+  /**
+   * Wraps an {@link Optional} of a type in an {@code Optional} of a {@link Equivalence.Wrapper} for
+   * that type.
+   */
+  static Optional<Equivalence.Wrapper<AnnotationMirror>> wrapOptionalInEquivalence(
+      Optional<AnnotationMirror> optional) {
+    return optional.isPresent()
+        ? Optional.of(AnnotationMirrors.equivalence().wrap(optional.get()))
+        : Optional.<Equivalence.Wrapper<AnnotationMirror>>absent();
+  }
+
+  /**
+   * Unwraps an {@link Optional} of a {@link Equivalence.Wrapper} into an {@code Optional} of the
+   * underlying type.
+   */
+  static Optional<AnnotationMirror> unwrapOptionalEquivalence(
+      Optional<Equivalence.Wrapper<AnnotationMirror>> wrappedOptional) {
+    return wrappedOptional.isPresent()
+        ? Optional.of(wrappedOptional.get().get())
+        : Optional.<AnnotationMirror>absent();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/MultibindingDeclaration.java b/compiler/src/main/java/dagger/internal/codegen/MultibindingDeclaration.java
index c682d6497..d41b71663 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MultibindingDeclaration.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MultibindingDeclaration.java
@@ -23,11 +23,13 @@
 import dagger.Multibindings;
 import dagger.internal.codegen.BindingType.HasBindingType;
 import dagger.internal.codegen.ContributionType.HasContributionType;
+import dagger.multibindings.Multibinds;
 import dagger.producers.Producer;
 import dagger.producers.ProducerModule;
 import java.util.Map;
 import java.util.Set;
 import javax.inject.Provider;
+import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
@@ -93,10 +95,10 @@
      * Creates multibinding declarations for each method in a
      * {@link Multibindings @Multibindings}-annotated interface.
      */
-    ImmutableSet<MultibindingDeclaration> forDeclaredInterface(TypeElement interfaceElement) {
+    ImmutableSet<MultibindingDeclaration> forMultibindingsInterface(TypeElement interfaceElement) {
       checkArgument(interfaceElement.getKind().equals(INTERFACE));
       checkArgument(isAnnotationPresent(interfaceElement, Multibindings.class));
-      BindingType bindingType = bindingType(interfaceElement);
+      BindingType bindingType = bindingType(interfaceElement.getEnclosingElement());
       DeclaredType interfaceType = MoreTypes.asDeclared(interfaceElement.asType());
 
       ImmutableSet.Builder<MultibindingDeclaration> declarations = ImmutableSet.builder();
@@ -110,15 +112,26 @@
       return declarations.build();
     }
 
-    private BindingType bindingType(TypeElement interfaceElement) {
-      if (isAnnotationPresent(interfaceElement.getEnclosingElement(), Module.class)) {
+    /** A multibinding declaration for a {@link Multibinds @Multibinds} method. */
+    MultibindingDeclaration forMultibindsMethod(
+        ExecutableElement moduleMethod, TypeElement moduleElement) {
+      checkArgument(isAnnotationPresent(moduleMethod, Multibinds.class));
+      return forDeclaredMethod(
+          bindingType(moduleElement),
+          moduleMethod,
+          MoreTypes.asExecutable(
+              types.asMemberOf(MoreTypes.asDeclared(moduleElement.asType()), moduleMethod)),
+          moduleElement);
+    }
+
+    private BindingType bindingType(Element moduleElement) {
+      if (isAnnotationPresent(moduleElement, Module.class)) {
         return BindingType.PROVISION;
-      } else if (isAnnotationPresent(
-          interfaceElement.getEnclosingElement(), ProducerModule.class)) {
+      } else if (isAnnotationPresent(moduleElement, ProducerModule.class)) {
         return BindingType.PRODUCTION;
       } else {
         throw new IllegalArgumentException(
-            "Expected " + interfaceElement + " to be nested in a @Module or @ProducerModule");
+            "Expected " + moduleElement + " to be a @Module or @ProducerModule");
       }
     }
 
@@ -126,7 +139,7 @@ private MultibindingDeclaration forDeclaredMethod(
         BindingType bindingType,
         ExecutableElement method,
         ExecutableType methodType,
-        TypeElement interfaceElement) {
+        TypeElement contributingType) {
       TypeMirror returnType = methodType.getReturnType();
       checkArgument(
           SetType.isSet(returnType) || MapType.isMap(returnType),
@@ -134,8 +147,8 @@ private MultibindingDeclaration forDeclaredMethod(
           method);
       return new AutoValue_MultibindingDeclaration(
           method,
-          Optional.of(interfaceElement),
-          keyFactory.forMultibindingsMethod(bindingType, methodType, method),
+          Optional.of(contributingType),
+          keyFactory.forMultibindsMethod(bindingType, methodType, method),
           contributionType(returnType),
           bindingType);
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MultibindingsMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/MultibindingsMethodValidator.java
new file mode 100644
index 000000000..4b7252cf6
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/MultibindingsMethodValidator.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableSet;
+import dagger.Multibindings;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+
+/** A {@link Validator} for methods in {@link Multibindings @Multibindings} interfaces. */
+final class MultibindingsMethodValidator extends MultibindsMethodValidator {
+
+  MultibindingsMethodValidator(Elements elements, Types types) {
+    super(elements, types, Multibindings.class, ImmutableSet.of(Multibindings.class));
+  }
+
+  @Override
+  protected void checkEnclosingElement(ValidationReport.Builder<ExecutableElement> builder) {
+    // no-op, since @Multibindings interfaces can inherit methods from unannotated supertypes.
+  }
+}
+
diff --git a/compiler/src/main/java/dagger/internal/codegen/MultibindingsValidator.java b/compiler/src/main/java/dagger/internal/codegen/MultibindingsValidator.java
index d68e1dec3..664029937 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MultibindingsValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MultibindingsValidator.java
@@ -15,35 +15,25 @@
  */
 package dagger.internal.codegen;
 
-import com.google.auto.common.MoreTypes;
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableListMultimap;
-import com.google.common.collect.ImmutableSet;
 import dagger.Module;
 import dagger.Multibindings;
-import dagger.producers.Produced;
-import dagger.producers.Producer;
 import dagger.producers.ProducerModule;
 import java.util.Collection;
 import java.util.Map;
-import javax.inject.Provider;
-import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 
 import static com.google.auto.common.MoreElements.getLocalAndInheritedMethods;
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.auto.common.MoreTypes.asExecutable;
 import static dagger.internal.codegen.ErrorMessages.DUPLICATE_SIZE_LIMIT;
-import static dagger.internal.codegen.ErrorMessages.MultibindingsMessages.METHOD_MUST_RETURN_MAP_OR_SET;
 import static dagger.internal.codegen.ErrorMessages.MultibindingsMessages.MUST_BE_INTERFACE;
 import static dagger.internal.codegen.ErrorMessages.MultibindingsMessages.MUST_BE_IN_MODULE;
 import static dagger.internal.codegen.ErrorMessages.MultibindingsMessages.MUST_NOT_HAVE_TYPE_PARAMETERS;
-import static dagger.internal.codegen.ErrorMessages.MultibindingsMessages.TOO_MANY_QUALIFIERS;
 import static dagger.internal.codegen.ErrorMessages.MultibindingsMessages.tooManyMethodsForKey;
-import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
 import static javax.lang.model.element.ElementKind.INTERFACE;
 
 /**
@@ -56,16 +46,19 @@
   private final KeyFormatter keyFormatter;
   private final MethodSignatureFormatter methodSignatureFormatter;
   private final TypeElement objectElement;
+  private final MultibindingsMethodValidator multibindingsMethodValidator;
 
   MultibindingsValidator(
       Elements elements,
       Key.Factory keyFactory,
       KeyFormatter keyFormatter,
-      MethodSignatureFormatter methodSignatureFormatter) {
+      MethodSignatureFormatter methodSignatureFormatter,
+      MultibindingsMethodValidator multibindingsMethodValidator) {
     this.elements = elements;
     this.keyFactory = keyFactory;
     this.keyFormatter = keyFormatter;
     this.methodSignatureFormatter = methodSignatureFormatter;
+    this.multibindingsMethodValidator = multibindingsMethodValidator;
     this.objectElement = elements.getTypeElement(Object.class.getCanonicalName());
   }
 
@@ -93,20 +86,14 @@
       if (method.getEnclosingElement().equals(objectElement)) {
         continue;
       }
-      if (!isPlainMap(method.getReturnType()) && !isPlainSet(method.getReturnType())) {
-        validation.addError(METHOD_MUST_RETURN_MAP_OR_SET, method);
-        continue;
-      }
-      ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(method);
-      if (qualifiers.size() > 1) {
-        for (AnnotationMirror qualifier : qualifiers) {
-          validation.addError(TOO_MANY_QUALIFIERS, method, qualifier);
-        }
-        continue;
-      }
-      if (bindingType.isPresent()) {
+      
+      ValidationReport<ExecutableElement> methodReport =
+          multibindingsMethodValidator.validate(method);
+      validation.addItems(methodReport.items());
+
+      if (methodReport.isClean() && bindingType.isPresent()) {
         methodsByKey.put(
-            keyFactory.forMultibindingsMethod(
+            keyFactory.forMultibindsMethod(
                 bindingType.get(), asExecutable(method.asType()), method),
             method);
       }
@@ -138,28 +125,4 @@ private String tooManyMultibindingsMethodsForKey(Key key, Collection<ExecutableE
       return Optional.<BindingType>absent();
     }
   }
-
-  private boolean isPlainMap(TypeMirror returnType) {
-    if (!MapType.isMap(returnType)) {
-      return false;
-    }
-    MapType mapType = MapType.from(returnType);
-    return !mapType.isRawType()
-        && MoreTypes.isType(mapType.valueType()) // No wildcards.
-        && !mapType.valuesAreTypeOf(Provider.class)
-        && !mapType.valuesAreTypeOf(Producer.class)
-        && !mapType.valuesAreTypeOf(Produced.class);
-  }
-
-  private boolean isPlainSet(TypeMirror returnType) {
-    if (!SetType.isSet(returnType)) {
-      return false;
-    }
-    SetType setType = SetType.from(returnType);
-    return !setType.isRawType()
-        && MoreTypes.isType(setType.elementType()) // No wildcards.
-        && !setType.elementsAreTypeOf(Provider.class)
-        && !setType.elementsAreTypeOf(Producer.class)
-        && !setType.elementsAreTypeOf(Produced.class);
-  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MultibindsMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/MultibindsMethodValidator.java
new file mode 100644
index 000000000..3b07faad7
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/MultibindsMethodValidator.java
@@ -0,0 +1,127 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreTypes;
+import com.google.common.collect.ImmutableSet;
+import dagger.MapKey;
+import dagger.Module;
+import dagger.Multibindings;
+import dagger.multibindings.ElementsIntoSet;
+import dagger.multibindings.IntoMap;
+import dagger.multibindings.IntoSet;
+import dagger.multibindings.Multibinds;
+import dagger.producers.ProducerModule;
+import java.lang.annotation.Annotation;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+
+import static dagger.internal.codegen.BindingMethodValidator.Abstractness.MUST_BE_ABSTRACT;
+import static dagger.internal.codegen.ErrorMessages.MultibindsMessages.METHOD_MUST_RETURN_MAP_OR_SET;
+import static dagger.internal.codegen.ErrorMessages.MultibindsMessages.NO_MAP_KEY;
+import static dagger.internal.codegen.ErrorMessages.MultibindsMessages.PARAMETERS;
+import static dagger.internal.codegen.FrameworkTypes.isFrameworkType;
+import static dagger.internal.codegen.MapKeys.getMapKeys;
+
+/**
+ * A {@link Validator} for {@link Multibinds @Multibinds} methods or methods in
+ * {@link Multibindings @Multibindings} interfaces.
+ */
+class MultibindsMethodValidator extends BindingMethodValidator {
+
+  /** Creates a {@link Validator} for {@link Multibinds @Multibinds} methods. */
+  MultibindsMethodValidator(Elements elements, Types types) {
+    this(elements, types, Multibinds.class, ImmutableSet.of(Module.class, ProducerModule.class));
+  }
+
+  protected MultibindsMethodValidator(
+      Elements elements,
+      Types types,
+      Class<? extends Annotation> methodAnnotation,
+      Iterable<? extends Class<? extends Annotation>> enclosingElementAnnotations) {
+    super(
+        elements,
+        types,
+        methodAnnotation,
+        enclosingElementAnnotations,
+        MUST_BE_ABSTRACT,
+        ExceptionSuperclass.NONE);
+  }
+  
+  @Override
+  protected void checkMethod(ValidationReport.Builder<ExecutableElement> builder) {
+    super.checkMethod(builder);
+
+    checkParameters(builder);
+  }
+
+  private void checkParameters(ValidationReport.Builder<ExecutableElement> builder) {
+    if (!builder.getSubject().getParameters().isEmpty()) {
+      builder.addError(formatErrorMessage(PARAMETERS));
+    }
+  }
+
+  /** Adds an error unless the method returns a {@code Map<K, V>} or {@code Set<T>}. */
+  @Override
+  protected void checkReturnType(ValidationReport.Builder<ExecutableElement> builder) {
+    if (!isPlainMap(builder.getSubject().getReturnType())
+        && !isPlainSet(builder.getSubject().getReturnType())) {
+      builder.addError(formatErrorMessage(METHOD_MUST_RETURN_MAP_OR_SET));
+    }
+  }
+
+  /** Adds an error if the method has any {@link MapKey @MapKey} annotations. */
+  @Override
+  protected void checkMapKeys(ValidationReport.Builder<ExecutableElement> builder) {
+    ImmutableSet<? extends AnnotationMirror> mapKeys = getMapKeys(builder.getSubject());
+    if (!mapKeys.isEmpty()) {
+      builder.addError(formatErrorMessage(NO_MAP_KEY));
+    }
+  }
+
+  /**
+   * {@link MultibindingAnnotationsProcessingStep} reports an error if {@link IntoMap @IntoMap},
+   * {@link IntoSet @IntoSet}, or {@link ElementsIntoSet @ElementsIntoSet} are applied to the method
+   * at all, so no need to check again.
+   */
+  @Override
+  protected void checkMultibindings(ValidationReport.Builder<ExecutableElement> builder) {
+    // no-op
+  }
+
+  private boolean isPlainMap(TypeMirror returnType) {
+    if (!MapType.isMap(returnType)) {
+      return false;
+    }
+    MapType mapType = MapType.from(returnType);
+    return !mapType.isRawType()
+        && MoreTypes.isType(mapType.valueType()) // No wildcards.
+        && !isFrameworkType(mapType.valueType());
+  }
+
+  private boolean isPlainSet(TypeMirror returnType) {
+    if (!SetType.isSet(returnType)) {
+      return false;
+    }
+    SetType setType = SetType.from(returnType);
+    return !setType.isRawType()
+        && MoreTypes.isType(setType.elementType()) // No wildcards.
+        && !isFrameworkType(setType.elementType());
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
index 8fbd1d0f1..e1cbc85d6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -43,12 +43,10 @@
 import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_UNCHECKED;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.CodeBlocks.toCodeBlocks;
-import static dagger.internal.codegen.ContributionType.MAP;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
 import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
 import static dagger.internal.codegen.TypeNames.ASYNC_FUNCTION;
 import static dagger.internal.codegen.TypeNames.FUTURES;
-import static dagger.internal.codegen.TypeNames.IMMUTABLE_SET;
 import static dagger.internal.codegen.TypeNames.PRODUCERS;
 import static dagger.internal.codegen.TypeNames.PRODUCER_TOKEN;
 import static dagger.internal.codegen.TypeNames.VOID_CLASS;
@@ -88,11 +86,7 @@ ClassName nameGeneratedType(ProductionBinding binding) {
 
   @Override
   Optional<TypeSpec.Builder> write(ClassName generatedTypeName, ProductionBinding binding) {
-    TypeMirror keyType =
-        binding.contributionType().equals(MAP)
-            ? MapType.from(binding.key().type()).unwrappedValueType(Producer.class)
-            : binding.key().type();
-    TypeName providedTypeName = TypeName.get(keyType);
+    TypeName providedTypeName = TypeName.get(binding.factoryType());
     TypeName futureTypeName = listenableFutureOf(providedTypeName);
 
     TypeSpec.Builder factoryBuilder =
@@ -474,22 +468,11 @@ private CodeBlock getInvocationCodeBlock(
     ImmutableList.Builder<CodeBlock> codeBlocks = ImmutableList.builder();
     codeBlocks.add(CodeBlock.of("monitor.methodStarting();"));
 
-    final CodeBlock valueCodeBlock;
-    if (binding.contributionType().equals(ContributionType.SET)) {
-      if (binding.bindingKind().equals(ContributionBinding.Kind.FUTURE_PRODUCTION)) {
-        valueCodeBlock =
-            CodeBlock.of("$T.createFutureSingletonSet($L)", PRODUCERS, moduleCodeBlock);
-      } else {
-        valueCodeBlock = CodeBlock.of("$T.of($L)", IMMUTABLE_SET, moduleCodeBlock);
-      }
-    } else {
-      valueCodeBlock = moduleCodeBlock;
-    }
     CodeBlock returnCodeBlock =
         binding.bindingKind().equals(ContributionBinding.Kind.FUTURE_PRODUCTION)
-            ? valueCodeBlock
+            ? moduleCodeBlock
             : CodeBlock.of(
-                "$T.<$T>immediateFuture($L)", FUTURES, providedTypeName, valueCodeBlock);
+                "$T.<$T>immediateFuture($L)", FUTURES, providedTypeName, moduleCodeBlock);
     return CodeBlock.of(
         Joiner.on('\n')
             .join(
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerModuleProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ProducerModuleProcessingStep.java
deleted file mode 100644
index fa8a8227d..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerModuleProcessingStep.java
+++ /dev/null
@@ -1,181 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
-import com.google.auto.common.MoreElements;
-import com.google.auto.common.SuperficialValidation;
-import com.google.common.base.Function;
-import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.SetMultimap;
-import com.google.common.collect.Sets;
-import dagger.Binds;
-import dagger.producers.ProducerModule;
-import dagger.producers.Produces;
-import java.lang.annotation.Annotation;
-import java.util.List;
-import java.util.Set;
-import javax.annotation.processing.Messager;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.util.ElementFilter;
-
-import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static javax.lang.model.element.ElementKind.METHOD;
-
-/**
- * An annotation processor for generating Dagger implementation code based on the
- * {@link ProducerModule} (and {@link Produces}) annotation.
- *
- * @author Jesse Beder
- * @since 2.0
- */
-final class ProducerModuleProcessingStep implements ProcessingStep {
-  private final Messager messager;
-  private final ModuleValidator moduleValidator;
-  private final ProducesMethodValidator producesMethodValidator;
-  private final BindsMethodValidator bindsMethodValidator;
-  private final ProductionBinding.Factory productionBindingFactory;
-  private final ProducerFactoryGenerator factoryGenerator;
-  private final Set<Element> processedModuleElements = Sets.newLinkedHashSet();
-
-  ProducerModuleProcessingStep(
-      Messager messager,
-      ModuleValidator moduleValidator,
-      ProducesMethodValidator producesMethodValidator,
-      BindsMethodValidator bindsMethodValidator,
-      ProductionBinding.Factory productionBindingFactory,
-      ProducerFactoryGenerator factoryGenerator) {
-    this.messager = messager;
-    this.moduleValidator = moduleValidator;
-    this.producesMethodValidator = producesMethodValidator;
-    this.bindsMethodValidator = bindsMethodValidator;
-    this.productionBindingFactory = productionBindingFactory;
-    this.factoryGenerator = factoryGenerator;
-  }
-
-  @Override
-  public Set<Class<? extends Annotation>> annotations() {
-    return ImmutableSet.of(Produces.class, ProducerModule.class);
-  }
-
-  @Override
-  public Set<Element> process(
-      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
-    // first, check and collect all produces methods
-    ImmutableSet<ExecutableElement> validProducesMethods =
-        validateProducesMethods(elementsByAnnotation);
-
-    // second, check and collect all bind methods
-    ImmutableSet<ExecutableElement> validBindsMethods = validateBindsMethods(elementsByAnnotation);
-
-    // process each module
-    for (Element moduleElement :
-        Sets.difference(elementsByAnnotation.get(ProducerModule.class),
-            processedModuleElements)) {
-      if (SuperficialValidation.validateElement(moduleElement)) {
-        ValidationReport<TypeElement> report =
-            moduleValidator.validate(MoreElements.asType(moduleElement));
-        report.printMessagesTo(messager);
-
-        if (report.isClean()) {
-          ImmutableSet.Builder<ExecutableElement> moduleProducesMethodsBuilder =
-              ImmutableSet.builder();
-          ImmutableSet.Builder<ExecutableElement> moduleBindsMethodsBuilder =
-              ImmutableSet.builder();
-          List<ExecutableElement> moduleMethods =
-              ElementFilter.methodsIn(moduleElement.getEnclosedElements());
-          for (ExecutableElement methodElement : moduleMethods) {
-            if (isAnnotationPresent(methodElement, Produces.class)) {
-              moduleProducesMethodsBuilder.add(methodElement);
-            }
-            if (isAnnotationPresent(methodElement, Binds.class)) {
-              moduleBindsMethodsBuilder.add(methodElement);
-            }
-          }
-          ImmutableSet<ExecutableElement> moduleProducesMethods =
-              moduleProducesMethodsBuilder.build();
-          ImmutableSet<ExecutableElement> moduleBindsMethods = moduleBindsMethodsBuilder.build();
-
-          if (Sets.difference(moduleProducesMethods, validProducesMethods).isEmpty()
-              && Sets.difference(moduleBindsMethods, validBindsMethods).isEmpty()) {
-            // all of the produces methods in this module are valid!
-            // time to generate some factories!
-            ImmutableSet<ProductionBinding> bindings =
-                FluentIterable.from(moduleProducesMethods)
-                    .transform(
-                        new Function<ExecutableElement, ProductionBinding>() {
-                          @Override
-                          public ProductionBinding apply(ExecutableElement producesMethod) {
-                            return productionBindingFactory.forProducesMethod(
-                                producesMethod,
-                                MoreElements.asType(producesMethod.getEnclosingElement()));
-                          }
-                        })
-                    .toSet();
-
-            try {
-              for (ProductionBinding binding : bindings) {
-                factoryGenerator.generate(binding);
-              }
-            } catch (SourceFileGenerationException e) {
-              e.printMessageTo(messager);
-            }
-          }
-        }
-
-        processedModuleElements.add(moduleElement);
-      }
-    }
-    return ImmutableSet.of();
-  }
-
-  private ImmutableSet<ExecutableElement> validateProducesMethods(
-      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
-    ImmutableSet.Builder<ExecutableElement> validProducesMethodsBuilder = ImmutableSet.builder();
-    for (Element producesElement : elementsByAnnotation.get(Produces.class)) {
-      if (producesElement.getKind().equals(METHOD)) {
-        ExecutableElement producesMethodElement = (ExecutableElement) producesElement;
-        ValidationReport<ExecutableElement> methodReport =
-            producesMethodValidator.validate(producesMethodElement);
-        methodReport.printMessagesTo(messager);
-        if (methodReport.isClean()) {
-          validProducesMethodsBuilder.add(producesMethodElement);
-        }
-      }
-    }
-    return validProducesMethodsBuilder.build();
-  }
-
-  private ImmutableSet<ExecutableElement> validateBindsMethods(
-      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
-    ImmutableSet.Builder<ExecutableElement> validBindsMethodsBuilder = ImmutableSet.builder();
-    for (Element bindElement : elementsByAnnotation.get(Binds.class)) {
-      if (bindElement.getKind().equals(METHOD)) {
-        ExecutableElement bindsMethodElement = (ExecutableElement) bindElement;
-        ValidationReport<ExecutableElement> methodReport =
-            bindsMethodValidator.validate(bindsMethodElement);
-        methodReport.printMessagesTo(messager);
-        if (methodReport.isClean()) {
-          validBindsMethodsBuilder.add(bindsMethodElement);
-        }
-      }
-    }
-    return validBindsMethodsBuilder.build();
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
index 15b7a9619..c6468fa6f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
@@ -16,212 +16,113 @@
 package dagger.internal.codegen;
 
 import com.google.auto.common.MoreTypes;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Iterables;
+import com.google.common.base.Optional;
 import com.google.common.util.concurrent.ListenableFuture;
+import dagger.multibindings.ElementsIntoSet;
 import dagger.producers.ProducerModule;
 import dagger.producers.Produces;
 import java.util.Set;
-import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.Modifier;
-import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
-import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
-import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static com.google.common.base.Preconditions.checkNotNull;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_ABSTRACT;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_RETURN_A_VALUE;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_IN_MODULE;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_PRIVATE;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_SET_VALUES_RAW_SET;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_TYPE_PARAMETER;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_MULTIPLE_MAP_KEY;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_NO_MAP_KEY;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.BindingMethodValidator.Abstractness.MUST_BE_CONCRETE;
+import static dagger.internal.codegen.BindingMethodValidator.ExceptionSuperclass.EXCEPTION;
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_NULLABLE;
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_RAW_FUTURE;
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_RETURN_TYPE;
+import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_SCOPE;
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_SET_VALUES_RETURN_SET;
-import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_THROWS;
-import static dagger.internal.codegen.MapKeys.getMapKeys;
-import static dagger.internal.codegen.ProvidesMethodValidator.validateMapKey;
-import static dagger.internal.codegen.ProvidesMethodValidator.validateMultibindingSpecifiers;
-import static dagger.internal.codegen.Validation.validateMethodQualifiers;
-import static javax.lang.model.element.Modifier.ABSTRACT;
-import static javax.lang.model.element.Modifier.PRIVATE;
-import static javax.lang.model.type.TypeKind.ARRAY;
-import static javax.lang.model.type.TypeKind.DECLARED;
-import static javax.lang.model.type.TypeKind.VOID;
 
 /**
- * A {@linkplain ValidationReport validator} for {@link Produces} methods.
+ * A validator for {@link Produces} methods.
  *
  * @author Jesse Beder
  * @since 2.0
  */
 // TODO(beder): Consider unifying this with the ProvidesMethodValidator after Provides.Type and
 // Produces.Type are reconciled.
-final class ProducesMethodValidator {
-  private final Elements elements;
-  private final Types types;
+final class ProducesMethodValidator extends BindingMethodValidator {
 
   ProducesMethodValidator(Elements elements, Types types) {
-    this.elements = checkNotNull(elements);
-    this.types = checkNotNull(types);
+    super(elements, types, Produces.class, ProducerModule.class, MUST_BE_CONCRETE, EXCEPTION);
   }
-
-  private TypeElement getSetElement() {
-    return elements.getTypeElement(Set.class.getCanonicalName());
+  
+  @Override
+  protected void checkMethod(ValidationReport.Builder<ExecutableElement> builder) {
+    super.checkMethod(builder);
+    checkNullable(builder);
+    checkScope(builder);
   }
 
-  ValidationReport<ExecutableElement> validate(ExecutableElement producesMethodElement) {
-    ValidationReport.Builder<ExecutableElement> builder =
-        ValidationReport.about(producesMethodElement);
-
-    Element enclosingElement = producesMethodElement.getEnclosingElement();
-    if (!isAnnotationPresent(enclosingElement, ProducerModule.class)) {
-      builder.addError(
-          formatModuleErrorMessage(BINDING_METHOD_NOT_IN_MODULE), producesMethodElement);
-    }
-
-    if (!producesMethodElement.getTypeParameters().isEmpty()) {
-      builder.addError(formatErrorMessage(BINDING_METHOD_TYPE_PARAMETER), producesMethodElement);
+  /** Adds a warning if a {@link Produces @Produces} method is declared nullable. */
+  // TODO(beder): Make this an error.
+  private void checkNullable(ValidationReport.Builder<ExecutableElement> builder) {
+    if (ConfigurationAnnotations.getNullableType(builder.getSubject()).isPresent()) {
+      builder.addWarning(PRODUCES_METHOD_NULLABLE);
     }
+  }
 
-    Set<Modifier> modifiers = producesMethodElement.getModifiers();
-    if (modifiers.contains(PRIVATE)) {
-      builder.addError(formatErrorMessage(BINDING_METHOD_PRIVATE), producesMethodElement);
-    }
-    if (modifiers.contains(ABSTRACT)) {
-      builder.addError(formatErrorMessage(BINDING_METHOD_ABSTRACT), producesMethodElement);
-    }
-
-    if (ConfigurationAnnotations.getNullableType(producesMethodElement).isPresent()) {
-      // TODO(beder): Make this an error.
-      builder.addWarning(PRODUCES_METHOD_NULLABLE, producesMethodElement);
-    }
-
-    TypeMirror returnType = producesMethodElement.getReturnType();
-    TypeKind returnTypeKind = returnType.getKind();
-    if (returnTypeKind.equals(VOID)) {
-      builder.addError(
-          formatErrorMessage(BINDING_METHOD_MUST_RETURN_A_VALUE), producesMethodElement);
-    }
-
-    if (FrameworkTypes.isFrameworkType(returnType)) {
-      builder.addError(
-          formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES), producesMethodElement);
-    }
-
-    TypeMirror exceptionType = elements.getTypeElement(Exception.class.getCanonicalName()).asType();
-    TypeMirror errorType = elements.getTypeElement(Error.class.getCanonicalName()).asType();
-    for (TypeMirror thrownType : producesMethodElement.getThrownTypes()) {
-      if (!types.isSubtype(thrownType, exceptionType) && !types.isSubtype(thrownType, errorType)) {
-        builder.addError(PRODUCES_METHOD_THROWS, producesMethodElement);
-        break;
-      }
-    }
-
-    ContributionType contributionType = ContributionType.fromBindingMethod(producesMethodElement);
-    validateMapKey(builder, producesMethodElement, contributionType, Produces.class);
-
-    validateMultibindingSpecifiers(builder, producesMethodElement, Produces.class);
-
-    validateMethodQualifiers(builder, producesMethodElement);
-
-    switch (contributionType) {
-      case UNIQUE:
-      case SET:
-        validateSingleReturnType(builder, returnType);
-        break;
-      case MAP:
-        validateSingleReturnType(builder, returnType);
-        ImmutableSet<? extends AnnotationMirror> mapKeys = getMapKeys(producesMethodElement);
-        switch (mapKeys.size()) {
-          case 0:
-            builder.addError(
-                formatErrorMessage(BINDING_METHOD_WITH_NO_MAP_KEY), producesMethodElement);
-            break;
-          case 1:
-            break;
-          default:
-            builder.addError(
-                formatErrorMessage(BINDING_METHOD_WITH_MULTIPLE_MAP_KEY), producesMethodElement);
-            break;
-        }
-        break;
-      case SET_VALUES:
-        if (returnTypeKind.equals(DECLARED)
-            && MoreTypes.isTypeOf(ListenableFuture.class, returnType)) {
-          DeclaredType declaredReturnType = MoreTypes.asDeclared(returnType);
-          if (!declaredReturnType.getTypeArguments().isEmpty()) {
-            validateSetType(builder, Iterables.getOnlyElement(
-                declaredReturnType.getTypeArguments()));
-          }
-        } else {
-          validateSetType(builder, returnType);
-        }
-        break;
-      default:
-        throw new AssertionError();
+  /** Adds an error if a {@link Produces @Produces} method has a scope annotation. */
+  private void checkScope(ValidationReport.Builder<ExecutableElement> builder) {
+    if (!Scope.scopesOf(builder.getSubject()).isEmpty()) {
+      builder.addError(PRODUCES_METHOD_SCOPE);
     }
-
-    return builder.build();
   }
 
-  private String formatErrorMessage(String msg) {
-    return String.format(msg, Produces.class.getSimpleName());
+  @Override
+  protected String badReturnTypeMessage() {
+    return formatErrorMessage(PRODUCES_METHOD_RETURN_TYPE);
   }
 
-  private String formatModuleErrorMessage(String msg) {
-    return String.format(msg, Produces.class.getSimpleName(), ProducerModule.class.getSimpleName());
+  /**
+   * {@inheritDoc}
+   *
+   * <p>Allows {@code keyType} to be a {@link ListenableFuture} of an otherwise-valid key type.
+   */
+  @Override
+  protected void checkKeyType(
+      ValidationReport.Builder<ExecutableElement> reportBuilder, TypeMirror keyType) {
+    Optional<TypeMirror> typeToCheck = unwrapListenableFuture(reportBuilder, keyType);
+    if (typeToCheck.isPresent()) {
+      super.checkKeyType(reportBuilder, typeToCheck.get());
+    }
   }
 
-  private void validateKeyType(ValidationReport.Builder<? extends Element> reportBuilder,
-      TypeMirror type) {
-    TypeKind kind = type.getKind();
-    if (!(kind.isPrimitive() || kind.equals(DECLARED) || kind.equals(ARRAY))) {
-      reportBuilder.addError(PRODUCES_METHOD_RETURN_TYPE, reportBuilder.getSubject());
+  /**
+   * {@inheritDoc}
+   *
+   * <p>Allows an {@link ElementsIntoSet @ElementsIntoSet} or {@code SET_VALUES} method to return a
+   * {@link ListenableFuture} of a {@link Set} as well.
+   */
+  @Override
+  protected void checkSetValuesType(ValidationReport.Builder<ExecutableElement> builder) {
+    Optional<TypeMirror> typeToCheck =
+        unwrapListenableFuture(builder, builder.getSubject().getReturnType());
+    if (typeToCheck.isPresent()) {
+      checkSetValuesType(builder, typeToCheck.get());
     }
   }
 
-  private void validateSingleReturnType(ValidationReport.Builder<? extends Element> reportBuilder,
-      TypeMirror type) {
-    if (type.getKind().equals(DECLARED) && MoreTypes.isTypeOf(ListenableFuture.class, type)) {
+  @Override
+  protected String badSetValuesTypeMessage() {
+    return PRODUCES_METHOD_SET_VALUES_RETURN_SET;
+  }
+
+  private Optional<TypeMirror> unwrapListenableFuture(
+      ValidationReport.Builder<ExecutableElement> reportBuilder, TypeMirror type) {
+    if (MoreTypes.isType(type) && MoreTypes.isTypeOf(ListenableFuture.class, type)) {
       DeclaredType declaredType = MoreTypes.asDeclared(type);
       if (declaredType.getTypeArguments().isEmpty()) {
-        reportBuilder.addError(PRODUCES_METHOD_RAW_FUTURE, reportBuilder.getSubject());
+        reportBuilder.addError(PRODUCES_METHOD_RAW_FUTURE);
+        return Optional.absent();
       } else {
-        validateKeyType(reportBuilder, Iterables.getOnlyElement(declaredType.getTypeArguments()));
+        return Optional.of((TypeMirror) getOnlyElement(declaredType.getTypeArguments()));
       }
-    } else {
-      validateKeyType(reportBuilder, type);
-    }
-  }
-
-  private void validateSetType(ValidationReport.Builder<? extends Element> reportBuilder,
-      TypeMirror type) {
-    if (!type.getKind().equals(DECLARED)) {
-      reportBuilder.addError(PRODUCES_METHOD_SET_VALUES_RETURN_SET, reportBuilder.getSubject());
-      return;
-    }
-
-    // TODO(gak): should we allow "covariant return" for set values?
-    DeclaredType declaredType = MoreTypes.asDeclared(type);
-    if (!declaredType.asElement().equals(getSetElement())) {
-      reportBuilder.addError(PRODUCES_METHOD_SET_VALUES_RETURN_SET, reportBuilder.getSubject());
-    } else if (declaredType.getTypeArguments().isEmpty()) {
-      reportBuilder.addError(
-          formatErrorMessage(BINDING_METHOD_SET_VALUES_RAW_SET), reportBuilder.getSubject());
-    } else {
-      validateSingleReturnType(reportBuilder,
-          Iterables.getOnlyElement(declaredType.getTypeArguments()));
     }
+    return Optional.of(type);
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
index 268bfafab..38830b8a3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
@@ -17,12 +17,15 @@
 
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
+import com.google.common.base.Equivalence;
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
 import com.google.common.util.concurrent.ListenableFuture;
 import java.util.Set;
+
+import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
@@ -32,6 +35,8 @@
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.codegen.MapKeys.getMapKey;
+import static dagger.internal.codegen.MoreAnnotationMirrors.wrapOptionalInEquivalence;
 import static javax.lang.model.element.ElementKind.METHOD;
 
 /**
@@ -114,6 +119,7 @@ ProductionBinding forProducesMethod(
           findBindingPackage(key),
           Optional.<DeclaredType>absent(), // TODO(beder): Add nullability checking with Java 8.
           Optional.<DependencyRequest>absent(),
+          wrapOptionalInEquivalence(getMapKey(producesMethod)),
           kind,
           ImmutableList.copyOf(producesMethod.getThrownTypes()),
           Optional.of(executorRequest),
@@ -145,6 +151,7 @@ ProductionBinding syntheticMapOfValuesOrProducedBinding(
           findBindingPackage(requestForMapOfValuesOrProduced.key()),
           Optional.<DeclaredType>absent(),
           Optional.<DependencyRequest>absent(),
+          wrapOptionalInEquivalence(getMapKey(requestForMapOfProducers.requestElement())),
           Kind.SYNTHETIC_MAP,
           ImmutableList.<TypeMirror>of(),
           Optional.<DependencyRequest>absent(),
@@ -168,6 +175,7 @@ ProductionBinding syntheticMultibinding(
           findBindingPackage(request.key()),
           Optional.<DeclaredType>absent(),
           Optional.<DependencyRequest>absent(),
+          Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
           Kind.forMultibindingRequest(request),
           ImmutableList.<TypeMirror>of(),
           Optional.<DependencyRequest>absent(),
@@ -188,6 +196,7 @@ ProductionBinding forComponentMethod(ExecutableElement componentMethod) {
           Optional.<String>absent(),
           Optional.<DeclaredType>absent(),
           Optional.<DependencyRequest>absent(),
+          Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
           Kind.COMPONENT_PRODUCTION,
           ImmutableList.copyOf(componentMethod.getThrownTypes()),
           Optional.<DependencyRequest>absent(),
@@ -205,6 +214,7 @@ ProductionBinding delegate(
           findBindingPackage(delegateDeclaration.key()),
           delegateBinding.nullableType(),
           Optional.<DependencyRequest>absent(),
+          Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
           Kind.SYNTHETIC_DELEGATE_BINDING,
           ImmutableList.<TypeMirror>of(),
           Optional.<DependencyRequest>absent(),
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
index c435c3427..4de6fd673 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
@@ -15,221 +15,41 @@
  */
 package dagger.internal.codegen;
 
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Iterables;
 import dagger.Module;
 import dagger.Provides;
-import java.lang.annotation.Annotation;
-import java.util.Set;
-import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.Modifier;
-import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
-import javax.lang.model.type.DeclaredType;
-import javax.lang.model.type.TypeKind;
-import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
-import static com.google.auto.common.MoreElements.getAnnotationMirror;
-import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static com.google.common.base.Preconditions.checkNotNull;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_ABSTRACT;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_RETURN_A_VALUE;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_IN_MODULE;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_MAP_HAS_MAP_KEY;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_PRIVATE;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_SET_VALUES_RAW_SET;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_TYPE_PARAMETER;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_MULTIPLE_MAP_KEY;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_NO_MAP_KEY;
-import static dagger.internal.codegen.ErrorMessages.MULTIBINDING_ANNOTATION_CONFLICTS_WITH_BINDING_ANNOTATION_ENUM;
-import static dagger.internal.codegen.ErrorMessages.MULTIPLE_MULTIBINDING_ANNOTATIONS_ON_METHOD;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_SET_VALUES_RETURN_SET;
+import static dagger.internal.codegen.BindingMethodValidator.Abstractness.MUST_BE_CONCRETE;
+import static dagger.internal.codegen.BindingMethodValidator.ExceptionSuperclass.RUNTIME_EXCEPTION;
 import static dagger.internal.codegen.ErrorMessages.provisionMayNotDependOnProducerType;
-import static dagger.internal.codegen.MapKeys.getMapKeys;
-import static dagger.internal.codegen.Validation.validateMethodQualifiers;
-import static dagger.internal.codegen.Validation.validateReturnType;
-import static dagger.internal.codegen.Validation.validateUncheckedThrows;
-import static javax.lang.model.element.Modifier.ABSTRACT;
-import static javax.lang.model.element.Modifier.PRIVATE;
-import static javax.lang.model.type.TypeKind.DECLARED;
-import static javax.lang.model.type.TypeKind.VOID;
 
 /**
- * A {@linkplain ValidationReport validator} for {@link Provides} methods.
+ * A validator for {@link Provides} methods.
  *
  * @author Gregory Kick
  * @since 2.0
  */
-final class ProvidesMethodValidator {
-  private final Elements elements;
-  private final Types types;
+final class ProvidesMethodValidator extends BindingMethodValidator {
 
   ProvidesMethodValidator(Elements elements, Types types) {
-    this.elements = checkNotNull(elements);
-    this.types = checkNotNull(types);
+    super(elements, types, Provides.class, Module.class, MUST_BE_CONCRETE, RUNTIME_EXCEPTION);
   }
 
-  private TypeElement getSetElement() {
-    return elements.getTypeElement(Set.class.getCanonicalName());
+  @Override
+  protected void checkMethod(ValidationReport.Builder<ExecutableElement> builder) {
+    super.checkMethod(builder);
+    checkDependsOnProducers(builder);
   }
 
-  ValidationReport<ExecutableElement> validate(ExecutableElement providesMethodElement) {
-    ValidationReport.Builder<ExecutableElement> builder =
-        ValidationReport.about(providesMethodElement);
-
-    Element enclosingElement = providesMethodElement.getEnclosingElement();
-    if (!isAnnotationPresent(enclosingElement, Module.class)) {
-      builder.addError(
-          formatModuleErrorMessage(BINDING_METHOD_NOT_IN_MODULE), providesMethodElement);
-    }
-
-    if (!providesMethodElement.getTypeParameters().isEmpty()) {
-      builder.addError(formatErrorMessage(BINDING_METHOD_TYPE_PARAMETER), providesMethodElement);
-    }
-
-    Set<Modifier> modifiers = providesMethodElement.getModifiers();
-    if (modifiers.contains(PRIVATE)) {
-      builder.addError(formatErrorMessage(BINDING_METHOD_PRIVATE), providesMethodElement);
-    }
-    if (modifiers.contains(ABSTRACT)) {
-      builder.addError(formatErrorMessage(BINDING_METHOD_ABSTRACT), providesMethodElement);
-    }
-
-    TypeMirror returnType = providesMethodElement.getReturnType();
-    TypeKind returnTypeKind = returnType.getKind();
-    if (returnTypeKind.equals(VOID)) {
-      builder.addError(
-          formatErrorMessage(BINDING_METHOD_MUST_RETURN_A_VALUE), providesMethodElement);
-    }
-
-    validateUncheckedThrows(elements, types, providesMethodElement, Provides.class, builder);
-
-    for (VariableElement parameter : providesMethodElement.getParameters()) {
+  /** Adds an error if a {@link Provides @Provides} method depends on a producer type. */
+  private void checkDependsOnProducers(ValidationReport.Builder<ExecutableElement> builder) {
+    for (VariableElement parameter : builder.getSubject().getParameters()) {
       if (FrameworkTypes.isProducerType(parameter.asType())) {
         builder.addError(provisionMayNotDependOnProducerType(parameter.asType()), parameter);
       }
     }
-
-    ContributionType contributionType = ContributionType.fromBindingMethod(providesMethodElement);
-
-    validateMapKey(builder, providesMethodElement, contributionType, Provides.class);
-
-    validateMethodQualifiers(builder, providesMethodElement);
-
-    validateMultibindingSpecifiers(builder, providesMethodElement, Provides.class);
-    switch (contributionType) {
-      case UNIQUE:
-        /* Validate that a unique binding is not attempting to bind a framework type. This
-         * validation is only appropriate for unique bindings because multibindings may collect
-         * framework types.  E.g. Set<Provider<Foo>> is perfectly reasonable. */
-        if (FrameworkTypes.isFrameworkType(returnType)) {
-          builder.addError(
-              formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES),
-              providesMethodElement);
-        }
-        // fall through
-      case SET:
-        validateReturnType(Provides.class, builder, returnType);
-        break;
-      case MAP:
-        validateReturnType(Provides.class, builder, returnType);
-        ImmutableSet<? extends AnnotationMirror> mapKeys = getMapKeys(providesMethodElement);
-        switch (mapKeys.size()) {
-          case 0:
-            builder.addError(
-                formatErrorMessage(BINDING_METHOD_WITH_NO_MAP_KEY), providesMethodElement);
-            break;
-          case 1:
-            break;
-          default:
-            builder.addError(
-                formatErrorMessage(BINDING_METHOD_WITH_MULTIPLE_MAP_KEY), providesMethodElement);
-            break;
-        }
-        break;
-      case SET_VALUES:
-        if (!returnTypeKind.equals(DECLARED)) {
-          builder.addError(PROVIDES_METHOD_SET_VALUES_RETURN_SET, providesMethodElement);
-        } else {
-          DeclaredType declaredReturnType = (DeclaredType) returnType;
-          // TODO(gak): should we allow "covariant return" for set values?
-          if (!declaredReturnType.asElement().equals(getSetElement())) {
-            builder.addError(PROVIDES_METHOD_SET_VALUES_RETURN_SET, providesMethodElement);
-          } else if (declaredReturnType.getTypeArguments().isEmpty()) {
-            builder.addError(
-                formatErrorMessage(BINDING_METHOD_SET_VALUES_RAW_SET), providesMethodElement);
-          } else {
-            validateReturnType(
-                Provides.class,
-                builder,
-                Iterables.getOnlyElement(declaredReturnType.getTypeArguments()));
-          }
-        }
-        break;
-      default:
-        throw new AssertionError();
-    }
-
-    return builder.build();
-  }
-
-  /** Validate that methods for map multibindings have a {@code @MapKey} annotation. */
-  static void validateMapKey(
-      ValidationReport.Builder<ExecutableElement> builder,
-      ExecutableElement method,
-      ContributionType contributionType,
-      Class<? extends Annotation> bindingAnnotation) {
-    if (!contributionType.equals(ContributionType.MAP) && !getMapKeys(method).isEmpty()) {
-      builder.addError(
-          String.format(BINDING_METHOD_NOT_MAP_HAS_MAP_KEY, bindingAnnotation.getSimpleName()),
-          method);
-    }
-  }
-
-  /**
-   * Validate that at most one multibinding annotation is used, and not in conflict with {@link
-   * Provides#type()}.
-   */
-  static void validateMultibindingSpecifiers(
-      ValidationReport.Builder<ExecutableElement> builder,
-      ExecutableElement method,
-      Class<? extends Annotation> bindingAnnotation) {
-    ImmutableSet<AnnotationMirror> multibindingAnnotations =
-        MultibindingAnnotations.forMethod(method);
-    if (multibindingAnnotations.size() > 1) {
-      for (AnnotationMirror annotation : multibindingAnnotations) {
-        builder.addError(
-            String.format(
-                MULTIPLE_MULTIBINDING_ANNOTATIONS_ON_METHOD, bindingAnnotation.getSimpleName()),
-            method,
-            annotation);
-      }
-    }
-
-    AnnotationMirror bindingAnnotationMirror = getAnnotationMirror(method, bindingAnnotation).get();
-    boolean usesProvidesType = false;
-    for (ExecutableElement member : bindingAnnotationMirror.getElementValues().keySet()) {
-      usesProvidesType |= member.getSimpleName().contentEquals("type");
-    }
-    if (usesProvidesType && !multibindingAnnotations.isEmpty()) {
-      builder.addError(
-          String.format(
-              MULTIBINDING_ANNOTATION_CONFLICTS_WITH_BINDING_ANNOTATION_ENUM,
-              bindingAnnotation.getSimpleName()),
-          method);
-    }
-  }
-
-  private String formatErrorMessage(String msg) {
-    return String.format(msg, Provides.class.getSimpleName());
-  }
-
-  private static String formatModuleErrorMessage(String msg) {
-    return String.format(msg, Provides.class.getSimpleName(), Module.class.getSimpleName());
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index 13e8ba9ab..7a61391ce 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -18,10 +18,12 @@
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
+import com.google.common.base.Equivalence;
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
 import javax.inject.Inject;
+import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
@@ -38,6 +40,8 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
+import static dagger.internal.codegen.MapKeys.getMapKey;
+import static dagger.internal.codegen.MoreAnnotationMirrors.wrapOptionalInEquivalence;
 import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
 import static javax.lang.model.element.ElementKind.FIELD;
 import static javax.lang.model.element.ElementKind.METHOD;
@@ -124,6 +128,7 @@ ProvisionBinding forInjectConstructor(ExecutableElement constructorElement,
           findBindingPackage(key),
           Optional.<DeclaredType>absent(),
           membersInjectionRequest,
+          Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
           Kind.INJECTION,
           hasNonDefaultTypeParameters(bindingTypeElement, key.type(), types)
               ? Optional.of(forInjectConstructor(constructorElement, Optional.<TypeMirror>absent()))
@@ -170,6 +175,7 @@ ProvisionBinding forProvidesMethod(
           findBindingPackage(key),
           ConfigurationAnnotations.getNullableType(providesMethod),
           Optional.<DependencyRequest>absent(),
+          wrapOptionalInEquivalence(getMapKey(providesMethod)),
           Kind.PROVISION,
           Optional.<ProvisionBinding>absent(),
           scope);
@@ -198,6 +204,7 @@ ProvisionBinding syntheticMapOfValuesBinding(DependencyRequest requestForMapOfVa
           findBindingPackage(requestForMapOfValues.key()),
           Optional.<DeclaredType>absent(),
           Optional.<DependencyRequest>absent(),
+          wrapOptionalInEquivalence(getMapKey(requestForMapOfProviders.requestElement())),
           Kind.SYNTHETIC_MAP,
           Optional.<ProvisionBinding>absent(),
           Scope.uniqueScopeOf(requestForMapOfProviders.requestElement()));
@@ -220,6 +227,7 @@ ProvisionBinding syntheticMultibinding(
           findBindingPackage(request.key()),
           Optional.<DeclaredType>absent(),
           Optional.<DependencyRequest>absent(),
+          Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
           Kind.forMultibindingRequest(request),
           Optional.<ProvisionBinding>absent(),
           Scope.uniqueScopeOf(request.requestElement()));
@@ -236,6 +244,7 @@ ProvisionBinding forComponent(TypeElement componentDefinitionType) {
           Optional.<String>absent(),
           Optional.<DeclaredType>absent(),
           Optional.<DependencyRequest>absent(),
+          Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
           Kind.COMPONENT,
           Optional.<ProvisionBinding>absent(),
           Optional.<Scope>absent());
@@ -255,6 +264,7 @@ ProvisionBinding forComponentMethod(ExecutableElement componentMethod) {
           Optional.<String>absent(),
           ConfigurationAnnotations.getNullableType(componentMethod),
           Optional.<DependencyRequest>absent(),
+          Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
           Kind.COMPONENT_PROVISION,
           Optional.<ProvisionBinding>absent(),
           scope);
@@ -275,6 +285,7 @@ ProvisionBinding forSubcomponentBuilderMethod(
           Optional.<String>absent(),
           Optional.<DeclaredType>absent(),
           Optional.<DependencyRequest>absent(),
+          Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
           Kind.SUBCOMPONENT_BUILDER,
           Optional.<ProvisionBinding>absent(),
           Optional.<Scope>absent());
@@ -291,6 +302,8 @@ ProvisionBinding delegate(
           findBindingPackage(delegateDeclaration.key()),
           delegate.nullableType(),
           Optional.<DependencyRequest>absent(),
+          // TODO(ronshapiro): for @Binds @IntoMap, this should be delegateDeclaration.mapKey()
+          Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
           Kind.SYNTHETIC_DELEGATE_BINDING,
           Optional.<ProvisionBinding>absent(),
           Scope.uniqueScopeOf(delegateDeclaration.bindingElement()));
diff --git a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
index 40f1e5e93..0503ddcb5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
@@ -151,6 +151,16 @@ boolean isEmpty() {
     return allContributionBindings().get(owningComponent());
   }
 
+  /** The component that owns {@code binding}. */
+  ComponentDescriptor owningComponent(ContributionBinding binding) {
+    checkArgument(
+        contributionBindings().contains(binding),
+        "binding is not resolved for %s: %s",
+        bindingKey(),
+        binding);
+    return getOnlyElement(allContributionBindings().inverse().get(binding));
+  }
+
   /**
    * The members-injection binding, regardless of owning component. Empty if these are contribution
    * bindings.
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index 606a088c3..d93fae3d9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -170,5 +170,38 @@ public TypeElement visitType(TypeElement e, Void p) {
         }
       };
 
+      
+  /**
+   * Returns {@code true} iff the given element has an {@link AnnotationMirror} whose
+   * {@linkplain AnnotationMirror#getAnnotationType() annotation type} has the same canonical name
+   * as any of that of {@code annotationClasses}.
+   */
+  // TODO(dpb): Move to MoreElements.
+  static boolean isAnyAnnotationPresent(
+      Element element, Iterable<? extends Class<? extends Annotation>> annotationClasses) {
+    for (Class<? extends Annotation> annotation : annotationClasses) {
+      if (isAnnotationPresent(element, annotation)) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  /**
+   * The elements in {@code elements} that are annotated with an annotation of type
+   * {@code annotation}.
+   */
+  static <E extends Element> FluentIterable<E> elementsWithAnnotation(
+      Iterable<E> elements, final Class<? extends Annotation> annotation) {
+    return FluentIterable.from(elements)
+        .filter(
+            new Predicate<Element>() {
+              @Override
+              public boolean apply(Element element) {
+                return MoreElements.isAnnotationPresent(element, annotation);
+              }
+            });
+  }
+
   private Util() {}
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Validation.java b/compiler/src/main/java/dagger/internal/codegen/Validation.java
deleted file mode 100644
index 4a2c659b8..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/Validation.java
+++ /dev/null
@@ -1,87 +0,0 @@
-/*
- * Copyright (C) 2015 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import com.google.common.collect.ImmutableSet;
-import java.lang.annotation.Annotation;
-import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.type.TypeKind;
-import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
-
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MULTIPLE_QUALIFIERS;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_RETURN_TYPE;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_THROWS_CHECKED;
-import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
-import static javax.lang.model.type.TypeKind.ARRAY;
-import static javax.lang.model.type.TypeKind.DECLARED;
-import static javax.lang.model.type.TypeKind.TYPEVAR;
-
-final class Validation {
-
-  private Validation() {}
-
-  /** Validates that the given method only throws unchecked exceptions. */
-  static void validateUncheckedThrows(
-      Elements elements,
-      Types types,
-      ExecutableElement methodElement,
-      Class<? extends Annotation> methodAnnotation,
-      ValidationReport.Builder<ExecutableElement> builder) {
-    TypeMirror runtimeExceptionType =
-        elements.getTypeElement(RuntimeException.class.getCanonicalName()).asType();
-    TypeMirror errorType = elements.getTypeElement(Error.class.getCanonicalName()).asType();
-    for (TypeMirror thrownType : methodElement.getThrownTypes()) {
-      if (!types.isSubtype(thrownType, runtimeExceptionType)
-          && !types.isSubtype(thrownType, errorType)) {
-        builder.addError(
-            String.format(BINDING_METHOD_THROWS_CHECKED, methodAnnotation.getSimpleName()),
-            methodElement);
-        break;
-      }
-    }
-  }
-
-  /** Validates that the return type of a binding method is an acceptable kind. */
-  static void validateReturnType(
-      Class<? extends Annotation> methodAnnotation,
-      ValidationReport.Builder<? extends Element> reportBuilder,
-      TypeMirror returnType) {
-    TypeKind kind = returnType.getKind();
-    if (!(kind.isPrimitive()
-        || kind.equals(DECLARED)
-        || kind.equals(ARRAY)
-        || kind.equals(TYPEVAR))) {
-      reportBuilder.addError(
-          String.format(BINDING_METHOD_RETURN_TYPE, methodAnnotation.getSimpleName()),
-          reportBuilder.getSubject());
-    }
-  }
-
-  /** Validates that a Provides, Produces or Bind method doesn't have multiple qualifiers. */
-  static void validateMethodQualifiers(
-      ValidationReport.Builder<ExecutableElement> builder, ExecutableElement methodElement) {
-    ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(methodElement);
-    if (qualifiers.size() > 1) {
-      for (AnnotationMirror qualifier : qualifiers) {
-        builder.addError(BINDING_METHOD_MULTIPLE_QUALIFIERS, methodElement, qualifier);
-      }
-    }
-  }
-}
diff --git a/compiler/src/test/java/dagger/internal/codegen/BindsMethodValidatorTest.java b/compiler/src/test/java/dagger/internal/codegen/BindsMethodValidatorTest.java
index 13aafff1f..05071f493 100644
--- a/compiler/src/test/java/dagger/internal/codegen/BindsMethodValidatorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/BindsMethodValidatorTest.java
@@ -16,19 +16,20 @@
 package dagger.internal.codegen;
 
 import com.google.common.collect.ImmutableList;
-import com.google.testing.compile.JavaFileObjects;
 import dagger.Module;
 import dagger.producers.ProducerModule;
+import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.util.Collection;
-import javax.tools.JavaFileObject;
+import javax.inject.Qualifier;
+import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 import org.junit.runners.Parameterized.Parameters;
 
-import static com.google.common.truth.Truth.assertAbout;
-import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatMethodInUnannotatedClass;
+import static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatModuleMethod;
 
 @RunWith(Parameterized.class)
 public class BindsMethodValidatorTest {
@@ -37,141 +38,74 @@
     return ImmutableList.copyOf(new Object[][] {{Module.class}, {ProducerModule.class}});
   }
 
-  private final Class<? extends Annotation> moduleAnnotation;
+  private final String moduleDeclaration;
 
   public BindsMethodValidatorTest(Class<? extends Annotation> moduleAnnotation) {
-    this.moduleAnnotation = moduleAnnotation;
+    moduleDeclaration = "@" + moduleAnnotation.getCanonicalName() + " abstract class %s { %s }";
   }
 
   @Test
   public void nonAbstract() {
-    JavaFileObject moduleFile =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Binds;",
-            "",
-            "@" + moduleAnnotation.getCanonicalName(),
-            "abstract class TestModule {",
-            "  @Binds Object bindObject(String impl) { return null; }",
-            "}");
-    assertAbout(javaSource())
-        .that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("must be abstract")
-        .in(moduleFile)
-        .onLine(7);
+    assertThatMethod("@Binds Object concrete(String impl) { return null; }")
+        .hasError("must be abstract");
   }
 
   @Test
   public void notAssignable() {
-    JavaFileObject moduleFile =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Binds;",
-            "",
-            "@" + moduleAnnotation.getCanonicalName(),
-            "abstract class TestModule {",
-            "  @Binds abstract String bindString(Object impl);",
-            "}");
-    assertAbout(javaSource())
-        .that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("assignable")
-        .in(moduleFile)
-        .onLine(7);
+    assertThatMethod("@Binds abstract String notAssignable(Object impl);").hasError("assignable");
   }
-
+  
   @Test
-  public void moreThanOneParamter() {
-    JavaFileObject moduleFile =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Binds;",
-            "",
-            "@" + moduleAnnotation.getCanonicalName(),
-            "abstract class TestModule {",
-            "  @Binds abstract Object bindObject(String s1, String s2);",
-            "}");
-    assertAbout(javaSource())
-        .that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("one parameter")
-        .in(moduleFile)
-        .onLine(7);
+  public void moreThanOneParameter() {
+    assertThatMethod("@Binds abstract Object tooManyParameters(String s1, String s2);")
+        .hasError("one parameter");
   }
 
   @Test
   public void typeParameters() {
-    JavaFileObject moduleFile =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Binds;",
-            "",
-            "@" + moduleAnnotation.getCanonicalName(),
-            "abstract class TestModule {",
-            "  @Binds abstract <S, T extends S> S bindS(T t);",
-            "}");
-    assertAbout(javaSource())
-        .that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("type parameters")
-        .in(moduleFile)
-        .onLine(7);
+    assertThatMethod("@Binds abstract <S, T extends S> S generic(T t);")
+        .hasError("type parameters");
   }
 
   @Test
   public void notInModule() {
-    JavaFileObject moduleFile =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Binds;",
-            "",
-            "abstract class TestModule {",
-            "  @Binds abstract Object bindObject(String s);",
-            "}");
-    assertAbout(javaSource())
-        .that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("within a @Module or @ProducerModule")
-        .in(moduleFile)
-        .onLine(6);
+    assertThatMethodInUnannotatedClass("@Binds abstract Object bindObject(String s);")
+        .hasError("within a @Module or @ProducerModule");
   }
 
   @Test
   public void throwsException() {
-    JavaFileObject moduleFile =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Binds;",
-            "import java.io.IOException;",
-            "",
-            "@" + moduleAnnotation.getCanonicalName(),
-            "abstract class TestModule {",
-            "  @Binds abstract Object bindObject(String s1) throws IOException;",
-            "}");
-    assertAbout(javaSource())
-        .that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("only throw unchecked")
-        .in(moduleFile)
-        .onLine(8);
+    assertThatMethod("@Binds abstract Object throwsException(String s1) throws IOException;")
+        .importing(IOException.class)
+        .hasError("only throw unchecked");
+  }
+
+  @Test
+  @Ignore("TODO: @Binds methods do not check explicitly for void")
+  public void returnsVoid() {
+    assertThatMethod("@Binds abstract void returnsVoid(Object impl);").hasError("void");
+  }
+
+  @Test
+  public void tooManyQualifiers() {
+    assertThatMethod(
+            "@Binds @Qualifier1 @Qualifier2 abstract String tooManyQualifiers(String impl);")
+        .importing(Qualifier1.class, Qualifier2.class)
+        .hasError("more than one @Qualifier");
   }
+
+  @Test
+  public void noParameters() {
+    assertThatMethod("@Binds abstract Object noParameters();").hasError("one parameter");
+  }
+
+  private DaggerModuleMethodSubject assertThatMethod(String method) {
+    return assertThatModuleMethod(method).withDeclaration(moduleDeclaration);
+  }
+
+  @Qualifier
+  public @interface Qualifier1 {}
+
+  @Qualifier
+  public @interface Qualifier2 {}
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index fc1779e68..f535d430e 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -47,6 +47,7 @@
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
+import static java.util.Arrays.asList;
 import static javax.tools.StandardLocation.SOURCE_OUTPUT;
 
 @RunWith(JUnit4.class)
@@ -165,6 +166,35 @@
             "@Provides List<Integer> test.AnotherModule.provideListOfInteger()");
   }
 
+  @Test public void privateNestedClassWithWarningThatIsAnErrorInComponent() {
+    JavaFileObject outerClass = JavaFileObjects.forSourceLines("test.OuterClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class OuterClass {",
+        "  @Inject OuterClass(InnerClass innerClass) {}",
+        "",
+        "  private static final class InnerClass {",
+        "    @Inject InnerClass() {}",
+        "  }",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.BadComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "interface BadComponent {",
+        "  OuterClass outerClass();",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(outerClass, componentFile))
+        .withCompilerOptions("-Adagger.privateMemberValidation=WARNING")
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("Dagger does not support injection into private classes");
+  }
+
   @Test public void simpleComponent() {
     JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
         "package test;",
@@ -971,8 +1001,8 @@ public void subcomponentOmitsInheritedBindings() {
             "",
             "    @SuppressWarnings(\"unchecked\")",
             "    private void initialize() {",
-            "      this.setOfObjectProvider = SetFactory.create(",
-            "          ParentModule_ParentObjectFactory.create());",
+            "      this.setOfObjectProvider = SetFactory.<Object>builder(1, 0)",
+            "          .addProvider(ParentModule_ParentObjectFactory.create()).build();",
             "      this.mapOfStringAndProviderOfObjectProvider =",
             "          MapProviderFactory.<String, Object>builder(1)",
             "              .put(\"parent key\", DaggerParent.this.parentKeyObjectProvider)",
@@ -1083,7 +1113,7 @@ public void subcomponentOmitsInheritedBindings() {
             GENERATED_ANNOTATION,
             "public final class DaggerTestComponent implements TestComponent {",
             "  private Provider<Set<String>> emptySetProvider;",
-            "  private Provider<Set<String>> stringProvider;",
+            "  private Provider<String> stringProvider;",
             "  private Provider<Set<String>> setOfStringProvider;",
             "",
             "  private DaggerTestComponent(Builder builder) {",
@@ -1105,8 +1135,11 @@ public void subcomponentOmitsInheritedBindings() {
             "        EmptySetModule_EmptySetFactory.create(builder.emptySetModule);",
             "    this.stringProvider =",
             "        SetModule_StringFactory.create(builder.setModule);",
-            "    this.setOfStringProvider = SetFactory.create(",
-            "        emptySetProvider, stringProvider);",
+            "    this.setOfStringProvider = ",
+            "        SetFactory.<String>builder(1, 1)",
+            "            .addSetProvider(emptySetProvider)",
+            "            .addProvider(stringProvider)",
+            "            .build();",
             "  }",
             "",
             "  @Override",
@@ -2341,6 +2374,35 @@ public void scopeAnnotationOnInjectConstructorNotValid() {
         .onLine(6);
   }
 
+  @Test
+  public void attemptToInjectWildcardGenerics() {
+    JavaFileObject testComponent =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Lazy;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "interface TestComponent {",
+            "  Lazy<? extends Number> wildcardNumberLazy();",
+            "  Provider<? super Number> wildcardNumberProvider();",
+            "}");
+    assertAbout(javaSources())
+        .that(asList(testComponent))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("wildcard type")
+        .in(testComponent)
+        .onLine(9)
+        .and()
+        .withErrorContaining("wildcard type")
+        .in(testComponent)
+        .onLine(10);
+  }
+
   /**
    * A {@link ComponentProcessor} that excludes elements using a {@link Predicate}.
    */
diff --git a/compiler/src/test/java/dagger/internal/codegen/DaggerModuleMethodSubject.java b/compiler/src/test/java/dagger/internal/codegen/DaggerModuleMethodSubject.java
new file mode 100644
index 000000000..3581057bc
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/DaggerModuleMethodSubject.java
@@ -0,0 +1,192 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.base.Function;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.Iterables;
+import com.google.common.truth.FailureStrategy;
+import com.google.common.truth.Subject;
+import com.google.common.truth.SubjectFactory;
+import com.google.common.truth.Truth;
+import com.google.testing.compile.JavaFileObjects;
+import dagger.Module;
+import dagger.Multibindings;
+import dagger.producers.ProducerModule;
+import java.io.PrintWriter;
+import java.io.StringWriter;
+import java.util.Arrays;
+import javax.tools.JavaFileObject;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+
+/** A {@link Truth} subject for testing Dagger module methods. */
+final class DaggerModuleMethodSubject extends Subject<DaggerModuleMethodSubject, String> {
+
+  /** A {@link Truth} subject factory for testing Dagger module methods. */
+  static final class Factory extends SubjectFactory<DaggerModuleMethodSubject, String> {
+
+    /** Starts a clause testing a Dagger {@link Module @Module} method. */
+    static DaggerModuleMethodSubject assertThatModuleMethod(String method) {
+      return assertAbout(daggerModuleMethod())
+          .that(method)
+          .withDeclaration("@Module abstract class %s { %s }");
+    }
+
+    /** Starts a clause testing a Dagger {@link ProducerModule @ProducerModule} method. */
+    static DaggerModuleMethodSubject assertThatProductionModuleMethod(String method) {
+      return assertAbout(daggerModuleMethod())
+          .that(method)
+          .withDeclaration("@ProducerModule abstract class %s { %s }");
+    }
+
+    /** Starts a clause testing a Dagger {@link Multibindings @Multibindings} interface method. */
+    static DaggerModuleMethodSubject assertThatMultibindingsMethod(String method) {
+      return assertAbout(daggerModuleMethod())
+          .that(method)
+          .withDeclaration("@Module abstract class %s { @Multibindings interface Empties { %s }}");
+    }
+
+    /** Starts a clause testing a method in an unannotated class. */
+    static DaggerModuleMethodSubject assertThatMethodInUnannotatedClass(String method) {
+      return assertAbout(daggerModuleMethod())
+          .that(method)
+          .withDeclaration("abstract class %s { %s }");
+    }
+
+    static Factory daggerModuleMethod() {
+      return new Factory();
+    }
+
+    private Factory() {}
+
+    @Override
+    public DaggerModuleMethodSubject getSubject(FailureStrategy fs, String that) {
+      return new DaggerModuleMethodSubject(fs, that);
+    }
+  }
+
+  private ImmutableList.Builder<String> imports =
+      new ImmutableList.Builder<String>()
+          .add(
+              "import dagger.*;",
+              "import dagger.multibindings.*;",
+              "import dagger.producers.*;",
+              "import java.util.*;",
+              "import javax.inject.*;");
+  private String declaration;
+  private ImmutableList<JavaFileObject> additionalSources = ImmutableList.of();
+
+  private DaggerModuleMethodSubject(FailureStrategy failureStrategy, String subject) {
+    super(failureStrategy, subject);
+  }
+
+  /**
+   * Imports classes and interfaces. Note that all types in the following packages are already
+   * imported:<ul>
+   * <li>{@code dagger.*}
+   * <li>{@code dagger.multibindings.*}
+   * <li>(@code dagger.producers.*}
+   * <li>{@code java.util.*}
+   * <li>{@code javax.inject.*}
+   * </ul>
+   */
+  DaggerModuleMethodSubject importing(Class<?>... imports) {
+    return importing(FluentIterable.from(Arrays.asList(imports)));
+  }
+
+  /**
+   * Imports classes and interfaces. Note that all types in the following packages are already
+   * imported:<ul>
+   * <li>{@code dagger.*}
+   * <li>{@code dagger.multibindings.*}
+   * <li>(@code dagger.producers.*}
+   * <li>{@code java.util.*}
+   * <li>{@code javax.inject.*}
+   * </ul>
+   */
+  DaggerModuleMethodSubject importing(Iterable<? extends Class<?>> imports) {
+    this.imports.addAll(Iterables.transform(imports, IMPORT));
+    return this;
+  }
+
+  /**
+   * Sets the declaration of the module. Must be a string with two {@code %s} parameters. The first
+   * will be replaced with the name of the type, and the second with the method declaration, which
+   * must be within paired braces.
+   */
+  DaggerModuleMethodSubject withDeclaration(String declaration) {
+    this.declaration = declaration;
+    return this;
+  }
+
+  /** Additional source files that must be compiled with the module. */
+  DaggerModuleMethodSubject withAdditionalSources(JavaFileObject... sources) {
+    this.additionalSources = ImmutableList.copyOf(sources);
+    return this;
+  }
+
+  /**
+   * Fails if compiling the module with the method doesn't report an error at the method
+   * declaration whose message contains {@code errorSubstring}.
+   */
+  void hasError(String errorSubstring) {
+    String source = moduleSource();
+    JavaFileObject module = JavaFileObjects.forSourceLines("test.TestModule", source);
+    assertAbout(javaSources())
+        .that(FluentIterable.from(additionalSources).append(module))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(errorSubstring)
+        .in(module)
+        .onLine(methodLine(source));
+  }
+
+  private int methodLine(String source) {
+    String beforeMethod = source.substring(0, source.indexOf(getSubject()));
+    int methodLine = 1;
+    for (int nextNewlineIndex = beforeMethod.indexOf('\n');
+        nextNewlineIndex >= 0;
+        nextNewlineIndex = beforeMethod.indexOf('\n', nextNewlineIndex + 1)) {
+      methodLine++;
+    }
+    return methodLine;
+  }
+
+  private String moduleSource() {
+    StringWriter stringWriter = new StringWriter();
+    PrintWriter writer = new PrintWriter(stringWriter);
+    writer.println("package test;");
+    writer.println();
+    for (String importLine : imports.build()) {
+      writer.println(importLine);
+    }
+    writer.println();
+    writer.printf(declaration, "TestModule", "\n" + getSubject() + "\n");
+    writer.println();
+    return stringWriter.toString();
+  }
+
+  private static final Function<Class<?>, String> IMPORT =
+      new Function<Class<?>, String>() {
+        @Override
+        public String apply(Class<?> clazz) {
+          return String.format("import %s;", clazz.getCanonicalName());
+        }
+      };
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
index 0362ef195..f81916ff5 100644
--- a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
@@ -31,9 +31,9 @@
 
 @RunWith(JUnit4.class)
 public class GraphValidationTest {
-  private final JavaFileObject NULLABLE = JavaFileObjects.forSourceLines("test.Nullable",
-      "package test;",
-      "public @interface Nullable {}");
+  private static final JavaFileObject NULLABLE =
+      JavaFileObjects.forSourceLines(
+          "test.Nullable", "package test;", "public @interface Nullable {}");
 
   @Test public void componentOnConcreteClass() {
     JavaFileObject component = JavaFileObjects.forSourceLines("test.MyComponent",
@@ -932,6 +932,56 @@ public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration()
         .onLine(39);
   }
 
+  @Test
+  public void bindsMethodAppearsInTrace() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "TestComponent",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  TestInterface testInterface();",
+            "}");
+    JavaFileObject interfaceFile =
+        JavaFileObjects.forSourceLines("TestInterface", "interface TestInterface {}");
+    JavaFileObject implementationFile =
+        JavaFileObjects.forSourceLines(
+            "TestImplementation",
+            "import javax.inject.Inject;",
+            "",
+            "final class TestImplementation implements TestInterface {",
+            "  @Inject TestImplementation(String missingBinding) {}",
+            "}");
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "TestModule",
+            "import dagger.Binds;",
+            "import dagger.Module;",
+            "",
+            "@Module",
+            "interface TestModule {",
+            "  @Binds abstract TestInterface bindTestInterface(TestImplementation implementation);",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(component, module, interfaceFile, implementationFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            Joiner.on("\n      ")
+                .join(
+                    "java.lang.String cannot be provided without an @Inject constructor or from "
+                        + "an @Provides-annotated method.",
+                    "java.lang.String is injected at",
+                    "    TestImplementation.<init>(missingBinding)",
+                    "TestImplementation is injected at",
+                    "    TestModule.bindTestInterface(implementation)",
+                    "TestInterface is provided at",
+                    "    TestComponent.testInterface()"))
+        .in(component)
+        .onLine(5);
+  }
+
   @Test public void resolvedParametersInDependencyTrace() {
     JavaFileObject generic = JavaFileObjects.forSourceLines("test.Generic",
         "package test;",
@@ -1561,4 +1611,78 @@ public void bindingUsedOnlyInSubcomponentDependsOnBindingOnlyInSubcomponent() {
         .in(parent)
         .onLine(4);
   }
+  
+  @Test
+  public void multibindingContributionBetweenAncestorComponentAndEntrypointComponent() {
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "Parent",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = ParentModule.class)",
+            "interface Parent {",
+            "  Child child();",
+            "}");
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "Child",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = ChildModule.class)",
+            "interface Child {",
+            "  Grandchild grandchild();",
+            "}");
+    JavaFileObject grandchild =
+        JavaFileObjects.forSourceLines(
+            "Grandchild",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Grandchild {",
+            "  Object object();",
+            "}");
+
+    JavaFileObject parentModule =
+        JavaFileObjects.forSourceLines(
+            "ParentModule",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
+            "import java.util.Set;",
+            "",
+            "@Module",
+            "class ParentModule {",
+            "  @Provides static Object dependsOnSet(Set<String> strings) {",
+            "    return \"needs strings: \" + strings;",
+            "  }",
+            "",
+            "  @Provides @IntoSet static String contributesToSet() {",
+            "    return \"parent string\";",
+            "  }",
+            "",
+            "  @Provides int missingDependency(double dub) {",
+            "    return 4;",
+            "  }",
+            "}");
+    JavaFileObject childModule =
+        JavaFileObjects.forSourceLines(
+            "ChildModule",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
+            "",
+            "@Module",
+            "class ChildModule {",
+            "  @Provides @IntoSet static String contributesToSet(int i) {",
+            "    return \"\" + i;",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(parent, parentModule, child, childModule, grandchild))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("[Grandchild.object()] java.lang.Double cannot be provided")
+        .in(parent)
+        .onLine(4);
+  }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
index ccfd6117e..7237812f7 100644
--- a/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
@@ -26,10 +26,12 @@
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.internal.codegen.ErrorMessages.ABSTRACT_INJECT_METHOD;
+import static dagger.internal.codegen.ErrorMessages.CHECKED_EXCEPTIONS_ON_CONSTRUCTORS;
 import static dagger.internal.codegen.ErrorMessages.FINAL_INJECT_FIELD;
 import static dagger.internal.codegen.ErrorMessages.GENERIC_INJECT_METHOD;
 import static dagger.internal.codegen.ErrorMessages.INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS;
 import static dagger.internal.codegen.ErrorMessages.INJECT_CONSTRUCTOR_ON_INNER_CLASS;
+import static dagger.internal.codegen.ErrorMessages.INJECT_INTO_PRIVATE_CLASS;
 import static dagger.internal.codegen.ErrorMessages.INJECT_ON_PRIVATE_CONSTRUCTOR;
 import static dagger.internal.codegen.ErrorMessages.MULTIPLE_INJECT_CONSTRUCTORS;
 import static dagger.internal.codegen.ErrorMessages.MULTIPLE_QUALIFIERS;
@@ -510,6 +512,114 @@
         .and().withErrorContaining(QUALIFIER_ON_INJECT_CONSTRUCTOR).in(file).onLine(8);
   }
 
+  @Test public void injectConstructorWithCheckedExceptionsError() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.CheckedExceptionClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class CheckedExceptionClass {",
+        "  @Inject CheckedExceptionClass() throws Exception {}",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(file))
+        .processedWith(new ComponentProcessor()).failsToCompile()
+        .withErrorContaining(CHECKED_EXCEPTIONS_ON_CONSTRUCTORS).in(file).onLine(6);
+  }
+
+  @Test public void injectConstructorWithCheckedExceptionsWarning() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.CheckedExceptionClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class CheckedExceptionClass {",
+        "  @Inject CheckedExceptionClass() throws Exception {}",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(file))
+        .withCompilerOptions("-Adagger.privateMemberValidation=WARNING")
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .withWarningContaining(CHECKED_EXCEPTIONS_ON_CONSTRUCTORS).in(file).onLine(6);
+  }
+
+  @Test public void privateInjectClassError() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.OuterClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class OuterClass {",
+        "  private static final class InnerClass {",
+        "    @Inject InnerClass() {}",
+        "  }",
+        "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(file))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(INJECT_INTO_PRIVATE_CLASS).in(file).onLine(7);
+  }
+
+  @Test public void privateInjectClassWarning() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.OuterClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class OuterClass {",
+        "  private static final class InnerClass {",
+        "    @Inject InnerClass() {}",
+        "  }",
+        "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(file))
+        .withCompilerOptions("-Adagger.privateMemberValidation=WARNING")
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .withWarningContaining(INJECT_INTO_PRIVATE_CLASS).in(file).onLine(7);
+  }
+
+  @Test public void nestedInPrivateInjectClassError() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.OuterClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class OuterClass {",
+        "  private static final class MiddleClass {",
+        "    static final class InnerClass {",
+        "      @Inject InnerClass() {}",
+        "    }",
+        "  }",
+        "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(file))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(INJECT_INTO_PRIVATE_CLASS).in(file).onLine(8);
+  }
+
+  @Test public void nestedInPrivateInjectClassWarning() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.OuterClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class OuterClass {",
+        "  private static final class MiddleClass {",
+        "    static final class InnerClass {",
+        "      @Inject InnerClass() {}",
+        "    }",
+        "  }",
+        "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(file))
+        .withCompilerOptions("-Adagger.privateMemberValidation=WARNING")
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .withWarningContaining(INJECT_INTO_PRIVATE_CLASS).in(file).onLine(8);
+  }
+
   @Test public void finalInjectField() {
     JavaFileObject file = JavaFileObjects.forSourceLines("test.FinalInjectField",
         "package test;",
diff --git a/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java b/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
index b14e913de..f30368611 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
@@ -33,6 +33,7 @@
 import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.ErrorMessages.INJECT_INTO_PRIVATE_CLASS;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 import static javax.tools.StandardLocation.CLASS_OUTPUT;
 
@@ -1025,4 +1026,59 @@ public void fieldInjectionForShadowedMember() {
         .compilesWithoutError()
         .and().generatesSources(expectedMembersInjector);
   }
+
+  @Test public void privateNestedClassError() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.OuterClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class OuterClass {",
+        "  private static final class InnerClass {",
+        "    @Inject int field;",
+        "  }",
+        "}");
+    assertAbout(javaSource())
+        .that(file)
+        .processedWith(new ComponentProcessor()).failsToCompile()
+        .withErrorContaining(INJECT_INTO_PRIVATE_CLASS).in(file).onLine(6);
+  }
+
+  @Test public void privateNestedClassWarning() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.OuterClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class OuterClass {",
+        "  private static final class InnerClass {",
+        "    @Inject int field;",
+        "  }",
+        "}");
+    assertAbout(javaSource())
+        .that(file)
+        .withCompilerOptions("-Adagger.privateMemberValidation=WARNING")
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .withWarningContaining(INJECT_INTO_PRIVATE_CLASS).in(file).onLine(6);
+  }
+
+  @Test public void privateSuperclassIsOkIfNotInjectedInto() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.OuterClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class OuterClass {",
+        "  private static class BaseClass {}",
+        "",
+        "  static final class DerivedClass extends BaseClass {",
+        "    @Inject int field;",
+        "  }",
+        "}");
+    assertAbout(javaSource())
+        .that(file)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError();
+  }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
index d32aac54f..2253201af 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
@@ -28,6 +28,8 @@
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubject.assertThat;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatMethodInUnannotatedClass;
+import static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatModuleMethod;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_ABSTRACT;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MULTIPLE_QUALIFIERS;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES;
@@ -36,19 +38,19 @@
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_PRIVATE;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_RETURN_TYPE;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_SET_VALUES_RAW_SET;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_SET_VALUES_RETURN_SET;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_THROWS_CHECKED;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_TYPE_PARAMETER;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_SAME_NAME;
 import static dagger.internal.codegen.ErrorMessages.MODULES_WITH_TYPE_PARAMS_MUST_BE_ABSTRACT;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_SET_VALUES_RETURN_SET;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 
 @RunWith(JUnit4.class)
 public class ModuleFactoryGeneratorTest {
 
-  private final JavaFileObject NULLABLE = JavaFileObjects.forSourceLines("test.Nullable",
-      "package test;",
-      "public @interface Nullable {}");
+  private static final JavaFileObject NULLABLE =
+      JavaFileObjects.forSourceLines(
+          "test.Nullable", "package test;", "public @interface Nullable {}");
 
   private static final CodeBlock NPE_LITERAL =
       CodeBlocks.stringLiteral(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD);
@@ -65,197 +67,74 @@ private String formatModuleErrorMessage(String msg) {
   }
 
   @Test public void providesMethodNotInModule() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.Provides;",
-        "",
-        "final class TestModule {",
-        "  @Provides String provideString() {",
-        "    return \"\";",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(formatModuleErrorMessage(BINDING_METHOD_NOT_IN_MODULE));
+    assertThatMethodInUnannotatedClass("@Provides String provideString() { return null; }")
+        .hasError(formatModuleErrorMessage(BINDING_METHOD_NOT_IN_MODULE));
   }
 
   @Test public void providesMethodAbstract() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "",
-        "@Module",
-        "abstract class TestModule {",
-        "  @Provides abstract String provideString();",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(formatErrorMessage(BINDING_METHOD_ABSTRACT));
+    assertThatModuleMethod("@Provides abstract String abstractMethod();")
+        .hasError(formatErrorMessage(BINDING_METHOD_ABSTRACT));
   }
 
   @Test public void providesMethodPrivate() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "",
-        "@Module",
-        "final class TestModule {",
-        "  @Provides private String provideString() {",
-        "    return \"\";",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(formatErrorMessage(BINDING_METHOD_PRIVATE));
+    assertThatModuleMethod("@Provides private String privateMethod() { return null; }")
+        .hasError(formatErrorMessage(BINDING_METHOD_PRIVATE));
   }
 
   @Test public void providesMethodReturnVoid() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "",
-        "@Module",
-        "final class TestModule {",
-        "  @Provides void provideNothing() {}",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(formatErrorMessage(BINDING_METHOD_MUST_RETURN_A_VALUE));
+    assertThatModuleMethod("@Provides void voidMethod() {}")
+        .hasError(formatErrorMessage(BINDING_METHOD_MUST_RETURN_A_VALUE));
   }
 
-  @Test public void providesMethodFrameworkType() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.Lazy;",
-        "import dagger.MembersInjector;",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import dagger.producers.Producer;",
-        "import dagger.producers.Produced;",
-        "import javax.inject.Provider;",
-        "",
-        "@Module",
-        "final class TestModule {",
-        "  @Provides Provider<String> provideProvider() {}",
-        "  @Provides Lazy<String> provideLazy() {}",
-        "  @Provides MembersInjector<String> provideMembersInjector() {}",
-        "  @Provides Producer<String> provideProducer() {}",
-        "  @Provides Produced<String> provideProduced() {}",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES))
-        .in(moduleFile).onLine(13)
-        .and()
-        .withErrorContaining(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES))
-        .in(moduleFile).onLine(14)
-        .and()
-        .withErrorContaining(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES))
-        .in(moduleFile).onLine(15)
-        .and()
-        .withErrorContaining(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES))
-        .in(moduleFile).onLine(16)
-        .and()
-        .withErrorContaining(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES))
-        .in(moduleFile).onLine(17);
+  @Test
+  public void providesMethodReturnsProvider() {
+    assertThatModuleMethod("@Provides Provider<String> provideProvider() {}")
+        .hasError(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES));
+  }
+
+  @Test
+  public void providesMethodReturnsLazy() {
+    assertThatModuleMethod("@Provides Lazy<String> provideLazy() {}")
+        .hasError(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES));
+  }
+
+  @Test
+  public void providesMethodReturnsMembersInjector() {
+    assertThatModuleMethod("@Provides MembersInjector<String> provideMembersInjector() {}")
+        .hasError(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES));
+  }
+
+  @Test
+  public void providesMethodReturnsProducer() {
+    assertThatModuleMethod("@Provides Producer<String> provideProducer() {}")
+        .hasError(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES));
+  }
+
+  @Test
+  public void providesMethodReturnsProduced() {
+    assertThatModuleMethod("@Provides Produced<String> provideProduced() {}")
+        .hasError(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES));
   }
 
   @Test public void providesMethodWithTypeParameter() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "",
-        "@Module",
-        "final class TestModule {",
-        "  @Provides <T> String provideString() {",
-        "    return \"\";",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(formatErrorMessage(BINDING_METHOD_TYPE_PARAMETER));
+    assertThatModuleMethod("@Provides <T> String typeParameter() { return null; }")
+        .hasError(formatErrorMessage(BINDING_METHOD_TYPE_PARAMETER));
   }
 
   @Test public void providesMethodSetValuesWildcard() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import dagger.multibindings.ElementsIntoSet;",
-        "",
-        "import java.util.Set;",
-        "",
-        "@Module",
-        "final class TestModule {",
-        "  @Provides @ElementsIntoSet Set<?> provideWildcard() {",
-        "    return null;",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(String.format(BINDING_METHOD_RETURN_TYPE, "Provides"));
+    assertThatModuleMethod("@Provides @ElementsIntoSet Set<?> provideWildcard() { return null; }")
+        .hasError(formatErrorMessage(BINDING_METHOD_RETURN_TYPE));
   }
 
   @Test public void providesMethodSetValuesRawSet() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import dagger.multibindings.ElementsIntoSet;",
-        "",
-        "import java.util.Set;",
-        "",
-        "@Module",
-        "final class TestModule {",
-        "  @Provides @ElementsIntoSet Set provideSomething() {",
-        "    return null;",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(formatErrorMessage(BINDING_METHOD_SET_VALUES_RAW_SET));
+    assertThatModuleMethod("@Provides @ElementsIntoSet Set provideSomething() { return null; }")
+        .hasError(formatErrorMessage(BINDING_METHOD_SET_VALUES_RAW_SET));
   }
 
   @Test public void providesMethodSetValuesNotASet() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import dagger.multibindings.ElementsIntoSet;",
-        "",
-        "import java.util.List;",
-        "",
-        "@Module",
-        "final class TestModule {",
-        "  @Provides @ElementsIntoSet List<String> provideStrings() {",
-        "    return null;",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(PROVIDES_METHOD_SET_VALUES_RETURN_SET);
+    assertThatModuleMethod(
+            "@Provides @ElementsIntoSet List<String> provideStrings() { return null; }")
+        .hasError(formatErrorMessage(BINDING_METHOD_SET_VALUES_RETURN_SET));
   }
 
   @Test public void modulesWithTypeParamsMustBeAbstract() {
@@ -263,14 +142,16 @@ private String formatModuleErrorMessage(String msg) {
         "package test;",
         "",
         "import dagger.Module;",
-        "import dagger.Provides;",
         "",
         "@Module",
         "final class TestModule<A> {}");
-    assertAbout(javaSource()).that(moduleFile)
+    assertAbout(javaSource())
+        .that(moduleFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(MODULES_WITH_TYPE_PARAMS_MUST_BE_ABSTRACT);
+        .withErrorContaining(MODULES_WITH_TYPE_PARAMS_MUST_BE_ABSTRACT)
+        .in(moduleFile)
+        .onLine(6);
   }
 
   @Test public void provideOverriddenByNoProvide() {
@@ -284,20 +165,14 @@ private String formatModuleErrorMessage(String msg) {
         "class Parent {",
         "  @Provides String foo() { return null; }",
         "}");
-    JavaFileObject child = JavaFileObjects.forSourceLines("test.Child",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "",
-        "@Module",
-        "class Child extends Parent{",
-        "  String foo() { return null; }",
-        "}");
-    assertAbout(javaSources()).that(ImmutableList.of(parent, child))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(String.format(ErrorMessages.METHOD_OVERRIDES_PROVIDES_METHOD,
-            "Provides", "@Provides String test.Parent.foo()"));
+    assertThatModuleMethod("String foo() { return null; }")
+        .withDeclaration("@Module class %s extends Parent { %s }")
+        .withAdditionalSources(parent)
+        .hasError(
+            String.format(
+                ErrorMessages.METHOD_OVERRIDES_PROVIDES_METHOD,
+                "Provides",
+                "@Provides String test.Parent.foo()"));
   }
 
   @Test public void provideOverriddenByProvide() {
@@ -311,21 +186,14 @@ private String formatModuleErrorMessage(String msg) {
         "class Parent {",
         "  @Provides String foo() { return null; }",
         "}");
-    JavaFileObject child = JavaFileObjects.forSourceLines("test.Child",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "",
-        "@Module",
-        "class Child extends Parent{",
-        "  @Provides String foo() { return null; }",
-        "}");
-    assertAbout(javaSources()).that(ImmutableList.of(parent, child))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(String.format(ErrorMessages.PROVIDES_METHOD_OVERRIDES_ANOTHER,
-            "Provides", "@Provides String test.Parent.foo()"));
+    assertThatModuleMethod("@Provides String foo() { return null; }")
+        .withDeclaration("@Module class %s extends Parent { %s }")
+        .withAdditionalSources(parent)
+        .hasError(
+            String.format(
+                ErrorMessages.PROVIDES_METHOD_OVERRIDES_ANOTHER,
+                "Provides",
+                "@Provides String test.Parent.foo()"));
   }
 
   @Test public void providesOverridesNonProvides() {
@@ -338,21 +206,14 @@ private String formatModuleErrorMessage(String msg) {
         "class Parent {",
         "  String foo() { return null; }",
         "}");
-    JavaFileObject child = JavaFileObjects.forSourceLines("test.Child",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "",
-        "@Module",
-        "class Child extends Parent{",
-        "  @Provides String foo() { return null; }",
-        "}");
-    assertAbout(javaSources()).that(ImmutableList.of(parent, child))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(String.format(ErrorMessages.PROVIDES_METHOD_OVERRIDES_ANOTHER,
-            "Provides", "String test.Parent.foo()"));
+    assertThatModuleMethod("@Provides String foo() { return null; }")
+        .withDeclaration("@Module class %s extends Parent { %s }")
+        .withAdditionalSources(parent)
+        .hasError(
+            String.format(
+                ErrorMessages.PROVIDES_METHOD_OVERRIDES_ANOTHER,
+                "Provides",
+                "String test.Parent.foo()"));
   }
 
   @Test public void validatesIncludedModules() {
@@ -623,12 +484,11 @@ private String formatModuleErrorMessage(String msg) {
         "package test;",
         "",
         "import dagger.internal.Factory;",
-        "import java.util.Collections;",
-        "import java.util.Set;",
+        "import dagger.internal.Preconditions;",
         "import javax.annotation.Generated;",
         "",
         GENERATED_ANNOTATION,
-        "public final class TestModule_ProvideStringFactory implements Factory<Set<String>> {",
+        "public final class TestModule_ProvideStringFactory implements Factory<String> {",
         "  private final TestModule module;",
         "",
         "  public TestModule_ProvideStringFactory(TestModule module) {",
@@ -636,11 +496,11 @@ private String formatModuleErrorMessage(String msg) {
         "    this.module = module;",
         "  }",
         "",
-        "  @Override public Set<String> get() {",
-        "    return Collections.<String>singleton(module.provideString());",
+        "  @Override public String get() {",
+        "    return Preconditions.checkNotNull(module.provideString(), " + NPE_LITERAL + ");",
         "  }",
         "",
-        "  public static Factory<Set<String>> create(TestModule module) {",
+        "  public static Factory<String> create(TestModule module) {",
         "    return new TestModule_ProvideStringFactory(module);",
         "  }",
         "}");
@@ -672,14 +532,13 @@ private String formatModuleErrorMessage(String msg) {
         "package test;",
         "",
         "import dagger.internal.Factory;",
-        "import java.util.Collections;",
+        "import dagger.internal.Preconditions;",
         "import java.util.List;",
-        "import java.util.Set;",
         "import javax.annotation.Generated;",
         "",
         GENERATED_ANNOTATION,
         "public final class TestModule_ProvideWildcardListFactory implements "
-            + "Factory<Set<List<List<?>>>> {",
+            + "Factory<List<List<?>>> {",
         "  private final TestModule module;",
         "",
         "  public TestModule_ProvideWildcardListFactory(TestModule module) {",
@@ -687,11 +546,11 @@ private String formatModuleErrorMessage(String msg) {
         "    this.module = module;",
         "  }",
         "",
-        "  @Override public Set<List<List<?>>> get() {",
-        "    return Collections.<List<List<?>>>singleton(module.provideWildcardList());",
+        "  @Override public List<List<?>> get() {",
+        "    return Preconditions.checkNotNull(module.provideWildcardList(), " + NPE_LITERAL + ");",
         "  }",
         "",
-        "  public static Factory<Set<List<List<?>>>> create(TestModule module) {",
+        "  public static Factory<List<List<?>>> create(TestModule module) {",
         "    return new TestModule_ProvideWildcardListFactory(module);",
         "  }",
         "}");
@@ -1040,14 +899,13 @@ public void genericSubclassedModule() {
             "package test;",
             "",
             "import dagger.internal.Factory;",
-            "import java.util.Collections;",
-            "import java.util.Set;",
+            "import dagger.internal.Preconditions;",
             "import javax.annotation.Generated;",
             "import javax.inject.Provider;",
             "",
             GENERATED_ANNOTATION,
             "public final class ParentModule_ProvideBElementFactory<A extends CharSequence,",
-            "    B, C extends Number & Comparable<C>> implements Factory<Set<B>> {",
+            "    B, C extends Number & Comparable<C>> implements Factory<B> {",
             "  private final ParentModule<A, B, C> module;",
             "  private final Provider<B> bProvider;",
             "",
@@ -1060,12 +918,13 @@ public void genericSubclassedModule() {
             "  }",
             "",
             "  @Override",
-            "  public Set<B> get() {  ",
-            "    return Collections.<B>singleton(module.provideBElement(bProvider.get()));",
+            "  public B get() {  ",
+            "    return Preconditions.checkNotNull(",
+            "        module.provideBElement(bProvider.get()), " + NPE_LITERAL + ");",
             "  }",
             "",
             "  public static <A extends CharSequence, B, C extends Number & Comparable<C>>",
-            "      Factory<Set<B>> create(ParentModule<A, B, C> module, Provider<B> bProvider) {",
+            "      Factory<B> create(ParentModule<A, B, C> module, Provider<B> bProvider) {",
             "    return new ParentModule_ProvideBElementFactory<A, B, C>(module, bProvider);",
             "  }",
             "}");
@@ -1315,6 +1174,7 @@ public void genericSubclassedModule() {
   }
 
   private static final String BINDS_METHOD = "@Binds abstract Foo bindFoo(FooImpl impl);";
+  private static final String MULTIBINDS_METHOD = "@Multibinds abstract Set<Foo> foos();";
   private static final String STATIC_PROVIDES_METHOD =
       "@Provides static Bar provideBar() { return new Bar(); }";
   private static final String INSTANCE_PROVIDES_METHOD =
@@ -1325,8 +1185,17 @@ public void genericSubclassedModule() {
   public void moduleMethodPermutations() {
     assertThatMethodCombination(BINDS_METHOD, INSTANCE_PROVIDES_METHOD)
         .failsToCompile()
-        .withErrorContaining("not both at the same time");
+        .withErrorContaining(
+            "A @Module may not contain both non-static @Provides methods and "
+                + "abstract @Binds or @Multibinds declarations");
+    assertThatMethodCombination(MULTIBINDS_METHOD, INSTANCE_PROVIDES_METHOD)
+        .failsToCompile()
+        .withErrorContaining(
+            "A @Module may not contain both non-static @Provides methods and "
+                + "abstract @Binds or @Multibinds declarations");
     assertThatMethodCombination(BINDS_METHOD, STATIC_PROVIDES_METHOD).compilesWithoutError();
+    assertThatMethodCombination(BINDS_METHOD, MULTIBINDS_METHOD).compilesWithoutError();
+    assertThatMethodCombination(MULTIBINDS_METHOD, STATIC_PROVIDES_METHOD).compilesWithoutError();
     assertThatMethodCombination(INSTANCE_PROVIDES_METHOD, SOME_ABSTRACT_METHOD)
         .compilesWithoutError();
   }
@@ -1369,6 +1238,8 @@ private CompileTester assertThatMethodCombination(String... methodLines) {
                 "import dagger.Binds;",
                 "import dagger.Module;",
                 "import dagger.Provides;",
+                "import dagger.multibindings.Multibinds;",
+                "import java.util.Set;",
                 "",
                 "@Module abstract class TestModule {")
             .add(methodLines)
diff --git a/compiler/src/test/java/dagger/internal/codegen/MultibindingsValidatorTest.java b/compiler/src/test/java/dagger/internal/codegen/MultibindingsValidatorTest.java
index 91c908c73..5741aa6f1 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MultibindingsValidatorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MultibindingsValidatorTest.java
@@ -16,6 +16,7 @@
 package dagger.internal.codegen;
 
 import com.google.testing.compile.JavaFileObjects;
+import javax.inject.Qualifier;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -23,6 +24,7 @@
 
 import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatMultibindingsMethod;
 import static java.util.Arrays.asList;
 
 @RunWith(JUnit4.class)
@@ -47,7 +49,7 @@
           "",
           "@Qualifier",
           "@interface OtherQualifier {}");
-
+  
   @Test
   public void abstractClass() {
     JavaFileObject testModule =
@@ -198,103 +200,99 @@ public void notWithinModule() {
         .in(testModule)
         .onLine(9);
   }
+  
+  @Test
+  public void voidMethod() {
+    assertThatMultibindingsMethod("void voidMethod();")
+        .hasError("@Multibindings methods must return Map<K, V> or Set<T>");
+  }
 
   @Test
-  public void badMethods() {
-    JavaFileObject testModule =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Multibindings;",
-            "import dagger.producers.Produced;",
-            "import dagger.producers.Producer;",
-            "import java.util.Map;",
-            "import java.util.Set;",
-            "import javax.inject.Provider;",
-            "",
-            "@Module",
-            "class TestModule {",
-            "  @Multibindings",
-            "  interface Empties {",
-            "    void voidMethod();",
-            "    int primitive();",
-            "    Map rawMap();",
-            "    Map<?, ?> wildcardMap();",
-            "    Map<String, Provider<Object>> providerMap();",
-            "    Map<String, Producer<Object>> producerMap();",
-            "    Map<String, Produced<Object>> producedMap();",
-            "    Set rawSet();",
-            "    Set<?> wildcardSet();",
-            "    Set<Provider<Object>> providerSet();",
-            "    Set<Producer<Object>> producerSet();",
-            "    Set<Produced<Object>> producedSet();",
-            "    @SomeQualifier @OtherQualifier Set<Object> tooManyQualifiersSet();",
-            "    @SomeQualifier @OtherQualifier Map<String, Object> tooManyQualifiersMap();",
-            "  }",
-            "}");
-    assertAbout(javaSources())
-        .that(asList(testModule, SOME_QUALIFIER, OTHER_QUALIFIER))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("@Multibindings methods must return Map<K, V> or Set<T>")
-        .in(testModule)
-        .onLine(15)
-        .and()
-        .withErrorContaining("@Multibindings methods must return Map<K, V> or Set<T>")
-        .in(testModule)
-        .onLine(16)
-        .and()
-        .withErrorContaining("@Multibindings methods must return Map<K, V> or Set<T>")
-        .in(testModule)
-        .onLine(17)
-        .and()
-        .withErrorContaining("@Multibindings methods must return Map<K, V> or Set<T>")
-        .in(testModule)
-        .onLine(18)
-        .and()
-        .withErrorContaining("@Multibindings methods must return Map<K, V> or Set<T>")
-        .in(testModule)
-        .onLine(19)
-        .and()
-        .withErrorContaining("@Multibindings methods must return Map<K, V> or Set<T>")
-        .in(testModule)
-        .onLine(20)
-        .and()
-        .withErrorContaining("@Multibindings methods must return Map<K, V> or Set<T>")
-        .in(testModule)
-        .onLine(21)
-        .and()
-        .withErrorContaining("@Multibindings methods must return Map<K, V> or Set<T>")
-        .in(testModule)
-        .onLine(22)
-        .and()
-        .withErrorContaining("@Multibindings methods must return Map<K, V> or Set<T>")
-        .in(testModule)
-        .onLine(23)
-        .and()
-        .withErrorContaining("@Multibindings methods must return Map<K, V> or Set<T>")
-        .in(testModule)
-        .onLine(24)
-        .and()
-        .withErrorContaining("@Multibindings methods must return Map<K, V> or Set<T>")
-        .in(testModule)
-        .onLine(25)
-        .and()
-        .withErrorContaining("@Multibindings methods must return Map<K, V> or Set<T>")
-        .in(testModule)
-        .onLine(26)
-        .and()
-        .withErrorContaining(
-            "Cannot use more than one @Qualifier on a method in an @Multibindings type")
-        .in(testModule)
-        .onLine(27)
-        .and()
-        .withErrorContaining(
-            "Cannot use more than one @Qualifier on a method in an @Multibindings type")
-        .in(testModule)
-        .onLine(28);
+  public void primitiveMethod() {
+    assertThatMultibindingsMethod("int primitive();")
+        .hasError("@Multibindings methods must return Map<K, V> or Set<T>");
+  }
+
+  @Test
+  public void rawMap() {
+    assertThatMultibindingsMethod("Map rawMap();")
+        .hasError("@Multibindings methods must return Map<K, V> or Set<T>");
+  }
+
+  @Test
+  public void wildcardMap() {
+    assertThatMultibindingsMethod("Map<?, ?> wildcardMap();")
+        .hasError("@Multibindings methods must return Map<K, V> or Set<T>");
+  }
+
+  @Test
+  public void providerMap() {
+    assertThatMultibindingsMethod("Map<String, Provider<Object>> providerMap();")
+        .hasError("@Multibindings methods must return Map<K, V> or Set<T>");
+  }
+
+  @Test
+  public void producerMap() {
+    assertThatMultibindingsMethod("Map<String, Producer<Object>> producerMap();")
+        .hasError("@Multibindings methods must return Map<K, V> or Set<T>");
+  }
+
+  @Test
+  public void producedMap() {
+    assertThatMultibindingsMethod("Map<String, Produced<Object>> producedMap();")
+        .hasError("@Multibindings methods must return Map<K, V> or Set<T>");
+  }
+
+  @Test
+  public void rawSet() {
+    assertThatMultibindingsMethod("Set rawSet();")
+        .hasError("@Multibindings methods must return Map<K, V> or Set<T>");
+  }
+
+  @Test
+  public void wildcardSet() {
+    assertThatMultibindingsMethod("Set<?> wildcardSet();")
+        .hasError("@Multibindings methods must return Map<K, V> or Set<T>");
+  }
+
+  @Test
+  public void providerSet() {
+    assertThatMultibindingsMethod("Set<Provider<Object>> providerSet();")
+        .hasError("@Multibindings methods must return Map<K, V> or Set<T>");
+  }
+
+  @Test
+  public void producerSet() {
+    assertThatMultibindingsMethod("Set<Producer<Object>> producerSet();")
+        .hasError("@Multibindings methods must return Map<K, V> or Set<T>");
+  }
+
+  @Test
+  public void producedSet() {
+    assertThatMultibindingsMethod("Set<Produced<Object>> producedSet();")
+        .hasError("@Multibindings methods must return Map<K, V> or Set<T>");
+  }
+
+  @Test
+  public void overqualifiedSet() {
+    assertThatMultibindingsMethod(
+            "@SomeQualifier @OtherQualifier Set<Object> tooManyQualifiersSet();")
+        .importing(SomeQualifier.class, OtherQualifier.class)
+        .hasError("Cannot use more than one @Qualifier");
+  }
+
+  @Test
+  public void overqualifiedMap() {
+    assertThatMultibindingsMethod(
+            "@SomeQualifier @OtherQualifier Map<String, Object> tooManyQualifiersMap();")
+        .importing(SomeQualifier.class, OtherQualifier.class)
+        .hasError("Cannot use more than one @Qualifier");
+  }
+
+  @Test
+  public void hasParameters() {
+    assertThatMultibindingsMethod("Set<String> parameters(Object param);")
+        .hasError("@Multibindings methods cannot have parameters");
   }
 
   @Test
@@ -392,33 +390,9 @@ public void duplicateKeys() {
         .onLine(29);
   }
 
-  @Test
-  public void attemptToInjectWildcardGenerics() {
-    JavaFileObject testComponent =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import dagger.Lazy;",
-            "import javax.inject.Provider;",
-            "",
-            "@Component",
-            "interface TestComponent {",
-            "  Lazy<? extends Number> qualifiedNumberLazy();",
-            "  Provider<? super Number> qualifiedNumberProvider();",
-            "}");
-    assertAbout(javaSources())
-        .that(asList(testComponent))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("wildcard type")
-        .in(testComponent)
-        .onLine(9)
-        .and()
-        .withErrorContaining("wildcard type")
-        .in(testComponent)
-        .onLine(10);
-  }
+  @Qualifier
+  public @interface SomeQualifier {}
 
+  @Qualifier
+  public @interface OtherQualifier {}
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/MultibindsValidatorTest.java b/compiler/src/test/java/dagger/internal/codegen/MultibindsValidatorTest.java
new file mode 100644
index 000000000..e36006550
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/MultibindsValidatorTest.java
@@ -0,0 +1,167 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableList;
+import dagger.Module;
+import dagger.producers.ProducerModule;
+import java.lang.annotation.Annotation;
+import java.util.Collection;
+import javax.inject.Qualifier;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
+
+import static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatMethodInUnannotatedClass;
+import static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatModuleMethod;
+
+@RunWith(Parameterized.class)
+public class MultibindsValidatorTest {
+
+  @Parameters(name = "{0}")
+  public static Collection<Object[]> parameters() {
+    return ImmutableList.copyOf(new Object[][] {{Module.class}, {ProducerModule.class}});
+  }
+
+  private final String moduleDeclaration;
+
+  public MultibindsValidatorTest(Class<? extends Annotation> moduleAnnotation) {
+    moduleDeclaration = "@" + moduleAnnotation.getCanonicalName() + " abstract class %s { %s }";
+  }
+
+  @Test
+  public void notWithinModule() {
+    assertThatMethodInUnannotatedClass("@Multibinds abstract Set<Object> emptySet();")
+        .hasError("@Multibinds methods can only be present within a @Module or @ProducerModule");
+  }
+
+  @Test
+  public void voidMethod() {
+    assertThatModuleMethod("@Multibinds abstract void voidMethod();")
+        .withDeclaration(moduleDeclaration)
+        .hasError("@Multibinds methods must return Map<K, V> or Set<T>");
+  }
+
+  @Test
+  public void primitiveMethod() {
+    assertThatModuleMethod("@Multibinds abstract int primitive();")
+        .withDeclaration(moduleDeclaration)
+        .hasError("@Multibinds methods must return Map<K, V> or Set<T>");
+  }
+
+  @Test
+  public void rawMap() {
+    assertThatModuleMethod("@Multibinds abstract Map rawMap();")
+        .withDeclaration(moduleDeclaration)
+        .hasError("@Multibinds methods must return Map<K, V> or Set<T>");
+  }
+
+  @Test
+  public void wildcardMap() {
+    assertThatModuleMethod("@Multibinds abstract Map<?, ?> wildcardMap();")
+        .withDeclaration(moduleDeclaration)
+        .hasError("@Multibinds methods must return Map<K, V> or Set<T>");
+  }
+
+  @Test
+  public void providerMap() {
+    assertThatModuleMethod("@Multibinds abstract Map<String, Provider<Object>> providerMap();")
+        .withDeclaration(moduleDeclaration)
+        .hasError("@Multibinds methods must return Map<K, V> or Set<T>");
+  }
+
+  @Test
+  public void producerMap() {
+    assertThatModuleMethod("@Multibinds abstract Map<String, Producer<Object>> producerMap();")
+        .withDeclaration(moduleDeclaration)
+        .hasError("@Multibinds methods must return Map<K, V> or Set<T>");
+  }
+
+  @Test
+  public void producedMap() {
+    assertThatModuleMethod("@Multibinds abstract Map<String, Produced<Object>> producedMap();")
+        .withDeclaration(moduleDeclaration)
+        .hasError("@Multibinds methods must return Map<K, V> or Set<T>");
+  }
+
+  @Test
+  public void rawSet() {
+    assertThatModuleMethod("@Multibinds abstract Set rawSet();")
+        .withDeclaration(moduleDeclaration)
+        .hasError("@Multibinds methods must return Map<K, V> or Set<T>");
+  }
+
+  @Test
+  public void wildcardSet() {
+    assertThatModuleMethod("@Multibinds abstract Set<?> wildcardSet();")
+        .withDeclaration(moduleDeclaration)
+        .hasError("@Multibinds methods must return Map<K, V> or Set<T>");
+  }
+
+  @Test
+  public void providerSet() {
+    assertThatModuleMethod("@Multibinds abstract Set<Provider<Object>> providerSet();")
+        .withDeclaration(moduleDeclaration)
+        .hasError("@Multibinds methods must return Map<K, V> or Set<T>");
+  }
+
+  @Test
+  public void producerSet() {
+    assertThatModuleMethod("@Multibinds abstract Set<Producer<Object>> producerSet();")
+        .withDeclaration(moduleDeclaration)
+        .hasError("@Multibinds methods must return Map<K, V> or Set<T>");
+  }
+
+  @Test
+  public void producedSet() {
+    assertThatModuleMethod("@Multibinds abstract Set<Produced<Object>> producedSet();")
+        .withDeclaration(moduleDeclaration)
+        .hasError("@Multibinds methods must return Map<K, V> or Set<T>");
+  }
+
+  @Test
+  public void overqualifiedSet() {
+    assertThatModuleMethod(
+            "@Multibinds @SomeQualifier @OtherQualifier "
+                + "abstract Set<Object> tooManyQualifiersSet();")
+        .withDeclaration(moduleDeclaration)
+        .importing(SomeQualifier.class, OtherQualifier.class)
+        .hasError("Cannot use more than one @Qualifier");
+  }
+
+  @Test
+  public void overqualifiedMap() {
+    assertThatModuleMethod(
+            "@Multibinds @SomeQualifier @OtherQualifier "
+                + "abstract Map<String, Object> tooManyQualifiersMap();")
+        .withDeclaration(moduleDeclaration)
+        .importing(SomeQualifier.class, OtherQualifier.class)
+        .hasError("Cannot use more than one @Qualifier");
+  }
+
+  @Test
+  public void hasParameters() {
+    assertThatModuleMethod("@Multibinds abstract Set<String> parameters(Object param);")
+        .hasError("@Multibinds methods cannot have parameters");
+  }
+
+  @Qualifier
+  public @interface SomeQualifier {}
+
+  @Qualifier
+  public @interface OtherQualifier {}
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
index 5973a7bb3..59e50536a 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
@@ -17,7 +17,9 @@
 package dagger.internal.codegen;
 
 import com.google.common.collect.ImmutableList;
+import com.google.common.util.concurrent.ListenableFuture;
 import com.google.testing.compile.JavaFileObjects;
+import javax.inject.Qualifier;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -26,6 +28,8 @@
 import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatMethodInUnannotatedClass;
+import static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatProductionModuleMethod;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_ABSTRACT;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MULTIPLE_QUALIFIERS;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES;
@@ -37,12 +41,13 @@
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_SAME_NAME;
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_RAW_FUTURE;
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_RETURN_TYPE;
+import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_SCOPE;
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_SET_VALUES_RETURN_SET;
-import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_THROWS;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 
 @RunWith(JUnit4.class)
 public class ProducerModuleFactoryGeneratorTest {
+  
   private String formatErrorMessage(String msg) {
     return String.format(msg, "Produces");
   }
@@ -52,302 +57,112 @@ private String formatModuleErrorMessage(String msg) {
   }
 
   @Test public void producesMethodNotInModule() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.producers.Produces;",
-        "",
-        "final class TestModule {",
-        "  @Produces String produceString() {",
-        "    return \"\";",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(formatModuleErrorMessage(BINDING_METHOD_NOT_IN_MODULE));
+    assertThatMethodInUnannotatedClass("@Produces String produceString() { return null; }")
+        .hasError(formatModuleErrorMessage(BINDING_METHOD_NOT_IN_MODULE));
   }
 
   @Test public void producesMethodAbstract() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "",
-        "@ProducerModule",
-        "abstract class TestModule {",
-        "  @Produces abstract String produceString();",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(formatErrorMessage(BINDING_METHOD_ABSTRACT));
+    assertThatProductionModuleMethod("@Produces abstract String produceString();")
+        .hasError(formatErrorMessage(BINDING_METHOD_ABSTRACT));
   }
 
   @Test public void producesMethodPrivate() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "",
-        "@ProducerModule",
-        "final class TestModule {",
-        "  @Produces private String produceString() {",
-        "    return \"\";",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(formatErrorMessage(BINDING_METHOD_PRIVATE));
+    assertThatProductionModuleMethod("@Produces private String produceString() { return null; }")
+        .hasError(formatErrorMessage(BINDING_METHOD_PRIVATE));
   }
 
   @Test public void producesMethodReturnVoid() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "",
-        "@ProducerModule",
-        "final class TestModule {",
-        "  @Produces void produceNothing() {}",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(formatErrorMessage(BINDING_METHOD_MUST_RETURN_A_VALUE));
+    assertThatProductionModuleMethod("@Produces void produceNothing() {}")
+        .hasError(formatErrorMessage(BINDING_METHOD_MUST_RETURN_A_VALUE));
   }
 
-  @Test public void producesMethodFrameworkType() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.Lazy;",
-        "import dagger.MembersInjector;",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produced;",
-        "import dagger.producers.Producer;",
-        "import dagger.producers.Produces;",
-        "import javax.inject.Provider;",
-        "",
-        "@ProducerModule",
-        "final class TestModule {",
-        "  @Produces Provider<String> produceProvider() {}",
-        "  @Produces Lazy<String> produceLazy() {}",
-        "  @Produces MembersInjector<String> produceMembersInjector() {}",
-        "  @Produces Producer<String> produceProducer() {}",
-        "  @Produces Produced<String> produceProduced() {}",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-    .processedWith(new ComponentProcessor())
-    .failsToCompile()
-    .withErrorContaining(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES))
-    .in(moduleFile).onLine(13)
-    .and()
-    .withErrorContaining(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES))
-    .in(moduleFile).onLine(14)
-    .and()
-    .withErrorContaining(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES))
-    .in(moduleFile).onLine(15)
-    .and()
-    .withErrorContaining(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES))
-    .in(moduleFile).onLine(16)
-    .and()
-    .withErrorContaining(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES))
-    .in(moduleFile).onLine(17);
+  @Test
+  public void producesProvider() {
+    assertThatProductionModuleMethod("@Produces Provider<String> produceProvider() {}")
+        .hasError(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES));
+  }
+
+  @Test
+  public void producesLazy() {
+    assertThatProductionModuleMethod("@Produces Lazy<String> produceLazy() {}")
+        .hasError(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES));
+  }
+
+  @Test
+  public void producesMembersInjector() {
+    assertThatProductionModuleMethod(
+            "@Produces MembersInjector<String> produceMembersInjector() {}")
+        .hasError(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES));
+  }
+
+  @Test
+  public void producesProducer() {
+    assertThatProductionModuleMethod("@Produces Producer<String> produceProducer() {}")
+        .hasError(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES));
+  }
+
+  @Test
+  public void producesProduced() {
+    assertThatProductionModuleMethod("@Produces Produced<String> produceProduced() {}")
+        .hasError(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES));
   }
 
   @Test public void producesMethodReturnRawFuture() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "",
-        "@ProducerModule",
-        "final class TestModule {",
-        "  @Produces ListenableFuture produceRaw() {}",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(PRODUCES_METHOD_RAW_FUTURE);
+    assertThatProductionModuleMethod("@Produces ListenableFuture produceRaw() {}")
+        .importing(ListenableFuture.class)
+        .hasError(PRODUCES_METHOD_RAW_FUTURE);
   }
 
   @Test public void producesMethodReturnWildcardFuture() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "",
-        "@ProducerModule",
-        "final class TestModule {",
-        "  @Produces ListenableFuture<?> produceRaw() {}",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(PRODUCES_METHOD_RETURN_TYPE);
+    assertThatProductionModuleMethod("@Produces ListenableFuture<?> produceRaw() {}")
+        .importing(ListenableFuture.class)
+        .hasError(PRODUCES_METHOD_RETURN_TYPE);
   }
 
   @Test public void producesMethodWithTypeParameter() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "",
-        "@ProducerModule",
-        "final class TestModule {",
-        "  @Produces <T> String produceString() {",
-        "    return \"\";",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(formatErrorMessage(BINDING_METHOD_TYPE_PARAMETER));
+    assertThatProductionModuleMethod("@Produces <T> String produceString() { return null; }")
+        .hasError(formatErrorMessage(BINDING_METHOD_TYPE_PARAMETER));
   }
 
   @Test public void producesMethodSetValuesWildcard() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.multibindings.ElementsIntoSet;",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "",
-        "import java.util.Set;",
-        "",
-        "@ProducerModule",
-        "final class TestModule {",
-        "  @Produces @ElementsIntoSet Set<?> produceWildcard() {",
-        "    return null;",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(PRODUCES_METHOD_RETURN_TYPE);
+    assertThatProductionModuleMethod(
+            "@Produces @ElementsIntoSet Set<?> produceWildcard() { return null; }")
+        .hasError(PRODUCES_METHOD_RETURN_TYPE);
   }
 
   @Test public void producesMethodSetValuesRawSet() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.multibindings.ElementsIntoSet;",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "",
-        "import java.util.Set;",
-        "",
-        "@ProducerModule",
-        "final class TestModule {",
-        "  @Produces @ElementsIntoSet Set produceSomething() {",
-        "    return null;",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(formatErrorMessage(BINDING_METHOD_SET_VALUES_RAW_SET));
+    assertThatProductionModuleMethod(
+            "@Produces @ElementsIntoSet Set produceSomething() { return null; }")
+        .hasError(formatErrorMessage(BINDING_METHOD_SET_VALUES_RAW_SET));
   }
 
   @Test public void producesMethodSetValuesNotASet() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.multibindings.ElementsIntoSet;",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "",
-        "import java.util.List;",
-        "",
-        "@ProducerModule",
-        "final class TestModule {",
-        "  @Produces @ElementsIntoSet List<String> produceStrings() {",
-        "    return null;",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(PRODUCES_METHOD_SET_VALUES_RETURN_SET);
+    assertThatProductionModuleMethod(
+            "@Produces @ElementsIntoSet List<String> produceStrings() { return null; }")
+        .hasError(PRODUCES_METHOD_SET_VALUES_RETURN_SET);
   }
 
   @Test public void producesMethodSetValuesWildcardInFuture() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.multibindings.ElementsIntoSet;",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "",
-        "import java.util.Set;",
-        "",
-        "@ProducerModule",
-        "final class TestModule {",
-        "  @Produces @ElementsIntoSet ListenableFuture<Set<?>> produceWildcard() {",
-        "    return null;",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(PRODUCES_METHOD_RETURN_TYPE);
+    assertThatProductionModuleMethod(
+            "@Produces @ElementsIntoSet "
+                + "ListenableFuture<Set<?>> produceWildcard() { return null; }")
+        .importing(ListenableFuture.class)
+        .hasError(PRODUCES_METHOD_RETURN_TYPE);
   }
 
   @Test public void producesMethodSetValuesFutureRawSet() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.multibindings.ElementsIntoSet;",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "",
-        "import java.util.Set;",
-        "",
-        "@ProducerModule",
-        "final class TestModule {",
-        "  @Produces @ElementsIntoSet ListenableFuture<Set> produceSomething() {",
-        "    return null;",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(formatErrorMessage(BINDING_METHOD_SET_VALUES_RAW_SET));
+    assertThatProductionModuleMethod(
+            "@Produces @ElementsIntoSet ListenableFuture<Set> produceSomething() { return null; }")
+        .importing(ListenableFuture.class)
+        .hasError(formatErrorMessage(BINDING_METHOD_SET_VALUES_RAW_SET));
   }
 
   @Test public void producesMethodSetValuesFutureNotASet() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.multibindings.ElementsIntoSet;",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "",
-        "import java.util.List;",
-        "",
-        "@ProducerModule",
-        "final class TestModule {",
-        "  @Produces @ElementsIntoSet ListenableFuture<List<String>> produceStrings() {",
-        "    return null;",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(PRODUCES_METHOD_SET_VALUES_RETURN_SET);
+    assertThatProductionModuleMethod(
+            "@Produces @ElementsIntoSet "
+                + "ListenableFuture<List<String>> produceStrings() { return null; }")
+        .importing(ListenableFuture.class)
+        .hasError(PRODUCES_METHOD_SET_VALUES_RETURN_SET);
   }
 
   @Test public void multipleProducesMethodsWithSameName() {
@@ -377,28 +192,15 @@ private String formatModuleErrorMessage(String msg) {
 
   @Test
   public void producesMethodThrowsThrowable() {
-    JavaFileObject moduleFile =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.producers.ProducerModule;",
-            "import dagger.producers.Produces;",
-            "",
-            "@ProducerModule",
-            "final class TestModule {",
-            "  @Produces int produceInt() throws Throwable {",
-            "    return 0;",
-            "  }",
-            "",
-            "}");
-    assertAbout(javaSource())
-        .that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(PRODUCES_METHOD_THROWS)
-        .in(moduleFile)
-        .onLine(8);
+    assertThatProductionModuleMethod("@Produces int produceInt() throws Throwable { return 0; }")
+        .hasError(
+            "@Produces methods may only throw unchecked exceptions or exceptions subclassing "
+                + "Exception");
+  }
+
+  @Test public void producesMethodWithScope() {
+    assertThatProductionModuleMethod("@Produces @Singleton String str() { return \"\"; }")
+        .hasError(PRODUCES_METHOD_SCOPE);
   }
 
   @Test
@@ -688,37 +490,16 @@ public void singleProducesMethodNoArgsFutureWithProducerName() {
         .generatesSources(factoryFile);
   }
 
-  private static final JavaFileObject QUALIFIER_A =
-      JavaFileObjects.forSourceLines("test.QualifierA",
-          "package test;",
-          "",
-          "import javax.inject.Qualifier;",
-          "",
-          "@Qualifier @interface QualifierA {}");
-  private static final JavaFileObject QUALIFIER_B =
-      JavaFileObjects.forSourceLines("test.QualifierB",
-          "package test;",
-          "",
-          "import javax.inject.Qualifier;",
-          "",
-          "@Qualifier @interface QualifierB {}");
-
   @Test public void producesMethodMultipleQualifiers() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "",
-        "@ProducerModule",
-        "final class TestModule {",
-        "  @Produces @QualifierA @QualifierB abstract String produceString() {",
-        "    return \"\";",
-        "  }",
-        "}");
-    assertAbout(javaSources()).that(ImmutableList.of(moduleFile, QUALIFIER_A, QUALIFIER_B))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(BINDING_METHOD_MULTIPLE_QUALIFIERS);
+    assertThatProductionModuleMethod(
+            "@Produces @QualifierA @QualifierB abstract String produceString() { return null; }")
+        .importing(ListenableFuture.class, QualifierA.class, QualifierB.class)
+        .hasError(BINDING_METHOD_MULTIPLE_QUALIFIERS);
   }
+  
+  @Qualifier
+  public @interface QualifierA {}
+
+  @Qualifier
+  public @interface QualifierB {}
 }
diff --git a/core/src/main/java/dagger/internal/Collections.java b/core/src/main/java/dagger/internal/DaggerCollections.java
similarity index 56%
rename from core/src/main/java/dagger/internal/Collections.java
rename to core/src/main/java/dagger/internal/DaggerCollections.java
index 55f26ebab..e317c28b7 100644
--- a/core/src/main/java/dagger/internal/Collections.java
+++ b/core/src/main/java/dagger/internal/DaggerCollections.java
@@ -15,24 +15,54 @@
  */
 package dagger.internal;
 
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashSet;
 import java.util.LinkedHashMap;
-import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Set;
 
-final class Collections {
+/**
+ * Collection utility methods in service of Dagger internal classes. <em>Do not use</em> in client
+ * code.
+ */
+public final class DaggerCollections {
   /**
    * The maximum value for a signed 32-bit integer that is equal to a power of 2.
    */
   private static final int MAX_POWER_OF_TWO = 1 << (Integer.SIZE - 2);
 
-  private Collections() {
+  private DaggerCollections() {}
+
+  /**
+   * Returns a new list that is pre-sized to {@code size}, or {@link Collections#emptyList()} if
+   * empty. The list returned is never intended to grow beyond {@code size}, so adding to a list
+   * when the size is 0 is an error.
+   */
+  public static <T> List<T> presizedList(int size) {
+    if (size == 0) {
+      return Collections.emptyList();
+    }
+    return new ArrayList<T>(size);
   }
 
   /**
-   * Creates a {@link LinkedHashSet} instance, with a high enough "initial capacity" that it
-   * <em>should</em> hold {@code expectedSize} elements without growth.
+   * Returns true if at least one pair of items in {@code list} are equals.
+   */
+  public static boolean hasDuplicates(List<?> list) {
+    if (list.size() < 2) {
+      return false;
+    }
+    Set<Object> asSet = new HashSet<Object>(list);
+    return list.size() != asSet.size();
+  }
+
+  /**
+   * Creates a {@link HashSet} instance, with a high enough "intial capcity" that it <em>should</em>
+   * hold {@code expectedSize} elements without growth.
    */
-  static <E> LinkedHashSet<E> newLinkedHashSetWithExpectedSize(int expectedSize) {
-    return new LinkedHashSet<E>(calculateInitialCapacity(expectedSize));
+  static <T> HashSet<T> newHashSetWithExpectedSize(int expectedSize) {
+    return new HashSet<T>(calculateInitialCapacity(expectedSize));
   }
 
   /**
diff --git a/core/src/main/java/dagger/internal/MapFactory.java b/core/src/main/java/dagger/internal/MapFactory.java
index 4dac1262b..b0364ba01 100644
--- a/core/src/main/java/dagger/internal/MapFactory.java
+++ b/core/src/main/java/dagger/internal/MapFactory.java
@@ -19,7 +19,7 @@
 import java.util.Map.Entry;
 import javax.inject.Provider;
 
-import static dagger.internal.Collections.newLinkedHashMapWithExpectedSize;
+import static dagger.internal.DaggerCollections.newLinkedHashMapWithExpectedSize;
 import static java.util.Collections.unmodifiableMap;
 
 /**
diff --git a/core/src/main/java/dagger/internal/MapProviderFactory.java b/core/src/main/java/dagger/internal/MapProviderFactory.java
index b5c96e702..141a77bf0 100644
--- a/core/src/main/java/dagger/internal/MapProviderFactory.java
+++ b/core/src/main/java/dagger/internal/MapProviderFactory.java
@@ -20,7 +20,7 @@
 import java.util.Map;
 import javax.inject.Provider;
 
-import static dagger.internal.Collections.newLinkedHashMapWithExpectedSize;
+import static dagger.internal.DaggerCollections.newLinkedHashMapWithExpectedSize;
 import static java.util.Collections.unmodifiableMap;
 
 /**
diff --git a/core/src/main/java/dagger/internal/SetFactory.java b/core/src/main/java/dagger/internal/SetFactory.java
index b17156cfe..d4e89f9a8 100644
--- a/core/src/main/java/dagger/internal/SetFactory.java
+++ b/core/src/main/java/dagger/internal/SetFactory.java
@@ -16,13 +16,14 @@
 package dagger.internal;
 
 import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 import javax.inject.Provider;
 
-import static dagger.internal.Collections.newLinkedHashSetWithExpectedSize;
+import static dagger.internal.DaggerCollections.hasDuplicates;
+import static dagger.internal.DaggerCollections.newHashSetWithExpectedSize;
+import static dagger.internal.DaggerCollections.presizedList;
+import static dagger.internal.Preconditions.checkNotNull;
 import static java.util.Collections.emptySet;
 import static java.util.Collections.unmodifiableSet;
 
@@ -35,12 +36,6 @@
  * @since 2.0
  */
 public final class SetFactory<T> implements Factory<Set<T>> {
-  /**
-   * A message for NPEs that trigger on bad argument lists.
-   */
-  private static final String ARGUMENTS_MUST_BE_NON_NULL =
-      "SetFactory.create() requires its arguments to be non-null";
-
   private static final Factory<Set<Object>> EMPTY_FACTORY =
       new Factory<Set<Object>>() {
         @Override
@@ -55,45 +50,55 @@
   }
 
   /**
-   * Returns the supplied factory.  If there's just one factory, there's no need to wrap it or its
-   * result.
+   * Constructs a new {@link Builder} for a {@link SetFactory} with {@code individualProviderSize}
+   * individual {@code Provider<T>} and {@code setProviderSize} {@code Provider<Set<T>>} instances.
    */
-  public static <T> Factory<Set<T>> create(Factory<Set<T>> factory) {
-    assert factory != null : ARGUMENTS_MUST_BE_NON_NULL;
-    return factory;
+  public static <T> Builder<T> builder(int individualProviderSize, int setProviderSize) {
+    return new Builder<T>(individualProviderSize, setProviderSize);
   }
 
   /**
-   * Returns a new factory that creates {@link Set} instances that form the union of the given
-   * {@link Provider} instances.  Callers must not modify the providers array after invoking this
-   * method; no copy is made.
+   * A builder to accumulate {@code Provider<T>} and {@code Provider<Set<T>>} instances. These are
+   * only intended to be single-use and from within generated code. Do <em>NOT</em> add providers
+   * after calling {@link #build()}.
    */
-  public static <T> Factory<Set<T>> create(
-      @SuppressWarnings("unchecked") Provider<Set<T>>... providers) {
-    assert providers != null : ARGUMENTS_MUST_BE_NON_NULL;
+  public static final class Builder<T> {
+    private final List<Provider<T>> individualProviders;
+    private final List<Provider<Set<T>>> setProviders;
 
-    List<Provider<Set<T>>> contributingProviders = Arrays.asList(providers);
+    private Builder(int individualProviderSize, int setProviderSize) {
+      individualProviders = presizedList(individualProviderSize);
+      setProviders = presizedList(setProviderSize);
+    }
 
-    assert !contributingProviders.contains(null)
-        : "Codegen error?  Null within provider list.";
-    assert !hasDuplicates(contributingProviders)
-        : "Codegen error?  Duplicates in the provider list";
+    public Builder<T> addProvider(Provider<T> individualProvider) {
+      assert individualProvider != null : "Codegen error? Null provider";
+      individualProviders.add(individualProvider);
+      return this;
+    }
 
-    return new SetFactory<T>(contributingProviders);
-  }
+    public Builder<T> addSetProvider(Provider<Set<T>> multipleProvider) {
+      assert multipleProvider != null : "Codegen error? Null provider";
+      setProviders.add(multipleProvider);
+      return this;
+    }
 
-  /**
-   * Returns true if at least one pair of items in (@code original) are equals.
-   */
-  private static boolean hasDuplicates(List<? extends Object> original) {
-    Set<Object> asSet = new HashSet<Object>(original);
-    return original.size() != asSet.size();
+    public SetFactory<T> build() {
+      assert !hasDuplicates(individualProviders)
+          : "Codegen error?  Duplicates in the provider list";
+      assert !hasDuplicates(setProviders)
+          : "Codegen error?  Duplicates in the provider list";
+
+      return new SetFactory<T>(individualProviders, setProviders);
+    }
   }
 
-  private final List<Provider<Set<T>>> contributingProviders;
+  private final List<Provider<T>> individualProviders;
+  private final List<Provider<Set<T>>> setProviders;
 
-  private SetFactory(List<Provider<Set<T>>> contributingProviders) {
-    this.contributingProviders = contributingProviders;
+  private SetFactory(List<Provider<T>> individualProviders, List<Provider<Set<T>>> setProviders) {
+    this.individualProviders = individualProviders;
+    this.setProviders = setProviders;
   }
 
   /**
@@ -105,32 +110,28 @@ private SetFactory(List<Provider<Set<T>>> contributingProviders) {
    */
   @Override
   public Set<T> get() {
-    int size = 0;
-
+    int size = individualProviders.size();
     // Profiling revealed that this method was a CPU-consuming hotspot in some applications, so
     // these loops were changed to use c-style for.  Versus enhanced for-each loops, C-style for is
     // faster for ArrayLists, at least through Java 8.
 
-    List<Set<T>> providedSets = new ArrayList<Set<T>>(contributingProviders.size());
-    for (int i = 0, c = contributingProviders.size(); i < c; i++) {
-      Provider<Set<T>> provider = contributingProviders.get(i);
-      Set<T> providedSet = provider.get();
-      if (providedSet == null) {
-        throw new NullPointerException(provider + " returned null");
-      }
-      providedSets.add(providedSet);
+    List<Set<T>> providedSets = new ArrayList<Set<T>>(setProviders.size());
+    for (int i = 0, c = setProviders.size(); i < c; i++) {
+      Set<T> providedSet = setProviders.get(i).get();
       size += providedSet.size();
+      providedSets.add(providedSet);
     }
 
-    Set<T> result = newLinkedHashSetWithExpectedSize(size);
+    Set<T> providedValues = newHashSetWithExpectedSize(size);
+    for (int i = 0, c = individualProviders.size(); i < c; i++) {
+      providedValues.add(checkNotNull(individualProviders.get(i).get()));
+    }
     for (int i = 0, c = providedSets.size(); i < c; i++) {
       for (T element : providedSets.get(i)) {
-        if (element == null) {
-          throw new NullPointerException("a null element was provided");
-        }
-        result.add(element);
+        providedValues.add(checkNotNull(element));
       }
     }
-    return unmodifiableSet(result);
+
+    return unmodifiableSet(providedValues);
   }
 }
diff --git a/core/src/main/java/dagger/multibindings/Multibinds.java b/core/src/main/java/dagger/multibindings/Multibinds.java
new file mode 100644
index 000000000..d41a4dc92
--- /dev/null
+++ b/core/src/main/java/dagger/multibindings/Multibinds.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.multibindings;
+
+import dagger.internal.Beta;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.METHOD;
+
+@Documented
+@Target(METHOD)
+@Beta
+public @interface Multibinds {}
diff --git a/core/src/test/java/dagger/internal/SetFactoryTest.java b/core/src/test/java/dagger/internal/SetFactoryTest.java
index 04b982281..b6d5d78ab 100644
--- a/core/src/test/java/dagger/internal/SetFactoryTest.java
+++ b/core/src/test/java/dagger/internal/SetFactoryTest.java
@@ -15,9 +15,8 @@
  */
 package dagger.internal;
 
-import com.google.common.collect.ContiguousSet;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Range;
+import java.util.Arrays;
 import java.util.LinkedHashSet;
 import java.util.Set;
 import java.util.concurrent.atomic.AtomicInteger;
@@ -28,8 +27,7 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.collect.DiscreteDomain.integers;
-import static com.google.common.truth.Truth.assert_;
+import static com.google.common.truth.Truth.assertThat;
 
 @RunWith(JUnit4.class)
 @SuppressWarnings("unchecked")
@@ -37,97 +35,69 @@
   @Rule public ExpectedException thrown = ExpectedException.none();
 
   @Test
-  public void providerReturnsNullSet() {
-    Factory<Set<Integer>> factory = SetFactory.create(new Provider<Set<Integer>>() {
-      @Override
-      public Set<Integer> get() {
-        return null;
-      }
-    }, incrementingIntegerProvider(0));
+  public void providerReturnsNull() {
+    Factory<Set<Integer>> factory =
+        SetFactory.<Integer>builder(0, 1).addSetProvider(providerOf((Set<Integer>) null)).build();
     thrown.expect(NullPointerException.class);
     factory.get();
   }
 
   @Test
-  public void providerReturnsNullSet_single() {
-    Factory<Set<Integer>> factory = SetFactory.create(new Provider<Set<Integer>>() {
-      @Override
-      public Set<Integer> get() {
-        return null;
-      }
-    });
+  public void providerReturnsNullSet() {
+    Factory<Set<Integer>> factory =
+        SetFactory.<Integer>builder(1, 0).addProvider(providerOf((Integer) null)).build();
     thrown.expect(NullPointerException.class);
     factory.get();
   }
 
   @Test
   public void providerReturnsSetWithNullElement() {
-    Factory<Set<Integer>> factory = SetFactory.create(new Provider<Set<Integer>>() {
-      @Override
-      public Set<Integer> get() {
-        LinkedHashSet<Integer> result = new LinkedHashSet<Integer>();
-        result.add(1);
-        result.add(null);
-        result.add(3);
-        return result;
-      }
-    });
-    thrown.expect(NullPointerException.class);
-    factory.get();
-  }
-
-  @Test
-  public void providerReturnsSetWithNullElement_single() {
-    Factory<Set<Integer>> factory = SetFactory.create(new Provider<Set<Integer>>() {
-      @Override
-      public Set<Integer> get() {
-        LinkedHashSet<Integer> result = new LinkedHashSet<Integer>();
-        result.add(1);
-        result.add(null);
-        result.add(3);
-        return result;
-      }
-    }, incrementingIntegerProvider(0));
+    Set<Integer> set = new LinkedHashSet<Integer>(Arrays.asList(1, null, 3));
+    Factory<Set<Integer>> factory =
+        SetFactory.<Integer>builder(0, 1).addSetProvider(providerOf(set)).build();
     thrown.expect(NullPointerException.class);
     factory.get();
   }
 
   @Test
-  public void invokesProvidersEverytTime() {
-    Factory<Set<Integer>> factory = SetFactory.create(
-        incrementingIntegerProvider(0),
-        incrementingIntegerProvider(10),
-        incrementingIntegerProvider(20));
-    assert_().that(factory.get()).containsExactly(0, 10, 20);
-    assert_().that(factory.get()).containsExactly(1, 11, 21);
-    assert_().that(factory.get()).containsExactly(2, 12, 22);
+  public void invokesProvidersEveryTime() {
+    Factory<Set<Integer>> factory =
+        SetFactory.<Integer>builder(2, 2)
+            .addProvider(incrementingIntegerProvider(0))
+            .addProvider(incrementingIntegerProvider(10))
+            .addSetProvider(incrementingIntegerSetProvider(20))
+            .addSetProvider(incrementingIntegerSetProvider(30))
+            .build();
+    assertThat(factory.get()).containsExactly(0, 10, 20, 21, 30, 31);
+    assertThat(factory.get()).containsExactly(1, 11, 22, 23, 32, 33);
+    assertThat(factory.get()).containsExactly(2, 12, 24, 25, 34, 35);
   }
 
-  @Test
-  public void iterationOrder() {
-    Factory<Set<Integer>> factory = SetFactory.create(
-        integerSetProvider(Range.closed(5, 9)),
-        integerSetProvider(Range.closed(3, 6)),
-        integerSetProvider(Range.closed(0, 5)));
-    assert_().that(factory.get()).containsExactly(5, 6, 7, 8, 9, 3, 4, 0, 1, 2).inOrder();
+  private static <T> Provider<T> providerOf(final T value) {
+    return new Provider<T>() {
+      @Override
+      public T get() {
+        return value;
+      }
+    };
   }
 
-  private static Provider<Set<Integer>> incrementingIntegerProvider(int seed) {
+  private static Provider<Integer> incrementingIntegerProvider(int seed) {
     final AtomicInteger value = new AtomicInteger(seed);
-    return new Provider<Set<Integer>>() {
+    return new Provider<Integer>() {
       @Override
-      public Set<Integer> get() {
-        return ImmutableSet.of(value.getAndIncrement());
+      public Integer get() {
+        return value.getAndIncrement();
       }
     };
   }
 
-  private static Provider<Set<Integer>> integerSetProvider(Range<Integer> range) {
-    final ContiguousSet<Integer> set = ContiguousSet.create(range, integers());
+  private static Provider<Set<Integer>> incrementingIntegerSetProvider(int seed) {
+    final AtomicInteger value = new AtomicInteger(seed);
     return new Provider<Set<Integer>>() {
       @Override
       public Set<Integer> get() {
-        return set;
+        return ImmutableSet.of(value.getAndIncrement(), value.getAndIncrement());
       }
     };
   }
diff --git a/producers/src/main/java/dagger/producers/ProducerModule.java b/producers/src/main/java/dagger/producers/ProducerModule.java
index 714e3fa3e..f383145ad 100644
--- a/producers/src/main/java/dagger/producers/ProducerModule.java
+++ b/producers/src/main/java/dagger/producers/ProducerModule.java
@@ -18,9 +18,11 @@
 import dagger.Module;
 import dagger.internal.Beta;
 import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
 import static java.lang.annotation.ElementType.TYPE;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 /**
  * Annotates a class that contributes {@link Produces} bindings to the production component.
@@ -29,6 +31,7 @@
  */
 @Documented
 @Target(TYPE)
+@Retention(RUNTIME)
 @Beta
 public @interface ProducerModule {
   /**
diff --git a/producers/src/main/java/dagger/producers/Produces.java b/producers/src/main/java/dagger/producers/Produces.java
index 1b57bc39d..4bd807618 100644
--- a/producers/src/main/java/dagger/producers/Produces.java
+++ b/producers/src/main/java/dagger/producers/Produces.java
@@ -18,9 +18,11 @@
 import dagger.internal.Beta;
 import com.google.common.util.concurrent.ListenableFuture;
 import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
 import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 /**
  * Annotates methods of a producer module to create a production binding. If the method returns
@@ -32,6 +34,7 @@
  */
 @Documented
 @Target(METHOD)
+@Retention(RUNTIME)
 @Beta
 public @interface Produces {
   /** The type of binding into which the return type of the annotated method contributes. */
diff --git a/producers/src/main/java/dagger/producers/internal/SetOfProducedProducer.java b/producers/src/main/java/dagger/producers/internal/SetOfProducedProducer.java
index 2862f6c3c..39712fac6 100644
--- a/producers/src/main/java/dagger/producers/internal/SetOfProducedProducer.java
+++ b/producers/src/main/java/dagger/producers/internal/SetOfProducedProducer.java
@@ -27,6 +27,10 @@
 import java.util.Set;
 import java.util.concurrent.ExecutionException;
 
+import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.DaggerCollections.hasDuplicates;
+import static dagger.internal.DaggerCollections.presizedList;
+
 /**
  * A {@link Producer} implementation used to implement {@link Set} bindings. This producer returns a
  * future {@code Set<Produced<T>>} whose elements are populated by subsequent calls to the delegate
@@ -41,18 +45,56 @@
   }
 
   /**
-   * Returns a new producer that creates {@link Set} futures from the union of the given
-   * {@link Producer} instances.
+   * Constructs a new {@link Builder} for a {@link SetProducer} with {@code individualProducerSize}
+   * individual {@code Producer<T>} and {@code setProducerSize} {@code Producer<Set<T>>} instances.
+   */
+  public static <T> Builder<T> builder(int individualProducerSize, int setProducerSize) {
+    return new Builder<T>(individualProducerSize, setProducerSize);
+  }
+
+  /**
+   * A builder to accumulate {@code Producer<T>} and {@code Producer<Set<T>>} instances. These are
+   * only intended to be single-use and from within generated code. Do <em>NOT</em> add producers
+   * after calling {@link #build()}.
    */
-  @SafeVarargs
-  public static <T> Producer<Set<Produced<T>>> create(Producer<Set<T>>... producers) {
-    return new SetOfProducedProducer<T>(ImmutableSet.copyOf(producers));
+  public static final class Builder<T> {
+    private final List<Producer<T>> individualProducers;
+    private final List<Producer<Set<T>>> setProducers;
+
+    private Builder(int individualProducerSize, int setProducerSize) {
+      individualProducers = presizedList(individualProducerSize);
+      setProducers = presizedList(setProducerSize);
+    }
+
+    public Builder<T> addProducer(Producer<T> individualProducer) {
+      assert individualProducer != null : "Codegen error? Null producer";
+      individualProducers.add(individualProducer);
+      return this;
+    }
+
+    public Builder<T> addSetProducer(Producer<Set<T>> multipleProducer) {
+      assert multipleProducer != null : "Codegen error? Null producer";
+      setProducers.add(multipleProducer);
+      return this;
+    }
+
+    public SetOfProducedProducer<T> build() {
+      assert !hasDuplicates(individualProducers)
+          : "Codegen error?  Duplicates in the producer list";
+      assert !hasDuplicates(setProducers)
+          : "Codegen error?  Duplicates in the producer list";
+
+      return new SetOfProducedProducer<T>(individualProducers, setProducers);
+    }
   }
 
-  private final ImmutableSet<Producer<Set<T>>> contributingProducers;
+  private final List<Producer<T>> individualProducers;
+  private final List<Producer<Set<T>>> setProducers;
 
-  private SetOfProducedProducer(ImmutableSet<Producer<Set<T>>> contributingProducers) {
-    this.contributingProducers = contributingProducers;
+  private SetOfProducedProducer(
+      List<Producer<T>> individualProducers, List<Producer<Set<T>>> setProducers) {
+    this.individualProducers = individualProducers;
+    this.setProducers = setProducers;
   }
 
   /**
@@ -71,14 +113,19 @@ private SetOfProducedProducer(ImmutableSet<Producer<Set<T>>> contributingProduce
   @Override
   public ListenableFuture<Set<Produced<T>>> compute(ProducerMonitor unusedMonitor) {
     List<ListenableFuture<Produced<Set<T>>>> futureProducedSets =
-        new ArrayList<ListenableFuture<Produced<Set<T>>>>(contributingProducers.size());
-    for (Producer<Set<T>> producer : contributingProducers) {
-      ListenableFuture<Set<T>> futureSet = producer.get();
-      if (futureSet == null) {
-        throw new NullPointerException(producer + " returned null");
-      }
-      futureProducedSets.add(Producers.createFutureProduced(futureSet));
+        new ArrayList<ListenableFuture<Produced<Set<T>>>>(
+            individualProducers.size() + setProducers.size());
+    for (Producer<T> producer : individualProducers) {
+      // TODO(ronshapiro): Don't require individual productions to be added to a set just to be
+      // materialized into futureProducedSets.
+      futureProducedSets.add(
+          Producers.createFutureProduced(
+              Producers.createFutureSingletonSet(checkNotNull(producer.get()))));
     }
+    for (Producer<Set<T>> producer : setProducers) {
+      futureProducedSets.add(Producers.createFutureProduced(checkNotNull(producer.get())));
+    }
+
     return Futures.transform(
         Futures.allAsList(futureProducedSets),
         new Function<List<Produced<Set<T>>>, Set<Produced<T>>>() {
diff --git a/producers/src/main/java/dagger/producers/internal/SetProducer.java b/producers/src/main/java/dagger/producers/internal/SetProducer.java
index 090010d65..b9189d29a 100644
--- a/producers/src/main/java/dagger/producers/internal/SetProducer.java
+++ b/producers/src/main/java/dagger/producers/internal/SetProducer.java
@@ -25,6 +25,10 @@
 import java.util.List;
 import java.util.Set;
 
+import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.DaggerCollections.hasDuplicates;
+import static dagger.internal.DaggerCollections.presizedList;
+
 /**
  * A {@link Producer} implementation used to implement {@link Set} bindings. This producer returns
  * a future {@link Set} whose elements are populated by subsequent calls to the delegate
@@ -48,27 +52,56 @@
   }
 
   /**
-   * Returns the supplied producer.  If there's just one producer, there's no need to wrap it or its
-   * result.
+   * Constructs a new {@link Builder} for a {@link SetProducer} with {@code individualProducerSize}
+   * individual {@code Producer<T>} and {@code setProducerSize} {@code Producer<Set<T>>} instances.
    */
-  public static <T> Producer<Set<T>> create(Producer<Set<T>> producer) {
-    return producer;
+  public static <T> Builder<T> builder(int individualProducerSize, int setProducerSize) {
+    return new Builder<T>(individualProducerSize, setProducerSize);
   }
 
   /**
-   * Returns a new producer that creates {@link Set} futures from the union of the given
-   * {@link Producer} instances.
+   * A builder to accumulate {@code Producer<T>} and {@code Producer<Set<T>>} instances. These are
+   * only intended to be single-use and from within generated code. Do <em>NOT</em> add producers
+   * after calling {@link #build()}.
    */
-  @SafeVarargs
-  public static <T> Producer<Set<T>> create(Producer<Set<T>>... producers) {
-    return new SetProducer<T>(ImmutableSet.copyOf(producers));
+  public static final class Builder<T> {
+    private final List<Producer<T>> individualProducers;
+    private final List<Producer<Set<T>>> setProducers;
+
+    private Builder(int individualProducerSize, int setProducerSize) {
+      individualProducers = presizedList(individualProducerSize);
+      setProducers = presizedList(setProducerSize);
+    }
+
+    public Builder<T> addProducer(Producer<T> individualProducer) {
+      assert individualProducer != null : "Codegen error? Null producer";
+      individualProducers.add(individualProducer);
+      return this;
+    }
+
+    public Builder<T> addSetProducer(Producer<Set<T>> multipleProducer) {
+      assert multipleProducer != null : "Codegen error? Null producer";
+      setProducers.add(multipleProducer);
+      return this;
+    }
+
+    public SetProducer<T> build() {
+      assert !hasDuplicates(individualProducers)
+          : "Codegen error?  Duplicates in the producer list";
+      assert !hasDuplicates(setProducers)
+          : "Codegen error?  Duplicates in the producer list";
+
+      return new SetProducer<T>(individualProducers, setProducers);
+    }
   }
 
-  private final Set<Producer<Set<T>>> contributingProducers;
+  private final List<Producer<T>> individualProducers;
+  private final List<Producer<Set<T>>> setProducers;
 
-  private SetProducer(Set<Producer<Set<T>>> contributingProducers) {
-    super();
-    this.contributingProducers = contributingProducers;
+  private SetProducer(
+      List<Producer<T>> individualProducers, List<Producer<Set<T>>> setProducers) {
+    this.individualProducers = individualProducers;
+    this.setProducers = setProducers;
   }
 
   /**
@@ -85,14 +118,27 @@ private SetProducer(Set<Producer<Set<T>>> contributingProducers) {
    */
   @Override
   public ListenableFuture<Set<T>> compute(ProducerMonitor unusedMonitor) {
+    List<ListenableFuture<T>> individualFutures =
+        new ArrayList<ListenableFuture<T>>(individualProducers.size());
+    for (Producer<T> producer : individualProducers) {
+      individualFutures.add(checkNotNull(producer.get()));
+    }
+
     List<ListenableFuture<Set<T>>> futureSets =
-        new ArrayList<ListenableFuture<Set<T>>>(contributingProducers.size());
-    for (Producer<Set<T>> producer : contributingProducers) {
-      ListenableFuture<Set<T>> futureSet = producer.get();
-      if (futureSet == null) {
-        throw new NullPointerException(producer + " returned null");
-      }
-      futureSets.add(futureSet);
+        new ArrayList<ListenableFuture<Set<T>>>(setProducers.size() + 1);
+    futureSets.add(
+        Futures.transform(
+            Futures.allAsList(individualFutures),
+            // TODO(ronshapiro): make static instances of these transformation functions
+            new Function<List<T>, Set<T>>() {
+              @Override
+              public Set<T> apply(List<T> list) {
+                return ImmutableSet.copyOf(list);
+              }
+            }));
+
+    for (Producer<Set<T>> producer : setProducers) {
+      futureSets.add(checkNotNull(producer.get()));
     }
     return Futures.transform(Futures.allAsList(futureSets), new Function<List<Set<T>>, Set<T>>() {
       @Override public Set<T> apply(List<Set<T>> sets) {
diff --git a/producers/src/test/java/dagger/producers/internal/SetOfProducedProducerTest.java b/producers/src/test/java/dagger/producers/internal/SetOfProducedProducerTest.java
index e36ba05a4..1f87a6f99 100644
--- a/producers/src/test/java/dagger/producers/internal/SetOfProducedProducerTest.java
+++ b/producers/src/test/java/dagger/producers/internal/SetOfProducedProducerTest.java
@@ -38,13 +38,13 @@
   @Test
   public void success() throws Exception {
     Producer<Set<Produced<Integer>>> producer =
-        SetOfProducedProducer.create(
-            Producers.<Set<Integer>>immediateProducer(ImmutableSet.of(1, 2)),
-            Producers.<Set<Integer>>immediateProducer(ImmutableSet.of(5, 7)));
+        SetOfProducedProducer.<Integer>builder(1, 1)
+            .addProducer(Producers.immediateProducer(1))
+            .addSetProducer(Producers.<Set<Integer>>immediateProducer(ImmutableSet.of(5, 7)))
+            .build();
     assertThat(producer.get().get())
         .containsExactly(
             Produced.successful(1),
-            Produced.successful(2),
             Produced.successful(5),
             Produced.successful(7));
   }
@@ -53,18 +53,21 @@ public void success() throws Exception {
   public void failure() throws Exception {
     RuntimeException e = new RuntimeException("monkey");
     Producer<Set<Produced<Integer>>> producer =
-        SetOfProducedProducer.create(
-            Producers.<Set<Integer>>immediateProducer(ImmutableSet.of(1, 2)),
-            Producers.<Set<Integer>>immediateFailedProducer(e));
+        SetOfProducedProducer.<Integer>builder(1, 1)
+            .addSetProducer(Producers.<Set<Integer>>immediateProducer(ImmutableSet.of(1, 2)))
+            .addProducer(Producers.<Integer>immediateFailedProducer(e))
+            .build();
     assertThat(producer.get().get())
         .containsExactly(
             Produced.successful(1), Produced.successful(2), Produced.<Integer>failed(e));
   }
 
   @Test
-  public void delegateSetNpe() throws Exception {
+  public void delegateNpe() throws Exception {
     Producer<Set<Produced<Integer>>> producer =
-        SetOfProducedProducer.create(Producers.<Set<Integer>>immediateProducer(null));
+        SetOfProducedProducer.<Integer>builder(1, 0)
+            .addProducer(Producers.<Integer>immediateProducer(null))
+            .build();
     Results<Integer> results = Results.create(producer.get().get());
     assertThat(results.successes).isEmpty();
     assertThat(results.failures).hasSize(1);
@@ -73,13 +76,13 @@ public void delegateSetNpe() throws Exception {
   }
 
   @Test
-  public void oneOfDelegateSetNpe() throws Exception {
+  public void delegateSetNpe() throws Exception {
     Producer<Set<Produced<Integer>>> producer =
-        SetOfProducedProducer.create(
-            Producers.<Set<Integer>>immediateProducer(null),
-            Producers.<Set<Integer>>immediateProducer(ImmutableSet.of(7, 3)));
+        SetOfProducedProducer.<Integer>builder(0, 1)
+            .addSetProducer(Producers.<Set<Integer>>immediateProducer(null))
+            .build();
     Results<Integer> results = Results.create(producer.get().get());
-    assertThat(results.successes).containsExactly(3, 7);
+    assertThat(results.successes).isEmpty();
     assertThat(results.failures).hasSize(1);
     assertThat(Iterables.getOnlyElement(results.failures).getCause())
         .isInstanceOf(NullPointerException.class);
@@ -88,8 +91,10 @@ public void oneOfDelegateSetNpe() throws Exception {
   @Test
   public void delegateElementNpe() throws Exception {
     Producer<Set<Produced<Integer>>> producer =
-        SetOfProducedProducer.create(
-            Producers.<Set<Integer>>immediateProducer(Collections.<Integer>singleton(null)));
+        SetOfProducedProducer.<Integer>builder(0, 1)
+            .addSetProducer(
+                Producers.<Set<Integer>>immediateProducer(Collections.<Integer>singleton(null)))
+            .build();
     Results<Integer> results = Results.create(producer.get().get());
     assertThat(results.successes).isEmpty();
     assertThat(results.failures).hasSize(1);
@@ -100,8 +105,11 @@ public void delegateElementNpe() throws Exception {
   @Test
   public void oneOfDelegateElementNpe() throws Exception {
     Producer<Set<Produced<Integer>>> producer =
-        SetOfProducedProducer.create(
-            Producers.<Set<Integer>>immediateProducer(Sets.newHashSet(Arrays.asList(5, 2, null))));
+        SetOfProducedProducer.<Integer>builder(0, 1)
+            .addSetProducer(
+                Producers.<Set<Integer>>immediateProducer(
+                    Sets.newHashSet(Arrays.asList(5, 2, null))))
+            .build();
     Results<Integer> results = Results.create(producer.get().get());
     assertThat(results.successes).containsExactly(2, 5);
     assertThat(results.failures).hasSize(1);
diff --git a/producers/src/test/java/dagger/producers/internal/SetProducerTest.java b/producers/src/test/java/dagger/producers/internal/SetProducerTest.java
index a38830f0a..da250945e 100644
--- a/producers/src/test/java/dagger/producers/internal/SetProducerTest.java
+++ b/producers/src/test/java/dagger/producers/internal/SetProducerTest.java
@@ -33,19 +33,22 @@
  */
 @RunWith(JUnit4.class)
 public class SetProducerTest {
-  @Test public void success() throws Exception {
+  @Test
+  public void success() throws Exception {
     Producer<Set<Integer>> producer =
-        SetProducer.create(
-            Producers.<Set<Integer>>immediateProducer(ImmutableSet.of(1, 2)),
-            Producers.<Set<Integer>>immediateProducer(ImmutableSet.of(5, 7)));
-    assertThat(producer.get().get()).containsExactly(1, 2, 5, 7);
+        SetProducer.<Integer>builder(1, 1)
+            .addProducer(Producers.immediateProducer(1))
+            .addSetProducer(Producers.<Set<Integer>>immediateProducer(ImmutableSet.of(5, 7)))
+            .build();
+    assertThat(producer.get().get()).containsExactly(1, 5, 7);
   }
 
-  @Test public void delegateSetNpe() throws Exception {
+  @Test
+  public void delegateNpe() throws Exception {
     Producer<Set<Integer>> producer =
-        SetProducer.create(
-            Producers.<Set<Integer>>immediateProducer(ImmutableSet.of(1, 2)),
-            Producers.<Set<Integer>>immediateProducer(null));
+        SetProducer.<Integer>builder(1, 0)
+            .addProducer(Producers.<Integer>immediateProducer(null))
+            .build();
     ListenableFuture<Set<Integer>> future = producer.get();
     try {
       future.get();
@@ -55,11 +58,29 @@
     }
   }
 
-  @Test public void delegateElementNpe() throws Exception {
+  @Test
+  public void delegateSetNpe() throws Exception {
     Producer<Set<Integer>> producer =
-        SetProducer.create(
-            Producers.<Set<Integer>>immediateProducer(ImmutableSet.of(1, 2)),
-            Producers.<Set<Integer>>immediateProducer(Collections.<Integer>singleton(null)));
+        SetProducer.<Integer>builder(0, 1)
+            .addSetProducer(Producers.<Set<Integer>>immediateProducer(null))
+            .build();
+    ListenableFuture<Set<Integer>> future = producer.get();
+    try {
+      future.get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).isInstanceOf(NullPointerException.class);
+    }
+  }
+
+  @Test
+  public void delegateElementNpe() throws Exception {
+    Producer<Set<Integer>> producer =
+        SetProducer.<Integer>builder(0, 2)
+            .addSetProducer(Producers.<Set<Integer>>immediateProducer(ImmutableSet.of(1, 2)))
+            .addSetProducer(
+                Producers.<Set<Integer>>immediateProducer(Collections.<Integer>singleton(null)))
+            .build();
     ListenableFuture<Set<Integer>> future = producer.get();
     try {
       future.get();
