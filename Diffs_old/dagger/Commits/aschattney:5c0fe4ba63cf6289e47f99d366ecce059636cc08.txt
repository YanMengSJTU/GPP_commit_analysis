diff --git a/compiler/src/main/java/dagger/internal/codegen/ApplicationGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ApplicationGenerator.java
index e8ef80fa1..029d20729 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ApplicationGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ApplicationGenerator.java
@@ -2,7 +2,6 @@
 
 import com.google.auto.common.MoreTypes;
 import com.squareup.javapoet.*;
-import dagger.Component;
 
 import javax.annotation.processing.Filer;
 import javax.lang.model.element.*;
@@ -11,17 +10,19 @@
 import javax.lang.model.util.Types;
 import java.util.*;
 
-/**
- * Created by Andy on 18.05.2017.
- */
-public class ApplicationGenerator extends SourceFileGenerator<DI>{
+import static dagger.internal.codegen.Util.*;
+
+class ApplicationGenerator extends SourceFileGenerator<DI>{
+
+    private static final String SUPER_ON_CREATE_CALL = "super.onCreate()";
+    public static final CodeBlock CODEBLOCK_RETURN_BUILDER = CodeBlock.of("$L", "return builder");
 
     private Types types;
     private Elements elements;
     private final BindingGraph.Factory bindingGraphFactory;
     private final ComponentDescriptor.Factory componentDescriptorFactory;
 
-    public ApplicationGenerator(Filer filer, Types types, Elements elements, BindingGraph.Factory bindingGraphFactory, ComponentDescriptor.Factory componentDescriptorFactory) {
+    ApplicationGenerator(Filer filer, Types types, Elements elements, BindingGraph.Factory bindingGraphFactory, ComponentDescriptor.Factory componentDescriptorFactory) {
         super(filer, elements);
         this.types = types;
         this.elements = elements;
@@ -31,7 +32,7 @@ public ApplicationGenerator(Filer filer, Types types, Elements elements, Binding
 
     @Override
     ClassName nameGeneratedType(DI input) {
-        return ClassName.get(input.getAppClass()).topLevelClassName().peerClass("DaggerApplication");
+        return ClassName.get(input.getAppClass()).topLevelClassName().peerClass(Util.SIMPKE_NAME_INJECTOR_APPLICATION);
     }
 
     @Override
@@ -42,22 +43,21 @@ ClassName nameGeneratedType(DI input) {
     @Override
     Optional<TypeSpec.Builder> write(ClassName generatedTypeName, DI di) {
         final TypeSpec.Builder builder = TypeSpec.classBuilder(generatedTypeName);
-        TypeName superclass = ClassName.bestGuess("android.app.Application");
+        TypeName superclass = TYPENAME_ANDROID_APPLICATION;
         builder.addModifiers(Modifier.PUBLIC).superclass(superclass);
-        builder.addSuperinterface(ClassName.bestGuess("injector.InjectorSpec"));
+        builder.addSuperinterface(TYPENAME_INJECTOR_SPEC);
         final Set<TypeElement> components = di.getComponents();
 
-        final ClassName injectorType = ClassName.bestGuess("injector.Injector");
-        builder.addField(injectorType, "injector", Modifier.PRIVATE);
+        builder.addField(TYPENAME_INJECTOR, FIELDNAME_INJECTOR, Modifier.PRIVATE);
 
         for (TypeElement component : components) {
             final SpecComponentInfo componentInfo = ComponentInfo.forSpec(component, componentDescriptorFactory, bindingGraphFactory);
             final List<MethodSpec.Builder> methodBuilders = componentInfo.getMethods();
             for (MethodSpec.Builder methodBuilder : methodBuilders) {
                 List<CodeBlock> blocks = new ArrayList<>();
-                blocks.add(CodeBlock.of("$L", "return builder"));
-                final CodeBlock collect = blocks.stream().collect(CodeBlocks.joiningCodeBlocks("\n"));
-                methodBuilder.addStatement("$L", collect);
+                blocks.add(CODEBLOCK_RETURN_BUILDER);
+                final CodeBlock codeBlocks = blocks.stream().collect(CodeBlocks.joiningCodeBlocks("\n"));
+                methodBuilder.addStatement("$L", codeBlocks);
                 final MethodSpec build = methodBuilder.build();
                 builder.addMethod(build);
             }
@@ -66,15 +66,15 @@ ClassName nameGeneratedType(DI input) {
         final Optional<ExecutableElement> onCreateMethod = findOnCreateMethod(di.getAppClass());
         if (onCreateMethod.isPresent()) {
             final MethodSpec.Builder overriding = MethodSpec.overriding(onCreateMethod.get());
-            overriding.addStatement("this.injector = new $T(this)", injectorType);
-            overriding.addStatement("super.onCreate()");
+            overriding.addStatement("this.$L = new $T(this)", FIELDNAME_INJECTOR, TYPENAME_INJECTOR);
+            overriding.addStatement(SUPER_ON_CREATE_CALL);
             builder.addMethod(overriding.build());
         }
 
-        builder.addMethod(MethodSpec.methodBuilder("getInjector")
+        builder.addMethod(MethodSpec.methodBuilder(METHOD_NAME_GET_INJECTOR)
                 .addModifiers(Modifier.PUBLIC)
-                .returns(injectorType)
-                .addStatement("return this.injector")
+                .returns(TYPENAME_INJECTOR)
+                .addStatement(String.format("return this.%s", FIELDNAME_INJECTOR))
                 .build());
 
         return Optional.ofNullable(builder);
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentInfo.java b/compiler/src/main/java/dagger/internal/codegen/ComponentInfo.java
index 477766118..5dccd9f8b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentInfo.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentInfo.java
@@ -41,9 +41,9 @@ private static TriggerComponentInfo createTriggerComponentInfo(TypeElement compo
                                                          BindingGraph.Factory bindingGraphFactory) {
         final ComponentDescriptor descriptor = componentDescriptorFactory.forComponent(component);
         final BindingGraph bindingGraph = bindingGraphFactory.create(descriptor);
-        final TriggerComponentInfo componentInfo = new TriggerComponentInfo(component, descriptor, bindingGraph, bindingGraphFactory);
+        final TriggerComponentInfo componentInfo = new TriggerComponentInfo(component, descriptor, bindingGraph);
         for (BindingGraph subGraph : bindingGraph.subgraphs()) {
-            componentInfo.add(new TriggerComponentInfo(subGraph.componentType(), subGraph.componentDescriptor(), subGraph, bindingGraphFactory));
+            componentInfo.add(new TriggerComponentInfo(subGraph.componentType(), subGraph.componentDescriptor(), subGraph));
             createTriggerSubcomponentInfo(subGraph, componentInfo, bindingGraphFactory);
         }
         return componentInfo;
@@ -53,7 +53,7 @@ private static void createTriggerSubcomponentInfo(BindingGraph bindingGraph, Com
         for (BindingGraph subGraph : bindingGraph.subgraphs()) {
             ComponentDescriptor subcomponentDescriptor = subGraph.componentDescriptor();
             final ComponentInfo componentInfo =
-                    new TriggerComponentInfo(subcomponentDescriptor.componentDefinitionType(), subcomponentDescriptor, subGraph, factory);
+                    new TriggerComponentInfo(subcomponentDescriptor.componentDefinitionType(), subcomponentDescriptor, subGraph);
             componentMethodOverrider.add(componentInfo);
             createTriggerSubcomponentInfo(subGraph, componentInfo, factory);
         }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index 32b1303f3..cbb8a1daf 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -21,17 +21,9 @@
 
 import com.google.auto.common.BasicAnnotationProcessor;
 import com.google.auto.service.AutoService;
-import com.google.common.collect.HashMultimap;
-import com.google.common.collect.HashMultiset;
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.MultimapBuilder;
 import com.google.googlejavaformat.java.filer.FormattingFiler;
-import com.squareup.javapoet.JavaFile;
-import dagger.Component;
-import dagger.Config;
-import dagger.Injector;
 
-import java.lang.annotation.Annotation;
 import java.util.Arrays;
 import java.util.Set;
 import javax.annotation.processing.Filer;
@@ -39,8 +31,6 @@
 import javax.annotation.processing.Processor;
 import javax.annotation.processing.RoundEnvironment;
 import javax.lang.model.SourceVersion;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.TypeElement;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
@@ -55,18 +45,14 @@
  */
 @AutoService(Processor.class)
 public final class ComponentProcessor extends BasicAnnotationProcessor {
-  private InjectBindingRegistry injectBindingRegistry;
-  private FactoryGenerator factoryGenerator;
-  private MembersInjectorGenerator membersInjectorGenerator;
-  private StubGenerator stubGenerator;
+
   private TestRegistry testRegistry = new TestRegistry();
-  private MultipleSourceFileGenerator<ProvisionBinding> multipleGenerator;
-  private ComponentDescriptor.Factory componentDescriptorFactory;
-  private Types types;
-  private Elements elements;
+
   private Filer filer;
   private Messager messager;
-  private BindingGraph.Factory bindingGraphFactory;
+  private MultipleSourceFileGenerator multipleGenerator;
+  private InjectBindingRegistry injectBindingRegistry;
+  private MembersInjectorGenerator membersInjectorGenerator;
 
   @Override
   public SourceVersion getSupportedSourceVersion() {
@@ -81,8 +67,8 @@ public SourceVersion getSupportedSourceVersion() {
   @Override
   protected Iterable<? extends ProcessingStep> initSteps() {
     messager = processingEnv.getMessager();
-    types = processingEnv.getTypeUtils();
-    elements = processingEnv.getElementUtils();
+    Types types = processingEnv.getTypeUtils();
+    Elements elements = processingEnv.getElementUtils();
     filer = new FormattingFiler(processingEnv.getFiler());
     CompilerOptions compilerOptions = CompilerOptions.create(processingEnv, elements);
 
@@ -149,13 +135,10 @@ public SourceVersion getSupportedSourceVersion() {
             elements, types, moduleValidator, subcomponentValidator, builderValidator);
     MapKeyValidator mapKeyValidator = new MapKeyValidator();
 
-    this.stubGenerator =
-            new StubGenerator(filer, elements, types);
-    this.factoryGenerator =
-        new FactoryGenerator(filer, elements, compilerOptions, injectValidatorWhenGeneratingCode);
-    this.multipleGenerator = new MultipleSourceFileGenerator<>(filer, elements, Arrays.asList(this.stubGenerator, this.factoryGenerator));
-    this.membersInjectorGenerator =
-        new MembersInjectorGenerator(filer, elements, injectValidatorWhenGeneratingCode);
+    StubGenerator stubGenerator = new StubGenerator(filer, elements, types);
+    FactoryGenerator factoryGenerator = new FactoryGenerator(filer, elements, compilerOptions, injectValidatorWhenGeneratingCode);
+    multipleGenerator = new MultipleSourceFileGenerator<>(filer, elements, Arrays.asList(stubGenerator, factoryGenerator));
+    membersInjectorGenerator = new MembersInjectorGenerator(filer, elements, injectValidatorWhenGeneratingCode);
     ComponentGenerator componentGenerator =
         new ComponentGenerator(filer, elements, types, keyFactory, compilerOptions);
     ProducerFactoryGenerator producerFactoryGenerator =
@@ -184,11 +167,10 @@ public SourceVersion getSupportedSourceVersion() {
     OptionalBindingDeclaration.Factory optionalBindingDeclarationFactory =
         new OptionalBindingDeclaration.Factory(keyFactory);
 
-    this.injectBindingRegistry =
-        new InjectBindingRegistry(
-                elements,
-                types,
-                messager,
+    injectBindingRegistry = new InjectBindingRegistry(
+            elements,
+            types,
+            messager,
             injectValidator,
             keyFactory,
             provisionBindingFactory,
@@ -205,15 +187,15 @@ public SourceVersion getSupportedSourceVersion() {
             subcomponentDeclarationFactory,
             optionalBindingDeclarationFactory);
 
-    componentDescriptorFactory = new ComponentDescriptor.Factory(
+    ComponentDescriptor.Factory componentDescriptorFactory = new ComponentDescriptor.Factory(
             elements, types, dependencyRequestFactory, moduleDescriptorFactory);
 
-    bindingGraphFactory = new BindingGraph.Factory(
+    BindingGraph.Factory bindingGraphFactory = new BindingGraph.Factory(
             elements,
-        injectBindingRegistry,
-        keyFactory,
-        provisionBindingFactory,
-        productionBindingFactory);
+            injectBindingRegistry,
+            keyFactory,
+            provisionBindingFactory,
+            productionBindingFactory);
 
     AnnotationCreatorGenerator annotationCreatorGenerator =
         new AnnotationCreatorGenerator(filer, elements);
@@ -267,7 +249,7 @@ public SourceVersion getSupportedSourceVersion() {
                 messager,
             moduleValidator,
             provisionBindingFactory,
-            this.multipleGenerator,
+            multipleGenerator,
             productionBindingFactory,
             producerFactoryGenerator),
         new ComponentProcessingStep(
@@ -286,7 +268,7 @@ public SourceVersion getSupportedSourceVersion() {
             new InjectorProcessingStep(
                     types,
                     messager,
-                    new InjectorGenerator(filer, types, elements, componentDescriptorFactory, bindingGraphFactory, new TestClassGenerator(filer, elements), testRegistry, new Decorator.Factory(filer, elements, bindingGraphFactory, testRegistry)),
+                    new InjectorGenerator(filer, types, elements, componentDescriptorFactory, bindingGraphFactory, new TestClassGenerator.Factory(filer, elements), testRegistry, new Decorator.Factory(filer, elements, bindingGraphFactory, testRegistry)),
                     ComponentDescriptor.Kind.COMPONENT,
                     bindingGraphFactory,
                     componentDescriptorFactory,
diff --git a/compiler/src/main/java/dagger/internal/codegen/Decorator.java b/compiler/src/main/java/dagger/internal/codegen/Decorator.java
index 9eb60d9eb..9a35fff15 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Decorator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Decorator.java
@@ -1,6 +1,8 @@
 package dagger.internal.codegen;
 
 import java.util.Optional;
+
+import com.google.common.collect.ImmutableSet;
 import com.squareup.javapoet.*;
 
 import javax.annotation.processing.Filer;
@@ -12,15 +14,13 @@
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
-import java.util.Set;
-import java.util.stream.Collector;
-import java.util.stream.Collectors;
 
 public class Decorator  extends SourceFileGenerator<BindingGraph>{
 
     private BindingGraph.Factory factory;
     private ClassName appClass;
     private TestRegistry testRegistry;
+    private boolean hasGenerated = false;
 
     private Decorator(Filer filer, Elements elements, BindingGraph.Factory factory, ClassName appClass, TestRegistry testRegistry) {
         super(filer, elements);
@@ -49,19 +49,25 @@ private ClassName getClassName(BindingGraph input) {
         final TypeSpec.Builder builder = TypeSpec.classBuilder(generatedTypeName)
                 .addModifiers(Modifier.PUBLIC);
 
-        final String daggerBuilderClassName = TriggerComponentInfo.resolveClassName(factory, input.componentDescriptor());
+        final String daggerBuilderClassName = TriggerComponentInfo.resolveBuilderName(factory, input.componentDescriptor());
 
         builder.addField(appClass, "app", Modifier.PRIVATE);
-
         TypeName builderClassName = ClassName.get(input.componentDescriptor().builderSpec().get().builderDefinitionType());
-
-        addDecoratorType(builder, generatedTypeName, daggerBuilderClassName, builderClassName, input);
-
-        return Optional.of(builder);
+        final ImmutableSet<ContributionBinding> delegateRequirements = input.delegateRequirements();
+
+        if (delegateRequirements.isEmpty()) {
+            return Optional.empty();
+        }else {
+            final String componentName = input.componentDescriptor().componentDefinitionType().getSimpleName().toString();
+            addDecoratorType(builder, daggerBuilderClassName, builderClassName, delegateRequirements, componentName);
+            hasGenerated = true;
+            return Optional.of(builder);
+        }
     }
 
     public TypeSpec.Builder getAccessorType(ClassName appClassName, BindingGraph bindingGraph) {
-        ClassName name = this.getAccessorTypeName(appClassName, bindingGraph);
+        final String componentName = bindingGraph.componentDescriptor().componentDefinitionType().getSimpleName().toString();
+        ClassName name = this.getAccessorTypeName(appClassName, componentName);
         final TypeSpec.Builder interfaceBuilder = TypeSpec.interfaceBuilder(name)
                 .addModifiers(Modifier.PUBLIC);
         for (ContributionBinding contributionBinding : bindingGraph.delegateRequirements()) {
@@ -74,7 +80,7 @@ private ClassName getClassName(BindingGraph input) {
         return interfaceBuilder;
     }
 
-    private void addDecoratorType(TypeSpec.Builder builder, ClassName returnType, String className, TypeName builderClassName, BindingGraph bindingGraph) {
+    private void addDecoratorType(TypeSpec.Builder builder, String className, TypeName builderClassName, ImmutableSet<ContributionBinding> delegateRequirements, String componentName) {
 
         builder.addModifiers(Modifier.PUBLIC);
         builder.addMethod(MethodSpec.constructorBuilder()
@@ -87,11 +93,10 @@ private void addDecoratorType(TypeSpec.Builder builder, ClassName returnType, St
         final ClassName name = ClassName.bestGuess(className);
         statements.add(CodeBlock.of("$T impl = ($T) builder;", name, name));
 
-        TypeName interfaceName = this.getAccessorTypeName(appClass, bindingGraph);
-
+        TypeName interfaceName = this.getAccessorTypeName(appClass, componentName);
         builder.addSuperinterface(interfaceName);
 
-        for (ContributionBinding contributionBinding : bindingGraph.delegateRequirements()) {
+        for (ContributionBinding contributionBinding : delegateRequirements) {
             Util.createDelegateFieldAndMethod(interfaceName, builder, contributionBinding, new HashMap<>(1), true);
             final String delegateFieldName = Util.getDelegateFieldName(contributionBinding.key());
             final ClassName delegateTypeName = Util.getDelegateTypeName(contributionBinding.key());
@@ -113,23 +118,27 @@ private void addDecoratorType(TypeSpec.Builder builder, ClassName returnType, St
                 .returns(builderClassName)
                 .build());
 
-
-
     }
 
     @Override
     void generate(BindingGraph input) throws SourceFileGenerationException {
         final ClassName generatedTypeName = getClassName(input);
         final Optional<TypeSpec.Builder> builder = write(generatedTypeName, input);
-        try {
-            testRegistry.addEncodedClass(generatedTypeName, buildJavaFile(generatedTypeName, builder.get()));
-        } catch (IOException e) {
-            throw new IllegalStateException(e);
+        if (builder.isPresent()) {
+            try {
+                testRegistry.addEncodedClass(generatedTypeName, buildJavaFile(generatedTypeName, builder.get()));
+            } catch (IOException e) {
+                throw new IllegalStateException(e);
+            }
         }
     }
 
-    public ClassName getAccessorTypeName(ClassName app, BindingGraph bindingGraph) {
-        return app.nestedClass(bindingGraph.componentDescriptor().componentDefinitionType().getSimpleName() + "Accessor");
+    public ClassName getAccessorTypeName(ClassName app, String componentName) {
+        return app.nestedClass(componentName + "Accessor");
+    }
+
+    public boolean hasBeenGenerated() {
+        return this.hasGenerated;
     }
 
     public static class Factory {
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyInjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/DependencyInjectorGenerator.java
index 01ff7c587..fb1cfdf7d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyInjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyInjectorGenerator.java
@@ -1,28 +1,20 @@
 package dagger.internal.codegen;
 
 import java.util.Optional;
-import com.google.common.collect.ImmutableBiMap;
-import com.google.common.collect.ImmutableSet;
+
 import com.squareup.javapoet.*;
 
 import javax.annotation.processing.Filer;
 import javax.lang.model.element.Element;
-import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
-import java.util.ArrayList;
-import java.util.List;
 
-import static dagger.internal.codegen.AbstractComponentWriter.simpleVariableName;
-import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
+import static dagger.internal.codegen.Util.SIMPKE_NAME_INJECTOR_APPLICATION;
 
-/**
- * Created by Andy on 11.05.2017.
- */
 public class DependencyInjectorGenerator extends SourceFileGenerator<DI> {
 
+    public static final String APP_FIELDNAME = "app";
     private final BindingGraph.Factory bindingGraphFactory;
     private final ComponentDescriptor.Factory componentDescriptorFactory;
 
@@ -34,7 +26,7 @@
 
     @Override
     ClassName nameGeneratedType(DI input) {
-        return ClassName.bestGuess("injector.Injector");
+        return Util.TYPENAME_INJECTOR;
     }
 
     @Override
@@ -45,13 +37,13 @@ ClassName nameGeneratedType(DI input) {
     @Override
     Optional<TypeSpec.Builder> write(ClassName generatedTypeName, DI input) {
         final TypeSpec.Builder builder = TypeSpec.classBuilder(generatedTypeName).addModifiers(Modifier.PUBLIC);
-        final ClassName appType = ClassName.get(input.getAppClass()).topLevelClassName().peerClass("DaggerApplication");
+        final ClassName appType = ClassName.get(input.getAppClass()).topLevelClassName().peerClass(SIMPKE_NAME_INJECTOR_APPLICATION);
         builder.addMethod(MethodSpec.constructorBuilder()
                 .addModifiers(Modifier.PUBLIC)
-                .addParameter(appType, "app")
-                .addStatement("this.app = app")
+                .addParameter(appType, APP_FIELDNAME)
+                .addStatement(String.format("this.%s = %s", APP_FIELDNAME, APP_FIELDNAME))
                 .build());
-        builder.addField(appType, "app", Modifier.PRIVATE);
+        builder.addField(appType, APP_FIELDNAME, Modifier.PRIVATE);
         for (TypeElement typeElement : input.getComponents()) {
             final GeneratorComponentInfo info = ComponentInfo.forGenerator(typeElement, componentDescriptorFactory, bindingGraphFactory);
             info.process(builder);
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencySpecGenerator.java b/compiler/src/main/java/dagger/internal/codegen/DependencySpecGenerator.java
index 4caab7d4b..e8ced1ccd 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencySpecGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencySpecGenerator.java
@@ -1,22 +1,16 @@
 package dagger.internal.codegen;
 
-import com.google.auto.common.MoreTypes;
-import com.google.common.collect.ImmutableBiMap;
-import com.google.common.collect.ImmutableSet;
 import com.squareup.javapoet.*;
-import dagger.Component;
-
 import javax.annotation.processing.Filer;
 import javax.lang.model.element.Element;
-import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.util.Elements;
 import java.util.*;
-import java.util.function.Function;
 import java.util.stream.Collectors;
-
-import static dagger.internal.codegen.AbstractComponentWriter.simpleVariableName;
+import static dagger.internal.codegen.Util.METHOD_NAME_GET_INJECTOR;
+import static dagger.internal.codegen.Util.TYPENAME_INJECTOR;
+import static dagger.internal.codegen.Util.TYPENAME_INJECTOR_SPEC;
 
 public class DependencySpecGenerator extends SourceFileGenerator<Set<TypeElement>> {
 
@@ -31,7 +25,7 @@
 
     @Override
     ClassName nameGeneratedType(Set<TypeElement> input) {
-        return ClassName.bestGuess("injector.InjectorSpec");
+        return TYPENAME_INJECTOR_SPEC;
     }
 
     @Override
@@ -54,9 +48,9 @@ ClassName nameGeneratedType(Set<TypeElement> input) {
             componentInfo.process(builder);
         }
 
-        builder.addMethod(MethodSpec.methodBuilder("getInjector")
+        builder.addMethod(MethodSpec.methodBuilder(METHOD_NAME_GET_INJECTOR)
                 .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)
-                .returns(ClassName.bestGuess("injector.Injector"))
+                .returns(TYPENAME_INJECTOR)
                 .build());
 
         return Optional.of(builder);
diff --git a/compiler/src/main/java/dagger/internal/codegen/GeneratorComponentInfo.java b/compiler/src/main/java/dagger/internal/codegen/GeneratorComponentInfo.java
index c2235b862..0f47293d0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GeneratorComponentInfo.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GeneratorComponentInfo.java
@@ -72,7 +72,6 @@ public void process(TypeSpec.Builder builder) {
                 final String methodName = requirementMethod.method().getSimpleName().toString();
                 if ((requirement.kind() == ComponentRequirement.Kind.MODULE &&
                         hasNotOnlyNoArgConstructor) || requirement.kind() != ComponentRequirement.Kind.MODULE) {
-                    //statementParams.add(CodeBlock.of("$L", simpleVariableName(typeElement)));
                     moduleConstructorStatements.add(CodeBlock.of(".$L($L)",
                             methodName, simpleVariableName(typeElement)));
                 }else if (requirement.kind() == ComponentRequirement.Kind.MODULE && !hasNotOnlyNoArgConstructor) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/InjectorGenerator.java
index 9f68d315f..93c380815 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectorGenerator.java
@@ -1,12 +1,10 @@
 package dagger.internal.codegen;
 
-import com.google.auto.common.MoreTypes;
 import java.util.Optional;
 import com.squareup.javapoet.*;
 
 import javax.annotation.processing.Filer;
 import javax.lang.model.element.*;
-import javax.lang.model.type.DeclaredType;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 import java.io.IOException;
@@ -14,21 +12,22 @@
 
 public class InjectorGenerator extends SourceFileGenerator<DI>{
 
+    public static final String METHOD_NAME_PREFIX = "decorate";
     private Types types;
     private Elements elements;
     private final ComponentDescriptor.Factory componentDescriptorFactory;
     private final BindingGraph.Factory bindingGraphFactory;
-    private TestClassGenerator testClassGenerator;
+    private TestClassGenerator.Factory testClassGeneratorFactory;
     private final TestRegistry registry;
     private Decorator.Factory decoratorFactory;
 
-    InjectorGenerator(Filer filer, Types types, Elements elements, ComponentDescriptor.Factory componentDescriptorFactory, BindingGraph.Factory bindingGraphFactory, TestClassGenerator testClassGenerator, TestRegistry registry, Decorator.Factory decoratorFactory) {
+    InjectorGenerator(Filer filer, Types types, Elements elements, ComponentDescriptor.Factory componentDescriptorFactory, BindingGraph.Factory bindingGraphFactory, TestClassGenerator.Factory testClassGeneratorFactoty, TestRegistry registry, Decorator.Factory decoratorFactory) {
         super(filer, elements);
         this.types = types;
         this.elements = elements;
         this.componentDescriptorFactory = componentDescriptorFactory;
         this.bindingGraphFactory = bindingGraphFactory;
-        this.testClassGenerator = testClassGenerator;
+        this.testClassGeneratorFactory = testClassGeneratorFactoty;
         this.registry = registry;
         this.decoratorFactory = decoratorFactory;
     }
@@ -45,23 +44,11 @@ ClassName nameGeneratedType(DI input) {
 
     @Override
     Optional<TypeSpec.Builder> write(ClassName generatedTypeName, DI input) {
-        final TypeSpec.Builder builder = TypeSpec.classBuilder(generatedTypeName)
-                .addModifiers(Modifier.PUBLIC);
-
+        final TypeSpec.Builder builder = TypeSpec.classBuilder(generatedTypeName).addModifiers(Modifier.PUBLIC);
         final Set<TypeElement> components = input.getComponents();
-
-        builder.superclass(ClassName.get(input.getAppClass()));
-
-        /*final java.util.Optional<ExecutableElement> onCreateMethod = findOnCreateMethod(input.getAppClass());
-        if (!onCreateMethod.isPresent()) {
-            throw new IllegalStateException("onCreate method not found!");
-        }
-        final MethodSpec.Builder overriding = MethodSpec.overriding(onCreateMethod.get());*/
-        createDecoratorClasses(builder, components, input.getAppClass());
-        //overriding.addStatement("super.onCreate()");
-
-        //builder.addMethod(overriding.build());
-
+        final TypeElement appClass = input.getAppClass();
+        builder.superclass(ClassName.get(appClass));
+        createDecoratorClasses(builder, components, appClass);
         for (TypeElement component : components) {
             final TriggerComponentInfo componentInfo =
                     ComponentInfo.forTrigger(component, componentDescriptorFactory, bindingGraphFactory);
@@ -85,20 +72,22 @@ private void createDecoratorClass(TypeSpec.Builder builder, BindingGraph binding
         final Decorator decorator = decoratorFactory.create(testAppClassName);
         try {
             decorator.generate(bindingGraph);
-            final ClassName decoratorName = decorator.nameGeneratedType(bindingGraph);
-            final TypeName accessorName = decorator.getAccessorTypeName(testAppClassName, bindingGraph);
-            final String fieldName = Util.lowerCaseFirstLetter(decoratorName.simpleName());
-            final String methodName = "decorate" + Util.capitalize(fieldName.replaceAll("Decorator$", ""));
-            final FieldSpec.Builder fieldBuilder = FieldSpec.builder(decoratorName, fieldName, Modifier.PRIVATE);
-            fieldBuilder.addAnnotation(AnnotationSpec.builder(ClassName.bestGuess("android.support.annotation.NonNull")).build());
-            final FieldSpec field = fieldBuilder.initializer("new $T(this)", decoratorName).build();
-            builder.addField(field);
-            builder.addMethod(MethodSpec.methodBuilder(methodName)
-                    .addModifiers(Modifier.PUBLIC)
-                    .returns(accessorName)
-                    .addStatement("return this.$L", fieldName)
-                    .build());
-            builder.addType(decorator.getAccessorType(testAppClassName, bindingGraph).build());
+            if (decorator.hasBeenGenerated()) {
+                final ClassName decoratorName = decorator.nameGeneratedType(bindingGraph);
+                final String componentName = bindingGraph.componentDescriptor().componentDefinitionType().getSimpleName().toString();
+                final TypeName accessorName = decorator.getAccessorTypeName(testAppClassName, componentName);
+                final String fieldName = Util.lowerCaseFirstLetter(decoratorName.simpleName());
+                final String methodName =  METHOD_NAME_PREFIX + Util.capitalize(fieldName.replaceAll("Decorator$", ""));
+                final FieldSpec.Builder fieldBuilder = FieldSpec.builder(decoratorName, fieldName, Modifier.PRIVATE);
+                final FieldSpec field = fieldBuilder.initializer("new $T(this)", decoratorName).build();
+                builder.addField(field);
+                builder.addMethod(MethodSpec.methodBuilder(methodName)
+                        .addModifiers(Modifier.PUBLIC)
+                        .returns(accessorName)
+                        .addStatement("return this.$L", fieldName)
+                        .build());
+                builder.addType(decorator.getAccessorType(testAppClassName, bindingGraph).build());
+            }
         } catch (SourceFileGenerationException e) {
             throw new IllegalStateException("Exception while generating decorator: " + e);
         }
@@ -107,31 +96,14 @@ private void createDecoratorClass(TypeSpec.Builder builder, BindingGraph binding
         }
     }
 
-    private java.util.Optional<ExecutableElement> findOnCreateMethod(TypeElement applicationClass) {
-
-        final java.util.Optional<ExecutableElement> onCreateMethod = applicationClass.getEnclosedElements().stream()
-                .filter(e -> e.getKind() == ElementKind.METHOD)
-                .map(e -> (ExecutableElement) e)
-                .filter(e -> e.getSimpleName().toString().equals("onCreate"))
-                .findFirst();
-        if (!onCreateMethod.isPresent()) {
-            final com.google.common.base.Optional<DeclaredType> declaredTypeOptional = MoreTypes.nonObjectSuperclass(types, elements, MoreTypes.asDeclared(applicationClass.asType()));
-            if (declaredTypeOptional.isPresent()) {
-                return findOnCreateMethod(MoreTypes.asTypeElement(declaredTypeOptional.get()));
-            }
-        }
-
-        return onCreateMethod;
-    }
-
     @Override
     void generate(DI input) throws SourceFileGenerationException {
         final Optional<TypeSpec.Builder> builder = write(input.getClassName(), input);
         try {
-            registry.addEncodedClass(input.getClassName(), buildJavaFile(input.getClassName(), builder.get()));
-            final Set<TypeElement> components = input.getComponents();
-            testClassGenerator.setComponents(components);
-            testClassGenerator.setInjector(input.getAppClass());
+            if (builder.isPresent()) {
+                registry.addEncodedClass(input.getClassName(), buildJavaFile(input.getClassName(), builder.get()));
+            }
+            final TestClassGenerator testClassGenerator = testClassGeneratorFactory.create(input.getAppClass());
             testClassGenerator.generate(registry);
         } catch (IOException e) {
             throw new IllegalStateException(e);
diff --git a/compiler/src/main/java/dagger/internal/codegen/SpecComponentInfo.java b/compiler/src/main/java/dagger/internal/codegen/SpecComponentInfo.java
index 3364a07eb..ee9657618 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SpecComponentInfo.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SpecComponentInfo.java
@@ -12,9 +12,6 @@
 
 import static dagger.internal.codegen.AbstractComponentWriter.simpleVariableName;
 
-/**
- * Created by Andy on 12.05.2017.
- */
 public class SpecComponentInfo extends ComponentInfo {
 
     protected SpecComponentInfo(TypeElement component, ComponentDescriptor descriptor, BindingGraph bindingGraph) {
@@ -24,13 +21,12 @@ protected SpecComponentInfo(TypeElement component, ComponentDescriptor descripto
     @Override
     public void process(TypeSpec.Builder builder) {
         super.process(builder);
-
         final MethodSpec.Builder methodBuilder = buildMethod();
         methodBuilder.addModifiers(Modifier.ABSTRACT);
         builder.addMethod(methodBuilder.build());
     }
 
-    protected MethodSpec.Builder buildMethod() {
+    private MethodSpec.Builder buildMethod() {
         final MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder(simpleVariableName(component))
                 .addModifiers(Modifier.PUBLIC);
 
@@ -42,27 +38,6 @@ public void process(TypeSpec.Builder builder) {
 
         parameterSpecs.add(builderParameter);
 
-        if (descriptor.builderSpec().isPresent()) {
-            for (ComponentDescriptor.BuilderRequirementMethod requirementMethod : descriptor.builderSpec().get().requirementMethods()) {
-                final ComponentRequirement requirement = requirementMethod.requirement();
-                final TypeElement typeElement = requirement.typeElement();
-                if ((requirement.kind() == ComponentRequirement.Kind.MODULE && hasNotOnlyNoArgConstructor(typeElement, requirement.autoCreate())) || requirement.kind() != ComponentRequirement.Kind.MODULE) {
-                    //parameterSpecs.add(ParameterSpec.builder(ClassName.get(typeElement), simpleVariableName(typeElement)).build());
-                }
-            }
-        } else {
-            for (ModuleDescriptor moduleDescriptor : descriptor.modules()) {
-                final TypeElement typeElement = moduleDescriptor.moduleElement();
-                if (hasNotOnlyNoArgConstructor(typeElement, autoCreate(typeElement))) {
-                    //parameterSpecs.add(ParameterSpec.builder(ClassName.get(typeElement), simpleVariableName(typeElement)).build());
-                }
-            }
-
-            for (TypeElement typeElement : descriptor.dependencies()) {
-                //parameterSpecs.add(ParameterSpec.builder(ClassName.get(typeElement), simpleVariableName(typeElement)).build());
-            }
-        }
-
         methodBuilder.addParameters(parameterSpecs);
         return methodBuilder;
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/TestClassGenerator.java b/compiler/src/main/java/dagger/internal/codegen/TestClassGenerator.java
index b734cdacf..0a11e2811 100644
--- a/compiler/src/main/java/dagger/internal/codegen/TestClassGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/TestClassGenerator.java
@@ -1,6 +1,5 @@
 package dagger.internal.codegen;
 
-import com.google.auto.common.MoreTypes;
 import java.util.Optional;
 import com.squareup.javapoet.*;
 import dagger.Trigger;
@@ -14,16 +13,14 @@
 import java.util.Set;
 import java.util.UUID;
 
-/**
- * Created by Andy on 07.05.2017.
- */
 public class TestClassGenerator extends SourceFileGenerator<TestRegistry> {
 
-    private Set<TypeElement> components;
-    private TypeElement injector;
+    private final TypeElement injector;
+    private UniqueNameSet uniqueNameSet;
 
-    TestClassGenerator(Filer filer, Elements elements) {
+    TestClassGenerator(Filer filer, Elements elements, TypeElement injector) {
         super(filer, elements);
+        this.injector = injector;
     }
 
     @Override
@@ -38,20 +35,23 @@ ClassName nameGeneratedType(TestRegistry input) {
 
     @Override
     Optional<TypeSpec.Builder> write(ClassName generatedTypeName, TestRegistry input) {
+        uniqueNameSet = new UniqueNameSet();
         final TypeSpec.Builder builder = TypeSpec.classBuilder(generatedTypeName);
         final Iterator<TestRegistry.EncodedClass> it = input.iterator();
-        UniqueNameSet uniqueNameSet = new UniqueNameSet();
         while(it.hasNext()) {
+
             final TestRegistry.EncodedClass encodedClass = it.next();
-            final String randomString = UUID.randomUUID().toString().replace("-", "_");
-            final String randomMethodName = uniqueNameSet.getUniqueName("Method_" + randomString);
-            builder.addMethod(MethodSpec.methodBuilder(randomMethodName)
-                                .addAnnotation(AnnotationSpec.builder(Trigger.class)
-                                    .addMember("value", CodeBlock.of("$S", encodedClass.encoded))
-                                    .addMember("qualifiedName", CodeBlock.of("$S", encodedClass.qualifiedName))
-                                    .build())
-                                .build()
-            );
+            final String randomMethodName = getRandomMethodName();
+            final AnnotationSpec annotation = AnnotationSpec.builder(Trigger.class)
+                    .addMember("value", CodeBlock.of("$S", encodedClass.encoded))
+                    .addMember("qualifiedName", CodeBlock.of("$S", encodedClass.qualifiedName))
+                    .build();
+
+            final MethodSpec method = MethodSpec.methodBuilder(randomMethodName)
+                    .addAnnotation(annotation)
+                    .build();
+
+            builder.addMethod(method);
         }
 
         builder.addAnnotation(AnnotationSpec.builder(Trigger.class)
@@ -62,14 +62,25 @@ ClassName nameGeneratedType(TestRegistry input) {
         return Optional.of(builder);
     }
 
-    public void setComponents(Set<TypeElement> components) {
-        if (components == null) {
-            components = new HashSet<>();
-        }
-        this.components = components;
+    private String getRandomMethodName() {
+        final String randomString = UUID.randomUUID().toString().replace("-", "_");
+        final String randomMethodName = uniqueNameSet.getUniqueName("Method_" + randomString);
+        return randomMethodName;
     }
 
-    public void setInjector(TypeElement injector) {
-        this.injector = injector;
+    public static class Factory {
+
+        private Filer filer;
+        private Elements elements;
+
+        public Factory(Filer filer, Elements elements) {
+            this.filer = filer;
+            this.elements = elements;
+        }
+
+        public TestClassGenerator create(TypeElement injector) {
+            return new TestClassGenerator(filer, elements, injector);
+        }
+
     }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/TriggerComponentInfo.java b/compiler/src/main/java/dagger/internal/codegen/TriggerComponentInfo.java
index c05f4dcbb..3f161ff7e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/TriggerComponentInfo.java
+++ b/compiler/src/main/java/dagger/internal/codegen/TriggerComponentInfo.java
@@ -1,36 +1,34 @@
 package dagger.internal.codegen;
 
 import com.google.common.collect.ImmutableBiMap;
-import com.google.common.collect.ImmutableCollection;
 import com.squareup.javapoet.*;
 
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
 
-import java.util.ArrayList;
-import java.util.List;
-import java.util.stream.Collectors;
-
 import static dagger.internal.codegen.AbstractComponentWriter.simpleVariableName;
-import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
-import static dagger.internal.codegen.Util.bindingSupportsTestDelegate;
-import static dagger.internal.codegen.Util.getDelegateTypeName;
+import static dagger.internal.codegen.Util.lowerCaseFirstLetter;
 
 
 public class TriggerComponentInfo extends ComponentInfo {
 
-    private final BindingGraph.Factory bindingGraphFactory;
+    private BindingGraph bindingGraph;
+    private static final String METHODNAME_DECORATE = "decorate";
 
     protected TriggerComponentInfo(TypeElement typeElement, ComponentDescriptor descriptor,
-                                   BindingGraph bindingGraph, BindingGraph.Factory bindingGraphFactory) {
+                                   BindingGraph bindingGraph) {
         super(typeElement, descriptor, bindingGraph);
-        this.bindingGraphFactory = bindingGraphFactory;
+        this.bindingGraph = bindingGraph;
     }
 
     @Override
     public void process(TypeSpec.Builder builder) {
         super.process(builder);
 
+        if (noActionRequired()) {
+            return;
+        }
+
         final TypeElement component = descriptor.componentDefinitionType();
         String methodName = simpleVariableName(component);
         final MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder(methodName)
@@ -39,94 +37,67 @@ public void process(TypeSpec.Builder builder) {
 
         ClassName builderClassName = getBuilderClassName(component);
         methodBuilder.returns(builderClassName);
-        List<ParameterSpec> parameterSpecs = new ArrayList<>();
-
-        ParameterSpec builderParameter = ParameterSpec.builder(builderClassName, "builder").build();
-
-        parameterSpecs.add(builderParameter);
-
-/*        if(descriptor.builderSpec().isPresent()) {
-            final ComponentDescriptor.BuilderSpec builderSpec = descriptor.builderSpec().get();
-            for (ComponentDescriptor.BuilderRequirementMethod builderRequirementMethod : builderSpec.requirementMethods()) {
-                final ComponentRequirement requirement = builderRequirementMethod.requirement();
-                final TypeElement typeElement = requirement.typeElement();
-                if ((requirement.kind() == ComponentRequirement.Kind.MODULE &&
-                        hasNotOnlyNoArgConstructor(typeElement, requirement.autoCreate())) || requirement.kind() != ComponentRequirement.Kind.MODULE) {
-                    parameterSpecs.add(ParameterSpec.builder(ClassName.get(typeElement), simpleVariableName(typeElement)).build());
-                }
-            }
-        }else {
-            for (ModuleDescriptor moduleDescriptor : descriptor.modules()) {
-                final TypeElement typeElement = moduleDescriptor.moduleElement();
-                if (hasNotOnlyNoArgConstructor(typeElement, autoCreate(typeElement))) {
-                    parameterSpecs.add(ParameterSpec.builder(ClassName.get(typeElement), simpleVariableName(typeElement)).build());
-                }
-            }
-        }*/
-
-        methodBuilder.addParameters(parameterSpecs);
-
-        /*final List<CodeBlock> params = parameterSpecs.stream()
-                .map(parameterSpec -> CodeBlock.of("$L", parameterSpec.name))
-                .collect(Collectors.toList());
-
-        String className = resolveClassName(bindingGraphFactory, descriptor);
-
-        final ClassName name = ClassName.bestGuess(className);
-        methodBuilder.addStatement("$T componentBuilder = ($T) super.$L($L)\n",
-                name, name, methodName, makeParametersCodeBlock(params));
-
-        final String decoratorName = Util.lowerCaseFirstLetter(component.getSimpleName().toString()) + "Decorator";
-
-        methodBuilder.addStatement("this.$L.decorate(componentBuilder)", decoratorName);
-
-        methodBuilder.addStatement("return componentBuilder");*/
+        ParameterSpec builderParameter = this.getBuilderParameterSpec(builderClassName);
+        methodBuilder.addParameter(builderParameter);
+        final String decoratorName = getDecoratorFieldName(component);
+        methodBuilder.addStatement("return this.$L.$L(super.$L(builder))", decoratorName, METHODNAME_DECORATE, methodName);
+        builder.addMethod(methodBuilder.build());
+    }
 
-        final String decoratorName = Util.lowerCaseFirstLetter(component.getSimpleName().toString()) + "Decorator";
+    protected String getDecoratorFieldName(TypeElement component) {
+        return lowerCaseFirstLetter(component.getSimpleName().toString()) + "Decorator";
+    }
 
-        methodBuilder.addStatement("return this.$L.decorate(super.$L(builder))", decoratorName, methodName);
+    protected boolean noActionRequired() {
+        return bindingGraph.delegateRequirements().isEmpty();
+    }
 
-        builder.addMethod(methodBuilder.build());
+    protected ParameterSpec getBuilderParameterSpec(ClassName builderClassName) {
+        return ParameterSpec.builder(builderClassName, "builder").build();
     }
 
-    public static String resolveClassName(BindingGraph.Factory bindingGraphFactory, ComponentDescriptor descriptor) {
+    public static String resolveBuilderName(BindingGraph.Factory bindingGraphFactory, ComponentDescriptor descriptor) {
         if (descriptor.kind() == ComponentDescriptor.Kind.COMPONENT) {
             final ClassName daggerComponentClassName = Util.getDaggerComponentClassName(descriptor.componentDefinitionType());
             return daggerComponentClassName.packageName() + "." + daggerComponentClassName.simpleName() + ".Builder";
         }else if (descriptor.kind() == ComponentDescriptor.Kind.SUBCOMPONENT) {
-            final ComponentDescriptor parentDescriptor = descriptor.getParentDescriptor();
-            final String parentClassName = resolveClassName2(parentDescriptor, bindingGraphFactory);
-            final BindingGraph parentGraph = bindingGraphFactory.create(parentDescriptor);
-            final ImmutableBiMap<ComponentDescriptor, String> subcomponentNamesMap =
-                    new ComponentWriter.UniqueSubcomponentNamesGenerator(parentGraph).generate();
-            final String s = subcomponentNamesMap.get(descriptor);
-            if (s == null) {
-                throw new NullPointerException("s is null | " + subcomponentNamesMap.values().toString() + "|" + descriptor.componentDefinitionType().asType().toString());
-            }
-            return parentClassName + "." + s + "Builder";
+            return resolveSubcomponentBuilderName(bindingGraphFactory, descriptor);
         }else {
-            throw new IllegalStateException("unknown");
+            throw new IllegalStateException(String.format("Unknown component kind: %s", descriptor.kind()));
         }
     }
 
-    public static String resolveClassName2(ComponentDescriptor descriptor, BindingGraph.Factory bindingGraphFactory) {
+    protected static String resolveSubcomponentBuilderName(BindingGraph.Factory bindingGraphFactory, ComponentDescriptor descriptor) {
+        final ComponentDescriptor parentDescriptor = descriptor.getParentDescriptor();
+        final String parentClassName = internalResolveClassName(parentDescriptor, bindingGraphFactory);
+        final BindingGraph parentGraph = bindingGraphFactory.create(parentDescriptor);
+        final ImmutableBiMap<ComponentDescriptor, String> subcomponentNamesMap =
+                new ComponentWriter.UniqueSubcomponentNamesGenerator(parentGraph).generate();
+        final String subcomponentName = subcomponentNamesMap.get(descriptor);
+        if (subcomponentName == null) {
+            final String name = descriptor.componentDefinitionType().getQualifiedName().toString();
+            throw new NullPointerException(String.format("Name for Subcomponent '%s' not found", name));
+        }
+        return builderImplString(parentClassName, subcomponentName);
+    }
+
+    private static String internalResolveClassName(ComponentDescriptor descriptor, BindingGraph.Factory bindingGraphFactory) {
         if (descriptor.kind() == ComponentDescriptor.Kind.COMPONENT) {
             final ClassName daggerComponentClassName = Util.getDaggerComponentClassName(descriptor.componentDefinitionType());
-            return daggerComponentClassName.packageName() + "." + daggerComponentClassName.simpleName();
+            return classNameToString(daggerComponentClassName);
         }else if (descriptor.kind() == ComponentDescriptor.Kind.SUBCOMPONENT) {
-            final ComponentDescriptor parentDescriptor = descriptor.getParentDescriptor();
-            final String parentClassName = resolveClassName2(parentDescriptor, bindingGraphFactory);
-            final BindingGraph parentGraph = bindingGraphFactory.create(parentDescriptor);
-            final ImmutableBiMap<ComponentDescriptor, String> subcomponentNamesMap =
-                    new ComponentWriter.UniqueSubcomponentNamesGenerator(parentGraph).generate();
-            final String s = subcomponentNamesMap.get(descriptor);
-            if (s == null) {
-                throw new NullPointerException("s is null | " + subcomponentNamesMap.values().toString() + "|" + descriptor.componentDefinitionType().asType().toString());
-            }
-            return parentClassName + "." + s + "Impl";
+            return resolveSubcomponentBuilderName(bindingGraphFactory, descriptor);
         }else {
-            throw new IllegalStateException("unknown");
+            throw new IllegalStateException(String.format("Unknown component kind: %s", descriptor.kind()));
         }
     }
 
+    private static String builderImplString(String parentClassName, String subcomponentName) {
+        return parentClassName + "." + subcomponentName + "Impl";
+    }
+
+    private static String classNameToString(ClassName daggerComponentClassName) {
+        return daggerComponentClassName.packageName() + "." + daggerComponentClassName.simpleName();
+    }
+
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index e6c0aa855..251351d7c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -724,4 +724,10 @@ public static ClassName getDaggerComponentClassName(Element component) {
         return providingMethods;
     }
 
+    public static final String METHOD_NAME_GET_INJECTOR = "getInjector";
+    public static final ClassName TYPENAME_INJECTOR = ClassName.bestGuess("injector.Injector");
+    public static final String SIMPKE_NAME_INJECTOR_APPLICATION = "DaggerApplication";
+    public static final String FIELDNAME_INJECTOR = "injector";
+    public static final ClassName TYPENAME_INJECTOR_SPEC = ClassName.bestGuess("injector.InjectorSpec");
+    public static final ClassName TYPENAME_ANDROID_APPLICATION = ClassName.bestGuess("android.app.Application");
 }
