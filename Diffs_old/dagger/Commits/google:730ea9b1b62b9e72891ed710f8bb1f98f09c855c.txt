diff --git a/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java b/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java
index 7cad3bd1a..ac0624f83 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java
@@ -33,6 +33,7 @@
 )
 interface MultibindingComponent {
   Map<String, String> map();
+  Map<String, String[]> mapOfArrays();
   Map<String, Provider<String>> mapOfProviders();
   Set<String> mapKeys();
   Collection<String> mapValues();
diff --git a/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java b/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java
index f356850b3..4a7577e76 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java
@@ -46,6 +46,18 @@ static String provideBarKey() {
     return "bar value";
   }
 
+  @Provides(type = MAP)
+  @StringKey("foo")
+  static String[] provideFooArrayValue(double doubleDependency) {
+    return new String[] {"foo1", "foo2"};
+  }
+
+  @Provides(type = MAP)
+  @StringKey("bar")
+  static String[] provideBarArrayValue() {
+    return new String[] {"bar1", "bar2"};
+  }
+
   @Provides(type = SET)
   static int provideFiveToSet() {
     return 5;
diff --git a/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java b/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
index 5e06f848f..1b7e30233 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
@@ -49,6 +49,15 @@
     assertThat(map).containsEntry("bar", "bar value");
   }
 
+  @Test public void mapOfArrays() {
+    Map<String, String[]> map = multibindingComponent.mapOfArrays();
+    assertThat(map).hasSize(2);
+    assertThat(map).containsKey("foo");
+    assertThat(map.get("foo")).asList().containsExactly("foo1", "foo2").inOrder();
+    assertThat(map).containsKey("bar");
+    assertThat(map.get("bar")).asList().containsExactly("bar1", "bar2").inOrder();
+  }
+
   @Test public void mapOfProviders() {
     Map<String, Provider<String>> mapOfProviders = multibindingComponent.mapOfProviders();
     assertThat(mapOfProviders).hasSize(2);
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index fe03c3946..d34225542 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -335,7 +335,7 @@ Key forQualifiedType(Optional<AnnotationMirror> qualifier, TypeMirror type) {
         DeclaredType declaredMapType = MoreTypes.asDeclared(possibleMapKey.type());
         TypeMirror mapValueType = Util.getValueTypeOfMap(declaredMapType);
         if (!MoreTypes.isTypeOf(wrappingClass, mapValueType)) {
-          DeclaredType keyType = Util.getKeyTypeOfMap(declaredMapType);
+          TypeMirror keyType = Util.getKeyTypeOfMap(declaredMapType);
           TypeElement wrappingElement = getClassElement(wrappingClass);
           if (wrappingElement == null) {
             // This target might not be compiled with Producers, so wrappingClass might not have an
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index 65c5a6093..8c1aba399 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -22,7 +22,6 @@
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableSet;
 import dagger.producers.Produced;
-import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import javax.inject.Provider;
@@ -47,31 +46,29 @@
  */
 final class Util {
   /**
-   * Returns the {@code V} type for a {@link Map} type like Map<K, Provider<V>>} if the map
+   * Returns the {@code V} type for a {@link Map} type like {@code Map<K, Provider<V>>} if the map
    * includes such a construction
    */
-  public static DeclaredType getProvidedValueTypeOfMap(DeclaredType mapType) {
+  public static TypeMirror getProvidedValueTypeOfMap(DeclaredType mapType) {
     checkState(MoreTypes.isTypeOf(Map.class, mapType), "%s is not a Map.", mapType);
-    return asDeclared(asDeclared(mapType.getTypeArguments().get(1)).getTypeArguments().get(0));
+    return asDeclared(mapType.getTypeArguments().get(1)).getTypeArguments().get(0);
   }
 
   // TODO(cgruber): Consider an object that holds and exposes the various parts of a Map type.
   /**
    * returns the value type for a {@link Map} type like Map<K, V>}.
    */
-  public static DeclaredType getValueTypeOfMap(DeclaredType mapType) {
+  public static TypeMirror getValueTypeOfMap(DeclaredType mapType) {
     checkState(MoreTypes.isTypeOf(Map.class, mapType), "%s is not a Map.", mapType);
-    List<? extends TypeMirror> mapArgs = mapType.getTypeArguments();
-    return asDeclared(mapArgs.get(1));
+    return mapType.getTypeArguments().get(1);
   }
 
   /**
    * Returns the key type for a {@link Map} type like Map<K, Provider<V>>}
    */
-  public static DeclaredType getKeyTypeOfMap(DeclaredType mapType) {
+  public static TypeMirror getKeyTypeOfMap(DeclaredType mapType) {
     checkState(MoreTypes.isTypeOf(Map.class, mapType), "%s is not a Map.", mapType);
-    List<? extends TypeMirror> mapArgs = mapType.getTypeArguments();
-    return MoreTypes.asDeclared(mapArgs.get(0));
+    return mapType.getTypeArguments().get(0);
   }
 
   /**
