diff --git a/compiler/src/it/functional-tests/pom.xml b/compiler/src/it/functional-tests/pom.xml
index 821b030d1..ed87cc6ef 100644
--- a/compiler/src/it/functional-tests/pom.xml
+++ b/compiler/src/it/functional-tests/pom.xml
@@ -62,6 +62,7 @@ limitations under the License.
           <annotationProcessors>
             <annotationProcessor>dagger.internal.codegen.ComponentProcessor</annotationProcessor>
           </annotationProcessors>
+          <compilerArgument>-Adagger.nullableValidation=ERROR</compilerArgument>
         </configuration>
       </plugin>
       <plugin>
diff --git a/compiler/src/it/functional-tests/src/main/java/test/nullables/NullComponent.java b/compiler/src/it/functional-tests/src/main/java/test/nullables/NullComponent.java
new file mode 100644
index 000000000..a8a572473
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/nullables/NullComponent.java
@@ -0,0 +1,29 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test.nullables;
+
+import javax.inject.Provider;
+
+import dagger.Component;
+
+@Component(modules = NullModule.class)
+interface NullComponent {
+  NullFoo nullFoo();
+  @Nullable String string();
+  Provider<String> stringProvider();
+  Number number();
+  Provider<Number> numberProvider();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/nullables/NullComponentWithDependency.java b/compiler/src/it/functional-tests/src/main/java/test/nullables/NullComponentWithDependency.java
new file mode 100644
index 000000000..05093ed60
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/nullables/NullComponentWithDependency.java
@@ -0,0 +1,28 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test.nullables;
+
+import javax.inject.Provider;
+
+import dagger.Component;
+
+@Component(dependencies = NullComponent.class)
+interface NullComponentWithDependency {
+  @Nullable String string();
+  Provider<String> stringProvider();
+  Number number();
+  Provider<Number> numberProvider();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/nullables/NullFoo.java b/compiler/src/it/functional-tests/src/main/java/test/nullables/NullFoo.java
new file mode 100644
index 000000000..9ed4b5dea
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/nullables/NullFoo.java
@@ -0,0 +1,56 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test.nullables;
+
+import javax.inject.Inject;
+import javax.inject.Provider;
+
+class NullFoo {
+  final String string;
+  final Provider<String> stringProvider;
+  final Number number;
+  final Provider<Number> numberProvider;
+
+  @Inject
+  NullFoo(@Nullable String string,
+      Provider<String> stringProvider,
+      Number number,
+      Provider<Number> numberProvider) {
+    this.string = string;
+    this.stringProvider = stringProvider;
+    this.number = number;
+    this.numberProvider = numberProvider;
+  }
+
+  String methodInjectedString;
+  Provider<String> methodInjectedStringProvider;
+  Number methodInjectedNumber;
+  Provider<Number> methodInjectedNumberProvider;
+  @Inject void inject(@Nullable String string,
+      Provider<String> stringProvider,
+      Number number,
+      Provider<Number> numberProvider) {
+    this.methodInjectedString = string;
+    this.methodInjectedStringProvider = stringProvider;
+    this.methodInjectedNumber = number;
+    this.methodInjectedNumberProvider = numberProvider;
+  }
+
+  @Nullable @Inject String fieldInjectedString;
+  @Inject Provider<String> fieldInjectedStringProvider;
+  @Inject Number fieldInjectedNumber;
+  @Inject Provider<Number> fieldInjectedNumberProvider;
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/nullables/NullModule.java b/compiler/src/it/functional-tests/src/main/java/test/nullables/NullModule.java
new file mode 100644
index 000000000..652d5ebbb
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/nullables/NullModule.java
@@ -0,0 +1,35 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test.nullables;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+class NullModule {
+  Number numberValue = null;
+
+  @Nullable
+  @Provides
+  String provideNullableString() {
+    return null;
+  }
+
+  @Provides
+  Number provideNumber() {
+    return numberValue;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/nullables/Nullable.java b/compiler/src/it/functional-tests/src/main/java/test/nullables/Nullable.java
new file mode 100644
index 000000000..86776406a
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/nullables/Nullable.java
@@ -0,0 +1,3 @@
+package test.nullables;
+
+@interface Nullable {}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/nullables/NullabilityTest.java b/compiler/src/it/functional-tests/src/test/java/test/nullables/NullabilityTest.java
new file mode 100644
index 000000000..5ad9efb7c
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/test/java/test/nullables/NullabilityTest.java
@@ -0,0 +1,110 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test.nullables;
+
+import javax.inject.Provider;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+@RunWith(JUnit4.class)
+public class NullabilityTest {
+  @Test public void testNullability_provides() {
+    NullModule module = new NullModule();
+    NullComponent component = Dagger_NullComponent.builder().nullModule(module).build();
+
+    // Can't construct NullFoo because it depends on Number, and Number was null.
+    try {
+      component.nullFoo();
+      fail();
+    } catch (NullPointerException npe) {
+      assertThat(npe).hasMessage("Cannot return null from a non-@Nullable @Provides method");
+    }
+
+    // set number to non-null so we can create
+    module.numberValue = 1;
+    NullFoo nullFoo = component.nullFoo();
+
+    // Then set it back to null so we can test its providers.
+    module.numberValue = null;
+    validate(true, nullFoo.string, nullFoo.stringProvider, nullFoo.numberProvider);
+    validate(true, nullFoo.methodInjectedString, nullFoo.methodInjectedStringProvider,
+        nullFoo.methodInjectedNumberProvider);
+    validate(true, nullFoo.fieldInjectedString, nullFoo.fieldInjectedStringProvider,
+        nullFoo.fieldInjectedNumberProvider);
+  }
+  
+  @Test public void testNullability_components() {
+    NullComponent nullComponent = new NullComponent() {      
+      @Override public Provider<String> stringProvider() {
+        return new Provider<String>() {
+          @Override public String get() {
+            return null;
+          }
+        };
+      }
+      
+      @Override public String string() {
+        return null;
+      }
+      
+      @Override public Provider<Number> numberProvider() {
+        return new Provider<Number>() {
+          @Override public Number get() {
+            return null;
+          }
+        };
+      }
+      
+      @Override public Number number() {
+        return null;
+      }
+      
+      @Override public NullFoo nullFoo() {
+        return null;
+      }
+    };
+    NullComponentWithDependency component =
+        Dagger_NullComponentWithDependency.builder().nullComponent(nullComponent).build();
+    validate(false, component.string(), component.stringProvider(), component.numberProvider());
+    
+    // Also validate that the component's number() method fails
+    try {
+      component.number();
+      fail();
+    } catch (NullPointerException npe) {
+      assertThat(npe).hasMessage("Cannot return null from a non-@Nullable component method");
+    }
+  }
+
+  private void validate(boolean fromProvides,
+      String string,
+      Provider<String> stringProvider,
+      Provider<Number> numberProvider) {
+    assertThat(string).isNull();
+    assertThat(numberProvider).isNotNull();
+    try {
+      numberProvider.get();
+      fail();
+    } catch(NullPointerException npe) {
+      assertThat(npe).hasMessage("Cannot return null from a non-@Nullable "
+          + (fromProvides ? "@Provides" : "component") + " method");
+    }
+    assertThat(stringProvider.get()).isNull();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index f21f865e5..213811749 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -15,6 +15,8 @@
  */
 package dagger.internal.codegen;
 
+import javax.tools.Diagnostic;
+
 import com.google.auto.common.AnnotationMirrors;
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
@@ -32,6 +34,7 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Ordering;
+import com.google.common.collect.Sets;
 import dagger.Component;
 import dagger.internal.codegen.BindingGraph.ResolvedBindings;
 import dagger.internal.codegen.ContributionBinding.BindingType;
@@ -52,14 +55,13 @@
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.SimpleTypeVisitor6;
 import javax.lang.model.util.Types;
-import javax.tools.Diagnostic;
-
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static com.google.auto.common.MoreTypes.isTypeOf;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
 import static dagger.internal.codegen.ErrorMessages.INDENT;
 import static dagger.internal.codegen.ErrorMessages.MEMBERS_INJECTION_WITH_UNBOUNDED_TYPE;
+import static dagger.internal.codegen.ErrorMessages.NULLABLE_TO_NON_NULLABLE;
 import static dagger.internal.codegen.ErrorMessages.REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_FORMAT;
 import static dagger.internal.codegen.ErrorMessages.REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_OR_PRODUCER_FORMAT;
 import static dagger.internal.codegen.ErrorMessages.REQUIRES_PROVIDER_FORMAT;
@@ -71,7 +73,8 @@
 
   private final Types types;
   private final InjectBindingRegistry injectBindingRegistry;
-  private final ScopeCycleValidation disableInterComponentScopeCycles;
+  private final ValidationType scopeCycleValidationType;
+  private final Diagnostic.Kind nullableValidationType;
   private final ProvisionBindingFormatter provisionBindingFormatter;
   private final ProductionBindingFormatter productionBindingFormatter;
   private final MethodSignatureFormatter methodSignatureFormatter;
@@ -81,7 +84,8 @@
   BindingGraphValidator(
       Types types,
       InjectBindingRegistry injectBindingRegistry,
-      ScopeCycleValidation disableInterComponentScopeCycles,
+      ValidationType scopeCycleValidationType,
+      Diagnostic.Kind nullableValidationType,
       ProvisionBindingFormatter provisionBindingFormatter,
       ProductionBindingFormatter productionBindingFormatter,
       MethodSignatureFormatter methodSignatureFormatter,
@@ -89,7 +93,8 @@
       KeyFormatter keyFormatter) {
     this.types = types;
     this.injectBindingRegistry = injectBindingRegistry;
-    this.disableInterComponentScopeCycles = disableInterComponentScopeCycles;
+    this.scopeCycleValidationType = scopeCycleValidationType;
+    this.nullableValidationType = nullableValidationType;
     this.provisionBindingFormatter = provisionBindingFormatter;
     this.productionBindingFormatter = productionBindingFormatter;
     this.methodSignatureFormatter = methodSignatureFormatter;
@@ -176,6 +181,10 @@ private boolean validateResolvedBinding(
           throw new IllegalArgumentException(
               "contribution binding keys should never have members injection bindings");
         }
+        Set<ContributionBinding> combined = Sets.union(provisionBindings, productionBindings);
+        if (!validateNullability(path, combined, reportBuilder)) {
+          return false;
+        }
         if (!productionBindings.isEmpty() && doesPathRequireProvisionOnly(path)) {
           reportProviderMayNotDependOnProducer(path, reportBuilder);
           return false;
@@ -216,6 +225,40 @@ private boolean validateResolvedBinding(
     return true;
   }
 
+  /** Ensures that if the request isn't nullable, then each contribution is also not nullable. */
+  private boolean validateNullability(Deque<ResolvedRequest> requestPath,
+      Set<ContributionBinding> bindings, Builder<BindingGraph> reportBuilder) {
+    boolean valid = true;
+    DependencyRequest request = requestPath.peek().request();
+    String typeName = TypeNames.forTypeMirror(request.key().type()).toString();
+    if (!request.isNullable()) {
+      for (ContributionBinding binding : bindings) {
+        if (binding.nullableType().isPresent()) {
+          String methodSignature;
+          if (binding instanceof ProvisionBinding) {
+            ProvisionBinding provisionBinding = (ProvisionBinding) binding;
+            methodSignature = provisionBindingFormatter.format(provisionBinding);
+          } else {
+            ProductionBinding productionBinding = (ProductionBinding) binding;
+            methodSignature = productionBindingFormatter.format(productionBinding);
+          }
+          // Note: the method signature will include the @Nullable in it!
+          // TODO(sameb): Sometimes javac doesn't include the Element in its output.
+          // (Maybe this happens if the code was already compiled before this point?)
+          // ... we manually print ouf the request in that case, otherwise the error
+          // message is kind of useless.
+          reportBuilder.addItem(
+              String.format(NULLABLE_TO_NON_NULLABLE, typeName, methodSignature)
+              + "\n at: " + dependencyRequestFormatter.format(request),
+              nullableValidationType,
+              request.requestElement());
+          valid = false;
+        }
+      }
+    }
+    return valid;
+  }
+
   /**
    * Validates a members injection binding, returning false (and reporting the error) if it wasn't
    * valid.
@@ -271,7 +314,7 @@ private void validateDependencyScopes(BindingGraph subject,
     ImmutableSet<TypeElement> scopedDependencies = scopedTypesIn(descriptor.dependencies());
     if (scope.isPresent()) {
       // Dagger 1.x scope compatibility requires this be suppress-able.
-      if (disableInterComponentScopeCycles.diagnosticKind().isPresent()
+      if (scopeCycleValidationType.diagnosticKind().isPresent()
           && isTypeOf(Singleton.class, scope.get().getAnnotationType())) {
         // Singleton is a special-case representing the longest lifetime, and therefore
         // @Singleton components may not depend on scoped components
@@ -280,7 +323,7 @@ private void validateDependencyScopes(BindingGraph subject,
               "This @Singleton component cannot depend on scoped components:\n");
           appendIndentedComponentsList(message, scopedDependencies);
           reportBuilder.addItem(message.toString(),
-              disableInterComponentScopeCycles.diagnosticKind().get(),
+              scopeCycleValidationType.diagnosticKind().get(),
               descriptor.componentDefinitionType(),
               descriptor.componentAnnotation());
         }
@@ -296,7 +339,7 @@ private void validateDependencyScopes(BindingGraph subject,
             descriptor.componentAnnotation());
       } else {
         // Dagger 1.x scope compatibility requires this be suppress-able.
-        if (!disableInterComponentScopeCycles.equals(ScopeCycleValidation.NONE)) {
+        if (!scopeCycleValidationType.equals(ValidationType.NONE)) {
           validateScopeHierarchy(descriptor.componentDefinitionType(),
               descriptor.componentDefinitionType(),
               reportBuilder,
@@ -369,9 +412,9 @@ private void validateScopeHierarchy(TypeElement rootComponent,
         message.append(rootComponent.getQualifiedName());
         message.append(" depends on scoped components in a non-hierarchical scope ordering:\n");
         appendIndentedComponentsList(message, scopedDependencyStack);
-        if (disableInterComponentScopeCycles.diagnosticKind().isPresent()) {
+        if (scopeCycleValidationType.diagnosticKind().isPresent()) {
           reportBuilder.addItem(message.toString(),
-              disableInterComponentScopeCycles.diagnosticKind().get(),
+              scopeCycleValidationType.diagnosticKind().get(),
               rootComponent, getAnnotationMirror(rootComponent, Component.class).get());
         }
         scopedDependencyStack.pop();
@@ -692,30 +735,4 @@ private void traversalHelper(BindingGraph graph, Deque<ResolvedRequest> path,
   abstract static class Traverser {
     abstract boolean visitResolvedRequest(Deque<ResolvedRequest> path);
   }
-
-  /**
-   * {@code -Adagger.disableInterComponentScopeValidation=none} will suppress validation of
-   * scoping relationships between dagger {@code @Component} interfaces. This is a migration
-   * tool to permit easier migration from Dagger 1.x which used {@code @Singleton} for scoped
-   * graphs in any lifetime.
-   *
-   * <p>The value can be (case-insensitively) set to any of {@code ERROR}, {@code WARNING},
-   * or {@code NONE} and defaults to {@code ERROR}.
-   */
-  enum ScopeCycleValidation {
-    ERROR,
-    WARNING,
-    NONE;
-
-    Optional<Diagnostic.Kind> diagnosticKind() {
-      switch (this) {
-        case ERROR:
-          return Optional.of(Diagnostic.Kind.ERROR);
-        case WARNING:
-          return Optional.of(Diagnostic.Kind.WARNING);
-        default:
-          return Optional.absent();
-      }
-    }
-  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index 633c4b320..7792db003 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -79,11 +79,13 @@
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementKindVisitor6;
 import javax.lang.model.util.SimpleAnnotationValueVisitor6;
+import javax.tools.Diagnostic;
 
 import static com.google.auto.common.MoreTypes.asDeclared;
 import static com.google.common.base.CaseFormat.LOWER_CAMEL;
 import static dagger.internal.codegen.Binding.bindingPackageFor;
 import static dagger.internal.codegen.ConfigurationAnnotations.getMapKeys;
+import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD;
 import static dagger.internal.codegen.ProvisionBinding.FactoryCreationStrategy.ENUM_INSTANCE;
 import static dagger.internal.codegen.ProvisionBinding.Kind.PROVISION;
 import static dagger.internal.codegen.ProvisionBinding.Kind.SYNTHETIC_PROVISON;
@@ -106,8 +108,11 @@
  * @since 2.0
  */
 final class ComponentGenerator extends SourceFileGenerator<BindingGraph> {
-  ComponentGenerator(Filer filer) {
+  private final Diagnostic.Kind nullableValidationType;
+
+  ComponentGenerator(Filer filer, Diagnostic.Kind nullableValidationType) {
     super(filer);
+    this.nullableValidationType = nullableValidationType;
   }
 
   @Override
@@ -751,16 +756,47 @@ private Snippet initializeFactoryForBinding(ProvisionBinding binding,
             ClassName.fromClass(InstanceFactory.class),
             TypeNames.forTypeMirror(binding.key().type()));
       case COMPONENT_PROVISION:
-        return Snippet.format(Joiner.on('\n').join(
-          "new %s<%2$s>() {",
-          "  @Override public %2$s get() {",
-          "    return %3$s.%4$s();",
-          "  }",
-          "}"),
-          ClassName.fromClass(Factory.class),
-          TypeNames.forTypeMirror(binding.key().type()),
-          contributionFields.get(dependencyMethodIndex.get(binding.bindingElement())).name(),
-          binding.bindingElement().getSimpleName().toString());
+        if (binding.nullableType().isPresent()
+            || nullableValidationType.equals(Diagnostic.Kind.WARNING)) {
+          Snippet nullableSnippet = binding.nullableType().isPresent()
+              ? Snippet.format("@%s ", TypeNames.forTypeMirror(binding.nullableType().get()))
+              : Snippet.format("");
+          return Snippet.format(Joiner.on('\n').join(
+            "new %s<%2$s>() {",
+            "  %5$s@Override public %2$s get() {",
+            "    return %3$s.%4$s();",
+            "  }",
+            "}"),
+            ClassName.fromClass(Factory.class),
+            TypeNames.forTypeMirror(binding.key().type()),
+            contributionFields.get(dependencyMethodIndex.get(binding.bindingElement())).name(),
+            binding.bindingElement().getSimpleName().toString(),
+            nullableSnippet);
+        } else {
+          // TODO(sameb): This throws a very vague NPE right now.  The stack trace doesn't
+          // help to figure out what the method or return type is.  If we include a string
+          // of the return type or method name in the error message, that can defeat obfuscation.
+          // We can easily include the raw type (no generics) + annotation type (no values),
+          // using .class & String.format -- but that wouldn't be the whole story.
+          // What should we do?
+          StringLiteral failMsg =
+              StringLiteral.forValue(CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD);
+          return Snippet.format(Joiner.on('\n').join(
+            "new %s<%2$s>() {",
+            "  @Override public %2$s get() {",
+            "    %2$s provided = %3$s.%4$s();",
+            "    if (provided == null) {",
+            "      throw new NullPointerException(%5$s);",
+            "    }",
+            "    return provided;",
+            "  }",
+            "}"),
+            ClassName.fromClass(Factory.class),
+            TypeNames.forTypeMirror(binding.key().type()),
+            contributionFields.get(dependencyMethodIndex.get(binding.bindingElement())).name(),
+            binding.bindingElement().getSimpleName().toString(),
+            failMsg);
+        }
       case INJECTION:
       case PROVISION:
         List<Snippet> parameters =
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index 719b32bce..4ec2b3461 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -15,13 +15,16 @@
  */
 package dagger.internal.codegen;
 
+import java.util.EnumSet;
+
+import javax.tools.Diagnostic;
+import java.util.Arrays;
 import com.google.auto.common.BasicAnnotationProcessor;
 import com.google.auto.service.AutoService;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import dagger.Module;
 import dagger.Provides;
-import dagger.internal.codegen.BindingGraphValidator.ScopeCycleValidation;
 import dagger.producers.ProducerModule;
 import dagger.producers.Produces;
 import java.util.Map;
@@ -33,7 +36,6 @@
 import javax.lang.model.SourceVersion;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
-
 import static javax.tools.Diagnostic.Kind.ERROR;
 
 /**
@@ -56,7 +58,7 @@ public SourceVersion getSupportedSourceVersion() {
 
   @Override
   public Set<String> getSupportedOptions() {
-    return ImmutableSet.of(DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY);
+    return ImmutableSet.of(DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY, NULLABLE_VALIDATION_KEY);
   }
 
   @Override
@@ -66,6 +68,9 @@ public SourceVersion getSupportedSourceVersion() {
     Elements elements = processingEnv.getElementUtils();
     Filer filer = processingEnv.getFiler();
 
+    Diagnostic.Kind nullableDiagnosticType =
+        nullableValidationType(processingEnv).diagnosticKind().get();
+
     MethodSignatureFormatter methodSignatureFormatter = new MethodSignatureFormatter(types);
     ProvisionBindingFormatter provisionBindingFormatter =
         new ProvisionBindingFormatter(methodSignatureFormatter);
@@ -90,10 +95,10 @@ public SourceVersion getSupportedSourceVersion() {
     Key.Factory keyFactory = new Key.Factory(types, elements);
 
     FactoryGenerator factoryGenerator =
-        new FactoryGenerator(filer, DependencyRequestMapper.FOR_PROVIDER);
+        new FactoryGenerator(filer, DependencyRequestMapper.FOR_PROVIDER, nullableDiagnosticType);
     MembersInjectorGenerator membersInjectorGenerator =
         new MembersInjectorGenerator(filer, elements, types, DependencyRequestMapper.FOR_PROVIDER);
-    ComponentGenerator componentGenerator = new ComponentGenerator(filer);
+    ComponentGenerator componentGenerator = new ComponentGenerator(filer, nullableDiagnosticType);
     ProducerFactoryGenerator producerFactoryGenerator =
         new ProducerFactoryGenerator(filer, DependencyRequestMapper.FOR_PRODUCER);
 
@@ -121,7 +126,8 @@ public SourceVersion getSupportedSourceVersion() {
     BindingGraphValidator bindingGraphValidator = new BindingGraphValidator(
         types,
         injectBindingRegistry,
-        disableInterComponentScopeValidation(processingEnv),
+        scopeValidationType(processingEnv),
+        nullableDiagnosticType,
         provisionBindingFormatter,
         productionBindingFormatter,
         methodSignatureFormatter,
@@ -180,20 +186,39 @@ protected void postProcess() {
   private static final String DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY =
       "dagger.disableInterComponentScopeValidation";
 
-  private static ScopeCycleValidation disableInterComponentScopeValidation(
-      ProcessingEnvironment processingEnv) {
+  private static final String NULLABLE_VALIDATION_KEY =
+      "dagger.nullableValidation";
+
+  private static ValidationType scopeValidationType(ProcessingEnvironment processingEnv) {
+    return validationTypeFor(processingEnv,
+        DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY,
+        ValidationType.ERROR,
+        EnumSet.allOf(ValidationType.class));
+  }
+
+  private static ValidationType nullableValidationType(ProcessingEnvironment processingEnv) {
+    return validationTypeFor(processingEnv,
+        NULLABLE_VALIDATION_KEY,
+        ValidationType.WARNING, // TODO(sameb): Change the default to ERROR
+        EnumSet.of(ValidationType.ERROR, ValidationType.WARNING));
+  }
+
+  private static ValidationType validationTypeFor(ProcessingEnvironment processingEnv, String key,
+      ValidationType defaultValue, Set<ValidationType> validValues) {
     Map<String, String> options = processingEnv.getOptions();
-    if (options.containsKey(DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY)) {
+    if (options.containsKey(key)) {
       try {
-        return ScopeCycleValidation.valueOf(
-            options.get(DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY).toUpperCase());
+        ValidationType type = ValidationType.valueOf(options.get(key).toUpperCase());
+        if (!validValues.contains(type)) {
+          throw new IllegalArgumentException(); // let handler below print out good msg.
+        }
+        return type;
       } catch (IllegalArgumentException e) {
         processingEnv.getMessager().printMessage(ERROR, "Processor option -A"
-            + DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY
-            + " may only have the values ERROR, WARNING, or NONE (case insensitive) "
-            + " found: " + options.get(DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY));
+            + key + " may only have the values " + validValues
+            + " (case insensitive), found: " + options.get(key));
       }
     }
-    return ScopeCycleValidation.ERROR;
+    return defaultValue;
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
index 30080b211..3821cfd75 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
@@ -15,6 +15,8 @@
  */
 package dagger.internal.codegen;
 
+import javax.lang.model.type.DeclaredType;
+
 import com.google.auto.common.AnnotationMirrors;
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
@@ -44,7 +46,6 @@
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.SimpleTypeVisitor6;
 import javax.lang.model.util.Types;
-
 import static com.google.auto.common.AnnotationMirrors.getAnnotationValue;
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static com.google.common.base.Preconditions.checkNotNull;
@@ -87,6 +88,17 @@
   static ImmutableSet<? extends AnnotationMirror> getMapKeys(Element element) {
     return AnnotationMirrors.getAnnotatedAnnotations(element, MapKey.class);
   }
+  
+  /** Returns the first type that specifies this' nullability, or absent if none. */
+  static Optional<DeclaredType> getNullableType(Element element) {
+    List<? extends AnnotationMirror> mirrors = element.getAnnotationMirrors();
+    for (AnnotationMirror mirror : mirrors) {
+      if (mirror.getAnnotationType().asElement().getSimpleName().toString().equals("Nullable")) {
+        return Optional.of(mirror.getAnnotationType());
+      }
+    }
+    return Optional.absent();
+  }
 
   static ImmutableList<TypeMirror> convertClassArrayToListOfTypes(
       AnnotationMirror annotationMirror, final String elementName) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
index 5fe1b1a06..2a7c617d9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
@@ -22,6 +22,7 @@
 import java.util.EnumSet;
 import java.util.Set;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
@@ -48,6 +49,9 @@ boolean isMultibinding() {
   }
 
   abstract BindingType bindingType();
+  
+  /** Returns the type that specifies this' nullability, absent if not nullable. */
+  abstract Optional<DeclaredType> nullableType();
 
   /**
    * If this is a provision request from an {@code @Provides} or {@code @Produces} method, this will
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
index f75d51f91..bce63acc0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -83,6 +83,9 @@
    * requests, this is the type itself.
    */
   abstract DeclaredType enclosingType();
+  
+  /** Returns true if this request allows null objects. */
+  abstract boolean isNullable();
 
   static final class Factory {
     private final Key.Factory keyFactory;
@@ -120,8 +123,9 @@
     DependencyRequest forImplicitMapBinding(DependencyRequest delegatingRequest, Key delegateKey) {
       checkNotNull(delegatingRequest);
       return new AutoValue_DependencyRequest(Kind.PROVIDER, delegateKey,
-          delegatingRequest.requestElement(), 
-          MoreTypes.asDeclared(delegatingRequest.requestElement().getEnclosingElement().asType()));
+          delegatingRequest.requestElement(),
+          MoreTypes.asDeclared(delegatingRequest.requestElement().getEnclosingElement().asType()),
+          false /* doesn't allow null */);
     }
 
     DependencyRequest forRequiredVariable(VariableElement variableElement) {
@@ -167,7 +171,8 @@ DependencyRequest forComponentProductionMethod(ExecutableElement productionMetho
             keyFactory.forQualifiedType(qualifier,
                 Iterables.getOnlyElement(((DeclaredType) type).getTypeArguments())),
             productionMethod,
-            container);
+            container,
+            false /* doesn't allow null */);
       } else {
         return newDependencyRequest(productionMethod, type, qualifier, container);
       }
@@ -182,26 +187,34 @@ DependencyRequest forComponentMembersInjectionMethod(ExecutableElement membersIn
           keyFactory.forMembersInjectedType(
               Iterables.getOnlyElement(membersInjectionMethod.getParameters()).asType()),
           membersInjectionMethod,
-          MoreTypes.asDeclared(membersInjectionMethod.getEnclosingElement().asType()));
+          MoreTypes.asDeclared(membersInjectionMethod.getEnclosingElement().asType()),
+          false /* doesn't allow null */);
     }
 
     DependencyRequest forMembersInjectedType(DeclaredType type) {
       return new AutoValue_DependencyRequest(Kind.MEMBERS_INJECTOR,
           keyFactory.forMembersInjectedType(type),
           type.asElement(),
-          type);
+          type,
+          false /* doesn't allow null */);
     }
 
     private DependencyRequest newDependencyRequest(Element requestElement,
         TypeMirror type, Optional<AnnotationMirror> qualifier, DeclaredType container) {
       KindAndType kindAndType = extractKindAndType(type);
-      if (kindAndType.kind() == Kind.MEMBERS_INJECTOR) {
+      if (kindAndType.kind().equals(Kind.MEMBERS_INJECTOR)) {
         checkArgument(!qualifier.isPresent());
       }
+      // Only instance types can be non-null -- all other requests are wrapped
+      // inside something (e.g, Provider, Lazy, etc..).
+      // TODO(sameb): should Produced/Producer always require non-nullable?
+      boolean allowsNull = !kindAndType.kind().equals(Kind.INSTANCE)
+          || ConfigurationAnnotations.getNullableType(requestElement).isPresent();
       return new AutoValue_DependencyRequest(kindAndType.kind(),
           keyFactory.forQualifiedType(qualifier, kindAndType.type()),
           requestElement,
-          container);
+          container,
+          allowsNull);
     }
 
     @AutoValue
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index 2a2e91b68..2518beddc 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -202,6 +202,15 @@
   static final String MALFORMED_MODULE_METHOD_FORMAT =
       "Cannot generated a graph because method %s on module %s was malformed";
 
+  static final String NULLABLE_TO_NON_NULLABLE =
+      "%s is not nullable, but is being provided by %s";
+
+  static final String CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD =
+      "Cannot return null from a non-@Nullable component method";
+
+  static final String CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD =
+      "Cannot return null from a non-@Nullable @Provides method";
+
   /**
    * A regular expression to match a small list of specific packages deemed to
    * be unhelpful to display in fully qualified types in error messages.
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index 78bc2dd6f..8a5815a9c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -33,6 +33,7 @@
 import dagger.internal.codegen.writer.MethodWriter;
 import dagger.internal.codegen.writer.ParameterizedTypeName;
 import dagger.internal.codegen.writer.Snippet;
+import dagger.internal.codegen.writer.StringLiteral;
 import dagger.internal.codegen.writer.TypeName;
 import dagger.internal.codegen.writer.TypeNames;
 import dagger.internal.codegen.writer.TypeVariableName;
@@ -47,9 +48,11 @@
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeParameterElement;
 import javax.lang.model.type.TypeMirror;
+import javax.tools.Diagnostic;
 
 import static com.google.common.base.Preconditions.checkState;
 import static dagger.Provides.Type.SET;
+import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD;
 import static dagger.internal.codegen.ProvisionBinding.Kind.PROVISION;
 import static dagger.internal.codegen.SourceFiles.factoryNameForProvisionBinding;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
@@ -68,10 +71,13 @@
  */
 final class FactoryGenerator extends SourceFileGenerator<ProvisionBinding> {
   private final DependencyRequestMapper dependencyRequestMapper;
+  private final Diagnostic.Kind nullableValidationType;
 
-  FactoryGenerator(Filer filer, DependencyRequestMapper dependencyRequestMapper) {
+  FactoryGenerator(Filer filer, DependencyRequestMapper dependencyRequestMapper,
+      Diagnostic.Kind nullableValidationType) {
     super(filer);
     this.dependencyRequestMapper = dependencyRequestMapper;
+    this.nullableValidationType = nullableValidationType;
   }
 
   @Override
@@ -228,10 +234,28 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
             ClassName.fromClass(Collections.class),
             binding.bindingElement().getSimpleName(),
             parametersSnippet);
-      } else {
+      } else if (binding.nullableType().isPresent()
+          || nullableValidationType.equals(Diagnostic.Kind.WARNING)) {
+        if (binding.nullableType().isPresent()) {
+          getMethodWriter.annotate(
+              (ClassName) TypeNames.forTypeMirror(binding.nullableType().get()));
+        }
         getMethodWriter.body().addSnippet("return module.%s(%s);",
             binding.bindingElement().getSimpleName(),
             parametersSnippet);
+      } else {
+        StringLiteral failMsg =
+            StringLiteral.forValue(CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD);
+        getMethodWriter.body().addSnippet(Snippet.format(Joiner.on('\n').join(
+            "%s provided = module.%s(%s);",
+            "if (provided == null) {",
+            "  throw new NullPointerException(%s);",
+            "}",
+            "return provided;"),
+            getMethodWriter.returnType(),
+            binding.bindingElement().getSimpleName(),
+            parametersSnippet,
+            failMsg));
       }
     } else if (binding.memberInjectionRequest().isPresent()) {
       getMethodWriter.body().addSnippet("%1$s instance = new %1$s(%2$s);",
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
index ba3c2e28c..f92bf94c0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
@@ -126,6 +126,7 @@ ProductionBinding forProducesMethod(
           dependencies,
           findBindingPackage(key),
           false,
+          ConfigurationAnnotations.getNullableType(producesMethod),
           Optional.of(MoreTypes.asTypeElement(declaredContainer)),
           kind,
           producesAnnotation.type(),
@@ -143,6 +144,7 @@ ProductionBinding forImplicitMapBinding(DependencyRequest explicitRequest,
           dependencies,
           findBindingPackage(explicitRequest.key()),
           false,
+          Optional.<DeclaredType>absent(),
           Optional.<TypeElement>absent(),
           Kind.FUTURE_PRODUCTION,
           Produces.Type.MAP,
@@ -160,6 +162,7 @@ ProductionBinding forComponentMethod(ExecutableElement componentMethod) {
           ImmutableSet.<DependencyRequest>of(),
           Optional.<String>absent(),
           false,
+          Optional.<DeclaredType>absent(),
           Optional.<TypeElement>absent(),
           Kind.COMPONENT_PRODUCTION,
           Produces.Type.UNIQUE,
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index 2d3bbc903..f63eb1422 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -204,6 +204,7 @@ ProvisionBinding forInjectConstructor(ExecutableElement constructorElement,
           dependencies,
           findBindingPackage(key),
           hasNonDefaultTypeParameters(bindingTypeElement, key.type(), types),
+          Optional.<DeclaredType>absent(),
           Optional.<TypeElement>absent(),
           Kind.INJECTION,
           Provides.Type.UNIQUE,
@@ -251,6 +252,7 @@ ProvisionBinding forProvidesMethod(ExecutableElement providesMethod, TypeMirror
           dependencies,
           findBindingPackage(key),
           false /* no non-default parameter types */,
+          ConfigurationAnnotations.getNullableType(providesMethod),
           Optional.of(MoreTypes.asTypeElement(declaredContainer)),
           Kind.PROVISION,
           providesAnnotation.type(),
@@ -270,6 +272,7 @@ ProvisionBinding forImplicitMapBinding(DependencyRequest explicitRequest,
           dependencies,
           findBindingPackage(explicitRequest.key()),
           false /* no non-default parameter types */,
+          Optional.<DeclaredType>absent(),
           Optional.<TypeElement>absent(),
           Kind.SYNTHETIC_PROVISON,
           Provides.Type.MAP,
@@ -285,6 +288,7 @@ ProvisionBinding forComponent(TypeElement componentDefinitionType) {
           ImmutableSet.<DependencyRequest>of(),
           Optional.<String>absent(),
           false /* no non-default parameter types */,
+          Optional.<DeclaredType>absent(),
           Optional.<TypeElement>absent(),
           Kind.COMPONENT,
           Provides.Type.UNIQUE,
@@ -303,6 +307,7 @@ ProvisionBinding forComponentMethod(ExecutableElement componentMethod) {
           ImmutableSet.<DependencyRequest>of(),
           Optional.<String>absent(),
           false /* no non-default parameter types */,
+          ConfigurationAnnotations.getNullableType(componentMethod),
           Optional.<TypeElement>absent(),
           Kind.COMPONENT_PROVISION,
           Provides.Type.UNIQUE,
diff --git a/compiler/src/main/java/dagger/internal/codegen/ValidationType.java b/compiler/src/main/java/dagger/internal/codegen/ValidationType.java
new file mode 100644
index 000000000..d60207241
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ValidationType.java
@@ -0,0 +1,40 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package dagger.internal.codegen;
+
+import com.google.common.base.Optional;
+import javax.tools.Diagnostic;
+
+/**
+ * Allows options to control how component process validates things such as scope cycles
+ * or nullability.
+ */
+enum ValidationType {
+  ERROR,
+  WARNING,
+  NONE;
+
+  Optional<Diagnostic.Kind> diagnosticKind() {
+    switch (this) {
+      case ERROR:
+        return Optional.of(Diagnostic.Kind.ERROR);
+      case WARNING:
+        return Optional.of(Diagnostic.Kind.WARNING);
+      default:
+        return Optional.absent();
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/MethodWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/MethodWriter.java
index e44a65f90..7831fe816 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/MethodWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/MethodWriter.java
@@ -49,6 +49,10 @@ public String name() {
     return name;
   }
   
+  public TypeName returnType() {
+    return returnType;
+  }
+  
   public void addTypeParameter(TypeVariableName typeVariableName) {
     this.typeParameters.add(typeVariableName);
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/Modifiable.java b/compiler/src/main/java/dagger/internal/codegen/writer/Modifiable.java
index 0462bde1a..bb4c6ffd9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/Modifiable.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/Modifiable.java
@@ -42,12 +42,16 @@ public void addModifiers(Iterable<Modifier> modifiers) {
     Iterables.addAll(this.modifiers, modifiers);
   }
 
-  public AnnotationWriter annotate(Class<? extends Annotation> annotation) {
-    AnnotationWriter annotationWriter = new AnnotationWriter(ClassName.fromClass(annotation));
+  public AnnotationWriter annotate(ClassName annotation) {
+    AnnotationWriter annotationWriter = new AnnotationWriter(annotation);
     this.annotations.add(annotationWriter);
     return annotationWriter;
   }
 
+  public AnnotationWriter annotate(Class<? extends Annotation> annotation) {
+    return annotate(ClassName.fromClass(annotation));
+  }
+
   Appendable writeModifiers(Appendable appendable) throws IOException {
     for (Modifier modifier : modifiers) {
       appendable.append(modifier.toString()).append(' ');
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index 290a853f1..787a223a8 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -17,6 +17,7 @@
 
 import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.JavaFileObjects;
+import dagger.internal.codegen.writer.StringLiteral;
 import javax.tools.JavaFileObject;
 import org.junit.Ignore;
 import org.junit.Test;
@@ -30,6 +31,9 @@
 
 @RunWith(JUnit4.class)
 public class ComponentProcessorTest {
+  private static final StringLiteral NPE_LITERAL =
+      StringLiteral.forValue(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD);
+  
   @Test public void componentOnConcreteClass() {
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.NotAComponent",
         "package test;",
@@ -1232,7 +1236,11 @@
         "  private void initialize() {",
         "    this.aProvider = new Factory<A>() {",
         "      @Override public A get() {",
-        "        return aComponent.a();",
+        "        A provided = aComponent.a();",
+        "        if (provided == null) {",
+        "          throw new NullPointerException(" + NPE_LITERAL + ");",
+        "        }",
+        "        return provided;",
         "      }",
         "    };",
         "    this.bProvider = B$$Factory.create(aProvider);",
@@ -1267,6 +1275,7 @@
         "}");
     assertAbout(javaSources())
         .that(ImmutableList.of(aFile, bFile, aComponentFile, bComponentFile))
+        .withCompilerOptions("-Adagger.nullableValidation=ERROR")
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(generatedComponent);
diff --git a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
index df5edf005..f22bea130 100644
--- a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
@@ -27,9 +27,14 @@
 import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.ErrorMessages.NULLABLE_TO_NON_NULLABLE;
 
 @RunWith(JUnit4.class)
 public class GraphValidationTest {
+  private final JavaFileObject NULLABLE = JavaFileObjects.forSourceLines("test.Nullable",
+      "package test;",
+      "public @interface Nullable {}");
+  
   @Test public void componentOnConcreteClass() {
     JavaFileObject component = JavaFileObjects.forSourceLines("test.MyComponent",
         "package test;",
@@ -659,167 +664,165 @@
         .withErrorContaining(expectedMsg);
   }
   
-  @Test public void arrayGenericsRequiresAtProvides() {
-    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
+  @Test public void nullCheckForConstructorParameters() {
+    JavaFileObject a = JavaFileObjects.forSourceLines("test.A",
         "package test;",
         "",
         "import javax.inject.Inject;",
         "",
         "final class A {",
-        "  @Inject A() {}",
+        "  @Inject A(String string) {}",
         "}");
-    JavaFileObject bFile = JavaFileObjects.forSourceLines("test.B",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "import javax.inject.Provider;",
-        "",
-        "final class B<T> {",
-        "  @Inject B(T t) {}",
-        "}");
-    JavaFileObject cFile = JavaFileObjects.forSourceLines("test.C",
+    JavaFileObject module = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
         "",
+        "import dagger.Provides;",
         "import javax.inject.Inject;",
-        "import javax.inject.Provider;",
         "",
-        "final class C {",
-        "  @Inject C(B<Object[]> b) {}",
+        "@dagger.Module",
+        "final class TestModule {",
+        "  @Nullable @Provides String provideString() { return null; }",
         "}");
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestComponent",
         "package test;",
         "",
         "import dagger.Component;",
-        "import dagger.Lazy;",
-        "",
-        "import javax.inject.Provider;",
         "",
-        "@Component",
-        "interface SimpleComponent {",
-        "  C c();",
+        "@Component(modules = TestModule.class)",
+        "interface TestComponent {",
+        "  A a();",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(aFile, bFile, cFile, componentFile))
+    assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, a, module, component))
+        .withCompilerOptions("-Adagger.nullableValidation=ERROR")
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining("test.B<java.lang.Object[]> cannot be provided without"
-            + " an @Provides-annotated method");
+        .withErrorContaining(String.format(NULLABLE_TO_NON_NULLABLE, "java.lang.String",
+            "@test.Nullable @Provides String test.TestModule.provideString()"));
+    
+    // but if we disable the validation, then it compiles fine.
+    assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, a, module, component))
+        .withCompilerOptions("-Adagger.nullableValidation=WARNING")
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError();
   }
   
-  @Test public void rawTypeGenericsRequiresAtProvides() {
-    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
+  @Test public void nullCheckForMembersInjectParam() {
+    JavaFileObject a = JavaFileObjects.forSourceLines("test.A",
         "package test;",
         "",
         "import javax.inject.Inject;",
         "",
         "final class A {",
         "  @Inject A() {}",
+        "  @Inject void register(String string) {}",
         "}");
-    JavaFileObject bFile = JavaFileObjects.forSourceLines("test.B",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "import javax.inject.Provider;",
-        "",
-        "final class B<T> {",
-        "  @Inject B(T t) {}",
-        "}");
-    JavaFileObject cFile = JavaFileObjects.forSourceLines("test.C",
+    JavaFileObject module = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
         "",
+        "import dagger.Provides;",
         "import javax.inject.Inject;",
-        "import javax.inject.Provider;",
         "",
-        "final class C {",
-        "  @Inject C(B b) {}",
+        "@dagger.Module",
+        "final class TestModule {",
+        "  @Nullable @Provides String provideString() { return null; }",
         "}");
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestComponent",
         "package test;",
         "",
         "import dagger.Component;",
-        "import dagger.Lazy;",
         "",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "interface SimpleComponent {",
-        "  C c();",
+        "@Component(modules = TestModule.class)",
+        "interface TestComponent {",
+        "  A a();",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(aFile, bFile, cFile, componentFile))
+    assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, a, module, component))
+        .withCompilerOptions("-Adagger.nullableValidation=ERROR")
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining("test.B cannot be provided without an @Provides-annotated method");
+        .withErrorContaining(String.format(NULLABLE_TO_NON_NULLABLE, "java.lang.String",
+            "@test.Nullable @Provides String test.TestModule.provideString()"));
+    
+    // but if we disable the validation, then it compiles fine.
+    assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, a, module, component))
+        .withCompilerOptions("-Adagger.nullableValidation=WARNING")
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError();
   }
   
-  @Test public void rawTypeMembersInjectFails() {
-    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
+  @Test public void nullCheckForVariable() {
+    JavaFileObject a = JavaFileObjects.forSourceLines("test.A",
         "package test;",
         "",
         "import javax.inject.Inject;",
         "",
         "final class A {",
+        "  @Inject String string;",
         "  @Inject A() {}",
         "}");
-    JavaFileObject bFile = JavaFileObjects.forSourceLines("test.B",
+    JavaFileObject module = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
         "",
+        "import dagger.Provides;",
         "import javax.inject.Inject;",
         "",
-        "final class B<T extends Number> {",
-        "  @Inject A a;",
-        "  B(T t) {}",
+        "@dagger.Module",
+        "final class TestModule {",
+        "  @Nullable @Provides String provideString() { return null; }",
         "}");
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestComponent",
         "package test;",
         "",
         "import dagger.Component;",
-        "import dagger.Lazy;",
         "",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "interface SimpleComponent {",
-        "  void inject(B b);",
+        "@Component(modules = TestModule.class)",
+        "interface TestComponent {",
+        "  A a();",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(aFile, bFile, componentFile))
+    assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, a, module, component))
+        .withCompilerOptions("-Adagger.nullableValidation=ERROR")
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(
-            String.format(ErrorMessages.MEMBERS_INJECTION_WITH_RAW_TYPE, "test.B"));
+        .withErrorContaining(String.format(NULLABLE_TO_NON_NULLABLE, "java.lang.String",
+            "@test.Nullable @Provides String test.TestModule.provideString()"));
+    
+    // but if we disable the validation, then it compiles fine.
+    assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, a, module, component))
+        .withCompilerOptions("-Adagger.nullableValidation=WARNING")
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError();
   }
   
-  @Test public void unboundedMembersInjectionFails() {
-    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
+  @Test public void nullCheckForComponentReturn() {
+    JavaFileObject module = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
         "",
+        "import dagger.Provides;",
         "import javax.inject.Inject;",
         "",
-        "final class A {",
-        "  @Inject A() {}",
-        "}");
-    JavaFileObject bFile = JavaFileObjects.forSourceLines("test.B",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "final class B<T extends Number> {",
-        "  @Inject A a;",
-        "  B(T t) {}",
+        "@dagger.Module",
+        "final class TestModule {",
+        "  @Nullable @Provides String provideString() { return null; }",
         "}");
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestComponent",
         "package test;",
         "",
         "import dagger.Component;",
-        "import dagger.Lazy;",
-        "",
-        "import javax.inject.Provider;",
         "",
-        "@Component",
-        "interface SimpleComponent {",
-        "  void inject(B<? extends Number> b);",
+        "@Component(modules = TestModule.class)",
+        "interface TestComponent {",
+        "  String string();",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(aFile, bFile, componentFile))
+    assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, module, component))    
+        .withCompilerOptions("-Adagger.nullableValidation=ERROR")
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(ErrorMessages.MEMBERS_INJECTION_WITH_UNBOUNDED_TYPE);
+        .withErrorContaining(String.format(NULLABLE_TO_NON_NULLABLE, "java.lang.String",
+            "@test.Nullable @Provides String test.TestModule.provideString()"));
+    
+    // but if we disable the validation, then it compiles fine.
+    assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, module, component))
+        .withCompilerOptions("-Adagger.nullableValidation=WARNING")
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError();
   }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
index 5f1ca10fd..2cb78888f 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
@@ -17,6 +17,7 @@
 
 import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.JavaFileObjects;
+import dagger.internal.codegen.writer.StringLiteral;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -39,6 +40,14 @@
 
 @RunWith(JUnit4.class)
 public class ModuleFactoryGeneratorTest {
+
+  private final JavaFileObject NULLABLE = JavaFileObjects.forSourceLines("test.Nullable",
+      "package test;",
+      "public @interface Nullable {}");
+  
+  private static final StringLiteral NPE_LITERAL =
+      StringLiteral.forValue(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD);
+
   // TODO(gak): add tests for invalid combinations of scope and qualifier annotations like we have
   // for @Inject
 
@@ -362,6 +371,53 @@ private String formatModuleErrorMessage(String msg) {
   }
 
   @Test public void singleProvidesMethodNoArgs() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides String provideString() {",
+        "    return \"\";",
+        "  }",
+        "}");
+    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule$$ProvideStringFactory",
+        "package test;",
+        "",
+        "import dagger.Factory;",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class TestModule$$ProvideStringFactory implements Factory<String> {",
+        "  private final TestModule module;",
+        "",
+        "  public TestModule$$ProvideStringFactory(TestModule module) {",
+        "    assert module != null;",
+        "    this.module = module;",
+        "  }",
+        "",
+        "  @Override public String get() {",
+        "    String provided = module.provideString();",
+        "    if (provided == null) {",
+        "      throw new NullPointerException(" + NPE_LITERAL + ");",
+        "    }",
+        "    return provided;",
+        "  }",
+        "",
+        "  public static Factory<String> create(TestModule module) {",
+        "    return new TestModule$$ProvideStringFactory(module);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .withCompilerOptions("-Adagger.nullableValidation=ERROR")
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(factoryFile);
+  }
+
+  @Test public void singleProvidesMethodNoArgs_disableNullable() {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
         "",
@@ -398,6 +454,50 @@ private String formatModuleErrorMessage(String msg) {
         "  }",
         "}");
     assertAbout(javaSource()).that(moduleFile)
+        .withCompilerOptions("-Adagger.nullableValidation=WARNING")
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(factoryFile);
+  }
+
+  @Test public void nullableProvides() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides @Nullable String provideString() { return null; }",
+        "}");
+    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule$$ProvideStringFactory",
+        "package test;",
+        "",
+        "import dagger.Factory;",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class TestModule$$ProvideStringFactory implements Factory<String> {",
+        "  private final TestModule module;",
+        "",
+        "  public TestModule$$ProvideStringFactory(TestModule module) {",
+        "    assert module != null;",
+        "    this.module = module;",
+        "  }",
+        "",
+        "  @Override",
+        "  @Nullable",
+        "  public String get() {",
+        "    return module.provideString();",
+        "  }",
+        "",
+        "  public static Factory<String> create(TestModule module) {",
+        "    return new TestModule$$ProvideStringFactory(module);",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(moduleFile, NULLABLE))
+        .withCompilerOptions("-Adagger.nullableValidation=ERROR")
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(factoryFile);
@@ -485,7 +585,12 @@ private String formatModuleErrorMessage(String msg) {
         "  }",
         "",
         "  @Override public List<Object> get() {",
-        "    return module.provideObjects(aProvider.get(), bProvider.get(), xMembersInjector);",
+        "    List<Object> provided =",
+        "        module.provideObjects(aProvider.get(), bProvider.get(), xMembersInjector);",
+        "    if (provided == null) {",
+        "      throw new NullPointerException(" + NPE_LITERAL + ");",
+        "    }",
+        "    return provided;",
         "  }",
         "",
         "  public static Factory<List<Object>> create(",
@@ -499,6 +604,7 @@ private String formatModuleErrorMessage(String msg) {
         "}");
     assertAbout(javaSources()).that(
             ImmutableList.of(classXFile, moduleFile, QUALIFIER_A, QUALIFIER_B))
+        .withCompilerOptions("-Adagger.nullableValidation=ERROR")
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(listFactoryFile);
@@ -551,7 +657,7 @@ private String formatModuleErrorMessage(String msg) {
         .and().generatesSources(factoryFile);
   }
 
-  @Test public void proviesSetValues() {
+  @Test public void providesSetValues() {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
         "",
@@ -584,7 +690,11 @@ private String formatModuleErrorMessage(String msg) {
         "  }",
         "",
         "  @Override public Set<String> get() {",
-        "    return module.provideStrings();",
+        "    Set<String> provided = module.provideStrings();",
+        "    if (provided == null) {",
+        "      throw new NullPointerException(" + NPE_LITERAL + ");",
+        "    }",
+        "    return provided;",
         "  }",
         "",
         "  public static Factory<Set<String>> create(TestModule module) {",
@@ -592,6 +702,7 @@ private String formatModuleErrorMessage(String msg) {
         "  }",
         "}");
     assertAbout(javaSource()).that(moduleFile)
+        .withCompilerOptions("-Adagger.nullableValidation=ERROR")
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(factoryFile);
@@ -827,7 +938,11 @@ public void genericSubclassedModule() {
         "", 
         "  @Override", 
         "  public List<B> get() {  ", 
-        "    return module.provideListB(bProvider.get());", 
+        "    List<B> provided = module.provideListB(bProvider.get());",
+        "    if (provided == null) {",
+        "      throw new NullPointerException(" + NPE_LITERAL + ");",
+        "    }",
+        "    return provided;", 
         "  }", 
         "", 
         "  public static <A extends CharSequence, B, C extends Number & Comparable<C>>",
@@ -853,7 +968,11 @@ public void genericSubclassedModule() {
         "",
         "  @Override",
         "  public Number get() {  ",
-        "    return module.provideNumber();",
+        "    Number provided = module.provideNumber();",
+        "    if (provided == null) {",
+        "      throw new NullPointerException(" + NPE_LITERAL + ");",
+        "    }",
+        "    return provided;",
         "  }",
         "",
         "  public static Factory<Number> create(ChildNumberModule module) {",
@@ -879,7 +998,11 @@ public void genericSubclassedModule() {
         "",
         "  @Override",
         "  public Integer get() {  ",
-        "    return module.provideInteger();",
+        "    Integer provided = module.provideInteger();",
+        "    if (provided == null) {",
+        "      throw new NullPointerException(" + NPE_LITERAL + ");",
+        "    }",
+        "    return provided;",
         "  }",
         "",
         "  public static Factory<Integer> create(ChildIntegerModule module) {",
@@ -887,6 +1010,7 @@ public void genericSubclassedModule() {
         "  }",
         "}");
     assertAbout(javaSources()).that(ImmutableList.of(parent, numberChild, integerChild, component))
+        .withCompilerOptions("-Adagger.nullableValidation=ERROR")
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(listBFactory, numberFactory, integerFactory);
