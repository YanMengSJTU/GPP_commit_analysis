diff --git a/compiler/pom.xml b/compiler/pom.xml
index d41306c8d..69839a1e6 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -95,7 +95,7 @@
     <dependency>
       <groupId>com.squareup</groupId>
       <artifactId>javapoet</artifactId>
-      <version>1.4.0</version>
+      <version>1.5.1</version>
     </dependency>
     <dependency>
       <groupId>org.mockito</groupId>
diff --git a/compiler/src/it/functional-tests/src/main/java/test/ParentModule.java b/compiler/src/it/functional-tests/src/main/java/test/ParentModule.java
index a161abaa8..f550f2f21 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/ParentModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/ParentModule.java
@@ -4,6 +4,7 @@
 import dagger.Provides;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.Set;
 
 @Module
 abstract class ParentModule<A extends Number & Comparable<A>, B, C extends Iterable<A>> {
@@ -15,4 +16,14 @@
     }
     return list;
   }
+
+  @Provides static char provideNonGenericBindingInParameterizedModule() {
+    return 'c';
+  }
+
+  @Provides
+  static List<Set<String>> provideStaticGenericTypeWithNoTypeParametersInParameterizedModule() {
+    return new ArrayList<>();
+  }
+
 }
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/MultibindingComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingComponent.java
similarity index 77%
rename from compiler/src/it/producers-functional-tests/src/main/java/producerstest/MultibindingComponent.java
rename to compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingComponent.java
index 3c8ee5823..efbd5a593 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/MultibindingComponent.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingComponent.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2016 Google, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package producerstest;
+package producerstest.multibindings;
 
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.Produced;
@@ -21,8 +21,8 @@
 import dagger.producers.ProductionComponent;
 import java.util.Map;
 import java.util.Set;
-import producerstest.MultibindingProducerModule.PossiblyThrowingMap;
-import producerstest.MultibindingProducerModule.PossiblyThrowingSet;
+import producerstest.multibindings.Qualifiers.PossiblyThrowingMap;
+import producerstest.multibindings.Qualifiers.PossiblyThrowingSet;
 
 @ProductionComponent(modules = MultibindingProducerModule.class)
 interface MultibindingComponent {
@@ -36,11 +36,16 @@
 
   ListenableFuture<Map<Integer, String>> map();
 
-  ListenableFuture<Map<Integer, Producer<String>>> mapOfProducers();
+  ListenableFuture<Map<Integer, Producer<String>>> mapOfProducer();
+
+  ListenableFuture<Map<Integer, Produced<String>>> mapOfProduced();
 
   @PossiblyThrowingMap
   ListenableFuture<Map<Integer, String>> possiblyThrowingMap();
 
   @PossiblyThrowingMap
-  ListenableFuture<Map<Integer, Producer<String>>> possiblyThrowingMapOfProducers();
+  ListenableFuture<Map<Integer, Producer<String>>> possiblyThrowingMapOfProducer();
+
+  @PossiblyThrowingMap
+  ListenableFuture<Map<Integer, Produced<String>>> possiblyThrowingMapOfProduced();
 }
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/MultibindingProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingProducerModule.java
similarity index 72%
rename from compiler/src/it/producers-functional-tests/src/main/java/producerstest/MultibindingProducerModule.java
rename to compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingProducerModule.java
index 780ac7219..dbeefeede 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/MultibindingProducerModule.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingProducerModule.java
@@ -1,19 +1,19 @@
 /*
-* Copyright (C) 2015 Google, Inc.
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-package producerstest;
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.multibindings;
 
 import com.google.common.collect.ImmutableSet;
 import com.google.common.util.concurrent.Futures;
@@ -21,8 +21,9 @@
 import dagger.mapkeys.IntKey;
 import dagger.producers.ProducerModule;
 import dagger.producers.Produces;
+import producerstest.multibindings.Qualifiers.PossiblyThrowingMap;
+import producerstest.multibindings.Qualifiers.PossiblyThrowingSet;
 import java.util.Set;
-import javax.inject.Qualifier;
 
 import static dagger.producers.Produces.Type.MAP;
 import static dagger.producers.Produces.Type.SET;
@@ -30,12 +31,6 @@
 
 @ProducerModule
 final class MultibindingProducerModule {
-  @Qualifier
-  @interface PossiblyThrowingSet {}
-
-  @Qualifier
-  @interface PossiblyThrowingMap {}
-
   @Produces(type = SET)
   static ListenableFuture<String> futureStr() {
     return Futures.immediateFuture("foo");
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/Qualifiers.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/Qualifiers.java
new file mode 100644
index 000000000..1a41b4330
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/Qualifiers.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.multibindings;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.Documented;
+import javax.inject.Qualifier;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+final class Qualifiers {
+  @Documented
+  @Retention(RUNTIME)
+  @Qualifier
+  @interface PossiblyThrowingSet {}
+
+  @Documented
+  @Retention(RUNTIME)
+  @Qualifier
+  @interface PossiblyThrowingMap {}
+
+  private Qualifiers() {}
+}
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/MultibindingTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/multibindings/MultibindingTest.java
similarity index 68%
rename from compiler/src/it/producers-functional-tests/src/test/java/producerstest/MultibindingTest.java
rename to compiler/src/it/producers-functional-tests/src/test/java/producerstest/multibindings/MultibindingTest.java
index 3b189d4d0..15ce7592c 100644
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/MultibindingTest.java
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/multibindings/MultibindingTest.java
@@ -1,19 +1,19 @@
 /*
-* Copyright (C) 2015 Google, Inc.
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-package producerstest;
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.multibindings;
 
 import com.google.common.collect.Iterables;
 import com.google.common.util.concurrent.ListenableFuture;
@@ -89,7 +89,7 @@ public void mapBinding() throws Exception {
   public void mapOfProducerBinding() throws Exception {
     MultibindingComponent multibindingComponent =
         DaggerMultibindingComponent.builder().executor(MoreExecutors.directExecutor()).build();
-    Map<Integer, Producer<String>> map = multibindingComponent.mapOfProducers().get();
+    Map<Integer, Producer<String>> map = multibindingComponent.mapOfProducer().get();
     assertThat(map).hasSize(2);
     assertThat(map).containsKey(15);
     assertThat(map.get(15).get().get()).isEqualTo("fifteen");
@@ -97,6 +97,18 @@ public void mapOfProducerBinding() throws Exception {
     assertThat(map.get(42).get().get()).isEqualTo("forty two");
   }
 
+  @Test
+  public void mapOfProducedBinding() throws Exception {
+    MultibindingComponent multibindingComponent =
+        DaggerMultibindingComponent.builder().executor(MoreExecutors.directExecutor()).build();
+    Map<Integer, Produced<String>> map = multibindingComponent.mapOfProduced().get();
+    assertThat(map).hasSize(2);
+    assertThat(map).containsKey(15);
+    assertThat(map.get(15).get()).isEqualTo("fifteen");
+    assertThat(map).containsKey(42);
+    assertThat(map.get(42).get()).isEqualTo("forty two");
+  }
+
   @Test
   public void mapBindingWithFailures() throws Exception {
     MultibindingComponent multibindingComponent =
@@ -114,7 +126,7 @@ public void mapOfProducerBindingWithFailures() throws Exception {
     MultibindingComponent multibindingComponent =
         DaggerMultibindingComponent.builder().executor(MoreExecutors.directExecutor()).build();
     Map<Integer, Producer<String>> map =
-        multibindingComponent.possiblyThrowingMapOfProducers().get();
+        multibindingComponent.possiblyThrowingMapOfProducer().get();
     assertThat(map).hasSize(2);
     assertThat(map).containsKey(42);
     assertThat(map.get(42).get().get()).isEqualTo("forty two");
@@ -127,4 +139,23 @@ public void mapOfProducerBindingWithFailures() throws Exception {
       assertThat(e.getCause()).hasMessage("monkey");
     }
   }
+
+  @Test
+  public void mapOfProducedBindingWithFailures() throws Exception {
+    MultibindingComponent multibindingComponent =
+        DaggerMultibindingComponent.builder().executor(MoreExecutors.directExecutor()).build();
+    Map<Integer, Produced<String>> map =
+        multibindingComponent.possiblyThrowingMapOfProduced().get();
+    assertThat(map).hasSize(2);
+    assertThat(map).containsKey(42);
+    assertThat(map.get(42).get()).isEqualTo("forty two");
+    assertThat(map).containsKey(15);
+    Produced<String> produced = map.get(15);
+    try {
+      produced.get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).hasMessage("monkey");
+    }
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index e5168ac1b..261e1b270 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -52,6 +52,7 @@
 import dagger.internal.codegen.writer.VoidName;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
+import dagger.producers.internal.MapOfProducedProducer;
 import dagger.producers.internal.MapOfProducerProducer;
 import dagger.producers.internal.MapProducer;
 import dagger.producers.internal.Producers;
@@ -703,7 +704,7 @@ private void addSubcomponents() {
   private void initializeFrameworkTypes() {
     ImmutableList.Builder<Snippet> snippetsBuilder = ImmutableList.builder();
     for (BindingKey bindingKey : graph.resolvedBindings().keySet()) {
-      snippetsBuilder.add(initializeFrameworkType(bindingKey));
+      snippetsBuilder.addAll(initializeFrameworkType(bindingKey).asSet());
     }
     ImmutableList<Snippet> snippets = snippetsBuilder.build();
 
@@ -736,21 +737,21 @@ private void initializeFrameworkTypes() {
    * any place in any order.  By requiring a single snippet (often of concatenated snippets) we
    * ensure that things like local variables always behave as expected by the initialization logic.
    */
-  private Snippet initializeFrameworkType(BindingKey bindingKey) {
+  private Optional<Snippet> initializeFrameworkType(BindingKey bindingKey) {
     ResolvedBindings resolvedBindings = graph.resolvedBindings().get(bindingKey);
 
     // There's no field for inherited bindings.
     if (resolvedBindings.ownedBindings().isEmpty()) {
-      return Snippet.format("");
+      return Optional.absent();
     }
 
     switch (bindingKey.kind()) {
       case CONTRIBUTION:
         switch (resolvedBindings.contributionType()) {
           case SET:
-            return initializeSetMultibindings(resolvedBindings);
+            return Optional.of(initializeSetMultibindings(resolvedBindings));
           case MAP:
-            return initializeMapMultibindings(resolvedBindings);
+            return Optional.of(initializeMapMultibindings(resolvedBindings));
           case UNIQUE:
             return initializeUniqueContributionBinding(resolvedBindings);
           default:
@@ -816,32 +817,33 @@ private Snippet initializeMapMultibindings(ResolvedBindings resolvedBindings) {
     return Snippet.concat(initializationSnippets.build());
   }
 
-  private Snippet initializeUniqueContributionBinding(ResolvedBindings resolvedBindings) {
-    ImmutableList.Builder<Snippet> initializationSnippets = ImmutableList.builder();
-
+  private Optional<Snippet> initializeUniqueContributionBinding(ResolvedBindings resolvedBindings) {
     ContributionBinding binding = getOnlyElement(resolvedBindings.ownedContributionBindings());
-    if (!binding.factoryCreationStrategy().equals(ENUM_INSTANCE) || binding.scope().isPresent()) {
-      initializationSnippets.add(initializeDelegateFactoriesForUninitializedDependencies(binding));
-      initializationSnippets.add(
-          initializeMember(
-              resolvedBindings.bindingKey(), initializeFactoryForContributionBinding(binding)));
+    if (binding.factoryCreationStrategy().equals(ENUM_INSTANCE) && !binding.scope().isPresent()) {
+      return Optional.absent();
     }
 
-    return Snippet.concat(initializationSnippets.build());
+    return Optional.of(
+        Snippet.concat(
+            ImmutableList.of(
+                initializeDelegateFactoriesForUninitializedDependencies(binding),
+                initializeMember(
+                    resolvedBindings.bindingKey(),
+                    initializeFactoryForContributionBinding(binding)))));
   }
 
-  private Snippet initializeMembersInjectionBinding(ResolvedBindings resolvedBindings) {
-    ImmutableList.Builder<Snippet> initializationSnippets = ImmutableList.builder();
-
+  private Optional<Snippet> initializeMembersInjectionBinding(ResolvedBindings resolvedBindings) {
     MembersInjectionBinding binding = resolvedBindings.membersInjectionBinding().get();
-    if (!binding.injectionStrategy().equals(MembersInjectionBinding.Strategy.NO_OP)) {
-      initializationSnippets.add(initializeDelegateFactoriesForUninitializedDependencies(binding));
-      initializationSnippets.add(
-          initializeMember(
-              resolvedBindings.bindingKey(), initializeMembersInjectorForBinding(binding)));
+    if (binding.injectionStrategy().equals(MembersInjectionBinding.Strategy.NO_OP)) {
+      return Optional.absent();
     }
 
-    return Snippet.concat(initializationSnippets.build());
+    return Optional.of(
+        Snippet.concat(
+            ImmutableList.of(
+                initializeDelegateFactoriesForUninitializedDependencies(binding),
+                initializeMember(
+                    resolvedBindings.bindingKey(), initializeMembersInjectorForBinding(binding)))));
   }
 
   /**
@@ -1046,7 +1048,11 @@ private Snippet initializeFactoryForContributionBinding(ContributionBinding bind
         final ClassName contributionClassName;
         switch (binding.bindingType()) {
           case PRODUCTION:
-            contributionClassName = ClassName.fromClass(MapProducer.class);
+            if (MapType.from(binding.key().type()).valuesAreTypeOf(Produced.class)) {
+              contributionClassName = ClassName.fromClass(MapOfProducedProducer.class);
+            } else {
+              contributionClassName = ClassName.fromClass(MapProducer.class);
+            }
             break;
           case PROVISION:
             contributionClassName = ClassName.fromClass(MapFactory.class);
diff --git a/compiler/src/main/java/dagger/internal/codegen/AnnotationSpecs.java b/compiler/src/main/java/dagger/internal/codegen/AnnotationSpecs.java
index db7b9cf2f..d4772f3a5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AnnotationSpecs.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AnnotationSpecs.java
@@ -16,6 +16,8 @@
 package dagger.internal.codegen;
 
 import com.squareup.javapoet.AnnotationSpec;
+import com.squareup.javapoet.ClassName;
+import dagger.Provides;
 
 final class AnnotationSpecs {
 
@@ -26,5 +28,10 @@ private static AnnotationSpec suppressWarnings(String value) {
     return AnnotationSpec.builder(SuppressWarnings.class).addMember("value", "$S", value).build();
   }
 
+  static final AnnotationSpec PROVIDES_SET_VALUES =
+      AnnotationSpec.builder(Provides.class)
+          .addMember("type", "$T.SET_VALUES", ClassName.get(Provides.Type.class))
+          .build();
+
   private AnnotationSpecs() {}
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java b/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java
index 41d6570c0..0bb43f65a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java
+++ b/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java
@@ -19,6 +19,7 @@
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.ParameterSpec;
 import java.util.Iterator;
+import javax.lang.model.type.TypeMirror;
 
 final class CodeBlocks {
 
@@ -43,6 +44,14 @@ static CodeBlock join(Iterable<CodeBlock> codeBlocks, String delimiter) {
     return builder.build();
   }
 
+  static final Function<TypeMirror, CodeBlock> TYPE_MIRROR_TO_CODE_BLOCK =
+      new Function<TypeMirror, CodeBlock>() {
+        @Override
+        public CodeBlock apply(TypeMirror typeMirror) {
+          return CodeBlocks.format("$T", typeMirror);
+        }
+      };
+
   static Function<ParameterSpec, CodeBlock> PARAMETER_NAME =
       new Function<ParameterSpec, CodeBlock>() {
           @Override
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index 000abf14e..5d929868f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -27,6 +27,7 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
 import com.google.common.util.concurrent.ListenableFuture;
+import com.squareup.javapoet.ClassName;
 import dagger.Component;
 import dagger.Lazy;
 import dagger.MembersInjector;
@@ -582,8 +583,9 @@ private ComponentMethodDescriptor getDescriptorForComponentMethod(
      *     processor to retry in a later processing round.
      */
     private ModuleDescriptor descriptorForMonitoringModule(TypeElement componentDefinitionType) {
-      String generatedMonitorModuleName =
-          SourceFiles.generatedMonitoringModuleName(componentDefinitionType).canonicalName();
+      ClassName monitoringModuleName =
+          SourceFiles.generatedMonitoringModuleName(componentDefinitionType);
+      String generatedMonitorModuleName = monitoringModuleName.toString();
       TypeElement monitoringModule = elements.getTypeElement(generatedMonitorModuleName);
       if (monitoringModule == null) {
         throw new TypeNotPresentException(generatedMonitorModuleName, null);
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index b41e4d5d5..8b548c0db 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -30,6 +30,7 @@
 import com.squareup.javapoet.TypeSpec;
 import com.squareup.javapoet.TypeVariableName;
 import dagger.internal.Factory;
+import dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy;
 import java.util.Collections;
 import java.util.List;
 import javax.annotation.processing.Filer;
@@ -48,6 +49,8 @@
 import static dagger.Provides.Type.SET;
 import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_RAWTYPES;
 import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_UNCHECKED;
+import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.ENUM_INSTANCE;
+import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
 import static dagger.internal.codegen.TypeNames.factoryOf;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.ContributionBinding.Kind.PROVISION;
@@ -111,12 +114,16 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
     ImmutableList<TypeVariableName> typeParameters = bindingTypeElementTypeVariableNames(binding);
     ImmutableMap<BindingKey, FrameworkField> fields =
         generateBindingFieldsForDependencies(dependencyRequestMapper, binding);
+    boolean useRawType =
+        binding.factoryCreationStrategy() == ENUM_INSTANCE
+            && binding.bindingKind() == INJECTION
+            && !typeParameters.isEmpty();
     switch (binding.factoryCreationStrategy()) {
       case ENUM_INSTANCE:
         factoryBuilder = enumBuilder(generatedTypeName.simpleName()).addEnumConstant("INSTANCE");
         // If we have type parameters, then remove the parameters from our providedTypeName,
         // since we'll be implementing an erased version of it.
-        if (!typeParameters.isEmpty()) {
+        if (useRawType) {
           factoryBuilder.addAnnotation(SUPPRESS_WARNINGS_RAWTYPES);
           // TODO(ronshapiro): instead of reassigning, introduce an optional/second parameter
           providedTypeName = ((ParameterizedTypeName) providedTypeName).rawType;
@@ -165,15 +172,18 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
         MethodSpec.Builder createMethodBuilder =
             methodBuilder("create")
                 .addModifiers(PUBLIC, STATIC)
-                .addTypeVariables(typeParameters)
                 .returns(parameterizedFactoryName);
+        if (binding.factoryCreationStrategy() != ENUM_INSTANCE
+            || binding.bindingKind() == INJECTION) {
+          createMethodBuilder.addTypeVariables(typeParameters);
+        }
         List<ParameterSpec> params =
             constructorBuilder.isPresent()
                 ? constructorBuilder.get().build().parameters : ImmutableList.<ParameterSpec>of();
         createMethodBuilder.addParameters(params);
         switch (binding.factoryCreationStrategy()) {
           case ENUM_INSTANCE:
-            if (typeParameters.isEmpty()) {
+            if (!useRawType) {
               createMethodBuilder.addStatement("return INSTANCE");
             } else {
               // We use an unsafe cast here because the types are different.
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index 042edc5e9..77a92ed3a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -401,10 +401,39 @@ Key forQualifiedType(Optional<AnnotationMirror> qualifier, TypeMirror type) {
     /**
      * Optionally extract a {@link Key} for the underlying production binding(s) if such a
      * valid key can be inferred from the given key.  Specifically, if the key represents a
-     * {@link Map}{@code <K, V>}, a key of {@code Map<K, Producer<V>>} will be returned.
+     * {@link Map}{@code <K, V>} or {@code Map<K, Produced<V>>}, a key of
+     * {@code Map<K, Producer<V>>} will be returned.
      */
     Optional<Key> implicitMapProducerKeyFrom(Key possibleMapKey) {
-      return maybeWrapMapValue(possibleMapKey, Producer.class);
+      return maybeRewrapMapValue(possibleMapKey, Produced.class, Producer.class)
+          .or(maybeWrapMapValue(possibleMapKey, Producer.class));
+    }
+
+    /**
+     * Returns a key of {@link Map}{@code <K, NewWrappingClass<V>>} if the input key represents a
+     * {@code Map<K, CurrentWrappingClass<V>>}.
+     */
+    private Optional<Key> maybeRewrapMapValue(
+        Key possibleMapKey, Class<?> currentWrappingClass, Class<?> newWrappingClass) {
+      checkArgument(!currentWrappingClass.equals(newWrappingClass));
+      if (MapType.isMap(possibleMapKey.type())) {
+        MapType mapType = MapType.from(possibleMapKey.type());
+        if (mapType.valuesAreTypeOf(currentWrappingClass)) {
+          TypeElement wrappingElement = getClassElement(newWrappingClass);
+          if (wrappingElement == null) {
+            // This target might not be compiled with Producers, so wrappingClass might not have an
+            // associated element.
+            return Optional.absent();
+          }
+          DeclaredType wrappedValueType =
+              types.getDeclaredType(
+                  wrappingElement, mapType.unwrappedValueType(currentWrappingClass));
+          TypeMirror wrappedMapType =
+              types.getDeclaredType(getMapElement(), mapType.keyType(), wrappedValueType);
+          return Optional.of(possibleMapKey.withType(types, wrappedMapType));
+        }
+      }
+      return Optional.absent();
     }
 
     /**
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
index 83c22eb9a..d4539a8f6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
@@ -51,6 +51,9 @@
 import static com.google.auto.common.MoreElements.getPackage;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.collect.Iterables.getOnlyElement;
+import static com.squareup.javapoet.MethodSpec.constructorBuilder;
+import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static com.squareup.javapoet.TypeSpec.classBuilder;
 import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_RAWTYPES;
 import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_UNCHECKED;
 import static dagger.internal.codegen.TypeNames.membersInjectorOf;
@@ -100,7 +103,7 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
 
     ImmutableList<TypeVariableName> typeParameters = bindingTypeElementTypeVariableNames(binding);
     TypeSpec.Builder injectorTypeBuilder =
-        TypeSpec.classBuilder(generatedTypeName.simpleName())
+        classBuilder(generatedTypeName.simpleName())
             .addModifiers(PUBLIC, FINAL)
             .addTypeVariables(typeParameters);
 
@@ -109,7 +112,7 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
     injectorTypeBuilder.addSuperinterface(implementedType);
 
     MethodSpec.Builder injectMembersBuilder =
-        MethodSpec.methodBuilder("injectMembers")
+        methodBuilder("injectMembers")
             .returns(TypeName.VOID)
             .addModifiers(PUBLIC)
             .addAnnotation(Override.class)
@@ -126,13 +129,13 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
 
     ImmutableMap.Builder<BindingKey, FieldSpec> dependencyFieldsBuilder = ImmutableMap.builder();
 
-    MethodSpec.Builder constructorBuilder = MethodSpec.constructorBuilder().addModifiers(PUBLIC);
+    MethodSpec.Builder constructorBuilder = constructorBuilder().addModifiers(PUBLIC);
 
     // We use a static create method so that generated components can avoid having
     // to refer to the generic types of the factory.
     // (Otherwise they may have visibility problems referring to the types.)
     MethodSpec.Builder createMethodBuilder =
-        MethodSpec.methodBuilder("create")
+        methodBuilder("create")
             .returns(implementedType)
             .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
             .addTypeVariables(typeParameters);
@@ -310,7 +313,7 @@ private MethodSpec injectorMethodForSubclasses(
       Element injectionElement,
       ImmutableSet<DependencyRequest> dependencies) {
     MethodSpec.Builder methodBuilder =
-        MethodSpec.methodBuilder(injectionSiteDelegateMethodName(injectionElement))
+        methodBuilder(injectionSiteDelegateMethodName(injectionElement))
             .addModifiers(PUBLIC, STATIC)
             .addParameter(injectedTypeName, "instance")
             .addTypeVariables(typeParameters);
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
index e423f55ee..954b91eeb 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
@@ -40,6 +40,7 @@
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.base.Verify.verify;
 import static dagger.internal.codegen.ConfigurationAnnotations.getModuleIncludes;
 import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
@@ -149,7 +150,11 @@
     }
 
     ModuleDescriptor create(TypeElement moduleElement) {
-      AnnotationMirror moduleAnnotation = getModuleAnnotation(moduleElement).get();
+      Optional<AnnotationMirror> probableModuleAnnotation = getModuleAnnotation(moduleElement);
+      checkState(probableModuleAnnotation.isPresent(),
+          "%s did not have an AnnotationMirror for @Module",
+          moduleElement.getQualifiedName());
+      AnnotationMirror moduleAnnotation = probableModuleAnnotation.get();
 
       ImmutableSet.Builder<ContributionBinding> bindings = ImmutableSet.builder();
       for (ExecutableElement moduleMethod : methodsIn(elements.getAllMembers(moduleElement))) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleGenerator.java
index f5f33af1b..20b45fd53 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleGenerator.java
@@ -17,35 +17,30 @@
 
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableSet;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.FieldSpec;
+import com.squareup.javapoet.TypeSpec;
 import dagger.Module;
 import dagger.Provides;
-import dagger.internal.codegen.writer.ClassName;
-import dagger.internal.codegen.writer.ClassWriter;
-import dagger.internal.codegen.writer.FieldWriter;
-import dagger.internal.codegen.writer.JavaWriter;
-import dagger.internal.codegen.writer.MethodWriter;
-import dagger.internal.codegen.writer.ParameterizedTypeName;
-import dagger.internal.codegen.writer.TypeName;
 import dagger.producers.monitoring.ProductionComponentMonitor;
 import dagger.producers.monitoring.internal.MonitorCache;
 
-import java.util.Set;
-import javax.annotation.Generated;
 import javax.annotation.processing.Filer;
-import javax.inject.Provider;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.util.Elements;
 
+import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static com.squareup.javapoet.TypeSpec.classBuilder;
+import static dagger.internal.codegen.AnnotationSpecs.PROVIDES_SET_VALUES;
+import static dagger.internal.codegen.TypeNames.SET_OF_FACTORIES;
+import static dagger.internal.codegen.TypeNames.providerOf;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.STATIC;
 import static javax.lang.model.element.Modifier.FINAL;
 
 /** Generates a monitoring module for use with production components. */
-final class MonitoringModuleGenerator extends JavaWriterSourceFileGenerator<TypeElement> {
-  private static final TypeName SET_OF_FACTORIES =
-      ParameterizedTypeName.create(
-          Set.class, ClassName.fromClass(ProductionComponentMonitor.Factory.class));
+final class MonitoringModuleGenerator extends JavaPoetSourceFileGenerator<TypeElement> {
 
   MonitoringModuleGenerator(Filer filer, Elements elements) {
     super(filer, elements);
@@ -56,44 +51,41 @@ ClassName nameGeneratedType(TypeElement componentElement) {
     return SourceFiles.generatedMonitoringModuleName(componentElement);
   }
 
-  @Override
-  Iterable<? extends Element> getOriginatingElements(TypeElement componentElement) {
-    return ImmutableSet.of(componentElement);
-  }
-
   @Override
   Optional<? extends Element> getElementForErrorReporting(TypeElement componentElement) {
     return Optional.of(componentElement);
   }
 
   @Override
-  ImmutableSet<JavaWriter> write(ClassName generatedTypeName, TypeElement componentElement) {
-    JavaWriter writer = JavaWriter.inPackage(generatedTypeName.packageName());
-    ClassWriter classWriter = writer.addClass(generatedTypeName.simpleName());
-    classWriter.annotate(Module.class);
-    classWriter.addModifiers(FINAL);
+  Optional<TypeSpec.Builder> write(ClassName generatedTypeName, TypeElement componentElement) {
+    return Optional.of(
+        classBuilder(generatedTypeName.simpleName())
+            .addAnnotation(Module.class)
+            .addModifiers(FINAL)
 
-    // TODO(beder): Replace this default set binding with EmptyCollections when it exists.
-    MethodWriter emptySetBindingMethod =
-        classWriter.addMethod(SET_OF_FACTORIES, "defaultSetOfFactories");
-    emptySetBindingMethod.addModifiers(STATIC);
-    emptySetBindingMethod.annotate(Provides.class).setMember("type", Provides.Type.SET_VALUES);
-    emptySetBindingMethod
-        .body()
-        .addSnippet("return %s.of();", ClassName.fromClass(ImmutableSet.class));
+            // TODO(beder): Replace this default set binding with EmptyCollections when it exists.
+            .addMethod(
+                methodBuilder("defaultSetOfFactories")
+                    .returns(SET_OF_FACTORIES)
+                    .addModifiers(STATIC)
+                    .addAnnotation(PROVIDES_SET_VALUES)
+                    .addStatement("return $T.of()", ClassName.get(ImmutableSet.class))
+                    .build())
 
-    FieldWriter providerField = classWriter.addField(MonitorCache.class, "monitorCache");
-    providerField.addModifiers(PRIVATE, FINAL);
-    providerField.setInitializer("new %s()", ClassName.fromClass(MonitorCache.class));
-    MethodWriter monitorMethod = classWriter.addMethod(ProductionComponentMonitor.class, "monitor");
-    monitorMethod.annotate(Provides.class);
-    monitorMethod.addParameter(
-        ParameterizedTypeName.create(Provider.class, ClassName.fromTypeElement(componentElement)),
-        "component");
-    monitorMethod.addParameter(
-        ParameterizedTypeName.create(Provider.class, SET_OF_FACTORIES), "factories");
-    monitorMethod.body().addSnippet("return monitorCache.monitor(component, factories);");
+            .addField(
+                FieldSpec.builder(MonitorCache.class, "monitorCache", PRIVATE, FINAL)
+                    .initializer("new $T()", MonitorCache.class)
+                    .build())
 
-    return ImmutableSet.of(writer);
+            .addMethod(
+                methodBuilder("monitor")
+                    .returns(ProductionComponentMonitor.class)
+                    .addAnnotation(Provides.class)
+                    .addParameter(
+                        providerOf(ClassName.get(componentElement.asType())),
+                        "component")
+                    .addParameter(providerOf(SET_OF_FACTORIES), "factories")
+                    .addStatement("return monitorCache.monitor(component, factories)")
+                    .build()));
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
index 56cb6d25a..4741ef5b0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -22,39 +22,41 @@
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
-import com.google.common.util.concurrent.AsyncFunction;
-import com.google.common.util.concurrent.Futures;
-import com.google.common.util.concurrent.ListenableFuture;
-import dagger.internal.codegen.writer.ClassName;
-import dagger.internal.codegen.writer.ClassWriter;
-import dagger.internal.codegen.writer.ConstructorWriter;
-import dagger.internal.codegen.writer.FieldWriter;
-import dagger.internal.codegen.writer.JavaWriter;
-import dagger.internal.codegen.writer.MethodWriter;
-import dagger.internal.codegen.writer.ParameterizedTypeName;
-import dagger.internal.codegen.writer.Snippet;
-import dagger.internal.codegen.writer.TypeName;
-import dagger.internal.codegen.writer.TypeNames;
-import dagger.producers.Produced;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.TypeName;
+import com.squareup.javapoet.TypeSpec;
 import dagger.producers.Producer;
 import dagger.producers.Produces;
 import dagger.producers.Produces.Type;
-import dagger.producers.internal.AbstractProducer;
-import dagger.producers.internal.Producers;
 import dagger.producers.monitoring.ProducerMonitor;
-import dagger.producers.monitoring.ProducerToken;
 import java.util.List;
-import java.util.concurrent.Executor;
 import javax.annotation.processing.Filer;
 import javax.lang.model.element.Element;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 
+import static com.squareup.javapoet.ClassName.OBJECT;
+import static com.squareup.javapoet.MethodSpec.constructorBuilder;
+import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static com.squareup.javapoet.TypeSpec.classBuilder;
+import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_UNCHECKED;
+import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
-import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
-import static dagger.internal.codegen.writer.Snippet.makeParametersSnippet;
+import static dagger.internal.codegen.SourceFiles.javapoetGeneratedClassNameForBinding;
+import static dagger.internal.codegen.TypeNames.abstractProducerOf;
+import static dagger.internal.codegen.TypeNames.listOf;
+import static dagger.internal.codegen.TypeNames.listenableFutureOf;
+import static dagger.internal.codegen.TypeNames.ASYNC_FUNCTION;
+import static dagger.internal.codegen.TypeNames.EXECUTOR;
+import static dagger.internal.codegen.TypeNames.FUTURES;
+import static dagger.internal.codegen.TypeNames.IMMUTABLE_SET;
+import static dagger.internal.codegen.TypeNames.PRODUCER_TOKEN;
+import static dagger.internal.codegen.TypeNames.PRODUCERS;
+import static dagger.internal.codegen.TypeNames.VOID_CLASS;
+import static dagger.internal.codegen.TypeNames.producedOf;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PROTECTED;
@@ -67,7 +69,8 @@
  * @author Jesse Beder
  * @since 2.0
  */
-final class ProducerFactoryGenerator extends JavaWriterSourceFileGenerator<ProductionBinding> {
+final class ProducerFactoryGenerator extends JavaPoetSourceFileGenerator<ProductionBinding> {
+
   private final DependencyRequestMapper dependencyRequestMapper;
 
   ProducerFactoryGenerator(
@@ -78,12 +81,7 @@
 
   @Override
   ClassName nameGeneratedType(ProductionBinding binding) {
-    return generatedClassNameForBinding(binding);
-  }
-
-  @Override
-  Iterable<? extends Element> getOriginatingElements(ProductionBinding binding) {
-    return ImmutableSet.of(binding.bindingElement());
+    return javapoetGeneratedClassNameForBinding(binding);
   }
 
   @Override
@@ -92,65 +90,43 @@ ClassName nameGeneratedType(ProductionBinding binding) {
   }
 
   @Override
-  ImmutableSet<JavaWriter> write(ClassName generatedTypeName, ProductionBinding binding) {
+  Optional<TypeSpec.Builder> write(ClassName generatedTypeName, ProductionBinding binding) {
     TypeMirror keyType =
         binding.productionType().equals(Type.MAP)
             ? MapType.from(binding.key().type()).unwrappedValueType(Producer.class)
             : binding.key().type();
-    TypeName providedTypeName = TypeNames.forTypeMirror(keyType);
-    TypeName futureTypeName = ParameterizedTypeName.create(
-        ClassName.fromClass(ListenableFuture.class), providedTypeName);
-    JavaWriter writer = JavaWriter.inPackage(generatedTypeName.packageName());
+    TypeName providedTypeName = TypeName.get(keyType);
+    TypeName futureTypeName = listenableFutureOf(providedTypeName);
 
-    ClassWriter factoryWriter = writer.addClass(generatedTypeName.simpleName());
-    ConstructorWriter constructorWriter = factoryWriter.addConstructor();
-    constructorWriter.addModifiers(PUBLIC);
+    TypeSpec.Builder factoryBuilder =
+        classBuilder(generatedTypeName.simpleName())
+            .addModifiers(PUBLIC, FINAL)
+            .superclass(abstractProducerOf(providedTypeName));
 
     ImmutableMap<BindingKey, FrameworkField> fields =
         SourceFiles.generateBindingFieldsForDependencies(dependencyRequestMapper, binding);
 
-    constructorWriter
-        .body()
-        .addSnippet(
-            "super(%s, %s.create(%s.class));",
-            fields.get(binding.monitorRequest().get().bindingKey()).name(),
-            ClassName.fromClass(ProducerToken.class),
-            factoryWriter.name());
+    MethodSpec.Builder constructorBuilder =
+        constructorBuilder()
+            .addModifiers(PUBLIC)
+            .addStatement(
+                "super($L, $T.create($T.class))",
+                fields.get(binding.monitorRequest().get().bindingKey()).name(),
+                PRODUCER_TOKEN,
+                generatedTypeName);
 
     if (!binding.bindingElement().getModifiers().contains(STATIC)) {
-      factoryWriter.addField(binding.bindingTypeElement(), "module")
-          .addModifiers(PRIVATE, FINAL);
-      constructorWriter.addParameter(binding.bindingTypeElement(), "module");
-      constructorWriter.body()
-          .addSnippet("assert module != null;")
-          .addSnippet("this.module = module;");
+      TypeName moduleType = TypeName.get(binding.bindingTypeElement().asType());
+      addFieldAndConstructorParameter(
+          factoryBuilder, constructorBuilder, "module", moduleType);
     }
 
-    factoryWriter.addField(Executor.class, "executor")
-        .addModifiers(PRIVATE, FINAL);
-    constructorWriter.addParameter(Executor.class, "executor");
-    constructorWriter.body()
-        .addSnippet("assert executor != null;")
-        .addSnippet("this.executor = executor;");
-
-    factoryWriter.addModifiers(PUBLIC);
-    factoryWriter.addModifiers(FINAL);
-    factoryWriter.setSuperclass(
-        ParameterizedTypeName.create(AbstractProducer.class, providedTypeName));
-
-    MethodWriter computeMethodWriter = factoryWriter.addMethod(futureTypeName, "compute");
-    computeMethodWriter.annotate(Override.class);
-    computeMethodWriter.addModifiers(PROTECTED);
-    computeMethodWriter.addParameter(ProducerMonitor.class, "monitor").addModifiers(FINAL);
+    addFieldAndConstructorParameter(factoryBuilder, constructorBuilder, "executor", EXECUTOR);
 
     for (FrameworkField bindingField : fields.values()) {
-      TypeName fieldType = bindingField.frameworkType();
-      FieldWriter field = factoryWriter.addField(fieldType, bindingField.name());
-      field.addModifiers(PRIVATE, FINAL);
-      constructorWriter.addParameter(field.type(), field.name());
-      constructorWriter.body()
-          .addSnippet("assert %s != null;", field.name())
-          .addSnippet("this.%1$s = %1$s;", field.name());
+      TypeName fieldType = bindingField.javapoetFrameworkType();
+      addFieldAndConstructorParameter(
+          factoryBuilder, constructorBuilder, bindingField.name(), fieldType);
     }
 
     boolean returnsFuture =
@@ -166,58 +142,69 @@ public boolean apply(DependencyRequest dependency) {
                 })
             .toList();
 
+    MethodSpec.Builder computeMethodBuilder =
+        methodBuilder("compute")
+            .returns(futureTypeName)
+            .addAnnotation(Override.class)
+            .addModifiers(PROTECTED)
+            .addParameter(ProducerMonitor.class, "monitor", FINAL);
+
     for (DependencyRequest dependency : asyncDependencies) {
-      ParameterizedTypeName futureType = ParameterizedTypeName.create(
-          ClassName.fromClass(ListenableFuture.class),
-          asyncDependencyType(dependency));
-      String name = fields.get(dependency.bindingKey()).name();
-      Snippet futureAccess = Snippet.format("%s.get()", name);
-      computeMethodWriter
-          .body()
-          .addSnippet(
-              "%s %s = %s;",
-              futureType,
-              dependencyFutureName(dependency),
-              dependency.kind().equals(DependencyRequest.Kind.PRODUCED)
-                  ? Snippet.format(
-                      "%s.createFutureProduced(%s)",
-                      ClassName.fromClass(Producers.class),
-                      futureAccess)
-                  : futureAccess);
+      TypeName futureType = listenableFutureOf(asyncDependencyType(dependency));
+      CodeBlock futureAccess =
+          CodeBlocks.format("$L.get()", fields.get(dependency.bindingKey()).name());
+      computeMethodBuilder.addStatement(
+          "$T $L = $L",
+          futureType,
+          dependencyFutureName(dependency),
+          dependency.kind().equals(DependencyRequest.Kind.PRODUCED)
+              ? CodeBlocks.format("$T.createFutureProduced($L)", PRODUCERS, futureAccess)
+              : futureAccess);
     }
-
     FutureTransform futureTransform = FutureTransform.create(fields, binding, asyncDependencies);
-    Snippet transformSnippet =
-        Snippet.format(
+    CodeBlock transformCodeBlock =
+        CodeBlocks.format(
             Joiner.on('\n')
                 .join(
-                    "new %1$s<%2$s, %3$s>() {",
-                    "  %4$s",
-                    "  @Override public %5$s apply(%2$s %6$s) %7$s {",
-                    "    %8$s",
+                    "new $1T<$2T, $3T>() {",
+                    "  $4L",
+                    "  @Override public $5T apply($2T $6L) $7L {",
+                    "    $8L",
                     "  }",
                     "}"),
-            ClassName.fromClass(AsyncFunction.class),
+            ASYNC_FUNCTION,
             futureTransform.applyArgType(),
             providedTypeName,
             futureTransform.hasUncheckedCast()
-                ? "@SuppressWarnings(\"unchecked\")  // safe by specification"
+                ? CodeBlocks.format("$L // safe by specification", SUPPRESS_WARNINGS_UNCHECKED)
                 : "",
             futureTypeName,
             futureTransform.applyArgName(),
             getThrowsClause(binding.thrownTypes()),
-            getInvocationSnippet(
-                !returnsFuture, binding, providedTypeName, futureTransform.parameterSnippets()));
-    computeMethodWriter
-        .body()
-        .addSnippet(
-            "return %s.transform(%s, %s, executor);",
-            ClassName.fromClass(Futures.class),
-            futureTransform.futureSnippet(),
-            transformSnippet);
+            getInvocationCodeBlock(
+                !returnsFuture, binding, providedTypeName, futureTransform.parameterCodeBlocks()));
+    computeMethodBuilder.addStatement(
+        "return $T.transformAsync($L, $L, executor)",
+        FUTURES, futureTransform.futureCodeBlock(), transformCodeBlock);
+
+    factoryBuilder.addMethod(constructorBuilder.build());
+    factoryBuilder.addMethod(computeMethodBuilder.build());
 
     // TODO(gak): write a sensible toString
-    return ImmutableSet.of(writer);
+    return Optional.of(factoryBuilder);
+  }
+
+  // TODO(ronshapiro): consolidate versions of these
+  private static void addFieldAndConstructorParameter(
+      TypeSpec.Builder typeBuilder,
+      MethodSpec.Builder constructorBuilder,
+      String variableName,
+      TypeName variableType) {
+    typeBuilder.addField(variableType, variableName, PRIVATE, FINAL);
+    constructorBuilder
+        .addParameter(variableType, variableName)
+        .addStatement("assert $L != null", variableName)
+        .addStatement("this.$1L = $1L", variableName);
   }
 
   /** Returns a name of the variable representing this dependency's future. */
@@ -235,8 +222,8 @@ private static String dependencyFutureName(DependencyRequest dependency) {
       this.binding = binding;
     }
 
-    /** The snippet representing the future that should be transformed. */
-    abstract Snippet futureSnippet();
+    /** The code block representing the future that should be transformed. */
+    abstract CodeBlock futureCodeBlock();
 
     /** The type of the argument to the apply method. */
     abstract TypeName applyArgType();
@@ -244,8 +231,8 @@ private static String dependencyFutureName(DependencyRequest dependency) {
     /** The name of the argument to the apply method */
     abstract String applyArgName();
 
-    /** The snippets to be passed to the produces method itself. */
-    abstract ImmutableList<Snippet> parameterSnippets();
+    /** The code blocks to be passed to the produces method itself. */
+    abstract ImmutableList<CodeBlock> parameterCodeBlocks();
 
     /** Whether the transform method has an unchecked cast. */
     boolean hasUncheckedCast() {
@@ -274,16 +261,13 @@ static FutureTransform create(
     }
 
     @Override
-    Snippet futureSnippet() {
-      return Snippet.format(
-          "%s.<%s>immediateFuture(null)",
-          ClassName.fromClass(Futures.class),
-          ClassName.fromClass(Void.class));
+    CodeBlock futureCodeBlock() {
+      return CodeBlocks.format("$T.<$T>immediateFuture(null)", FUTURES, VOID_CLASS);
     }
 
     @Override
     TypeName applyArgType() {
-      return ClassName.fromClass(Void.class);
+      return VOID_CLASS;
     }
 
     @Override
@@ -292,15 +276,15 @@ String applyArgName() {
     }
 
     @Override
-    ImmutableList<Snippet> parameterSnippets() {
-      ImmutableList.Builder<Snippet> parameterSnippets = ImmutableList.builder();
+    ImmutableList<CodeBlock> parameterCodeBlocks() {
+      ImmutableList.Builder<CodeBlock> parameterCodeBlocks = ImmutableList.builder();
       for (DependencyRequest dependency : binding.dependencies()) {
-        parameterSnippets.add(
+        parameterCodeBlocks.add(
             frameworkTypeUsageStatement(
-                Snippet.format(
-                    "%s", fields.get(dependency.bindingKey()).name()), dependency.kind()));
+                CodeBlocks.format("$L", fields.get(dependency.bindingKey()).name()),
+                dependency.kind()));
       }
-      return parameterSnippets.build();
+      return parameterCodeBlocks.build();
     }
   }
 
@@ -316,8 +300,8 @@ String applyArgName() {
     }
 
     @Override
-    Snippet futureSnippet() {
-      return Snippet.format("%s", dependencyFutureName(asyncDependency));
+    CodeBlock futureCodeBlock() {
+      return CodeBlocks.format("$L", dependencyFutureName(asyncDependency));
     }
 
     @Override
@@ -331,21 +315,22 @@ String applyArgName() {
     }
 
     @Override
-    ImmutableList<Snippet> parameterSnippets() {
-      ImmutableList.Builder<Snippet> parameterSnippets = ImmutableList.builder();
+    ImmutableList<CodeBlock> parameterCodeBlocks() {
+      ImmutableList.Builder<CodeBlock> parameterCodeBlocks = ImmutableList.builder();
       for (DependencyRequest dependency : binding.dependencies()) {
         // We really want to compare instances here, because asyncDependency is an element in the
         // set binding.dependencies().
         if (dependency == asyncDependency) {
-          parameterSnippets.add(Snippet.format("%s", applyArgName()));
+          parameterCodeBlocks.add(CodeBlocks.format("$L", applyArgName()));
         } else {
-          parameterSnippets.add(
+          parameterCodeBlocks.add(
+              // TODO(ronshapiro) extract this into a method shared by FutureTransform subclasses
               frameworkTypeUsageStatement(
-                  Snippet.format(
-                      "%s", fields.get(dependency.bindingKey()).name()), dependency.kind()));
+                  CodeBlocks.format("$L", fields.get(dependency.bindingKey()).name()),
+                  dependency.kind()));
         }
       }
-      return parameterSnippets.build();
+      return parameterCodeBlocks.build();
     }
   }
 
@@ -361,26 +346,25 @@ String applyArgName() {
     }
 
     @Override
-    Snippet futureSnippet() {
-      return Snippet.format(
-          "%s.<%s>allAsList(%s)",
-          ClassName.fromClass(Futures.class),
-          ClassName.fromClass(Object.class),
-          makeParametersSnippet(
+    CodeBlock futureCodeBlock() {
+      return CodeBlocks.format(
+          "$T.<$T>allAsList($L)",
+          FUTURES,
+          OBJECT,
+          makeParametersCodeBlock(
               FluentIterable.from(asyncDependencies)
                   .transform(
-                      new Function<DependencyRequest, Snippet>() {
+                      new Function<DependencyRequest, CodeBlock>() {
                         @Override
-                        public Snippet apply(DependencyRequest dependency) {
-                          return Snippet.format("%s", dependencyFutureName(dependency));
+                        public CodeBlock apply(DependencyRequest dependency) {
+                          return CodeBlocks.format("$L", dependencyFutureName(dependency));
                         }
                       })));
     }
 
     @Override
     TypeName applyArgType() {
-      return ParameterizedTypeName.create(
-          ClassName.fromClass(List.class), ClassName.fromClass(Object.class));
+      return listOf(OBJECT);
     }
 
     @Override
@@ -389,8 +373,8 @@ String applyArgName() {
     }
 
     @Override
-    ImmutableList<Snippet> parameterSnippets() {
-      return getParameterSnippets(binding, fields, applyArgName());
+    ImmutableList<CodeBlock> parameterCodeBlocks() {
+      return getParameterCodeBlocks(binding, fields, applyArgName());
     }
 
     @Override
@@ -410,119 +394,113 @@ private static boolean isAsyncDependency(DependencyRequest dependency) {
   }
 
   private static TypeName asyncDependencyType(DependencyRequest dependency) {
-    TypeName keyName = TypeNames.forTypeMirror(dependency.key().type());
+    TypeName keyName = TypeName.get(dependency.key().type());
     switch (dependency.kind()) {
       case INSTANCE:
         return keyName;
       case PRODUCED:
-        return ParameterizedTypeName.create(ClassName.fromClass(Produced.class), keyName);
+        return producedOf(keyName);
       default:
         throw new AssertionError();
     }
   }
 
-  private static ImmutableList<Snippet> getParameterSnippets(
+  private static ImmutableList<CodeBlock> getParameterCodeBlocks(
       ProductionBinding binding,
       ImmutableMap<BindingKey, FrameworkField> fields,
       String listArgName) {
     int argIndex = 0;
-    ImmutableList.Builder<Snippet> snippets = ImmutableList.builder();
+    ImmutableList.Builder<CodeBlock> codeBlocks = ImmutableList.builder();
     for (DependencyRequest dependency : binding.dependencies()) {
       if (isAsyncDependency(dependency)) {
-        snippets.add(Snippet.format(
-            "(%s) %s.get(%s)",
+        codeBlocks.add(CodeBlocks.format(
+            "($T) $L.get($L)",
             asyncDependencyType(dependency),
             listArgName,
             argIndex));
         argIndex++;
       } else {
-        snippets.add(frameworkTypeUsageStatement(
-            Snippet.format("%s", fields.get(dependency.bindingKey()).name()), dependency.kind()));
+        codeBlocks.add(frameworkTypeUsageStatement(
+            CodeBlocks.format("$L", fields.get(dependency.bindingKey()).name()),
+            dependency.kind()));
       }
     }
-    return snippets.build();
+    return codeBlocks.build();
   }
 
   /**
-   * Creates a snippet for the invocation of the producer method from the module, which should be
+   * Creates a code block for the invocation of the producer method from the module, which should be
    * used entirely within a method body.
    *
    * @param wrapWithFuture If true, wraps the result of the call to the producer method
    *        in an immediate future.
-   * @param binding The binding to generate the invocation snippet for.
+   * @param binding The binding to generate the invocation code block for.
    * @param providedTypeName The type name that should be provided by this producer.
-   * @param parameterSnippets The snippets for all the parameters to the producer method.
+   * @param parameterCodeBlocks The code blocks for all the parameters to the producer method.
    */
-  private Snippet getInvocationSnippet(
+  private CodeBlock getInvocationCodeBlock(
       boolean wrapWithFuture,
       ProductionBinding binding,
       TypeName providedTypeName,
-      ImmutableList<Snippet> parameterSnippets) {
-     Snippet moduleSnippet = Snippet.format("%s.%s(%s)",
+      ImmutableList<CodeBlock> parameterCodeBlocks) {
+    CodeBlock moduleCodeBlock = CodeBlocks.format("$L.$L($L)",
         binding.bindingElement().getModifiers().contains(STATIC)
-            ? ClassName.fromTypeElement(binding.bindingTypeElement())
+            ? CodeBlocks.format("$T", ClassName.get(binding.bindingTypeElement()))
             : "module",
         binding.bindingElement().getSimpleName(),
-        makeParametersSnippet(parameterSnippets));
+        makeParametersCodeBlock(parameterCodeBlocks));
 
-    // NOTE(beder): We don't worry about catching exeptions from the monitor methods themselves
+    // NOTE(beder): We don't worry about catching exceptions from the monitor methods themselves
     // because we'll wrap all monitoring in non-throwing monitors before we pass them to the
     // factories.
-    ImmutableList.Builder<Snippet> snippets = ImmutableList.builder();
-    snippets.add(Snippet.format("monitor.methodStarting();"));
+    ImmutableList.Builder<CodeBlock> codeBlocks = ImmutableList.builder();
+    codeBlocks.add(CodeBlocks.format("monitor.methodStarting();"));
 
-    final Snippet valueSnippet;
+    final CodeBlock valueCodeBlock;
     if (binding.productionType().equals(Produces.Type.SET)) {
       if (binding.bindingKind().equals(ContributionBinding.Kind.FUTURE_PRODUCTION)) {
-        valueSnippet =
-            Snippet.format(
-                "%s.createFutureSingletonSet(%s)",
-                ClassName.fromClass(Producers.class),
-                moduleSnippet);
+        valueCodeBlock =
+            CodeBlocks.format("$T.createFutureSingletonSet($L)", PRODUCERS, moduleCodeBlock);
       } else {
-        valueSnippet =
-            Snippet.format("%s.of(%s)", ClassName.fromClass(ImmutableSet.class), moduleSnippet);
+        valueCodeBlock =
+            CodeBlocks.format("$T.of($L)", IMMUTABLE_SET, moduleCodeBlock);
       }
     } else {
-      valueSnippet = moduleSnippet;
+      valueCodeBlock = moduleCodeBlock;
     }
-    Snippet returnSnippet =
+    CodeBlock returnCodeBlock =
         wrapWithFuture
-            ? Snippet.format(
-                "%s.<%s>immediateFuture(%s)",
-                ClassName.fromClass(Futures.class),
+            ? CodeBlocks.format(
+                "$T.<$T>immediateFuture($L)",
+                FUTURES,
                 providedTypeName,
-                valueSnippet)
-            : valueSnippet;
-    return Snippet.format(
+                valueCodeBlock)
+            : valueCodeBlock;
+    return CodeBlocks.format(
         Joiner.on('\n')
             .join(
                 "monitor.methodStarting();",
                 "try {",
-                "  return %s;",
+                "  return $L;",
                 "} finally {",
                 "  monitor.methodFinished();",
                 "}"),
-        returnSnippet);
+        returnCodeBlock);
   }
 
   /**
-   * Creates a Snippet for the throws clause.
+   * Creates a CodeBlock for the throws clause.
    *
    * @param thrownTypes the list of thrown types.
    */
-  private Snippet getThrowsClause(List<? extends TypeMirror> thrownTypes) {
+  private CodeBlock getThrowsClause(List<? extends TypeMirror> thrownTypes) {
     if (thrownTypes.isEmpty()) {
-      return Snippet.format("");
+      return CodeBlocks.format("");
     }
-    return Snippet.format("throws %s ",
-        Snippet.makeParametersSnippet(FluentIterable
-            .from(thrownTypes)
-            .transform(new Function<TypeMirror, Snippet>() {
-              @Override public Snippet apply(TypeMirror thrownType) {
-                return Snippet.format("%s", TypeNames.forTypeMirror(thrownType));
-              }
-            })
-            .toList()));
+    return CodeBlocks.format(
+        "throws $L",
+        CodeBlocks.join(
+            FluentIterable.from(thrownTypes)
+                .transform(CodeBlocks.TYPE_MIRROR_TO_CODE_BLOCK), ", "));
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index b66b6b72b..f7b2f8ee9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -18,6 +18,7 @@
 import com.google.common.base.Functions;
 import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
+import com.google.common.base.Splitter;
 import com.google.common.collect.ComparisonChain;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
@@ -34,8 +35,11 @@
 import dagger.internal.codegen.writer.ParameterizedTypeName;
 import dagger.internal.codegen.writer.Snippet;
 import dagger.internal.codegen.writer.TypeName;
+import dagger.internal.codegen.writer.TypeNames;
+import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Iterator;
+import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
 import javax.lang.model.element.Element;
@@ -46,6 +50,7 @@
 
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
 import static com.google.common.base.Preconditions.checkArgument;
+import static dagger.internal.codegen.TypeNames.DOUBLE_CHECK_LAZY;
 
 /**
  * Utilities for generating files.
@@ -208,7 +213,7 @@ static CodeBlock frameworkTypeUsageStatement(
     switch (dependencyKind) {
       case LAZY:
         return CodeBlocks.format(
-            "$T.create($L)", TypeNames.DOUBLE_CHECK_LAZY, frameworkTypeMemberSelect);
+            "$T.create($L)", DOUBLE_CHECK_LAZY, frameworkTypeMemberSelect);
       case INSTANCE:
       case FUTURE:
         return CodeBlocks.format("$L.get()", frameworkTypeMemberSelect);
@@ -382,22 +387,24 @@ static ClassName membersInjectorNameForType(TypeElement typeElement) {
 
   static com.squareup.javapoet.ClassName javapoetMembersInjectorNameForType(
       TypeElement typeElement) {
-    com.squareup.javapoet.ClassName injectedClassName =
-        com.squareup.javapoet.ClassName.get(typeElement);
-    return injectedClassName
-        .topLevelClassName()
-        .peerClass(classFileName(injectedClassName) + "_MembersInjector");
+    return siblingClassName(typeElement,  "_MembersInjector");
   }
 
   static String classFileName(com.squareup.javapoet.ClassName className) {
     return CLASS_FILE_NAME_JOINER.join(className.simpleNames());
   }
 
-  static ClassName generatedMonitoringModuleName(TypeElement componentElement) {
-    ClassName componentName = ClassName.fromTypeElement(componentElement);
-    return componentName
-        .topLevelClassName()
-        .peerNamed(componentName.classFileName() + "_MonitoringModule");
+  static com.squareup.javapoet.ClassName generatedMonitoringModuleName(
+      TypeElement componentElement) {
+    return siblingClassName(componentElement, "_MonitoringModule");
+  }
+
+  // TODO(ronshapiro): when JavaPoet migration is complete, replace the duplicated code which could
+  // use this.
+  private static com.squareup.javapoet.ClassName siblingClassName(
+      TypeElement typeElement, String suffix) {
+    com.squareup.javapoet.ClassName className = com.squareup.javapoet.ClassName.get(typeElement);
+    return className.topLevelClassName().peerClass(classFileName(className) + suffix);
   }
 
   private static String factoryPrefix(ContributionBinding binding) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/TypeNames.java b/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
index c0135dccd..80d83efba 100644
--- a/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
+++ b/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
@@ -15,21 +15,75 @@
  */
 package dagger.internal.codegen;
 
+import com.google.common.collect.ImmutableSet;
+import com.google.common.util.concurrent.AsyncFunction;
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.ParameterizedTypeName;
 import com.squareup.javapoet.TypeName;
 import dagger.MembersInjector;
 import dagger.internal.DoubleCheckLazy;
 import dagger.internal.Factory;
+import dagger.producers.Produced;
+import dagger.producers.internal.AbstractProducer;
+import dagger.producers.internal.Producers;
+import dagger.producers.monitoring.ProducerToken;
+import dagger.producers.monitoring.ProductionComponentMonitor;
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.Executor;
+import javax.inject.Provider;
 
 /**
  * Common names and convenience methods for JavaPoet {@link TypeName} usage.
  */
 final class TypeNames {
 
+  static final ClassName ABSTRACT_PRODUCER = ClassName.get(AbstractProducer.class);
+  static final ClassName ASYNC_FUNCTION = ClassName.get(AsyncFunction.class);
   static final ClassName DOUBLE_CHECK_LAZY = ClassName.get(DoubleCheckLazy.class);
+  static final ClassName EXECUTOR = ClassName.get(Executor.class);
   static final ClassName FACTORY = ClassName.get(Factory.class);
+  static final ClassName FUTURES = ClassName.get(Futures.class);
+  static final ClassName IMMUTABLE_SET = ClassName.get(ImmutableSet.class);
+  static final ClassName LIST = ClassName.get(List.class);
+  static final ClassName LISTENABLE_FUTURE = ClassName.get(ListenableFuture.class);
   static final ClassName MEMBERS_INJECTOR = ClassName.get(MembersInjector.class);
+  static final ClassName PRODUCER_TOKEN = ClassName.get(ProducerToken.class);
+  static final ClassName PRODUCED = ClassName.get(Produced.class);
+  static final ClassName PRODUCERS = ClassName.get(Producers.class);
+  static final ClassName PROVIDER = ClassName.get(Provider.class);
+
+  /**
+   * {@link TypeName#VOID} is lowercase-v {@code void} whereas this represents the class, {@link
+   * Void}.
+   */
+  static final ClassName VOID_CLASS = ClassName.get(Void.class);
+
+  static final TypeName SET_OF_FACTORIES =
+      ParameterizedTypeName.get(
+          ClassName.get(Set.class), ClassName.get(ProductionComponentMonitor.Factory.class));
+
+  static ParameterizedTypeName listOf(TypeName typeName) {
+    return ParameterizedTypeName.get(LIST, typeName);
+  }
+
+  static ParameterizedTypeName abstractProducerOf(TypeName typeName) {
+    return ParameterizedTypeName.get(ABSTRACT_PRODUCER, typeName);
+  }
+
+  static ParameterizedTypeName producedOf(TypeName typeName) {
+    return ParameterizedTypeName.get(PRODUCED, typeName);
+  }
+
+  static ParameterizedTypeName listenableFutureOf(TypeName typeName) {
+    return ParameterizedTypeName.get(LISTENABLE_FUTURE, typeName);
+  }
+
+  static ParameterizedTypeName providerOf(TypeName typeName) {
+    return ParameterizedTypeName.get(PROVIDER, typeName);
+  }
 
   static ParameterizedTypeName membersInjectorOf(TypeName membersInjectorType) {
     return ParameterizedTypeName.get(MEMBERS_INJECTOR, membersInjectorType);
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java
index e3adecc8a..d318cd37c 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java
@@ -71,7 +71,6 @@ public void testEmptyBuilder() {
         "public final class DaggerSimpleComponent implements SimpleComponent {",
         "  private DaggerSimpleComponent(Builder builder) {",
         "    assert builder != null;",
-        "    initialize(builder);",
         "  }",
         "",
         "  public static SimpleComponent.Builder builder() {",
@@ -82,10 +81,6 @@ public void testEmptyBuilder() {
         "    return builder().build();",
         "  }",
         "",
-        "  @SuppressWarnings(\"unchecked\")",
-        "  private void initialize(final Builder builder) {",
-        "  }",
-        "",
         "  @Override",
         "  public SomeInjectableType someInjectableType() {",
         "    return SomeInjectableType_Factory.create().get();",
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index 3f400efbc..ba235258a 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -232,7 +232,6 @@ private void checkCannotReferToModuleOfType(String moduleType) {
         "public final class DaggerSimpleComponent implements SimpleComponent {",
         "  private DaggerSimpleComponent(Builder builder) {",
         "    assert builder != null;",
-        "    initialize(builder);",
         "  }",
         "",
         "  public static Builder builder() {",
@@ -243,10 +242,6 @@ private void checkCannotReferToModuleOfType(String moduleType) {
         "    return builder().build();",
         "  }",
         "",
-        "  @SuppressWarnings(\"unchecked\")",
-        "  private void initialize(final Builder builder) {",
-        "  }",
-        "",
         "  @Override",
         "  public SomeInjectableType someInjectableType() {",
         "    return SomeInjectableType_Factory.create().get();",
@@ -1825,7 +1820,6 @@ public void subcomponentOmitsInheritedBindings() {
         "public final class DaggerSimpleComponent implements SimpleComponent {",
         "  private DaggerSimpleComponent(Builder builder) {",
         "    assert builder != null;",
-        "    initialize(builder);",
         "  }",
         "",
         "  public static Builder builder() {",
@@ -1836,9 +1830,6 @@ public void subcomponentOmitsInheritedBindings() {
         "    return builder().build();",
         "  }",
         "",
-        "  @SuppressWarnings(\"unchecked\")",
-        "  private void initialize(final Builder builder) {}",
-        "",
         "  @Override",
         "  public SomeInjectableType someInjectableType() {",
         "    return SomeInjectableType_Factory.create().get();",
@@ -1914,7 +1905,6 @@ public void subcomponentOmitsInheritedBindings() {
         "public final class DaggerSimpleComponent implements SimpleComponent {",
         "  private DaggerSimpleComponent(Builder builder) {",
         "    assert builder != null;",
-        "    initialize(builder);",
         "  }",
         "",
         "  public static Builder builder() {",
@@ -1925,9 +1915,6 @@ public void subcomponentOmitsInheritedBindings() {
         "    return builder().build();",
         "  }",
         "",
-        "  @SuppressWarnings(\"unchecked\")",
-        "  private void initialize(final Builder builder) {}",
-        "",
         "  @Override",
         "  public SomeInjectableType someInjectableType() {",
         "    return SomeInjectableType_Factory.create().get();",
diff --git a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
index 03184f8a3..cd44b97e5 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
@@ -17,6 +17,7 @@
 
 import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.JavaFileObjects;
+import dagger.Provides;
 import dagger.internal.codegen.writer.StringLiteral;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
@@ -767,7 +768,7 @@ private String formatModuleErrorMessage(String msg) {
   }
 
   @Test
-  public void producesMethodThrowsChecked() {
+  public void providesMethodThrowsChecked() {
     JavaFileObject moduleFile =
         JavaFileObjects.forSourceLines(
             "test.TestModule",
@@ -1171,6 +1172,96 @@ public void genericSubclassedModule() {
             listBFactory, bElementFactory, bEntryFactory, numberFactory, integerFactory);
   }
 
+  @Test public void parameterizedModuleWithStaticProvidesMethodOfGenericType() {
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.ParameterizedModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import java.util.List;",
+            "import java.util.ArrayList;",
+            "import java.util.Map;",
+            "import java.util.HashMap;",
+            "",
+            "@Module abstract class ParameterizedModule<T> {",
+            "  @Provides List<T> provideListT() {",
+            "    return new ArrayList<>();",
+            "  }",
+            "",
+            "  @Provides static Map<String, Number> provideMapStringNumber() {",
+            "    return new HashMap<>();",
+            "  }",
+            "",
+            "  @Provides static Object provideNonGenericType() {",
+            "    return new Object();",
+            "  }",
+            "}");
+
+    JavaFileObject provideMapStringNumberFactory =
+        JavaFileObjects.forSourceLines(
+            "test.ParameterizedModule_ProvideMapStringNumberFactory;",
+            "package test;",
+            "",
+            "import dagger.internal.Factory;",
+            "import java.util.Map;",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION_JAVAPOET,
+            "public enum ParameterizedModule_ProvideMapStringNumberFactory",
+            "    implements Factory<Map<String, Number>> {",
+            "  INSTANCE;",
+            "",
+            "  @Override",
+            "  public Map<String, Number> get() {",
+            "    Map<String, Number> provided = ParameterizedModule.provideMapStringNumber();",
+            "    if (provided == null) {",
+            "      throw new NullPointerException(" + NPE_LITERAL + ");",
+            "    }",
+            "    return provided;",
+            "  }",
+            "",
+            "  public static Factory<Map<String, Number>> create() {",
+            "    return INSTANCE;",
+            "  }",
+            "}");
+
+    JavaFileObject provideNonGenericTypeFactory =
+        JavaFileObjects.forSourceLines(
+            "test.ParameterizedModule_ProvideNonGenericTypeFactory;",
+            "package test;",
+            "",
+            "import dagger.internal.Factory;",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION_JAVAPOET,
+            "public enum ParameterizedModule_ProvideNonGenericTypeFactory",
+            "    implements Factory<Object> {",
+            "  INSTANCE;",
+            "",
+            "  @Override",
+            "  public Object get() {",
+            "    Object provided = ParameterizedModule.provideNonGenericType();",
+            "    if (provided == null) {",
+            "      throw new NullPointerException(" + NPE_LITERAL + ");",
+            "    }",
+            "    return provided;",
+            "  }",
+            "",
+            "  public static Factory<Object> create() {",
+            "    return INSTANCE;",
+            "  }",
+            "}");
+
+    assertAbout(javaSource())
+        .that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(provideMapStringNumberFactory, provideNonGenericTypeFactory);
+  }
+
   @Test public void providesMethodMultipleQualifiers() {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
index dd9e53863..41fae8ad1 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
@@ -38,7 +38,7 @@
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_SET_VALUES_RETURN_SET;
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_THROWS;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_OR_PRODUCES_METHOD_MULTIPLE_QUALIFIERS;
-import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION_JAVAPOET;
 
 @RunWith(JUnit4.class)
 public class ProducerModuleFactoryGeneratorTest {
@@ -510,7 +510,7 @@ public void publicModuleNonPublicIncludes() {
             "import javax.annotation.Generated;",
             "import javax.inject.Provider;",
             "",
-            GENERATED_ANNOTATION,
+            GENERATED_ANNOTATION_JAVAPOET,
             "public final class TestModule_ProduceStringFactory extends AbstractProducer<String> {",
             "  private final TestModule module;",
             "  private final Executor executor;",
@@ -533,7 +533,7 @@ public void publicModuleNonPublicIncludes() {
             "",
             "  @Override protected ListenableFuture<String> compute(",
             "      final ProducerMonitor monitor) {",
-            "    return Futures.transform(",
+            "    return Futures.transformAsync(",
             "      Futures.<Void>immediateFuture(null),",
             "      new AsyncFunction<Void, String>() {",
             "        @Override public ListenableFuture<String> apply(Void ignoredVoidArg) {",
diff --git a/producers/src/main/java/dagger/producers/internal/MapOfProducedProducer.java b/producers/src/main/java/dagger/producers/internal/MapOfProducedProducer.java
new file mode 100644
index 000000000..7217e8c11
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/internal/MapOfProducedProducer.java
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.internal;
+
+import com.google.common.base.Function;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Maps;
+import com.google.common.util.concurrent.AsyncFunction;
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.internal.Beta;
+import dagger.producers.Produced;
+import dagger.producers.Producer;
+import dagger.producers.monitoring.ProducerMonitor;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * A {@link Producer} implementation used to implement {@link Map} bindings. This producer returns a
+ * {@code Map<K, Produced<V>>} which is populated by calls to the delegate {@link Producer#get}
+ * methods.
+ *
+ * @author Jesse Beder
+ */
+@Beta
+public final class MapOfProducedProducer<K, V> extends AbstractProducer<Map<K, Produced<V>>> {
+  private final Producer<Map<K, Producer<V>>> mapProducerProducer;
+
+  private MapOfProducedProducer(Producer<Map<K, Producer<V>>> mapProducerProducer) {
+    this.mapProducerProducer = mapProducerProducer;
+  }
+
+  /**
+   * Returns a producer of {@code Map<K, Produced<V>>}, where the map is derived from the given map
+   * of producers by waiting for those producers' resulting futures. The iteration order mirrors the
+   * order of the input map.
+   *
+   * <p>If any of the delegate producers, or their resulting values, are null, then this producer's
+   * future will succeed and the corresponding {@code Produced<V>} will fail with a
+   * {@link NullPointerException}.
+   *
+   * <p>Canceling this future will attempt to cancel all of the component futures, and if any of the
+   * component futures fails or is canceled, this one is, too.
+   */
+  public static <K, V> MapOfProducedProducer<K, V> create(
+      Producer<Map<K, Producer<V>>> mapProducerProducer) {
+    return new MapOfProducedProducer<K, V>(mapProducerProducer);
+  }
+
+  @Override
+  public ListenableFuture<Map<K, Produced<V>>> compute(ProducerMonitor unusedMonitor) {
+    return Futures.transformAsync(
+        mapProducerProducer.get(),
+        new AsyncFunction<Map<K, Producer<V>>, Map<K, Produced<V>>>() {
+          @Override
+          public ListenableFuture<Map<K, Produced<V>>> apply(final Map<K, Producer<V>> map) {
+            // TODO(beder): Use Futures.whenAllComplete when Guava 20 is released.
+            return Futures.transform(
+                Futures.allAsList(
+                    Iterables.transform(
+                        map.entrySet(), MapOfProducedProducer.<K, V>entryUnwrapper())),
+                new Function<List<Map.Entry<K, Produced<V>>>, Map<K, Produced<V>>>() {
+                  @Override
+                  public Map<K, Produced<V>> apply(List<Map.Entry<K, Produced<V>>> entries) {
+                    return ImmutableMap.copyOf(entries);
+                  }
+                });
+          }
+        });
+  }
+
+  private static final Function<
+          Map.Entry<Object, Producer<Object>>,
+          ListenableFuture<Map.Entry<Object, Produced<Object>>>>
+      ENTRY_UNWRAPPER =
+          new Function<
+              Map.Entry<Object, Producer<Object>>,
+              ListenableFuture<Map.Entry<Object, Produced<Object>>>>() {
+            @Override
+            public ListenableFuture<Map.Entry<Object, Produced<Object>>> apply(
+                final Map.Entry<Object, Producer<Object>> entry) {
+              return Futures.transform(
+                  Producers.createFutureProduced(entry.getValue().get()),
+                  new Function<Produced<Object>, Map.Entry<Object, Produced<Object>>>() {
+                    @Override
+                    public Map.Entry<Object, Produced<Object>> apply(Produced<Object> value) {
+                      return Maps.immutableEntry(entry.getKey(), value);
+                    }
+                  });
+            }
+          };
+
+  @SuppressWarnings({"unchecked", "rawtypes"}) // bivariate implementation
+  private static <K, V>
+      Function<Map.Entry<K, Producer<V>>, ListenableFuture<Map.Entry<K, Produced<V>>>>
+          entryUnwrapper() {
+    return (Function<Map.Entry<K, Producer<V>>, ListenableFuture<Map.Entry<K, Produced<V>>>>)
+        (Function) ENTRY_UNWRAPPER;
+  }
+}
diff --git a/producers/src/main/java/dagger/producers/monitoring/ProducerMonitor.java b/producers/src/main/java/dagger/producers/monitoring/ProducerMonitor.java
index 5d46cf235..f18046231 100644
--- a/producers/src/main/java/dagger/producers/monitoring/ProducerMonitor.java
+++ b/producers/src/main/java/dagger/producers/monitoring/ProducerMonitor.java
@@ -93,7 +93,8 @@ public void requested() {}
   public void methodStarting() {}
 
   /**
-   * Called when the producer method has finished executing.
+   * Called when the producer method has finished executing. This will be called from the same
+   * thread as {@link #methodStarting()}.
    *
    * <p>When multiple monitors are installed, calls to this method will be in the reverse order from
    * calls to {@link #requested()}.
