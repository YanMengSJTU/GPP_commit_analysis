diff --git a/java/dagger/internal/codegen/AbstractComponentWriter.java b/java/dagger/internal/codegen/AbstractComponentWriter.java
index fd7d78c54..74b426db4 100644
--- a/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -402,11 +402,8 @@ private void implementInterfaceMethods() {
                   "return $N($N)", getMembersInjectionMethod(binding.key()), parameter);
             }
           } else {
-            interfaceMethod.addStatement(
-                "return $L",
-                bindingExpressions
-                    .getComponentMethodExpression(interfaceRequest, name)
-                    .codeBlock());
+            interfaceMethod.addCode(
+                bindingExpressions.getComponentMethodImplementation(interfaceRequest, name));
           }
           interfaceMethods.add(interfaceMethod.build());
         }
diff --git a/java/dagger/internal/codegen/BindingExpression.java b/java/dagger/internal/codegen/BindingExpression.java
index aa52b5322..22dcdb063 100644
--- a/java/dagger/internal/codegen/BindingExpression.java
+++ b/java/dagger/internal/codegen/BindingExpression.java
@@ -24,6 +24,7 @@
 
 import com.google.common.collect.ImmutableMap;
 import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.FieldSpec;
 import java.util.Optional;
 import javax.lang.model.util.Elements;
@@ -52,11 +53,11 @@ abstract Expression getDependencyExpression(
 
   /** Returns an expression for the implementation of a component method with the given request. */
   // TODO(dpb): Consider using ComponentMethodDescriptor instead of DependencyRequest?
-  // TODO(dpb): Consider renaming to getComponentMethodImplementation and include "return ... ;"?
-  Expression getComponentMethodExpression(DependencyRequest request, ClassName requestingClass) {
+  CodeBlock getComponentMethodImplementation(DependencyRequest request, ClassName requestingClass) {
     checkArgument(request.bindingKey().equals(resolvedBindings().bindingKey()));
     // By default, just delegate to #getDependencyExpression().
-    return getDependencyExpression(request.kind(), requestingClass);
+    CodeBlock expression = getDependencyExpression(request.kind(), requestingClass).codeBlock();
+    return CodeBlock.of("return $L;", expression);
   }
 
   /** Factory for building a {@link BindingExpression}. */
diff --git a/java/dagger/internal/codegen/ComponentBindingExpressions.java b/java/dagger/internal/codegen/ComponentBindingExpressions.java
index 11a1bd6e1..697296592 100644
--- a/java/dagger/internal/codegen/ComponentBindingExpressions.java
+++ b/java/dagger/internal/codegen/ComponentBindingExpressions.java
@@ -22,6 +22,7 @@
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
 import java.util.HashMap;
 import java.util.Map;
 import javax.lang.model.type.TypeMirror;
@@ -123,9 +124,9 @@ Expression getDependencyArgumentExpression(
    * @throws IllegalStateException if there is no binding expression that satisfies the dependency
    *     request
    */
-  Expression getComponentMethodExpression(DependencyRequest request, ClassName requestingClass) {
+  CodeBlock getComponentMethodImplementation(DependencyRequest request, ClassName requestingClass) {
     return getBindingExpression(request.bindingKey())
-        .getComponentMethodExpression(request, requestingClass);
+        .getComponentMethodImplementation(request, requestingClass);
   }
 
   private BindingExpression getBindingExpression(BindingKey bindingKey) {
diff --git a/java/dagger/internal/codegen/PrivateMethodBindingExpression.java b/java/dagger/internal/codegen/PrivateMethodBindingExpression.java
index 74494687c..fd49f95a2 100644
--- a/java/dagger/internal/codegen/PrivateMethodBindingExpression.java
+++ b/java/dagger/internal/codegen/PrivateMethodBindingExpression.java
@@ -74,17 +74,17 @@
   }
 
   @Override
-  Expression getComponentMethodExpression(DependencyRequest request, ClassName requestingClass) {
+  CodeBlock getComponentMethodImplementation(DependencyRequest request, ClassName requestingClass) {
     checkArgument(request.bindingKey().equals(resolvedBindings().bindingKey()));
     if (ignorePrivateMethodStrategy(request.kind())) {
-      return delegate.getDependencyExpression(request.kind(), requestingClass);
+      return delegate.getComponentMethodImplementation(request, requestingClass);
     }
 
     return findComponentMethod(request.kind())
             .map(method -> method.dependencyRequest().get().equals(request))
             .orElse(false)
-        ? Expression.create(returnType(request.kind()), methodBody(request.kind()))
-        : getDependencyExpression(request.kind(), requestingClass);
+        ? methodBody(request.kind())
+        : super.getComponentMethodImplementation(request, requestingClass);
   }
 
   @Override
@@ -166,7 +166,7 @@ private void createMethod(String name, DependencyRequest.Kind requestKind) {
         methodBuilder(name)
             .addModifiers(PRIVATE)
             .returns(TypeName.get(returnType(requestKind)))
-            .addStatement("return $L", methodBody(requestKind))
+            .addCode(methodBody(requestKind))
             .build());
   }
 
@@ -184,20 +184,21 @@ private CodeBlock methodBody(DependencyRequest.Kind requestKind) {
     switch (requestKind) {
       case PROVIDER:
         // TODO(user): Cache provider field instead of recreating each time.
-        return CodeBlock.of("$L", providerTypeSpec());
+        return CodeBlock.of("return $L;", providerTypeSpec());
       case LAZY:
       case PROVIDER_OF_LAZY:
         // TODO(user): Refactor the delegate BindingExpression to handle these cases?
         // Don't use delegate.getDependencyExpression() because that will inline the provider
         // dependency instead of delegating to the private method. To use the private method,
         // recursively call this.getDependencyExpression().
-        return FrameworkType.PROVIDER.to(
-            requestKind,
-            getDependencyExpression(DependencyRequest.Kind.PROVIDER, componentName).codeBlock());
+        CodeBlock asProvider =
+            getDependencyExpression(DependencyRequest.Kind.PROVIDER, componentName).codeBlock();
+        return CodeBlock.of("return $L;", FrameworkType.PROVIDER.to(requestKind, asProvider));
       case INSTANCE:
       case PRODUCER:
       case FUTURE:
-        return delegate.getDependencyExpression(requestKind, componentName).codeBlock();
+        return CodeBlock.of(
+            "return $L;", delegate.getDependencyExpression(requestKind, componentName).codeBlock());
       default:
         throw new AssertionError("Unhandled DependencyRequest: " + requestKind);
     }
