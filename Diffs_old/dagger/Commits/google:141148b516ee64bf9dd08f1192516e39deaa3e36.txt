diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index 0ddaa5027..10ce2baf1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -33,6 +33,7 @@
 import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_OPTIONAL_BINDING;
 import static dagger.internal.codegen.Key.indexByKey;
 import static dagger.internal.codegen.Scope.reusableScope;
+import static dagger.internal.codegen.Util.toImmutableSet;
 import static java.util.function.Predicate.isEqual;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 
@@ -90,6 +91,20 @@
   abstract ImmutableMap<BindingKey, ResolvedBindings> resolvedBindings();
   abstract ImmutableSet<BindingGraph> subgraphs();
 
+  /** Returns the resolved bindings for the dependencies of {@code binding}. */
+  ImmutableSet<ResolvedBindings> resolvedDependencies(ContributionBinding binding) {
+    return binding
+        .dependencies()
+        .stream()
+        .map(
+            dependencyRequest ->
+                resolvedBindings()
+                    .getOrDefault(
+                        dependencyRequest.bindingKey(),
+                        ResolvedBindings.noBindings(
+                            dependencyRequest.bindingKey(), componentDescriptor())))
+        .collect(toImmutableSet());
+  }
   /**
    * The type that defines the component for this graph.
    *
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 4147c84a9..55a61a879 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -21,11 +21,8 @@
 import static com.google.auto.common.MoreTypes.asExecutable;
 import static com.google.auto.common.MoreTypes.asTypeElements;
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.base.Verify.verify;
 import static com.google.common.collect.Iterables.getOnlyElement;
-import static com.google.common.collect.Iterables.indexOf;
-import static dagger.internal.codegen.BindingType.MEMBERS_INJECTION;
 import static dagger.internal.codegen.BindingType.PRODUCTION;
 import static dagger.internal.codegen.BindingType.PROVISION;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentAnnotation;
@@ -42,6 +39,7 @@
 import static dagger.internal.codegen.ErrorMessages.DUPLICATE_BINDINGS_FOR_KEY_FORMAT;
 import static dagger.internal.codegen.ErrorMessages.DUPLICATE_SIZE_LIMIT;
 import static dagger.internal.codegen.ErrorMessages.INDENT;
+import static dagger.internal.codegen.ErrorMessages.MEMBERS_INJECTION_WITH_RAW_TYPE;
 import static dagger.internal.codegen.ErrorMessages.MEMBERS_INJECTION_WITH_UNBOUNDED_TYPE;
 import static dagger.internal.codegen.ErrorMessages.MULTIPLE_CONTRIBUTION_TYPES_FOR_KEY_FORMAT;
 import static dagger.internal.codegen.ErrorMessages.PROVIDER_ENTRY_POINT_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT;
@@ -55,17 +53,16 @@
 import static dagger.internal.codegen.ErrorMessages.nullableToNonNullable;
 import static dagger.internal.codegen.ErrorMessages.stripCommonTypePrefixes;
 import static dagger.internal.codegen.Scope.reusableScope;
+import static dagger.internal.codegen.Scope.scopesOf;
 import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
+import static dagger.internal.codegen.Util.toImmutableSet;
 import static java.util.stream.Collectors.joining;
 import static java.util.stream.Collectors.toSet;
-import static javax.tools.Diagnostic.Kind.ERROR;
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
-import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
 import com.google.common.base.Optional;
-import com.google.common.base.Predicate;
 import com.google.common.base.Predicates;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
@@ -74,10 +71,9 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.ImmutableSortedMap;
-import com.google.common.collect.Iterables;
-import com.google.common.collect.LinkedHashMultiset;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Multimap;
+import com.google.common.collect.Multimaps;
 import com.google.common.collect.Sets;
 import com.squareup.javapoet.TypeName;
 import dagger.BindsOptionalOf;
@@ -85,19 +81,18 @@
 import dagger.Lazy;
 import dagger.MapKey;
 import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
-import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.internal.codegen.ContributionType.HasContributionType;
 import java.util.ArrayDeque;
 import java.util.Collection;
 import java.util.Deque;
 import java.util.Formatter;
-import java.util.HashSet;
+import java.util.LinkedHashMap;
 import java.util.Map;
 import java.util.Queue;
 import java.util.Set;
+import java.util.concurrent.atomic.AtomicBoolean;
 import javax.inject.Provider;
 import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.ArrayType;
@@ -106,8 +101,9 @@
 import javax.lang.model.type.PrimitiveType;
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
+import javax.lang.model.type.TypeVisitor;
 import javax.lang.model.util.Elements;
-import javax.lang.model.util.SimpleTypeVisitor6;
+import javax.lang.model.util.SimpleTypeVisitor8;
 import javax.lang.model.util.Types;
 
 /** Reports errors in the shape of the binding graph. */
@@ -147,570 +143,123 @@
     this.keyFactory = keyFactory;
   }
 
-  /** A dependency path from an entry point. */
-  static final class DependencyPath {
-    private final Deque<ResolvedRequest> path = new ArrayDeque<>();
-    private final LinkedHashMultiset<BindingKey> keyPath = LinkedHashMultiset.create();
-    private final Set<DependencyRequest> resolvedDependencyRequests = new HashSet<>();
+  private final class ComponentValidation extends ComponentTreeTraverser {
+    final BindingGraph rootGraph;
+    final Map<ComponentDescriptor, ValidationReport.Builder<TypeElement>> reports =
+        new LinkedHashMap<>();
 
-    /** The entry point. */
-    Element entryPointElement() {
-      return path.getFirst().dependencyRequest().requestElement().get();
+    ComponentValidation(BindingGraph rootGraph) {
+      super(rootGraph);
+      this.rootGraph = rootGraph;
     }
 
-    /** The the current dependency request and resolved bindings. */
-    ResolvedRequest current() {
-      return path.getLast();
-    }
-
-    /**
-     * {@code true} if there is a dependency cycle, which means that the current request's binding
-     * key occurs earlier in the path.
-     */
-    boolean hasCycle() {
-      return keyPath.count(current().dependencyRequest().bindingKey()) > 1;
-    }
-
-    /**
-     * If there is a cycle, the segment of the path that represents the cycle. The first request's
-     * and the last request's binding keys are equal. The last request is the current request.
-     *
-     * @throws IllegalStateException if {@link #hasCycle()} is {@code false}
-     */
-    FluentIterable<ResolvedRequest> cycle() {
-      checkState(hasCycle(), "no cycle");
-      return resolvedRequests()
-          .skip(indexOf(keyPath, Predicates.equalTo(current().dependencyRequest().bindingKey())));
-    }
-
-    /**
-     * Makes {@code request} the current request. Be sure to call {@link #pop()} to back up to the
-     * previous request in the path.
-     */
-    void push(DependencyRequest request, ResolvedBindings resolvedBindings) {
-      path.add(
-          ResolvedRequest.create(
-              request,
-              resolvedBindings,
-              path.isEmpty()
-                  ? Optional.<ResolvedBindings>absent()
-                  : Optional.of(current().resolvedBindings())));
-      keyPath.add(request.bindingKey());
-    }
-
-    /** Makes the previous request the current request. */
-    void pop() {
-      verify(keyPath.remove(path.removeLast().dependencyRequest().bindingKey()));
-    }
-
-    /**
-     * Adds the current request to a set of visited requests, and returns {@code true} if the set
-     * didn't already contain it.
-     */
-    boolean visitCurrentDependencyRequest() {
-      return resolvedDependencyRequests.add(current().dependencyRequest());
-    }
-
-    int size() {
-      return path.size();
-    }
-
-    /** Returns the resolved dependency requests in this path, starting with the entry point. */
-    FluentIterable<ResolvedRequest> resolvedRequests() {
-      return FluentIterable.from(path);
-    }
-  }
-
-  private final class Validation {
-    final BindingGraph subject;
-    final ValidationReport.Builder<TypeElement> reportBuilder;
-    final Optional<Validation> parent;
-    final ImmutableMap<ComponentDescriptor, BindingGraph> subgraphsByComponentDescriptor;
-
-    Validation(BindingGraph subject, Optional<Validation> parent) {
-      this.subject = subject;
-      this.reportBuilder = ValidationReport.about(subject.componentType());
-      this.parent = parent;
-      this.subgraphsByComponentDescriptor =
-          Maps.uniqueIndex(subject.subgraphs(), BindingGraph::componentDescriptor);
-    }
-
-    Validation(BindingGraph topLevelGraph) {
-      this(topLevelGraph, Optional.<Validation>absent());
-    }
-
-    BindingGraph topLevelGraph() {
-      return parent.isPresent() ? parent.get().topLevelGraph() : subject;
-    }
-
-    ValidationReport.Builder<TypeElement> topLevelReport() {
-      return parent.isPresent() ? parent.get().topLevelReport() : reportBuilder;
+    @Override
+    protected BindingGraphTraverser bindingGraphTraverser(
+        ComponentTreePath componentPath, DependencyRequest entryPoint) {
+      return new BindingGraphValidation(componentPath, entryPoint);
     }
 
+    /** Returns a report that contains all validation messages found during traversal. */
     ValidationReport<TypeElement> buildReport() {
-      return reportBuilder.build();
+      ValidationReport.Builder<TypeElement> report =
+          ValidationReport.about(rootGraph.componentType());
+      reports.values().forEach(subreport -> report.addSubreport(subreport.build()));
+      return report.build();
     }
 
-    void validateSubgraph() {
-      validateComponentScope();
-      validateDependencyScopes();
-      validateComponentHierarchy();
-      validateBuilders();
-
-      for (ComponentMethodDescriptor componentMethod :
-           subject.componentDescriptor().componentMethods()) {
-        Optional<DependencyRequest> entryPoint = componentMethod.dependencyRequest();
-        if (entryPoint.isPresent()) {
-          traverseDependencyRequest(entryPoint.get(), new DependencyPath());
-        }
-      }
-
-      for (Map.Entry<ComponentMethodDescriptor, ComponentDescriptor> entry :
-          subject.componentDescriptor().subcomponentsByFactoryMethod().entrySet()) {
-        validateSubcomponentFactoryMethod(
-            entry.getKey().methodElement(), subgraphsByComponentDescriptor.get(entry.getValue()));
-      }
+    /** Returns the report builder for a (sub)component. */
+    private ValidationReport.Builder<TypeElement> report(BindingGraph graph) {
+      return reports.computeIfAbsent(
+          graph.componentDescriptor(),
+          descriptor -> ValidationReport.about(descriptor.componentDefinitionType()));
+    }
 
-      for (BindingGraph subgraph : subject.subgraphs()) {
-        Validation subgraphValidation = new Validation(subgraph, Optional.of(this));
-        subgraphValidation.validateSubgraph();
-        reportBuilder.addSubreport(subgraphValidation.buildReport());
-      }
+    @Override
+    protected void visitComponent(BindingGraph graph) {
+      validateComponentScope(graph);
+      validateDependencyScopes(graph);
+      validateComponentDependencyHierarchy(graph);
+      validateBuilders(graph);
+      super.visitComponent(graph);
     }
 
-    private void validateSubcomponentFactoryMethod(
-        ExecutableElement factoryMethod, BindingGraph subgraph) {
-      Set<TypeElement> missingModules = subgraph.componentRequirements()
-          .stream()
-          .filter(componentRequirement -> !subgraphFactoryMethodParameters(factoryMethod)
-              .contains(componentRequirement))
-          .filter(moduleType -> !componentCanMakeNewInstances(moduleType))
-          .collect(toSet());
+    @Override
+    protected void visitSubcomponentFactoryMethod(
+        BindingGraph graph, BindingGraph parent, ExecutableElement factoryMethod) {
+      Set<TypeElement> missingModules =
+          graph
+              .componentRequirements()
+              .stream()
+              .filter(
+                  componentRequirement ->
+                      !subgraphFactoryMethodParameters(parent, factoryMethod)
+                          .contains(componentRequirement))
+              .filter(moduleType -> !componentCanMakeNewInstances(moduleType))
+              .collect(toSet());
       if (!missingModules.isEmpty()) {
-        reportBuilder.addError(
-            String.format(
-                "%s requires modules which have no visible default constructors. "
-                    + "Add the following modules as parameters to this method: %s",
-                subgraph.componentType().getQualifiedName(),
-                missingModules.stream().map(Object::toString).collect(joining(", "))),
-            factoryMethod);
+        report(parent)
+            .addError(
+                String.format(
+                    "%s requires modules which have no visible default constructors. "
+                        + "Add the following modules as parameters to this method: %s",
+                    graph.componentType().getQualifiedName(),
+                    missingModules.stream().map(Object::toString).collect(joining(", "))),
+                factoryMethod);
       }
     }
 
     private ImmutableSet<TypeElement> subgraphFactoryMethodParameters(
-        ExecutableElement factoryMethod) {
-      DeclaredType componentType = asDeclared(subject.componentType().asType());
+        BindingGraph parent, ExecutableElement childFactoryMethod) {
+      DeclaredType componentType = asDeclared(parent.componentType().asType());
       ExecutableType factoryMethodType =
-          asExecutable(types.asMemberOf(componentType, factoryMethod));
+          asExecutable(types.asMemberOf(componentType, childFactoryMethod));
       return asTypeElements(factoryMethodType.getParameterTypes());
     }
 
-    /**
-     * Traverse the resolved dependency requests, validating resolved bindings, and reporting any
-     * cycles found.
-     *
-     * @param request the current dependency request
-     */
-    private void traverseDependencyRequest(DependencyRequest request, DependencyPath path) {
-      path.push(request, resolvedBindings(request));
-      try {
-        if (path.hasCycle()) {
-          reportCycle(path);
-          return;
-        }
-
-        if (path.visitCurrentDependencyRequest()) {
-          validateResolvedBindings(path);
-
-          // Validate all dependencies within the component that owns the binding.
-          path.current()
-              .resolvedBindings()
-              .allBindings()
-              .asMap()
-              .forEach(
-                  (component, bindings) -> {
-                    Validation validation = validationForComponent(component);
-                    for (Binding binding : bindings) {
-                      for (DependencyRequest nextRequest : binding.dependencies()) {
-                        validation.traverseDependencyRequest(nextRequest, path);
-                      }
-                    }
-                  });
-        }
-      } finally {
-        path.pop();
-      }
-    }
-
-    private ResolvedBindings resolvedBindings(DependencyRequest request) {
-      BindingKey bindingKey = request.bindingKey();
-      ResolvedBindings resolvedBindings = subject.resolvedBindings().get(bindingKey);
-      return resolvedBindings == null
-          ? ResolvedBindings.noBindings(bindingKey, subject.componentDescriptor())
-          : resolvedBindings;
-    }
-
-    private Validation validationForComponent(ComponentDescriptor component) {
-      if (component.equals(subject.componentDescriptor())) {
-        return this;
-      } else if (parent.isPresent()) {
-        return parent.get().validationForComponent(component);
-      } else {
-        throw new IllegalArgumentException(
-            String.format(
-                "unknown component %s within %s",
-                component.componentDefinitionType(), subject.componentType()));
-      }
+    /** Validates that component dependencies do not form a cycle. */
+    private void validateComponentDependencyHierarchy(BindingGraph graph) {
+      validateComponentDependencyHierarchy(graph, graph.componentType(), new ArrayDeque<>());
     }
 
-    /**
-     * Reports errors if the set of bindings resolved is inconsistent with the type of the binding.
-     */
-    private void validateResolvedBindings(DependencyPath path) {
-      ResolvedBindings resolvedBindings = path.current().resolvedBindings();
-      if (resolvedBindings.isEmpty()) {
-        reportMissingBinding(path);
-        return;
-      }
-
-      switch (resolvedBindings.bindingKey().kind()) {
-        case CONTRIBUTION:
-          if (Iterables.any(
-              resolvedBindings.bindings(), MEMBERS_INJECTION::isOfType)) {
-            // TODO(dpb): How could this ever happen, even in an invalid graph?
-            throw new AssertionError(
-                "contribution binding keys should never have members injection bindings");
-          }
-          validateNullability(path, resolvedBindings.contributionBindings());
-          if (resolvedBindings.contributionBindings().size() > 1) {
-            reportDuplicateBindings(path);
-            return;
-          }
-          ContributionBinding contributionBinding = resolvedBindings.contributionBinding();
-          if (contributionBinding.bindingKind().equals(INJECTION)) {
-            TypeMirror type = contributionBinding.key().type();
-            ValidationReport<TypeElement> report =
-                injectValidator.validateType(MoreTypes.asTypeElement(type));
-            if (!report.isClean()) {
-              reportBuilder.addSubreport(report);
-              return;
-            }
-          }
-          if (contributionBinding.bindingType().equals(PRODUCTION)
-              && doesPathRequireProvisionOnly(path)) {
-            reportProviderMayNotDependOnProducer(path, contributionBinding);
-            return;
-          }
-          // TODO(dpb,beder): Validate this during @Inject/@Provides/@Produces validation.
-          if (compilerOptions.usesProducers()) {
-            Key productionImplementationExecutorKey =
-                keyFactory.forProductionImplementationExecutor();
-            // only forbid depending on the production executor if it's not the Dagger-specific
-            // binding to the implementation
-            if (!contributionBinding.key().equals(productionImplementationExecutorKey)) {
-              Key productionExecutorKey = keyFactory.forProductionExecutor();
-              for (DependencyRequest request : contributionBinding.explicitDependencies()) {
-                if (request.key().equals(productionExecutorKey)
-                    || request.key().equals(productionImplementationExecutorKey)) {
-                  reportDependsOnProductionExecutor(path);
-                  return;
-                }
-              }
-            }
-          }
-          if (contributionBinding.bindingKind().equals(SYNTHETIC_MULTIBOUND_MAP)) {
-            validateMapKeys(path, contributionBinding);
-          }
-          break;
-        case MEMBERS_INJECTION:
-          if (!Iterables.all(resolvedBindings.bindings(), MEMBERS_INJECTION::isOfType)) {
-            // TODO(dpb): How could this ever happen, even in an invalid graph?
-            throw new AssertionError(
-                "members injection binding keys should never have contribution bindings");
-          }
-          if (resolvedBindings.bindings().size() > 1) {
-            reportDuplicateBindings(path);
-            return;
-          }
-          validateMembersInjectionBinding(resolvedBindings.membersInjectionBinding().get(), path);
-          return;
-        default:
-          throw new AssertionError();
-      }
-    }
-
-    /**
-     * Returns the binding declarations that can be reported for {@code resolvedBindings}, indexed
-     * by the component that owns each declaration.
-     *
-     * <p>Contains all {@link MultibindingDeclaration}s, {@link SubcomponentDeclaration}s, and
-     * {@link OptionalBindingDeclaration}s within {@code resolvedBindings}, as well as all {@link
-     * ContributionBinding}s with present {@linkplain BindingDeclaration#bindingElement() binding
-     * elements}.
-     *
-     *
-     * <p>For other bindings without binding elements, such as the {@link
-     * ContributionBinding.Kind#SYNTHETIC_MULTIBOUND_KINDS}, includes the conflicting declarations
-     * in their resolved dependencies.
-     */
-    private ImmutableSetMultimap<ComponentDescriptor, BindingDeclaration> reportableDeclarations(
-        ResolvedBindings resolvedBindings) {
-      ImmutableSetMultimap.Builder<ComponentDescriptor, BindingDeclaration> declarations =
-          ImmutableSetMultimap.builder();
-
-      Queue<ResolvedBindings> queue = new ArrayDeque<>();
-      queue.add(resolvedBindings);
-
-      while (!queue.isEmpty()) {
-        ResolvedBindings queued = queue.remove();
-        declarations
-            .putAll(queued.owningComponent(), queued.multibindingDeclarations())
-            .putAll(queued.owningComponent(), queued.subcomponentDeclarations())
-            .putAll(queued.owningComponent(), queued.optionalBindingDeclarations());
-        queued
-            .allContributionBindings()
-            .asMap()
-            .forEach(
-                (owningComponent, bindings) -> {
-                  BindingGraph owningGraph = validationForComponent(owningComponent).subject;
-                  for (ContributionBinding binding : bindings) {
-                    if (bindingDeclarationFormatter.canFormat(binding)) {
-                      declarations.put(owningComponent, binding);
-                    } else {
-                      for (DependencyRequest dependency : binding.dependencies()) {
-                        queue.add(owningGraph.resolvedBindings().get(dependency.bindingKey()));
-                      }
-                    }
-                  }
-                });
-      }
-
-      return declarations.build();
-    }
-
-    /**
-     * Ensures that if the current request isn't nullable, then each contribution is also not
-     * nullable.
-     */
-    private void validateNullability(DependencyPath path, Set<ContributionBinding> bindings) {
-      if (path.current().dependencyRequest().isNullable()) {
-        return;
-      }
-
-      // Note: the method signature will include the @Nullable in it!
-      /* TODO(sameb): Sometimes javac doesn't include the Element in its output.
-       * (Maybe this happens if the code was already compiled before this point?)
-       * ... we manually print out the request in that case, otherwise the error
-       * message is kind of useless. */
-      String typeName = TypeName.get(path.current().dependencyRequest().key().type()).toString();
-
-      for (ContributionBinding binding : bindings) {
-        if (binding.nullableType().isPresent()) {
-          owningReportBuilder(
-                  path.current()
-                      .dependentBindings()
-                      .filter(ContributionBinding.class)
-                      .append(binding))
-              .addItem(
-                  nullableToNonNullable(typeName, bindingDeclarationFormatter.format(binding))
-                      + "\n at: "
-                      + dependencyRequestFormatter.toDependencyTrace(path),
-                  compilerOptions.nullableValidationKind(),
-                  path.entryPointElement());
-        }
-      }
-    }
-
-    private void validateMapKeys(
-        DependencyPath path, ContributionBinding binding) {
-      checkArgument(binding.bindingKind().equals(SYNTHETIC_MULTIBOUND_MAP),
-          "binding must be a synthetic multibound map: %s",
-          binding);
-      ImmutableSet.Builder<ContributionBinding> multibindingContributionsBuilder =
-          ImmutableSet.builder();
-      for (DependencyRequest dependency : binding.explicitDependencies()) {
-        multibindingContributionsBuilder.add(
-            subject.resolvedBindings().get(dependency.bindingKey()).contributionBinding());
-      }
-      ImmutableSet<ContributionBinding> multibindingContributions =
-          multibindingContributionsBuilder.build();
-      validateMapKeySet(path, multibindingContributions);
-      validateMapKeyAnnotationTypes(path, multibindingContributions);
-    }
-
-    /**
-     * Reports errors if {@code mapBindings} has more than one binding for the same map key.
-     */
-    private void validateMapKeySet(DependencyPath path, Set<ContributionBinding> mapBindings) {
-      for (Collection<ContributionBinding> mapBindingsForMapKey :
-          indexMapBindingsByMapKey(mapBindings).asMap().values()) {
-        if (mapBindingsForMapKey.size() > 1) {
-          reportDuplicateMapKeys(path, mapBindingsForMapKey);
-        }
-      }
-    }
-
-    /**
-     * Reports errors if {@code mapBindings} uses more than one {@link MapKey} annotation type.
-     */
-    private void validateMapKeyAnnotationTypes(
-        DependencyPath path, Set<ContributionBinding> contributionBindings) {
-      ImmutableSetMultimap<Equivalence.Wrapper<DeclaredType>, ContributionBinding>
-          mapBindingsByAnnotationType = indexMapBindingsByAnnotationType(contributionBindings);
-      if (mapBindingsByAnnotationType.keySet().size() > 1) {
-        reportInconsistentMapKeyAnnotations(path, mapBindingsByAnnotationType);
-      }
-    }
-
-    /** Reports errors if a members injection binding is invalid. */
-    // TODO(dpb): Can this be done while validating @Inject?
-    private void validateMembersInjectionBinding(
-        final MembersInjectionBinding binding, final DependencyPath path) {
-      binding
-          .key()
-          .type()
-          .accept(
-              new SimpleTypeVisitor6<Void, Void>() {
-                @Override
-                protected Void defaultAction(TypeMirror e, Void p) {
-                  reportBuilder.addError(
-                      "Invalid members injection request.", binding.membersInjectedType());
-                  return null;
-                }
-
-                @Override
-                public Void visitDeclared(DeclaredType type, Void ignored) {
-                  // If the key has type arguments, validate that each type argument is declared.
-                  // Otherwise the type argument may be a wildcard (or other type), and we can't
-                  // resolve that to actual types.  If the arg was an array, validate the type
-                  // of the array.
-                  for (TypeMirror arg : type.getTypeArguments()) {
-                    boolean declared;
-                    switch (arg.getKind()) {
-                      case ARRAY:
-                        declared =
-                            MoreTypes.asArray(arg)
-                                .getComponentType()
-                                .accept(
-                                    new SimpleTypeVisitor6<Boolean, Void>() {
-                                      @Override
-                                      protected Boolean defaultAction(TypeMirror e, Void p) {
-                                        return false;
-                                      }
-
-                                      @Override
-                                      public Boolean visitDeclared(DeclaredType t, Void p) {
-                                        for (TypeMirror arg : t.getTypeArguments()) {
-                                          if (!arg.accept(this, null)) {
-                                            return false;
-                                          }
-                                        }
-                                        return true;
-                                      }
-
-                                      @Override
-                                      public Boolean visitArray(ArrayType t, Void p) {
-                                        return t.getComponentType().accept(this, null);
-                                      }
-
-                                      @Override
-                                      public Boolean visitPrimitive(PrimitiveType t, Void p) {
-                                        return true;
-                                      }
-                                    },
-                                    null);
-                        break;
-                      case DECLARED:
-                        declared = true;
-                        break;
-                      default:
-                        declared = false;
-                    }
-                    if (!declared) {
-                      reportBuilder.addError(
-                          String.format(
-                              MEMBERS_INJECTION_WITH_UNBOUNDED_TYPE,
-                              arg.toString(),
-                              type.toString(),
-                              dependencyRequestFormatter.toDependencyTrace(path)),
-                          path.entryPointElement());
-                      return null;
-                    }
-                  }
-
-                  TypeElement element = MoreElements.asType(type.asElement());
-                  // Also validate that the key is not the erasure of a generic type.
-                  // If it is, that means the user referred to Foo<T> as just 'Foo',
-                  // which we don't allow.  (This is a judgement call -- we *could*
-                  // allow it and instantiate the type bounds... but we don't.)
-                  if (!MoreTypes.asDeclared(element.asType()).getTypeArguments().isEmpty()
-                      && types.isSameType(types.erasure(element.asType()), type)) {
-                    reportBuilder.addError(
-                        String.format(
-                            ErrorMessages.MEMBERS_INJECTION_WITH_RAW_TYPE,
-                            type.toString(),
-                            dependencyRequestFormatter.toDependencyTrace(path)),
-                        path.entryPointElement());
-                  }
-                  return null;
-                }
-              },
-              null);
-    }
-
-    /**
-     * Validates that component dependencies do not form a cycle.
-     */
-    private void validateComponentHierarchy() {
-      ComponentDescriptor descriptor = subject.componentDescriptor();
-      TypeElement componentType = descriptor.componentDefinitionType();
-      validateComponentHierarchy(componentType, componentType, new ArrayDeque<TypeElement>());
-    }
-
-    /**
-     * Recursive method to validate that component dependencies do not form a cycle.
-     */
-    private void validateComponentHierarchy(
-        TypeElement rootComponent,
-        TypeElement componentType,
-        Deque<TypeElement> componentStack) {
-
-      if (componentStack.contains(componentType)) {
+    /** Recursive method to validate that component dependencies do not form a cycle. */
+    private void validateComponentDependencyHierarchy(
+        BindingGraph graph, TypeElement dependency, Deque<TypeElement> dependencyStack) {
+      if (dependencyStack.contains(dependency)) {
         // Current component has already appeared in the component chain.
         StringBuilder message = new StringBuilder();
-        message.append(rootComponent.getQualifiedName());
+        message.append(graph.componentType().getQualifiedName());
         message.append(" contains a cycle in its component dependencies:\n");
-        componentStack.push(componentType);
-        appendIndentedComponentsList(message, componentStack);
-        componentStack.pop();
-        reportBuilder.addItem(
-            message.toString(),
-            compilerOptions.scopeCycleValidationType().diagnosticKind().get(),
-            rootComponent,
-            getComponentAnnotation(rootComponent).get());
+        dependencyStack.push(dependency);
+        appendIndentedComponentsList(message, dependencyStack);
+        dependencyStack.pop();
+        report(graph)
+            .addItem(
+                message.toString(),
+                compilerOptions.scopeCycleValidationType().diagnosticKind().get(),
+                graph.componentType(),
+                getComponentAnnotation(graph.componentType()).get());
       } else {
-        Optional<AnnotationMirror> componentAnnotation = getComponentAnnotation(componentType);
+        Optional<AnnotationMirror> componentAnnotation = getComponentAnnotation(dependency);
         if (componentAnnotation.isPresent()) {
-          componentStack.push(componentType);
+          dependencyStack.push(dependency);
 
           ImmutableSet<TypeElement> dependencies =
               MoreTypes.asTypeElements(getComponentDependencies(componentAnnotation.get()));
-          for (TypeElement dependency : dependencies) {
-            validateComponentHierarchy(rootComponent, dependency, componentStack);
+          for (TypeElement nextDependency : dependencies) {
+            validateComponentDependencyHierarchy(graph, nextDependency, dependencyStack);
           }
 
-          componentStack.pop();
+          dependencyStack.pop();
         }
       }
     }
 
     /**
-     * Validates that among the dependencies are at most one scoped dependency,
-     * that there are no cycles within the scoping chain, and that singleton
-     * components have no scoped dependencies.
+     * Validates that among the dependencies are at most one scoped dependency, that there are no
+     * cycles within the scoping chain, and that singleton components have no scoped dependencies.
      */
-    private void validateDependencyScopes() {
-      ComponentDescriptor descriptor = subject.componentDescriptor();
+    private void validateDependencyScopes(BindingGraph graph) {
+      ComponentDescriptor descriptor = graph.componentDescriptor();
       ImmutableSet<Scope> scopes = descriptor.scopes();
       ImmutableSet<TypeElement> scopedDependencies = scopedTypesIn(descriptor.dependencies());
       if (!scopes.isEmpty()) {
@@ -724,11 +273,12 @@ private void validateDependencyScopes() {
             StringBuilder message = new StringBuilder(
                 "This @Singleton component cannot depend on scoped components:\n");
             appendIndentedComponentsList(message, scopedDependencies);
-            reportBuilder.addItem(
-                message.toString(),
-                compilerOptions.scopeCycleValidationType().diagnosticKind().get(),
-                descriptor.componentDefinitionType(),
-                descriptor.componentAnnotation());
+            report(graph)
+                .addItem(
+                    message.toString(),
+                    compilerOptions.scopeCycleValidationType().diagnosticKind().get(),
+                    descriptor.componentDefinitionType(),
+                    descriptor.componentAnnotation());
           }
         } else if (scopedDependencies.size() > 1) {
           // Scoped components may depend on at most one scoped component.
@@ -740,14 +290,16 @@ private void validateDependencyScopes() {
               .append(descriptor.componentDefinitionType().getQualifiedName())
               .append(" depends on more than one scoped component:\n");
           appendIndentedComponentsList(message, scopedDependencies);
-          reportBuilder.addError(
-              message.toString(),
-              descriptor.componentDefinitionType(),
-              descriptor.componentAnnotation());
+          report(graph)
+              .addError(
+                  message.toString(),
+                  descriptor.componentDefinitionType(),
+                  descriptor.componentAnnotation());
         } else {
           // Dagger 1.x scope compatibility requires this be suppress-able.
           if (!compilerOptions.scopeCycleValidationType().equals(ValidationType.NONE)) {
-            validateScopeHierarchy(descriptor.componentDefinitionType(),
+            validateDependencyScopeHierarchy(
+                graph,
                 descriptor.componentDefinitionType(),
                 new ArrayDeque<ImmutableSet<Scope>>(),
                 new ArrayDeque<TypeElement>());
@@ -760,49 +312,50 @@ private void validateDependencyScopes() {
               new StringBuilder(descriptor.componentDefinitionType().getQualifiedName())
                   .append(" (unscoped) cannot depend on scoped components:\n");
           appendIndentedComponentsList(message, scopedDependencies);
-          reportBuilder.addError(
-              message.toString(),
-              descriptor.componentDefinitionType(),
-              descriptor.componentAnnotation());
+          report(graph)
+              .addError(
+                  message.toString(),
+                  descriptor.componentDefinitionType(),
+                  descriptor.componentAnnotation());
         }
       }
     }
 
-    private void validateBuilders() {
-      ComponentDescriptor componentDesc = subject.componentDescriptor();
+    private void validateBuilders(BindingGraph graph) {
+      ComponentDescriptor componentDesc = graph.componentDescriptor();
       if (!componentDesc.builderSpec().isPresent()) {
         // If no builder, nothing to validate.
         return;
       }
 
-      Set<TypeElement> availableDependencies = subject.availableDependencies();
+      Set<TypeElement> availableDependencies = graph.availableDependencies();
       Set<TypeElement> requiredDependencies =
           Sets.filter(availableDependencies, input -> !componentCanMakeNewInstances(input));
       final BuilderSpec spec = componentDesc.builderSpec().get();
       Map<TypeElement, ExecutableElement> allSetters = spec.methodMap();
 
       ErrorMessages.ComponentBuilderMessages msgs =
-          ErrorMessages.builderMsgsFor(subject.componentDescriptor().kind());
+          ErrorMessages.builderMsgsFor(graph.componentDescriptor().kind());
       Set<TypeElement> extraSetters = Sets.difference(allSetters.keySet(), availableDependencies);
       if (!extraSetters.isEmpty()) {
         Collection<ExecutableElement> excessMethods =
             Maps.filterKeys(allSetters, Predicates.in(extraSetters)).values();
-        Iterable<String> formatted =
-            FluentIterable.from(excessMethods)
-                .transform(
-                    method ->
-                        methodSignatureFormatter.format(
-                            method,
-                            Optional.of(
-                                MoreTypes.asDeclared(spec.builderDefinitionType().asType()))));
-        reportBuilder.addError(
-            String.format(msgs.extraSetters(), formatted), spec.builderDefinitionType());
+        Optional<DeclaredType> container =
+            Optional.of(MoreTypes.asDeclared(spec.builderDefinitionType().asType()));
+        String formatted =
+            excessMethods
+                .stream()
+                .map(method -> methodSignatureFormatter.format(method, container))
+                .collect(joining(", ", "[", "]"));
+        report(graph)
+            .addError(String.format(msgs.extraSetters(), formatted), spec.builderDefinitionType());
       }
 
       Set<TypeElement> missingSetters = Sets.difference(requiredDependencies, allSetters.keySet());
       if (!missingSetters.isEmpty()) {
-        reportBuilder.addError(
-            String.format(msgs.missingSetters(), missingSetters), spec.builderDefinitionType());
+        report(graph)
+            .addError(
+                String.format(msgs.missingSetters(), missingSetters), spec.builderDefinitionType());
       }
     }
 
@@ -812,42 +365,44 @@ private void validateBuilders() {
      *
      * <p>As a side-effect, this means scoped components cannot have a dependency cycle between
      * themselves, since a component's presence within its own dependency path implies a cyclical
-     * relationship between scopes. However, cycles in component dependencies are explicitly
-     * checked in {@link #validateComponentHierarchy()}.
+     * relationship between scopes. However, cycles in component dependencies are explicitly checked
+     * in {@link #validateComponentDependencyHierarchy(BindingGraph)}.
      */
-    private void validateScopeHierarchy(TypeElement rootComponent,
-        TypeElement componentType,
+    private void validateDependencyScopeHierarchy(
+        BindingGraph graph,
+        TypeElement dependency,
         Deque<ImmutableSet<Scope>> scopeStack,
         Deque<TypeElement> scopedDependencyStack) {
-      ImmutableSet<Scope> scopes = Scope.scopesOf(componentType);
+      ImmutableSet<Scope> scopes = Scope.scopesOf(dependency);
       if (stackOverlaps(scopeStack, scopes)) {
-        scopedDependencyStack.push(componentType);
+        scopedDependencyStack.push(dependency);
         // Current scope has already appeared in the component chain.
         StringBuilder message = new StringBuilder();
-        message.append(rootComponent.getQualifiedName());
+        message.append(graph.componentType().getQualifiedName());
         message.append(" depends on scoped components in a non-hierarchical scope ordering:\n");
         appendIndentedComponentsList(message, scopedDependencyStack);
         if (compilerOptions.scopeCycleValidationType().diagnosticKind().isPresent()) {
-          reportBuilder.addItem(
-              message.toString(),
-              compilerOptions.scopeCycleValidationType().diagnosticKind().get(),
-              rootComponent,
-              getComponentAnnotation(rootComponent).get());
+          report(graph)
+              .addItem(
+                  message.toString(),
+                  compilerOptions.scopeCycleValidationType().diagnosticKind().get(),
+                  graph.componentType(),
+                  getComponentAnnotation(graph.componentType()).get());
         }
         scopedDependencyStack.pop();
       } else {
         // TODO(beder): transitively check scopes of production components too.
         Optional<AnnotationMirror> componentAnnotation =
-            getAnnotationMirror(componentType, Component.class);
+            getAnnotationMirror(dependency, Component.class);
         if (componentAnnotation.isPresent()) {
           ImmutableSet<TypeElement> scopedDependencies = scopedTypesIn(
               MoreTypes.asTypeElements(getComponentDependencies(componentAnnotation.get())));
           if (scopedDependencies.size() == 1) {
             // empty can be ignored (base-case), and > 1 is a different error reported separately.
             scopeStack.push(scopes);
-            scopedDependencyStack.push(componentType);
-            validateScopeHierarchy(rootComponent, getOnlyElement(scopedDependencies),
-                scopeStack, scopedDependencyStack);
+            scopedDependencyStack.push(dependency);
+            validateDependencyScopeHierarchy(
+                graph, getOnlyElement(scopedDependencies), scopeStack, scopedDependencyStack);
             scopedDependencyStack.pop();
             scopeStack.pop();
           }
@@ -866,11 +421,13 @@ private void validateScopeHierarchy(TypeElement rootComponent,
 
     /**
      * Validates that the scope (if any) of this component are compatible with the scopes of the
-     * bindings available in this component
+     * bindings available in this component.
      */
-    void validateComponentScope() {
-      ImmutableMap<BindingKey, ResolvedBindings> resolvedBindings = subject.resolvedBindings();
-      ImmutableSet<Scope> componentScopes = subject.componentDescriptor().scopes();
+    // TODO(dpb): Do this instead during visitContributionBindings, building up an error to report
+    // at the end.
+    private void validateComponentScope(BindingGraph graph) {
+      ImmutableMap<BindingKey, ResolvedBindings> resolvedBindings = graph.resolvedBindings();
+      ImmutableSet<Scope> componentScopes = graph.componentDescriptor().scopes();
       ImmutableSet.Builder<String> incompatiblyScopedMethodsBuilder = ImmutableSet.builder();
       Scope reusableScope = reusableScope(elements);
       for (ResolvedBindings bindings : resolvedBindings.values()) {
@@ -905,7 +462,7 @@ void validateComponentScope() {
 
       ImmutableSet<String> incompatiblyScopedMethods = incompatiblyScopedMethodsBuilder.build();
       if (!incompatiblyScopedMethods.isEmpty()) {
-        TypeElement componentType = subject.componentType();
+        TypeElement componentType = graph.componentType();
         StringBuilder message = new StringBuilder(componentType.getQualifiedName());
         if (!componentScopes.isEmpty()) {
           message.append(" scoped with ");
@@ -919,303 +476,565 @@ void validateComponentScope() {
         for (String method : incompatiblyScopedMethods) {
           message.append(ErrorMessages.INDENT).append(method).append("\n");
         }
-        reportBuilder.addError(
-            message.toString(), componentType, subject.componentDescriptor().componentAnnotation());
+        report(graph)
+            .addError(
+                message.toString(),
+                componentType,
+                graph.componentDescriptor().componentAnnotation());
       }
     }
 
-    @SuppressWarnings("resource") // Appendable is a StringBuilder.
-    // TODO(b/29509141): Clarify the error.
-    private void reportProviderMayNotDependOnProducer(
-        DependencyPath path, ContributionBinding productionBinding) {
-      if (path.size() == 1) {
-        reportBuilder.addError(
-            String.format(
-                PROVIDER_ENTRY_POINT_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT,
-                formatCurrentDependencyRequestKey(path)),
-            path.entryPointElement());
-      } else {
-        FluentIterable<ContributionBinding> dependentProvisions =
-            provisionsDependingOnLatestRequest(path);
-        // TODO(beder): Consider displaying all dependent provisions in the error message. If we
-        // do that, should we display all productions that depend on them also?
-        owningReportBuilder(dependentProvisions.append(productionBinding))
-            .addError(
-                String.format(
-                    PROVIDER_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT,
-                    dependentProvisions.iterator().next().key()),
-                path.entryPointElement());
+    final class BindingGraphValidation extends BindingGraphTraverser {
+
+      BindingGraphValidation(ComponentTreePath componentPath, DependencyRequest entryPoint) {
+        super(componentPath, entryPoint);
       }
-    }
 
-    /**
-     * Descriptive portion of the error message for when the given request has no binding.
-     * Currently, the only other portions of the message are the dependency path, line number and
-     * filename. Not static because it uses the instance field types.
-     */
-    private StringBuilder requiresErrorMessageBase(DependencyPath path) {
-      Key key = path.current().dependencyRequest().key();
-      String requiresErrorMessageFormat;
-      // TODO(dpb): Check for wildcard injection somewhere else first?
-      if (key.type().getKind().equals(TypeKind.WILDCARD)) {
-        requiresErrorMessageFormat = CANNOT_INJECT_WILDCARD_TYPE;
-      } else {
-        boolean requiresProvision = doesPathRequireProvisionOnly(path);
-        if (!key.isValidImplicitProvisionKey(types)) {
-          requiresErrorMessageFormat = requiresProvision
-              ? REQUIRES_PROVIDER_FORMAT
-              : REQUIRES_PROVIDER_OR_PRODUCER_FORMAT;
-        } else {
-          requiresErrorMessageFormat = requiresProvision
-              ? REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_FORMAT
-              : REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_OR_PRODUCER_FORMAT;
+      /** Reports an error for the current component at the entry point. */
+      private void reportErrorAtEntryPoint(String format, Object... args) {
+        reportErrorAtEntryPoint(currentGraph(), format, args);
+      }
+
+      /** Reports an error for the given component at the entry point. */
+      private void reportErrorAtEntryPoint(BindingGraph graph, String format, Object... args) {
+        String message = args.length == 0 ? format : String.format(format, args);
+        report(graph).addError(message, entryPointElement());
+      }
+
+      private String formatDependencyTrace() {
+        return dependencyRequestFormatter.format(dependencyTrace());
+      }
+
+      @Override
+      protected void visitDependencyRequest(DependencyRequest dependencyRequest) {
+        if (atDependencyCycle()) {
+          reportDependencyCycle();
         }
+        super.visitDependencyRequest(dependencyRequest);
       }
-      StringBuilder errorMessage =
-          new StringBuilder(
-              String.format(requiresErrorMessageFormat, formatCurrentDependencyRequestKey(path)));
-      if (key.isValidMembersInjectionKey()) {
-        Optional<MembersInjectionBinding> membersInjectionBinding =
-            injectBindingRegistry.getOrFindMembersInjectionBinding(key);
-        if (membersInjectionBinding.isPresent()
-            && !membersInjectionBinding.get().injectionSites().isEmpty()) {
-          errorMessage.append(" ");
-          errorMessage.append(ErrorMessages.MEMBERS_INJECTION_DOES_NOT_IMPLY_PROVISION);
+
+      @Override
+      protected void visitResolvedBindings(ResolvedBindings resolvedBindings) {
+        if (resolvedBindings.isEmpty()) {
+          reportMissingBinding();
+        } else if (resolvedBindings.bindings().size() > 1) {
+          reportDuplicateBindings();
         }
+        super.visitResolvedBindings(resolvedBindings);
       }
-      return errorMessage.append('\n');
-    }
 
-    private void reportMissingBinding(DependencyPath path) {
-      StringBuilder errorMessage =
-          requiresErrorMessageBase(path).append(dependencyRequestFormatter.toDependencyTrace(path));
-      for (String suggestion :
-          MissingBindingSuggestions.forKey(
-              topLevelGraph(), path.current().dependencyRequest().bindingKey())) {
-        errorMessage.append('\n').append(suggestion);
+      @Override
+      protected void visitContributionBinding(
+          ContributionBinding binding, ComponentDescriptor owningComponent) {
+        if (!dependencyRequest().isNullable() && binding.nullableType().isPresent()) {
+          reportNullableBindingForNonNullableRequest(binding);
+        }
+        if (binding.bindingKind().equals(INJECTION)) {
+          TypeMirror type = binding.key().type();
+          ValidationReport<TypeElement> report =
+              injectValidator.validateType(MoreTypes.asTypeElement(type));
+          if (!report.isClean()) {
+            report(currentGraph()).addSubreport(report);
+          }
+        }
+        if (binding.bindingType().equals(PRODUCTION) && doesPathRequireProvisionOnly()) {
+          reportProviderMayNotDependOnProducer(binding);
+        }
+        if (compilerOptions.usesProducers()) {
+          // TODO(dpb,beder): Validate this during @Inject/@Provides/@Produces validation.
+          // Only the Dagger-specific binding may depend on the production executor.
+          Key productionImplementationExecutorKey =
+              keyFactory.forProductionImplementationExecutor();
+          if (!binding.key().equals(productionImplementationExecutorKey)) {
+            Key productionExecutorKey = keyFactory.forProductionExecutor();
+            for (DependencyRequest request : binding.explicitDependencies()) {
+              if (request.key().equals(productionExecutorKey)
+                  || request.key().equals(productionImplementationExecutorKey)) {
+                reportDependsOnProductionExecutor();
+              }
+            }
+          }
+        }
+        if (binding.bindingKind().equals(SYNTHETIC_MULTIBOUND_MAP)) {
+          validateMapKeys(binding, owningComponent);
+        }
+        super.visitContributionBinding(binding, owningComponent);
       }
-      topLevelReport().addError(errorMessage.toString(), path.entryPointElement());
-    }
 
-    @SuppressWarnings("resource") // Appendable is a StringBuilder.
-    private void reportDependsOnProductionExecutor(DependencyPath path) {
-      reportBuilder.addError(
-          String.format(
-              DEPENDS_ON_PRODUCTION_EXECUTOR_FORMAT, formatCurrentDependencyRequestKey(path)),
-          path.entryPointElement());
-    }
+      @Override
+      protected void visitMembersInjectionBinding(
+          MembersInjectionBinding binding, ComponentDescriptor owningComponent) {
+        validateMembersInjectionBinding(binding);
+        super.visitMembersInjectionBinding(binding, owningComponent);
+      }
 
-    @SuppressWarnings("resource") // Appendable is a StringBuilder.
-    private void reportDuplicateBindings(DependencyPath path) {
-      ResolvedBindings resolvedBindings = path.current().resolvedBindings();
-      if (FluentIterable.from(resolvedBindings.contributionBindings())
-          .transform(ContributionBinding::bindingKind)
-          // TODO(dpb): Kill with fire.
-          .anyMatch(
-              kind -> SYNTHETIC_MULTIBOUND_KINDS.contains(kind) || SYNTHETIC_MAP.equals(kind))) {
-        // If any of the duplicate bindings results from multibinding contributions or declarations,
-        // report the conflict using those contributions and declarations.
-        reportMultipleContributionTypes(path);
-        return;
+      /**
+       * Returns the binding declarations that can be reported for {@code resolvedBindings}, indexed
+       * by the component that owns each declaration.
+       *
+       * <p>Contains all {@link MultibindingDeclaration}s, {@link SubcomponentDeclaration}s, and
+       * {@link OptionalBindingDeclaration}s within {@code resolvedBindings}, as well as all {@link
+       * ContributionBinding}s with present {@linkplain BindingDeclaration#bindingElement() binding
+       * elements}.
+       *
+       *
+       * <p>For other bindings without binding elements, such as the {@link
+       * ContributionBinding.Kind#SYNTHETIC_MULTIBOUND_KINDS}, includes the conflicting declarations
+       * in their resolved dependencies.
+       */
+      private ImmutableSetMultimap<ComponentDescriptor, BindingDeclaration>
+          reportableDeclarations() {
+        ImmutableSetMultimap.Builder<ComponentDescriptor, BindingDeclaration> declarations =
+            ImmutableSetMultimap.builder();
+
+        Queue<ResolvedBindings> queue = new ArrayDeque<>();
+        queue.add(resolvedBindings());
+
+        while (!queue.isEmpty()) {
+          ResolvedBindings queued = queue.remove();
+          declarations
+              .putAll(queued.owningComponent(), queued.multibindingDeclarations())
+              .putAll(queued.owningComponent(), queued.subcomponentDeclarations())
+              .putAll(queued.owningComponent(), queued.optionalBindingDeclarations());
+          queued
+              .allContributionBindings()
+              .asMap()
+              .forEach(
+                  (owningComponent, bindings) -> {
+                    BindingGraph owningGraph =
+                        componentTreePath().graphForComponent(owningComponent);
+                    for (ContributionBinding binding : bindings) {
+                      if (bindingDeclarationFormatter.canFormat(binding)) {
+                        declarations.put(owningComponent, binding);
+                      } else {
+                        queue.addAll(owningGraph.resolvedDependencies(binding));
+                      }
+                    }
+                  });
+        }
+
+        return declarations.build();
       }
-      StringBuilder builder = new StringBuilder();
-      new Formatter(builder)
-          .format(DUPLICATE_BINDINGS_FOR_KEY_FORMAT, formatCurrentDependencyRequestKey(path));
-      ImmutableSetMultimap<ComponentDescriptor, BindingDeclaration> duplicateDeclarations =
-          reportableDeclarations(resolvedBindings);
-      bindingDeclarationFormatter.formatIndentedList(
-          builder, duplicateDeclarations.values(), 1, DUPLICATE_SIZE_LIMIT);
-      owningReportBuilder(duplicateDeclarations.keySet())
-          .addError(builder.toString(), path.entryPointElement());
-    }
 
-    /**
-     * Returns the report builder for the rootmost component that contains any of the {@code
-     * bindings}.
-     */
-    private ValidationReport.Builder<TypeElement> owningReportBuilder(
-        Iterable<ContributionBinding> bindings) {
-      ImmutableSet.Builder<ComponentDescriptor> owningComponentsBuilder = ImmutableSet.builder();
-      for (ContributionBinding binding : bindings) {
-        ResolvedBindings resolvedBindings =
-            subject.resolvedBindings().get(BindingKey.contribution(binding.key()));
-        owningComponentsBuilder.addAll(
-            resolvedBindings.allContributionBindings().inverse().get(binding));
+      private void reportNullableBindingForNonNullableRequest(ContributionBinding binding) {
+        // Note: the method signature will include the @Nullable in it!
+        /* TODO(sameb): Sometimes javac doesn't include the Element in its output.
+         * (Maybe this happens if the code was already compiled before this point?)
+         * ... we manually print out the request in that case, otherwise the error
+         * message is kind of useless. */
+        FluentIterable<ContributionBinding> dependentContributions =
+            FluentIterable.from(dependentBindings()).filter(ContributionBinding.class);
+        report(owningGraph(dependentContributions.append(binding)))
+            .addItem(
+                nullableToNonNullable(
+                        TypeName.get(dependencyRequest().key().type()).toString(),
+                        bindingDeclarationFormatter.format(binding))
+                    + "\n at: "
+                    + formatDependencyTrace(),
+                compilerOptions.nullableValidationKind(),
+                entryPointElement());
       }
-      return owningReportBuilder(owningComponentsBuilder.build());
-    }
 
-    private ValidationReport.Builder<TypeElement> owningReportBuilder(
-        Collection<ComponentDescriptor> owningComponents) {
-      for (Validation validation : validationPath()) {
-        if (owningComponents.contains(validation.subject.componentDescriptor())) {
-          return validation.reportBuilder;
+      private void validateMapKeys(
+          ContributionBinding binding, ComponentDescriptor owningComponent) {
+        checkArgument(
+            binding.bindingKind().equals(SYNTHETIC_MULTIBOUND_MAP),
+            "binding must be a synthetic multibound map: %s",
+            binding);
+        ImmutableSet<ContributionBinding> multibindingContributions =
+            componentTreePath()
+                .graphForComponent(owningComponent)
+                .resolvedDependencies(binding)
+                .stream()
+                .map(ResolvedBindings::contributionBinding)
+                .collect(toImmutableSet());
+        validateMapKeySet(multibindingContributions);
+        validateMapKeyAnnotationTypes(multibindingContributions);
+      }
+
+      /**
+       * Reports errors if there is more than one map binding contribution with the same map key.
+       */
+      private void validateMapKeySet(Set<ContributionBinding> mapBindingContributions) {
+        for (Collection<ContributionBinding> mapBindingsForMapKey :
+            indexMapBindingsByMapKey(mapBindingContributions).asMap().values()) {
+          if (mapBindingsForMapKey.size() > 1) {
+            reportDuplicateMapKeys(mapBindingsForMapKey);
+          }
         }
       }
-      throw new AssertionError("cannot find component: " + owningComponents);
-    }
 
-    /**
-     * The path from the {@link Validation} of the root graph down to this {@link Validation}.
-     */
-    private ImmutableList<Validation> validationPath() {
-      ImmutableList.Builder<Validation> validationPath = ImmutableList.builder();
-      for (Optional<Validation> validation = Optional.of(this);
-          validation.isPresent();
-          validation = validation.get().parent) {
-        validationPath.add(validation.get());
+      /**
+       * Reports errors if there is more than one {@link MapKey} annotation type within the map
+       * binding contributions' map keys.
+       */
+      private void validateMapKeyAnnotationTypes(Set<ContributionBinding> mapBindingContributions) {
+        ImmutableSetMultimap<Equivalence.Wrapper<DeclaredType>, ContributionBinding>
+            mapBindingsByAnnotationType = indexMapBindingsByAnnotationType(mapBindingContributions);
+        if (mapBindingsByAnnotationType.keySet().size() > 1) {
+          reportInconsistentMapKeyAnnotations(mapBindingsByAnnotationType);
+        }
       }
-      return validationPath.build().reverse();
-    }
 
-    @SuppressWarnings("resource") // Appendable is a StringBuilder.
-    private void reportMultipleContributionTypes(DependencyPath path) {
-      StringBuilder builder = new StringBuilder();
-      new Formatter(builder)
-          .format(
-              MULTIPLE_CONTRIBUTION_TYPES_FOR_KEY_FORMAT, formatCurrentDependencyRequestKey(path));
-      ImmutableSetMultimap<ComponentDescriptor, BindingDeclaration> duplicateDeclarations =
-          reportableDeclarations(path.current().resolvedBindings());
-      ImmutableListMultimap<ContributionType, BindingDeclaration> duplicateDeclarationsByType =
-          FluentIterable.from(duplicateDeclarations.values())
-              .index(
-                  declaration ->
-                      declaration instanceof HasContributionType
-                          ? ((HasContributionType) declaration).contributionType()
-                          : ContributionType.UNIQUE);
-      verify(
-          duplicateDeclarationsByType.keySet().size() > 1,
-          "expected multiple contribution types for %s: %s",
-          path.current().dependencyRequest().bindingKey(),
-          duplicateDeclarationsByType);
-      ImmutableSortedMap.copyOf(duplicateDeclarationsByType.asMap())
-          .forEach(
-              (contributionType, declarations) -> {
-                builder.append(INDENT);
-                builder.append(formatContributionType(contributionType));
-                builder.append(" bindings and declarations:");
-                bindingDeclarationFormatter.formatIndentedList(
-                    builder, declarations, 2, DUPLICATE_SIZE_LIMIT);
-                builder.append('\n');
-              });
-      owningReportBuilder(duplicateDeclarations.keySet())
-          .addError(builder.toString(), path.entryPointElement());
-    }
+      /** Reports errors if a members injection binding is invalid. */
+      // TODO(dpb): Can this be done while validating @Inject?
+      private void validateMembersInjectionBinding(MembersInjectionBinding binding) {
+        binding.key().type().accept(membersInjectionBindingValidator, binding);
+      }
 
-    private void reportDuplicateMapKeys(
-        DependencyPath path, Collection<ContributionBinding> mapBindings) {
-      StringBuilder builder = new StringBuilder();
-      builder.append(duplicateMapKeysError(formatCurrentDependencyRequestKey(path)));
-      bindingDeclarationFormatter.formatIndentedList(builder, mapBindings, 1, DUPLICATE_SIZE_LIMIT);
-      owningReportBuilder(mapBindings).addError(builder.toString(), path.entryPointElement());
-    }
+      private final TypeVisitor<Void, MembersInjectionBinding> membersInjectionBindingValidator =
+          new SimpleTypeVisitor8<Void, MembersInjectionBinding>() {
+            @Override
+            protected Void defaultAction(TypeMirror e, MembersInjectionBinding p) {
+              report(currentGraph())
+                  .addError("Invalid members injection request.", p.membersInjectedType());
+              return null;
+            }
+
+            @Override
+            public Void visitDeclared(DeclaredType type, MembersInjectionBinding binding) {
+              // If the key has type arguments, validate that each type argument is declared.
+              // Otherwise the type argument may be a wildcard (or other type), and we can't
+              // resolve that to actual types.  If the arg was an array, validate the type
+              // of the array.
+              for (TypeMirror arg : type.getTypeArguments()) {
+                boolean declared =
+                    arg.accept(
+                        new SimpleTypeVisitor8<Boolean, Void>(false) {
+                          @Override
+                          public Boolean visitArray(ArrayType t, Void p) {
+                            return t.getComponentType()
+                                .accept(
+                                    new SimpleTypeVisitor8<Boolean, Void>(false) {
+                                      @Override
+                                      public Boolean visitDeclared(DeclaredType t, Void p) {
+                                        for (TypeMirror arg : t.getTypeArguments()) {
+                                          if (!arg.accept(this, null)) {
+                                            return false;
+                                          }
+                                        }
+                                        return true;
+                                      }
+
+                                      @Override
+                                      public Boolean visitArray(ArrayType t, Void p) {
+                                        return t.getComponentType().accept(this, null);
+                                      }
+
+                                      @Override
+                                      public Boolean visitPrimitive(PrimitiveType t, Void p) {
+                                        return true;
+                                      }
+                                    },
+                                    null);
+                          }
+
+                          @Override
+                          public Boolean visitDeclared(DeclaredType t, Void p) {
+                            return true;
+                          }
+                        },
+                        null);
+                if (!declared) {
+                  reportErrorAtEntryPoint(
+                      MEMBERS_INJECTION_WITH_UNBOUNDED_TYPE,
+                      arg.toString(),
+                      type.toString(),
+                      formatDependencyTrace());
+                  return null;
+                }
+              }
+
+              TypeElement element = MoreElements.asType(type.asElement());
+              // Also validate that the key is not the erasure of a generic type.
+              // If it is, that means the user referred to Foo<T> as just 'Foo',
+              // which we don't allow.  (This is a judgement call -- we *could*
+              // allow it and instantiate the type bounds... but we don't.)
+              if (!MoreTypes.asDeclared(element.asType()).getTypeArguments().isEmpty()
+                  && types.isSameType(types.erasure(element.asType()), type)) {
+                reportErrorAtEntryPoint(
+                    MEMBERS_INJECTION_WITH_RAW_TYPE, type.toString(), formatDependencyTrace());
+              }
+              return null;
+            }
+          };
+
+      // TODO(b/29509141): Clarify the error.
+      private void reportProviderMayNotDependOnProducer(ContributionBinding productionBinding) {
+        if (atEntryPoint()) {
+          reportErrorAtEntryPoint(
+              PROVIDER_ENTRY_POINT_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT,
+              formatCurrentDependencyRequestKey());
+        } else {
+          // TODO(beder): Consider displaying all dependent provisions in the error message. If we
+          // do that, should we display all productions that depend on them also?
+          reportErrorAtEntryPoint(
+              owningGraph(provisionsDependingOnLatestRequest().append(productionBinding)),
+              PROVIDER_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT,
+              provisionsDependingOnLatestRequest().iterator().next().key());
+        }
+      }
 
-    private void reportInconsistentMapKeyAnnotations(
-        DependencyPath path,
-        Multimap<Equivalence.Wrapper<DeclaredType>, ContributionBinding>
-            mapBindingsByAnnotationType) {
-      StringBuilder builder =
-          new StringBuilder(
-              inconsistentMapKeyAnnotationsError(formatCurrentDependencyRequestKey(path)));
-      for (Map.Entry<Equivalence.Wrapper<DeclaredType>, Collection<ContributionBinding>> entry :
-          mapBindingsByAnnotationType.asMap().entrySet()) {
-        DeclaredType annotationType = entry.getKey().get();
-        Collection<ContributionBinding> bindings = entry.getValue();
-
-        builder
-            .append('\n')
-            .append(INDENT)
-            .append(annotationType)
-            .append(':');
-
-        bindingDeclarationFormatter.formatIndentedList(builder, bindings, 2, DUPLICATE_SIZE_LIMIT);
+      /**
+       * Descriptive portion of the error message for when the given request has no binding.
+       * Currently, the only other portions of the message are the dependency path, line number and
+       * filename.
+       */
+      private StringBuilder requiresErrorMessageBase() {
+        Key key = dependencyRequest().key();
+        String requiresErrorMessageFormat;
+        // TODO(dpb): Check for wildcard injection somewhere else first?
+        if (key.type().getKind().equals(TypeKind.WILDCARD)) {
+          requiresErrorMessageFormat = CANNOT_INJECT_WILDCARD_TYPE;
+        } else {
+          boolean requiresProvision = doesPathRequireProvisionOnly();
+          if (!key.isValidImplicitProvisionKey(types)) {
+            requiresErrorMessageFormat =
+                requiresProvision ? REQUIRES_PROVIDER_FORMAT : REQUIRES_PROVIDER_OR_PRODUCER_FORMAT;
+          } else {
+            requiresErrorMessageFormat =
+                requiresProvision
+                    ? REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_FORMAT
+                    : REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_OR_PRODUCER_FORMAT;
+          }
+        }
+        StringBuilder errorMessage =
+            new StringBuilder(
+                String.format(requiresErrorMessageFormat, formatCurrentDependencyRequestKey()));
+        if (key.isValidMembersInjectionKey()) {
+          Optional<MembersInjectionBinding> membersInjectionBinding =
+              injectBindingRegistry.getOrFindMembersInjectionBinding(key);
+          if (membersInjectionBinding.isPresent()
+              && !membersInjectionBinding.get().injectionSites().isEmpty()) {
+            errorMessage.append(" ");
+            errorMessage.append(ErrorMessages.MEMBERS_INJECTION_DOES_NOT_IMPLY_PROVISION);
+          }
+        }
+        return errorMessage.append('\n');
       }
-      owningReportBuilder(mapBindingsByAnnotationType.values())
-          .addError(builder.toString(), path.entryPointElement());
-    }
 
-    private void reportCycle(DependencyPath path) {
-      if (!providersBreakingCycle(path).isEmpty()) {
-        return;
+      private void reportMissingBinding() {
+        StringBuilder errorMessage = requiresErrorMessageBase().append(formatDependencyTrace());
+        for (String suggestion :
+            MissingBindingSuggestions.forKey(rootGraph, dependencyRequest().bindingKey())) {
+          errorMessage.append('\n').append(suggestion);
+        }
+        reportErrorAtEntryPoint(rootGraph, errorMessage.toString());
+      }
+
+      @SuppressWarnings("resource") // Appendable is a StringBuilder.
+      private void reportDependsOnProductionExecutor() {
+        reportErrorAtEntryPoint(
+            DEPENDS_ON_PRODUCTION_EXECUTOR_FORMAT, formatCurrentDependencyRequestKey());
       }
+
+      @SuppressWarnings("resource") // Appendable is a StringBuilder.
+      private void reportDuplicateBindings() {
+        // If any of the duplicate bindings results from multibinding contributions or declarations,
+        // report the conflict using those contributions and declarations.
+        if (resolvedBindings()
+            .contributionBindings()
+            .stream()
+            .map(ContributionBinding::bindingKind)
+            // TODO(dpb): Kill with fire.
+            .anyMatch(
+                kind -> SYNTHETIC_MULTIBOUND_KINDS.contains(kind) || SYNTHETIC_MAP.equals(kind))) {
+          reportMultipleContributionTypes();
+          return;
+        }
+        StringBuilder builder = new StringBuilder();
+        new Formatter(builder)
+            .format(DUPLICATE_BINDINGS_FOR_KEY_FORMAT, formatCurrentDependencyRequestKey());
+        ImmutableSetMultimap<ComponentDescriptor, BindingDeclaration> duplicateDeclarations =
+            reportableDeclarations();
+        bindingDeclarationFormatter.formatIndentedList(
+            builder, duplicateDeclarations.values(), 1, DUPLICATE_SIZE_LIMIT);
+        reportErrorAtEntryPoint(
+            componentTreePath().rootmostGraph(duplicateDeclarations.keySet()), builder.toString());
+      }
+
+      @SuppressWarnings("resource") // Appendable is a StringBuilder.
+      private void reportMultipleContributionTypes() {
+        StringBuilder builder = new StringBuilder();
+        new Formatter(builder)
+            .format(
+                MULTIPLE_CONTRIBUTION_TYPES_FOR_KEY_FORMAT, formatCurrentDependencyRequestKey());
+        ImmutableSetMultimap<ComponentDescriptor, BindingDeclaration> duplicateDeclarations =
+            reportableDeclarations();
+        ImmutableListMultimap<ContributionType, BindingDeclaration> duplicateDeclarationsByType =
+            Multimaps.index(
+                duplicateDeclarations.values(),
+                declaration ->
+                    declaration instanceof HasContributionType
+                        ? ((HasContributionType) declaration).contributionType()
+                        : ContributionType.UNIQUE);
+        verify(
+            duplicateDeclarationsByType.keySet().size() > 1,
+            "expected multiple contribution types for %s: %s",
+            dependencyRequest().bindingKey(),
+            duplicateDeclarationsByType);
+        ImmutableSortedMap.copyOf(Multimaps.asMap(duplicateDeclarationsByType))
+            .forEach(
+                (contributionType, declarations) -> {
+                  builder.append(INDENT);
+                  builder.append(formatContributionType(contributionType));
+                  builder.append(" bindings and declarations:");
+                  bindingDeclarationFormatter.formatIndentedList(
+                      builder, declarations, 2, DUPLICATE_SIZE_LIMIT);
+                  builder.append('\n');
+                });
+        reportErrorAtEntryPoint(
+            componentTreePath().rootmostGraph(duplicateDeclarations.keySet()), builder.toString());
+      }
+
+      private void reportDuplicateMapKeys(Collection<ContributionBinding> mapBindings) {
+        StringBuilder builder = new StringBuilder();
+        builder.append(duplicateMapKeysError(formatCurrentDependencyRequestKey()));
+        bindingDeclarationFormatter.formatIndentedList(
+            builder, mapBindings, 1, DUPLICATE_SIZE_LIMIT);
+        reportErrorAtEntryPoint(owningGraph(mapBindings), builder.toString());
+      }
+
+      private void reportInconsistentMapKeyAnnotations(
+          Multimap<Equivalence.Wrapper<DeclaredType>, ContributionBinding>
+              mapBindingsByAnnotationType) {
+        StringBuilder builder =
+            new StringBuilder(
+                inconsistentMapKeyAnnotationsError(formatCurrentDependencyRequestKey()));
+        for (Map.Entry<Equivalence.Wrapper<DeclaredType>, Collection<ContributionBinding>> entry :
+            mapBindingsByAnnotationType.asMap().entrySet()) {
+          DeclaredType annotationType = entry.getKey().get();
+          Collection<ContributionBinding> bindings = entry.getValue();
+
+          builder.append('\n').append(INDENT).append(annotationType).append(':');
+
+          bindingDeclarationFormatter.formatIndentedList(
+              builder, bindings, 2, DUPLICATE_SIZE_LIMIT);
+        }
+        reportErrorAtEntryPoint(
+            owningGraph(mapBindingsByAnnotationType.values()), builder.toString());
+      }
+
       // TODO(cgruber): Provide a hint for the start and end of the cycle.
-      owningReportBuilder(
-              path.cycle()
-                  .transform(ResolvedRequest::resolvedBindings)
-                  .transformAndConcat(ResolvedBindings::contributionBindings))
-          .addItem(
-              String.format(
-                  CONTAINS_DEPENDENCY_CYCLE_FORMAT,
-                  dependencyRequestFormatter.toDependencyTrace(path)),
-              ERROR,
-              path.entryPointElement());
-    }
+      private void reportDependencyCycle() {
+        if (!providersBreakingCycle().isEmpty()) {
+          return;
+        }
+        ImmutableList.Builder<ContributionBinding> cycleBindings = ImmutableList.builder();
+        cycleDependencyTrace()
+            .forEach(
+                (dependencyRequest, resolvedBindings) ->
+                    cycleBindings.addAll(resolvedBindings.contributionBindings()));
+        reportErrorAtEntryPoint(
+            owningGraph(cycleBindings.build()),
+            CONTAINS_DEPENDENCY_CYCLE_FORMAT,
+            formatDependencyTrace());
+      }
 
-    /**
-     * Returns any steps in a dependency cycle that "break" the cycle. These are any nonsynthetic
-     * {@link Provider}, {@link Lazy}, or {@code Map<K, Provider<V>>} requests after the first
-     * request in the cycle.
-     *
-     * <p>The synthetic request for a {@code Map<K, Provider<V>>} as a dependency of a multibound
-     * {@code Map<K, V>} does not break cycles because the map's {@link Provider}s' {@link
-     * Provider#get() get()} methods are called during provision.
-     *
-     * <p>A request for an instance of {@code Optional} breaks the cycle if it is resolved to a
-     * {@link BindsOptionalOf} binding and a request for the {@code Optional}'s type parameter
-     * would.
-     */
-    private ImmutableSet<DependencyRequest> providersBreakingCycle(DependencyPath path) {
-      return path.cycle()
-          .skip(1)
-          .filter(
-              new Predicate<ResolvedRequest>() {
-                @Override
-                public boolean apply(ResolvedRequest resolvedRequest) {
-                  DependencyRequest dependencyRequest = resolvedRequest.dependencyRequest();
-                  if (dependencyRequest.requestElement().isPresent()) {
-                    if (breaksCycle(dependencyRequest.key().type(), dependencyRequest.kind())) {
-                      return true;
-                    } else if (!resolvedRequest
-                        .resolvedBindings()
-                        .optionalBindingDeclarations()
-                        .isEmpty()) {
-                      /* Request resolved to a @BindsOptionalOf binding, so test the type inside the
-                       * Optional. Optional<Provider or Lazy or Provider of Lazy or Map of Provider>
-                       * breaks the cycle. */
-                      DependencyRequest.KindAndType kindAndType =
-                          DependencyRequest.extractKindAndType(
-                              OptionalType.from(dependencyRequest.key()).valueType());
-                      return breaksCycle(kindAndType.type(), kindAndType.kind());
+      /**
+       * Returns any steps in a dependency cycle that "break" the cycle. These are any nonsynthetic
+       * {@link Provider}, {@link Lazy}, or {@code Map<K, Provider<V>>} requests after the first
+       * request in the cycle.
+       *
+       * <p>The synthetic request for a {@code Map<K, Provider<V>>} as a dependency of a multibound
+       * {@code Map<K, V>} does not break cycles because the map's {@link Provider}s' {@link
+       * Provider#get() get()} methods are called during provision.
+       *
+       * <p>A request for an instance of {@code Optional} breaks the cycle if it is resolved to a
+       * {@link BindsOptionalOf} binding and a request for the {@code Optional}'s type parameter
+       * would.
+       */
+      private ImmutableSet<DependencyRequest> providersBreakingCycle() {
+        ImmutableSet.Builder<DependencyRequest> providers = ImmutableSet.builder();
+        AtomicBoolean first = new AtomicBoolean(true);
+        cycleDependencyTrace()
+            .forEach(
+                (dependencyRequest, resolvedBindings) -> {
+                  // Skip the first request in the cycle and any synthetic requests.
+                  if (first.getAndSet(false) || !dependencyRequest.requestElement().isPresent()) {
+                    return;
+                  }
+
+                  if (breaksCycle(dependencyRequest.key().type(), dependencyRequest.kind())) {
+                    providers.add(dependencyRequest);
+                  } else if (!resolvedBindings.optionalBindingDeclarations().isEmpty()) {
+                    /* Request resolved to a @BindsOptionalOf binding, so test the type inside the
+                     * Optional. Optional<Provider or Lazy or Provider of Lazy or Map of Provider>
+                     * breaks the cycle. */
+                    DependencyRequest.KindAndType kindAndType =
+                        DependencyRequest.extractKindAndType(
+                            OptionalType.from(dependencyRequest.key()).valueType());
+                    if (breaksCycle(kindAndType.type(), kindAndType.kind())) {
+                      providers.add(dependencyRequest);
                     }
                   }
-                  return false;
-                }
+                });
+        return providers.build();
+      }
 
-                private boolean breaksCycle(
-                    TypeMirror requestedType, DependencyRequest.Kind requestKind) {
-                  switch (requestKind) {
-                    case PROVIDER:
-                    case LAZY:
-                    case PROVIDER_OF_LAZY:
-                      return true;
+      private boolean breaksCycle(TypeMirror requestedType, DependencyRequest.Kind requestKind) {
+        switch (requestKind) {
+          case PROVIDER:
+          case LAZY:
+          case PROVIDER_OF_LAZY:
+            return true;
 
-                    case INSTANCE:
-                      return MapType.isMap(requestedType)
-                          && MapType.from(requestedType).valuesAreTypeOf(Provider.class);
+          case INSTANCE:
+            return MapType.isMap(requestedType)
+                && MapType.from(requestedType).valuesAreTypeOf(Provider.class);
 
-                    default:
-                      return false;
-                  }
-                }
-              })
-          .transform(ResolvedRequest::dependencyRequest)
-          .toSet();
+          default:
+            return false;
+        }
+      }
+
+      /**
+       * Returns whether the given dependency path would require the most recent request to be
+       * resolved by only provision bindings.
+       */
+      private boolean doesPathRequireProvisionOnly() {
+        // The second-most-recent bindings determine whether the most recent one must be a
+        // provision.
+        if (!atEntryPoint()) {
+          return !provisionsDependingOnLatestRequest().isEmpty();
+        }
+
+        // Check the request kind for entry points.
+        switch (dependencyRequest().kind()) {
+          case INSTANCE:
+          case PROVIDER:
+          case LAZY:
+          case MEMBERS_INJECTOR:
+            return true;
+          case PRODUCER:
+          case PRODUCED:
+          case FUTURE:
+            return false;
+          default:
+            throw new AssertionError();
+        }
+      }
+
+      /**
+       * Returns any provision bindings resolved for the second-most-recent request in the given
+       * path; that is, returns those provision bindings that depend on the latest request in the
+       * path.
+       */
+      private FluentIterable<ContributionBinding> provisionsDependingOnLatestRequest() {
+        return FluentIterable.from(dependentBindings())
+            .filter(ContributionBinding.class)
+            .filter(PROVISION::isOfType);
+      }
+
+      private String formatCurrentDependencyRequestKey() {
+        return keyFormatter.format(dependencyRequest().key());
+      }
     }
   }
 
-  ValidationReport<TypeElement> validate(BindingGraph subject) {
-    Validation validation = new Validation(subject);
-    validation.validateSubgraph();
+  ValidationReport<TypeElement> validate(BindingGraph graph) {
+    ComponentValidation validation = new ComponentValidation(graph);
+    validation.traverseComponents();
     return validation.buildReport();
   }
 
@@ -1238,45 +1057,7 @@ private void appendIndentedComponentsList(StringBuilder message, Iterable<TypeEl
    * a scoping annotation.
    */
   private ImmutableSet<TypeElement> scopedTypesIn(Set<TypeElement> types) {
-    return FluentIterable.from(types).filter(type -> !Scope.scopesOf(type).isEmpty()).toSet();
-  }
-
-  /**
-   * Returns whether the given dependency path would require the most recent request to be resolved
-   * by only provision bindings.
-   */
-  private boolean doesPathRequireProvisionOnly(DependencyPath path) {
-    if (path.size() == 1) {
-      // if this is an entry-point, then we check the request
-      switch (path.current().dependencyRequest().kind()) {
-        case INSTANCE:
-        case PROVIDER:
-        case LAZY:
-        case MEMBERS_INJECTOR:
-          return true;
-        case PRODUCER:
-        case PRODUCED:
-        case FUTURE:
-          return false;
-        default:
-          throw new AssertionError();
-      }
-    }
-    // otherwise, the second-most-recent bindings determine whether the most recent one must be a
-    // provision
-    return !provisionsDependingOnLatestRequest(path).isEmpty();
-  }
-
-  /**
-   * Returns any provision bindings resolved for the second-most-recent request in the given path;
-   * that is, returns those provision bindings that depend on the latest request in the path.
-   */
-  private FluentIterable<ContributionBinding> provisionsDependingOnLatestRequest(
-      DependencyPath path) {
-    return path.current()
-        .dependentBindings()
-        .filter(ContributionBinding.class)
-        .filter(PROVISION::isOfType);
+    return types.stream().filter(type -> !scopesOf(type).isEmpty()).collect(toImmutableSet());
   }
 
   private String formatContributionType(ContributionType type) {
@@ -1292,40 +1073,4 @@ private String formatContributionType(ContributionType type) {
         throw new IllegalStateException("Unknown binding type: " + type);
     }
   }
-
-  private String formatCurrentDependencyRequestKey(DependencyPath path) {
-    return keyFormatter.format(path.current().dependencyRequest().key());
-  }
-
-  @AutoValue
-  abstract static class ResolvedRequest {
-
-    abstract DependencyRequest dependencyRequest();
-
-    abstract ResolvedBindings resolvedBindings();
-
-    /**
-     * The {@link #resolvedBindings()} of the previous entry in the {@link DependencyPath}. One of
-     * these bindings depends directly on {@link #dependencyRequest()}.
-     */
-    abstract Optional<ResolvedBindings> dependentResolvedBindings();
-
-    /**
-     * Returns the bindings that depend on this {@linkplain #dependencyRequest() dependency
-     * request}.
-     */
-    FluentIterable<? extends Binding> dependentBindings() {
-      return FluentIterable.from(dependentResolvedBindings().asSet())
-          .transformAndConcat(ResolvedBindings::bindings)
-          .filter(binding -> binding.dependencies().contains(dependencyRequest()));
-    }
-
-    private static ResolvedRequest create(
-        DependencyRequest request,
-        ResolvedBindings resolvedBindings,
-        Optional<ResolvedBindings> dependentBindings) {
-      return new AutoValue_BindingGraphValidator_ResolvedRequest(
-          request, resolvedBindings, dependentBindings);
-    }
-  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index 3c44f06a9..be3a2ced6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -28,6 +28,7 @@
 import static dagger.internal.codegen.ConfigurationAnnotations.isSubcomponentBuilder;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
 import static dagger.internal.codegen.Util.getUnimplementedMethods;
+import static dagger.internal.codegen.Util.toImmutableSet;
 import static javax.lang.model.type.TypeKind.DECLARED;
 import static javax.lang.model.type.TypeKind.VOID;
 
@@ -318,6 +319,16 @@ private static void addTransitiveModules(
 
   abstract ImmutableSet<ComponentMethodDescriptor> componentMethods();
 
+  /** The dependency requests defined by methods on the component type. */
+  ImmutableSet<DependencyRequest> entryPoints() {
+    return componentMethods()
+        .stream()
+        .map(ComponentMethodDescriptor::dependencyRequest)
+        .filter(Optional::isPresent)
+        .map(Optional::get)
+        .collect(toImmutableSet());
+  }
+
   // TODO(gak): Consider making this non-optional and revising the
   // interaction between the spec & generation
   abstract Optional<BuilderSpec> builderSpec();
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentTreeTraverser.java b/compiler/src/main/java/dagger/internal/codegen/ComponentTreeTraverser.java
new file mode 100644
index 000000000..d19f454df
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentTreeTraverser.java
@@ -0,0 +1,648 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkState;
+import static com.google.common.base.Predicates.equalTo;
+import static com.google.common.base.Verify.verify;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static com.google.common.collect.Iterables.indexOf;
+import static com.google.common.collect.Iterables.skip;
+import static com.google.common.collect.Multimaps.asMap;
+import static dagger.internal.codegen.BindingKey.contribution;
+import static dagger.internal.codegen.Util.toImmutableSet;
+import static java.util.Spliterator.ORDERED;
+import static java.util.Spliterator.SIZED;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Iterators;
+import com.google.common.collect.LinkedHashMultiset;
+import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
+import java.util.ArrayDeque;
+import java.util.Deque;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.Set;
+import java.util.Spliterators.AbstractSpliterator;
+import java.util.function.BiConsumer;
+import java.util.function.BiFunction;
+import java.util.function.Consumer;
+import java.util.function.Predicate;
+import java.util.stream.Stream;
+import java.util.stream.StreamSupport;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+
+/**
+ * An object that traverses the entire component hierarchy, starting from the root component.
+ *
+ * <p>Subclasses can override {@link #visitComponent(BindingGraph)} to perform custom logic at each
+ * component in the tree, and {@link #visitSubcomponentFactoryMethod(BindingGraph, BindingGraph,
+ * ExecutableElement)} to perform custom logic at each subcomponent factory method.
+ *
+ * <p>Subclasses can override {@link #bindingGraphTraverser(ComponentTreePath, DependencyRequest)}
+ * to traverse each entry point within each component in the tree.
+ */
+public class ComponentTreeTraverser {
+
+  /** The path from the root graph to the currently visited graph. */
+  private final Deque<BindingGraph> bindingGraphPath = new ArrayDeque<>();
+
+  /** Constructs a traverser for a root (component, not subcomponent) binding graph. */
+  public ComponentTreeTraverser(BindingGraph rootGraph) {
+    checkArgument(
+        rootGraph.componentDescriptor().kind().isTopLevel(),
+        "only top-level graphs can be traversed, not %s",
+        rootGraph.componentDescriptor().componentDefinitionType().getQualifiedName());
+    bindingGraphPath.add(rootGraph);
+  }
+
+  /**
+   * Calls {@link #visitComponent(BindingGraph)} for the root component.
+   *
+   * @throws IllegalStateException if a traversal is in progress
+   */
+  public final void traverseComponents() {
+    checkState(bindingGraphPath.size() == 1);
+    visitComponent(bindingGraphPath.getFirst());
+  }
+
+  /**
+   * Called once for each component in a component hierarchy.
+   *
+   * <p>Subclasses can override this method to perform whatever logic is required per component.
+   * They should call the {@code super} implementation if they want to continue the traversal in the
+   * standard order.
+   *
+   * <p>This implementation does the following:
+   *
+   * <ol>
+   *   <li>If this component is installed in its parent by a subcomponent factory method, calls
+   *       {@link #visitSubcomponentFactoryMethod(BindingGraph, BindingGraph, ExecutableElement)}.
+   *   <li>For each entry point in the component, calls {@link #visitEntryPoint(DependencyRequest,
+   *       BindingGraph)}.
+   *   <li>For each child component, calls {@link #visitComponent(BindingGraph)}, updating the
+   *       traversal state.
+   * </ol>
+   *
+   * @param graph the currently visited graph
+   */
+  protected void visitComponent(BindingGraph graph) {
+    if (bindingGraphPath.size() > 1) {
+      BindingGraph parent = Iterators.get(bindingGraphPath.descendingIterator(), 1);
+      ComponentMethodDescriptor childFactoryMethod =
+          parent
+              .componentDescriptor()
+              .subcomponentsByFactoryMethod()
+              .inverse()
+              .get(graph.componentDescriptor());
+      if (childFactoryMethod != null) {
+        visitSubcomponentFactoryMethod(graph, parent, childFactoryMethod.methodElement());
+      }
+    }
+
+    for (DependencyRequest entryPoint : graph.componentDescriptor().entryPoints()) {
+      visitEntryPoint(entryPoint, graph);
+    }
+
+    for (BindingGraph child : graph.subgraphs()) {
+      bindingGraphPath.addLast(child);
+      try {
+        visitComponent(child);
+      } finally {
+        verify(bindingGraphPath.removeLast().equals(child));
+      }
+    }
+  }
+
+  /**
+   * Called if this component was installed in its parent by a subcomponent factory method.
+   *
+   * <p>This implementation does nothing.
+   *
+   * @param graph the currently visited graph
+   * @param parent the parent graph
+   * @param factoryMethod the factory method in the parent component that declares that the current
+   *     component is a child
+   */
+  protected void visitSubcomponentFactoryMethod(
+      BindingGraph graph, BindingGraph parent, ExecutableElement factoryMethod) {}
+
+  /**
+   * Called once for each entry point in a component.
+   *
+   * <p>Subclasses can override this method to perform whatever logic is required per entry point.
+   * They should call the {@code super} implementation if they want to continue the traversal in the
+   * standard order.
+   *
+   * <p>This implementation passes the entry point and the current component tree path to {@link
+   * #bindingGraphTraverser(ComponentTreePath, DependencyRequest)}, and calls {@link
+   * BindingGraphTraverser#traverseDependencies()} on the returned object.
+   *
+   * @param graph the graph for the component that contains the entry point
+   */
+  protected void visitEntryPoint(DependencyRequest entryPoint, BindingGraph graph) {
+    bindingGraphTraverser(componentTreePath(), entryPoint).traverseDependencies();
+  }
+
+  /**
+   * Returns an object that traverses the binding graph starting from an entry point.
+   *
+   * <p>This implementation returns a no-op object that does nothing. Subclasses should override in
+   * order to perform custom logic within the binding graph.
+   *
+   * @param componentPath the path from the root component to the component that includes the entry
+   *     point
+   * @param entryPoint the entry point
+   */
+  protected BindingGraphTraverser bindingGraphTraverser(
+      ComponentTreePath componentPath, DependencyRequest entryPoint) {
+    return new NoOpBindingGraphTraverser(componentPath, entryPoint);
+  }
+
+  /**
+   * Returns an immutable snapshot of the path from the root component to the currently visited
+   * component.
+   */
+  protected final ComponentTreePath componentTreePath() {
+    return new ComponentTreePath(bindingGraphPath);
+  }
+
+  /** An object that traverses the binding graph starting from an entry point. */
+  public static class BindingGraphTraverser {
+
+    private final ComponentTreePath componentTreePath;
+    private final DependencyRequest entryPoint;
+    private final Deque<DependencyRequest> dependencyRequestPath = new ArrayDeque<>();
+    private final Deque<ResolvedBindings> resolvedBindingsPath = new ArrayDeque<>();
+    private final LinkedHashMultiset<BindingKey> bindingKeysInPath = LinkedHashMultiset.create();
+    private final Set<DependencyRequest> visitedDependencyRequests = new HashSet<>();
+
+    /**
+     * Constructs a traverser for an entry point.
+     *
+     * @param componentPath the path from the root component to the component that includes the
+     *     entry point to be traversed
+     * @param entryPoint the entry point to be traversed
+     */
+    public BindingGraphTraverser(ComponentTreePath componentPath, DependencyRequest entryPoint) {
+      this.componentTreePath = componentPath;
+      this.entryPoint = entryPoint;
+    }
+
+    /**
+     * Calls {@link #visitDependencyRequest(DependencyRequest)} for the {@linkplain
+     * #entryPointElement() entry point}.
+     *
+     * @throws IllegalStateException if a traversal is in progress
+     */
+    public void traverseDependencies() {
+      checkState(dependencyRequestPath.isEmpty());
+      checkState(resolvedBindingsPath.isEmpty());
+      checkState(bindingKeysInPath.isEmpty());
+      checkState(visitedDependencyRequests.isEmpty());
+      nextDependencyRequest(entryPoint, currentGraph());
+    }
+
+    /**
+     * Called once for each dependency request that is reachable from an entry point.
+     *
+     * <p>Subclasses can override this method to perform whatever logic is required per dependency
+     * request. They should call the {@code super} implementation if they want to continue the
+     * traversal in the standard order.
+     *
+     * <p>This implementation calls {@link #visitResolvedBindings(ResolvedBindings)} unless the
+     * dependency request introduces a cycle.
+     *
+     * @param dependencyRequest the object returned by {@link #dependencyRequest()}
+     */
+    protected void visitDependencyRequest(DependencyRequest dependencyRequest) {
+      if (!atDependencyCycle()) {
+        visitResolvedBindings(resolvedBindingsPath.getLast());
+      }
+    }
+
+    /**
+     * Called once for each dependency request that is reachable from an entry point.
+     *
+     * <p>Subclasses can override this method to perform whatever logic is required per resolved
+     * bindings. They should call the {@code super} implementation if they want to continue the
+     * traversal in the standard order.
+     *
+     * <p>This implementation calls either {@link #visitMembersInjectionBindings(ResolvedBindings)}
+     * or {@link #visitContributionBindings(ResolvedBindings)}, depending on the binding key kind.
+     *
+     * @param resolvedBindings the object returned by {@link #resolvedBindings()}
+     */
+    protected void visitResolvedBindings(ResolvedBindings resolvedBindings) {
+      switch (resolvedBindings.bindingKey().kind()) {
+        case MEMBERS_INJECTION:
+          visitMembersInjectionBindings(resolvedBindings);
+          break;
+
+        case CONTRIBUTION:
+          visitContributionBindings(resolvedBindings);
+          break;
+      }
+    }
+
+    /**
+     * Called once for each dependency request for a members injector that is reachable from an
+     * entry point.
+     *
+     * <p>Subclasses can override this method to perform whatever logic is required per resolved
+     * members injection bindings. They should call the {@code super} implementation if they want to
+     * continue the traversal in the standard order.
+     *
+     * <p>This implementation calls {@link #visitMembersInjectionBinding(MembersInjectionBinding,
+     * ComponentDescriptor)}.
+     *
+     * @param resolvedBindings the object returned by {@link #resolvedBindings()}
+     */
+    protected void visitMembersInjectionBindings(ResolvedBindings resolvedBindings) {
+      if (!resolvedBindings.contributionBindings().isEmpty()) {
+        // TODO(dpb): How could this ever happen, even in an invalid graph?
+        throw new AssertionError(
+            "members injection binding keys should never have contribution bindings");
+      }
+      visitMembersInjectionBinding(
+          resolvedBindings.membersInjectionBinding().get(),
+          getOnlyElement(resolvedBindings.allMembersInjectionBindings().keySet()));
+    }
+
+    /**
+     * Called once for each members injection binding that is reachable from an entry point.
+     *
+     * <p>Subclasses can override this method to perform whatever logic is required per members
+     * injection binding. They should call the {@code super} implementation if they want to continue
+     * the traversal in the standard order.
+     *
+     * <p>This implementation calls {@link #visitBinding(Binding, ComponentDescriptor)}.
+     *
+     * @param binding the only value of {@code resolvedBindings().allMembersInjectionBindings()}
+     * @param owningComponent the only key of {@code
+     *     resolvedBindings().allMembersInjectionBindings()}. The binding's dependencies should be
+     *     resolved within this component.
+     */
+    protected void visitMembersInjectionBinding(
+        MembersInjectionBinding binding, ComponentDescriptor owningComponent) {
+      visitBinding(binding, owningComponent);
+    }
+
+    /**
+     * Called once for each dependency request for a contribution that is reachable from an entry
+     * point.
+     *
+     * <p>Subclasses can override this method to perform whatever logic is required per resolved
+     * contribution bindings. They should call the {@code super} implementation if they want to
+     * continue the traversal in the standard order.
+     *
+     * <p>This implementation calls {@link #visitContributionBinding(ContributionBinding,
+     * ComponentDescriptor)} for each contribution binding.
+     *
+     * @param resolvedBindings the object returned by {@link #resolvedBindings()}
+     */
+    protected void visitContributionBindings(ResolvedBindings resolvedBindings) {
+      if (resolvedBindings.membersInjectionBinding().isPresent()) {
+        throw new AssertionError(
+            "contribution binding keys should never have members injection bindings");
+      }
+      asMap(resolvedBindings.allContributionBindings())
+          .forEach(
+              (owningComponent, bindings) -> {
+                bindings.forEach(binding -> visitContributionBinding(binding, owningComponent));
+              });
+    }
+
+    /**
+     * Called once for each contribution binding that is reachable from an entry point.
+     *
+     * <p>Subclasses can override this method to perform whatever logic is required per contribution
+     * binding. They should call the {@code super} implementation if they want to continue the
+     * traversal in the standard order.
+     *
+     * <p>This implementation calls {@link #visitBinding(Binding, ComponentDescriptor)}.
+     *
+     * @param binding a value of {@code resolvedBindings().allContributionBindings()}
+     * @param owningComponent the key of {@code resolvedBindings().allContributionBindings()} for
+     *     {@code binding}. The binding's dependencies should be resolved within this component.
+     */
+    protected void visitContributionBinding(
+        ContributionBinding binding, ComponentDescriptor owningComponent) {
+      visitBinding(binding, owningComponent);
+    }
+
+    /**
+     * Called once for each binding that is reachable from an entry point.
+     *
+     * <p>Subclasses can override this method to perform whatever logic is required per binding.
+     * They should call the {@code super} implementation if they want to continue the traversal in
+     * the standard order.
+     *
+     * <p>This implementation calls {@link #visitDependencyRequest(DependencyRequest)} for each
+     * dependency of the binding, resolved within {@code owningComponent}, that has not already been
+     * visited while traversing the current entry point.
+     *
+     * @param binding a value of {@code resolvedBindings().allBindings()}
+     * @param owningComponent the key of {@code resolvedBindings().allBindings()} for {@code
+     *     binding}. The binding's dependencies should be resolved within this component.
+     */
+    protected void visitBinding(Binding binding, ComponentDescriptor owningComponent) {
+      BindingGraph owningGraph = componentTreePath.graphForComponent(owningComponent);
+      for (DependencyRequest dependency : binding.dependencies()) {
+        nextDependencyRequest(dependency, owningGraph);
+      }
+    }
+
+    private void nextDependencyRequest(
+        DependencyRequest dependencyRequest, BindingGraph bindingGraph) {
+      if (!visitedDependencyRequests.add(dependencyRequest)) {
+        return;
+      }
+
+      ResolvedBindings resolvedBindings =
+          bindingGraph.resolvedBindings().get(dependencyRequest.bindingKey());
+      dependencyRequestPath.addLast(dependencyRequest);
+      resolvedBindingsPath.addLast(resolvedBindings);
+      bindingKeysInPath.add(dependencyRequest.bindingKey());
+      try {
+        visitDependencyRequest(dependencyRequest);
+      } finally {
+        verify(dependencyRequestPath.removeLast().equals(dependencyRequest));
+        verify(resolvedBindingsPath.removeLast().equals(resolvedBindings));
+        verify(bindingKeysInPath.remove(dependencyRequest.bindingKey()));
+      }
+    }
+
+    /**
+     * Returns the path from the root component to the component that includes the {@linkplain
+     * #entryPointElement()} entry point.
+     */
+    protected final ComponentTreePath componentTreePath() {
+      return componentTreePath;
+    }
+
+    /**
+     * Returns the rootmost of the binding graphs in the component path that own each binding.
+     *
+     * <p>For arguments {@code [x, y]}, if binding {@code x} is owned by component {@code A} and
+     * binding {@code y} is owned by component {@code B}, and {@code A} is an ancestor of {@code B},
+     * then this method returns the binding graph for {@code A}.
+     */
+    public BindingGraph owningGraph(Iterable<ContributionBinding> bindings) {
+      ImmutableSet.Builder<ComponentDescriptor> owningComponents = ImmutableSet.builder();
+      for (ContributionBinding binding : bindings) {
+        ResolvedBindings resolvedBindings =
+            currentGraph().resolvedBindings().get(contribution(binding.key()));
+        owningComponents.add(resolvedBindings.owningComponent(binding));
+      }
+      return componentTreePath.rootmostGraph(owningComponents.build());
+    }
+
+    /**
+     * Returns {@code true} if the {@linkplain #dependencyRequest() current dependency request} is
+     * also higher in the dependency path.
+     *
+     * @throws IllegalStateException if this object is not currently traversing dependencies
+     */
+    protected final boolean atDependencyCycle() {
+      checkState(!dependencyRequestPath.isEmpty());
+      return bindingKeysInPath.count(dependencyRequest().bindingKey()) > 1;
+    }
+
+    /**
+     * Returns the dependency request currently being visited.
+     *
+     * @throws IllegalStateException if this object is not currently traversing dependencies
+     */
+    protected final DependencyRequest dependencyRequest() {
+      return dependencyRequestPath.getLast();
+    }
+
+    /**
+     * Returns the resolved bindings for the {@linkplain #dependencyRequest() current dependency
+     * request}.
+     *
+     * @throws IllegalStateException if this object is not currently traversing dependencies
+     */
+    protected final ResolvedBindings resolvedBindings() {
+      return resolvedBindingsPath.getLast();
+    }
+
+    /**
+     * Returns the bindings that depend directly on the {@linkplain #dependencyRequest() current
+     * dependency request}.
+     */
+    protected final ImmutableSet<? extends Binding> dependentBindings() {
+      if (atEntryPoint()) {
+        return ImmutableSet.of();
+      }
+      ResolvedBindings dependentResolvedBindings =
+          Iterators.get(resolvedBindingsPath.descendingIterator(), 1);
+      return dependentResolvedBindings
+          .bindings()
+          .stream()
+          .filter(binding -> binding.dependencies().contains(dependencyRequest()))
+          .collect(toImmutableSet());
+    }
+
+    /**
+     * Returns the entry point whose dependencies are currently being traversed.
+     *
+     * @throws IllegalStateException if this object is not currently traversing dependencies
+     */
+    protected final Element entryPointElement() {
+      return entryPoint.requestElement().get();
+    }
+
+    /**
+     * Returns {@code true} if the {@linkplain #dependencyRequest() current dependency request} is
+     * an entry point.
+     */
+    protected final boolean atEntryPoint() {
+      return dependencyRequestPath.size() == 1;
+    }
+
+    /** Returns the binding graph for the component that is currently being visited. */
+    protected final BindingGraph currentGraph() {
+      return componentTreePath.currentGraph();
+    }
+
+    /**
+     * Returns the dependency requests and resolved bindings starting with the entry point and
+     * ending with the {@linkplain #dependencyRequest() current dependency request}.
+     */
+    protected final DependencyTrace dependencyTrace() {
+      checkState(!dependencyRequestPath.isEmpty());
+      return new DependencyTrace(dependencyRequestPath, resolvedBindingsPath);
+    }
+
+    /**
+     * Returns the dependency requests and resolved bindings in the {@linkplain #atDependencyCycle()
+     * dependency cycle}, starting with the request closest to the entry point and ending with the
+     * {@linkplain #dependencyRequest() current dependency request}.
+     *
+     * <p>The first request and the last request in the trace will have the same {@linkplain
+     * DependencyRequest#bindingKey() binding key}.
+     */
+    protected final DependencyTrace cycleDependencyTrace() {
+      checkState(atDependencyCycle(), "no cycle");
+      int skip = indexOf(bindingKeysInPath, equalTo(dependencyRequest().bindingKey()));
+      return new DependencyTrace(
+          skip(dependencyRequestPath, skip), skip(resolvedBindingsPath, skip));
+    }
+  }
+
+  /** A traverser that does nothing. */
+  private static final class NoOpBindingGraphTraverser extends BindingGraphTraverser {
+    private NoOpBindingGraphTraverser(
+        ComponentTreePath componentPath, DependencyRequest entryPoint) {
+      super(componentPath, entryPoint);
+    }
+
+    @Override
+    public void traverseDependencies() {}
+  }
+
+  /**
+   * A path from the root component to a component within the component tree during a {@linkplain
+   * ComponentTreeTraverser traversal}.
+   */
+  public static final class ComponentTreePath {
+    /** The binding graph path from the root graph to the currently visited graph. */
+    private final ImmutableList<BindingGraph> bindingGraphPath;
+
+    private ComponentTreePath(Iterable<BindingGraph> path) {
+      this.bindingGraphPath = ImmutableList.copyOf(path);
+    }
+
+    /**
+     * Returns the binding graphs in the path, starting from the {@linkplain #rootGraph() root
+     * graph} and ending with the {@linkplain #currentGraph() current graph}.
+     */
+    public ImmutableList<BindingGraph> graphsInPath() {
+      return bindingGraphPath;
+    }
+
+    /** Returns the binding graph for the component at the end of the path. */
+    public BindingGraph currentGraph() {
+      return Iterables.getLast(bindingGraphPath);
+    }
+
+    // TODO(dpb): Do we also want methods that return ComponentDescriptors, like currentComponent()?
+
+    /**
+     * Returns the binding graph for the parent of the {@linkplain #currentGraph() current
+     * component}.
+     *
+     * @throws IllegalStateException if the current graph is the {@linkplain #atRoot() root graph}
+     */
+    public BindingGraph parentGraph() {
+      checkState(!atRoot());
+      return bindingGraphPath.reverse().get(1);
+    }
+
+    /** Returns the binding graph for the root component. */
+    public BindingGraph rootGraph() {
+      return bindingGraphPath.get(0);
+    }
+
+    /**
+     * Returns {@code true} if the {@linkplain #currentGraph() current graph} is the {@linkplain
+     * #rootGraph() root graph}.
+     */
+    public boolean atRoot() {
+      return bindingGraphPath.size() == 1;
+    }
+
+    /** Returns the rootmost binding graph in the component path among the given components. */
+    public BindingGraph rootmostGraph(Iterable<ComponentDescriptor> components) {
+      ImmutableSet<ComponentDescriptor> set = ImmutableSet.copyOf(components);
+      return rootmostGraph(graph -> set.contains(graph.componentDescriptor()));
+    }
+
+    /** Returns the binding graph within this path that represents the given component. */
+    public BindingGraph graphForComponent(ComponentDescriptor component) {
+      return rootmostGraph(graph -> graph.componentDescriptor().equals(component));
+    }
+
+    private BindingGraph rootmostGraph(Predicate<? super BindingGraph> predicate) {
+      return bindingGraphPath.stream().filter(predicate).findFirst().get();
+    }
+  }
+
+  /**
+   * An immutable snapshot of a path through the binding graph.
+   *
+   * <p>The path contains pairs of a dependency request and the bindings resolved for it. At each
+   * step after the first the dependency request is contained by one of the bindings resolved for
+   * the previous dependency request.
+   */
+  public static final class DependencyTrace {
+    private final ImmutableList<DependencyRequest> dependencyRequests;
+    private final ImmutableList<ResolvedBindings> resolvedBindings;
+
+    private DependencyTrace(
+        Iterable<DependencyRequest> dependencyRequests,
+        Iterable<ResolvedBindings> resolvedBindings) {
+      this.dependencyRequests = ImmutableList.copyOf(dependencyRequests);
+      this.resolvedBindings = ImmutableList.copyOf(resolvedBindings);
+      checkArgument(
+          this.dependencyRequests.size() == this.resolvedBindings.size(),
+          "dependency requests and resolved bindings must have the same size: %s vs. %s",
+          this.dependencyRequests,
+          this.resolvedBindings);
+    }
+
+    /** Calls {@code consumer} for every dependency request and the bindings resolved for it. */
+    protected final void forEach(
+        BiConsumer<? super DependencyRequest, ? super ResolvedBindings> consumer) {
+      Iterator<DependencyRequest> dependencyRequestIterator = dependencyRequests.iterator();
+      Iterator<ResolvedBindings> resolvedBindingsIterator = resolvedBindings.iterator();
+      while (dependencyRequestIterator.hasNext()) {
+        consumer.accept(dependencyRequestIterator.next(), resolvedBindingsIterator.next());
+      }
+    }
+
+    /**
+     * Returns an ordered stream of the results of calling {@code function} on every dependency
+     * request and the bindings resolved for it.
+     */
+    protected final <T> Stream<T> transform(
+        BiFunction<? super DependencyRequest, ? super ResolvedBindings, T> function) {
+      Iterator<DependencyRequest> dependencyRequestIterator = dependencyRequests.iterator();
+      Iterator<ResolvedBindings> resolvedBindingsIterator = resolvedBindings.iterator();
+      return StreamSupport.stream(
+          new AbstractSpliterator<T>(dependencyRequests.size(), ORDERED | SIZED) {
+            @Override
+            public boolean tryAdvance(Consumer<? super T> action) {
+              if (!dependencyRequestIterator.hasNext()) {
+                return false;
+              }
+              action.accept(
+                  function.apply(
+                      dependencyRequestIterator.next(), resolvedBindingsIterator.next()));
+              return true;
+            }
+          },
+          false);
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
index 3ed9fc84b..dbb463341 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
@@ -19,19 +19,20 @@
 import static com.google.auto.common.MoreElements.asExecutable;
 import static dagger.internal.codegen.ErrorMessages.DOUBLE_INDENT;
 import static dagger.internal.codegen.ErrorMessages.INDENT;
+import static dagger.internal.codegen.Util.toImmutableList;
 
 import com.google.auto.common.MoreElements;
 import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
-import com.google.common.base.Predicates;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.util.concurrent.ListenableFuture;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import dagger.Lazy;
 import dagger.Provides;
-import dagger.internal.codegen.BindingGraphValidator.DependencyPath;
+import dagger.internal.codegen.ComponentTreeTraverser.DependencyTrace;
 import dagger.producers.Produces;
 import java.util.List;
+import java.util.concurrent.atomic.AtomicReference;
 import javax.inject.Inject;
 import javax.inject.Provider;
 import javax.lang.model.element.AnnotationMirror;
@@ -77,28 +78,24 @@
     this.elements = elements;
   }
 
-  /**
-   * A string representation of the dependency trace, starting with the current request and ending
-   * with the entry point.
-   */
-  String toDependencyTrace(DependencyPath dependencyPath) {
+  /** Returns a representation of the dependency trace, with the entry point at the bottom. */
+  String format(DependencyTrace dependencyTrace) {
+    AtomicReference<ImmutableSet<OptionalBindingDeclaration>> dependentOptionalBindingDeclarations =
+        new AtomicReference<>(ImmutableSet.of());
     return Joiner.on('\n')
         .join(
-            dependencyPath
-                .resolvedRequests()
+            dependencyTrace
                 .transform(
-                    resolvedRequest -> {
+                    (dependencyRequest, resolvedBindings) -> {
                       ImmutableSet<OptionalBindingDeclaration> optionalBindingDeclarations =
-                          resolvedRequest
-                              .dependentResolvedBindings()
-                              .transform(ResolvedBindings::optionalBindingDeclarations)
-                              .or(ImmutableSet.of());
+                          dependentOptionalBindingDeclarations.getAndSet(
+                              resolvedBindings.optionalBindingDeclarations());
                       return optionalBindingDeclarations.isEmpty()
-                          ? format(resolvedRequest.dependencyRequest())
+                          ? format(dependencyRequest)
                           : formatSyntheticOptionalBindingDependency(optionalBindingDeclarations);
                     })
-                .filter(Predicates.not(Predicates.equalTo("")))
-                .toList()
+                .filter(f -> !f.isEmpty())
+                .collect(toImmutableList())
                 .reverse());
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index c98e366d7..36a13b28a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -20,6 +20,8 @@
 import static com.google.auto.common.MoreElements.hasModifiers;
 import static com.google.auto.common.MoreTypes.asDeclared;
 import static com.google.common.collect.Lists.asList;
+import static java.util.stream.Collectors.collectingAndThen;
+import static java.util.stream.Collectors.toList;
 import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.PRIVATE;
@@ -30,12 +32,14 @@
 import com.google.common.base.Function;
 import com.google.common.base.Optional;
 import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import dagger.Binds;
 import dagger.Provides;
 import dagger.producers.Produces;
 import java.lang.annotation.Annotation;
 import java.util.Comparator;
+import java.util.stream.Collector;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementVisitor;
@@ -218,5 +222,21 @@ static boolean isAnnotationPresent(Element element, TypeMirror annotationType) {
         .thenComparing(Optional::get);
   }
 
+  /**
+   * Returns a {@link Collector} that accumulates the input elements into a new {@link
+   * ImmutableList}, in encounter order.
+   */
+  static <T> Collector<T, ?, ImmutableList<T>> toImmutableList() {
+    return collectingAndThen(toList(), ImmutableList::copyOf);
+  }
+
+  /**
+   * Returns a {@link Collector} that accumulates the input elements into a new {@link
+   * ImmutableSet}, in encounter order.
+   */
+  static <T> Collector<T, ?, ImmutableSet<T>> toImmutableSet() {
+    return collectingAndThen(toList(), ImmutableSet::copyOf);
+  }
+
   private Util() {}
 }
