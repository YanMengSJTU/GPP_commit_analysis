diff --git a/java/dagger/internal/codegen/ComponentBindingExpressions.java b/java/dagger/internal/codegen/ComponentBindingExpressions.java
index 37cf1e8fa..b6b1ecdc2 100644
--- a/java/dagger/internal/codegen/ComponentBindingExpressions.java
+++ b/java/dagger/internal/codegen/ComponentBindingExpressions.java
@@ -20,7 +20,6 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Verify.verify;
 import static dagger.internal.codegen.BindingRequest.bindingRequest;
-import static dagger.internal.codegen.BindingType.MEMBERS_INJECTION;
 import static dagger.internal.codegen.DelegateBindingExpression.isBindsScopeStrongerThanDependencyScope;
 import static dagger.internal.codegen.MemberSelect.staticFactoryCreation;
 import static dagger.internal.codegen.RequestKinds.isDerivedFromProvider;
@@ -47,6 +46,7 @@
 import dagger.internal.codegen.langmodel.DaggerElements;
 import dagger.internal.codegen.langmodel.DaggerTypes;
 import dagger.model.DependencyRequest;
+import dagger.model.Key;
 import dagger.model.RequestKind;
 import java.util.HashMap;
 import java.util.Map;
@@ -273,7 +273,8 @@ BindingExpression createBindingExpression(
     switch (resolvedBindings.bindingType()) {
       case MEMBERS_INJECTION:
         checkArgument(request.isRequestKind(RequestKind.MEMBERS_INJECTION));
-        return new MembersInjectionBindingExpression(resolvedBindings, membersInjectionMethods);
+        return new MembersInjectionBindingExpression(
+            resolvedBindings.membersInjectionBinding().get(), membersInjectionMethods);
 
       case PROVISION:
         return provisionBindingExpression(resolvedBindings, request);
@@ -290,38 +291,37 @@ BindingExpression createBindingExpression(
    */
   private BindingExpression frameworkInstanceBindingExpression(ResolvedBindings resolvedBindings) {
     // TODO(user): Consider merging the static factory creation logic into CreationExpressions?
+    ContributionBinding binding = resolvedBindings.contributionBinding();
     Optional<MemberSelect> staticMethod =
-        useStaticFactoryCreation(resolvedBindings.contributionBinding())
-            ? staticFactoryCreation(resolvedBindings)
-            : Optional.empty();
+        useStaticFactoryCreation(binding) ? staticFactoryCreation(binding) : Optional.empty();
     FrameworkInstanceCreationExpression frameworkInstanceCreationExpression =
-        resolvedBindings.scope().isPresent()
-            ? scope(resolvedBindings, frameworkInstanceCreationExpression(resolvedBindings))
-            : frameworkInstanceCreationExpression(resolvedBindings);
+        binding.scope().isPresent()
+            ? scope(binding, frameworkInstanceCreationExpression(binding))
+            : frameworkInstanceCreationExpression(binding);
     FrameworkInstanceSupplier frameworkInstanceSupplier =
         staticMethod.isPresent()
             ? staticMethod::get
             : new FrameworkFieldInitializer(
                 componentImplementation, resolvedBindings, frameworkInstanceCreationExpression);
 
-    switch (resolvedBindings.bindingType()) {
+    switch (binding.bindingType()) {
       case PROVISION:
         return new ProviderInstanceBindingExpression(
-            resolvedBindings, frameworkInstanceSupplier, types, elements);
+            binding, frameworkInstanceSupplier, types, elements);
       case PRODUCTION:
         return new ProducerNodeInstanceBindingExpression(
-            resolvedBindings, frameworkInstanceSupplier, types, elements, componentImplementation);
+            binding, frameworkInstanceSupplier, types, elements, componentImplementation);
       default:
-        throw new AssertionError("invalid binding type: " + resolvedBindings.bindingType());
+        throw new AssertionError("invalid binding type: " + binding.bindingType());
     }
   }
 
   private FrameworkInstanceCreationExpression scope(
-      ResolvedBindings resolvedBindings, FrameworkInstanceCreationExpression unscoped) {
+      ContributionBinding binding, FrameworkInstanceCreationExpression unscoped) {
     return () ->
         CodeBlock.of(
             "$T.provider($L)",
-            resolvedBindings.scope().get().isReusable() ? SINGLE_CHECK : DOUBLE_CHECK,
+            binding.scope().get().isReusable() ? SINGLE_CHECK : DOUBLE_CHECK,
             unscoped.creationExpression());
   }
 
@@ -330,9 +330,7 @@ private FrameworkInstanceCreationExpression scope(
    * {@link dagger.producers.Producer} for production bindings.
    */
   private FrameworkInstanceCreationExpression frameworkInstanceCreationExpression(
-      ResolvedBindings resolvedBindings) {
-    checkArgument(!resolvedBindings.bindingType().equals(MEMBERS_INJECTION));
-    ContributionBinding binding = resolvedBindings.contributionBinding();
+      ContributionBinding binding) {
     switch (binding.kind()) {
       case COMPONENT:
         // The cast can be removed when we drop java 7 source support
@@ -413,6 +411,7 @@ private BindingExpression provisionBindingExpression(
       return producerFromProviderBindingExpression(resolvedBindings);
     }
     RequestKind requestKind = request.requestKind().get();
+    Key key = request.key();
     switch (requestKind) {
       case INSTANCE:
         return instanceBindingExpression(resolvedBindings);
@@ -424,13 +423,13 @@ private BindingExpression provisionBindingExpression(
       case PRODUCED:
       case PROVIDER_OF_LAZY:
         return new DerivedFromFrameworkInstanceBindingExpression(
-            resolvedBindings.key(), FrameworkType.PROVIDER, requestKind, this, types);
+            key, FrameworkType.PROVIDER, requestKind, this, types);
 
       case PRODUCER:
         return producerFromProviderBindingExpression(resolvedBindings);
 
       case FUTURE:
-        return new ImmediateFutureBindingExpression(resolvedBindings, this, types, sourceVersion);
+        return new ImmediateFutureBindingExpression(key, this, types, sourceVersion);
 
       case MEMBERS_INJECTION:
         throw new IllegalArgumentException();
@@ -448,14 +447,14 @@ private BindingExpression productionBindingExpression(
       // If no FrameworkType is present, a RequestKind is guaranteed to be present.
       RequestKind requestKind = request.requestKind().get();
       return new DerivedFromFrameworkInstanceBindingExpression(
-          resolvedBindings.key(), FrameworkType.PRODUCER_NODE, requestKind, this, types);
+          request.key(), FrameworkType.PRODUCER_NODE, requestKind, this, types);
     }
   }
 
   /**
    * Returns a binding expression for {@link RequestKind#PROVIDER} requests.
    *
-   * <p>{@code @Binds} bindings that don't {@linkplain #needsCaching(ResolvedBindings) need to be
+   * <p>{@code @Binds} bindings that don't {@linkplain #needsCaching(ContributionBinding) need to be
    * cached} can use a {@link DelegateBindingExpression}.
    *
    * <p>In fastInit mode, use an {@link InnerSwitchingProviders inner switching provider} unless
@@ -465,18 +464,18 @@ private BindingExpression productionBindingExpression(
    * <p>Otherwise, return a {@link FrameworkInstanceBindingExpression}.
    */
   private BindingExpression providerBindingExpression(ResolvedBindings resolvedBindings) {
-    if (resolvedBindings.contributionBinding().kind().equals(DELEGATE)
-        && !needsCaching(resolvedBindings)) {
+    ContributionBinding binding = resolvedBindings.contributionBinding();
+    if (binding.kind().equals(DELEGATE) && !needsCaching(binding)) {
       return new DelegateBindingExpression(
-          resolvedBindings, RequestKind.PROVIDER, this, types, elements);
+          binding, RequestKind.PROVIDER, this, types, elements);
     } else if (compilerOptions.fastInit()
-        && frameworkInstanceCreationExpression(resolvedBindings).useInnerSwitchingProvider()
+        && frameworkInstanceCreationExpression(binding).useInnerSwitchingProvider()
         && !(instanceBindingExpression(resolvedBindings)
             instanceof DerivedFromFrameworkInstanceBindingExpression)) {
       return wrapInMethod(
           resolvedBindings,
-          bindingRequest(resolvedBindings.key(), RequestKind.PROVIDER),
-          innerSwitchingProviders.newBindingExpression(resolvedBindings.contributionBinding()));
+          bindingRequest(binding.key(), RequestKind.PROVIDER),
+          innerSwitchingProviders.newBindingExpression(binding));
     }
     return frameworkInstanceBindingExpression(resolvedBindings);
   }
@@ -487,14 +486,14 @@ private BindingExpression providerBindingExpression(ResolvedBindings resolvedBin
    */
   private FrameworkInstanceBindingExpression producerFromProviderBindingExpression(
       ResolvedBindings resolvedBindings) {
-    checkArgument(resolvedBindings.bindingType().equals(BindingType.PROVISION));
+    ContributionBinding binding = resolvedBindings.contributionBinding();
+    checkArgument(binding.bindingType().equals(BindingType.PROVISION));
     return new ProducerNodeInstanceBindingExpression(
-        resolvedBindings,
+        binding,
         new FrameworkFieldInitializer(
             componentImplementation,
             resolvedBindings,
-            new ProducerFromProviderCreationExpression(
-                resolvedBindings.contributionBinding(), componentImplementation, this)),
+            new ProducerFromProviderCreationExpression(binding, componentImplementation, this)),
         types,
         elements,
         componentImplementation);
@@ -505,26 +504,25 @@ private FrameworkInstanceBindingExpression producerFromProviderBindingExpression
    *
    * <p>If there is a direct expression (not calling {@link Provider#get()}) we can use for an
    * instance of this binding, return it, wrapped in a method if the binding {@linkplain
-   * #needsCaching(ResolvedBindings) needs to be cached} or the expression has dependencies.
+   * #needsCaching(ContributionBinding) needs to be cached} or the expression has dependencies.
    *
    * <p>In fastInit mode, we can use direct expressions unless the binding needs to be cached.
    */
   private BindingExpression instanceBindingExpression(ResolvedBindings resolvedBindings) {
+    ContributionBinding binding = resolvedBindings.contributionBinding();
     Optional<BindingExpression> maybeDirectInstanceExpression =
-        unscopedDirectInstanceExpression(resolvedBindings);
-    if (canUseDirectInstanceExpression(resolvedBindings)
-        && maybeDirectInstanceExpression.isPresent()) {
+        unscopedDirectInstanceExpression(binding);
+    if (canUseDirectInstanceExpression(binding) && maybeDirectInstanceExpression.isPresent()) {
       BindingExpression directInstanceExpression = maybeDirectInstanceExpression.get();
-      return directInstanceExpression.requiresMethodEncapsulation()
-              || needsCaching(resolvedBindings)
+      return directInstanceExpression.requiresMethodEncapsulation() || needsCaching(binding)
           ? wrapInMethod(
               resolvedBindings,
-              bindingRequest(resolvedBindings.key(), RequestKind.INSTANCE),
+              bindingRequest(binding.key(), RequestKind.INSTANCE),
               directInstanceExpression)
           : directInstanceExpression;
     }
     return new DerivedFromFrameworkInstanceBindingExpression(
-        resolvedBindings.key(), FrameworkType.PROVIDER, RequestKind.INSTANCE, this, types);
+        binding.key(), FrameworkType.PROVIDER, RequestKind.INSTANCE, this, types);
   }
 
   /**
@@ -532,62 +530,62 @@ private BindingExpression instanceBindingExpression(ResolvedBindings resolvedBin
    * {@code get()} on its provider, if there is one.
    */
   private Optional<BindingExpression> unscopedDirectInstanceExpression(
-      ResolvedBindings resolvedBindings) {
-    switch (resolvedBindings.contributionBinding().kind()) {
+      ContributionBinding binding) {
+    switch (binding.kind()) {
       case DELEGATE:
         return Optional.of(
-            new DelegateBindingExpression(
-                resolvedBindings, RequestKind.INSTANCE, this, types, elements));
+            new DelegateBindingExpression(binding, RequestKind.INSTANCE, this, types, elements));
 
       case COMPONENT:
         return Optional.of(
-            new ComponentInstanceBindingExpression(
-                resolvedBindings, componentImplementation.name()));
+            new ComponentInstanceBindingExpression(binding, componentImplementation.name()));
 
       case COMPONENT_DEPENDENCY:
         return Optional.of(
             new ComponentRequirementBindingExpression(
-                resolvedBindings,
-                ComponentRequirement.forDependency(resolvedBindings.key().type()),
+                binding,
+                ComponentRequirement.forDependency(binding.key().type()),
                 componentRequirementExpressions));
 
       case COMPONENT_PROVISION:
         return Optional.of(
             new ComponentProvisionBindingExpression(
-                resolvedBindings, graph, componentRequirementExpressions, compilerOptions));
+                (ProvisionBinding) binding,
+                graph,
+                componentRequirementExpressions,
+                compilerOptions));
 
       case SUBCOMPONENT_CREATOR:
         return Optional.of(
             new SubcomponentCreatorBindingExpression(
-                resolvedBindings,
-                componentImplementation.getSubcomponentCreatorSimpleName(resolvedBindings.key())));
+                binding, componentImplementation.getSubcomponentCreatorSimpleName(binding.key())));
 
       case MULTIBOUND_SET:
         return Optional.of(
             new SetBindingExpression(
-                resolvedBindings, componentImplementation, graph, this, types, elements));
+                (ProvisionBinding) binding, componentImplementation, graph, this, types, elements));
 
       case MULTIBOUND_MAP:
         return Optional.of(
             new MapBindingExpression(
-                resolvedBindings, componentImplementation, graph, this, types, elements));
+                (ProvisionBinding) binding, componentImplementation, graph, this, types, elements));
 
       case OPTIONAL:
         return Optional.of(
-            new OptionalBindingExpression(resolvedBindings, this, types, sourceVersion));
+            new OptionalBindingExpression((ProvisionBinding) binding, this, types, sourceVersion));
 
       case BOUND_INSTANCE:
         return Optional.of(
             new ComponentRequirementBindingExpression(
-                resolvedBindings,
-                ComponentRequirement.forBoundInstance(resolvedBindings.contributionBinding()),
+                binding,
+                ComponentRequirement.forBoundInstance(binding),
                 componentRequirementExpressions));
 
       case INJECTION:
       case PROVISION:
         return Optional.of(
             new SimpleMethodBindingExpression(
-                resolvedBindings,
+                (ProvisionBinding) binding,
                 compilerOptions,
                 this,
                 membersInjectionMethods,
@@ -602,8 +600,7 @@ private BindingExpression instanceBindingExpression(ResolvedBindings resolvedBin
       case MEMBERS_INJECTION:
       case COMPONENT_PRODUCTION:
       case PRODUCTION:
-        throw new IllegalArgumentException(
-            resolvedBindings.contributionBinding().kind().toString());
+        throw new IllegalArgumentException(binding.kind().toString());
     }
     throw new AssertionError();
   }
@@ -624,14 +621,14 @@ private boolean useStaticFactoryCreation(ContributionBinding binding) {
 
   /**
    * Returns {@code true} if we can use a direct (not {@code Provider.get()}) expression for this
-   * binding. If the binding doesn't {@linkplain #needsCaching(ResolvedBindings) need to be cached},
-   * we can.
+   * binding. If the binding doesn't {@linkplain #needsCaching(ContributionBinding) need to be
+   * cached}, we can.
    *
    * <p>In fastInit mode, we can use a direct expression even if the binding {@linkplain
-   * #needsCaching(ResolvedBindings) needs to be cached}.
+   * #needsCaching(ContributionBinding) needs to be cached}.
    */
-  private boolean canUseDirectInstanceExpression(ResolvedBindings resolvedBindings) {
-    return !needsCaching(resolvedBindings) || compilerOptions.fastInit();
+  private boolean canUseDirectInstanceExpression(ContributionBinding binding) {
+    return !needsCaching(binding) || compilerOptions.fastInit();
   }
 
   /**
@@ -651,7 +648,7 @@ BindingExpression wrapInMethod(
     }
 
     MethodImplementationStrategy methodImplementationStrategy =
-        methodImplementationStrategy(resolvedBindings, request);
+        methodImplementationStrategy(resolvedBindings.contributionBinding(), request);
     Optional<ComponentMethodDescriptor> matchingComponentMethod =
         graph.componentDescriptor().firstMatchingComponentMethod(request);
 
@@ -682,12 +679,12 @@ BindingExpression wrapInMethod(
   }
 
   private MethodImplementationStrategy methodImplementationStrategy(
-      ResolvedBindings resolvedBindings, BindingRequest request) {
+      ContributionBinding binding, BindingRequest request) {
     if (compilerOptions.fastInit()) {
       if (request.isRequestKind(RequestKind.PROVIDER)) {
         return MethodImplementationStrategy.SINGLE_CHECK;
-      } else if (request.isRequestKind(RequestKind.INSTANCE) && needsCaching(resolvedBindings)) {
-        return resolvedBindings.scope().get().isReusable()
+      } else if (request.isRequestKind(RequestKind.INSTANCE) && needsCaching(binding)) {
+        return binding.scope().get().isReusable()
             ? MethodImplementationStrategy.SINGLE_CHECK
             : MethodImplementationStrategy.DOUBLE_CHECK;
       }
@@ -701,12 +698,12 @@ private MethodImplementationStrategy methodImplementationStrategy(
    * <p>The component needs to cache the value for scoped bindings except for {@code @Binds}
    * bindings whose scope is no stronger than their delegate's.
    */
-  private boolean needsCaching(ResolvedBindings resolvedBindings) {
-    if (!resolvedBindings.scope().isPresent()) {
+  private boolean needsCaching(ContributionBinding binding) {
+    if (!binding.scope().isPresent()) {
       return false;
     }
-    if (resolvedBindings.contributionBinding().kind().equals(DELEGATE)) {
-      return isBindsScopeStrongerThanDependencyScope(resolvedBindings, graph);
+    if (binding.kind().equals(DELEGATE)) {
+      return isBindsScopeStrongerThanDependencyScope(binding, graph);
     }
     return true;
   }
diff --git a/java/dagger/internal/codegen/ComponentInstanceBindingExpression.java b/java/dagger/internal/codegen/ComponentInstanceBindingExpression.java
index e98d595d3..9ec177af1 100644
--- a/java/dagger/internal/codegen/ComponentInstanceBindingExpression.java
+++ b/java/dagger/internal/codegen/ComponentInstanceBindingExpression.java
@@ -25,10 +25,10 @@
   private final ClassName componentName;
   private final ContributionBinding binding;
 
-  ComponentInstanceBindingExpression(ResolvedBindings resolvedBindings, ClassName componentName) {
-    super(resolvedBindings);
+  ComponentInstanceBindingExpression(ContributionBinding binding, ClassName componentName) {
+    super(binding);
+    this.binding = binding;
     this.componentName = componentName;
-    this.binding = resolvedBindings.contributionBinding();
   }
 
   @Override
diff --git a/java/dagger/internal/codegen/ComponentProvisionBindingExpression.java b/java/dagger/internal/codegen/ComponentProvisionBindingExpression.java
index b8c60496e..4a134507e 100644
--- a/java/dagger/internal/codegen/ComponentProvisionBindingExpression.java
+++ b/java/dagger/internal/codegen/ComponentProvisionBindingExpression.java
@@ -31,12 +31,12 @@
   private final CompilerOptions compilerOptions;
 
   ComponentProvisionBindingExpression(
-      ResolvedBindings resolvedBindings,
+      ProvisionBinding binding,
       BindingGraph bindingGraph,
       ComponentRequirementExpressions componentRequirementExpressions,
       CompilerOptions compilerOptions) {
-    super(resolvedBindings);
-    this.binding = (ProvisionBinding) resolvedBindings.contributionBinding();
+    super(binding);
+    this.binding = binding;
     this.bindingGraph = checkNotNull(bindingGraph);
     this.componentRequirementExpressions = checkNotNull(componentRequirementExpressions);
     this.compilerOptions = checkNotNull(compilerOptions);
diff --git a/java/dagger/internal/codegen/ComponentRequirementBindingExpression.java b/java/dagger/internal/codegen/ComponentRequirementBindingExpression.java
index d6aa053be..1a044f389 100644
--- a/java/dagger/internal/codegen/ComponentRequirementBindingExpression.java
+++ b/java/dagger/internal/codegen/ComponentRequirementBindingExpression.java
@@ -29,10 +29,10 @@
   private final ComponentRequirementExpressions componentRequirementExpressions;
 
   ComponentRequirementBindingExpression(
-      ResolvedBindings resolvedBindings,
+      ContributionBinding binding,
       ComponentRequirement componentRequirement,
       ComponentRequirementExpressions componentRequirementExpressions) {
-    super(resolvedBindings);
+    super(binding);
     this.componentRequirement = componentRequirement;
     this.componentRequirementExpressions = componentRequirementExpressions;
   }
diff --git a/java/dagger/internal/codegen/DelegateBindingExpression.java b/java/dagger/internal/codegen/DelegateBindingExpression.java
index 2249f800f..6a42927ea 100644
--- a/java/dagger/internal/codegen/DelegateBindingExpression.java
+++ b/java/dagger/internal/codegen/DelegateBindingExpression.java
@@ -40,12 +40,12 @@
   private final BindsTypeChecker bindsTypeChecker;
 
   DelegateBindingExpression(
-      ResolvedBindings resolvedBindings,
+      ContributionBinding binding,
       RequestKind requestKind,
       ComponentBindingExpressions componentBindingExpressions,
       DaggerTypes types,
       DaggerElements elements) {
-    this.binding = checkNotNull(resolvedBindings.contributionBinding());
+    this.binding = checkNotNull(binding);
     this.requestKind = checkNotNull(requestKind);
     this.componentBindingExpressions = checkNotNull(componentBindingExpressions);
     this.types = checkNotNull(types);
@@ -57,8 +57,7 @@
    * binding it depends on.
    */
   static boolean isBindsScopeStrongerThanDependencyScope(
-      ResolvedBindings resolvedBindings, BindingGraph graph) {
-    ContributionBinding bindsBinding = resolvedBindings.contributionBinding();
+      ContributionBinding bindsBinding, BindingGraph graph) {
     checkArgument(bindsBinding.kind().equals(DELEGATE));
     Binding dependencyBinding =
         graph
diff --git a/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java b/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java
index 6f62d66a7..103765735 100644
--- a/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java
+++ b/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java
@@ -30,17 +30,17 @@
 
 /** A binding expression that uses a {@link FrameworkType} field. */
 abstract class FrameworkInstanceBindingExpression extends BindingExpression {
-  private final ResolvedBindings resolvedBindings;
+  private final ContributionBinding binding;
   private final FrameworkInstanceSupplier frameworkInstanceSupplier;
   private final DaggerTypes types;
   private final DaggerElements elements;
 
   FrameworkInstanceBindingExpression(
-      ResolvedBindings resolvedBindings,
+      ContributionBinding binding,
       FrameworkInstanceSupplier frameworkInstanceSupplier,
       DaggerTypes types,
       DaggerElements elements) {
-    this.resolvedBindings = checkNotNull(resolvedBindings);
+    this.binding = checkNotNull(binding);
     this.frameworkInstanceSupplier = checkNotNull(frameworkInstanceSupplier);
     this.types = checkNotNull(types);
     this.elements = checkNotNull(elements);
@@ -55,11 +55,10 @@
   @Override
   Expression getDependencyExpression(ClassName requestingClass) {
     MemberSelect memberSelect = frameworkInstanceSupplier.memberSelect();
-    TypeMirror contributedType = resolvedBindings.contributionBinding().contributedType();
     TypeMirror expressionType =
-        isTypeAccessibleFrom(contributedType, requestingClass.packageName())
+        isTypeAccessibleFrom(binding.contributedType(), requestingClass.packageName())
                 || isInlinedFactoryCreation(memberSelect)
-            ? types.wrapType(contributedType, frameworkType().frameworkClass())
+            ? types.wrapType(binding.contributedType(), frameworkType().frameworkClass())
             : rawFrameworkType();
     return Expression.create(expressionType, memberSelect.getExpressionFor(requestingClass));
   }
diff --git a/java/dagger/internal/codegen/ImmediateFutureBindingExpression.java b/java/dagger/internal/codegen/ImmediateFutureBindingExpression.java
index 69b107c2b..9a0853c7d 100644
--- a/java/dagger/internal/codegen/ImmediateFutureBindingExpression.java
+++ b/java/dagger/internal/codegen/ImmediateFutureBindingExpression.java
@@ -30,21 +30,20 @@
 import javax.lang.model.SourceVersion;
 
 final class ImmediateFutureBindingExpression extends BindingExpression {
-
+  private final Key key;
   private final ComponentBindingExpressions componentBindingExpressions;
   private final DaggerTypes types;
   private final SourceVersion sourceVersion;
-  private final Key key;
 
   ImmediateFutureBindingExpression(
-      ResolvedBindings resolvedBindings,
+      Key key,
       ComponentBindingExpressions componentBindingExpressions,
       DaggerTypes types,
       SourceVersion sourceVersion) {
+    this.key = key;
     this.componentBindingExpressions = checkNotNull(componentBindingExpressions);
     this.types = checkNotNull(types);
     this.sourceVersion = checkNotNull(sourceVersion);
-    this.key = resolvedBindings.key();
   }
 
   @Override
diff --git a/java/dagger/internal/codegen/MapBindingExpression.java b/java/dagger/internal/codegen/MapBindingExpression.java
index 526c493ec..bc2cf4dc4 100644
--- a/java/dagger/internal/codegen/MapBindingExpression.java
+++ b/java/dagger/internal/codegen/MapBindingExpression.java
@@ -52,14 +52,14 @@
   private final DaggerElements elements;
 
   MapBindingExpression(
-      ResolvedBindings resolvedBindings,
+      ProvisionBinding binding,
       ComponentImplementation componentImplementation,
       BindingGraph graph,
       ComponentBindingExpressions componentBindingExpressions,
       DaggerTypes types,
       DaggerElements elements) {
-    super(resolvedBindings, componentImplementation);
-    this.binding = (ProvisionBinding) resolvedBindings.contributionBinding();
+    super(binding, componentImplementation);
+    this.binding = binding;
     BindingKind bindingKind = this.binding.kind();
     checkArgument(bindingKind.equals(MULTIBOUND_MAP), bindingKind);
     this.componentBindingExpressions = componentBindingExpressions;
diff --git a/java/dagger/internal/codegen/MemberSelect.java b/java/dagger/internal/codegen/MemberSelect.java
index c42c7c9ae..4ae874516 100644
--- a/java/dagger/internal/codegen/MemberSelect.java
+++ b/java/dagger/internal/codegen/MemberSelect.java
@@ -106,21 +106,7 @@ CodeBlock getExpressionFor(ClassName usingClass) {
    * this method returns the static member select that returns the factory or no-op members
    * injector.
    */
-  static Optional<MemberSelect> staticFactoryCreation(ResolvedBindings resolvedBindings) {
-    if (resolvedBindings.contributionBindings().isEmpty()) {
-      throw new AssertionError(
-          "Expected a contribution binding, but none found. *THIS IS A DAGGER BUG* - please "
-              + "report it on Github with as much context as you can provide. Thanks!"
-              + "\n\nKey: "
-              + resolvedBindings.key()
-              + "\nMultibinding declarations: "
-              + resolvedBindings.multibindingDeclarations()
-              + "\nSubcomponent declarations: "
-              + resolvedBindings.subcomponentDeclarations()
-              + "\nOptional binding declarations: "
-              + resolvedBindings.optionalBindingDeclarations());
-    }
-    ContributionBinding contributionBinding = resolvedBindings.contributionBinding();
+  static Optional<MemberSelect> staticFactoryCreation(ContributionBinding contributionBinding) {
     if (contributionBinding.factoryCreationStrategy().equals(SINGLETON_INSTANCE)
         && !contributionBinding.scope().isPresent()) {
       switch (contributionBinding.kind()) {
@@ -132,7 +118,7 @@ CodeBlock getExpressionFor(ClassName usingClass) {
 
         case INJECTION:
         case PROVISION:
-          TypeMirror keyType = resolvedBindings.key().type();
+          TypeMirror keyType = contributionBinding.key().type();
           if (keyType.getKind().equals(DECLARED)) {
             ImmutableList<TypeVariableName> typeVariables =
                 bindingTypeElementTypeVariableNames(contributionBinding);
diff --git a/java/dagger/internal/codegen/MembersInjectionBindingExpression.java b/java/dagger/internal/codegen/MembersInjectionBindingExpression.java
index e9a8ffc3d..f2b1d1a6e 100644
--- a/java/dagger/internal/codegen/MembersInjectionBindingExpression.java
+++ b/java/dagger/internal/codegen/MembersInjectionBindingExpression.java
@@ -35,8 +35,8 @@
   private final MembersInjectionMethods membersInjectionMethods;
 
   MembersInjectionBindingExpression(
-      ResolvedBindings resolvedBindings, MembersInjectionMethods membersInjectionMethods) {
-    this.binding = resolvedBindings.membersInjectionBinding().get();
+      MembersInjectionBinding binding, MembersInjectionMethods membersInjectionMethods) {
+    this.binding = binding;
     this.membersInjectionMethods = membersInjectionMethods;
   }
 
diff --git a/java/dagger/internal/codegen/MultibindingExpression.java b/java/dagger/internal/codegen/MultibindingExpression.java
index f0523eb41..ff74d57d7 100644
--- a/java/dagger/internal/codegen/MultibindingExpression.java
+++ b/java/dagger/internal/codegen/MultibindingExpression.java
@@ -34,10 +34,10 @@
   private final ComponentImplementation componentImplementation;
 
   MultibindingExpression(
-      ResolvedBindings resolvedBindings, ComponentImplementation componentImplementation) {
-    super(resolvedBindings);
+      ProvisionBinding binding, ComponentImplementation componentImplementation) {
+    super(binding);
+    this.binding = binding;
     this.componentImplementation = componentImplementation;
-    this.binding = (ProvisionBinding) resolvedBindings.contributionBinding();
   }
 
   @Override
diff --git a/java/dagger/internal/codegen/OptionalBindingExpression.java b/java/dagger/internal/codegen/OptionalBindingExpression.java
index dbb0e374c..6019d5d92 100644
--- a/java/dagger/internal/codegen/OptionalBindingExpression.java
+++ b/java/dagger/internal/codegen/OptionalBindingExpression.java
@@ -38,12 +38,12 @@
 
   @Inject
   OptionalBindingExpression(
-      ResolvedBindings resolvedBindings,
+      ProvisionBinding binding,
       ComponentBindingExpressions componentBindingExpressions,
       DaggerTypes types,
       SourceVersion sourceVersion) {
-    super(resolvedBindings);
-    this.binding = (ProvisionBinding) resolvedBindings.contributionBinding();
+    super(binding);
+    this.binding = binding;
     this.componentBindingExpressions = componentBindingExpressions;
     this.types = types;
     this.sourceVersion = sourceVersion;
diff --git a/java/dagger/internal/codegen/ProducerNodeInstanceBindingExpression.java b/java/dagger/internal/codegen/ProducerNodeInstanceBindingExpression.java
index 18818d56b..a1810c877 100644
--- a/java/dagger/internal/codegen/ProducerNodeInstanceBindingExpression.java
+++ b/java/dagger/internal/codegen/ProducerNodeInstanceBindingExpression.java
@@ -33,14 +33,14 @@
   private final ProducerEntryPointView producerEntryPointView;
 
   ProducerNodeInstanceBindingExpression(
-      ResolvedBindings resolvedBindings,
+      ContributionBinding binding,
       FrameworkInstanceSupplier frameworkInstanceSupplier,
       DaggerTypes types,
       DaggerElements elements,
       ComponentImplementation componentImplementation) {
-    super(resolvedBindings, frameworkInstanceSupplier, types, elements);
+    super(binding, frameworkInstanceSupplier, types, elements);
     this.componentImplementation = checkNotNull(componentImplementation);
-    this.key = resolvedBindings.key();
+    this.key = binding.key();
     this.producerEntryPointView = new ProducerEntryPointView(types);
   }
 
diff --git a/java/dagger/internal/codegen/ProviderInstanceBindingExpression.java b/java/dagger/internal/codegen/ProviderInstanceBindingExpression.java
index 60166de64..e9f696817 100644
--- a/java/dagger/internal/codegen/ProviderInstanceBindingExpression.java
+++ b/java/dagger/internal/codegen/ProviderInstanceBindingExpression.java
@@ -23,12 +23,12 @@
 final class ProviderInstanceBindingExpression extends FrameworkInstanceBindingExpression {
 
   ProviderInstanceBindingExpression(
-      ResolvedBindings resolvedBindings,
+      ContributionBinding binding,
       FrameworkInstanceSupplier frameworkInstanceSupplier,
       DaggerTypes types,
       DaggerElements elements) {
     super(
-        resolvedBindings,
+        binding,
         frameworkInstanceSupplier,
         types,
         elements);
diff --git a/java/dagger/internal/codegen/SetBindingExpression.java b/java/dagger/internal/codegen/SetBindingExpression.java
index 5efb85fca..d2a833a79 100644
--- a/java/dagger/internal/codegen/SetBindingExpression.java
+++ b/java/dagger/internal/codegen/SetBindingExpression.java
@@ -44,14 +44,14 @@
   private final DaggerElements elements;
 
   SetBindingExpression(
-      ResolvedBindings resolvedBindings,
+      ProvisionBinding binding,
       ComponentImplementation componentImplementation,
       BindingGraph graph,
       ComponentBindingExpressions componentBindingExpressions,
       DaggerTypes types,
       DaggerElements elements) {
-    super(resolvedBindings, componentImplementation);
-    this.binding = (ProvisionBinding) resolvedBindings.contributionBinding();
+    super(binding, componentImplementation);
+    this.binding = binding;
     this.graph = graph;
     this.componentBindingExpressions = componentBindingExpressions;
     this.types = types;
diff --git a/java/dagger/internal/codegen/SimpleInvocationBindingExpression.java b/java/dagger/internal/codegen/SimpleInvocationBindingExpression.java
index 909d7ae84..297842624 100644
--- a/java/dagger/internal/codegen/SimpleInvocationBindingExpression.java
+++ b/java/dagger/internal/codegen/SimpleInvocationBindingExpression.java
@@ -20,15 +20,14 @@
 
 /** A simple binding expression for instance requests. Does not scope. */
 abstract class SimpleInvocationBindingExpression extends BindingExpression {
-  // TODO(dpb): Take ContributionBinding instead of ResolvedBindings.
-  private final ResolvedBindings resolvedBindings;
+  private final ContributionBinding binding;
 
-  SimpleInvocationBindingExpression(ResolvedBindings resolvedBindings) {
-    this.resolvedBindings = checkNotNull(resolvedBindings);
+  SimpleInvocationBindingExpression(ContributionBinding binding) {
+    this.binding = checkNotNull(binding);
   }
 
   @Override
   boolean requiresMethodEncapsulation() {
-    return !resolvedBindings.contributionBinding().dependencies().isEmpty();
+    return !binding.dependencies().isEmpty();
   }
 }
diff --git a/java/dagger/internal/codegen/SimpleMethodBindingExpression.java b/java/dagger/internal/codegen/SimpleMethodBindingExpression.java
index 805ac7b7e..1eddca53f 100644
--- a/java/dagger/internal/codegen/SimpleMethodBindingExpression.java
+++ b/java/dagger/internal/codegen/SimpleMethodBindingExpression.java
@@ -58,7 +58,7 @@
   private final SourceVersion sourceVersion;
 
   SimpleMethodBindingExpression(
-      ResolvedBindings resolvedBindings,
+      ProvisionBinding binding,
       CompilerOptions compilerOptions,
       ComponentBindingExpressions componentBindingExpressions,
       MembersInjectionMethods membersInjectionMethods,
@@ -66,9 +66,9 @@
       DaggerTypes types,
       DaggerElements elements,
       SourceVersion sourceVersion) {
-    super(resolvedBindings);
+    super(binding);
     this.compilerOptions = compilerOptions;
-    this.provisionBinding = (ProvisionBinding) resolvedBindings.contributionBinding();
+    this.provisionBinding = binding;
     checkArgument(
         provisionBinding.implicitDependencies().isEmpty(),
         "framework deps are not currently supported");
diff --git a/java/dagger/internal/codegen/SubcomponentCreatorBindingExpression.java b/java/dagger/internal/codegen/SubcomponentCreatorBindingExpression.java
index b415d3fae..4f6958303 100644
--- a/java/dagger/internal/codegen/SubcomponentCreatorBindingExpression.java
+++ b/java/dagger/internal/codegen/SubcomponentCreatorBindingExpression.java
@@ -26,9 +26,9 @@
   private final String creatorImplementationName;
 
   SubcomponentCreatorBindingExpression(
-      ResolvedBindings resolvedBindings, String creatorImplementationName) {
-    super(resolvedBindings);
-    this.creatorType = resolvedBindings.key().type();
+      ContributionBinding binding, String creatorImplementationName) {
+    super(binding);
+    this.creatorType = binding.key().type();
     this.creatorImplementationName = creatorImplementationName;
   }
 
