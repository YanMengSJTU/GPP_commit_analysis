diff --git a/java/dagger/internal/codegen/AbstractComponentWriter.java b/java/dagger/internal/codegen/AbstractComponentWriter.java
index 193022a0d..27d4be699 100644
--- a/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -33,7 +33,6 @@
 import static dagger.internal.codegen.BindingExpression.InitializationState.UNINITIALIZED;
 import static dagger.internal.codegen.BindingKey.contribution;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
-import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.SINGLETON_INSTANCE;
 import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
 import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD;
 import static dagger.internal.codegen.MapKeys.getMapKeyExpression;
@@ -111,7 +110,6 @@
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
-import javax.tools.Diagnostic;
 
 /** Creates the implementation class for a component or subcomponent. */
 abstract class AbstractComponentWriter implements HasBindingExpressions {
@@ -174,7 +172,12 @@
     this.optionalFactories = optionalFactories;
     this.bindingExpressionFactory =
         new BindingExpression.Factory(
-            name, this, childComponentNames(keyFactory, subcomponentNames), graph, elements);
+            compilerOptions,
+            name,
+            this,
+            childComponentNames(keyFactory, subcomponentNames),
+            graph,
+            elements);
   }
 
   private static ImmutableMap<BindingKey, String> childComponentNames(
@@ -781,14 +784,13 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
           // using .class & String.format -- but that wouldn't be the whole story.
           // What should we do?
           CodeBlock getMethodBody =
-              binding.nullableType().isPresent()
-                      || compilerOptions.nullableValidationKind().equals(Diagnostic.Kind.WARNING)
-                  ? CodeBlock.of("return $L;", callFactoryMethod)
-                  : CodeBlock.of(
-                      "return $T.checkNotNull($L, $S);",
+              !binding.nullableType().isPresent() && compilerOptions.doCheckForNulls()
+                  ? CodeBlock.of(
+                      "return $T.checkNotNull($L, $S);", // TODO(dpb): Extract these checkNotNulls.
                       Preconditions.class,
                       callFactoryMethod,
-                      CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD);
+                      CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD)
+                  : CodeBlock.of("return $L;", callFactoryMethod);
           ClassName dependencyClassName = ClassName.get(dependencyType);
           String factoryName =
               dependencyClassName.toString().replace('.', '_') + "_" + componentMethod;
diff --git a/java/dagger/internal/codegen/BindingExpression.java b/java/dagger/internal/codegen/BindingExpression.java
index c39741d2e..6dffed953 100644
--- a/java/dagger/internal/codegen/BindingExpression.java
+++ b/java/dagger/internal/codegen/BindingExpression.java
@@ -143,6 +143,7 @@ private void checkHasField() {
 
   /** Factory for building a {@link BindingExpression}. */
   static final class Factory {
+    private final CompilerOptions compilerOptions;
     private final ClassName componentName;
     private final HasBindingExpressions hasBindingExpressions;
     private final ImmutableMap<BindingKey, String> subcomponentNames;
@@ -150,11 +151,13 @@ private void checkHasField() {
     private final Elements elements;
 
     Factory(
+        CompilerOptions compilerOptions,
         ClassName componentName,
         HasBindingExpressions hasBindingExpressions,
         ImmutableMap<BindingKey, String> subcomponentNames,
         BindingGraph graph,
         Elements elements) {
+      this.compilerOptions = checkNotNull(compilerOptions);
       this.componentName = checkNotNull(componentName);
       this.hasBindingExpressions = checkNotNull(hasBindingExpressions);
       this.subcomponentNames = checkNotNull(subcomponentNames);
@@ -220,6 +223,7 @@ private RequestFulfillment createRequestFulfillment(
                   && !provisionBinding.requiresModuleInstance()
                   && provisionBinding.bindingElement().isPresent()) {
                 return new SimpleMethodRequestFulfillment(
+                    compilerOptions,
                     bindingKey,
                     provisionBinding,
                     providerFieldRequestFulfillment,
diff --git a/java/dagger/internal/codegen/CodeBlocks.java b/java/dagger/internal/codegen/CodeBlocks.java
index c8f06405c..8b6b4a0d7 100644
--- a/java/dagger/internal/codegen/CodeBlocks.java
+++ b/java/dagger/internal/codegen/CodeBlocks.java
@@ -20,14 +20,17 @@
 import static java.util.stream.StreamSupport.stream;
 
 import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.CodeBlock.Builder;
+import com.squareup.javapoet.MethodSpec;
 import com.squareup.javapoet.TypeName;
 import java.util.stream.Collector;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.DeclaredType;
 
 final class CodeBlocks {
   /**
@@ -76,6 +79,11 @@ static CodeBlock makeParametersCodeBlock(Iterable<CodeBlock> codeBlocks) {
     return stream(codeBlocks.spliterator(), false).collect(toParametersCodeBlock());
   }
 
+  /** Adds an annotation to a method. */
+  static void addAnnotation(MethodSpec.Builder method, DeclaredType nullableType) {
+    method.addAnnotation(ClassName.get(MoreTypes.asTypeElement(nullableType)));
+  }
+
   private static final class CodeBlockJoiner {
     private final String delimiter;
     private final CodeBlock.Builder builder;
diff --git a/java/dagger/internal/codegen/CompilerOptions.java b/java/dagger/internal/codegen/CompilerOptions.java
index b979128ac..8ff16cbb5 100644
--- a/java/dagger/internal/codegen/CompilerOptions.java
+++ b/java/dagger/internal/codegen/CompilerOptions.java
@@ -26,6 +26,7 @@
 import javax.annotation.processing.ProcessingEnvironment;
 import javax.lang.model.util.Elements;
 import javax.tools.Diagnostic;
+import javax.tools.Diagnostic.Kind;
 
 /** A collection of options that dictate how the compiler will run. */
 @AutoValue
@@ -33,6 +34,11 @@
   abstract boolean usesProducers();
   abstract boolean writeProducerNameInToken();
   abstract Diagnostic.Kind nullableValidationKind();
+
+  boolean doCheckForNulls() {
+    return nullableValidationKind().equals(Kind.ERROR);
+  }
+
   abstract Diagnostic.Kind privateMemberValidationKind();
   abstract Diagnostic.Kind staticMemberValidationKind();
   abstract boolean ignorePrivateAndStaticInjectionForComponent();
diff --git a/java/dagger/internal/codegen/FactoryGenerator.java b/java/dagger/internal/codegen/FactoryGenerator.java
index da6784fda..864ba4df8 100644
--- a/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/java/dagger/internal/codegen/FactoryGenerator.java
@@ -66,7 +66,6 @@
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.util.Elements;
-import javax.tools.Diagnostic;
 
 /**
  * Generates {@link Factory} implementations from {@link ProvisionBinding} instances for
@@ -236,29 +235,22 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
             .addModifiers(PUBLIC);
 
     if (binding.bindingKind().equals(PROVISION)) {
-      CodeBlock.Builder providesMethodInvocationBuilder = CodeBlock.builder();
-      if (binding.requiresModuleInstance()) {
-        providesMethodInvocationBuilder.add("module");
-      } else {
-        providesMethodInvocationBuilder.add(
-            "$T", ClassName.get(binding.bindingTypeElement().get()));
-      }
-      providesMethodInvocationBuilder.add(
-          ".$L($L)", binding.bindingElement().get().getSimpleName(), parametersCodeBlock);
-      CodeBlock providesMethodInvocation = providesMethodInvocationBuilder.build();
-
-      if (binding.nullableType().isPresent()
-          || compilerOptions.nullableValidationKind().equals(Diagnostic.Kind.WARNING)) {
-        if (binding.nullableType().isPresent()) {
-          getMethodBuilder.addAnnotation((ClassName) TypeName.get(binding.nullableType().get()));
-        }
-        getMethodBuilder.addStatement("return $L", providesMethodInvocation);
-      } else {
-        getMethodBuilder.addStatement("return $T.checkNotNull($L, $S)",
-            Preconditions.class,
-            providesMethodInvocation,
-            CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD);
-      }
+      binding
+          .nullableType()
+          .ifPresent(nullableType -> CodeBlocks.addAnnotation(getMethodBuilder, nullableType));
+      CodeBlock methodCall =
+          CodeBlock.of(
+              "$L.$L($L)",
+              binding.requiresModuleInstance()
+                  ? "module"
+                  : CodeBlock.of("$T", ClassName.get(binding.bindingTypeElement().get())),
+              binding.bindingElement().get().getSimpleName(),
+              parametersCodeBlock);
+      getMethodBuilder.addStatement(
+          "return $L",
+          !binding.nullableType().isPresent() && compilerOptions.doCheckForNulls()
+              ? checkNotNullProvidesMethod(methodCall)
+              : methodCall);
     } else if (binding.membersInjectionRequest().isPresent()) {
       getMethodBuilder.addStatement(
           "return $T.injectMembers($N, new $T($L))",
@@ -282,6 +274,18 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
     return Optional.of(factoryBuilder);
   }
 
+  /**
+   * Returns {@code Preconditions.checkNotNull(providesMethodInvocation)} with a message suitable
+   * for {@code @Provides} methods.
+   */
+  static CodeBlock checkNotNullProvidesMethod(CodeBlock providesMethodInvocation) {
+    return CodeBlock.of(
+        "$T.checkNotNull($L, $S)",
+        Preconditions.class,
+        providesMethodInvocation,
+        CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD);
+  }
+
   /**
    * Returns a method to proxy access to the binding's {@link Binding#bindingElement()}, which
    * behaves according to the description in {@link Proxies}. Use here is further restricted by
diff --git a/java/dagger/internal/codegen/OptionalBindingRequestFulfillment.java b/java/dagger/internal/codegen/OptionalBindingRequestFulfillment.java
index 609e24159..ed64787d0 100644
--- a/java/dagger/internal/codegen/OptionalBindingRequestFulfillment.java
+++ b/java/dagger/internal/codegen/OptionalBindingRequestFulfillment.java
@@ -55,9 +55,16 @@ CodeBlock getSimpleInvocation(DependencyRequest request, ClassName requestingCla
       return optionalKind.absentValueExpression();
     }
     DependencyRequest dependency = getOnlyElement(binding.dependencies());
-    return optionalKind.presentExpression(
+
+    CodeBlock dependencyExpression =
         hasBindingExpressions
             .getBindingExpression(dependency.bindingKey())
-            .getSnippetForDependencyRequest(dependency, requestingClass));
+            .getSnippetForDependencyRequest(dependency, requestingClass);
+
+    // If the dependency type is inaccessible, then we have to use Optional.<Object>of(...), or else
+    // we will get "incompatible types: inference variable has incompatible bounds.
+    return isTypeAccessibleFrom(dependency.key().type(), requestingClass.packageName())
+        ? optionalKind.presentExpression(dependencyExpression)
+        : optionalKind.presentObjectExpression(dependencyExpression);
   }
 }
diff --git a/java/dagger/internal/codegen/OptionalType.java b/java/dagger/internal/codegen/OptionalType.java
index c68aebf14..cd7896ef1 100644
--- a/java/dagger/internal/codegen/OptionalType.java
+++ b/java/dagger/internal/codegen/OptionalType.java
@@ -79,6 +79,14 @@ CodeBlock parameterizedAbsentValueExpression(OptionalType optionalType) {
     CodeBlock presentExpression(CodeBlock value) {
       return CodeBlock.of("$T.of($L)", clazz, value);
     }
+
+    /**
+     * Returns an expression for the present {@code value}, returning {@code Optional<Object>} no
+     * matter what type the value is.
+     */
+    CodeBlock presentObjectExpression(CodeBlock value) {
+      return CodeBlock.of("$T.<$T>of($L)", clazz, Object.class, value);
+    }
   }
 
   private static final TypeVisitor<Optional<OptionalKind>, Void> OPTIONAL_KIND =
diff --git a/java/dagger/internal/codegen/Proxies.java b/java/dagger/internal/codegen/Proxies.java
index 6a1041d8c..61d8a40db 100644
--- a/java/dagger/internal/codegen/Proxies.java
+++ b/java/dagger/internal/codegen/Proxies.java
@@ -27,6 +27,7 @@
 import static dagger.internal.codegen.Accessibility.isRawTypePubliclyAccessible;
 import static dagger.internal.codegen.CodeBlocks.javadocLinkTo;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
+import static dagger.internal.codegen.ConfigurationAnnotations.getNullableType;
 import static dagger.internal.codegen.TypeNames.rawTypeName;
 import static javax.lang.model.element.Modifier.PUBLIC;
 import static javax.lang.model.element.Modifier.STATIC;
@@ -68,6 +69,7 @@
  *       type regardless of its accessibility. For example, if a proxied method returns {@code
  *       MyPackagePrivateClass}, the proxy method will also return {@code MyPackagePrivateClass}
  *       because the accessibility of the return type does not impact callers.
+ *   <li>If the method being proxied is {@code @Nullable}, so will the proxy be.
  *   <li>Proxies for constructors are named "{@code newTypeName}" (where "{@code TypeName}" is the
  *       name of the type being constructed) and proxies for methods are named "{@code
  *       proxyMethodName}" (where "{@code methodName}" is the name of the method being proxied).
@@ -199,6 +201,9 @@ static MethodSpec createProxy(ExecutableElement method) {
     }
     CodeBlock arguments = copyParameters(method, methodBuilder, nameSet, argumentsBuilder);
     if (!method.getReturnType().getKind().equals(VOID)) {
+      methodBuilder.returns(TypeName.get(method.getReturnType()));
+      getNullableType(method)
+          .ifPresent(nullableType -> CodeBlocks.addAnnotation(methodBuilder, nullableType));
       methodBuilder.addCode("return ");
     }
     if (method.getModifiers().contains(STATIC)) {
@@ -209,7 +214,6 @@ static MethodSpec createProxy(ExecutableElement method) {
       methodBuilder.addCode("instance", method.getSimpleName());
     }
     methodBuilder.addCode(".$N($L);", method.getSimpleName(), arguments);
-    methodBuilder.returns(TypeName.get(method.getReturnType()));
     return methodBuilder;
   }
 
diff --git a/java/dagger/internal/codegen/SimpleMethodRequestFulfillment.java b/java/dagger/internal/codegen/SimpleMethodRequestFulfillment.java
index e70593836..d5325aec1 100644
--- a/java/dagger/internal/codegen/SimpleMethodRequestFulfillment.java
+++ b/java/dagger/internal/codegen/SimpleMethodRequestFulfillment.java
@@ -22,11 +22,13 @@
 import static dagger.internal.codegen.Accessibility.isRawTypeAccessible;
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
+import static dagger.internal.codegen.CodeBlocks.toParametersCodeBlock;
+import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
+import static dagger.internal.codegen.FactoryGenerator.checkNotNullProvidesMethod;
 import static dagger.internal.codegen.Proxies.proxyName;
 import static dagger.internal.codegen.Proxies.requiresProxyAccess;
 import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
 import static dagger.internal.codegen.TypeNames.rawTypeName;
-import static java.util.stream.Collectors.collectingAndThen;
 import static java.util.stream.Collectors.toList;
 import static javax.lang.model.element.Modifier.STATIC;
 
@@ -43,15 +45,18 @@
  */
 final class SimpleMethodRequestFulfillment extends SimpleInvocationRequestFulfillment {
 
+  private final CompilerOptions compilerOptions;
   private final ProvisionBinding provisionBinding;
   private final HasBindingExpressions hasBindingExpressions;
 
   SimpleMethodRequestFulfillment(
+      CompilerOptions compilerOptions,
       BindingKey bindingKey,
       ProvisionBinding provisionBinding,
       RequestFulfillment providerDelegate,
       HasBindingExpressions hasBindingExpressions) {
     super(bindingKey, providerDelegate);
+    this.compilerOptions = compilerOptions;
     checkArgument(
         provisionBinding.implicitDependencies().isEmpty(),
         "framework deps are not currently supported");
@@ -94,39 +99,48 @@ private CodeBlock invokeMethod(ClassName requestingClass) {
         return CodeBlock.of("new $T($L)", provisionBinding.key().type(), parametersCodeBlock);
       case METHOD:
         checkState(method.getModifiers().contains(STATIC));
-        return CodeBlock.of(
-            "$T.$L($L)",
-            provisionBinding.bindingTypeElement().get(),
-            method.getSimpleName(),
-            parametersCodeBlock);
+        return maybeCheckForNulls(
+            CodeBlock.of(
+                "$T.$L($L)",
+                provisionBinding.bindingTypeElement().get(),
+                method.getSimpleName(),
+                parametersCodeBlock));
       default:
         throw new IllegalStateException();
     }
   }
 
   private CodeBlock invokeProxyMethod(ClassName requestingClass) {
-    return CodeBlock.of(
-        "$T.$L($L)",
-        generatedClassNameForBinding(provisionBinding),
-        proxyName(asExecutable(provisionBinding.bindingElement().get())),
-        provisionBinding
-            .explicitDependencies()
-            .stream()
-            .map(
-                request -> {
-                  CodeBlock snippet = getDependencySnippet(requestingClass, request);
-                  TypeMirror requestElementType = request.requestElement().get().asType();
-                  /* If the type is accessible, use the snippet.  If only the raw type is
-                   * accessible, cast it to the raw type.  If the type is completely inaccessible,
-                   * the proxy will have an Object method parameter, so we can again, just use the
-                   * snippet. */
-                  return isTypeAccessibleFrom(requestElementType, requestingClass.packageName())
-                          || !isRawTypeAccessible(requestElementType, requestingClass.packageName())
-                      ? snippet
-                      : CodeBlock.of(
-                          "($T) $L", rawTypeName(TypeName.get(requestElementType)), snippet);
-                })
-            .collect(collectingAndThen(toList(), CodeBlocks::makeParametersCodeBlock)));
+    return maybeCheckForNulls(
+        CodeBlock.of(
+            "$T.$L($L)",
+            generatedClassNameForBinding(provisionBinding),
+            proxyName(asExecutable(provisionBinding.bindingElement().get())),
+            provisionBinding
+                .explicitDependencies()
+                .stream()
+                .map(request -> proxyMethodParameter(request, requestingClass))
+                .collect(toParametersCodeBlock())));
+  }
+
+  private CodeBlock proxyMethodParameter(DependencyRequest dependency, ClassName requestingClass) {
+    CodeBlock snippet = getDependencySnippet(requestingClass, dependency);
+    TypeMirror requestElementType = dependency.requestElement().get().asType();
+    /* If the type is accessible, use the snippet.  If only the raw type is accessible, cast it to
+     * the raw type.  If the type is completely inaccessible, the proxy will have an Object method
+     * parameter, so we can again, just use the snippet. */
+    return isTypeAccessibleFrom(requestElementType, requestingClass.packageName())
+            || !isRawTypeAccessible(requestElementType, requestingClass.packageName())
+        ? snippet
+        : CodeBlock.of("($T) $L", rawTypeName(TypeName.get(requestElementType)), snippet);
+  }
+
+  private CodeBlock maybeCheckForNulls(CodeBlock methodCall) {
+    return !provisionBinding.bindingKind().equals(INJECTION)
+            && !provisionBinding.nullableType().isPresent()
+            && compilerOptions.doCheckForNulls()
+        ? checkNotNullProvidesMethod(methodCall)
+        : methodCall;
   }
 
   private CodeBlock getDependencySnippet(ClassName requestingClass, DependencyRequest request) {
diff --git a/javatests/dagger/internal/codegen/ComponentProcessorTest.java b/javatests/dagger/internal/codegen/ComponentProcessorTest.java
index 0e86e8778..8ada8cfed 100644
--- a/javatests/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/javatests/dagger/internal/codegen/ComponentProcessorTest.java
@@ -18,6 +18,7 @@
 
 import static com.google.testing.compile.CompilationSubject.assertThat;
 import static com.google.testing.compile.Compiler.javac;
+import static dagger.internal.codegen.CodeBlocks.stringLiteral;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 
 import com.google.auto.common.MoreElements;
@@ -52,8 +53,10 @@
 
 @RunWith(JUnit4.class)
 public class ComponentProcessorTest {
-  private static final CodeBlock NPE_LITERAL =
-      CodeBlocks.stringLiteral(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD);
+  private static final CodeBlock NPE_FROM_COMPONENT_METHOD =
+      stringLiteral(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD);
+  private static final CodeBlock NPE_FROM_PROVIDES_METHOD =
+      stringLiteral(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD);
 
   @Test public void componentOnConcreteClass() {
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.NotAComponent",
@@ -638,6 +641,7 @@ public void componentWithAbstractModule() {
             "test.DaggerTestComponent",
             "package test;",
             "",
+            "import dagger.internal.Preconditions;",
             "import javax.annotation.Generated;",
             "import javax.inject.Provider;",
             "",
@@ -667,7 +671,8 @@ public void componentWithAbstractModule() {
             "",
             "  @Override",
             "  public A a() {",
-            "    return new A(TestModule.b(new C()));",
+            "    return new A(Preconditions.checkNotNull(",
+            "        TestModule.b(new C()), " + NPE_FROM_PROVIDES_METHOD + "));",
             "  }",
             "",
             "  public static final class Builder {",
@@ -976,7 +981,8 @@ public void subcomponentNotGeneratedIfNotUsedInGraph() {
             "",
             "  @Override",
             "  public String notSubcomponent() {",
-            "    return ParentModule.notSubcomponent();",
+            "    return Preconditions.checkNotNull(",
+            "        ParentModule.notSubcomponent(), " + NPE_FROM_PROVIDES_METHOD + ");",
             "  }",
             "",
             "  public static final class Builder {",
@@ -1455,7 +1461,8 @@ public void testDefaultPackage() {
             "    ",
             "    @Override()",
             "    public A get() {",
-            "      return Preconditions.checkNotNull(aComponent.a(), " + NPE_LITERAL + ");",
+            "      return Preconditions.checkNotNull(",
+            "          aComponent.a(), " + NPE_FROM_COMPONENT_METHOD + ");",
             "    }",
             "  }",
             "}");
@@ -2569,6 +2576,105 @@ public void bindsInstanceFrameworkType() {
         .onLine(9);
   }
 
+  @Test
+  public void nullIncorrectlyReturnedFromNonNullableInlinedProvider() {
+    Compilation compilation =
+        daggerCompiler()
+            .compile(
+                JavaFileObjects.forSourceLines(
+                    "test.TestModule",
+                    "package test;",
+                    "",
+                    "import dagger.Module;",
+                    "import dagger.Provides;",
+                    "",
+                    "@Module()",
+                    "public abstract class TestModule {",
+                    "  @Provides static String nonNullableString() { return \"string\"; }",
+                    "}"),
+                JavaFileObjects.forSourceLines(
+                    "test.TestComponent",
+                    "package test;",
+                    "",
+                    "import dagger.Component;",
+                    "",
+                    "@Component(modules = TestModule.class)",
+                    "interface TestComponent {",
+                    "  String nonNullableString();",
+                    "}"));
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.TestModule_NonNullableStringFactory")
+        .hasSourceEquivalentTo(
+            JavaFileObjects.forSourceLines(
+                "test.TestModule_NonNullableStringFactory",
+                "package test;",
+                "",
+                "import dagger.internal.Factory;",
+                "import dagger.internal.Preconditions;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class TestModule_NonNullableStringFactory",
+                "    implements Factory<String> {",
+                "  private static final TestModule_NonNullableStringFactory INSTANCE =",
+                "      new TestModule_NonNullableStringFactory();",
+                "",
+                "  @Override",
+                "  public String get() {",
+                "    return Preconditions.checkNotNull(",
+                "        TestModule.nonNullableString(), " + NPE_FROM_PROVIDES_METHOD + ");",
+                "  }",
+                "",
+                "  public static Factory<String> create() {",
+                "    return INSTANCE;",
+                "  }",
+                "",
+                "  /** Proxies {@link TestModule#nonNullableString()}. */",
+                "  public static String proxyNonNullableString() {",
+                "    return TestModule.nonNullableString();",
+                "  }",
+                "}"));
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import dagger.internal.Preconditions",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {",
+                "    assert builder != null;",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public String nonNullableString() {",
+                "    return Preconditions.checkNotNull(",
+                "        TestModule.nonNullableString(), " + NPE_FROM_PROVIDES_METHOD + ");",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}"));
+  }
+
   private static Compiler daggerCompiler(Processor... extraProcessors) {
     return javac().withProcessors(Lists.asList(new ComponentProcessor(), extraProcessors));
   }
diff --git a/javatests/dagger/internal/codegen/ModuleFactoryGeneratorTest.java b/javatests/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
index 2af869205..3cd0a8658 100644
--- a/javatests/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
+++ b/javatests/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
@@ -370,6 +370,7 @@ public void providesMethodReturnsProduced() {
             "    return new TestModule_ProvideStringFactory(module);",
             "  }",
             "",
+            "  @Nullable",
             "  public static String proxyProvideString(TestModule instance) {",
             "    return instance.provideString();",
             "  }",
@@ -579,9 +580,8 @@ public void providesMethodReturnsProduced() {
             "  }",
             "",
             "  @Override public List<List<?>> get() {",
-            "    return Preconditions.checkNotNull(module.provideWildcardList(), "
-                + NPE_LITERAL
-                + ");",
+            "    return Preconditions.checkNotNull(",
+            "        module.provideWildcardList(), " + NPE_LITERAL + ");",
             "  }",
             "",
             "  public static Factory<List<List<?>>> create(TestModule module) {",
diff --git a/javatests/dagger/internal/codegen/OptionalBindingRequestFulfillmentTest.java b/javatests/dagger/internal/codegen/OptionalBindingRequestFulfillmentTest.java
index 9cc900581..e89e20110 100644
--- a/javatests/dagger/internal/codegen/OptionalBindingRequestFulfillmentTest.java
+++ b/javatests/dagger/internal/codegen/OptionalBindingRequestFulfillmentTest.java
@@ -22,6 +22,7 @@
 
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
+import com.squareup.javapoet.CodeBlock;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -29,6 +30,10 @@
 
 @RunWith(JUnit4.class)
 public class OptionalBindingRequestFulfillmentTest {
+
+  public static final CodeBlock NPE_FROM_PROVIDES =
+      CodeBlocks.stringLiteral(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD);
+
   @Test
   public void inlinedOptionalBindings() {
     JavaFileObject module =
@@ -150,7 +155,9 @@ public void inlinedOptionalBindings() {
             "",
             "  @Override",
             "  public Optional<Maybe> maybe() {",
-            "    return Optional.of(Maybe.MaybeModule.provideMaybe());",
+            "    return Optional.of(",
+            "        Preconditions.checkNotNull(",
+            "            Maybe.MaybeModule.provideMaybe(), " + NPE_FROM_PROVIDES + "));",
             "  }",
             "",
             "  @Override",
@@ -331,7 +338,8 @@ public void requestForFuture() {
             "",
             "  @Override",
             "  public ListenableFuture<Optional<Maybe>> maybe() {",
-            "    return Futures.immediateFuture(Optional.of(Maybe.MaybeModule.provideMaybe()));",
+            "    return Futures.immediateFuture(Optional.of(Preconditions.checkNotNull(",
+            "        Maybe.MaybeModule.provideMaybe(), " + NPE_FROM_PROVIDES + ")));",
             "  }",
             "",
             "  @Override",
diff --git a/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentTest.java b/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentTest.java
index 42dc1e7c5..694bbc937 100644
--- a/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentTest.java
+++ b/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentTest.java
@@ -27,6 +27,7 @@
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.Compiler;
 import com.google.testing.compile.JavaFileObjects;
+import com.squareup.javapoet.CodeBlock;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -34,6 +35,10 @@
 
 @RunWith(JUnit4.class)
 public class SetBindingRequestFulfillmentTest {
+
+  public static final CodeBlock NPE_FROM_PROVIDES =
+      CodeBlocks.stringLiteral(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD);
+
   @Test
   public void setBindings() {
     JavaFileObject emptySetModuleFile = JavaFileObjects.forSourceLines("test.EmptySetModule",
@@ -120,8 +125,10 @@ public void setBindings() {
             "  @Override",
             "  public Set<String> strings() {",
             "    return SetBuilder.<String>newSetBuilder(2)",
-            "        .addAll(EmptySetModule.emptySet())",
-            "        .add(SetModule.string())",
+            "        .addAll(Preconditions.checkNotNull(",
+            "            EmptySetModule.emptySet(), " + NPE_FROM_PROVIDES + "))",
+            "        .add(Preconditions.checkNotNull(",
+            "            SetModule.string(), " + NPE_FROM_PROVIDES + "))",
             "        .build();",
             "  }",
             "",
@@ -220,6 +227,7 @@ public void inaccessible() {
             "package test;",
             "",
             "import dagger.internal.Factory;",
+            "import dagger.internal.Preconditions;",
             "import dagger.internal.SetBuilder;",
             "import dagger.internal.SetFactory;",
             "import java.util.Collections;",
@@ -265,7 +273,9 @@ public void inaccessible() {
             "    return UsesInaccessible_Factory.newUsesInaccessible(",
             "        (Set) Collections.emptySet(),",
             "        (Set) SetBuilder.newSetBuilder(1)",
-            "            .addAll(TestModule_EmptySetFactory.proxyEmptySet())",
+            "            .addAll(Preconditions.checkNotNull(",
+            "                TestModule_EmptySetFactory.proxyEmptySet(),",
+            "                " + NPE_FROM_PROVIDES + "))",
             "            .build());",
             "  }",
             "",
@@ -419,7 +429,8 @@ public void subcomponentOmitsInheritedBindings() {
             "",
             "    @Override",
             "    public Set<Object> objectSet() {",
-            "      return Collections.<Object>singleton(ParentModule.parentObject());",
+            "      return Collections.<Object>singleton(Preconditions.checkNotNull(",
+            "          ParentModule.parentObject(), " + NPE_FROM_PROVIDES + "));",
             "    }",
             "",
             "    @Override",
diff --git a/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentWithGuavaTest.java b/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentWithGuavaTest.java
index bda5d290d..f7cb7eac9 100644
--- a/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentWithGuavaTest.java
+++ b/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentWithGuavaTest.java
@@ -22,6 +22,7 @@
 
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
+import com.squareup.javapoet.CodeBlock;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -29,6 +30,10 @@
 
 @RunWith(JUnit4.class)
 public class SetBindingRequestFulfillmentWithGuavaTest {
+
+  public static final CodeBlock NPE_FROM_PROVIDES =
+      CodeBlocks.stringLiteral(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD);
+
   @Test
   public void setBindings() {
     JavaFileObject emptySetModuleFile = JavaFileObjects.forSourceLines("test.EmptySetModule",
@@ -125,8 +130,10 @@ public void setBindings() {
             "  @Override",
             "  public Set<String> strings() {",
             "    return ImmutableSet.<String>builder()",
-            "        .addAll(EmptySetModule.emptySet())",
-            "        .add(SetModule.string())",
+            "        .addAll(Preconditions.checkNotNull(",
+            "            EmptySetModule.emptySet(), " + NPE_FROM_PROVIDES + "))",
+            "        .add(Preconditions.checkNotNull(",
+            "            SetModule.string(), " + NPE_FROM_PROVIDES + "))",
             "        .build();",
             "  }",
             "",
@@ -138,7 +145,9 @@ public void setBindings() {
             "  @Override",
             "  public Set<Integer> onlyContributionIsElementsIntoSet() {",
             "    return ImmutableSet.<Integer>copyOf(",
-            "        EmptySetModule.onlyContributionIsElementsIntoSet());",
+            "        Preconditions.checkNotNull(",
+            "            EmptySetModule.onlyContributionIsElementsIntoSet(),",
+            "            " + NPE_FROM_PROVIDES + "));",
             "  }",
             "",
             "  public static final class Builder {",
@@ -233,6 +242,7 @@ public void inaccessible() {
             "",
             "import com.google.common.collect.ImmutableSet;",
             "import dagger.internal.Factory;",
+            "import dagger.internal.Preconditions;",
             "import dagger.internal.SetFactory;",
             "import java.util.Set;",
             "import javax.annotation.Generated;",
@@ -275,7 +285,9 @@ public void inaccessible() {
             "  public UsesInaccessible usesInaccessible() {",
             "    return UsesInaccessible_Factory.newUsesInaccessible(",
             "        (Set) ImmutableSet.of(),",
-            "        (Set) ImmutableSet.copyOf(TestModule_EmptySetFactory.proxyEmptySet()));",
+            "        (Set) ImmutableSet.copyOf(Preconditions.checkNotNull(",
+            "            TestModule_EmptySetFactory.proxyEmptySet(),",
+            "            " + NPE_FROM_PROVIDES + ")));",
             "  }",
             "",
             "  public static final class Builder {",
@@ -429,7 +441,8 @@ public void subcomponentOmitsInheritedBindings() {
             "",
             "    @Override",
             "    public Set<Object> objectSet() {",
-            "      return ImmutableSet.<Object>of(ParentModule.parentObject());",
+            "      return ImmutableSet.<Object>of(Preconditions.checkNotNull(",
+            "          ParentModule.parentObject(), " + NPE_FROM_PROVIDES + "));",
             "    }",
             "",
             "    @Override",
@@ -517,7 +530,8 @@ public void productionComponents() {
             "  public ListenableFuture<Set<String>> strings() {",
             "    return Futures.<Set<String>>immediateFuture(",
 
-            "        ImmutableSet.<String>copyOf(EmptySetModule.emptySet());",
+            "        ImmutableSet.<String>copyOf(Preconditions.checkNotNull(",
+            "            EmptySetModule.emptySet(), " + NPE_FROM_PROVIDES + "));",
             "  }",
             "",
             "  public static final class Builder {",
