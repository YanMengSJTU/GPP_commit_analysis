diff --git a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentMultibindingsTest.java b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentMultibindingsTest.java
index 40592577a..f4ae9ef2a 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentMultibindingsTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentMultibindingsTest.java
@@ -22,6 +22,7 @@
 import org.junit.runners.Parameterized;
 import org.junit.runners.Parameterized.Parameters;
 
+import static com.google.common.collect.Iterables.getOnlyElement;
 import static com.google.common.truth.Truth.assertWithMessage;
 
 @RunWith(Parameterized.class)
@@ -54,4 +55,20 @@ public void testMultibindingsInSubcomponents() {
         .containsExactly("string provided by parent");
   }
 
+  @Test
+  public void testOverriddenMultibindingsInSubcomponents() {
+    RequiresMultibindingsInChild requiresMultibindingsInChild =
+        parent.childComponent().requiresMultibindingsInChild();
+
+    assertWithMessage("setOfRequiresSetOfObjects")
+        .that(requiresMultibindingsInChild.setOfRequiresSetOfObjects())
+        .hasSize(1);
+
+    RequiresSetOfObjects onlyElementInSetOfRequiresSetOfObjects =
+        getOnlyElement(requiresMultibindingsInChild.setOfRequiresSetOfObjects());
+
+    assertWithMessage("setOfRequiresSetOfObjects[only].setOfObjects")
+        .that(onlyElementInSetOfRequiresSetOfObjects.setOfObjects())
+        .containsExactly("object provided by parent", "object provided by child");
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index cc3860286..c28a39274 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -264,9 +264,8 @@ ResolvedBindings lookUpBindings(DependencyRequest request) {
               ImmutableSet.Builder<ContributionBinding> inheritedBindings = ImmutableSet.builder();
               for (ProvisionBinding provisionBinding :
                   Sets.union(explicitProvisionBindingsForKey, explicitMapProvisionBindings)) {
-                Optional<RequestResolver> owningResolver = getOwningResolver(provisionBinding);
-                if (owningResolver.isPresent() && !owningResolver.get().equals(this)) {
-                  owningResolver.get().resolve(request);
+                if (isResolvedInParent(request, provisionBinding)
+                    && !shouldOwnParentBinding(request, provisionBinding)) {
                   inheritedBindings.add(provisionBinding);
                 } else {
                   ownedBindings.add(provisionBinding);
@@ -298,13 +297,10 @@ ResolvedBindings lookUpBindings(DependencyRequest request) {
                 Optional<ProvisionBinding> provisionBinding =
                     injectBindingRegistry.getOrFindProvisionBinding(bindingKey.key());
                 if (provisionBinding.isPresent()) {
-                  Optional<RequestResolver> owningResolver =
-                      getOwningResolver(provisionBinding.get());
-                  if (owningResolver.isPresent() && !owningResolver.get().equals(this)) {
-                    owningResolver.get().resolve(request);
+                  if (isResolvedInParent(request, provisionBinding.get())
+                      && !shouldOwnParentBinding(request, provisionBinding.get())) {
                     return ResolvedBindings.create(
-                        bindingKey, ImmutableSet.<Binding>of(),
-                        provisionBinding.asSet());
+                        bindingKey, ImmutableSet.<Binding>of(), provisionBinding.asSet());
                   }
                 }
                 return ResolvedBindings.create(
@@ -320,6 +316,34 @@ ResolvedBindings lookUpBindings(DependencyRequest request) {
         }
       }
 
+      /**
+       * Returns {@code true} if {@code provisionBinding} is owned by a parent resolver. If so,
+       * calls {@link #resolve(DependencyRequest) resolve(request)} on that resolver.
+       */
+      private boolean isResolvedInParent(
+          DependencyRequest request, ProvisionBinding provisionBinding) {
+        Optional<RequestResolver> owningResolver = getOwningResolver(provisionBinding);
+        if (owningResolver.isPresent() && !owningResolver.get().equals(this)) {
+          owningResolver.get().resolve(request);
+          return true;
+        } else {
+          return false;
+        }
+      }
+
+      /**
+       * Returns {@code true} if {@code provisionBinding}, which was previously resolved by a parent
+       * resolver, should be moved into this resolver's bindings for {@code request} because it is
+       * unscoped and {@linkplain #dependsOnLocalMultibindings(ResolvedBindings) depends on local
+       * multibindings}, or {@code false} if it can satisfy {@code request} as an inherited binding.
+       */
+      private boolean shouldOwnParentBinding(
+          DependencyRequest request, ProvisionBinding provisionBinding) {
+        return !isScoped(provisionBinding)
+            && dependsOnLocalMultibindings(
+                getPreviouslyResolvedBindings(request.bindingKey()).get());
+      }
+
       private MembersInjectionBinding rollUpMembersInjectionBindings(Key key) {
         MembersInjectionBinding membersInjectionBinding =
             injectBindingRegistry.getOrFindMembersInjectionBinding(key);
