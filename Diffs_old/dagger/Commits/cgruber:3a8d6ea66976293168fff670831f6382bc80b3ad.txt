diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 87b3dca0e..5c7a67f24 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -33,7 +33,6 @@
 import static dagger.internal.codegen.AnnotationSpecs.Suppression.UNCHECKED;
 import static dagger.internal.codegen.BindingKey.contribution;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
-import static dagger.internal.codegen.ConfigurationAnnotations.typeValue;
 import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.SINGLETON_INSTANCE;
 import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD;
 import static dagger.internal.codegen.MapKeys.getMapKeyExpression;
@@ -42,6 +41,7 @@
 import static dagger.internal.codegen.MemberSelect.localField;
 import static dagger.internal.codegen.MemberSelect.noOpMembersInjector;
 import static dagger.internal.codegen.MemberSelect.staticMethod;
+import static dagger.internal.codegen.MoreAnnotationMirrors.getTypeValue;
 import static dagger.internal.codegen.Scope.reusableScope;
 import static dagger.internal.codegen.SourceFiles.bindingTypeElementTypeVariableNames;
 import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
@@ -1511,7 +1511,7 @@ private Scope forReleasableReferencesAnnotationValue(AnnotationMirror annotation
     checkArgument(
         MoreTypes.isTypeOf(ForReleasableReferences.class, annotation.getAnnotationType()));
     return Scope.scope(
-        MoreElements.asType(MoreTypes.asDeclared(typeValue(annotation, "value")).asElement()));
+        MoreElements.asType(MoreTypes.asDeclared(getTypeValue(annotation, "value")).asElement()));
   }
 
   /**
diff --git a/compiler/src/main/java/dagger/internal/codegen/AnyBindingMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/AnyBindingMethodValidator.java
new file mode 100644
index 000000000..62b90a63e
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/AnyBindingMethodValidator.java
@@ -0,0 +1,106 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static com.google.common.collect.Maps.uniqueIndex;
+import static dagger.internal.codegen.ErrorMessages.tooManyBindingMethodAnnotations;
+import static dagger.internal.codegen.Util.isAnyAnnotationPresent;
+import static dagger.internal.codegen.Util.toImmutableSet;
+import static java.util.Arrays.asList;
+
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
+import java.lang.annotation.Annotation;
+import java.util.HashMap;
+import java.util.Map;
+import javax.lang.model.element.ExecutableElement;
+
+/** Validates any binding method. */
+final class AnyBindingMethodValidator {
+
+  private final ImmutableMap<Class<? extends Annotation>, BindingMethodValidator> validators;
+  private final Map<ExecutableElement, ValidationReport<ExecutableElement>> reports =
+      new HashMap<>();
+
+  AnyBindingMethodValidator(BindingMethodValidator... validators) {
+    this.validators = uniqueIndex(asList(validators), BindingMethodValidator::methodAnnotation);
+  }
+
+  /** Returns the binding method annotations considered by this validator. */
+  ImmutableSet<Class<? extends Annotation>> methodAnnotations() {
+    return validators.keySet();
+  }
+
+  /**
+   * Returns {@code true} if {@code method} is annotated with at least one of {@link
+   * #methodAnnotations()}.
+   */
+  boolean isBindingMethod(ExecutableElement method) {
+    return isAnyAnnotationPresent(method, methodAnnotations());
+  }
+
+  /**
+   * Returns a validation report for a method.
+   *
+   * <ul>
+   *   <li>Reports an error if {@code method} is annotated with more than one {@linkplain
+   *       #methodAnnotations() binding method annotation}.
+   *   <li>Validates {@code method} with the {@link BindingMethodValidator} for the single
+   *       {@linkplain #methodAnnotations() binding method annotation}.
+   * </ul>
+   *
+   * @throws IllegalArgumentException if {@code method} is not annotated by any {@linkplain
+   *     #methodAnnotations() binding method annotation}
+   */
+  ValidationReport<ExecutableElement> validate(ExecutableElement method) {
+    return reports.computeIfAbsent(method, this::validateUncached);
+  }
+
+  /**
+   * Returns {@code true} if {@code method} was already {@linkplain #validate(ExecutableElement)
+   * validated}.
+   */
+  boolean wasAlreadyValidated(ExecutableElement method) {
+    return reports.containsKey(method);
+  }
+
+  private ValidationReport<ExecutableElement> validateUncached(ExecutableElement method) {
+    ValidationReport.Builder<ExecutableElement> report = ValidationReport.about(method);
+    ImmutableSet<? extends Class<? extends Annotation>> bindingMethodAnnotations =
+        methodAnnotations()
+            .stream()
+            .filter(annotation -> isAnnotationPresent(method, annotation))
+            .collect(toImmutableSet());
+    switch (bindingMethodAnnotations.size()) {
+      case 0:
+        throw new IllegalArgumentException(
+            String.format("%s has no binding method annotation", method));
+
+      case 1:
+        report.addSubreport(
+            validators.get(getOnlyElement(bindingMethodAnnotations)).validate(method));
+        break;
+
+      default:
+        report.addError(tooManyBindingMethodAnnotations(method, methodAnnotations()), method);
+        break;
+    }
+    return report.build();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 32d864e49..f2ae3e816 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -30,7 +30,6 @@
 import static dagger.internal.codegen.BindingType.PROVISION;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentAnnotation;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
-import static dagger.internal.codegen.ConfigurationAnnotations.typeValue;
 import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
 import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MAP;
 import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MULTIBOUND_KINDS;
@@ -59,6 +58,7 @@
 import static dagger.internal.codegen.ErrorMessages.referenceReleasingScopeNotAnnotatedWithMetadata;
 import static dagger.internal.codegen.ErrorMessages.referenceReleasingScopeNotInComponentHierarchy;
 import static dagger.internal.codegen.ErrorMessages.stripCommonTypePrefixes;
+import static dagger.internal.codegen.MoreAnnotationMirrors.getTypeValue;
 import static dagger.internal.codegen.Scope.reusableScope;
 import static dagger.internal.codegen.Scope.scopesOf;
 import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
@@ -931,7 +931,7 @@ private boolean reportMissingReleasableReferenceManager() {
         }
 
         Scope scope =
-            Scope.scope(MoreTypes.asTypeElement(typeValue(key.qualifier().get(), "value")));
+            Scope.scope(MoreTypes.asTypeElement(getTypeValue(key.qualifier().get(), "value")));
         String missingRequestKey = formatCurrentDependencyRequestKey();
         if (!rootGraph.componentDescriptor().releasableReferencesScopes().contains(scope)) {
           reportErrorAtEntryPoint(
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingMethodProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/BindingMethodProcessingStep.java
new file mode 100644
index 000000000..cc1e164db
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingMethodProcessingStep.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkArgument;
+import static javax.lang.model.util.ElementFilter.methodsIn;
+
+import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.SetMultimap;
+import java.lang.annotation.Annotation;
+import java.util.Set;
+import javax.annotation.processing.Messager;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+
+/** A step that validates all binding methods that were not validated while processing modules. */
+final class BindingMethodProcessingStep implements ProcessingStep {
+
+  private final Messager messager;
+  private final AnyBindingMethodValidator anyBindingMethodValidator;
+
+  BindingMethodProcessingStep(
+      Messager messager, AnyBindingMethodValidator anyBindingMethodValidator) {
+    this.messager = messager;
+    this.anyBindingMethodValidator = anyBindingMethodValidator;
+  }
+
+  @Override
+  public Set<? extends Class<? extends Annotation>> annotations() {
+    return anyBindingMethodValidator.methodAnnotations();
+  }
+
+  @Override
+  public Set<Element> process(
+      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+    for (ExecutableElement method : methodsIn(elementsByAnnotation.values())) {
+      checkArgument(
+          anyBindingMethodValidator.isBindingMethod(method),
+          "%s is not annotated with any of %s",
+          method,
+          annotations());
+      if (!anyBindingMethodValidator.wasAlreadyValidated(method)) {
+        anyBindingMethodValidator.validate(method).printMessagesTo(messager);
+      }
+    }
+    return ImmutableSet.of();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingMethodValidator.java
index 89be40108..cff4b4cee 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingMethodValidator.java
@@ -47,9 +47,6 @@
 import static javax.lang.model.type.TypeKind.VOID;
 
 import com.google.common.base.Joiner;
-import com.google.common.cache.CacheBuilder;
-import com.google.common.cache.CacheLoader;
-import com.google.common.cache.LoadingCache;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Lists;
@@ -59,8 +56,9 @@
 import dagger.multibindings.IntoMap;
 import dagger.producers.Produces;
 import java.lang.annotation.Annotation;
+import java.util.HashMap;
+import java.util.Map;
 import javax.annotation.OverridingMethodsMustInvokeSuper;
-import javax.annotation.processing.Messager;
 import javax.inject.Qualifier;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
@@ -78,18 +76,7 @@
   private final ImmutableSet<? extends Class<? extends Annotation>> enclosingElementAnnotations;
   private final Abstractness abstractness;
   private final ExceptionSuperclass exceptionSuperclass;
-  private final LoadingCache<ExecutableElement, ValidationReport<ExecutableElement>> cache =
-      CacheBuilder.newBuilder()
-          .build(
-              new CacheLoader<ExecutableElement, ValidationReport<ExecutableElement>>() {
-                @Override
-                public ValidationReport<ExecutableElement> load(ExecutableElement method) {
-                  ValidationReport.Builder<ExecutableElement> builder =
-                      ValidationReport.about(method);
-                  checkMethod(builder);
-                  return builder.build();
-                }
-              });
+  private final Map<ExecutableElement, ValidationReport<ExecutableElement>> cache = new HashMap<>();
   private final AllowsMultibindings allowsMultibindings;
 
   /**
@@ -148,21 +135,13 @@ protected BindingMethodValidator(
 
   /** Returns a {@link ValidationReport} for {@code method}. */
   final ValidationReport<ExecutableElement> validate(ExecutableElement method) {
-    return cache.getUnchecked(method);
+    return cache.computeIfAbsent(method, this::validateUncached);
   }
 
-  /** Prints validation reports to {@code messager}, and returns valid methods. */
-  final ImmutableSet<ExecutableElement> validate(
-      Messager messager, Iterable<? extends ExecutableElement> methods) {
-    ImmutableSet.Builder<ExecutableElement> validMethods = ImmutableSet.builder();
-    for (ExecutableElement method : methods) {
-      ValidationReport<ExecutableElement> report = validate(method);
-      report.printMessagesTo(messager);
-      if (report.isClean()) {
-        validMethods.add(method);
-      }
-    }
-    return validMethods.build();
+  private ValidationReport<ExecutableElement> validateUncached(ExecutableElement m) {
+    ValidationReport.Builder<ExecutableElement> report = ValidationReport.about(m);
+    checkMethod(report);
+    return report.build();
   }
 
   /** Checks the method for validity. Adds errors to {@code builder}. */
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index b150fc551..ebc762e06 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -74,16 +74,6 @@ public SourceVersion getSupportedSourceVersion() {
 
     InjectValidator injectValidator = new InjectValidator(types, elements, compilerOptions);
     InjectValidator injectValidatorWhenGeneratingCode = injectValidator.whenGeneratingCode();
-    ModuleValidator moduleValidator =
-        new ModuleValidator(types, elements, methodSignatureFormatter);
-    BuilderValidator builderValidator = new BuilderValidator(elements, types);
-    ComponentValidator subcomponentValidator =
-        ComponentValidator.createForSubcomponent(
-            elements, types, moduleValidator, builderValidator);
-    ComponentValidator componentValidator =
-        ComponentValidator.createForComponent(
-            elements, types, moduleValidator, subcomponentValidator, builderValidator);
-    MapKeyValidator mapKeyValidator = new MapKeyValidator();
     ProvidesMethodValidator providesMethodValidator = new ProvidesMethodValidator(elements, types);
     ProducesMethodValidator producesMethodValidator = new ProducesMethodValidator(elements, types);
     BindsMethodValidator bindsMethodValidator = new BindsMethodValidator(elements, types);
@@ -93,6 +83,23 @@ public SourceVersion getSupportedSourceVersion() {
         new MultibindingsMethodValidator(elements, types);
     BindsOptionalOfMethodValidator bindsOptionalOfMethodValidator =
         new BindsOptionalOfMethodValidator(elements, types);
+    AnyBindingMethodValidator anyBindingMethodValidator =
+        new AnyBindingMethodValidator(
+            providesMethodValidator,
+            producesMethodValidator,
+            bindsMethodValidator,
+            multibindsMethodValidator,
+            bindsOptionalOfMethodValidator);
+    ModuleValidator moduleValidator =
+        new ModuleValidator(types, elements, anyBindingMethodValidator, methodSignatureFormatter);
+    BuilderValidator builderValidator = new BuilderValidator(elements, types);
+    ComponentValidator subcomponentValidator =
+        ComponentValidator.createForSubcomponent(
+            elements, types, moduleValidator, builderValidator);
+    ComponentValidator componentValidator =
+        ComponentValidator.createForComponent(
+            elements, types, moduleValidator, subcomponentValidator, builderValidator);
+    MapKeyValidator mapKeyValidator = new MapKeyValidator();
 
     Key.Factory keyFactory = new Key.Factory(types, elements);
 
@@ -200,15 +207,7 @@ public SourceVersion getSupportedSourceVersion() {
         new ProductionExecutorModuleProcessingStep(messager, productionExecutorModuleGenerator),
         new MultibindingsProcessingStep(messager, multibindingsValidator),
         new MultibindingAnnotationsProcessingStep(messager),
-        moduleProcessingStep(
-            messager,
-            moduleValidator,
-            provisionBindingFactory,
-            factoryGenerator,
-            providesMethodValidator,
-            bindsMethodValidator,
-            multibindsMethodValidator,
-            bindsOptionalOfMethodValidator),
+        moduleProcessingStep(messager, moduleValidator, provisionBindingFactory, factoryGenerator),
         new ComponentProcessingStep(
             ComponentDescriptor.Kind.COMPONENT,
             messager,
@@ -225,13 +224,8 @@ public SourceVersion getSupportedSourceVersion() {
             moduleValidator,
             provisionBindingFactory,
             factoryGenerator,
-            providesMethodValidator,
             productionBindingFactory,
-            producerFactoryGenerator,
-            producesMethodValidator,
-            bindsMethodValidator,
-            multibindsMethodValidator,
-            bindsOptionalOfMethodValidator),
+            producerFactoryGenerator),
         new ComponentProcessingStep(
             ComponentDescriptor.Kind.PRODUCTION_COMPONENT,
             messager,
@@ -242,7 +236,8 @@ public SourceVersion getSupportedSourceVersion() {
             bindingGraphValidator,
             componentDescriptorFactory,
             bindingGraphFactory,
-            componentGenerator));
+            componentGenerator),
+        new BindingMethodProcessingStep(messager, anyBindingMethodValidator));
   }
 
   @Override
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
index 7045643fa..65076dcbb 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
@@ -247,9 +247,9 @@ public ComponentValidationReport validate(
     if (componentKind.isTopLevel()) {
       validateComponentDependencies(builder, getComponentDependencies(componentMirror));
     }
-    ImmutableList<TypeMirror> moduleTypes = getComponentModules(componentMirror);
-    moduleValidator.validateReferencedModules(
-        subject, builder, moduleTypes, componentKind.moduleKinds());
+    builder.addSubreport(
+        moduleValidator.validateReferencedModules(
+            subject, componentMirror, componentKind.moduleKinds()));
 
     // Make sure we validate any subcomponents we're referencing, unless we know we validated
     // them already in this pass.
diff --git a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
index 79fe5addf..214e7bc91 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
@@ -20,13 +20,14 @@
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.codegen.MoreAnnotationMirrors.getTypeListValue;
+import static dagger.internal.codegen.MoreAnnotationValues.asAnnotationValues;
 import static dagger.internal.codegen.Util.isAnyAnnotationPresent;
 import static javax.lang.model.util.ElementFilter.typesIn;
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.Optional;
-import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
@@ -44,14 +45,12 @@
 import java.util.Set;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
-import javax.lang.model.element.AnnotationValueVisitor;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
-import javax.lang.model.util.SimpleAnnotationValueVisitor6;
 import javax.lang.model.util.SimpleTypeVisitor6;
 import javax.lang.model.util.Types;
 
@@ -92,18 +91,36 @@ static boolean isSubcomponentBuilder(Element element) {
         element, Subcomponent.Builder.class, ProductionSubcomponent.Builder.class);
   }
 
+  /**
+   * Returns the annotation values for the modules directly installed into a component or included
+   * in a module.
+   *
+   * @param annotatedType the component or module type
+   * @param annotation the component or module annotation
+   */
+  static ImmutableList<AnnotationValue> getModules(
+      TypeElement annotatedType, AnnotationMirror annotation) {
+    if (ComponentDescriptor.Kind.forAnnotatedElement(annotatedType).isPresent()) {
+      return asAnnotationValues(getAnnotationValue(annotation, MODULES_ATTRIBUTE));
+    }
+    if (ModuleDescriptor.Kind.forAnnotatedElement(annotatedType).isPresent()) {
+      return asAnnotationValues(getAnnotationValue(annotation, INCLUDES_ATTRIBUTE));
+    }
+    throw new IllegalArgumentException(String.format("unsupported annotation: %s", annotation));
+  }
+
   private static final String MODULES_ATTRIBUTE = "modules";
 
   static ImmutableList<TypeMirror> getComponentModules(AnnotationMirror componentAnnotation) {
     checkNotNull(componentAnnotation);
-    return convertClassArrayToListOfTypes(componentAnnotation, MODULES_ATTRIBUTE);
+    return getTypeListValue(componentAnnotation, MODULES_ATTRIBUTE);
   }
 
   private static final String DEPENDENCIES_ATTRIBUTE = "dependencies";
 
   static ImmutableList<TypeMirror> getComponentDependencies(AnnotationMirror componentAnnotation) {
     checkNotNull(componentAnnotation);
-    return convertClassArrayToListOfTypes(componentAnnotation, DEPENDENCIES_ATTRIBUTE);
+    return getTypeListValue(componentAnnotation, DEPENDENCIES_ATTRIBUTE);
   }
 
   static Optional<AnnotationMirror> getModuleAnnotation(TypeElement moduleElement) {
@@ -115,21 +132,21 @@ static boolean isSubcomponentBuilder(Element element) {
 
   static ImmutableList<TypeMirror> getModuleIncludes(AnnotationMirror moduleAnnotation) {
     checkNotNull(moduleAnnotation);
-    return convertClassArrayToListOfTypes(moduleAnnotation, INCLUDES_ATTRIBUTE);
+    return getTypeListValue(moduleAnnotation, INCLUDES_ATTRIBUTE);
   }
 
   private static final String SUBCOMPONENTS_ATTRIBUTE = "subcomponents";
 
   static ImmutableList<TypeMirror> getModuleSubcomponents(AnnotationMirror moduleAnnotation) {
     checkNotNull(moduleAnnotation);
-    return convertClassArrayToListOfTypes(moduleAnnotation, SUBCOMPONENTS_ATTRIBUTE);
+    return getTypeListValue(moduleAnnotation, SUBCOMPONENTS_ATTRIBUTE);
   }
 
   private static final String INJECTS_ATTRIBUTE = "injects";
 
   static ImmutableList<TypeMirror> getModuleInjects(AnnotationMirror moduleAnnotation) {
     checkNotNull(moduleAnnotation);
-    return convertClassArrayToListOfTypes(moduleAnnotation, INJECTS_ATTRIBUTE);
+    return getTypeListValue(moduleAnnotation, INJECTS_ATTRIBUTE);
   }
 
   /** Returns the first type that specifies this' nullability, or absent if none. */
@@ -143,19 +160,6 @@ static boolean isSubcomponentBuilder(Element element) {
     return Optional.absent();
   }
 
-  /**
-   * Extracts the list of types that is the value of the annotation member {@code elementName} of
-   * {@code annotationMirror}.
-   *
-   * @throws IllegalArgumentException if no such member exists on {@code annotationMirror}, or it
-   *     exists but is not an array
-   * @throws TypeNotPresentException if any of the values cannot be converted to a type
-   */
-  static ImmutableList<TypeMirror> convertClassArrayToListOfTypes(
-      AnnotationMirror annotationMirror, String elementName) {
-    return TO_LIST_OF_TYPES.visit(getAnnotationValue(annotationMirror, elementName), elementName);
-  }
-
   static <T extends Element> void validateComponentDependencies(
       ValidationReport.Builder<T> report, Iterable<TypeMirror> types) {
     validateTypesAreDeclared(report, types, "component dependency");
@@ -186,41 +190,6 @@ public Void visitDeclared(DeclaredType t, Void aVoid) {
     }
   }
 
-  private static final AnnotationValueVisitor<ImmutableList<TypeMirror>, String> TO_LIST_OF_TYPES =
-      new SimpleAnnotationValueVisitor6<ImmutableList<TypeMirror>, String>() {
-        @Override
-        public ImmutableList<TypeMirror> visitArray(
-            List<? extends AnnotationValue> vals, String elementName) {
-          return FluentIterable.from(vals).transform(TO_TYPE::visit).toList();
-        }
-
-        @Override
-        protected ImmutableList<TypeMirror> defaultAction(Object o, String elementName) {
-          throw new IllegalArgumentException(elementName + " is not an array: " + o);
-        }
-      };
-
-  /**
-   * Returns the value named {@code elementName} from {@code annotation}, which must be a member
-   * that contains a single type.
-   */
-  static TypeMirror typeValue(AnnotationMirror annotation, String elementName) {
-    return TO_TYPE.visit(getAnnotationValue(annotation, elementName));
-  }
-
-  private static final AnnotationValueVisitor<TypeMirror, Void> TO_TYPE =
-      new SimpleAnnotationValueVisitor6<TypeMirror, Void>() {
-        @Override
-        public TypeMirror visitType(TypeMirror t, Void p) {
-          return t;
-        }
-
-        @Override
-        protected TypeMirror defaultAction(Object o, Void p) {
-          throw new TypeNotPresentException(o.toString(), null);
-        }
-      };
-
   /**
    * Returns the full set of modules transitively {@linkplain Module#includes included} from the
    * given seed modules.  If a module is malformed and a type listed in {@link Module#includes}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index 7fcdcef53..3ec84c5c7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -18,6 +18,7 @@
 
 import static dagger.internal.codegen.ConfigurationAnnotations.getSubcomponentAnnotation;
 import static dagger.internal.codegen.MoreAnnotationMirrors.simpleName;
+import static java.util.stream.Collectors.joining;
 import static java.util.stream.Collectors.toList;
 
 import com.google.auto.common.MoreElements;
@@ -27,9 +28,12 @@
 import dagger.multibindings.Multibinds;
 import dagger.releasablereferences.CanReleaseReferences;
 import dagger.releasablereferences.ForReleasableReferences;
+import java.lang.annotation.Annotation;
+import java.util.Collection;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
@@ -389,6 +393,20 @@ static String referenceReleasingScopeNotAnnotatedWithMetadata(
         formattedKey, scope.getQualifiedName(), metadataType);
   }
 
+  /**
+   * Returns an error message for a method that has more than one binding method annotation.
+   *
+   * @param methodAnnotations the valid method annotations, only one of which may annotate the
+   *     method
+   */
+  static String tooManyBindingMethodAnnotations(
+      ExecutableElement method, Collection<Class<? extends Annotation>> methodAnnotations) {
+    return String.format(
+        "%s is annotated with more than one of (%s)",
+        method.getSimpleName(),
+        methodAnnotations.stream().map(Class::getCanonicalName).collect(joining(", ")));
+  }
+
   static class ComponentBuilderMessages {
     static final ComponentBuilderMessages INSTANCE = new ComponentBuilderMessages();
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/ForReleasableReferencesValidator.java b/compiler/src/main/java/dagger/internal/codegen/ForReleasableReferencesValidator.java
index 4566bc589..720b70959 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ForReleasableReferencesValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ForReleasableReferencesValidator.java
@@ -19,9 +19,9 @@
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Preconditions.checkArgument;
-import static dagger.internal.codegen.ConfigurationAnnotations.typeValue;
 import static dagger.internal.codegen.ErrorMessages.forReleasableReferencesValueCannotReleaseReferences;
 import static dagger.internal.codegen.ErrorMessages.forReleasableReferencesValueNotAScope;
+import static dagger.internal.codegen.MoreAnnotationMirrors.getTypeValue;
 import static dagger.internal.codegen.Scope.isScope;
 import static dagger.internal.codegen.Scope.scope;
 
@@ -51,7 +51,7 @@
     ValidationReport.Builder<Element> report = ValidationReport.about(annotatedElement);
     AnnotationMirror annotation =
         getAnnotationMirror(annotatedElement, ForReleasableReferences.class).get();
-    TypeElement scopeType = MoreTypes.asTypeElement(typeValue(annotation, "value"));
+    TypeElement scopeType = MoreTypes.asTypeElement(getTypeValue(annotation, "value"));
     if (!isScope(scopeType)) {
       report.addError(
           forReleasableReferencesValueNotAScope(scopeType), annotatedElement, annotation);
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
index 647b65c59..c6596c27c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
@@ -33,6 +33,7 @@
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
+import com.google.common.collect.Sets;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import dagger.Binds;
 import dagger.BindsOptionalOf;
@@ -74,16 +75,11 @@
   abstract ImmutableSet<OptionalBindingDeclaration> optionalDeclarations();
 
   enum Kind {
-    MODULE(
-        Module.class, Provides.class, ImmutableSet.of(Module.class)),
-    PRODUCER_MODULE(
-        ProducerModule.class,
-        Produces.class,
-        ImmutableSet.of(Module.class, ProducerModule.class));
+    MODULE(Module.class, Provides.class),
+    PRODUCER_MODULE(ProducerModule.class, Produces.class);
 
     private final Class<? extends Annotation> moduleAnnotation;
     private final Class<? extends Annotation> methodAnnotation;
-    private final ImmutableSet<? extends Class<? extends Annotation>> includesTypes;
 
     /**
      * Returns the kind of an annotated element if it is annotated with one of the
@@ -106,11 +102,9 @@
 
     Kind(
         Class<? extends Annotation> moduleAnnotation,
-        Class<? extends Annotation> methodAnnotation,
-        ImmutableSet<? extends Class<? extends Annotation>> includesTypes) {
+        Class<? extends Annotation> methodAnnotation) {
       this.moduleAnnotation = moduleAnnotation;
       this.methodAnnotation = methodAnnotation;
-      this.includesTypes = includesTypes;
     }
 
     Optional<AnnotationMirror> getModuleAnnotationMirror(TypeElement element) {
@@ -125,8 +119,15 @@
       return methodAnnotation;
     }
 
-    ImmutableSet<? extends Class<? extends Annotation>> includesTypes() {
-      return includesTypes;
+    ImmutableSet<Kind> includesKinds() {
+      switch (this) {
+        case MODULE:
+          return Sets.immutableEnumSet(MODULE);
+        case PRODUCER_MODULE:
+          return Sets.immutableEnumSet(MODULE, PRODUCER_MODULE);
+        default:
+          throw new AssertionError(this);
+      }
     }
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
index 818e5f510..28bac6826 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
@@ -17,7 +17,6 @@
 package dagger.internal.codegen;
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static dagger.internal.codegen.Util.elementsWithAnnotation;
 import static javax.lang.model.util.ElementFilter.methodsIn;
 import static javax.lang.model.util.ElementFilter.typesIn;
 
@@ -50,23 +49,14 @@
   static ModuleProcessingStep moduleProcessingStep(
       Messager messager,
       ModuleValidator moduleValidator,
-      final ProvisionBinding.Factory provisionBindingFactory,
-      FactoryGenerator factoryGenerator,
-      ProvidesMethodValidator providesMethodValidator,
-      BindsMethodValidator bindsMethodValidator,
-      MultibindsMethodValidator multibindsMethodValidator,
-      BindsOptionalOfMethodValidator bindsOptionalOfMethodValidator) {
+      ProvisionBinding.Factory provisionBindingFactory,
+      FactoryGenerator factoryGenerator) {
     return new ModuleProcessingStep(
         messager,
         Module.class,
         moduleValidator,
-        ImmutableSet.<ModuleMethodFactoryGenerator>of(
-            new ProvisionModuleMethodFactoryGenerator(provisionBindingFactory, factoryGenerator)),
         ImmutableSet.of(
-            providesMethodValidator,
-            bindsMethodValidator,
-            multibindsMethodValidator,
-            bindsOptionalOfMethodValidator));
+            new ProvisionModuleMethodFactoryGenerator(provisionBindingFactory, factoryGenerator)));
   }
 
   /**
@@ -78,13 +68,8 @@ static ModuleProcessingStep producerModuleProcessingStep(
       ModuleValidator moduleValidator,
       ProvisionBinding.Factory provisionBindingFactory,
       FactoryGenerator factoryGenerator,
-      ProvidesMethodValidator providesMethodValidator,
       ProductionBinding.Factory productionBindingFactory,
-      ProducerFactoryGenerator producerFactoryGenerator,
-      ProducesMethodValidator producesMethodValidator,
-      BindsMethodValidator bindsMethodValidator,
-      MultibindsMethodValidator multibindsMethodValidator,
-      BindsOptionalOfMethodValidator bindsOptionalOfMethodValidator) {
+      ProducerFactoryGenerator producerFactoryGenerator) {
     return new ModuleProcessingStep(
         messager,
         ProducerModule.class,
@@ -92,107 +77,61 @@ static ModuleProcessingStep producerModuleProcessingStep(
         ImmutableSet.of(
             new ProvisionModuleMethodFactoryGenerator(provisionBindingFactory, factoryGenerator),
             new ProductionModuleMethodFactoryGenerator(
-                productionBindingFactory, producerFactoryGenerator)),
-        ImmutableSet.of(
-            providesMethodValidator,
-            producesMethodValidator,
-            bindsMethodValidator,
-            multibindsMethodValidator,
-            bindsOptionalOfMethodValidator));
+                productionBindingFactory, producerFactoryGenerator)));
   }
 
   private final Messager messager;
   private final Class<? extends Annotation> moduleAnnotation;
   private final ModuleValidator moduleValidator;
   private final ImmutableSet<ModuleMethodFactoryGenerator> moduleMethodFactoryGenerators;
-  private final ImmutableSet<? extends BindingMethodValidator> methodValidators;
   private final Set<TypeElement> processedModuleElements = Sets.newLinkedHashSet();
 
   /**
    * Creates a new processing step.
    *
    * @param moduleAnnotation the annotation on the module class
-   * @param methodValidators validators for binding methods
    */
   ModuleProcessingStep(
       Messager messager,
       Class<? extends Annotation> moduleAnnotation,
       ModuleValidator moduleValidator,
-      ImmutableSet<ModuleMethodFactoryGenerator> moduleMethodFactoryGenerators,
-      Iterable<? extends BindingMethodValidator> methodValidators) {
+      ImmutableSet<ModuleMethodFactoryGenerator> moduleMethodFactoryGenerators) {
     this.messager = messager;
     this.moduleAnnotation = moduleAnnotation;
     this.moduleValidator = moduleValidator;
     this.moduleMethodFactoryGenerators = moduleMethodFactoryGenerators;
-    this.methodValidators = ImmutableSet.copyOf(methodValidators);
   }
 
   @Override
   public Set<? extends Class<? extends Annotation>> annotations() {
-    ImmutableSet.Builder<Class<? extends Annotation>> annotations = ImmutableSet.builder();
-    annotations.add(moduleAnnotation);
-    for (BindingMethodValidator validator : methodValidators) {
-      annotations.add(validator.methodAnnotation());
-    }
-    return annotations.build();
+    return ImmutableSet.of(moduleAnnotation);
   }
 
   @Override
   public Set<Element> process(
       SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
-    ImmutableSet<ExecutableElement> validMethods = validMethods(elementsByAnnotation);
-
-    // process each module
-    for (TypeElement moduleElement :
-        Sets.difference(
-            typesIn(elementsByAnnotation.get(moduleAnnotation)), processedModuleElements)) {
-      ValidationReport<TypeElement> report = moduleValidator.validate(moduleElement);
-      report.printMessagesTo(messager);
-
-      if (report.isClean()) {
-        List<ExecutableElement> moduleMethods = methodsIn(moduleElement.getEnclosedElements());
-        if (moduleMethodsAreValid(validMethods, moduleMethods)) {
-          for (ModuleMethodFactoryGenerator generator : moduleMethodFactoryGenerators) {
-            for (ExecutableElement method :
-                elementsWithAnnotation(moduleMethods, generator.factoryMethodAnnotation())) {
-              generator.generate(method, moduleElement, messager);
-            }
-          }
-        }
+    List<TypeElement> modules = typesIn(elementsByAnnotation.values());
+    moduleValidator.addKnownModules(modules);
+    for (TypeElement module : modules) {
+      if (processedModuleElements.add(module)) {
+        processModule(module);
       }
-      processedModuleElements.add(moduleElement);
     }
     return ImmutableSet.of();
   }
 
-  /** The binding methods that are valid according to their validator. */
-  private ImmutableSet<ExecutableElement> validMethods(
-      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
-    ImmutableSet.Builder<ExecutableElement> validMethods = ImmutableSet.builder();
-    for (BindingMethodValidator validator : methodValidators) {
-      validMethods.addAll(
-          validator.validate(
-              messager, methodsIn(elementsByAnnotation.get(validator.methodAnnotation()))));
-    }
-    return validMethods.build();
-  }
-
-  /**
-   * {@code true} if all {@code moduleMethods} that are annotated with a binding method annotation
-   * are in {@code validMethods}.
-   */
-  private boolean moduleMethodsAreValid(
-      ImmutableSet<ExecutableElement> validMethods, Iterable<ExecutableElement> moduleMethods) {
-    for (ExecutableElement methodElement : moduleMethods) {
-      if (!validMethods.contains(methodElement)) {
-        for (BindingMethodValidator validator : methodValidators) {
-          if (isAnnotationPresent(methodElement, validator.methodAnnotation())) {
-            return false;
+  private void processModule(TypeElement module) {
+    ValidationReport<TypeElement> report = moduleValidator.validate(module);
+    report.printMessagesTo(messager);
+    if (report.isClean()) {
+      for (ExecutableElement method : methodsIn(module.getEnclosedElements())) {
+        for (ModuleMethodFactoryGenerator generator : moduleMethodFactoryGenerators) {
+          if (isAnnotationPresent(method, generator.factoryMethodAnnotation())) {
+            generator.generate(method, module, messager);
           }
         }
       }
     }
-    return true;
   }
 
   interface ModuleMethodFactoryGenerator {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
index 131b1f925..bd2f9140a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
@@ -21,9 +21,9 @@
 import static com.google.auto.common.Visibility.PRIVATE;
 import static com.google.auto.common.Visibility.PUBLIC;
 import static com.google.auto.common.Visibility.effectiveVisibilityOfElement;
-import static com.google.common.collect.Iterables.any;
 import static dagger.internal.codegen.ConfigurationAnnotations.getModuleIncludes;
 import static dagger.internal.codegen.ConfigurationAnnotations.getModuleSubcomponents;
+import static dagger.internal.codegen.ConfigurationAnnotations.getModules;
 import static dagger.internal.codegen.ConfigurationAnnotations.getSubcomponentBuilder;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_SAME_NAME;
 import static dagger.internal.codegen.ErrorMessages.INCOMPATIBLE_MODULE_METHODS;
@@ -35,10 +35,14 @@
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_OVERRIDES_ANOTHER;
 import static dagger.internal.codegen.ErrorMessages.REFERENCED_MODULE_MUST_NOT_HAVE_TYPE_PARAMS;
 import static dagger.internal.codegen.ErrorMessages.REFERENCED_MODULE_NOT_ANNOTATED;
+import static dagger.internal.codegen.MoreAnnotationValues.asType;
 import static dagger.internal.codegen.Util.isAnyAnnotationPresent;
+import static dagger.internal.codegen.Util.toImmutableSet;
+import static java.util.EnumSet.noneOf;
 import static java.util.stream.Collectors.joining;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.STATIC;
+import static javax.lang.model.util.ElementFilter.methodsIn;
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
@@ -46,24 +50,26 @@
 import com.google.common.base.Joiner;
 import com.google.common.collect.ArrayListMultimap;
 import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ListMultimap;
 import com.google.common.collect.Sets;
 import dagger.Binds;
 import dagger.Module;
 import dagger.Subcomponent;
-import dagger.internal.codegen.ModuleDescriptor.Kind;
 import dagger.multibindings.Multibinds;
 import dagger.producers.ProducerModule;
 import dagger.producers.ProductionSubcomponent;
 import java.lang.annotation.Annotation;
 import java.util.Collection;
 import java.util.EnumSet;
+import java.util.HashMap;
+import java.util.HashSet;
 import java.util.List;
+import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Set;
 import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
@@ -73,6 +79,7 @@
 import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.SimpleTypeVisitor6;
+import javax.lang.model.util.SimpleTypeVisitor8;
 import javax.lang.model.util.Types;
 
 /**
@@ -89,25 +96,53 @@
 
   private final Types types;
   private final Elements elements;
+  private final AnyBindingMethodValidator anyBindingMethodValidator;
   private final MethodSignatureFormatter methodSignatureFormatter;
+  private final Map<TypeElement, ValidationReport<TypeElement>> cache = new HashMap<>();
+  private final Set<TypeElement> knownModules = new HashSet<>();
 
   ModuleValidator(
-      Types types, Elements elements, MethodSignatureFormatter methodSignatureFormatter) {
+      Types types,
+      Elements elements,
+      AnyBindingMethodValidator anyBindingMethodValidator,
+      MethodSignatureFormatter methodSignatureFormatter) {
     this.types = types;
     this.elements = elements;
+    this.anyBindingMethodValidator = anyBindingMethodValidator;
     this.methodSignatureFormatter = methodSignatureFormatter;
   }
 
-  ValidationReport<TypeElement> validate(final TypeElement subject) {
-    final ValidationReport.Builder<TypeElement> builder = ValidationReport.about(subject);
-    ModuleDescriptor.Kind moduleKind = ModuleDescriptor.Kind.forAnnotatedElement(subject).get();
+  /**
+   * Adds {@code modules} to the set of module types that will be validated during this compilation
+   * step. If a component or module includes a module that is not in this set, that included module
+   * is assumed to be valid because it was processed in a previous compilation step. If it were
+   * invalid, that previous compilation step would have failed and blocked this one.
+   *
+   * <p>This logic depends on this method being called before {@linkplain #validate(TypeElement)
+   * validating} any module or {@linkplain #validateReferencedModules(TypeElement, AnnotationMirror,
+   * ImmutableSet) component}.
+   */
+  void addKnownModules(Collection<TypeElement> modules) {
+    knownModules.addAll(modules);
+  }
+
+  /** Returns a validation report for a module type. */
+  ValidationReport<TypeElement> validate(TypeElement module) {
+    return cache.computeIfAbsent(module, this::validateUncached);
+  }
+
+  private ValidationReport<TypeElement> validateUncached(TypeElement module) {
+    ValidationReport.Builder<TypeElement> builder = ValidationReport.about(module);
+    ModuleDescriptor.Kind moduleKind = ModuleDescriptor.Kind.forAnnotatedElement(module).get();
 
-    List<ExecutableElement> moduleMethods = ElementFilter.methodsIn(subject.getEnclosedElements());
     ListMultimap<String, ExecutableElement> allMethodsByName = ArrayListMultimap.create();
     ListMultimap<String, ExecutableElement> bindingMethodsByName = ArrayListMultimap.create();
 
-    Set<ModuleMethodKind> methodKinds = EnumSet.noneOf(ModuleMethodKind.class);
-    for (ExecutableElement moduleMethod : moduleMethods) {
+    Set<ModuleMethodKind> methodKinds = noneOf(ModuleMethodKind.class);
+    for (ExecutableElement moduleMethod : methodsIn(module.getEnclosedElements())) {
+      if (anyBindingMethodValidator.isBindingMethod(moduleMethod)) {
+        builder.addSubreport(anyBindingMethodValidator.validate(moduleMethod));
+      }
       if (isAnyAnnotationPresent(
           moduleMethod,
           ImmutableSet.of(moduleKind.methodAnnotation(), Binds.class, Multibinds.class))) {
@@ -126,17 +161,16 @@
               moduleKind.methodAnnotation().getSimpleName()));
     }
 
-    validateModuleVisibility(subject, moduleKind, builder);
+    validateModuleVisibility(module, moduleKind, builder);
     validateMethodsWithSameName(moduleKind, builder, bindingMethodsByName);
-    if (subject.getKind() != ElementKind.INTERFACE) {
+    if (module.getKind() != ElementKind.INTERFACE) {
       validateProvidesOverrides(
-          subject, moduleKind, builder, allMethodsByName, bindingMethodsByName);
+          module, moduleKind, builder, allMethodsByName, bindingMethodsByName);
     }
-    validateModifiers(subject, builder);
-    validateReferencedModules(subject, moduleKind, builder);
-    validateReferencedSubcomponents(subject, moduleKind, builder);
+    validateModifiers(module, builder);
+    validateReferencedModules(module, moduleKind, builder);
+    validateReferencedSubcomponents(module, moduleKind, builder);
 
-    // TODO(gak): port the dagger 1 module validation?
     return builder.build();
   }
 
@@ -148,7 +182,7 @@ private void validateReferencedSubcomponents(
     // TODO(ronshapiro): use validateTypesAreDeclared when it is checked in
     for (TypeMirror subcomponentAttribute : getModuleSubcomponents(moduleAnnotation)) {
       subcomponentAttribute.accept(
-          new SimpleTypeVisitor6<Void, Void>(){
+          new SimpleTypeVisitor6<Void, Void>() {
             @Override
             protected Void defaultAction(TypeMirror e, Void aVoid) {
               builder.addError(e + " is not a valid subcomponent type", subject, moduleAnnotation);
@@ -165,17 +199,18 @@ public Void visitDeclared(DeclaredType declaredType, Void aVoid) {
                     isAnyAnnotationPresent(attributeType, SUBCOMPONENT_BUILDER_TYPES)
                         ? moduleSubcomponentsIncludesBuilder(attributeType)
                         : moduleSubcomponentsIncludesNonSubcomponent(attributeType),
-                    attributeType,
+                    subject,
                     moduleAnnotation);
               }
 
               return null;
             }
-          }, null);
+          },
+          null);
     }
   }
 
-  private void validateSubcomponentHasBuilder(
+  private static void validateSubcomponentHasBuilder(
       TypeElement subcomponentAttribute,
       AnnotationMirror moduleAnnotation,
       ValidationReport.Builder<TypeElement> builder) {
@@ -184,7 +219,7 @@ private void validateSubcomponentHasBuilder(
     }
     builder.addError(
         moduleSubcomponentsDoesntHaveBuilder(subcomponentAttribute, moduleAnnotation),
-        subcomponentAttribute,
+        builder.getSubject(),
         moduleAnnotation);
   }
 
@@ -237,64 +272,75 @@ private void validateReferencedModules(
       ValidationReport.Builder<TypeElement> builder) {
     // Validate that all the modules we include are valid for inclusion.
     AnnotationMirror mirror = moduleKind.getModuleAnnotationMirror(subject).get();
-    ImmutableList<TypeMirror> includes = getModuleIncludes(mirror);
-    validateReferencedModules(subject, builder, includes, ImmutableSet.of(moduleKind));
-  }
-
-  private static ImmutableSet<? extends Class<? extends Annotation>> includedModuleClasses(
-      ImmutableSet<ModuleDescriptor.Kind> validModuleKinds) {
-    return FluentIterable.from(validModuleKinds).transformAndConcat(Kind::includesTypes).toSet();
+    builder.addSubreport(validateReferencedModules(subject, mirror, moduleKind.includesKinds()));
   }
 
   /**
-   * Used by {@link ModuleValidator} and {@link ComponentValidator} to validate referenced modules.
+   * Validates modules included in a given module or installed in a given component.
+   *
+   * <p>Checks that the referenced modules are non-generic types annotated with {@code @Module} or
+   * {@code @ProducerModule}.
+   *
+   * <p>If the referenced module is in the {@linkplain #addKnownModules(Collection) known modules
+   * set} and has errors, reports an error at that module's inclusion.
+   *
+   * @param annotatedType the annotated module or component
+   * @param annotation the annotation specifying the referenced modules ({@code @Component},
+   *     {@code @ProductionComponent}, {@code @Subcomponent}, {@code @ProductionSubcomponent},
+   *     {@code @Module}, or {@code @ProducerModule})
+   * @param validModuleKinds the module kinds that the annotated type is permitted to include
    */
-  void validateReferencedModules(
-      final TypeElement subject,
-      final ValidationReport.Builder<TypeElement> builder,
-      ImmutableList<TypeMirror> includes,
+  ValidationReport<TypeElement> validateReferencedModules(
+      TypeElement annotatedType,
+      AnnotationMirror annotation,
       ImmutableSet<ModuleDescriptor.Kind> validModuleKinds) {
-    final ImmutableSet<? extends Class<? extends Annotation>> includedModuleClasses =
-        includedModuleClasses(validModuleKinds);
+    ValidationReport.Builder<TypeElement> subreport = ValidationReport.about(annotatedType);
+    ImmutableSet<? extends Class<? extends Annotation>> validModuleAnnotations =
+        validModuleKinds
+            .stream()
+            .map(ModuleDescriptor.Kind::moduleAnnotation)
+            .collect(toImmutableSet());
 
-    for (TypeMirror includesType : includes) {
-      includesType.accept(
-          new SimpleTypeVisitor6<Void, Void>() {
-            @Override
-            protected Void defaultAction(TypeMirror mirror, Void p) {
-              builder.addError(mirror + " is not a valid module type.", subject);
-              return null;
-            }
+    for (AnnotationValue includedModule : getModules(annotatedType, annotation)) {
+      asType(includedModule)
+          .accept(
+              new SimpleTypeVisitor8<Void, Void>() {
+                @Override
+                protected Void defaultAction(TypeMirror mirror, Void p) {
+                  reportError("%s is not a valid module type.", mirror);
+                  return null;
+                }
 
-            @Override
-            public Void visitDeclared(DeclaredType t, Void p) {
-              final TypeElement element = MoreElements.asType(t.asElement());
-              if (!t.getTypeArguments().isEmpty()) {
-                builder.addError(
-                    String.format(
-                        REFERENCED_MODULE_MUST_NOT_HAVE_TYPE_PARAMS, element.getQualifiedName()),
-                    subject);
-              }
-              boolean isIncludedModule =
-                  any(
-                      includedModuleClasses,
-                      otherClass -> MoreElements.isAnnotationPresent(element, otherClass));
-              if (!isIncludedModule) {
-                builder.addError(
-                    String.format(
+                @Override
+                public Void visitDeclared(DeclaredType t, Void p) {
+                  TypeElement module = MoreElements.asType(t.asElement());
+                  if (!t.getTypeArguments().isEmpty()) {
+                    reportError(
+                        REFERENCED_MODULE_MUST_NOT_HAVE_TYPE_PARAMS, module.getQualifiedName());
+                  }
+                  if (!isAnyAnnotationPresent(module, validModuleAnnotations)) {
+                    reportError(
                         REFERENCED_MODULE_NOT_ANNOTATED,
-                        element.getQualifiedName(),
-                        (includedModuleClasses.size() > 1 ? "one of " : "")
-                            + includedModuleClasses.stream()
+                        module.getQualifiedName(),
+                        (validModuleAnnotations.size() > 1 ? "one of " : "")
+                            + validModuleAnnotations
+                                .stream()
                                 .map(otherClass -> "@" + otherClass.getSimpleName())
-                                .collect(joining(", "))),
-                    subject);
-              }
-              return null;
-            }
-          },
-          null);
+                                .collect(joining(", ")));
+                  } else if (knownModules.contains(module) && !validate(module).isClean()) {
+                    reportError("%s has errors", module.getQualifiedName());
+                  }
+                  return null;
+                }
+
+                private void reportError(String format, Object... args) {
+                  subreport.addError(
+                      String.format(format, args), annotatedType, annotation, includedModule);
+                }
+              },
+              null);
     }
+    return subreport.build();
   }
 
   private void validateProvidesOverrides(
diff --git a/compiler/src/main/java/dagger/internal/codegen/MoreAnnotationMirrors.java b/compiler/src/main/java/dagger/internal/codegen/MoreAnnotationMirrors.java
index 29f41748d..fb8e5f87e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MoreAnnotationMirrors.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MoreAnnotationMirrors.java
@@ -16,11 +16,18 @@
 
 package dagger.internal.codegen;
 
+import static com.google.auto.common.AnnotationMirrors.getAnnotationValue;
+import static dagger.internal.codegen.MoreAnnotationValues.asAnnotationValues;
+import static dagger.internal.codegen.MoreAnnotationValues.asType;
+import static dagger.internal.codegen.Util.toImmutableList;
+
 import com.google.auto.common.AnnotationMirrors;
 import com.google.common.base.Equivalence;
 import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableList;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Name;
+import javax.lang.model.type.TypeMirror;
 
 /**
  * A utility class for working with {@link AnnotationMirror} instances, similar to {@link
@@ -55,4 +62,26 @@ private MoreAnnotationMirrors() {}
   static Name simpleName(AnnotationMirror annotationMirror) {
     return annotationMirror.getAnnotationType().asElement().getSimpleName();
   }
+
+  /**
+   * Returns the value named {@code name} from {@code annotation}.
+   *
+   * @throws IllegalArgumentException unless that member represents a single type
+   */
+  static TypeMirror getTypeValue(AnnotationMirror annotation, String name) {
+    return asType(getAnnotationValue(annotation, name));
+  }
+
+  /**
+   * Returns the list of types that is the value named {@code name} from {@code annotationMirror}.
+   *
+   * @throws IllegalArgumentException unless that member represents an array of types
+   */
+  static ImmutableList<TypeMirror> getTypeListValue(
+      AnnotationMirror annotationMirror, String name) {
+    return asAnnotationValues(getAnnotationValue(annotationMirror, name))
+        .stream()
+        .map(MoreAnnotationValues::asType)
+        .collect(toImmutableList());
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MoreAnnotationValues.java b/compiler/src/main/java/dagger/internal/codegen/MoreAnnotationValues.java
new file mode 100644
index 000000000..84a4d94b0
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/MoreAnnotationValues.java
@@ -0,0 +1,75 @@
+/*
+ * Copyright (C) 2013 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableList;
+import java.util.List;
+import javax.lang.model.element.AnnotationValue;
+import javax.lang.model.element.AnnotationValueVisitor;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.SimpleAnnotationValueVisitor8;
+
+/** Utility methods for working with {@link AnnotationValue} instances. */
+final class MoreAnnotationValues {
+  /**
+   * Returns the list of values represented by an array annotation value.
+   *
+   * @throws IllegalArgumentException unless {@code annotationValue} represents an array
+   */
+  static ImmutableList<AnnotationValue> asAnnotationValues(AnnotationValue annotationValue) {
+    return annotationValue.accept(AS_ANNOTATION_VALUES, null);
+  }
+
+  private static final AnnotationValueVisitor<ImmutableList<AnnotationValue>, String>
+      AS_ANNOTATION_VALUES =
+          new SimpleAnnotationValueVisitor8<ImmutableList<AnnotationValue>, String>() {
+            @Override
+            public ImmutableList<AnnotationValue> visitArray(
+                List<? extends AnnotationValue> vals, String elementName) {
+              return ImmutableList.copyOf(vals);
+            }
+
+            @Override
+            protected ImmutableList<AnnotationValue> defaultAction(Object o, String elementName) {
+              throw new IllegalArgumentException(elementName + " is not an array: " + o);
+            }
+          };
+
+  /**
+   * Returns the type represented by an annotation value.
+   *
+   * @throws IllegalArgumentException unless {@code annotationValue} represents a single type
+   */
+  static TypeMirror asType(AnnotationValue annotationValue) {
+    return AS_TYPE.visit(annotationValue);
+  }
+
+  private static final AnnotationValueVisitor<TypeMirror, Void> AS_TYPE =
+      new SimpleAnnotationValueVisitor8<TypeMirror, Void>() {
+        @Override
+        public TypeMirror visitType(TypeMirror t, Void p) {
+          return t;
+        }
+
+        @Override
+        protected TypeMirror defaultAction(Object o, Void p) {
+          throw new TypeNotPresentException(o.toString(), null);
+        }
+      };
+
+  private MoreAnnotationValues() {}
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java b/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java
index 019bc07a4..72bcfed07 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java
@@ -27,35 +27,30 @@
 import javax.annotation.CheckReturnValue;
 import javax.annotation.processing.Messager;
 import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.util.SimpleElementVisitor6;
 import javax.tools.Diagnostic;
 import javax.tools.Diagnostic.Kind;
 
-/**
- * A collection of items describing contractual issues with the code as presented to an annotation
- * processor.  A "clean" report (i.e. with no issues) is a report with no {@linkplain Item items}
- * and clean subreports. Callers will typically print the results of the report to a
- * {@link Messager} instance using {@link #printMessagesTo}.
- *
- * <p>A report describes a subject {@link Element}.  Callers may choose to add report items about
- * other elements that are contained within or related to the subject. Since {@link Diagnostic}
- * reporting is expected to be associated with elements that are currently being compiled,
- * {@link #printMessagesTo(Messager)} will only associate messages with non-subject elements if they
- * are contained within the subject. Otherwise, they will be associated with the subject and contain
- * a reference to the item's element in the message string. It is the responsibility of the caller
- * to choose subjects that are part of the compilation.
- *
- * @author Gregory Kick
- * @since 2.0
- */
+/** A collection of issues to report for source code. */
 @AutoValue
 abstract class ValidationReport<T extends Element> {
+
+  /**
+   * The subject of the report. Should be an element within a compilation unit being processed by
+   * this compilation task.
+   */
   abstract T subject();
+
+  /** The items to report for the {@linkplain #subject() subject}. */
   abstract ImmutableSet<Item> items();
+
+  /** Other reports associated with this one. */
   abstract ImmutableSet<ValidationReport<?>> subreports();
 
+  /** Returns {@code true} if there are no errors in this report or any subreports. */
   boolean isClean() {
     for (Item item : items()) {
       switch (item.kind()) {
@@ -73,22 +68,35 @@ boolean isClean() {
     return true;
   }
 
+  /**
+   * Prints all {@linkplain #items() messages} to {@code messager} (and recurs for subreports). If a
+   * message's {@linkplain Item#element() element} is contained within the report's {@linkplain
+   * #subject() subject}, associates the message with the message's element. Otherwise, since
+   * {@link Diagnostic} reporting is expected to be associated with elements that are currently
+   * being compiled, associates the message with the subject itself and prepends a reference to the
+   * item's element.
+   */
   void printMessagesTo(Messager messager) {
     for (Item item : items()) {
       if (isEnclosedIn(subject(), item.element())) {
         if (item.annotation().isPresent()) {
-          messager.printMessage(
-              item.kind(), item.message(), item.element(), item.annotation().get());
+          if (item.annotationValue().isPresent()) {
+            messager.printMessage(
+                item.kind(),
+                item.message(),
+                item.element(),
+                item.annotation().get(),
+                item.annotationValue().get());
+          } else {
+            messager.printMessage(
+                item.kind(), item.message(), item.element(), item.annotation().get());
+          }
         } else {
           messager.printMessage(item.kind(), item.message(), item.element());
         }
       } else {
         String message = String.format("[%s] %s", elementString(item.element()), item.message());
-        if (item.annotation().isPresent()) {
-          messager.printMessage(item.kind(), message, subject(), item.annotation().get());
-        } else {
-          messager.printMessage(item.kind(), message, subject());
-        }
+        messager.printMessage(item.kind(), message, subject());
       }
     }
     for (ValidationReport<?> subreport : subreports()) {
@@ -129,6 +137,7 @@ private static boolean isEnclosedIn(Element parent, Element child) {
     abstract Kind kind();
     abstract Element element();
     abstract Optional<AnnotationMirror> annotation();
+    abstract Optional<AnnotationValue> annotationValue();
   }
 
   static <T extends Element> Builder<T> about(T subject) {
@@ -156,52 +165,90 @@ T getSubject() {
     }
 
     Builder<T> addError(String message) {
-      return addItem(message, ERROR, subject, Optional.<AnnotationMirror>absent());
+      return addError(message, subject);
     }
 
     Builder<T> addError(String message, Element element) {
-      return addItem(message, ERROR, element, Optional.<AnnotationMirror>absent());
+      return addItem(message, ERROR, element);
     }
 
     Builder<T> addError(String message, Element element, AnnotationMirror annotation) {
-      return addItem(message, ERROR, element, Optional.of(annotation));
+      return addItem(message, ERROR, element, annotation);
+    }
+
+    Builder<T> addError(
+        String message,
+        Element element,
+        AnnotationMirror annotation,
+        AnnotationValue annotationValue) {
+      return addItem(message, ERROR, element, annotation, annotationValue);
     }
 
     Builder<T> addWarning(String message) {
-      return addItem(message, WARNING, subject, Optional.<AnnotationMirror>absent());
+      return addWarning(message, subject);
     }
 
     Builder<T> addWarning(String message, Element element) {
-      return addItem(message, WARNING, element, Optional.<AnnotationMirror>absent());
+      return addItem(message, WARNING, element);
     }
 
     Builder<T> addWarning(String message, Element element, AnnotationMirror annotation) {
-      return addItem(message, WARNING, element, Optional.of(annotation));
+      return addItem(message, WARNING, element, annotation);
+    }
+
+    Builder<T> addWarning(
+        String message,
+        Element element,
+        AnnotationMirror annotation,
+        AnnotationValue annotationValue) {
+      return addItem(message, WARNING, element, annotation, annotationValue);
     }
 
     Builder<T> addNote(String message) {
-      return addItem(message, NOTE, subject, Optional.<AnnotationMirror>absent());
+      return addNote(message, subject);
     }
 
     Builder<T> addNote(String message, Element element) {
-      return addItem(message, NOTE, element, Optional.<AnnotationMirror>absent());
+      return addItem(message, NOTE, element);
     }
 
     Builder<T> addNote(String message, Element element, AnnotationMirror annotation) {
-      return addItem(message, NOTE, element, Optional.of(annotation));
+      return addItem(message, NOTE, element, annotation);
+    }
+
+    Builder<T> addNote(
+        String message,
+        Element element,
+        AnnotationMirror annotation,
+        AnnotationValue annotationValue) {
+      return addItem(message, NOTE, element, annotation, annotationValue);
     }
 
     Builder<T> addItem(String message, Kind kind, Element element) {
-      return addItem(message, kind, element, Optional.<AnnotationMirror>absent());
+      return addItem(message, kind, element, Optional.absent(), Optional.absent());
     }
 
     Builder<T> addItem(String message, Kind kind, Element element, AnnotationMirror annotation) {
-      return addItem(message, kind, element, Optional.of(annotation));
+      return addItem(message, kind, element, Optional.of(annotation), Optional.absent());
+    }
+
+    Builder<T> addItem(
+        String message,
+        Kind kind,
+        Element element,
+        AnnotationMirror annotation,
+        AnnotationValue annotationValue) {
+      return addItem(message, kind, element, Optional.of(annotation), Optional.of(annotationValue));
     }
 
-    private Builder<T> addItem(String message, Kind kind, Element element,
-        Optional<AnnotationMirror> annotation) {
-      items.add(new AutoValue_ValidationReport_Item(message, kind, element, annotation));
+    private Builder<T> addItem(
+        String message,
+        Kind kind,
+        Element element,
+        Optional<AnnotationMirror> annotation,
+        Optional<AnnotationValue> annotationValue) {
+      items.add(
+          new AutoValue_ValidationReport_Item(message, kind, element, annotation, annotationValue));
       return this;
     }
 
diff --git a/compiler/src/test/java/dagger/internal/codegen/Compilers.java b/compiler/src/test/java/dagger/internal/codegen/Compilers.java
new file mode 100644
index 000000000..a42d1a2ff
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/Compilers.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.testing.compile.Compiler.javac;
+
+import com.google.testing.compile.Compiler;
+
+/** {@link Compiler} instances for testing Dagger. */
+final class Compilers {
+
+  /** Returns a compiler that runs the Dagger processor. */
+  static Compiler daggerCompiler() {
+    return javac().withProcessors(new ComponentProcessor());
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index a9f1474d5..07374ede1 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -109,6 +109,38 @@
     assertThat(compilation).hadErrorContaining("is not annotated with @Module");
   }
 
+  @Test
+  public void componentWithInvalidModule() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.BadModule",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "import dagger.Module;",
+            "",
+            "@Module",
+            "abstract class BadModule {",
+            "  @Binds abstract Object noParameters();",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.BadComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = BadModule.class)",
+            "interface BadComponent {",
+            "  Object object();",
+            "}");
+    Compilation compilation = daggerCompiler().compile(module, component);
+    assertThat(compilation)
+        .hadErrorContaining("test.BadModule has errors")
+        .inFile(component)
+        .onLine(5);
+  }
+
   @Test public void doubleBindingFromResolvedModules() {
     JavaFileObject parent = JavaFileObjects.forSourceLines("test.ParentModule",
         "package test;",
diff --git a/compiler/src/test/java/dagger/internal/codegen/ModuleValidatorTest.java b/compiler/src/test/java/dagger/internal/codegen/ModuleValidatorTest.java
index 9d52862d9..34ab495a6 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ModuleValidatorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ModuleValidatorTest.java
@@ -16,7 +16,10 @@
 
 package dagger.internal.codegen;
 
+import static com.google.testing.compile.CompilationSubject.assertThat;
 import static com.google.testing.compile.JavaSourcesSubject.assertThat;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
+import static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatModuleMethod;
 
 import com.google.testing.compile.JavaFileObjects;
 import dagger.Module;
@@ -240,4 +243,40 @@ public void moduleSubcomponentsAreTypes() {
         .in(module)
         .onLine(5);
   }
+  
+  @Test
+  public void tooManyAnnotations() {
+    assertThatModuleMethod(
+            "@BindsOptionalOf @Multibinds abstract Set<Object> tooManyAnnotations();")
+        .hasError("is annotated with more than one of");
+  }
+
+  @Test
+  public void invalidIncludedModule() {
+    JavaFileObject badModule =
+        JavaFileObjects.forSourceLines(
+            "test.BadModule",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "import dagger.Module;",
+            "",
+            "@Module",
+            "abstract class BadModule {",
+            "  @Binds abstract Object noParameters();",
+            "}");
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.IncludesBadModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "",
+            "@Module(includes = BadModule.class)",
+            "abstract class IncludesBadModule {}");
+    assertThat(daggerCompiler().compile(badModule, module))
+        .hadErrorContaining("test.BadModule has errors")
+        .inFile(module)
+        .onLine(5);
+  }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java
index 96d573b1a..040000fbf 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java
@@ -17,9 +17,12 @@
 package dagger.internal.codegen;
 
 import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.CompilationSubject.assertThat;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
 
 import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
@@ -438,4 +441,44 @@ public void cycleNotBrokenByProducerMap() {
         .in(component)
         .onLine(8);
   }
+  
+  @Test
+  public void componentWithBadModule() {
+    JavaFileObject badModule =
+        JavaFileObjects.forSourceLines(
+            "test.BadModule",
+            "package test;",
+            "",
+            "import dagger.BindsOptionalOf;",
+            "import dagger.multibindings.Multibinds;",
+            "import dagger.Module;",
+            "import java.util.Set;",
+            "",
+            "@Module",
+            "abstract class BadModule {",
+            "  @Multibinds",
+            "  @BindsOptionalOf",
+            "  abstract Set<String> strings();",
+            "}");
+    JavaFileObject badComponent =
+        JavaFileObjects.forSourceLines(
+            "test.BadComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import java.util.Optional;",
+            "import java.util.Set;",
+            "",
+            "@Component(modules = BadModule.class)",
+            "interface BadComponent {",
+            "  Set<String> strings();",
+            "  Optional<Set<String>> optionalStrings();",
+            "}");
+    Compilation compilation = daggerCompiler().compile(badModule, badComponent);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("test.BadModule has errors")
+        .inFile(badComponent)
+        .onLine(7);
+  }
 }
