diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentRequirement.java b/compiler/src/main/java/dagger/internal/codegen/ComponentRequirement.java
index 428deef86..d281c93f8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentRequirement.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentRequirement.java
@@ -93,7 +93,7 @@ NullPolicy nullPolicy(Elements elements, Types types) {
       case MODULE:
         return componentCanMakeNewInstances(typeElement())
             ? NullPolicy.NEW
-            : requiresAPassedInstance(elements, types, typeElement())
+            : requiresAPassedInstance(elements, types, this)
                 ? NullPolicy.THROW
                 : NullPolicy.ALLOW;
       case BINDING:
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
index 577362213..a4101eb90 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
@@ -191,6 +191,6 @@ protected void addFactoryMethods() {
   private boolean canInstantiateAllRequirements() {
     return !Iterables.any(
         graph.componentRequirements(),
-        dependency -> requiresAPassedInstance(elements, types, dependency.typeElement()));
+        dependency -> requiresAPassedInstance(elements, types, dependency));
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index 0c6046e37..84407a753 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -43,10 +43,17 @@
  */
 final class Util {
   /**
-   * Returns true if the passed {@link TypeElement} requires a passed instance in order to be used
-   * within a component.
+   * Returns true if the passed {@link ComponentRequirement} requires a passed instance in order
+   * to be used within a component.
    */
-  static boolean requiresAPassedInstance(Elements elements, Types types, TypeElement typeElement) {
+  static boolean requiresAPassedInstance(
+      Elements elements, Types types, ComponentRequirement componentRequirement) {
+    if (componentRequirement.kind() == ComponentRequirement.Kind.BINDING) {
+      // A user has explicitly defined in their component builder they will provide an instance.
+      return true;
+    }
+
+    TypeElement typeElement = componentRequirement.typeElement();
     ImmutableSet<ExecutableElement> methods =
         getLocalAndInheritedMethods(typeElement, types, elements);
     boolean foundInstanceMethod = false;
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java
index f5af32957..e241dcc26 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java
@@ -420,6 +420,88 @@ public void testBuilderMissingBuildMethodFails() {
         .in(componentFile);
   }
 
+  @Test
+  public void testBuilderBindsInstanceNoCreateGenerated() {
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.BindsInstance;",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "interface SimpleComponent {",
+            "  Object object();",
+            "",
+            "  @Component.Builder",
+            "  interface Builder {",
+            "    @BindsInstance Builder object(Object object);",
+            "    SimpleComponent build();",
+            "  }",
+            "}");
+
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerSimpleComponent",
+            "package test;",
+            "",
+            "import dagger.internal.InstanceFactory;",
+            "import dagger.internal.Preconditions;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerSimpleComponent implements SimpleComponent {",
+            "  private Provider<Object> objectProvider;",
+            "",
+            "  private DaggerSimpleComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static SimpleComponent.Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.objectProvider = InstanceFactory.create(builder.object);",
+            "  }",
+            "",
+            "  @Override",
+            "  public Object object() {",
+            "    return objectProvider.get();",
+            "  }",
+            "",
+            "  private static final class Builder implements SimpleComponent.Builder {",
+            "    private Object object;",
+            "",
+            "    @Override",
+            "    public SimpleComponent build() {",
+            "      if (object == null) {",
+            "        throw new IllegalStateException(",
+            "            Object.class.getCanonicalName() + \" must be set\")",
+            "      }",
+            "      return new DaggerSimpleComponent(this);",
+            "    }",
+            "",
+            "    @Override",
+            "    public Builder object(Object object) {",
+            "      this.object = Preconditions.checkNotNull(object);",
+            "      return this;",
+            "    }",
+            "  }",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(generatedComponent);
+  }
+
   @Test
   public void testPrivateBuilderFails() {
     JavaFileObject componentFile =
