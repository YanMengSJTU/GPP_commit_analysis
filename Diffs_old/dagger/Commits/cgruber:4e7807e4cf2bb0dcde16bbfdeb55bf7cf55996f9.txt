diff --git a/java/dagger/internal/codegen/ProducerCreationExpression.java b/java/dagger/internal/codegen/ProducerCreationExpression.java
index 56e82a804..05d74f8d0 100644
--- a/java/dagger/internal/codegen/ProducerCreationExpression.java
+++ b/java/dagger/internal/codegen/ProducerCreationExpression.java
@@ -43,7 +43,7 @@
   @Override
   public CodeBlock creationExpression() {
     return CodeBlock.of(
-        "new $T($L)",
+        "$T.create($L)",
         generatedClassNameForBinding(binding),
         componentBindingExpressions.getCreateMethodArgumentsCodeBlock(binding));
   }
diff --git a/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/java/dagger/internal/codegen/ProducerFactoryGenerator.java
index efc0c515e..4d3df446a 100644
--- a/java/dagger/internal/codegen/ProducerFactoryGenerator.java
+++ b/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -24,11 +24,13 @@
 import static com.squareup.javapoet.TypeSpec.classBuilder;
 import static dagger.internal.codegen.AnnotationSpecs.Suppression.UNCHECKED;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
+import static dagger.internal.codegen.CodeBlocks.toParametersCodeBlock;
 import static dagger.internal.codegen.GwtCompatibility.gwtIncompatibleAnnotation;
 import static dagger.internal.codegen.SourceFiles.bindingTypeElementTypeVariableNames;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
 import static dagger.internal.codegen.SourceFiles.generateBindingFieldsForDependencies;
 import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
+import static dagger.internal.codegen.SourceFiles.parameterizedGeneratedTypeNameForBinding;
 import static dagger.internal.codegen.TypeNames.FUTURES;
 import static dagger.internal.codegen.TypeNames.PRODUCERS;
 import static dagger.internal.codegen.TypeNames.PRODUCER_TOKEN;
@@ -41,6 +43,7 @@
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PROTECTED;
 import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.STATIC;
 
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
@@ -122,7 +125,7 @@ Element originatingElement(ProductionBinding binding) {
     UniqueNameSet uniqueFieldNames = new UniqueNameSet();
     ImmutableMap.Builder<Key, FieldSpec> fieldsBuilder = ImmutableMap.builder();
 
-    MethodSpec.Builder constructorBuilder = constructorBuilder().addModifiers(PUBLIC);
+    MethodSpec.Builder constructorBuilder = constructorBuilder().addModifiers(PRIVATE);
 
     Optional<FieldSpec> moduleField =
         binding.requiresModuleInstance()
@@ -209,13 +212,15 @@ Element originatingElement(ProductionBinding binding) {
       callProducesMethod.addAnnotation(AnnotationSpecs.suppressWarnings(UNCHECKED));
     }
 
+    MethodSpec constructor = constructorBuilder.build();
     factoryBuilder
         .superclass(
             ParameterizedTypeName.get(
                 ClassName.get(AbstractProducesMethodProducer.class),
                 futureTransform.applyArgType(),
                 providedTypeName))
-        .addMethod(constructorBuilder.build())
+        .addMethod(constructor)
+        .addMethod(staticFactoryMethod(binding, constructor))
         .addMethod(collectDependenciesBuilder.build())
         .addMethod(callProducesMethod.build());
 
@@ -225,6 +230,21 @@ Element originatingElement(ProductionBinding binding) {
     return Optional.of(factoryBuilder);
   }
 
+  private MethodSpec staticFactoryMethod(ProductionBinding binding, MethodSpec constructor) {
+    return MethodSpec.methodBuilder("create")
+        .addModifiers(PUBLIC, STATIC)
+        .returns(parameterizedGeneratedTypeNameForBinding(binding))
+        .addTypeVariables(bindingTypeElementTypeVariableNames(binding))
+        .addParameters(constructor.parameters)
+        .addStatement(
+            "return new $T($L)",
+            parameterizedGeneratedTypeNameForBinding(binding),
+            constructor.parameters.stream()
+                .map(p -> CodeBlock.of("$N", p.name))
+                .collect(toParametersCodeBlock()))
+        .build();
+  }
+
   // TODO(ronshapiro): consolidate versions of these
   private static FieldSpec addFieldAndConstructorParameter(
       TypeSpec.Builder typeBuilder,
diff --git a/javatests/dagger/functional/producers/ProducerFactoryTest.java b/javatests/dagger/functional/producers/ProducerFactoryTest.java
index ba39b9784..b3980704c 100644
--- a/javatests/dagger/functional/producers/ProducerFactoryTest.java
+++ b/javatests/dagger/functional/producers/ProducerFactoryTest.java
@@ -76,7 +76,7 @@ public ProductionComponentMonitor get() {
   public void noArgMethod() throws Exception {
     ProducerToken token = ProducerToken.create(SimpleProducerModule_StrFactory.class);
     Producer<String> producer =
-        new SimpleProducerModule_StrFactory(executorProvider, componentMonitorProvider);
+        SimpleProducerModule_StrFactory.create(executorProvider, componentMonitorProvider);
     assertThat(producer.get().get()).isEqualTo("str");
     InOrder order = inOrder(componentMonitor, monitor);
     order.verify(componentMonitor).producerMonitorFor(token);
@@ -91,7 +91,7 @@ public void singleArgMethod() throws Exception {
     SettableFuture<Integer> intFuture = SettableFuture.create();
     CancellableProducer<Integer> intProducer = producerOfFuture(intFuture);
     Producer<String> producer =
-        new SimpleProducerModule_StrWithArgFactory(
+        SimpleProducerModule_StrWithArgFactory.create(
             executorProvider, componentMonitorProvider, intProducer);
     assertThat(producer.get().isDone()).isFalse();
     intFuture.set(42);
@@ -108,7 +108,7 @@ public void successMonitor() throws Exception {
     CancellableProducer<SettableFuture<String>> strFutureProducer =
         producerOfFuture(strFutureFuture);
     Producer<String> producer =
-        new SimpleProducerModule_SettableFutureStrFactory(
+        SimpleProducerModule_SettableFutureStrFactory.create(
             executorProvider, componentMonitorProvider, strFutureProducer);
     assertThat(producer.get().isDone()).isFalse();
 
@@ -137,7 +137,7 @@ public void failureMonitor() throws Exception {
     CancellableProducer<SettableFuture<String>> strFutureProducer =
         producerOfFuture(strFutureFuture);
     Producer<String> producer =
-        new SimpleProducerModule_SettableFutureStrFactory(
+        SimpleProducerModule_SettableFutureStrFactory.create(
             executorProvider, componentMonitorProvider, strFutureProducer);
     assertThat(producer.get().isDone()).isFalse();
 
@@ -167,7 +167,7 @@ public void failureMonitorDueToThrowingProducer() throws Exception {
     ProducerToken token = ProducerToken.create(SimpleProducerModule_ThrowingProducerFactory.class);
 
     Producer<String> producer =
-        new SimpleProducerModule_ThrowingProducerFactory(
+        SimpleProducerModule_ThrowingProducerFactory.create(
             executorProvider, componentMonitorProvider);
     assertThat(producer.get().isDone()).isTrue();
 
@@ -189,7 +189,7 @@ public void failureMonitorDueToThrowingProducer() throws Exception {
 
   @Test(expected = NullPointerException.class)
   public void nullComponentMonitorProvider() throws Exception {
-    new SimpleProducerModule_StrFactory(executorProvider, null);
+    SimpleProducerModule_StrFactory.create(executorProvider, null);
   }
 
   private static <T> CancellableProducer<T> producerOfFuture(final ListenableFuture<T> future) {
diff --git a/javatests/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java b/javatests/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
index cd9a97779..0b4b2116f 100644
--- a/javatests/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
+++ b/javatests/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
@@ -373,7 +373,7 @@ public void publicModuleNonPublicIncludes() {
             "    extends AbstractProducesMethodProducer<Void, String> {",
             "  private final TestModule module;",
             "",
-            "  public TestModule_ProduceStringFactory(",
+            "  private TestModule_ProduceStringFactory(",
             "      TestModule module,",
             "      Provider<Executor> executorProvider,",
             "      Provider<ProductionComponentMonitor> productionComponentMonitorProvider) {",
@@ -384,6 +384,14 @@ public void publicModuleNonPublicIncludes() {
             "    this.module = module;",
             "  }",
             "",
+            "  public static TestModule_ProduceStringFactory create(",
+            "      TestModule module,",
+            "      Provider<Executor> executorProvider,",
+            "      Provider<ProductionComponentMonitor> productionComponentMonitorProvider) {",
+            "    return new TestModule_ProduceStringFactory(",
+            "        module, executorProvider, productionComponentMonitorProvider);",
+            "  }",
+            "",
             "  @Override protected ListenableFuture<Void> collectDependencies() {",
             "    return Futures.<Void>immediateFuture(null);",
             "  }",
@@ -438,7 +446,7 @@ public void singleProducesMethodNoArgsFutureWithProducerName() {
             "    extends AbstractProducesMethodProducer<Void, String> {",
             "  private final TestModule module;",
             "",
-            "  public TestModule_ProduceStringFactory(",
+            "  private TestModule_ProduceStringFactory(",
             "      TestModule module,",
             "      Provider<Executor> executorProvider,",
             "      Provider<ProductionComponentMonitor> productionComponentMonitorProvider) {",
@@ -449,6 +457,14 @@ public void singleProducesMethodNoArgsFutureWithProducerName() {
             "    this.module = module;",
             "  }",
             "",
+            "  public static TestModule_ProduceStringFactory create(",
+            "      TestModule module,",
+            "      Provider<Executor> executorProvider,",
+            "      Provider<ProductionComponentMonitor> productionComponentMonitorProvider) {",
+            "    return new TestModule_ProduceStringFactory(",
+            "        module, executorProvider, productionComponentMonitorProvider);",
+            "  }",
+            "",
             "  @Override protected ListenableFuture<Void> collectDependencies() {",
             "    return Futures.<Void>immediateFuture(null);",
             "  }",
diff --git a/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java b/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
index 2173deec4..3e111c5b8 100644
--- a/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
+++ b/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
@@ -340,7 +340,7 @@ public void simpleComponent() {
                 "        InstanceFactory.create((TestClass.SimpleComponent) this);",
                 "    this.bProducer = Producers.producerFromProvider(getBProvider());",
                 "    this.aProducer =",
-                "        new TestClass_AModule_AFactory(",
+                "        TestClass_AModule_AFactory.create(",
                 "            builder.aModule,",
                 "            getProductionImplementationExecutorProvider(),",
                 "            getProductionComponentMonitorProvider(),",
@@ -479,7 +479,7 @@ public void simpleComponent() {
                 "    this.bProvider = TestClass_BModule_BFactory.create(",
                 "        builder.bModule, TestClass_C_Factory.create());",
                 "    this.bProducer = Producers.producerFromProvider(bProvider);",
-                "    this.aProducer = new TestClass_AModule_AFactory(",
+                "    this.aProducer = TestClass_AModule_AFactory.create(",
                 "        builder.aModule,",
                 "        executorProvider2,",
                 "        monitorProvider,",
