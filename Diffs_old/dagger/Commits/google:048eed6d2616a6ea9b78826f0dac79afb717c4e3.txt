diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index fae6ac65c..3ad3d46ac 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -38,8 +38,8 @@
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Queue;
-import javax.inject.Provider;
 import java.util.Set;
+import javax.inject.Provider;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
@@ -299,7 +299,7 @@ private void resolveRequest(DependencyRequest request,
             } else {
               // no explicit binding, look it up
               Optional<ProvisionBinding> provisionBinding =
-                  injectBindingRegistry.getOrFindOrCreateProvisionBindingForKey(requestKey);
+                  injectBindingRegistry.getOrFindOrCreateProvisionBinding(requestKey);
               checkState(provisionBinding.isPresent(),
                   "Can not find a provision binding for %s. this should not have passed validation",
                   requestKey);
@@ -312,7 +312,7 @@ private void resolveRequest(DependencyRequest request,
               }
               resolvedBindings.put(frameworkKey, provisionBinding.get());
               resolvedProvisionsBindingBuilder.put(requestKey, provisionBinding.get());
-              } 
+              }
           } else {
             // we found explicit bindings. resolve the deps and them mark them resolved
             for (ProvisionBinding explicitBinding : explicitBindingsForKey) {
@@ -328,7 +328,7 @@ private void resolveRequest(DependencyRequest request,
         case MEMBERS_INJECTOR:
          // no explicit deps for members injection, so just look it up
           MembersInjectionBinding membersInjectionBinding =
-              injectBindingRegistry.getOrFindOrCreateMembersInjectionBindingForKey(requestKey);
+              injectBindingRegistry.getOrFindOrCreateMembersInjectionBinding(requestKey);
           //resolve its deps and then mark it resolved
           for (DependencyRequest dependency : Iterables.concat(
               membersInjectionBinding.dependencies(),
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
index e94c48348..a0a956a4d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
@@ -36,16 +36,19 @@
   private final ComponentValidator componentValidator;
   private final ComponentDescriptor.Factory componentDescriptorFactory;
   private final ComponentGenerator componentGenerator;
+  private final GraphValidator graphValidator;
 
   ComponentProcessingStep(
       Messager messager,
       ComponentValidator componentValidator,
+      GraphValidator graphValidator,
       Factory componentDescriptorFactory,
       ComponentGenerator componentGenerator) {
     this.messager = messager;
     this.componentValidator = componentValidator;
     this.componentDescriptorFactory = componentDescriptorFactory;
     this.componentGenerator = componentGenerator;
+    this.graphValidator = graphValidator;
   }
 
   @Override
@@ -55,11 +58,13 @@ public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment
     for (Element element : componentElements) {
       if (SuperficialValidation.validateElement(element)) {
         TypeElement componentTypeElement = MoreElements.asType(element);
-        ValidationReport<TypeElement> report =
+        ValidationReport<TypeElement> componentReport =
             componentValidator.validate(componentTypeElement);
-        report.printMessagesTo(messager);
-
-        if (report.isClean()) {
+        componentReport.printMessagesTo(messager);
+        ValidationReport<TypeElement> graphReport =
+            graphValidator.validate(componentTypeElement);
+        graphReport.printMessagesTo(messager);
+        if (componentReport.isClean() && graphReport.isClean()) {
           try {
             componentGenerator.generate(componentDescriptorFactory.create(componentTypeElement));
           } catch (SourceFileGenerationException e) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index dcf54d775..d6fcaba2a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -15,14 +15,12 @@
  */
 package dagger.internal.codegen;
 
-import dagger.MapKey;
-
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import dagger.Component;
+import dagger.MapKey;
 import dagger.Module;
 import dagger.Provides;
-import dagger.internal.codegen.MembersInjectionBinding.InjectionSite;
 import java.util.Set;
 import javax.annotation.processing.AbstractProcessor;
 import javax.annotation.processing.Filer;
@@ -103,6 +101,9 @@ public synchronized void init(ProcessingEnvironment processingEnv) {
             provisionBindingFactory, dependencyRequestFactory);
     MapKeyGenerator mapKeyGenerator = new MapKeyGenerator(filer);
 
+    GraphValidator graphValidator = new GraphValidator(elements, types, dependencyRequestFactory,
+        provisionBindingFactory, injectBindingRegistry);
+
     this.processingSteps = ImmutableList.<ProcessingStep>of(
         new MapKeyProcessingStep(
             messager,
@@ -127,6 +128,7 @@ public synchronized void init(ProcessingEnvironment processingEnv) {
         new ComponentProcessingStep(
             messager,
             componentValidator,
+            graphValidator,
             componentDescriptorFactory,
             componentGenerator));
   }
@@ -138,4 +140,4 @@ public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment
     }
     return false;
   }
-}
\ No newline at end of file
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
index b625a09e8..586dfab1c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
@@ -37,8 +37,6 @@
  *
  * @author Gregory Kick
  */
-// TODO(gak): this class does superficial component validation, but we need to do graph validation
-// as well
 final class ComponentValidator implements Validator<TypeElement> {
   private final Elements elements;
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
index 527f5d1f1..eaaf9a8bb 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -107,6 +107,8 @@ DependencyRequest forRequiredVariable(VariableElement variableElement) {
 
     DependencyRequest forComponentProvisionMethod(ExecutableElement provisionMethod) {
       checkNotNull(provisionMethod);
+      checkArgument(provisionMethod.getParameters().isEmpty(),
+          "Component provision methods must be empty: " + provisionMethod);
       TypeMirror type = provisionMethod.getReturnType();
       Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(provisionMethod);
       return newDependencyRequest(provisionMethod, type, qualifier);
@@ -162,4 +164,4 @@ private boolean isTypeOf(Class<?> type, TypeMirror mirror) {
       return elements.getTypeElement(type.getCanonicalName()).equals(types.asElement(mirror));
     }
   }
-}
\ No newline at end of file
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
new file mode 100644
index 000000000..d7150c8c9
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
@@ -0,0 +1,132 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreElements;
+import com.google.common.base.Optional;
+import com.google.common.collect.Queues;
+import java.util.Deque;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.util.SimpleElementVisitor6;
+
+import static com.google.common.collect.Iterables.getOnlyElement;
+
+/**
+ * Formats a {@link DependencyRequest} into a {@link String} suitable for an error message listing
+ * a chain of dependencies.
+ *
+ * @author Christian Gruber
+ * @since 2.0
+ */
+final class DependencyRequestFormatter extends Formatter<DependencyRequest> {
+  private static final DependencyRequestFormatter INSTANCE = new DependencyRequestFormatter();
+  private static final String INDENT = "    ";
+
+  static DependencyRequestFormatter instance() {
+    return INSTANCE;
+  }
+
+  // TODO(user): Sweep this class for TypeMirror.toString() usage and do some preventive format.
+  // TODO(user): consider returning a small structure containing strings to be indented later.
+  @Override public String format(DependencyRequest request) {
+    Element requestElement = request.requestElement();
+    Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(requestElement);
+    return requestElement.accept(new SimpleElementVisitor6<String, Optional<AnnotationMirror>>(){
+
+      /* Handle component methods */
+      @Override public String visitExecutable(
+          ExecutableElement method, Optional<AnnotationMirror> qualifier) {
+        StringBuilder builder = new StringBuilder(INDENT);
+        if (method.getParameters().isEmpty()) {
+          // some.package.name.MyComponent.myMethod()
+          //     [component method with return type: @other.package.Qualifier some.package.name.Foo]
+          appendMember(method, builder).append("()\n")
+              .append(INDENT).append(INDENT).append("[component method with return type: ");
+          if (qualifier.isPresent()) {
+            // TODO(user) use chenying's annotation mirror stringifier
+            builder.append(qualifier.get()).append(' ');
+          }
+          builder.append(method.getReturnType()).append(']');
+        } else {
+          // some.package.name.MyComponent.myMethod(some.package.name.Foo foo)
+          //     [component injection method for type: some.package.name.Foo]
+          VariableElement componentMethodParameter = getOnlyElement(method.getParameters());
+          appendMember(method, builder).append("(");
+          appendParameter(componentMethodParameter, builder);
+          builder.append(")\n");
+          builder.append(INDENT).append(INDENT).append("[component injection method for type: ")
+              .append(componentMethodParameter.asType())
+              .append(']');
+        }
+        return builder.toString();
+      }
+
+      /* Handle injected fields or method/constructor parameter injection. */
+      @Override public String visitVariable(
+          VariableElement variable, Optional<AnnotationMirror> qualifier) {
+        StringBuilder builder = new StringBuilder(INDENT);
+        if (variable.getKind().equals(ElementKind.PARAMETER)) {
+          // some.package.name.MyClass.myMethod(some.package.name.Foo arg0, some.package.Bar arg1)
+          //     [parameter: @other.package.Qualifier some.package.name.Foo arg0]
+          ExecutableElement methodOrConstructor =
+              MoreElements.asExecutable(variable.getEnclosingElement());
+          appendMember(methodOrConstructor, builder).append('(');
+          Deque<VariableElement> parameters =
+              Queues.newArrayDeque(methodOrConstructor.getParameters());
+          if (!parameters.isEmpty()) {
+            appendParameter(parameters.poll(), builder);
+          }
+          for(VariableElement current : parameters) {
+            appendParameter(current, builder.append(", "));
+          }
+          builder.append(")\n").append(INDENT).append(INDENT).append("[parameter: ");
+        } else {
+          // some.package.name.MyClass.myField
+          //     [injected field of type: @other.package.Qualifier some.package.name.Foo myField]
+          appendMember(variable, builder).append("()\n")
+              .append(INDENT).append(INDENT).append("[injected field of type: ");
+        }
+        if (qualifier.isPresent()) {
+          // TODO(user) use chenying's annotation mirror stringifier
+          builder.append(qualifier.get()).append(' ');
+        }
+        builder.append(variable.asType()).append(' ').append(variable.getSimpleName()).append(']');
+        return builder.toString();
+      }
+
+      @Override protected String defaultAction(Element element, Optional<AnnotationMirror> ignore) {
+        throw new IllegalStateException(
+            "Invalid request " + element.getKind() +  " element " + element);
+      }
+    }, qualifier);
+  }
+
+  private StringBuilder appendParameter(VariableElement parameter, StringBuilder builder) {
+    return builder.append(parameter.asType()).append(' ').append(parameter.getSimpleName());
+  }
+
+  private StringBuilder appendMember(Element member, StringBuilder builder) {
+    TypeElement type = MoreElements.asType(member.getEnclosingElement());
+    return builder.append(type.getQualifiedName())
+        .append('.')
+        .append(member.getSimpleName());
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index 001a42b7a..742675168 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -105,10 +105,10 @@
 
   static final String PROVIDES_METHOD_NOT_IN_MODULE =
       "@Provides methods can only be present within a @Module";
-  
+
   static final String PROVIDES_METHOD_NOT_MAP_HAS_MAP_KEY =
       "@Provides methods of non map type cannot declare a map key";
-  
+
   static final String PROVIDES_METHOD_WITH_NO_MAP_KEY =
       "@Provides methods of type map must declare a map key";
 
@@ -119,7 +119,7 @@
       "Cannot have more than one @Provides method with the same name in a single module";
 
   /*mapKey errors*/
-  static final String MAPKEY_WITHOUT_FIELDS = 
+  static final String MAPKEY_WITHOUT_FIELDS =
       "Map key annotation does not have fields";
 
   /* collection binding errors */
@@ -132,5 +132,16 @@
   static final String INVALID_COLLECTIONBINDING =
       "More than one binding present, but found an invalid binding";
 
+  static final String REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_FORMAT =
+      "%s cannot be provided without an @Inject constructor or from an @Provides-annotated method.";
+
+  static final String MEMBERS_INJECTION_DOES_NOT_IMPLY_PROVISION =
+      "This type supports members injection but cannot be implicitly provided.";
+
+  static final String CONTAINS_DEPENDENCY_CYCLE_FORMAT = "%s.%s() contains a dependency cycle:\n%s";
+
+  static final String MALFORMED_MODULE_METHOD_FORMAT =
+      "Cannot generated a graph because method %s on module %s was malformed";
+
   private ErrorMessages() {}
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Formatter.java b/compiler/src/main/java/dagger/internal/codegen/Formatter.java
new file mode 100644
index 000000000..891349ea5
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/Formatter.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.base.Function;
+
+/**
+ * A formatter which transforms an instance of a particular type into a string
+ * representation.
+ *
+ * @param <T> the type of the object to be transformed.
+ * @author Christian Gruber
+ * @since 2.0
+ */
+abstract class Formatter<T> implements Function<T, String> {
+
+  /**
+   * Performs the transformation of an object into a string representation.
+   */
+  public abstract String format(T object);
+
+  /**
+   * Performs the transformation of an object into a string representation in
+   * conformity with the {@link Function}{@code <T, String>} contract, delegating
+   * to {@link #format(Object)}.
+   *
+   * @deprecated Override {@link #format(T)} instead.
+   */
+  @Deprecated
+  @Override final public String apply(T object) {
+    return format(object);
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/FrameworkKey.java b/compiler/src/main/java/dagger/internal/codegen/FrameworkKey.java
index ba4f0d003..0488e22d1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FrameworkKey.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FrameworkKey.java
@@ -57,6 +57,10 @@ static FrameworkKey forDependencyRequest(DependencyRequest dependencyRequest) {
     return new AutoValue_FrameworkKey(dependencyRequest.key(), frameworkClass);
   }
 
+  static FrameworkKey forProvisionBinding(ProvisionBinding binding) {
+    return new AutoValue_FrameworkKey(binding.providedKey(), Provider.class);
+  }
+
   abstract Key key();
   abstract Class<?> frameworkClass();
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/GraphValidator.java
new file mode 100644
index 000000000..801db36d9
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/GraphValidator.java
@@ -0,0 +1,367 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
+import com.google.common.base.Joiner;
+import com.google.common.base.Optional;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ImmutableSetMultimap;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Queues;
+import com.google.common.collect.Sets;
+import dagger.Component;
+import dagger.Module;
+import dagger.Provides;
+import dagger.internal.codegen.ValidationReport.Builder;
+import java.util.Deque;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Queue;
+import java.util.Set;
+import javax.inject.Provider;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.ElementFilter;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+
+import static com.google.auto.common.MoreElements.getAnnotationMirror;
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
+import static javax.lang.model.type.TypeKind.VOID;
+import static javax.lang.model.util.ElementFilter.methodsIn;
+
+/**
+ * Performs validation of object graphs rooted in the provision and injection methods of
+ * a {link @Component} interface.
+ *
+ * @author Christian Gruber
+ */
+public class GraphValidator implements Validator<TypeElement> {
+  private final Elements elements;
+  private final Types types;
+  private final DependencyRequest.Factory dependencyRequestFactory;
+  private final ProvisionBinding.Factory provisionBindingFactory;
+  private final InjectBindingRegistry bindingRegistry;
+
+  GraphValidator(
+      Elements elements,
+      Types types,
+      DependencyRequest.Factory dependencyRequestFactory,
+      ProvisionBinding.Factory provisionBindingFactory,
+      InjectBindingRegistry bindingRegistry) {
+    this.elements = elements;
+    this.types = types;
+    this.provisionBindingFactory = provisionBindingFactory;
+    this.dependencyRequestFactory = dependencyRequestFactory;
+    this.bindingRegistry = bindingRegistry;
+  }
+
+  @Override
+  public ValidationReport<TypeElement> validate(TypeElement subject) {
+    ValidationReport.Builder<TypeElement> reportBuilder = ValidationReport.Builder.about(subject);
+    validateGraph(subject, reportBuilder);
+    return reportBuilder.build();
+  }
+
+  private ImmutableSet<TypeElement> getTransitiveModules(ImmutableSet<TypeElement> seedModules) {
+    // TODO(user): Detect and report module cycles.
+    Queue<TypeElement> moduleQueue = Queues.newArrayDeque(seedModules);
+    LinkedHashSet<TypeElement> moduleElements = Sets.newLinkedHashSet();
+    for (TypeElement moduleElement = moduleQueue.poll();
+        moduleElement != null;
+        moduleElement = moduleQueue.poll()) {
+      moduleElements.add(moduleElement);
+      Optional<AnnotationMirror> moduleMirror = getAnnotationMirror(moduleElement, Module.class);
+      if (moduleMirror.isPresent()) {
+        ImmutableSet<TypeElement> moduleDependencies = MoreTypes.asTypeElements(types,
+            ConfigurationAnnotations.getModuleIncludes(elements, moduleMirror.get()));
+        for (TypeElement dependencyType : moduleDependencies) {
+          if (!moduleElements.contains(dependencyType)) {
+            moduleQueue.add(dependencyType);
+          }
+        }
+      }
+    }
+    return ImmutableSet.copyOf(moduleElements);
+  }
+
+  void validateGraph(TypeElement component,
+      ValidationReport.Builder<TypeElement> reportBuilder) {
+    AnnotationMirror componentMirror =
+        getAnnotationMirror(component, Component.class).get();
+    ImmutableSet.Builder<ProvisionBinding> explicitBindingsBuilder = ImmutableSet.builder();
+    ProvisionBinding componentBinding = provisionBindingFactory.forComponent(component);
+    explicitBindingsBuilder.add(componentBinding);
+
+    // Collect Component dependencies.
+    ImmutableSet<TypeElement> componentDependencyTypes = MoreTypes.asTypeElements(types,
+        ConfigurationAnnotations.getComponentDependencies(elements, componentMirror));
+    for (TypeElement componentDependency : componentDependencyTypes) {
+      explicitBindingsBuilder.add(provisionBindingFactory.forComponent(componentDependency));
+      List<ExecutableElement> dependencyMethods =
+          ElementFilter.methodsIn(elements.getAllMembers(componentDependency));
+      for (ExecutableElement method : dependencyMethods) {
+        if (isComponentProvisionMethod(method)) {
+          // MembersInjection methods aren't "provided" explicitly, so ignore them.
+          try {
+            explicitBindingsBuilder.add(provisionBindingFactory.forComponentMethod(method));
+          } catch (IllegalArgumentException e) {
+            // Should not ever get here due to previous component validation.
+            reportBuilder.addItem("Component provision methods cannot have parameters.", method);
+          }
+        }
+      }
+    }
+
+    // Collect transitive modules provisions.
+    ImmutableSet<TypeElement> moduleTypes =
+        MoreTypes.asTypeElements(types, getComponentModules(elements, componentMirror));
+    for (TypeElement module : getTransitiveModules(moduleTypes)) {
+      // traverse the modules, collect the bindings
+      List<ExecutableElement> moduleMethods = methodsIn(elements.getAllMembers(module));
+      for (ExecutableElement moduleMethod : moduleMethods) {
+        if (isAnnotationPresent(moduleMethod, Provides.class)) {
+          try {
+            explicitBindingsBuilder.add(provisionBindingFactory.forProvidesMethod(moduleMethod));
+          } catch (IllegalArgumentException e) {
+            // Should not ever get here due to previous module validation.
+            reportBuilder.addItem(
+                String.format(ErrorMessages.MALFORMED_MODULE_METHOD_FORMAT,
+                    moduleMethod.getSimpleName(),
+                    MoreElements.asType(moduleMethod.getEnclosingElement()).getQualifiedName()),
+                component);
+          }
+        }
+      }
+    }
+
+    for (DependencyRequest componentMethodRequest : componentMethodRequests(component)) {
+      Deque<FrameworkKey> cycleStack = Queues.newArrayDeque();
+      Deque<DependencyRequest> dependencyPath = Queues.newArrayDeque();
+      resolveRequest(
+          componentMethodRequest,
+          componentMethodRequest,
+          reportBuilder,
+          explicitBindingsByKey(explicitBindingsBuilder.build()),
+          new LinkedHashSet<FrameworkKey>(),
+          cycleStack,
+          dependencyPath);
+    }
+  }
+
+  private ImmutableSetMultimap<Key, ProvisionBinding> explicitBindingsByKey(
+      Iterable<ProvisionBinding> bindings) {
+    // Multimaps.index() doesn't do ImmutableSetMultimaps.
+    ImmutableSetMultimap.Builder<Key, ProvisionBinding> builder = ImmutableSetMultimap.builder();
+    for (ProvisionBinding binding : bindings) {
+      builder.put(binding.providedKey(), binding);
+    }
+    return builder.build();
+  }
+
+  private ImmutableList<DependencyRequest> componentMethodRequests(TypeElement componentType) {
+    ImmutableList.Builder<DependencyRequest> interfaceRequestsBuilder = ImmutableList.builder();
+    for (ExecutableElement componentMethod : methodsIn(elements.getAllMembers(componentType))) {
+      if (componentMethod.getModifiers().contains(Modifier.ABSTRACT)) { // Elide Object.*;
+        if (isComponentProvisionMethod(componentMethod)) {
+          interfaceRequestsBuilder.add(
+              dependencyRequestFactory.forComponentProvisionMethod(componentMethod));
+        } else if (isComponentMembersInjectionMethod(componentMethod)) {
+          interfaceRequestsBuilder.add(
+              dependencyRequestFactory.forComponentMembersInjectionMethod(componentMethod));
+        }
+      }
+    }
+    return interfaceRequestsBuilder.build();
+  }
+
+  private void resolveRequest(DependencyRequest request,
+      DependencyRequest rootRequest,
+      ValidationReport.Builder<TypeElement> reportBuilder,
+      ImmutableSetMultimap<Key, ProvisionBinding> explicitBindings,
+      Set<FrameworkKey> resolvedBindings,
+      Deque<FrameworkKey> cycleStack,
+      Deque<DependencyRequest> dependencyPath) {
+
+    FrameworkKey frameworkKey = FrameworkKey.forDependencyRequest(request);
+    if (cycleStack.contains(frameworkKey) && !isComponent(frameworkKey.key().type())) {
+      resolvedBindings.add(frameworkKey); // it's present, but bad, and we report that.
+      dependencyPath = Queues.newArrayDeque(dependencyPath); // copy
+      dependencyPath.push(request); // add current request.
+      dependencyPath.pollLast(); // strip off original request from the component method.
+      ImmutableList<String> printableDependencyPath = FluentIterable.from(dependencyPath)
+          .transform(DependencyRequestFormatter.instance()).toList().reverse();
+      TypeElement componentType =
+          MoreElements.asType(rootRequest.requestElement().getEnclosingElement());
+      // TODO(user): Restructure to provide a hint for the start and end of the cycle.
+      reportBuilder.addItem(
+          String.format(ErrorMessages.CONTAINS_DEPENDENCY_CYCLE_FORMAT,
+              componentType.getQualifiedName(),
+              rootRequest.requestElement().getSimpleName(),
+              Joiner.on("\n").join(printableDependencyPath)),
+          rootRequest.requestElement());
+
+      return;
+    }
+    if (resolvedBindings.contains(frameworkKey)) {
+      return;
+    }
+
+    dependencyPath.push(request);
+    cycleStack.push(frameworkKey);
+    try {
+      Key requestKey = request.key();
+      switch (request.kind()) {
+        case INSTANCE:
+        case LAZY:
+        case PROVIDER:
+          // First, check for explicit keys (those from modules and components)
+          ImmutableSet<ProvisionBinding> explicitBindingsForKey = explicitBindings.get(requestKey);
+          if (explicitBindingsForKey.isEmpty()) {
+            // If the key is Map<K, V>, get its implicit binding key which is Map<K, Provider<V>>
+            Optional<Key> key = findMapKey(request);
+            if (key.isPresent()) {
+              DependencyRequest implicitRequest =
+                  dependencyRequestFactory.forImplicitMapBinding(request, key.get());
+              ProvisionBinding implicitBinding =
+                  provisionBindingFactory.forImplicitMapBinding(request, implicitRequest);
+              resolveRequest(Iterables.getOnlyElement(implicitBinding.dependencies()),
+                  rootRequest, reportBuilder, explicitBindings, resolvedBindings, cycleStack,
+                  dependencyPath);
+              resolvedBindings.add(frameworkKey);
+            } else {
+              // no explicit binding, look it up or fail.
+              Optional<ProvisionBinding> provisionBinding =
+                  findProvidableType(requestKey, reportBuilder, rootRequest, dependencyPath);
+              if (provisionBinding.isPresent()) {
+                // found a binding, resolve its deps and then mark it resolved
+                for (DependencyRequest dependency : provisionBinding.get().dependencies()) {
+                  resolveRequest(dependency, rootRequest, reportBuilder, explicitBindings,
+                      resolvedBindings, cycleStack, dependencyPath);
+                }
+                if (provisionBinding.get().memberInjectionRequest().isPresent()) {
+                  resolveRequest(provisionBinding.get().memberInjectionRequest().get(),
+                      rootRequest, reportBuilder, explicitBindings, resolvedBindings, cycleStack,
+                      dependencyPath);
+                }
+                resolvedBindings.add(frameworkKey);
+              }
+            }
+          } else {
+            // we found explicit bindings. resolve the deps and them mark them resolved
+            for (ProvisionBinding explicitBinding : explicitBindingsForKey) {
+              for (DependencyRequest dependency : explicitBinding.dependencies()) {
+                resolveRequest(dependency, rootRequest, reportBuilder, explicitBindings,
+                    resolvedBindings, cycleStack, dependencyPath);
+              }
+            }
+            resolvedBindings.add(frameworkKey);
+          }
+          break;
+        case MEMBERS_INJECTOR:
+          // no explicit deps for members injection, so just look it up
+          Optional<MembersInjectionBinding> membersInjectionBinding =
+              Optional.fromNullable(bindingRegistry.getOrFindMembersInjectionBinding(requestKey));
+          if (membersInjectionBinding.isPresent()) {
+            // found a binding, resolve its deps and then mark it resolved
+            for (DependencyRequest dependency : membersInjectionBinding.get().dependencies()) {
+              resolveRequest(dependency, rootRequest, reportBuilder, explicitBindings,
+                  resolvedBindings, cycleStack, dependencyPath);
+            }
+            resolvedBindings.add(frameworkKey);
+          }
+          break;
+        default:
+          throw new AssertionError();
+      }
+    } finally {
+      dependencyPath.pop();
+      cycleStack.pop();
+    }
+  }
+
+  // TODO(user): Unify this with ComponentDescriptor.findMapKey() and put it somewhere in common.
+  private Optional<Key> findMapKey(final DependencyRequest request) {
+    if (Util.isTypeOf(Map.class, request.key().type(), elements, types)) {
+      DeclaredType declaredMapType = Util.getDeclaredTypeOfMap(request.key().type());
+      TypeMirror mapValueType = Util.getValueTypeOfMap(declaredMapType);
+      if (!Util.isTypeOf(Provider.class, mapValueType, elements, types)) {
+        TypeMirror keyType =
+            Util.getKeyTypeOfMap((DeclaredType) (request.key().wrappedType().get()));
+        TypeMirror valueType = types.getDeclaredType(
+            elements.getTypeElement(Provider.class.getCanonicalName()), mapValueType);
+        TypeMirror mapType = types.getDeclaredType(
+            elements.getTypeElement(Map.class.getCanonicalName()), keyType, valueType);
+        return Optional.of((Key) new AutoValue_Key(request.key().wrappedQualifier(),
+            MoreTypes.equivalence().wrap(mapType)));
+      }
+    }
+    return Optional.absent();
+  }
+
+  // TODO(user) determine what bits of InjectBindingRegistry's findOrCreate logic to factor out.
+  private Optional<ProvisionBinding> findProvidableType(Key key, Builder<TypeElement> reportBuilder,
+      DependencyRequest rootRequest, Deque<DependencyRequest> dependencyPath) {
+    Optional<ProvisionBinding> binding = bindingRegistry.getOrFindProvisionBinding(key);
+    if (!binding.isPresent()) {
+      TypeElement type = (TypeElement) types.asElement(key.type());
+      StringBuilder errorMessage = new StringBuilder(
+          String.format(ErrorMessages.REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_FORMAT,
+              type.getQualifiedName()));
+      if (!bindingRegistry.getOrFindMembersInjectionBinding(key).injectionSites().isEmpty()) {
+        errorMessage.append(" ").append(ErrorMessages.MEMBERS_INJECTION_DOES_NOT_IMPLY_PROVISION);
+      }
+      dependencyPath = Queues.newArrayDeque(dependencyPath); // copy
+      dependencyPath.pollLast();
+      ImmutableList<String> printableDependencyPath = FluentIterable.from(dependencyPath)
+          .transform(DependencyRequestFormatter.instance()).toList().reverse();
+      for(String dependency : printableDependencyPath) {
+        errorMessage.append("\n").append(dependency);
+      }
+      reportBuilder.addItem(errorMessage.toString(), rootRequest.requestElement());
+    }
+    return binding;
+  }
+
+  private boolean isComponent(TypeMirror type) {
+    // No need to fully validate. Components themselves will be validated by the ComponentValidator
+    return MoreElements.isAnnotationPresent(types.asElement(type), Component.class);
+  }
+
+  private static boolean isComponentProvisionMethod(ExecutableElement method) {
+    return method.getParameters().isEmpty()
+        && !method.getReturnType().getKind().equals(VOID);
+  }
+
+  private static boolean isComponentMembersInjectionMethod(ExecutableElement method) {
+    List<? extends VariableElement> parameters = method.getParameters();
+    TypeMirror returnType = method.getReturnType();
+    return parameters.size() == 1
+        && (returnType.getKind().equals(VOID)
+            || MoreTypes.equivalence().equivalent(returnType, parameters.get(0).asType()));
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
index 6f02fc350..a03e309c9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
@@ -20,10 +20,13 @@
 import com.google.common.base.Predicate;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
 import com.google.common.collect.Maps;
+import com.google.common.collect.Sets;
 import dagger.internal.codegen.writer.ClassName;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 import javax.annotation.processing.Messager;
 import javax.inject.Inject;
 import javax.lang.model.element.ExecutableElement;
@@ -55,6 +58,7 @@
   private final Key.Factory keyFactory;
   private final Map<Key, ProvisionBinding> provisionBindingsByKey;
   private final Map<Key, MembersInjectionBinding> membersInjectionBindingsByKey;
+  private final Set<ClassName> generatedTypeNames;
 
   InjectBindingRegistry(Elements elements,
       Types types,
@@ -73,9 +77,16 @@
     this.membersInjectorGenerator = membersInjectorGenerator;
     this.provisionBindingsByKey = Maps.newLinkedHashMap();
     this.membersInjectionBindingsByKey = Maps.newLinkedHashMap();
+    this.generatedTypeNames = Sets.newLinkedHashSet();
     this.keyFactory = keyFactory;
   }
 
+  // TODO(gak): rework how we handle knowing what we've generated and not.
+  void registerGeneratedFile(ClassName generatedTypeName) {
+    checkState(generatedTypeNames.add(generatedTypeName),
+        "couldn't register %s as it was already registered.", generatedTypeName);
+  }
+
   void registerProvisionBinding(ProvisionBinding binding) {
     ProvisionBinding previousValue = provisionBindingsByKey.put(binding.providedKey(), binding);
     checkState(previousValue == null, "couldn't register %s. %s was already registered", binding,
@@ -89,13 +100,29 @@ void registerMembersInjectionBinding(MembersInjectionBinding binding) {
         previousValue);
   }
 
-  Optional<ProvisionBinding> getOrFindOrCreateProvisionBindingForKey(Key key)
+  Optional<ProvisionBinding> getOrFindOrCreateProvisionBinding(Key key)
       throws SourceFileGenerationException {
+    Optional<ProvisionBinding> binding = getOrFindProvisionBinding(key);
+    if (binding.isPresent()) {
+      ClassName factoryName = SourceFiles.factoryNameForProvisionBinding(binding.get());
+      if (!generatedTypeNames.contains(factoryName)
+          && elements.getTypeElement(factoryName.canonicalName()) == null) {
+        // does not exist.  generate
+        factoryGenerator.generate(binding.get());
+        generatedTypeNames.add(factoryName);
+        messager.printMessage(Kind.NOTE, String.format("Generating a Factory for %s. "
+            + "Prefer to run the dagger processor over that class instead.", key.type()));
+      }
+    }
+    return binding;
+  }
+
+  Optional<ProvisionBinding> getOrFindProvisionBinding(Key key) {
     checkNotNull(key);
     checkArgument(!key.qualifier().isPresent());
-    ProvisionBinding bindingFromThisProcessor = provisionBindingsByKey.get(key);
-    if (bindingFromThisProcessor != null) {
-      return Optional.of(bindingFromThisProcessor);
+    Optional<ProvisionBinding> binding = Optional.fromNullable(provisionBindingsByKey.get(key));
+    if (binding.isPresent()) {
+      return binding;
     }
     // ok, let's see if we can find an @Inject constructor
     TypeElement element = MoreElements.asType(types.asElement(key.type()));
@@ -109,18 +136,12 @@ void registerMembersInjectionBinding(MembersInjectionBinding binding) {
         }).toSet();
     switch (injectConstructors.size()) {
       case 0:
+        // No constructor found.
         return Optional.absent();
       case 1:
         ProvisionBinding constructorBinding = provisionBindingFactory.forInjectConstructor(
-            injectConstructors.iterator().next());
+            Iterables.getOnlyElement(injectConstructors));
         registerProvisionBinding(constructorBinding);
-        ClassName factoryName = SourceFiles.factoryNameForProvisionBinding(constructorBinding);
-        if (elements.getTypeElement(factoryName.canonicalName()) == null) {
-          // does not exist.  generate
-          factoryGenerator.generate(constructorBinding);
-          messager.printMessage(Kind.NOTE, String.format("Generating a Factory for %s. "
-              + "Prefer to run the dagger processor over that class instead.", key.type()));
-        }
         return Optional.of(constructorBinding);
       default:
         throw new IllegalStateException("Found multiple @Inject constructors: "
@@ -128,27 +149,33 @@ void registerMembersInjectionBinding(MembersInjectionBinding binding) {
     }
   }
 
-    MembersInjectionBinding getOrFindOrCreateMembersInjectionBindingForKey(Key key)
+  MembersInjectionBinding getOrFindOrCreateMembersInjectionBinding(Key key)
       throws SourceFileGenerationException {
-    checkNotNull(key);
-    checkArgument(!key.qualifier().isPresent());
-    MembersInjectionBinding bindingFromThisProcessor = membersInjectionBindingsByKey.get(key);
-    if (bindingFromThisProcessor != null) {
-      return bindingFromThisProcessor;
-    }
-    TypeElement element = MoreElements.asType(types.asElement(key.type()));
-    MembersInjectionBinding binding = membersInjectionBindingFactory.forInjectedType(element);
+    MembersInjectionBinding binding = getOrFindMembersInjectionBinding(key);
     if (!binding.injectionSites().isEmpty()) {
       ClassName membersInjectorName =
           SourceFiles.membersInjectorNameForMembersInjectionBinding(binding);
-      if (elements.getTypeElement(membersInjectorName.canonicalName()) == null) {
+      if (!generatedTypeNames.contains(membersInjectorName)
+          && elements.getTypeElement(membersInjectorName.canonicalName()) == null) {
         // does not exist.  generate
         membersInjectorGenerator.generate(binding);
         messager.printMessage(Kind.NOTE, String.format("Generating a MembersInjector for %s. "
             + "Prefer to run the dagger processor over that class instead.", key.type()));
         registerMembersInjectionBinding(binding);
+        generatedTypeNames.add(membersInjectorName);
       }
     }
     return binding;
   }
+
+  MembersInjectionBinding getOrFindMembersInjectionBinding(Key key) {
+    checkNotNull(key);
+    checkArgument(!key.qualifier().isPresent());
+    MembersInjectionBinding binding = membersInjectionBindingsByKey.get(key);
+    if (binding == null) {
+      TypeElement element = MoreElements.asType(types.asElement(key.type()));
+      binding = membersInjectionBindingFactory.forInjectedType(element);
+    }
+    return binding;
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java
index 92183c5ca..06e15bf16 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java
@@ -43,7 +43,7 @@
   private final ProvisionBinding.Factory provisionBindingFactory;
   private final FactoryGenerator factoryGenerator;
   private final MembersInjectionBinding.Factory membersInjectionBindingFactory;
-  private final MembersInjectorGenerator membersInjectorWriter;
+  private final MembersInjectorGenerator membersInjectorGenerator;
   private final InjectBindingRegistry injectBindingRegistry;
 
   InjectProcessingStep(Messager messager,
@@ -62,7 +62,7 @@
     this.provisionBindingFactory = provisionBindingFactory;
     this.factoryGenerator = factoryGenerator;
     this.membersInjectionBindingFactory = membersInjectionBindingFactory;
-    this.membersInjectorWriter = membersInjectorWriter;
+    this.membersInjectorGenerator = membersInjectorWriter;
     this.injectBindingRegistry = factoryRegistrar;
   }
 
@@ -127,8 +127,10 @@ public Void visitExecutableAsMethod(ExecutableElement methodElement, Void p) {
       try {
         MembersInjectionBinding binding =
             membersInjectionBindingFactory.forInjectedType(injectedType);
-        membersInjectorWriter.generate(binding);
+        membersInjectorGenerator.generate(binding);
         injectBindingRegistry.registerMembersInjectionBinding(binding);
+        injectBindingRegistry.registerGeneratedFile(
+            membersInjectorGenerator.nameGeneratedType(binding));
       } catch (SourceFileGenerationException e) {
         e.printMessageTo(messager);
       }
@@ -138,6 +140,7 @@ public Void visitExecutableAsMethod(ExecutableElement methodElement, Void p) {
       try {
         factoryGenerator.generate(binding);
         injectBindingRegistry.registerProvisionBinding(binding);
+        injectBindingRegistry.registerGeneratedFile(factoryGenerator.nameGeneratedType(binding));
       } catch (SourceFileGenerationException e) {
         e.printMessageTo(messager);
       }
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/Writables.java b/compiler/src/main/java/dagger/internal/codegen/writer/Writables.java
index 612e7ebf4..be43fbefb 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/Writables.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/Writables.java
@@ -31,7 +31,7 @@ static String writeToString(Writable writable) {
     try {
       writable.write(builder, DEFAULT_CONTEXT);
     } catch (IOException e) {
-      throw new AssertionError("StringBuilder doesn't throw IOException", e);
+      throw new AssertionError("StringBuilder doesn't throw IOException" + e);
     }
     return builder.toString();
   }
diff --git a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
new file mode 100644
index 000000000..ad2e70f38
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
@@ -0,0 +1,196 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.testing.compile.JavaFileObjects;
+import java.util.Arrays;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assert_;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+
+@RunWith(JUnit4.class)
+public class GraphValidationTest {
+  @Test public void componentOnConcreteClass() {
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.MyComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "interface MyComponent {",
+        "  Foo getFoo();",
+        "}");
+    JavaFileObject injectable = JavaFileObjects.forSourceLines("test.Foo",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class Foo {",
+        "  @Inject Foo(Bar bar) {}",
+        "}");
+    JavaFileObject nonInjectable = JavaFileObjects.forSourceLines("test.Bar",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "interface Bar {}");
+    assert_().about(javaSources()).that(Arrays.asList(component, injectable, nonInjectable))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("test.Bar cannot be provided without an @Inject constructor")
+            .in(component).onLine(7);
+  }
+
+  @Test public void membersInjectWithoutProvision() {
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestClass",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "",
+        "final class TestClass {",
+        "  static class A {",
+        "    @Inject A() {}",
+        "  }",
+        "",
+        "  static class B {",
+        "    @Inject A a;",
+        "  }",
+        "",
+        "  @Component()",
+        "  interface AComponent {",
+        "    B getB();",
+        "  }",
+        "}");
+    String expectedError = "test.TestClass.B cannot be provided without an "
+        + "@Inject constructor or from an @Provides-annotated method. "
+        + "This type supports members injection but cannot be implicitly provided.";
+    assert_().about(javaSource()).that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedError).in(component).onLine(19);
+  }
+
+  @Test public void cyclicDependency() {
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "",
+        "final class Outer {",
+        "  static class A {",
+        "    @Inject A(C cParam) {}",
+        "  }",
+        "",
+        "  static class B {",
+        "    @Inject B(A aParam) {}",
+        "  }",
+        "",
+        "  static class C {",
+        "    @Inject C(B bParam) {}",
+        "  }",
+        "",
+        "  @Component()",
+        "  interface CComponent {",
+        "    C getC();",
+        "  }",
+        "}");
+
+    String expectedError = "test.Outer.CComponent.getC() contains a dependency cycle:\n"
+        + "      test.Outer.C.<init>(test.Outer.B bParam)\n"
+        + "          [parameter: test.Outer.B bParam]\n"
+        + "      test.Outer.B.<init>(test.Outer.A aParam)\n"
+        + "          [parameter: test.Outer.A aParam]\n"
+        + "      test.Outer.A.<init>(test.Outer.C cParam)\n"
+        + "          [parameter: test.Outer.C cParam]";
+
+    assert_().about(javaSource()).that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedError).in(component).onLine(23);
+  }
+
+  @Test public void longChainOfDependencies() {
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestClass",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "",
+        "final class TestClass {",
+        "  interface A {}",
+        "",
+        "  static class B {",
+        "    @Inject B(A a) {}",
+        "  }",
+        "",
+        "  static class C {",
+        "    @Inject B b;",
+        "    @Inject C(B b) {}",
+        "  }",
+        "",
+        "  interface D { }",
+        "",
+        "  static class DImpl implements D {",
+        "    @Inject DImpl(C c, B b) {}",
+        "  }",
+        "",
+        "  @Module",
+        "  static class DModule {",
+        "    @Provides D d(DImpl impl) { return impl; }",
+        "  }",
+        "",
+        "  @Component(modules = { DModule.class })",
+        "  interface AComponent {",
+        "    D getFoo();",
+        "    C injectC(C c);",
+        "  }",
+        "}");
+    String errorText = "test.TestClass.A cannot be provided without "
+        + "an @Inject constructor or from an @Provides-annotated method.\n";
+    String firstError = errorText
+        + "      test.TestClass.DModule.d(test.TestClass.DImpl impl)\n"
+        + "          [parameter: test.TestClass.DImpl impl]\n"
+        + "      test.TestClass.DImpl.<init>(test.TestClass.C c, test.TestClass.B b)\n"
+        + "          [parameter: test.TestClass.C c]\n"
+        + "      test.TestClass.C.<init>(test.TestClass.B b)\n"
+        + "          [parameter: test.TestClass.B b]\n"
+        + "      test.TestClass.B.<init>(test.TestClass.A a)\n"
+        + "          [parameter: test.TestClass.A a]";
+    String secondError = errorText
+        + "      test.TestClass.C.b()\n"
+        + "          [injected field of type: test.TestClass.B b]\n"
+        + "      test.TestClass.B.<init>(test.TestClass.A a)\n"
+        + "          [parameter: test.TestClass.A a]";
+    assert_().about(javaSource()).that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(firstError).in(component).onLine(33)
+        .and().withErrorContaining(secondError).in(component).onLine(34);
+  }
+}
\ No newline at end of file
