diff --git a/compiler/src/it/functional-tests/src/main/java/test/ParentModule.java b/compiler/src/it/functional-tests/src/main/java/test/ParentModule.java
index f550f2f21..4d0f56266 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/ParentModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/ParentModule.java
@@ -25,5 +25,4 @@
   static List<Set<String>> provideStaticGenericTypeWithNoTypeParametersInParameterizedModule() {
     return new ArrayList<>();
   }
-
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/cycle/Cycles.java b/compiler/src/it/functional-tests/src/main/java/test/cycle/Cycles.java
index db4b6b5e2..b78c4e76a 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/cycle/Cycles.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/cycle/Cycles.java
@@ -30,13 +30,15 @@
 
 /**
  * Cycle classes used for testing cyclic dependencies.
- * A <- (E <- D <- B <- C <- Provider<A>, Lazy<A>), (B <- C <- Provider<A>, Lazy<A>)
- * S <- Provider<S>, Lazy<S>
+ *
+ * <pre>
+ * {@literal A ← (E ← D ← B ← C ← Provider<A>, Lazy<A>), (B ← C ← Provider<A>, Lazy<A>)}
+ * {@literal S ← Provider<S>, Lazy<S>}
+ * </pre>
  *
  * @author Tony Bentancur
  * @since 2.0
  */
-
 final class Cycles {
   private Cycles() {}
 
diff --git a/compiler/src/it/functional-tests/src/test/java/test/GenericTest.java b/compiler/src/it/functional-tests/src/test/java/test/GenericTest.java
index f62a1a80d..0bb10b20b 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/GenericTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/GenericTest.java
@@ -144,6 +144,5 @@
     GenericComponent component = DaggerGenericComponent.create();
     assertThat(component.iterableInt()).containsExactly(1, 2).inOrder();
     assertThat(component.iterableDouble()).containsExactly(3d, 4d).inOrder();
-    
   }
 }
diff --git a/compiler/src/it/guava-functional-tests/src/main/java/test/optional/OptionalBindingComponents.java b/compiler/src/it/guava-functional-tests/src/main/java/test/optional/OptionalBindingComponents.java
index d130a5e6e..33d6918b9 100644
--- a/compiler/src/it/guava-functional-tests/src/main/java/test/optional/OptionalBindingComponents.java
+++ b/compiler/src/it/guava-functional-tests/src/main/java/test/optional/OptionalBindingComponents.java
@@ -31,11 +31,7 @@
 import javax.inject.Provider;
 import javax.inject.Qualifier;
 
-/**
- * Classes to support {@link OptionalBindingComponentsPresentTest}, {@link
- * OptionalBindingComponentsAbsentTest} and {@link
- * test.optional.a.OptionalBindingComponentsWithInaccessibleTypesTest}.
- */
+/** Classes to support testing {@code BindsOptionalOf} functionality. */
 public final class OptionalBindingComponents {
 
   /** A qualifier. */
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/binds/FooOfStrings.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/binds/FooOfStrings.java
index a0c89cd0f..1c0377b23 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/binds/FooOfStrings.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/binds/FooOfStrings.java
@@ -17,12 +17,11 @@
 package producerstest.binds;
 
 /**
- * This is not marked with {@link javax.inject.Inject @Inject} (like the {@link dagger.Provides
- * @Provides} version in {@link test.bind.FooOfStrings}), to test that {@link dagger.Binds @Binds}
- * properly translate to {@link dagger.internal.codegen.ProductionBinding}s when the right-hand-side
- * of the method is also a production binding. We force this by adding a {@link
- * dagger.producers.Produces @Produces} method to add it to the graph instead of relying on the
- * {@link dagger.internal.codegen.ProvisionBinding} that would be created by default with an {@code
- * @Inject} constructor.
+ * This is not marked with {@link javax.inject.Inject @Inject} in order to test that {@link
+ * dagger.Binds @Binds} properly translate to {@link dagger.internal.codegen.ProductionBinding}s
+ * when the right-hand-side of the method is also a production binding. We force this by adding a
+ * {@link dagger.producers.Produces @Produces} method to add it to the graph instead of relying on
+ * the {@link dagger.internal.codegen.ProvisionBinding} that would be created by default with an
+ * {@code @Inject} constructor.
  */
 final class FooOfStrings implements Foo<String> {}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/optional/OptionalBindingComponents.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/optional/OptionalBindingComponents.java
index 60d31bb20..743b033e1 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/optional/OptionalBindingComponents.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/optional/OptionalBindingComponents.java
@@ -34,12 +34,10 @@
 import java.lang.annotation.Retention;
 import java.util.concurrent.Executor;
 import java.util.concurrent.Executors;
+import javax.inject.Provider;
 import javax.inject.Qualifier;
 
-/**
- * Classes to support {@link OptionalBindingComponentsAbsentTest} and {@link
- * OptionalBindingComponentsPresentTest}.
- */
+/** Classes to support testing {@code BindsOptionalOf} functionality. */
 final class OptionalBindingComponents {
 
   /** A qualifier. */
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 869d3be59..2bdea0086 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -27,10 +27,11 @@
 import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.DELEGATED;
 import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.INITIALIZED;
 import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.UNINITIALIZED;
-import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_UNCHECKED;
+import static dagger.internal.codegen.AnnotationSpecs.Suppression.RAWTYPES;
+import static dagger.internal.codegen.AnnotationSpecs.Suppression.UNCHECKED;
 import static dagger.internal.codegen.BindingKey.contribution;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
-import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.ENUM_INSTANCE;
+import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.SINGLETON_INSTANCE;
 import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD;
 import static dagger.internal.codegen.MapKeys.getMapKeyExpression;
 import static dagger.internal.codegen.MemberSelect.emptyFrameworkMapFactory;
@@ -40,6 +41,7 @@
 import static dagger.internal.codegen.MemberSelect.staticMethod;
 import static dagger.internal.codegen.MembersInjectionBinding.Strategy.NO_OP;
 import static dagger.internal.codegen.Scope.reusableScope;
+import static dagger.internal.codegen.SourceFiles.bindingTypeElementTypeVariableNames;
 import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
 import static dagger.internal.codegen.SourceFiles.membersInjectorNameForType;
 import static dagger.internal.codegen.TypeNames.DELEGATE_FACTORY;
@@ -198,12 +200,8 @@ protected AbstractComponentWriter(
         parent.optionalFactories);
   }
 
-  protected final TypeElement componentDefinitionType() {
-    return graph.componentDescriptor().componentDefinitionType();
-  }
-
   protected final ClassName componentDefinitionTypeName() {
-    return ClassName.get(componentDefinitionType());
+    return ClassName.get(graph.componentType());
   }
 
   /**
@@ -374,7 +372,7 @@ private void addBuildMethod(
       if (componentCanMakeNewInstances(builderFieldEntry.getKey())) {
         buildMethod.addCode(
             "if ($1N == null) { this.$1N = new $2T(); }", builderField, builderField.type);
-      } else if (requiresAPassedInstance(elements, builderFieldEntry.getKey())) {
+      } else if (requiresAPassedInstance(elements, types, builderFieldEntry.getKey())) {
         buildMethod.addCode(
             "if ($N == null) { throw new $T($T.class.getCanonicalName() + $S); }",
             builderField,
@@ -537,7 +535,7 @@ private FieldSpec addFrameworkField(
             contributionBindingField.name());
     contributionField.addModifiers(PRIVATE);
     if (useRawType) {
-      contributionField.addAnnotation(AnnotationSpecs.SUPPRESS_WARNINGS_RAWTYPES);
+      contributionField.addAnnotation(AnnotationSpecs.suppressWarnings(RAWTYPES));
     }
 
     FieldSpec field = contributionField.build();
@@ -568,7 +566,7 @@ private boolean useRawType(Optional<String> bindingPackage) {
     switch (bindingKey.kind()) {
       case CONTRIBUTION:
         ContributionBinding contributionBinding = resolvedBindings.contributionBinding();
-        if (contributionBinding.factoryCreationStrategy().equals(ENUM_INSTANCE)
+        if (contributionBinding.factoryCreationStrategy().equals(SINGLETON_INSTANCE)
             && !contributionBinding.scope().isPresent()) {
           switch (contributionBinding.bindingKind()) {
             case SYNTHETIC_MULTIBOUND_MAP:
@@ -589,7 +587,7 @@ private boolean useRawType(Optional<String> bindingPackage) {
             case PROVISION:
               if (bindingKey.key().type().getKind().equals(DECLARED)) {
                 ImmutableList<TypeVariableName> typeVariables =
-                    SourceFiles.bindingTypeElementTypeVariableNames(contributionBinding);
+                    bindingTypeElementTypeVariableNames(contributionBinding);
                 if (!typeVariables.isEmpty()) {
                   List<? extends TypeMirror> typeArguments =
                       ((DeclaredType) bindingKey.key().type()).getTypeArguments();
@@ -696,7 +694,7 @@ private void implementInterfaceMethods() {
         ExecutableType requestType =
             MoreTypes.asExecutable(
                 types.asMemberOf(
-                    MoreTypes.asDeclared(componentDefinitionType().asType()), methodElement));
+                    MoreTypes.asDeclared(graph.componentType().asType()), methodElement));
         MethodSignature signature =
             MethodSignature.fromExecutableType(
                 methodElement.getSimpleName().toString(), requestType);
@@ -795,7 +793,7 @@ private void initializeFrameworkTypes() {
                * initializing a raw field in this method, but the structure of this code makes it
                * awkward to pass that bit through.  This will be cleaned up when we no longer
                * separate fields and initilization as we do now. */
-              .addAnnotation(SUPPRESS_WARNINGS_UNCHECKED)
+              .addAnnotation(AnnotationSpecs.suppressWarnings(UNCHECKED))
               .addCode(CodeBlocks.concat(partition));
       if (builderName.isPresent()) {
         initializeMethod.addParameter(builderName.get(), "builder", FINAL);
@@ -856,7 +854,7 @@ private void initializeFrameworkTypes() {
                         binding.scope().isPresent()
                             ? decorateForScope(delegatingCodeBlock, binding.scope().get())
                             : delegatingCodeBlock))));
-      case ENUM_INSTANCE:
+      case SINGLETON_INSTANCE:
         if (!binding.scope().isPresent()) {
           return Optional.absent();
         }
diff --git a/compiler/src/main/java/dagger/internal/codegen/AnnotationSpecs.java b/compiler/src/main/java/dagger/internal/codegen/AnnotationSpecs.java
index 1b8a1f151..06416f953 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AnnotationSpecs.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AnnotationSpecs.java
@@ -16,15 +16,32 @@
 
 package dagger.internal.codegen;
 
+import static com.google.common.base.Preconditions.checkNotNull;
+
+import com.google.common.base.Ascii;
+import com.google.common.base.Preconditions;
+import com.google.common.collect.Lists;
 import com.squareup.javapoet.AnnotationSpec;
+import java.util.Arrays;
 
 final class AnnotationSpecs {
+  enum Suppression {
+    RAWTYPES,
+    UNCHECKED,
+    ;
 
-  static final AnnotationSpec SUPPRESS_WARNINGS_UNCHECKED = suppressWarnings("unchecked");
-  static final AnnotationSpec SUPPRESS_WARNINGS_RAWTYPES = suppressWarnings("rawtypes");
+    @Override
+    public String toString() {
+      return Ascii.toLowerCase(name());
+    }
+  }
 
-  private static AnnotationSpec suppressWarnings(String value) {
-    return AnnotationSpec.builder(SuppressWarnings.class).addMember("value", "$S", value).build();
+  static AnnotationSpec suppressWarnings(Suppression first, Suppression... rest) {
+    checkNotNull(first);
+    Arrays.stream(rest).forEach(Preconditions::checkNotNull);
+    AnnotationSpec.Builder builder = AnnotationSpec.builder(SuppressWarnings.class);
+    Lists.asList(first, rest).forEach(suppression -> builder.addMember("value", "$S", suppression));
+    return builder.build();
   }
 
   private AnnotationSpecs() {}
diff --git a/compiler/src/main/java/dagger/internal/codegen/Binding.java b/compiler/src/main/java/dagger/internal/codegen/Binding.java
index e70b5df8d..303d05f8a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Binding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Binding.java
@@ -22,6 +22,7 @@
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.value.AutoValue;
+import com.google.auto.value.extension.memoized.Memoized;
 import com.google.common.base.Optional;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
@@ -112,10 +113,10 @@
    * binding keys:
    *
    * <dl>
-   * <dt>{@code T}
-   * <dd>{@code String t}
-   * <dt>{@code String}
-   * <dd>{@code String string}
+   *   <dt>{@code T}
+   *   <dd>{@code String t}
+   *   <dt>{@code String}
+   *   <dd>{@code String string}
    * </dl>
    *
    * <p>Note that the sets returned by this method when called on the same binding will be equal,
@@ -124,6 +125,7 @@
   /* TODO(dpb): The stable-order postcondition is actually hard to verify in code for two equal
    * instances of Binding, because it really depends on the order of the binding's dependencies,
    * and two equal instances of Binding may have the same dependencies in a different order. */
+  @Memoized
   ImmutableList<FrameworkDependency> frameworkDependencies() {
     return ImmutableList.copyOf(
         dependencyAssociations()
@@ -158,6 +160,7 @@ static DependencyAssociation create(
    * multiple times if the {@linkplain Binding#unresolved() unresolved} binding requires it. If that
    * distinction is not important, the entries can be merged into a single mapping.
    */
+  @Memoized
   ImmutableList<DependencyAssociation> dependencyAssociations() {
     BindingTypeMapper bindingTypeMapper = BindingTypeMapper.forBindingType(bindingType());
     ImmutableList.Builder<DependencyAssociation> frameworkDependencies = ImmutableList.builder();
@@ -179,6 +182,7 @@ static DependencyAssociation create(
    * Returns the mapping from each {@linkplain #dependencies dependency} to its associated {@link
    * FrameworkDependency}.
    */
+  @Memoized
   ImmutableMap<DependencyRequest, FrameworkDependency> dependenciesToFrameworkDependenciesMap() {
     ImmutableMap.Builder<DependencyRequest, FrameworkDependency> frameworkDependencyMap =
         ImmutableMap.builder();
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingDeclarationFormatter.java b/compiler/src/main/java/dagger/internal/codegen/BindingDeclarationFormatter.java
index d2aece6d3..8eca2f06d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingDeclarationFormatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingDeclarationFormatter.java
@@ -17,26 +17,53 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.collect.Sets.immutableEnumSet;
 import static dagger.internal.codegen.ConfigurationAnnotations.getModuleSubcomponents;
 import static dagger.internal.codegen.ErrorMessages.stripCommonTypePrefixes;
 import static dagger.internal.codegen.MoreAnnotationMirrors.simpleName;
 import static dagger.internal.codegen.Util.AS_DECLARED_TYPE;
+import static javax.lang.model.type.TypeKind.DECLARED;
+import static javax.lang.model.type.TypeKind.EXECUTABLE;
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 import javax.lang.model.element.Element;
+import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 
 /**
  * Formats a {@link BindingDeclaration} into a {@link String} suitable for use in error messages.
  */
 final class BindingDeclarationFormatter extends Formatter<BindingDeclaration> {
+  private static final ImmutableSet<TypeKind> FORMATTABLE_ELEMENT_TYPE_KINDS =
+      immutableEnumSet(EXECUTABLE, DECLARED);
+
   private final MethodSignatureFormatter methodSignatureFormatter;
+  private final KeyFormatter keyFormatter;
 
-  BindingDeclarationFormatter(MethodSignatureFormatter methodSignatureFormatter) {
+  BindingDeclarationFormatter(
+      MethodSignatureFormatter methodSignatureFormatter, KeyFormatter keyFormatter) {
     this.methodSignatureFormatter = methodSignatureFormatter;
+    this.keyFormatter = keyFormatter;
+  }
+
+  /**
+   * Returns {@code true} for declarations that this formatter can format. Specifically:
+   *
+   * <ul>
+   * <li>Those with {@linkplain BindingDeclaration#bindingElement() binding elements} that are
+   *     methods, constructors, or types.
+   * </ul>
+   */
+  boolean canFormat(BindingDeclaration bindingDeclaration) {
+    if (bindingDeclaration.bindingElement().isPresent()) {
+      return FORMATTABLE_ELEMENT_TYPE_KINDS.contains(
+          bindingDeclaration.bindingElement().get().asType().getKind());
+    }
+    return false;
   }
 
   @Override
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index a1305bb9c..10ce2baf1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -33,6 +33,7 @@
 import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_OPTIONAL_BINDING;
 import static dagger.internal.codegen.Key.indexByKey;
 import static dagger.internal.codegen.Scope.reusableScope;
+import static dagger.internal.codegen.Util.toImmutableSet;
 import static java.util.function.Predicate.isEqual;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 
@@ -90,6 +91,29 @@
   abstract ImmutableMap<BindingKey, ResolvedBindings> resolvedBindings();
   abstract ImmutableSet<BindingGraph> subgraphs();
 
+  /** Returns the resolved bindings for the dependencies of {@code binding}. */
+  ImmutableSet<ResolvedBindings> resolvedDependencies(ContributionBinding binding) {
+    return binding
+        .dependencies()
+        .stream()
+        .map(
+            dependencyRequest ->
+                resolvedBindings()
+                    .getOrDefault(
+                        dependencyRequest.bindingKey(),
+                        ResolvedBindings.noBindings(
+                            dependencyRequest.bindingKey(), componentDescriptor())))
+        .collect(toImmutableSet());
+  }
+  /**
+   * The type that defines the component for this graph.
+   *
+   * @see ComponentDescriptor#componentDefinitionType()
+   */
+  TypeElement componentType() {
+    return componentDescriptor().componentDefinitionType();
+  }
+
   /**
    * Returns the set of modules that are owned by this graph regardless of whether or not any of
    * their bindings are used in this graph. For graphs representing top-level {@link Component
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 831fba7b0..7209c6e08 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -21,11 +21,8 @@
 import static com.google.auto.common.MoreTypes.asExecutable;
 import static com.google.auto.common.MoreTypes.asTypeElements;
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.base.Verify.verify;
 import static com.google.common.collect.Iterables.getOnlyElement;
-import static com.google.common.collect.Iterables.indexOf;
-import static dagger.internal.codegen.BindingType.MEMBERS_INJECTION;
 import static dagger.internal.codegen.BindingType.PRODUCTION;
 import static dagger.internal.codegen.BindingType.PROVISION;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentAnnotation;
@@ -42,6 +39,7 @@
 import static dagger.internal.codegen.ErrorMessages.DUPLICATE_BINDINGS_FOR_KEY_FORMAT;
 import static dagger.internal.codegen.ErrorMessages.DUPLICATE_SIZE_LIMIT;
 import static dagger.internal.codegen.ErrorMessages.INDENT;
+import static dagger.internal.codegen.ErrorMessages.MEMBERS_INJECTION_WITH_RAW_TYPE;
 import static dagger.internal.codegen.ErrorMessages.MEMBERS_INJECTION_WITH_UNBOUNDED_TYPE;
 import static dagger.internal.codegen.ErrorMessages.MULTIPLE_CONTRIBUTION_TYPES_FOR_KEY_FORMAT;
 import static dagger.internal.codegen.ErrorMessages.PROVIDER_ENTRY_POINT_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT;
@@ -55,49 +53,47 @@
 import static dagger.internal.codegen.ErrorMessages.nullableToNonNullable;
 import static dagger.internal.codegen.ErrorMessages.stripCommonTypePrefixes;
 import static dagger.internal.codegen.Scope.reusableScope;
+import static dagger.internal.codegen.Scope.scopesOf;
 import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
+import static dagger.internal.codegen.Util.toImmutableSet;
 import static java.util.stream.Collectors.joining;
 import static java.util.stream.Collectors.toSet;
-import static javax.tools.Diagnostic.Kind.ERROR;
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
-import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
 import com.google.common.base.Optional;
-import com.google.common.base.Predicate;
 import com.google.common.base.Predicates;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableListMultimap;
-import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
-import com.google.common.collect.Iterables;
-import com.google.common.collect.LinkedHashMultiset;
+import com.google.common.collect.ImmutableSortedMap;
+import com.google.common.collect.LinkedHashMultimap;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Multimap;
 import com.google.common.collect.Multimaps;
-import com.google.common.collect.Ordering;
+import com.google.common.collect.SetMultimap;
 import com.google.common.collect.Sets;
 import com.squareup.javapoet.TypeName;
+import dagger.BindsOptionalOf;
 import dagger.Component;
 import dagger.Lazy;
 import dagger.MapKey;
 import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
-import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.internal.codegen.ContributionType.HasContributionType;
 import java.util.ArrayDeque;
 import java.util.Collection;
 import java.util.Deque;
 import java.util.Formatter;
-import java.util.HashSet;
+import java.util.LinkedHashMap;
 import java.util.Map;
 import java.util.Queue;
 import java.util.Set;
+import java.util.concurrent.atomic.AtomicBoolean;
 import javax.inject.Provider;
 import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.ArrayType;
@@ -106,8 +102,9 @@
 import javax.lang.model.type.PrimitiveType;
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
+import javax.lang.model.type.TypeVisitor;
 import javax.lang.model.util.Elements;
-import javax.lang.model.util.SimpleTypeVisitor6;
+import javax.lang.model.util.SimpleTypeVisitor8;
 import javax.lang.model.util.Types;
 
 /** Reports errors in the shape of the binding graph. */
@@ -147,603 +144,127 @@
     this.keyFactory = keyFactory;
   }
 
-  /** A dependency path from an entry point. */
-  static final class DependencyPath {
-    private final Deque<ResolvedRequest> path = new ArrayDeque<>();
-    private final LinkedHashMultiset<BindingKey> keyPath = LinkedHashMultiset.create();
-    private final Set<DependencyRequest> resolvedDependencyRequests = new HashSet<>();
+  private final class ComponentValidation extends ComponentTreeTraverser {
+    final BindingGraph rootGraph;
+    final Map<ComponentDescriptor, ValidationReport.Builder<TypeElement>> reports =
+        new LinkedHashMap<>();
 
-    /** The entry point. */
-    Element entryPointElement() {
-      return path.getFirst().dependencyRequest().requestElement().get();
-    }
-
-    /** The the current dependency request and resolved bindings. */
-    ResolvedRequest current() {
-      return path.getLast();
-    }
-
-    /**
-     * {@code true} if there is a dependency cycle, which means that the
-     * {@linkplain #currentDependencyRequest() current request}'s binding key occurs earlier in the
-     * path.
-     */
-    boolean hasCycle() {
-      return keyPath.count(current().dependencyRequest().bindingKey()) > 1;
-    }
+    /** Bindings whose scopes are not compatible with the component that owns them. */
+    private final SetMultimap<ComponentDescriptor, ContributionBinding> incompatiblyScopedBindings =
+        LinkedHashMultimap.create();
 
-    /**
-     * If there is a cycle, the segment of the path that represents the cycle. The first request's
-     * and the last request's binding keys are equal. The last request is the {@linkplain
-     * #currentDependencyRequest() current request}.
-     *
-     * @throws IllegalStateException if {@link #hasCycle()} is {@code false}
-     */
-    FluentIterable<ResolvedRequest> cycle() {
-      checkState(hasCycle(), "no cycle");
-      return resolvedRequests()
-          .skip(indexOf(keyPath, Predicates.equalTo(current().dependencyRequest().bindingKey())));
+    ComponentValidation(BindingGraph rootGraph) {
+      super(rootGraph);
+      this.rootGraph = rootGraph;
     }
 
-    /**
-     * Makes {@code request} the current request. Be sure to call {@link #pop()} to back up to the
-     * previous request in the path.
-     */
-    void push(DependencyRequest request, ResolvedBindings resolvedBindings) {
-      path.add(
-          ResolvedRequest.create(
-              request,
-              resolvedBindings,
-              path.isEmpty()
-                  ? Optional.<ResolvedBindings>absent()
-                  : Optional.of(current().resolvedBindings())));
-      keyPath.add(request.bindingKey());
-    }
-
-    /** Makes the previous request the current request. */
-    void pop() {
-      verify(keyPath.remove(path.removeLast().dependencyRequest().bindingKey()));
-    }
-
-    /**
-     * Adds the {@linkplain #currentDependencyRequest() current request} to a set of visited
-     * requests, and returns {@code true} if the set didn't already contain it.
-     */
-    boolean visitCurrentDependencyRequest() {
-      return resolvedDependencyRequests.add(current().dependencyRequest());
-    }
-
-    int size() {
-      return path.size();
-    }
-
-    /** Returns the resolved dependency requests in this path, starting with the entry point. */
-    FluentIterable<ResolvedRequest> resolvedRequests() {
-      return FluentIterable.from(path);
-    }
-  }
-
-  private final class Validation {
-    final BindingGraph subject;
-    final ValidationReport.Builder<TypeElement> reportBuilder;
-    final Optional<Validation> parent;
-    final ImmutableMap<ComponentDescriptor, BindingGraph> subgraphsByComponentDescriptor;
-
-    Validation(BindingGraph subject, Optional<Validation> parent) {
-      this.subject = subject;
-      this.reportBuilder =
-          ValidationReport.about(subject.componentDescriptor().componentDefinitionType());
-      this.parent = parent;
-      this.subgraphsByComponentDescriptor =
-          Maps.uniqueIndex(subject.subgraphs(), BindingGraph::componentDescriptor);
-    }
-
-    Validation(BindingGraph topLevelGraph) {
-      this(topLevelGraph, Optional.<Validation>absent());
-    }
-
-    BindingGraph topLevelGraph() {
-      return parent.isPresent() ? parent.get().topLevelGraph() : subject;
-    }
-
-    ValidationReport.Builder<TypeElement> topLevelReport() {
-      return parent.isPresent() ? parent.get().topLevelReport() : reportBuilder;
+    @Override
+    protected BindingGraphTraverser bindingGraphTraverser(
+        ComponentTreePath componentPath, DependencyRequest entryPoint) {
+      return new BindingGraphValidation(componentPath, entryPoint);
     }
 
+    /** Returns a report that contains all validation messages found during traversal. */
     ValidationReport<TypeElement> buildReport() {
-      return reportBuilder.build();
+      ValidationReport.Builder<TypeElement> report =
+          ValidationReport.about(rootGraph.componentType());
+      reports.values().forEach(subreport -> report.addSubreport(subreport.build()));
+      return report.build();
     }
 
-    void validateSubgraph() {
-      validateComponentScope();
-      validateDependencyScopes();
-      validateComponentHierarchy();
-      validateBuilders();
-
-      for (ComponentMethodDescriptor componentMethod :
-           subject.componentDescriptor().componentMethods()) {
-        Optional<DependencyRequest> entryPoint = componentMethod.dependencyRequest();
-        if (entryPoint.isPresent()) {
-          traverseDependencyRequest(entryPoint.get(), new DependencyPath());
-        }
-      }
-
-      for (Map.Entry<ComponentMethodDescriptor, ComponentDescriptor> entry :
-          subject.componentDescriptor().subcomponentsByFactoryMethod().entrySet()) {
-        validateSubcomponentFactoryMethod(
-            entry.getKey().methodElement(), subgraphsByComponentDescriptor.get(entry.getValue()));
-      }
+    /** Returns the report builder for a (sub)component. */
+    private ValidationReport.Builder<TypeElement> report(BindingGraph graph) {
+      return reports.computeIfAbsent(
+          graph.componentDescriptor(),
+          descriptor -> ValidationReport.about(descriptor.componentDefinitionType()));
+    }
 
-      for (BindingGraph subgraph : subject.subgraphs()) {
-        Validation subgraphValidation = new Validation(subgraph, Optional.of(this));
-        subgraphValidation.validateSubgraph();
-        reportBuilder.addSubreport(subgraphValidation.buildReport());
-      }
+    @Override
+    protected void visitComponent(BindingGraph graph) {
+      validateDependencyScopes(graph);
+      validateComponentDependencyHierarchy(graph);
+      validateBuilders(graph);
+      super.visitComponent(graph);
+      checkScopedBindings(graph);
     }
 
-    private void validateSubcomponentFactoryMethod(
-        ExecutableElement factoryMethod, BindingGraph subgraph) {
-      Set<TypeElement> missingModules = subgraph.componentRequirements()
-          .stream()
-          .filter(componentRequirement -> !subgraphFactoryMethodParameters(factoryMethod)
-              .contains(componentRequirement))
-          .filter(moduleType -> !componentCanMakeNewInstances(moduleType))
-          .collect(toSet());
+    @Override
+    protected void visitSubcomponentFactoryMethod(
+        BindingGraph graph, BindingGraph parent, ExecutableElement factoryMethod) {
+      Set<TypeElement> missingModules =
+          graph
+              .componentRequirements()
+              .stream()
+              .filter(
+                  componentRequirement ->
+                      !subgraphFactoryMethodParameters(parent, factoryMethod)
+                          .contains(componentRequirement))
+              .filter(moduleType -> !componentCanMakeNewInstances(moduleType))
+              .collect(toSet());
       if (!missingModules.isEmpty()) {
-        reportBuilder.addError(
-            String.format(
-                "%s requires modules which have no visible default constructors. "
-                    + "Add the following modules as parameters to this method: %s",
-                subgraph.componentDescriptor().componentDefinitionType().getQualifiedName(),
-                missingModules.stream().map(Object::toString).collect(joining(", "))),
-            factoryMethod);
+        report(parent)
+            .addError(
+                String.format(
+                    "%s requires modules which have no visible default constructors. "
+                        + "Add the following modules as parameters to this method: %s",
+                    graph.componentType().getQualifiedName(),
+                    missingModules.stream().map(Object::toString).collect(joining(", "))),
+                factoryMethod);
       }
     }
 
     private ImmutableSet<TypeElement> subgraphFactoryMethodParameters(
-        ExecutableElement factoryMethod) {
-      DeclaredType componentType =
-          asDeclared(subject.componentDescriptor().componentDefinitionType().asType());
+        BindingGraph parent, ExecutableElement childFactoryMethod) {
+      DeclaredType componentType = asDeclared(parent.componentType().asType());
       ExecutableType factoryMethodType =
-          asExecutable(types.asMemberOf(componentType, factoryMethod));
+          asExecutable(types.asMemberOf(componentType, childFactoryMethod));
       return asTypeElements(factoryMethodType.getParameterTypes());
     }
 
-    /**
-     * Traverse the resolved dependency requests, validating resolved bindings, and reporting any
-     * cycles found.
-     *
-     * @param request the current dependency request
-     */
-    private void traverseDependencyRequest(DependencyRequest request, DependencyPath path) {
-      path.push(request, resolvedBindings(request));
-      try {
-        if (path.hasCycle()) {
-          reportCycle(path);
-          return;
-        }
-
-        if (path.visitCurrentDependencyRequest()) {
-          validateResolvedBindings(path);
-
-          // Validate all dependencies within the component that owns the binding.
-          path.current()
-              .resolvedBindings()
-              .allBindings()
-              .asMap()
-              .forEach(
-                  (component, bindings) -> {
-                    Validation validation = validationForComponent(component);
-                    for (Binding binding : bindings) {
-                      for (DependencyRequest nextRequest : binding.dependencies()) {
-                        validation.traverseDependencyRequest(nextRequest, path);
-                      }
-                    }
-                  });
-        }
-      } finally {
-        path.pop();
-      }
-    }
-
-    private ResolvedBindings resolvedBindings(DependencyRequest request) {
-      BindingKey bindingKey = request.bindingKey();
-      ResolvedBindings resolvedBindings = subject.resolvedBindings().get(bindingKey);
-      return resolvedBindings == null
-          ? ResolvedBindings.noBindings(bindingKey, subject.componentDescriptor())
-          : resolvedBindings;
-    }
-
-    private Validation validationForComponent(ComponentDescriptor component) {
-      if (component.equals(subject.componentDescriptor())) {
-        return this;
-      } else if (parent.isPresent()) {
-        return parent.get().validationForComponent(component);
-      } else {
-        throw new IllegalArgumentException(
-            String.format(
-                "unknown component %s within %s",
-                component.componentDefinitionType(),
-                subject.componentDescriptor().componentDefinitionType()));
-      }
-    }
-
-    /**
-     * Reports errors if the set of bindings resolved is inconsistent with the type of the binding.
-     */
-    private void validateResolvedBindings(DependencyPath path) {
-      ResolvedBindings resolvedBindings = path.current().resolvedBindings();
-      if (resolvedBindings.isEmpty()) {
-        reportMissingBinding(path);
-        return;
-      }
-
-      switch (resolvedBindings.bindingKey().kind()) {
-        case CONTRIBUTION:
-          if (Iterables.any(
-              resolvedBindings.bindings(), MEMBERS_INJECTION::isOfType)) {
-            // TODO(dpb): How could this ever happen, even in an invalid graph?
-            throw new AssertionError(
-                "contribution binding keys should never have members injection bindings");
-          }
-          validateNullability(path, resolvedBindings.contributionBindings());
-          if (resolvedBindings.contributionBindings().size() > 1) {
-            reportDuplicateBindings(path);
-            return;
-          }
-          ContributionBinding contributionBinding = resolvedBindings.contributionBinding();
-          if (contributionBinding.bindingKind().equals(INJECTION)) {
-            TypeMirror type = contributionBinding.key().type();
-            ValidationReport<TypeElement> report =
-                injectValidator.validateType(MoreTypes.asTypeElement(type));
-            if (!report.isClean()) {
-              reportBuilder.addSubreport(report);
-              return;
-            }
-          }
-          if (contributionBinding.bindingType().equals(PRODUCTION)
-              && doesPathRequireProvisionOnly(path)) {
-            reportProviderMayNotDependOnProducer(path, contributionBinding);
-            return;
-          }
-          // TODO(dpb,beder): Validate this during @Inject/@Provides/@Produces validation.
-          if (compilerOptions.usesProducers()) {
-            Key productionImplementationExecutorKey =
-                keyFactory.forProductionImplementationExecutor();
-            // only forbid depending on the production executor if it's not the Dagger-specific
-            // binding to the implementation
-            if (!contributionBinding.key().equals(productionImplementationExecutorKey)) {
-              Key productionExecutorKey = keyFactory.forProductionExecutor();
-              for (DependencyRequest request : contributionBinding.explicitDependencies()) {
-                if (request.key().equals(productionExecutorKey)
-                    || request.key().equals(productionImplementationExecutorKey)) {
-                  reportDependsOnProductionExecutor(path);
-                  return;
-                }
-              }
-            }
-          }
-          if (contributionBinding.bindingKind().equals(SYNTHETIC_MULTIBOUND_MAP)) {
-            validateMapKeys(path, contributionBinding);
-          }
-          break;
-        case MEMBERS_INJECTION:
-          if (!Iterables.all(resolvedBindings.bindings(), MEMBERS_INJECTION::isOfType)) {
-            // TODO(dpb): How could this ever happen, even in an invalid graph?
-            throw new AssertionError(
-                "members injection binding keys should never have contribution bindings");
-          }
-          if (resolvedBindings.bindings().size() > 1) {
-            reportDuplicateBindings(path);
-            return;
-          }
-          validateMembersInjectionBinding(resolvedBindings.membersInjectionBinding().get(), path);
-          return;
-        default:
-          throw new AssertionError();
-      }
-    }
-
-    /**
-     * Returns an object that contains all the same bindings as {@code resolvedBindings}, except
-     * that any {@link ContributionBinding}s without {@linkplain Binding#bindingElement() binding
-     * elements} are replaced by the contribution bindings and multibinding declarations of their
-     * dependencies.
-     *
-     * <p>For example, if:
-     *
-     * <ul>
-     * <li>The bindings for {@code key1} are {@code A} and {@code B}, with multibinding declaration
-     *     {@code X}.
-     * <li>{@code B} is a binding without a binding element that has a dependency on {@code key2}.
-     * <li>The bindings for {@code key2} are {@code C} and {@code D}, with multibinding declaration
-     *     {@code Y}.
-     * </ul>
-     *
-     * then {@code inlineContributionsWithoutBindingElements(bindingsForKey1)} has bindings {@code
-     * A}, {@code C}, and {@code D}, with multibinding declarations {@code X} and {@code Y}.
-     *
-     * <p>The replacement is repeated until all of the bindings have elements.
-     */
-    private ResolvedBindings inlineContributionsWithoutBindingElements(
-        ResolvedBindings resolvedBinding) {
-      if (Iterables.all(resolvedBinding.bindings(),
-          bindingDeclaration -> bindingDeclaration.bindingElement().isPresent())) {
-        return resolvedBinding;
-      }
-
-      ImmutableSetMultimap.Builder<ComponentDescriptor, ContributionBinding> contributions =
-          ImmutableSetMultimap.builder();
-      ImmutableSet.Builder<MultibindingDeclaration> multibindingDeclarations =
-          ImmutableSet.builder();
-      ImmutableSet.Builder<SubcomponentDeclaration> subcomponentDeclarations =
-          ImmutableSet.builder();
-      ImmutableSet.Builder<OptionalBindingDeclaration> optionalBindingDeclarations =
-          ImmutableSet.builder();
-
-      Queue<ResolvedBindings> queue = new ArrayDeque<>();
-      queue.add(resolvedBinding);
-
-      for (ResolvedBindings queued = queue.poll(); queued != null; queued = queue.poll()) {
-        multibindingDeclarations.addAll(queued.multibindingDeclarations());
-        subcomponentDeclarations.addAll(queued.subcomponentDeclarations());
-        optionalBindingDeclarations.addAll(queued.optionalBindingDeclarations());
-        for (Map.Entry<ComponentDescriptor, ContributionBinding> bindingEntry :
-            queued.allContributionBindings().entries()) {
-          BindingGraph owningGraph = validationForComponent(bindingEntry.getKey()).subject;
-          ContributionBinding binding = bindingEntry.getValue();
-          if (binding.bindingElement().isPresent()) {
-            contributions.put(bindingEntry);
-          } else {
-            for (DependencyRequest dependency : binding.explicitDependencies()) {
-              queue.add(owningGraph.resolvedBindings().get(dependency.bindingKey()));
-            }
-          }
-        }
-      }
-      return ResolvedBindings.forContributionBindings(
-          resolvedBinding.bindingKey(),
-          resolvedBinding.owningComponent(),
-          contributions.build(),
-          multibindingDeclarations.build(),
-          subcomponentDeclarations.build(),
-          optionalBindingDeclarations.build());
-    }
-
-    private ImmutableListMultimap<ContributionType, BindingDeclaration> declarationsByType(
-        ResolvedBindings resolvedBinding) {
-      ResolvedBindings inlined = inlineContributionsWithoutBindingElements(resolvedBinding);
-      return new ImmutableListMultimap.Builder<ContributionType, BindingDeclaration>()
-          .putAll(Multimaps
-              .index(inlined.contributionBindings(), HasContributionType::contributionType))
-          .putAll(Multimaps
-              .index(inlined.multibindingDeclarations(), HasContributionType::contributionType))
-          .build();
+    /** Validates that component dependencies do not form a cycle. */
+    private void validateComponentDependencyHierarchy(BindingGraph graph) {
+      validateComponentDependencyHierarchy(graph, graph.componentType(), new ArrayDeque<>());
     }
 
-    /**
-     * Ensures that if the current request isn't nullable, then each contribution is also not
-     * nullable.
-     */
-    private void validateNullability(DependencyPath path, Set<ContributionBinding> bindings) {
-      if (path.current().dependencyRequest().isNullable()) {
-        return;
-      }
-
-      // Note: the method signature will include the @Nullable in it!
-      /* TODO(sameb): Sometimes javac doesn't include the Element in its output.
-       * (Maybe this happens if the code was already compiled before this point?)
-       * ... we manually print out the request in that case, otherwise the error
-       * message is kind of useless. */
-      String typeName = TypeName.get(path.current().dependencyRequest().key().type()).toString();
-
-      for (ContributionBinding binding : bindings) {
-        if (binding.nullableType().isPresent()) {
-          owningReportBuilder(
-                  path.current()
-                      .dependentBindings()
-                      .filter(ContributionBinding.class)
-                      .append(binding))
-              .addItem(
-                  nullableToNonNullable(typeName, bindingDeclarationFormatter.format(binding))
-                      + "\n at: "
-                      + dependencyRequestFormatter.toDependencyTrace(path),
-                  compilerOptions.nullableValidationKind(),
-                  path.entryPointElement());
-        }
-      }
-    }
-
-    private void validateMapKeys(
-        DependencyPath path, ContributionBinding binding) {
-      checkArgument(binding.bindingKind().equals(SYNTHETIC_MULTIBOUND_MAP),
-          "binding must be a synthetic multibound map: %s",
-          binding);
-      ImmutableSet.Builder<ContributionBinding> multibindingContributionsBuilder =
-          ImmutableSet.builder();
-      for (DependencyRequest dependency : binding.explicitDependencies()) {
-        multibindingContributionsBuilder.add(
-            subject.resolvedBindings().get(dependency.bindingKey()).contributionBinding());
-      }
-      ImmutableSet<ContributionBinding> multibindingContributions =
-          multibindingContributionsBuilder.build();
-      validateMapKeySet(path, multibindingContributions);
-      validateMapKeyAnnotationTypes(path, multibindingContributions);
-    }
-
-    /**
-     * Reports errors if {@code mapBindings} has more than one binding for the same map key.
-     */
-    private void validateMapKeySet(DependencyPath path, Set<ContributionBinding> mapBindings) {
-      for (Collection<ContributionBinding> mapBindingsForMapKey :
-          indexMapBindingsByMapKey(mapBindings).asMap().values()) {
-        if (mapBindingsForMapKey.size() > 1) {
-          reportDuplicateMapKeys(path, mapBindingsForMapKey);
-        }
-      }
-    }
-
-    /**
-     * Reports errors if {@code mapBindings} uses more than one {@link MapKey} annotation type.
-     */
-    private void validateMapKeyAnnotationTypes(
-        DependencyPath path, Set<ContributionBinding> contributionBindings) {
-      ImmutableSetMultimap<Equivalence.Wrapper<DeclaredType>, ContributionBinding>
-          mapBindingsByAnnotationType = indexMapBindingsByAnnotationType(contributionBindings);
-      if (mapBindingsByAnnotationType.keySet().size() > 1) {
-        reportInconsistentMapKeyAnnotations(path, mapBindingsByAnnotationType);
-      }
-    }
-
-    /** Reports errors if a members injection binding is invalid. */
-    // TODO(dpb): Can this be done while validating @Inject?
-    private void validateMembersInjectionBinding(
-        final MembersInjectionBinding binding, final DependencyPath path) {
-      binding
-          .key()
-          .type()
-          .accept(
-              new SimpleTypeVisitor6<Void, Void>() {
-                @Override
-                protected Void defaultAction(TypeMirror e, Void p) {
-                  reportBuilder.addError(
-                      "Invalid members injection request.", binding.membersInjectedType());
-                  return null;
-                }
-
-                @Override
-                public Void visitDeclared(DeclaredType type, Void ignored) {
-                  // If the key has type arguments, validate that each type argument is declared.
-                  // Otherwise the type argument may be a wildcard (or other type), and we can't
-                  // resolve that to actual types.  If the arg was an array, validate the type
-                  // of the array.
-                  for (TypeMirror arg : type.getTypeArguments()) {
-                    boolean declared;
-                    switch (arg.getKind()) {
-                      case ARRAY:
-                        declared =
-                            MoreTypes.asArray(arg)
-                                .getComponentType()
-                                .accept(
-                                    new SimpleTypeVisitor6<Boolean, Void>() {
-                                      @Override
-                                      protected Boolean defaultAction(TypeMirror e, Void p) {
-                                        return false;
-                                      }
-
-                                      @Override
-                                      public Boolean visitDeclared(DeclaredType t, Void p) {
-                                        for (TypeMirror arg : t.getTypeArguments()) {
-                                          if (!arg.accept(this, null)) {
-                                            return false;
-                                          }
-                                        }
-                                        return true;
-                                      }
-
-                                      @Override
-                                      public Boolean visitArray(ArrayType t, Void p) {
-                                        return t.getComponentType().accept(this, null);
-                                      }
-
-                                      @Override
-                                      public Boolean visitPrimitive(PrimitiveType t, Void p) {
-                                        return true;
-                                      }
-                                    },
-                                    null);
-                        break;
-                      case DECLARED:
-                        declared = true;
-                        break;
-                      default:
-                        declared = false;
-                    }
-                    if (!declared) {
-                      reportBuilder.addError(
-                          String.format(
-                              MEMBERS_INJECTION_WITH_UNBOUNDED_TYPE,
-                              arg.toString(),
-                              type.toString(),
-                              dependencyRequestFormatter.toDependencyTrace(path)),
-                          path.entryPointElement());
-                      return null;
-                    }
-                  }
-
-                  TypeElement element = MoreElements.asType(type.asElement());
-                  // Also validate that the key is not the erasure of a generic type.
-                  // If it is, that means the user referred to Foo<T> as just 'Foo',
-                  // which we don't allow.  (This is a judgement call -- we *could*
-                  // allow it and instantiate the type bounds... but we don't.)
-                  if (!MoreTypes.asDeclared(element.asType()).getTypeArguments().isEmpty()
-                      && types.isSameType(types.erasure(element.asType()), type)) {
-                    reportBuilder.addError(
-                        String.format(
-                            ErrorMessages.MEMBERS_INJECTION_WITH_RAW_TYPE,
-                            type.toString(),
-                            dependencyRequestFormatter.toDependencyTrace(path)),
-                        path.entryPointElement());
-                  }
-                  return null;
-                }
-              },
-              null);
-    }
-
-    /**
-     * Validates that component dependencies do not form a cycle.
-     */
-    private void validateComponentHierarchy() {
-      ComponentDescriptor descriptor = subject.componentDescriptor();
-      TypeElement componentType = descriptor.componentDefinitionType();
-      validateComponentHierarchy(componentType, componentType, new ArrayDeque<TypeElement>());
-    }
-
-    /**
-     * Recursive method to validate that component dependencies do not form a cycle.
-     */
-    private void validateComponentHierarchy(
-        TypeElement rootComponent,
-        TypeElement componentType,
-        Deque<TypeElement> componentStack) {
-
-      if (componentStack.contains(componentType)) {
+    /** Recursive method to validate that component dependencies do not form a cycle. */
+    private void validateComponentDependencyHierarchy(
+        BindingGraph graph, TypeElement dependency, Deque<TypeElement> dependencyStack) {
+      if (dependencyStack.contains(dependency)) {
         // Current component has already appeared in the component chain.
         StringBuilder message = new StringBuilder();
-        message.append(rootComponent.getQualifiedName());
+        message.append(graph.componentType().getQualifiedName());
         message.append(" contains a cycle in its component dependencies:\n");
-        componentStack.push(componentType);
-        appendIndentedComponentsList(message, componentStack);
-        componentStack.pop();
-        reportBuilder.addItem(
-            message.toString(),
-            compilerOptions.scopeCycleValidationType().diagnosticKind().get(),
-            rootComponent,
-            getComponentAnnotation(rootComponent).get());
+        dependencyStack.push(dependency);
+        appendIndentedComponentsList(message, dependencyStack);
+        dependencyStack.pop();
+        report(graph)
+            .addItem(
+                message.toString(),
+                compilerOptions.scopeCycleValidationType().diagnosticKind().get(),
+                graph.componentType(),
+                getComponentAnnotation(graph.componentType()).get());
       } else {
-        Optional<AnnotationMirror> componentAnnotation = getComponentAnnotation(componentType);
+        Optional<AnnotationMirror> componentAnnotation = getComponentAnnotation(dependency);
         if (componentAnnotation.isPresent()) {
-          componentStack.push(componentType);
+          dependencyStack.push(dependency);
 
           ImmutableSet<TypeElement> dependencies =
               MoreTypes.asTypeElements(getComponentDependencies(componentAnnotation.get()));
-          for (TypeElement dependency : dependencies) {
-            validateComponentHierarchy(rootComponent, dependency, componentStack);
+          for (TypeElement nextDependency : dependencies) {
+            validateComponentDependencyHierarchy(graph, nextDependency, dependencyStack);
           }
 
-          componentStack.pop();
+          dependencyStack.pop();
         }
       }
     }
 
     /**
-     * Validates that among the dependencies are at most one scoped dependency,
-     * that there are no cycles within the scoping chain, and that singleton
-     * components have no scoped dependencies.
+     * Validates that among the dependencies are at most one scoped dependency, that there are no
+     * cycles within the scoping chain, and that singleton components have no scoped dependencies.
      */
-    private void validateDependencyScopes() {
-      ComponentDescriptor descriptor = subject.componentDescriptor();
+    private void validateDependencyScopes(BindingGraph graph) {
+      ComponentDescriptor descriptor = graph.componentDescriptor();
       ImmutableSet<Scope> scopes = descriptor.scopes();
       ImmutableSet<TypeElement> scopedDependencies = scopedTypesIn(descriptor.dependencies());
       if (!scopes.isEmpty()) {
@@ -757,11 +278,12 @@ private void validateDependencyScopes() {
             StringBuilder message = new StringBuilder(
                 "This @Singleton component cannot depend on scoped components:\n");
             appendIndentedComponentsList(message, scopedDependencies);
-            reportBuilder.addItem(
-                message.toString(),
-                compilerOptions.scopeCycleValidationType().diagnosticKind().get(),
-                descriptor.componentDefinitionType(),
-                descriptor.componentAnnotation());
+            report(graph)
+                .addItem(
+                    message.toString(),
+                    compilerOptions.scopeCycleValidationType().diagnosticKind().get(),
+                    descriptor.componentDefinitionType(),
+                    descriptor.componentAnnotation());
           }
         } else if (scopedDependencies.size() > 1) {
           // Scoped components may depend on at most one scoped component.
@@ -773,14 +295,16 @@ private void validateDependencyScopes() {
               .append(descriptor.componentDefinitionType().getQualifiedName())
               .append(" depends on more than one scoped component:\n");
           appendIndentedComponentsList(message, scopedDependencies);
-          reportBuilder.addError(
-              message.toString(),
-              descriptor.componentDefinitionType(),
-              descriptor.componentAnnotation());
+          report(graph)
+              .addError(
+                  message.toString(),
+                  descriptor.componentDefinitionType(),
+                  descriptor.componentAnnotation());
         } else {
           // Dagger 1.x scope compatibility requires this be suppress-able.
           if (!compilerOptions.scopeCycleValidationType().equals(ValidationType.NONE)) {
-            validateScopeHierarchy(descriptor.componentDefinitionType(),
+            validateDependencyScopeHierarchy(
+                graph,
                 descriptor.componentDefinitionType(),
                 new ArrayDeque<ImmutableSet<Scope>>(),
                 new ArrayDeque<TypeElement>());
@@ -793,49 +317,50 @@ private void validateDependencyScopes() {
               new StringBuilder(descriptor.componentDefinitionType().getQualifiedName())
                   .append(" (unscoped) cannot depend on scoped components:\n");
           appendIndentedComponentsList(message, scopedDependencies);
-          reportBuilder.addError(
-              message.toString(),
-              descriptor.componentDefinitionType(),
-              descriptor.componentAnnotation());
+          report(graph)
+              .addError(
+                  message.toString(),
+                  descriptor.componentDefinitionType(),
+                  descriptor.componentAnnotation());
         }
       }
     }
 
-    private void validateBuilders() {
-      ComponentDescriptor componentDesc = subject.componentDescriptor();
+    private void validateBuilders(BindingGraph graph) {
+      ComponentDescriptor componentDesc = graph.componentDescriptor();
       if (!componentDesc.builderSpec().isPresent()) {
         // If no builder, nothing to validate.
         return;
       }
 
-      Set<TypeElement> availableDependencies = subject.availableDependencies();
+      Set<TypeElement> availableDependencies = graph.availableDependencies();
       Set<TypeElement> requiredDependencies =
           Sets.filter(availableDependencies, input -> !componentCanMakeNewInstances(input));
       final BuilderSpec spec = componentDesc.builderSpec().get();
       Map<TypeElement, ExecutableElement> allSetters = spec.methodMap();
 
       ErrorMessages.ComponentBuilderMessages msgs =
-          ErrorMessages.builderMsgsFor(subject.componentDescriptor().kind());
+          ErrorMessages.builderMsgsFor(graph.componentDescriptor().kind());
       Set<TypeElement> extraSetters = Sets.difference(allSetters.keySet(), availableDependencies);
       if (!extraSetters.isEmpty()) {
         Collection<ExecutableElement> excessMethods =
             Maps.filterKeys(allSetters, Predicates.in(extraSetters)).values();
-        Iterable<String> formatted =
-            FluentIterable.from(excessMethods)
-                .transform(
-                    method ->
-                        methodSignatureFormatter.format(
-                            method,
-                            Optional.of(
-                                MoreTypes.asDeclared(spec.builderDefinitionType().asType()))));
-        reportBuilder.addError(
-            String.format(msgs.extraSetters(), formatted), spec.builderDefinitionType());
+        Optional<DeclaredType> container =
+            Optional.of(MoreTypes.asDeclared(spec.builderDefinitionType().asType()));
+        String formatted =
+            excessMethods
+                .stream()
+                .map(method -> methodSignatureFormatter.format(method, container))
+                .collect(joining(", ", "[", "]"));
+        report(graph)
+            .addError(String.format(msgs.extraSetters(), formatted), spec.builderDefinitionType());
       }
 
       Set<TypeElement> missingSetters = Sets.difference(requiredDependencies, allSetters.keySet());
       if (!missingSetters.isEmpty()) {
-        reportBuilder.addError(
-            String.format(msgs.missingSetters(), missingSetters), spec.builderDefinitionType());
+        report(graph)
+            .addError(
+                String.format(msgs.missingSetters(), missingSetters), spec.builderDefinitionType());
       }
     }
 
@@ -845,42 +370,44 @@ private void validateBuilders() {
      *
      * <p>As a side-effect, this means scoped components cannot have a dependency cycle between
      * themselves, since a component's presence within its own dependency path implies a cyclical
-     * relationship between scopes. However, cycles in component dependencies are explicitly
-     * checked in {@link #validateComponentHierarchy()}.
+     * relationship between scopes. However, cycles in component dependencies are explicitly checked
+     * in {@link #validateComponentDependencyHierarchy(BindingGraph)}.
      */
-    private void validateScopeHierarchy(TypeElement rootComponent,
-        TypeElement componentType,
+    private void validateDependencyScopeHierarchy(
+        BindingGraph graph,
+        TypeElement dependency,
         Deque<ImmutableSet<Scope>> scopeStack,
         Deque<TypeElement> scopedDependencyStack) {
-      ImmutableSet<Scope> scopes = Scope.scopesOf(componentType);
+      ImmutableSet<Scope> scopes = Scope.scopesOf(dependency);
       if (stackOverlaps(scopeStack, scopes)) {
-        scopedDependencyStack.push(componentType);
+        scopedDependencyStack.push(dependency);
         // Current scope has already appeared in the component chain.
         StringBuilder message = new StringBuilder();
-        message.append(rootComponent.getQualifiedName());
+        message.append(graph.componentType().getQualifiedName());
         message.append(" depends on scoped components in a non-hierarchical scope ordering:\n");
         appendIndentedComponentsList(message, scopedDependencyStack);
         if (compilerOptions.scopeCycleValidationType().diagnosticKind().isPresent()) {
-          reportBuilder.addItem(
-              message.toString(),
-              compilerOptions.scopeCycleValidationType().diagnosticKind().get(),
-              rootComponent,
-              getComponentAnnotation(rootComponent).get());
+          report(graph)
+              .addItem(
+                  message.toString(),
+                  compilerOptions.scopeCycleValidationType().diagnosticKind().get(),
+                  graph.componentType(),
+                  getComponentAnnotation(graph.componentType()).get());
         }
         scopedDependencyStack.pop();
       } else {
         // TODO(beder): transitively check scopes of production components too.
         Optional<AnnotationMirror> componentAnnotation =
-            getAnnotationMirror(componentType, Component.class);
+            getAnnotationMirror(dependency, Component.class);
         if (componentAnnotation.isPresent()) {
           ImmutableSet<TypeElement> scopedDependencies = scopedTypesIn(
               MoreTypes.asTypeElements(getComponentDependencies(componentAnnotation.get())));
           if (scopedDependencies.size() == 1) {
             // empty can be ignored (base-case), and > 1 is a different error reported separately.
             scopeStack.push(scopes);
-            scopedDependencyStack.push(componentType);
-            validateScopeHierarchy(rootComponent, getOnlyElement(scopedDependencies),
-                scopeStack, scopedDependencyStack);
+            scopedDependencyStack.push(dependency);
+            validateDependencyScopeHierarchy(
+                graph, getOnlyElement(scopedDependencies), scopeStack, scopedDependencyStack);
             scopedDependencyStack.pop();
             scopeStack.pop();
           }
@@ -898,350 +425,622 @@ private void validateScopeHierarchy(TypeElement rootComponent,
     }
 
     /**
-     * Validates that the scope (if any) of this component are compatible with the scopes of the
-     * bindings available in this component
+     * Collects scoped bindings that are not compatible with their owning component for later
+     * reporting by {@link #checkScopedBindings(BindingGraph)}.
      */
-    void validateComponentScope() {
-      ImmutableMap<BindingKey, ResolvedBindings> resolvedBindings = subject.resolvedBindings();
-      ImmutableSet<Scope> componentScopes = subject.componentDescriptor().scopes();
-      ImmutableSet.Builder<String> incompatiblyScopedMethodsBuilder = ImmutableSet.builder();
-      Scope reusableScope = reusableScope(elements);
-      for (ResolvedBindings bindings : resolvedBindings.values()) {
-        for (ContributionBinding contributionBinding : bindings.ownedContributionBindings()) {
-          Optional<Scope> bindingScope = contributionBinding.scope();
-          if (bindingScope.isPresent()
-              && !bindingScope.get().equals(reusableScope)
-              && !componentScopes.contains(bindingScope.get())) {
-            // Scoped components cannot reference bindings to @Provides methods or @Inject
-            // types decorated by a different scope annotation. Unscoped components cannot
-            // reference to scoped @Provides methods or @Inject types decorated by any
-            // scope annotation.
-            switch (contributionBinding.bindingKind()) {
-              case SYNTHETIC_DELEGATE_BINDING:
-              case PROVISION:
-                incompatiblyScopedMethodsBuilder.add(
-                    methodSignatureFormatter.format(
-                        MoreElements.asExecutable(contributionBinding.bindingElement().get())));
-                break;
-              case INJECTION:
-                incompatiblyScopedMethodsBuilder.add(
-                    bindingScope.get().getReadableSource()
-                        + " class "
-                        + contributionBinding.bindingTypeElement().get().getQualifiedName());
-                break;
-              default:
-                throw new IllegalStateException();
-            }
-          }
+    private void checkBindingScope(
+        ContributionBinding binding, ComponentDescriptor owningComponent) {
+      if (binding.scope().isPresent()
+          && !binding.scope().get().equals(reusableScope(elements))
+          && !owningComponent.scopes().contains(binding.scope().get())) {
+        incompatiblyScopedBindings.put(owningComponent, binding);
+      }
+    }
+
+    /**
+     * Reports an error if any of the scoped bindings owned by a given component are incompatible
+     * with the component. Must be called after all bindings owned by the given component have been
+     * {@linkplain #checkBindingScope(ContributionBinding, ComponentDescriptor) visited}.
+     */
+    private void checkScopedBindings(BindingGraph graph) {
+      if (!incompatiblyScopedBindings.containsKey(graph.componentDescriptor())) {
+        return;
+      }
+
+      StringBuilder message = new StringBuilder(graph.componentType().getQualifiedName());
+      if (!graph.componentDescriptor().scopes().isEmpty()) {
+        message.append(" scoped with ");
+        for (Scope scope : graph.componentDescriptor().scopes()) {
+          message.append(scope.getReadableSource()).append(' ');
         }
+        message.append("may not reference bindings with different scopes:\n");
+      } else {
+        message.append(" (unscoped) may not reference scoped bindings:\n");
       }
+      for (ContributionBinding binding :
+          incompatiblyScopedBindings.get(graph.componentDescriptor())) {
+        message.append(ErrorMessages.INDENT);
+
+        switch (binding.bindingKind()) {
+          case SYNTHETIC_DELEGATE_BINDING:
+          case PROVISION:
+            message.append(
+                methodSignatureFormatter.format(
+                    MoreElements.asExecutable(binding.bindingElement().get())));
+            break;
+
+          case INJECTION:
+            message
+                .append(binding.scope().get().getReadableSource())
+                .append(" class ")
+                .append(binding.bindingTypeElement().get().getQualifiedName());
+            break;
+
+          default:
+            throw new AssertionError(binding);
+        }
 
-      ImmutableSet<String> incompatiblyScopedMethods = incompatiblyScopedMethodsBuilder.build();
-      if (!incompatiblyScopedMethods.isEmpty()) {
-        TypeElement componentType = subject.componentDescriptor().componentDefinitionType();
-        StringBuilder message = new StringBuilder(componentType.getQualifiedName());
-        if (!componentScopes.isEmpty()) {
-          message.append(" scoped with ");
-          for (Scope scope : componentScopes) {
-            message.append(scope.getReadableSource()).append(' ');
+        message.append("\n");
+      }
+      report(graph)
+          .addError(
+              message.toString(),
+              graph.componentType(),
+              graph.componentDescriptor().componentAnnotation());
+    }
+
+    final class BindingGraphValidation extends BindingGraphTraverser {
+
+      BindingGraphValidation(ComponentTreePath componentPath, DependencyRequest entryPoint) {
+        super(componentPath, entryPoint);
+      }
+
+      /** Reports an error for the current component at the entry point. */
+      private void reportErrorAtEntryPoint(String format, Object... args) {
+        reportErrorAtEntryPoint(currentGraph(), format, args);
+      }
+
+      /** Reports an error for the given component at the entry point. */
+      private void reportErrorAtEntryPoint(BindingGraph graph, String format, Object... args) {
+        String message = args.length == 0 ? format : String.format(format, args);
+        report(graph).addError(message, entryPointElement());
+      }
+
+      private String formatDependencyTrace() {
+        return dependencyRequestFormatter.format(dependencyTrace());
+      }
+
+      @Override
+      protected void visitDependencyRequest(DependencyRequest dependencyRequest) {
+        if (atDependencyCycle()) {
+          reportDependencyCycle();
+        }
+        super.visitDependencyRequest(dependencyRequest);
+      }
+
+      @Override
+      protected void visitResolvedBindings(ResolvedBindings resolvedBindings) {
+        if (resolvedBindings.isEmpty()) {
+          reportMissingBinding();
+        } else if (resolvedBindings.bindings().size() > 1) {
+          reportDuplicateBindings();
+        }
+        super.visitResolvedBindings(resolvedBindings);
+      }
+
+      @Override
+      protected void visitContributionBinding(
+          ContributionBinding binding, ComponentDescriptor owningComponent) {
+        checkBindingScope(binding, owningComponent);
+        if (!dependencyRequest().isNullable() && binding.nullableType().isPresent()) {
+          reportNullableBindingForNonNullableRequest(binding);
+        }
+        if (binding.bindingKind().equals(INJECTION)) {
+          TypeMirror type = binding.key().type();
+          ValidationReport<TypeElement> report =
+              injectValidator.validateType(MoreTypes.asTypeElement(type));
+          if (!report.isClean()) {
+            report(currentGraph()).addSubreport(report);
+          }
+        }
+        if (binding.bindingType().equals(PRODUCTION) && doesPathRequireProvisionOnly()) {
+          reportProviderMayNotDependOnProducer(binding);
+        }
+        if (compilerOptions.usesProducers()) {
+          // TODO(dpb,beder): Validate this during @Inject/@Provides/@Produces validation.
+          // Only the Dagger-specific binding may depend on the production executor.
+          Key productionImplementationExecutorKey =
+              keyFactory.forProductionImplementationExecutor();
+          if (!binding.key().equals(productionImplementationExecutorKey)) {
+            Key productionExecutorKey = keyFactory.forProductionExecutor();
+            for (DependencyRequest request : binding.explicitDependencies()) {
+              if (request.key().equals(productionExecutorKey)
+                  || request.key().equals(productionImplementationExecutorKey)) {
+                reportDependsOnProductionExecutor();
+              }
+            }
           }
-          message.append("may not reference bindings with different scopes:\n");
-        } else {
-          message.append(" (unscoped) may not reference scoped bindings:\n");
         }
-        for (String method : incompatiblyScopedMethods) {
-          message.append(ErrorMessages.INDENT).append(method).append("\n");
+        if (binding.bindingKind().equals(SYNTHETIC_MULTIBOUND_MAP)) {
+          validateMapKeys(binding, owningComponent);
         }
-        reportBuilder.addError(
-            message.toString(), componentType, subject.componentDescriptor().componentAnnotation());
+        super.visitContributionBinding(binding, owningComponent);
       }
-    }
 
-    @SuppressWarnings("resource") // Appendable is a StringBuilder.
-    // TODO(b/29509141): Clarify the error.
-    private void reportProviderMayNotDependOnProducer(
-        DependencyPath path, ContributionBinding productionBinding) {
-      if (path.size() == 1) {
-        reportBuilder.addError(
-            String.format(
-                PROVIDER_ENTRY_POINT_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT,
-                formatCurrentDependencyRequestKey(path)),
-            path.entryPointElement());
-      } else {
-        FluentIterable<ContributionBinding> dependentProvisions =
-            provisionsDependingOnLatestRequest(path);
-        // TODO(beder): Consider displaying all dependent provisions in the error message. If we
-        // do that, should we display all productions that depend on them also?
-        owningReportBuilder(dependentProvisions.append(productionBinding))
-            .addError(
-                String.format(
-                    PROVIDER_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT,
-                    dependentProvisions.iterator().next().key()),
-                path.entryPointElement());
+      @Override
+      protected void visitMembersInjectionBinding(
+          MembersInjectionBinding binding, ComponentDescriptor owningComponent) {
+        validateMembersInjectionBinding(binding);
+        super.visitMembersInjectionBinding(binding, owningComponent);
       }
-    }
 
-    /**
-     * Descriptive portion of the error message for when the given request has no binding.
-     * Currently, the only other portions of the message are the dependency path, line number and
-     * filename. Not static because it uses the instance field types.
-     */
-    private StringBuilder requiresErrorMessageBase(DependencyPath path) {
-      Key key = path.current().dependencyRequest().key();
-      String requiresErrorMessageFormat;
-      // TODO(dpb): Check for wildcard injection somewhere else first?
-      if (key.type().getKind().equals(TypeKind.WILDCARD)) {
-        requiresErrorMessageFormat = CANNOT_INJECT_WILDCARD_TYPE;
-      } else {
-        boolean requiresProvision = doesPathRequireProvisionOnly(path);
-        if (!key.isValidImplicitProvisionKey(types)) {
-          requiresErrorMessageFormat = requiresProvision
-              ? REQUIRES_PROVIDER_FORMAT
-              : REQUIRES_PROVIDER_OR_PRODUCER_FORMAT;
-        } else {
-          requiresErrorMessageFormat = requiresProvision
-              ? REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_FORMAT
-              : REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_OR_PRODUCER_FORMAT;
+      /**
+       * Returns the binding declarations that can be reported for {@code resolvedBindings}, indexed
+       * by the component that owns each declaration.
+       *
+       * <p>Contains all {@link MultibindingDeclaration}s, {@link SubcomponentDeclaration}s, and
+       * {@link OptionalBindingDeclaration}s within {@code resolvedBindings}, as well as all {@link
+       * ContributionBinding}s with present {@linkplain BindingDeclaration#bindingElement() binding
+       * elements}.
+       *
+       *
+       * <p>For other bindings without binding elements, such as the {@link
+       * ContributionBinding.Kind#SYNTHETIC_MULTIBOUND_KINDS}, includes the conflicting declarations
+       * in their resolved dependencies.
+       */
+      private ImmutableSetMultimap<ComponentDescriptor, BindingDeclaration>
+          reportableDeclarations() {
+        ImmutableSetMultimap.Builder<ComponentDescriptor, BindingDeclaration> declarations =
+            ImmutableSetMultimap.builder();
+
+        Queue<ResolvedBindings> queue = new ArrayDeque<>();
+        queue.add(resolvedBindings());
+
+        while (!queue.isEmpty()) {
+          ResolvedBindings queued = queue.remove();
+          declarations
+              .putAll(queued.owningComponent(), queued.multibindingDeclarations())
+              .putAll(queued.owningComponent(), queued.subcomponentDeclarations())
+              .putAll(queued.owningComponent(), queued.optionalBindingDeclarations());
+          queued
+              .allContributionBindings()
+              .asMap()
+              .forEach(
+                  (owningComponent, bindings) -> {
+                    BindingGraph owningGraph =
+                        componentTreePath().graphForComponent(owningComponent);
+                    for (ContributionBinding binding : bindings) {
+                      if (bindingDeclarationFormatter.canFormat(binding)) {
+                        declarations.put(owningComponent, binding);
+                      } else {
+                        queue.addAll(owningGraph.resolvedDependencies(binding));
+                      }
+                    }
+                  });
         }
+
+        return declarations.build();
+      }
+
+      private void reportNullableBindingForNonNullableRequest(ContributionBinding binding) {
+        // Note: the method signature will include the @Nullable in it!
+        /* TODO(sameb): Sometimes javac doesn't include the Element in its output.
+         * (Maybe this happens if the code was already compiled before this point?)
+         * ... we manually print out the request in that case, otherwise the error
+         * message is kind of useless. */
+        FluentIterable<ContributionBinding> dependentContributions =
+            FluentIterable.from(dependentBindings()).filter(ContributionBinding.class);
+        report(owningGraph(dependentContributions.append(binding)))
+            .addItem(
+                nullableToNonNullable(
+                        TypeName.get(dependencyRequest().key().type()).toString(),
+                        bindingDeclarationFormatter.format(binding))
+                    + "\n at: "
+                    + formatDependencyTrace(),
+                compilerOptions.nullableValidationKind(),
+                entryPointElement());
+      }
+
+      private void validateMapKeys(
+          ContributionBinding binding, ComponentDescriptor owningComponent) {
+        checkArgument(
+            binding.bindingKind().equals(SYNTHETIC_MULTIBOUND_MAP),
+            "binding must be a synthetic multibound map: %s",
+            binding);
+        ImmutableSet<ContributionBinding> multibindingContributions =
+            componentTreePath()
+                .graphForComponent(owningComponent)
+                .resolvedDependencies(binding)
+                .stream()
+                .map(ResolvedBindings::contributionBinding)
+                .collect(toImmutableSet());
+        validateMapKeySet(multibindingContributions);
+        validateMapKeyAnnotationTypes(multibindingContributions);
       }
-      StringBuilder errorMessage =
-          new StringBuilder(
-              String.format(requiresErrorMessageFormat, formatCurrentDependencyRequestKey(path)));
-      if (key.isValidMembersInjectionKey()) {
-        Optional<MembersInjectionBinding> membersInjectionBinding =
-            injectBindingRegistry.getOrFindMembersInjectionBinding(key);
-        if (membersInjectionBinding.isPresent()
-            && !membersInjectionBinding.get().injectionSites().isEmpty()) {
-          errorMessage.append(" ");
-          errorMessage.append(ErrorMessages.MEMBERS_INJECTION_DOES_NOT_IMPLY_PROVISION);
+
+      /**
+       * Reports errors if there is more than one map binding contribution with the same map key.
+       */
+      private void validateMapKeySet(Set<ContributionBinding> mapBindingContributions) {
+        for (Collection<ContributionBinding> mapBindingsForMapKey :
+            indexMapBindingsByMapKey(mapBindingContributions).asMap().values()) {
+          if (mapBindingsForMapKey.size() > 1) {
+            reportDuplicateMapKeys(mapBindingsForMapKey);
+          }
         }
       }
-      return errorMessage.append('\n');
-    }
 
-    private void reportMissingBinding(DependencyPath path) {
-      StringBuilder errorMessage =
-          requiresErrorMessageBase(path).append(dependencyRequestFormatter.toDependencyTrace(path));
-      for (String suggestion :
-          MissingBindingSuggestions.forKey(
-              topLevelGraph(), path.current().dependencyRequest().bindingKey())) {
-        errorMessage.append('\n').append(suggestion);
+      /**
+       * Reports errors if there is more than one {@link MapKey} annotation type within the map
+       * binding contributions' map keys.
+       */
+      private void validateMapKeyAnnotationTypes(Set<ContributionBinding> mapBindingContributions) {
+        ImmutableSetMultimap<Equivalence.Wrapper<DeclaredType>, ContributionBinding>
+            mapBindingsByAnnotationType = indexMapBindingsByAnnotationType(mapBindingContributions);
+        if (mapBindingsByAnnotationType.keySet().size() > 1) {
+          reportInconsistentMapKeyAnnotations(mapBindingsByAnnotationType);
+        }
       }
-      topLevelReport().addError(errorMessage.toString(), path.entryPointElement());
-    }
 
-    @SuppressWarnings("resource") // Appendable is a StringBuilder.
-    private void reportDependsOnProductionExecutor(DependencyPath path) {
-      reportBuilder.addError(
-          String.format(
-              DEPENDS_ON_PRODUCTION_EXECUTOR_FORMAT, formatCurrentDependencyRequestKey(path)),
-          path.entryPointElement());
-    }
+      /** Reports errors if a members injection binding is invalid. */
+      // TODO(dpb): Can this be done while validating @Inject?
+      private void validateMembersInjectionBinding(MembersInjectionBinding binding) {
+        binding.key().type().accept(membersInjectionBindingValidator, binding);
+      }
 
-    @SuppressWarnings("resource") // Appendable is a StringBuilder.
-    private void reportDuplicateBindings(DependencyPath path) {
-      ResolvedBindings resolvedBindings = path.current().resolvedBindings();
-      if (FluentIterable.from(resolvedBindings.contributionBindings())
-          .transform(ContributionBinding::bindingKind)
-          // TODO(dpb): Kill with fire.
-          .anyMatch(
-              kind -> SYNTHETIC_MULTIBOUND_KINDS.contains(kind) || SYNTHETIC_MAP.equals(kind))) {
-        // If any of the duplicate bindings results from multibinding contributions or declarations,
-        // report the conflict using those contributions and declarations.
-        reportMultipleContributionTypes(path);
-        return;
+      private final TypeVisitor<Void, MembersInjectionBinding> membersInjectionBindingValidator =
+          new SimpleTypeVisitor8<Void, MembersInjectionBinding>() {
+            @Override
+            protected Void defaultAction(TypeMirror e, MembersInjectionBinding p) {
+              report(currentGraph())
+                  .addError("Invalid members injection request.", p.membersInjectedType());
+              return null;
+            }
+
+            @Override
+            public Void visitDeclared(DeclaredType type, MembersInjectionBinding binding) {
+              // If the key has type arguments, validate that each type argument is declared.
+              // Otherwise the type argument may be a wildcard (or other type), and we can't
+              // resolve that to actual types.  If the arg was an array, validate the type
+              // of the array.
+              for (TypeMirror arg : type.getTypeArguments()) {
+                boolean declared =
+                    arg.accept(
+                        new SimpleTypeVisitor8<Boolean, Void>(false) {
+                          @Override
+                          public Boolean visitArray(ArrayType t, Void p) {
+                            return t.getComponentType()
+                                .accept(
+                                    new SimpleTypeVisitor8<Boolean, Void>(false) {
+                                      @Override
+                                      public Boolean visitDeclared(DeclaredType t, Void p) {
+                                        for (TypeMirror arg : t.getTypeArguments()) {
+                                          if (!arg.accept(this, null)) {
+                                            return false;
+                                          }
+                                        }
+                                        return true;
+                                      }
+
+                                      @Override
+                                      public Boolean visitArray(ArrayType t, Void p) {
+                                        return t.getComponentType().accept(this, null);
+                                      }
+
+                                      @Override
+                                      public Boolean visitPrimitive(PrimitiveType t, Void p) {
+                                        return true;
+                                      }
+                                    },
+                                    null);
+                          }
+
+                          @Override
+                          public Boolean visitDeclared(DeclaredType t, Void p) {
+                            return true;
+                          }
+                        },
+                        null);
+                if (!declared) {
+                  reportErrorAtEntryPoint(
+                      MEMBERS_INJECTION_WITH_UNBOUNDED_TYPE,
+                      arg.toString(),
+                      type.toString(),
+                      formatDependencyTrace());
+                  return null;
+                }
+              }
+
+              TypeElement element = MoreElements.asType(type.asElement());
+              // Also validate that the key is not the erasure of a generic type.
+              // If it is, that means the user referred to Foo<T> as just 'Foo',
+              // which we don't allow.  (This is a judgement call -- we *could*
+              // allow it and instantiate the type bounds... but we don't.)
+              if (!MoreTypes.asDeclared(element.asType()).getTypeArguments().isEmpty()
+                  && types.isSameType(types.erasure(element.asType()), type)) {
+                reportErrorAtEntryPoint(
+                    MEMBERS_INJECTION_WITH_RAW_TYPE, type.toString(), formatDependencyTrace());
+              }
+              return null;
+            }
+          };
+
+      // TODO(b/29509141): Clarify the error.
+      private void reportProviderMayNotDependOnProducer(ContributionBinding productionBinding) {
+        if (atEntryPoint()) {
+          reportErrorAtEntryPoint(
+              PROVIDER_ENTRY_POINT_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT,
+              formatCurrentDependencyRequestKey());
+        } else {
+          // TODO(beder): Consider displaying all dependent provisions in the error message. If we
+          // do that, should we display all productions that depend on them also?
+          reportErrorAtEntryPoint(
+              owningGraph(provisionsDependingOnLatestRequest().append(productionBinding)),
+              PROVIDER_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT,
+              provisionsDependingOnLatestRequest().iterator().next().key());
+        }
       }
-      StringBuilder builder = new StringBuilder();
-      new Formatter(builder)
-          .format(DUPLICATE_BINDINGS_FOR_KEY_FORMAT, formatCurrentDependencyRequestKey(path));
-      ResolvedBindings inlined = inlineContributionsWithoutBindingElements(resolvedBindings);
-      ImmutableSet<ContributionBinding> duplicateBindings = inlined.contributionBindings();
-      Set<BindingDeclaration> conflictingDeclarations =
-          Sets.union(duplicateBindings, inlined.subcomponentDeclarations());
-      bindingDeclarationFormatter.formatIndentedList(
-          builder, conflictingDeclarations, 1, DUPLICATE_SIZE_LIMIT);
-      owningReportBuilder(duplicateBindings).addError(builder.toString(), path.entryPointElement());
-    }
 
-    /**
-     * Returns the report builder for the rootmost component that contains any of the {@code
-     * bindings}.
-     */
-    private ValidationReport.Builder<TypeElement> owningReportBuilder(
-        Iterable<ContributionBinding> bindings) {
-      ImmutableSet.Builder<ComponentDescriptor> owningComponentsBuilder = ImmutableSet.builder();
-      for (ContributionBinding binding : bindings) {
-        ResolvedBindings resolvedBindings =
-            subject.resolvedBindings().get(BindingKey.contribution(binding.key()));
-        owningComponentsBuilder.addAll(
-            resolvedBindings.allContributionBindings().inverse().get(binding));
+      /**
+       * Descriptive portion of the error message for when the given request has no binding.
+       * Currently, the only other portions of the message are the dependency path, line number and
+       * filename.
+       */
+      private StringBuilder requiresErrorMessageBase() {
+        Key key = dependencyRequest().key();
+        String requiresErrorMessageFormat;
+        // TODO(dpb): Check for wildcard injection somewhere else first?
+        if (key.type().getKind().equals(TypeKind.WILDCARD)) {
+          requiresErrorMessageFormat = CANNOT_INJECT_WILDCARD_TYPE;
+        } else {
+          boolean requiresProvision = doesPathRequireProvisionOnly();
+          if (!key.isValidImplicitProvisionKey(types)) {
+            requiresErrorMessageFormat =
+                requiresProvision ? REQUIRES_PROVIDER_FORMAT : REQUIRES_PROVIDER_OR_PRODUCER_FORMAT;
+          } else {
+            requiresErrorMessageFormat =
+                requiresProvision
+                    ? REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_FORMAT
+                    : REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_OR_PRODUCER_FORMAT;
+          }
+        }
+        StringBuilder errorMessage =
+            new StringBuilder(
+                String.format(requiresErrorMessageFormat, formatCurrentDependencyRequestKey()));
+        if (key.isValidMembersInjectionKey()) {
+          Optional<MembersInjectionBinding> membersInjectionBinding =
+              injectBindingRegistry.getOrFindMembersInjectionBinding(key);
+          if (membersInjectionBinding.isPresent()
+              && !membersInjectionBinding.get().injectionSites().isEmpty()) {
+            errorMessage.append(" ");
+            errorMessage.append(ErrorMessages.MEMBERS_INJECTION_DOES_NOT_IMPLY_PROVISION);
+          }
+        }
+        return errorMessage.append('\n');
       }
-      ImmutableSet<ComponentDescriptor> owningComponents = owningComponentsBuilder.build();
-      for (Validation validation : validationPath()) {
-        if (owningComponents.contains(validation.subject.componentDescriptor())) {
-          return validation.reportBuilder;
+
+      private void reportMissingBinding() {
+        StringBuilder errorMessage = requiresErrorMessageBase().append(formatDependencyTrace());
+        for (String suggestion :
+            MissingBindingSuggestions.forKey(rootGraph, dependencyRequest().bindingKey())) {
+          errorMessage.append('\n').append(suggestion);
         }
+        reportErrorAtEntryPoint(rootGraph, errorMessage.toString());
       }
-      throw new AssertionError("cannot find owning component for bindings: " + bindings);
-    }
 
-    /**
-     * The path from the {@link Validation} of the root graph down to this {@link Validation}.
-     */
-    private ImmutableList<Validation> validationPath() {
-      ImmutableList.Builder<Validation> validationPath = ImmutableList.builder();
-      for (Optional<Validation> validation = Optional.of(this);
-          validation.isPresent();
-          validation = validation.get().parent) {
-        validationPath.add(validation.get());
+      @SuppressWarnings("resource") // Appendable is a StringBuilder.
+      private void reportDependsOnProductionExecutor() {
+        reportErrorAtEntryPoint(
+            DEPENDS_ON_PRODUCTION_EXECUTOR_FORMAT, formatCurrentDependencyRequestKey());
       }
-      return validationPath.build().reverse();
-    }
 
-    @SuppressWarnings("resource") // Appendable is a StringBuilder.
-    private void reportMultipleContributionTypes(DependencyPath path) {
-      StringBuilder builder = new StringBuilder();
-      new Formatter(builder)
-          .format(
-              MULTIPLE_CONTRIBUTION_TYPES_FOR_KEY_FORMAT, formatCurrentDependencyRequestKey(path));
-      ResolvedBindings resolvedBindings = path.current().resolvedBindings();
-      ImmutableListMultimap<ContributionType, BindingDeclaration> declarationsByType =
-          declarationsByType(resolvedBindings);
-      verify(
-          declarationsByType.keySet().size() > 1,
-          "expected multiple contribution types for %s: %s",
-          resolvedBindings.bindingKey(),
-          declarationsByType);
-      for (ContributionType contributionType :
-          Ordering.natural().immutableSortedCopy(declarationsByType.keySet())) {
-        builder.append(INDENT);
-        builder.append(formatContributionType(contributionType));
-        builder.append(" bindings and declarations:");
+      @SuppressWarnings("resource") // Appendable is a StringBuilder.
+      private void reportDuplicateBindings() {
+        // If any of the duplicate bindings results from multibinding contributions or declarations,
+        // report the conflict using those contributions and declarations.
+        if (resolvedBindings()
+            .contributionBindings()
+            .stream()
+            .map(ContributionBinding::bindingKind)
+            // TODO(dpb): Kill with fire.
+            .anyMatch(
+                kind -> SYNTHETIC_MULTIBOUND_KINDS.contains(kind) || SYNTHETIC_MAP.equals(kind))) {
+          reportMultipleContributionTypes();
+          return;
+        }
+        StringBuilder builder = new StringBuilder();
+        new Formatter(builder)
+            .format(DUPLICATE_BINDINGS_FOR_KEY_FORMAT, formatCurrentDependencyRequestKey());
+        ImmutableSetMultimap<ComponentDescriptor, BindingDeclaration> duplicateDeclarations =
+            reportableDeclarations();
         bindingDeclarationFormatter.formatIndentedList(
-            builder, declarationsByType.get(contributionType), 2, DUPLICATE_SIZE_LIMIT);
-        builder.append('\n');
+            builder, duplicateDeclarations.values(), 1, DUPLICATE_SIZE_LIMIT);
+        reportErrorAtEntryPoint(
+            componentTreePath().rootmostGraph(duplicateDeclarations.keySet()), builder.toString());
       }
-      owningReportBuilder(resolvedBindings.contributionBindings())
-          .addError(builder.toString(), path.entryPointElement());
-    }
 
-    private void reportDuplicateMapKeys(
-        DependencyPath path, Collection<ContributionBinding> mapBindings) {
-      StringBuilder builder = new StringBuilder();
-      builder.append(duplicateMapKeysError(formatCurrentDependencyRequestKey(path)));
-      bindingDeclarationFormatter.formatIndentedList(builder, mapBindings, 1, DUPLICATE_SIZE_LIMIT);
-      owningReportBuilder(mapBindings).addError(builder.toString(), path.entryPointElement());
-    }
+      @SuppressWarnings("resource") // Appendable is a StringBuilder.
+      private void reportMultipleContributionTypes() {
+        StringBuilder builder = new StringBuilder();
+        new Formatter(builder)
+            .format(
+                MULTIPLE_CONTRIBUTION_TYPES_FOR_KEY_FORMAT, formatCurrentDependencyRequestKey());
+        ImmutableSetMultimap<ComponentDescriptor, BindingDeclaration> duplicateDeclarations =
+            reportableDeclarations();
+        ImmutableListMultimap<ContributionType, BindingDeclaration> duplicateDeclarationsByType =
+            Multimaps.index(
+                duplicateDeclarations.values(),
+                declaration ->
+                    declaration instanceof HasContributionType
+                        ? ((HasContributionType) declaration).contributionType()
+                        : ContributionType.UNIQUE);
+        verify(
+            duplicateDeclarationsByType.keySet().size() > 1,
+            "expected multiple contribution types for %s: %s",
+            dependencyRequest().bindingKey(),
+            duplicateDeclarationsByType);
+        ImmutableSortedMap.copyOf(Multimaps.asMap(duplicateDeclarationsByType))
+            .forEach(
+                (contributionType, declarations) -> {
+                  builder.append(INDENT);
+                  builder.append(formatContributionType(contributionType));
+                  builder.append(" bindings and declarations:");
+                  bindingDeclarationFormatter.formatIndentedList(
+                      builder, declarations, 2, DUPLICATE_SIZE_LIMIT);
+                  builder.append('\n');
+                });
+        reportErrorAtEntryPoint(
+            componentTreePath().rootmostGraph(duplicateDeclarations.keySet()), builder.toString());
+      }
 
-    private void reportInconsistentMapKeyAnnotations(
-        DependencyPath path,
-        Multimap<Equivalence.Wrapper<DeclaredType>, ContributionBinding>
-            mapBindingsByAnnotationType) {
-      StringBuilder builder =
-          new StringBuilder(
-              inconsistentMapKeyAnnotationsError(formatCurrentDependencyRequestKey(path)));
-      for (Map.Entry<Equivalence.Wrapper<DeclaredType>, Collection<ContributionBinding>> entry :
-          mapBindingsByAnnotationType.asMap().entrySet()) {
-        DeclaredType annotationType = entry.getKey().get();
-        Collection<ContributionBinding> bindings = entry.getValue();
-
-        builder
-            .append('\n')
-            .append(INDENT)
-            .append(annotationType)
-            .append(':');
-
-        bindingDeclarationFormatter.formatIndentedList(builder, bindings, 2, DUPLICATE_SIZE_LIMIT);
+      private void reportDuplicateMapKeys(Collection<ContributionBinding> mapBindings) {
+        StringBuilder builder = new StringBuilder();
+        builder.append(duplicateMapKeysError(formatCurrentDependencyRequestKey()));
+        bindingDeclarationFormatter.formatIndentedList(
+            builder, mapBindings, 1, DUPLICATE_SIZE_LIMIT);
+        reportErrorAtEntryPoint(owningGraph(mapBindings), builder.toString());
       }
-      owningReportBuilder(mapBindingsByAnnotationType.values())
-          .addError(builder.toString(), path.entryPointElement());
-    }
 
-    private void reportCycle(DependencyPath path) {
-      if (!providersBreakingCycle(path).isEmpty()) {
-        return;
+      private void reportInconsistentMapKeyAnnotations(
+          Multimap<Equivalence.Wrapper<DeclaredType>, ContributionBinding>
+              mapBindingsByAnnotationType) {
+        StringBuilder builder =
+            new StringBuilder(
+                inconsistentMapKeyAnnotationsError(formatCurrentDependencyRequestKey()));
+        for (Map.Entry<Equivalence.Wrapper<DeclaredType>, Collection<ContributionBinding>> entry :
+            mapBindingsByAnnotationType.asMap().entrySet()) {
+          DeclaredType annotationType = entry.getKey().get();
+          Collection<ContributionBinding> bindings = entry.getValue();
+
+          builder.append('\n').append(INDENT).append(annotationType).append(':');
+
+          bindingDeclarationFormatter.formatIndentedList(
+              builder, bindings, 2, DUPLICATE_SIZE_LIMIT);
+        }
+        reportErrorAtEntryPoint(
+            owningGraph(mapBindingsByAnnotationType.values()), builder.toString());
       }
+
       // TODO(cgruber): Provide a hint for the start and end of the cycle.
-      owningReportBuilder(
-              path.cycle()
-                  .transform(ResolvedRequest::resolvedBindings)
-                  .transformAndConcat(ResolvedBindings::contributionBindings))
-          .addItem(
-              String.format(
-                  CONTAINS_DEPENDENCY_CYCLE_FORMAT,
-                  dependencyRequestFormatter.toDependencyTrace(path)),
-              ERROR,
-              path.entryPointElement());
-    }
+      private void reportDependencyCycle() {
+        if (!providersBreakingCycle().isEmpty()) {
+          return;
+        }
+        ImmutableList.Builder<ContributionBinding> cycleBindings = ImmutableList.builder();
+        cycleDependencyTrace()
+            .forEach(
+                (dependencyRequest, resolvedBindings) ->
+                    cycleBindings.addAll(resolvedBindings.contributionBindings()));
+        reportErrorAtEntryPoint(
+            owningGraph(cycleBindings.build()),
+            CONTAINS_DEPENDENCY_CYCLE_FORMAT,
+            formatDependencyTrace());
+      }
 
-    /**
-     * Returns any steps in a dependency cycle that "break" the cycle. These are any {@link
-     * Provider}, {@link Lazy}, or {@code Map<K, Provider<V>>} requests after the first request in
-     * the cycle.
-     *
-     * <p>If an implicit {@link Provider} dependency on {@code Map<K, Provider<V>>} is immediately
-     * preceded by a dependency on {@code Map<K, V>}, which means that the map's {@link Provider}s'
-     * {@link Provider#get() get()} methods are called during provision and so the cycle is not
-     * really broken.
-     *
-     * <p>A request for an instance of {@code Optional} breaks the cycle if a request for the {@code
-     * Optional}'s type parameter would.
-     */
-    private ImmutableSet<DependencyRequest> providersBreakingCycle(DependencyPath path) {
-      return path.cycle()
-          .skip(1)
-          .filter(
-              new Predicate<ResolvedRequest>() {
-                @Override
-                public boolean apply(ResolvedRequest resolvedRequest) {
-                  DependencyRequest dependencyRequest = resolvedRequest.dependencyRequest();
-                  if (dependencyRequest.requestElement().isPresent()) {
-                    // Non-synthetic request
-                    return breaksCycle(dependencyRequest.key().type(), dependencyRequest.kind());
-                  } else if (!resolvedRequest
-                      .dependentResolvedBindings()
-                      .transform(ResolvedBindings::optionalBindingDeclarations)
-                      .or(ImmutableSet.of())
-                      .isEmpty()) {
-                    // Synthetic request from a @BindsOptionalOf: test the type inside the Optional.
-                    // Optional<Provider or Lazy or Provider of Lazy> breaks the cycle.
-                    TypeMirror requestedOptionalType =
-                        resolvedRequest.dependentResolvedBindings().get().key().type();
+      /**
+       * Returns any steps in a dependency cycle that "break" the cycle. These are any nonsynthetic
+       * {@link Provider}, {@link Lazy}, or {@code Map<K, Provider<V>>} requests after the first
+       * request in the cycle.
+       *
+       * <p>The synthetic request for a {@code Map<K, Provider<V>>} as a dependency of a multibound
+       * {@code Map<K, V>} does not break cycles because the map's {@link Provider}s' {@link
+       * Provider#get() get()} methods are called during provision.
+       *
+       * <p>A request for an instance of {@code Optional} breaks the cycle if it is resolved to a
+       * {@link BindsOptionalOf} binding and a request for the {@code Optional}'s type parameter
+       * would.
+       */
+      private ImmutableSet<DependencyRequest> providersBreakingCycle() {
+        ImmutableSet.Builder<DependencyRequest> providers = ImmutableSet.builder();
+        AtomicBoolean first = new AtomicBoolean(true);
+        cycleDependencyTrace()
+            .forEach(
+                (dependencyRequest, resolvedBindings) -> {
+                  // Skip the first request in the cycle and any synthetic requests.
+                  if (first.getAndSet(false) || !dependencyRequest.requestElement().isPresent()) {
+                    return;
+                  }
+
+                  if (breaksCycle(dependencyRequest.key().type(), dependencyRequest.kind())) {
+                    providers.add(dependencyRequest);
+                  } else if (!resolvedBindings.optionalBindingDeclarations().isEmpty()) {
+                    /* Request resolved to a @BindsOptionalOf binding, so test the type inside the
+                     * Optional. Optional<Provider or Lazy or Provider of Lazy or Map of Provider>
+                     * breaks the cycle. */
                     DependencyRequest.KindAndType kindAndType =
                         DependencyRequest.extractKindAndType(
-                            OptionalType.from(requestedOptionalType).valueType());
-                    return breaksCycle(kindAndType.type(), kindAndType.kind());
-                  } else {
-                    // Other synthetic requests.
-                    return false;
+                            OptionalType.from(dependencyRequest.key()).valueType());
+                    if (breaksCycle(kindAndType.type(), kindAndType.kind())) {
+                      providers.add(dependencyRequest);
+                    }
                   }
-                }
+                });
+        return providers.build();
+      }
 
-                private boolean breaksCycle(
-                    TypeMirror requestedType, DependencyRequest.Kind requestKind) {
-                  switch (requestKind) {
-                    case PROVIDER:
-                    case LAZY:
-                    case PROVIDER_OF_LAZY:
-                      return true;
+      private boolean breaksCycle(TypeMirror requestedType, DependencyRequest.Kind requestKind) {
+        switch (requestKind) {
+          case PROVIDER:
+          case LAZY:
+          case PROVIDER_OF_LAZY:
+            return true;
 
-                    case INSTANCE:
-                      return MapType.isMap(requestedType)
-                          && MapType.from(requestedType).valuesAreTypeOf(Provider.class);
+          case INSTANCE:
+            return MapType.isMap(requestedType)
+                && MapType.from(requestedType).valuesAreTypeOf(Provider.class);
 
-                    default:
-                      return false;
-                  }
-                }
-              })
-          .transform(ResolvedRequest::dependencyRequest)
-          .toSet();
+          default:
+            return false;
+        }
+      }
+
+      /**
+       * Returns whether the given dependency path would require the most recent request to be
+       * resolved by only provision bindings.
+       */
+      private boolean doesPathRequireProvisionOnly() {
+        // The second-most-recent bindings determine whether the most recent one must be a
+        // provision.
+        if (!atEntryPoint()) {
+          return !provisionsDependingOnLatestRequest().isEmpty();
+        }
+
+        // Check the request kind for entry points.
+        switch (dependencyRequest().kind()) {
+          case INSTANCE:
+          case PROVIDER:
+          case LAZY:
+          case MEMBERS_INJECTOR:
+            return true;
+          case PRODUCER:
+          case PRODUCED:
+          case FUTURE:
+            return false;
+          default:
+            throw new AssertionError();
+        }
+      }
+
+      /**
+       * Returns any provision bindings resolved for the second-most-recent request in the given
+       * path; that is, returns those provision bindings that depend on the latest request in the
+       * path.
+       */
+      private FluentIterable<ContributionBinding> provisionsDependingOnLatestRequest() {
+        return FluentIterable.from(dependentBindings())
+            .filter(ContributionBinding.class)
+            .filter(PROVISION::isOfType);
+      }
+
+      private String formatCurrentDependencyRequestKey() {
+        return keyFormatter.format(dependencyRequest().key());
+      }
     }
   }
 
-  ValidationReport<TypeElement> validate(BindingGraph subject) {
-    Validation validation = new Validation(subject);
-    validation.validateSubgraph();
+  ValidationReport<TypeElement> validate(BindingGraph graph) {
+    ComponentValidation validation = new ComponentValidation(graph);
+    validation.traverseComponents();
     return validation.buildReport();
   }
 
@@ -1264,45 +1063,7 @@ private void appendIndentedComponentsList(StringBuilder message, Iterable<TypeEl
    * a scoping annotation.
    */
   private ImmutableSet<TypeElement> scopedTypesIn(Set<TypeElement> types) {
-    return FluentIterable.from(types).filter(type -> !Scope.scopesOf(type).isEmpty()).toSet();
-  }
-
-  /**
-   * Returns whether the given dependency path would require the most recent request to be resolved
-   * by only provision bindings.
-   */
-  private boolean doesPathRequireProvisionOnly(DependencyPath path) {
-    if (path.size() == 1) {
-      // if this is an entry-point, then we check the request
-      switch (path.current().dependencyRequest().kind()) {
-        case INSTANCE:
-        case PROVIDER:
-        case LAZY:
-        case MEMBERS_INJECTOR:
-          return true;
-        case PRODUCER:
-        case PRODUCED:
-        case FUTURE:
-          return false;
-        default:
-          throw new AssertionError();
-      }
-    }
-    // otherwise, the second-most-recent bindings determine whether the most recent one must be a
-    // provision
-    return !provisionsDependingOnLatestRequest(path).isEmpty();
-  }
-
-  /**
-   * Returns any provision bindings resolved for the second-most-recent request in the given path;
-   * that is, returns those provision bindings that depend on the latest request in the path.
-   */
-  private FluentIterable<ContributionBinding> provisionsDependingOnLatestRequest(
-      DependencyPath path) {
-    return path.current()
-        .dependentBindings()
-        .filter(ContributionBinding.class)
-        .filter(PROVISION::isOfType);
+    return types.stream().filter(type -> !scopesOf(type).isEmpty()).collect(toImmutableSet());
   }
 
   private String formatContributionType(ContributionType type) {
@@ -1318,40 +1079,4 @@ private String formatContributionType(ContributionType type) {
         throw new IllegalStateException("Unknown binding type: " + type);
     }
   }
-
-  private String formatCurrentDependencyRequestKey(DependencyPath path) {
-    return keyFormatter.format(path.current().dependencyRequest().key());
-  }
-
-  @AutoValue
-  abstract static class ResolvedRequest {
-
-    abstract DependencyRequest dependencyRequest();
-
-    abstract ResolvedBindings resolvedBindings();
-
-    /**
-     * The {@link #resolvedBindings()} of the previous entry in the {@link DependencyPath}. One of
-     * these bindings depends directly on {@link #dependencyRequest()}.
-     */
-    abstract Optional<ResolvedBindings> dependentResolvedBindings();
-
-    /**
-     * Returns the bindings that depend on this {@linkplain #dependencyRequest() dependency
-     * request}.
-     */
-    FluentIterable<? extends Binding> dependentBindings() {
-      return FluentIterable.from(dependentResolvedBindings().asSet())
-          .transformAndConcat(ResolvedBindings::bindings)
-          .filter(binding -> binding.dependencies().contains(dependencyRequest()));
-    }
-
-    private static ResolvedRequest create(
-        DependencyRequest request,
-        ResolvedBindings resolvedBindings,
-        Optional<ResolvedBindings> dependentBindings) {
-      return new AutoValue_BindingGraphValidator_ResolvedRequest(
-          request, resolvedBindings, dependentBindings);
-    }
-  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingMethodValidator.java
index abe98cff0..89be40108 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingMethodValidator.java
@@ -460,7 +460,7 @@ private ExceptionSuperclass(Class<? extends Exception> superclass, String errorM
      * Adds an error if the method declares throws anything but an {@link Error} or an appropriate
      * subtype of {@link Exception}.
      *
-     * <p>This method is overridden in {@link #NONE}.
+     * <p>This method is overridden in {@link #NO_EXCEPTIONS}.
      */
     protected void checkThrows(
         BindingMethodValidator validator, ValidationReport.Builder<ExecutableElement> builder) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java b/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java
index cdc8d8f09..7b2038e5d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java
@@ -19,6 +19,7 @@
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.Util.getUnimplementedMethods;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.STATIC;
@@ -109,7 +110,7 @@
     ExecutableElement buildMethod = null;
     Multimap<Equivalence.Wrapper<TypeMirror>, ExecutableElement> methodsPerParam =
         LinkedHashMultimap.create();
-    for (ExecutableElement method : Util.getUnimplementedMethods(elements, subject)) {
+    for (ExecutableElement method : getUnimplementedMethods(elements, types, subject)) {
       ExecutableType resolvedMethodType =
           MoreTypes.asExecutable(types.asMemberOf(MoreTypes.asDeclared(subject.asType()), method));
       TypeMirror returnType = resolvedMethodType.getReturnType();
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index 1d19ee815..be3a2ced6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -27,12 +27,15 @@
 import static dagger.internal.codegen.ConfigurationAnnotations.isSubcomponent;
 import static dagger.internal.codegen.ConfigurationAnnotations.isSubcomponentBuilder;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
+import static dagger.internal.codegen.Util.getUnimplementedMethods;
+import static dagger.internal.codegen.Util.toImmutableSet;
 import static javax.lang.model.type.TypeKind.DECLARED;
 import static javax.lang.model.type.TypeKind.VOID;
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
+import com.google.auto.value.extension.memoized.Memoized;
 import com.google.common.base.Optional;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableBiMap;
@@ -292,7 +295,7 @@ private static void addTransitiveModules(
   /**
    * All {@linkplain Subcomponent direct child} components that are declared by an entry point
    * method. This is equivalent to the set of values from {@link #subcomponentsByFactoryMethod()}
-   * and {@link #subcomponentsByBuilderMethod().
+   * and {@link #subcomponentsByBuilderMethod()}.
    */
   ImmutableSet<ComponentDescriptor> subcomponentsFromEntryPoints() {
     return ImmutableSet.<ComponentDescriptor>builder()
@@ -301,17 +304,8 @@ private static void addTransitiveModules(
         .build();
   }
 
-  // TODO(ronshapiro): convert this to use @Memoized
-  private ImmutableBiMap<TypeElement, ComponentDescriptor> subcomponentsByBuilderType;
-
+  @Memoized
   ImmutableBiMap<TypeElement, ComponentDescriptor> subcomponentsByBuilderType() {
-    if (subcomponentsByBuilderType == null) {
-      subcomponentsByBuilderType = computeSubcomponentsByBuilderType();
-    }
-    return subcomponentsByBuilderType;
-  }
-
-  private ImmutableBiMap<TypeElement, ComponentDescriptor> computeSubcomponentsByBuilderType() {
     ImmutableBiMap.Builder<TypeElement, ComponentDescriptor> subcomponentsByBuilderType =
         ImmutableBiMap.builder();
     for (ComponentDescriptor subcomponent : subcomponents()) {
@@ -325,6 +319,16 @@ private static void addTransitiveModules(
 
   abstract ImmutableSet<ComponentMethodDescriptor> componentMethods();
 
+  /** The dependency requests defined by methods on the component type. */
+  ImmutableSet<DependencyRequest> entryPoints() {
+    return componentMethods()
+        .stream()
+        .map(ComponentMethodDescriptor::dependencyRequest)
+        .filter(Optional::isPresent)
+        .map(Optional::get)
+        .collect(toImmutableSet());
+  }
+
   // TODO(gak): Consider making this non-optional and revising the
   // interaction between the spec & generation
   abstract Optional<BuilderSpec> builderSpec();
@@ -485,7 +489,7 @@ private ComponentDescriptor create(
         }
       }
       ImmutableSet<ExecutableElement> unimplementedMethods =
-          Util.getUnimplementedMethods(elements, componentDefinitionType);
+          getUnimplementedMethods(elements, types, componentDefinitionType);
 
       ImmutableSet.Builder<ComponentMethodDescriptor> componentMethodsBuilder =
           ImmutableSet.builder();
@@ -631,7 +635,7 @@ private ComponentMethodDescriptor getDescriptorForComponentMethod(
         return Optional.absent();
       }
       TypeElement element = MoreTypes.asTypeElement(builderType.get());
-      ImmutableSet<ExecutableElement> methods = Util.getUnimplementedMethods(elements, element);
+      ImmutableSet<ExecutableElement> methods = getUnimplementedMethods(elements, types, element);
       ImmutableMap.Builder<TypeElement, ExecutableElement> map = ImmutableMap.builder();
       ExecutableElement buildMethod = null;
       for (ExecutableElement method : methods) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index 980f8e36a..b9b646315 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -53,8 +53,7 @@
 
   @Override
   ClassName nameGeneratedType(BindingGraph input) {
-    ClassName componentDefinitionClassName =
-        ClassName.get(input.componentDescriptor().componentDefinitionType());
+    ClassName componentDefinitionClassName = ClassName.get(input.componentType());
     String componentName =
         "Dagger" + Joiner.on('_').join(componentDefinitionClassName.simpleNames());
     return componentDefinitionClassName.topLevelClassName().peerClass(componentName);
@@ -62,7 +61,7 @@ ClassName nameGeneratedType(BindingGraph input) {
 
   @Override
   Optional<? extends Element> getElementForErrorReporting(BindingGraph input) {
-    return Optional.of(input.componentDescriptor().componentDefinitionType());
+    return Optional.of(input.componentType());
   }
 
   @Override
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
index 3d4f062d6..46b07dce3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
@@ -188,9 +188,10 @@ private void generateComponent(BindingGraph bindingGraph) {
 
   /**
    * Returns true if the component's report is clean, its builder report is clean, and all
-   * referenced subcomponent reports & subcomponent builder reports are clean.
+   * referenced subcomponent reports and subcomponent builder reports are clean.
    */
-  private boolean isClean(ComponentValidationReport report,
+  private boolean isClean(
+      ComponentValidationReport report,
       Map<Element, ValidationReport<TypeElement>> builderReportsByComponent,
       Map<Element, ValidationReport<TypeElement>> reportsBySubcomponent,
       Map<Element, ValidationReport<TypeElement>> builderReportsBySubcomponent) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index 0fe526112..2e70a9cef 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -22,6 +22,7 @@
 import com.google.auto.common.BasicAnnotationProcessor;
 import com.google.auto.service.AutoService;
 import com.google.common.collect.ImmutableList;
+import com.google.googlejavaformat.java.filer.FormattingFiler;
 import java.util.Set;
 import javax.annotation.processing.Filer;
 import javax.annotation.processing.Messager;
@@ -61,16 +62,16 @@ public SourceVersion getSupportedSourceVersion() {
     Messager messager = processingEnv.getMessager();
     Types types = processingEnv.getTypeUtils();
     Elements elements = processingEnv.getElementUtils();
-    Filer filer = processingEnv.getFiler();
+    Filer filer = new FormattingFiler(processingEnv.getFiler());
 
     CompilerOptions compilerOptions = CompilerOptions.create(processingEnv, elements);
 
+    KeyFormatter keyFormatter = new KeyFormatter();
     MethodSignatureFormatter methodSignatureFormatter = new MethodSignatureFormatter(types);
     BindingDeclarationFormatter bindingDeclarationFormatter =
-        new BindingDeclarationFormatter(methodSignatureFormatter);
+        new BindingDeclarationFormatter(methodSignatureFormatter, keyFormatter);
     DependencyRequestFormatter dependencyRequestFormatter =
         new DependencyRequestFormatter(types, elements);
-    KeyFormatter keyFormatter = new KeyFormatter();
 
     InjectValidator injectValidator = new InjectValidator(types, elements, compilerOptions);
     InjectValidator injectValidatorWhenGeneratingCode = injectValidator.whenGeneratingCode();
@@ -99,6 +100,7 @@ public SourceVersion getSupportedSourceVersion() {
     MultibindingsValidator multibindingsValidator =
         new MultibindingsValidator(
             elements,
+            types,
             keyFactory,
             keyFormatter,
             methodSignatureFormatter,
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentTreeTraverser.java b/compiler/src/main/java/dagger/internal/codegen/ComponentTreeTraverser.java
new file mode 100644
index 000000000..93dd1e538
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentTreeTraverser.java
@@ -0,0 +1,650 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkState;
+import static com.google.common.base.Predicates.equalTo;
+import static com.google.common.base.Verify.verify;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static com.google.common.collect.Iterables.indexOf;
+import static com.google.common.collect.Iterables.skip;
+import static com.google.common.collect.Multimaps.asMap;
+import static dagger.internal.codegen.BindingKey.contribution;
+import static dagger.internal.codegen.Util.toImmutableSet;
+import static java.util.Spliterator.ORDERED;
+import static java.util.Spliterator.SIZED;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Iterators;
+import com.google.common.collect.LinkedHashMultiset;
+import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
+import java.util.ArrayDeque;
+import java.util.Deque;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.Set;
+import java.util.Spliterators.AbstractSpliterator;
+import java.util.function.BiConsumer;
+import java.util.function.BiFunction;
+import java.util.function.Consumer;
+import java.util.function.Predicate;
+import java.util.stream.Stream;
+import java.util.stream.StreamSupport;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+
+/**
+ * An object that traverses the entire component hierarchy, starting from the root component.
+ *
+ * <p>Subclasses can override {@link #visitComponent(BindingGraph)} to perform custom logic at each
+ * component in the tree, and {@link #visitSubcomponentFactoryMethod(BindingGraph, BindingGraph,
+ * ExecutableElement)} to perform custom logic at each subcomponent factory method.
+ *
+ * <p>Subclasses can override {@link #bindingGraphTraverser(ComponentTreePath, DependencyRequest)}
+ * to traverse each entry point within each component in the tree.
+ */
+public class ComponentTreeTraverser {
+
+  /** The path from the root graph to the currently visited graph. */
+  private final Deque<BindingGraph> bindingGraphPath = new ArrayDeque<>();
+
+  /** Constructs a traverser for a root (component, not subcomponent) binding graph. */
+  public ComponentTreeTraverser(BindingGraph rootGraph) {
+    checkArgument(
+        rootGraph.componentDescriptor().kind().isTopLevel(),
+        "only top-level graphs can be traversed, not %s",
+        rootGraph.componentDescriptor().componentDefinitionType().getQualifiedName());
+    bindingGraphPath.add(rootGraph);
+  }
+
+  /**
+   * Calls {@link #visitComponent(BindingGraph)} for the root component.
+   *
+   * @throws IllegalStateException if a traversal is in progress
+   */
+  public final void traverseComponents() {
+    checkState(bindingGraphPath.size() == 1);
+    visitComponent(bindingGraphPath.getFirst());
+  }
+
+  /**
+   * Called once for each component in a component hierarchy.
+   *
+   * <p>Subclasses can override this method to perform whatever logic is required per component.
+   * They should call the {@code super} implementation if they want to continue the traversal in the
+   * standard order.
+   *
+   * <p>This implementation does the following:
+   *
+   * <ol>
+   *   <li>If this component is installed in its parent by a subcomponent factory method, calls
+   *       {@link #visitSubcomponentFactoryMethod(BindingGraph, BindingGraph, ExecutableElement)}.
+   *   <li>For each entry point in the component, calls {@link #visitEntryPoint(DependencyRequest,
+   *       BindingGraph)}.
+   *   <li>For each child component, calls {@link #visitComponent(BindingGraph)}, updating the
+   *       traversal state.
+   * </ol>
+   *
+   * @param graph the currently visited graph
+   */
+  protected void visitComponent(BindingGraph graph) {
+    if (bindingGraphPath.size() > 1) {
+      BindingGraph parent = Iterators.get(bindingGraphPath.descendingIterator(), 1);
+      ComponentMethodDescriptor childFactoryMethod =
+          parent
+              .componentDescriptor()
+              .subcomponentsByFactoryMethod()
+              .inverse()
+              .get(graph.componentDescriptor());
+      if (childFactoryMethod != null) {
+        visitSubcomponentFactoryMethod(graph, parent, childFactoryMethod.methodElement());
+      }
+    }
+
+    for (DependencyRequest entryPoint : graph.componentDescriptor().entryPoints()) {
+      visitEntryPoint(entryPoint, graph);
+    }
+
+    for (BindingGraph child : graph.subgraphs()) {
+      bindingGraphPath.addLast(child);
+      try {
+        visitComponent(child);
+      } finally {
+        verify(bindingGraphPath.removeLast().equals(child));
+      }
+    }
+  }
+
+  /**
+   * Called if this component was installed in its parent by a subcomponent factory method.
+   *
+   * <p>This implementation does nothing.
+   *
+   * @param graph the currently visited graph
+   * @param parent the parent graph
+   * @param factoryMethod the factory method in the parent component that declares that the current
+   *     component is a child
+   */
+  protected void visitSubcomponentFactoryMethod(
+      BindingGraph graph, BindingGraph parent, ExecutableElement factoryMethod) {}
+
+  /**
+   * Called once for each entry point in a component.
+   *
+   * <p>Subclasses can override this method to perform whatever logic is required per entry point.
+   * They should call the {@code super} implementation if they want to continue the traversal in the
+   * standard order.
+   *
+   * <p>This implementation passes the entry point and the current component tree path to {@link
+   * #bindingGraphTraverser(ComponentTreePath, DependencyRequest)}, and calls {@link
+   * BindingGraphTraverser#traverseDependencies()} on the returned object.
+   *
+   * @param graph the graph for the component that contains the entry point
+   */
+  protected void visitEntryPoint(DependencyRequest entryPoint, BindingGraph graph) {
+    bindingGraphTraverser(componentTreePath(), entryPoint).traverseDependencies();
+  }
+
+  /**
+   * Returns an object that traverses the binding graph starting from an entry point.
+   *
+   * <p>This implementation returns a no-op object that does nothing. Subclasses should override in
+   * order to perform custom logic within the binding graph.
+   *
+   * @param componentPath the path from the root component to the component that includes the entry
+   *     point
+   * @param entryPoint the entry point
+   */
+  protected BindingGraphTraverser bindingGraphTraverser(
+      ComponentTreePath componentPath, DependencyRequest entryPoint) {
+    return new NoOpBindingGraphTraverser(componentPath, entryPoint);
+  }
+
+  /**
+   * Returns an immutable snapshot of the path from the root component to the currently visited
+   * component.
+   */
+  protected final ComponentTreePath componentTreePath() {
+    return new ComponentTreePath(bindingGraphPath);
+  }
+
+  /** An object that traverses the binding graph starting from an entry point. */
+  public static class BindingGraphTraverser {
+
+    private final ComponentTreePath componentTreePath;
+    private final DependencyRequest entryPoint;
+    private final Deque<DependencyRequest> dependencyRequestPath = new ArrayDeque<>();
+    private final Deque<ResolvedBindings> resolvedBindingsPath = new ArrayDeque<>();
+    private final LinkedHashMultiset<BindingKey> bindingKeysInPath = LinkedHashMultiset.create();
+    private final Set<DependencyRequest> visitedDependencyRequests = new HashSet<>();
+
+    /**
+     * Constructs a traverser for an entry point.
+     *
+     * @param componentPath the path from the root component to the component that includes the
+     *     entry point to be traversed
+     * @param entryPoint the entry point to be traversed
+     */
+    public BindingGraphTraverser(ComponentTreePath componentPath, DependencyRequest entryPoint) {
+      this.componentTreePath = componentPath;
+      this.entryPoint = entryPoint;
+    }
+
+    /**
+     * Calls {@link #visitDependencyRequest(DependencyRequest)} for the {@linkplain
+     * #entryPointElement() entry point}.
+     *
+     * @throws IllegalStateException if a traversal is in progress
+     */
+    public void traverseDependencies() {
+      checkState(dependencyRequestPath.isEmpty());
+      checkState(resolvedBindingsPath.isEmpty());
+      checkState(bindingKeysInPath.isEmpty());
+      checkState(visitedDependencyRequests.isEmpty());
+      nextDependencyRequest(entryPoint, currentGraph());
+    }
+
+    /**
+     * Called once for each dependency request that is reachable from an entry point.
+     *
+     * <p>Subclasses can override this method to perform whatever logic is required per dependency
+     * request. They should call the {@code super} implementation if they want to continue the
+     * traversal in the standard order.
+     *
+     * <p>This implementation calls {@link #visitResolvedBindings(ResolvedBindings)} unless the
+     * dependency request introduces a cycle.
+     *
+     * @param dependencyRequest the object returned by {@link #dependencyRequest()}
+     */
+    protected void visitDependencyRequest(DependencyRequest dependencyRequest) {
+      if (!atDependencyCycle()) {
+        visitResolvedBindings(resolvedBindingsPath.getLast());
+      }
+    }
+
+    /**
+     * Called once for each dependency request that is reachable from an entry point.
+     *
+     * <p>Subclasses can override this method to perform whatever logic is required per resolved
+     * bindings. They should call the {@code super} implementation if they want to continue the
+     * traversal in the standard order.
+     *
+     * <p>This implementation calls either {@link #visitMembersInjectionBindings(ResolvedBindings)}
+     * or {@link #visitContributionBindings(ResolvedBindings)}, depending on the binding key kind.
+     *
+     * @param resolvedBindings the object returned by {@link #resolvedBindings()}
+     */
+    protected void visitResolvedBindings(ResolvedBindings resolvedBindings) {
+      switch (resolvedBindings.bindingKey().kind()) {
+        case MEMBERS_INJECTION:
+          visitMembersInjectionBindings(resolvedBindings);
+          break;
+
+        case CONTRIBUTION:
+          visitContributionBindings(resolvedBindings);
+          break;
+      }
+    }
+
+    /**
+     * Called once for each dependency request for a members injector that is reachable from an
+     * entry point.
+     *
+     * <p>Subclasses can override this method to perform whatever logic is required per resolved
+     * members injection bindings. They should call the {@code super} implementation if they want to
+     * continue the traversal in the standard order.
+     *
+     * <p>This implementation calls {@link #visitMembersInjectionBinding(MembersInjectionBinding,
+     * ComponentDescriptor)}.
+     *
+     * @param resolvedBindings the object returned by {@link #resolvedBindings()}
+     */
+    protected void visitMembersInjectionBindings(ResolvedBindings resolvedBindings) {
+      if (!resolvedBindings.contributionBindings().isEmpty()) {
+        // TODO(dpb): How could this ever happen, even in an invalid graph?
+        throw new AssertionError(
+            "members injection binding keys should never have contribution bindings");
+      }
+      if (resolvedBindings.membersInjectionBinding().isPresent()) {
+        visitMembersInjectionBinding(
+            resolvedBindings.membersInjectionBinding().get(),
+            getOnlyElement(resolvedBindings.allMembersInjectionBindings().keySet()));
+      }
+    }
+
+    /**
+     * Called once for each members injection binding that is reachable from an entry point.
+     *
+     * <p>Subclasses can override this method to perform whatever logic is required per members
+     * injection binding. They should call the {@code super} implementation if they want to continue
+     * the traversal in the standard order.
+     *
+     * <p>This implementation calls {@link #visitBinding(Binding, ComponentDescriptor)}.
+     *
+     * @param binding the only value of {@code resolvedBindings().allMembersInjectionBindings()}
+     * @param owningComponent the only key of {@code
+     *     resolvedBindings().allMembersInjectionBindings()}. The binding's dependencies should be
+     *     resolved within this component.
+     */
+    protected void visitMembersInjectionBinding(
+        MembersInjectionBinding binding, ComponentDescriptor owningComponent) {
+      visitBinding(binding, owningComponent);
+    }
+
+    /**
+     * Called once for each dependency request for a contribution that is reachable from an entry
+     * point.
+     *
+     * <p>Subclasses can override this method to perform whatever logic is required per resolved
+     * contribution bindings. They should call the {@code super} implementation if they want to
+     * continue the traversal in the standard order.
+     *
+     * <p>This implementation calls {@link #visitContributionBinding(ContributionBinding,
+     * ComponentDescriptor)} for each contribution binding.
+     *
+     * @param resolvedBindings the object returned by {@link #resolvedBindings()}
+     */
+    protected void visitContributionBindings(ResolvedBindings resolvedBindings) {
+      if (resolvedBindings.membersInjectionBinding().isPresent()) {
+        throw new AssertionError(
+            "contribution binding keys should never have members injection bindings");
+      }
+      asMap(resolvedBindings.allContributionBindings())
+          .forEach(
+              (owningComponent, bindings) -> {
+                bindings.forEach(binding -> visitContributionBinding(binding, owningComponent));
+              });
+    }
+
+    /**
+     * Called once for each contribution binding that is reachable from an entry point.
+     *
+     * <p>Subclasses can override this method to perform whatever logic is required per contribution
+     * binding. They should call the {@code super} implementation if they want to continue the
+     * traversal in the standard order.
+     *
+     * <p>This implementation calls {@link #visitBinding(Binding, ComponentDescriptor)}.
+     *
+     * @param binding a value of {@code resolvedBindings().allContributionBindings()}
+     * @param owningComponent the key of {@code resolvedBindings().allContributionBindings()} for
+     *     {@code binding}. The binding's dependencies should be resolved within this component.
+     */
+    protected void visitContributionBinding(
+        ContributionBinding binding, ComponentDescriptor owningComponent) {
+      visitBinding(binding, owningComponent);
+    }
+
+    /**
+     * Called once for each binding that is reachable from an entry point.
+     *
+     * <p>Subclasses can override this method to perform whatever logic is required per binding.
+     * They should call the {@code super} implementation if they want to continue the traversal in
+     * the standard order.
+     *
+     * <p>This implementation calls {@link #visitDependencyRequest(DependencyRequest)} for each
+     * dependency of the binding, resolved within {@code owningComponent}, that has not already been
+     * visited while traversing the current entry point.
+     *
+     * @param binding a value of {@code resolvedBindings().allBindings()}
+     * @param owningComponent the key of {@code resolvedBindings().allBindings()} for {@code
+     *     binding}. The binding's dependencies should be resolved within this component.
+     */
+    protected void visitBinding(Binding binding, ComponentDescriptor owningComponent) {
+      BindingGraph owningGraph = componentTreePath.graphForComponent(owningComponent);
+      for (DependencyRequest dependency : binding.dependencies()) {
+        nextDependencyRequest(dependency, owningGraph);
+      }
+    }
+
+    private void nextDependencyRequest(
+        DependencyRequest dependencyRequest, BindingGraph bindingGraph) {
+      if (!visitedDependencyRequests.add(dependencyRequest)) {
+        return;
+      }
+
+      ResolvedBindings resolvedBindings =
+          bindingGraph.resolvedBindings().get(dependencyRequest.bindingKey());
+      dependencyRequestPath.addLast(dependencyRequest);
+      resolvedBindingsPath.addLast(resolvedBindings);
+      bindingKeysInPath.add(dependencyRequest.bindingKey());
+      try {
+        visitDependencyRequest(dependencyRequest);
+      } finally {
+        verify(dependencyRequestPath.removeLast().equals(dependencyRequest));
+        verify(resolvedBindingsPath.removeLast().equals(resolvedBindings));
+        verify(bindingKeysInPath.remove(dependencyRequest.bindingKey()));
+      }
+    }
+
+    /**
+     * Returns the path from the root component to the component that includes the {@linkplain
+     * #entryPointElement()} entry point.
+     */
+    protected final ComponentTreePath componentTreePath() {
+      return componentTreePath;
+    }
+
+    /**
+     * Returns the rootmost of the binding graphs in the component path that own each binding.
+     *
+     * <p>For arguments {@code [x, y]}, if binding {@code x} is owned by component {@code A} and
+     * binding {@code y} is owned by component {@code B}, and {@code A} is an ancestor of {@code B},
+     * then this method returns the binding graph for {@code A}.
+     */
+    public BindingGraph owningGraph(Iterable<ContributionBinding> bindings) {
+      ImmutableSet.Builder<ComponentDescriptor> owningComponents = ImmutableSet.builder();
+      for (ContributionBinding binding : bindings) {
+        ResolvedBindings resolvedBindings =
+            currentGraph().resolvedBindings().get(contribution(binding.key()));
+        owningComponents.add(resolvedBindings.owningComponent(binding));
+      }
+      return componentTreePath.rootmostGraph(owningComponents.build());
+    }
+
+    /**
+     * Returns {@code true} if the {@linkplain #dependencyRequest() current dependency request} is
+     * also higher in the dependency path.
+     *
+     * @throws IllegalStateException if this object is not currently traversing dependencies
+     */
+    protected final boolean atDependencyCycle() {
+      checkState(!dependencyRequestPath.isEmpty());
+      return bindingKeysInPath.count(dependencyRequest().bindingKey()) > 1;
+    }
+
+    /**
+     * Returns the dependency request currently being visited.
+     *
+     * @throws IllegalStateException if this object is not currently traversing dependencies
+     */
+    protected final DependencyRequest dependencyRequest() {
+      return dependencyRequestPath.getLast();
+    }
+
+    /**
+     * Returns the resolved bindings for the {@linkplain #dependencyRequest() current dependency
+     * request}.
+     *
+     * @throws IllegalStateException if this object is not currently traversing dependencies
+     */
+    protected final ResolvedBindings resolvedBindings() {
+      return resolvedBindingsPath.getLast();
+    }
+
+    /**
+     * Returns the bindings that depend directly on the {@linkplain #dependencyRequest() current
+     * dependency request}.
+     */
+    protected final ImmutableSet<? extends Binding> dependentBindings() {
+      if (atEntryPoint()) {
+        return ImmutableSet.of();
+      }
+      ResolvedBindings dependentResolvedBindings =
+          Iterators.get(resolvedBindingsPath.descendingIterator(), 1);
+      return dependentResolvedBindings
+          .bindings()
+          .stream()
+          .filter(binding -> binding.dependencies().contains(dependencyRequest()))
+          .collect(toImmutableSet());
+    }
+
+    /**
+     * Returns the entry point whose dependencies are currently being traversed.
+     *
+     * @throws IllegalStateException if this object is not currently traversing dependencies
+     */
+    protected final Element entryPointElement() {
+      return entryPoint.requestElement().get();
+    }
+
+    /**
+     * Returns {@code true} if the {@linkplain #dependencyRequest() current dependency request} is
+     * an entry point.
+     */
+    protected final boolean atEntryPoint() {
+      return dependencyRequestPath.size() == 1;
+    }
+
+    /** Returns the binding graph for the component that is currently being visited. */
+    protected final BindingGraph currentGraph() {
+      return componentTreePath.currentGraph();
+    }
+
+    /**
+     * Returns the dependency requests and resolved bindings starting with the entry point and
+     * ending with the {@linkplain #dependencyRequest() current dependency request}.
+     */
+    protected final DependencyTrace dependencyTrace() {
+      checkState(!dependencyRequestPath.isEmpty());
+      return new DependencyTrace(dependencyRequestPath, resolvedBindingsPath);
+    }
+
+    /**
+     * Returns the dependency requests and resolved bindings in the {@linkplain #atDependencyCycle()
+     * dependency cycle}, starting with the request closest to the entry point and ending with the
+     * {@linkplain #dependencyRequest() current dependency request}.
+     *
+     * <p>The first request and the last request in the trace will have the same {@linkplain
+     * DependencyRequest#bindingKey() binding key}.
+     */
+    protected final DependencyTrace cycleDependencyTrace() {
+      checkState(atDependencyCycle(), "no cycle");
+      int skip = indexOf(bindingKeysInPath, equalTo(dependencyRequest().bindingKey()));
+      return new DependencyTrace(
+          skip(dependencyRequestPath, skip), skip(resolvedBindingsPath, skip));
+    }
+  }
+
+  /** A traverser that does nothing. */
+  private static final class NoOpBindingGraphTraverser extends BindingGraphTraverser {
+    private NoOpBindingGraphTraverser(
+        ComponentTreePath componentPath, DependencyRequest entryPoint) {
+      super(componentPath, entryPoint);
+    }
+
+    @Override
+    public void traverseDependencies() {}
+  }
+
+  /**
+   * A path from the root component to a component within the component tree during a {@linkplain
+   * ComponentTreeTraverser traversal}.
+   */
+  public static final class ComponentTreePath {
+    /** The binding graph path from the root graph to the currently visited graph. */
+    private final ImmutableList<BindingGraph> bindingGraphPath;
+
+    private ComponentTreePath(Iterable<BindingGraph> path) {
+      this.bindingGraphPath = ImmutableList.copyOf(path);
+    }
+
+    /**
+     * Returns the binding graphs in the path, starting from the {@linkplain #rootGraph() root
+     * graph} and ending with the {@linkplain #currentGraph() current graph}.
+     */
+    public ImmutableList<BindingGraph> graphsInPath() {
+      return bindingGraphPath;
+    }
+
+    /** Returns the binding graph for the component at the end of the path. */
+    public BindingGraph currentGraph() {
+      return Iterables.getLast(bindingGraphPath);
+    }
+
+    // TODO(dpb): Do we also want methods that return ComponentDescriptors, like currentComponent()?
+
+    /**
+     * Returns the binding graph for the parent of the {@linkplain #currentGraph() current
+     * component}.
+     *
+     * @throws IllegalStateException if the current graph is the {@linkplain #atRoot() root graph}
+     */
+    public BindingGraph parentGraph() {
+      checkState(!atRoot());
+      return bindingGraphPath.reverse().get(1);
+    }
+
+    /** Returns the binding graph for the root component. */
+    public BindingGraph rootGraph() {
+      return bindingGraphPath.get(0);
+    }
+
+    /**
+     * Returns {@code true} if the {@linkplain #currentGraph() current graph} is the {@linkplain
+     * #rootGraph() root graph}.
+     */
+    public boolean atRoot() {
+      return bindingGraphPath.size() == 1;
+    }
+
+    /** Returns the rootmost binding graph in the component path among the given components. */
+    public BindingGraph rootmostGraph(Iterable<ComponentDescriptor> components) {
+      ImmutableSet<ComponentDescriptor> set = ImmutableSet.copyOf(components);
+      return rootmostGraph(graph -> set.contains(graph.componentDescriptor()));
+    }
+
+    /** Returns the binding graph within this path that represents the given component. */
+    public BindingGraph graphForComponent(ComponentDescriptor component) {
+      return rootmostGraph(graph -> graph.componentDescriptor().equals(component));
+    }
+
+    private BindingGraph rootmostGraph(Predicate<? super BindingGraph> predicate) {
+      return bindingGraphPath.stream().filter(predicate).findFirst().get();
+    }
+  }
+
+  /**
+   * An immutable snapshot of a path through the binding graph.
+   *
+   * <p>The path contains pairs of a dependency request and the bindings resolved for it. At each
+   * step after the first the dependency request is contained by one of the bindings resolved for
+   * the previous dependency request.
+   */
+  public static final class DependencyTrace {
+    private final ImmutableList<DependencyRequest> dependencyRequests;
+    private final ImmutableList<ResolvedBindings> resolvedBindings;
+
+    private DependencyTrace(
+        Iterable<DependencyRequest> dependencyRequests,
+        Iterable<ResolvedBindings> resolvedBindings) {
+      this.dependencyRequests = ImmutableList.copyOf(dependencyRequests);
+      this.resolvedBindings = ImmutableList.copyOf(resolvedBindings);
+      checkArgument(
+          this.dependencyRequests.size() == this.resolvedBindings.size(),
+          "dependency requests and resolved bindings must have the same size: %s vs. %s",
+          this.dependencyRequests,
+          this.resolvedBindings);
+    }
+
+    /** Calls {@code consumer} for every dependency request and the bindings resolved for it. */
+    protected final void forEach(
+        BiConsumer<? super DependencyRequest, ? super ResolvedBindings> consumer) {
+      Iterator<DependencyRequest> dependencyRequestIterator = dependencyRequests.iterator();
+      Iterator<ResolvedBindings> resolvedBindingsIterator = resolvedBindings.iterator();
+      while (dependencyRequestIterator.hasNext()) {
+        consumer.accept(dependencyRequestIterator.next(), resolvedBindingsIterator.next());
+      }
+    }
+
+    /**
+     * Returns an ordered stream of the results of calling {@code function} on every dependency
+     * request and the bindings resolved for it.
+     */
+    protected final <T> Stream<T> transform(
+        BiFunction<? super DependencyRequest, ? super ResolvedBindings, T> function) {
+      Iterator<DependencyRequest> dependencyRequestIterator = dependencyRequests.iterator();
+      Iterator<ResolvedBindings> resolvedBindingsIterator = resolvedBindings.iterator();
+      return StreamSupport.stream(
+          new AbstractSpliterator<T>(dependencyRequests.size(), ORDERED | SIZED) {
+            @Override
+            public boolean tryAdvance(Consumer<? super T> action) {
+              if (!dependencyRequestIterator.hasNext()) {
+                return false;
+              }
+              action.accept(
+                  function.apply(
+                      dependencyRequestIterator.next(), resolvedBindingsIterator.next()));
+              return true;
+            }
+          },
+          false);
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
index acced9d23..7045643fa 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
@@ -17,6 +17,8 @@
 package dagger.internal.codegen;
 
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
+import static com.google.auto.common.MoreElements.getLocalAndInheritedMethods;
+import static com.google.auto.common.MoreTypes.asExecutable;
 import static dagger.internal.codegen.ConfigurationAnnotations.enclosedBuilders;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
@@ -37,6 +39,7 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.LinkedHashMultimap;
+import com.google.common.collect.Maps;
 import com.google.common.collect.SetMultimap;
 import com.google.common.collect.Sets;
 import dagger.Component;
@@ -44,9 +47,7 @@
 import dagger.internal.codegen.ComponentDescriptor.Kind;
 import dagger.producers.ProductionComponent;
 import java.lang.annotation.Annotation;
-import java.util.Collection;
 import java.util.List;
-import java.util.Map;
 import java.util.Set;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
@@ -56,14 +57,13 @@
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.SimpleTypeVisitor6;
 import javax.lang.model.util.Types;
 
 /**
- * Performs superficial validation of the contract of the {@link Component} and
- * {@link ProductionComponent} annotations.
+ * Performs superficial validation of the contract of the {@link Component} and {@link
+ * ProductionComponent} annotations.
  *
  * @author Gregory Kick
  */
@@ -74,7 +74,8 @@
   private final ComponentValidator subcomponentValidator;
   private final BuilderValidator subcomponentBuilderValidator;
 
-  private ComponentValidator(Elements elements,
+  private ComponentValidator(
+      Elements elements,
       Types types,
       ModuleValidator moduleValidator,
       BuilderValidator subcomponentBuilderValidator) {
@@ -85,7 +86,8 @@ private ComponentValidator(Elements elements,
     this.subcomponentBuilderValidator = subcomponentBuilderValidator;
   }
 
-  private ComponentValidator(Elements elements,
+  private ComponentValidator(
+      Elements elements,
       Types types,
       ModuleValidator moduleValidator,
       ComponentValidator subcomponentValidator,
@@ -97,7 +99,8 @@ private ComponentValidator(Elements elements,
     this.subcomponentBuilderValidator = subcomponentBuilderValidator;
   }
 
-  static ComponentValidator createForComponent(Elements elements,
+  static ComponentValidator createForComponent(
+      Elements elements,
       Types types,
       ModuleValidator moduleValidator,
       ComponentValidator subcomponentValidator,
@@ -106,7 +109,8 @@ static ComponentValidator createForComponent(Elements elements,
         elements, types, moduleValidator, subcomponentValidator, subcomponentBuilderValidator);
   }
 
-  static ComponentValidator createForSubcomponent(Elements elements,
+  static ComponentValidator createForSubcomponent(
+      Elements elements,
       Types types,
       ModuleValidator moduleValidator,
       BuilderValidator subcomponentBuilderValidator) {
@@ -114,8 +118,9 @@ static ComponentValidator createForSubcomponent(Elements elements,
   }
 
   @AutoValue
-  static abstract class ComponentValidationReport {
+  abstract static class ComponentValidationReport {
     abstract Set<Element> referencedSubcomponents();
+
     abstract ValidationReport<TypeElement> report();
   }
 
@@ -123,7 +128,8 @@ static ComponentValidator createForSubcomponent(Elements elements,
    * Validates the given component subject. Also validates any referenced subcomponents that aren't
    * already included in the {@code validatedSubcomponents} set.
    */
-  public ComponentValidationReport validate(final TypeElement subject,
+  public ComponentValidationReport validate(
+      final TypeElement subject,
       Set<? extends Element> validatedSubcomponents,
       Set<? extends Element> validatedSubcomponentBuilders) {
     ValidationReport.Builder<TypeElement> builder = ValidationReport.about(subject);
@@ -155,90 +161,86 @@ public ComponentValidationReport validate(final TypeElement subject,
 
     DeclaredType subjectType = MoreTypes.asDeclared(subject.asType());
 
-    // TODO(gak): This should use Util.findLocalAndInheritedMethods, otherwise
-    // it can return a logical method multiple times (including overrides, etc.)
-    List<? extends Element> members = elements.getAllMembers(subject);
     SetMultimap<Element, ExecutableElement> referencedSubcomponents = LinkedHashMultimap.create();
-    for (ExecutableElement method : ElementFilter.methodsIn(members)) {
-      if (method.getModifiers().contains(ABSTRACT)) {
-        ExecutableType resolvedMethod =
-            MoreTypes.asExecutable(types.asMemberOf(subjectType, method));
-        List<? extends TypeMirror> parameterTypes = resolvedMethod.getParameterTypes();
-        List<? extends VariableElement> parameters = method.getParameters();
-        TypeMirror returnType = resolvedMethod.getReturnType();
-
-        // abstract methods are ones we have to implement, so they each need to be validated
-        // first, check the return type.  if it's a subcomponent, validate that method as such.
-        Optional<AnnotationMirror> subcomponentAnnotation =
-            checkForAnnotations(
-                returnType,
-                FluentIterable.from(componentKind.subcomponentKinds())
-                    .transform(Kind::annotationType)
-                    .toSet());
-        Optional<AnnotationMirror> subcomponentBuilderAnnotation =
-            checkForAnnotations(
-                returnType,
-                FluentIterable.from(componentKind.subcomponentKinds())
-                    .transform(Kind::builderAnnotationType)
-                    .toSet());
-        if (subcomponentAnnotation.isPresent()) {
-          referencedSubcomponents.put(MoreTypes.asElement(returnType), method);
-          validateSubcomponentMethod(
-              builder,
-              ComponentDescriptor.Kind.forAnnotatedElement(MoreTypes.asTypeElement(returnType))
-                  .get(),
-              method,
-              parameters,
-              parameterTypes,
-              returnType,
-              subcomponentAnnotation);
-        } else if (subcomponentBuilderAnnotation.isPresent()) {
-          referencedSubcomponents.put(MoreTypes.asElement(returnType).getEnclosingElement(),
-              method);
-          validateSubcomponentBuilderMethod(builder,
-              method,
-              parameters,
-              returnType,
-              validatedSubcomponentBuilders);
-        } else {
-          // if it's not a subcomponent...
-          switch (parameters.size()) {
-            case 0:
-              // no parameters means that it is a provision method
-              // basically, there are no restrictions here.  \o/
-              break;
-            case 1:
-              // one parameter means that it's a members injection method
-              TypeMirror onlyParameter = Iterables.getOnlyElement(parameterTypes);
-              if (!(returnType.getKind().equals(VOID)
-                  || types.isSameType(returnType, onlyParameter))) {
-                builder.addError(
-                    "Members injection methods may only return the injected type or void.", method);
+    getLocalAndInheritedMethods(subject, types, elements)
+        .stream()
+        .filter(method -> method.getModifiers().contains(ABSTRACT))
+        .forEachOrdered(
+            method -> {
+              ExecutableType resolvedMethod = asExecutable(types.asMemberOf(subjectType, method));
+              List<? extends TypeMirror> parameterTypes = resolvedMethod.getParameterTypes();
+              List<? extends VariableElement> parameters = method.getParameters();
+              TypeMirror returnType = resolvedMethod.getReturnType();
+
+              // abstract methods are ones we have to implement, so they each need to be validated
+              // first, check the return type. if it's a subcomponent, validate that method as such.
+              Optional<AnnotationMirror> subcomponentAnnotation =
+                  checkForAnnotations(
+                      returnType,
+                      FluentIterable.from(componentKind.subcomponentKinds())
+                          .transform(Kind::annotationType)
+                          .toSet());
+              Optional<AnnotationMirror> subcomponentBuilderAnnotation =
+                  checkForAnnotations(
+                      returnType,
+                      FluentIterable.from(componentKind.subcomponentKinds())
+                          .transform(Kind::builderAnnotationType)
+                          .toSet());
+              if (subcomponentAnnotation.isPresent()) {
+                referencedSubcomponents.put(MoreTypes.asElement(returnType), method);
+                validateSubcomponentMethod(
+                    builder,
+                    ComponentDescriptor.Kind.forAnnotatedElement(
+                            MoreTypes.asTypeElement(returnType))
+                        .get(),
+                    method,
+                    parameters,
+                    parameterTypes,
+                    returnType,
+                    subcomponentAnnotation);
+              } else if (subcomponentBuilderAnnotation.isPresent()) {
+                referencedSubcomponents.put(
+                    MoreTypes.asElement(returnType).getEnclosingElement(), method);
+                validateSubcomponentBuilderMethod(
+                    builder, method, parameters, returnType, validatedSubcomponentBuilders);
+              } else {
+                // if it's not a subcomponent...
+                switch (parameters.size()) {
+                  case 0:
+                    // no parameters means that it is a provision method
+                    // basically, there are no restrictions here.  \o/
+                    break;
+                  case 1:
+                    // one parameter means that it's a members injection method
+                    TypeMirror onlyParameter = Iterables.getOnlyElement(parameterTypes);
+                    if (!(returnType.getKind().equals(VOID)
+                        || types.isSameType(returnType, onlyParameter))) {
+                      builder.addError(
+                          "Members injection methods may only return the injected type or void.",
+                          method);
+                    }
+                    break;
+                  default:
+                    // this isn't any method that we know how to implement...
+                    builder.addError(
+                        "This method isn't a valid provision method, members injection method or "
+                            + "subcomponent factory method. Dagger cannot implement this method",
+                        method);
+                    break;
+                }
               }
-              break;
-            default:
-              // this isn't any method that we know how to implement...
-              builder.addError(
-                  "This method isn't a valid provision method, members injection method or "
-                      + "subcomponent factory method. Dagger cannot implement this method",
-                  method);
-              break;
-          }
-        }
-      }
-    }
+            });
 
-    for (Map.Entry<Element, Collection<ExecutableElement>> entry :
-        referencedSubcomponents.asMap().entrySet()) {
-      if (entry.getValue().size() > 1) {
-        builder.addError(
-            String.format(
-                ErrorMessages.SubcomponentBuilderMessages.INSTANCE.moreThanOneRefToSubcomponent(),
-                entry.getKey(),
-                entry.getValue()),
-            subject);
-      }
-    }
+    Maps.filterValues(referencedSubcomponents.asMap(), methods -> methods.size() > 1)
+        .forEach(
+            (subcomponent, methods) ->
+                builder.addError(
+                    String.format(
+                        ErrorMessages.SubcomponentBuilderMessages.INSTANCE
+                            .moreThanOneRefToSubcomponent(),
+                        subcomponent,
+                        methods),
+                    subject));
 
     AnnotationMirror componentMirror =
         getAnnotationMirror(subject, componentKind.annotationType()).get();
@@ -258,14 +260,17 @@ public ComponentValidationReport validate(final TypeElement subject,
         ImmutableSet.<Element>builder().addAll(referencedSubcomponents.keySet());
     for (Element subcomponent :
         Sets.difference(referencedSubcomponents.keySet(), validatedSubcomponents)) {
-      ComponentValidationReport subreport = subcomponentValidator.validate(
-          MoreElements.asType(subcomponent), validatedSubcomponents, validatedSubcomponentBuilders);
+      ComponentValidationReport subreport =
+          subcomponentValidator.validate(
+              MoreElements.asType(subcomponent),
+              validatedSubcomponents,
+              validatedSubcomponentBuilders);
       builder.addItems(subreport.report().items());
       allSubcomponents.addAll(subreport.referencedSubcomponents());
     }
 
-    return new AutoValue_ComponentValidator_ComponentValidationReport(allSubcomponents.build(),
-        builder.build());
+    return new AutoValue_ComponentValidator_ComponentValidationReport(
+        allSubcomponents.build(), builder.build());
   }
 
   private void validateSubcomponentMethod(
@@ -340,8 +345,11 @@ private void validateSubcomponentMethod(
     }
   }
 
-  private void validateSubcomponentBuilderMethod(ValidationReport.Builder<TypeElement> builder,
-      ExecutableElement method, List<? extends VariableElement> parameters, TypeMirror returnType,
+  private void validateSubcomponentBuilderMethod(
+      ValidationReport.Builder<TypeElement> builder,
+      ExecutableElement method,
+      List<? extends VariableElement> parameters,
+      TypeMirror returnType,
       Set<? extends Element> validatedSubcomponentBuilders) {
 
     if (!parameters.isEmpty()) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
index 635dbeefc..bb90d0a46 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
@@ -138,7 +138,7 @@ private UniqueSubcomponentNamesGenerator(BindingGraph graph) {
   @Override
   protected void decorateComponent() {
     component.addModifiers(PUBLIC, FINAL);
-    addSupertype(component, componentDefinitionType());
+    addSupertype(component, graph.componentType());
   }
 
   @Override
@@ -190,6 +190,7 @@ protected void addFactoryMethods() {
   /** {@code true} if all of the graph's required dependencies can be automatically constructed. */
   private boolean canInstantiateAllRequirements() {
     return !Iterables.any(
-        graph.componentRequirements(), dependency -> requiresAPassedInstance(elements, dependency));
+        graph.componentRequirements(),
+        dependency -> requiresAPassedInstance(elements, types, dependency));
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
index 235b99a2e..61f1a1b51 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
@@ -19,7 +19,7 @@
 import static com.google.common.collect.Sets.immutableEnumSet;
 import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.CLASS_CONSTRUCTOR;
 import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.DELEGATE;
-import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.ENUM_INSTANCE;
+import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.SINGLETON_INSTANCE;
 import static dagger.internal.codegen.MapKeys.unwrapValue;
 import static dagger.internal.codegen.MoreAnnotationMirrors.unwrapOptionalEquivalence;
 import static javax.lang.model.element.Modifier.ABSTRACT;
@@ -174,8 +174,8 @@ boolean requiresModuleInstance() {
    * The strategy for getting an instance of a factory for a {@link ContributionBinding}.
    */
   enum FactoryCreationStrategy {
-    /** The factory class is an enum with one value named {@code INSTANCE}. */
-    ENUM_INSTANCE,
+    /** The factory class is a single instance. */
+    SINGLETON_INSTANCE,
     /** The factory must be created by calling the constructor. */
     CLASS_CONSTRUCTOR,
     /** The factory is simply delegated to another. */
@@ -188,7 +188,7 @@ boolean requiresModuleInstance() {
    * <p>Delegate bindings use the {@link FactoryCreationStrategy#DELEGATE} strategy.
    *
    * <p>Bindings without dependencies that don't require a module instance use the {@link
-   * FactoryCreationStrategy#ENUM_INSTANCE} strategy.
+   * FactoryCreationStrategy#SINGLETON_INSTANCE} strategy.
    *
    * <p>All other bindings use the {@link FactoryCreationStrategy#CLASS_CONSTRUCTOR} strategy.
    */
@@ -198,12 +198,12 @@ FactoryCreationStrategy factoryCreationStrategy() {
         return DELEGATE;
       case PROVISION:
         return dependencies().isEmpty() && !requiresModuleInstance()
-            ? ENUM_INSTANCE
+            ? SINGLETON_INSTANCE
             : CLASS_CONSTRUCTOR;
       case INJECTION:
       case SYNTHETIC_MULTIBOUND_SET:
       case SYNTHETIC_MULTIBOUND_MAP:
-        return dependencies().isEmpty() ? ENUM_INSTANCE : CLASS_CONSTRUCTOR;
+        return dependencies().isEmpty() ? SINGLETON_INSTANCE : CLASS_CONSTRUCTOR;
       default:
         return CLASS_CONSTRUCTOR;
     }
@@ -214,7 +214,7 @@ FactoryCreationStrategy factoryCreationStrategy() {
    * for this binding. Uses the binding's key, V in the came of {@code Map<K, FrameworkClass<V>>>},
    * and E {@code Set<E>} for {@link dagger.multibindings.IntoSet @IntoSet} methods.
    */
-  final TypeMirror factoryType() {
+  final TypeMirror contributedType() {
     switch (contributionType()) {
       case MAP:
         return MapType.from(key()).unwrappedValueType(bindingType().frameworkClass());
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
index 3848f6727..dbb463341 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
@@ -19,19 +19,20 @@
 import static com.google.auto.common.MoreElements.asExecutable;
 import static dagger.internal.codegen.ErrorMessages.DOUBLE_INDENT;
 import static dagger.internal.codegen.ErrorMessages.INDENT;
+import static dagger.internal.codegen.Util.toImmutableList;
 
 import com.google.auto.common.MoreElements;
 import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
-import com.google.common.base.Predicates;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.util.concurrent.ListenableFuture;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import dagger.Lazy;
 import dagger.Provides;
-import dagger.internal.codegen.BindingGraphValidator.DependencyPath;
+import dagger.internal.codegen.ComponentTreeTraverser.DependencyTrace;
 import dagger.producers.Produces;
 import java.util.List;
+import java.util.concurrent.atomic.AtomicReference;
 import javax.inject.Inject;
 import javax.inject.Provider;
 import javax.lang.model.element.AnnotationMirror;
@@ -77,29 +78,24 @@
     this.elements = elements;
   }
 
-  /**
-   * A string representation of the dependency trace, starting with the
-   * {@linkplain DependencyPath#currentDependencyRequest() current request} and ending with the
-   * entry point, excluding {@linkplain DependencyRequest#isSynthetic() synthetic} requests.
-   */
-  String toDependencyTrace(DependencyPath dependencyPath) {
+  /** Returns a representation of the dependency trace, with the entry point at the bottom. */
+  String format(DependencyTrace dependencyTrace) {
+    AtomicReference<ImmutableSet<OptionalBindingDeclaration>> dependentOptionalBindingDeclarations =
+        new AtomicReference<>(ImmutableSet.of());
     return Joiner.on('\n')
         .join(
-            dependencyPath
-                .resolvedRequests()
+            dependencyTrace
                 .transform(
-                    resolvedRequest -> {
+                    (dependencyRequest, resolvedBindings) -> {
                       ImmutableSet<OptionalBindingDeclaration> optionalBindingDeclarations =
-                          resolvedRequest
-                              .dependentResolvedBindings()
-                              .transform(ResolvedBindings::optionalBindingDeclarations)
-                              .or(ImmutableSet.of());
+                          dependentOptionalBindingDeclarations.getAndSet(
+                              resolvedBindings.optionalBindingDeclarations());
                       return optionalBindingDeclarations.isEmpty()
-                          ? format(resolvedRequest.dependencyRequest())
+                          ? format(dependencyRequest)
                           : formatSyntheticOptionalBindingDependency(optionalBindingDeclarations);
                     })
-                .filter(Predicates.not(Predicates.equalTo("")))
-                .toList()
+                .filter(f -> !f.isEmpty())
+                .collect(toImmutableList())
                 .reverse());
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index 332562b61..13504f3a2 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -20,11 +20,10 @@
 import static com.squareup.javapoet.MethodSpec.constructorBuilder;
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static com.squareup.javapoet.TypeSpec.classBuilder;
-import static com.squareup.javapoet.TypeSpec.enumBuilder;
-import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_RAWTYPES;
-import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_UNCHECKED;
+import static dagger.internal.codegen.AnnotationSpecs.Suppression.RAWTYPES;
+import static dagger.internal.codegen.AnnotationSpecs.Suppression.UNCHECKED;
+import static dagger.internal.codegen.AnnotationSpecs.suppressWarnings;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
-import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.ENUM_INSTANCE;
 import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
 import static dagger.internal.codegen.ContributionBinding.Kind.PROVISION;
 import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD;
@@ -103,38 +102,39 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
     checkArgument(binding.bindingElement().isPresent());
 
     if (binding.bindingKind().equals(INJECTION)
-        && !injectValidator.isValidType(binding.factoryType())) {
+        && !injectValidator.isValidType(binding.contributedType())) {
       return Optional.absent();
     }
 
-    TypeName providedTypeName = TypeName.get(binding.factoryType());
-    ParameterizedTypeName parameterizedFactoryName = factoryOf(providedTypeName);
-    Optional<ParameterizedTypeName> factoryOfRawTypeName = Optional.absent();
-    TypeSpec.Builder factoryBuilder;
-    Optional<MethodSpec.Builder> constructorBuilder = Optional.absent();
+    TypeName providedTypeName = TypeName.get(binding.contributedType());
+    ParameterizedTypeName factoryTypeName = factoryOf(providedTypeName);
     ImmutableList<TypeVariableName> typeParameters = bindingTypeElementTypeVariableNames(binding);
+    TypeSpec.Builder factoryBuilder = classBuilder(generatedTypeName).addModifiers(FINAL);
+    // Use type parameters from the injected type or the module instance *only* if we require it.
+    boolean factoryHasTypeParameters =
+        (binding.bindingKind().equals(INJECTION) || binding.requiresModuleInstance())
+            && !typeParameters.isEmpty();
+    if (factoryHasTypeParameters) {
+      factoryBuilder.addTypeVariables(typeParameters);
+    }
+    Optional<MethodSpec.Builder> constructorBuilder = Optional.absent();
     UniqueNameSet uniqueFieldNames = new UniqueNameSet();
     ImmutableMap.Builder<BindingKey, FieldSpec> fieldsBuilder = ImmutableMap.builder();
 
-    boolean useRawType =
-        binding.factoryCreationStrategy() == ENUM_INSTANCE
-            && binding.bindingKind() == INJECTION
-            && !typeParameters.isEmpty();
     switch (binding.factoryCreationStrategy()) {
-      case ENUM_INSTANCE:
-        factoryBuilder = enumBuilder(generatedTypeName.simpleName()).addEnumConstant("INSTANCE");
-        // If we have type parameters, then remove the parameters from our providedTypeName,
-        // since we'll be implementing an erased version of it.
-        if (useRawType) {
-          factoryBuilder.addAnnotation(SUPPRESS_WARNINGS_RAWTYPES);
-          // TODO(ronshapiro): instead of reassigning, introduce an optional/second parameter
-          providedTypeName = ((ParameterizedTypeName) providedTypeName).rawType;
-          factoryOfRawTypeName = Optional.of(factoryOf(providedTypeName));
+      case SINGLETON_INSTANCE:
+        FieldSpec.Builder instanceFieldBuilder =
+            FieldSpec.builder(generatedTypeName, "INSTANCE", PRIVATE, STATIC, FINAL)
+                .initializer("new $T()", generatedTypeName);
+
+        // if the factory has type parameters, we're ignoring them in the initializer
+        if (factoryHasTypeParameters) {
+          instanceFieldBuilder.addAnnotation(suppressWarnings(RAWTYPES));
         }
+
+        factoryBuilder.addField(instanceFieldBuilder.build());
         break;
       case CLASS_CONSTRUCTOR:
-        factoryBuilder =
-            classBuilder(generatedTypeName).addTypeVariables(typeParameters).addModifiers(FINAL);
         constructorBuilder = Optional.of(constructorBuilder().addModifiers(PUBLIC));
         if (binding.requiresModuleInstance()) {
           addConstructorParameterAndTypeField(
@@ -163,9 +163,7 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
     }
     ImmutableMap<BindingKey, FieldSpec> fields = fieldsBuilder.build();
 
-    factoryBuilder
-        .addModifiers(PUBLIC)
-        .addSuperinterface(factoryOfRawTypeName.or(parameterizedFactoryName));
+    factoryBuilder.addModifiers(PUBLIC).addSuperinterface(factoryTypeName);
 
     // If constructing a factory for @Inject or @Provides bindings, we use a static create method
     // so that generated components can avoid having to refer to the generic types
@@ -177,26 +175,24 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
         // The return type is usually the same as the implementing type, except in the case
         // of enums with type variables (where we cast).
         MethodSpec.Builder createMethodBuilder =
-            methodBuilder("create")
-                .addModifiers(PUBLIC, STATIC)
-                .returns(parameterizedFactoryName);
-        if (binding.factoryCreationStrategy() != ENUM_INSTANCE
-            || binding.bindingKind() == INJECTION) {
+            methodBuilder("create").addModifiers(PUBLIC, STATIC).returns(factoryTypeName);
+        if (factoryHasTypeParameters) {
           createMethodBuilder.addTypeVariables(typeParameters);
         }
         List<ParameterSpec> params =
             constructorBuilder.isPresent()
-                ? constructorBuilder.get().build().parameters : ImmutableList.<ParameterSpec>of();
+                ? constructorBuilder.get().build().parameters
+                : ImmutableList.of();
         createMethodBuilder.addParameters(params);
         switch (binding.factoryCreationStrategy()) {
-          case ENUM_INSTANCE:
-            if (!useRawType) {
-              createMethodBuilder.addStatement("return INSTANCE");
-            } else {
+          case SINGLETON_INSTANCE:
+            if (factoryHasTypeParameters) {
               // We use an unsafe cast here because the types are different.
               // It's safe because the type is never referenced anywhere.
               createMethodBuilder.addStatement("return ($T) INSTANCE", TypeNames.FACTORY);
-              createMethodBuilder.addAnnotation(SUPPRESS_WARNINGS_UNCHECKED);
+              createMethodBuilder.addAnnotation(suppressWarnings(RAWTYPES, UNCHECKED));
+            } else {
+              createMethodBuilder.addStatement("return INSTANCE");
             }
             break;
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/Formatter.java b/compiler/src/main/java/dagger/internal/codegen/Formatter.java
index da3cb4789..ce1a292f8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Formatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Formatter.java
@@ -38,16 +38,16 @@
   public abstract String format(T object);
 
   /**
-   * Performs the transformation of an object into a string representation in
-   * conformity with the {@link Function}{@code <T, String>} contract, delegating
-   * to {@link #format(Object)}.
+   * Performs the transformation of an object into a string representation in conformity with the
+   * {@link Function}{@code <T, String>} contract, delegating to {@link #format(Object)}.
    *
-   * @deprecated Call {@link #format(T)} instead.  This method exists to make
-   * formatters easy to use when functions are required, but shouldn't be called directly.
+   * @deprecated Call {@link #format(Object)} instead. This method exists to make formatters easy to
+   *     use when functions are required, but shouldn't be called directly.
    */
   @SuppressWarnings("javadoc")
   @Deprecated
-  @Override final public String apply(T object) {
+  @Override
+  public final String apply(T object) {
     return format(object);
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index f1c004813..cefb4c9a0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -109,9 +109,9 @@
    * #qualifier()}.
    *
    * <p>Each multibound map and set has a {@linkplain
-   * ProvisionBinding.Factory#syntheticMultibinding(DependencyRequest, Iterable) synthetic
-   * multibinding} that depends on the specific contributions to that map or set using keys that
-   * identify those multibinding contributions.
+   * ProvisionBinding.Factory#syntheticMultibinding(Key, Iterable) synthetic multibinding} that
+   * depends on the specific contributions to that map or set using keys that identify those
+   * multibinding contributions.
    *
    * <p>Absent except for multibinding contributions.
    */
@@ -281,7 +281,7 @@ public Boolean visitDeclared(DeclaredType type, Void ignored) {
    * {@inheritDoc}
    *
    * <p>The returned string is equal to another key's if and only if this key is {@link
-   * #equal(Object)} to it.
+   * #equals(Object)} to it.
    */
   @Override
   public String toString() {
diff --git a/compiler/src/main/java/dagger/internal/codegen/MemberSelect.java b/compiler/src/main/java/dagger/internal/codegen/MemberSelect.java
index 9525860e3..6643208e1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MemberSelect.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MemberSelect.java
@@ -80,10 +80,7 @@ static MemberSelect staticMethod(ClassName owningClass, CodeBlock methodInvocati
   static MemberSelect parameterizedFactoryCreateMethod(
       ClassName owningClass, List<? extends TypeMirror> parameters) {
     return new ParameterizedStaticMethod(
-        owningClass,
-        ImmutableList.<TypeMirror>copyOf(parameters),
-        CodeBlock.of("create()"),
-        FACTORY);
+        owningClass, ImmutableList.copyOf(parameters), CodeBlock.of("create()"), FACTORY);
   }
 
   private static final class StaticMethod extends MemberSelect {
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
index 24404c6aa..d6c73f0c9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
@@ -176,7 +176,7 @@ boolean hasInjectedMembers(DeclaredType declaredType) {
 
     /**
      * Returns a MembersInjectionBinding for the given type. If {@code resolvedType} is present,
-     * this will return a resolved binding, with the key & type resolved to the given type (using
+     * this will return a resolved binding, with the key and type resolved to the given type (using
      * {@link Types#asMemberOf(DeclaredType, Element)}).
      */
     MembersInjectionBinding forInjectedType(
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
index 4b6563406..53278fb91 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
@@ -22,8 +22,9 @@
 import static com.squareup.javapoet.MethodSpec.constructorBuilder;
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static com.squareup.javapoet.TypeSpec.classBuilder;
-import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_RAWTYPES;
-import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_UNCHECKED;
+import static dagger.internal.codegen.AnnotationSpecs.Suppression.RAWTYPES;
+import static dagger.internal.codegen.AnnotationSpecs.Suppression.UNCHECKED;
+import static dagger.internal.codegen.AnnotationSpecs.suppressWarnings;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.SourceFiles.bindingTypeElementTypeVariableNames;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
@@ -171,8 +172,8 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
       // parameters' raw-type warnings.
       if (useRawFrameworkType) {
         usesRawFrameworkTypes = true;
-        fieldBuilder.addAnnotation(SUPPRESS_WARNINGS_RAWTYPES);
-        parameterBuilder.addAnnotation(SUPPRESS_WARNINGS_RAWTYPES);
+        fieldBuilder.addAnnotation(suppressWarnings(RAWTYPES));
+        parameterBuilder.addAnnotation(suppressWarnings(RAWTYPES));
       }
       constructorBuilder.addParameter(parameterBuilder.build());
       createMethodBuilder.addParameter(parameterBuilder.build());
@@ -212,7 +213,7 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
     }
 
     if (usesRawFrameworkTypes) {
-      injectMembersBuilder.addAnnotation(SUPPRESS_WARNINGS_UNCHECKED);
+      injectMembersBuilder.addAnnotation(suppressWarnings(UNCHECKED));
     }
 
     injectorTypeBuilder.addMethod(injectMembersBuilder.build());
diff --git a/compiler/src/main/java/dagger/internal/codegen/MissingBindingSuggestions.java b/compiler/src/main/java/dagger/internal/codegen/MissingBindingSuggestions.java
index 8f86422b0..a5311b80b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MissingBindingSuggestions.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MissingBindingSuggestions.java
@@ -42,8 +42,9 @@
       if ((bindings == null) || bindings.bindings().isEmpty()) {
         graphsToTry.addAll(graph.subgraphs());
       } else {
-        resolutions.add("A binding with matching key exists in component: "
-            + graph.componentDescriptor().componentDefinitionType().getQualifiedName());
+        resolutions.add(
+            "A binding with matching key exists in component: "
+                + graph.componentType().getQualifiedName());
       }
     } while (!graphsToTry.isEmpty());
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
index 51e85504c..131b1f925 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
@@ -247,7 +247,7 @@ private void validateReferencedModules(
   }
 
   /**
-   * Used by {@link ModuleValidator} & {@link ComponentValidator} to validate referenced modules.
+   * Used by {@link ModuleValidator} and {@link ComponentValidator} to validate referenced modules.
    */
   void validateReferencedModules(
       final TypeElement subject,
diff --git a/compiler/src/main/java/dagger/internal/codegen/MultibindingAnnotationsProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/MultibindingAnnotationsProcessingStep.java
index 26a4a36f2..61bb5ccfb 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MultibindingAnnotationsProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MultibindingAnnotationsProcessingStep.java
@@ -38,8 +38,8 @@
 import javax.tools.Diagnostic.Kind;
 
 /**
- * Processing step which verifies that {@link IntoSet @IntoSet}, {@link ElementsIntoSet
- * @ElementsIntoSet} and {@link IntoMap @IntoMap} are not present on invalid elements.
+ * Processing step that verifies that {@link IntoSet}, {@link ElementsIntoSet} and {@link IntoMap}
+ * are not present on invalid elements.
  */
 final class MultibindingAnnotationsProcessingStep implements ProcessingStep {
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/MultibindingDeclaration.java b/compiler/src/main/java/dagger/internal/codegen/MultibindingDeclaration.java
index c7b769f2b..279304d4f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MultibindingDeclaration.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MultibindingDeclaration.java
@@ -103,7 +103,8 @@
       DeclaredType interfaceType = MoreTypes.asDeclared(interfaceElement.asType());
 
       ImmutableSet.Builder<MultibindingDeclaration> declarations = ImmutableSet.builder();
-      for (ExecutableElement method : getLocalAndInheritedMethods(interfaceElement, elements)) {
+      for (ExecutableElement method :
+          getLocalAndInheritedMethods(interfaceElement, types, elements)) {
         if (!method.getEnclosingElement().equals(objectElement)) {
           ExecutableType methodType =
               MoreTypes.asExecutable(types.asMemberOf(interfaceType, method));
diff --git a/compiler/src/main/java/dagger/internal/codegen/MultibindingsValidator.java b/compiler/src/main/java/dagger/internal/codegen/MultibindingsValidator.java
index 74fe9a1fd..48c81f53a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MultibindingsValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MultibindingsValidator.java
@@ -36,6 +36,7 @@
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
 
 /**
  * A {@linkplain ValidationReport validator} for {@link Multibindings @Multibindings}-annotated
@@ -43,6 +44,7 @@
  */
 final class MultibindingsValidator {
   private final Elements elements;
+  private final Types types;
   private final Key.Factory keyFactory;
   private final KeyFormatter keyFormatter;
   private final MethodSignatureFormatter methodSignatureFormatter;
@@ -51,11 +53,13 @@
 
   MultibindingsValidator(
       Elements elements,
+      Types types,
       Key.Factory keyFactory,
       KeyFormatter keyFormatter,
       MethodSignatureFormatter methodSignatureFormatter,
       MultibindingsMethodValidator multibindingsMethodValidator) {
     this.elements = elements;
+    this.types = types;
     this.keyFactory = keyFactory;
     this.keyFormatter = keyFormatter;
     this.methodSignatureFormatter = methodSignatureFormatter;
@@ -82,7 +86,8 @@
 
     ImmutableListMultimap.Builder<Key, ExecutableElement> methodsByKey =
         ImmutableListMultimap.builder();
-    for (ExecutableElement method : getLocalAndInheritedMethods(multibindingsType, elements)) {
+    for (ExecutableElement method :
+        getLocalAndInheritedMethods(multibindingsType, types, elements)) {
       // Skip methods in Object.
       if (method.getEnclosingElement().equals(objectElement)) {
         continue;
diff --git a/compiler/src/main/java/dagger/internal/codegen/MultibindsMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/MultibindsMethodValidator.java
index fc0ace9ff..35ae26c00 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MultibindsMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MultibindsMethodValidator.java
@@ -35,10 +35,7 @@
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
-/**
- * A validator for {@link Multibinds @Multibinds} methods or methods in {@link Multibindings
- * @Multibindings} interfaces.
- */
+/** A validator for {@link Multibinds} methods or methods in {@link Multibindings} interfaces. */
 class MultibindsMethodValidator extends BindingMethodValidator {
 
   /** Creates a validator for {@link Multibinds @Multibinds} methods. */
diff --git a/compiler/src/main/java/dagger/internal/codegen/OptionalFactories.java b/compiler/src/main/java/dagger/internal/codegen/OptionalFactories.java
index d0a268e12..864e620f5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/OptionalFactories.java
+++ b/compiler/src/main/java/dagger/internal/codegen/OptionalFactories.java
@@ -22,8 +22,8 @@
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static com.squareup.javapoet.TypeSpec.anonymousClassBuilder;
 import static com.squareup.javapoet.TypeSpec.classBuilder;
-import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_RAWTYPES;
-import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_UNCHECKED;
+import static dagger.internal.codegen.AnnotationSpecs.Suppression.RAWTYPES;
+import static dagger.internal.codegen.AnnotationSpecs.Suppression.UNCHECKED;
 import static dagger.internal.codegen.TypeNames.PROVIDER;
 import static dagger.internal.codegen.TypeNames.listenableFutureOf;
 import static dagger.internal.codegen.TypeNames.providerOf;
@@ -96,7 +96,7 @@ CodeBlock absentOptionalProvider(ContributionBinding binding) {
   }
 
   /**
-   * Creates a method specification for a {@link Provider<Optional<T>>} that always returns an
+   * Creates a method specification for a {@code Provider<Optional<T>>} that always returns an
    * absent value.
    */
   private MethodSpec absentOptionalProviderMethod(OptionalKind optionalKind) {
@@ -111,7 +111,7 @@ private MethodSpec absentOptionalProviderMethod(OptionalKind optionalKind) {
             "Returns a {@link $T} that returns {@code $L}.",
             Provider.class,
             optionalKind.absentValueExpression())
-        .addCode("$L // safe covariant cast\n", SUPPRESS_WARNINGS_UNCHECKED)
+        .addCode("$L // safe covariant cast\n", AnnotationSpecs.suppressWarnings(UNCHECKED))
         .addCode(
             "$1T provider = ($1T) $2N;",
             providerOf(optionalKind.of(typeVariable)),
@@ -122,7 +122,7 @@ private MethodSpec absentOptionalProviderMethod(OptionalKind optionalKind) {
   }
 
   /**
-   * Creates a field specification for a {@link Provider<Optional<T>>} that always returns an absent
+   * Creates a field specification for a {@code Provider<Optional<T>>} that always returns an absent
    * value.
    */
   private FieldSpec absentOptionalProviderField(OptionalKind optionalKind) {
@@ -132,7 +132,7 @@ private FieldSpec absentOptionalProviderField(OptionalKind optionalKind) {
             PRIVATE,
             STATIC,
             FINAL)
-        .addAnnotation(SUPPRESS_WARNINGS_RAWTYPES)
+        .addAnnotation(AnnotationSpecs.suppressWarnings(RAWTYPES))
         .initializer("$T.create($L)", InstanceFactory.class, optionalKind.absentValueExpression())
         .addJavadoc(
             "A {@link $T} that returns {@code $L}.",
@@ -295,7 +295,7 @@ private TypeSpec presentOptionalFactoryClass(PresentFactorySpec spec) {
         .addModifiers(PRIVATE, STATIC, FINAL)
         .addSuperinterface(spec.factoryType())
         .addJavadoc(
-            "A {@link $T} that uses a delegate {@code $T}.", spec.factoryType(), delegateField.type)
+            "A {@code $T} that uses a delegate {@code $T}.", spec.factoryType(), delegateField.type)
         .addField(delegateField)
         .addMethod(
             constructorBuilder()
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
index c759af798..485f95cf6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -21,7 +21,7 @@
 import static com.squareup.javapoet.MethodSpec.constructorBuilder;
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static com.squareup.javapoet.TypeSpec.classBuilder;
-import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_UNCHECKED;
+import static dagger.internal.codegen.AnnotationSpecs.Suppression.UNCHECKED;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
 import static dagger.internal.codegen.SourceFiles.generateBindingFieldsForDependencies;
@@ -89,7 +89,7 @@ ClassName nameGeneratedType(ProductionBinding binding) {
   Optional<TypeSpec.Builder> write(ClassName generatedTypeName, ProductionBinding binding) {
     checkArgument(binding.bindingElement().isPresent());
 
-    TypeName providedTypeName = TypeName.get(binding.factoryType());
+    TypeName providedTypeName = TypeName.get(binding.contributedType());
     TypeName futureTypeName = listenableFutureOf(providedTypeName);
 
     TypeSpec.Builder factoryBuilder =
@@ -188,7 +188,7 @@ ClassName nameGeneratedType(ProductionBinding binding) {
                     providedTypeName,
                     futureTransform.parameterCodeBlocks()));
     if (futureTransform.hasUncheckedCast()) {
-      applyMethodBuilder.addAnnotation(SUPPRESS_WARNINGS_UNCHECKED);
+      applyMethodBuilder.addAnnotation(AnnotationSpecs.suppressWarnings(UNCHECKED));
     }
 
     factoryBuilder.addMethod(constructorBuilder.build());
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index d913c4351..c3a3e88ea 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -115,11 +115,11 @@ private static Builder builder() {
 
     /**
      * Returns a ProvisionBinding for the given element. If {@code resolvedType} is present, this
-     * will return a resolved binding, with the key & type resolved to the given type (using
+     * will return a resolved binding, with the key and type resolved to the given type (using
      * {@link Types#asMemberOf(DeclaredType, Element)}).
      */
-    ProvisionBinding forInjectConstructor(ExecutableElement constructorElement,
-        Optional<TypeMirror> resolvedType) {
+    ProvisionBinding forInjectConstructor(
+        ExecutableElement constructorElement, Optional<TypeMirror> resolvedType) {
       checkNotNull(constructorElement);
       checkArgument(constructorElement.getKind().equals(CONSTRUCTOR));
       checkArgument(isAnnotationPresent(constructorElement, Inject.class));
diff --git a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
index c09d5d955..c0c51c70c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
@@ -178,8 +178,8 @@ ComponentDescriptor owningComponent(ContributionBinding binding) {
   }
 
   /**
-   * The members-injection binding, regardless of owning component. Empty if these are contribution
-   * bindings.
+   * The members-injection binding, regardless of owning component. Absent if these are contribution
+   * bindings, or if there is no members-injection binding because the type fails validation.
    */
   Optional<MembersInjectionBinding> membersInjectionBinding() {
     ImmutableSet<MembersInjectionBinding> membersInjectionBindings =
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java
index 4c7e0bc86..dd451e97b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java
@@ -20,23 +20,15 @@
 
 import com.google.common.base.Optional;
 import com.google.common.base.Throwables;
-import com.google.common.collect.Iterables;
-import com.google.common.io.CharSink;
-import com.google.common.io.CharSource;
-import com.google.googlejavaformat.java.Formatter;
-import com.google.googlejavaformat.java.FormatterException;
 import com.squareup.javapoet.AnnotationSpec;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.JavaFile;
 import com.squareup.javapoet.TypeSpec;
-import java.io.IOException;
-import java.io.Writer;
 import javax.annotation.Generated;
 import javax.annotation.processing.Filer;
 import javax.annotation.processing.Messager;
 import javax.lang.model.element.Element;
 import javax.lang.model.util.Elements;
-import javax.tools.JavaFileObject;
 
 /**
  * A template class that provides a framework for properly handling IO while generating source files
@@ -77,28 +69,12 @@ void generate(T input, Messager messager) {
   /** Generates a source file to be compiled for {@code T}. */
   void generate(T input) throws SourceFileGenerationException {
     ClassName generatedTypeName = nameGeneratedType(input);
+    Optional<TypeSpec.Builder> type = write(generatedTypeName, input);
+    if (!type.isPresent()) {
+      return;
+    }
     try {
-      Optional<TypeSpec.Builder> type = write(generatedTypeName, input);
-      if (!type.isPresent()) {
-        return;
-      }
-      JavaFile javaFile = buildJavaFile(generatedTypeName, type.get());
-
-      final JavaFileObject sourceFile = filer.createSourceFile(
-          generatedTypeName.toString(),
-          Iterables.toArray(javaFile.typeSpec.originatingElements, Element.class));
-      try {
-        new Formatter().formatSource(
-            CharSource.wrap(javaFile.toString()),
-            new CharSink() {
-              @Override public Writer openStream() throws IOException {
-                return sourceFile.openWriter();
-              }
-            });
-      } catch (FormatterException e) {
-        throw new SourceFileGenerationException(
-            Optional.of(generatedTypeName), e, getElementForErrorReporting(input));
-      }
+      buildJavaFile(generatedTypeName, type.get()).writeTo(filer);
     } catch (Exception e) {
       // if the code above threw a SFGE, use that
       Throwables.propagateIfPossible(e, SourceFileGenerationException.class);
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index 2b7aebda5..43bce4baf 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -16,6 +16,7 @@
 
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
 import static com.google.common.base.Preconditions.checkArgument;
+import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
 import static dagger.internal.codegen.TypeNames.DOUBLE_CHECK;
 import static dagger.internal.codegen.TypeNames.PROVIDER_OF_LAZY;
 import static dagger.internal.codegen.Util.ELEMENT_SIMPLE_NAME;
@@ -23,7 +24,6 @@
 
 import com.google.common.base.CaseFormat;
 import com.google.common.base.Joiner;
-import com.google.common.base.Optional;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
@@ -39,7 +39,6 @@
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.TypeParameterElement;
-import javax.lang.model.type.TypeMirror;
 
 /**
  * Utilities for generating files.
@@ -173,62 +172,12 @@ static ClassName generatedClassNameForBinding(Binding binding) {
     }
   }
 
-  static TypeName parameterizedGeneratedTypeNameForBinding(
-      Binding binding) {
+  static TypeName parameterizedGeneratedTypeNameForBinding(Binding binding) {
     ClassName className = generatedClassNameForBinding(binding);
-    ImmutableList<TypeName> typeParameters = bindingTypeParameters(binding);
-    if (typeParameters.isEmpty()) {
-      return className;
-    } else {
-      return ParameterizedTypeName.get(
-          className,
-          FluentIterable.from(typeParameters).toArray(TypeName.class));
-    }
-  }
-
-  private static Optional<TypeMirror> typeMirrorForBindingTypeParameters(Binding binding)
-      throws AssertionError {
-    switch (binding.bindingType()) {
-      case PROVISION:
-      case PRODUCTION:
-        ContributionBinding contributionBinding = (ContributionBinding) binding;
-        switch (contributionBinding.bindingKind()) {
-          case INJECTION:
-            return Optional.of(contributionBinding.key().type());
-
-          case PROVISION:
-            // For provision bindings, we parameterize creation on the types of
-            // the module, not the types of the binding.
-            // Consider: Module<A, B, C> { @Provides List<B> provideB(B b) { .. }}
-            // The binding is just parameterized on <B>, but we need all of <A, B, C>.
-            return Optional.of(contributionBinding.bindingTypeElement().get().asType());
-
-          case PRODUCTION:
-            // TODO(beder): Can these be treated just like PROVISION?
-            throw new UnsupportedOperationException();
-            
-          default:
-            return Optional.absent();
-        }
-
-      case MEMBERS_INJECTION:
-        return Optional.of(binding.key().type());
-
-      default:
-        throw new AssertionError();
-    }
-  }
-
-  static ImmutableList<TypeName> bindingTypeParameters(
-      Binding binding) {
-    Optional<TypeMirror> typeMirror = typeMirrorForBindingTypeParameters(binding);
-    if (!typeMirror.isPresent()) {
-      return ImmutableList.of();
-    }
-    TypeName bindingTypeName = TypeName.get(typeMirror.get());
-    return bindingTypeName instanceof ParameterizedTypeName
-        ? ImmutableList.copyOf(((ParameterizedTypeName) bindingTypeName).typeArguments)
-        : ImmutableList.<TypeName>of();
+    ImmutableList<TypeVariableName> typeParameters = bindingTypeElementTypeVariableNames(binding);
+    return typeParameters.isEmpty()
+        ? className
+        : ParameterizedTypeName.get(className, Iterables.toArray(typeParameters, TypeName.class));
   }
 
   static ClassName membersInjectorNameForType(TypeElement typeElement) {
@@ -271,6 +220,13 @@ private static String factoryPrefix(ContributionBinding binding) {
   }
 
   static ImmutableList<TypeVariableName> bindingTypeElementTypeVariableNames(Binding binding) {
+    if (binding instanceof ContributionBinding) {
+      ContributionBinding contributionBinding = (ContributionBinding) binding;
+      if (!contributionBinding.bindingKind().equals(INJECTION)
+          && !contributionBinding.requiresModuleInstance()) {
+        return ImmutableList.of();
+      }
+    }
     ImmutableList.Builder<TypeVariableName> builder = ImmutableList.builder();
     for (TypeParameterElement typeParameter :
         binding.bindingTypeElement().get().getTypeParameters()) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
index 9555ba055..050b6bc77 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
@@ -101,11 +101,11 @@ private ExecutableType resolvedSubcomponentFactoryMethod() {
     checkState(
         subcomponentFactoryMethod.isPresent(),
         "%s does not have a factory method for %s",
-        parent.componentDefinitionType(),
-        componentDefinitionType());
+        parent.graph.componentType(),
+        graph.componentType());
     return MoreTypes.asExecutable(
         types.asMemberOf(
-            MoreTypes.asDeclared(parent.componentDefinitionType().asType()),
+            MoreTypes.asDeclared(parent.graph.componentType().asType()),
             subcomponentFactoryMethod.get().methodElement()));
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/UnwrappedMapKeyGenerator.java b/compiler/src/main/java/dagger/internal/codegen/UnwrappedMapKeyGenerator.java
index 47a6293a0..86f8d84b9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/UnwrappedMapKeyGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/UnwrappedMapKeyGenerator.java
@@ -37,7 +37,7 @@
  *   }
  *
  *   {@literal @interface} Bar {
- *     Class<?> baz();
+ *     {@literal Class<?> baz();}
  *   }
  * </pre>
  *
@@ -47,7 +47,7 @@
  *   public final class FooCreator {
  *     private FooCreator() {}
  *
- *     public static Bar createBar(Class<?> baz) { … }
+ *     public static Bar createBar({@literal Class<?> baz}) { … }
  *   }
  * </pre>
  */
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index 09c547d2c..36a13b28a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -20,6 +20,8 @@
 import static com.google.auto.common.MoreElements.hasModifiers;
 import static com.google.auto.common.MoreTypes.asDeclared;
 import static com.google.common.collect.Lists.asList;
+import static java.util.stream.Collectors.collectingAndThen;
+import static java.util.stream.Collectors.toList;
 import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.PRIVATE;
@@ -30,12 +32,14 @@
 import com.google.common.base.Function;
 import com.google.common.base.Optional;
 import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import dagger.Binds;
 import dagger.Provides;
 import dagger.producers.Produces;
 import java.lang.annotation.Annotation;
 import java.util.Comparator;
+import java.util.stream.Collector;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementVisitor;
@@ -45,6 +49,7 @@
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.SimpleElementVisitor6;
+import javax.lang.model.util.Types;
 
 /**
  * Utilities for handling types in annotation processors
@@ -54,9 +59,9 @@
    * Returns true if the passed {@link TypeElement} requires a passed instance in order to be used
    * within a component.
    */
-  static boolean requiresAPassedInstance(Elements elements, TypeElement typeElement) {
+  static boolean requiresAPassedInstance(Elements elements, Types types, TypeElement typeElement) {
     ImmutableSet<ExecutableElement> methods =
-        MoreElements.getLocalAndInheritedMethods(typeElement, elements);
+        getLocalAndInheritedMethods(typeElement, types, elements);
     boolean foundInstanceMethod = false;
     for (ExecutableElement method : methods) {
       if (method.getModifiers().contains(ABSTRACT)
@@ -130,8 +135,8 @@ private static boolean requiresEnclosingInstance(TypeElement typeElement) {
   }
 
   static ImmutableSet<ExecutableElement> getUnimplementedMethods(
-      Elements elements, TypeElement type) {
-    return FluentIterable.from(getLocalAndInheritedMethods(type, elements))
+      Elements elements, Types types, TypeElement type) {
+    return FluentIterable.from(getLocalAndInheritedMethods(type, types, elements))
         .filter(hasModifiers(ABSTRACT))
         .toSet();
   }
@@ -217,5 +222,21 @@ static boolean isAnnotationPresent(Element element, TypeMirror annotationType) {
         .thenComparing(Optional::get);
   }
 
+  /**
+   * Returns a {@link Collector} that accumulates the input elements into a new {@link
+   * ImmutableList}, in encounter order.
+   */
+  static <T> Collector<T, ?, ImmutableList<T>> toImmutableList() {
+    return collectingAndThen(toList(), ImmutableList::copyOf);
+  }
+
+  /**
+   * Returns a {@link Collector} that accumulates the input elements into a new {@link
+   * ImmutableSet}, in encounter order.
+   */
+  static <T> Collector<T, ?, ImmutableSet<T>> toImmutableSet() {
+    return collectingAndThen(toList(), ImmutableSet::copyOf);
+  }
+
   private Util() {}
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/GraphValidationScopingTest.java b/compiler/src/test/java/dagger/internal/codegen/GraphValidationScopingTest.java
index 6f850cdb0..1bdea110a 100644
--- a/compiler/src/test/java/dagger/internal/codegen/GraphValidationScopingTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/GraphValidationScopingTest.java
@@ -63,9 +63,10 @@
         "  @Provides long integer() { return 0L; }",
         "  @Provides float floatingPoint() { return 0.0f; }",
         "}");
-    String errorMessage = "test.MyComponent (unscoped) may not reference scoped bindings:\n"
-        + "      @Provides @Singleton String test.ScopedModule.string()\n"
-        + "      @Singleton class test.ScopedType";
+    String errorMessage =
+        "test.MyComponent (unscoped) may not reference scoped bindings:\n"
+            + "      @Singleton class test.ScopedType\n"
+            + "      @Provides @Singleton String test.ScopedModule.string()";
     assertAbout(javaSources())
         .that(asList(componentFile, typeFile, moduleFile))
         .processedWith(new ComponentProcessor())
@@ -114,10 +115,11 @@
         "  @Provides long integer() { return 0L; }", // unscoped - valid
         "  @Provides @Singleton float floatingPoint() { return 0.0f; }", // same scope - valid
         "}");
-    String errorMessage = "test.MyComponent scoped with @Singleton "
-        + "may not reference bindings with different scopes:\n"
-        + "      @Provides @test.PerTest String test.ScopedModule.string()\n"
-        + "      @test.PerTest class test.ScopedType";
+    String errorMessage =
+        "test.MyComponent scoped with @Singleton "
+            + "may not reference bindings with different scopes:\n"
+            + "      @test.PerTest class test.ScopedType\n"
+            + "      @Provides @test.PerTest String test.ScopedModule.string()";
     assertAbout(javaSources())
         .that(asList(componentFile, scopeFile, typeFile, moduleFile))
         .processedWith(new ComponentProcessor())
diff --git a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
index d67855df5..34f77ea46 100644
--- a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
@@ -207,6 +207,38 @@ public void membersInjectDependsOnUnboundedType() {
         .onLine(7);
   }
 
+  @Test
+  public void invalidMembersInjection() {
+    JavaFileObject injected =
+        JavaFileObjects.forSourceLines(
+            "test.Injected",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "final class Injected {",
+            "  @Inject static Object object;",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface TestComponent {",
+            "  void inject(Injected injected);",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(injected, component))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("static fields")
+        .in(injected)
+        .onLine(6);
+  }
+
   @Test public void cyclicDependency() {
     JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
         "package test;",
@@ -2226,4 +2258,8 @@ public void multibindingContributionBetweenAncestorComponentAndEntrypointCompone
         .in(parent)
         .onLine(4);
   }
+
+  private String error(String... lines) {
+    return Joiner.on("\n      ").join(lines);
+  }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
index 6382d8d27..a23a5008b 100644
--- a/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
@@ -222,28 +222,30 @@
         "class GenericClass<T> {",
         "  @Inject GenericClass() {}",
         "}");
-    JavaFileObject expected = JavaFileObjects.forSourceLines("test.GenericClass_Factory",
-        "package test;",
-        "",
-        "import dagger.internal.Factory;",
-        "import javax.annotation.Generated;",
-        "",
-        "@SuppressWarnings(\"rawtypes\")",
-        GENERATED_ANNOTATION,
-        "public enum GenericClass_Factory implements Factory<GenericClass> {",
-        "  INSTANCE;",
-        "",
-        "  @Override",
-        "  public GenericClass get() {",
-        "    return new GenericClass();",
-        "  }",
-        "",
-        "  @SuppressWarnings(\"unchecked\")",
-        "  public static <T> Factory<GenericClass<T>> create() {",
-        "    return (Factory) INSTANCE;",
-        "  }",
-        "",
-        "}");
+    JavaFileObject expected =
+        JavaFileObjects.forSourceLines(
+            "test.GenericClass_Factory",
+            "package test;",
+            "",
+            "import dagger.internal.Factory;",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class GenericClass_Factory<T> implements Factory<GenericClass<T>> {",
+            "  @SuppressWarnings(\"rawtypes\")",
+            "  private static final GenericClass_Factory INSTANCE = new GenericClass_Factory();",
+            "",
+            "  @Override",
+            "  public GenericClass<T> get() {",
+            "    return new GenericClass<T>();",
+            "  }",
+            "",
+            "  @SuppressWarnings({\"rawtypes\", \"unchecked\"})",
+            "  public static <T> Factory<GenericClass<T>> create() {",
+            "    return (Factory) INSTANCE;",
+            "  }",
+            "",
+            "}");
     assertAbout(javaSource()).that(file)
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
@@ -1271,24 +1273,26 @@ public void noDeps() {
         "final class SimpleType {",
         "  @Inject SimpleType() {}",
         "}");
-    JavaFileObject factory = JavaFileObjects.forSourceLines("test.SimpleType_Factory",
-        "package test;",
-        "",
-        "import dagger.internal.Factory;",
-        "import javax.annotation.Generated;",
-        "",
-        GENERATED_ANNOTATION,
-        "public enum SimpleType_Factory implements Factory<SimpleType> {",
-        "  INSTANCE;",
-        "",
-        "  @Override public SimpleType get() {",
-        "    return new SimpleType();",
-        "  }",
-        "",
-        "  public static Factory<SimpleType> create() {",
-        "    return INSTANCE;",
-        "  }",
-        "}");
+    JavaFileObject factory =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleType_Factory",
+            "package test;",
+            "",
+            "import dagger.internal.Factory;",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class SimpleType_Factory implements Factory<SimpleType> {",
+            "  private static final SimpleType_Factory INSTANCE = new SimpleType_Factory();",
+            "",
+            "  @Override public SimpleType get() {",
+            "    return new SimpleType();",
+            "  }",
+            "",
+            "  public static Factory<SimpleType> create() {",
+            "    return INSTANCE;",
+            "  }",
+            "}");
     assertAbout(javaSource())
         .that(simpleType)
         .processedWith(new ComponentProcessor())
@@ -1315,25 +1319,26 @@ public void noDeps() {
         "    void inject(B b);",
         "  }",
         "}");
-    JavaFileObject aFactory = JavaFileObjects.forSourceLines(
-        "test.OuterType_A_Factory",
-        "package test;",
-        "",
-        "import dagger.internal.Factory;",
-        "import javax.annotation.Generated;",
-        "",
-        GENERATED_ANNOTATION,
-        "public enum OuterType_A_Factory implements Factory<OuterType.A> {",
-        "  INSTANCE;",
-        "",
-        "  @Override public OuterType.A get() {",
-        "    return new OuterType.A();",
-        "  }",
-        "",
-        "  public static Factory<OuterType.A> create() {",
-        "    return INSTANCE;",
-        "  }",
-        "}");
+    JavaFileObject aFactory =
+        JavaFileObjects.forSourceLines(
+            "test.OuterType_A_Factory",
+            "package test;",
+            "",
+            "import dagger.internal.Factory;",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class OuterType_A_Factory implements Factory<OuterType.A> {",
+            "  private static final OuterType_A_Factory INSTANCE = new OuterType_A_Factory();",
+            "",
+            "  @Override public OuterType.A get() {",
+            "    return new OuterType.A();",
+            "  }",
+            "",
+            "  public static Factory<OuterType.A> create() {",
+            "    return INSTANCE;",
+            "  }",
+            "}");
     assertAbout(javaSources()).that(ImmutableList.of(nestedTypesFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
diff --git a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
index 7f167647d..202c8c485 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
@@ -1050,6 +1050,10 @@ public void genericSubclassedModule() {
             "  @Provides static Object provideNonGenericType() {",
             "    return new Object();",
             "  }",
+            "",
+            "  @Provides static String provideNonGenericTypeWithDeps(Object o) {",
+            "    return o.toString();",
+            "  }",
             "}");
 
     JavaFileObject provideMapStringNumberFactory =
@@ -1063,9 +1067,10 @@ public void genericSubclassedModule() {
             "import javax.annotation.Generated;",
             "",
             GENERATED_ANNOTATION,
-            "public enum ParameterizedModule_ProvideMapStringNumberFactory",
+            "public final class ParameterizedModule_ProvideMapStringNumberFactory",
             "    implements Factory<Map<String, Number>> {",
-            "  INSTANCE;",
+            "  private static final ParameterizedModule_ProvideMapStringNumberFactory INSTANCE =",
+            "      new ParameterizedModule_ProvideMapStringNumberFactory();",
             "",
             "  @Override",
             "  public Map<String, Number> get() {",
@@ -1088,9 +1093,10 @@ public void genericSubclassedModule() {
             "import javax.annotation.Generated;",
             "",
             GENERATED_ANNOTATION,
-            "public enum ParameterizedModule_ProvideNonGenericTypeFactory",
+            "public final class ParameterizedModule_ProvideNonGenericTypeFactory",
             "    implements Factory<Object> {",
-            "  INSTANCE;",
+            "  private static final ParameterizedModule_ProvideNonGenericTypeFactory INSTANCE = ",
+            "      new ParameterizedModule_ProvideNonGenericTypeFactory();",
             "",
             "  @Override",
             "  public Object get() {",
@@ -1103,12 +1109,48 @@ public void genericSubclassedModule() {
             "  }",
             "}");
 
+    JavaFileObject provideNonGenericTypeWithDepsFactory =
+        JavaFileObjects.forSourceLines(
+            "test.ParameterizedModule_ProvideNonGenericTypeWithDepsFactory;",
+            "package test;",
+            "",
+            "import dagger.internal.Factory;",
+            "import dagger.internal.Preconditions;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class ParameterizedModule_ProvideNonGenericTypeWithDepsFactory",
+            "    implements Factory<String> {",
+            "  private final Provider<Object> oProvider;",
+            "",
+            "  public ParameterizedModule_ProvideNonGenericTypeWithDepsFactory(",
+            "      Provider<Object> oProvider) {",
+            "    assert oProvider != null;",
+            "    this.oProvider = oProvider;",
+            "  }",
+            "",
+            "  @Override",
+            "  public String get() {",
+            "    return Preconditions.checkNotNull(",
+            "        ParameterizedModule.provideNonGenericTypeWithDeps(oProvider.get()),",
+            "        " + NPE_LITERAL + ");",
+            "  }",
+            "",
+            "  public static Factory<String> create(Provider<Object> oProvider) {",
+            "    return new ParameterizedModule_ProvideNonGenericTypeWithDepsFactory(oProvider);",
+            "  }",
+            "}");
+
     assertAbout(javaSource())
         .that(moduleFile)
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and()
-        .generatesSources(provideMapStringNumberFactory, provideNonGenericTypeFactory);
+        .generatesSources(
+            provideMapStringNumberFactory,
+            provideNonGenericTypeFactory,
+            provideNonGenericTypeWithDepsFactory);
   }
 
   @Test public void providesMethodMultipleQualifiers() {
diff --git a/core/pom.xml b/core/pom.xml
index ec7e622fd..96967f7c8 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -26,11 +26,6 @@
   <artifactId>dagger</artifactId>
   <name>Dagger</name>
 
-  <properties>
-    <!-- Runtime must remain Java6 to support android. -->
-    <java.version>1.6</java.version>
-  </properties>
-
   <dependencies>
     <dependency>
       <groupId>javax.inject</groupId>
@@ -56,6 +51,36 @@
 
   <build>
     <plugins>
+      <plugin>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <configuration>
+          <compilerArgument>-Xlint:all</compilerArgument>
+          <showWarnings>true</showWarnings>
+          <showDeprecation>true</showDeprecation>
+        </configuration>
+        <executions>
+          <execution>
+            <id>default-compile</id>
+            <goals>
+              <goal>compile</goal>
+            </goals>
+            <configuration>
+              <source>1.7</source>
+              <target>1.7</target>
+            </configuration>
+          </execution>
+          <execution>
+            <id>default-testCompile</id>
+            <goals>
+              <goal>testCompile</goal>
+            </goals>
+            <configuration>
+              <source>1.8</source>
+              <target>1.8</target>
+            </configuration>
+          </execution>
+        </executions>
+      </plugin>
       <plugin>
         <groupId>org.codehaus.mojo</groupId>
         <artifactId>animal-sniffer-maven-plugin</artifactId>
diff --git a/core/src/test/java/dagger/internal/DoubleCheckTest.java b/core/src/test/java/dagger/internal/DoubleCheckTest.java
index 0a5a55160..20abbe566 100644
--- a/core/src/test/java/dagger/internal/DoubleCheckTest.java
+++ b/core/src/test/java/dagger/internal/DoubleCheckTest.java
@@ -58,13 +58,7 @@ public void lazy_nullPointerException() {
   }
 
   private static final Provider<Object> DOUBLE_CHECK_OBJECT_PROVIDER =
-      DoubleCheck.provider(
-          new Provider<Object>() {
-            @Override
-            public Object get() {
-              return new Object();
-            }
-          });
+      DoubleCheck.provider(Object::new);
 
   @Test
   public void doubleWrapping_provider() {
@@ -90,12 +84,9 @@ public void get() throws Exception {
     List<Callable<Object>> tasks = Lists.newArrayListWithCapacity(numThreads);
     for (int i = 0; i < numThreads; i++) {
       tasks.add(
-          new Callable<Object>() {
-            @Override
-            public Object call() throws Exception {
-              latch.countDown();
-              return lazy.get();
-            }
+          () -> {
+            latch.countDown();
+            return lazy.get();
           });
     }
 
@@ -130,13 +121,8 @@ public Object get() {
 
   @Test public void reentranceWithoutCondition_throwsStackOverflow() {
     final AtomicReference<Provider<Object>> doubleCheckReference =
-        new AtomicReference<Provider<Object>>();
-    Provider<Object> doubleCheck = DoubleCheck.provider(new Provider<Object>() {
-      @Override
-      public Object get() {
-        return doubleCheckReference.get().get();
-      }
-    });
+        new AtomicReference<>();
+    Provider<Object> doubleCheck = DoubleCheck.provider(() -> doubleCheckReference.get().get());
     doubleCheckReference.set(doubleCheck);
     try {
       doubleCheck.get();
@@ -146,35 +132,29 @@ public Object get() {
 
   @Test public void reentranceReturningSameInstance() {
     final AtomicReference<Provider<Object>> doubleCheckReference =
-        new AtomicReference<Provider<Object>>();
+        new AtomicReference<>();
     final AtomicInteger invocationCount = new AtomicInteger();
     final Object object = new Object();
-    Provider<Object> doubleCheck = DoubleCheck.provider(new Provider<Object>() {
-     @Override
-      public Object get() {
-         if (invocationCount.incrementAndGet() == 1) {
-          doubleCheckReference.get().get();
-        }
-        return object;
-      }
-    });
+    Provider<Object> doubleCheck = DoubleCheck.provider(() -> {
+        if (invocationCount.incrementAndGet() == 1) {
+         doubleCheckReference.get().get();
+       }
+       return object;
+     });
     doubleCheckReference.set(doubleCheck);
     assertThat(doubleCheck.get()).isSameAs(object);
   }
 
   @Test public void reentranceReturningDifferentInstances_throwsIllegalStateException() {
     final AtomicReference<Provider<Object>> doubleCheckReference =
-        new AtomicReference<Provider<Object>>();
+        new AtomicReference<>();
     final AtomicInteger invocationCount = new AtomicInteger();
-    Provider<Object> doubleCheck = DoubleCheck.provider(new Provider<Object>() {
-     @Override
-      public Object get() {
-        if (invocationCount.incrementAndGet() == 1) {
-          doubleCheckReference.get().get();
-        }
-        return new Object();
-      }
-    });
+    Provider<Object> doubleCheck = DoubleCheck.provider(() -> {
+       if (invocationCount.incrementAndGet() == 1) {
+         doubleCheckReference.get().get();
+       }
+       return new Object();
+     });
     doubleCheckReference.set(doubleCheck);
     try {
       doubleCheck.get();
diff --git a/core/src/test/java/dagger/internal/MapProviderFactoryTest.java b/core/src/test/java/dagger/internal/MapProviderFactoryTest.java
index 3b17641e0..5598ff223 100644
--- a/core/src/test/java/dagger/internal/MapProviderFactoryTest.java
+++ b/core/src/test/java/dagger/internal/MapProviderFactoryTest.java
@@ -63,7 +63,7 @@ public void iterationOrder() {
         .put("four", p4)
         .build();
 
-    Map<String, Provider<Integer>> expectedMap = new LinkedHashMap<String, Provider<Integer>>();
+    Map<String, Provider<Integer>> expectedMap = new LinkedHashMap<>();
     expectedMap.put("two", p2);
     expectedMap.put("one", p1);
     expectedMap.put("three", p3);
@@ -75,12 +75,6 @@ public void iterationOrder() {
   }
 
   private static Provider<Integer> incrementingIntegerProvider(int seed) {
-    final AtomicInteger value = new AtomicInteger(seed);
-    return new Provider<Integer>() {
-      @Override
-      public Integer get() {
-        return value.getAndIncrement();
-      }
-    };
+    return new AtomicInteger(seed)::getAndIncrement;
   }
 }
diff --git a/core/src/test/java/dagger/internal/SetFactoryTest.java b/core/src/test/java/dagger/internal/SetFactoryTest.java
index 575292e23..0032578c6 100644
--- a/core/src/test/java/dagger/internal/SetFactoryTest.java
+++ b/core/src/test/java/dagger/internal/SetFactoryTest.java
@@ -38,7 +38,7 @@
   @Test
   public void providerReturnsNull() {
     Factory<Set<Integer>> factory =
-        SetFactory.<Integer>builder(0, 1).addCollectionProvider(providerOf((Set<Integer>) null)).build();
+        SetFactory.<Integer>builder(0, 1).addCollectionProvider(() -> null).build();
     thrown.expect(NullPointerException.class);
     factory.get();
   }
@@ -46,16 +46,16 @@ public void providerReturnsNull() {
   @Test
   public void providerReturnsNullSet() {
     Factory<Set<Integer>> factory =
-        SetFactory.<Integer>builder(1, 0).addProvider(providerOf((Integer) null)).build();
+        SetFactory.<Integer>builder(1, 0).addProvider(() -> null).build();
     thrown.expect(NullPointerException.class);
     factory.get();
   }
 
   @Test
   public void providerReturnsSetWithNullElement() {
-    Set<Integer> set = new LinkedHashSet<Integer>(Arrays.asList(1, null, 3));
+    Set<Integer> set = new LinkedHashSet<>(Arrays.asList(1, null, 3));
     Factory<Set<Integer>> factory =
-        SetFactory.<Integer>builder(0, 1).addCollectionProvider(providerOf(set)).build();
+        SetFactory.<Integer>builder(0, 1).addCollectionProvider(() -> set).build();
     thrown.expect(NullPointerException.class);
     factory.get();
   }
@@ -74,32 +74,13 @@ public void invokesProvidersEveryTime() {
     assertThat(factory.get()).containsExactly(2, 12, 24, 25, 34, 35);
   }
 
-  private static <T> Provider<T> providerOf(final T value) {
-    return new Provider<T>() {
-      @Override
-      public T get() {
-        return value;
-      }
-    };
-  }
-
   private static Provider<Integer> incrementingIntegerProvider(int seed) {
     final AtomicInteger value = new AtomicInteger(seed);
-    return new Provider<Integer>() {
-      @Override
-      public Integer get() {
-        return value.getAndIncrement();
-      }
-    };
+    return value::getAndIncrement;
   }
 
   private static Provider<Set<Integer>> incrementingIntegerSetProvider(int seed) {
     final AtomicInteger value = new AtomicInteger(seed);
-    return new Provider<Set<Integer>>() {
-      @Override
-      public Set<Integer> get() {
-        return ImmutableSet.of(value.getAndIncrement(), value.getAndIncrement());
-      }
-    };
+    return () -> ImmutableSet.of(value.getAndIncrement(), value.getAndIncrement());
   }
 }
diff --git a/core/src/test/java/dagger/internal/SingleCheckTest.java b/core/src/test/java/dagger/internal/SingleCheckTest.java
index bcb6d996b..0c043fd4c 100644
--- a/core/src/test/java/dagger/internal/SingleCheckTest.java
+++ b/core/src/test/java/dagger/internal/SingleCheckTest.java
@@ -18,6 +18,7 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
+import java.util.concurrent.atomic.AtomicInteger;
 import javax.inject.Provider;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -35,16 +36,8 @@ public void create_nullPointerException() {
 
   @Test
   public void get() {
-    Provider<Integer> provider =
-        SingleCheck.provider(
-            new Factory<Integer>() {
-              int i = 0;
-
-              @Override
-              public Integer get() {
-                return i++;
-              }
-            });
+    AtomicInteger integer = new AtomicInteger();
+    Provider<Integer> provider = SingleCheck.provider(integer::getAndIncrement);
     assertThat(provider.get()).isEqualTo(0);
     assertThat(provider.get()).isEqualTo(0);
     assertThat(provider.get()).isEqualTo(0);
diff --git a/pom.xml b/pom.xml
index 3f81dc608..8df415f51 100644
--- a/pom.xml
+++ b/pom.xml
@@ -88,22 +88,22 @@
       <dependency>
         <groupId>com.google.guava</groupId>
         <artifactId>guava</artifactId>
-        <version>19.0</version>
+        <version>20.0-rc1</version>
       </dependency>
       <dependency>
         <groupId>com.google.guava</groupId>
         <artifactId>guava-testlib</artifactId>
-        <version>19.0</version>
+        <version>20.0-rc1</version>
       </dependency>
       <dependency>
         <groupId>com.google.googlejavaformat</groupId>
         <artifactId>google-java-format</artifactId>
-        <version>1.0</version>
+        <version>1.1</version>
       </dependency>
       <dependency>
         <groupId>com.google.auto</groupId>
         <artifactId>auto-common</artifactId>
-        <version>0.7</version>
+        <version>0.8</version>
       </dependency>
       <dependency>
         <groupId>com.google.auto.factory</groupId>
@@ -118,7 +118,7 @@
       <dependency>
         <groupId>com.google.auto.value</groupId>
         <artifactId>auto-value</artifactId>
-        <version>1.3</version>
+        <version>1.4-rc1</version>
       </dependency>
       <dependency>
         <groupId>com.google.errorprone</groupId>
@@ -198,6 +198,7 @@
           <windowtitle>Dagger Dependency Injection ${project.version} API</windowtitle>
           <doctitle>Dagger Dependency Injection ${project.version} API</doctitle>
           <docfilessubdirs>true</docfilessubdirs>
+          <additionalparam>-Xdoclint:html,reference,syntax</additionalparam>
         </configuration>
       </plugin>
     </plugins>
