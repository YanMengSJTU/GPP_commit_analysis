diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index d9d48b6e4..95b01f38b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -76,6 +76,7 @@
 import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_UNCHECKED;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.ENUM_INSTANCE;
+import static dagger.internal.codegen.ContributionBinding.Kind.PROVISION;
 import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD;
 import static dagger.internal.codegen.FrameworkDependency.frameworkDependenciesForBinding;
 import static dagger.internal.codegen.MapKeys.getMapKeyExpression;
@@ -116,6 +117,7 @@
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.STATIC;
 import static javax.lang.model.type.TypeKind.DECLARED;
 import static javax.lang.model.type.TypeKind.VOID;
 
@@ -934,11 +936,14 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
 
       case COMPONENT_PROVISION:
         {
-          TypeElement dependencyType = dependencyTypeForBinding(binding);
-          String dependencyVariable = simpleVariableName(dependencyType);
+          TypeElement bindingTypeElement =
+              graph.componentDescriptor().dependencyMethodIndex().get(binding.bindingElement());
+          String localFactoryVariable = simpleVariableName(bindingTypeElement);
           CodeBlock callFactoryMethod =
               CodeBlock.of(
-                  "$L.$L()", dependencyVariable, binding.bindingElement().get().getSimpleName());
+                  "$L.$L()",
+                  localFactoryVariable,
+                  binding.bindingElement().getSimpleName().toString());
           // TODO(sameb): This throws a very vague NPE right now.  The stack trace doesn't
           // help to figure out what the method or return type is.  If we include a string
           // of the return type or method name in the error message, that can defeat obfuscation.
@@ -964,10 +969,10 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
                       "}"),
               /* 1 */ FACTORY,
               /* 2 */ bindingKeyTypeName,
-              /* 3 */ getComponentContributionExpression(dependencyType),
+              /* 3 */ getComponentContributionExpression(bindingTypeElement),
               /* 4 */ nullableAnnotation(binding.nullableType()),
-              /* 5 */ TypeName.get(dependencyType.asType()),
-              /* 6 */ dependencyVariable,
+              /* 5 */ TypeName.get(bindingTypeElement.asType()),
+              /* 6 */ localFactoryVariable,
               /* 7 */ getMethodBody);
         }
 
@@ -982,14 +987,15 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
                     "}"),
             /* 1 */ FACTORY,
             /* 2 */ bindingKeyTypeName,
-            /* 3 */ binding.bindingElement().get().getSimpleName());
+            /* 3 */ binding.bindingElement().getSimpleName().toString());
 
       case INJECTION:
       case PROVISION:
         {
           List<CodeBlock> arguments =
               Lists.newArrayListWithCapacity(binding.dependencies().size() + 1);
-          if (binding.requiresModuleInstance()) {
+          if (binding.bindingKind().equals(PROVISION)
+              && !binding.bindingElement().getModifiers().contains(STATIC)) {
             arguments.add(getComponentContributionExpression(binding.contributingModule().get()));
           }
           arguments.addAll(getDependencyArguments(binding));
@@ -1006,7 +1012,8 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
 
       case COMPONENT_PRODUCTION:
         {
-          TypeElement dependencyType = dependencyTypeForBinding(binding);
+          TypeElement bindingTypeElement =
+              graph.componentDescriptor().dependencyMethodIndex().get(binding.bindingElement());
           return CodeBlock.of(
               Joiner.on('\n')
                   .join(
@@ -1019,10 +1026,10 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
               /* 1 */ PRODUCER,
               /* 2 */ TypeName.get(binding.key().type()),
               /* 3 */ LISTENABLE_FUTURE,
-              /* 4 */ getComponentContributionExpression(dependencyType),
-              /* 5 */ binding.bindingElement().get().getSimpleName(),
-              /* 6 */ TypeName.get(dependencyType.asType()),
-              /* 7 */ simpleVariableName(dependencyType));
+              /* 4 */ getComponentContributionExpression(bindingTypeElement),
+              /* 5 */ binding.bindingElement().getSimpleName().toString(),
+              /* 6 */ TypeName.get(bindingTypeElement.asType()),
+              /* 7 */ simpleVariableName(bindingTypeElement));
         }
 
       case IMMEDIATE:
@@ -1030,8 +1037,8 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
         {
           List<CodeBlock> arguments =
               Lists.newArrayListWithCapacity(binding.implicitDependencies().size() + 2);
-          if (binding.requiresModuleInstance()) {
-            arguments.add(getComponentContributionExpression(binding.contributingModule().get()));
+          if (!binding.bindingElement().getModifiers().contains(STATIC)) {
+            arguments.add(getComponentContributionExpression(binding.bindingTypeElement()));
           }
           arguments.addAll(getDependencyArguments(binding));
 
@@ -1058,10 +1065,6 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
     }
   }
 
-  private TypeElement dependencyTypeForBinding(ContributionBinding binding) {
-    return graph.componentDescriptor().dependencyMethodIndex().get(binding.bindingElement().get());
-  }
-
   private CodeBlock decorateForScope(CodeBlock factoryCreate, Scope scope) {
       return CodeBlock.of(
           "$T.provider($L)",
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingDeclaration.java b/compiler/src/main/java/dagger/internal/codegen/BindingDeclaration.java
index f71c83287..7fe894edc 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingDeclaration.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingDeclaration.java
@@ -15,54 +15,59 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreElements;
 import com.google.common.base.Function;
 import com.google.common.base.Optional;
 import com.google.common.base.Predicate;
 import dagger.internal.codegen.Key.HasKey;
 import java.util.Set;
 import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
 
+import static dagger.internal.codegen.Util.AS_DECLARED_TYPE;
 import static dagger.internal.codegen.Util.ENCLOSING_TYPE_ELEMENT;
-import static javax.lang.model.element.Modifier.ABSTRACT;
-import static javax.lang.model.element.Modifier.STATIC;
 
 /** An object that declares or specifies a binding. */
 abstract class BindingDeclaration implements HasKey {
 
-  /**
-   * The {@link Element} that declares the binding. Absent for bindings without identifying
-   * declarations.
-   */
-  abstract Optional<Element> bindingElement();
+  /** The {@link Element} that declares the binding. */
+  abstract Element bindingElement();
 
   /**
-   * The type enclosing the {@link #bindingElement()}, or {@link Optional#absent()} if {@link
-   * #bindingElement()} is absent.
+   * The {@link ExecutableElement} that declares the binding. Equivalent to
+   * {@code MoreElements.asExecutable(bindingElement())}.
+   *
+   * @throws IllegalStateException if {@link #bindingElement()} is not an executable element
    */
-  Optional<TypeElement> bindingTypeElement() {
-    return bindingElement()
-        .transform(
-            new Function<Element, TypeElement>() {
-              @Override
-              public TypeElement apply(Element element) {
-                return element.accept(ENCLOSING_TYPE_ELEMENT, null);
-              }
-            });
+  ExecutableElement bindingElementAsExecutable() {
+    try {
+      return MoreElements.asExecutable(bindingElement());
+    } catch (IllegalArgumentException e) {
+      throw new IllegalStateException(e);
+    }
   }
-  
+
+  /** The type enclosing the {@link #bindingElement()}. */
+  TypeElement bindingTypeElement() {
+    return ENCLOSING_TYPE_ELEMENT.visit(bindingElement());
+  }
+
   /**
-   * The installed module class that contributed the {@link #bindingElement()}. May be a subclass of
-   * the class that contains {@link #bindingElement()}. Absent if {@link #bindingElement()} is
-   * absent.
+   * The installed module class that contributed the {@link #bindingElement()}. May be a subclass
+   * of the class that contains {@link #bindingElement()}.
    */
   abstract Optional<TypeElement> contributingModule();
 
   /**
-   * A function that returns a singleton set containing the {@link #contributingModule()} for
-   * binding declarations that have one, and an empty set for those that don't.
+   * The type of {@link #contributingModule()}.
    */
+  Optional<DeclaredType> contributingModuleType() {
+    return contributingModule().transform(AS_DECLARED_TYPE);
+  }
+
   static final Function<BindingDeclaration, Set<TypeElement>> CONTRIBUTING_MODULE =
       new Function<BindingDeclaration, Set<TypeElement>>() {
         @Override
@@ -71,39 +76,12 @@ public TypeElement apply(Element element) {
         }
       };
 
-  /**
-   * {@code true} if {@link #contributingModule()} is present and this is a nonabstract instance
-   * method.
-   */
-  boolean requiresModuleInstance() {
-    if (!bindingElement().isPresent() || !contributingModule().isPresent()) {
-      return false;
-    }
-    Set<Modifier> modifiers = bindingElement().get().getModifiers();
-    return !modifiers.contains(ABSTRACT) && !modifiers.contains(STATIC);
+  static Predicate<BindingDeclaration> bindingElementHasModifier(final Modifier modifier) {
+    return new Predicate<BindingDeclaration>() {
+      @Override
+      public boolean apply(BindingDeclaration bindingDeclaration) {
+        return bindingDeclaration.bindingElement().getModifiers().contains(modifier);
+      }
+    };
   }
-
-  /**
-   * A predicate that passes for binding declarations for which {@link #requiresModuleInstance()} is
-   * {@code true}.
-   */
-  static final Predicate<BindingDeclaration> REQUIRES_MODULE_INSTANCE =
-      new Predicate<BindingDeclaration>() {
-        @Override
-        public boolean apply(BindingDeclaration bindingDeclaration) {
-          return bindingDeclaration.requiresModuleInstance();
-        }
-      };
-
-  /**
-   * A predicate that passes for binding declarations for which {@link #bindingElement()} is
-   * present.
-   */
-  static final Predicate<BindingDeclaration> HAS_BINDING_ELEMENT =
-      new Predicate<BindingDeclaration>() {
-        @Override
-        public boolean apply(BindingDeclaration bindingDeclaration) {
-          return bindingDeclaration.bindingElement().isPresent();
-        }
-      };
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingDeclarationFormatter.java b/compiler/src/main/java/dagger/internal/codegen/BindingDeclarationFormatter.java
index 221881821..d682ea486 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingDeclarationFormatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingDeclarationFormatter.java
@@ -15,12 +15,7 @@
  */
 package dagger.internal.codegen;
 
-import com.google.auto.common.MoreElements;
-import javax.lang.model.element.Element;
-
-import static com.google.common.base.Preconditions.checkArgument;
 import static dagger.internal.codegen.ErrorMessages.stripCommonTypePrefixes;
-import static dagger.internal.codegen.Util.AS_DECLARED_TYPE;
 
 /**
  * Formats a {@link BindingDeclaration} into a {@link String} suitable for use in error messages.
@@ -34,20 +29,16 @@
 
   @Override
   public String format(BindingDeclaration bindingDeclaration) {
-    checkArgument(
-        bindingDeclaration.bindingElement().isPresent(),
-        "Cannot format bindings without source elements: %s",
-        bindingDeclaration);
-    Element bindingElement = bindingDeclaration.bindingElement().get();
-    switch (bindingElement.asType().getKind()) {
+    switch (bindingDeclaration.bindingElement().asType().getKind()) {
       case EXECUTABLE:
         return methodSignatureFormatter.format(
-            MoreElements.asExecutable(bindingElement),
-            bindingDeclaration.contributingModule().transform(AS_DECLARED_TYPE));
+            bindingDeclaration.bindingElementAsExecutable(),
+            bindingDeclaration.contributingModuleType());
       case DECLARED:
-        return stripCommonTypePrefixes(bindingElement.asType().toString());
+        return stripCommonTypePrefixes(bindingDeclaration.bindingElement().asType().toString());
       default:
-        throw new IllegalArgumentException("Formatting unsupported for element: " + bindingElement);
+        throw new IllegalArgumentException(
+            "Formatting unsupported for element: " + bindingDeclaration.bindingElement());
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index a2bdf2fe9..ee00ed823 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -79,6 +79,7 @@
 import static dagger.internal.codegen.Key.indexByKey;
 import static dagger.internal.codegen.Scope.reusableScope;
 import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.STATIC;
 
 /**
  * The canonical representation of a full-resolved graph.
@@ -128,7 +129,8 @@
         .preOrderTraversal(this)
         .transformAndConcat(RESOLVED_BINDINGS)
         .transformAndConcat(ResolvedBindings.CONTRIBUTION_BINDINGS)
-        .filter(BindingDeclaration.REQUIRES_MODULE_INSTANCE)
+        .filter(not(BindingDeclaration.bindingElementHasModifier(STATIC)))
+        .filter(not(BindingDeclaration.bindingElementHasModifier(ABSTRACT)))
         .transformAndConcat(BindingDeclaration.CONTRIBUTING_MODULE)
         .filter(in(ownedModuleTypes()))
         .append(componentDescriptor().dependencies())
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 34a2786a1..b9826d3bf 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -72,7 +72,6 @@
 import static com.google.auto.common.MoreTypes.asDeclared;
 import static com.google.auto.common.MoreTypes.asExecutable;
 import static com.google.auto.common.MoreTypes.asTypeElements;
-import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.base.Predicates.equalTo;
 import static com.google.common.base.Predicates.in;
@@ -82,7 +81,6 @@
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static com.google.common.collect.Iterables.indexOf;
 import static com.google.common.collect.Maps.filterKeys;
-import static dagger.internal.codegen.BindingDeclaration.HAS_BINDING_ELEMENT;
 import static dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor.isOfKind;
 import static dagger.internal.codegen.ComponentDescriptor.ComponentMethodKind.PRODUCTION_SUBCOMPONENT;
 import static dagger.internal.codegen.ComponentDescriptor.ComponentMethodKind.SUBCOMPONENT;
@@ -90,6 +88,8 @@
 import static dagger.internal.codegen.ContributionBinding.indexMapBindingsByAnnotationType;
 import static dagger.internal.codegen.ContributionBinding.indexMapBindingsByMapKey;
 import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
+import static dagger.internal.codegen.ContributionBinding.Kind.IS_SYNTHETIC_KIND;
+import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_DELEGATE_BINDING;
 import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MULTIBOUND_MAP;
 import static dagger.internal.codegen.ContributionType.indexByContributionType;
 import static dagger.internal.codegen.ErrorMessages.CANNOT_INJECT_WILDCARD_TYPE;
@@ -425,7 +425,10 @@ private void validateResolvedBindings(DependencyPath path) {
             }
           }
           if (contributionBinding.bindingKind().equals(SYNTHETIC_MULTIBOUND_MAP)) {
-            validateMapKeys(path, contributionBinding);
+            ImmutableSet<ContributionBinding> multibindings =
+                inlineSyntheticNondelegateContributions(resolvedBindings).contributionBindings();
+            validateMapKeySet(path, multibindings);
+            validateMapKeyAnnotationTypes(path, multibindings);
           }
           break;
         case MEMBERS_INJECTION:
@@ -448,28 +451,32 @@ private void validateResolvedBindings(DependencyPath path) {
 
     /**
      * Returns an object that contains all the same bindings as {@code resolvedBindings}, except
-     * that any {@link ContributionBinding}s without {@linkplain Binding#bindingElement() binding
-     * elements} are replaced by the contribution bindings and multibinding declarations of their
-     * dependencies.
+     * that any synthetic {@link ContributionBinding}s are replaced by the contribution bindings and
+     * multibinding declarations of their dependencies.
      *
      * <p>For example, if:
      *
      * <ul>
      * <li>The bindings for {@code key1} are {@code A} and {@code B}, with multibinding declaration
      *     {@code X}.
-     * <li>{@code B} is a binding without a binding element that has a dependency on {@code key2}.
+     * <li>{@code B} is a synthetic binding with a dependency on {@code key2}.
      * <li>The bindings for {@code key2} are {@code C} and {@code D}, with multibinding declaration
      *     {@code Y}.
      * </ul>
      *
-     * then {@code inlineContributionsWithoutBindingElements(bindingsForKey1)} has bindings {@code
-     * A}, {@code C}, and {@code D}, with multibinding declarations {@code X} and {@code Y}.
+     * then {@code inlineSyntheticNondelegateContributions(bindingsForKey1)} has bindings {@code A},
+     * {@code C}, and {@code D}, with multibinding declarations {@code X} and {@code Y}.
      *
-     * <p>The replacement is repeated until all of the bindings have elements.
+     * <p>The replacement is repeated until none of the bindings are synthetic.
      */
-    private ResolvedBindings inlineContributionsWithoutBindingElements(
+    // TODO(dpb): The actual operation we want is to inline bindings without real binding elements.
+    // Delegate bindings are the first example of synthetic bindings that have real binding elements
+    // and nonsynthetic dependencies.
+    private ResolvedBindings inlineSyntheticNondelegateContributions(
         ResolvedBindings resolvedBinding) {
-      if (Iterables.all(resolvedBinding.bindings(), HAS_BINDING_ELEMENT)) {
+      if (!FluentIterable.from(resolvedBinding.contributionBindings())
+          .transform(ContributionBinding.KIND)
+          .anyMatch(IS_SYNTHETIC_KIND)) {
         return resolvedBinding;
       }
 
@@ -487,12 +494,13 @@ private ResolvedBindings inlineContributionsWithoutBindingElements(
             queued.allContributionBindings().entries()) {
           BindingGraph owningGraph = validationForComponent(bindingEntry.getKey()).subject;
           ContributionBinding binding = bindingEntry.getValue();
-          if (binding.bindingElement().isPresent()) {
-            contributions.put(bindingEntry);
-          } else {
+          if (binding.isSyntheticBinding()
+              && !binding.bindingKind().equals(SYNTHETIC_DELEGATE_BINDING)) {
             for (DependencyRequest dependency : binding.dependencies()) {
               queue.add(owningGraph.resolvedBindings().get(dependency.bindingKey()));
             }
+          } else {
+            contributions.put(bindingEntry);
           }
         }
       }
@@ -505,7 +513,7 @@ private ResolvedBindings inlineContributionsWithoutBindingElements(
 
     private ImmutableListMultimap<ContributionType, BindingDeclaration> declarationsByType(
         ResolvedBindings resolvedBinding) {
-      ResolvedBindings inlined = inlineContributionsWithoutBindingElements(resolvedBinding);
+      ResolvedBindings inlined = inlineSyntheticNondelegateContributions(resolvedBinding);
       return new ImmutableListMultimap.Builder<ContributionType, BindingDeclaration>()
           .putAll(indexByContributionType(inlined.contributionBindings()))
           .putAll(indexByContributionType(inlined.multibindingDeclarations()))
@@ -537,23 +545,6 @@ private void validateNullability(DependencyRequest request, Set<ContributionBind
       }
     }
 
-    private void validateMapKeys(
-        DependencyPath path, ContributionBinding binding) {
-      checkArgument(binding.bindingKind().equals(SYNTHETIC_MULTIBOUND_MAP),
-          "binding must be a synthetic multibound map: %s",
-          binding);
-      ImmutableSet.Builder<ContributionBinding> multibindingContributionsBuilder =
-          ImmutableSet.builder();
-      for (DependencyRequest dependency : binding.dependencies()) {
-        multibindingContributionsBuilder.add(
-            subject.resolvedBindings().get(dependency.bindingKey()).contributionBinding());
-      }
-      ImmutableSet<ContributionBinding> multibindingContributions =
-          multibindingContributionsBuilder.build();
-      validateMapKeySet(path, multibindingContributions);
-      validateMapKeyAnnotationTypes(path, multibindingContributions);
-    }
-
     /**
      * Reports errors if {@code mapBindings} has more than one binding for the same map key.
      */
@@ -913,13 +904,13 @@ void validateComponentScope() {
               case PROVISION:
                 incompatiblyScopedMethodsBuilder.add(
                     methodSignatureFormatter.format(
-                        MoreElements.asExecutable(contributionBinding.bindingElement().get())));
+                        contributionBinding.bindingElementAsExecutable()));
                 break;
               case INJECTION:
                 incompatiblyScopedMethodsBuilder.add(
                     bindingScope.get().getReadableSource()
                         + " class "
-                        + contributionBinding.bindingTypeElement().get().getQualifiedName());
+                        + contributionBinding.bindingTypeElement().getQualifiedName());
                 break;
               default:
                 throw new IllegalStateException();
@@ -1041,7 +1032,7 @@ private void reportDuplicateBindings(DependencyPath path) {
       new Formatter(builder)
           .format(ErrorMessages.DUPLICATE_BINDINGS_FOR_KEY_FORMAT, formatRootRequestKey(path));
       ImmutableSet<ContributionBinding> duplicateBindings =
-          inlineContributionsWithoutBindingElements(resolvedBindings).contributionBindings();
+          inlineSyntheticNondelegateContributions(resolvedBindings).contributionBindings();
       bindingDeclarationFormatter.formatIndentedList(
           builder, duplicateBindings, 1, DUPLICATE_SIZE_LIMIT);
       owningReportBuilder(duplicateBindings).addError(builder.toString(), path.entryPointElement());
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
index c9114f733..472c7115a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
@@ -50,6 +50,7 @@
 import static dagger.internal.codegen.ContributionType.SET;
 import static dagger.internal.codegen.MapKeys.unwrapValue;
 import static dagger.internal.codegen.MoreAnnotationMirrors.unwrapOptionalEquivalence;
+import static javax.lang.model.element.Modifier.STATIC;
 
 /**
  * An abstract class for a value object representing the mechanism by which a {@link Key} can be
@@ -238,7 +239,7 @@ FactoryCreationStrategy factoryCreationStrategy() {
       case SYNTHETIC_DELEGATE_BINDING:
         return DELEGATE;
       case PROVISION:
-        return implicitDependencies().isEmpty() && !requiresModuleInstance()
+        return implicitDependencies().isEmpty() && bindingElement().getModifiers().contains(STATIC)
             ? ENUM_INSTANCE
             : CLASS_CONSTRUCTOR;
       case INJECTION:
diff --git a/compiler/src/main/java/dagger/internal/codegen/DelegateDeclaration.java b/compiler/src/main/java/dagger/internal/codegen/DelegateDeclaration.java
index 77f8cfa02..f4653b538 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DelegateDeclaration.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DelegateDeclaration.java
@@ -24,7 +24,6 @@
 import dagger.Binds;
 import dagger.internal.codegen.ContributionType.HasContributionType;
 import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.ExecutableType;
@@ -68,7 +67,7 @@ DelegateDeclaration create(
       return new AutoValue_DelegateDeclaration(
           ContributionType.fromBindingMethod(bindsMethod),
           keyFactory.forBindsMethod(bindsMethod, contributingElement),
-          Optional.<Element>of(bindsMethod),
+          bindsMethod,
           Optional.of(contributingElement),
           delegateRequest,
           wrapOptionalInEquivalence(getMapKey(bindsMethod)));
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index 228fe3154..276c0447c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -38,7 +38,7 @@
 import javax.lang.model.util.Elements;
 import javax.tools.Diagnostic;
 
-import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkState;
 import static com.squareup.javapoet.MethodSpec.constructorBuilder;
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static com.squareup.javapoet.TypeSpec.classBuilder;
@@ -90,14 +90,13 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
 
   @Override
   Optional<? extends Element> getElementForErrorReporting(ProvisionBinding binding) {
-    return binding.bindingElement();
+    return Optional.of(binding.bindingElement());
   }
 
   @Override
   Optional<TypeSpec.Builder> write(ClassName generatedTypeName, ProvisionBinding binding) {
     // We don't want to write out resolved bindings -- we want to write out the generic version.
-    checkArgument(!binding.unresolved().isPresent());
-    checkArgument(binding.bindingElement().isPresent());
+    checkState(!binding.unresolved().isPresent());
 
     if (binding.bindingKind().equals(INJECTION)
         && !injectValidator.isValidType(binding.factoryType())) {
@@ -129,11 +128,14 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
         break;
       case CLASS_CONSTRUCTOR:
         factoryBuilder =
-            classBuilder(generatedTypeName).addTypeVariables(typeParameters).addModifiers(FINAL);
+            classBuilder(generatedTypeName)
+                .addTypeVariables(typeParameters)
+                .addModifiers(FINAL);
         constructorBuilder = Optional.of(constructorBuilder().addModifiers(PUBLIC));
-        if (binding.requiresModuleInstance()) {
+        if (binding.bindingKind().equals(PROVISION)
+            && !binding.bindingElement().getModifiers().contains(STATIC)) {
           addConstructorParameterAndTypeField(
-              TypeName.get(binding.bindingTypeElement().get().asType()),
+              TypeName.get(binding.bindingTypeElement().asType()),
               "module",
               factoryBuilder,
               constructorBuilder.get());
@@ -226,14 +228,13 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
 
     if (binding.bindingKind().equals(PROVISION)) {
       CodeBlock.Builder providesMethodInvocationBuilder = CodeBlock.builder();
-      if (binding.requiresModuleInstance()) {
-        providesMethodInvocationBuilder.add("module");
+      if (binding.bindingElement().getModifiers().contains(STATIC)) {
+        providesMethodInvocationBuilder.add("$T", ClassName.get(binding.bindingTypeElement()));
       } else {
-        providesMethodInvocationBuilder.add(
-            "$T", ClassName.get(binding.bindingTypeElement().get()));
+        providesMethodInvocationBuilder.add("module");
       }
       providesMethodInvocationBuilder.add(
-          ".$L($L)", binding.bindingElement().get().getSimpleName(), parametersCodeBlock);
+          ".$L($L)", binding.bindingElement().getSimpleName(), parametersCodeBlock);
       CodeBlock providesMethodInvocation = providesMethodInvocationBuilder.build();
 
       if (binding.nullableType().isPresent()
diff --git a/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java b/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
index f23ccf38f..b7fb2b135 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
@@ -91,8 +91,8 @@ private static TypeMirror fieldValueType(ResolvedBindings resolvedBindings) {
   private static String frameworkFieldName(ResolvedBindings resolvedBindings) {
     if (resolvedBindings.bindingKey().kind().equals(BindingKey.Kind.CONTRIBUTION)) {
       ContributionBinding binding = resolvedBindings.contributionBinding();
-      if (binding.bindingElement().isPresent()) {
-        return BINDING_ELEMENT_NAME.visit(binding.bindingElement().get(), binding);
+      if (!binding.isSyntheticBinding()) {
+        return BINDING_ELEMENT_NAME.visit(binding.bindingElement(), binding);
       }
     }
     return BindingVariableNamer.name(resolvedBindings.binding());
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
index 1e8422242..ee94329d0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
@@ -133,7 +133,7 @@ private void tryToCacheBinding(B binding) {
       // We only cache resolved bindings or unresolved bindings w/o type arguments.
       // Unresolved bindings w/ type arguments aren't valid for the object graph.
       if (binding.unresolved().isPresent()
-          || binding.bindingTypeElement().get().getTypeParameters().isEmpty()) {
+          || binding.bindingTypeElement().getTypeParameters().isEmpty()) {
         Key key = binding.key();
         Binding previousValue = bindingsByKey.put(key, binding);
         checkState(previousValue == null || binding.equals(previousValue),
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
index a3d3bbae2..2854eb519 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
@@ -61,16 +61,13 @@
  */
 @AutoValue
 abstract class MembersInjectionBinding extends Binding {
-  @Override
-  Optional<Element> bindingElement() {
-    return Optional.<Element>of(membersInjectedType());
-  }
-
-  abstract TypeElement membersInjectedType();
-
   @Override
   abstract Optional<MembersInjectionBinding> unresolved();
 
+  TypeElement membersInjectedType() {
+    return MoreElements.asType(bindingElement());
+  }
+  
   @Override
   Optional<TypeElement> contributingModule() {
     return Optional.absent();
@@ -228,9 +225,9 @@ public Key apply(DeclaredType superclass) {
       Key key = keyFactory.forMembersInjectedType(declaredType);
       TypeElement typeElement = MoreElements.asType(declaredType.asElement());
       return new AutoValue_MembersInjectionBinding(
+          typeElement,
           key,
           dependencies,
-          typeElement,
           hasNonDefaultTypeParameters(typeElement, key.type(), types)
               ? Optional.of(
                   forInjectedType(
diff --git a/compiler/src/main/java/dagger/internal/codegen/MultibindingDeclaration.java b/compiler/src/main/java/dagger/internal/codegen/MultibindingDeclaration.java
index 5a3ae304d..9bb8b1636 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MultibindingDeclaration.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MultibindingDeclaration.java
@@ -146,7 +146,7 @@ private MultibindingDeclaration forDeclaredMethod(
           "%s must return a set or map",
           method);
       return new AutoValue_MultibindingDeclaration(
-          Optional.<Element>of(method),
+          method,
           Optional.of(contributingType),
           keyFactory.forMultibindsMethod(bindingType, methodType, method),
           contributionType(returnType),
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
index 2b7023d83..38ef0ad51 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -35,7 +35,6 @@
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 
-import static com.google.common.base.Preconditions.checkArgument;
 import static com.squareup.javapoet.ClassName.OBJECT;
 import static com.squareup.javapoet.MethodSpec.constructorBuilder;
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
@@ -57,6 +56,7 @@
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PROTECTED;
 import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.STATIC;
 
 /**
  * Generates {@link Producer} implementations from {@link ProductionBinding} instances.
@@ -79,13 +79,11 @@ ClassName nameGeneratedType(ProductionBinding binding) {
 
   @Override
   Optional<? extends Element> getElementForErrorReporting(ProductionBinding binding) {
-    return binding.bindingElement();
+    return Optional.of(binding.bindingElement());
   }
 
   @Override
   Optional<TypeSpec.Builder> write(ClassName generatedTypeName, ProductionBinding binding) {
-    checkArgument(binding.bindingElement().isPresent());
-
     TypeName providedTypeName = TypeName.get(binding.factoryType());
     TypeName futureTypeName = listenableFutureOf(providedTypeName);
 
@@ -105,8 +103,8 @@ ClassName nameGeneratedType(ProductionBinding binding) {
                 fields.get(binding.monitorRequest().get().bindingKey()).name(),
                 producerTokenConstruction(generatedTypeName, binding));
 
-    if (binding.requiresModuleInstance()) {
-      TypeName moduleType = TypeName.get(binding.bindingTypeElement().get().asType());
+    if (!binding.bindingElement().getModifiers().contains(STATIC)) {
+      TypeName moduleType = TypeName.get(binding.bindingTypeElement().asType());
       addFieldAndConstructorParameter(factoryBuilder, constructorBuilder, "module", moduleType);
     }
 
@@ -217,8 +215,8 @@ private CodeBlock producerTokenConstruction(
                 "$S",
                 String.format(
                     "%s#%s",
-                    ClassName.get(binding.bindingTypeElement().get()),
-                    binding.bindingElement().get().getSimpleName()))
+                    ClassName.get(binding.bindingTypeElement()),
+                    binding.bindingElement().getSimpleName()))
             : CodeBlock.of("$T.class", generatedTypeName);
     return CodeBlock.of("$T.create($L)", PRODUCER_TOKEN, producerTokenArgs);
   }
@@ -459,10 +457,10 @@ private CodeBlock getInvocationCodeBlock(
     CodeBlock moduleCodeBlock =
         CodeBlock.of(
             "$L.$L($L)",
-            binding.requiresModuleInstance()
-                ? CodeBlock.of("$T.this.module", generatedTypeName)
-                : CodeBlock.of("$T", ClassName.get(binding.bindingTypeElement().get())),
-            binding.bindingElement().get().getSimpleName(),
+            binding.bindingElement().getModifiers().contains(STATIC)
+                ? CodeBlock.of("$T", ClassName.get(binding.bindingTypeElement()))
+                : CodeBlock.of("$T.this.module", generatedTypeName),
+            binding.bindingElement().getSimpleName(),
             makeParametersCodeBlock(parameterCodeBlocks));
 
     // NOTE(beder): We don't worry about catching exceptions from the monitor methods themselves
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
index f27f6bef9..bfe8a099d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
@@ -162,6 +162,7 @@ ProductionBinding syntheticMapOfValuesOrProducedBinding(
               requestForMapOfValuesOrProduced, mapOfProducersKey.get());
       return ProductionBinding.builder()
           .contributionType(ContributionType.UNIQUE)
+          .bindingElement(requestForMapOfProducers.requestElement())
           .key(requestForMapOfValuesOrProduced.key())
           .dependencies(requestForMapOfProducers)
           .bindingKind(Kind.SYNTHETIC_MAP)
@@ -178,6 +179,7 @@ ProductionBinding syntheticMultibinding(
         DependencyRequest request, Iterable<ContributionBinding> multibindingContributions) {
       return ProductionBinding.builder()
           .contributionType(ContributionType.UNIQUE)
+          .bindingElement(request.requestElement())
           .key(request.key())
           .dependencies(
               dependencyRequestFactory.forMultibindingContributions(
@@ -204,7 +206,7 @@ ProductionBinding delegate(
         DelegateDeclaration delegateDeclaration, ProductionBinding delegateBinding) {
       return ProductionBinding.builder()
           .contributionType(delegateDeclaration.contributionType())
-          .bindingElement(delegateDeclaration.bindingElement().get())
+          .bindingElement(delegateDeclaration.bindingElement())
           .contributingModule(delegateDeclaration.contributingModule().get())
           .key(keyFactory.forDelegateBinding(delegateDeclaration, Producer.class))
           .dependencies(delegateDeclaration.delegateRequest())
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index 532778e0c..6d43149b1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -209,9 +209,13 @@ ProvisionBinding syntheticMapOfValuesBinding(DependencyRequest requestForMapOfVa
               requestForMapOfValues, mapOfProvidersKey.get());
       return ProvisionBinding.builder()
           .contributionType(ContributionType.UNIQUE)
+          .bindingElement(requestForMapOfProviders.requestElement())
           .key(requestForMapOfValues.key())
           .dependencies(requestForMapOfProviders)
+          .wrappedMapKey(
+              wrapOptionalInEquivalence(getMapKey(requestForMapOfProviders.requestElement())))
           .bindingKind(Kind.SYNTHETIC_MAP)
+          .scope(Scope.uniqueScopeOf(requestForMapOfProviders.requestElement()))
           .build();
     }
 
@@ -225,11 +229,13 @@ ProvisionBinding syntheticMultibinding(
         DependencyRequest request, Iterable<ContributionBinding> multibindingContributions) {
       return ProvisionBinding.builder()
           .contributionType(ContributionType.UNIQUE)
+          .bindingElement(request.requestElement())
           .key(request.key())
           .dependencies(
               dependencyRequestFactory.forMultibindingContributions(
                   request, multibindingContributions))
           .bindingKind(Kind.forMultibindingRequest(request))
+          .scope(Scope.uniqueScopeOf(request.requestElement()))
           .build();
     }
 
@@ -276,14 +282,14 @@ ProvisionBinding delegate(
         DelegateDeclaration delegateDeclaration, ProvisionBinding delegate) {
       return ProvisionBinding.builder()
           .contributionType(delegateDeclaration.contributionType())
-          .bindingElement(delegateDeclaration.bindingElement().get())
+          .bindingElement(delegateDeclaration.bindingElement())
           .contributingModule(delegateDeclaration.contributingModule().get())
           .key(keyFactory.forDelegateBinding(delegateDeclaration, Provider.class))
           .dependencies(delegateDeclaration.delegateRequest())
           .nullableType(delegate.nullableType())
           .wrappedMapKey(delegateDeclaration.wrappedMapKey())
           .bindingKind(Kind.SYNTHETIC_DELEGATE_BINDING)
-          .scope(Scope.uniqueScopeOf(delegateDeclaration.bindingElement().get()))
+          .scope(Scope.uniqueScopeOf(delegateDeclaration.bindingElement()))
           .build();
     }
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
index 76ff8a72c..9bb8d3df3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
@@ -20,6 +20,7 @@
 import com.google.common.base.Optional;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
@@ -34,6 +35,7 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.ContributionType.indexByContributionType;
 
 /**
  * The collection of bindings that have been resolved for a binding key. For valid graphs, contains
@@ -286,12 +288,38 @@ public BindingType bindingType() {
   /**
    * The contribution type for these bindings.
    *
-   * @throws IllegalStateException if there is not exactly one element in {@link
-   *     #contributionBindings()}, which will never happen for contributions in valid graphs
+   * @throws IllegalStateException if {@link #isEmpty()} or the contribution types conflict
    */
   @Override
   public ContributionType contributionType() {
-    return contributionBinding().contributionType();
+    ImmutableSet<ContributionType> types = contributionTypes();
+    checkState(!types.isEmpty(), "no bindings or declarations for %s", bindingKey());
+    checkState(
+        types.size() == 1,
+        "More than one binding present of different types for %s: %s",
+        bindingKey(),
+        bindingsAndDeclarationsByContributionType());
+    return getOnlyElement(types);
+  }
+
+  /**
+   * The contribution types represented by {@link #contributionBindings()} and
+   * {@link #multibindingDeclarations()}.
+   */
+  ImmutableSet<ContributionType> contributionTypes() {
+    return bindingsAndDeclarationsByContributionType().keySet();
+  }
+
+  /**
+   * The {@link #contributionBindings()} and {@link #multibindingDeclarations()}, indexed by
+   * {@link ContributionType}.
+   */
+  ImmutableListMultimap<ContributionType, BindingDeclaration>
+      bindingsAndDeclarationsByContributionType() {
+    return new ImmutableListMultimap.Builder<ContributionType, BindingDeclaration>()
+        .putAll(indexByContributionType(contributionBindings()))
+        .putAll(indexByContributionType(multibindingDeclarations()))
+        .build();
   }
 
   /**
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index 8fda68942..ac455d3a0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -147,8 +147,8 @@ static ClassName generatedClassNameForBinding(Binding binding) {
       case PROVISION:
       case PRODUCTION:
         ContributionBinding contribution = (ContributionBinding) binding;
-        checkArgument(contribution.bindingTypeElement().isPresent());
-        ClassName enclosingClassName = ClassName.get(contribution.bindingTypeElement().get());
+        checkArgument(!contribution.isSyntheticBinding());
+        ClassName enclosingClassName = ClassName.get(contribution.bindingTypeElement());
         switch (contribution.bindingKind()) {
           case INJECTION:
           case PROVISION:
@@ -203,7 +203,7 @@ static TypeName parameterizedGeneratedTypeNameForBinding(
             // the module, not the types of the binding.
             // Consider: Module<A, B, C> { @Provides List<B> provideB(B b) { .. }}
             // The binding is just parameterized on <B>, but we need all of <A, B, C>.
-            return Optional.of(contributionBinding.bindingTypeElement().get().asType());
+            return Optional.of(contributionBinding.bindingTypeElement().asType());
 
           case IMMEDIATE:
           case FUTURE_PRODUCTION:
@@ -267,7 +267,7 @@ private static String factoryPrefix(ContributionBinding binding) {
       case IMMEDIATE:
       case FUTURE_PRODUCTION:
         return CaseFormat.LOWER_CAMEL.to(
-            UPPER_CAMEL, binding.bindingElement().get().getSimpleName().toString());
+            UPPER_CAMEL, binding.bindingElement().getSimpleName().toString());
 
       default:
         throw new IllegalArgumentException();
@@ -276,8 +276,7 @@ private static String factoryPrefix(ContributionBinding binding) {
 
   static ImmutableList<TypeVariableName> bindingTypeElementTypeVariableNames(Binding binding) {
     ImmutableList.Builder<TypeVariableName> builder = ImmutableList.builder();
-    for (TypeParameterElement typeParameter :
-        binding.bindingTypeElement().get().getTypeParameters()) {
+    for (TypeParameterElement typeParameter : binding.bindingTypeElement().getTypeParameters()) {
       builder.add(TypeVariableName.get(typeParameter));
     }
     return builder.build();
