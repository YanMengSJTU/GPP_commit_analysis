diff --git a/compiler/src/it/functional-tests/src/main/java/test/PrimitivesModule.java b/compiler/src/it/functional-tests/src/main/java/test/PrimitivesModule.java
index 907287dd3..acbf271df 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/PrimitivesModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/PrimitivesModule.java
@@ -27,67 +27,67 @@
   static final float[] BOUND_FLOAT_ARRAY = {(float) 0.1, (float) 0.01, (float) 0.001};
   static final double[] BOUND_DOUBLE_ARRAY = {0.2, 0.02, 0.002};
 
-  @Provides byte provideByte() {
+  @Provides static byte provideByte() {
     return BOUND_BYTE;
   }
 
-  @Provides char provideChar() {
+  @Provides static char provideChar() {
     return BOUND_CHAR;
   }
 
-  @Provides short provideShort() {
+  @Provides static short provideShort() {
     return BOUND_SHORT;
   }
 
-  @Provides int provideInt() {
+  @Provides static int provideInt() {
     return BOUND_INT;
   }
 
-  @Provides long provideLong() {
+  @Provides static long provideLong() {
     return BOUND_LONG;
   }
 
-  @Provides boolean provideBoolean() {
+  @Provides static boolean provideBoolean() {
     return BOUND_BOOLEAN;
   }
 
-  @Provides float provideFloat() {
+  @Provides static float provideFloat() {
     return BOUND_FLOAT;
   }
 
-  @Provides double boundDouble() {
+  @Provides static double boundDouble() {
     return BOUND_DOUBLE;
   }
 
-  @Provides byte[] provideByteArray() {
+  @Provides static byte[] provideByteArray() {
     return BOUND_BYTE_ARRAY;
   }
 
-  @Provides char[] provideCharArray() {
+  @Provides static char[] provideCharArray() {
     return BOUND_CHAR_ARRAY;
   }
 
-  @Provides short[] provideShortArray() {
+  @Provides static short[] provideShortArray() {
     return BOUND_SHORT_ARRAY;
   }
 
-  @Provides int[] provideIntArray() {
+  @Provides static int[] provideIntArray() {
     return BOUND_INT_ARRAY;
   }
 
-  @Provides long[] provideLongArray() {
+  @Provides static long[] provideLongArray() {
     return BOUND_LONG_ARRAY;
   }
 
-  @Provides boolean[] provideBooleanArray() {
+  @Provides static boolean[] provideBooleanArray() {
     return BOUND_BOOLEAN_ARRAY;
   }
 
-  @Provides float[] provideFloatArray() {
+  @Provides static float[] provideFloatArray() {
     return BOUND_FLOAT_ARRAY;
   }
 
-  @Provides double[] boundDoubleArray() {
+  @Provides static double[] boundDoubleArray() {
     return BOUND_DOUBLE_ARRAY;
   }
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/ByteModule.java b/compiler/src/it/functional-tests/src/main/java/test/builder/ByteModule.java
new file mode 100644
index 000000000..8b85d606c
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/ByteModule.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.builder;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+class ByteModule {
+  final byte b;
+
+  ByteModule(byte b) {
+    this.b = b;
+  }
+  
+  @Provides byte b() { return b; }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/DepComponent.java b/compiler/src/it/functional-tests/src/main/java/test/builder/DepComponent.java
new file mode 100644
index 000000000..93fd59def
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/DepComponent.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.builder;
+
+import dagger.Component;
+
+@Component
+interface DepComponent {
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/DoubleModule.java b/compiler/src/it/functional-tests/src/main/java/test/builder/DoubleModule.java
new file mode 100644
index 000000000..2dec4a7a2
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/DoubleModule.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.builder;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+class DoubleModule {
+  @Provides
+  double d() {
+    return 4.2d;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/FloatModule.java b/compiler/src/it/functional-tests/src/main/java/test/builder/FloatModule.java
new file mode 100644
index 000000000..309e7ee98
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/FloatModule.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.builder;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+class FloatModule {  
+  @Provides
+  float f() {
+    return 5.5f;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/GenericParent.java b/compiler/src/it/functional-tests/src/main/java/test/builder/GenericParent.java
new file mode 100644
index 000000000..af196eeda
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/GenericParent.java
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.builder;
+
+interface GenericParent<B> {  
+  B subcomponentBuilder();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/Grandchild.java b/compiler/src/it/functional-tests/src/main/java/test/builder/Grandchild.java
new file mode 100644
index 000000000..8cbf67b19
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/Grandchild.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.builder;
+
+import dagger.Subcomponent;
+
+@Subcomponent(modules = IntModuleIncludingDoubleAndFloat.class)
+interface Grandchild {
+  int i();
+  String s();
+
+  @Subcomponent.Builder
+  interface Builder {
+    Grandchild build();
+    Builder set(IntModuleIncludingDoubleAndFloat intModule);
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/IntModuleIncludingDoubleAndFloat.java b/compiler/src/it/functional-tests/src/main/java/test/builder/IntModuleIncludingDoubleAndFloat.java
new file mode 100644
index 000000000..5e3a92827
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/IntModuleIncludingDoubleAndFloat.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.builder;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module(includes = { DoubleModule.class, FloatModule.class })
+class IntModuleIncludingDoubleAndFloat {
+  final int integer;
+
+  IntModuleIncludingDoubleAndFloat(int integer) {
+    this.integer = integer;
+  }
+  
+  @Provides
+  int integer() {
+    return integer;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/LongModule.java b/compiler/src/it/functional-tests/src/main/java/test/builder/LongModule.java
new file mode 100644
index 000000000..c16c9c79f
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/LongModule.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.builder;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+class LongModule {  
+  @Provides
+  long l() {
+    return 6L;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/MiddleChild.java b/compiler/src/it/functional-tests/src/main/java/test/builder/MiddleChild.java
new file mode 100644
index 000000000..59c29ab34
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/MiddleChild.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.builder;
+
+import dagger.Subcomponent;
+
+@MiddleScope
+@Subcomponent(modules = StringModule.class)
+interface MiddleChild {
+  String s();
+  
+  Grandchild.Builder grandchildBuilder();
+  
+  @Subcomponent.Builder
+  interface Builder {
+    MiddleChild build();
+    Builder set(StringModule stringModule);
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/MiddleScope.java b/compiler/src/it/functional-tests/src/main/java/test/builder/MiddleScope.java
new file mode 100644
index 000000000..e2fbcaa42
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/MiddleScope.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.builder;
+
+import java.lang.annotation.Retention;
+import javax.inject.Scope;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+@Scope
+@Retention(RUNTIME)
+@interface MiddleScope {
+
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/OtherMiddleChild.java b/compiler/src/it/functional-tests/src/main/java/test/builder/OtherMiddleChild.java
new file mode 100644
index 000000000..28e43bafe
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/OtherMiddleChild.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.builder;
+
+import dagger.Subcomponent;
+
+@MiddleScope
+@Subcomponent(modules = {StringModule.class, LongModule.class})
+interface OtherMiddleChild {
+  long l();
+  String s();
+  
+  Grandchild.Builder grandchildBuilder();
+  
+  @Subcomponent.Builder
+  interface Builder {
+    OtherMiddleChild build();
+    Builder set(StringModule stringModule);
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/ParentComponent.java b/compiler/src/it/functional-tests/src/main/java/test/builder/ParentComponent.java
new file mode 100644
index 000000000..f901b8863
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/ParentComponent.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.builder;
+
+import dagger.Component;
+import javax.inject.Singleton;
+
+@Singleton
+@Component
+interface ParentComponent {  
+  TestChildComponentWithBuilderAbstractClass.Builder childAbstractClassBuilder();
+  TestChildComponentWithBuilderInterface.Builder childInterfaceBuilder();
+  
+  MiddleChild.Builder middleBuilder();
+  OtherMiddleChild.Builder otherBuilder();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/ParentOfGenericComponent.java b/compiler/src/it/functional-tests/src/main/java/test/builder/ParentOfGenericComponent.java
new file mode 100644
index 000000000..474c61701
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/ParentOfGenericComponent.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.builder;
+
+import dagger.Component;
+import javax.inject.Singleton;
+
+@Component(modules = StringModule.class)
+@Singleton
+interface ParentOfGenericComponent extends GenericParent<Grandchild.Builder> {}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/StringModule.java b/compiler/src/it/functional-tests/src/main/java/test/builder/StringModule.java
new file mode 100644
index 000000000..3b979a5ab
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/StringModule.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.builder;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+class StringModule {
+  final String string;
+
+  StringModule(String string) {
+    this.string = string;
+  }
+  
+  @Provides
+  String string() {
+    return string;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/TestChildComponentWithBuilderAbstractClass.java b/compiler/src/it/functional-tests/src/main/java/test/builder/TestChildComponentWithBuilderAbstractClass.java
new file mode 100644
index 000000000..8f39c1401
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/TestChildComponentWithBuilderAbstractClass.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.builder;
+
+import dagger.Subcomponent;
+
+@Subcomponent(modules = {StringModule.class, IntModuleIncludingDoubleAndFloat.class,
+    LongModule.class, ByteModule.class})
+interface TestChildComponentWithBuilderAbstractClass {
+  String s();
+  int i();
+  long l();
+  float f();
+  double d();
+  byte b();
+ 
+  abstract class SharedBuilder<B, C, M1, M2> {
+    abstract C build(); // Test resolving return type of build()
+    abstract B setM1(M1 m1); // Test resolving return type & param of setter
+    abstract SharedBuilder<B, C, M1, M2> setM2(M2 m2); // Test being overridden
+    abstract void setM3(DoubleModule doubleModule);  // Test being overridden
+    abstract SharedBuilder<B, C, M1, M2> set(FloatModule floatModule); // Test returning supertype.
+  }
+  
+  @Subcomponent.Builder
+  abstract class Builder extends SharedBuilder<Builder, TestChildComponentWithBuilderAbstractClass,
+      StringModule, IntModuleIncludingDoubleAndFloat> {
+    @Override abstract Builder setM2(IntModuleIncludingDoubleAndFloat m2); // Test covariance
+    @Override abstract void setM3(DoubleModule doubleModule); // Test simple overrides allowed    
+    abstract void set(ByteModule byteModule);
+    
+    // Note we're missing LongModule -- it's implicit
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/TestChildComponentWithBuilderInterface.java b/compiler/src/it/functional-tests/src/main/java/test/builder/TestChildComponentWithBuilderInterface.java
new file mode 100644
index 000000000..2add34ed5
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/TestChildComponentWithBuilderInterface.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.builder;
+
+import dagger.Subcomponent;
+
+@Subcomponent(modules = {StringModule.class, IntModuleIncludingDoubleAndFloat.class,
+    LongModule.class, ByteModule.class})
+interface TestChildComponentWithBuilderInterface {
+  String s();
+  int i();
+  long l();
+  float f();
+  double d();
+  byte b();
+  
+  interface SharedBuilder<B, C, M1, M2> {
+    C build(); // Test resolving return type of build()
+    B setM1(M1 m1); // Test resolving return type & param of setter
+    SharedBuilder<B, C, M1, M2> setM2(M2 m2); // Test being overridden
+    void setM3(DoubleModule doubleModule);  // Test being overridden
+    SharedBuilder<B, C, M1, M2> set(FloatModule floatModule); // Test return type is supertype.
+  }
+  
+  @Subcomponent.Builder
+  interface Builder extends SharedBuilder<Builder, TestChildComponentWithBuilderInterface,
+      StringModule, IntModuleIncludingDoubleAndFloat> {
+    @Override Builder setM2(IntModuleIncludingDoubleAndFloat m2); // Test covariant overrides
+    @Override void setM3(DoubleModule doubleModule); // Test simple overrides allowed    
+    void set(ByteModule byteModule);
+    
+    // Note we're missing LongModule -- it's implicit
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/TestComponentWithBuilderAbstractClass.java b/compiler/src/it/functional-tests/src/main/java/test/builder/TestComponentWithBuilderAbstractClass.java
new file mode 100644
index 000000000..5eef53fe5
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/TestComponentWithBuilderAbstractClass.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.builder;
+
+import dagger.Component;
+
+@Component(
+    modules = {StringModule.class, IntModuleIncludingDoubleAndFloat.class, LongModule.class},
+    dependencies = DepComponent.class)
+abstract class TestComponentWithBuilderAbstractClass {
+  
+  static Builder builder() {
+    return DaggerTestComponentWithBuilderAbstractClass.builder();
+  }
+  
+  abstract String s();
+  abstract int i();
+  abstract long l();
+  abstract float f();
+  abstract double d();
+  
+
+  static abstract class SharedBuilder {
+    // Make sure we use the overriding signature.
+    abstract Object build();
+    
+    Object stringModule(@SuppressWarnings("unused") StringModule stringModule) {
+      return null;
+    } 
+
+    SharedBuilder ignoredLongModule(@SuppressWarnings("unused") LongModule longModule) {
+      return null;
+    }
+    
+  }
+  
+  @Component.Builder
+  static abstract class Builder extends SharedBuilder {
+    @Override abstract TestComponentWithBuilderAbstractClass build(); // Narrowing return type
+    @Override abstract Builder stringModule(StringModule stringModule); // Make abstract & narrow
+    abstract Builder intModule(IntModuleIncludingDoubleAndFloat intModule);
+    abstract void doubleModule(DoubleModule doubleModule); // Module w/o args
+    abstract void depComponent(DepComponent depComponent);
+
+    Builder ignoredIntModule(
+        @SuppressWarnings("unused") IntModuleIncludingDoubleAndFloat intModule) {
+      return null;
+    }    
+    
+    // Note we're missing LongModule & FloatModule -- they/re implicit
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/TestComponentWithBuilderInterface.java b/compiler/src/it/functional-tests/src/main/java/test/builder/TestComponentWithBuilderInterface.java
new file mode 100644
index 000000000..55214f836
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/TestComponentWithBuilderInterface.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.builder;
+
+import dagger.Component;
+
+@Component(
+    modules = {StringModule.class, IntModuleIncludingDoubleAndFloat.class, LongModule.class},
+    dependencies = DepComponent.class)
+interface TestComponentWithBuilderInterface {
+  String s();
+  int i();
+  long l();
+  float f();
+  double d();
+  
+  interface SharedBuilder {
+    // Make sure we use the overriding signature.
+    Object build();
+    Object stringModule(StringModule m1); 
+  }
+  
+  @Component.Builder
+  interface Builder extends SharedBuilder {
+    @Override TestComponentWithBuilderInterface build(); // Narrowing return type
+    @Override Builder stringModule(StringModule stringModule); // Narrowing return type
+    Builder intModule(IntModuleIncludingDoubleAndFloat intModule);
+    void doubleModule(DoubleModule doubleModule); // Module w/o args
+    void depComponent(DepComponent depComponent);
+    
+    // Note we're missing LongModule & FloatModule -- they/re implicit
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/TestComponentWithGenericBuilderAbstractClass.java b/compiler/src/it/functional-tests/src/main/java/test/builder/TestComponentWithGenericBuilderAbstractClass.java
new file mode 100644
index 000000000..8032185b2
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/TestComponentWithGenericBuilderAbstractClass.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.builder;
+
+import dagger.Component;
+
+@Component(
+    modules = {StringModule.class, IntModuleIncludingDoubleAndFloat.class, LongModule.class},
+    dependencies = DepComponent.class)
+interface TestComponentWithGenericBuilderAbstractClass {
+  String s();
+  int i();
+  long l();
+  float f();
+  double d();
+  
+  static abstract class SharedBuilder<B, C, M1, M2> {
+    abstract C build(); // Test resolving return type of build()
+    abstract B setM1(M1 m1); // Test resolving return type & param of setter
+    abstract SharedBuilder<B, C, M1, M2> setM2(M2 m2); // Test being overridden
+    abstract void doubleModule(DoubleModule doubleModule);  // Test being overridden
+    abstract SharedBuilder<B, C, M1, M2> depComponent(FloatModule floatModule); // Test return type
+  }
+  
+  @Component.Builder
+  static abstract class Builder extends SharedBuilder<Builder,
+      TestComponentWithGenericBuilderAbstractClass, StringModule,
+      IntModuleIncludingDoubleAndFloat> {
+    @Override abstract Builder setM2(IntModuleIncludingDoubleAndFloat m2); // Test covariant overrides
+    @Override abstract void doubleModule(DoubleModule module3); // Test simple overrides allowed    
+    abstract void depComponent(DepComponent depComponent);
+    
+    // Note we're missing LongModule & FloatModule -- they're implicit
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/TestComponentWithGenericBuilderInterface.java b/compiler/src/it/functional-tests/src/main/java/test/builder/TestComponentWithGenericBuilderInterface.java
new file mode 100644
index 000000000..f63e3ec90
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/TestComponentWithGenericBuilderInterface.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.builder;
+
+import dagger.Component;
+
+@Component(
+    modules = {StringModule.class, IntModuleIncludingDoubleAndFloat.class, LongModule.class},
+    dependencies = DepComponent.class)
+interface TestComponentWithGenericBuilderInterface {
+  String s();
+  int i();
+  long l();
+  float f();
+  double d();
+  
+  interface SharedBuilder<B, C, M1, M2> {
+    C build(); // Test resolving return type of build()
+    B setM1(M1 m1); // Test resolving return type & param of setter
+    SharedBuilder<B, C, M1, M2> setM2(M2 m2); // Test being overridden
+    void doubleModule(DoubleModule doubleModule);  // Test being overridden
+    SharedBuilder<B, C, M1, M2> set(FloatModule floatModule); // Test return type is supertype.
+  }
+  
+  @Component.Builder
+  interface Builder extends SharedBuilder<Builder, TestComponentWithGenericBuilderInterface,
+      StringModule, IntModuleIncludingDoubleAndFloat> {
+    @Override Builder setM2(IntModuleIncludingDoubleAndFloat m2); // Test covariant overrides allowed
+    @Override void doubleModule(DoubleModule module3); // Test simple overrides allowed    
+    void depComponent(DepComponent depComponent);
+    
+    // Note we're missing M5 -- that's implicit.
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/staticprovides/AllStaticModule.java b/compiler/src/it/functional-tests/src/main/java/test/staticprovides/AllStaticModule.java
new file mode 100644
index 000000000..f47d36c6a
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/staticprovides/AllStaticModule.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.staticprovides;
+
+import static dagger.Provides.Type.SET;
+import static dagger.Provides.Type.SET_VALUES;
+import static java.util.Collections.emptySet;
+
+import dagger.Module;
+import dagger.Provides;
+import java.util.Set;
+
+@Module
+final class AllStaticModule {
+  @Provides(type = SET) static String contributeString() {
+    return AllStaticModule.class + ".contributeString";
+  }
+
+  @Provides(type = SET_VALUES) static Set<Integer> contibuteEmptyIntegerSet() {
+    return emptySet();
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/staticprovides/SomeStaticModule.java b/compiler/src/it/functional-tests/src/main/java/test/staticprovides/SomeStaticModule.java
new file mode 100644
index 000000000..53ee14d95
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/staticprovides/SomeStaticModule.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.staticprovides;
+
+import static dagger.Provides.Type.SET;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+final class SomeStaticModule {
+  @Provides(type = SET) static String contributeStringFromAStaticMethod() {
+    return SomeStaticModule.class + ".contributeStringFromAStaticMethod";
+  }
+
+  @Provides(type = SET) String contributeStringFromAnInstanceMethod() {
+    return SomeStaticModule.class + ".contributeStringFromAnInstanceMethod";
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/staticprovides/StaticTestComponent.java b/compiler/src/it/functional-tests/src/main/java/test/staticprovides/StaticTestComponent.java
new file mode 100644
index 000000000..255f28c3a
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/staticprovides/StaticTestComponent.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.staticprovides;
+
+import dagger.Component;
+import java.util.Set;
+
+/**
+ * A simple component that demonstrates both static an non-static provides methods.
+ */
+@Component(modules = {AllStaticModule.class, SomeStaticModule.class})
+interface StaticTestComponent {
+  Set<String> getMultiboundStrings();
+  Set<Integer> getMultiboundIntegers();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/AnInterface.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/AnInterface.java
new file mode 100644
index 000000000..8aaa015d1
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/AnInterface.java
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+interface AnInterface {
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildAbstractClassComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildAbstractClassComponent.java
new file mode 100644
index 000000000..6c061bc5c
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildAbstractClassComponent.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import dagger.Subcomponent;
+
+@Subcomponent(modules = ChildModule.class)
+abstract class ChildAbstractClassComponent implements ChildComponent {
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GenericParentComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GenericParentComponent.java
new file mode 100644
index 000000000..5580ab8d4
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GenericParentComponent.java
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+interface GenericParentComponent<B> {  
+  B subcomponent();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GrandchildComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GrandchildComponent.java
index 9ed4c714a..9f724edfc 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GrandchildComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GrandchildComponent.java
@@ -26,4 +26,6 @@
   RequiresSingletons requiresSingleton();
 
   Set<Object> objectSet();
+
+  NeedsAnInterface needsAnInterface();
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GrandchildModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GrandchildModule.java
index b426f6386..b2885412f 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GrandchildModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GrandchildModule.java
@@ -29,4 +29,12 @@
       }
     };
   }
+
+  @Provides AnInterface provideAnInterface(ImplementsAnInterface implementsAnInterface) {
+    return implementsAnInterface;
+  }
+
+  @Provides NeedsAnInterface provideNeedsAnInterface(AnInterface anInterface) {
+    return new NeedsAnInterface(anInterface);
+  }
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ImplementsAnInterface.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ImplementsAnInterface.java
new file mode 100644
index 000000000..ff3170cba
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ImplementsAnInterface.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import javax.inject.Inject;
+
+class ImplementsAnInterface implements AnInterface {
+  @Inject ImplementsAnInterface() {}
+}
+
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/NeedsAnInterface.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/NeedsAnInterface.java
new file mode 100644
index 000000000..bccde8589
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/NeedsAnInterface.java
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+class NeedsAnInterface {
+  NeedsAnInterface(AnInterface anInterface) {}
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponent.java
index babf3ea34..ebb067d6f 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponent.java
@@ -16,19 +16,15 @@
 package test.subcomponent;
 
 import dagger.Component;
-import java.util.Set;
-import javax.inject.Provider;
 import javax.inject.Singleton;
 
 @Component(modules = ParentModule.class)
 @Singleton
-interface ParentComponent {
-  Provider<UnscopedType> getUnscopedTypeProvider();
-
-  Set<Object> objectSet();
-
+interface ParentComponent extends ParentGetters {
   ChildComponent newChildComponent();
 
+  ChildAbstractClassComponent newChildAbstractClassComponent();
+
   ChildComponentRequiringModules newChildComponentRequiringModules(
       ChildModuleWithParameters cmwp,
       ChildModuleWithState childModuleWithState);
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentGetters.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentGetters.java
new file mode 100644
index 000000000..3ff855a9d
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentGetters.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import java.util.Set;
+import javax.inject.Provider;
+
+interface ParentGetters {
+  Provider<UnscopedType> getUnscopedTypeProvider();
+
+  Set<Object> objectSet();
+
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentOfGenericComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentOfGenericComponent.java
new file mode 100644
index 000000000..bf8553772
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentOfGenericComponent.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import dagger.Component;
+import javax.inject.Singleton;
+
+@Component(modules = ParentModule.class)
+@Singleton
+interface ParentOfGenericComponent extends GenericParentComponent<ChildComponent>, ParentGetters {
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/ChildComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/ChildComponent.java
new file mode 100644
index 000000000..badb7cac6
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/ChildComponent.java
@@ -0,0 +1,14 @@
+
+
+package test.subcomponent.repeat;
+
+import dagger.Subcomponent;
+
+import java.util.Set;
+
+@Subcomponent(modules = RepeatedModule.class)
+interface ChildComponent {
+  String getString();
+  Set<String> getMultiboundStrings();
+  OnlyUsedInChild getOnlyUsedInChild();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/OnlyUsedInChild.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/OnlyUsedInChild.java
new file mode 100644
index 000000000..2dd8d20d3
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/OnlyUsedInChild.java
@@ -0,0 +1,5 @@
+package test.subcomponent.repeat;
+
+abstract class OnlyUsedInChild {
+
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/OnlyUsedInParent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/OnlyUsedInParent.java
new file mode 100644
index 000000000..cc22b1e05
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/OnlyUsedInParent.java
@@ -0,0 +1,5 @@
+package test.subcomponent.repeat;
+
+abstract class OnlyUsedInParent {
+
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/ParentComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/ParentComponent.java
new file mode 100644
index 000000000..91df02cc3
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/ParentComponent.java
@@ -0,0 +1,19 @@
+package test.subcomponent.repeat;
+
+import dagger.Component;
+
+import java.util.Set;
+
+@Component(modules = RepeatedModule.class)
+interface ParentComponent {
+  String getString();
+  Set<String> getMultiboundStrings();
+  OnlyUsedInParent getOnlyUsedInParent();
+
+  ChildComponent newChildComponent();
+
+  @Component.Builder
+  interface Builder {
+    ParentComponent build();
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/RepeatedModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/RepeatedModule.java
new file mode 100644
index 000000000..508a41b56
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/RepeatedModule.java
@@ -0,0 +1,25 @@
+package test.subcomponent.repeat;
+
+import static dagger.Provides.Type.SET;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+final class RepeatedModule {
+  @Provides String provideString() {
+    return "a string";
+  }
+
+  @Provides(type = SET) String contributeString() {
+    return "a string in a set";
+  }
+
+  @Provides OnlyUsedInParent provideOnlyUsedInParent() {
+    return new OnlyUsedInParent() {};
+  }
+
+  @Provides OnlyUsedInChild provideOnlyUsedInChild() {
+    return new OnlyUsedInChild() {};
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/builder/BuilderTest.java b/compiler/src/it/functional-tests/src/test/java/test/builder/BuilderTest.java
new file mode 100644
index 000000000..ba590d2d9
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/test/java/test/builder/BuilderTest.java
@@ -0,0 +1,225 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.builder;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+@RunWith(JUnit4.class)
+public class BuilderTest {
+
+  @Test public void interfaceBuilder() {
+    TestComponentWithBuilderInterface.Builder builder =
+        DaggerTestComponentWithBuilderInterface.builder();
+
+    // Make sure things fail if we don't set our required modules.
+    try {
+      builder.build();
+      fail();
+    } catch(IllegalStateException expected) {}
+    
+    builder.intModule(new IntModuleIncludingDoubleAndFloat(1))
+        .stringModule(new StringModule("sam"))
+        .depComponent(new DepComponent() {});
+    builder.doubleModule(new DoubleModule());
+    // Don't set other modules -- make sure it works.
+    
+    TestComponentWithBuilderInterface component = builder.build();
+    assertThat(component.s()).isEqualTo("sam");
+    assertThat(component.i()).isEqualTo(1);
+    assertThat(component.d()).isWithin(0).of(4.2d);
+    assertThat(component.f()).isEqualTo(5.5f);
+    assertThat(component.l()).isEqualTo(6L);
+  }
+
+  @Test public void abstractClassBuilder() {
+    TestComponentWithBuilderAbstractClass.Builder builder =
+        TestComponentWithBuilderAbstractClass.builder();
+
+    // Make sure things fail if we don't set our required modules.
+    try {
+      builder.build();
+      fail();
+    } catch(IllegalStateException expected) {}
+    
+    builder.intModule(new IntModuleIncludingDoubleAndFloat(1))
+        .stringModule(new StringModule("sam"))
+        .depComponent(new DepComponent() {});
+    builder.doubleModule(new DoubleModule());
+    // Don't set other modules -- make sure it works.
+    
+    TestComponentWithBuilderAbstractClass component = builder.build();
+    assertThat(component.s()).isEqualTo("sam");
+    assertThat(component.i()).isEqualTo(1);
+    assertThat(component.d()).isWithin(0).of(4.2d);
+    assertThat(component.f()).isEqualTo(5.5f);
+    assertThat(component.l()).isEqualTo(6L);
+  }
+
+  @Test public void interfaceGenericBuilder() {
+    TestComponentWithGenericBuilderInterface.Builder builder =
+        DaggerTestComponentWithGenericBuilderInterface.builder();
+
+    // Make sure things fail if we don't set our required modules.
+    try {
+      builder.build();
+      fail();
+    } catch(IllegalStateException expected) {}
+    
+    builder.setM2(new IntModuleIncludingDoubleAndFloat(1))
+        .setM1(new StringModule("sam"))
+        .depComponent(new DepComponent() {});
+    builder.doubleModule(new DoubleModule());
+    // Don't set other modules -- make sure it works.
+    
+    TestComponentWithGenericBuilderInterface component = builder.build();
+    assertThat(component.s()).isEqualTo("sam");
+    assertThat(component.i()).isEqualTo(1);
+    assertThat(component.d()).isWithin(0).of(4.2d);
+    assertThat(component.f()).isEqualTo(5.5f);
+    assertThat(component.l()).isEqualTo(6L);
+  }
+
+  @Test public void abstractClassGenericBuilder() {
+    TestComponentWithGenericBuilderAbstractClass.Builder builder =
+        DaggerTestComponentWithGenericBuilderAbstractClass.builder();
+
+    // Make sure things fail if we don't set our required modules.
+    try {
+      builder.build();
+      fail();
+    } catch(IllegalStateException expected) {}
+    
+    builder.setM2(new IntModuleIncludingDoubleAndFloat(1))
+        .setM1(new StringModule("sam"))
+        .depComponent(new DepComponent() {});
+    builder.doubleModule(new DoubleModule());
+    // Don't set other modules -- make sure it works.
+    
+    TestComponentWithGenericBuilderAbstractClass component = builder.build();
+    assertThat(component.s()).isEqualTo("sam");
+    assertThat(component.i()).isEqualTo(1);
+    assertThat(component.d()).isWithin(0).of(4.2d);
+    assertThat(component.f()).isEqualTo(5.5f);
+    assertThat(component.l()).isEqualTo(6L);
+  }
+  
+  @Test public void subcomponents_interface() {
+    ParentComponent parent = DaggerParentComponent.create();    
+    TestChildComponentWithBuilderInterface.Builder builder1 = parent.childInterfaceBuilder();
+    try {
+      builder1.build();
+      fail();
+    } catch(IllegalStateException expected) {}
+    
+    builder1.setM2(new IntModuleIncludingDoubleAndFloat(1))
+        .setM1(new StringModule("sam"))
+        .set(new ByteModule((byte)7));
+    builder1.set(new FloatModule());
+    TestChildComponentWithBuilderInterface child1 = builder1.build();
+    assertThat(child1.s()).isEqualTo("sam");
+    assertThat(child1.i()).isEqualTo(1);
+    assertThat(child1.d()).isWithin(0).of(4.2d);
+    assertThat(child1.f()).isEqualTo(5.5f);
+    assertThat(child1.l()).isEqualTo(6L);
+    assertThat(child1.b()).isEqualTo((byte)7);
+  }
+  
+  @Test public void subcomponents_abstractclass() {
+    ParentComponent parent = DaggerParentComponent.create();
+    TestChildComponentWithBuilderAbstractClass.Builder builder2 =
+        parent.childAbstractClassBuilder();
+    try {
+      builder2.build();
+      fail();
+    } catch(IllegalStateException expected) {}
+    
+    builder2.setM2(new IntModuleIncludingDoubleAndFloat(10))
+        .setM1(new StringModule("tara"))
+        .set(new ByteModule((byte)70));
+    builder2.set(new FloatModule());
+    TestChildComponentWithBuilderAbstractClass child2 = builder2.build();
+    assertThat(child2.s()).isEqualTo("tara");
+    assertThat(child2.i()).isEqualTo(10);
+    assertThat(child2.d()).isWithin(0).of(4.2d);
+    assertThat(child2.f()).isEqualTo(5.5f);
+    assertThat(child2.l()).isEqualTo(6L);
+    assertThat(child2.b()).isEqualTo((byte)70);
+  }
+  
+  @Test
+  public void grandchildren() {
+    ParentComponent parent = DaggerParentComponent.create();
+    MiddleChild middle1 = parent.middleBuilder().set(new StringModule("sam")).build();
+    Grandchild grandchild1 =
+        middle1.grandchildBuilder().set(new IntModuleIncludingDoubleAndFloat(21)).build();
+    Grandchild grandchild2 =
+        middle1.grandchildBuilder().set(new IntModuleIncludingDoubleAndFloat(22)).build();
+    
+    assertThat(middle1.s()).isEqualTo("sam");
+    assertThat(grandchild1.i()).isEqualTo(21);
+    assertThat(grandchild1.s()).isEqualTo("sam");
+    assertThat(grandchild2.i()).isEqualTo(22);
+    assertThat(grandchild2.s()).isEqualTo("sam");
+
+    // Make sure grandchildren from newer children have no relation to the older ones.
+    MiddleChild middle2 = parent.middleBuilder().set(new StringModule("tara")).build();
+    Grandchild grandchild3 =
+        middle2.grandchildBuilder().set(new IntModuleIncludingDoubleAndFloat(23)).build();
+    Grandchild grandchild4 =
+        middle2.grandchildBuilder().set(new IntModuleIncludingDoubleAndFloat(24)).build();
+    
+    assertThat(middle2.s()).isEqualTo("tara");
+    assertThat(grandchild3.i()).isEqualTo(23);
+    assertThat(grandchild3.s()).isEqualTo("tara");
+    assertThat(grandchild4.i()).isEqualTo(24);
+    assertThat(grandchild4.s()).isEqualTo("tara");
+  }
+  
+  @Test
+  public void diamondGrandchildren() {
+    ParentComponent parent = DaggerParentComponent.create();
+    MiddleChild middle = parent.middleBuilder().set(new StringModule("sam")).build();
+    OtherMiddleChild other = parent.otherBuilder().set(new StringModule("tara")).build();
+    
+    Grandchild middlegrand =
+        middle.grandchildBuilder().set(new IntModuleIncludingDoubleAndFloat(21)).build();
+    Grandchild othergrand =
+        other.grandchildBuilder().set(new IntModuleIncludingDoubleAndFloat(22)).build();
+    
+    assertThat(middle.s()).isEqualTo("sam");
+    assertThat(other.s()).isEqualTo("tara");
+    assertThat(middlegrand.s()).isEqualTo("sam");
+    assertThat(othergrand.s()).isEqualTo("tara");
+    assertThat(middlegrand.i()).isEqualTo(21);
+    assertThat(othergrand.i()).isEqualTo(22);
+  }
+  
+  @Test
+  public void genericSubcomponentMethod() {
+    ParentOfGenericComponent parent =
+        DaggerParentOfGenericComponent.builder().stringModule(new StringModule("sam")).build();
+    Grandchild.Builder builder = parent.subcomponentBuilder();
+    Grandchild child = builder.set(new IntModuleIncludingDoubleAndFloat(21)).build();
+    assertThat(child.s()).isEqualTo("sam");
+    assertThat(child.i()).isEqualTo(21);
+  }
+  
+}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/staticprovides/StaticProvidesTest.java b/compiler/src/it/functional-tests/src/test/java/test/staticprovides/StaticProvidesTest.java
new file mode 100644
index 000000000..53185f8fc
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/test/java/test/staticprovides/StaticProvidesTest.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.staticprovides;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.common.collect.ImmutableSet;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class StaticProvidesTest {
+  private final StaticTestComponent component = DaggerStaticTestComponent.create();
+
+  @Test public void setMultibinding() {
+    assertThat(component.getMultiboundStrings()).isEqualTo(ImmutableSet.of(
+        AllStaticModule.class + ".contributeString",
+        SomeStaticModule.class + ".contributeStringFromAStaticMethod",
+        SomeStaticModule.class + ".contributeStringFromAnInstanceMethod"));
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentTest.java b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentTest.java
index c0d01b19a..cb6292513 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentTest.java
@@ -15,48 +15,68 @@
  */
 package test.subcomponent;
 
+import java.util.Arrays;
+import java.util.Collection;
 import java.util.Set;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
 
 import static com.google.common.collect.Sets.intersection;
 import static com.google.common.truth.Truth.assertThat;
 
-@RunWith(JUnit4.class)
+@RunWith(Parameterized.class)
 public class SubcomponentTest {
+  private static final ParentComponent parentComponent = DaggerParentComponent.create();
+  private static final ParentOfGenericComponent parentOfGenericComponent =
+      DaggerParentOfGenericComponent.create();
+  
+  @Parameters
+  public static Collection<Object[]> parameters() {
+    return Arrays.asList(new Object[][] {
+        { parentComponent, parentComponent.newChildComponent() },
+        { parentComponent, parentComponent.newChildAbstractClassComponent() },
+        { parentOfGenericComponent, parentOfGenericComponent.subcomponent() }});
+  }        
+  
+  private final ParentGetters parentGetters;
+  private final ChildComponent childComponent;
+  
+  public SubcomponentTest(ParentGetters parentGetters, ChildComponent childComponent) {
+    this.parentGetters = parentGetters;
+    this.childComponent = childComponent;
+  }
+  
+
   @Test
   public void scopePropagatesUpward_class() {
-    ParentComponent parentComponent = DaggerParentComponent.create();
-    assertThat(parentComponent.newChildComponent().requiresSingleton().singletonType())
-        .isSameAs(parentComponent.newChildComponent().requiresSingleton().singletonType());
-    assertThat(parentComponent.newChildComponent().requiresSingleton().singletonType())
-        .isSameAs(parentComponent.newChildComponent()
-            .newGrandchildComponent().requiresSingleton().singletonType());
+    assertThat(childComponent.requiresSingleton().singletonType())
+        .isSameAs(childComponent.requiresSingleton().singletonType());
+    assertThat(childComponent.requiresSingleton().singletonType())
+        .isSameAs(childComponent.newGrandchildComponent().requiresSingleton().singletonType());
   }
 
   @Test
   public void scopePropagatesUpward_provides() {
-    ParentComponent parentComponent = DaggerParentComponent.create();
-    assertThat(parentComponent.newChildComponent()
+    assertThat(childComponent
         .requiresSingleton().unscopedTypeBoundAsSingleton())
-            .isSameAs(parentComponent.newChildComponent()
+            .isSameAs(childComponent
                 .requiresSingleton().unscopedTypeBoundAsSingleton());
-    assertThat(parentComponent.newChildComponent()
+    assertThat(childComponent
         .requiresSingleton().unscopedTypeBoundAsSingleton())
-            .isSameAs(parentComponent.newChildComponent().newGrandchildComponent()
+            .isSameAs(childComponent.newGrandchildComponent()
                 .requiresSingleton().unscopedTypeBoundAsSingleton());
   }
 
   @Test
   public void multibindingContributions() {
-    ParentComponent parentComponent = DaggerParentComponent.create();
-    Set<Object> parentObjectSet = parentComponent.objectSet();
+    Set<Object> parentObjectSet = parentGetters.objectSet();
     assertThat(parentObjectSet).hasSize(2);
-    Set<Object> childObjectSet = parentComponent.newChildComponent().objectSet();
+    Set<Object> childObjectSet = childComponent.objectSet();
     assertThat(childObjectSet).hasSize(3);
     Set<Object> grandchildObjectSet =
-        parentComponent.newChildComponent().newGrandchildComponent().objectSet();
+        childComponent.newGrandchildComponent().objectSet();
     assertThat(grandchildObjectSet).hasSize(4);
     assertThat(intersection(parentObjectSet, childObjectSet)).hasSize(1);
     assertThat(intersection(parentObjectSet, grandchildObjectSet)).hasSize(1);
@@ -65,18 +85,16 @@ public void multibindingContributions() {
 
   @Test
   public void unscopedProviders() {
-    ParentComponent parentComponent = DaggerParentComponent.create();
-    assertThat(parentComponent.getUnscopedTypeProvider())
-        .isSameAs(parentComponent.newChildComponent().getUnscopedTypeProvider());
-    assertThat(parentComponent.getUnscopedTypeProvider())
-        .isSameAs(parentComponent.newChildComponent()
+    assertThat(parentGetters.getUnscopedTypeProvider())
+        .isSameAs(childComponent.getUnscopedTypeProvider());
+    assertThat(parentGetters.getUnscopedTypeProvider())
+        .isSameAs(childComponent
             .newGrandchildComponent()
             .getUnscopedTypeProvider());
   }
 
   @Test
   public void passedModules() {
-    ParentComponent parentComponent = DaggerParentComponent.create();
     ChildModuleWithState childModuleWithState = new ChildModuleWithState();
     ChildComponentRequiringModules childComponent1 =
         parentComponent.newChildComponentRequiringModules(
@@ -89,4 +107,9 @@ public void passedModules() {
     assertThat(childComponent1.getInt()).isEqualTo(0);
     assertThat(childComponent2.getInt()).isEqualTo(1);
   }
+
+  @Test
+  public void dependenceisInASubcomponent() {
+    assertThat(childComponent.newGrandchildComponent().needsAnInterface()).isNotNull();
+  }  
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index 69c9b3d74..77115015e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -388,15 +388,22 @@ private MembersInjectionBinding rollUpMembersInjectionBindings(Key key) {
       private Optional<RequestResolver> getOwningResolver(ProvisionBinding provisionBinding) {
         Optional<Equivalence.Wrapper<AnnotationMirror>> bindingScope =
             provisionBinding.wrappedScope();
-        for (RequestResolver requestResolver : getResolverLineage()) {
-          if (bindingScope.equals(requestResolver.targetScope)
-              || requestResolver.explicitProvisionBindings.containsValue(provisionBinding)) {
+        for (RequestResolver requestResolver : getResolverLineage().reverse()) {
+          if (requestResolver.explicitProvisionBindings.containsValue(provisionBinding)) {
+             return Optional.of(requestResolver);
+          }
+        }
+        // look for scope separately.  we do this for the case where @Singleton can appear twice
+        // in the † compatibility mode
+        for (RequestResolver requestResolver : getResolverLineage().reverse()) {
+          if (bindingScope.isPresent() && bindingScope.equals(requestResolver.targetScope)) {
             return Optional.of(requestResolver);
           }
         }
         return Optional.absent();
       }
 
+      /** Returns the resolver lineage from parent to child. */
       private ImmutableList<RequestResolver> getResolverLineage() {
         List<RequestResolver> resolverList = Lists.newArrayList();
         for (Optional<RequestResolver> currentResolver = Optional.of(this);
@@ -476,7 +483,7 @@ void resolve(DependencyRequest request) {
         resolvedBindingsBuilder.putAll(resolvedBindings);
         if (parentResolver.isPresent()) {
           for (ResolvedBindings resolvedInParent :
-            parentResolver.get().getResolvedBindings().values()) {
+              parentResolver.get().getResolvedBindings().values()) {
             BindingKey bindingKey = resolvedInParent.bindingKey();
             if (!resolvedBindings.containsKey(bindingKey)) {
               if (resolvedInParent.ownedBindings().isEmpty()) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 47d51015f..1b10497bc 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -31,18 +31,22 @@
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
+import com.google.common.collect.Maps;
 import com.google.common.collect.Ordering;
 import com.google.common.collect.Sets;
 import dagger.Component;
 import dagger.internal.codegen.BindingGraph.ResolvedBindings;
+import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.internal.codegen.ContributionBinding.BindingType;
 import dagger.internal.codegen.ValidationReport.Builder;
 import dagger.internal.codegen.writer.TypeNames;
 import java.util.ArrayDeque;
+import java.util.Collection;
 import java.util.Deque;
 import java.util.Formatter;
 import java.util.Iterator;
+import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Set;
 import javax.inject.Singleton;
@@ -117,6 +121,7 @@
 
     validateComponentScope(subject, reportBuilder, resolvedBindings);
     validateDependencyScopes(subject, reportBuilder);
+    validateBuilders(subject, reportBuilder);
 
     for (ComponentMethodDescriptor componentMethod :
         subject.componentDescriptor().componentMethods()) {
@@ -436,6 +441,51 @@ private void validateDependencyScopes(BindingGraph subject,
     }
   }
 
+  private void validateBuilders(BindingGraph subject, Builder<BindingGraph> reportBuilder) {
+    ComponentDescriptor componentDesc = subject.componentDescriptor();
+    if (!componentDesc.builderSpec().isPresent()) {
+      // If no builder, nothing to validate.
+      return;
+    }
+
+    Set<TypeElement> allDependents =
+        Sets.union(
+            Sets.union(
+                subject.transitiveModules().keySet(),
+                componentDesc.dependencies()),
+            componentDesc.executorDependency().asSet());
+    Set<TypeElement> requiredDependents =
+        Sets.filter(allDependents, new Predicate<TypeElement>() {
+          @Override public boolean apply(TypeElement input) {
+            return !Util.componentCanMakeNewInstances(input);
+          }
+        });
+    final BuilderSpec spec = componentDesc.builderSpec().get();
+    Map<TypeElement, ExecutableElement> allSetters = spec.methodMap();
+
+    ErrorMessages.ComponentBuilderMessages msgs =
+        ErrorMessages.builderMsgsFor(subject.componentDescriptor().kind());
+    Set<TypeElement> extraSetters = Sets.difference(allSetters.keySet(), allDependents);
+    if (!extraSetters.isEmpty()) {
+      Collection<ExecutableElement> excessMethods =
+          Maps.filterKeys(allSetters, Predicates.in(extraSetters)).values();
+      Iterable<String> formatted = FluentIterable.from(excessMethods).transform(
+          new Function<ExecutableElement, String>() {
+            @Override public String apply(ExecutableElement input) {
+              return methodSignatureFormatter.format(input,
+                  Optional.of(MoreTypes.asDeclared(spec.builderDefinitionType().asType())));
+            }});
+      reportBuilder.addItem(String.format(msgs.extraSetters(), formatted),
+          spec.builderDefinitionType());
+    }
+
+    Set<TypeElement> missingSetters = Sets.difference(requiredDependents, allSetters.keySet());
+    if (!missingSetters.isEmpty()) {
+      reportBuilder.addItem(String.format(msgs.missingSetters(), missingSetters),
+          spec.builderDefinitionType());
+    }
+  }
+
   /**
    * Append and format a list of indented component types (with their scope annotations)
    */
diff --git a/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java b/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java
new file mode 100644
index 000000000..3bb85e3f9
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java
@@ -0,0 +1,200 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreTypes;
+import com.google.common.base.Equivalence;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.LinkedHashMultimap;
+import com.google.common.collect.Multimap;
+import java.lang.annotation.Annotation;
+import java.util.Collection;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.ExecutableType;
+import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.ElementFilter;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.STATIC;
+
+/** 
+ * Validates {@link dagger.Component.Builder} annotations.
+ * 
+ * @author sameb@google.com (Sam Berlin)  
+ */
+class BuilderValidator implements Validator<TypeElement> {
+  private final Elements elements;
+  private final Types types;
+  private final ComponentDescriptor.Kind componentType;
+  
+  BuilderValidator(Elements elements, Types types, ComponentDescriptor.Kind componentType) {
+    this.elements = elements;
+    this.types = types;
+    this.componentType = componentType;
+  }
+
+  @Override public ValidationReport<TypeElement> validate(TypeElement subject) {
+    ValidationReport.Builder<TypeElement> builder = ValidationReport.Builder.about(subject);
+
+    Element componentElement = subject.getEnclosingElement();
+    ErrorMessages.ComponentBuilderMessages msgs = ErrorMessages.builderMsgsFor(componentType);
+    Class<? extends Annotation> componentAnnotation = componentType.annotationType();
+    Class<? extends Annotation> builderAnnotation = componentType.builderAnnotationType();
+    checkArgument(subject.getAnnotation(builderAnnotation) != null);
+    
+    if (!isAnnotationPresent(componentElement, componentAnnotation)) {
+      builder.addItem(msgs.mustBeInComponent(), subject);
+    }
+
+    switch (subject.getKind()) {
+      case CLASS:
+        List<? extends Element> allElements = subject.getEnclosedElements();
+        List<ExecutableElement> cxtors = ElementFilter.constructorsIn(allElements);
+        if (cxtors.size() != 1 || getOnlyElement(cxtors).getParameters().size() != 0) {
+          builder.addItem(msgs.cxtorOnlyOneAndNoArgs(), subject);
+        }
+        break;
+      case INTERFACE:
+        break;
+      default:
+        // If not the correct type, exit early since the rest of the messages will be bogus.
+        builder.addItem(msgs.mustBeClassOrInterface(), subject);
+        return builder.build(); 
+    }    
+
+    
+    if (!subject.getTypeParameters().isEmpty()) {
+      builder.addItem(msgs.generics(), subject);
+    }
+
+    Set<Modifier> modifiers = subject.getModifiers();
+    if (modifiers.contains(PRIVATE)) {
+      builder.addItem(msgs.isPrivate(), subject);
+    }
+    if (!modifiers.contains(STATIC)) {
+      builder.addItem(msgs.mustBeStatic(), subject);
+    }
+    // Note: Must be abstract, so no need to check for final.
+    if (!modifiers.contains(ABSTRACT)) {
+      builder.addItem(msgs.mustBeAbstract(), subject);
+    }
+    
+    ExecutableElement buildMethod = null;
+    Multimap<Equivalence.Wrapper<TypeMirror>, ExecutableElement> methodsPerParam =
+        LinkedHashMultimap.create();    
+    for (ExecutableElement method : Util.getUnimplementedMethods(elements, subject)) {
+      ExecutableType resolvedMethodType =
+          MoreTypes.asExecutable(types.asMemberOf(MoreTypes.asDeclared(subject.asType()), method));
+      TypeMirror returnType = resolvedMethodType.getReturnType();
+      if (method.getParameters().size() == 0) {
+        // If this is potentially a build() method, validate it returns the correct type.
+        if (types.isSameType(returnType, componentElement.asType())) {
+          if (buildMethod != null) {
+            // If we found more than one build-like method, fail.
+            error(builder, method, msgs.twoBuildMethods(), msgs.inheritedTwoBuildMethods(),
+                buildMethod);
+          }
+        } else {
+          error(builder, method, msgs.buildMustReturnComponentType(),
+              msgs.inheritedBuildMustReturnComponentType());
+        }
+        // We set the buildMethod regardless of the return type to reduce error spam.
+        buildMethod = method;
+      } else if (method.getParameters().size() > 1) {
+        // If this is a setter, make sure it has one arg.
+        error(builder, method, msgs.methodsMustTakeOneArg(), msgs.inheritedMethodsMustTakeOneArg());
+      } else if (returnType.getKind() != TypeKind.VOID
+          && !types.isSubtype(subject.asType(), returnType)) {
+        // If this correctly had one arg, make sure the return types are valid.
+        error(builder, method, msgs.methodsMustReturnVoidOrBuilder(),
+            msgs.inheritedMethodsMustReturnVoidOrBuilder());
+      } else {
+        // If the return types are valid, record the method.
+        methodsPerParam.put(
+            MoreTypes.equivalence().<TypeMirror>wrap(
+                Iterables.getOnlyElement(resolvedMethodType.getParameterTypes())),
+            method);
+      }
+      
+      if (!method.getTypeParameters().isEmpty()) {
+        error(builder, method, msgs.methodsMayNotHaveTypeParameters(),
+            msgs.inheritedMethodsMayNotHaveTypeParameters());
+      }
+    }
+    
+    if (buildMethod == null) {
+      builder.addItem(msgs.missingBuildMethod(), subject);
+    }
+    
+    // Go back through each recorded method per param type.  If we had more than one method
+    // for a given param, fail.
+    for (Map.Entry<Equivalence.Wrapper<TypeMirror>, Collection<ExecutableElement>> entry :
+        methodsPerParam.asMap().entrySet()) {
+      if (entry.getValue().size() > 1) {
+        TypeMirror type = entry.getKey().get();
+        builder.addItem(String.format(msgs.manyMethodsForType(), type, entry.getValue()), subject);
+      }
+    }
+    
+    // Note: there's more validation in BindingGraphValidator,
+    // specifically to make sure the setter methods mirror the deps.
+
+    return builder.build();
+  }
+  
+  /**
+   * Generates one of two error messages. If the method is enclosed in the subject, we target the
+   * error to the method itself. Otherwise we target the error to the subject and list the method as
+   * an argumnent. (Otherwise we have no way of knowing if the method is being compiled in this pass
+   * too, so javac might not be able to pinpoint it's line of code.)
+   */
+  /*
+   * For Component.Builder, the prototypical example would be if someone had:
+   *    libfoo: interface SharedBuilder { void badSetter(A a, B b); }
+   *    libbar: BarComponent { BarBuilder extends SharedBuilder } }
+   * ... the compiler only validates BarBuilder when compiling libbar, but it fails because
+   * of libfoo's SharedBuilder (which could have been compiled in a previous pass).
+   * So we can't point to SharedBuilder#badSetter as the subject of the BarBuilder validation
+   * failure.
+   * 
+   * This check is a little more strict than necessary -- ideally we'd check if method's enclosing
+   * class was included in this compile run.  But that's hard, and this is close enough.
+   */
+  private void error(ValidationReport.Builder<TypeElement> builder, ExecutableElement method,
+      String enclosedError, String inheritedError, Object... extraArgs) {
+    if (method.getEnclosingElement().equals(builder.getSubject())) {
+      builder.addItem(String.format(enclosedError, extraArgs), method);
+    } else {
+      Object[] newArgs = new Object[extraArgs.length + 1];
+      newArgs[0] = method;
+      System.arraycopy(extraArgs, 0, newArgs, 1, extraArgs.length);
+      builder.addItem(String.format(inheritedError, newArgs), builder.getSubject());
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index 03f759a2e..6c514f99c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -21,9 +21,9 @@
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
 import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Lists;
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.Component;
 import dagger.Lazy;
@@ -31,22 +31,25 @@
 import dagger.Subcomponent;
 import dagger.producers.ProductionComponent;
 import java.lang.annotation.Annotation;
-import java.util.Iterator;
 import java.util.List;
+import java.util.Map;
 import java.util.concurrent.Executor;
 import javax.inject.Provider;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ExecutableType;
-import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.base.Verify.verify;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.ConfigurationAnnotations.enclosedBuilders;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
 import static dagger.internal.codegen.ConfigurationAnnotations.isComponent;
 import static dagger.internal.codegen.InjectionAnnotations.getScopeAnnotation;
@@ -66,18 +69,25 @@
   ComponentDescriptor() {}
 
   enum Kind {
-    COMPONENT(Component.class),
-    PRODUCTION_COMPONENT(ProductionComponent.class);
+    COMPONENT(Component.class, Component.Builder.class),
+    SUBCOMPONENT(Subcomponent.class, Subcomponent.Builder.class),
+    PRODUCTION_COMPONENT(ProductionComponent.class, null);
 
     private final Class<? extends Annotation> annotationType;
+    private final Class<? extends Annotation> builderType;
 
-    Kind(Class<? extends Annotation> annotationType) {
+    Kind(Class<? extends Annotation> annotationType, Class<? extends Annotation> builderType) {
       this.annotationType = annotationType;
+      this.builderType = builderType;
     }
 
     Class<? extends Annotation> annotationType() {
       return annotationType;
     }
+    
+    Class<? extends Annotation> builderAnnotationType() {
+      return builderType;
+    }
   }
 
   abstract Kind kind();
@@ -125,6 +135,10 @@
 
   abstract ImmutableSet<ComponentMethodDescriptor> componentMethods();
 
+  // TODO(gak): Consider making this non-optional and revising the
+  // interaction between the spec & generation
+  abstract Optional<BuilderSpec> builderSpec();
+
   @AutoValue
   static abstract class ComponentMethodDescriptor {
     abstract ComponentMethodKind kind();
@@ -137,6 +151,15 @@
     PRODUCTION,
     MEMBERS_INJECTION,
     SUBCOMPONENT,
+    SUBCOMPONENT_BUILDER,
+  }
+  
+  @AutoValue
+  static abstract class BuilderSpec {    
+    abstract TypeElement builderDefinitionType();
+    abstract Map<TypeElement, ExecutableElement> methodMap();
+    abstract ExecutableElement buildMethod();
+    abstract TypeMirror componentType();
   }
 
   static final class Factory {
@@ -159,6 +182,7 @@ ComponentDescriptor forProductionComponent(TypeElement componentDefinitionType)
     }
 
     private ComponentDescriptor create(TypeElement componentDefinitionType, Kind kind) {
+      DeclaredType declaredComponentType = MoreTypes.asDeclared(componentDefinitionType.asType());
       AnnotationMirror componentMirror =
           getAnnotationMirror(componentDefinitionType, kind.annotationType())
               .or(getAnnotationMirror(componentDefinitionType, Subcomponent.class))
@@ -187,7 +211,7 @@ private ComponentDescriptor create(TypeElement componentDefinitionType, Kind kin
               : Optional.<TypeElement>absent();
 
       ImmutableSet<ExecutableElement> unimplementedMethods =
-          getUnimplementedMethods(elements, componentDefinitionType);
+          Util.getUnimplementedMethods(elements, componentDefinitionType);
 
       ImmutableSet.Builder<ComponentMethodDescriptor> componentMethodsBuilder =
           ImmutableSet.builder();
@@ -195,15 +219,32 @@ private ComponentDescriptor create(TypeElement componentDefinitionType, Kind kin
       ImmutableMap.Builder<ExecutableElement, ComponentDescriptor> subcomponentDescriptors =
           ImmutableMap.builder();
       for (ExecutableElement componentMethod : unimplementedMethods) {
+        ExecutableType resolvedMethod =
+            MoreTypes.asExecutable(types.asMemberOf(declaredComponentType, componentMethod));
         ComponentMethodDescriptor componentMethodDescriptor =
             getDescriptorForComponentMethod(componentDefinitionType, kind, componentMethod);
         componentMethodsBuilder.add(componentMethodDescriptor);
-        if (componentMethodDescriptor.kind().equals(ComponentMethodKind.SUBCOMPONENT)) {
-          subcomponentDescriptors.put(componentMethod,
-              create(MoreElements.asType(MoreTypes.asElement(componentMethod.getReturnType())),
-                  Kind.COMPONENT));
+        switch (componentMethodDescriptor.kind()) {
+          case SUBCOMPONENT:
+            subcomponentDescriptors.put(componentMethod,
+                create(MoreElements.asType(MoreTypes.asElement(resolvedMethod.getReturnType())),
+                    Kind.SUBCOMPONENT));
+            break;
+          case SUBCOMPONENT_BUILDER:
+            subcomponentDescriptors.put(componentMethod, create(MoreElements.asType(
+                MoreTypes.asElement(resolvedMethod.getReturnType()).getEnclosingElement()),
+                    Kind.SUBCOMPONENT));
+            break;
+          default: // nothing special to do for other methods.
         }
+        
       }
+      
+      ImmutableList<DeclaredType> enclosedBuilders = kind.builderAnnotationType() == null
+          ? ImmutableList.<DeclaredType>of()
+          : enclosedBuilders(componentDefinitionType, kind.builderAnnotationType());
+      Optional<DeclaredType> builderType =
+          Optional.fromNullable(getOnlyElement(enclosedBuilders, null));        
 
       Optional<AnnotationMirror> scope = getScopeAnnotation(componentDefinitionType);
       return new AutoValue_ComponentDescriptor(
@@ -215,7 +256,8 @@ private ComponentDescriptor create(TypeElement componentDefinitionType, Kind kin
           executorDependency,
           wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), scope),
           subcomponentDescriptors.build(),
-          componentMethodsBuilder.build());
+          componentMethodsBuilder.build(),
+          createBuilderSpec(builderType));
     }
 
     private ComponentMethodDescriptor getDescriptorForComponentMethod(TypeElement componentElement,
@@ -239,12 +281,17 @@ private ComponentMethodDescriptor getDescriptorForComponentMethod(TypeElement co
                   componentMethod,
                   resolvedComponentMethod)),
               componentMethod);
-        } else if (getAnnotationMirror(MoreTypes.asElement(returnType), Subcomponent.class)
-            .isPresent()) {
+        } else if (isAnnotationPresent(MoreTypes.asElement(returnType), Subcomponent.class)) {
           return new AutoValue_ComponentDescriptor_ComponentMethodDescriptor(
               ComponentMethodKind.SUBCOMPONENT,
               Optional.<DependencyRequest>absent(),
               componentMethod);
+        } else if (isAnnotationPresent(MoreTypes.asElement(returnType),
+            Subcomponent.Builder.class)) {
+          return new AutoValue_ComponentDescriptor_ComponentMethodDescriptor(
+              ComponentMethodKind.SUBCOMPONENT_BUILDER,
+              Optional.<DependencyRequest>absent(),
+              componentMethod);
         }
       }
 
@@ -253,6 +300,7 @@ private ComponentMethodDescriptor getDescriptorForComponentMethod(TypeElement co
           && !componentMethod.getReturnType().getKind().equals(VOID)) {
         switch (componentKind) {
           case COMPONENT:
+          case SUBCOMPONENT:
             return new AutoValue_ComponentDescriptor_ComponentMethodDescriptor(
                 ComponentMethodKind.PROVISON,
                 Optional.of(dependencyRequestFactory.forComponentProvisionMethod(componentMethod,
@@ -283,6 +331,28 @@ private ComponentMethodDescriptor getDescriptorForComponentMethod(TypeElement co
 
       throw new IllegalArgumentException("not a valid component method: " + componentMethod);
     }
+
+    private Optional<BuilderSpec> createBuilderSpec(Optional<DeclaredType> builderType) {
+      if (!builderType.isPresent()) {
+        return Optional.absent();
+      }
+      TypeElement element = MoreTypes.asTypeElement(builderType.get());
+      ImmutableSet<ExecutableElement> methods = Util.getUnimplementedMethods(elements, element);
+      ImmutableMap.Builder<TypeElement, ExecutableElement> map = ImmutableMap.builder();
+      ExecutableElement buildMethod = null;
+      for (ExecutableElement method : methods) {
+        if (method.getParameters().isEmpty()) {
+          buildMethod = method;
+        } else {
+          ExecutableType resolved =
+              MoreTypes.asExecutable(types.asMemberOf(builderType.get(), method));
+          map.put(MoreTypes.asTypeElement(getOnlyElement(resolved.getParameterTypes())), method);
+        }
+      }
+      verify(buildMethod != null); // validation should have ensured this.
+      return Optional.<BuilderSpec>of(new AutoValue_ComponentDescriptor_BuilderSpec(element,
+          map.build(), buildMethod, element.getEnclosingElement().asType()));
+    }
   }
 
   static boolean isComponentContributionMethod(Elements elements, ExecutableElement method) {
@@ -296,57 +366,4 @@ static boolean isComponentProductionMethod(Elements elements, ExecutableElement
     return isComponentContributionMethod(elements, method)
         && MoreTypes.isTypeOf(ListenableFuture.class, method.getReturnType());
   }
-
-  /*
-   * These two methods were borrowed from AutoValue and slightly modified.  TODO(gak): reconcile
-   * the two and put them in auto common
-   */
-  private static void findLocalAndInheritedMethods(Elements elements, TypeElement type,
-      List<ExecutableElement> methods) {
-    for (TypeMirror superInterface : type.getInterfaces()) {
-      findLocalAndInheritedMethods(
-          elements, MoreElements.asType(MoreTypes.asElement(superInterface)), methods);
-    }
-    if (type.getSuperclass().getKind() != TypeKind.NONE) {
-      // Visit the superclass after superinterfaces so we will always see the implementation of a
-      // method after any interfaces that declared it.
-      findLocalAndInheritedMethods(
-          elements, MoreElements.asType(MoreTypes.asElement(type.getSuperclass())), methods);
-    }
-    // Add each method of this class, and in so doing remove any inherited method it overrides.
-    // This algorithm is quadratic in the number of methods but it's hard to see how to improve
-    // that while still using Elements.overrides.
-    List<ExecutableElement> theseMethods = ElementFilter.methodsIn(type.getEnclosedElements());
-    for (ExecutableElement method : theseMethods) {
-      if (!method.getModifiers().contains(Modifier.PRIVATE)) {
-        boolean alreadySeen = false;
-        for (Iterator<ExecutableElement> methodIter = methods.iterator(); methodIter.hasNext();) {
-          ExecutableElement otherMethod = methodIter.next();
-          if (elements.overrides(method, otherMethod, type)) {
-            methodIter.remove();
-          } else if (method.getSimpleName().equals(otherMethod.getSimpleName())
-              && method.getParameters().equals(otherMethod.getParameters())) {
-            // If we inherit this method on more than one path, we don't want to add it twice.
-            alreadySeen = true;
-          }
-        }
-        if (!alreadySeen) {
-          methods.add(method);
-        }
-      }
-    }
-  }
-
-  private static ImmutableSet<ExecutableElement> getUnimplementedMethods(
-      Elements elements, TypeElement type) {
-    ImmutableSet.Builder<ExecutableElement> unimplementedMethods = ImmutableSet.builder();
-    List<ExecutableElement> methods = Lists.newArrayList();
-    findLocalAndInheritedMethods(elements, type, methods);
-    for (ExecutableElement method : methods) {
-      if (method.getModifiers().contains(Modifier.ABSTRACT)) {
-        unimplementedMethods.add(method);
-      }
-    }
-    return unimplementedMethods.build();
-  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index 3f69f1623..82903739a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -24,6 +24,7 @@
 import com.google.common.base.Functions;
 import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
+import com.google.common.base.Predicate;
 import com.google.common.base.Predicates;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
@@ -46,6 +47,7 @@
 import dagger.internal.ScopedProvider;
 import dagger.internal.SetFactory;
 import dagger.internal.codegen.BindingGraph.ResolvedBindings;
+import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.internal.codegen.ContributionBinding.BindingType;
 import dagger.internal.codegen.writer.ClassName;
@@ -85,6 +87,7 @@
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ExecutableType;
+import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementKindVisitor6;
 import javax.lang.model.util.SimpleAnnotationValueVisitor6;
@@ -111,6 +114,7 @@
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
 import static javax.lang.model.element.Modifier.STATIC;
+import static javax.lang.model.type.TypeKind.DECLARED;
 import static javax.lang.model.type.TypeKind.VOID;
 
 /**
@@ -234,16 +238,61 @@ Snippet getSnippetFor(ClassName usingClass) {
     return ImmutableSet.copyOf(javaWriters);
   }
 
-  private ImmutableMap<BindingKey, MemberSelect> writeComponent(
-      BindingGraph input, ClassName componentDefinitionTypeName, ClassWriter componentWriter,
-      Set<JavaWriter> proxyWriters) {
-    ClassWriter builderWriter = componentWriter.addNestedClass("Builder");
-    builderWriter.addModifiers(PUBLIC, STATIC, FINAL);
+  /**
+   * Writes out a builder for a component or subcomponent.
+   *
+   * @param input the component or subcomponent
+   * @param componentApiName the API name of the component we're building (not our impl)
+   * @param componentImplName the implementation name of the component we're building
+   * @param componentWriter the class we're adding this builder to
+   * @param componentContributionFields a map of member selects so we can later use the fields
+   */
+  private ClassWriter writeBuilder(BindingGraph input, ClassName componentApiName,
+      ClassName componentImplName, ClassWriter componentWriter,
+      Map<TypeElement, MemberSelect> componentContributionFields) {
+    ClassWriter builderWriter;
+    Optional<BuilderSpec> builderSpec = input.componentDescriptor().builderSpec();
+    switch (input.componentDescriptor().kind()) {
+      case COMPONENT:
+      case PRODUCTION_COMPONENT:
+        builderWriter = componentWriter.addNestedClass("Builder");
+        builderWriter.addModifiers(STATIC);
+
+        // Only top-level components have the factory builder() method.
+        // Mirror the user's builder API type if they had one.
+        MethodWriter builderFactoryMethod = builderSpec.isPresent()
+            ? componentWriter.addMethod(
+                builderSpec.get().builderDefinitionType().asType(), "builder")
+            : componentWriter.addMethod(builderWriter, "builder");
+        builderFactoryMethod.addModifiers(PUBLIC, STATIC);
+        builderFactoryMethod.body().addSnippet("return new %s();", builderWriter.name());
+        break;
+      case SUBCOMPONENT:
+        verify(builderSpec.isPresent()); // we only write subcomponent builders if there was a spec
+        builderWriter =
+            componentWriter.addNestedClass(componentApiName.simpleName() + "Builder");
+        break;
+      default:
+        throw new IllegalStateException();
+    }
+    builderWriter.addModifiers(FINAL);
     builderWriter.addConstructor().addModifiers(PRIVATE);
-
-    MethodWriter builderFactoryMethod = componentWriter.addMethod(builderWriter, "builder");
-    builderFactoryMethod.addModifiers(PUBLIC, STATIC);
-    builderFactoryMethod.body().addSnippet("return new %s();", builderWriter.name());
+    if (builderSpec.isPresent()) {
+      builderWriter.addModifiers(PRIVATE);
+      TypeElement builderType = builderSpec.get().builderDefinitionType();
+      switch (builderType.getKind()) {
+        case CLASS:
+          builderWriter.setSuperType(builderType);
+          break;
+        case INTERFACE:
+          builderWriter.addImplementedType(builderType);
+          break;
+        default:
+          throw new IllegalStateException("not a class or interface: " + builderType);
+      }
+    } else {
+      builderWriter.addModifiers(PUBLIC);
+    }
 
     // the full set of types that calling code uses to construct a component instance
     ImmutableMap<TypeElement, String> componentContributionNames =
@@ -261,35 +310,27 @@ Snippet getSnippetFor(ClassName usingClass) {
                   }
                 })));
 
-    ConstructorWriter constructorWriter = componentWriter.addConstructor();
-    constructorWriter.addModifiers(PRIVATE);
-    constructorWriter.addParameter(builderWriter, "builder");
-    constructorWriter.body().addSnippet("assert builder != null;");
-
-    MethodWriter buildMethod = builderWriter.addMethod(componentDefinitionTypeName, "build");
+    MethodWriter buildMethod;
+    if (builderSpec.isPresent()) {
+      ExecutableElement specBuildMethod = builderSpec.get().buildMethod();
+      // Note: we don't use the specBuildMethod.getReturnType() as the return type
+      // because it might be a type variable.  We make use of covariant returns to allow
+      // us to return the component type, which will always be valid.
+      buildMethod = builderWriter.addMethod(componentApiName,
+          specBuildMethod.getSimpleName().toString());
+      buildMethod.annotate(Override.class);
+    } else {
+      buildMethod = builderWriter.addMethod(componentApiName, "build");
+    }
     buildMethod.addModifiers(PUBLIC);
 
-    boolean requiresBuilder = false;
-
-    Map<TypeElement, MemberSelect> componentContributionFields = Maps.newHashMap();
-
     for (Entry<TypeElement, String> entry : componentContributionNames.entrySet()) {
       TypeElement contributionElement = entry.getKey();
       String contributionName = entry.getValue();
       FieldWriter builderField = builderWriter.addField(contributionElement, contributionName);
       builderField.addModifiers(PRIVATE);
       componentContributionFields.put(contributionElement, MemberSelect.instanceSelect(
-          componentWriter.name(), Snippet.format("builder.%s", builderField.name())));
-      MethodWriter builderMethod = builderWriter.addMethod(builderWriter, contributionName);
-      builderMethod.addModifiers(PUBLIC);
-      builderMethod.addParameter(contributionElement, contributionName);
-      builderMethod.body()
-          .addSnippet("if (%s == null) {", contributionName)
-          .addSnippet("  throw new NullPointerException(%s);",
-              StringLiteral.forValue(contributionName))
-          .addSnippet("}")
-          .addSnippet("this.%s = %s;", builderField.name(), contributionName)
-          .addSnippet("return this;");
+          componentImplName, Snippet.format("builder.%s", builderField.name())));
       if (componentCanMakeNewInstances(contributionElement)) {
         buildMethod.body()
             .addSnippet("if (%s == null) {", builderField.name())
@@ -297,20 +338,83 @@ Snippet getSnippetFor(ClassName usingClass) {
                 builderField.name(), ClassName.fromTypeElement(contributionElement))
             .addSnippet("}");
       } else {
-        requiresBuilder = true;
         buildMethod.body()
             .addSnippet("if (%s == null) {", builderField.name())
             .addSnippet("  throw new IllegalStateException(\"%s must be set\");",
                 builderField.name())
             .addSnippet("}");
       }
+      MethodWriter builderMethod;
+      boolean returnsVoid = false;
+      if (builderSpec.isPresent()) {
+        ExecutableElement method = builderSpec.get().methodMap().get(contributionElement);
+        if (method == null) { // no method in the API, nothing to write out.
+          continue;
+        }
+        // If the return type is void, we add a method with the void return type.
+        // Otherwise we use the builderWriter and take advantage of covariant returns
+        // (so that we don't have to worry about setter methods that return type variables).
+        if (method.getReturnType().getKind().equals(TypeKind.VOID)) {
+          returnsVoid = true;
+          builderMethod =
+              builderWriter.addMethod(method.getReturnType(), method.getSimpleName().toString());
+        } else {
+          builderMethod = builderWriter.addMethod(builderWriter, method.getSimpleName().toString());
+        }
+        builderMethod.annotate(Override.class);
+      } else {
+        builderMethod = builderWriter.addMethod(builderWriter, contributionName);
+      }
+      // TODO(gak): Mirror the API's visibility.
+      // (Makes no difference to the user since this class is private,
+      //  but makes generated code prettier.)
+      builderMethod.addModifiers(PUBLIC);
+      builderMethod.addParameter(contributionElement, contributionName);
+      builderMethod.body()
+          .addSnippet("if (%s == null) {", contributionName)
+          .addSnippet("  throw new NullPointerException(%s);",
+              StringLiteral.forValue(contributionName))
+          .addSnippet("}")
+          .addSnippet("this.%s = %s;", builderField.name(), contributionName);
+      if (!returnsVoid) {
+        builderMethod.body().addSnippet("return this;");
+      }
     }
+    buildMethod.body().addSnippet("return new %s(this);", componentImplName);
+    return builderWriter;
+  }
+
+  /** Returns true if the graph has any dependents that can't be automatically constructed. */
+  private boolean requiresUserSuppliedDependents(BindingGraph input) {
+    Set<TypeElement> allDependents =
+        Sets.union(
+            Sets.union(
+                input.transitiveModules().keySet(),
+                input.componentDescriptor().dependencies()),
+            input.componentDescriptor().executorDependency().asSet());
+    Set<TypeElement> userRequiredDependents =
+        Sets.filter(allDependents, new Predicate<TypeElement>() {
+          @Override public boolean apply(TypeElement input) {
+            return !Util.componentCanMakeNewInstances(input);
+          }
+        });
+    return !userRequiredDependents.isEmpty();
+  }
 
-    if (!requiresBuilder) {
+  private ImmutableMap<BindingKey, MemberSelect> writeComponent(
+      BindingGraph input, ClassName componentDefinitionTypeName, ClassWriter componentWriter,
+      Set<JavaWriter> proxyWriters) {
+    Map<TypeElement, MemberSelect> componentContributionFields = Maps.newHashMap();
+    ClassWriter builderWriter = writeBuilder(input, componentDefinitionTypeName,
+        componentWriter.name(), componentWriter, componentContributionFields);
+    if (!requiresUserSuppliedDependents(input)) {
       MethodWriter factoryMethod = componentWriter.addMethod(componentDefinitionTypeName, "create");
       factoryMethod.addModifiers(PUBLIC, STATIC);
       // TODO(gak): replace this with something that doesn't allocate a builder
-      factoryMethod.body().addSnippet("return builder().build();");
+      factoryMethod.body().addSnippet("return builder().%s();",
+          input.componentDescriptor().builderSpec().isPresent()
+              ? input.componentDescriptor().builderSpec().get().buildMethod().getSimpleName()
+              : "build");
     }
 
     Map<BindingKey, MemberSelect> memberSelectSnippetsBuilder = Maps.newHashMap();
@@ -328,14 +432,16 @@ Snippet getSnippetFor(ClassName usingClass) {
         enumBindingKeysBuilder,
         packageProxies);
 
-    buildMethod.body().addSnippet("return new %s(this);", componentWriter.name());
-
     ImmutableMap<BindingKey, MemberSelect> memberSelectSnippets =
         ImmutableMap.copyOf(memberSelectSnippetsBuilder);
     ImmutableMap<ContributionBinding, Snippet> multibindingContributionSnippets =
         ImmutableMap.copyOf(multibindingContributionSnippetsBuilder);
     ImmutableSet<BindingKey> enumBindingKeys = enumBindingKeysBuilder.build();
 
+    ConstructorWriter constructorWriter = componentWriter.addConstructor();
+    constructorWriter.addModifiers(PRIVATE);
+    constructorWriter.addParameter(builderWriter, "builder");
+    constructorWriter.body().addSnippet("assert builder != null;");
     initializeFrameworkTypes(input,
         componentWriter,
         constructorWriter,
@@ -349,8 +455,8 @@ Snippet getSnippetFor(ClassName usingClass) {
 
     for (Entry<ExecutableElement, BindingGraph> subgraphEntry : input.subgraphs().entrySet()) {
       writeSubcomponent(componentWriter,
+          MoreTypes.asDeclared(input.componentDescriptor().componentDefinitionType().asType()),
           proxyWriters,
-          componentContributionFields,
           memberSelectSnippets,
           multibindingContributionSnippets,
           subgraphEntry.getKey(),
@@ -361,85 +467,73 @@ Snippet getSnippetFor(ClassName usingClass) {
   }
 
   private void writeSubcomponent(ClassWriter componentWriter,
+      DeclaredType containingComponent,
       Set<JavaWriter> proxyWriters,
-      Map<TypeElement, MemberSelect> parentContributionFields,
       ImmutableMap<BindingKey, MemberSelect> parentMemberSelectSnippets,
       ImmutableMap<ContributionBinding, Snippet> parentMultibindingContributionSnippets,
       ExecutableElement subcomponentFactoryMethod,
       BindingGraph subgraph) {
-    TypeName subcomponentType =
-        TypeNames.forTypeMirror(subcomponentFactoryMethod.getReturnType());
-
-    ClassWriter subcomponentWriter = componentWriter.addNestedClass(
-        subgraph.componentDescriptor().componentDefinitionType().getSimpleName()
-            + "Impl");
-
+    ClassName subcomponentApiName =
+        ClassName.fromTypeElement(subgraph.componentDescriptor().componentDefinitionType());
+    ClassWriter subcomponentWriter =
+        componentWriter.addNestedClass(subcomponentApiName.simpleName() + "Impl");
     subcomponentWriter.addModifiers(PRIVATE, FINAL);
-    subcomponentWriter.addImplementedType(subcomponentType);
-
-    MethodWriter componentMethod = componentWriter.addMethod(subcomponentType,
-        subcomponentFactoryMethod.getSimpleName().toString());
-    componentMethod.addModifiers(PUBLIC);
-    componentMethod.annotate(Override.class);
 
     ConstructorWriter constructorWriter = subcomponentWriter.addConstructor();
     constructorWriter.addModifiers(PRIVATE);
     constructorWriter.body();
 
-    Map<TypeElement, MemberSelect> componentContributionFields =
-        Maps.newHashMap(parentContributionFields);
+    Map<TypeElement, MemberSelect> componentContributionFields = Maps.newHashMap();
     ImmutableList.Builder<Snippet> subcomponentConstructorParameters = ImmutableList.builder();
 
-    for (VariableElement moduleVariable : subcomponentFactoryMethod.getParameters()) {
-      // safe because this passed validation
-      TypeElement moduleType = MoreTypes.asTypeElement(moduleVariable.asType());
-      verify(subgraph.transitiveModules().containsKey(moduleType));
-      componentMethod.addParameter(
-          TypeNames.forTypeMirror(moduleVariable.asType()),
-          moduleVariable.getSimpleName().toString());
-      if (!componentContributionFields.containsKey(moduleType)) {
-        String preferredModuleName = CaseFormat.UPPER_CAMEL.to(LOWER_CAMEL,
-            moduleType.getSimpleName().toString());
-        FieldWriter contributionField =
-            subcomponentWriter.addField(moduleType, preferredModuleName);
-        contributionField.addModifiers(PRIVATE, FINAL);
-        String actualModuleName = contributionField.name();
-        constructorWriter.addParameter(
-            TypeNames.forTypeMirror(moduleVariable.asType()), actualModuleName);
-        constructorWriter.body().addSnippet(Snippet.format(Joiner.on('\n').join(
-            "if (%s == null) {",
-            "  throw new NullPointerException();",
-            "}"), actualModuleName));
-        constructorWriter.body().addSnippet(
-            Snippet.format("this.%1$s = %1$s;", actualModuleName));
-        MemberSelect moduleSelect = MemberSelect.instanceSelect(
-            subcomponentWriter.name(), Snippet.format(actualModuleName));
-        componentContributionFields.put(moduleType, moduleSelect);
-        subcomponentConstructorParameters.add(Snippet.format("%s", moduleVariable.getSimpleName()));
-      }
+    TypeMirror subcomponentType;
+    MethodWriter componentMethod;
+    Optional<ClassName> builderName;
+    if (subgraph.componentDescriptor().builderSpec().isPresent()) {
+      BuilderSpec spec = subgraph.componentDescriptor().builderSpec().get();
+      subcomponentType = spec.componentType();
+      componentMethod = componentWriter.addMethod(
+          ClassName.fromTypeElement(spec.builderDefinitionType()),
+          subcomponentFactoryMethod.getSimpleName().toString());
+      ClassWriter builderWriter = writeBuilder(subgraph, subcomponentApiName,
+          subcomponentWriter.name(), componentWriter, componentContributionFields);
+      builderName = Optional.of(builderWriter.name());
+      constructorWriter.addParameter(builderWriter, "builder");
+      constructorWriter.body().addSnippet("assert builder != null;");
+      componentMethod.body().addSnippet("return new %s();", builderWriter.name());
+    } else {
+      builderName = Optional.absent();
+      ExecutableType resolvedMethod =
+          MoreTypes.asExecutable(types.asMemberOf(containingComponent, subcomponentFactoryMethod));
+      subcomponentType = resolvedMethod.getReturnType();
+      componentMethod = componentWriter.addMethod(subcomponentType,
+          subcomponentFactoryMethod.getSimpleName().toString());
+      writeSubcomponentWithoutBuilder(subcomponentFactoryMethod,
+          subgraph,
+          subcomponentWriter,
+          constructorWriter,
+          componentContributionFields,
+          subcomponentConstructorParameters,
+          componentMethod,
+          resolvedMethod);
     }
+    componentMethod.addModifiers(PUBLIC);
+    componentMethod.annotate(Override.class);
 
-    SetView<TypeElement> uninitializedModules = Sets.difference(
-        subgraph.transitiveModules().keySet(), componentContributionFields.keySet());
-    for (TypeElement moduleType : uninitializedModules) {
-      String preferredModuleName = CaseFormat.UPPER_CAMEL.to(LOWER_CAMEL,
-          moduleType.getSimpleName().toString());
-      FieldWriter contributionField =
-          subcomponentWriter.addField(moduleType, preferredModuleName);
-      contributionField.addModifiers(PRIVATE, FINAL);
-      String actualModuleName = contributionField.name();
-      constructorWriter.body().addSnippet(
-          Snippet.format("this.%s = new %s();", actualModuleName,
-              ClassName.fromTypeElement(moduleType)));
-      MemberSelect moduleSelect = MemberSelect.instanceSelect(
-          subcomponentWriter.name(), Snippet.format(actualModuleName));
-      componentContributionFields.put(moduleType, moduleSelect);
+    TypeName subcomponentTypeName = TypeNames.forTypeMirror(subcomponentType);
+    Element subcomponentElement = MoreTypes.asElement(subcomponentType);
+    switch (subcomponentElement.getKind()) {
+      case CLASS:
+        checkState(subcomponentElement.getModifiers().contains(ABSTRACT));
+        subcomponentWriter.setSuperType(subcomponentTypeName);
+        break;
+      case INTERFACE:
+        subcomponentWriter.addImplementedType(subcomponentTypeName);
+        break;
+      default:
+        throw new IllegalStateException();
     }
 
-    componentMethod.body().addSnippet("return new %s(%s);",
-        subcomponentWriter.name(),
-        Snippet.makeParametersSnippet(subcomponentConstructorParameters.build()));
-
     Map<BindingKey, MemberSelect> memberSelectSnippetsBuilder = Maps.newHashMap();
 
     Map<ContributionBinding, Snippet> multibindingContributionSnippetsBuilder = Maps.newHashMap();
@@ -472,7 +566,7 @@ private void writeSubcomponent(ClassWriter componentWriter,
     initializeFrameworkTypes(subgraph,
         subcomponentWriter,
         constructorWriter,
-        Optional.<ClassName>absent(),
+        builderName,
         componentContributionFields,
         memberSelectSnippets,
         parentMultibindingContributionSnippets,
@@ -482,8 +576,8 @@ private void writeSubcomponent(ClassWriter componentWriter,
 
     for (Entry<ExecutableElement, BindingGraph> subgraphEntry : subgraph.subgraphs().entrySet()) {
       writeSubcomponent(subcomponentWriter,
+          MoreTypes.asDeclared(subgraph.componentDescriptor().componentDefinitionType().asType()),
           proxyWriters,
-          componentContributionFields,
           memberSelectSnippets,
           new ImmutableMap.Builder<ContributionBinding, Snippet>()
               .putAll(parentMultibindingContributionSnippets)
@@ -494,6 +588,66 @@ private void writeSubcomponent(ClassWriter componentWriter,
     }
   }
 
+  private void writeSubcomponentWithoutBuilder(ExecutableElement subcomponentFactoryMethod,
+      BindingGraph subgraph,
+      ClassWriter subcomponentWriter,
+      ConstructorWriter constructorWriter,
+      Map<TypeElement, MemberSelect> componentContributionFields,
+      ImmutableList.Builder<Snippet> subcomponentConstructorParameters,
+      MethodWriter componentMethod,
+      ExecutableType resolvedMethod) {
+    List<? extends VariableElement> params = subcomponentFactoryMethod.getParameters();
+    List<? extends TypeMirror> paramTypes = resolvedMethod.getParameterTypes();
+    for (int i = 0; i < params.size(); i++) {
+      VariableElement moduleVariable = params.get(i);
+      TypeElement moduleTypeElement = MoreTypes.asTypeElement(paramTypes.get(i));
+      TypeName moduleType = TypeNames.forTypeMirror(paramTypes.get(i));
+      verify(subgraph.transitiveModules().containsKey(moduleTypeElement));
+      componentMethod.addParameter(moduleType, moduleVariable.getSimpleName().toString());
+      if (!componentContributionFields.containsKey(moduleTypeElement)) {
+        String preferredModuleName = CaseFormat.UPPER_CAMEL.to(LOWER_CAMEL,
+            moduleTypeElement.getSimpleName().toString());
+        FieldWriter contributionField =
+            subcomponentWriter.addField(moduleTypeElement, preferredModuleName);
+        contributionField.addModifiers(PRIVATE, FINAL);
+        String actualModuleName = contributionField.name();
+        constructorWriter.addParameter(moduleType, actualModuleName);
+        constructorWriter.body().addSnippet(Snippet.format(Joiner.on('\n').join(
+            "if (%s == null) {",
+            "  throw new NullPointerException();",
+            "}"), actualModuleName));
+        constructorWriter.body().addSnippet(
+            Snippet.format("this.%1$s = %1$s;", actualModuleName));
+        MemberSelect moduleSelect = MemberSelect.instanceSelect(
+            subcomponentWriter.name(), Snippet.format(actualModuleName));
+        componentContributionFields.put(moduleTypeElement, moduleSelect);
+        subcomponentConstructorParameters.add(
+            Snippet.format("%s", moduleVariable.getSimpleName()));
+      }
+    }
+
+    SetView<TypeElement> uninitializedModules = Sets.difference(
+        subgraph.transitiveModules().keySet(), componentContributionFields.keySet());
+    for (TypeElement moduleType : uninitializedModules) {
+      String preferredModuleName = CaseFormat.UPPER_CAMEL.to(LOWER_CAMEL,
+          moduleType.getSimpleName().toString());
+      FieldWriter contributionField =
+          subcomponentWriter.addField(moduleType, preferredModuleName);
+      contributionField.addModifiers(PRIVATE, FINAL);
+      String actualModuleName = contributionField.name();
+      constructorWriter.body().addSnippet(
+          Snippet.format("this.%s = new %s();", actualModuleName,
+              ClassName.fromTypeElement(moduleType)));
+      MemberSelect moduleSelect = MemberSelect.instanceSelect(
+          subcomponentWriter.name(), Snippet.format(actualModuleName));
+      componentContributionFields.put(moduleType, moduleSelect);
+    }
+
+    componentMethod.body().addSnippet("return new %s(%s);",
+        subcomponentWriter.name(),
+        Snippet.makeParametersSnippet(subcomponentConstructorParameters.build()));
+  }
+
   private void writeFields(BindingGraph input,
       ClassWriter componentWriter,
       Set<JavaWriter> proxyWriters,
@@ -536,7 +690,8 @@ private void writeField(
       if (bindingKey.kind().equals(BindingKey.Kind.CONTRIBUTION)) {
         ContributionBinding contributionBinding =
             Iterables.getOnlyElement(resolvedBindings.contributionBindings());
-        if (contributionBinding instanceof ProvisionBinding) {
+        if (!contributionBinding.bindingType().isMultibinding()
+            && (contributionBinding instanceof ProvisionBinding)) {
           ProvisionBinding provisionBinding = (ProvisionBinding) contributionBinding;
           if (provisionBinding.factoryCreationStrategy().equals(ENUM_INSTANCE)
               && !provisionBinding.scope().isPresent()) {
@@ -705,8 +860,8 @@ private void writeInterfaceMethods(BindingGraph input, ClassWriter componentWrit
               break;
             case INSTANCE:
               if (enumBindingKeys.contains(bindingKey)
-                  && !MoreTypes.asDeclared(bindingKey.key().type())
-                          .getTypeArguments().isEmpty()) {
+                  && (bindingKey.key().type().getKind().equals(DECLARED)
+                      && !((DeclaredType) bindingKey.key().type()).getTypeArguments().isEmpty())) {
                 // If using a parameterized enum type, then we need to store the factory
                 // in a temporary variable, in order to help javac be able to infer
                 // the generics of the Factory.create methods.
@@ -787,7 +942,7 @@ private void initializeFrameworkTypes(BindingGraph input,
                   } else if (parentMultibindingContributionSnippets.containsKey(binding)) {
                     parameterSnippets.add(parentMultibindingContributionSnippets.get(binding));
                   } else {
-                    throw new IllegalStateException();
+                    throw new IllegalStateException(binding + " was not found in");
                   }
                 }
                 Snippet initializeSetSnippet = Snippet.format("%s.create(%s)",
@@ -1011,6 +1166,9 @@ private Snippet initializeFactoryForProvisionBinding(ProvisionBinding binding,
             ClassName.fromClass(InstanceFactory.class),
             TypeNames.forTypeMirror(binding.key().type()));
       case COMPONENT_PROVISION:
+        TypeElement bindingTypeElement = dependencyMethodIndex.get(binding.bindingElement());
+        String sourceFieldName =
+            CaseFormat.UPPER_CAMEL.to(LOWER_CAMEL, bindingTypeElement.getSimpleName().toString());
         if (binding.nullableType().isPresent()
             || nullableValidationType.equals(Diagnostic.Kind.WARNING)) {
           Snippet nullableSnippet = binding.nullableType().isPresent()
@@ -1018,16 +1176,18 @@ private Snippet initializeFactoryForProvisionBinding(ProvisionBinding binding,
               : Snippet.format("");
           return Snippet.format(Joiner.on('\n').join(
             "new %s<%2$s>() {",
+            "  private final %6$s %7$s = %3$s;",
             "  %5$s@Override public %2$s get() {",
-            "    return %3$s.%4$s();",
+            "    return %7$s.%4$s();",
             "  }",
             "}"),
             ClassName.fromClass(Factory.class),
             TypeNames.forTypeMirror(binding.key().type()),
-            contributionFields.get(dependencyMethodIndex.get(binding.bindingElement()))
-                .getSnippetFor(componentName),
+            contributionFields.get(bindingTypeElement).getSnippetFor(componentName),
             binding.bindingElement().getSimpleName().toString(),
-            nullableSnippet);
+            nullableSnippet,
+            TypeNames.forTypeMirror(bindingTypeElement.asType()),
+            sourceFieldName);
         } else {
           // TODO(sameb): This throws a very vague NPE right now.  The stack trace doesn't
           // help to figure out what the method or return type is.  If we include a string
@@ -1039,8 +1199,9 @@ private Snippet initializeFactoryForProvisionBinding(ProvisionBinding binding,
               StringLiteral.forValue(CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD);
           return Snippet.format(Joiner.on('\n').join(
             "new %s<%2$s>() {",
+            "  private final %6$s %7$s = %3$s;",
             "  @Override public %2$s get() {",
-            "    %2$s provided = %3$s.%4$s();",
+            "    %2$s provided = %7$s.%4$s();",
             "    if (provided == null) {",
             "      throw new NullPointerException(%5$s);",
             "    }",
@@ -1049,16 +1210,18 @@ private Snippet initializeFactoryForProvisionBinding(ProvisionBinding binding,
             "}"),
             ClassName.fromClass(Factory.class),
             TypeNames.forTypeMirror(binding.key().type()),
-            contributionFields.get(dependencyMethodIndex.get(binding.bindingElement()))
-                .getSnippetFor(componentName),
+            contributionFields.get(bindingTypeElement).getSnippetFor(componentName),
             binding.bindingElement().getSimpleName().toString(),
-            failMsg);
+            failMsg,
+            TypeNames.forTypeMirror(bindingTypeElement.asType()),
+            sourceFieldName);
         }
       case INJECTION:
       case PROVISION:
         List<Snippet> parameters =
             Lists.newArrayListWithCapacity(binding.dependencies().size() + 1);
-        if (binding.bindingKind().equals(PROVISION)) {
+        if (binding.bindingKind().equals(PROVISION)
+            && !binding.bindingElement().getModifiers().contains(STATIC)) {
           parameters.add(contributionFields.get(binding.contributedBy().get())
               .getSnippetFor(componentName));
         }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
index b458ee322..a7f486897 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
@@ -18,10 +18,14 @@
 import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
 import com.google.auto.common.MoreElements;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Maps;
 import com.google.common.collect.SetMultimap;
 import dagger.Component;
+import dagger.Subcomponent;
 import dagger.internal.codegen.ComponentDescriptor.Factory;
+import dagger.internal.codegen.ComponentValidator.ComponentValidationReport;
 import java.lang.annotation.Annotation;
+import java.util.Map;
 import java.util.Set;
 import javax.annotation.processing.Messager;
 import javax.lang.model.element.Element;
@@ -36,6 +40,9 @@
 final class ComponentProcessingStep implements ProcessingStep {
   private final Messager messager;
   private final ComponentValidator componentValidator;
+  private final ComponentValidator subcomponentValidator;
+  private final BuilderValidator componentBuilderValidator;
+  private final BuilderValidator subcomponentBuilderValidator;
   private final BindingGraphValidator bindingGraphValidator;
   private final ComponentDescriptor.Factory componentDescriptorFactory;
   private final BindingGraph.Factory bindingGraphFactory;
@@ -44,12 +51,18 @@
   ComponentProcessingStep(
       Messager messager,
       ComponentValidator componentValidator,
+      ComponentValidator subcomponentValidator,
+      BuilderValidator componentBuilderValidator,
+      BuilderValidator subcomponentBuilderValidator,
       BindingGraphValidator bindingGraphValidator,
       Factory componentDescriptorFactory,
       BindingGraph.Factory bindingGraphFactory,
       ComponentGenerator componentGenerator) {
     this.messager = messager;
     this.componentValidator = componentValidator;
+    this.subcomponentValidator = subcomponentValidator;
+    this.componentBuilderValidator = componentBuilderValidator;
+    this.subcomponentBuilderValidator = subcomponentBuilderValidator;
     this.bindingGraphValidator = bindingGraphValidator;
     this.componentDescriptorFactory = componentDescriptorFactory;
     this.bindingGraphFactory = bindingGraphFactory;
@@ -58,19 +71,77 @@
 
   @Override
   public Set<Class<? extends Annotation>> annotations() {
-    return ImmutableSet.<Class<? extends Annotation>>of(Component.class);
+    return ImmutableSet.<Class<? extends Annotation>>of(Component.class, Component.Builder.class,
+        Subcomponent.class, Subcomponent.Builder.class);
   }
 
   @Override
   public void process(SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+    Map<Element, ValidationReport<TypeElement>> builderReportsByComponent =
+        processComponentBuilders(elementsByAnnotation.get(Component.Builder.class));
+    Set<? extends Element> subcomponentBuilderElements =
+        elementsByAnnotation.get(Subcomponent.Builder.class);
+    Map<Element, ValidationReport<TypeElement>> builderReportsBySubcomponent =
+        processSubcomponentBuilders(subcomponentBuilderElements);
+    Set<? extends Element> subcomponentElements = elementsByAnnotation.get(Subcomponent.class);
+    Map<Element, ValidationReport<TypeElement>> reportsBySubcomponent =
+        processSubcomponents(subcomponentElements, subcomponentBuilderElements);
     Set<? extends Element> componentElements = elementsByAnnotation.get(Component.class);
+    processComponents(componentElements, builderReportsByComponent, subcomponentElements,
+        reportsBySubcomponent, subcomponentBuilderElements, builderReportsBySubcomponent);
+  }
 
+  private Map<Element, ValidationReport<TypeElement>> processComponentBuilders(
+      Set<? extends Element> componentBuilderElements) {
+    Map<Element, ValidationReport<TypeElement>> builderReportsByComponent = Maps.newHashMap();
+    for (Element element : componentBuilderElements) {
+      ValidationReport<TypeElement> report =
+          componentBuilderValidator.validate(MoreElements.asType(element));
+      report.printMessagesTo(messager);
+      builderReportsByComponent.put(element.getEnclosingElement(), report);
+    }
+    return builderReportsByComponent;
+  }
+
+  private Map<Element, ValidationReport<TypeElement>> processSubcomponentBuilders(
+      Set<? extends Element> subcomponentBuilderElements) {
+    Map<Element, ValidationReport<TypeElement>> builderReportsBySubcomponent = Maps.newHashMap();
+    for (Element element : subcomponentBuilderElements) {
+      ValidationReport<TypeElement> report =
+          subcomponentBuilderValidator.validate(MoreElements.asType(element));
+      report.printMessagesTo(messager);
+      builderReportsBySubcomponent.put(element, report);
+    }
+    return builderReportsBySubcomponent;
+  }
+
+  private Map<Element, ValidationReport<TypeElement>> processSubcomponents(
+      Set<? extends Element> subcomponentElements,
+      Set<? extends Element> subcomponentBuilderElements) {
+    Map<Element, ValidationReport<TypeElement>> reportsBySubcomponent = Maps.newHashMap();
+    for (Element element : subcomponentElements) {
+      ComponentValidationReport report = subcomponentValidator.validate(
+          MoreElements.asType(element), subcomponentElements, subcomponentBuilderElements);
+      report.report().printMessagesTo(messager);
+      reportsBySubcomponent.put(element, report.report());
+    }
+    return reportsBySubcomponent;
+  }
+
+  private void processComponents(
+      Set<? extends Element> componentElements,
+      Map<Element, ValidationReport<TypeElement>> builderReportsByComponent,
+      Set<? extends Element> subcomponentElements,
+      Map<Element, ValidationReport<TypeElement>> reportsBySubcomponent,
+      Set<? extends Element> subcomponentBuilderElements,
+      Map<Element, ValidationReport<TypeElement>> builderReportsBySubcomponent) {
     for (Element element : componentElements) {
       TypeElement componentTypeElement = MoreElements.asType(element);
-      ValidationReport<TypeElement> componentReport =
-          componentValidator.validate(componentTypeElement);
-      componentReport.printMessagesTo(messager);
-      if (componentReport.isClean()) {
+      ComponentValidationReport report = componentValidator.validate(
+          componentTypeElement, subcomponentElements, subcomponentBuilderElements);
+      report.report().printMessagesTo(messager);
+      if (isClean(report, builderReportsByComponent, reportsBySubcomponent,
+          builderReportsBySubcomponent)) {
         ComponentDescriptor componentDescriptor =
             componentDescriptorFactory.forComponent(componentTypeElement);
         BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor);
@@ -87,4 +158,34 @@ public void process(SetMultimap<Class<? extends Annotation>, Element> elementsBy
       }
     }
   }
+
+  /**
+   * Returns true if the component's report is clean, its builder report is clean, and all
+   * referenced subcomponent reports & subcomponent builder reports are clean.
+   */
+  private boolean isClean(ComponentValidationReport report,
+      Map<Element, ValidationReport<TypeElement>> builderReportsByComponent,
+      Map<Element, ValidationReport<TypeElement>> reportsBySubcomponent,
+      Map<Element, ValidationReport<TypeElement>> builderReportsBySubcomponent) {
+    Element component = report.report().subject();
+    ValidationReport<?> componentReport = report.report();
+    if (!componentReport.isClean()) {
+      return false;
+    }
+    ValidationReport<?> builderReport = builderReportsByComponent.get(component);
+    if (builderReport != null && !builderReport.isClean()) {
+      return false;
+    }
+    for (Element element : report.referencedSubcomponents()) {
+      ValidationReport<?> subcomponentBuilderReport = builderReportsBySubcomponent.get(element);
+      if (subcomponentBuilderReport != null && !subcomponentBuilderReport.isClean()) {
+        return false;
+      }
+      ValidationReport<?> subcomponentReport = reportsBySubcomponent.get(element);
+      if (subcomponentReport != null && !subcomponentReport.isClean()) {
+        return false;
+      }
+    }
+    return true;
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index 401681c72..1214684ec 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -49,6 +49,8 @@
 @AutoService(Processor.class)
 public final class ComponentProcessor extends BasicAnnotationProcessor {
   private InjectBindingRegistry injectBindingRegistry;
+  private FactoryGenerator factoryGenerator;
+  private MembersInjectorGenerator membersInjectorGenerator;
 
   @Override
   public SourceVersion getSupportedSourceVersion() {
@@ -84,8 +86,14 @@ public SourceVersion getSupportedSourceVersion() {
     ModuleValidator moduleValidator = new ModuleValidator(types, elements, methodSignatureFormatter,
         Module.class, Provides.class);
     ProvidesMethodValidator providesMethodValidator = new ProvidesMethodValidator(elements);
-    ComponentValidator componentValidator =
-        new ComponentValidator(elements, types, moduleValidator);
+    BuilderValidator componentBuilderValidator =
+        new BuilderValidator(elements, types, ComponentDescriptor.Kind.COMPONENT);
+    BuilderValidator subcomponentBuilderValidator =
+        new BuilderValidator(elements, types, ComponentDescriptor.Kind.SUBCOMPONENT);
+    ComponentValidator subcomponentValidator = ComponentValidator.createForSubcomponent(elements,
+        types, moduleValidator, subcomponentBuilderValidator);
+    ComponentValidator componentValidator = ComponentValidator.createForComponent(elements, types,
+        moduleValidator, subcomponentValidator, subcomponentBuilderValidator);
     MapKeyValidator mapKeyValidator = new MapKeyValidator();
     ModuleValidator producerModuleValidator = new ModuleValidator(types, elements,
         methodSignatureFormatter, ProducerModule.class, Produces.class);
@@ -94,9 +102,9 @@ public SourceVersion getSupportedSourceVersion() {
 
     Key.Factory keyFactory = new Key.Factory(types, elements);
 
-    FactoryGenerator factoryGenerator =
+    this.factoryGenerator =
         new FactoryGenerator(filer, DependencyRequestMapper.FOR_PROVIDER, nullableDiagnosticType);
-    MembersInjectorGenerator membersInjectorGenerator =
+    this.membersInjectorGenerator =
         new MembersInjectorGenerator(filer, elements, types, DependencyRequestMapper.FOR_PROVIDER);
     ComponentGenerator componentGenerator =
         new ComponentGenerator(filer, types, nullableDiagnosticType);
@@ -113,8 +121,7 @@ public SourceVersion getSupportedSourceVersion() {
         new MembersInjectionBinding.Factory(elements, types, keyFactory, dependencyRequestFactory);
 
     this.injectBindingRegistry = new InjectBindingRegistry(
-        elements, types, messager, provisionBindingFactory, factoryGenerator,
-        membersInjectionBindingFactory, membersInjectorGenerator);
+        elements, types, messager, provisionBindingFactory, membersInjectionBindingFactory);
 
     ComponentDescriptor.Factory componentDescriptorFactory =
         new ComponentDescriptor.Factory(elements, types, dependencyRequestFactory);
@@ -157,6 +164,9 @@ public SourceVersion getSupportedSourceVersion() {
         new ComponentProcessingStep(
             messager,
             componentValidator,
+            subcomponentValidator,
+            componentBuilderValidator,
+            subcomponentBuilderValidator,
             bindingGraphValidator,
             componentDescriptorFactory,
             bindingGraphFactory,
@@ -179,7 +189,8 @@ public SourceVersion getSupportedSourceVersion() {
   @Override
   protected void postProcess() {
     try {
-      injectBindingRegistry.generateSourcesForRequiredBindings();
+      injectBindingRegistry.generateSourcesForRequiredBindings(
+          factoryGenerator, membersInjectorGenerator);
     } catch (SourceFileGenerationException e) {
       e.printMessageTo(processingEnv.getMessager());
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
index 022275750..469b37591 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
@@ -17,6 +17,7 @@
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
+import com.google.auto.value.AutoValue;
 import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
 import com.google.common.base.Predicate;
@@ -24,12 +25,17 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
+import com.google.common.collect.LinkedHashMultimap;
+import com.google.common.collect.Multimap;
 import com.google.common.collect.Sets;
 import com.google.common.collect.Sets.SetView;
 import dagger.Component;
 import dagger.Module;
 import dagger.Subcomponent;
+import java.lang.annotation.Annotation;
+import java.util.Collection;
 import java.util.List;
+import java.util.Map;
 import java.util.Set;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
@@ -37,6 +43,7 @@
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
@@ -44,6 +51,7 @@
 import javax.lang.model.util.Types;
 
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
+import static dagger.internal.codegen.ConfigurationAnnotations.enclosedBuilders;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
 import static dagger.internal.codegen.ConfigurationAnnotations.getTransitiveModules;
 import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
@@ -57,46 +65,126 @@
  *
  * @author Gregory Kick
  */
-final class ComponentValidator implements Validator<TypeElement> {
+final class ComponentValidator {
   private final Elements elements;
   private final Types types;
+  private final ComponentDescriptor.Kind componentType;
   private final ModuleValidator moduleValidator;
+  private final ComponentValidator subcomponentValidator;
+  private final BuilderValidator subcomponentBuilderValidator;
+  
+  private ComponentValidator(Elements elements,
+      Types types,
+      ModuleValidator moduleValidator,
+      BuilderValidator subcomponentBuilderValidator) {
+    this.elements = elements;
+    this.types = types;
+    this.componentType = ComponentDescriptor.Kind.SUBCOMPONENT;
+    this.moduleValidator = moduleValidator;
+    this.subcomponentValidator = this;
+    this.subcomponentBuilderValidator = subcomponentBuilderValidator;
+  }
 
-  ComponentValidator(Elements elements, Types types, ModuleValidator moduleValidator) {
+  private ComponentValidator(Elements elements,
+      Types types,
+      ModuleValidator moduleValidator,
+      ComponentValidator subcomponentValidator,
+      BuilderValidator subcomponentBuilderValidator) {
     this.elements = elements;
     this.types = types;
+    this.componentType = ComponentDescriptor.Kind.COMPONENT;
     this.moduleValidator = moduleValidator;
+    this.subcomponentValidator = subcomponentValidator;
+    this.subcomponentBuilderValidator = subcomponentBuilderValidator;
+  }
+  
+  static ComponentValidator createForComponent(Elements elements,
+      Types types,
+      ModuleValidator moduleValidator,
+      ComponentValidator subcomponentValidator,
+      BuilderValidator subcomponentBuilderValidator) {
+    return new ComponentValidator(elements,
+        types,
+        moduleValidator,
+        subcomponentValidator,
+        subcomponentBuilderValidator);
+  }
+  
+  static ComponentValidator createForSubcomponent(Elements elements,
+      Types types,
+      ModuleValidator moduleValidator,
+      BuilderValidator subcomponentBuilderValidator) {
+    return new ComponentValidator(elements,
+        types,
+        moduleValidator,
+        subcomponentBuilderValidator);
+  }
+  
+  @AutoValue
+  static abstract class ComponentValidationReport {
+    abstract Set<Element> referencedSubcomponents();
+    abstract ValidationReport<TypeElement> report();
   }
 
-  @Override public ValidationReport<TypeElement> validate(final TypeElement subject) {
-    final ValidationReport.Builder<TypeElement> builder = ValidationReport.Builder.about(subject);
+  /**
+   * Validates the given component subject. Also validates any referenced subcomponents that aren't
+   * already included in the {@code validatedSubcomponents} set.
+   */
+  public ComponentValidationReport validate(final TypeElement subject,
+      Set<? extends Element> validatedSubcomponents,
+      Set<? extends Element> validatedSubcomponentBuilders) {
+    ValidationReport.Builder<TypeElement> builder = ValidationReport.Builder.about(subject);
 
     if (!subject.getKind().equals(INTERFACE)
         && !(subject.getKind().equals(CLASS) && subject.getModifiers().contains(ABSTRACT))) {
-      builder.addItem("@Component may only be applied to an interface or abstract class", subject);
+      builder.addItem(String.format("@%s may only be applied to an interface or abstract class",
+          componentType.annotationType().getSimpleName()), subject);
+    }
+    
+    ImmutableList<DeclaredType> builders =
+        enclosedBuilders(subject, componentType.builderAnnotationType());
+    if (builders.size() > 1) {
+      builder.addItem(
+          String.format(ErrorMessages.builderMsgsFor(componentType).moreThanOne(), builders),
+          subject);
     }
+    
+    DeclaredType subjectType = MoreTypes.asDeclared(subject.asType());
 
+    // TODO(gak): This should use Util.findLocalAndInheritedMethods, otherwise
+    // it can return a logical method multiple times (including overrides, etc.)
     List<? extends Element> members = elements.getAllMembers(subject);
+    Multimap<Element, ExecutableElement> referencedSubcomponents = LinkedHashMultimap.create();
     for (ExecutableElement method : ElementFilter.methodsIn(members)) {
       if (method.getModifiers().contains(ABSTRACT)) {
+        ExecutableType resolvedMethod =
+            MoreTypes.asExecutable(types.asMemberOf(subjectType, method));
+        List<? extends TypeMirror> parameterTypes = resolvedMethod.getParameterTypes();
         List<? extends VariableElement> parameters = method.getParameters();
-        TypeMirror returnType = method.getReturnType();
+        TypeMirror returnType = resolvedMethod.getReturnType();
 
         // abstract methods are ones we have to implement, so they each need to be validated
         // first, check the return type.  if it's a subcomponent, validate that method as such.
-        Optional<AnnotationMirror> subcomponentAnnotation  = returnType.accept(
-            new SimpleTypeVisitor6<Optional<AnnotationMirror>, Void>() {
-              @Override protected Optional<AnnotationMirror> defaultAction(TypeMirror e, Void p) {
-                return Optional.absent();
-              }
-
-              @Override public Optional<AnnotationMirror> visitDeclared(DeclaredType t, Void p) {
-                return MoreElements.getAnnotationMirror(t.asElement(), Subcomponent.class);
-              }
-            }, null);
+        Optional<AnnotationMirror> subcomponentAnnotation =
+            checkForAnnotation(returnType, Subcomponent.class);
+        Optional<AnnotationMirror> subcomponentBuilderAnnotation =
+            checkForAnnotation(returnType, Subcomponent.Builder.class);
         if (subcomponentAnnotation.isPresent()) {
-          validateSubcomponentMethod(
-              builder, method, parameters, returnType, subcomponentAnnotation);
+          referencedSubcomponents.put(MoreTypes.asElement(returnType), method);
+          validateSubcomponentMethod(builder,
+              method,
+              parameters,
+              parameterTypes,
+              returnType,
+              subcomponentAnnotation);
+        } else if (subcomponentBuilderAnnotation.isPresent()) {
+          referencedSubcomponents.put(MoreTypes.asElement(returnType).getEnclosingElement(),
+              method);
+          validateSubcomponentBuilderMethod(builder,
+              method,
+              parameters,
+              returnType,
+              validatedSubcomponentBuilders);
         } else {
           // if it's not a subcomponent...
           switch (parameters.size()) {
@@ -106,9 +194,9 @@
               break;
             case 1:
               // one parameter means that it's a members injection method
-              VariableElement onlyParameter = Iterables.getOnlyElement(parameters);
+              TypeMirror onlyParameter = Iterables.getOnlyElement(parameterTypes);
               if (!(returnType.getKind().equals(VOID)
-                  || types.isSameType(returnType, onlyParameter.asType()))) {
+                  || types.isSameType(returnType, onlyParameter))) {
                 builder.addItem(
                     "Members injection methods may only return the injected type or void.",
                     method);
@@ -124,15 +212,47 @@
         }
       }
     }
+    
+    for (Map.Entry<Element, Collection<ExecutableElement>> entry :
+        referencedSubcomponents.asMap().entrySet()) {
+      if (entry.getValue().size() > 1) {
+        builder.addItem(
+            String.format(
+                ErrorMessages.SubcomponentBuilderMessages.INSTANCE.moreThanOneRefToSubcomponent(),
+                entry.getKey(), entry.getValue()),
+            subject);
+      }
+    }
 
-    AnnotationMirror componentMirror = getAnnotationMirror(subject, Component.class).get();
+    AnnotationMirror componentMirror =
+        getAnnotationMirror(subject, componentType.annotationType()).get();
     ImmutableList<TypeMirror> moduleTypes = getComponentModules(componentMirror);
     moduleValidator.validateReferencedModules(subject, builder, moduleTypes);
-    return builder.build();
+    
+    // Make sure we validate any subcomponents we're referencing, unless we know we validated
+    // them already in this pass.
+    // TODO(sameb): If subcomponents refer to each other and both aren't in
+    //              'validatedSubcomponents' (e.g, both aren't compiled in this pass),
+    //              then this can loop forever.
+    ImmutableSet.Builder<Element> allSubcomponents =
+        ImmutableSet.<Element>builder().addAll(referencedSubcomponents.keySet());
+    for (Element subcomponent :
+        Sets.difference(referencedSubcomponents.keySet(), validatedSubcomponents)) {
+      ComponentValidationReport subreport = subcomponentValidator.validate(
+          MoreElements.asType(subcomponent), validatedSubcomponents, validatedSubcomponentBuilders);
+      builder.addItems(subreport.report().items());
+      allSubcomponents.addAll(subreport.referencedSubcomponents());
+    }
+    
+    return new AutoValue_ComponentValidator_ComponentValidationReport(allSubcomponents.build(),
+        builder.build());
   }
 
   private void validateSubcomponentMethod(final ValidationReport.Builder<TypeElement> builder,
-      ExecutableElement method, List<? extends VariableElement> parameters, TypeMirror returnType,
+      ExecutableElement method,
+      List<? extends VariableElement> parameters,
+      List<? extends TypeMirror> parameterTypes,
+      TypeMirror returnType,
       Optional<AnnotationMirror> subcomponentAnnotation) {
     ImmutableSet<TypeElement> moduleTypes =
         MoreTypes.asTypeElements(getComponentModules(subcomponentAnnotation.get()));
@@ -151,8 +271,10 @@ private void validateSubcomponentMethod(final ValidationReport.Builder<TypeEleme
 
     Set<TypeElement> variableTypes = Sets.newHashSet();
 
-    for (VariableElement parameter : parameters) {
-      Optional<TypeElement> moduleType = parameter.asType().accept(
+    for (int i = 0; i < parameterTypes.size(); i++) {
+      VariableElement parameter = parameters.get(i);
+      TypeMirror parameterType = parameterTypes.get(i);
+      Optional<TypeElement> moduleType = parameterType.accept(
           new SimpleTypeVisitor6<Optional<TypeElement>, Void>() {
             @Override protected Optional<TypeElement> defaultAction(TypeMirror e, Void p) {
               return Optional.absent();
@@ -186,7 +308,7 @@ private void validateSubcomponentMethod(final ValidationReport.Builder<TypeEleme
         builder.addItem(
             String.format(
                 "Subcomponent factory methods may only accept modules, but %s is not.",
-                parameter.asType()),
+                parameterType),
             parameter);
       }
     }
@@ -203,4 +325,39 @@ private void validateSubcomponentMethod(final ValidationReport.Builder<TypeEleme
           method);
     }
   }
+
+  private void validateSubcomponentBuilderMethod(ValidationReport.Builder<TypeElement> builder,
+      ExecutableElement method, List<? extends VariableElement> parameters, TypeMirror returnType,
+      Set<? extends Element> validatedSubcomponentBuilders) {
+
+    if (!parameters.isEmpty()) {
+      builder.addItem(
+          ErrorMessages.SubcomponentBuilderMessages.INSTANCE.builderMethodRequiresNoArgs(), method);
+    }
+    
+    // If we haven't already validated the subcomponent builder itself, validate it now.
+    TypeElement builderElement = MoreTypes.asTypeElement(returnType);
+    if (!validatedSubcomponentBuilders.contains(builderElement)) {
+      // TODO(sameb): The builder validator right now assumes the element is being compiled
+      // in this pass, which isn't true here.  We should change error messages to spit out
+      // this method as the subject and add the original subject to the message output.
+      builder.addItems(subcomponentBuilderValidator.validate(builderElement).items());
+    }
+  }
+
+  
+  private Optional<AnnotationMirror> checkForAnnotation(TypeMirror type,
+      final Class<? extends Annotation> annotation) {
+    return type.accept(new SimpleTypeVisitor6<Optional<AnnotationMirror>, Void>() {
+      @Override
+      protected Optional<AnnotationMirror> defaultAction(TypeMirror e, Void p) {
+        return Optional.absent();
+      }
+
+      @Override
+      public Optional<AnnotationMirror> visitDeclared(DeclaredType t, Void p) {
+        return MoreElements.getAnnotationMirror(t.asElement(), annotation);
+      }
+    }, null);
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
index de60f4285..176755d3f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
@@ -31,6 +31,7 @@
 import dagger.Subcomponent;
 import dagger.producers.ProducerModule;
 import dagger.producers.ProductionComponent;
+import java.lang.annotation.Annotation;
 import java.util.List;
 import java.util.Queue;
 import java.util.Set;
@@ -41,6 +42,7 @@
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.SimpleTypeVisitor6;
 import javax.lang.model.util.Types;
@@ -151,6 +153,18 @@ static boolean isComponent(TypeElement componentDefinitionType) {
     }
     return ImmutableSet.copyOf(moduleElements);
   }
+  
+  /** Returns the enclosed elements annotated with the given annotation type. */
+  static ImmutableList<DeclaredType> enclosedBuilders(TypeElement typeElement,
+      final Class<? extends Annotation> annotation) {
+    final ImmutableList.Builder<DeclaredType> builders = ImmutableList.builder();
+    for (TypeElement element : ElementFilter.typesIn(typeElement.getEnclosedElements())) {
+      if (MoreElements.isAnnotationPresent(element, annotation)) {
+        builders.add(MoreTypes.asDeclared(element.asType()));
+      }
+    }
+    return builders.build();
+  }
 
   static boolean isSubcomponentType(TypeMirror type) {
     return type.accept(new SubcomponentDetector(), null).isPresent();
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index 82f19ce76..5e5e57478 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -118,8 +118,6 @@
 
   static final String BINDING_METHOD_ABSTRACT = "@%s methods cannot be abstract";
 
-  static final String BINDING_METHOD_STATIC = "@%s methods cannot be static";
-
   static final String BINDING_METHOD_PRIVATE = "@%s methods cannot be private";
 
   static final String BINDING_METHOD_TYPE_PARAMETER =
@@ -213,6 +211,143 @@
 
   static final String CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD =
       "Cannot return null from a non-@Nullable @Provides method";
+  
+  static ComponentBuilderMessages builderMsgsFor(ComponentDescriptor.Kind kind) {
+    switch(kind) {
+      case COMPONENT:
+        return ComponentBuilderMessages.INSTANCE;
+      case SUBCOMPONENT:
+        return SubcomponentBuilderMessages.INSTANCE;
+      default:
+        throw new IllegalStateException(kind.toString());
+    }
+  }
+
+  static class ComponentBuilderMessages {
+    static final ComponentBuilderMessages INSTANCE = new ComponentBuilderMessages();
+
+    protected String process(String s) { return s; }
+    
+    /** Errors for component builders. */
+    final String moreThanOne() {
+      return process("@Component has more than one @Component.Builder: %s");
+    }
+    
+    final String cxtorOnlyOneAndNoArgs() {
+      return process("@Component.Builder classes must have exactly one constructor,"
+          + " and it must not have any parameters");
+    }
+    
+    final String generics() {
+      return process("@Component.Builder types must not have any generic types");
+    }
+    
+    final String mustBeInComponent() {
+      return process("@Component.Builder types must be nested within a @Component");
+    }
+    
+    final String mustBeClassOrInterface() {
+      return process("@Component.Builder types must be abstract classes or interfaces");
+    }
+    
+    final String isPrivate() {
+      return process("@Component.Builder types must not be private");
+    }
+    
+    final String mustBeStatic() {
+      return process("@Component.Builder types must be static");
+    }
+    
+    final String mustBeAbstract() {
+      return process("@Component.Builder types must be abstract");
+    }
+    
+    final String missingBuildMethod() {
+      return process("@Component.Builder types must have exactly one no-args method that "
+          + " returns the @Component type");
+    }
+    
+    final String manyMethodsForType() {
+      return process("@Component.Builder types must not have more than one setter method per type,"
+          + " but %s is set by %s");
+    }
+    
+    final String extraSetters() {
+      return process(
+          "@Component.Builder has setters for modules or components that aren't required: %s");
+    }
+    
+    final String missingSetters() {
+      return process(
+          "@Component.Builder is missing setters for required modules or components: %s");
+    }
+    
+    final String twoBuildMethods() {
+      return process("@Component.Builder types must have exactly one zero-arg method, and that"
+          + " method must return the @Component type. Already found: %s");
+    }
+    
+    final String inheritedTwoBuildMethods() {
+      return process("@Component.Builder types must have exactly one zero-arg method, and that"
+          + " method must return the @Component type. Found %s and %s");
+    }
+    
+    final String buildMustReturnComponentType() {
+      return process(
+          "@Component.Builder methods that have no arguments must return the @Component type");
+    }
+    
+    final String inheritedBuildMustReturnComponentType() {
+      return process(
+          "@Component.Builder methods that have no arguments must return the @Component type"
+          + " Inherited method: %s");
+    }
+    
+    final String methodsMustTakeOneArg() {
+      return process("@Component.Builder methods must not have more than one argument");
+    }
+    
+    final String inheritedMethodsMustTakeOneArg() {
+      return process(
+          "@Component.Builder methods must not have more than one argument. Inherited method: %s");
+    }
+    
+    final String methodsMustReturnVoidOrBuilder() {
+      return process("@Component.Builder setter methods must return void, the builder,"
+          + " or a supertype of the builder");
+    }
+    
+    final String inheritedMethodsMustReturnVoidOrBuilder() {
+      return process("@Component.Builder setter methods must return void, the builder,"
+          + "or a supertype of the builder. Inherited method: %s");
+    }
+    
+    final String methodsMayNotHaveTypeParameters() {
+      return process("@Component.Builder methods must not have type parameters");
+    }
+
+    final String inheritedMethodsMayNotHaveTypeParameters() {
+      return process(
+          "@Component.Builder methods must not have type parameters. Inherited method: %s");
+    }
+  }
+
+  static final class SubcomponentBuilderMessages extends ComponentBuilderMessages {
+    @SuppressWarnings("hiding")
+    static final SubcomponentBuilderMessages INSTANCE = new SubcomponentBuilderMessages();
+    
+    @Override protected String process(String s) {
+      return s.replaceAll("component", "subcomponent").replaceAll("Component", "Subcomponent");
+    }
+
+    String builderMethodRequiresNoArgs() {
+      return "Methods returning a @Subcomponent.Builder must have no arguments";
+    }
+    
+    String moreThanOneRefToSubcomponent() {
+      return "Only one method can create a given subcomponent. %s is created by: %s";
+    }
+  }
 
   /**
    * A regular expression to match a small list of specific packages deemed to
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index 28987e1d0..75ff023e8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -61,6 +61,7 @@
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.STATIC;
 
 /**
  * Generates {@link Factory} implementations from {@link ProvisionBinding} instances for
@@ -132,7 +133,8 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
         constructorWriter = Optional.of(classWriter.addConstructor());
         constructorWriter.get().addModifiers(PUBLIC);
         factoryWriter = classWriter;
-        if (binding.bindingKind().equals(PROVISION)) {
+        if (binding.bindingKind().equals(PROVISION)
+            && !binding.bindingElement().getModifiers().contains(STATIC)) {
           TypeName enclosingType = TypeNames.forTypeMirror(binding.bindingTypeElement().asType());
           factoryWriter.addField(enclosingType, "module").addModifiers(PRIVATE, FINAL);
           constructorWriter.get().addParameter(enclosingType, "module");
@@ -227,32 +229,34 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
     Snippet parametersSnippet = makeParametersSnippet(parameters);
 
     if (binding.bindingKind().equals(PROVISION)) {
+      Snippet providesMethodInvocation = Snippet.format("%s.%s(%s)",
+          binding.bindingElement().getModifiers().contains(STATIC)
+              ? ClassName.fromTypeElement(binding.bindingTypeElement())
+              : "module",
+          binding.bindingElement().getSimpleName(),
+          parametersSnippet);
+
       if (binding.provisionType().equals(SET)) {
-        getMethodWriter.body().addSnippet("return %s.singleton(module.%s(%s));",
-            ClassName.fromClass(Collections.class),
-            binding.bindingElement().getSimpleName(),
-            parametersSnippet);
+        getMethodWriter.body().addSnippet("return %s.singleton(%s);",
+            ClassName.fromClass(Collections.class), providesMethodInvocation);
       } else if (binding.nullableType().isPresent()
           || nullableValidationType.equals(Diagnostic.Kind.WARNING)) {
         if (binding.nullableType().isPresent()) {
           getMethodWriter.annotate(
               (ClassName) TypeNames.forTypeMirror(binding.nullableType().get()));
         }
-        getMethodWriter.body().addSnippet("return module.%s(%s);",
-            binding.bindingElement().getSimpleName(),
-            parametersSnippet);
+        getMethodWriter.body().addSnippet("return %s;", providesMethodInvocation);
       } else {
         StringLiteral failMsg =
             StringLiteral.forValue(CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD);
         getMethodWriter.body().addSnippet(Snippet.format(Joiner.on('\n').join(
-            "%s provided = module.%s(%s);",
+            "%s provided = %s;",
             "if (provided == null) {",
             "  throw new NullPointerException(%s);",
             "}",
             "return provided;"),
             getMethodWriter.returnType(),
-            binding.bindingElement().getSimpleName(),
-            parametersSnippet,
+            providesMethodInvocation,
             failMsg));
       }
     } else if (binding.memberInjectionRequest().isPresent()) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
index e41f6e9cf..09a7f1b21 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
@@ -59,9 +59,7 @@
   private final Types types;
   private final Messager messager;
   private final ProvisionBinding.Factory provisionBindingFactory;
-  private final FactoryGenerator factoryGenerator;
   private final MembersInjectionBinding.Factory membersInjectionBindingFactory;
-  private final MembersInjectorGenerator membersInjectorGenerator;
 
   final class BindingsCollection<B extends Binding> {
     private final Map<Key, B> bindingsByKey = Maps.newLinkedHashMap();
@@ -146,16 +144,12 @@ private void tryToCacheBinding(B binding) {
       Types types,
       Messager messager,
       ProvisionBinding.Factory provisionBindingFactory,
-      FactoryGenerator factoryGenerator,
-      MembersInjectionBinding.Factory membersInjectionBindingFactory,
-      MembersInjectorGenerator membersInjectorGenerator) {
+      MembersInjectionBinding.Factory membersInjectionBindingFactory) {
     this.elements = elements;
     this.types = types;
     this.messager = messager;
     this.provisionBindingFactory = provisionBindingFactory;
-    this.factoryGenerator = factoryGenerator;
     this.membersInjectionBindingFactory = membersInjectionBindingFactory;
-    this.membersInjectorGenerator = membersInjectorGenerator;
   }
 
   /**
@@ -163,7 +157,8 @@ private void tryToCacheBinding(B binding) {
    * {@linkplain #registerBinding explicitly} or implicitly via
    * {@link #getOrFindMembersInjectionBinding} or {@link #getOrFindProvisionBinding}) are generated.
    */
-  void generateSourcesForRequiredBindings() throws SourceFileGenerationException {
+  void generateSourcesForRequiredBindings(FactoryGenerator factoryGenerator,
+      MembersInjectorGenerator membersInjectorGenerator) throws SourceFileGenerationException {
     provisionBindings.generateBindings(factoryGenerator);
     membersInjectionBindings.generateBindings(membersInjectorGenerator);
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MethodSignatureFormatter.java b/compiler/src/main/java/dagger/internal/codegen/MethodSignatureFormatter.java
index 9f8514df8..078977e16 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MethodSignatureFormatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MethodSignatureFormatter.java
@@ -26,6 +26,7 @@
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ExecutableType;
+import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Types;
 
@@ -105,7 +106,10 @@ private static void appendParameter(StringBuilder builder, VariableElement param
   private static String nameOfType(TypeMirror type) {
     if (type.getKind().isPrimitive()) {
       return MoreTypes.asPrimitiveType(type).toString();
+    } else if (type.getKind() == TypeKind.VOID) {
+      return "void";
+    } else {
+      return stripCommonTypePrefixes(MoreTypes.asDeclared(type).toString());
     }
-    return stripCommonTypePrefixes(MoreTypes.asDeclared(type).toString());
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
index d9cd793b4..cf4b43ec7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
@@ -42,7 +42,6 @@
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_MAP_HAS_MAP_KEY;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_PRIVATE;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_SET_VALUES_RAW_SET;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_STATIC;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_TYPE_PARAMETER;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_MULTIPLE_MAP_KEY;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_NO_MAP_KEY;
@@ -51,7 +50,6 @@
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_SET_VALUES_RETURN_SET;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.PRIVATE;
-import static javax.lang.model.element.Modifier.STATIC;
 import static javax.lang.model.type.TypeKind.ARRAY;
 import static javax.lang.model.type.TypeKind.DECLARED;
 import static javax.lang.model.type.TypeKind.VOID;
@@ -97,10 +95,6 @@ private TypeElement getSetElement() {
     if (modifiers.contains(PRIVATE)) {
       builder.addItem(formatErrorMessage(BINDING_METHOD_PRIVATE), producesMethodElement);
     }
-    if (modifiers.contains(STATIC)) {
-      // TODO(gak): why not?
-      builder.addItem(formatErrorMessage(BINDING_METHOD_STATIC), producesMethodElement);
-    }
     if (modifiers.contains(ABSTRACT)) {
       builder.addItem(formatErrorMessage(BINDING_METHOD_ABSTRACT), producesMethodElement);
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
index 32bf8d0a0..535c5fa26 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
@@ -40,7 +40,6 @@
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_MAP_HAS_MAP_KEY;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_PRIVATE;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_SET_VALUES_RAW_SET;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_STATIC;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_TYPE_PARAMETER;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_MULTIPLE_MAP_KEY;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_NO_MAP_KEY;
@@ -96,10 +95,6 @@ private TypeElement getSetElement() {
       builder.addItem(formatErrorMessage(BINDING_METHOD_PRIVATE),
           providesMethodElement);
     }
-    if (modifiers.contains(STATIC)) {
-      // TODO(gak): why not?
-      builder.addItem(formatErrorMessage(BINDING_METHOD_STATIC), providesMethodElement);
-    }
     if (modifiers.contains(ABSTRACT)) {
       builder.addItem(formatErrorMessage(BINDING_METHOD_ABSTRACT), providesMethodElement);
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index 1d660a9e4..89383a292 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -45,11 +45,13 @@
 import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
 import static dagger.internal.codegen.InjectionAnnotations.getScopeAnnotation;
 import static dagger.internal.codegen.ProvisionBinding.Kind.INJECTION;
+import static dagger.internal.codegen.ProvisionBinding.Kind.PROVISION;
 import static dagger.internal.codegen.Util.unwrapOptionalEquivalence;
 import static dagger.internal.codegen.Util.wrapOptionalInEquivalence;
 import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
 import static javax.lang.model.element.ElementKind.FIELD;
 import static javax.lang.model.element.ElementKind.METHOD;
+import static javax.lang.model.element.Modifier.STATIC;
 
 /**
  * A value object representing the mechanism by which a {@link Key} can be provided. New instances
@@ -139,10 +141,15 @@ boolean isSyntheticBinding() {
   }
 
   FactoryCreationStrategy factoryCreationStrategy() {
-    return (bindingKind().equals(INJECTION)
-          && implicitDependencies().isEmpty())
-          ? FactoryCreationStrategy.ENUM_INSTANCE
-          : FactoryCreationStrategy.CLASS_CONSTRUCTOR;
+    if (bindingKind().equals(INJECTION) && implicitDependencies().isEmpty()) {
+      return FactoryCreationStrategy.ENUM_INSTANCE;
+    }
+    if (bindingKind().equals(PROVISION)
+        && implicitDependencies().isEmpty()
+        && bindingElement().getModifiers().contains(STATIC)) {
+      return FactoryCreationStrategy.ENUM_INSTANCE;
+    }
+    return FactoryCreationStrategy.CLASS_CONSTRUCTOR;
   }
 
   static final class Factory {
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index 58ad95c36..7acb9d759 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -21,7 +21,12 @@
 import com.google.common.base.Equivalence;
 import com.google.common.base.Equivalence.Wrapper;
 import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ImmutableSet.Builder;
 import com.google.common.collect.Iterables;
+import com.google.common.collect.Lists;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import javax.lang.model.element.AnnotationMirror;
@@ -29,10 +34,13 @@
 import javax.lang.model.element.AnnotationValueVisitor;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.SimpleAnnotationValueVisitor6;
 
@@ -175,5 +183,71 @@ static boolean componentCanMakeNewInstances(TypeElement typeElement) {
     return false;
   }
 
+  /*
+   * Borrowed from AutoValue and slightly modified. TODO(gak): reconcile and put in autocommon.
+   */
+  private static ImmutableList<ExecutableElement> findLocalAndInheritedMethods(Elements elements,
+      TypeElement type) {
+    List<ExecutableElement> methods = Lists.newArrayList();
+    TypeElement objectType = elements.getTypeElement(Object.class.getName());
+    findLocalAndInheritedMethodsRecursive(objectType, elements, type, methods);
+    return ImmutableList.copyOf(methods);
+  }
+
+  private static void findLocalAndInheritedMethodsRecursive(TypeElement objectType,
+      Elements elements, TypeElement type, List<ExecutableElement> methods) {
+    if (objectType.equals(type)) {
+      return;
+    }
+
+    for (TypeMirror superInterface : type.getInterfaces()) {
+      findLocalAndInheritedMethodsRecursive(objectType,
+          elements, MoreElements.asType(MoreTypes.asElement(superInterface)), methods);
+    }
+    if (type.getSuperclass().getKind() != TypeKind.NONE) {
+      // Visit the superclass after superinterfaces so we will always see the implementation of a
+      // method after any interfaces that declared it.
+      findLocalAndInheritedMethodsRecursive(objectType,
+          elements, MoreElements.asType(MoreTypes.asElement(type.getSuperclass())), methods);
+    }
+    // Add each method of this class, and in so doing remove any inherited method it overrides.
+    // This algorithm is quadratic in the number of methods but it's hard to see how to improve
+    // that while still using Elements.overrides.
+    List<ExecutableElement> theseMethods = ElementFilter.methodsIn(type.getEnclosedElements());
+    for (ExecutableElement method : theseMethods) {
+      if (!method.getModifiers().contains(Modifier.PRIVATE)) {
+        boolean alreadySeen = false;
+        for (Iterator<ExecutableElement> methodIter = methods.iterator(); methodIter.hasNext();) {
+          ExecutableElement otherMethod = methodIter.next();
+          if (elements.overrides(method, otherMethod, type)) {
+            methodIter.remove();
+          } else if (method.getSimpleName().equals(otherMethod.getSimpleName())
+              && method.getParameters().equals(otherMethod.getParameters())) {
+            // If we inherit this method on more than one path, we don't want to add it twice.
+            alreadySeen = true;
+          }
+        }
+        if (!alreadySeen) {
+          methods.add(method);
+        }
+      }
+    }
+  }
+
+  /*
+   * Borrowed from AutoValue and slightly modified. TODO(gak): reconcile and put in autocommon.
+   */
+  static ImmutableSet<ExecutableElement> getUnimplementedMethods(
+      Elements elements, TypeElement type) {
+    ImmutableSet.Builder<ExecutableElement> unimplementedMethods = ImmutableSet.builder();
+    List<ExecutableElement> methods = findLocalAndInheritedMethods(elements, type);
+    for (ExecutableElement method : methods) {
+      if (method.getModifiers().contains(Modifier.ABSTRACT)) {
+        unimplementedMethods.add(method);
+      }
+    }
+    return unimplementedMethods.build();
+  }
+
   private Util() {}
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java b/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java
index 6f1be009f..d9e9daef7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java
@@ -89,6 +89,11 @@ private Builder(T subject) {
     T getSubject() {
       return subject;
     }
+    
+    Builder<T> addItems(Iterable<Item> newItems) {
+      items.addAll(newItems);
+      return this;
+    }
 
     Builder<T> addItem(String message, Element element) {
       addItem(message, ERROR, element, Optional.<AnnotationMirror>absent());
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/ArrayTypeName.java b/compiler/src/main/java/dagger/internal/codegen/writer/ArrayTypeName.java
index 041cdc625..e7960629e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/ArrayTypeName.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/ArrayTypeName.java
@@ -38,7 +38,7 @@ public Appendable write(Appendable appendable, Context context) throws IOExcepti
   @Override
   public boolean equals(Object obj) {
     return (obj instanceof ArrayTypeName)
-        & this.componentType.equals(((ArrayTypeName) obj).componentType);
+        && this.componentType.equals(((ArrayTypeName) obj).componentType);
   }
 
   @Override
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java
new file mode 100644
index 000000000..de59af6ec
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java
@@ -0,0 +1,938 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+
+/** Tests for {@link dagger.Component.Builder} */
+@RunWith(JUnit4.class)
+public class ComponentBuilderTest {
+  
+  private static final ErrorMessages.ComponentBuilderMessages MSGS =
+      ErrorMessages.ComponentBuilderMessages.INSTANCE;
+  
+  @Test
+  public void testEmptyBuilder() {
+    JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class SomeInjectableType {",
+        "  @Inject SomeInjectableType() {}",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface SimpleComponent {",
+        "  SomeInjectableType someInjectableType();",
+        "",
+        "  @Component.Builder",
+        "  static interface Builder {",
+        "     SimpleComponent build();",
+        "  }",        
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.DaggerSimpleComponent",
+        "package test;",
+        "",
+        "import javax.annotation.Generated;",
+        "import test.SimpleComponent",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class DaggerSimpleComponent implements SimpleComponent {",
+        "  private DaggerSimpleComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    initialize(builder);",
+        "  }",
+        "",
+        "  public static SimpleComponent.Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static SimpleComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  private void initialize(final Builder builder) {",
+        "  }",
+        "",
+        "  @Override",
+        "  public SomeInjectableType someInjectableType() {",
+        "    return SomeInjectableType_Factory.create().get();",
+        "  }",
+        "",
+        "  private static final class Builder implements SimpleComponent.Builder {",
+        "    @Override",
+        "    public SimpleComponent build() {",
+        "      return new DaggerSimpleComponent(this);",
+        "    }",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(injectableTypeFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
+  
+  @Test
+  public void testUsesBuildAndSetterNames() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides String string() { return null; }",
+        "}");
+
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component(modules = TestModule.class)",
+        "interface TestComponent {",
+        "  String string();",
+        "",
+        "  @Component.Builder",
+        "  interface Builder {",
+        "    Builder setTestModule(TestModule testModule);",
+        "    TestComponent create();",
+        "  }",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.DaggerTestComponent",
+        "package test;",
+        "",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "import test.TestComponent;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class DaggerTestComponent implements TestComponent {",
+        "  private Provider<String> stringProvider;",
+        "",
+        "  private DaggerTestComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    initialize(builder);",
+        "  }",
+        "",
+        "  public static TestComponent.Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static TestComponent create() {",
+        "    return builder().create();",
+        "  }",
+        "",
+        "  private void initialize(final Builder builder) {",
+        "    this.stringProvider = TestModule_StringFactory.create(builder.testModule);",
+        "  }",
+        "",
+        "  @Override",
+        "  public String string() {",
+        "    return stringProvider.get();",
+        "  }",
+        "",
+        "  private static final class Builder implements TestComponent.Builder {",
+        "    private TestModule testModule;",
+        "",
+        "    @Override",
+        "    public TestComponent create() {",
+        "      if (testModule == null) {",
+        "        this.testModule = new TestModule();",
+        "      }",
+        "      return new DaggerTestComponent(this);",
+        "    }",
+        "",
+        "    @Override",
+        "    public Builder setTestModule(TestModule testModule) {",
+        "      if (testModule == null) {",
+        "        throw new NullPointerException(\"testModule\");",
+        "      }",
+        "      this.testModule = testModule;",
+        "      return this;",
+        "    }",
+        "  }",
+        "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(moduleFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
+  
+  @Test
+  public void testIgnoresModulesNotInApi() {
+    JavaFileObject module1 = JavaFileObjects.forSourceLines("test.TestModule1",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class TestModule1 {",
+        "  @Provides String string() { return null; }",
+        "}");
+    JavaFileObject module2 = JavaFileObjects.forSourceLines("test.TestModule2",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class TestModule2 {",
+        "  @Provides Integer integer() { return null; }",
+        "}");
+
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component(modules = {TestModule1.class, TestModule2.class})",
+        "interface TestComponent {",
+        "  String string();",
+        "  Integer integer();",
+        "",
+        "  @Component.Builder",
+        "  interface Builder {",
+        "    Builder testModule1(TestModule1 testModule);",
+        "    TestComponent build();",
+        "  }",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.DaggerTestComponent",
+        "package test;",
+        "",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "import test.TestComponent;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class DaggerTestComponent implements TestComponent {",
+        "  private Provider<String> stringProvider;",
+        "  private Provider<Integer> integerProvider;",
+        "",
+        "  private DaggerTestComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    initialize(builder);",
+        "  }",
+        "",
+        "  public static TestComponent.Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static TestComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  private void initialize(final Builder builder) {",
+        "    this.stringProvider = TestModule1_StringFactory.create(builder.testModule1);",
+        "    this.integerProvider = TestModule2_IntegerFactory.create(builder.testModule2);",
+        "  }",
+        "",
+        "  @Override",
+        "  public String string() {",
+        "    return stringProvider.get();",
+        "  }",
+        "",
+        "  @Override",
+        "  public Integer integer() {",
+        "    return integerProvider.get();",
+        "  }",
+        "",
+        "  private static final class Builder implements TestComponent.Builder {",
+        "    private TestModule1 testModule1;",
+        "    private TestModule2 testModule2;",
+        "",
+        "    @Override",
+        "    public TestComponent build() {",
+        "      if (testModule1 == null) {",
+        "        this.testModule1 = new TestModule1();",
+        "      }",
+        "      if (testModule2 == null) {",
+        "        this.testModule2 = new TestModule2();",
+        "      }",
+        "      return new DaggerTestComponent(this);",
+        "    }",
+        "",
+        "    @Override",
+        "    public Builder testModule1(TestModule1 testModule1) {",
+        "      if (testModule1 == null) {",
+        "        throw new NullPointerException(\"testModule1\");",
+        "      }",
+        "      this.testModule1 = testModule1;",
+        "      return this;",
+        "    }",
+        "  }",
+        "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(module1, module2, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
+  
+  @Test
+  public void testMoreThanOneBuilderFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface SimpleComponent {",
+        "  @Component.Builder",
+        "  static interface Builder {",
+        "     SimpleComponent build();",
+        "  }",
+        "",
+        "  @Component.Builder",
+        "  interface Builder2 {",
+        "     SimpleComponent build();",
+        "  }",           
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(String.format(MSGS.moreThanOne(),
+            "[test.SimpleComponent.Builder, test.SimpleComponent.Builder2]"))
+        .in(componentFile);
+  }
+  
+  @Test
+  public void testBuilderGenericsFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface SimpleComponent {",
+        "  @Component.Builder",
+        "  interface Builder<T> {",
+        "     SimpleComponent build();",
+        "  }",           
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.generics())
+        .in(componentFile);
+  }
+  
+  @Test
+  public void testBuilderNotInComponentFails() {
+    JavaFileObject builder = JavaFileObjects.forSourceLines("test.Builder",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component.Builder",
+        "interface Builder {}");
+    assertAbout(javaSource()).that(builder)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.mustBeInComponent())
+        .in(builder);
+  }
+  
+  @Test
+  public void testBuilderMissingBuildMethodFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface SimpleComponent {",
+        "  @Component.Builder",
+        "  interface Builder {}",
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.missingBuildMethod())
+        .in(componentFile);
+  }
+  
+  @Test
+  public void testPrivateBuilderFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "abstract class SimpleComponent {",
+        "  @Component.Builder",
+        "  private interface Builder {}",
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.isPrivate())
+        .in(componentFile);
+  }
+  
+  @Test
+  public void testNonStaticBuilderFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "abstract class SimpleComponent {",
+        "  @Component.Builder",
+        "  abstract class Builder {}",
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.mustBeStatic())
+        .in(componentFile);
+  }
+  
+  @Test
+  public void testNonAbstractBuilderFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "abstract class SimpleComponent {",
+        "  @Component.Builder",
+        "  static class Builder {}",
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.mustBeAbstract());
+  }
+  
+  @Test
+  public void testBuilderOneCxtorWithArgsFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "abstract class SimpleComponent {",
+        "  @Component.Builder",
+        "  static abstract class Builder {",
+        "    Builder(String unused) {}",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.cxtorOnlyOneAndNoArgs())
+        .in(componentFile);
+  }
+  
+  @Test
+  public void testBuilderMoreThanOneCxtorFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "abstract class SimpleComponent {",
+        "  @Component.Builder",
+        "  static abstract class Builder {",
+        "    Builder() {}",
+        "    Builder(String unused) {}",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.cxtorOnlyOneAndNoArgs())
+        .in(componentFile);
+  }
+  
+  @Test
+  public void testBuilderEnumFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "abstract class SimpleComponent {",
+        "  @Component.Builder",
+        "  enum Builder {}",
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.mustBeClassOrInterface())
+        .in(componentFile);
+  }
+  
+  @Test
+  public void testBuilderBuildReturnsWrongTypeFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "abstract class SimpleComponent {",
+        "  @Component.Builder",
+        "  interface Builder {",
+        "    String build();",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.buildMustReturnComponentType())
+            .in(componentFile).onLine(11);
+  }
+  
+  @Test
+  public void testInheritedBuilderBuildReturnsWrongTypeFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "abstract class SimpleComponent {",
+        "  interface Parent {",
+        "    String build();",
+        "  }",
+        "",
+        "  @Component.Builder",
+        "  interface Builder extends Parent {}",
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(MSGS.inheritedBuildMustReturnComponentType(), "build"))
+            .in(componentFile).onLine(14);
+  }
+  
+  @Test
+  public void testTwoBuildMethodsFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "abstract class SimpleComponent {",
+        "  @Component.Builder",
+        "  interface Builder {",
+        "    SimpleComponent build();",
+        "    SimpleComponent create();",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(String.format(MSGS.twoBuildMethods(), "build()"))
+            .in(componentFile).onLine(12);
+  }
+  
+  @Test
+  public void testInheritedTwoBuildMethodsFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "abstract class SimpleComponent {",
+        "  interface Parent {",
+        "    SimpleComponent build();",
+        "    SimpleComponent create();",
+        "  }",
+        "",
+        "  @Component.Builder",
+        "  interface Builder extends Parent {}",
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(MSGS.inheritedTwoBuildMethods(), "create()", "build()"))
+            .in(componentFile).onLine(15);
+  }
+  
+  @Test
+  public void testMoreThanOneArgFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "abstract class SimpleComponent {",
+        "  @Component.Builder",
+        "  interface Builder {",
+        "    SimpleComponent build();",
+        "    Builder set(String s, Integer i);",
+        "    Builder set(Number n, Double d);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.methodsMustTakeOneArg())
+            .in(componentFile).onLine(12)
+        .and().withErrorContaining(MSGS.methodsMustTakeOneArg())
+            .in(componentFile).onLine(13);
+  }
+  
+  @Test
+  public void testInheritedMoreThanOneArgFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "abstract class SimpleComponent {",
+        "  interface Parent {",
+        "    SimpleComponent build();",
+        "    Builder set1(String s, Integer i);",
+        "  }",
+        "",
+        "  @Component.Builder",
+        "  interface Builder extends Parent {}",
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(MSGS.inheritedMethodsMustTakeOneArg(),
+                "set1(java.lang.String,java.lang.Integer)"))
+            .in(componentFile).onLine(15);
+  }
+  
+  @Test
+  public void testSetterReturningNonVoidOrBuilderFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "abstract class SimpleComponent {",
+        "  @Component.Builder",
+        "  interface Builder {",
+        "    SimpleComponent build();",
+        "    String set(Integer i);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.methodsMustReturnVoidOrBuilder())
+            .in(componentFile).onLine(12);
+  }
+  
+  @Test
+  public void testInheritedSetterReturningNonVoidOrBuilderFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "abstract class SimpleComponent {",
+        "  interface Parent {",
+        "    SimpleComponent build();",
+        "    String set(Integer i);",
+        "  }",
+        "",
+        "  @Component.Builder",
+        "  interface Builder extends Parent {}",
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(MSGS.inheritedMethodsMustReturnVoidOrBuilder(),
+                "set(java.lang.Integer)"))
+            .in(componentFile).onLine(15);    
+  }
+  
+  @Test
+  public void testGenericsOnSetterMethodFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "abstract class SimpleComponent {",
+        "  @Component.Builder",
+        "  interface Builder {",
+        "    SimpleComponent build();",
+        "    <T> Builder set(T t);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.methodsMayNotHaveTypeParameters())
+            .in(componentFile).onLine(12);
+  }
+  
+  @Test
+  public void testGenericsOnInheritedSetterMethodFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "abstract class SimpleComponent {",
+        "  interface Parent {",
+        "    SimpleComponent build();",
+        "    <T> Builder set(T t);",
+        "  }",
+        "",
+        "  @Component.Builder",
+        "  interface Builder extends Parent {}",
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(MSGS.inheritedMethodsMayNotHaveTypeParameters(), "<T>set(T)"))
+            .in(componentFile).onLine(15);    
+  }
+  
+  @Test
+  public void testMultipleSettersPerTypeFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "abstract class SimpleComponent {",
+        "  @Component.Builder",
+        "  interface Builder {",
+        "    SimpleComponent build();",
+        "    void set1(String s);",
+        "    void set2(String s);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(MSGS.manyMethodsForType(),
+                  "java.lang.String", "[set1(java.lang.String), set2(java.lang.String)]"))
+            .in(componentFile).onLine(10);
+  }
+  
+  @Test
+  public void testMultipleSettersPerTypeIncludingResolvedGenericsFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "abstract class SimpleComponent {",
+        "  interface Parent<T> {",
+        "    void set1(T t);",
+        "  }",
+        "",
+        "  @Component.Builder",
+        "  interface Builder extends Parent<String> {",
+        "    SimpleComponent build();",
+        "    void set2(String s);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(MSGS.manyMethodsForType(),
+                  "java.lang.String", "[set1(T), set2(java.lang.String)]"))
+            .in(componentFile).onLine(14);
+  }
+  
+  @Test
+  public void testExtraSettersFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "abstract class SimpleComponent {",
+        "  @Component.Builder",
+        "  interface Builder {",
+        "    SimpleComponent build();",
+        "    void set1(String s);",
+        "    void set2(Integer s);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(MSGS.extraSetters(),
+                  "[void test.SimpleComponent.Builder.set1(String),"
+                  + " void test.SimpleComponent.Builder.set2(Integer)]"))
+            .in(componentFile).onLine(10);
+    
+  }
+  
+  @Test
+  public void testMissingSettersFail() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  TestModule(String unused) {}",
+        "  @Provides String s() { return null; }",
+        "}");
+    JavaFileObject module2File = JavaFileObjects.forSourceLines("test.Test2Module",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class Test2Module {",
+        "  @Provides Integer i() { return null; }",
+        "}");
+    JavaFileObject module3File = JavaFileObjects.forSourceLines("test.Test3Module",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class Test3Module {",
+        "  Test3Module(String unused) {}",
+        "  @Provides Double d() { return null; }",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component(modules = {TestModule.class, Test2Module.class, Test3Module.class},",
+        "           dependencies = OtherComponent.class)",
+        "interface TestComponent {",
+        "  String string();",
+        "  Integer integer();",
+        "",
+        "  @Component.Builder",
+        "  interface Builder {",
+        "    TestComponent create();",
+        "  }",
+        "}");
+    JavaFileObject otherComponent = JavaFileObjects.forSourceLines("test.OtherComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "interface OtherComponent {}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(moduleFile, module2File, module3File, componentFile, otherComponent))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            // Ignores Test2Module because we can construct it ourselves.
+            // TODO(sameb): Ignore Test3Module because it's not used within transitive dependencies.
+            String.format(MSGS.missingSetters(),
+                "[test.TestModule, test.Test3Module, test.OtherComponent]"))
+            .in(componentFile).onLine(12);
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index 175dd1969..c5841c8db 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -1242,8 +1242,9 @@
         "",
         "  private void initialize(final Builder builder) {",
         "    this.aProvider = new Factory<A>() {",
+        "      private final AComponent aComponent = builder.aComponent;",
         "      @Override public A get() {",
-        "        A provided = builder.aComponent.a();",
+        "        A provided = aComponent.a();",
         "        if (provided == null) {",
         "          throw new NullPointerException(" + NPE_LITERAL + ");",
         "        }",
diff --git a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
index 56a51df7b..2642497f2 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
@@ -31,7 +31,6 @@
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_IN_MODULE;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_PRIVATE;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_SET_VALUES_RAW_SET;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_STATIC;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_TYPE_PARAMETER;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_SAME_NAME;
 import static dagger.internal.codegen.ErrorMessages.MODULES_WITH_TYPE_PARAMS_MUST_BE_ABSTRACT;
@@ -113,25 +112,6 @@ private String formatModuleErrorMessage(String msg) {
         .withErrorContaining(formatErrorMessage(BINDING_METHOD_PRIVATE));
   }
 
-  @Test public void providesMethodStatic() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "",
-        "@Module",
-        "final class TestModule {",
-        "  @Provides static String provideString() {",
-        "    return \"\";",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(formatErrorMessage(BINDING_METHOD_STATIC));
-  }
-
   @Test public void providesMethodReturnVoid() {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
index 0878f42a4..9e209bb00 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
@@ -30,7 +30,6 @@
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_IN_MODULE;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_PRIVATE;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_SET_VALUES_RAW_SET;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_STATIC;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_TYPE_PARAMETER;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_SAME_NAME;
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_RAW_FUTURE;
@@ -101,25 +100,6 @@ private String formatModuleErrorMessage(String msg) {
         .withErrorContaining(formatErrorMessage(BINDING_METHOD_PRIVATE));
   }
 
-  @Test public void producesMethodStatic() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "",
-        "@ProducerModule",
-        "final class TestModule {",
-        "  @Produces static String produceString() {",
-        "    return \"\";",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(formatErrorMessage(BINDING_METHOD_STATIC));
-  }
-
   @Test public void producesMethodReturnVoid() {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
diff --git a/compiler/src/test/java/dagger/internal/codegen/SubcomponentBuilderValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/SubcomponentBuilderValidationTest.java
new file mode 100644
index 000000000..6311a90ca
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/SubcomponentBuilderValidationTest.java
@@ -0,0 +1,742 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+
+/** Tests for {@link dagger.Subcomponent.Builder} validation. */
+@RunWith(JUnit4.class)
+public class SubcomponentBuilderValidationTest {
+  
+  private static final ErrorMessages.SubcomponentBuilderMessages MSGS =
+      new ErrorMessages.SubcomponentBuilderMessages();
+  
+  @Test
+  public void testRefSubcomponentAndSubBuilderFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.ParentComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface ParentComponent {",
+        "  ChildComponent child();",
+        "  ChildComponent.Builder builder();",        
+        "}");
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "interface ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  static interface Builder {",
+        "    ChildComponent build();",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(String.format(MSGS.moreThanOneRefToSubcomponent(),
+            "test.ChildComponent", "[child(), builder()]"))
+        .in(componentFile);
+  }
+  
+  @Test
+  public void testRefSubBuilderTwiceFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.ParentComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface ParentComponent {",
+        "  ChildComponent.Builder builder1();",
+        "  ChildComponent.Builder builder2();",        
+        "}");
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "interface ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  static interface Builder {",
+        "    ChildComponent build();",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(String.format(MSGS.moreThanOneRefToSubcomponent(),
+            "test.ChildComponent", "[builder1(), builder2()]"))
+        .in(componentFile);
+  }
+  
+  @Test
+  public void testMoreThanOneBuilderFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.ParentComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface ParentComponent {",
+        "  ChildComponent.Builder1 build();",        
+        "}");
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "interface ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  static interface Builder1 {",
+        "    ChildComponent build();",
+        "  }",
+        "",
+        "  @Subcomponent.Builder",
+        "  static interface Builder2 {",
+        "    ChildComponent build();",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(String.format(MSGS.moreThanOne(),
+            "[test.ChildComponent.Builder1, test.ChildComponent.Builder2]"))
+        .in(childComponentFile);
+  }
+  
+  @Test
+  public void testBuilderGenericsFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.ParentComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface ParentComponent {",
+        "  ChildComponent.Builder1 build();",        
+        "}");
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "interface ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  interface Builder<T> {",
+        "     ChildComponent build();",
+        "  }",           
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.generics())
+        .in(childComponentFile);
+  }
+  
+  @Test
+  public void testBuilderNotInComponentFails() {
+    JavaFileObject builder = JavaFileObjects.forSourceLines("test.Builder",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent.Builder",
+        "interface Builder {}");
+    assertAbout(javaSource()).that(builder)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.mustBeInComponent())
+        .in(builder);
+  }
+  
+  @Test
+  public void testBuilderMissingBuildMethodFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.ParentComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface ParentComponent {",
+        "  ChildComponent.Builder1 build();",        
+        "}");
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "interface ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  interface Builder {}",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.missingBuildMethod())
+        .in(childComponentFile);
+  }
+  
+  @Test
+  public void testPrivateBuilderFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  private interface Builder {}",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.isPrivate())
+        .in(childComponentFile);
+  }
+  
+  @Test
+  public void testNonStaticBuilderFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  abstract class Builder {}",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.mustBeStatic())
+        .in(childComponentFile);
+  }
+  
+  @Test
+  public void testNonAbstractBuilderFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  static class Builder {}",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.mustBeAbstract())
+        .in(childComponentFile);
+  }
+  
+  @Test
+  public void testBuilderOneCxtorWithArgsFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  static abstract class Builder {",
+        "    Builder(String unused) {}",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.cxtorOnlyOneAndNoArgs())
+        .in(childComponentFile);
+  }
+  
+  @Test
+  public void testBuilderMoreThanOneCxtorFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  static abstract class Builder {",
+        "    Builder() {}",
+        "    Builder(String unused) {}",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.cxtorOnlyOneAndNoArgs())
+        .in(childComponentFile);
+  }
+  
+  @Test
+  public void testBuilderEnumFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  enum Builder {}",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.mustBeClassOrInterface())
+        .in(childComponentFile);
+  }
+  
+  @Test
+  public void testBuilderBuildReturnsWrongTypeFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  interface Builder {",
+        "    String build();",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.buildMustReturnComponentType())
+            .in(childComponentFile).onLine(9);
+  }
+  
+  @Test
+  public void testInheritedBuilderBuildReturnsWrongTypeFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  interface Parent {",
+        "    String build();",
+        "  }",
+        "",
+        "  @Subcomponent.Builder",
+        "  interface Builder extends Parent {}",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(MSGS.inheritedBuildMustReturnComponentType(), "build"))
+            .in(childComponentFile).onLine(12);
+  }
+  
+  @Test
+  public void testTwoBuildMethodsFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  interface Builder {",
+        "    ChildComponent build();",
+        "    ChildComponent create();",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(String.format(MSGS.twoBuildMethods(), "build()"))
+            .in(childComponentFile).onLine(10);
+  }
+  
+  @Test
+  public void testInheritedTwoBuildMethodsFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  interface Parent {",
+        "    ChildComponent build();",
+        "    ChildComponent create();",
+        "  }",
+        "",
+        "  @Subcomponent.Builder",
+        "  interface Builder extends Parent {}",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(MSGS.inheritedTwoBuildMethods(), "create()", "build()"))
+            .in(childComponentFile).onLine(13);
+  }
+  
+  @Test
+  public void testMoreThanOneArgFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  interface Builder {",
+        "    ChildComponent build();",
+        "    Builder set(String s, Integer i);",
+        "    Builder set(Number n, Double d);",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.methodsMustTakeOneArg())
+            .in(childComponentFile).onLine(10)
+        .and().withErrorContaining(MSGS.methodsMustTakeOneArg())
+            .in(childComponentFile).onLine(11);
+  }
+  
+  @Test
+  public void testInheritedMoreThanOneArgFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  interface Parent {",
+        "    ChildComponent build();",
+        "    Builder set1(String s, Integer i);",
+        "  }",
+        "",
+        "  @Subcomponent.Builder",
+        "  interface Builder extends Parent {}",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(MSGS.inheritedMethodsMustTakeOneArg(),
+                "set1(java.lang.String,java.lang.Integer)"))
+            .in(childComponentFile).onLine(13);
+  }
+  
+  @Test
+  public void testSetterReturningNonVoidOrBuilderFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  interface Builder {",
+        "    ChildComponent build();",
+        "    String set(Integer i);",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.methodsMustReturnVoidOrBuilder())
+            .in(childComponentFile).onLine(10);
+  }
+  
+  @Test
+  public void testInheritedSetterReturningNonVoidOrBuilderFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  interface Parent {",
+        "    ChildComponent build();",
+        "    String set(Integer i);",
+        "  }",
+        "",
+        "  @Subcomponent.Builder",
+        "  interface Builder extends Parent {}",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(MSGS.inheritedMethodsMustReturnVoidOrBuilder(),
+                "set(java.lang.Integer)"))
+            .in(childComponentFile).onLine(13);    
+  }
+  
+  @Test
+  public void testGenericsOnSetterMethodFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  interface Builder {",
+        "    ChildComponent build();",
+        "    <T> Builder set(T t);",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.methodsMayNotHaveTypeParameters())
+            .in(childComponentFile).onLine(10);
+  }
+  
+  @Test
+  public void testGenericsOnInheritedSetterMethodFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  interface Parent {",
+        "    ChildComponent build();",
+        "    <T> Builder set(T t);",
+        "  }",
+        "",
+        "  @Subcomponent.Builder",
+        "  interface Builder extends Parent {}",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(MSGS.inheritedMethodsMayNotHaveTypeParameters(), "<T>set(T)"))
+            .in(childComponentFile).onLine(13);    
+  }
+  
+  @Test
+  public void testMultipleSettersPerTypeFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  interface Builder {",
+        "    ChildComponent build();",
+        "    void set1(String s);",
+        "    void set2(String s);",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(MSGS.manyMethodsForType(),
+                  "java.lang.String", "[set1(java.lang.String), set2(java.lang.String)]"))
+            .in(childComponentFile).onLine(8);
+  }
+  
+  @Test
+  public void testMultipleSettersPerTypeIncludingResolvedGenericsFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  interface Parent<T> {",
+        "    void set1(T t);",
+        "  }",
+        "",
+        "  @Subcomponent.Builder",
+        "  interface Builder extends Parent<String> {",
+        "    ChildComponent build();",
+        "    void set2(String s);",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(MSGS.manyMethodsForType(),
+                  "java.lang.String", "[set1(T), set2(java.lang.String)]"))
+            .in(childComponentFile).onLine(12);
+  }
+  
+  @Test
+  public void testExtraSettersFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.ParentComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface ParentComponent {",
+        "  ChildComponent.Builder build();",        
+        "}");
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "interface ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  interface Builder {",
+        "    ChildComponent build();",
+        "    void set1(String s);",
+        "    void set2(Integer s);",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(MSGS.extraSetters(),
+                  "[void test.ChildComponent.Builder.set1(String),"
+                  + " void test.ChildComponent.Builder.set2(Integer)]"))
+            .in(childComponentFile).onLine(8);
+    
+  }
+  
+  @Test
+  public void testMissingSettersFail() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  TestModule(String unused) {}",
+        "  @Provides String s() { return null; }",
+        "}");
+    JavaFileObject module2File = JavaFileObjects.forSourceLines("test.Test2Module",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class Test2Module {",
+        "  @Provides Integer i() { return null; }",
+        "}");
+    JavaFileObject module3File = JavaFileObjects.forSourceLines("test.Test3Module",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class Test3Module {",
+        "  Test3Module(String unused) {}",
+        "  @Provides Double d() { return null; }",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.ParentComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface ParentComponent {",
+        "  ChildComponent.Builder build();",        
+        "}");
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent(modules = {TestModule.class, Test2Module.class, Test3Module.class})",
+        "interface ChildComponent {",
+        "  String string();",
+        "  Integer integer();",
+        "",
+        "  @Subcomponent.Builder",
+        "  interface Builder {",
+        "    ChildComponent create();",
+        "  }",
+        "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(moduleFile,
+            module2File,
+            module3File,
+            componentFile,
+            childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            // Ignores Test2Module because we can construct it ourselves.
+            // TODO(sameb): Ignore Test3Module because it's not used within transitive dependencies.
+            String.format(MSGS.missingSetters(), "[test.TestModule, test.Test3Module]"))
+            .in(childComponentFile).onLine(11);
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java
index cf15210ee..91035b291 100644
--- a/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java
@@ -192,4 +192,56 @@
             "java.lang.Integer cannot be provided without an @Inject constructor or from an "
                 + "@Provides-annotated method");
   }
+
+  @Test public void subcomponentOnConcreteType() {
+    JavaFileObject subcomponentFile = JavaFileObjects.forSourceLines("test.NotASubcomponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "final class NotASubcomponent {}");
+    assertAbout(javaSources()).that(ImmutableList.of(subcomponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("interface");
+  }
+
+  @Test public void scopeMismatch() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.ParentComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import javax.inject.Singleton;",
+        "",
+        "@Component",
+        "@Singleton",
+        "interface ParentComponent {",
+        "  ChildComponent childComponent();",
+        "}");
+    JavaFileObject subcomponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent(modules = ChildModule.class)",
+        "interface ChildComponent {",
+        "  Object getObject();",
+        "}");
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.ChildModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Singleton;",
+        "",
+        "@Module",
+        "final class ChildModule {",
+        "  @Provides @Singleton Object provideObject() { return null; }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(componentFile, subcomponentFile, moduleFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("@Singleton");
+  }
 }
diff --git a/core/src/main/java/dagger/Component.java b/core/src/main/java/dagger/Component.java
index a1667328b..7d724017e 100644
--- a/core/src/main/java/dagger/Component.java
+++ b/core/src/main/java/dagger/Component.java
@@ -22,6 +22,7 @@
 import javax.inject.Provider;
 import javax.inject.Qualifier;
 import javax.inject.Scope;
+import javax.inject.Singleton;
 
 import static java.lang.annotation.ElementType.TYPE;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
@@ -108,13 +109,16 @@
  *
  * <p>Component implementations are primarily instantiated via a generated
  * <a href="http://en.wikipedia.org/wiki/Builder_pattern">builder</a>. An instance of the builder
- * is obtained using the {@code builder()} method on the component implementation. The returned
- * builder has a method to set each of the {@linkplain #modules} and component
- * {@linkplain #dependencies} named with the <a href="http://en.wikipedia.org/wiki/CamelCase">lower
- * camel case</a> version of the module or dependency type. Each component dependency and module
- * without a visible default constructor must be set explicitly, but any module with a default or
- * no-args constructor accessible to the component implementation may be elided. This is an example
- * usage of a component builder: <pre><code>
+ * is obtained using the {@code builder()} method on the component implementation.
+ * If a nested {@code @Component.Builder} type exists in the component, the {@code builder()}
+ * method will return a generated implementation of that type.  If no nested
+ * {@code @Component.Builder} exists, the returned builder has a method to set each of the
+ * {@linkplain #modules} and component {@linkplain #dependencies} named with the
+ * <a href="http://en.wikipedia.org/wiki/CamelCase">lower camel case</a> version of the module
+ * or dependency type. Each component dependency and module without a visible default constructor
+ * must be set explicitly, but any module with a default or no-args constructor accessible to the
+ * component implementation may be elided. This is an example usage of a component builder:
+ * <pre><code>
  *   public static void main(String[] args) {
  *     OtherComponent otherComponent = ...;
  *     MyComponent component = DaggerMyComponent.builder()
@@ -217,4 +221,38 @@
    * dependencies</a>.
    */
   Class<?>[] dependencies() default {};
+
+  /**
+   * A builder for a component. Components may have a single nested static abstract class or
+   * interface annotated with {@code @Component.Builder}.  If they do, then the component's
+   * generated builder will match the API in the type.  Builders must follow some rules:
+   * <ul>
+   * <li> A single abstract method with no arguments must exist, and must return the component.
+   *      (This is typically the {@code build()} method.)
+   * <li> All other abstract methods must take a single argument and must return void,
+   *      the Builder type, or a supertype of the builder.
+   * <li> Each component dependency <b>must</b> have an abstract setter method.
+   * <li> Each module dependency that Dagger can't instantiate itself (e.g, the module
+   *      doesn't have a visible no-args constructor) <b>must</b> have an abstract setter method.
+   *      Other module dependencies (ones that Dagger can instantiate) are allowed, but not required.
+   * <li> Non-abstract methods are allowed, but ignored as far as validation and builder generation
+   *      are concerned.
+   * </ul>
+   * 
+   * For example, this could be a valid Component with a Builder: <pre><code>
+   * {@literal @}Component(modules = {BackendModule.class, FrontendModule.class})
+   * interface MyComponent {
+   *   MyWidget myWidget();
+   *   
+   *   {@literal @}Component.Builder
+   *   interface Builder {
+   *     MyComponent build();
+   *     Builder backendModule(BackendModule bm);
+   *     Builder frontendModule(FrontendModule fm);
+   *   }
+   * }</code></pre>
+   */
+  @Target(TYPE)
+  @Documented
+  @interface Builder {}
 }
diff --git a/core/src/main/java/dagger/MapKey.java b/core/src/main/java/dagger/MapKey.java
index 8699c42a0..fcde154ce 100644
--- a/core/src/main/java/dagger/MapKey.java
+++ b/core/src/main/java/dagger/MapKey.java
@@ -24,26 +24,76 @@
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 /**
- * It enables to define customized key type annotation for map binding by
- * annotating an annotation of a {@code Map}'s key type. The defined key type
- * annotation can be later applied to the key of the {@code Map}. Currently
- * {@code String} and {@code enum} key types are supported for map binding.
+ * Identifies annotation types that are used to associate keys with values returned by
+ * {@linkplain Provides provider methods} in order to compose a {@linkplain Provides#Type#MAP map}.
  *
- * <h2>Example</h2> For example, if you want to define a key type annotation
- * called StringKey, you can define it the following way:
+ * <p>Every provider method annotated with {@code @Provides(type = MAP)} must also have an
+ * annotation that identifies the key for that map entry. That annotation's type must be annotated
+ * with {@code @MapKey}.
+ *
+ * <p>Typically, the key annotation has a single member element, whose value is used as the map key.
+ *
+ * <p>For example, to add an entry to a {@code Map<String, Integer>} with key "foo", you could use
+ * an annotation called {@code @StringKey}:
+ *
+ * <pre><code>
+ * {@literal @}MapKey
+ * {@literal @}interface StringKey {
+ *   String value();
+ * }
+ *
+ * {@literal @}Module
+ * class SomeModule {
+ *   {@literal @}Provides(type = MAP)
+ *   {@literal @}StringKey("foo")
+ *   Integer provideFooValue() {
+ *     return 2;
+ *   }
+ * }
+ *
+ * class SomeInjectedType {
+ *   {@literal @}Inject
+ *   SomeInjectedType(Map<String, Integer> map) {
+ *     assert map.get("foo") == 2;
+ *   }
+ * }
+ * </code></pre>
+ *
+ * <p><b>Note:</b> Until <a href=http://github.com/google/dagger/issues/144>issue 144</a> is fixed,
+ * if {@code unwrapValue} is true, the annotation's single element must be a {@code String} or
+ * enumerated type.
+ *
+ * <h2>Annotations as keys</h2>
+ *
+ * <p>If {@link #unwrapValue} is false, then the annotation itself is used as the map key. For
+ * example, to add an entry to a {@code Map<MyMapKey, Integer>} map:
  *
  * <pre><code>
- *&#64;MapKey(unwrapValue = true)
- *&#64;Retention(RUNTIME)
- *public &#64;interface StringKey {
- *String value();
- *}
- *</code></pre>
- *
- * if {@code unwrapValue} is false, then the whole annotation will be the key
- * type for the map and annotation instances will be the keys. If
- * {@code unwrapValue} is true, the value() type of key type annotation will be
- * the key type for injected map and the value instances will be the keys.
+ * {@literal @}MapKey(unwrapValue = false)
+ * {@literal @}interface MyMapKey {
+ *   String someString();
+ *   MyEnum someEnum();
+ * }
+ *
+ * {@literal @}Module
+ * class SomeModule {
+ *   {@literal @}Provides(type = MAP)
+ *   {@literal @}MyMapKey(someString = "foo", someEnum = BAR)
+ *   Integer provideFooBarValue() {
+ *     return 2;
+ *   }
+ * }
+ *
+ * class SomeInjectedType {
+ *   {@literal @}Inject
+ *   SomeInjectedType(Map<MyMapKey, Integer> map) {
+ *     assert map.get(new MyMapKeyImpl("foo", MyEnum.BAR)) == 2;
+ *   }
+ * }
+ * </code></pre>
+ *
+ * <p>(Note that there must be a class {@code MyMapKeyImpl} that implements {@code MyMapKey} in
+ * order to call {@link Map#get()} on the provided map.)
  */
 @Documented
 @Target(ANNOTATION_TYPE)
@@ -51,10 +101,11 @@
 @Beta
 public @interface MapKey {
   /**
-   * if {@code unwrapValue} is false, then the whole annotation will be the type and annotation
-   * instances will be the keys. If {@code unwrapValue} is true, the value() type of key type
-   * annotation will be the key type for injected map and the value instances will be the keys.
-   * Currently only support {@code unwrapValue} to be true.
+   * True to use the value of the single element of the annotated annotation as the map key; false
+   * to use the annotation instance as the map key.
+   *
+   * <p>Until <a href=http://github.com/google/dagger/issues/144>issue 144</a> is fixed, if true
+   * the single element must be a {@code String} or an enumerated type.
    */
   boolean unwrapValue() default true;
 }
diff --git a/core/src/main/java/dagger/Subcomponent.java b/core/src/main/java/dagger/Subcomponent.java
index 1c8799515..0ef47011f 100644
--- a/core/src/main/java/dagger/Subcomponent.java
+++ b/core/src/main/java/dagger/Subcomponent.java
@@ -38,4 +38,14 @@
    * here.
    */
   Class<?>[] modules() default {};
+  
+  /**
+   * A builder for a subcomponent.  This follows all the rules of {@link Component.Builder}, except
+   * it must appear in classes annotated with {@link Subcomponent} instead of {@code Component}.
+   * Components can have methods that return a {@link Subcomponent.Builder}-annotated type,
+   * allowing the user to set modules on the subcomponent using their defined API.
+   */
+  @Target(TYPE)
+  @Documented
+  @interface Builder {}
 }
diff --git a/core/src/main/java/dagger/internal/Collections.java b/core/src/main/java/dagger/internal/Collections.java
index a43ab2d01..55f26ebab 100644
--- a/core/src/main/java/dagger/internal/Collections.java
+++ b/core/src/main/java/dagger/internal/Collections.java
@@ -19,32 +19,40 @@
 import java.util.LinkedHashSet;
 
 final class Collections {
+  /**
+   * The maximum value for a signed 32-bit integer that is equal to a power of 2.
+   */
+  private static final int MAX_POWER_OF_TWO = 1 << (Integer.SIZE - 2);
+
   private Collections() {
   }
 
   /**
    * Creates a {@link LinkedHashSet} instance, with a high enough "initial capacity" that it
-   * <em>should</em> hold {@code expectedSize} elements without growth. The load factor is set at
-   * {@code 1f} under the assumption this will be filled and wrapped in an unmodifiable wrapper.
+   * <em>should</em> hold {@code expectedSize} elements without growth.
    */
   static <E> LinkedHashSet<E> newLinkedHashSetWithExpectedSize(int expectedSize) {
-    return new LinkedHashSet<E>(calculateInitialCapacity(expectedSize), 1f);
+    return new LinkedHashSet<E>(calculateInitialCapacity(expectedSize));
   }
 
   /**
    * Creates a {@link LinkedHashMap} instance, with a high enough "initial capacity" that it
-   * <em>should</em> hold {@code expectedSize} elements without growth. The load factor is set at
-   * {@code 1f} under the assumption this will be filled and wrapped in an unmodifiable wrapper.
+   * <em>should</em> hold {@code expectedSize} elements without growth.
    */
   static <K, V> LinkedHashMap<K, V> newLinkedHashMapWithExpectedSize(int expectedSize) {
-    return new LinkedHashMap<K, V>(calculateInitialCapacity(expectedSize), 1f);
+    return new LinkedHashMap<K, V>(calculateInitialCapacity(expectedSize));
   }
 
   private static int calculateInitialCapacity(int expectedSize) {
-    return (expectedSize < 3)
-        ? expectedSize + 1
-        : (expectedSize < (1 << (Integer.SIZE - 2)))
-            ? expectedSize + expectedSize / 3
-            : Integer.MAX_VALUE;
+    if (expectedSize < 3) {
+      return expectedSize + 1;
+    }
+    if (expectedSize < MAX_POWER_OF_TWO) {
+      // This is the calculation used in JDK8 to resize when a putAll
+      // happens; it seems to be the most conservative calculation we
+      // can make.  0.75 is the default load factor.
+      return (int) (expectedSize / 0.75F + 1.0F);
+    }
+    return Integer.MAX_VALUE; // any large value
   }
 }
diff --git a/core/src/main/java/dagger/internal/SetFactory.java b/core/src/main/java/dagger/internal/SetFactory.java
index ecc43cb58..9b73e79db 100644
--- a/core/src/main/java/dagger/internal/SetFactory.java
+++ b/core/src/main/java/dagger/internal/SetFactory.java
@@ -16,6 +16,8 @@
 package dagger.internal;
 
 import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 import javax.inject.Provider;
@@ -33,31 +35,50 @@
  */
 public final class SetFactory<T> implements Factory<Set<T>> {
   /**
-   * Returns a new factory that creates {@link Set} instances that from the union of the given
-   * {@link Provider} instances.
+   * A message for NPEs that trigger on bad argument lists.
    */
-  public static <T> Factory<Set<T>> create(Provider<Set<T>> first,
-      @SuppressWarnings("unchecked") Provider<Set<T>>... rest) {
-    if (first == null) {
-      throw new NullPointerException();
-    }
-    if (rest == null) {
-      throw new NullPointerException();
-    }
-    Set<Provider<Set<T>>> contributingProviders = newLinkedHashSetWithExpectedSize(1 + rest.length);
-    contributingProviders.add(first);
-    for (Provider<Set<T>> provider : rest) {
-      if (provider == null) {
-        throw new NullPointerException();
-      }
-      contributingProviders.add(provider);
-    }
+  private static final String ARGUMENTS_MUST_BE_NON_NULL =
+      "SetFactory.create() requires its arguments to be non-null";
+
+  /**
+   * Returns the supplied factory.  If there's just one factory, there's no need to wrap it or its
+   * result.
+   */
+  public static <T> Factory<Set<T>> create(Factory<Set<T>> factory) {
+    assert factory != null : ARGUMENTS_MUST_BE_NON_NULL;
+    return factory;
+  }
+  
+  /**
+   * Returns a new factory that creates {@link Set} instances that form the union of the given
+   * {@link Provider} instances.  Callers must not modify the providers array after invoking this
+   * method; no copy is made.
+   */
+  public static <T> Factory<Set<T>> create(
+      @SuppressWarnings("unchecked") Provider<Set<T>>... providers) {
+    assert providers != null : ARGUMENTS_MUST_BE_NON_NULL;
+
+    List<Provider<Set<T>>> contributingProviders = Arrays.asList(providers);
+
+    assert !contributingProviders.contains(null)
+        : "Codegen error?  Null within provider list.";
+    assert !hasDuplicates(contributingProviders)
+        : "Codegen error?  Duplicates in the provider list";
+
     return new SetFactory<T>(contributingProviders);
   }
 
-  private final Set<Provider<Set<T>>> contributingProviders;
+  /**
+   * Returns true if at least one pair of items in (@code original) are equals.
+   */
+  private static boolean hasDuplicates(List<? extends Object> original) {
+    Set<Object> asSet = new HashSet<Object>(original);
+    return original.size() != asSet.size();
+  }
+
+  private final List<Provider<Set<T>>> contributingProviders;
 
-  private SetFactory(Set<Provider<Set<T>>> contributingProviders) {
+  private SetFactory(List<Provider<Set<T>>> contributingProviders) {
     this.contributingProviders = contributingProviders;
   }
 
@@ -70,21 +91,26 @@ private SetFactory(Set<Provider<Set<T>>> contributingProviders) {
    */
   @Override
   public Set<T> get() {
+    int size = 0;
+
+    // Profiling revealed that this method was a CPU-consuming hotspot in some applications, so
+    // these loops were changed to use c-style for.  Versus enhanced for-each loops, C-style for is 
+    // faster for ArrayLists, at least through Java 8.
+
     List<Set<T>> providedSets = new ArrayList<Set<T>>(contributingProviders.size());
-    for (Provider<Set<T>> provider : contributingProviders) {
+    for (int i = 0, c = contributingProviders.size(); i < c; i++) {
+      Provider<Set<T>> provider = contributingProviders.get(i);
       Set<T> providedSet = provider.get();
       if (providedSet == null) {
         throw new NullPointerException(provider + " returned null");
       }
       providedSets.add(providedSet);
-    }
-    int size = 0;
-    for (Set<T> providedSet : providedSets) {
       size += providedSet.size();
     }
+
     Set<T> result = newLinkedHashSetWithExpectedSize(size);
-    for (Set<T> s : providedSets) {
-      for (T element : s) {
+    for (int i = 0, c = providedSets.size(); i < c; i++) {
+      for (T element : providedSets.get(i)) {
         if (element == null) {
           throw new NullPointerException("a null element was provided");
         }
diff --git a/core/src/test/java/dagger/internal/SetFactoryTest.java b/core/src/test/java/dagger/internal/SetFactoryTest.java
index fcd6f6efb..04b982281 100644
--- a/core/src/test/java/dagger/internal/SetFactoryTest.java
+++ b/core/src/test/java/dagger/internal/SetFactoryTest.java
@@ -37,34 +37,39 @@
   @Rule public ExpectedException thrown = ExpectedException.none();
 
   @Test
-  public void nullFirstProvider() {
-    thrown.expect(NullPointerException.class);
-    SetFactory.create(null);
-  }
-
-  @Test
-  public void nullRest() {
+  public void providerReturnsNullSet() {
+    Factory<Set<Integer>> factory = SetFactory.create(new Provider<Set<Integer>>() {
+      @Override
+      public Set<Integer> get() {
+        return null;
+      }
+    }, incrementingIntegerProvider(0));
     thrown.expect(NullPointerException.class);
-    SetFactory.create(incrementingIntegerProvider(1),
-        (Provider<Set<Integer>>[]) null);
+    factory.get();
   }
 
   @Test
-  public void nullProviderInRest() {
+  public void providerReturnsNullSet_single() {
+    Factory<Set<Integer>> factory = SetFactory.create(new Provider<Set<Integer>>() {
+      @Override
+      public Set<Integer> get() {
+        return null;
+      }
+    });
     thrown.expect(NullPointerException.class);
-    SetFactory.create(
-        incrementingIntegerProvider(1),
-        incrementingIntegerProvider(2),
-        null,
-        incrementingIntegerProvider(3));
+    factory.get();
   }
 
   @Test
-  public void providerReturnsNullSet() {
+  public void providerReturnsSetWithNullElement() {
     Factory<Set<Integer>> factory = SetFactory.create(new Provider<Set<Integer>>() {
       @Override
       public Set<Integer> get() {
-        return null;
+        LinkedHashSet<Integer> result = new LinkedHashSet<Integer>();
+        result.add(1);
+        result.add(null);
+        result.add(3);
+        return result;
       }
     });
     thrown.expect(NullPointerException.class);
@@ -72,7 +77,7 @@ public void providerReturnsNullSet() {
   }
 
   @Test
-  public void providerReturnsSetWithNullElement() {
+  public void providerReturnsSetWithNullElement_single() {
     Factory<Set<Integer>> factory = SetFactory.create(new Provider<Set<Integer>>() {
       @Override
       public Set<Integer> get() {
@@ -82,7 +87,7 @@ public void providerReturnsSetWithNullElement() {
         result.add(3);
         return result;
       }
-    });
+    }, incrementingIntegerProvider(0));
     thrown.expect(NullPointerException.class);
     factory.get();
   }
diff --git a/pom.xml b/pom.xml
index e8dde626e..61458696f 100644
--- a/pom.xml
+++ b/pom.xml
@@ -54,7 +54,7 @@
     <compile-testing.version>0.7</compile-testing.version>
     <junit.version>4.11</junit.version>
     <mockito.version>1.9.5</mockito.version>
-    <truth.version>0.25</truth.version>
+    <truth.version>0.26</truth.version>
   </properties>
 
   <scm>
diff --git a/producers/src/main/java/dagger/producers/Produced.java b/producers/src/main/java/dagger/producers/Produced.java
index 9019aa657..3fbbee24c 100644
--- a/producers/src/main/java/dagger/producers/Produced.java
+++ b/producers/src/main/java/dagger/producers/Produced.java
@@ -24,16 +24,17 @@
  * injected, you can also inject {@code Produced<T>}, which enables handling of any exceptions that
  * were thrown during the production of {@code T}.
  *
- * <p>For example: <pre>   {@code
- *
- *   @Produces Html getResponse(UserInfo criticalInfo, Produced<ExtraInfo> noncriticalInfo) {
+ * <p>For example: <pre><code>
+ *   {@literal @}Produces Html getResponse(
+ *       UserInfo criticalInfo, {@literal Produced<ExtraInfo>} noncriticalInfo) {
  *     try {
  *       return new Html(criticalInfo, noncriticalInfo.get());
  *     } catch (ExecutionException e) {
  *       logger.warning(e, "Noncritical info");
  *       return new Html(criticalInfo);
  *     }
- *   }}</pre>
+ *   }
+ * </code></pre>
  *
  * @author Jesse Beder
  */
diff --git a/producers/src/main/java/dagger/producers/Producer.java b/producers/src/main/java/dagger/producers/Producer.java
index 5aeb4a03d..eb159bbf6 100644
--- a/producers/src/main/java/dagger/producers/Producer.java
+++ b/producers/src/main/java/dagger/producers/Producer.java
@@ -24,66 +24,68 @@
  * produces the {@code T} until {@link #get} is called.
  *
  * <p>For example, you might inject {@code Producer} to lazily choose between several different
- * implementations of some type: <pre>   {@code
- *
- *   @Produces ListenableFuture<Heater> getHeater(
+ * implementations of some type: <pre><code>
+ *   {@literal @Produces ListenableFuture<Heater>} getHeater(
  *       HeaterFlag flag,
- *       @Electric Producer<Heater> electricHeater,
- *       @Gas Producer<Heater> gasHeater) {
+ *       {@literal @Electric Producer<Heater>} electricHeater,
+ *       {@literal @Gas Producer<Heater>} gasHeater) {
  *     return flag.useElectricHeater() ? electricHeater.get() : gasHeater.get();
- *   }}</pre>
+ *   }
+ * </code></pre>
  *
  * <p>Here is a complete example that demonstrates how calling {@code get()} will cause each
- * method to be executed: <pre>   {@code
+ * method to be executed: <pre><code>
  *
- *   @ProducerModule
+ *   {@literal @}ProducerModule
  *   final class MyModule {
- *     @Produces ListenableFuture<A> a() {
+ *     {@literal @Produces ListenableFuture<A>} a() {
  *       System.out.println("a");
  *       return Futures.immediateFuture(new A());
  *     }
  *
- *     @Produces ListenableFuture<B> b(A a) {
+ *     {@literal @Produces ListenableFuture<B>} b(A a) {
  *       System.out.println("b");
  *       return Futures.immediateFuture(new B(a));
  *     }
  *
- *     @Produces ListenableFuture<C> c(B b) {
+ *     {@literal @Produces ListenableFuture<C>} c(B b) {
  *       System.out.println("c");
  *       return Futures.immediateFuture(new C(b));
  *     }
  *
- *     @Produces @Delayed ListenableFuture<C> delayedC(A a, Producer<C> c) {
+ *     {@literal @Produces @Delayed ListenableFuture<C>} delayedC(A a, {@literal Producer<C>} c) {
  *       System.out.println("delayed c");
  *       return c.get();
  *     }
  *   }
  *
- *   @ProductionComponent(modules = MyModule.class)
+ *   {@literal @}ProductionComponent(modules = MyModule.class)
  *   interface MyComponent {
- *     @Delayed ListenableFuture<C> delayedC();
- *   }}</pre>
+ *     {@literal @Delayed ListenableFuture<C>} delayedC();
+ *   }
+ * </code></pre>
  * Suppose we instantiate the generated implementation of this component and call
- * {@code delayedC()}: <pre>   {@code
- *
+ * {@code delayedC()}: <pre><code>
  *   MyComponent component = DaggerMyComponent
  *       .builder()
  *       .executor(MoreExecutors.directExecutor())
  *       .build();
  *   System.out.println("Constructed component");
- *   ListenableFuture<C> cFuture = component.delayedC();
+ *   {@literal ListenableFuture<C>} cFuture = component.delayedC();
  *   System.out.println("Retrieved future");
  *   C c = cFuture.get();
- *   System.out.println("Retrieved c");}</pre>
+ *   System.out.println("Retrieved c");
+ * </code></pre>
  * Here, we're using {@code MoreExecutors.directExecutor} in order to illustrate how each call
- * directly causes code to execute. The above code will print: <pre>   {@code
+ * directly causes code to execute. The above code will print: <pre><code>
  *   Constructed component
  *   a
  *   delayed c
  *   b
  *   c
  *   Retrieved future
- *   Retrieved c}</pre>
+ *   Retrieved c
+ * </code></pre>
  *
  * @author Jesse Beder
  */
diff --git a/producers/src/main/java/dagger/producers/ProductionComponent.java b/producers/src/main/java/dagger/producers/ProductionComponent.java
index e4fe125ba..6aa9ea8f0 100644
--- a/producers/src/main/java/dagger/producers/ProductionComponent.java
+++ b/producers/src/main/java/dagger/producers/ProductionComponent.java
@@ -45,11 +45,11 @@
  * Production methods have no arguments and return either a {@link ListenableFuture} or
  * {@link Producer} of a type that is {@link Inject injected}, {@link Provides provided}, or
  * {@link Produces produced}. Each may have a {@link Qualifier} annotation as well. The following
- * are all valid production method declarations: <pre>   {@code
- *
+ * are all valid production method declarations: <pre><code>
  *   ListenableFuture<SomeType> getSomeType();
- *   Producer<Set<SomeType>> getSomeTypes();
- *   @Response ListenableFuture<Html> getResponse();}</pre>
+ *   {@literal Producer<Set<SomeType>>} getSomeTypes();
+ *   {@literal @Response ListenableFuture<Html>} getResponse();
+ * </code></pre>
  *
  * <h2>Exceptions</h2>
  *
