diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/DepComponent.java b/compiler/src/it/functional-tests/src/main/java/test/builder/DepComponent.java
new file mode 100644
index 000000000..93fd59def
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/DepComponent.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.builder;
+
+import dagger.Component;
+
+@Component
+interface DepComponent {
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/DoubleModule.java b/compiler/src/it/functional-tests/src/main/java/test/builder/DoubleModule.java
new file mode 100644
index 000000000..2dec4a7a2
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/DoubleModule.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.builder;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+class DoubleModule {
+  @Provides
+  double d() {
+    return 4.2d;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/FloatModule.java b/compiler/src/it/functional-tests/src/main/java/test/builder/FloatModule.java
new file mode 100644
index 000000000..309e7ee98
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/FloatModule.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.builder;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+class FloatModule {  
+  @Provides
+  float f() {
+    return 5.5f;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/IntModuleIncludingDoubleAndFloat.java b/compiler/src/it/functional-tests/src/main/java/test/builder/IntModuleIncludingDoubleAndFloat.java
new file mode 100644
index 000000000..5e3a92827
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/IntModuleIncludingDoubleAndFloat.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.builder;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module(includes = { DoubleModule.class, FloatModule.class })
+class IntModuleIncludingDoubleAndFloat {
+  final int integer;
+
+  IntModuleIncludingDoubleAndFloat(int integer) {
+    this.integer = integer;
+  }
+  
+  @Provides
+  int integer() {
+    return integer;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/LongModule.java b/compiler/src/it/functional-tests/src/main/java/test/builder/LongModule.java
new file mode 100644
index 000000000..c16c9c79f
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/LongModule.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.builder;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+class LongModule {  
+  @Provides
+  long l() {
+    return 6L;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/StringModule.java b/compiler/src/it/functional-tests/src/main/java/test/builder/StringModule.java
new file mode 100644
index 000000000..3b979a5ab
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/StringModule.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.builder;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+class StringModule {
+  final String string;
+
+  StringModule(String string) {
+    this.string = string;
+  }
+  
+  @Provides
+  String string() {
+    return string;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/TestComponentWithBuilderAbstractClass.java b/compiler/src/it/functional-tests/src/main/java/test/builder/TestComponentWithBuilderAbstractClass.java
new file mode 100644
index 000000000..5eef53fe5
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/TestComponentWithBuilderAbstractClass.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.builder;
+
+import dagger.Component;
+
+@Component(
+    modules = {StringModule.class, IntModuleIncludingDoubleAndFloat.class, LongModule.class},
+    dependencies = DepComponent.class)
+abstract class TestComponentWithBuilderAbstractClass {
+  
+  static Builder builder() {
+    return DaggerTestComponentWithBuilderAbstractClass.builder();
+  }
+  
+  abstract String s();
+  abstract int i();
+  abstract long l();
+  abstract float f();
+  abstract double d();
+  
+
+  static abstract class SharedBuilder {
+    // Make sure we use the overriding signature.
+    abstract Object build();
+    
+    Object stringModule(@SuppressWarnings("unused") StringModule stringModule) {
+      return null;
+    } 
+
+    SharedBuilder ignoredLongModule(@SuppressWarnings("unused") LongModule longModule) {
+      return null;
+    }
+    
+  }
+  
+  @Component.Builder
+  static abstract class Builder extends SharedBuilder {
+    @Override abstract TestComponentWithBuilderAbstractClass build(); // Narrowing return type
+    @Override abstract Builder stringModule(StringModule stringModule); // Make abstract & narrow
+    abstract Builder intModule(IntModuleIncludingDoubleAndFloat intModule);
+    abstract void doubleModule(DoubleModule doubleModule); // Module w/o args
+    abstract void depComponent(DepComponent depComponent);
+
+    Builder ignoredIntModule(
+        @SuppressWarnings("unused") IntModuleIncludingDoubleAndFloat intModule) {
+      return null;
+    }    
+    
+    // Note we're missing LongModule & FloatModule -- they/re implicit
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/TestComponentWithBuilderInterface.java b/compiler/src/it/functional-tests/src/main/java/test/builder/TestComponentWithBuilderInterface.java
new file mode 100644
index 000000000..55214f836
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/TestComponentWithBuilderInterface.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.builder;
+
+import dagger.Component;
+
+@Component(
+    modules = {StringModule.class, IntModuleIncludingDoubleAndFloat.class, LongModule.class},
+    dependencies = DepComponent.class)
+interface TestComponentWithBuilderInterface {
+  String s();
+  int i();
+  long l();
+  float f();
+  double d();
+  
+  interface SharedBuilder {
+    // Make sure we use the overriding signature.
+    Object build();
+    Object stringModule(StringModule m1); 
+  }
+  
+  @Component.Builder
+  interface Builder extends SharedBuilder {
+    @Override TestComponentWithBuilderInterface build(); // Narrowing return type
+    @Override Builder stringModule(StringModule stringModule); // Narrowing return type
+    Builder intModule(IntModuleIncludingDoubleAndFloat intModule);
+    void doubleModule(DoubleModule doubleModule); // Module w/o args
+    void depComponent(DepComponent depComponent);
+    
+    // Note we're missing LongModule & FloatModule -- they/re implicit
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/TestComponentWithGenericBuilderAbstractClass.java b/compiler/src/it/functional-tests/src/main/java/test/builder/TestComponentWithGenericBuilderAbstractClass.java
new file mode 100644
index 000000000..8032185b2
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/TestComponentWithGenericBuilderAbstractClass.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.builder;
+
+import dagger.Component;
+
+@Component(
+    modules = {StringModule.class, IntModuleIncludingDoubleAndFloat.class, LongModule.class},
+    dependencies = DepComponent.class)
+interface TestComponentWithGenericBuilderAbstractClass {
+  String s();
+  int i();
+  long l();
+  float f();
+  double d();
+  
+  static abstract class SharedBuilder<B, C, M1, M2> {
+    abstract C build(); // Test resolving return type of build()
+    abstract B setM1(M1 m1); // Test resolving return type & param of setter
+    abstract SharedBuilder<B, C, M1, M2> setM2(M2 m2); // Test being overridden
+    abstract void doubleModule(DoubleModule doubleModule);  // Test being overridden
+    abstract SharedBuilder<B, C, M1, M2> depComponent(FloatModule floatModule); // Test return type
+  }
+  
+  @Component.Builder
+  static abstract class Builder extends SharedBuilder<Builder,
+      TestComponentWithGenericBuilderAbstractClass, StringModule,
+      IntModuleIncludingDoubleAndFloat> {
+    @Override abstract Builder setM2(IntModuleIncludingDoubleAndFloat m2); // Test covariant overrides
+    @Override abstract void doubleModule(DoubleModule module3); // Test simple overrides allowed    
+    abstract void depComponent(DepComponent depComponent);
+    
+    // Note we're missing LongModule & FloatModule -- they're implicit
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/TestComponentWithGenericBuilderInterface.java b/compiler/src/it/functional-tests/src/main/java/test/builder/TestComponentWithGenericBuilderInterface.java
new file mode 100644
index 000000000..f63e3ec90
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/TestComponentWithGenericBuilderInterface.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.builder;
+
+import dagger.Component;
+
+@Component(
+    modules = {StringModule.class, IntModuleIncludingDoubleAndFloat.class, LongModule.class},
+    dependencies = DepComponent.class)
+interface TestComponentWithGenericBuilderInterface {
+  String s();
+  int i();
+  long l();
+  float f();
+  double d();
+  
+  interface SharedBuilder<B, C, M1, M2> {
+    C build(); // Test resolving return type of build()
+    B setM1(M1 m1); // Test resolving return type & param of setter
+    SharedBuilder<B, C, M1, M2> setM2(M2 m2); // Test being overridden
+    void doubleModule(DoubleModule doubleModule);  // Test being overridden
+    SharedBuilder<B, C, M1, M2> set(FloatModule floatModule); // Test return type is supertype.
+  }
+  
+  @Component.Builder
+  interface Builder extends SharedBuilder<Builder, TestComponentWithGenericBuilderInterface,
+      StringModule, IntModuleIncludingDoubleAndFloat> {
+    @Override Builder setM2(IntModuleIncludingDoubleAndFloat m2); // Test covariant overrides allowed
+    @Override void doubleModule(DoubleModule module3); // Test simple overrides allowed    
+    void depComponent(DepComponent depComponent);
+    
+    // Note we're missing M5 -- that's implicit.
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/builder/BuilderTest.java b/compiler/src/it/functional-tests/src/test/java/test/builder/BuilderTest.java
new file mode 100644
index 000000000..eb2abd66c
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/test/java/test/builder/BuilderTest.java
@@ -0,0 +1,124 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.builder;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+@RunWith(JUnit4.class)
+public class BuilderTest {
+
+  @Test public void testInterfaceBuilder() {
+    TestComponentWithBuilderInterface.Builder builder =
+        DaggerTestComponentWithBuilderInterface.builder();
+
+    // Make sure things fail if we don't set our required modules.
+    try {
+      builder.build();
+      fail();
+    } catch(IllegalStateException expected) {}
+    
+    builder.intModule(new IntModuleIncludingDoubleAndFloat(1))
+        .stringModule(new StringModule("sam"))
+        .depComponent(new DepComponent() {});
+    builder.doubleModule(new DoubleModule());
+    // Don't set other modules -- make sure it works.
+    
+    TestComponentWithBuilderInterface component = builder.build();
+    assertThat(component.s()).isEqualTo("sam");
+    assertThat(component.i()).isEqualTo(1);
+    assertThat(component.d()).isWithin(0).of(4.2d);
+    assertThat(component.f()).isEqualTo(5.5f);
+    assertThat(component.l()).isEqualTo(6L);
+  }
+
+  @Test public void testAbstractClassBuilder() {
+    TestComponentWithBuilderAbstractClass.Builder builder =
+        TestComponentWithBuilderAbstractClass.builder();
+
+    // Make sure things fail if we don't set our required modules.
+    try {
+      builder.build();
+      fail();
+    } catch(IllegalStateException expected) {}
+    
+    builder.intModule(new IntModuleIncludingDoubleAndFloat(1))
+        .stringModule(new StringModule("sam"))
+        .depComponent(new DepComponent() {});
+    builder.doubleModule(new DoubleModule());
+    // Don't set other modules -- make sure it works.
+    
+    TestComponentWithBuilderAbstractClass component = builder.build();
+    assertThat(component.s()).isEqualTo("sam");
+    assertThat(component.i()).isEqualTo(1);
+    assertThat(component.d()).isWithin(0).of(4.2d);
+    assertThat(component.f()).isEqualTo(5.5f);
+    assertThat(component.l()).isEqualTo(6L);
+  }
+
+  @Test public void testInterfaceGenericBuilder() {
+    TestComponentWithGenericBuilderInterface.Builder builder =
+        DaggerTestComponentWithGenericBuilderInterface.builder();
+
+    // Make sure things fail if we don't set our required modules.
+    try {
+      builder.build();
+      fail();
+    } catch(IllegalStateException expected) {}
+    
+    builder.setM2(new IntModuleIncludingDoubleAndFloat(1))
+        .setM1(new StringModule("sam"))
+        .depComponent(new DepComponent() {});
+    builder.doubleModule(new DoubleModule());
+    // Don't set other modules -- make sure it works.
+    
+    TestComponentWithGenericBuilderInterface component = builder.build();
+    assertThat(component.s()).isEqualTo("sam");
+    assertThat(component.i()).isEqualTo(1);
+    assertThat(component.d()).isWithin(0).of(4.2d);
+    assertThat(component.f()).isEqualTo(5.5f);
+    assertThat(component.l()).isEqualTo(6L);
+  }
+
+  @Test public void testAbstractClassGenericBuilder() {
+    TestComponentWithGenericBuilderAbstractClass.Builder builder =
+        DaggerTestComponentWithGenericBuilderAbstractClass.builder();
+
+    // Make sure things fail if we don't set our required modules.
+    try {
+      builder.build();
+      fail();
+    } catch(IllegalStateException expected) {}
+    
+    builder.setM2(new IntModuleIncludingDoubleAndFloat(1))
+        .setM1(new StringModule("sam"))
+        .depComponent(new DepComponent() {});
+    builder.doubleModule(new DoubleModule());
+    // Don't set other modules -- make sure it works.
+    
+    TestComponentWithGenericBuilderAbstractClass component = builder.build();
+    assertThat(component.s()).isEqualTo("sam");
+    assertThat(component.i()).isEqualTo(1);
+    assertThat(component.d()).isWithin(0).of(4.2d);
+    assertThat(component.f()).isEqualTo(5.5f);
+    assertThat(component.l()).isEqualTo(6L);
+  }
+  
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 47d51015f..24b5ba27c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -31,18 +31,22 @@
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
+import com.google.common.collect.Maps;
 import com.google.common.collect.Ordering;
 import com.google.common.collect.Sets;
 import dagger.Component;
 import dagger.internal.codegen.BindingGraph.ResolvedBindings;
+import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.internal.codegen.ContributionBinding.BindingType;
 import dagger.internal.codegen.ValidationReport.Builder;
 import dagger.internal.codegen.writer.TypeNames;
 import java.util.ArrayDeque;
+import java.util.Collection;
 import java.util.Deque;
 import java.util.Formatter;
 import java.util.Iterator;
+import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Set;
 import javax.inject.Singleton;
@@ -61,6 +65,8 @@
 import static com.google.auto.common.MoreTypes.isTypeOf;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
+import static dagger.internal.codegen.ErrorMessages.BUILDER_EXTRA_SETTERS;
+import static dagger.internal.codegen.ErrorMessages.BUILDER_MISSING_SETTERS;
 import static dagger.internal.codegen.ErrorMessages.INDENT;
 import static dagger.internal.codegen.ErrorMessages.MEMBERS_INJECTION_WITH_UNBOUNDED_TYPE;
 import static dagger.internal.codegen.ErrorMessages.NULLABLE_TO_NON_NULLABLE;
@@ -117,6 +123,7 @@
 
     validateComponentScope(subject, reportBuilder, resolvedBindings);
     validateDependencyScopes(subject, reportBuilder);
+    validateBuilders(subject, reportBuilder);
 
     for (ComponentMethodDescriptor componentMethod :
         subject.componentDescriptor().componentMethods()) {
@@ -436,6 +443,48 @@ private void validateDependencyScopes(BindingGraph subject,
     }
   }
 
+  private void validateBuilders(BindingGraph subject, Builder<BindingGraph> reportBuilder) {
+    ComponentDescriptor componentDesc = subject.componentDescriptor();
+    if (!componentDesc.builderSpec().isPresent()) {
+      // If no builder, nothing to validate.
+      return;
+    }
+
+    Set<TypeElement> allDependents =
+        Sets.union(
+            Sets.union(
+                subject.transitiveModules().keySet(),
+                componentDesc.dependencies()),
+            componentDesc.executorDependency().asSet());
+    Set<TypeElement> requiredDependents =
+        Sets.filter(allDependents, new Predicate<TypeElement>() {
+          @Override public boolean apply(TypeElement input) {
+            return !Util.componentCanMakeNewInstances(input);
+          }
+        });
+    final BuilderSpec spec = componentDesc.builderSpec().get();
+    Map<TypeElement, ExecutableElement> allSetters = spec.methodMap();
+
+    Set<TypeElement> extraSetters = Sets.difference(allSetters.keySet(), allDependents);
+    if (!extraSetters.isEmpty()) {
+      Collection<ExecutableElement> excessMethods =
+          Maps.filterKeys(allSetters, Predicates.in(extraSetters)).values();
+      Iterable<String> formatted = FluentIterable.from(excessMethods).transform(
+          new Function<ExecutableElement, String>() {
+            @Override public String apply(ExecutableElement input) {
+              return methodSignatureFormatter.format(input,
+                  Optional.of(MoreTypes.asDeclared(spec.builderDefinitionType().asType())));
+            }});
+      reportBuilder.addItem(String.format(BUILDER_EXTRA_SETTERS, formatted), spec.builderDefinitionType());
+    }
+
+    Set<TypeElement> missingSetters = Sets.difference(requiredDependents, allSetters.keySet());
+    if (!missingSetters.isEmpty()) {
+      reportBuilder.addItem(String.format(BUILDER_MISSING_SETTERS, missingSetters),
+          spec.builderDefinitionType());
+    }
+  }
+
   /**
    * Append and format a list of indented component types (with their scope annotations)
    */
diff --git a/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java b/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java
new file mode 100644
index 000000000..93367bafb
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java
@@ -0,0 +1,216 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreTypes;
+import com.google.common.base.Equivalence;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.LinkedHashMultimap;
+import com.google.common.collect.Multimap;
+import dagger.Component;
+import java.util.Collection;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.ExecutableType;
+import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.ElementFilter;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.ErrorMessages.BUILDER_BUILD_MUST_RETURN_COMPONENT_TYPE;
+import static dagger.internal.codegen.ErrorMessages.BUILDER_CXTOR_ONLY_ONE_AND_NO_ARGS;
+import static dagger.internal.codegen.ErrorMessages.BUILDER_GENERICS;
+import static dagger.internal.codegen.ErrorMessages.BUILDER_INHERITED_BUILD_MUST_RETURN_COMPONENT_TYPE;
+import static dagger.internal.codegen.ErrorMessages.BUILDER_INHERITED_METHODS_MAY_NOT_HAVE_TYPE_PARAMETERS;
+import static dagger.internal.codegen.ErrorMessages.BUILDER_INHERITED_METHODS_MUST_RETURN_VOID_OR_BUILDER;
+import static dagger.internal.codegen.ErrorMessages.BUILDER_INHERITED_METHOD_MUST_TAKE_ONE_ARG;
+import static dagger.internal.codegen.ErrorMessages.BUILDER_INHERITED_TWO_BUILD_METHODS;
+import static dagger.internal.codegen.ErrorMessages.BUILDER_METHODS_MAY_NOT_HAVE_TYPE_PARAMETERS;
+import static dagger.internal.codegen.ErrorMessages.BUILDER_METHODS_MUST_RETURN_VOID_OR_BUILDER;
+import static dagger.internal.codegen.ErrorMessages.BUILDER_METHOD_MUST_TAKE_ONE_ARG;
+import static dagger.internal.codegen.ErrorMessages.BUILDER_MISSING_BUILD_METHOD;
+import static dagger.internal.codegen.ErrorMessages.BUILDER_MUST_BE_ABSTRACT;
+import static dagger.internal.codegen.ErrorMessages.BUILDER_MUST_BE_CLASS_OR_INTERFACE;
+import static dagger.internal.codegen.ErrorMessages.BUILDER_MUST_BE_IN_COMPONENT;
+import static dagger.internal.codegen.ErrorMessages.BUILDER_MUST_BE_STATIC;
+import static dagger.internal.codegen.ErrorMessages.BUILDER_PRIVATE;
+import static dagger.internal.codegen.ErrorMessages.BUILDER_TWO_BUILD_METHODS;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.STATIC;
+
+/** 
+ * Validates {@link dagger.Component.Builder} annotations.
+ * 
+ * @author sameb@google.com (Sam Berlin)  
+ */
+class BuilderValidator implements Validator<TypeElement> {
+  private final Elements elements;
+  private final Types types;
+
+  BuilderValidator(Elements elements, Types types) {
+    this.elements = elements;
+    this.types = types;
+  }
+
+  @Override public ValidationReport<TypeElement> validate(TypeElement subject) {
+    ValidationReport.Builder<TypeElement> builder = ValidationReport.Builder.about(subject);
+    Component.Builder builderAnnotation = subject.getAnnotation(Component.Builder.class);
+    checkArgument(builderAnnotation != null);
+
+    Element componentElement = subject.getEnclosingElement();
+    if (!isAnnotationPresent(componentElement, Component.class)) {
+      builder.addItem(BUILDER_MUST_BE_IN_COMPONENT, subject);
+    }
+
+    switch (subject.getKind()) {
+      case CLASS:
+        List<? extends Element> allElements = subject.getEnclosedElements();
+        List<ExecutableElement> cxtors = ElementFilter.constructorsIn(allElements);
+        if (cxtors.size() != 1 || getOnlyElement(cxtors).getParameters().size() != 0) {
+          builder.addItem(BUILDER_CXTOR_ONLY_ONE_AND_NO_ARGS, subject);
+        }
+        break;
+      case INTERFACE:
+        break;
+      default:
+        // If not the correct type, exit early since the rest of the messages will be bogus.
+        builder.addItem(BUILDER_MUST_BE_CLASS_OR_INTERFACE, subject);
+        return builder.build(); 
+    }    
+
+    
+    if (!subject.getTypeParameters().isEmpty()) {
+      builder.addItem(BUILDER_GENERICS, subject);
+    }
+
+    Set<Modifier> modifiers = subject.getModifiers();
+    if (modifiers.contains(PRIVATE)) {
+      builder.addItem(BUILDER_PRIVATE, subject);
+    }
+    if (!modifiers.contains(STATIC)) {
+      builder.addItem(BUILDER_MUST_BE_STATIC, subject);
+    }
+    // Note: Must be abstract, so no need to check for final.
+    if (!modifiers.contains(ABSTRACT)) {
+      builder.addItem(BUILDER_MUST_BE_ABSTRACT, subject);
+    }
+    
+    ExecutableElement buildMethod = null;
+    Multimap<Equivalence.Wrapper<TypeMirror>, ExecutableElement> methodsPerParam =
+        LinkedHashMultimap.create();    
+    for (ExecutableElement method : Util.getUnimplementedMethods(elements, subject)) {
+      ExecutableType resolvedMethodType =
+          MoreTypes.asExecutable(types.asMemberOf(MoreTypes.asDeclared(subject.asType()), method));
+      TypeMirror returnType = resolvedMethodType.getReturnType();      
+      if (method.getParameters().size() == 0) {
+        // If this is potentially a build() method, validate it returns the correct type.
+        if (types.isSameType(returnType, componentElement.asType())) {
+          if (buildMethod != null) {
+            // If we found more than one build-like method, fail.
+            error(builder, method, BUILDER_TWO_BUILD_METHODS, BUILDER_INHERITED_TWO_BUILD_METHODS,
+                buildMethod);
+          }
+        } else {
+          error(builder, method, BUILDER_BUILD_MUST_RETURN_COMPONENT_TYPE,
+              BUILDER_INHERITED_BUILD_MUST_RETURN_COMPONENT_TYPE);
+        }
+        // We set the buildMethod regardless of the return type to reduce error spam.
+        buildMethod = method;
+      } else if (method.getParameters().size() > 1) {
+        // If this is a setter, make sure it has one arg.
+        error(builder, method, BUILDER_METHOD_MUST_TAKE_ONE_ARG,
+            BUILDER_INHERITED_METHOD_MUST_TAKE_ONE_ARG);
+      } else if (returnType.getKind() != TypeKind.VOID
+          && !types.isSubtype(subject.asType(), returnType)) {
+        // If this correctly had one arg, make sure the return types are valid.
+        error(builder, method, BUILDER_METHODS_MUST_RETURN_VOID_OR_BUILDER,
+            BUILDER_INHERITED_METHODS_MUST_RETURN_VOID_OR_BUILDER);
+      } else {
+        // If the return types are valid, record the method.
+        methodsPerParam.put(
+            MoreTypes.equivalence().<TypeMirror>wrap(
+                Iterables.getOnlyElement(resolvedMethodType.getParameterTypes())),
+            method);
+      }
+      
+      if (!method.getTypeParameters().isEmpty()) {
+        error(builder, method, BUILDER_METHODS_MAY_NOT_HAVE_TYPE_PARAMETERS,
+            BUILDER_INHERITED_METHODS_MAY_NOT_HAVE_TYPE_PARAMETERS);
+      }
+    }
+    
+    if (buildMethod == null) {
+      builder.addItem(BUILDER_MISSING_BUILD_METHOD, subject);
+    }
+    
+    // Go back through each recorded method per param type.  If we had more than one method
+    // for a given param, fail.
+    for (Map.Entry<Equivalence.Wrapper<TypeMirror>, Collection<ExecutableElement>> entry :
+        methodsPerParam.asMap().entrySet()) {
+      if (entry.getValue().size() > 1) {
+        TypeMirror type = entry.getKey().get();
+        builder.addItem(
+            String.format(ErrorMessages.BUILDER_MANY_METHODS_FOR_TYPE, type, entry.getValue()),
+            subject);
+      }
+    }
+    
+    // Note: there's more validation in BindingGraphValidator,
+    // specifically to make sure the setter methods mirror the deps.
+
+    return builder.build();
+  }
+  
+  /**
+   * Generates one of two error messages. If the method is enclosed in the subject, we target the
+   * error to the method itself. Otherwise we target the error to the subject and list the method as
+   * an argumnent. (Otherwise we have no way of knowing if the method is being compiled in this pass
+   * too, so javac might not be able to pinpoint it's line of code.)
+   */
+  /*
+   * For Component.Builder, the prototypical example would be if someone had:
+   *    libfoo: interface SharedBuilder { void badSetter(A a, B b); }
+   *    libbar: BarComponent { BarBuilder extends SharedBuilder } }
+   * ... the compiler only validates BarBuilder when compiling libbar, but it fails because
+   * of libfoo's SharedBuilder (which could have been compiled in a previous pass).
+   * So we can't point to SharedBuilder#badSetter as the subject of the BarBuilder validation
+   * failure.
+   * 
+   * This check is a little more strict than necessary -- ideally we'd check if method's enclosing
+   * class was included in this compile run.  But that's hard, and this is close enough.
+   */
+  private void error(ValidationReport.Builder<TypeElement> builder, ExecutableElement method,
+      String enclosedError, String inheritedError, Object... extraArgs) {
+    if (method.getEnclosingElement().equals(builder.getSubject())) {
+      builder.addItem(String.format(enclosedError, extraArgs), method);
+    } else {
+      Object[] newArgs = new Object[extraArgs.length + 1];
+      newArgs[0] = method;
+      System.arraycopy(extraArgs, 0, newArgs, 1, extraArgs.length);
+      builder.addItem(String.format(inheritedError, newArgs), builder.getSubject());
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index 03f759a2e..012985370 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -21,9 +21,9 @@
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
 import com.google.common.base.Optional;
+import com.google.common.base.Verify;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Lists;
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.Component;
 import dagger.Lazy;
@@ -31,22 +31,24 @@
 import dagger.Subcomponent;
 import dagger.producers.ProductionComponent;
 import java.lang.annotation.Annotation;
-import java.util.Iterator;
 import java.util.List;
+import java.util.Map;
 import java.util.concurrent.Executor;
 import javax.inject.Provider;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ExecutableType;
-import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
+import static com.google.common.base.Verify.verify;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.ConfigurationAnnotations.enclosedBuilders;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
 import static dagger.internal.codegen.ConfigurationAnnotations.isComponent;
 import static dagger.internal.codegen.InjectionAnnotations.getScopeAnnotation;
@@ -125,6 +127,10 @@
 
   abstract ImmutableSet<ComponentMethodDescriptor> componentMethods();
 
+  // TODO(gak): Consider making this non-optional and revising the
+  // interaction between the spec & generation
+  abstract Optional<BuilderSpec> builderSpec();
+
   @AutoValue
   static abstract class ComponentMethodDescriptor {
     abstract ComponentMethodKind kind();
@@ -138,6 +144,13 @@
     MEMBERS_INJECTION,
     SUBCOMPONENT,
   }
+  
+  @AutoValue
+  static abstract class BuilderSpec {    
+    abstract TypeElement builderDefinitionType();
+    abstract Map<TypeElement, ExecutableElement> methodMap();
+    abstract ExecutableElement buildMethod();
+  }
 
   static final class Factory {
     private final Elements elements;
@@ -187,7 +200,7 @@ private ComponentDescriptor create(TypeElement componentDefinitionType, Kind kin
               : Optional.<TypeElement>absent();
 
       ImmutableSet<ExecutableElement> unimplementedMethods =
-          getUnimplementedMethods(elements, componentDefinitionType);
+          Util.getUnimplementedMethods(elements, componentDefinitionType);
 
       ImmutableSet.Builder<ComponentMethodDescriptor> componentMethodsBuilder =
           ImmutableSet.builder();
@@ -204,6 +217,9 @@ private ComponentDescriptor create(TypeElement componentDefinitionType, Kind kin
                   Kind.COMPONENT));
         }
       }
+      
+      Optional<DeclaredType> builderType = Optional.fromNullable(
+          getOnlyElement(enclosedBuilders(componentDefinitionType), null));
 
       Optional<AnnotationMirror> scope = getScopeAnnotation(componentDefinitionType);
       return new AutoValue_ComponentDescriptor(
@@ -215,7 +231,8 @@ private ComponentDescriptor create(TypeElement componentDefinitionType, Kind kin
           executorDependency,
           wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), scope),
           subcomponentDescriptors.build(),
-          componentMethodsBuilder.build());
+          componentMethodsBuilder.build(),
+          createBuilderSpec(builderType));
     }
 
     private ComponentMethodDescriptor getDescriptorForComponentMethod(TypeElement componentElement,
@@ -283,6 +300,28 @@ private ComponentMethodDescriptor getDescriptorForComponentMethod(TypeElement co
 
       throw new IllegalArgumentException("not a valid component method: " + componentMethod);
     }
+
+    private Optional<BuilderSpec> createBuilderSpec(Optional<DeclaredType> builderType) {
+      if (!builderType.isPresent()) {
+        return Optional.absent();
+      }
+      TypeElement element = MoreTypes.asTypeElement(builderType.get());
+      ImmutableSet<ExecutableElement> methods = Util.getUnimplementedMethods(elements, element);
+      ImmutableMap.Builder<TypeElement, ExecutableElement> map = ImmutableMap.builder();
+      ExecutableElement buildMethod = null;
+      for (ExecutableElement method : methods) {
+        if (method.getParameters().isEmpty()) {
+          buildMethod = method;
+        } else {
+          ExecutableType resolved =
+              MoreTypes.asExecutable(types.asMemberOf(builderType.get(), method));
+          map.put(MoreTypes.asTypeElement(getOnlyElement(resolved.getParameterTypes())), method);
+        }
+      }
+      verify(buildMethod != null); // validation should have ensured this.
+      return Optional.<BuilderSpec>of(
+          new AutoValue_ComponentDescriptor_BuilderSpec(element, map.build(), buildMethod));
+    }
   }
 
   static boolean isComponentContributionMethod(Elements elements, ExecutableElement method) {
@@ -296,57 +335,4 @@ static boolean isComponentProductionMethod(Elements elements, ExecutableElement
     return isComponentContributionMethod(elements, method)
         && MoreTypes.isTypeOf(ListenableFuture.class, method.getReturnType());
   }
-
-  /*
-   * These two methods were borrowed from AutoValue and slightly modified.  TODO(gak): reconcile
-   * the two and put them in auto common
-   */
-  private static void findLocalAndInheritedMethods(Elements elements, TypeElement type,
-      List<ExecutableElement> methods) {
-    for (TypeMirror superInterface : type.getInterfaces()) {
-      findLocalAndInheritedMethods(
-          elements, MoreElements.asType(MoreTypes.asElement(superInterface)), methods);
-    }
-    if (type.getSuperclass().getKind() != TypeKind.NONE) {
-      // Visit the superclass after superinterfaces so we will always see the implementation of a
-      // method after any interfaces that declared it.
-      findLocalAndInheritedMethods(
-          elements, MoreElements.asType(MoreTypes.asElement(type.getSuperclass())), methods);
-    }
-    // Add each method of this class, and in so doing remove any inherited method it overrides.
-    // This algorithm is quadratic in the number of methods but it's hard to see how to improve
-    // that while still using Elements.overrides.
-    List<ExecutableElement> theseMethods = ElementFilter.methodsIn(type.getEnclosedElements());
-    for (ExecutableElement method : theseMethods) {
-      if (!method.getModifiers().contains(Modifier.PRIVATE)) {
-        boolean alreadySeen = false;
-        for (Iterator<ExecutableElement> methodIter = methods.iterator(); methodIter.hasNext();) {
-          ExecutableElement otherMethod = methodIter.next();
-          if (elements.overrides(method, otherMethod, type)) {
-            methodIter.remove();
-          } else if (method.getSimpleName().equals(otherMethod.getSimpleName())
-              && method.getParameters().equals(otherMethod.getParameters())) {
-            // If we inherit this method on more than one path, we don't want to add it twice.
-            alreadySeen = true;
-          }
-        }
-        if (!alreadySeen) {
-          methods.add(method);
-        }
-      }
-    }
-  }
-
-  private static ImmutableSet<ExecutableElement> getUnimplementedMethods(
-      Elements elements, TypeElement type) {
-    ImmutableSet.Builder<ExecutableElement> unimplementedMethods = ImmutableSet.builder();
-    List<ExecutableElement> methods = Lists.newArrayList();
-    findLocalAndInheritedMethods(elements, type, methods);
-    for (ExecutableElement method : methods) {
-      if (method.getModifiers().contains(Modifier.ABSTRACT)) {
-        unimplementedMethods.add(method);
-      }
-    }
-    return unimplementedMethods.build();
-  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index 3f69f1623..1f0a94e8d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -46,6 +46,7 @@
 import dagger.internal.ScopedProvider;
 import dagger.internal.SetFactory;
 import dagger.internal.codegen.BindingGraph.ResolvedBindings;
+import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.internal.codegen.ContributionBinding.BindingType;
 import dagger.internal.codegen.writer.ClassName;
@@ -85,6 +86,7 @@
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ExecutableType;
+import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementKindVisitor6;
 import javax.lang.model.util.SimpleAnnotationValueVisitor6;
@@ -238,10 +240,31 @@ Snippet getSnippetFor(ClassName usingClass) {
       BindingGraph input, ClassName componentDefinitionTypeName, ClassWriter componentWriter,
       Set<JavaWriter> proxyWriters) {
     ClassWriter builderWriter = componentWriter.addNestedClass("Builder");
-    builderWriter.addModifiers(PUBLIC, STATIC, FINAL);
+    builderWriter.addModifiers(STATIC, FINAL);
     builderWriter.addConstructor().addModifiers(PRIVATE);
+    Optional<BuilderSpec> builderSpec = input.componentDescriptor().builderSpec();
+    if (builderSpec.isPresent()) {
+      builderWriter.addModifiers(PRIVATE);
+      TypeElement builderType = builderSpec.get().builderDefinitionType();
+      switch (builderType.getKind()) {
+        case CLASS:
+          builderWriter.setSuperType(builderType);
+          break;
+        case INTERFACE:
+          builderWriter.addImplementedType(builderType);
+          break;
+        default:
+          throw new IllegalStateException("not a class or interface: " + builderType);
+      }
+    } else {
+      builderWriter.addModifiers(PUBLIC);
+    }
 
-    MethodWriter builderFactoryMethod = componentWriter.addMethod(builderWriter, "builder");
+    MethodWriter builderFactoryMethod;
+    // If the user gave us a builder API, the factory method should return that (not our subclass).
+    builderFactoryMethod = builderSpec.isPresent()
+        ? componentWriter.addMethod(builderSpec.get().builderDefinitionType().asType(), "builder")
+        : componentWriter.addMethod(builderWriter, "builder");
     builderFactoryMethod.addModifiers(PUBLIC, STATIC);
     builderFactoryMethod.body().addSnippet("return new %s();", builderWriter.name());
 
@@ -266,7 +289,18 @@ Snippet getSnippetFor(ClassName usingClass) {
     constructorWriter.addParameter(builderWriter, "builder");
     constructorWriter.body().addSnippet("assert builder != null;");
 
-    MethodWriter buildMethod = builderWriter.addMethod(componentDefinitionTypeName, "build");
+    MethodWriter buildMethod;
+    if (builderSpec.isPresent()) {
+      ExecutableElement specBuildMethod = builderSpec.get().buildMethod();
+      // Note: we don't use the specBuildMethod.getReturnType() as the return type
+      // because it might be a type variable.  We make use of covariant returns to allow
+      // us to return the component type, which will always be valid.
+      buildMethod = builderWriter.addMethod(componentDefinitionTypeName,
+          specBuildMethod.getSimpleName().toString());
+      buildMethod.annotate(Override.class);
+    } else {
+      buildMethod = builderWriter.addMethod(componentDefinitionTypeName, "build");
+    }
     buildMethod.addModifiers(PUBLIC);
 
     boolean requiresBuilder = false;
@@ -280,16 +314,6 @@ Snippet getSnippetFor(ClassName usingClass) {
       builderField.addModifiers(PRIVATE);
       componentContributionFields.put(contributionElement, MemberSelect.instanceSelect(
           componentWriter.name(), Snippet.format("builder.%s", builderField.name())));
-      MethodWriter builderMethod = builderWriter.addMethod(builderWriter, contributionName);
-      builderMethod.addModifiers(PUBLIC);
-      builderMethod.addParameter(contributionElement, contributionName);
-      builderMethod.body()
-          .addSnippet("if (%s == null) {", contributionName)
-          .addSnippet("  throw new NullPointerException(%s);",
-              StringLiteral.forValue(contributionName))
-          .addSnippet("}")
-          .addSnippet("this.%s = %s;", builderField.name(), contributionName)
-          .addSnippet("return this;");
       if (componentCanMakeNewInstances(contributionElement)) {
         buildMethod.body()
             .addSnippet("if (%s == null) {", builderField.name())
@@ -304,13 +328,50 @@ Snippet getSnippetFor(ClassName usingClass) {
                 builderField.name())
             .addSnippet("}");
       }
+      MethodWriter builderMethod;
+      boolean returnsVoid = false;
+      if (builderSpec.isPresent()) {
+        ExecutableElement method = builderSpec.get().methodMap().get(contributionElement);
+        if (method == null) { // no method in the API, nothing to write out.
+          continue;
+        }
+        // If the return type is void, we add a method with the void return type.
+        // Otherwise we use the builderWriter and take advantage of covariant returns
+        // (so that we don't have to worry about setter methods that return type variables).
+        if (method.getReturnType().getKind().equals(TypeKind.VOID)) {
+          returnsVoid = true;
+          builderMethod =
+              builderWriter.addMethod(method.getReturnType(), method.getSimpleName().toString());
+        } else {
+          builderMethod = builderWriter.addMethod(builderWriter, method.getSimpleName().toString());
+        }
+        builderMethod.annotate(Override.class);
+      } else {
+        builderMethod = builderWriter.addMethod(builderWriter, contributionName);
+      }
+      // TODO(gak): Mirror the API's visibility.
+      // (Makes no difference to the user since this class is private,
+      //  but makes generated code prettier.)
+      builderMethod.addModifiers(PUBLIC);
+      builderMethod.addParameter(contributionElement, contributionName);
+      builderMethod.body()
+          .addSnippet("if (%s == null) {", contributionName)
+          .addSnippet("  throw new NullPointerException(%s);",
+              StringLiteral.forValue(contributionName))
+          .addSnippet("}")
+          .addSnippet("this.%s = %s;", builderField.name(), contributionName);
+      if (!returnsVoid) {
+        builderMethod.body().addSnippet("return this;");
+      }
     }
 
     if (!requiresBuilder) {
       MethodWriter factoryMethod = componentWriter.addMethod(componentDefinitionTypeName, "create");
       factoryMethod.addModifiers(PUBLIC, STATIC);
       // TODO(gak): replace this with something that doesn't allocate a builder
-      factoryMethod.body().addSnippet("return builder().build();");
+      factoryMethod.body().addSnippet("return builder().%s();",
+          builderSpec.isPresent()
+              ? builderSpec.get().buildMethod().getSimpleName() : "build");
     }
 
     Map<BindingKey, MemberSelect> memberSelectSnippetsBuilder = Maps.newHashMap();
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
index b458ee322..691fe0835 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
@@ -18,10 +18,12 @@
 import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
 import com.google.auto.common.MoreElements;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Maps;
 import com.google.common.collect.SetMultimap;
 import dagger.Component;
 import dagger.internal.codegen.ComponentDescriptor.Factory;
 import java.lang.annotation.Annotation;
+import java.util.Map;
 import java.util.Set;
 import javax.annotation.processing.Messager;
 import javax.lang.model.element.Element;
@@ -36,6 +38,7 @@
 final class ComponentProcessingStep implements ProcessingStep {
   private final Messager messager;
   private final ComponentValidator componentValidator;
+  private final BuilderValidator builderValidator;
   private final BindingGraphValidator bindingGraphValidator;
   private final ComponentDescriptor.Factory componentDescriptorFactory;
   private final BindingGraph.Factory bindingGraphFactory;
@@ -44,6 +47,7 @@
   ComponentProcessingStep(
       Messager messager,
       ComponentValidator componentValidator,
+      BuilderValidator builderValidator,
       BindingGraphValidator bindingGraphValidator,
       Factory componentDescriptorFactory,
       BindingGraph.Factory bindingGraphFactory,
@@ -51,6 +55,7 @@
     this.messager = messager;
     this.componentValidator = componentValidator;
     this.bindingGraphValidator = bindingGraphValidator;
+    this.builderValidator = builderValidator;
     this.componentDescriptorFactory = componentDescriptorFactory;
     this.bindingGraphFactory = bindingGraphFactory;
     this.componentGenerator = componentGenerator;
@@ -58,19 +63,28 @@
 
   @Override
   public Set<Class<? extends Annotation>> annotations() {
-    return ImmutableSet.<Class<? extends Annotation>>of(Component.class);
+    return ImmutableSet.<Class<? extends Annotation>>of(Component.class, Component.Builder.class);
   }
 
   @Override
   public void process(SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+    Set<? extends Element> builderElements = elementsByAnnotation.get(Component.Builder.class);
+    Map<Element, ValidationReport<TypeElement>> builderReportsByComponent = Maps.newHashMap();
+    for (Element element : builderElements) {
+      ValidationReport<TypeElement> builderReport =
+          builderValidator.validate(MoreElements.asType(element));
+      builderReport.printMessagesTo(messager);
+      builderReportsByComponent.put(element.getEnclosingElement(), builderReport);
+    }
+    
     Set<? extends Element> componentElements = elementsByAnnotation.get(Component.class);
-
     for (Element element : componentElements) {
       TypeElement componentTypeElement = MoreElements.asType(element);
       ValidationReport<TypeElement> componentReport =
           componentValidator.validate(componentTypeElement);
       componentReport.printMessagesTo(messager);
-      if (componentReport.isClean()) {
+      ValidationReport<TypeElement> builderReport = builderReportsByComponent.get(element);
+      if (componentReport.isClean() && (builderReport == null || builderReport.isClean())) {
         ComponentDescriptor componentDescriptor =
             componentDescriptorFactory.forComponent(componentTypeElement);
         BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor);
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index bb9a56770..8b452b68f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -88,6 +88,7 @@ public SourceVersion getSupportedSourceVersion() {
     ProvidesMethodValidator providesMethodValidator = new ProvidesMethodValidator(elements);
     ComponentValidator componentValidator =
         new ComponentValidator(elements, types, moduleValidator);
+    BuilderValidator builderValidator = new BuilderValidator(elements, types);
     MapKeyValidator mapKeyValidator = new MapKeyValidator();
     ModuleValidator producerModuleValidator = new ModuleValidator(types, elements,
         methodSignatureFormatter, ProducerModule.class, Produces.class);
@@ -158,6 +159,7 @@ public SourceVersion getSupportedSourceVersion() {
         new ComponentProcessingStep(
             messager,
             componentValidator,
+            builderValidator,
             bindingGraphValidator,
             componentDescriptorFactory,
             bindingGraphFactory,
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
index 022275750..1d32a6cc5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
@@ -44,8 +44,10 @@
 import javax.lang.model.util.Types;
 
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
+import static dagger.internal.codegen.ConfigurationAnnotations.enclosedBuilders;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
 import static dagger.internal.codegen.ConfigurationAnnotations.getTransitiveModules;
+import static dagger.internal.codegen.ErrorMessages.BUILDER_MORE_THAN_ONE;
 import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
 import static javax.lang.model.element.ElementKind.CLASS;
 import static javax.lang.model.element.ElementKind.INTERFACE;
@@ -75,6 +77,11 @@
         && !(subject.getKind().equals(CLASS) && subject.getModifiers().contains(ABSTRACT))) {
       builder.addItem("@Component may only be applied to an interface or abstract class", subject);
     }
+    
+    ImmutableList<DeclaredType> builders = enclosedBuilders(subject);
+    if (builders.size() > 1) {
+      builder.addItem(String.format(BUILDER_MORE_THAN_ONE, builders), subject);
+    }
 
     List<? extends Element> members = elements.getAllMembers(subject);
     for (ExecutableElement method : ElementFilter.methodsIn(members)) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
index de60f4285..d533b5021 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
@@ -41,6 +41,8 @@
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
+import javax.lang.model.type.TypeVisitor;
+import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.SimpleTypeVisitor6;
 import javax.lang.model.util.Types;
@@ -151,6 +153,17 @@ static boolean isComponent(TypeElement componentDefinitionType) {
     }
     return ImmutableSet.copyOf(moduleElements);
   }
+  
+  /** Returns the enclosed elements annotated with {@link dagger.Component.Builder}. */
+  static ImmutableList<DeclaredType> enclosedBuilders(TypeElement typeElement) {
+    final ImmutableList.Builder<DeclaredType> builders = ImmutableList.builder();
+    for (TypeElement element : ElementFilter.typesIn(typeElement.getEnclosedElements())) {
+      if (MoreElements.isAnnotationPresent(element, Component.Builder.class)) {
+        builders.add(MoreTypes.asDeclared(element.asType()));
+      }
+    }
+    return builders.build();
+  }
 
   static boolean isSubcomponentType(TypeMirror type) {
     return type.accept(new SubcomponentDetector(), null).isPresent();
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index 82f19ce76..4c9e9d574 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -213,6 +213,77 @@
 
   static final String CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD =
       "Cannot return null from a non-@Nullable @Provides method";
+  
+  /** Errors for component builders. */
+  static final String BUILDER_MORE_THAN_ONE = "@Component has more than one @Component.Builder: %s";
+  
+  static final String BUILDER_CXTOR_ONLY_ONE_AND_NO_ARGS =
+      "@Component.Builder classes must have exactly one constructor,"
+      + " and it must not have any parameters";
+  
+  static final String BUILDER_GENERICS =
+      "@Component.Builder types must not have any generic types";
+  
+  static final String BUILDER_MUST_BE_IN_COMPONENT =
+      "@Component.Builder types must be nested within a @Component";
+  
+  static final String BUILDER_MUST_BE_CLASS_OR_INTERFACE =
+      "@Component.Builder types must be abstract classes or interfaces";
+  
+  static final String BUILDER_PRIVATE = "@Component.Builder types must not be private";
+  
+  static final String BUILDER_MUST_BE_STATIC = "@Component.Builder types must be static";
+  
+  static final String BUILDER_MUST_BE_ABSTRACT = "@Component.Builder types must be abstract";
+  
+  static final String BUILDER_MISSING_BUILD_METHOD =
+      "@Component.Builder types must have exactly one no-args method that returns the"
+      + " @Component type.";
+  
+  static final String BUILDER_MANY_METHODS_FOR_TYPE =
+      "@Component.Builder types must not have more than one setter method per type, but %s"
+      + " is set by %s";
+  
+  static final String BUILDER_EXTRA_SETTERS =
+      "@Component.Builder has setters for modules or components that aren't required: %s";
+  
+  static final String BUILDER_MISSING_SETTERS =
+      "@Component.Builder is missing setters for required modules or components: %s";
+  
+  static final String BUILDER_TWO_BUILD_METHODS =
+      "@Component.Builder types must have exactly one zero-arg method, and that"
+      + " method must return the @Component type. Already found: %s";
+  
+  static final String BUILDER_INHERITED_TWO_BUILD_METHODS =
+      "@Component.Builder types must have exactly one zero-arg method, and that"
+      + " method must return the @Component type. Found %s and %s";
+  
+  static final String BUILDER_BUILD_MUST_RETURN_COMPONENT_TYPE =
+      "@Component.Builder methods that have no arguments must return the @Component type";
+      
+  static final String BUILDER_INHERITED_BUILD_MUST_RETURN_COMPONENT_TYPE =
+      "@Component.Builder methods that have no arguments must return the @Component type"
+      + " Inherited method: %s";
+  
+  static final String BUILDER_METHOD_MUST_TAKE_ONE_ARG =
+      "@Component.Builder methods must not have more than one argument.";
+  
+  static final String BUILDER_INHERITED_METHOD_MUST_TAKE_ONE_ARG =
+      "@Component.Builder methods must not have more than one argument. Inherited method: %s";
+  
+  static final String BUILDER_METHODS_MUST_RETURN_VOID_OR_BUILDER =
+      "@Component.Builder setter methods must return void, the builder,"
+      + " or a supertype of the builder";
+  
+  static final String BUILDER_INHERITED_METHODS_MUST_RETURN_VOID_OR_BUILDER =
+      "@Component.Builder setter methods must return void, the builder,"
+      + "or a supertype of the builder. Inherited method: %s";
+  
+  static final String BUILDER_METHODS_MAY_NOT_HAVE_TYPE_PARAMETERS =
+      "@Component.Builder methods must not have type parameters";
+  
+  static final String BUILDER_INHERITED_METHODS_MAY_NOT_HAVE_TYPE_PARAMETERS =
+      "@Component.Builder methods must not have type parameters. Inherited method: %s";
 
   /**
    * A regular expression to match a small list of specific packages deemed to
diff --git a/compiler/src/main/java/dagger/internal/codegen/MethodSignatureFormatter.java b/compiler/src/main/java/dagger/internal/codegen/MethodSignatureFormatter.java
index 9f8514df8..078977e16 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MethodSignatureFormatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MethodSignatureFormatter.java
@@ -26,6 +26,7 @@
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ExecutableType;
+import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Types;
 
@@ -105,7 +106,10 @@ private static void appendParameter(StringBuilder builder, VariableElement param
   private static String nameOfType(TypeMirror type) {
     if (type.getKind().isPrimitive()) {
       return MoreTypes.asPrimitiveType(type).toString();
+    } else if (type.getKind() == TypeKind.VOID) {
+      return "void";
+    } else {
+      return stripCommonTypePrefixes(MoreTypes.asDeclared(type).toString());
     }
-    return stripCommonTypePrefixes(MoreTypes.asDeclared(type).toString());
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index 58ad95c36..7acb9d759 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -21,7 +21,12 @@
 import com.google.common.base.Equivalence;
 import com.google.common.base.Equivalence.Wrapper;
 import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ImmutableSet.Builder;
 import com.google.common.collect.Iterables;
+import com.google.common.collect.Lists;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import javax.lang.model.element.AnnotationMirror;
@@ -29,10 +34,13 @@
 import javax.lang.model.element.AnnotationValueVisitor;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.SimpleAnnotationValueVisitor6;
 
@@ -175,5 +183,71 @@ static boolean componentCanMakeNewInstances(TypeElement typeElement) {
     return false;
   }
 
+  /*
+   * Borrowed from AutoValue and slightly modified. TODO(gak): reconcile and put in autocommon.
+   */
+  private static ImmutableList<ExecutableElement> findLocalAndInheritedMethods(Elements elements,
+      TypeElement type) {
+    List<ExecutableElement> methods = Lists.newArrayList();
+    TypeElement objectType = elements.getTypeElement(Object.class.getName());
+    findLocalAndInheritedMethodsRecursive(objectType, elements, type, methods);
+    return ImmutableList.copyOf(methods);
+  }
+
+  private static void findLocalAndInheritedMethodsRecursive(TypeElement objectType,
+      Elements elements, TypeElement type, List<ExecutableElement> methods) {
+    if (objectType.equals(type)) {
+      return;
+    }
+
+    for (TypeMirror superInterface : type.getInterfaces()) {
+      findLocalAndInheritedMethodsRecursive(objectType,
+          elements, MoreElements.asType(MoreTypes.asElement(superInterface)), methods);
+    }
+    if (type.getSuperclass().getKind() != TypeKind.NONE) {
+      // Visit the superclass after superinterfaces so we will always see the implementation of a
+      // method after any interfaces that declared it.
+      findLocalAndInheritedMethodsRecursive(objectType,
+          elements, MoreElements.asType(MoreTypes.asElement(type.getSuperclass())), methods);
+    }
+    // Add each method of this class, and in so doing remove any inherited method it overrides.
+    // This algorithm is quadratic in the number of methods but it's hard to see how to improve
+    // that while still using Elements.overrides.
+    List<ExecutableElement> theseMethods = ElementFilter.methodsIn(type.getEnclosedElements());
+    for (ExecutableElement method : theseMethods) {
+      if (!method.getModifiers().contains(Modifier.PRIVATE)) {
+        boolean alreadySeen = false;
+        for (Iterator<ExecutableElement> methodIter = methods.iterator(); methodIter.hasNext();) {
+          ExecutableElement otherMethod = methodIter.next();
+          if (elements.overrides(method, otherMethod, type)) {
+            methodIter.remove();
+          } else if (method.getSimpleName().equals(otherMethod.getSimpleName())
+              && method.getParameters().equals(otherMethod.getParameters())) {
+            // If we inherit this method on more than one path, we don't want to add it twice.
+            alreadySeen = true;
+          }
+        }
+        if (!alreadySeen) {
+          methods.add(method);
+        }
+      }
+    }
+  }
+
+  /*
+   * Borrowed from AutoValue and slightly modified. TODO(gak): reconcile and put in autocommon.
+   */
+  static ImmutableSet<ExecutableElement> getUnimplementedMethods(
+      Elements elements, TypeElement type) {
+    ImmutableSet.Builder<ExecutableElement> unimplementedMethods = ImmutableSet.builder();
+    List<ExecutableElement> methods = findLocalAndInheritedMethods(elements, type);
+    for (ExecutableElement method : methods) {
+      if (method.getModifiers().contains(Modifier.ABSTRACT)) {
+        unimplementedMethods.add(method);
+      }
+    }
+    return unimplementedMethods.build();
+  }
+
   private Util() {}
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java
new file mode 100644
index 000000000..e4f335bbd
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java
@@ -0,0 +1,939 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.ErrorMessages.BUILDER_INHERITED_BUILD_MUST_RETURN_COMPONENT_TYPE;
+import static dagger.internal.codegen.ErrorMessages.BUILDER_INHERITED_METHODS_MUST_RETURN_VOID_OR_BUILDER;
+import static dagger.internal.codegen.ErrorMessages.BUILDER_INHERITED_METHOD_MUST_TAKE_ONE_ARG;
+
+/** Tests for {@link dagger.Component.Builder} */
+@RunWith(JUnit4.class)
+public class ComponentBuilderTest {
+  
+  @Test
+  public void testEmptyBuilder() {
+    JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class SomeInjectableType {",
+        "  @Inject SomeInjectableType() {}",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface SimpleComponent {",
+        "  SomeInjectableType someInjectableType();",
+        "",
+        "  @Component.Builder",
+        "  static interface Builder {",
+        "     SimpleComponent build();",
+        "  }",        
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.DaggerSimpleComponent",
+        "package test;",
+        "",
+        "import javax.annotation.Generated;",
+        "import test.SimpleComponent",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class DaggerSimpleComponent implements SimpleComponent {",
+        "  private DaggerSimpleComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    initialize(builder);",
+        "  }",
+        "",
+        "  public static SimpleComponent.Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static SimpleComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  private void initialize(final Builder builder) {",
+        "  }",
+        "",
+        "  @Override",
+        "  public SomeInjectableType someInjectableType() {",
+        "    return SomeInjectableType_Factory.create().get();",
+        "  }",
+        "",
+        "  private static final class Builder implements SimpleComponent.Builder {",
+        "    @Override",
+        "    public SimpleComponent build() {",
+        "      return new DaggerSimpleComponent(this);",
+        "    }",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(injectableTypeFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
+  
+  @Test
+  public void testUsesBuildAndSetterNames() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides String string() { return null; }",
+        "}");
+
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component(modules = TestModule.class)",
+        "interface TestComponent {",
+        "  String string();",
+        "",
+        "  @Component.Builder",
+        "  interface Builder {",
+        "    Builder setTestModule(TestModule testModule);",
+        "    TestComponent create();",
+        "  }",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.DaggerTestComponent",
+        "package test;",
+        "",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "import test.TestComponent;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class DaggerTestComponent implements TestComponent {",
+        "  private Provider<String> stringProvider;",
+        "",
+        "  private DaggerTestComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    initialize(builder);",
+        "  }",
+        "",
+        "  public static TestComponent.Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static TestComponent create() {",
+        "    return builder().create();",
+        "  }",
+        "",
+        "  private void initialize(final Builder builder) {",
+        "    this.stringProvider = TestModule_StringFactory.create(builder.testModule);",
+        "  }",
+        "",
+        "  @Override",
+        "  public String string() {",
+        "    return stringProvider.get();",
+        "  }",
+        "",
+        "  private static final class Builder implements TestComponent.Builder {",
+        "    private TestModule testModule;",
+        "",
+        "    @Override",
+        "    public TestComponent create() {",
+        "      if (testModule == null) {",
+        "        this.testModule = new TestModule();",
+        "      }",
+        "      return new DaggerTestComponent(this);",
+        "    }",
+        "",
+        "    @Override",
+        "    public Builder setTestModule(TestModule testModule) {",
+        "      if (testModule == null) {",
+        "        throw new NullPointerException(\"testModule\");",
+        "      }",
+        "      this.testModule = testModule;",
+        "      return this;",
+        "    }",
+        "  }",
+        "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(moduleFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
+  
+  @Test
+  public void testIgnoresModulesNotInApi() {
+    JavaFileObject module1 = JavaFileObjects.forSourceLines("test.TestModule1",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class TestModule1 {",
+        "  @Provides String string() { return null; }",
+        "}");
+    JavaFileObject module2 = JavaFileObjects.forSourceLines("test.TestModule2",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class TestModule2 {",
+        "  @Provides Integer integer() { return null; }",
+        "}");
+
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component(modules = {TestModule1.class, TestModule2.class})",
+        "interface TestComponent {",
+        "  String string();",
+        "  Integer integer();",
+        "",
+        "  @Component.Builder",
+        "  interface Builder {",
+        "    Builder testModule1(TestModule1 testModule);",
+        "    TestComponent build();",
+        "  }",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.DaggerTestComponent",
+        "package test;",
+        "",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "import test.TestComponent;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class DaggerTestComponent implements TestComponent {",
+        "  private Provider<String> stringProvider;",
+        "  private Provider<Integer> integerProvider;",
+        "",
+        "  private DaggerTestComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    initialize(builder);",
+        "  }",
+        "",
+        "  public static TestComponent.Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static TestComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  private void initialize(final Builder builder) {",
+        "    this.stringProvider = TestModule1_StringFactory.create(builder.testModule1);",
+        "    this.integerProvider = TestModule2_IntegerFactory.create(builder.testModule2);",
+        "  }",
+        "",
+        "  @Override",
+        "  public String string() {",
+        "    return stringProvider.get();",
+        "  }",
+        "",
+        "  @Override",
+        "  public Integer integer() {",
+        "    return integerProvider.get();",
+        "  }",
+        "",
+        "  private static final class Builder implements TestComponent.Builder {",
+        "    private TestModule1 testModule1;",
+        "    private TestModule2 testModule2;",
+        "",
+        "    @Override",
+        "    public TestComponent build() {",
+        "      if (testModule1 == null) {",
+        "        this.testModule1 = new TestModule1();",
+        "      }",
+        "      if (testModule2 == null) {",
+        "        this.testModule2 = new TestModule2();",
+        "      }",
+        "      return new DaggerTestComponent(this);",
+        "    }",
+        "",
+        "    @Override",
+        "    public Builder testModule1(TestModule1 testModule1) {",
+        "      if (testModule1 == null) {",
+        "        throw new NullPointerException(\"testModule1\");",
+        "      }",
+        "      this.testModule1 = testModule1;",
+        "      return this;",
+        "    }",
+        "  }",
+        "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(module1, module2, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
+  
+  @Test
+  public void testMoreThanOneBuilderFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface SimpleComponent {",
+        "  @Component.Builder",
+        "  static interface Builder {",
+        "     SimpleComponent build();",
+        "  }",
+        "",
+        "  @Component.Builder",
+        "  interface Builder2 {",
+        "     SimpleComponent build();",
+        "  }",           
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(String.format(ErrorMessages.BUILDER_MORE_THAN_ONE,
+            "[test.SimpleComponent.Builder, test.SimpleComponent.Builder2]"))
+        .in(componentFile);
+  }
+  
+  @Test
+  public void testBuilderGenericsFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface SimpleComponent {",
+        "  @Component.Builder",
+        "  interface Builder<T> {",
+        "     SimpleComponent build();",
+        "  }",           
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(ErrorMessages.BUILDER_GENERICS)
+        .in(componentFile);
+  }
+  
+  @Test
+  public void testBuilderNotInComponentFails() {
+    JavaFileObject builder = JavaFileObjects.forSourceLines("test.Builder",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component.Builder",
+        "interface Builder {}");
+    assertAbout(javaSource()).that(builder)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(ErrorMessages.BUILDER_MUST_BE_IN_COMPONENT)
+        .in(builder);
+  }
+  
+  @Test
+  public void testBuilderMissingBuildMethodFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface SimpleComponent {",
+        "  @Component.Builder",
+        "  interface Builder {}",
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(ErrorMessages.BUILDER_MISSING_BUILD_METHOD)
+        .in(componentFile);
+  }
+  
+  @Test
+  public void testPrivateBuilderFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "abstract class SimpleComponent {",
+        "  @Component.Builder",
+        "  private interface Builder {}",
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(ErrorMessages.BUILDER_PRIVATE)
+        .in(componentFile);
+  }
+  
+  @Test
+  public void testNonStaticBuilderFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "abstract class SimpleComponent {",
+        "  @Component.Builder",
+        "  abstract class Builder {}",
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(ErrorMessages.BUILDER_MUST_BE_STATIC)
+        .in(componentFile);
+  }
+  
+  @Test
+  public void testNonAbstractBuilderFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "abstract class SimpleComponent {",
+        "  @Component.Builder",
+        "  static class Builder {}",
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(ErrorMessages.BUILDER_MUST_BE_ABSTRACT);
+  }
+  
+  @Test
+  public void testBuilderOneCxtorWithArgsFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "abstract class SimpleComponent {",
+        "  @Component.Builder",
+        "  static abstract class Builder {",
+        "    Builder(String unused) {}",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(ErrorMessages.BUILDER_CXTOR_ONLY_ONE_AND_NO_ARGS)
+        .in(componentFile);
+  }
+  
+  @Test
+  public void testBuilderMoreThanOneCxtorFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "abstract class SimpleComponent {",
+        "  @Component.Builder",
+        "  static abstract class Builder {",
+        "    Builder() {}",
+        "    Builder(String unused) {}",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(ErrorMessages.BUILDER_CXTOR_ONLY_ONE_AND_NO_ARGS)
+        .in(componentFile);
+  }
+  
+  @Test
+  public void testBuilderEnumFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "abstract class SimpleComponent {",
+        "  @Component.Builder",
+        "  enum Builder {}",
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(ErrorMessages.BUILDER_MUST_BE_CLASS_OR_INTERFACE)
+        .in(componentFile);
+  }
+  
+  @Test
+  public void testBuilderBuildReturnsWrongTypeFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "abstract class SimpleComponent {",
+        "  @Component.Builder",
+        "  interface Builder {",
+        "    String build();",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(ErrorMessages.BUILDER_BUILD_MUST_RETURN_COMPONENT_TYPE)
+            .in(componentFile).onLine(11);
+  }
+  
+  @Test
+  public void testInheritedBuilderBuildReturnsWrongTypeFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "abstract class SimpleComponent {",
+        "  interface Parent {",
+        "    String build();",
+        "  }",
+        "",
+        "  @Component.Builder",
+        "  interface Builder extends Parent {}",
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(BUILDER_INHERITED_BUILD_MUST_RETURN_COMPONENT_TYPE, "build"))
+            .in(componentFile).onLine(14);
+  }
+  
+  @Test
+  public void testTwoBuildMethodsFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "abstract class SimpleComponent {",
+        "  @Component.Builder",
+        "  interface Builder {",
+        "    SimpleComponent build();",
+        "    SimpleComponent create();",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(String.format(ErrorMessages.BUILDER_TWO_BUILD_METHODS, "build()"))
+            .in(componentFile).onLine(12);
+  }
+  
+  @Test
+  public void testInheritedTwoBuildMethodsFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "abstract class SimpleComponent {",
+        "  interface Parent {",
+        "    SimpleComponent build();",
+        "    SimpleComponent create();",
+        "  }",
+        "",
+        "  @Component.Builder",
+        "  interface Builder extends Parent {}",
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(ErrorMessages.BUILDER_INHERITED_TWO_BUILD_METHODS, "create()", "build()"))
+            .in(componentFile).onLine(15);
+  }
+  
+  @Test
+  public void testMoreThanOneArgFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "abstract class SimpleComponent {",
+        "  @Component.Builder",
+        "  interface Builder {",
+        "    SimpleComponent build();",
+        "    Builder set(String s, Integer i);",
+        "    Builder set(Number n, Double d);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(ErrorMessages.BUILDER_METHOD_MUST_TAKE_ONE_ARG)
+            .in(componentFile).onLine(12)
+        .and().withErrorContaining(ErrorMessages.BUILDER_METHOD_MUST_TAKE_ONE_ARG)
+            .in(componentFile).onLine(13);
+  }
+  
+  @Test
+  public void testInheritedMoreThanOneArgFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "abstract class SimpleComponent {",
+        "  interface Parent {",
+        "    SimpleComponent build();",
+        "    Builder set1(String s, Integer i);",
+        "  }",
+        "",
+        "  @Component.Builder",
+        "  interface Builder extends Parent {}",
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(BUILDER_INHERITED_METHOD_MUST_TAKE_ONE_ARG,
+                "set1(java.lang.String,java.lang.Integer)"))
+            .in(componentFile).onLine(15);
+  }
+  
+  @Test
+  public void testSetterReturningNonVoidOrBuilderFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "abstract class SimpleComponent {",
+        "  @Component.Builder",
+        "  interface Builder {",
+        "    SimpleComponent build();",
+        "    String set(Integer i);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(ErrorMessages.BUILDER_METHODS_MUST_RETURN_VOID_OR_BUILDER)
+            .in(componentFile).onLine(12);
+  }
+  
+  @Test
+  public void testInheritedSetterReturningNonVoidOrBuilderFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "abstract class SimpleComponent {",
+        "  interface Parent {",
+        "    SimpleComponent build();",
+        "    String set(Integer i);",
+        "  }",
+        "",
+        "  @Component.Builder",
+        "  interface Builder extends Parent {}",
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(BUILDER_INHERITED_METHODS_MUST_RETURN_VOID_OR_BUILDER,
+                "set(java.lang.Integer)"))
+            .in(componentFile).onLine(15);    
+  }
+  
+  @Test
+  public void testGenericsOnSetterMethodFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "abstract class SimpleComponent {",
+        "  @Component.Builder",
+        "  interface Builder {",
+        "    SimpleComponent build();",
+        "    <T> Builder set(T t);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(ErrorMessages.BUILDER_METHODS_MAY_NOT_HAVE_TYPE_PARAMETERS)
+            .in(componentFile).onLine(12);
+  }
+  
+  @Test
+  public void testGenericsOnInheritedSetterMethodFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "abstract class SimpleComponent {",
+        "  interface Parent {",
+        "    SimpleComponent build();",
+        "    <T> Builder set(T t);",
+        "  }",
+        "",
+        "  @Component.Builder",
+        "  interface Builder extends Parent {}",
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(ErrorMessages.BUILDER_INHERITED_METHODS_MAY_NOT_HAVE_TYPE_PARAMETERS,
+                "<T>set(T)"))
+            .in(componentFile).onLine(15);    
+  }
+  
+  @Test
+  public void testMultipleSettersPerTypeFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "abstract class SimpleComponent {",
+        "  @Component.Builder",
+        "  interface Builder {",
+        "    SimpleComponent build();",
+        "    void set1(String s);",
+        "    void set2(String s);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(ErrorMessages.BUILDER_MANY_METHODS_FOR_TYPE,
+                  "java.lang.String", "[set1(java.lang.String), set2(java.lang.String)]"))
+            .in(componentFile).onLine(10);
+  }
+  
+  @Test
+  public void testMultipleSettersPerTypeIncludingResolvedGenericsFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "abstract class SimpleComponent {",
+        "  interface Parent<T> {",
+        "    void set1(T t);",
+        "  }",
+        "",
+        "  @Component.Builder",
+        "  interface Builder extends Parent<String> {",
+        "    SimpleComponent build();",
+        "    void set2(String s);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(ErrorMessages.BUILDER_MANY_METHODS_FOR_TYPE,
+                  "java.lang.String", "[set1(T), set2(java.lang.String)]"))
+            .in(componentFile).onLine(14);
+  }
+  
+  @Test
+  public void testExtraSettersFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "abstract class SimpleComponent {",
+        "  @Component.Builder",
+        "  interface Builder {",
+        "    SimpleComponent build();",
+        "    void set1(String s);",
+        "    void set2(Integer s);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(ErrorMessages.BUILDER_EXTRA_SETTERS,
+                  "[void test.SimpleComponent.Builder.set1(String),"
+                  + " void test.SimpleComponent.Builder.set2(Integer)]"))
+            .in(componentFile).onLine(10);
+    
+  }
+  
+  @Test
+  public void testMissingSettersFail() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  TestModule(String unused) {}",
+        "  @Provides String s() { return null; }",
+        "}");
+    JavaFileObject module2File = JavaFileObjects.forSourceLines("test.Test2Module",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class Test2Module {",
+        "  @Provides Integer i() { return null; }",
+        "}");
+    JavaFileObject module3File = JavaFileObjects.forSourceLines("test.Test3Module",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class Test3Module {",
+        "  Test3Module(String unused) {}",
+        "  @Provides Double d() { return null; }",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component(modules = {TestModule.class, Test2Module.class, Test3Module.class},",
+        "           dependencies = OtherComponent.class)",
+        "interface TestComponent {",
+        "  String string();",
+        "  Integer integer();",
+        "",
+        "  @Component.Builder",
+        "  interface Builder {",
+        "    TestComponent create();",
+        "  }",
+        "}");
+    JavaFileObject otherComponent = JavaFileObjects.forSourceLines("test.OtherComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "interface OtherComponent {}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(moduleFile, module2File, module3File, componentFile, otherComponent))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            // Ignores Test2Module because we can construct it ourselves.
+            // TODO(sameb): Ignore Test3Module because it's not used within transitive dependencies.
+            String.format(ErrorMessages.BUILDER_MISSING_SETTERS,
+                "[test.TestModule, test.Test3Module, test.OtherComponent]"))
+            .in(componentFile).onLine(12);
+  }
+}
diff --git a/core/src/main/java/dagger/Component.java b/core/src/main/java/dagger/Component.java
index a1667328b..7d724017e 100644
--- a/core/src/main/java/dagger/Component.java
+++ b/core/src/main/java/dagger/Component.java
@@ -22,6 +22,7 @@
 import javax.inject.Provider;
 import javax.inject.Qualifier;
 import javax.inject.Scope;
+import javax.inject.Singleton;
 
 import static java.lang.annotation.ElementType.TYPE;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
@@ -108,13 +109,16 @@
  *
  * <p>Component implementations are primarily instantiated via a generated
  * <a href="http://en.wikipedia.org/wiki/Builder_pattern">builder</a>. An instance of the builder
- * is obtained using the {@code builder()} method on the component implementation. The returned
- * builder has a method to set each of the {@linkplain #modules} and component
- * {@linkplain #dependencies} named with the <a href="http://en.wikipedia.org/wiki/CamelCase">lower
- * camel case</a> version of the module or dependency type. Each component dependency and module
- * without a visible default constructor must be set explicitly, but any module with a default or
- * no-args constructor accessible to the component implementation may be elided. This is an example
- * usage of a component builder: <pre><code>
+ * is obtained using the {@code builder()} method on the component implementation.
+ * If a nested {@code @Component.Builder} type exists in the component, the {@code builder()}
+ * method will return a generated implementation of that type.  If no nested
+ * {@code @Component.Builder} exists, the returned builder has a method to set each of the
+ * {@linkplain #modules} and component {@linkplain #dependencies} named with the
+ * <a href="http://en.wikipedia.org/wiki/CamelCase">lower camel case</a> version of the module
+ * or dependency type. Each component dependency and module without a visible default constructor
+ * must be set explicitly, but any module with a default or no-args constructor accessible to the
+ * component implementation may be elided. This is an example usage of a component builder:
+ * <pre><code>
  *   public static void main(String[] args) {
  *     OtherComponent otherComponent = ...;
  *     MyComponent component = DaggerMyComponent.builder()
@@ -217,4 +221,38 @@
    * dependencies</a>.
    */
   Class<?>[] dependencies() default {};
+
+  /**
+   * A builder for a component. Components may have a single nested static abstract class or
+   * interface annotated with {@code @Component.Builder}.  If they do, then the component's
+   * generated builder will match the API in the type.  Builders must follow some rules:
+   * <ul>
+   * <li> A single abstract method with no arguments must exist, and must return the component.
+   *      (This is typically the {@code build()} method.)
+   * <li> All other abstract methods must take a single argument and must return void,
+   *      the Builder type, or a supertype of the builder.
+   * <li> Each component dependency <b>must</b> have an abstract setter method.
+   * <li> Each module dependency that Dagger can't instantiate itself (e.g, the module
+   *      doesn't have a visible no-args constructor) <b>must</b> have an abstract setter method.
+   *      Other module dependencies (ones that Dagger can instantiate) are allowed, but not required.
+   * <li> Non-abstract methods are allowed, but ignored as far as validation and builder generation
+   *      are concerned.
+   * </ul>
+   * 
+   * For example, this could be a valid Component with a Builder: <pre><code>
+   * {@literal @}Component(modules = {BackendModule.class, FrontendModule.class})
+   * interface MyComponent {
+   *   MyWidget myWidget();
+   *   
+   *   {@literal @}Component.Builder
+   *   interface Builder {
+   *     MyComponent build();
+   *     Builder backendModule(BackendModule bm);
+   *     Builder frontendModule(FrontendModule fm);
+   *   }
+   * }</code></pre>
+   */
+  @Target(TYPE)
+  @Documented
+  @interface Builder {}
 }
