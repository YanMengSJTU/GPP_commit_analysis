diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index af74000a0..011fad725 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -297,9 +297,7 @@ private boolean validateResolvedBinding(
             throw new AssertionError(
                 "contribution binding keys should never have members injection bindings");
           }
-          if (!validateNullability(path.peek().request(), resolvedBinding.contributionBindings())) {
-            return false;
-          }
+          validateNullability(path.peek().request(), resolvedBinding.contributionBindings());
           if (resolvedBinding.contributionBindings().size() > 1) {
             reportDuplicateBindings(path);
             return false;
@@ -419,10 +417,9 @@ private ResolvedBindings inlineSyntheticContributions(ResolvedBindings resolvedB
     }
 
     /** Ensures that if the request isn't nullable, then each contribution is also not nullable. */
-    private boolean validateNullability(
-        DependencyRequest request, Set<ContributionBinding> bindings) {
+    private void validateNullability(DependencyRequest request, Set<ContributionBinding> bindings) {
       if (request.isNullable()) {
-        return true;
+        return;
       }
 
       // Note: the method signature will include the @Nullable in it!
@@ -432,7 +429,6 @@ private boolean validateNullability(
        * message is kind of useless. */
       String typeName = TypeName.get(request.key().type()).toString();
 
-      boolean valid = true;
       for (ContributionBinding binding : bindings) {
         if (binding.nullableType().isPresent()) {
           reportBuilder.addItem(
@@ -441,10 +437,8 @@ private boolean validateNullability(
                   + dependencyRequestFormatter.format(request),
               compilerOptions.nullableValidationKind(),
               request.requestElement());
-          valid = false;
         }
       }
-      return valid;
     }
 
     /**
diff --git a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
index 9d902de05..45eddac27 100644
--- a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
@@ -1496,4 +1496,63 @@ public void subcomponentBindingConflictsWithParent() {
         .in(child)
         .onLine(8);
   }
+
+  @Test
+  public void subcomponentBindingConflictsWithParentWithNullableViolationAsWarning() {
+    JavaFileObject parentConflictsWithChild =
+        JavaFileObjects.forSourceLines(
+            "test.ParentConflictsWithChild",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import javax.annotation.Nullable;",
+            "",
+            "@Component(modules = ParentConflictsWithChild.ParentModule.class)",
+            "interface ParentConflictsWithChild {",
+            "  Child child();",
+            "",
+            "  @Module",
+            "  static class ParentModule {",
+            "    @Provides @Nullable static Object nullableParentChildConflict() {",
+            "      return \"parent\";",
+            "    }",
+            "  }",
+            "}");
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = Child.ChildModule.class)",
+            "interface Child {",
+            "  Object parentChildConflictThatViolatesNullability();",
+            "",
+            "  @Module",
+            "  static class ChildModule {",
+            "    @Provides static Object nonNullableParentChildConflict() {",
+            "      return \"child\";",
+            "    }",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(parentConflictsWithChild, child))
+        .withCompilerOptions("-Adagger.nullableValidation=WARNING")
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "[test.Child.parentChildConflictThatViolatesNullability()] "
+                + "java.lang.Object is bound multiple times:\n"
+                + "      @Provides @javax.annotation.Nullable Object"
+                + " test.ParentConflictsWithChild.ParentModule.nullableParentChildConflict()\n"
+                + "      @Provides Object"
+                + " test.Child.ChildModule.nonNullableParentChildConflict()")
+        .in(parentConflictsWithChild)
+        .onLine(9);
+  }
 }
