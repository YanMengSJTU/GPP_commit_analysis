diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index 54a60087f..a71d2e369 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -315,9 +315,9 @@ private BindingGraph create(
         this.delegateDeclarations = delegateDeclarations;
         this.resolvedBindings = Maps.newLinkedHashMap();
         this.explicitMultibindings =
-            multibindingsKeyedWithoutBindingIdentifiers(explicitBindingsSet);
+            multibindingContributionsByMultibindingKey(explicitBindingsSet);
         this.delegateMultibindingDeclarations =
-            multibindingsKeyedWithoutBindingIdentifiers(delegateDeclarations.values());
+            multibindingContributionsByMultibindingKey(delegateDeclarations.values());
       }
 
       /**
@@ -684,9 +684,8 @@ private boolean isResolvedInParent(DependencyRequest request, ContributionBindin
       }
 
       /**
-       * Returns the explicit multibinding contributions whose key (minus its
-       * {@link Key#bindingIdentifier()}) matches the {@code requestKey} from this and all ancestor
-       * resolvers.
+       * Returns the explicit multibinding contributions that contribute to the map or set requested
+       * by {@code requestKey} from this and all ancestor resolvers.
        */
       private ImmutableSet<ContributionBinding> getExplicitMultibindingContributions(
           Key requestKey) {
@@ -721,6 +720,10 @@ private boolean isResolvedInParent(DependencyRequest request, ContributionBindin
         return delegateBindings.build();
       }
 
+      /**
+       * Returns the delegate multibinding contribution declarations that contribute to the map or
+       * set requested by {@code requestKey} from this and all ancestor resolvers.
+       */
       private ImmutableSet<ContributionBinding> getDelegateMultibindingContributions(
           Key requestKey) {
         if (MapType.isMap(requestKey) && !MapType.from(requestKey).valuesAreFrameworkType()) {
@@ -931,16 +934,16 @@ private boolean isMultibindingsWithLocalContributions(ResolvedBindings resolvedB
     }
 
     /**
-     * Selects each item in {@code haveKeys} that has a {@link Key#bindingIdentifier()} and indexes
-     * them by its {@link HasKey#key()}, where each key has its binding identifier removed.
+     * A multimap of those {@code declarations} that are multibinding contribution declarations,
+     * indexed by the key of the set or map to which they contribute.
      */
     static <T extends HasKey>
-        ImmutableSetMultimap<Key, T> multibindingsKeyedWithoutBindingIdentifiers(
-            Iterable<T> haveKeys) {
+        ImmutableSetMultimap<Key, T> multibindingContributionsByMultibindingKey(
+            Iterable<T> declarations) {
       ImmutableSetMultimap.Builder<Key, T> builder = ImmutableSetMultimap.builder();
-      for (T hasKey : haveKeys) {
-        if (hasKey.key().bindingIdentifier().isPresent()) {
-          builder.put(hasKey.key().withoutBindingIdentifier(), hasKey);
+      for (T declaration : declarations) {
+        if (declaration.key().multibindingContributionIdentifier().isPresent()) {
+          builder.put(declaration.key().withoutMultibindingContributionIdentifier(), declaration);
         }
       }
       return builder.build();
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 531845dcd..6e3f23741 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -42,10 +42,14 @@
 import static dagger.internal.codegen.ContributionType.indexByContributionType;
 import static dagger.internal.codegen.ErrorMessages.CANNOT_INJECT_WILDCARD_TYPE;
 import static dagger.internal.codegen.ErrorMessages.CONTAINS_DEPENDENCY_CYCLE_FORMAT;
+import static dagger.internal.codegen.ErrorMessages.DEPENDS_ON_PRODUCTION_EXECUTOR_FORMAT;
+import static dagger.internal.codegen.ErrorMessages.DUPLICATE_BINDINGS_FOR_KEY_FORMAT;
 import static dagger.internal.codegen.ErrorMessages.DUPLICATE_SIZE_LIMIT;
 import static dagger.internal.codegen.ErrorMessages.INDENT;
 import static dagger.internal.codegen.ErrorMessages.MEMBERS_INJECTION_WITH_UNBOUNDED_TYPE;
 import static dagger.internal.codegen.ErrorMessages.MULTIPLE_CONTRIBUTION_TYPES_FOR_KEY_FORMAT;
+import static dagger.internal.codegen.ErrorMessages.PROVIDER_ENTRY_POINT_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT;
+import static dagger.internal.codegen.ErrorMessages.PROVIDER_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT;
 import static dagger.internal.codegen.ErrorMessages.REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_FORMAT;
 import static dagger.internal.codegen.ErrorMessages.REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_OR_PRODUCER_FORMAT;
 import static dagger.internal.codegen.ErrorMessages.REQUIRES_PROVIDER_FORMAT;
@@ -957,15 +961,17 @@ private void reportProviderMayNotDependOnProducer(DependencyPath path) {
       if (path.size() == 1) {
         new Formatter(errorMessage)
             .format(
-                ErrorMessages.PROVIDER_ENTRY_POINT_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT,
-                formatRootRequestKey(path));
+                PROVIDER_ENTRY_POINT_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT,
+                formatCurrentDependencyRequestKey(path));
       } else {
         ImmutableSet<? extends Binding> dependentProvisions =
             provisionsDependingOnLatestRequest(path);
         // TODO(beder): Consider displaying all dependent provisions in the error message. If we do
         // that, should we display all productions that depend on them also?
-        new Formatter(errorMessage).format(ErrorMessages.PROVIDER_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT,
-            keyFormatter.format(dependentProvisions.iterator().next().key()));
+        new Formatter(errorMessage)
+            .format(
+                PROVIDER_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT,
+                dependentProvisions.iterator().next().key());
       }
       reportBuilder.addError(errorMessage.toString(), path.entryPointElement());
     }
@@ -993,8 +999,9 @@ private StringBuilder requiresErrorMessageBase(DependencyPath path) {
               : REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_OR_PRODUCER_FORMAT;
         }
       }
-      StringBuilder errorMessage = new StringBuilder(
-          String.format(requiresErrorMessageFormat, keyFormatter.format(key)));
+      StringBuilder errorMessage =
+          new StringBuilder(
+              String.format(requiresErrorMessageFormat, formatCurrentDependencyRequestKey(path)));
       if (key.isValidMembersInjectionKey()) {
         Optional<MembersInjectionBinding> membersInjectionBinding =
             injectBindingRegistry.getOrFindMembersInjectionBinding(key);
@@ -1020,10 +1027,10 @@ private void reportMissingBinding(DependencyPath path) {
 
     @SuppressWarnings("resource") // Appendable is a StringBuilder.
     private void reportDependsOnProductionExecutor(DependencyPath path) {
-      StringBuilder builder = new StringBuilder();
-      new Formatter(builder)
-          .format(ErrorMessages.DEPENDS_ON_PRODUCTION_EXECUTOR_FORMAT, formatRootRequestKey(path));
-      reportBuilder.addError(builder.toString(), path.entryPointElement());
+      reportBuilder.addError(
+          String.format(
+              DEPENDS_ON_PRODUCTION_EXECUTOR_FORMAT, formatCurrentDependencyRequestKey(path)),
+          path.entryPointElement());
     }
 
     @SuppressWarnings("resource") // Appendable is a StringBuilder.
@@ -1040,7 +1047,7 @@ private void reportDuplicateBindings(DependencyPath path) {
       }
       StringBuilder builder = new StringBuilder();
       new Formatter(builder)
-          .format(ErrorMessages.DUPLICATE_BINDINGS_FOR_KEY_FORMAT, formatRootRequestKey(path));
+          .format(DUPLICATE_BINDINGS_FOR_KEY_FORMAT, formatCurrentDependencyRequestKey(path));
       ImmutableSet<ContributionBinding> duplicateBindings =
           inlineContributionsWithoutBindingElements(resolvedBindings).contributionBindings();
       bindingDeclarationFormatter.formatIndentedList(
@@ -1088,7 +1095,8 @@ private void reportDuplicateBindings(DependencyPath path) {
     private void reportMultipleContributionTypes(DependencyPath path) {
       StringBuilder builder = new StringBuilder();
       new Formatter(builder)
-          .format(MULTIPLE_CONTRIBUTION_TYPES_FOR_KEY_FORMAT, formatRootRequestKey(path));
+          .format(
+              MULTIPLE_CONTRIBUTION_TYPES_FOR_KEY_FORMAT, formatCurrentDependencyRequestKey(path));
       ResolvedBindings resolvedBindings = path.currentResolvedBindings();
       ImmutableListMultimap<ContributionType, BindingDeclaration> declarationsByType =
           declarationsByType(resolvedBindings);
@@ -1112,7 +1120,7 @@ private void reportMultipleContributionTypes(DependencyPath path) {
     private void reportDuplicateMapKeys(
         DependencyPath path, Collection<ContributionBinding> mapBindings) {
       StringBuilder builder = new StringBuilder();
-      builder.append(duplicateMapKeysError(formatRootRequestKey(path)));
+      builder.append(duplicateMapKeysError(formatCurrentDependencyRequestKey(path)));
       bindingDeclarationFormatter.formatIndentedList(builder, mapBindings, 1, DUPLICATE_SIZE_LIMIT);
       reportBuilder.addError(builder.toString(), path.entryPointElement());
     }
@@ -1122,7 +1130,8 @@ private void reportInconsistentMapKeyAnnotations(
         Multimap<Equivalence.Wrapper<DeclaredType>, ContributionBinding>
             mapBindingsByAnnotationType) {
       StringBuilder builder =
-          new StringBuilder(inconsistentMapKeyAnnotationsError(formatRootRequestKey(path)));
+          new StringBuilder(
+              inconsistentMapKeyAnnotationsError(formatCurrentDependencyRequestKey(path)));
       for (Map.Entry<Equivalence.Wrapper<DeclaredType>, Collection<ContributionBinding>> entry :
           mapBindingsByAnnotationType.asMap().entrySet()) {
         DeclaredType annotationType = entry.getKey().get();
@@ -1285,7 +1294,7 @@ private String formatContributionType(ContributionType type) {
     }
   }
 
-  private String formatRootRequestKey(DependencyPath path) {
+  private String formatCurrentDependencyRequestKey(DependencyPath path) {
     return keyFormatter.format(path.currentDependencyRequest().key());
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index c8ba5ba6d..6c60484f6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -69,7 +69,7 @@ public SourceVersion getSupportedSourceVersion() {
         new BindingDeclarationFormatter(methodSignatureFormatter);
     DependencyRequestFormatter dependencyRequestFormatter =
         new DependencyRequestFormatter(types, elements);
-    KeyFormatter keyFormatter = new KeyFormatter(methodSignatureFormatter);
+    KeyFormatter keyFormatter = new KeyFormatter();
 
     InjectValidator injectValidator = new InjectValidator(types, elements, compilerOptions);
     InjectValidator injectValidatorWhenGeneratingCode = injectValidator.whenGeneratingCode();
@@ -91,7 +91,7 @@ public SourceVersion getSupportedSourceVersion() {
     MultibindingsMethodValidator multibindingsMethodValidator =
         new MultibindingsMethodValidator(elements, types);
 
-    Key.Factory keyFactory = new Key.Factory(types, elements, methodSignatureFormatter);
+    Key.Factory keyFactory = new Key.Factory(types, elements);
 
     MultibindingsValidator multibindingsValidator =
         new MultibindingsValidator(
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
index 977221af4..e11344c29 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -225,8 +225,8 @@ DependencyRequest forImplicitMapBinding(
     DependencyRequest forMultibindingContribution(
         DependencyRequest request, ContributionBinding multibindingContribution) {
       checkArgument(
-          multibindingContribution.key().bindingIdentifier().isPresent(),
-          "multibindingContribution's key must have a binding identifier: %s",
+          multibindingContribution.key().multibindingContributionIdentifier().isPresent(),
+          "multibindingContribution's key must have a multibinding contribution identifier: %s",
           multibindingContribution);
       return new AutoValue_DependencyRequest(
           multibindingContributionRequestKind(multibindingContribution),
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index ce6cee6f0..7745ab5d7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -34,7 +34,7 @@
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
 import com.google.common.base.Function;
-import com.google.common.base.MoreObjects;
+import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
@@ -101,29 +101,55 @@
   abstract Equivalence.Wrapper<TypeMirror> wrappedType();
 
   /**
-   * Absent except for multibinding contributions. Each multibound map and set is represented by a
-   * {@linkplain ProvisionBinding.Factory#syntheticMultibinding(DependencyRequest, Iterable)
-   * synthetic binding} that depends on the specific contributions to that map or set. Each such
-   * contribution binding therefore needs a key that identifies the specific binding, and not only
-   * the qualified type that is bound.
+   * Distinguishes keys for multibinding contributions that share a {@link #type()} and {@link
+   * #qualifier()}.
    *
-   * <p>For nonsynthetic multibinding contributions, this should be a human-readable string that
-   * identifies the method and contributing module.
+   * <p>Each multibound map and set has a {@linkplain
+   * ProvisionBinding.Factory#syntheticMultibinding(DependencyRequest, Iterable) synthetic
+   * multibinding} that depends on the specific contributions to that map or set using keys that
+   * identify those multibinding contributions.
+   *
+   * <p>Absent except for multibinding contributions.
+   */
+  abstract Optional<MultibindingContributionIdentifier> multibindingContributionIdentifier();
+
+  /**
+   * An object that identifies a multibinding contribution method and the module class that
+   * contributes it to the graph.
+   *
+   * @see Key#multibindingContributionIdentifier()
    */
-  abstract Optional<BindingIdentifier> bindingIdentifier();
+  static final class MultibindingContributionIdentifier {
+    private final String identifierString;
 
-  /** An object that uniquely identifies a multibinding contribution binding. */
-  @AutoValue
-  abstract static class BindingIdentifier {
-    abstract String string();
+    MultibindingContributionIdentifier(
+        ExecutableElement bindingMethod, TypeElement contributingModule) {
+      this.identifierString =
+          String.format(
+              "%s#%s", contributingModule.getQualifiedName(), bindingMethod.getSimpleName());
+    }
+
+    /**
+     * {@inheritDoc}
+     *
+     * <p>The returned string is human-readable and distinguishes the keys in the same way as the
+     * whole object.
+     */
+    @Override
+    public String toString() {
+      return identifierString;
+    }
 
     @Override
-    public final String toString() {
-      return string();
+    public boolean equals(Object obj) {
+      return obj instanceof MultibindingContributionIdentifier
+          && ((MultibindingContributionIdentifier) obj)
+              .identifierString.equals(this.identifierString);
     }
 
-    static BindingIdentifier create(String string) {
-      return new AutoValue_Key_BindingIdentifier(string);
+    @Override
+    public int hashCode() {
+      return identifierString.hashCode();
     }
   }
 
@@ -148,34 +174,32 @@ private static TypeMirror normalize(Types types, TypeMirror type) {
   }
 
   /**
-   * A key whose {@link #qualifier()} and {@link #bindingIdentifier()} are equivalent to this
-   * one's, but with {@code newType} (normalized) as its {@link #type()}.
+   * A key whose {@link #qualifier()} and {@link #multibindingContributionIdentifier()} are
+   * equivalent to this one's, but with {@code newType} (normalized) as its {@link #type()}.
    */
   private Key withType(Types types, TypeMirror newType) {
     return new AutoValue_Key(
         wrappedQualifier(),
         MoreTypes.equivalence().wrap(normalize(types, newType)),
-        bindingIdentifier());
+        multibindingContributionIdentifier());
   }
 
   /**
    * A key whose {@link #qualifier()} and {@link #type()} are equivalent to this one's, but with
-   * {@code bindingIdentifier} as its {@link #bindingIdentifier()}.
+   * {@code identifier} as its {@link #multibindingContributionIdentifier()}.
    */
-  private Key withBindingIdentifier(String bindingIdentifier) {
-    return new AutoValue_Key(
-        wrappedQualifier(),
-        wrappedType(),
-        Optional.of(BindingIdentifier.create(bindingIdentifier)));
+  private Key withMultibindingContributionIdentifier(
+      MultibindingContributionIdentifier identifier) {
+    return new AutoValue_Key(wrappedQualifier(), wrappedType(), Optional.of(identifier));
   }
 
   /**
-   * A key whose {@link #qualifier()} and {@link #type()} are equivalent to this one's, but with an
-   * absent {@link #bindingIdentifier()}.
+   * A key whose {@link #qualifier()} and {@link #type()} are equivalent to this one's, but without
+   * a {@link #multibindingContributionIdentifier()}.
    */
-  Key withoutBindingIdentifier() {
+  Key withoutMultibindingContributionIdentifier() {
     return new AutoValue_Key(
-        wrappedQualifier(), wrappedType(), Optional.<BindingIdentifier>absent());
+        wrappedQualifier(), wrappedType(), Optional.<MultibindingContributionIdentifier>absent());
   }
 
   boolean isValidMembersInjectionKey() {
@@ -224,14 +248,17 @@ boolean isValidImplicitProvisionKey(final Types types) {
     }, null);
   }
 
+  /**
+   * {@inheritDoc}
+   *
+   * <p>The returned string is equal to another key's if and only if this key is {@link
+   * #equal(Object)} to it.
+   */
   @Override
   public String toString() {
-    return MoreObjects.toStringHelper(Key.class)
-        .omitNullValues()
-        .add("qualifier", qualifier().orNull())
-        .add("type", type())
-        .add("bindingIdentifier", bindingIdentifier().orNull())
-        .toString();
+    return Joiner.on(' ')
+        .skipNulls()
+        .join(qualifier().orNull(), type(), multibindingContributionIdentifier().orNull());
   }
 
   /**
@@ -252,12 +279,10 @@ public Key apply(HasKey hasKey) {
   static final class Factory {
     private final Types types;
     private final Elements elements;
-    private final MethodSignatureFormatter methodSignatureFormatter;
 
-    Factory(Types types, Elements elements, MethodSignatureFormatter methodSignatureFormatter) {
+    Factory(Types types, Elements elements) {
       this.types = checkNotNull(types);
       this.elements = checkNotNull(elements);
-      this.methodSignatureFormatter = checkNotNull(methodSignatureFormatter);
     }
 
     private DeclaredType setOf(TypeMirror elementType) {
@@ -335,7 +360,8 @@ private Key forProvidesOrProducesMethod(
       Key key = forMethod(method, keyType);
       return contributionType.equals(ContributionType.UNIQUE)
           ? key
-          : key.withBindingIdentifier(bindingIdentifier(method, contributingModule));
+          : key.withMultibindingContributionIdentifier(
+              new MultibindingContributionIdentifier(method, contributingModule));
     }
 
     /**
@@ -377,12 +403,8 @@ Key forBindsMethod(ExecutableElement method, TypeElement contributingModule) {
       Key key = forMethod(method, keyType);
       return contributionType.equals(ContributionType.UNIQUE)
           ? key
-          : key.withBindingIdentifier(bindingIdentifier(method, contributingModule));
-    }
-
-    private String bindingIdentifier(ExecutableElement method, TypeElement contributingModule) {
-      return methodSignatureFormatter.format(
-          method, Optional.of(MoreTypes.asDeclared(contributingModule.asType())));
+          : key.withMultibindingContributionIdentifier(
+              new MultibindingContributionIdentifier(method, contributingModule));
     }
 
     private TypeMirror bindingMethodKeyType(
@@ -443,35 +465,35 @@ private Key forMethod(ExecutableElement method, TypeMirror keyType) {
       return new AutoValue_Key(
           wrapOptionalInEquivalence(getQualifier(method)),
           MoreTypes.equivalence().wrap(keyType),
-          Optional.<BindingIdentifier>absent());
+          Optional.<MultibindingContributionIdentifier>absent());
     }
 
     Key forInjectConstructorWithResolvedType(TypeMirror type) {
       return new AutoValue_Key(
           Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
           MoreTypes.equivalence().wrap(type),
-          Optional.<BindingIdentifier>absent());
+          Optional.<MultibindingContributionIdentifier>absent());
     }
 
     Key forComponent(TypeMirror type) {
       return new AutoValue_Key(
           Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
           MoreTypes.equivalence().wrap(normalize(types, type)),
-          Optional.<BindingIdentifier>absent());
+          Optional.<MultibindingContributionIdentifier>absent());
     }
 
     Key forMembersInjectedType(TypeMirror type) {
       return new AutoValue_Key(
           Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
           MoreTypes.equivalence().wrap(normalize(types, type)),
-          Optional.<BindingIdentifier>absent());
+          Optional.<MultibindingContributionIdentifier>absent());
     }
 
     Key forQualifiedType(Optional<AnnotationMirror> qualifier, TypeMirror type) {
       return new AutoValue_Key(
           wrapOptionalInEquivalence(qualifier),
           MoreTypes.equivalence().wrap(normalize(types, type)),
-          Optional.<BindingIdentifier>absent());
+          Optional.<MultibindingContributionIdentifier>absent());
     }
 
     Key forProductionExecutor() {
diff --git a/compiler/src/main/java/dagger/internal/codegen/KeyFormatter.java b/compiler/src/main/java/dagger/internal/codegen/KeyFormatter.java
index b14869faf..e5d391f63 100644
--- a/compiler/src/main/java/dagger/internal/codegen/KeyFormatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/KeyFormatter.java
@@ -16,32 +16,10 @@
 
 package dagger.internal.codegen;
 
-/**
- * Formats a {@link Key} into a {@link String} suitable for use in error messages and JSON keys.
- *
- * @author Christian Gruber
- * @since 2.0
- */
+/** Formats a {@link Key} into a {@link String} suitable for use in error messages. */
 final class KeyFormatter extends Formatter<Key> {
-  
-  final MethodSignatureFormatter methodSignatureFormatter;
-
-  KeyFormatter(MethodSignatureFormatter methodSignatureFormatter) {
-    this.methodSignatureFormatter = methodSignatureFormatter;
-  }
-
   @Override
   public String format(Key key) {
-    if (key.bindingIdentifier().isPresent()) {
-      // If there's a binding identifier, use that.
-      return key.bindingIdentifier().get().toString();
-    }
-    StringBuilder builder = new StringBuilder();
-    if (key.qualifier().isPresent()) {
-      builder.append(key.qualifier().get());
-      builder.append(' ');
-    }
-    builder.append(key.type());
-    return builder.toString();
+    return key.toString();
   }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/DependencyRequestMapperTest.java b/compiler/src/test/java/dagger/internal/codegen/DependencyRequestMapperTest.java
index cd6e5a325..162305408 100644
--- a/compiler/src/test/java/dagger/internal/codegen/DependencyRequestMapperTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/DependencyRequestMapperTest.java
@@ -57,7 +57,7 @@
   @Before public void setUp() {
     this.types = compilationRule.getTypes();
     this.elements = compilationRule.getElements();
-    this.keyFactory = new Key.Factory(types, elements, new MethodSignatureFormatter(types));
+    this.keyFactory = new Key.Factory(types, elements);
     this.dependencyRequestFactory = new DependencyRequest.Factory(elements, keyFactory);
   }
 
diff --git a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
index 82d0dd196..80a1bc3e3 100644
--- a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
@@ -26,7 +26,7 @@
 import com.google.testing.compile.CompilationRule;
 import dagger.Module;
 import dagger.Provides;
-import dagger.internal.codegen.Key.BindingIdentifier;
+import dagger.internal.codegen.Key.MultibindingContributionIdentifier;
 import dagger.multibindings.ElementsIntoSet;
 import dagger.multibindings.IntoSet;
 import dagger.producers.ProducerModule;
@@ -57,14 +57,12 @@
 
   private Elements elements;
   private Types types;
-  private MethodSignatureFormatter methodSignatureFormatter;
   private Key.Factory keyFactory;
 
   @Before public void setUp() {
     this.types = compilationRule.getTypes();
     this.elements = compilationRule.getElements();
-    this.methodSignatureFormatter = new MethodSignatureFormatter(types);
-    this.keyFactory = new Key.Factory(types, elements, methodSignatureFormatter);
+    this.keyFactory = new Key.Factory(types, elements);
   }
 
   @Test public void forInjectConstructorWithResolvedType() {
@@ -72,14 +70,15 @@
         compilationRule.getElements().getTypeElement(InjectedClass.class.getCanonicalName());
     ExecutableElement constructor =
         Iterables.getOnlyElement(ElementFilter.constructorsIn(typeElement.getEnclosedElements()));
-    assertThat(
-            keyFactory.forInjectConstructorWithResolvedType(
-                constructor.getEnclosingElement().asType()))
+    Key key =
+        keyFactory.forInjectConstructorWithResolvedType(constructor.getEnclosingElement().asType());
+    assertThat(key)
         .isEqualTo(
             new AutoValue_Key(
                 Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
                 MoreTypes.equivalence().wrap(typeElement.asType()),
-                Optional.<BindingIdentifier>absent()));
+                Optional.<MultibindingContributionIdentifier>absent()));
+    assertThat(key.toString()).isEqualTo("dagger.internal.codegen.KeyTest.InjectedClass");
   }
 
   static final class InjectedClass {
@@ -93,12 +92,14 @@
         elements.getTypeElement(ProvidesMethodModule.class.getCanonicalName());
     ExecutableElement providesMethod =
         Iterables.getOnlyElement(ElementFilter.methodsIn(moduleElement.getEnclosedElements()));
-    assertThat(keyFactory.forProvidesMethod(providesMethod, moduleElement))
+    Key key = keyFactory.forProvidesMethod(providesMethod, moduleElement);
+    assertThat(key)
         .isEqualTo(
             new AutoValue_Key(
                 Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
                 MoreTypes.equivalence().wrap(stringType),
-                Optional.<BindingIdentifier>absent()));
+                Optional.<MultibindingContributionIdentifier>absent()));
+    assertThat(key.toString()).isEqualTo("java.lang.String");
   }
 
   @Module
@@ -120,6 +121,10 @@
     assertThat(MoreTypes.equivalence().wrap(key.qualifier().get().getAnnotationType()))
         .isEqualTo(MoreTypes.equivalence().wrap(qualifierElement.asType()));
     assertThat(key.wrappedType()).isEqualTo(MoreTypes.equivalence().wrap(stringType));
+    assertThat(key.toString())
+        .isEqualTo(
+            "@dagger.internal.codegen.KeyTest.TestQualifier("
+                + "{@dagger.internal.codegen.KeyTest.InnerAnnotation}) java.lang.String");
   }
 
   @Test public void qualifiedKeyEquivalents() {
@@ -138,6 +143,10 @@
     Key injectionKey = keyFactory.forQualifiedType(Optional.<AnnotationMirror>of(qualifier), type);
 
     assertThat(provisionKey).isEqualTo(injectionKey);
+    assertThat(injectionKey.toString())
+        .isEqualTo(
+            "@dagger.internal.codegen.KeyTest.TestQualifier("
+                + "{@dagger.internal.codegen.KeyTest.InnerAnnotation}) java.lang.String");
   }
 
   @Module
@@ -168,16 +177,20 @@ String provideQualifiedString() {
         elements.getTypeElement(SetProvidesMethodsModule.class.getCanonicalName());
     for (ExecutableElement providesMethod
         : ElementFilter.methodsIn(moduleElement.getEnclosedElements())) {
-      assertThat(keyFactory.forProvidesMethod(providesMethod, moduleElement))
+      Key key = keyFactory.forProvidesMethod(providesMethod, moduleElement);
+      assertThat(key)
           .isEqualTo(
               new AutoValue_Key(
                   Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
                   MoreTypes.equivalence().wrap(setOfStringsType),
                   Optional.of(
-                      BindingIdentifier.create(
-                          methodSignatureFormatter.format(
-                              providesMethod,
-                              Optional.of(MoreTypes.asDeclared(moduleElement.asType())))))));
+                      new MultibindingContributionIdentifier(providesMethod, moduleElement))));
+      assertThat(key.toString())
+          .isEqualTo(
+              String.format(
+                  "java.util.Set<java.lang.String> "
+                      + "dagger.internal.codegen.KeyTest.SetProvidesMethodsModule#%s",
+                  providesMethod.getSimpleName()));
     }
   }
 
@@ -224,6 +237,8 @@ String provideQualifiedString() {
     Key intKey = keyFactory.forProvidesMethod(intMethod, primitiveHolder);
     Key integerKey = keyFactory.forProvidesMethod(integerMethod, boxedPrimitiveHolder);
     assertThat(intKey).isEqualTo(integerKey);
+    assertThat(intKey.toString()).isEqualTo("java.lang.Integer");
+    assertThat(integerKey.toString()).isEqualTo("java.lang.Integer");
   }
 
   @Test public void forProducesMethod() {
@@ -232,12 +247,14 @@ String provideQualifiedString() {
         elements.getTypeElement(ProducesMethodsModule.class.getCanonicalName());
     for (ExecutableElement producesMethod
         : ElementFilter.methodsIn(moduleElement.getEnclosedElements())) {
-      assertThat(keyFactory.forProducesMethod(producesMethod, moduleElement))
+      Key key = keyFactory.forProducesMethod(producesMethod, moduleElement);
+      assertThat(key)
           .isEqualTo(
               new AutoValue_Key(
                   Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
                   MoreTypes.equivalence().wrap(stringType),
-                  Optional.<BindingIdentifier>absent()));
+                  Optional.<MultibindingContributionIdentifier>absent()));
+      assertThat(key.toString()).isEqualTo("java.lang.String");
     }
   }
 
@@ -260,16 +277,20 @@ String provideQualifiedString() {
         elements.getTypeElement(SetProducesMethodsModule.class.getCanonicalName());
     for (ExecutableElement producesMethod
         : ElementFilter.methodsIn(moduleElement.getEnclosedElements())) {
-      assertThat(keyFactory.forProducesMethod(producesMethod, moduleElement))
+      Key key = keyFactory.forProducesMethod(producesMethod, moduleElement);
+      assertThat(key)
           .isEqualTo(
               new AutoValue_Key(
                   Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
                   MoreTypes.equivalence().wrap(setOfStringsType),
                   Optional.of(
-                      BindingIdentifier.create(
-                          methodSignatureFormatter.format(
-                              producesMethod,
-                              Optional.of(MoreTypes.asDeclared(moduleElement.asType())))))));
+                      new MultibindingContributionIdentifier(producesMethod, moduleElement))));
+      assertThat(key.toString())
+          .isEqualTo(
+              String.format(
+                  "java.util.Set<java.lang.String> "
+                      + "dagger.internal.codegen.KeyTest.SetProducesMethodsModule#%s",
+                  producesMethod.getSimpleName()));
     }
   }
 
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java
index 2c4ee102c..e47178faa 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java
@@ -337,9 +337,8 @@ public void monitoringDependsOnProduction() {
             "  }",
             "}");
     String expectedError =
-        "@Provides @dagger.multibindings.IntoSet"
-            + " dagger.producers.monitoring.ProductionComponentMonitor.Factory"
-            + " test.TestClass.MonitoringModule.monitorFactory(test.TestClass.A) is a provision,"
+        "java.util.Set<dagger.producers.monitoring.ProductionComponentMonitor.Factory>"
+            + " test.TestClass.MonitoringModule#monitorFactory is a provision,"
             + " which cannot depend on a production.";
     assertAbout(javaSources()).that(ImmutableList.of(EXECUTOR_MODULE, component))
         .processedWith(new ComponentProcessor())
