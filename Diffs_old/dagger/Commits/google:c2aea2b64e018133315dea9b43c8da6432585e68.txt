diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/MultibindingComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingComponent.java
similarity index 77%
rename from compiler/src/it/producers-functional-tests/src/main/java/producerstest/MultibindingComponent.java
rename to compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingComponent.java
index 3c8ee5823..efbd5a593 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/MultibindingComponent.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingComponent.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2016 Google, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package producerstest;
+package producerstest.multibindings;
 
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.Produced;
@@ -21,8 +21,8 @@
 import dagger.producers.ProductionComponent;
 import java.util.Map;
 import java.util.Set;
-import producerstest.MultibindingProducerModule.PossiblyThrowingMap;
-import producerstest.MultibindingProducerModule.PossiblyThrowingSet;
+import producerstest.multibindings.Qualifiers.PossiblyThrowingMap;
+import producerstest.multibindings.Qualifiers.PossiblyThrowingSet;
 
 @ProductionComponent(modules = MultibindingProducerModule.class)
 interface MultibindingComponent {
@@ -36,11 +36,16 @@
 
   ListenableFuture<Map<Integer, String>> map();
 
-  ListenableFuture<Map<Integer, Producer<String>>> mapOfProducers();
+  ListenableFuture<Map<Integer, Producer<String>>> mapOfProducer();
+
+  ListenableFuture<Map<Integer, Produced<String>>> mapOfProduced();
 
   @PossiblyThrowingMap
   ListenableFuture<Map<Integer, String>> possiblyThrowingMap();
 
   @PossiblyThrowingMap
-  ListenableFuture<Map<Integer, Producer<String>>> possiblyThrowingMapOfProducers();
+  ListenableFuture<Map<Integer, Producer<String>>> possiblyThrowingMapOfProducer();
+
+  @PossiblyThrowingMap
+  ListenableFuture<Map<Integer, Produced<String>>> possiblyThrowingMapOfProduced();
 }
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/MultibindingProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingProducerModule.java
similarity index 72%
rename from compiler/src/it/producers-functional-tests/src/main/java/producerstest/MultibindingProducerModule.java
rename to compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingProducerModule.java
index 780ac7219..dbeefeede 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/MultibindingProducerModule.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingProducerModule.java
@@ -1,19 +1,19 @@
 /*
-* Copyright (C) 2015 Google, Inc.
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-package producerstest;
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.multibindings;
 
 import com.google.common.collect.ImmutableSet;
 import com.google.common.util.concurrent.Futures;
@@ -21,8 +21,9 @@
 import dagger.mapkeys.IntKey;
 import dagger.producers.ProducerModule;
 import dagger.producers.Produces;
+import producerstest.multibindings.Qualifiers.PossiblyThrowingMap;
+import producerstest.multibindings.Qualifiers.PossiblyThrowingSet;
 import java.util.Set;
-import javax.inject.Qualifier;
 
 import static dagger.producers.Produces.Type.MAP;
 import static dagger.producers.Produces.Type.SET;
@@ -30,12 +31,6 @@
 
 @ProducerModule
 final class MultibindingProducerModule {
-  @Qualifier
-  @interface PossiblyThrowingSet {}
-
-  @Qualifier
-  @interface PossiblyThrowingMap {}
-
   @Produces(type = SET)
   static ListenableFuture<String> futureStr() {
     return Futures.immediateFuture("foo");
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/Qualifiers.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/Qualifiers.java
new file mode 100644
index 000000000..1a41b4330
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/Qualifiers.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.multibindings;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.Documented;
+import javax.inject.Qualifier;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+final class Qualifiers {
+  @Documented
+  @Retention(RUNTIME)
+  @Qualifier
+  @interface PossiblyThrowingSet {}
+
+  @Documented
+  @Retention(RUNTIME)
+  @Qualifier
+  @interface PossiblyThrowingMap {}
+
+  private Qualifiers() {}
+}
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/MultibindingTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/multibindings/MultibindingTest.java
similarity index 68%
rename from compiler/src/it/producers-functional-tests/src/test/java/producerstest/MultibindingTest.java
rename to compiler/src/it/producers-functional-tests/src/test/java/producerstest/multibindings/MultibindingTest.java
index 3b189d4d0..15ce7592c 100644
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/MultibindingTest.java
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/multibindings/MultibindingTest.java
@@ -1,19 +1,19 @@
 /*
-* Copyright (C) 2015 Google, Inc.
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-package producerstest;
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.multibindings;
 
 import com.google.common.collect.Iterables;
 import com.google.common.util.concurrent.ListenableFuture;
@@ -89,7 +89,7 @@ public void mapBinding() throws Exception {
   public void mapOfProducerBinding() throws Exception {
     MultibindingComponent multibindingComponent =
         DaggerMultibindingComponent.builder().executor(MoreExecutors.directExecutor()).build();
-    Map<Integer, Producer<String>> map = multibindingComponent.mapOfProducers().get();
+    Map<Integer, Producer<String>> map = multibindingComponent.mapOfProducer().get();
     assertThat(map).hasSize(2);
     assertThat(map).containsKey(15);
     assertThat(map.get(15).get().get()).isEqualTo("fifteen");
@@ -97,6 +97,18 @@ public void mapOfProducerBinding() throws Exception {
     assertThat(map.get(42).get().get()).isEqualTo("forty two");
   }
 
+  @Test
+  public void mapOfProducedBinding() throws Exception {
+    MultibindingComponent multibindingComponent =
+        DaggerMultibindingComponent.builder().executor(MoreExecutors.directExecutor()).build();
+    Map<Integer, Produced<String>> map = multibindingComponent.mapOfProduced().get();
+    assertThat(map).hasSize(2);
+    assertThat(map).containsKey(15);
+    assertThat(map.get(15).get()).isEqualTo("fifteen");
+    assertThat(map).containsKey(42);
+    assertThat(map.get(42).get()).isEqualTo("forty two");
+  }
+
   @Test
   public void mapBindingWithFailures() throws Exception {
     MultibindingComponent multibindingComponent =
@@ -114,7 +126,7 @@ public void mapOfProducerBindingWithFailures() throws Exception {
     MultibindingComponent multibindingComponent =
         DaggerMultibindingComponent.builder().executor(MoreExecutors.directExecutor()).build();
     Map<Integer, Producer<String>> map =
-        multibindingComponent.possiblyThrowingMapOfProducers().get();
+        multibindingComponent.possiblyThrowingMapOfProducer().get();
     assertThat(map).hasSize(2);
     assertThat(map).containsKey(42);
     assertThat(map.get(42).get().get()).isEqualTo("forty two");
@@ -127,4 +139,23 @@ public void mapOfProducerBindingWithFailures() throws Exception {
       assertThat(e.getCause()).hasMessage("monkey");
     }
   }
+
+  @Test
+  public void mapOfProducedBindingWithFailures() throws Exception {
+    MultibindingComponent multibindingComponent =
+        DaggerMultibindingComponent.builder().executor(MoreExecutors.directExecutor()).build();
+    Map<Integer, Produced<String>> map =
+        multibindingComponent.possiblyThrowingMapOfProduced().get();
+    assertThat(map).hasSize(2);
+    assertThat(map).containsKey(42);
+    assertThat(map.get(42).get()).isEqualTo("forty two");
+    assertThat(map).containsKey(15);
+    Produced<String> produced = map.get(15);
+    try {
+      produced.get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).hasMessage("monkey");
+    }
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 34788aad9..261e1b270 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -52,6 +52,7 @@
 import dagger.internal.codegen.writer.VoidName;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
+import dagger.producers.internal.MapOfProducedProducer;
 import dagger.producers.internal.MapOfProducerProducer;
 import dagger.producers.internal.MapProducer;
 import dagger.producers.internal.Producers;
@@ -1047,7 +1048,11 @@ private Snippet initializeFactoryForContributionBinding(ContributionBinding bind
         final ClassName contributionClassName;
         switch (binding.bindingType()) {
           case PRODUCTION:
-            contributionClassName = ClassName.fromClass(MapProducer.class);
+            if (MapType.from(binding.key().type()).valuesAreTypeOf(Produced.class)) {
+              contributionClassName = ClassName.fromClass(MapOfProducedProducer.class);
+            } else {
+              contributionClassName = ClassName.fromClass(MapProducer.class);
+            }
             break;
           case PROVISION:
             contributionClassName = ClassName.fromClass(MapFactory.class);
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index 042edc5e9..77a92ed3a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -401,10 +401,39 @@ Key forQualifiedType(Optional<AnnotationMirror> qualifier, TypeMirror type) {
     /**
      * Optionally extract a {@link Key} for the underlying production binding(s) if such a
      * valid key can be inferred from the given key.  Specifically, if the key represents a
-     * {@link Map}{@code <K, V>}, a key of {@code Map<K, Producer<V>>} will be returned.
+     * {@link Map}{@code <K, V>} or {@code Map<K, Produced<V>>}, a key of
+     * {@code Map<K, Producer<V>>} will be returned.
      */
     Optional<Key> implicitMapProducerKeyFrom(Key possibleMapKey) {
-      return maybeWrapMapValue(possibleMapKey, Producer.class);
+      return maybeRewrapMapValue(possibleMapKey, Produced.class, Producer.class)
+          .or(maybeWrapMapValue(possibleMapKey, Producer.class));
+    }
+
+    /**
+     * Returns a key of {@link Map}{@code <K, NewWrappingClass<V>>} if the input key represents a
+     * {@code Map<K, CurrentWrappingClass<V>>}.
+     */
+    private Optional<Key> maybeRewrapMapValue(
+        Key possibleMapKey, Class<?> currentWrappingClass, Class<?> newWrappingClass) {
+      checkArgument(!currentWrappingClass.equals(newWrappingClass));
+      if (MapType.isMap(possibleMapKey.type())) {
+        MapType mapType = MapType.from(possibleMapKey.type());
+        if (mapType.valuesAreTypeOf(currentWrappingClass)) {
+          TypeElement wrappingElement = getClassElement(newWrappingClass);
+          if (wrappingElement == null) {
+            // This target might not be compiled with Producers, so wrappingClass might not have an
+            // associated element.
+            return Optional.absent();
+          }
+          DeclaredType wrappedValueType =
+              types.getDeclaredType(
+                  wrappingElement, mapType.unwrappedValueType(currentWrappingClass));
+          TypeMirror wrappedMapType =
+              types.getDeclaredType(getMapElement(), mapType.keyType(), wrappedValueType);
+          return Optional.of(possibleMapKey.withType(types, wrappedMapType));
+        }
+      }
+      return Optional.absent();
     }
 
     /**
diff --git a/producers/src/main/java/dagger/producers/internal/MapOfProducedProducer.java b/producers/src/main/java/dagger/producers/internal/MapOfProducedProducer.java
new file mode 100644
index 000000000..7217e8c11
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/internal/MapOfProducedProducer.java
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.internal;
+
+import com.google.common.base.Function;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Maps;
+import com.google.common.util.concurrent.AsyncFunction;
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.internal.Beta;
+import dagger.producers.Produced;
+import dagger.producers.Producer;
+import dagger.producers.monitoring.ProducerMonitor;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * A {@link Producer} implementation used to implement {@link Map} bindings. This producer returns a
+ * {@code Map<K, Produced<V>>} which is populated by calls to the delegate {@link Producer#get}
+ * methods.
+ *
+ * @author Jesse Beder
+ */
+@Beta
+public final class MapOfProducedProducer<K, V> extends AbstractProducer<Map<K, Produced<V>>> {
+  private final Producer<Map<K, Producer<V>>> mapProducerProducer;
+
+  private MapOfProducedProducer(Producer<Map<K, Producer<V>>> mapProducerProducer) {
+    this.mapProducerProducer = mapProducerProducer;
+  }
+
+  /**
+   * Returns a producer of {@code Map<K, Produced<V>>}, where the map is derived from the given map
+   * of producers by waiting for those producers' resulting futures. The iteration order mirrors the
+   * order of the input map.
+   *
+   * <p>If any of the delegate producers, or their resulting values, are null, then this producer's
+   * future will succeed and the corresponding {@code Produced<V>} will fail with a
+   * {@link NullPointerException}.
+   *
+   * <p>Canceling this future will attempt to cancel all of the component futures, and if any of the
+   * component futures fails or is canceled, this one is, too.
+   */
+  public static <K, V> MapOfProducedProducer<K, V> create(
+      Producer<Map<K, Producer<V>>> mapProducerProducer) {
+    return new MapOfProducedProducer<K, V>(mapProducerProducer);
+  }
+
+  @Override
+  public ListenableFuture<Map<K, Produced<V>>> compute(ProducerMonitor unusedMonitor) {
+    return Futures.transformAsync(
+        mapProducerProducer.get(),
+        new AsyncFunction<Map<K, Producer<V>>, Map<K, Produced<V>>>() {
+          @Override
+          public ListenableFuture<Map<K, Produced<V>>> apply(final Map<K, Producer<V>> map) {
+            // TODO(beder): Use Futures.whenAllComplete when Guava 20 is released.
+            return Futures.transform(
+                Futures.allAsList(
+                    Iterables.transform(
+                        map.entrySet(), MapOfProducedProducer.<K, V>entryUnwrapper())),
+                new Function<List<Map.Entry<K, Produced<V>>>, Map<K, Produced<V>>>() {
+                  @Override
+                  public Map<K, Produced<V>> apply(List<Map.Entry<K, Produced<V>>> entries) {
+                    return ImmutableMap.copyOf(entries);
+                  }
+                });
+          }
+        });
+  }
+
+  private static final Function<
+          Map.Entry<Object, Producer<Object>>,
+          ListenableFuture<Map.Entry<Object, Produced<Object>>>>
+      ENTRY_UNWRAPPER =
+          new Function<
+              Map.Entry<Object, Producer<Object>>,
+              ListenableFuture<Map.Entry<Object, Produced<Object>>>>() {
+            @Override
+            public ListenableFuture<Map.Entry<Object, Produced<Object>>> apply(
+                final Map.Entry<Object, Producer<Object>> entry) {
+              return Futures.transform(
+                  Producers.createFutureProduced(entry.getValue().get()),
+                  new Function<Produced<Object>, Map.Entry<Object, Produced<Object>>>() {
+                    @Override
+                    public Map.Entry<Object, Produced<Object>> apply(Produced<Object> value) {
+                      return Maps.immutableEntry(entry.getKey(), value);
+                    }
+                  });
+            }
+          };
+
+  @SuppressWarnings({"unchecked", "rawtypes"}) // bivariate implementation
+  private static <K, V>
+      Function<Map.Entry<K, Producer<V>>, ListenableFuture<Map.Entry<K, Produced<V>>>>
+          entryUnwrapper() {
+    return (Function<Map.Entry<K, Producer<V>>, ListenableFuture<Map.Entry<K, Produced<V>>>>)
+        (Function) ENTRY_UNWRAPPER;
+  }
+}
