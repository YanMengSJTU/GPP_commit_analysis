diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 3c37f1a99..d26365dc8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -61,7 +61,6 @@
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 import javax.tools.Diagnostic;
-import javax.tools.Diagnostic.Kind;
 
 import static com.google.common.base.CaseFormat.LOWER_CAMEL;
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
@@ -131,7 +130,7 @@
   protected final Elements elements;
   protected final Types types;
   protected final Key.Factory keyFactory;
-  protected final Kind nullableValidationType;
+  protected final CompilerOptions compilerOptions;
   protected final ClassName name;
   protected final BindingGraph graph;
   protected final ImmutableMap<ComponentDescriptor, String> subcomponentImplNames;
@@ -160,14 +159,14 @@
       Types types,
       Elements elements,
       Key.Factory keyFactory,
-      Diagnostic.Kind nullableValidationType,
+      CompilerOptions compilerOptions,
       ClassName name,
       BindingGraph graph,
       ImmutableMap<ComponentDescriptor, String> subcomponentImplNames) {
     this.types = types;
     this.elements = elements;
     this.keyFactory = keyFactory;
-    this.nullableValidationType = nullableValidationType;
+    this.compilerOptions = compilerOptions;
     this.name = name;
     this.graph = graph;
     this.subcomponentImplNames = subcomponentImplNames;
@@ -867,7 +866,7 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
           // What should we do?
           CodeBlock getMethodBody =
               binding.nullableType().isPresent()
-                      || nullableValidationType.equals(Diagnostic.Kind.WARNING)
+                      || compilerOptions.nullableValidationKind().equals(Diagnostic.Kind.WARNING)
                   ? CodeBlocks.format("return $L;", callFactoryMethod)
                   : CodeBlocks.format(
                       Joiner.on('\n')
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index d26f02736..90a897d0f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -108,10 +108,8 @@
 
   private final Elements elements;
   private final Types types;
-  private final CompilerOptions options;
+  private final CompilerOptions compilerOptions;
   private final InjectBindingRegistry injectBindingRegistry;
-  private final ValidationType scopeCycleValidationType;
-  private final Diagnostic.Kind nullableValidationType;
   private final HasSourceElementFormatter hasSourceElementFormatter;
   private final MethodSignatureFormatter methodSignatureFormatter;
   private final DependencyRequestFormatter dependencyRequestFormatter;
@@ -121,10 +119,8 @@
   BindingGraphValidator(
       Elements elements,
       Types types,
-      CompilerOptions options,
+      CompilerOptions compilerOptions,
       InjectBindingRegistry injectBindingRegistry,
-      ValidationType scopeCycleValidationType,
-      Diagnostic.Kind nullableValidationType,
       HasSourceElementFormatter hasSourceElementFormatter,
       MethodSignatureFormatter methodSignatureFormatter,
       DependencyRequestFormatter dependencyRequestFormatter,
@@ -132,10 +128,8 @@
       Key.Factory keyFactory) {
     this.elements = elements;
     this.types = types;
-    this.options = options;
+    this.compilerOptions = compilerOptions;
     this.injectBindingRegistry = injectBindingRegistry;
-    this.scopeCycleValidationType = scopeCycleValidationType;
-    this.nullableValidationType = nullableValidationType;
     this.hasSourceElementFormatter = hasSourceElementFormatter;
     this.methodSignatureFormatter = methodSignatureFormatter;
     this.dependencyRequestFormatter = dependencyRequestFormatter;
@@ -313,7 +307,7 @@ private boolean validateResolvedBinding(
             reportProviderMayNotDependOnProducer(path);
             return false;
           }
-          if (options.usesProducers()) {
+          if (compilerOptions.usesProducers()) {
             Key productionImplementationExecutorKey =
                 keyFactory.forProductionImplementationExecutor();
             // only forbid depending on the production executor if it's not the Dagger-specific
@@ -442,7 +436,7 @@ private boolean validateNullability(
               nullableToNonNullable(typeName, hasSourceElementFormatter.format(binding))
                   + "\n at: "
                   + dependencyRequestFormatter.format(request),
-              nullableValidationType,
+              compilerOptions.nullableValidationKind(),
               request.requestElement());
           valid = false;
         }
@@ -621,9 +615,11 @@ private void validateComponentHierarchy(
         componentStack.push(componentType);
         appendIndentedComponentsList(message, componentStack);
         componentStack.pop();
-        reportBuilder.addItem(message.toString(),
-            scopeCycleValidationType.diagnosticKind().get(),
-            rootComponent, getAnnotationMirror(rootComponent, Component.class).get());
+        reportBuilder.addItem(
+            message.toString(),
+            compilerOptions.scopeCycleValidationType().diagnosticKind().get(),
+            rootComponent,
+            getAnnotationMirror(rootComponent, Component.class).get());
       } else {
         Optional<AnnotationMirror> componentAnnotation =
             getAnnotationMirror(componentType, Component.class);
@@ -653,7 +649,7 @@ private void validateDependencyScopes() {
       if (!scopes.isEmpty()) {
         Scope singletonScope = Scope.singletonScope(elements);
         // Dagger 1.x scope compatibility requires this be suppress-able.
-        if (scopeCycleValidationType.diagnosticKind().isPresent()
+        if (compilerOptions.scopeCycleValidationType().diagnosticKind().isPresent()
             && scopes.contains(singletonScope)) {
           // Singleton is a special-case representing the longest lifetime, and therefore
           // @Singleton components may not depend on scoped components
@@ -661,8 +657,9 @@ private void validateDependencyScopes() {
             StringBuilder message = new StringBuilder(
                 "This @Singleton component cannot depend on scoped components:\n");
             appendIndentedComponentsList(message, scopedDependencies);
-            reportBuilder.addItem(message.toString(),
-                scopeCycleValidationType.diagnosticKind().get(),
+            reportBuilder.addItem(
+                message.toString(),
+                compilerOptions.scopeCycleValidationType().diagnosticKind().get(),
                 descriptor.componentDefinitionType(),
                 descriptor.componentAnnotation());
           }
@@ -682,7 +679,7 @@ private void validateDependencyScopes() {
               descriptor.componentAnnotation());
         } else {
           // Dagger 1.x scope compatibility requires this be suppress-able.
-          if (!scopeCycleValidationType.equals(ValidationType.NONE)) {
+          if (!compilerOptions.scopeCycleValidationType().equals(ValidationType.NONE)) {
             validateScopeHierarchy(descriptor.componentDefinitionType(),
                 descriptor.componentDefinitionType(),
                 new ArrayDeque<ImmutableSet<Scope>>(),
@@ -768,10 +765,10 @@ private void validateScopeHierarchy(TypeElement rootComponent,
         message.append(rootComponent.getQualifiedName());
         message.append(" depends on scoped components in a non-hierarchical scope ordering:\n");
         appendIndentedComponentsList(message, scopedDependencyStack);
-        if (scopeCycleValidationType.diagnosticKind().isPresent()) {
+        if (compilerOptions.scopeCycleValidationType().diagnosticKind().isPresent()) {
           reportBuilder.addItem(
               message.toString(),
-              scopeCycleValidationType.diagnosticKind().get(),
+              compilerOptions.scopeCycleValidationType().diagnosticKind().get(),
               rootComponent,
               getAnnotationMirror(rootComponent, Component.class)
                   .or(getAnnotationMirror(rootComponent, ProductionComponent.class))
diff --git a/compiler/src/main/java/dagger/internal/codegen/CompilerOptions.java b/compiler/src/main/java/dagger/internal/codegen/CompilerOptions.java
index f1bfc84db..aa92fa5c5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/CompilerOptions.java
+++ b/compiler/src/main/java/dagger/internal/codegen/CompilerOptions.java
@@ -15,18 +15,130 @@
  */
 package dagger.internal.codegen;
 
+import com.google.common.base.Ascii;
 import dagger.producers.Produces;
+import java.util.EnumSet;
+import java.util.Map;
+import java.util.Set;
+import javax.annotation.processing.ProcessingEnvironment;
 import javax.lang.model.util.Elements;
+import javax.tools.Diagnostic;
 
 /** A collection of options that dictate how the compiler will run. */
 final class CompilerOptions {
   private final boolean usesProducers;
+  private final Diagnostic.Kind nullableValidationKind;
+  private final Diagnostic.Kind privateMemberValidationKind;
+  private final Diagnostic.Kind staticMemberValidationKind;
+  private final ValidationType scopeCycleValidationType;
 
-  CompilerOptions(Elements elements) {
-    this.usesProducers = elements.getTypeElement(Produces.class.getCanonicalName()) != null;
+  CompilerOptions(ProcessingEnvironment processingEnv, Elements elements) {
+    this(
+        elements.getTypeElement(Produces.class.getCanonicalName()) != null,
+        nullableValidationType(processingEnv).diagnosticKind().get(),
+        privateMemberValidationType(processingEnv).diagnosticKind().get(),
+        staticMemberValidationType(processingEnv).diagnosticKind().get(),
+        scopeValidationType(processingEnv));
+  }
+
+  CompilerOptions(
+      boolean usesProducers,
+      Diagnostic.Kind nullableValidationKind,
+      Diagnostic.Kind privateMemberValidationKind,
+      Diagnostic.Kind staticMemberValidationKind,
+      ValidationType scopeCycleValidationType) {
+    this.usesProducers = usesProducers;
+    this.nullableValidationKind = nullableValidationKind;
+    this.privateMemberValidationKind = privateMemberValidationKind;
+    this.staticMemberValidationKind = staticMemberValidationKind;
+    this.scopeCycleValidationType = scopeCycleValidationType;
   }
 
   boolean usesProducers() {
     return usesProducers;
   }
+
+  Diagnostic.Kind nullableValidationKind() {
+    return nullableValidationKind;
+  }
+
+  Diagnostic.Kind privateMemberValidationKind() {
+    return privateMemberValidationKind;
+  }
+
+  Diagnostic.Kind staticMemberValidationKind() {
+    return staticMemberValidationKind;
+  }
+
+  ValidationType scopeCycleValidationType() {
+    return scopeCycleValidationType;
+  }
+
+  static final String DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY =
+      "dagger.disableInterComponentScopeValidation";
+
+  static final String NULLABLE_VALIDATION_KEY = "dagger.nullableValidation";
+
+  static final String PRIVATE_MEMBER_VALIDATION_TYPE_KEY = "dagger.privateMemberValidation";
+
+  static final String STATIC_MEMBER_VALIDATION_TYPE_KEY = "dagger.staticMemberValidation";
+
+  private static ValidationType scopeValidationType(ProcessingEnvironment processingEnv) {
+    return valueOf(
+        processingEnv,
+        DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY,
+        ValidationType.ERROR,
+        EnumSet.allOf(ValidationType.class));
+  }
+
+  private static ValidationType nullableValidationType(ProcessingEnvironment processingEnv) {
+    return valueOf(
+        processingEnv,
+        NULLABLE_VALIDATION_KEY,
+        ValidationType.ERROR,
+        EnumSet.of(ValidationType.ERROR, ValidationType.WARNING));
+  }
+
+  private static ValidationType privateMemberValidationType(ProcessingEnvironment processingEnv) {
+    return valueOf(
+        processingEnv,
+        PRIVATE_MEMBER_VALIDATION_TYPE_KEY,
+        ValidationType.ERROR,
+        EnumSet.of(ValidationType.ERROR, ValidationType.WARNING));
+  }
+
+  private static ValidationType staticMemberValidationType(ProcessingEnvironment processingEnv) {
+    return valueOf(
+        processingEnv,
+        STATIC_MEMBER_VALIDATION_TYPE_KEY,
+        ValidationType.ERROR,
+        EnumSet.of(ValidationType.ERROR, ValidationType.WARNING));
+  }
+
+  private static <T extends Enum<T>> T valueOf(
+      ProcessingEnvironment processingEnv, String key, T defaultValue, Set<T> validValues) {
+    Map<String, String> options = processingEnv.getOptions();
+    if (options.containsKey(key)) {
+      try {
+        T type =
+            Enum.valueOf(defaultValue.getDeclaringClass(), Ascii.toUpperCase(options.get(key)));
+        if (!validValues.contains(type)) {
+          throw new IllegalArgumentException(); // let handler below print out good msg.
+        }
+        return type;
+      } catch (IllegalArgumentException e) {
+        processingEnv
+            .getMessager()
+            .printMessage(
+                Diagnostic.Kind.ERROR,
+                "Processor option -A"
+                    + key
+                    + " may only have the values "
+                    + validValues
+                    + " (case insensitive), found: "
+                    + options.get(key));
+      }
+    }
+    return defaultValue;
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index 2b47e3baa..b1b530b09 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -24,7 +24,6 @@
 import javax.lang.model.element.Element;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
-import javax.tools.Diagnostic;
 
 /**
  * Generates the implementation of the abstract types annotated with {@link Component}.
@@ -36,19 +35,19 @@
   private final Types types;
   private final Elements elements;
   private final Key.Factory keyFactory;
-  private final Diagnostic.Kind nullableValidationType;
+  private final CompilerOptions compilerOptions;
 
   ComponentGenerator(
       Filer filer,
       Elements elements,
       Types types,
       Key.Factory keyFactory,
-      Diagnostic.Kind nullableValidationType) {
+      CompilerOptions compilerOptions) {
     super(filer, elements);
     this.types = types;
     this.elements = elements;
     this.keyFactory = keyFactory;
-    this.nullableValidationType = nullableValidationType;
+    this.compilerOptions = compilerOptions;
   }
 
   @Override
@@ -68,8 +67,7 @@ ClassName nameGeneratedType(BindingGraph input) {
   @Override
   Optional<TypeSpec.Builder> write(ClassName componentName, BindingGraph input) {
     return Optional.of(
-        new ComponentWriter(
-                types, elements, keyFactory, nullableValidationType, componentName, input)
+        new ComponentWriter(types, elements, keyFactory, compilerOptions, componentName, input)
             .write());
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index 9064f09a8..90126f9db 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -17,22 +17,15 @@
 
 import com.google.auto.common.BasicAnnotationProcessor;
 import com.google.auto.service.AutoService;
-import com.google.common.base.Ascii;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
-import java.util.EnumSet;
-import java.util.Map;
 import java.util.Set;
 import javax.annotation.processing.Filer;
 import javax.annotation.processing.Messager;
-import javax.annotation.processing.ProcessingEnvironment;
 import javax.annotation.processing.Processor;
 import javax.lang.model.SourceVersion;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
-import javax.tools.Diagnostic;
-
-import static javax.tools.Diagnostic.Kind.ERROR;
 
 /**
  * The annotation processor responsible for generating the classes that drive the Dagger 2.0
@@ -57,11 +50,10 @@ public SourceVersion getSupportedSourceVersion() {
   @Override
   public Set<String> getSupportedOptions() {
     return ImmutableSet.of(
-        DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY,
-        NULLABLE_VALIDATION_KEY,
-        PRIVATE_MEMBER_VALIDATION_TYPE_KEY,
-        STATIC_MEMBER_VALIDATION_TYPE_KEY
-    );
+        CompilerOptions.DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY,
+        CompilerOptions.NULLABLE_VALIDATION_KEY,
+        CompilerOptions.PRIVATE_MEMBER_VALIDATION_TYPE_KEY,
+        CompilerOptions.STATIC_MEMBER_VALIDATION_TYPE_KEY);
   }
 
   @Override
@@ -71,11 +63,7 @@ public SourceVersion getSupportedSourceVersion() {
     Elements elements = processingEnv.getElementUtils();
     Filer filer = processingEnv.getFiler();
 
-    CompilerOptions options = new CompilerOptions(elements);
-
-    // TODO(beder): Move these diagnostic options to CompilerOptions.
-    Diagnostic.Kind nullableDiagnosticType =
-        nullableValidationType(processingEnv).diagnosticKind().get();
+    CompilerOptions compilerOptions = new CompilerOptions(processingEnv, elements);
 
     MethodSignatureFormatter methodSignatureFormatter = new MethodSignatureFormatter(types);
     HasSourceElementFormatter hasSourceElementFormatter =
@@ -84,12 +72,8 @@ public SourceVersion getSupportedSourceVersion() {
     KeyFormatter keyFormatter = new KeyFormatter(methodSignatureFormatter);
 
     InjectConstructorValidator injectConstructorValidator = new InjectConstructorValidator();
-    InjectFieldValidator injectFieldValidator = new InjectFieldValidator(
-        privateMemberValidationType(processingEnv).diagnosticKind().get(),
-        staticMemberValidationType(processingEnv).diagnosticKind().get());
-    InjectMethodValidator injectMethodValidator = new InjectMethodValidator(
-        privateMemberValidationType(processingEnv).diagnosticKind().get(),
-        staticMemberValidationType(processingEnv).diagnosticKind().get());
+    InjectFieldValidator injectFieldValidator = new InjectFieldValidator(compilerOptions);
+    InjectMethodValidator injectMethodValidator = new InjectMethodValidator(compilerOptions);
     MembersInjectedTypeValidator membersInjectedTypeValidator =
         new MembersInjectedTypeValidator(injectFieldValidator, injectMethodValidator);
     ModuleValidator moduleValidator =
@@ -110,10 +94,10 @@ public SourceVersion getSupportedSourceVersion() {
     MultibindingsValidator multibindingsValidator =
         new MultibindingsValidator(elements, keyFactory, keyFormatter, methodSignatureFormatter);
 
-    this.factoryGenerator = new FactoryGenerator(filer, elements, nullableDiagnosticType);
+    this.factoryGenerator = new FactoryGenerator(filer, elements, compilerOptions);
     this.membersInjectorGenerator = new MembersInjectorGenerator(filer, elements);
     ComponentGenerator componentGenerator =
-        new ComponentGenerator(filer, elements, types, keyFactory, nullableDiagnosticType);
+        new ComponentGenerator(filer, elements, types, keyFactory, compilerOptions);
     ProducerFactoryGenerator producerFactoryGenerator =
         new ProducerFactoryGenerator(filer, elements);
     MonitoringModuleGenerator monitoringModuleGenerator =
@@ -168,10 +152,8 @@ public SourceVersion getSupportedSourceVersion() {
         new BindingGraphValidator(
             elements,
             types,
-            options,
+            compilerOptions,
             injectBindingRegistry,
-            scopeValidationType(processingEnv),
-            nullableDiagnosticType,
             hasSourceElementFormatter,
             methodSignatureFormatter,
             dependencyRequestFormatter,
@@ -229,64 +211,4 @@ protected void postProcess() {
       e.printMessageTo(processingEnv.getMessager());
     }
   }
-
-  private static final String DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY =
-      "dagger.disableInterComponentScopeValidation";
-
-  private static final String NULLABLE_VALIDATION_KEY = "dagger.nullableValidation";
-
-  private static final String PRIVATE_MEMBER_VALIDATION_TYPE_KEY =
-      "dagger.privateMemberValidation";
-
-  private static final String STATIC_MEMBER_VALIDATION_TYPE_KEY =
-      "dagger.staticMemberValidation";
-
-  private static ValidationType scopeValidationType(ProcessingEnvironment processingEnv) {
-    return valueOf(processingEnv,
-        DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY,
-        ValidationType.ERROR,
-        EnumSet.allOf(ValidationType.class));
-  }
-
-  private static ValidationType nullableValidationType(ProcessingEnvironment processingEnv) {
-    return valueOf(processingEnv,
-        NULLABLE_VALIDATION_KEY,
-        ValidationType.ERROR,
-        EnumSet.of(ValidationType.ERROR, ValidationType.WARNING));
-  }
-
-  private static ValidationType privateMemberValidationType(ProcessingEnvironment processingEnv) {
-    return valueOf(processingEnv,
-        PRIVATE_MEMBER_VALIDATION_TYPE_KEY,
-        ValidationType.ERROR,
-        EnumSet.of(ValidationType.ERROR, ValidationType.WARNING));
-  }
-
-  private static ValidationType staticMemberValidationType(ProcessingEnvironment processingEnv) {
-    return valueOf(processingEnv,
-        STATIC_MEMBER_VALIDATION_TYPE_KEY,
-        ValidationType.ERROR,
-        EnumSet.of(ValidationType.ERROR, ValidationType.WARNING));
-  }
-
-  private static <T extends Enum<T>> T valueOf(ProcessingEnvironment processingEnv, String key,
-      T defaultValue, Set<T> validValues) {
-    Map<String, String> options = processingEnv.getOptions();
-    if (options.containsKey(key)) {
-      try {
-        T type = Enum.valueOf(
-            defaultValue.getDeclaringClass(),
-            Ascii.toUpperCase(options.get(key)));
-        if (!validValues.contains(type)) {
-          throw new IllegalArgumentException(); // let handler below print out good msg.
-        }
-        return type;
-      } catch (IllegalArgumentException e) {
-        processingEnv.getMessager().printMessage(ERROR, "Processor option -A"
-            + key + " may only have the values " + validValues
-            + " (case insensitive), found: " + options.get(key));
-      }
-    }
-    return defaultValue;
-  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
index 6a7750fa2..d6492f41d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
@@ -35,7 +35,6 @@
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
-import javax.tools.Diagnostic.Kind;
 
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static com.squareup.javapoet.TypeSpec.classBuilder;
@@ -54,14 +53,14 @@
       Types types,
       Elements elements,
       Key.Factory keyFactory,
-      Kind nullableValidationType,
+      CompilerOptions compilerOptions,
       ClassName name,
       BindingGraph graph) {
     super(
         types,
         elements,
         keyFactory,
-        nullableValidationType,
+        compilerOptions,
         name,
         graph,
         new UniqueSubcomponentNamesGenerator(graph).generate());
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index 94ec0e5af..e4a5761bb 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -73,14 +73,11 @@
  */
 final class FactoryGenerator extends JavaPoetSourceFileGenerator<ProvisionBinding> {
 
-  private final Diagnostic.Kind nullableValidationType;
+  private final CompilerOptions compilerOptions;
 
-  FactoryGenerator(
-      Filer filer,
-      Elements elements,
-      Diagnostic.Kind nullableValidationType) {
+  FactoryGenerator(Filer filer, Elements elements, CompilerOptions compilerOptions) {
     super(filer, elements);
-    this.nullableValidationType = nullableValidationType;
+    this.compilerOptions = compilerOptions;
   }
 
   @Override
@@ -242,7 +239,7 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
             "return $T.<$T>singleton($L)",
             Collections.class, paramTypeName, providesMethodInvocation);
       } else if (binding.nullableType().isPresent()
-          || nullableValidationType.equals(Diagnostic.Kind.WARNING)) {
+          || compilerOptions.nullableValidationKind().equals(Diagnostic.Kind.WARNING)) {
         if (binding.nullableType().isPresent()) {
           getMethodBuilder.addAnnotation((ClassName) TypeName.get(binding.nullableType().get()));
         }
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectFieldValidator.java b/compiler/src/main/java/dagger/internal/codegen/InjectFieldValidator.java
index 96822b190..198ae7136 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectFieldValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectFieldValidator.java
@@ -21,7 +21,6 @@
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.VariableElement;
-import javax.tools.Diagnostic.Kind;
 
 import static dagger.internal.codegen.ErrorMessages.FINAL_INJECT_FIELD;
 import static dagger.internal.codegen.ErrorMessages.MULTIPLE_QUALIFIERS;
@@ -40,13 +39,10 @@
  * @since 2.0
  */
 final class InjectFieldValidator {
-  private Kind privateMemberValidationKind;
-  private Kind staticMemberValidationKind;
-  
-  public InjectFieldValidator(
-      Kind privateMemberValidationKind, Kind staticMemberValidationKind) {
-    this.privateMemberValidationKind = privateMemberValidationKind;
-    this.staticMemberValidationKind = staticMemberValidationKind;
+  private CompilerOptions compilerOptions;
+
+  public InjectFieldValidator(CompilerOptions compilerOptions) {
+    this.compilerOptions = compilerOptions;
   }
 
   ValidationReport<VariableElement> validate(VariableElement fieldElement) {
@@ -57,11 +53,13 @@ public InjectFieldValidator(
     }
 
     if (modifiers.contains(PRIVATE)) {
-      builder.addItem(PRIVATE_INJECT_FIELD, privateMemberValidationKind, fieldElement);
+      builder.addItem(
+          PRIVATE_INJECT_FIELD, compilerOptions.privateMemberValidationKind(), fieldElement);
     }
 
     if (modifiers.contains(STATIC)) {
-      builder.addItem(STATIC_INJECT_FIELD, staticMemberValidationKind, fieldElement);
+      builder.addItem(
+          STATIC_INJECT_FIELD, compilerOptions.staticMemberValidationKind(), fieldElement);
     }
     
     ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(fieldElement);
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/InjectMethodValidator.java
index b151ee4fa..3ad6e7d74 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectMethodValidator.java
@@ -22,7 +22,6 @@
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.VariableElement;
-import javax.tools.Diagnostic.Kind;
 
 import static dagger.internal.codegen.ErrorMessages.ABSTRACT_INJECT_METHOD;
 import static dagger.internal.codegen.ErrorMessages.GENERIC_INJECT_METHOD;
@@ -42,13 +41,10 @@
  * @since 2.0
  */
 final class InjectMethodValidator {
-  private Kind privateMemberValidationKind;
-  private Kind staticMemberValidationKind;
-  
-  public InjectMethodValidator(
-      Kind privateMemberValidationKind, Kind staticMemberValidationKind) {
-    this.privateMemberValidationKind = privateMemberValidationKind;
-    this.staticMemberValidationKind = staticMemberValidationKind;
+  private CompilerOptions compilerOptions;
+
+  public InjectMethodValidator(CompilerOptions compilerOptions) {
+    this.compilerOptions = compilerOptions;
   }
 
   ValidationReport<ExecutableElement> validate(ExecutableElement methodElement) {
@@ -59,11 +55,13 @@ public InjectMethodValidator(
     }
 
     if (modifiers.contains(PRIVATE)) {
-      builder.addItem(PRIVATE_INJECT_METHOD, privateMemberValidationKind, methodElement);
+      builder.addItem(
+          PRIVATE_INJECT_METHOD, compilerOptions.privateMemberValidationKind(), methodElement);
     }
     
     if (modifiers.contains(STATIC)) {
-      builder.addItem(STATIC_INJECT_METHOD, staticMemberValidationKind, methodElement);
+      builder.addItem(
+          STATIC_INJECT_METHOD, compilerOptions.staticMemberValidationKind(), methodElement);
     }
 
     if (!methodElement.getTypeParameters().isEmpty()) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
index 118713147..61a7fb638 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
@@ -64,7 +64,7 @@ public SubcomponentWriter(
         parent.types,
         parent.elements,
         parent.keyFactory,
-        parent.nullableValidationType,
+        parent.compilerOptions,
         subcomponentName(parent, subgraph),
         subgraph,
         parent.subcomponentImplNames);
