diff --git a/compiler/src/main/java/dagger/internal/codegen/BindsMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindsMethodValidator.java
index 2184a8b92..700f35c5b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindsMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindsMethodValidator.java
@@ -37,8 +37,8 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_IN_MODULE;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_TYPE_PARAMETER;
-import static dagger.internal.codegen.ErrorMessages.BIND_METHOD_NOT_ABSTRACT;
-import static dagger.internal.codegen.ErrorMessages.BIND_METHOD_ONE_ASSIGNABLE_PARAMETER;
+import static dagger.internal.codegen.ErrorMessages.BINDS_METHOD_NOT_ABSTRACT;
+import static dagger.internal.codegen.ErrorMessages.BINDS_METHOD_ONE_ASSIGNABLE_PARAMETER;
 import static dagger.internal.codegen.Validation.validateMethodQualifiers;
 import static dagger.internal.codegen.Validation.validateReturnType;
 import static dagger.internal.codegen.Validation.validateUncheckedThrows;
@@ -88,7 +88,7 @@
 
       Set<Modifier> modifiers = bindsMethodElement.getModifiers();
       if (!modifiers.contains(ABSTRACT)) {
-        builder.addError(formatErrorMessage(BIND_METHOD_NOT_ABSTRACT), bindsMethodElement);
+        builder.addError(formatErrorMessage(BINDS_METHOD_NOT_ABSTRACT), bindsMethodElement);
       }
       TypeMirror returnType = bindsMethodElement.getReturnType();
       validateReturnType(Binds.class, builder, returnType);
@@ -98,11 +98,11 @@
         VariableElement parameter = Iterables.getOnlyElement(parameters);
         if (!types.isAssignable(parameter.asType(), returnType)) {
           builder.addError(
-              formatErrorMessage(BIND_METHOD_ONE_ASSIGNABLE_PARAMETER), bindsMethodElement);
+              formatErrorMessage(BINDS_METHOD_ONE_ASSIGNABLE_PARAMETER), bindsMethodElement);
         }
       } else {
         builder.addError(
-            formatErrorMessage(BIND_METHOD_ONE_ASSIGNABLE_PARAMETER), bindsMethodElement);
+            formatErrorMessage(BINDS_METHOD_ONE_ASSIGNABLE_PARAMETER), bindsMethodElement);
       }
 
       validateUncheckedThrows(elements, types, bindsMethodElement, Binds.class, builder);
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index b8a439417..6ecf713e6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -158,15 +158,15 @@ static String inconsistentMapKeyAnnotationsError(String key) {
 
   static final String BINDING_METHOD_ABSTRACT = "@%s methods cannot be abstract";
 
-  static final String BIND_METHOD_NOT_ABSTRACT = "@Bind methods must be abstract";
+  static final String BINDS_METHOD_NOT_ABSTRACT = "@Binds methods must be abstract";
 
   static final String BINDING_METHOD_PRIVATE = "@%s methods cannot be private";
 
   static final String BINDING_METHOD_TYPE_PARAMETER =
       "@%s methods may not have type parameters.";
 
-  static final String BIND_METHOD_ONE_ASSIGNABLE_PARAMETER =
-      "@Bind methods must have only one parameter whose type is assignable to the return type";
+  static final String BINDS_METHOD_ONE_ASSIGNABLE_PARAMETER =
+      "@Binds methods must have only one parameter whose type is assignable to the return type";
 
   static final String BINDING_METHOD_NOT_IN_MODULE =
       "@%s methods can only be present within a @%s";
@@ -184,7 +184,7 @@ static String inconsistentMapKeyAnnotationsError(String key) {
       "Cannot have more than one @%s method with the same name in a single module";
 
   static final String INCOMPATIBLE_MODULE_METHODS =
-      "A @%1$s may contain non-static @%2$s methods or @Bind methods,"
+      "A @%1$s may contain non-static @%2$s methods or @Binds methods,"
           + " but not both at the same time.  (Static @%2$s may be used with either.)";
 
   static final String MODULES_WITH_TYPE_PARAMS_MUST_BE_ABSTRACT =
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index e7d9685e1..e23c4eb25 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -53,7 +53,7 @@ static boolean requiresAPassedInstance(Elements elements, TypeElement typeElemen
     boolean foundInstanceMethod = false;
     for (ExecutableElement method : methods) {
       if (method.getModifiers().contains(ABSTRACT) && !isAnnotationPresent(method, Binds.class)) {
-        /* We found an abstract method that isn't a @Bind method.  That automatically means that
+        /* We found an abstract method that isn't a @Binds method.  That automatically means that
          * a user will have to provide an instance because we don't know which subclass to use. */
         return true;
       } else if (!method.getModifiers().contains(STATIC)
diff --git a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
index acc6bb6e4..d32aac54f 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
@@ -1314,7 +1314,7 @@ public void genericSubclassedModule() {
         .withErrorContaining("Produced may only be injected in @Produces methods");
   }
 
-  private static final String BIND_METHOD = "@Binds abstract Foo bindFoo(FooImpl impl);";
+  private static final String BINDS_METHOD = "@Binds abstract Foo bindFoo(FooImpl impl);";
   private static final String STATIC_PROVIDES_METHOD =
       "@Provides static Bar provideBar() { return new Bar(); }";
   private static final String INSTANCE_PROVIDES_METHOD =
@@ -1323,10 +1323,10 @@ public void genericSubclassedModule() {
 
   @Test
   public void moduleMethodPermutations() {
-    assertThatMethodCombination(BIND_METHOD, INSTANCE_PROVIDES_METHOD)
+    assertThatMethodCombination(BINDS_METHOD, INSTANCE_PROVIDES_METHOD)
         .failsToCompile()
         .withErrorContaining("not both at the same time");
-    assertThatMethodCombination(BIND_METHOD, STATIC_PROVIDES_METHOD).compilesWithoutError();
+    assertThatMethodCombination(BINDS_METHOD, STATIC_PROVIDES_METHOD).compilesWithoutError();
     assertThatMethodCombination(INSTANCE_PROVIDES_METHOD, SOME_ABSTRACT_METHOD)
         .compilesWithoutError();
   }
diff --git a/core/src/main/java/dagger/internal/DoubleCheck.java b/core/src/main/java/dagger/internal/DoubleCheck.java
index 513722929..73d4ee6a3 100644
--- a/core/src/main/java/dagger/internal/DoubleCheck.java
+++ b/core/src/main/java/dagger/internal/DoubleCheck.java
@@ -57,7 +57,7 @@ public T get() {
   public static <T> Provider<T> provider(Provider<T> delegate) {
     checkNotNull(delegate);
     if (delegate instanceof DoubleCheck) {
-      /* This should be a rare case, but if we have a scoped @Bind that delegates to a scoped
+      /* This should be a rare case, but if we have a scoped @Binds that delegates to a scoped
        * binding, we shouldn't cache the value again. */
       return delegate;
     }
