diff --git a/compiler/src/main/java/dagger/internal/codegen/AnnotationMirrors.java b/compiler/src/main/java/dagger/internal/codegen/AnnotationMirrors.java
index d4eb51102..bd9865fd2 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AnnotationMirrors.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AnnotationMirrors.java
@@ -61,6 +61,7 @@
         simplifyAnnotationValueMap(elements.getElementValuesWithDefaults(annotationMirror));
     ImmutableList.Builder<TypeMirror> builder = ImmutableList.builder();
 
+    @SuppressWarnings("unchecked") // that's the whole point of this method
     List<? extends AnnotationValue> typeValues =
         (List<? extends AnnotationValue>) valueMap.get(attributeName).getValue();
     for (AnnotationValue typeValue : typeValues) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
index cbe2d8b06..1449649e7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
@@ -59,5 +59,14 @@
     return getAttributeAsListOfTypes(elements, moduleAnnotation, INCLUDES_ATTRIBUTE);
   }
 
+  private static final String INJECTS_ATTRIBUTE = "injects";
+
+  static ImmutableList<TypeMirror> getModuleInjects(Elements elements,
+      AnnotationMirror moduleAnnotation) {
+    checkNotNull(elements);
+    checkNotNull(moduleAnnotation);
+    return getAttributeAsListOfTypes(elements, moduleAnnotation, INJECTS_ATTRIBUTE);
+  }
+
   private ConfigurationAnnotations() {}
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleInjectsProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleInjectsProcessor.java
new file mode 100644
index 000000000..1e185b2e4
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleInjectsProcessor.java
@@ -0,0 +1,101 @@
+package dagger.internal.codegen;
+
+import com.google.auto.common.SuperficialValidation;
+import com.google.common.annotations.GoogleInternal;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import dagger.Component;
+import dagger.Module;
+import dagger.ObjectGraph;
+import dagger.internal.codegen.writer.ClassName;
+import dagger.internal.codegen.writer.InterfaceWriter;
+import dagger.internal.codegen.writer.JavaWriter;
+import dagger.internal.codegen.writer.TypeNames;
+import java.io.IOException;
+import java.util.Set;
+import javax.annotation.Generated;
+import javax.annotation.processing.AbstractProcessor;
+import javax.annotation.processing.RoundEnvironment;
+import javax.lang.model.SourceVersion;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.TypeMirror;
+import javax.tools.Diagnostic.Kind;
+
+import static com.google.auto.common.MoreElements.asType;
+import static com.google.auto.common.MoreElements.getAnnotationMirror;
+import static dagger.internal.codegen.ConfigurationAnnotations.getModuleInjects;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.PUBLIC;
+
+/**
+ * A simple annotation processor that generates a {@link Component}-style interface from
+ * {@link Module#injects} to be used as a migration aid in the transition from {@link ObjectGraph}
+ * to components.  The generated interface is not annotated with {@link Component}, but is suitable
+ * as a supertype for an interface that is annotated as such.  For example, given the following
+ * modules: <pre>   {@code
+ *
+ *   @Module(...)
+ *   final class AModule {...}
+ *
+ *   @Module(...)
+ *   final class BModule {...}}</pre>
+ *
+ * <p>This processor would generate interfaces named {@code AModule$$InjectsInterface} and
+ * {@code BModule$$InjectsInterface}.  Those modules could then be used to create a component that
+ * looks like the following: <pre>   {@code
+ *
+ *   @Component(modules = {AModule.class, BModule.class})
+ *   interface MyComponent extends AModule$$InjectsInterface, BModule$$InjectsInterface  {...}}
+ *
+ * <p>The methods on the generated interface are named with the canonical name of the type, but with
+ * the periods replaced with underscores.  They are intentionally ugly.  Use this as motivation to
+ * migrate to better interfaces as soon as possible.
+ */
+@GoogleInternal
+public final class ModuleInjectsProcessor extends AbstractProcessor {
+  @Override
+  public Set<String> getSupportedAnnotationTypes() {
+    return ImmutableSet.of(Module.class.getCanonicalName());
+  }
+
+  @Override
+  public SourceVersion getSupportedSourceVersion() {
+    return SourceVersion.latestSupported();
+  }
+
+  @Override
+  public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
+    Set<? extends Element> moduleElements = roundEnv.getElementsAnnotatedWith(Module.class);
+    for (Element moduleElement : moduleElements) {
+      if (SuperficialValidation.validateElement(moduleElement)) {
+        ClassName moduleClassName = ClassName.fromTypeElement(asType(moduleElement));
+        AnnotationMirror moduleAnnotation = getAnnotationMirror(moduleElement, Module.class).get();
+        ImmutableList<TypeMirror> moduleInjects =
+            getModuleInjects(processingEnv.getElementUtils(), moduleAnnotation);
+        JavaWriter javaWriter = JavaWriter.inPackage(moduleClassName.packageName());
+        InterfaceWriter interfaceWriter =
+            javaWriter.addInterface(moduleClassName.classFileName() + "$$InjectsInterface");
+        interfaceWriter.addModifiers(PUBLIC);
+        interfaceWriter.annotate(Generated.class)
+            .setValue(ModuleInjectsProcessor.class.getCanonicalName());
+
+        for (TypeMirror injectType : moduleInjects) {
+          // these method names are horrendous, but that's ok because these are placeholder
+          // interfaces
+          interfaceWriter.addMethod(injectType,
+              TypeNames.forTypeMirror(injectType).toString().replace('.', '_'))
+                  .addModifiers(PUBLIC, ABSTRACT);
+        }
+        try {
+          javaWriter.file(processingEnv.getFiler(), ImmutableList.of(moduleElement));
+        } catch (IOException e) {
+          processingEnv.getMessager()
+              .printMessage(Kind.ERROR, "Could not write file.", moduleElement);
+        }
+      }
+    }
+    return false;
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java
index 922eadfe8..727d22f22 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java
@@ -12,7 +12,6 @@
 import java.util.Set;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.TypeMirror;
 
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PROTECTED;
@@ -22,7 +21,6 @@
   private final List<TypeWriter> nestedTypeWriters;
   private final List<FieldWriter> fieldWriters;
   private final List<ConstructorWriter> constructorWriters;
-  private final List<MethodWriter> methodWriters;
   private final List<TypeVariableName> typeVariables;
 
   ClassWriter(ClassName className) {
@@ -30,7 +28,6 @@
     this.nestedTypeWriters = Lists.newArrayList();
     this.fieldWriters = Lists.newArrayList();
     this.constructorWriters = Lists.newArrayList();
-    this.methodWriters = Lists.newArrayList();
     this.typeVariables = Lists.newArrayList();
   }
 
@@ -72,32 +69,6 @@ public ClassWriter addNestedClass(String name) {
     return innerClassWriter;
   }
 
-  public MethodWriter addMethod(TypeWriter returnType, String name) {
-    MethodWriter methodWriter = new MethodWriter(returnType.name, name);
-    methodWriters.add(methodWriter);
-    return methodWriter;
-  }
-
-  public MethodWriter addMethod(TypeMirror returnType, String name) {
-    MethodWriter methodWriter =
-        new MethodWriter(TypeNames.forTypeMirror(returnType), name);
-    methodWriters.add(methodWriter);
-    return methodWriter;
-  }
-
-  public MethodWriter addMethod(TypeName returnType, String name) {
-    MethodWriter methodWriter = new MethodWriter(returnType, name);
-    methodWriters.add(methodWriter);
-    return methodWriter;
-  }
-
-  public MethodWriter addMethod(Class<?> returnType, String name) {
-    MethodWriter methodWriter =
-        new MethodWriter(ClassName.fromClass(returnType), name);
-    methodWriters.add(methodWriter);
-    return methodWriter;
-  }
-
   @Override
   public Appendable write(Appendable appendable, Context context) throws IOException {
     context = context.createSubcontext(FluentIterable.from(nestedTypeWriters)
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/InterfaceWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/InterfaceWriter.java
index 33b1cd918..f777100c1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/InterfaceWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/InterfaceWriter.java
@@ -3,20 +3,20 @@
 import com.google.common.base.Function;
 import com.google.common.base.Joiner;
 import com.google.common.collect.FluentIterable;
+import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
 import java.io.IOException;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Set;
 
 public class InterfaceWriter extends TypeWriter {
   private final List<TypeVariableName> typeVariables;
-  private final List<MethodWriter> methodWriters;
   private final List<TypeWriter> nestedTypeWriters;
 
   InterfaceWriter(ClassName name) {
     super(name);
     this.typeVariables = Lists.newArrayList();
-    this.methodWriters = Lists.newArrayList();
     this.nestedTypeWriters = Lists.newArrayList();
   }
 
@@ -26,18 +26,40 @@ public void addTypeVariable(TypeVariableName typeVariable) {
 
   @Override
   public Appendable write(Appendable appendable, Context context) throws IOException {
-    writeModifiers(appendable).append("class ").append(name.simpleName());
+    context = context.createSubcontext(FluentIterable.from(nestedTypeWriters)
+        .transform(new Function<TypeWriter, ClassName>() {
+          @Override public ClassName apply(TypeWriter input) {
+            return input.name;
+          }
+        })
+        .toSet());
+    writeAnnotations(appendable, context);
+    writeModifiers(appendable).append("interface ").append(name.simpleName());
     if (!typeVariables.isEmpty()) {
       appendable.append('<');
       Joiner.on(", ").appendTo(appendable, typeVariables);
       appendable.append('>');
     }
-    appendable.append(" {\n");
+    if (supertype.isPresent()) {
+      appendable.append(" extends ");
+      supertype.get().write(appendable, context);
+    }
+    Iterator<TypeName> implementedTypesIterator = implementedTypes.iterator();
+    if (implementedTypesIterator.hasNext()) {
+      appendable.append(" implements ");
+      implementedTypesIterator.next().write(appendable, context);
+      while (implementedTypesIterator.hasNext()) {
+        appendable.append(", ");
+        implementedTypesIterator.next().write(appendable, context);
+      }
+    }
+    appendable.append(" {");
     for (MethodWriter methodWriter : methodWriters) {
+      appendable.append('\n');
       methodWriter.write(new IndentingAppendable(appendable), context);
     }
-    appendable.append('\n');
     for (TypeWriter nestedTypeWriter : nestedTypeWriters) {
+      appendable.append('\n');
       nestedTypeWriter.write(new IndentingAppendable(appendable), context);
     }
     appendable.append("}\n");
@@ -46,7 +68,11 @@ public Appendable write(Appendable appendable, Context context) throws IOExcepti
 
   @Override
   public Set<ClassName> referencedClasses() {
-    return FluentIterable.from(nestedTypeWriters)
+    @SuppressWarnings("unchecked")
+    Iterable<? extends HasClassReferences> concat =
+        Iterables.concat(nestedTypeWriters, methodWriters, implementedTypes, supertype.asSet(),
+            annotations);
+    return FluentIterable.from(concat)
         .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {
           @Override
           public Set<ClassName> apply(HasClassReferences input) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/TypeWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/TypeWriter.java
index a18c68cb0..9405aca75 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/TypeWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/TypeWriter.java
@@ -3,6 +3,7 @@
 import com.google.common.base.Optional;
 import com.google.common.collect.Lists;
 import java.util.List;
+import javax.lang.model.type.TypeMirror;
 
 
 /**
@@ -13,15 +14,43 @@
   final ClassName name;
   Optional<TypeName> supertype;
   final List<TypeName> implementedTypes;
+  final List<MethodWriter> methodWriters;
 
   TypeWriter(ClassName name) {
     this.name = name;
     this.supertype = Optional.absent();
     this.implementedTypes = Lists.newArrayList();
+    this.methodWriters = Lists.newArrayList();
   }
 
   @Override
   public TypeName name() {
     return name;
   }
+
+  public MethodWriter addMethod(TypeWriter returnType, String name) {
+    MethodWriter methodWriter = new MethodWriter(returnType.name, name);
+    methodWriters.add(methodWriter);
+    return methodWriter;
+  }
+
+  public MethodWriter addMethod(TypeMirror returnType, String name) {
+    MethodWriter methodWriter =
+        new MethodWriter(TypeNames.forTypeMirror(returnType), name);
+    methodWriters.add(methodWriter);
+    return methodWriter;
+  }
+
+  public MethodWriter addMethod(TypeName returnType, String name) {
+    MethodWriter methodWriter = new MethodWriter(returnType, name);
+    methodWriters.add(methodWriter);
+    return methodWriter;
+  }
+
+  public MethodWriter addMethod(Class<?> returnType, String name) {
+    MethodWriter methodWriter =
+        new MethodWriter(ClassName.fromClass(returnType), name);
+    methodWriters.add(methodWriter);
+    return methodWriter;
+  }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ModuleInjectsProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ModuleInjectsProcessorTest.java
new file mode 100644
index 000000000..4db293e59
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/ModuleInjectsProcessorTest.java
@@ -0,0 +1,42 @@
+package dagger.internal.codegen;
+
+import com.google.common.annotations.GoogleInternal;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assert_;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+
+@GoogleInternal
+@RunWith(JUnit4.class)
+public class ModuleInjectsProcessorTest {
+  @Test public void singleProvidesMethodNoArgs() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module(injects = {String.class, Object.class})",
+        "final class TestModule {",
+        "}");
+    JavaFileObject interfaceFile = JavaFileObjects.forSourceLines(
+        "test.TestModule$$InjectsInterface",
+        "package test;",
+        "",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ModuleInjectsProcessor\")",
+        "public interface TestModule$$InjectsInterface {",
+        "  public abstract String java_lang_String();",
+        "  public abstract Object java_lang_Object();",
+        "}");
+    assert_().about(javaSource()).that(moduleFile)
+        .processedWith(new ModuleInjectsProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(interfaceFile);
+  }
+}
