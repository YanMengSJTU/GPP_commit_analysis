diff --git a/compiler/src/it/functional-tests/src/main/java/test/ParentModule.java b/compiler/src/it/functional-tests/src/main/java/test/ParentModule.java
index a161abaa8..f550f2f21 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/ParentModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/ParentModule.java
@@ -4,6 +4,7 @@
 import dagger.Provides;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.Set;
 
 @Module
 abstract class ParentModule<A extends Number & Comparable<A>, B, C extends Iterable<A>> {
@@ -15,4 +16,14 @@
     }
     return list;
   }
+
+  @Provides static char provideNonGenericBindingInParameterizedModule() {
+    return 'c';
+  }
+
+  @Provides
+  static List<Set<String>> provideStaticGenericTypeWithNoTypeParametersInParameterizedModule() {
+    return new ArrayList<>();
+  }
+
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index b41e4d5d5..8b548c0db 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -30,6 +30,7 @@
 import com.squareup.javapoet.TypeSpec;
 import com.squareup.javapoet.TypeVariableName;
 import dagger.internal.Factory;
+import dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy;
 import java.util.Collections;
 import java.util.List;
 import javax.annotation.processing.Filer;
@@ -48,6 +49,8 @@
 import static dagger.Provides.Type.SET;
 import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_RAWTYPES;
 import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_UNCHECKED;
+import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.ENUM_INSTANCE;
+import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
 import static dagger.internal.codegen.TypeNames.factoryOf;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.ContributionBinding.Kind.PROVISION;
@@ -111,12 +114,16 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
     ImmutableList<TypeVariableName> typeParameters = bindingTypeElementTypeVariableNames(binding);
     ImmutableMap<BindingKey, FrameworkField> fields =
         generateBindingFieldsForDependencies(dependencyRequestMapper, binding);
+    boolean useRawType =
+        binding.factoryCreationStrategy() == ENUM_INSTANCE
+            && binding.bindingKind() == INJECTION
+            && !typeParameters.isEmpty();
     switch (binding.factoryCreationStrategy()) {
       case ENUM_INSTANCE:
         factoryBuilder = enumBuilder(generatedTypeName.simpleName()).addEnumConstant("INSTANCE");
         // If we have type parameters, then remove the parameters from our providedTypeName,
         // since we'll be implementing an erased version of it.
-        if (!typeParameters.isEmpty()) {
+        if (useRawType) {
           factoryBuilder.addAnnotation(SUPPRESS_WARNINGS_RAWTYPES);
           // TODO(ronshapiro): instead of reassigning, introduce an optional/second parameter
           providedTypeName = ((ParameterizedTypeName) providedTypeName).rawType;
@@ -165,15 +172,18 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
         MethodSpec.Builder createMethodBuilder =
             methodBuilder("create")
                 .addModifiers(PUBLIC, STATIC)
-                .addTypeVariables(typeParameters)
                 .returns(parameterizedFactoryName);
+        if (binding.factoryCreationStrategy() != ENUM_INSTANCE
+            || binding.bindingKind() == INJECTION) {
+          createMethodBuilder.addTypeVariables(typeParameters);
+        }
         List<ParameterSpec> params =
             constructorBuilder.isPresent()
                 ? constructorBuilder.get().build().parameters : ImmutableList.<ParameterSpec>of();
         createMethodBuilder.addParameters(params);
         switch (binding.factoryCreationStrategy()) {
           case ENUM_INSTANCE:
-            if (typeParameters.isEmpty()) {
+            if (!useRawType) {
               createMethodBuilder.addStatement("return INSTANCE");
             } else {
               // We use an unsafe cast here because the types are different.
diff --git a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
index 03184f8a3..cd44b97e5 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
@@ -17,6 +17,7 @@
 
 import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.JavaFileObjects;
+import dagger.Provides;
 import dagger.internal.codegen.writer.StringLiteral;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
@@ -767,7 +768,7 @@ private String formatModuleErrorMessage(String msg) {
   }
 
   @Test
-  public void producesMethodThrowsChecked() {
+  public void providesMethodThrowsChecked() {
     JavaFileObject moduleFile =
         JavaFileObjects.forSourceLines(
             "test.TestModule",
@@ -1171,6 +1172,96 @@ public void genericSubclassedModule() {
             listBFactory, bElementFactory, bEntryFactory, numberFactory, integerFactory);
   }
 
+  @Test public void parameterizedModuleWithStaticProvidesMethodOfGenericType() {
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.ParameterizedModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import java.util.List;",
+            "import java.util.ArrayList;",
+            "import java.util.Map;",
+            "import java.util.HashMap;",
+            "",
+            "@Module abstract class ParameterizedModule<T> {",
+            "  @Provides List<T> provideListT() {",
+            "    return new ArrayList<>();",
+            "  }",
+            "",
+            "  @Provides static Map<String, Number> provideMapStringNumber() {",
+            "    return new HashMap<>();",
+            "  }",
+            "",
+            "  @Provides static Object provideNonGenericType() {",
+            "    return new Object();",
+            "  }",
+            "}");
+
+    JavaFileObject provideMapStringNumberFactory =
+        JavaFileObjects.forSourceLines(
+            "test.ParameterizedModule_ProvideMapStringNumberFactory;",
+            "package test;",
+            "",
+            "import dagger.internal.Factory;",
+            "import java.util.Map;",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION_JAVAPOET,
+            "public enum ParameterizedModule_ProvideMapStringNumberFactory",
+            "    implements Factory<Map<String, Number>> {",
+            "  INSTANCE;",
+            "",
+            "  @Override",
+            "  public Map<String, Number> get() {",
+            "    Map<String, Number> provided = ParameterizedModule.provideMapStringNumber();",
+            "    if (provided == null) {",
+            "      throw new NullPointerException(" + NPE_LITERAL + ");",
+            "    }",
+            "    return provided;",
+            "  }",
+            "",
+            "  public static Factory<Map<String, Number>> create() {",
+            "    return INSTANCE;",
+            "  }",
+            "}");
+
+    JavaFileObject provideNonGenericTypeFactory =
+        JavaFileObjects.forSourceLines(
+            "test.ParameterizedModule_ProvideNonGenericTypeFactory;",
+            "package test;",
+            "",
+            "import dagger.internal.Factory;",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION_JAVAPOET,
+            "public enum ParameterizedModule_ProvideNonGenericTypeFactory",
+            "    implements Factory<Object> {",
+            "  INSTANCE;",
+            "",
+            "  @Override",
+            "  public Object get() {",
+            "    Object provided = ParameterizedModule.provideNonGenericType();",
+            "    if (provided == null) {",
+            "      throw new NullPointerException(" + NPE_LITERAL + ");",
+            "    }",
+            "    return provided;",
+            "  }",
+            "",
+            "  public static Factory<Object> create() {",
+            "    return INSTANCE;",
+            "  }",
+            "}");
+
+    assertAbout(javaSource())
+        .that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(provideMapStringNumberFactory, provideNonGenericTypeFactory);
+  }
+
   @Test public void providesMethodMultipleQualifiers() {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
