diff --git a/compiler/pom.xml b/compiler/pom.xml
index 5a39f86a8..c420563aa 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -65,14 +65,13 @@
     <dependency>
       <groupId>com.google.auto.service</groupId>
       <artifactId>auto-service</artifactId>
-      <scope>provided</scope> <!-- to leave out of the all-deps jar -->
+      <scope>provided</scope>
     </dependency>
     <dependency>
       <groupId>com.google.auto.value</groupId>
       <artifactId>auto-value</artifactId>
-      <scope>provided</scope> <!-- to leave out of the all-deps jar -->
+      <scope>provided</scope>
     </dependency>
-
     <dependency>
       <groupId>junit</groupId>
       <artifactId>junit</artifactId>
@@ -81,9 +80,9 @@
     <dependency>
       <groupId>${project.groupId}</groupId>
       <artifactId>dagger</artifactId>
+      <classifier>tests</classifier>
       <version>${project.version}</version>
       <scope>test</scope>
-      <classifier>tests</classifier>
     </dependency>
     <dependency>
       <groupId>com.google.testing.compile</groupId>
@@ -98,7 +97,6 @@
     <dependency>
       <groupId>com.squareup</groupId>
       <artifactId>javapoet</artifactId>
-      <version>1.7.0</version>
     </dependency>
     <dependency>
       <groupId>org.mockito</groupId>
@@ -158,10 +156,6 @@
             <pomInclude>*/pom.xml</pomInclude>
           </pomIncludes>
           <localRepositoryPath>${project.build.directory}/it-repo</localRepositoryPath>
-          <filterProperties>
-            <dagger.version>${project.version}</dagger.version>
-            <dagger.groupId>${project.groupId}</dagger.groupId>
-          </filterProperties>
           <streamLogs>true</streamLogs>
         </configuration>
         <executions>
diff --git a/compiler/src/it/functional-tests/pom.xml b/compiler/src/it/functional-tests/pom.xml
index 2f0463499..6a0ac5507 100644
--- a/compiler/src/it/functional-tests/pom.xml
+++ b/compiler/src/it/functional-tests/pom.xml
@@ -46,14 +46,12 @@ limitations under the License.
     <dependency>
       <groupId>com.google.auto.value</groupId>
       <artifactId>auto-value</artifactId>
-      <version>${auto.value.version}</version>
-      <scope>provided</scope> <!-- to leave out of the all-deps jar -->
+      <scope>provided</scope>
     </dependency>
     <dependency>
       <groupId>com.google.auto.factory</groupId>
       <artifactId>auto-factory</artifactId>
-      <version>${auto.factory.version}</version>
-      <scope>provided</scope> <!-- to leave out of the all-deps jar -->
+      <scope>provided</scope>
     </dependency>
 
     <dependency>
diff --git a/compiler/src/it/guava-functional-tests/pom.xml b/compiler/src/it/guava-functional-tests/pom.xml
index cb127fa0e..d8f1a65f2 100644
--- a/compiler/src/it/guava-functional-tests/pom.xml
+++ b/compiler/src/it/guava-functional-tests/pom.xml
@@ -42,14 +42,12 @@ limitations under the License.
     <dependency>
       <groupId>com.google.auto.value</groupId>
       <artifactId>auto-value</artifactId>
-      <version>${auto.value.version}</version>
-      <scope>provided</scope> <!-- to leave out of the all-deps jar -->
+      <scope>provided</scope>
     </dependency>
     <dependency>
       <groupId>com.google.auto.factory</groupId>
       <artifactId>auto-factory</artifactId>
-      <version>${auto.factory.version}</version>
-      <scope>provided</scope> <!-- to leave out of the all-deps jar -->
+      <scope>provided</scope>
     </dependency>
 
     <dependency>
diff --git a/compiler/src/it/producers-functional-tests/pom.xml b/compiler/src/it/producers-functional-tests/pom.xml
index a36759e8d..3006318b2 100644
--- a/compiler/src/it/producers-functional-tests/pom.xml
+++ b/compiler/src/it/producers-functional-tests/pom.xml
@@ -51,8 +51,7 @@ limitations under the License.
     <dependency>
       <groupId>com.google.auto.value</groupId>
       <artifactId>auto-value</artifactId>
-      <version>${auto.value.version}</version>
-      <scope>provided</scope> <!-- to leave out of the all-deps jar -->
+      <scope>provided</scope>
     </dependency>
     <dependency>
       <groupId>junit</groupId>
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 6b191fce0..3e92d661a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -579,7 +579,7 @@ private boolean useRawType(Optional<String> bindingPackage) {
               MapType mapType = MapType.from(contributionBinding.key());
               return Optional.of(
                   emptyFrameworkMapFactory(
-                      frameworkMapFactoryClassName(bindingType),
+                      bindingType,
                       mapType.keyType(),
                       mapType.unwrappedValueType(bindingType.frameworkClass())));
 
@@ -1283,10 +1283,6 @@ private CodeBlock initializeFactoryForMapMultibinding(ContributionBinding bindin
               useRawTypes,
               frameworkDependency.frameworkClass(),
               getDependencyArgument(frameworkDependency).getExpressionFor(name));
-      if (binding.bindingType().frameworkClass().equals(Producer.class)
-          && frameworkDependency.frameworkClass().equals(Provider.class)) {
-        value = CodeBlock.of("$T.producerFromProvider($L)", PRODUCERS, value);
-      }
       codeBlocks.add(
           CodeBlock.of(
               ".put($L, $L)", getMapKeyExpression(contributionBinding.mapKey().get()), value));
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index f1434e0df..e4095a92e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -183,6 +183,19 @@ ResolvedBindings previousResolvedBindings() {
       return Iterators.get(path.descendingIterator(), 1).resolvedBindings();
     }
 
+    /**
+     * Returns the contribution bindings resolved for the second-most-recent request in the given
+     * path; that is, returns those bindings that depend on the latest request in the path.
+     */
+    FluentIterable<ContributionBinding> contributionsDependingOnLatestRequest() {
+      if (size() <= 1) {
+        return FluentIterable.from(ImmutableList.<ContributionBinding>of());
+      }
+      return FluentIterable.from(previousResolvedBindings().bindings())
+          .filter(binding -> binding.implicitDependencies().contains(currentDependencyRequest()))
+          .filter(ContributionBinding.class);
+    }
+
     /**
      * {@code true} if there is a dependency cycle, which means that the
      * {@linkplain #currentDependencyRequest() current request}'s binding key occurs earlier in the
@@ -347,14 +360,18 @@ private void traverseDependencyRequest(DependencyRequest request, DependencyPath
           validateResolvedBindings(path);
 
           // Validate all dependencies within the component that owns the binding.
-          for (Map.Entry<ComponentDescriptor, ? extends Binding> entry :
-              path.currentResolvedBindings().bindingsByComponent()) {
-            Validation validation = validationForComponent(entry.getKey());
-            Binding binding = entry.getValue();
-            for (DependencyRequest nextRequest : binding.implicitDependencies()) {
-              validation.traverseDependencyRequest(nextRequest, path);
-            }
-          }
+          path.currentResolvedBindings()
+              .allBindings()
+              .asMap()
+              .forEach(
+                  (component, bindings) -> {
+                    Validation validation = validationForComponent(component);
+                    for (Binding binding : bindings) {
+                      for (DependencyRequest nextRequest : binding.implicitDependencies()) {
+                        validation.traverseDependencyRequest(nextRequest, path);
+                      }
+                    }
+                  });
         }
       } finally {
         path.pop();
@@ -418,9 +435,10 @@ private void validateResolvedBindings(DependencyPath path) {
           }
           if (contributionBinding.bindingType().equals(PRODUCTION)
               && doesPathRequireProvisionOnly(path)) {
-            reportProviderMayNotDependOnProducer(path);
+            reportProviderMayNotDependOnProducer(path, contributionBinding);
             return;
           }
+          // TODO(dpb,beder): Validate this during @Inject/@Provides/@Produces validation.
           if (compilerOptions.usesProducers()) {
             Key productionImplementationExecutorKey =
                 keyFactory.forProductionImplementationExecutor();
@@ -553,12 +571,13 @@ private void validateNullability(DependencyPath path, Set<ContributionBinding> b
 
       for (ContributionBinding binding : bindings) {
         if (binding.nullableType().isPresent()) {
-          reportBuilder.addItem(
-              nullableToNonNullable(typeName, bindingDeclarationFormatter.format(binding))
-                  + "\n at: "
-                  + dependencyRequestFormatter.toDependencyTrace(path),
-              compilerOptions.nullableValidationKind(),
-              path.entryPointElement());
+          owningReportBuilder(path.contributionsDependingOnLatestRequest().append(binding))
+              .addItem(
+                  nullableToNonNullable(typeName, bindingDeclarationFormatter.format(binding))
+                      + "\n at: "
+                      + dependencyRequestFormatter.toDependencyTrace(path),
+                  compilerOptions.nullableValidationKind(),
+                  path.entryPointElement());
         }
       }
     }
@@ -605,6 +624,7 @@ private void validateMapKeyAnnotationTypes(
     }
 
     /** Reports errors if a members injection binding is invalid. */
+    // TODO(dpb): Can this be done while validating @Inject?
     private void validateMembersInjectionBinding(
         final MembersInjectionBinding binding, final DependencyPath path) {
       binding
@@ -967,24 +987,26 @@ void validateComponentScope() {
 
     @SuppressWarnings("resource") // Appendable is a StringBuilder.
     // TODO(b/29509141): Clarify the error.
-    private void reportProviderMayNotDependOnProducer(DependencyPath path) {
-      StringBuilder errorMessage = new StringBuilder();
+    private void reportProviderMayNotDependOnProducer(
+        DependencyPath path, ContributionBinding productionBinding) {
       if (path.size() == 1) {
-        new Formatter(errorMessage)
-            .format(
+        reportBuilder.addError(
+            String.format(
                 PROVIDER_ENTRY_POINT_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT,
-                formatCurrentDependencyRequestKey(path));
+                formatCurrentDependencyRequestKey(path)),
+            path.entryPointElement());
       } else {
         FluentIterable<ContributionBinding> dependentProvisions =
             provisionsDependingOnLatestRequest(path);
         // TODO(beder): Consider displaying all dependent provisions in the error message. If we
         // do that, should we display all productions that depend on them also?
-        new Formatter(errorMessage)
-            .format(
-                PROVIDER_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT,
-                dependentProvisions.iterator().next().key());
+        owningReportBuilder(dependentProvisions.append(productionBinding))
+            .addError(
+                String.format(
+                    PROVIDER_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT,
+                    dependentProvisions.iterator().next().key()),
+                path.entryPointElement());
       }
-      reportBuilder.addError(errorMessage.toString(), path.entryPointElement());
     }
 
     /**
@@ -1033,7 +1055,7 @@ private void reportMissingBinding(DependencyPath path) {
               topLevelGraph(), path.currentDependencyRequest().bindingKey())) {
         errorMessage.append('\n').append(suggestion);
       }
-      reportBuilder.addError(errorMessage.toString(), path.entryPointElement());
+      topLevelReport().addError(errorMessage.toString(), path.entryPointElement());
     }
 
     @SuppressWarnings("resource") // Appendable is a StringBuilder.
@@ -1070,13 +1092,13 @@ private void reportDuplicateBindings(DependencyPath path) {
     }
 
     /**
-     * Returns the report builder for the rootmost component that contains any of the duplicate
-     * bindings.
+     * Returns the report builder for the rootmost component that contains any of the {@code
+     * bindings}.
      */
     private ValidationReport.Builder<TypeElement> owningReportBuilder(
-        Iterable<ContributionBinding> duplicateBindings) {
+        Iterable<ContributionBinding> bindings) {
       ImmutableSet.Builder<ComponentDescriptor> owningComponentsBuilder = ImmutableSet.builder();
-      for (ContributionBinding binding : duplicateBindings) {
+      for (ContributionBinding binding : bindings) {
         ResolvedBindings resolvedBindings =
             subject.resolvedBindings().get(BindingKey.contribution(binding.key()));
         owningComponentsBuilder.addAll(
@@ -1088,8 +1110,7 @@ private void reportDuplicateBindings(DependencyPath path) {
           return validation.reportBuilder;
         }
       }
-      throw new AssertionError(
-          "cannot find owning component for duplicate bindings: " + duplicateBindings);
+      throw new AssertionError("cannot find owning component for bindings: " + bindings);
     }
 
     /**
@@ -1128,7 +1149,8 @@ private void reportMultipleContributionTypes(DependencyPath path) {
             builder, declarationsByType.get(contributionType), 2, DUPLICATE_SIZE_LIMIT);
         builder.append('\n');
       }
-      reportBuilder.addError(builder.toString(), path.entryPointElement());
+      owningReportBuilder(resolvedBindings.contributionBindings())
+          .addError(builder.toString(), path.entryPointElement());
     }
 
     private void reportDuplicateMapKeys(
@@ -1136,7 +1158,7 @@ private void reportDuplicateMapKeys(
       StringBuilder builder = new StringBuilder();
       builder.append(duplicateMapKeysError(formatCurrentDependencyRequestKey(path)));
       bindingDeclarationFormatter.formatIndentedList(builder, mapBindings, 1, DUPLICATE_SIZE_LIMIT);
-      reportBuilder.addError(builder.toString(), path.entryPointElement());
+      owningReportBuilder(mapBindings).addError(builder.toString(), path.entryPointElement());
     }
 
     private void reportInconsistentMapKeyAnnotations(
@@ -1159,7 +1181,8 @@ private void reportInconsistentMapKeyAnnotations(
 
         bindingDeclarationFormatter.formatIndentedList(builder, bindings, 2, DUPLICATE_SIZE_LIMIT);
       }
-      reportBuilder.addError(builder.toString(), path.entryPointElement());
+      owningReportBuilder(mapBindingsByAnnotationType.values())
+          .addError(builder.toString(), path.entryPointElement());
     }
 
     private void reportCycle(DependencyPath path) {
@@ -1167,16 +1190,16 @@ private void reportCycle(DependencyPath path) {
         return;
       }
       // TODO(cgruber): Provide a hint for the start and end of the cycle.
-      TypeElement componentType =
-          MoreElements.asType(path.entryPointElement().getEnclosingElement());
-      reportBuilder.addItem(
-          String.format(
-              CONTAINS_DEPENDENCY_CYCLE_FORMAT,
-              componentType.getQualifiedName(),
-              path.entryPointElement().getSimpleName(),
-              dependencyRequestFormatter.toDependencyTrace(path)),
-          ERROR,
-          path.entryPointElement());
+      owningReportBuilder(
+              path.cycle()
+                  .transform(ResolvedRequest::resolvedBindings)
+                  .transformAndConcat(ResolvedBindings::contributionBindings))
+          .addItem(
+              String.format(
+                  CONTAINS_DEPENDENCY_CYCLE_FORMAT,
+                  dependencyRequestFormatter.toDependencyTrace(path)),
+              ERROR,
+              path.entryPointElement());
     }
 
     /**
@@ -1299,11 +1322,8 @@ private boolean doesPathRequireProvisionOnly(DependencyPath path) {
    * that is, returns those provision bindings that depend on the latest request in the path.
    */
   private FluentIterable<ContributionBinding> provisionsDependingOnLatestRequest(
-      final DependencyPath path) {
-    return FluentIterable.from(path.previousResolvedBindings().bindings())
-        .filter(PROVISION::isOfType)
-        .filter(binding -> binding.implicitDependencies().contains(path.currentDependencyRequest()))
-        .filter(ContributionBinding.class);
+      DependencyPath path) {
+    return path.contributionsDependingOnLatestRequest().filter(PROVISION::isOfType);
   }
 
   private String formatContributionType(ContributionType type) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index bf709f292..efdf5f761 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -288,7 +288,7 @@ static String provisionMayNotDependOnProducerType(TypeMirror type) {
   static final String MEMBERS_INJECTION_WITH_UNBOUNDED_TYPE =
       "Type parameters must be bounded for members injection. %s required by %s, via:\n%s";
 
-  static final String CONTAINS_DEPENDENCY_CYCLE_FORMAT = "%s.%s() contains a dependency cycle:\n%s";
+  static final String CONTAINS_DEPENDENCY_CYCLE_FORMAT = "Found a dependency cycle:\n%s";
 
   static String nullableToNonNullable(String typeName, String bindingString) {
     return String.format(
diff --git a/compiler/src/main/java/dagger/internal/codegen/MemberSelect.java b/compiler/src/main/java/dagger/internal/codegen/MemberSelect.java
index 015ad36bf..9525860e3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MemberSelect.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MemberSelect.java
@@ -16,7 +16,6 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
@@ -31,8 +30,6 @@
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import dagger.MembersInjector;
-import dagger.internal.MapProviderFactory;
-import dagger.producers.internal.MapOfProducerProducer;
 import java.util.List;
 import java.util.Set;
 import javax.lang.model.type.TypeMirror;
@@ -116,24 +113,31 @@ static MemberSelect noOpMembersInjector(TypeMirror type) {
         MEMBERS_INJECTOR);
   }
 
-  /**
+   /**
    * A {@link MemberSelect} for an empty map of framework types.
    *
-   * @param frameworkMapFactoryClass either {@link MapProviderFactory}
-   *     or {@link MapOfProducerProducer}
+   * @param bindingType the type of the binding of the empty map
    */
   static MemberSelect emptyFrameworkMapFactory(
-      ClassName frameworkMapFactoryClass, TypeMirror keyType, TypeMirror unwrappedValueType) {
-    checkArgument(
-        frameworkMapFactoryClass.equals(MAP_PROVIDER_FACTORY)
-            || frameworkMapFactoryClass.equals(MAP_OF_PRODUCER_PRODUCER),
-        "frameworkMapFactoryClass must be MapProviderFactory or MapOfProducerProducer: %s",
-        frameworkMapFactoryClass);
+      BindingType bindingType, TypeMirror keyType, TypeMirror unwrappedValueType) {
+    final ClassName frameworkMapFactoryClass;
+    switch (bindingType) {
+      case PROVISION:
+        frameworkMapFactoryClass = MAP_PROVIDER_FACTORY;
+        break;
+      case PRODUCTION:
+        frameworkMapFactoryClass = MAP_OF_PRODUCER_PRODUCER;
+        break;
+      case MEMBERS_INJECTION:
+        throw new IllegalArgumentException();
+      default:
+        throw new AssertionError();
+    }
     return new ParameterizedStaticMethod(
         frameworkMapFactoryClass,
         ImmutableList.of(keyType, unwrappedValueType),
         CodeBlock.of("empty()"),
-        frameworkMapFactoryClass);
+        ClassName.get(bindingType.frameworkClass()));
   }
 
   /**
diff --git a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
index 69704da09..c09d5d955 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
@@ -23,7 +23,6 @@
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Optional;
 import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
@@ -32,7 +31,6 @@
 import dagger.internal.codegen.BindingType.HasBindingType;
 import dagger.internal.codegen.ContributionType.HasContributionType;
 import dagger.internal.codegen.Key.HasKey;
-import java.util.Map;
 
 /**
  * The collection of bindings that have been resolved for a binding key. For valid graphs, contains
@@ -55,18 +53,18 @@
   abstract ComponentDescriptor owningComponent();
 
   /**
-   * The contribution bindings for {@link #bindingKey()} that were resolved in
-   * {@link #owningComponent()} or its ancestor components, keyed by the component in which the
-   * binding was resolved. If {@link #bindingKey()}'s kind is not
-   * {@link BindingKey.Kind#CONTRIBUTION}, this is empty.
+   * The contribution bindings for {@link #bindingKey()} that were resolved in {@link
+   * #owningComponent()} or its ancestor components, indexed by the component in which the binding
+   * was resolved. If {@link #bindingKey()}'s kind is not {@link BindingKey.Kind#CONTRIBUTION}, this
+   * is empty.
    */
   abstract ImmutableSetMultimap<ComponentDescriptor, ContributionBinding> allContributionBindings();
 
   /**
-   * The members-injection bindings for {@link #bindingKey()} that were resolved in
-   * {@link #owningComponent()} or its ancestor components, keyed by the component in which the
-   * binding was resolved. If {@link #bindingKey()}'s kind is not
-   * {@link BindingKey.Kind#MEMBERS_INJECTION}, this is empty.
+   * The members-injection bindings for {@link #bindingKey()} that were resolved in {@link
+   * #owningComponent()} or its ancestor components, indexed by the component in which the binding
+   * was resolved. If {@link #bindingKey()}'s kind is not {@link BindingKey.Kind#MEMBERS_INJECTION},
+   * this is empty.
    */
   abstract ImmutableMap<ComponentDescriptor, MembersInjectionBinding> allMembersInjectionBindings();
 
@@ -94,20 +92,28 @@ public Key key() {
   abstract ImmutableSet<OptionalBindingDeclaration> optionalBindingDeclarations();
 
   /**
-   * All bindings for {@link #bindingKey()}, regardless of in which component they were resolved.
+   * All bindings for {@link #bindingKey()}, indexed by the component in which the binding was
+   * resolved.
    */
-  ImmutableSet<? extends Binding> bindings() {
+  ImmutableSetMultimap<ComponentDescriptor, ? extends Binding> allBindings() {
     switch (bindingKey().kind()) {
       case CONTRIBUTION:
-        return contributionBindings();
+        return allContributionBindings();
 
       case MEMBERS_INJECTION:
-        return ImmutableSet.copyOf(membersInjectionBinding().asSet());
+        return allMembersInjectionBindings().asMultimap();
 
       default:
         throw new AssertionError(bindingKey());
     }
   }
+  
+  /**
+   * All bindings for {@link #bindingKey()}, regardless of in which component they were resolved.
+   */
+  ImmutableSet<? extends Binding> bindings() {
+    return ImmutableSet.copyOf(allBindings().values());
+  }
 
   /**
    * Returns the single binding.
@@ -119,17 +125,6 @@ Binding binding() {
     return getOnlyElement(bindings());
   }
 
-  /**
-   * All bindings for {@link #bindingKey()}, together with the component in which they were
-   * resolved.
-   */
-  ImmutableList<Map.Entry<ComponentDescriptor, ? extends Binding>> bindingsByComponent() {
-    return new ImmutableList.Builder<Map.Entry<ComponentDescriptor, ? extends Binding>>()
-        .addAll(allContributionBindings().entries())
-        .addAll(allMembersInjectionBindings().entrySet())
-        .build();
-  }
-
   /**
    * {@code true} if there are no {@link #bindings()}, {@link #multibindingDeclarations()}, or
    * {@link #subcomponentDeclarations()}.
diff --git a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
index 9f04042c3..d67855df5 100644
--- a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
@@ -238,7 +238,7 @@ public void membersInjectDependsOnUnboundedType() {
     String expectedError =
         Joiner.on('\n')
             .join(
-                "test.Outer.CComponent.getC() contains a dependency cycle:",
+                "Found a dependency cycle:",
                 "      test.Outer.C is injected at",
                 "          test.Outer.A.<init>(cParam)",
                 "      test.Outer.A is injected at",
@@ -291,7 +291,7 @@ public void membersInjectDependsOnUnboundedType() {
     String expectedError =
         Joiner.on('\n')
             .join(
-                "test.Outer.DComponent.getD() contains a dependency cycle:",
+                "Found a dependency cycle:",
                 "      test.Outer.C is injected at",
                 "          test.Outer.A.<init>(cParam)",
                 "      test.Outer.A is injected at",
@@ -363,7 +363,7 @@ public void cyclicDependencyNotBrokenByMapBinding() {
     String expectedError =
         Joiner.on('\n')
             .join(
-                "test.Outer.CComponent.getC() contains a dependency cycle:",
+                "Found a dependency cycle:",
                 "      test.Outer.C is injected at",
                 "          test.Outer.CModule.c(c)",
                 "      java.util.Map<java.lang.String,test.Outer.C> is injected at",
@@ -428,7 +428,7 @@ public void cyclicDependencyWithSetBinding() {
     String expectedError =
         Joiner.on('\n')
             .join(
-                "test.Outer.CComponent.getC() contains a dependency cycle:",
+                "Found a dependency cycle:",
                 "      test.Outer.C is injected at",
                 "          test.Outer.CModule.c(c)",
                 "      java.util.Set<test.Outer.C> is injected at",
@@ -488,7 +488,7 @@ public void falsePositiveCyclicDependencyIndirectionDetected() {
     String expectedError =
         Joiner.on('\n')
             .join(
-                "test.Outer.DComponent.getD() contains a dependency cycle:",
+                "Found a dependency cycle:",
                 "      test.Outer.C is injected at",
                 "          test.Outer.A.<init>(cParam)",
                 "      test.Outer.A is injected at",
@@ -509,6 +509,90 @@ public void falsePositiveCyclicDependencyIndirectionDetected() {
         .onLine(28);
   }
 
+  @Test
+  public void cyclicDependencyInSubcomponents() {
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "test.Parent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface Parent {",
+            "  Child child();",
+            "}");
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = ChildModule.class)",
+            "interface Child {",
+            "  Grandchild grandchild();",
+            "}");
+    JavaFileObject grandchild =
+        JavaFileObjects.forSourceLines(
+            "test.Grandchild",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = GrandchildModule.class)",
+            "interface Grandchild {",
+            "  String entry();",
+            "}");
+    JavaFileObject childModule =
+        JavaFileObjects.forSourceLines(
+            "test.ChildModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "abstract class ChildModule {",
+            "  @Provides static Object object(String string) {",
+            "    return string;",
+            "  }",
+            "}");
+    JavaFileObject grandchildModule =
+        JavaFileObjects.forSourceLines(
+            "test.GrandchildModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "abstract class GrandchildModule {",
+            "  @Provides static String string(Object object) {",
+            "    return object.toString();",
+            "  }",
+            "}");
+
+    String expectedError =
+        Joiner.on('\n')
+            .join(
+                "[test.Grandchild.entry()] Found a dependency cycle:",
+                "      java.lang.String is injected at",
+                "          test.ChildModule.object(string)",
+                "      java.lang.Object is injected at",
+                "          test.GrandchildModule.string(object)",
+                "      java.lang.String is provided at",
+                "          test.Grandchild.entry()");
+
+    assertAbout(javaSources())
+        .that(ImmutableList.of(parent, child, grandchild, childModule, grandchildModule))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedError)
+        .in(child)
+        .onLine(6);
+  }
+
   @Test
   public void circularBindsMethods() {
     JavaFileObject qualifier =
@@ -549,7 +633,7 @@ public void circularBindsMethods() {
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(
-            "test.TestComponent.unqualified() contains a dependency cycle:\n"
+            "Found a dependency cycle:\n"
                 + "      java.lang.Object is injected at\n"
                 + "          test.TestModule.bindQualified(unqualified)\n"
                 + "      @test.SomeQualifier java.lang.Object is injected at\n"
@@ -560,7 +644,7 @@ public void circularBindsMethods() {
         .onLine(7)
         .and()
         .withErrorContaining(
-            "test.TestComponent.qualified() contains a dependency cycle:\n"
+            "Found a dependency cycle:\n"
                 + "      @test.SomeQualifier java.lang.Object is injected at\n"
                 + "          test.TestModule.bindUnqualified(qualified)\n"
                 + "      java.lang.Object is injected at\n"
@@ -603,7 +687,7 @@ public void selfReferentialBinds() {
         .withErrorContaining(
             // TODO(gak): cl/126230644 produces a better error message in this case. Here it isn't
             // unclear what is going wrong.
-            "test.TestComponent.selfReferential() contains a dependency cycle:\n"
+            "Found a dependency cycle:\n"
                 + "      java.lang.Object is injected at\n"
                 + "          test.TestModule.bindToSelf(sameKey)\n"
                 + "      java.lang.Object is provided at\n"
diff --git a/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java
index c1ed888f4..fb3a38873 100644
--- a/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java
@@ -199,12 +199,16 @@
         "interface ChildComponent {",
         "  String getString();",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(moduleFile, componentFile, childComponentFile))
+    assertAbout(javaSources())
+        .that(ImmutableList.of(moduleFile, componentFile, childComponentFile))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(
-            "java.lang.Integer cannot be provided without an @Inject constructor or from an "
-                + "@Provides-annotated method");
+            "[test.ChildComponent.getString()] "
+                + "java.lang.Integer cannot be provided without an @Inject constructor or from an "
+                + "@Provides-annotated method")
+        .in(componentFile)
+        .onLine(6);
   }
 
   @Test public void subcomponentOnConcreteType() {
diff --git a/core/src/main/java/dagger/internal/InstanceFactory.java b/core/src/main/java/dagger/internal/InstanceFactory.java
index d4b96ea2d..8cb993f17 100644
--- a/core/src/main/java/dagger/internal/InstanceFactory.java
+++ b/core/src/main/java/dagger/internal/InstanceFactory.java
@@ -16,24 +16,25 @@
 
 package dagger.internal;
 
+import static dagger.internal.Preconditions.checkNotNull;
+
+import dagger.Lazy;
+
 /**
- * A {@link Factory} implementation that returns a single instance for all invocations of
- * {@link #get}.
+ * A {@link Factory} implementation that returns a single instance for all invocations of {@link
+ * #get}.
  *
  * <p>Note that while this is a {@link Factory} implementation, and thus unscoped, each call to
- * {@link #get} will always return the same instance.  As such, any scoping applied to this factory
- * is redundant and unnecessary.  However, using this with {@link DoubleCheck#provider} is valid and
+ * {@link #get} will always return the same instance. As such, any scoping applied to this factory
+ * is redundant and unnecessary. However, using this with {@link DoubleCheck#provider} is valid and
  * may be desired for testing or contractual guarantees.
  *
  * @author Gregory Kick
  * @since 2.0
  */
-public final class InstanceFactory<T> implements Factory<T> {
+public final class InstanceFactory<T> implements Factory<T>, Lazy<T> {
   public static <T> Factory<T> create(T instance) {
-    if (instance == null) {
-      throw new NullPointerException();
-    }
-    return new InstanceFactory<T>(instance);
+    return new InstanceFactory<T>(checkNotNull(instance, "instance cannot be null"));
   }
 
   private final T instance;
diff --git a/core/src/main/java/dagger/internal/SetFactory.java b/core/src/main/java/dagger/internal/SetFactory.java
index 618df1b6e..b5a2ecd1e 100644
--- a/core/src/main/java/dagger/internal/SetFactory.java
+++ b/core/src/main/java/dagger/internal/SetFactory.java
@@ -38,13 +38,7 @@
  * @since 2.0
  */
 public final class SetFactory<T> implements Factory<Set<T>> {
-  private static final Factory<Set<Object>> EMPTY_FACTORY =
-      new Factory<Set<Object>>() {
-        @Override
-        public Set<Object> get() {
-          return emptySet();
-        }
-      };
+  private static final Factory<Set<Object>> EMPTY_FACTORY = InstanceFactory.create(emptySet());
 
   @SuppressWarnings({"unchecked", "rawtypes"}) // safe covariant cast
   public static <T> Factory<Set<T>> empty() {
diff --git a/core/src/test/java/dagger/internal/DoubleCheckTest.java b/core/src/test/java/dagger/internal/DoubleCheckTest.java
index eda82aaa0..0a5a55160 100644
--- a/core/src/test/java/dagger/internal/DoubleCheckTest.java
+++ b/core/src/test/java/dagger/internal/DoubleCheckTest.java
@@ -181,4 +181,10 @@ public Object get() {
       fail();
     } catch (IllegalStateException expected) {}
   }
+
+  @Test
+  public void instanceFactoryAsLazyDoesNotWrap() {
+    Factory<Object> factory = InstanceFactory.create(new Object());
+    assertThat(DoubleCheck.lazy(factory)).isSameAs(factory);
+  }
 }
diff --git a/core/src/test/java/dagger/internal/InstanceFactoryTest.java b/core/src/test/java/dagger/internal/InstanceFactoryTest.java
index 14474723a..82b66e687 100644
--- a/core/src/test/java/dagger/internal/InstanceFactoryTest.java
+++ b/core/src/test/java/dagger/internal/InstanceFactoryTest.java
@@ -17,17 +17,14 @@
 package dagger.internal;
 
 import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
 
-import org.junit.Rule;
 import org.junit.Test;
-import org.junit.rules.ExpectedException;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
 @RunWith(JUnit4.class)
 public final class InstanceFactoryTest {
-  @Rule public final ExpectedException thrown = ExpectedException.none();
-
   @Test public void instanceFactory() {
     Object instance = new Object();
     Factory<Object> factory = InstanceFactory.create(instance);
@@ -37,7 +34,10 @@
   }
 
   @Test public void create_throwsNullPointerException() {
-    thrown.expect(NullPointerException.class);
-    InstanceFactory.create(null);
+    try {
+      InstanceFactory.create(null);
+      fail();
+    } catch (NullPointerException expected) {
+    }
   }
 }
diff --git a/examples/android-activity-graphs/pom.xml b/examples/android-activity-graphs/pom.xml
index d25d7e280..1843eacb3 100644
--- a/examples/android-activity-graphs/pom.xml
+++ b/examples/android-activity-graphs/pom.xml
@@ -36,12 +36,10 @@
     <dependency>
       <groupId>com.google.dagger</groupId>
       <artifactId>dagger</artifactId>
-      <version>${project.version}</version>
     </dependency>
     <dependency>
       <groupId>com.google.dagger</groupId>
       <artifactId>dagger-compiler</artifactId>
-      <version>${project.version}</version>
       <scope>provided</scope>
       <optional>true</optional>
     </dependency>
diff --git a/examples/android-simple/pom.xml b/examples/android-simple/pom.xml
index 1c329fd6c..d0dee3b15 100644
--- a/examples/android-simple/pom.xml
+++ b/examples/android-simple/pom.xml
@@ -36,12 +36,10 @@
     <dependency>
       <groupId>com.google.dagger</groupId>
       <artifactId>dagger</artifactId>
-      <version>${project.version}</version>
     </dependency>
     <dependency>
       <groupId>com.google.dagger</groupId>
       <artifactId>dagger-compiler</artifactId>
-      <version>${project.version}</version>
       <scope>provided</scope>
       <optional>true</optional>
     </dependency>
diff --git a/examples/pom.xml b/examples/pom.xml
index acbab0a22..1985ff3db 100644
--- a/examples/pom.xml
+++ b/examples/pom.xml
@@ -48,6 +48,16 @@
         <artifactId>support-v4</artifactId>
         <version>r7</version>
       </dependency>
+      <dependency>
+        <groupId>com.google.dagger</groupId>
+        <artifactId>dagger</artifactId>
+        <version>${project.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>com.google.dagger</groupId>
+        <artifactId>dagger-compiler</artifactId>
+        <version>${project.version}</version>
+      </dependency>
     </dependencies>
   </dependencyManagement>
 
diff --git a/examples/simple/pom.xml b/examples/simple/pom.xml
index a28bf5f0e..c261d4df1 100644
--- a/examples/simple/pom.xml
+++ b/examples/simple/pom.xml
@@ -35,12 +35,10 @@
     <dependency>
       <groupId>com.google.dagger</groupId>
       <artifactId>dagger</artifactId>
-      <version>${project.version}</version>
     </dependency>
     <dependency>
       <groupId>com.google.dagger</groupId>
       <artifactId>dagger-compiler</artifactId>
-      <version>${project.version}</version>
       <optional>true</optional>
     </dependency>
   </dependencies>
diff --git a/gwt/pom.xml b/gwt/pom.xml
index 48c7828b1..1f1f0e04f 100644
--- a/gwt/pom.xml
+++ b/gwt/pom.xml
@@ -30,15 +30,15 @@
 
   <dependencies>
     <dependency>
-      <groupId>com.google.dagger</groupId>
+      <groupId>${project.groupId}</groupId>
       <artifactId>dagger</artifactId>
       <version>${project.version}</version>
     </dependency>
     <dependency>
-      <groupId>com.google.dagger</groupId>
+      <groupId>${project.groupId}</groupId>
       <artifactId>dagger</artifactId>
-      <version>${project.version}</version>
       <classifier>sources</classifier>
+      <version>${project.version}</version>
     </dependency>
   </dependencies>
 
diff --git a/pom.xml b/pom.xml
index 79b297e2c..3f81dc608 100644
--- a/pom.xml
+++ b/pom.xml
@@ -42,24 +42,6 @@
 
   <properties>
     <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
-
-    <!-- Compilation -->
-    <javax.inject.version>1</javax.inject.version>
-    <javax.annotation.version>3.0.1</javax.annotation.version>
-    <auto.common.version>0.7</auto.common.version>
-    <auto.factory.version>1.0-beta3</auto.factory.version>
-    <auto.service.version>1.0-rc2</auto.service.version>
-    <auto.value.version>1.3</auto.value.version>
-    <errorprone.version>2.0.12</errorprone.version>
-    <guava.version>19.0</guava.version>
-    <google.java.format.version>1.0</google.java.format.version>
-
-
-    <!-- Test Dependencies -->
-    <compile-testing.version>0.9</compile-testing.version>
-    <junit.version>4.11</junit.version>
-    <mockito.version>1.9.5</mockito.version>
-    <truth.version>0.30</truth.version>
   </properties>
 
   <scm>
@@ -91,72 +73,82 @@
       <dependency>
         <groupId>javax.inject</groupId>
         <artifactId>javax.inject</artifactId>
-        <version>${javax.inject.version}</version>
+        <version>1</version>
       </dependency>
-       <dependency>
+      <dependency>
         <groupId>javax.inject</groupId>
         <artifactId>javax.inject-tck</artifactId>
-        <version>${javax.inject.version}</version>
+        <version>1</version>
       </dependency>
       <dependency>
         <groupId>com.google.code.findbugs</groupId>
         <artifactId>jsr305</artifactId>
-        <version>${javax.annotation.version}</version>
+        <version>3.0.1</version>
       </dependency>
       <dependency>
         <groupId>com.google.guava</groupId>
         <artifactId>guava</artifactId>
-        <version>${guava.version}</version>
+        <version>19.0</version>
       </dependency>
       <dependency>
         <groupId>com.google.guava</groupId>
         <artifactId>guava-testlib</artifactId>
-        <version>${guava.version}</version>
+        <version>19.0</version>
       </dependency>
       <dependency>
         <groupId>com.google.googlejavaformat</groupId>
         <artifactId>google-java-format</artifactId>
-        <version>${google.java.format.version}</version>
+        <version>1.0</version>
       </dependency>
       <dependency>
         <groupId>com.google.auto</groupId>
         <artifactId>auto-common</artifactId>
-        <version>${auto.common.version}</version>
+        <version>0.7</version>
+      </dependency>
+      <dependency>
+        <groupId>com.google.auto.factory</groupId>
+        <artifactId>auto-factory</artifactId>
+        <version>1.0-beta3</version>
       </dependency>
       <dependency>
         <groupId>com.google.auto.service</groupId>
         <artifactId>auto-service</artifactId>
-        <version>${auto.service.version}</version>
+        <version>1.0-rc2</version>
       </dependency>
       <dependency>
         <groupId>com.google.auto.value</groupId>
         <artifactId>auto-value</artifactId>
-        <version>${auto.value.version}</version>
+        <version>1.3</version>
       </dependency>
       <dependency>
         <groupId>com.google.errorprone</groupId>
         <artifactId>error_prone_annotations</artifactId>
-        <version>${errorprone.version}</version>
+        <version>2.0.12</version>
       </dependency>
       <dependency>
         <groupId>junit</groupId>
         <artifactId>junit</artifactId>
-        <version>${junit.version}</version>
+        <version>4.11</version>
       </dependency>
       <dependency>
         <groupId>com.google.testing.compile</groupId>
         <artifactId>compile-testing</artifactId>
-        <version>${compile-testing.version}</version>
+        <version>0.9</version>
       </dependency>
       <dependency>
         <groupId>org.mockito</groupId>
         <artifactId>mockito-core</artifactId>
-        <version>${mockito.version}</version>
+        <version>1.9.5</version>
       </dependency>
       <dependency>
         <groupId>com.google.truth</groupId>
         <artifactId>truth</artifactId>
-        <version>${truth.version}</version>
+        <version>0.30</version>
+      </dependency>
+      <dependency>
+        <groupId>com.squareup</groupId>
+        <artifactId>javapoet</artifactId>
+        <version>1.7.0</version>
       </dependency>
     </dependencies>
   </dependencyManagement>
diff --git a/producers/src/main/java/dagger/producers/internal/MapOfProducerProducer.java b/producers/src/main/java/dagger/producers/internal/MapOfProducerProducer.java
index 673498ffc..216966e75 100644
--- a/producers/src/main/java/dagger/producers/internal/MapOfProducerProducer.java
+++ b/producers/src/main/java/dagger/producers/internal/MapOfProducerProducer.java
@@ -18,6 +18,7 @@
 
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.Maps.newLinkedHashMapWithExpectedSize;
+import static dagger.producers.internal.Producers.producerFromProvider;
 
 import com.google.common.collect.ImmutableMap;
 import com.google.common.util.concurrent.Futures;
@@ -25,6 +26,7 @@
 import dagger.internal.Beta;
 import dagger.producers.Producer;
 import java.util.Map;
+import javax.inject.Provider;
 
 /**
  * A {@link Producer} implementation used to implement {@link Map} bindings. This factory returns an
@@ -74,12 +76,20 @@ private Builder(int size) {
       return new MapOfProducerProducer<K, V>(ImmutableMap.copyOf(mapBuilder));
     }
 
-    /** Associates k with producerOfValue in {@code Builder}. */
+    /** Associates key with producerOfValue in {@code Builder}. */
     public Builder<K, V> put(K key, Producer<V> producerOfValue) {
       checkNotNull(key, "key");
       checkNotNull(producerOfValue, "producer of value");
       mapBuilder.put(key, producerOfValue);
       return this;
     }
+
+    /** Associates key with providerOfValue in {@code Builder}. */
+    public Builder<K, V> put(K key, Provider<V> providerOfValue) {
+      checkNotNull(key, "key");
+      checkNotNull(providerOfValue, "provider of value");
+      mapBuilder.put(key, producerFromProvider(providerOfValue));
+      return this;
+    }
   }
 }
