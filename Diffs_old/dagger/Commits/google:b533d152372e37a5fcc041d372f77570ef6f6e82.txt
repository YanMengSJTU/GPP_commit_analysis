diff --git a/core/src/main/java/dagger/ObjectGraph.java b/core/src/main/java/dagger/ObjectGraph.java
index 1fe64b407..5ffa23f0d 100644
--- a/core/src/main/java/dagger/ObjectGraph.java
+++ b/core/src/main/java/dagger/ObjectGraph.java
@@ -23,6 +23,7 @@
 import dagger.internal.Loader;
 import dagger.internal.ModuleAdapter;
 import dagger.internal.ProblemDetector;
+import dagger.internal.SetBinding;
 import dagger.internal.StaticInjection;
 import dagger.internal.ThrowingErrorHandler;
 import dagger.internal.UniqueMap;
@@ -162,31 +163,48 @@ private static ObjectGraph makeGraph(DaggerObjectGraph base, Loader plugin, Obje
 
       // Extract bindings in the 'base' and 'overrides' set. Within each set no
       // duplicates are permitted.
-      Map<String, Binding<?>> baseBindings = new UniqueMap<String, Binding<?>>();
-      Map<String, Binding<?>> overrideBindings = new UniqueMap<String, Binding<?>>();
+      UniqueMap<String, Binding<?>> baseBindings = new UniqueMap<String, Binding<?>>() {
+        @Override public Binding<?> put(String key, Binding<?> value) {
+          return super.put(key, (value instanceof SetBinding)
+              ? new SetBinding<Object>((SetBinding<Object>) value) : value);
+        }
+      };
+      if (base != null) {
+        baseBindings.putAll(base.linkEverything()); // Add parent bindings
+      }
+      UniqueMap<String, Binding<?>> overrideBindings = new UniqueMap<String, Binding<?>>() {
+        @Override public Binding<?> put(String key, Binding<?> value) {
+          if (value instanceof SetBinding) {
+            throw new IllegalArgumentException("Module overrides cannot contribute set bindings.");
+          }
+          return super.put(key, value);
+        }
+      };
       for (ModuleAdapter<?> moduleAdapter : getAllModuleAdapters(plugin, modules).values()) {
-        for (String key : moduleAdapter.injectableTypes) {
-          injectableTypes.put(key, moduleAdapter.getModule().getClass());
+        for (int i = 0; i < moduleAdapter.injectableTypes.length; i++) {
+          injectableTypes.put(moduleAdapter.injectableTypes[i], moduleAdapter.getModuleClass());
         }
-        for (Class<?> c : moduleAdapter.staticInjections) {
-          staticInjections.put(c, null);
+        for (int i = 0; i < moduleAdapter.staticInjections.length; i++) {
+          staticInjections.put(moduleAdapter.staticInjections[i], null);
+        }
+        try {
+          moduleAdapter.getBindings(moduleAdapter.overrides ? overrideBindings : baseBindings);
+        } catch (IllegalArgumentException e) {
+          throw new IllegalArgumentException(moduleAdapter.getModuleClass().getSimpleName()
+              + " is an overriding module and cannot contribute set bindings.");
         }
-        Map<String, Binding<?>> addTo = moduleAdapter.overrides ? overrideBindings : baseBindings;
-        moduleAdapter.getBindings(addTo);
       }
 
       // Create a linker and install all of the user's bindings
-      Linker linker = new Linker((base != null) ? base.linker : null, plugin,
-          new ThrowingErrorHandler());
+      Linker linker =
+          new Linker((base != null) ? base.linker : null, plugin, new ThrowingErrorHandler());
       linker.installBindings(baseBindings);
       linker.installBindings(overrideBindings);
 
       return new DaggerObjectGraph(base, linker, plugin, staticInjections, injectableTypes);
     }
 
-
     @Override public ObjectGraph plus(Object... modules) {
-      linkEverything();
       return makeGraph(this, plugin, modules);
     }
 
@@ -292,4 +310,5 @@ private void linkInjectableTypes() {
       }
     }
   }
+
 }
diff --git a/core/src/main/java/dagger/internal/Linker.java b/core/src/main/java/dagger/internal/Linker.java
index 86edaf545..57e5b0459 100644
--- a/core/src/main/java/dagger/internal/Linker.java
+++ b/core/src/main/java/dagger/internal/Linker.java
@@ -280,10 +280,9 @@ private void assertLockHeld() {
    * Returns a scoped binding for {@code binding}.
    */
   static <T> Binding<T> scope(final Binding<T> binding) {
-    if (!binding.isSingleton()) {
-      return binding;
+    if (!binding.isSingleton() || binding instanceof SingletonBinding) {
+      return binding; // Default scoped binding or already a scoped binding.
     }
-    if (binding instanceof SingletonBinding) throw new AssertionError();
     return new SingletonBinding<T>(binding);
   }
 
@@ -424,5 +423,8 @@ private DeferredBinding(String deferredKey, ClassLoader classLoader, Object requ
     @Override public void getDependencies(Set<Binding<?>> get, Set<Binding<?>> injectMembers) {
       throw new UnsupportedOperationException("Deferred bindings must resolve first.");
     }
+    @Override public String toString() {
+      return "DeferredBinding[deferredKey=" + deferredKey + "]";
+    }
   }
 }
diff --git a/core/src/main/java/dagger/internal/ModuleAdapter.java b/core/src/main/java/dagger/internal/ModuleAdapter.java
index ab255ce21..818ec00c9 100644
--- a/core/src/main/java/dagger/internal/ModuleAdapter.java
+++ b/core/src/main/java/dagger/internal/ModuleAdapter.java
@@ -57,7 +57,7 @@ protected T newModule() {
     throw new UnsupportedOperationException("No no-args constructor on " + getClass().getName());
   }
 
-  public T getModule() {
-    return module;
+  public Class<?> getModuleClass() {
+    return module.getClass();
   }
 }
diff --git a/core/src/main/java/dagger/internal/Modules.java b/core/src/main/java/dagger/internal/Modules.java
index ef994cd31..36bde7558 100644
--- a/core/src/main/java/dagger/internal/Modules.java
+++ b/core/src/main/java/dagger/internal/Modules.java
@@ -50,7 +50,7 @@ private Modules() { }
     // Add the adapters that we have module instances for. This way we won't
     // construct module objects when we have a user-supplied instance.
     for (ModuleAdapter<?> adapter : seedAdapters) {
-      adaptersByModuleType.put(adapter.getModule().getClass(), adapter);
+      adaptersByModuleType.put(adapter.getModuleClass(), adapter);
     }
 
     // Next add adapters for the modules that we need to construct. This creates
diff --git a/core/src/main/java/dagger/internal/SetBinding.java b/core/src/main/java/dagger/internal/SetBinding.java
index 9b94c78f1..202fa5be8 100644
--- a/core/src/main/java/dagger/internal/SetBinding.java
+++ b/core/src/main/java/dagger/internal/SetBinding.java
@@ -28,27 +28,45 @@
  */
 public final class SetBinding<T> extends Binding<Set<T>> {
 
-  @SuppressWarnings("unchecked")
   public static <T> void add(Map<String, Binding<?>> bindings, String setKey, Binding<?> binding) {
+    prepareSetBinding(bindings, setKey, binding).contributors.add(Linker.scope(binding));
+  }
+
+  @SuppressWarnings("unchecked")
+  private static <T> SetBinding<T> prepareSetBinding(
+      Map<String, Binding<?>> bindings, String setKey, Binding<?> binding) {
     Binding<?> previous = bindings.get(setKey);
     SetBinding<T> setBinding;
     if (previous instanceof SetBinding) {
-      setBinding = (SetBinding) previous;
+      return (SetBinding<T>) previous;
     } else if (previous != null) {
       throw new IllegalArgumentException("Duplicate:\n    " + previous + "\n    " + binding);
     } else {
       setBinding = new SetBinding<T>(setKey, binding.requiredBy);
       bindings.put(setKey, setBinding);
+      return (SetBinding<T>) bindings.get(setKey); // BindingMap.put() copies SetBindings.
     }
-    setBinding.contributors.add(Linker.scope(binding));
   }
 
   private final Set<Binding<?>> contributors = new LinkedHashSet<Binding<?>>();
 
+  /**
+   * Creates a new {@code SetBinding} with the given "provides" key, and the requiredBy object
+   * for traceability.
+   */
   public SetBinding(String key, Object requiredBy) {
     super(key, null, false, requiredBy);
   }
 
+  /**
+   * Creates a new {@code SetBinding} with all of the contributing bindings of the provided
+   * original {@code SetBinding}.
+   */
+  public SetBinding(SetBinding<T> original) {
+    super(original.provideKey, null, false, original.requiredBy);
+    contributors.addAll(original.contributors);
+  }
+
   @Override public void attach(Linker linker) {
     for (Binding<?> contributor : contributors) {
       contributor.attach(linker);
diff --git a/core/src/test/java/dagger/ExtensionWithSetBindingsTest.java b/core/src/test/java/dagger/ExtensionWithSetBindingsTest.java
new file mode 100644
index 000000000..0f604236b
--- /dev/null
+++ b/core/src/test/java/dagger/ExtensionWithSetBindingsTest.java
@@ -0,0 +1,88 @@
+/*
+ * Copyright (C) 2013 Google Inc.
+ * Copyright (C) 2013 Square Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger;
+
+import dagger.internal.TestingLoader;
+import java.util.Set;
+import java.util.concurrent.atomic.AtomicInteger;
+import javax.inject.Inject;
+import javax.inject.Singleton;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static dagger.Provides.Type.SET;
+import static org.fest.assertions.Assertions.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+@RunWith(JUnit4.class)
+public final class ExtensionWithSetBindingsTest {
+  private static final AtomicInteger counter = new AtomicInteger(0);
+
+  @Singleton
+  static class RealSingleton {
+    @Inject Set<Integer> ints;
+  }
+
+  @Singleton
+  static class Main {
+    @Inject Set<Integer> ints;
+  }
+
+  @Module(injects = RealSingleton.class)
+  static class RootModule {
+    @Provides(type=SET) @Singleton Integer provideA() { return counter.getAndIncrement(); }
+    @Provides(type=SET) @Singleton Integer provideB() { return counter.getAndIncrement(); }
+  }
+
+  @Module(addsTo = RootModule.class, injects = Main.class )
+  static class ExtensionModule {
+    @Provides(type=SET) @Singleton Integer provideC() { return counter.getAndIncrement(); }
+    @Provides(type=SET) @Singleton Integer provideD() { return counter.getAndIncrement(); }
+  }
+
+  @Test public void basicInjectionWithExtension() {
+    ObjectGraph root = ObjectGraph.createWith(new TestingLoader(), new RootModule());
+    RealSingleton rs = root.get(RealSingleton.class);
+    assertThat(rs.ints).contains(0, 1);
+
+    ObjectGraph extension = root.plus(new ExtensionModule());
+    Main main = extension.get(Main.class);
+    assertThat(main.ints).contains(0, 1, 2, 3);
+
+    // Second time around.
+    ObjectGraph extension2 = root.plus(new ExtensionModule());
+    Main main2 = extension2.get(Main.class);
+    assertThat(main2.ints).contains(0, 1, 4, 5);
+  }
+
+  @Module(includes = ExtensionModule.class, overrides = true)
+  static class TestModule {
+    @Provides(type=SET) @Singleton Integer provide9999() { return 9999; }
+  }
+
+  @Test public void basicInjectionWithExtensionAndOverrides() {
+    try {
+      ObjectGraph.createWith(new TestingLoader(), new RootModule()).plus(new TestModule());
+      fail("Should throw exception.");
+    } catch (IllegalArgumentException e) {
+      assertEquals("TestModule is an overriding module and cannot contribute set bindings.",
+          e.getMessage());
+    }
+  }
+}
diff --git a/core/src/test/java/dagger/internal/TestingModuleAdapter.java b/core/src/test/java/dagger/internal/TestingModuleAdapter.java
index 2819a5e55..04dcc5e54 100644
--- a/core/src/test/java/dagger/internal/TestingModuleAdapter.java
+++ b/core/src/test/java/dagger/internal/TestingModuleAdapter.java
@@ -128,6 +128,10 @@ private void handleSetBindings(Map<String, Binding<?>> bindings, Method method,
     }
   }
 
+  @Override public String toString() {
+    return "TestingModuleAdapter[" + this.moduleClass.getName() + "]";
+  }
+
   /**
    * Creates a TestingModuleAdapter or throws an {@code IllegalArgumentException}.
    */
