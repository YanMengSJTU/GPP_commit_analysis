diff --git a/core/src/main/java/dagger/ObjectGraph.java b/core/src/main/java/dagger/ObjectGraph.java
index 1e86b1b82..6432c84e3 100644
--- a/core/src/main/java/dagger/ObjectGraph.java
+++ b/core/src/main/java/dagger/ObjectGraph.java
@@ -33,7 +33,6 @@
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
-import java.util.Map.Entry;
 
 
 /**
@@ -130,8 +129,15 @@ public static ObjectGraph create(Object... modules) {
     return DaggerObjectGraph.makeGraph(null, new FailoverLoader(), modules);
   }
 
-  // visible for testing
-  static ObjectGraph createWith(Loader loader, Object... modules) {
+  /**
+   * Load the graph with a custom loading strategy.  If you're not using this to work around
+   * proguard obfuscation, then use {@link #create(Object...)}
+   *
+   * @deprecated Recreated for reflective use of Dagger in the obfuscation case, and will be
+   *     entirely obsolete in Dagger 2.0.
+   */
+  @Deprecated
+  public static ObjectGraph createWith(Loader loader, Object... modules) {
     return DaggerObjectGraph.makeGraph(null, loader, modules);
   }
 
diff --git a/core/src/main/java/dagger/internal/ReflectiveLoader.java b/core/src/main/java/dagger/internal/ReflectiveLoader.java
new file mode 100644
index 000000000..038fb6084
--- /dev/null
+++ b/core/src/main/java/dagger/internal/ReflectiveLoader.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ * Copyright (C) 2013 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+
+import dagger.internal.loaders.ReflectiveAtInjectBinding;
+import dagger.internal.loaders.ReflectiveModuleAdapter;
+import dagger.internal.loaders.ReflectiveStaticInjection;
+
+import static dagger.internal.loaders.GeneratedAdapters.STATIC_INJECTION_SUFFIX;
+
+/**
+ * Handles loading/finding of modules, injection bindings, and static injections by use of a
+ * reflective bindings.
+ *
+ * @deprecated Provided only to work around proguard obfuscation - obsolete in 2.0.
+ */
+@Deprecated
+public final class ReflectiveLoader extends Loader {
+  /**
+   * Obtains a {@link ReflectiveModuleAdapter} for {@code module}.
+   */
+  @SuppressWarnings("unchecked") // cache ensures types match
+  @Override public <T> ModuleAdapter<T> getModuleAdapter(Class<T> type) {
+    return ReflectiveModuleAdapter.create(type);
+  }
+
+  /**
+   * Obtains a {@link ReflectiveAtInjectBinding} for a given key.
+   */
+  @Override public Binding<?> getAtInjectBinding(
+      String key, String className, ClassLoader classLoader, boolean mustHaveInjections) {
+    Class<?> type = loadClass(classLoader, className);
+    if (type.equals(Void.class)) {
+      throw new IllegalStateException(
+          String.format("Could not load class %s needed for binding %s", className, key));
+    }
+    if (type.isInterface()) {
+      return null; // Short-circuit since we can't build reflective bindings for interfaces.
+    }
+    return ReflectiveAtInjectBinding.createFactory(type).create(mustHaveInjections);
+  }
+
+  @Override public StaticInjection getStaticInjection(Class<?> injectedClass) {
+    return ReflectiveStaticInjection.create(injectedClass);
+  }
+}
diff --git a/core/src/main/java/dagger/internal/loaders/ReflectiveModuleAdapter.java b/core/src/main/java/dagger/internal/loaders/ReflectiveModuleAdapter.java
new file mode 100644
index 000000000..a9c28bada
--- /dev/null
+++ b/core/src/main/java/dagger/internal/loaders/ReflectiveModuleAdapter.java
@@ -0,0 +1,217 @@
+package dagger.internal.loaders;
+
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import dagger.Lazy;
+import dagger.Module;
+import dagger.Provides;
+import dagger.internal.Binding;
+import dagger.internal.BindingsGroup;
+import dagger.internal.Keys;
+import dagger.internal.Linker;
+import dagger.internal.ModuleAdapter;
+import dagger.internal.ProvidesBinding;
+import dagger.internal.SetBinding;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.util.Set;
+import javax.inject.Provider;
+import javax.inject.Singleton;
+
+
+/**
+ * @deprecated this is in place to temporarily support obfuscation needs and
+ *     will not exist as of Dagger 2.0
+ */
+@Deprecated
+public class ReflectiveModuleAdapter<M> extends ModuleAdapter<M> {
+  public ReflectiveModuleAdapter(Class<M> moduleClass, Module annotation) {
+    super(
+        moduleClass,
+        injectableTypesToKeys(annotation.injects()),
+        annotation.staticInjections(),
+        annotation.overrides(),
+        annotation.includes(),
+        annotation.complete(),
+        annotation.library());
+  }
+
+  private static String[] injectableTypesToKeys(Class<?>[] injectableTypes) {
+    String[] result = new String[injectableTypes.length];
+    for (int i = 0; i < injectableTypes.length; i++) {
+      Class<?> injectableType = injectableTypes[i];
+      result[i] = injectableType.isInterface()
+          ? Keys.get(injectableType)
+          : Keys.getMembersKey(injectableType);
+    }
+    return result;
+  }
+
+  @Override public void getBindings(BindingsGroup bindings, M module) {
+    for (Class<?> c = moduleClass; !c.equals(Object.class); c = c.getSuperclass()) {
+      for (Method method : c.getDeclaredMethods()) {
+        Provides provides = method.getAnnotation(Provides.class);
+        if (provides != null) {
+          Type genericReturnType = method.getGenericReturnType();
+
+          Type typeToCheck = genericReturnType;
+          if (genericReturnType instanceof ParameterizedType) {
+            typeToCheck = ((ParameterizedType) genericReturnType).getRawType();
+          }
+          if (Provider.class.equals(typeToCheck)) {
+            throw new IllegalStateException("@Provides method must not return Provider directly: "
+                + c.getName()
+                + "."
+                + method.getName());
+          }
+          if (Lazy.class.equals(typeToCheck)) {
+            throw new IllegalStateException("@Provides method must not return Lazy directly: "
+                + c.getName()
+                + "."
+                + method.getName());
+          }
+
+          String key = Keys.get(genericReturnType, method.getAnnotations(), method);
+          switch (provides.type()) {
+            case UNIQUE:
+              handleBindings(bindings, module, method, key, library);
+              break;
+            case SET:
+              String setKey = Keys.getSetKey(method.getGenericReturnType(),
+                  method.getAnnotations(), method);
+              handleSetBindings(bindings, module, method, setKey, key, library);
+              break;
+            case SET_VALUES:
+              handleSetBindings(bindings, module, method, key, key, library);
+              break;
+            default:
+              throw new AssertionError("Unknown @Provides type " + provides.type());
+          }
+        }
+      }
+    }
+  }
+
+  private void handleBindings(BindingsGroup bindings, M module, Method method, String key,
+      boolean library) {
+    bindings.contributeProvidesBinding(key,
+        new ReflectiveProvidesBinding<M>(method, key, moduleClass.getName(), module, library));
+  }
+
+  private void handleSetBindings(BindingsGroup bindings, M module, Method method,
+      String setKey, String providerKey, boolean library) {
+    SetBinding.<M>add(bindings, setKey,
+        new ReflectiveProvidesBinding<M>(
+            method, providerKey, moduleClass.getName(), module, library));
+  }
+
+  @Override public M newModule() {
+    try {
+      Constructor<?> constructor = moduleClass.getDeclaredConstructor();
+      constructor.setAccessible(true);
+      return (M)constructor.newInstance();
+    } catch (InvocationTargetException e) {
+      throw new IllegalArgumentException(e.getCause());
+    } catch (NoSuchMethodException e) {
+      throw new IllegalArgumentException("Could not construct " + moduleClass.getName()
+          + " as it lacks an accessible no-args constructor. This module must be passed"
+          + " in as an instance, or an accessible no-args constructor must be added.", e);
+    } catch (InstantiationException e) {
+      throw new IllegalArgumentException("Failed to construct " + moduleClass.getName(), e);
+    } catch (IllegalAccessException e) {
+      throw new AssertionError();
+    }
+  }
+
+  @Override public String toString() {
+    return "ReflectiveModuleAdapter[" + this.moduleClass.getName() + "]";
+  }
+
+  /**
+   * Creates a ReflectiveModuleAdapter or throws an {@code IllegalArgumentException}.
+   */
+  public static <M> ModuleAdapter<M> create(Class<M> moduleClass) {
+    Module annotation = moduleClass.getAnnotation(Module.class);
+    if (annotation == null) {
+      throw new IllegalArgumentException("No @Module on " + moduleClass.getName());
+    }
+    if (!moduleClass.getSuperclass().equals(Object.class)) {
+      throw new IllegalArgumentException(
+          "Modules must not extend from other classes: " + moduleClass.getName());
+    }
+    return new ReflectiveModuleAdapter<M>(moduleClass, annotation);
+  }
+
+  /**
+   * Invokes a method to provide a value. The method's parameters are injected.
+   */
+  private static final class ReflectiveProvidesBinding<T> extends ProvidesBinding<T> {
+    private Binding<?>[] parameters;
+    private final Method method;
+    private final Object instance;
+
+    public ReflectiveProvidesBinding(Method method, String key, String moduleClass,
+        Object instance, boolean library) {
+      super(key, method.isAnnotationPresent(Singleton.class), moduleClass, method.getName());
+      this.method = method;
+      this.instance = instance;
+      method.setAccessible(true);
+      setLibrary(library);
+    }
+
+    @Override public void attach(Linker linker) {
+      Type[] types = method.getGenericParameterTypes();
+      Annotation[][] annotations = method.getParameterAnnotations();
+      parameters = new Binding[types.length];
+      for (int i = 0; i < parameters.length; i++) {
+        String key = Keys.get(types[i], annotations[i], method + " parameter " + i);
+        parameters[i] = linker.requestBinding(key, method, instance.getClass().getClassLoader());
+      }
+    }
+
+    @Override public T get() {
+      Object[] args = new Object[parameters.length];
+      for (int i = 0; i < parameters.length; i++) {
+        args[i] = parameters[i].get();
+      }
+      try {
+        return (T) method.invoke(instance, args);
+      } catch (InvocationTargetException e) {
+        Throwable cause = e.getCause();
+        throw cause instanceof RuntimeException
+            ? (RuntimeException) cause
+            : new RuntimeException(cause);
+      } catch (IllegalAccessException e) {
+        throw new RuntimeException(e);
+      }
+    }
+
+    @Override public void getDependencies(Set<Binding<?>> get, Set<Binding<?>> injectMembers) {
+      for (Binding<?> binding : parameters) {
+        get.add(binding);
+      }
+    }
+
+    @Override public void injectMembers(T t) {
+      throw new AssertionError("Provides method bindings are not MembersInjectors");
+    }
+  }
+}
diff --git a/core/src/test/java/dagger/ReflectiveLoaderTest.java b/core/src/test/java/dagger/ReflectiveLoaderTest.java
new file mode 100644
index 000000000..c15d0e623
--- /dev/null
+++ b/core/src/test/java/dagger/ReflectiveLoaderTest.java
@@ -0,0 +1,279 @@
+/*
+ * Copyright (C) 2012 Square Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger;
+
+import dagger.internal.Loader;
+import dagger.internal.ReflectiveLoader;
+import javax.inject.Inject;
+import javax.inject.Provider;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static org.fest.assertions.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+/**
+ * @deprecated This exists to test ReflectiveLoader which is obsolete but needed to work around
+ *     proguard obfuscation.
+ */
+@Deprecated
+@RunWith(JUnit4.class)
+public final class ReflectiveLoaderTest {
+  private static final Loader LOADER = new ReflectiveLoader();
+
+  static class TestEntryPoint {
+    @Inject String s;
+  }
+
+  @Module(injects = TestEntryPoint.class)
+  static class ModuleWithEntryPoint {
+  }
+
+  @Test public void childModuleWithEntryPoint() {
+    @Module(includes = ModuleWithEntryPoint.class)
+    class TestModule {
+      @Provides String provideString() {
+        return "injected";
+      }
+    }
+
+    ObjectGraph objectGraph = ObjectGraph.createWith(LOADER, new TestModule());
+    TestEntryPoint entryPoint = objectGraph.get(TestEntryPoint.class);
+    assertThat(entryPoint.s).isEqualTo("injected");
+  }
+
+  static class TestStaticInjection {
+    @Inject static String s;
+  }
+
+  @Module(staticInjections = TestStaticInjection.class)
+  static class ModuleWithStaticInjection {
+  }
+
+  @Test public void childModuleWithStaticInjection() {
+    @Module(includes = ModuleWithStaticInjection.class)
+    class TestModule {
+      @Provides String provideString() {
+        return "injected";
+      }
+    }
+
+    ObjectGraph objectGraph = ObjectGraph.createWith(LOADER, new TestModule());
+    TestStaticInjection.s = null;
+    objectGraph.injectStatics();
+    assertThat(TestStaticInjection.s).isEqualTo("injected");
+  }
+
+  @Module
+  static class ModuleWithBinding {
+    @Provides String provideString() {
+      return "injected";
+    }
+  }
+
+  @Test public void childModuleWithBinding() {
+
+    @Module(
+        injects = TestEntryPoint.class,
+        includes = ModuleWithBinding.class
+    )
+    class TestModule {
+    }
+
+    ObjectGraph objectGraph = ObjectGraph.createWith(LOADER, new TestModule());
+    TestEntryPoint entryPoint = new TestEntryPoint();
+    objectGraph.inject(entryPoint);
+    assertThat(entryPoint.s).isEqualTo("injected");
+  }
+
+  @Module(includes = ModuleWithBinding.class)
+  static class ModuleWithChildModule {
+  }
+
+  @Test public void childModuleWithChildModule() {
+
+    @Module(
+        injects = TestEntryPoint.class,
+        includes = ModuleWithChildModule.class
+    )
+    class TestModule {
+    }
+
+    ObjectGraph objectGraph = ObjectGraph.createWith(LOADER, new TestModule());
+    TestEntryPoint entryPoint = new TestEntryPoint();
+    objectGraph.inject(entryPoint);
+    assertThat(entryPoint.s).isEqualTo("injected");
+  }
+
+  @Module
+  static class ModuleWithConstructor {
+    private final String value;
+
+    ModuleWithConstructor(String value) {
+      this.value = value;
+    }
+
+    @Provides String provideString() {
+      return value;
+    }
+  }
+
+  @Test public void childModuleMissingManualConstruction() {
+    @Module(includes = ModuleWithConstructor.class)
+    class TestModule {
+    }
+
+    try {
+      ObjectGraph.createWith(LOADER, new TestModule());
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void childModuleWithManualConstruction() {
+
+    @Module(
+        injects = TestEntryPoint.class,
+        includes = ModuleWithConstructor.class
+    )
+    class TestModule {
+    }
+
+    ObjectGraph objectGraph = ObjectGraph.createWith(LOADER, new ModuleWithConstructor("a"), new TestModule());
+    TestEntryPoint entryPoint = new TestEntryPoint();
+    objectGraph.inject(entryPoint);
+    assertThat(entryPoint.s).isEqualTo("a");
+  }
+
+  static class A {}
+
+  static class B { @Inject A a; }
+
+  @Module(injects = A.class) public static class TestModuleA {
+    @Provides A a() { return new A(); }
+  }
+
+  @Module(includes = TestModuleA.class, injects = B.class) public static class TestModuleB {}
+
+  @Test public void autoInstantiationOfModules() {
+    // Have to make these non-method-scoped or instantiation errors occur.
+    ObjectGraph objectGraph = ObjectGraph.createWith(LOADER, TestModuleA.class);
+    assertThat(objectGraph.get(A.class)).isNotNull();
+  }
+
+  @Test public void autoInstantiationOfIncludedModules() {
+    // Have to make these non-method-scoped or instantiation errors occur.
+    ObjectGraph objectGraph = ObjectGraph.createWith(LOADER, new TestModuleB()); // TestModuleA auto-created.
+    assertThat(objectGraph.get(A.class)).isNotNull();
+    assertThat(objectGraph.get(B.class).a).isNotNull();
+  }
+
+  static class ModuleMissingModuleAnnotation {}
+
+  @Module(includes = ModuleMissingModuleAnnotation.class)
+  static class ChildModuleMissingModuleAnnotation {}
+
+  @Test
+  public void childModuleMissingModuleAnnotation() {
+    try {
+      ObjectGraph.createWith(LOADER, new ChildModuleMissingModuleAnnotation());
+    } catch (IllegalArgumentException e) {
+      assertThat(e.getMessage())
+          .contains("No @Module on ").contains("ModuleMissingModuleAnnotation");
+    }
+  }
+
+  @Module
+  static class ThreadModule extends Thread {}
+
+  @Test public void moduleExtendingClassThrowsException() {
+    try {
+      ObjectGraph.createWith(LOADER, new ThreadModule());
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e.getMessage()).startsWith("Modules must not extend from other classes: ");
+    }
+  }
+
+  @Test public void provideProviderFails() {
+    @Module
+    class ProvidesProviderModule {
+      @Provides Provider<Object> provideObject() {
+        return null;
+      }
+    }
+    try {
+      ObjectGraph.createWith(LOADER, new ProvidesProviderModule());
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e.getMessage()) //
+          .startsWith("@Provides method must not return Provider directly: ")
+          .endsWith("ProvidesProviderModule.provideObject");
+    }
+  }
+
+  @Test public void provideRawProviderFails() {
+    @Module
+    class ProvidesRawProviderModule {
+      @Provides Provider provideObject() {
+        return null;
+      }
+    }
+    try {
+      ObjectGraph.createWith(LOADER, new ProvidesRawProviderModule());
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e.getMessage()) //
+          .startsWith("@Provides method must not return Provider directly: ")
+          .endsWith("ProvidesRawProviderModule.provideObject");
+    }
+  }
+
+  @Test public void provideLazyFails() {
+    @Module
+    class ProvidesLazyModule {
+      @Provides Lazy<Object> provideObject() {
+        return null;
+      }
+    }
+    try {
+      ObjectGraph.createWith(LOADER, new ProvidesLazyModule());
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e.getMessage()) //
+          .startsWith("@Provides method must not return Lazy directly: ")
+          .endsWith("ProvidesLazyModule.provideObject");
+    }
+  }
+
+  @Test public void provideRawLazyFails() {
+    @Module
+    class ProvidesRawLazyModule {
+      @Provides Lazy provideObject() {
+        return null;
+      }
+    }
+    try {
+      ObjectGraph.createWith(LOADER, new ProvidesRawLazyModule());
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e.getMessage()) //
+          .startsWith("@Provides method must not return Lazy directly: ")
+          .endsWith("ProvidesRawLazyModule.provideObject");
+    }
+  }
+}
