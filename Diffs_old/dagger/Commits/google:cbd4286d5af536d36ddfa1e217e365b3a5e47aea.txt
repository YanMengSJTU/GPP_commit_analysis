diff --git a/README.md b/README.md
index b035cc66e..4a6d9bedc 100644
--- a/README.md
+++ b/README.md
@@ -44,6 +44,8 @@ In order to activate code generation and generate implementations to manage
 your graph you will need to include `dagger-compiler-2.1.jar` in your build
 at compile time.
 
+### Maven
+
 In a Maven project, include the `dagger` artifact in the dependencies section
 of your `pom.xml` and the `dagger-compiler` artifact as either an `optional` or
 `provided` dependency:
@@ -77,6 +79,41 @@ parallelizable execution graphs), then add this to your maven configuration:
 </dependencies>
 ```
 
+### Java Gradle
+```groovy
+// Add plugin https://plugins.gradle.org/plugin/net.ltgt.apt
+plugins {
+  id "net.ltgt.apt" version "0.5"
+}
+
+// Add Dagger dependencies
+dependencies {
+  compile 'com.google.dagger:dagger:2.0.2'
+  apt 'com.google.dagger:dagger-compiler:2.0.2'
+}
+```
+
+### Android Gradle
+```groovy
+// Add plugin https://bitbucket.org/hvisser/android-apt
+buildscript {
+  repositories {
+    mavenCentral()
+  }
+  dependencies {
+    classpath 'com.neenbedankt.gradle.plugins:android-apt:1.8'
+  }
+}
+
+// Apply plugin
+apply plugin: 'com.neenbedankt.android-apt'
+
+// Add Dagger dependencies
+dependencies {
+  compile 'com.google.dagger:dagger:2.0.2'
+  apt 'com.google.dagger:dagger-compiler:2.0.2'
+}
+```
 
 ### Download
 
diff --git a/compiler/pom.xml b/compiler/pom.xml
index 3411d1fc0..5a982c35e 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -70,7 +70,6 @@
     <dependency>
       <groupId>com.google.auto.value</groupId>
       <artifactId>auto-value</artifactId>
-      <version>1.1</version>
       <scope>provided</scope> <!-- to leave out of the all-deps jar -->
     </dependency>
 
diff --git a/compiler/src/it/functional-tests/src/main/java/test/ComponentDependsOnGeneratedCode.java b/compiler/src/it/functional-tests/src/main/java/test/ComponentDependsOnGeneratedCode.java
index 6ffe1e07d..bd49a2459 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/ComponentDependsOnGeneratedCode.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/ComponentDependsOnGeneratedCode.java
@@ -17,6 +17,13 @@
 
 import dagger.Component;
 
+/**
+ * A component that indirectly depends on code generated by another processor, in this case
+ * {@link com.google.auto.factory.AutoFactory}. Neither this type nor its immediately referenced
+ * types are generated, but {@link NeedsFactory} depends on the generated
+ * {@link NeedsFactory_SomethingFactory}.
+ *
+ */
 @Component
 interface ComponentDependsOnGeneratedCode {
   NeedsFactory needsFactory();
diff --git a/compiler/src/it/functional-tests/src/main/java/test/ComponentSupertypeDependsOnGeneratedCode.java b/compiler/src/it/functional-tests/src/main/java/test/ComponentSupertypeDependsOnGeneratedCode.java
index f7460c989..6cbf6af8d 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/ComponentSupertypeDependsOnGeneratedCode.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/ComponentSupertypeDependsOnGeneratedCode.java
@@ -17,6 +17,11 @@
 
 import dagger.Component;
 
+/**
+ * A component whose supertype depends on code generated by another processor, in this case
+ * {@link com.google.auto.factory.AutoFactory}.
+ *
+ */
 @Component
 interface ComponentSupertypeDependsOnGeneratedCode
     extends ComponentSupertypeDependsOnGeneratedCodeInterface {}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/cycle/Cycles.java b/compiler/src/it/functional-tests/src/main/java/test/cycle/Cycles.java
index 63bf45c87..d422245f6 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/cycle/Cycles.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/cycle/Cycles.java
@@ -15,6 +15,7 @@
  */
 package test.cycle;
 
+import dagger.Binds;
 import dagger.Component;
 import dagger.Lazy;
 import dagger.Module;
@@ -22,7 +23,9 @@
 import dagger.Subcomponent;
 import dagger.multibindings.IntoMap;
 import dagger.multibindings.StringKey;
+
 import java.util.Map;
+
 import javax.inject.Inject;
 import javax.inject.Provider;
 
@@ -117,20 +120,16 @@ private Cycles() {}
   }
 
   @Module
-  static class CycleMapModule {
-    @Provides
+  abstract static class CycleMapModule {
+    @Binds
     @IntoMap
     @StringKey("X")
-    static X x(X x) {
-      return x;
-    }
+    abstract X x(X x);
 
-    @Provides
+    @Binds
     @IntoMap
     @StringKey("Y")
-    static Y y(Y y) {
-      return y;
-    }
+    abstract Y y(Y y);
   }
 
   @SuppressWarnings("dependency-cycle")
diff --git a/compiler/src/it/functional-tests/src/main/java/test/cycle/LongCycle.java b/compiler/src/it/functional-tests/src/main/java/test/cycle/LongCycle.java
index 0562ad610..ccf5fe1c7 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/cycle/LongCycle.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/cycle/LongCycle.java
@@ -19,6 +19,11 @@
 import javax.inject.Inject;
 import javax.inject.Provider;
 
+/**
+ * Component with a long enough cycle such that the initialization of a provider happens in a
+ * separate {@code initialize} method from the one where it is used as a delegated factory.
+ *
+ */
 // Each nested class's constructor has an intentionally unused parameter.
 @SuppressWarnings("unused")
 final class LongCycle {
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AModule.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AModule.java
index cede7c36a..8b0fe52b2 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AModule.java
@@ -16,29 +16,30 @@
 
 package test.multipackage.a;
 
+import dagger.Binds;
 import dagger.Module;
 import dagger.Provides;
 import dagger.multibindings.ElementsIntoSet;
 import dagger.multibindings.IntoMap;
 import dagger.multibindings.IntoSet;
 import dagger.multibindings.StringKey;
+
 import java.util.HashSet;
 import java.util.Set;
+
 import javax.inject.Inject;
 
 @Module
-public final class AModule {
+public abstract class AModule {
   @Provides
   @IntoSet
   static String provideString() {
     return "a";
   }
 
-  @Provides
+  @Binds
   @IntoSet
-  static Inaccessible provideInaccessible(Inaccessible inaccessible) {
-    return inaccessible;
-  }
+  abstract Inaccessible provideInaccessible(Inaccessible inaccessible);
 
   @Provides
   @ElementsIntoSet
@@ -46,12 +47,10 @@ static Inaccessible provideInaccessible(Inaccessible inaccessible) {
     return new HashSet<>();
   }
 
-  @Provides
+  @Binds
   @IntoMap
   @StringKey("inaccessible")
-  static Inaccessible provideInaccessibleToMap(Inaccessible inaccessible) {
-    return inaccessible;
-  }
+  abstract Inaccessible provideInaccessibleToMap(Inaccessible inaccessible);
 
   static class Inaccessible {
     @Inject Inaccessible() {}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GrandchildModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GrandchildModule.java
index b74ad8beb..e5595dce4 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GrandchildModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GrandchildModule.java
@@ -15,12 +15,13 @@
  */
 package test.subcomponent;
 
+import dagger.Binds;
 import dagger.Module;
 import dagger.Provides;
 import dagger.multibindings.IntoSet;
 
 @Module
-final class GrandchildModule {
+abstract class GrandchildModule {
   @Provides
   @IntoSet
   static Object provideUnscopedObject() {
@@ -31,10 +32,8 @@ static Object provideUnscopedObject() {
     };
   }
 
-  @Provides
-  static AnInterface provideAnInterface(ImplementsAnInterface implementsAnInterface) {
-    return implementsAnInterface;
-  }
+  @Binds
+  abstract AnInterface provideAnInterface(ImplementsAnInterface implementsAnInterface);
 
   @Provides
   static NeedsAnInterface provideNeedsAnInterface(AnInterface anInterface) {
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/MultibindingSubcomponents.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/MultibindingSubcomponents.java
index 14abce625..62c31928d 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/MultibindingSubcomponents.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/MultibindingSubcomponents.java
@@ -15,6 +15,7 @@
  */
 package test.subcomponent;
 
+import dagger.Binds;
 import dagger.Component;
 import dagger.Module;
 import dagger.Provides;
@@ -22,9 +23,11 @@
 import dagger.multibindings.IntoMap;
 import dagger.multibindings.IntoSet;
 import dagger.multibindings.StringKey;
+
 import java.util.Map;
 import java.util.Objects;
 import java.util.Set;
+
 import javax.inject.Inject;
 
 final class MultibindingSubcomponents {
@@ -83,7 +86,7 @@ public String toString() {
   }
 
   @Module
-  static final class ParentMultibindingModule {
+  abstract static class ParentMultibindingModule {
 
     @Provides
     @IntoSet
@@ -113,13 +116,11 @@ static BoundInParentAndChild inParentAndChildEntry() {
 
     /* This is not static because otherwise we have no tests that cover the case where a
      * subcomponent uses a module instance installed onto a parent component. */
-    @Provides
+    @Binds
     @IntoSet
-    static RequiresMultibindings<BoundInParentAndChild>
+    abstract RequiresMultibindings<BoundInParentAndChild>
         requiresMultibindingsInParentAndChildElement(
-            RequiresMultibindings<BoundInParentAndChild> requiresMultibindingsInParentAndChild) {
-      return requiresMultibindingsInParentAndChild;
-    }
+            RequiresMultibindings<BoundInParentAndChild> requiresMultibindingsInParentAndChild);
   }
 
   @Module
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentModule.java
index 748db15b0..9f3fea077 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentModule.java
@@ -15,13 +15,15 @@
  */
 package test.subcomponent;
 
+import dagger.Binds;
 import dagger.Module;
 import dagger.Provides;
 import dagger.multibindings.IntoSet;
+
 import javax.inject.Singleton;
 
 @Module
-final class ParentModule {
+abstract class ParentModule {
   @Provides
   @IntoSet
   static Object provideUnscopedObject() {
@@ -43,10 +45,8 @@ static Object provideSingletonObject() {
     };
   }
 
-  @Provides
+  @Binds
   @Singleton
   @BoundAsSingleton
-  static UnscopedType provideUnscopedTypeBoundAsSingleton(UnscopedType unscopedType) {
-    return unscopedType;
-  }
+  abstract UnscopedType provideUnscopedTypeBoundAsSingleton(UnscopedType unscopedType);
 }
diff --git a/compiler/src/it/functional-tests/src/test/java/test/DependsOnGeneratedCodeTest.java b/compiler/src/it/functional-tests/src/test/java/test/DependsOnGeneratedCodeTest.java
index 0310df6ef..f26e3ad0b 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/DependsOnGeneratedCodeTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/DependsOnGeneratedCodeTest.java
@@ -21,6 +21,9 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
+/**
+ * @see <a href="http://b/19435358">Bug 19435358</a>
+ */
 @RunWith(JUnit4.class)
 public class DependsOnGeneratedCodeTest {
   @Test public void testComponentDependsOnGeneratedCode() {
diff --git a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentMultibindingsTest.java b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentMultibindingsTest.java
index 99ca1cd44..a86931922 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentMultibindingsTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentMultibindingsTest.java
@@ -100,6 +100,13 @@ public void testParentWithoutProvisionHasChildWithoutProvision() {
                 .requiresMultibindingsBoundInChild())
         .isEqualTo(BOUND_IN_CHILD);
 
+    /*
+     * Even though the multibinding for Set<RequiresMultiboundObjects> does not itself have a
+     * contribution from the child, it must be pushed down to (not duplicated in) the child because
+     * its contribution depends on multibindings that have one contribution from the parent and one
+     * from the child.
+     *
+     */
     assertThat(
             parentWithoutProvisionHasChildWithoutProvision
                 .childWithoutProvision()
@@ -132,6 +139,13 @@ public void testParentWithoutProvisionHasChildWithProvision() {
                 .requiresMultibindingsBoundInChild())
         .isEqualTo(BOUND_IN_CHILD);
 
+    /*
+     * Even though the multibinding for Set<RequiresMultiboundObjects> does not itself have a
+     * contribution from the child, it must be pushed down to (not duplicated in) the child because
+     * its contribution depends on multibindings that have one contribution from the parent and one
+     * from the child.
+     *
+     */
     assertThat(
             parentWithoutProvisionHasChildWithProvision
                 .childWithProvision()
@@ -172,6 +186,13 @@ public void testParentWithProvisionHasChildWithoutProvision() {
                 .requiresMultibindingsBoundInParentAndChild())
         .isEqualTo(BOUND_IN_PARENT_AND_CHILD);
 
+    /*
+     * Even though the multibinding for Set<RequiresMultiboundObjects> does not itself have a
+     * contribution from the child, it must be pushed down to (not duplicated in) the child because
+     * its contribution depends on multibindings that have one contribution from the parent and one
+     * from the child.
+     *
+     */
     assertThat(
             parentWithProvisionHasChildWithoutProvision
                 .childWithoutProvision()
@@ -203,6 +224,13 @@ public void testParentWithProvisionHasChildWithProvision() {
                 .requiresMultibindingsBoundInParentAndChild())
         .isEqualTo(BOUND_IN_PARENT_AND_CHILD);
 
+    /*
+     * Even though the multibinding for Set<RequiresMultiboundObjects> does not itself have a
+     * contribution from the child, it must be pushed down to (not duplicated in) the child because
+     * its contribution depends on multibindings that have one contribution from the parent and one
+     * from the child.
+     *
+     */
     assertThat(
             parentWithProvisionHasChildWithProvision
                 .childWithProvision()
@@ -229,6 +257,13 @@ public void testParentWithProvisionHasChildWithProvision() {
                 .requiresMultibindingsBoundInParentAndChild())
         .isEqualTo(BOUND_IN_PARENT_AND_CHILD);
 
+    /*
+     * Even though the multibinding for Set<RequiresMultiboundObjects> does not itself have a
+     * contribution from the child, it must be pushed down to (not duplicated in) the child because
+     * its contribution depends on multibindings that have one contribution from the parent and one
+     * from the child.
+     *
+     */
     assertThat(
             parentWithProvisionHasChildWithProvision
                 .childWithProvision()
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/ProvidesInProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/ProvidesInProducerModule.java
new file mode 100644
index 000000000..37677aa81
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/ProvidesInProducerModule.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import com.google.common.util.concurrent.MoreExecutors;
+import dagger.Provides;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import dagger.producers.Production;
+import dagger.producers.ProductionComponent;
+import java.util.concurrent.Executor;
+
+final class ProvidesInProducerModule {
+  @ProducerModule
+  static class OnlyModule {
+    @Provides
+    @Production
+    static Executor provideExecutor() {
+      return MoreExecutors.directExecutor();
+    }
+
+    @Produces
+    static String produceString() {
+      return "produced";
+    }
+  }
+
+  @ProductionComponent(modules = OnlyModule.class)
+  interface C {
+    ListenableFuture<String> string();
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingComponent.java
index a9c9360bf..50a55f6f9 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingComponent.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingComponent.java
@@ -22,7 +22,10 @@
 import java.util.Map;
 import java.util.Set;
 import producerstest.ExecutorModule;
+import producerstest.multibindings.Qualifiers.EmptyButDeclaredInModule;
+import producerstest.multibindings.Qualifiers.EmptyButDeclaredInModuleAndProducerModule;
 import producerstest.multibindings.Qualifiers.ObjCount;
+import producerstest.multibindings.Qualifiers.OnlyProvisionMultibindings;
 import producerstest.multibindings.Qualifiers.PossiblyThrowingMap;
 import producerstest.multibindings.Qualifiers.PossiblyThrowingSet;
 
@@ -65,4 +68,13 @@
 
   @ObjCount
   ListenableFuture<Integer> objCount();
+
+  @EmptyButDeclaredInModuleAndProducerModule
+  ListenableFuture<Map<String, Object>> emptyButDeclaredInModuleAndProducerModule();
+
+  @EmptyButDeclaredInModule
+  ListenableFuture<Map<String, Object>> emptyButDeclaredInModule();
+
+  @OnlyProvisionMultibindings
+  ListenableFuture<Map<String, Object>> onlyProvisionMultibindings();
 }
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingModule.java
index 5c5834f54..98a6e36a8 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingModule.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingModule.java
@@ -22,10 +22,16 @@
 import dagger.multibindings.IntKey;
 import dagger.multibindings.IntoMap;
 import dagger.multibindings.IntoSet;
+import dagger.multibindings.Multibinds;
+import dagger.multibindings.StringKey;
+import java.util.Map;
 import java.util.Set;
+import producerstest.multibindings.Qualifiers.EmptyButDeclaredInModule;
+import producerstest.multibindings.Qualifiers.OnlyProvisionMultibindings;
+import producerstest.multibindings.Qualifiers.EmptyButDeclaredInModuleAndProducerModule;
 
 @Module
-final class MultibindingModule {
+abstract class MultibindingModule {
   @Provides
   @IntoSet
   static String providedStr() {
@@ -44,4 +50,20 @@ static String providedStr() {
   static String providedValueFor3() {
     return "provided three";
   }
+  
+  @Multibinds
+  @EmptyButDeclaredInModuleAndProducerModule
+  abstract Map<String, Object> emptyButDeclaredInModuleAndProducerModule();
+
+  @Multibinds
+  @EmptyButDeclaredInModule
+  abstract Map<String, Object> emptyButDeclaredInModule();
+
+  @Provides
+  @IntoMap
+  @StringKey("a")
+  @OnlyProvisionMultibindings
+  static Object onlyProvisionMultibindings() {
+    return "only multibinding";
+  }
 }
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingProducerModule.java
index 8532686f8..ee80ede02 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingProducerModule.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingProducerModule.java
@@ -18,7 +18,6 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
-
 import dagger.multibindings.ElementsIntoSet;
 import dagger.multibindings.IntKey;
 import dagger.multibindings.IntoMap;
@@ -27,14 +26,13 @@
 import dagger.producers.Produced;
 import dagger.producers.ProducerModule;
 import dagger.producers.Produces;
-
+import java.util.Map;
+import java.util.Set;
 import producerstest.multibindings.Qualifiers.ObjCount;
+import producerstest.multibindings.Qualifiers.EmptyButDeclaredInModuleAndProducerModule;
 import producerstest.multibindings.Qualifiers.PossiblyThrowingMap;
 import producerstest.multibindings.Qualifiers.PossiblyThrowingSet;
 
-import java.util.Map;
-import java.util.Set;
-
 @ProducerModule
 abstract class MultibindingProducerModule {
   @Produces
@@ -128,4 +126,8 @@ static String throwingValueFor15() {
   static int objCount(Set<Produced<Object>> objs, Map<Object, Produced<Object>> objMap) {
     return objs.size() + objMap.size();
   }
+  
+  @Multibinds
+  @EmptyButDeclaredInModuleAndProducerModule
+  abstract Map<String, Object> emptyButDeclaredInModuleAndProducerModule();
 }
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/Qualifiers.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/Qualifiers.java
index c638270ed..7d754622e 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/Qualifiers.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/Qualifiers.java
@@ -15,8 +15,8 @@
  */
 package producerstest.multibindings;
 
-import java.lang.annotation.Retention;
 import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
 import javax.inject.Qualifier;
 
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
@@ -37,5 +37,20 @@
   @Qualifier
   @interface ObjCount {}
 
+  @Documented
+  @Retention(RUNTIME)
+  @Qualifier
+  @interface EmptyButDeclaredInModule {}
+
+  @Documented
+  @Retention(RUNTIME)
+  @Qualifier
+  @interface EmptyButDeclaredInModuleAndProducerModule {}
+
+  @Documented
+  @Retention(RUNTIME)
+  @Qualifier
+  @interface OnlyProvisionMultibindings {}
+
   private Qualifiers() {}
 }
diff --git a/compiler/src/it/tck/src/main/java/test/tck/CarModule.java b/compiler/src/it/tck/src/main/java/test/tck/CarModule.java
index 31a8006e1..4c5b9ae9c 100644
--- a/compiler/src/it/tck/src/main/java/test/tck/CarModule.java
+++ b/compiler/src/it/tck/src/main/java/test/tck/CarModule.java
@@ -15,15 +15,14 @@
  */
 package test.tck;
 
+import dagger.Binds;
 import dagger.Module;
-import dagger.Provides;
+
 import org.atinject.tck.auto.Car;
 import org.atinject.tck.auto.Convertible;
 
 @Module
-class CarModule {
-  @Provides
-  static Car provideConvertible(Convertible convertible) {
-    return convertible;
-  }
+abstract class CarModule {
+  @Binds
+  abstract Car provideConvertible(Convertible convertible);
 }
diff --git a/compiler/src/it/tck/src/main/java/test/tck/SeatModule.java b/compiler/src/it/tck/src/main/java/test/tck/SeatModule.java
index b02f218bb..b04b6c2a5 100644
--- a/compiler/src/it/tck/src/main/java/test/tck/SeatModule.java
+++ b/compiler/src/it/tck/src/main/java/test/tck/SeatModule.java
@@ -15,17 +15,16 @@
  */
 package test.tck;
 
+import dagger.Binds;
 import dagger.Module;
-import dagger.Provides;
+
 import org.atinject.tck.auto.Drivers;
 import org.atinject.tck.auto.DriversSeat;
 import org.atinject.tck.auto.Seat;
 
 @Module
-class SeatModule {
-  @Provides
+abstract class SeatModule {
+  @Binds
   @Drivers
-  static Seat provideSeat(DriversSeat seat) {
-    return seat;
-  }
+  abstract Seat provideSeat(DriversSeat seat);
 }
diff --git a/compiler/src/it/tck/src/main/java/test/tck/TireModule.java b/compiler/src/it/tck/src/main/java/test/tck/TireModule.java
index f41852025..35a997258 100644
--- a/compiler/src/it/tck/src/main/java/test/tck/TireModule.java
+++ b/compiler/src/it/tck/src/main/java/test/tck/TireModule.java
@@ -15,17 +15,17 @@
  */
 package test.tck;
 
+import dagger.Binds;
 import dagger.Module;
-import dagger.Provides;
+
 import org.atinject.tck.auto.Tire;
 import org.atinject.tck.auto.accessories.SpareTire;
+
 import javax.inject.Named;
 
 @Module
-class TireModule {
-  @Provides
+abstract class TireModule {
+  @Binds
   @Named("spare")
-  static Tire provideTire(SpareTire sparetire) {
-    return sparetire;
-  }
+  abstract Tire provideTire(SpareTire sparetire);
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 703ebb384..0513c7528 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -261,7 +261,7 @@ private void setInitializationState(BindingKey bindingKey, InitializationState s
     component = createComponentClass();
     addBuilder();
     addFactoryMethods();
-    addFields();
+    addFrameworkFields();
     initializeFrameworkTypes();
     implementInterfaceMethods();
     addSubcomponents();
@@ -461,7 +461,7 @@ private void addBuilderMethodReturnStatementForSpec(
    */
   protected abstract void addFactoryMethods();
 
-  private void addFields() {
+  private void addFrameworkFields() {
     for (ResolvedBindings resolvedBindings : graph.resolvedBindings().values()) {
       addField(resolvedBindings);
     }
@@ -1066,10 +1066,10 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
   }
 
   private CodeBlock decorateForScope(CodeBlock factoryCreate, Scope scope) {
-    return CodeBlock.of(
-        "$T.provider($L)",
-        scope.equals(reusableScope(elements)) ? SINGLE_CHECK : DOUBLE_CHECK,
-        factoryCreate);
+      return CodeBlock.of(
+          "$T.provider($L)",
+          scope.equals(reusableScope(elements)) ? SINGLE_CHECK : DOUBLE_CHECK,
+          factoryCreate);
   }
 
   private CodeBlock nullableAnnotation(Optional<DeclaredType> nullableType) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index 233ab5511..60a2e874d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -19,6 +19,7 @@
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Function;
 import com.google.common.base.Optional;
+import com.google.common.base.VerifyException;
 import com.google.common.cache.Cache;
 import com.google.common.cache.CacheBuilder;
 import com.google.common.collect.FluentIterable;
@@ -31,12 +32,14 @@
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
 import com.google.common.collect.TreeTraverser;
+import com.google.common.util.concurrent.ListenableFuture;
 import dagger.Component;
 import dagger.Reusable;
 import dagger.Subcomponent;
-import dagger.internal.codegen.BindingType.HasBindingType;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.internal.codegen.Key.HasKey;
+import dagger.producers.Produced;
+import dagger.producers.Producer;
 import dagger.producers.ProductionComponent;
 import java.util.ArrayDeque;
 import java.util.Collection;
@@ -50,6 +53,7 @@
 import java.util.concurrent.Callable;
 import java.util.concurrent.ExecutionException;
 import javax.inject.Inject;
+import javax.inject.Provider;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
@@ -62,7 +66,9 @@
 import static com.google.common.base.Predicates.in;
 import static com.google.common.base.Predicates.not;
 import static com.google.common.base.Verify.verify;
+import static com.google.common.collect.Iterables.isEmpty;
 import static dagger.internal.codegen.BindingKey.Kind.CONTRIBUTION;
+import static dagger.internal.codegen.BindingType.isOfType;
 import static dagger.internal.codegen.ComponentDescriptor.isComponentContributionMethod;
 import static dagger.internal.codegen.ComponentDescriptor.isComponentProductionMethod;
 import static dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor.isOfKind;
@@ -351,7 +357,8 @@ ResolvedBindings lookUpBindings(DependencyRequest request) {
         switch (bindingKey.kind()) {
           case CONTRIBUTION:
             Set<ContributionBinding> contributionBindings = new LinkedHashSet<>();
-            ImmutableSet.Builder<ContributionBinding> multibindingsBuilder = ImmutableSet.builder();
+            ImmutableSet.Builder<ContributionBinding> multibindingContributionsBuilder =
+                ImmutableSet.builder();
             ImmutableSet.Builder<MultibindingDeclaration> multibindingDeclarationsBuilder =
                 ImmutableSet.builder();
 
@@ -359,51 +366,24 @@ ResolvedBindings lookUpBindings(DependencyRequest request) {
               contributionBindings.addAll(getExplicitBindings(key));
               contributionBindings.addAll(getDelegateBindings(key));
 
-              multibindingsBuilder.addAll(getExplicitMultibindings(key));
-              multibindingsBuilder.addAll(getDelegateMultibindings(key));
+              multibindingContributionsBuilder.addAll(getExplicitMultibindingContributions(key));
+              multibindingContributionsBuilder.addAll(getDelegateMultibindingContributions(key));
 
               multibindingDeclarationsBuilder.addAll(getMultibindingDeclarations(key));
             }
 
-            if (shouldCreateSyntheticMapOfValuesBinding(
-                keyFactory.implicitMapProducerKeyFrom(requestKey))) {
-              /* If the binding key is Map<K, V> or Map<K, Produced<V>> and there are some explicit
-               * Map<K, Producer<V>> bindings or multibinding declarations, then add the synthetic
-               * binding that depends on Map<K, Producer<V>>. */
-              contributionBindings.add(
-                  productionBindingFactory.syntheticMapOfValuesOrProducedBinding(request));
-            } else if (shouldCreateSyntheticMapOfValuesBinding(
-                keyFactory.implicitMapProviderKeyFrom(requestKey))) {
-              /* If the binding key is Map<K, V> and there are some explicit Map<K, Provider<V>>
-               * bindings or multibinding declarations but no explicit Map<K, Producer<V>> bindings
-               * or multibinding declarations, then add the synthetic binding that depends on
-               * Map<K, Provider<V>>. */
-              contributionBindings.add(
-                  provisionBindingFactory.syntheticMapOfValuesBinding(request));
-            }
-
-            ImmutableSet<ContributionBinding> multibindings = multibindingsBuilder.build();
+            ImmutableSet<ContributionBinding> multibindingContributions =
+                multibindingContributionsBuilder.build();
             ImmutableSet<MultibindingDeclaration> multibindingDeclarations =
                 multibindingDeclarationsBuilder.build();
 
-            Iterable<? extends HasBindingType> multibindingsAndDeclarations =
-                Iterables.concat(multibindings, multibindingDeclarations);
-            if (Iterables.any(
-                multibindingsAndDeclarations, BindingType.isOfType(BindingType.PRODUCTION))) {
-              /* If there are production multibindings, add a synthetic binding that depends on each
-               * individual multibinding. */
-              contributionBindings.add(
-                  productionBindingFactory.syntheticMultibinding(request, multibindings));
-            } else if (Iterables.any(
-                multibindingsAndDeclarations, BindingType.isOfType(BindingType.PROVISION))) {
-              /* If there are provision multibindings but not production ones, add a synthetic
-               * binding that depends on each individual multibinding. */
-              contributionBindings.add(
-                  provisionBindingFactory.syntheticMultibinding(request, multibindings));
-            }
+            contributionBindings.addAll(syntheticMapOfValuesBinding(request).asSet());
+            contributionBindings.addAll(
+                syntheticMultibinding(request, multibindingContributions, multibindingDeclarations)
+                    .asSet());
 
-            /* If there are still no bindings, look for an implicit @Inject- constructed binding if
-             * there is one. */
+            /* If there are no bindings, add the implicit @Inject-constructed binding if there is
+             * one. */
             if (contributionBindings.isEmpty()) {
               contributionBindings.addAll(
                   injectBindingRegistry.getOrFindProvisionBinding(requestKey).asSet());
@@ -423,6 +403,7 @@ ResolvedBindings lookUpBindings(DependencyRequest request) {
                 ? ResolvedBindings.forMembersInjectionBinding(
                     bindingKey, componentDescriptor, binding.get())
                 : ResolvedBindings.noBindings(bindingKey, componentDescriptor);
+
           default:
             throw new AssertionError();
         }
@@ -431,28 +412,148 @@ ResolvedBindings lookUpBindings(DependencyRequest request) {
       private Iterable<Key> keysMatchingRequest(Key requestKey) {
         return ImmutableSet.<Key>builder()
             .add(requestKey)
-            .addAll(keyFactory.implicitSetKeyFromProduced(requestKey).asSet())
-            .addAll(keyFactory.implicitProviderMapKeyFromProducer(requestKey).asSet())
+            .addAll(keyFactory.unwrapSetKey(requestKey, Produced.class).asSet())
+            .addAll(keyFactory.rewrapMapKey(requestKey, Producer.class, Provider.class).asSet())
+            .addAll(keyFactory.rewrapMapKey(requestKey, Provider.class, Producer.class).asSet())
             .build();
       }
 
-      private boolean shouldCreateSyntheticMapOfValuesBinding(Optional<Key> maybeKey) {
-        if (!maybeKey.isPresent()) {
-          return false;
-        }
+      /**
+       * If {@code request} is for a {@code Map<K, V>} or {@code Map<K, Produced<V>>}, and there are
+       * any multibinding contributions or declarations that apply to that map, returns a synthetic
+       * binding for the {@code request} that depends on an {@linkplain
+       * #syntheticMultibinding(DependencyRequest, Iterable, Iterable) underlying synthetic
+       * multibinding}.
+       *
+       * <p>The returned binding has the same {@link BindingType} as the underlying synthetic
+       * multibinding.
+       */
+      private Optional<ContributionBinding> syntheticMapOfValuesBinding(
+          final DependencyRequest request) {
+        return syntheticMultibinding(
+                request,
+                multibindingContributionsForValueMap(request.key()),
+                multibindingDeclarationsForValueMap(request.key()))
+            .transform(
+                new Function<ContributionBinding, ContributionBinding>() {
+                  @Override
+                  public ContributionBinding apply(ContributionBinding syntheticMultibinding) {
+                    switch (syntheticMultibinding.bindingType()) {
+                      case PROVISION:
+                        return provisionBindingFactory.syntheticMapOfValuesBinding(request);
 
-        Key key = maybeKey.get();
-        if (!getExplicitMultibindings(key).isEmpty()
-            || !getMultibindingDeclarations(key).isEmpty()) {
-          return true;
+                      case PRODUCTION:
+                        return productionBindingFactory.syntheticMapOfValuesOrProducedBinding(
+                            request);
+
+                      default:
+                        throw new VerifyException(syntheticMultibinding.toString());
+                    }
+                  }
+                });
+      }
+
+      /**
+       * If {@code requestKey} is for {@code Map<K, V>} or {@code Map<K, Produced<V>>}, returns all
+       * multibinding contributions whose key is for {@code Map<K, Provider<V>>} or {@code Map<K,
+       * Producer<V>>} with the same qualifier and {@code K} and {@code V}.
+       */
+      private FluentIterable<ContributionBinding> multibindingContributionsForValueMap(
+          Key requestKey) {
+        return keyFactory
+            .implicitFrameworkMapKeys(requestKey)
+            .transformAndConcat(
+                new Function<Key, Iterable<ContributionBinding>>() {
+                  @Override
+                  public Iterable<ContributionBinding> apply(Key key) {
+                    return Iterables.concat(
+                        getExplicitMultibindingContributions(key),
+                        getDelegateMultibindingContributions(key));
+                  }
+                });
+      }
+
+      /**
+       * If {@code requestKey} is for {@code Map<K, V>} or {@code Map<K, Produced<V>>}, returns all
+       * multibinding declarations whose key is for {@code Map<K, Provider<V>>} or {@code Map<K,
+       * Producer<V>>} with the same qualifier and {@code K} and {@code V}.
+       */
+      private FluentIterable<MultibindingDeclaration> multibindingDeclarationsForValueMap(
+          Key requestKey) {
+        return keyFactory
+            .implicitFrameworkMapKeys(requestKey)
+            .transformAndConcat(
+                new Function<Key, Iterable<MultibindingDeclaration>>() {
+                  @Override
+                  public Iterable<MultibindingDeclaration> apply(Key key) {
+                    return getMultibindingDeclarations(key);
+                  }
+                });
+      }
+
+      /**
+       * Returns a synthetic binding that depends on individual multibinding contributions.
+       *
+       * <p>If there are no {@code multibindingContributions} or {@code multibindingDeclarations},
+       * returns {@link Optional#absent()}.
+       *
+       * <p>If there are production {@code multibindingContributions} or the request is for any of
+       * the following types, returns a {@link ProductionBinding}.
+       *
+       * <ul>
+       * <li>{@link Producer Producer<SetOrMap>}
+       * <li>{@link Produced Produced<SetOrMap>}
+       * <li>{@link ListenableFuture ListenableFuture<SetOrMap>}
+       * <li>{@code Set<Produced<T>>}
+       * <li>{@code Map<K, Producer<V>>}
+       * <li>{@code Map<K, Produced<V>>}
+       * </ul>
+       *
+       * Otherwise, returns a {@link ProvisionBinding}.
+       */
+      private Optional<? extends ContributionBinding> syntheticMultibinding(
+          DependencyRequest request,
+          Iterable<ContributionBinding> multibindingContributions,
+          Iterable<MultibindingDeclaration> multibindingDeclarations) {
+        if (isEmpty(multibindingContributions) && isEmpty(multibindingDeclarations)) {
+          return Optional.absent();
+        } else if (multibindingsRequireProduction(multibindingContributions, request)) {
+          return Optional.of(
+              productionBindingFactory.syntheticMultibinding(request, multibindingContributions));
+        } else {
+          return Optional.of(
+              provisionBindingFactory.syntheticMultibinding(request, multibindingContributions));
         }
+      }
 
-        for (ContributionBinding delegateMultibinding : getDelegateMultibindings(key)) {
-          if (delegateMultibinding.key().withoutBindingMethodIdentifier().equals(key)) {
+      private boolean multibindingsRequireProduction(
+          Iterable<ContributionBinding> multibindingContributions, DependencyRequest request) {
+        switch (request.kind()) {
+          case PRODUCER:
+          case PRODUCED:
+          case FUTURE:
             return true;
-          }
+
+          case INSTANCE:
+          case LAZY:
+          case PROVIDER:
+          case PROVIDER_OF_LAZY:
+            if (MapType.isMap(request.key())) {
+              MapType mapType = MapType.from(request.key());
+              if (mapType.valuesAreTypeOf(Producer.class)
+                  || mapType.valuesAreTypeOf(Produced.class)) {
+                return true;
+              }
+            } else if (SetType.isSet(request.key())
+                && SetType.from(request.key()).elementsAreTypeOf(Produced.class)) {
+              return true;
+            }
+            return Iterables.any(multibindingContributions, isOfType(BindingType.PRODUCTION));
+
+          case MEMBERS_INJECTOR:
+          default:
+            throw new AssertionError(request.kind());
         }
-        return false;
       }
 
       private ImmutableSet<ContributionBinding> createDelegateBindings(
@@ -586,11 +687,12 @@ private boolean isResolvedInParent(DependencyRequest request, ContributionBindin
       }
 
       /**
-       * Returns the explicit multibindings whose key (minus its
-       * {@link Key#bindingMethodIdentifier()}) matches the {@code requestKey} from this and all
-       * ancestor resolvers.
+       * Returns the explicit multibinding contributions whose key (minus its
+       * {@link Key#bindingIdentifier()}) matches the {@code requestKey} from this and all ancestor
+       * resolvers.
        */
-      private ImmutableSet<ContributionBinding> getExplicitMultibindings(Key requestKey) {
+      private ImmutableSet<ContributionBinding> getExplicitMultibindingContributions(
+          Key requestKey) {
         ImmutableSet.Builder<ContributionBinding> explicitMultibindingsForKey =
             ImmutableSet.builder();
         for (Resolver resolver : getResolverLineage()) {
@@ -622,7 +724,8 @@ private boolean isResolvedInParent(DependencyRequest request, ContributionBindin
         return delegateBindings.build();
       }
 
-      private ImmutableSet<ContributionBinding> getDelegateMultibindings(Key requestKey) {
+      private ImmutableSet<ContributionBinding> getDelegateMultibindingContributions(
+          Key requestKey) {
         if (MapType.isMap(requestKey) && !MapType.from(requestKey).valuesAreFrameworkType()) {
           // There are no @Binds @IntoMap delegate declarations for Map<K, V> requests. All @IntoMap
           // requests must be for Map<K, Framework<V>>.
@@ -755,6 +858,7 @@ boolean dependsOnLocalMultibindings(final BindingKey bindingKey) {
               Resolver.this,
               bindingKey);
           // Don't recur infinitely if there are valid cycles in the dependency graph.
+          // http://b/23032377
           if (!cycleChecker.add(bindingKey)) {
             return false;
           }
@@ -830,16 +934,16 @@ private boolean isMultibindingsWithLocalContributions(ResolvedBindings resolvedB
     }
 
     /**
-     * Selects each item in {@code haveKeys} that has a {@link Key#bindingMethodIdentifier()} and
-     * indexes them by its {@link HasKey#key()}, where each key has its {@link
-     * dagger.internal.codegen.Key.BindingMethodIdentifier} removed.
+     * Selects each item in {@code haveKeys} that has a {@link Key#bindingIdentifier()} and indexes
+     * them by its {@link HasKey#key()}, where each key has its binding identifier removed.
      */
-    static <T extends HasKey> ImmutableSetMultimap<Key, T>
-        multibindingsKeyedWithoutBindingIdentifiers(Iterable<T> haveKeys) {
+    static <T extends HasKey>
+        ImmutableSetMultimap<Key, T> multibindingsKeyedWithoutBindingIdentifiers(
+            Iterable<T> haveKeys) {
       ImmutableSetMultimap.Builder<Key, T> builder = ImmutableSetMultimap.builder();
       for (T hasKey : haveKeys) {
-        if (hasKey.key().bindingMethodIdentifier().isPresent()) {
-          builder.put(hasKey.key().withoutBindingMethodIdentifier(), hasKey);
+        if (hasKey.key().bindingIdentifier().isPresent()) {
+          builder.put(hasKey.key().withoutBindingIdentifier(), hasKey);
         }
       }
       return builder.build();
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 7eb4663ad..91dc556ed 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -43,6 +43,7 @@
 import dagger.MapKey;
 import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
+import dagger.internal.codegen.ContributionBinding.Kind;
 import dagger.producers.ProductionComponent;
 import java.util.ArrayDeque;
 import java.util.Collection;
@@ -72,8 +73,10 @@
 import static com.google.auto.common.MoreTypes.asExecutable;
 import static com.google.auto.common.MoreTypes.asTypeElements;
 import static com.google.common.base.Preconditions.checkState;
+import static com.google.common.base.Predicates.equalTo;
 import static com.google.common.base.Predicates.in;
 import static com.google.common.base.Predicates.not;
+import static com.google.common.base.Predicates.or;
 import static com.google.common.base.Verify.verify;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static com.google.common.collect.Iterables.indexOf;
@@ -82,11 +85,11 @@
 import static dagger.internal.codegen.ComponentDescriptor.ComponentMethodKind.PRODUCTION_SUBCOMPONENT;
 import static dagger.internal.codegen.ComponentDescriptor.ComponentMethodKind.SUBCOMPONENT;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
-import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_DELEGATE_BINDING;
 import static dagger.internal.codegen.ContributionBinding.indexMapBindingsByAnnotationType;
 import static dagger.internal.codegen.ContributionBinding.indexMapBindingsByMapKey;
 import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
 import static dagger.internal.codegen.ContributionBinding.Kind.IS_SYNTHETIC_KIND;
+import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_DELEGATE_BINDING;
 import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MULTIBOUND_MAP;
 import static dagger.internal.codegen.ContributionType.indexByContributionType;
 import static dagger.internal.codegen.ErrorMessages.CANNOT_INJECT_WILDCARD_TYPE;
@@ -94,6 +97,7 @@
 import static dagger.internal.codegen.ErrorMessages.DUPLICATE_SIZE_LIMIT;
 import static dagger.internal.codegen.ErrorMessages.INDENT;
 import static dagger.internal.codegen.ErrorMessages.MEMBERS_INJECTION_WITH_UNBOUNDED_TYPE;
+import static dagger.internal.codegen.ErrorMessages.MULTIPLE_CONTRIBUTION_TYPES_FOR_KEY_FORMAT;
 import static dagger.internal.codegen.ErrorMessages.REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_FORMAT;
 import static dagger.internal.codegen.ErrorMessages.REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_OR_PRODUCER_FORMAT;
 import static dagger.internal.codegen.ErrorMessages.REQUIRES_PROVIDER_FORMAT;
@@ -145,26 +149,26 @@
 
   /** A dependency path from an entry point. */
   static final class DependencyPath {
-    private final Deque<ResolvedRequest> requestPath = new ArrayDeque<>();
+    private final Deque<ResolvedRequest> path = new ArrayDeque<>();
     private final LinkedHashMultiset<BindingKey> keyPath = LinkedHashMultiset.create();
-    private final Set<DependencyRequest> resolvedRequests = new HashSet<>();
+    private final Set<DependencyRequest> resolvedDependencyRequests = new HashSet<>();
 
     /** The entry point. */
     Element entryPointElement() {
-      return requestPath.getFirst().request().requestElement();
+      return path.getFirst().dependencyRequest().requestElement();
     }
 
     /** The current dependency request, which is a transitive dependency of the entry point. */
     DependencyRequest currentDependencyRequest() {
-      return requestPath.getLast().request();
+      return path.getLast().dependencyRequest();
     }
 
     /**
      * The resolved bindings for the {@linkplain #currentDependencyRequest() current dependency
      * request.
      */
-    ResolvedBindings currentBinding() {
-      return requestPath.getLast().binding();
+    ResolvedBindings currentResolvedBindings() {
+      return path.getLast().resolvedBindings();
     }
 
     /**
@@ -172,9 +176,9 @@ ResolvedBindings currentBinding() {
      *
      * @throws IllegalStateException if there are fewer than two requests in the path
      */
-    ResolvedBindings previousBinding() {
+    ResolvedBindings previousResolvedBindings() {
       checkState(size() > 1);
-      return Iterators.get(requestPath.descendingIterator(), 1).binding();
+      return Iterators.get(path.descendingIterator(), 1).resolvedBindings();
     }
 
     /**
@@ -195,7 +199,7 @@ boolean hasCycle() {
      */
     ImmutableList<ResolvedRequest> cycle() {
       checkState(hasCycle(), "no cycle");
-      return FluentIterable.from(requestPath)
+      return FluentIterable.from(path)
           .skip(indexOf(keyPath, Predicates.equalTo(currentDependencyRequest().bindingKey())))
           .toList();
     }
@@ -205,40 +209,31 @@ boolean hasCycle() {
      * previous request in the path.
      */
     void push(ResolvedRequest request) {
-      requestPath.addLast(request);
-      keyPath.add(request.request().bindingKey());
+      path.addLast(request);
+      keyPath.add(request.dependencyRequest().bindingKey());
     }
 
     /** Makes the previous request the current request. */
     void pop() {
-      verify(keyPath.remove(requestPath.removeLast().request().bindingKey()));
+      verify(keyPath.remove(path.removeLast().dependencyRequest().bindingKey()));
     }
 
     /**
      * Adds the {@linkplain #currentDependencyRequest() current request} to a set of visited
      * requests, and returns {@code true} if the set didn't already contain it.
      */
-    boolean visitCurrentRequest() {
-      return resolvedRequests.add(currentDependencyRequest());
+    boolean visitCurrentDependencyRequest() {
+      return resolvedDependencyRequests.add(currentDependencyRequest());
     }
 
     int size() {
-      return requestPath.size();
+      return path.size();
     }
 
     /** The dependency requests in this path, starting with the entry point. */
-    FluentIterable<DependencyRequest> requests() {
-      return FluentIterable.from(requestPath).transform(REQUEST_FROM_RESOLVED_REQUEST);
+    FluentIterable<DependencyRequest> dependencyRequests() {
+      return FluentIterable.from(path).transform(ResolvedRequest.DEPENDENCY_REQUEST);
     }
-
-    private static final Function<ResolvedRequest, DependencyRequest>
-        REQUEST_FROM_RESOLVED_REQUEST =
-            new Function<ResolvedRequest, DependencyRequest>() {
-              @Override
-              public DependencyRequest apply(ResolvedRequest resolvedRequest) {
-                return resolvedRequest.request();
-              }
-            };
   }
 
   private final class Validation {
@@ -275,7 +270,7 @@ void validateSubgraph() {
            subject.componentDescriptor().componentMethods()) {
         Optional<DependencyRequest> entryPoint = componentMethod.dependencyRequest();
         if (entryPoint.isPresent()) {
-          traverseRequest(entryPoint.get(), new DependencyPath());
+          traverseDependencyRequest(entryPoint.get(), new DependencyPath());
         }
       }
 
@@ -334,7 +329,7 @@ public boolean apply(TypeElement moduleType) {
      *
      * @param request the current dependency request
      */
-    private void traverseRequest(DependencyRequest request, DependencyPath path) {
+    private void traverseDependencyRequest(DependencyRequest request, DependencyPath path) {
       path.push(ResolvedRequest.create(request, subject));
       try {
         if (path.hasCycle()) {
@@ -342,16 +337,16 @@ private void traverseRequest(DependencyRequest request, DependencyPath path) {
           return;
         }
 
-        if (path.visitCurrentRequest()) {
-          validateResolvedBinding(path);
+        if (path.visitCurrentDependencyRequest()) {
+          validateResolvedBindings(path);
 
           // Validate all dependencies within the component that owns the binding.
           for (Map.Entry<ComponentDescriptor, ? extends Binding> entry :
-              path.currentBinding().bindingsByComponent()) {
+              path.currentResolvedBindings().bindingsByComponent()) {
             Validation validation = validationForComponent(entry.getKey());
             Binding binding = entry.getValue();
             for (DependencyRequest nextRequest : binding.implicitDependencies()) {
-              validation.traverseRequest(nextRequest, path);
+              validation.traverseDependencyRequest(nextRequest, path);
             }
           }
         }
@@ -377,31 +372,30 @@ private Validation validationForComponent(ComponentDescriptor component) {
     /**
      * Reports errors if the set of bindings resolved is inconsistent with the type of the binding.
      */
-    private void validateResolvedBinding(DependencyPath path) {
-      ResolvedBindings resolvedBinding = path.currentBinding();
-      if (resolvedBinding.isEmpty()) {
+    private void validateResolvedBindings(DependencyPath path) {
+      ResolvedBindings resolvedBindings = path.currentResolvedBindings();
+      if (resolvedBindings.isEmpty()) {
         reportMissingBinding(path);
         return;
       }
 
-      switch (resolvedBinding.bindingKey().kind()) {
+      switch (resolvedBindings.bindingKey().kind()) {
         case CONTRIBUTION:
           if (Iterables.any(
-              resolvedBinding.bindings(), BindingType.isOfType(BindingType.MEMBERS_INJECTION))) {
+              resolvedBindings.bindings(), BindingType.isOfType(BindingType.MEMBERS_INJECTION))) {
             // TODO(dpb): How could this ever happen, even in an invalid graph?
             throw new AssertionError(
                 "contribution binding keys should never have members injection bindings");
           }
           validateNullability(
-              path.currentDependencyRequest(), resolvedBinding.contributionBindings());
-          if (resolvedBinding.contributionBindings().size() > 1) {
+              path.currentDependencyRequest(), resolvedBindings.contributionBindings());
+          if (resolvedBindings.contributionBindings().size() > 1) {
             reportDuplicateBindings(path);
             return;
           }
-          ContributionBinding binding =
-              Iterables.getOnlyElement(resolvedBinding.contributionBindings());
-          if (binding.bindingKind().equals(INJECTION)) {
-            TypeMirror type = resolvedBinding.bindingKey().key().type();
+          ContributionBinding contributionBinding = resolvedBindings.contributionBinding();
+          if (contributionBinding.bindingKind().equals(INJECTION)) {
+            TypeMirror type = contributionBinding.key().type();
             ValidationReport<TypeElement> report =
                 injectValidator.validateType(MoreTypes.asTypeElement(type));
             if (!report.isClean()) {
@@ -409,7 +403,6 @@ private void validateResolvedBinding(DependencyPath path) {
               return;
             }
           }
-          ContributionBinding contributionBinding = resolvedBinding.contributionBinding();
           if (contributionBinding.bindingType().equals(BindingType.PRODUCTION)
               && doesPathRequireProvisionOnly(path)) {
             reportProviderMayNotDependOnProducer(path);
@@ -433,23 +426,23 @@ private void validateResolvedBinding(DependencyPath path) {
           }
           if (contributionBinding.bindingKind().equals(SYNTHETIC_MULTIBOUND_MAP)) {
             ImmutableSet<ContributionBinding> multibindings =
-                inlineSyntheticNondelegateContributions(resolvedBinding).contributionBindings();
+                inlineSyntheticNondelegateContributions(resolvedBindings).contributionBindings();
             validateMapKeySet(path, multibindings);
             validateMapKeyAnnotationTypes(path, multibindings);
           }
           break;
         case MEMBERS_INJECTION:
           if (!Iterables.all(
-              resolvedBinding.bindings(), BindingType.isOfType(BindingType.MEMBERS_INJECTION))) {
+              resolvedBindings.bindings(), BindingType.isOfType(BindingType.MEMBERS_INJECTION))) {
             // TODO(dpb): How could this ever happen, even in an invalid graph?
             throw new AssertionError(
                 "members injection binding keys should never have contribution bindings");
           }
-          if (resolvedBinding.bindings().size() > 1) {
+          if (resolvedBindings.bindings().size() > 1) {
             reportDuplicateBindings(path);
             return;
           }
-          validateMembersInjectionBinding(getOnlyElement(resolvedBinding.bindings()), path);
+          validateMembersInjectionBinding(resolvedBindings.membersInjectionBinding().get(), path);
           return;
         default:
           throw new AssertionError();
@@ -948,6 +941,7 @@ void validateComponentScope() {
     }
 
     @SuppressWarnings("resource") // Appendable is a StringBuilder.
+    // TODO(b/29509141): Clarify the error.
     private void reportProviderMayNotDependOnProducer(DependencyPath path) {
       StringBuilder errorMessage = new StringBuilder();
       if (path.size() == 1) {
@@ -1024,18 +1018,21 @@ private void reportDependsOnProductionExecutor(DependencyPath path) {
 
     @SuppressWarnings("resource") // Appendable is a StringBuilder.
     private void reportDuplicateBindings(DependencyPath path) {
-      ResolvedBindings resolvedBinding = path.currentBinding();
-      if (FluentIterable.from(resolvedBinding.contributionBindings())
+      ResolvedBindings resolvedBindings = path.currentResolvedBindings();
+      if (FluentIterable.from(resolvedBindings.contributionBindings())
           .transform(ContributionBinding.KIND)
-          .anyMatch(IS_SYNTHETIC_KIND)) {
-        reportMultipleBindingTypes(path);
+          // TODO(dpb): Kill with fire.
+          .anyMatch(or(Kind.IS_SYNTHETIC_MULTIBINDING_KIND, equalTo(Kind.SYNTHETIC_MAP)))) {
+        // If any of the duplicate bindings results from multibinding contributions or declarations,
+        // report the conflict using those contributions and declarations.
+        reportMultipleContributionTypes(path);
         return;
       }
       StringBuilder builder = new StringBuilder();
       new Formatter(builder)
           .format(ErrorMessages.DUPLICATE_BINDINGS_FOR_KEY_FORMAT, formatRootRequestKey(path));
       ImmutableSet<ContributionBinding> duplicateBindings =
-          inlineSyntheticNondelegateContributions(resolvedBinding).contributionBindings();
+          inlineSyntheticNondelegateContributions(resolvedBindings).contributionBindings();
       bindingDeclarationFormatter.formatIndentedList(
           builder, duplicateBindings, 1, DUPLICATE_SIZE_LIMIT);
       owningReportBuilder(duplicateBindings).addError(builder.toString(), path.entryPointElement());
@@ -1078,25 +1075,25 @@ private void reportDuplicateBindings(DependencyPath path) {
     }
 
     @SuppressWarnings("resource") // Appendable is a StringBuilder.
-    private void reportMultipleBindingTypes(DependencyPath path) {
+    private void reportMultipleContributionTypes(DependencyPath path) {
       StringBuilder builder = new StringBuilder();
       new Formatter(builder)
-          .format(ErrorMessages.MULTIPLE_BINDING_TYPES_FOR_KEY_FORMAT, formatRootRequestKey(path));
-      ResolvedBindings resolvedBinding = path.currentBinding();
+          .format(MULTIPLE_CONTRIBUTION_TYPES_FOR_KEY_FORMAT, formatRootRequestKey(path));
+      ResolvedBindings resolvedBindings = path.currentResolvedBindings();
       ImmutableListMultimap<ContributionType, BindingDeclaration> declarationsByType =
-          declarationsByType(resolvedBinding);
+          declarationsByType(resolvedBindings);
       verify(
           declarationsByType.keySet().size() > 1,
-          "expected multiple binding types for %s: %s",
-          resolvedBinding.bindingKey(),
+          "expected multiple contribution types for %s: %s",
+          resolvedBindings.bindingKey(),
           declarationsByType);
-      for (ContributionType type :
+      for (ContributionType contributionType :
           Ordering.natural().immutableSortedCopy(declarationsByType.keySet())) {
         builder.append(INDENT);
-        builder.append(formatContributionType(type));
+        builder.append(formatContributionType(contributionType));
         builder.append(" bindings and declarations:");
         bindingDeclarationFormatter.formatIndentedList(
-            builder, declarationsByType.get(type), 2, DUPLICATE_SIZE_LIMIT);
+            builder, declarationsByType.get(contributionType), 2, DUPLICATE_SIZE_LIMIT);
         builder.append('\n');
       }
       reportBuilder.addError(builder.toString(), path.entryPointElement());
@@ -1161,51 +1158,29 @@ private void reportCycle(DependencyPath path) {
      */
     private ImmutableSet<DependencyRequest> providersBreakingCycle(
         ImmutableList<ResolvedRequest> cycle) {
-      ImmutableSet.Builder<DependencyRequest> providers = ImmutableSet.builder();
-      for (int i = 1; i < cycle.size(); i++) {
-        DependencyRequest dependencyRequest = cycle.get(i).request();
-        switch (dependencyRequest.kind()) {
-          case PROVIDER:
-            // TODO(dpb): Just exclude requests from synthetic bindings.
-            if (isDependencyOfSyntheticMap(dependencyRequest, cycle.get(i - 1).request())) {
-              i++; // Skip the Provider requests in the Map<K, Provider<V>> too.
-            } else {
-              providers.add(dependencyRequest);
-            }
-            break;
-
-          case LAZY:
-            providers.add(dependencyRequest);
-            break;
-
-          case INSTANCE:
-            TypeMirror type = dependencyRequest.key().type();
-            if (MapType.isMap(type) && MapType.from(type).valuesAreTypeOf(Provider.class)) {
-              providers.add(dependencyRequest);
-            }
-            break;
-
-          default:
-            break;
-        }
-      }
-      return providers.build();
-    }
-
-    /**
-     * Returns {@code true} if {@code request} is a request for {@code Map<K, Provider<V>>} or
-     * {@code Map<K, Producer<V>>} from a synthetic binding for {@code Map<K, V>} or
-     * {@code Map<K, Produced<V>>}.
-     */
-    // TODO(dpb): Make this check more explicit.
-    private boolean isDependencyOfSyntheticMap(
-        DependencyRequest request, DependencyRequest requestForPreviousBinding) {
-      // Synthetic map dependencies share the same request element as the previous request.
-      return request.requestElement().equals(requestForPreviousBinding.requestElement())
-          && Sets.union(
-                  keyFactory.implicitMapProviderKeyFrom(requestForPreviousBinding.key()).asSet(),
-                  keyFactory.implicitMapProducerKeyFrom(requestForPreviousBinding.key()).asSet())
-              .contains(request.key());
+      return FluentIterable.from(cycle)
+          .skip(1)
+          .transform(ResolvedRequest.DEPENDENCY_REQUEST)
+          .filter(not(DependencyRequest.IS_SYNTHETIC))
+          .filter(
+              new Predicate<DependencyRequest>() {
+                @Override
+                public boolean apply(DependencyRequest dependencyRequest) {
+                  switch (dependencyRequest.kind()) {
+                    case PROVIDER:
+                    case LAZY:
+                      return true;
+
+                    case INSTANCE:
+                      return MapType.isMap(dependencyRequest.key())
+                          && MapType.from(dependencyRequest.key()).valuesAreTypeOf(Provider.class);
+
+                    default:
+                      return false;
+                  }
+                }
+              })
+          .toSet();
     }
   }
 
@@ -1273,7 +1248,7 @@ private boolean doesPathRequireProvisionOnly(DependencyPath path) {
    */
   private ImmutableSet<? extends Binding> provisionsDependingOnLatestRequest(
       final DependencyPath path) {
-    return FluentIterable.from(path.previousBinding().bindings())
+    return FluentIterable.from(path.previousResolvedBindings().bindings())
         .filter(BindingType.isOfType(BindingType.PROVISION))
         .filter(
             new Predicate<Binding>() {
@@ -1305,8 +1280,10 @@ private String formatRootRequestKey(DependencyPath path) {
 
   @AutoValue
   abstract static class ResolvedRequest {
-    abstract DependencyRequest request();
-    abstract ResolvedBindings binding();
+
+    abstract DependencyRequest dependencyRequest();
+
+    abstract ResolvedBindings resolvedBindings();
 
     static ResolvedRequest create(DependencyRequest request, BindingGraph graph) {
       BindingKey bindingKey = request.bindingKey();
@@ -1317,5 +1294,13 @@ static ResolvedRequest create(DependencyRequest request, BindingGraph graph) {
               ? ResolvedBindings.noBindings(bindingKey, graph.componentDescriptor())
               : resolvedBindings);
     }
+
+    static final Function<ResolvedRequest, DependencyRequest> DEPENDENCY_REQUEST =
+        new Function<ResolvedRequest, DependencyRequest>() {
+          @Override
+          public DependencyRequest apply(ResolvedRequest resolvedRequest) {
+            return resolvedRequest.dependencyRequest();
+          }
+        };
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index fa3e8e30e..e33d0cd74 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -285,7 +285,7 @@ boolean isProducer() {
   abstract Optional<BuilderSpec> builderSpec();
 
   @AutoValue
-  static abstract class ComponentMethodDescriptor {
+  abstract static class ComponentMethodDescriptor {
     abstract ComponentMethodKind kind();
     abstract Optional<DependencyRequest> dependencyRequest();
     abstract ExecutableElement methodElement();
@@ -356,7 +356,7 @@ Kind componentKind() {
   }
 
   @AutoValue
-  static abstract class BuilderSpec {
+  abstract static class BuilderSpec {
     abstract TypeElement builderDefinitionType();
     abstract Map<TypeElement, ExecutableElement> methodMap();
     abstract ExecutableElement buildMethod();
@@ -465,7 +465,6 @@ private ComponentDescriptor create(
             break;
           default: // nothing special to do for other methods.
         }
-
       }
 
       ImmutableList<DeclaredType> enclosedBuilders = kind.builderAnnotationType() == null
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index 5fae068e6..41f685cba 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -90,7 +90,7 @@ public SourceVersion getSupportedSourceVersion() {
     MultibindingsMethodValidator multibindingsMethodValidator =
         new MultibindingsMethodValidator(elements, types);
 
-    Key.Factory keyFactory = new Key.Factory(types, elements);
+    Key.Factory keyFactory = new Key.Factory(types, elements, methodSignatureFormatter);
 
     MultibindingsValidator multibindingsValidator =
         new MultibindingsValidator(
@@ -201,6 +201,9 @@ public SourceVersion getSupportedSourceVersion() {
         producerModuleProcessingStep(
             messager,
             moduleValidator,
+            provisionBindingFactory,
+            factoryGenerator,
+            providesMethodValidator,
             productionBindingFactory,
             producerFactoryGenerator,
             producesMethodValidator,
diff --git a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
index 76e8c0d64..23f396377 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
@@ -130,6 +130,14 @@ public TypeMirror apply(AnnotationValue typeValue) {
           throw new IllegalArgumentException(elementName + " is not an array: " + o);
         }
       };
+      
+  /**
+   * Returns the value named {@code elementName} from {@code annotation}, which must be a member
+   * that contains a single type.
+   */
+  static TypeMirror typeValue(AnnotationMirror annotation, String elementName) {
+    return TO_TYPE.visit(getAnnotationValue(annotation, elementName));
+  }
 
   private static final AnnotationValueVisitor<TypeMirror, Void> TO_TYPE =
       new SimpleAnnotationValueVisitor6<TypeMirror, Void>() {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
index fe22d2b11..1096ea3a2 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
@@ -26,6 +26,7 @@
 import com.google.common.collect.Multimaps;
 import com.google.common.collect.Sets;
 import com.google.common.util.concurrent.ListenableFuture;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import dagger.Component;
 import dagger.MapKey;
 import dagger.Provides;
@@ -36,11 +37,17 @@
 import javax.inject.Inject;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
 
 import static com.google.common.collect.Sets.immutableEnumSet;
+import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.CLASS_CONSTRUCTOR;
+import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.DELEGATE;
+import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.ENUM_INSTANCE;
 import static dagger.internal.codegen.ContributionBinding.Kind.IS_SYNTHETIC_KIND;
+import static dagger.internal.codegen.ContributionType.SET;
 import static dagger.internal.codegen.MapKeys.unwrapValue;
 import static dagger.internal.codegen.MoreAnnotationMirrors.unwrapOptionalEquivalence;
 import static javax.lang.model.element.Modifier.STATIC;
@@ -213,26 +220,30 @@ static Kind forMultibindingRequest(DependencyRequest request) {
   }
 
   /**
-   * Returns {@link FactoryCreationStrategy#ENUM_INSTANCE} if the binding has no dependencies and
-   * is a static provision binding or an {@link Inject @Inject} constructor binding. Otherwise
-   * returns {@link FactoryCreationStrategy#CLASS_CONSTRUCTOR}.
+   * Returns the {@link FactoryCreationStrategy} appropriate for a binding.
+   *
+   * <p>Delegate bindings
+   * use the {@link FactoryCreationStrategy#DELEGATE} strategy.
+   *
+   * <p>Bindings without dependencies that don't require a module instance use the
+   * {@link FactoryCreationStrategy#ENUM_INSTANCE} strategy.
+   *
+   * <p>All other bindings use the {@link FactoryCreationStrategy#CLASS_CONSTRUCTOR} strategy.
    */
   FactoryCreationStrategy factoryCreationStrategy() {
     switch (bindingKind()) {
       case SYNTHETIC_DELEGATE_BINDING:
-        return FactoryCreationStrategy.DELEGATE;
+        return DELEGATE;
       case PROVISION:
         return implicitDependencies().isEmpty() && bindingElement().getModifiers().contains(STATIC)
-            ? FactoryCreationStrategy.ENUM_INSTANCE
-            : FactoryCreationStrategy.CLASS_CONSTRUCTOR;
+            ? ENUM_INSTANCE
+            : CLASS_CONSTRUCTOR;
       case INJECTION:
       case SYNTHETIC_MULTIBOUND_SET:
       case SYNTHETIC_MULTIBOUND_MAP:
-        return implicitDependencies().isEmpty()
-            ? FactoryCreationStrategy.ENUM_INSTANCE
-            : FactoryCreationStrategy.CLASS_CONSTRUCTOR;
+        return implicitDependencies().isEmpty() ? ENUM_INSTANCE : CLASS_CONSTRUCTOR;
       default:
-        return FactoryCreationStrategy.CLASS_CONSTRUCTOR;
+        return CLASS_CONSTRUCTOR;
     }
   }
 
@@ -291,4 +302,31 @@ public Object apply(ContributionBinding mapBinding) {
               }
             }));
   }
+
+  /**
+   * Base builder for {@link com.google.auto.value.AutoValue @AutoValue} subclasses of
+   * {@link ContributionBinding}.
+   */
+  @CanIgnoreReturnValue
+  abstract static class Builder<B extends Builder<B>> {
+    abstract B contributionType(ContributionType contributionType);
+
+    abstract B bindingElement(Element bindingElement);
+
+    abstract B contributingModule(TypeElement contributingModule);
+
+    abstract B key(Key key);
+
+    abstract B dependencies(Iterable<DependencyRequest> dependencies);
+
+    abstract B dependencies(DependencyRequest... dependencies);
+
+    abstract B nullableType(Optional<DeclaredType> nullableType);
+
+    abstract B membersInjectionRequest(Optional<DependencyRequest> membersInjectionRequest);
+
+    abstract B wrappedMapKey(Optional<Equivalence.Wrapper<AnnotationMirror>> wrappedMapKey);
+
+    abstract B bindingKind(ContributionBinding.Kind kind);
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/DelegateDeclaration.java b/compiler/src/main/java/dagger/internal/codegen/DelegateDeclaration.java
index e2bf84705..cfabcae1e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DelegateDeclaration.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DelegateDeclaration.java
@@ -66,7 +66,7 @@ DelegateDeclaration create(
               Iterables.getOnlyElement(resolvedMethod.getParameterTypes()));
       return new AutoValue_DelegateDeclaration(
           ContributionType.fromBindingMethod(bindsMethod),
-          keyFactory.forBindsMethod(bindsMethod, resolvedMethod),
+          keyFactory.forBindsMethod(bindsMethod, contributingElement),
           bindsMethod,
           Optional.of(contributingElement),
           delegateRequest,
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
index 84434fcdd..19c5c0959 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -110,7 +110,7 @@
     Kind() {
       this.frameworkClass = Optional.absent();
     }
-    
+
     /**
      * If {@code type}'s raw type is {@link #frameworkClass}, returns a {@link KindAndType} with
      * this kind that represents the dependency request.
@@ -131,7 +131,7 @@ KindAndType ofType(TypeMirror type) {
 
   abstract Kind kind();
   abstract Key key();
-  
+
   BindingKey bindingKey() {
     switch (kind()) {
       case INSTANCE:
@@ -159,7 +159,7 @@ BindingKey bindingKey() {
    * use a name derived from {@link #requestElement}.
    */
   abstract Optional<String> overriddenVariableName();
-  
+
   /** {@code true} if this is a synthetic request, which should not appear in dependency traces. */
   abstract boolean isSynthetic();
 
@@ -200,7 +200,7 @@ public boolean apply(DependencyRequest request) {
     /**
      * Creates a implicit {@link DependencyRequest} for {@code mapOfFactoryKey}, which will be used
      * to satisfy the {@code mapOfValueRequest}.
-     * 
+     *
      * @param mapOfValueRequest a request for {@code Map<K, V>}
      * @param mapOfFactoryKey a key equivalent to {@code mapOfValueRequest}'s key, whose type is
      *     {@code Map<K, Provider<V>>} or {@code Map<K, Producer<V>>}
@@ -224,8 +224,8 @@ DependencyRequest forImplicitMapBinding(
     DependencyRequest forMultibindingContribution(
         DependencyRequest request, ContributionBinding multibindingContribution) {
       checkArgument(
-          multibindingContribution.key().bindingMethodIdentifier().isPresent(),
-          "multibindingContribution's key must have a binding method identifier: %s",
+          multibindingContribution.key().bindingIdentifier().isPresent(),
+          "multibindingContribution's key must have a binding identifier: %s",
           multibindingContribution);
       return new AutoValue_DependencyRequest(
           multibindingContributionRequestKind(multibindingContribution),
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
index 9c3c65b92..adfdd69e5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
@@ -78,7 +78,7 @@ String toDependencyTrace(DependencyPath dependencyPath) {
     return Joiner.on('\n')
         .join(
             dependencyPath
-                .requests()
+                .dependencyRequests()
                 .filter(Predicates.not(DependencyRequest.IS_SYNTHETIC))
                 .transform(this)
                 .filter(Predicates.not(Predicates.equalTo("")))
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index cbb82fc58..69b2d0ece 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -231,7 +231,7 @@ static String inconsistentMapKeyAnnotationsError(String key) {
       "Map key annotations with unwrapped values cannot use arrays";
 
   /* collection binding errors */
-  static final String MULTIPLE_BINDING_TYPES_FOR_KEY_FORMAT =
+  static final String MULTIPLE_CONTRIBUTION_TYPES_FOR_KEY_FORMAT =
       "%s has incompatible bindings or declarations:\n";
 
   static final String PROVIDER_ENTRY_POINT_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT =
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index 9ca9ef07f..757833900 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -23,6 +23,8 @@
 import com.google.common.base.Function;
 import com.google.common.base.MoreObjects;
 import com.google.common.base.Optional;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Multimaps;
@@ -55,6 +57,7 @@
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.auto.common.MoreTypes.asExecutable;
+import static com.google.common.base.Optional.presentInstances;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
@@ -102,28 +105,28 @@
    * {@linkplain ProvisionBinding.Factory#syntheticMultibinding(DependencyRequest, Iterable)
    * synthetic binding} that depends on the specific contributions to that map or set. Each such
    * contribution binding therefore needs a key that identifies the specific binding, and not only
-   * the qualified type that is bound. For those bindings, this is the binding method element.
+   * the qualified type that is bound.
+   *
+   * <p>For nonsynthetic multibinding contributions, this should be a human-readable string that
+   * identifies the method and contributing module.
    */
-  abstract Optional<BindingMethodIdentifier> bindingMethodIdentifier();
+  abstract Optional<BindingIdentifier> bindingIdentifier();
 
   /** An object that uniquely identifies a multibinding contribution binding. */
   @AutoValue
-  abstract static class BindingMethodIdentifier {
-    /**
-     * The {@link dagger.Provides} or {@link dagger.producers.Produces} method that contributes to
-     * the multibinding.
-     */
-    abstract ExecutableElement bindingMethod();
+  abstract static class BindingIdentifier {
+    abstract String string();
 
-    /** The installed module that contains or inherits the {@link #bindingMethod()}. */
-    abstract TypeElement contributingModule();
+    @Override
+    public final String toString() {
+      return string();
+    }
 
-    static BindingMethodIdentifier create(
-        ExecutableElement bindingMethod, TypeElement contributingModule) {
-      return new AutoValue_Key_BindingMethodIdentifier(bindingMethod, contributingModule);
+    static BindingIdentifier create(String string) {
+      return new AutoValue_Key_BindingIdentifier(string);
     }
   }
-  
+
   /**
    * A {@link javax.inject.Qualifier} annotation that provides a unique namespace prefix
    * for the type of this key.
@@ -145,32 +148,34 @@ private static TypeMirror normalize(Types types, TypeMirror type) {
   }
 
   /**
-   * A key whose {@link #qualifier()} and {@link #bindingMethodIdentifier()} are equivalent to this
+   * A key whose {@link #qualifier()} and {@link #bindingIdentifier()} are equivalent to this
    * one's, but with {@code newType} (normalized) as its {@link #type()}.
    */
   private Key withType(Types types, TypeMirror newType) {
     return new AutoValue_Key(
         wrappedQualifier(),
         MoreTypes.equivalence().wrap(normalize(types, newType)),
-        bindingMethodIdentifier());
+        bindingIdentifier());
   }
 
   /**
    * A key whose {@link #qualifier()} and {@link #type()} are equivalent to this one's, but with
-   * {@code bindingDeclaration} as its {@link #bindingMethodIdentifier()}.
+   * {@code bindingIdentifier} as its {@link #bindingIdentifier()}.
    */
-  private Key withBindingMethodIdentifier(BindingMethodIdentifier bindingMethodIdentifier) {
+  private Key withBindingIdentifier(String bindingIdentifier) {
     return new AutoValue_Key(
-        wrappedQualifier(), wrappedType(), Optional.of(bindingMethodIdentifier));
+        wrappedQualifier(),
+        wrappedType(),
+        Optional.of(BindingIdentifier.create(bindingIdentifier)));
   }
 
   /**
    * A key whose {@link #qualifier()} and {@link #type()} are equivalent to this one's, but with an
-   * absent {@link #bindingMethodIdentifier()}.
+   * absent {@link #bindingIdentifier()}.
    */
-  Key withoutBindingMethodIdentifier() {
+  Key withoutBindingIdentifier() {
     return new AutoValue_Key(
-        wrappedQualifier(), wrappedType(), Optional.<BindingMethodIdentifier>absent());
+        wrappedQualifier(), wrappedType(), Optional.<BindingIdentifier>absent());
   }
 
   boolean isValidMembersInjectionKey() {
@@ -225,7 +230,7 @@ public String toString() {
         .omitNullValues()
         .add("qualifier", qualifier().orNull())
         .add("type", type())
-        .add("bindingMethodIdentifier", bindingMethodIdentifier().orNull())
+        .add("bindingIdentifier", bindingIdentifier().orNull())
         .toString();
   }
 
@@ -247,18 +252,22 @@ public Key apply(HasKey hasKey) {
   static final class Factory {
     private final Types types;
     private final Elements elements;
+    private final MethodSignatureFormatter methodSignatureFormatter;
 
-    Factory(Types types, Elements elements) {
+    Factory(Types types, Elements elements, MethodSignatureFormatter methodSignatureFormatter) {
       this.types = checkNotNull(types);
       this.elements = checkNotNull(elements);
+      this.methodSignatureFormatter = checkNotNull(methodSignatureFormatter);
     }
 
-    private TypeElement getSetElement() {
-      return elements.getTypeElement(Set.class.getCanonicalName());
+    private DeclaredType setOf(TypeMirror elementType) {
+      return types.getDeclaredType(
+          elements.getTypeElement(Set.class.getCanonicalName()), elementType);
     }
 
-    private TypeElement getMapElement() {
-      return elements.getTypeElement(Map.class.getCanonicalName());
+    private DeclaredType mapOf(TypeMirror keyType, TypeMirror valueType) {
+      return types.getDeclaredType(
+          elements.getTypeElement(Map.class.getCanonicalName()), keyType, valueType);
     }
 
     private TypeElement getProviderElement() {
@@ -326,8 +335,7 @@ private Key forProvidesOrProducesMethod(
       Key key = forMethod(method, keyType);
       return contributionType.equals(ContributionType.UNIQUE)
           ? key
-          : key.withBindingMethodIdentifier(
-              BindingMethodIdentifier.create(method, contributingModule));
+          : key.withBindingIdentifier(bindingIdentifier(method, contributingModule));
     }
 
     /**
@@ -354,19 +362,27 @@ Key forMultibindsMethod(
     }
 
     /** Returns the key bound by a {@link Binds} method. */
-    Key forBindsMethod(ExecutableElement method, ExecutableType methodType) {
+    Key forBindsMethod(ExecutableElement method, TypeElement contributingModule) {
       checkArgument(isAnnotationPresent(method, Binds.class));
       ContributionType contributionType = ContributionType.fromBindingMethod(method);
-      TypeMirror returnType = normalize(types, methodType.getReturnType());
+      TypeMirror returnType =
+          normalize(
+              types,
+              MoreTypes.asExecutable(
+                      types.asMemberOf(MoreTypes.asDeclared(contributingModule.asType()), method))
+                  .getReturnType());
       TypeMirror keyType =
           bindingMethodKeyType(
               returnType, method, contributionType, Optional.<TypeElement>absent());
       Key key = forMethod(method, keyType);
       return contributionType.equals(ContributionType.UNIQUE)
           ? key
-          : key.withBindingMethodIdentifier(
-              BindingMethodIdentifier.create(
-                  method, MoreElements.asType(method.getEnclosingElement())));
+          : key.withBindingIdentifier(bindingIdentifier(method, contributingModule));
+    }
+
+    private String bindingIdentifier(ExecutableElement method, TypeElement contributingModule) {
+      return methodSignatureFormatter.format(
+          method, Optional.of(MoreTypes.asDeclared(contributingModule.asType())));
     }
 
     private TypeMirror bindingMethodKeyType(
@@ -378,12 +394,12 @@ private TypeMirror bindingMethodKeyType(
         case UNIQUE:
           return returnType;
         case SET:
-          return types.getDeclaredType(getSetElement(), returnType);
+          return setOf(returnType);
         case MAP:
           if (frameworkType.isPresent()) {
             return mapOfFrameworkType(mapKeyType(method), frameworkType.get(), returnType);
           } else {
-            return types.getDeclaredType(getMapElement(), mapKeyType(method), returnType);
+            return mapOf(mapKeyType(method), returnType);
           }
         case SET_VALUES:
           // TODO(gak): do we want to allow people to use "covariant return" here?
@@ -413,8 +429,7 @@ Key forDelegateBinding(
      */
     private TypeMirror mapOfFrameworkType(
         TypeMirror keyType, TypeElement frameworkType, TypeMirror valueType) {
-      return types.getDeclaredType(
-          getMapElement(), keyType, types.getDeclaredType(frameworkType, valueType));
+      return mapOf(keyType, types.getDeclaredType(frameworkType, valueType));
     }
 
     private TypeMirror mapKeyType(ExecutableElement method) {
@@ -428,35 +443,35 @@ private Key forMethod(ExecutableElement method, TypeMirror keyType) {
       return new AutoValue_Key(
           wrapOptionalInEquivalence(getQualifier(method)),
           MoreTypes.equivalence().wrap(keyType),
-          Optional.<BindingMethodIdentifier>absent());
+          Optional.<BindingIdentifier>absent());
     }
 
     Key forInjectConstructorWithResolvedType(TypeMirror type) {
       return new AutoValue_Key(
           Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
           MoreTypes.equivalence().wrap(type),
-          Optional.<BindingMethodIdentifier>absent());
+          Optional.<BindingIdentifier>absent());
     }
 
     Key forComponent(TypeMirror type) {
       return new AutoValue_Key(
           Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
           MoreTypes.equivalence().wrap(normalize(types, type)),
-          Optional.<BindingMethodIdentifier>absent());
+          Optional.<BindingIdentifier>absent());
     }
 
     Key forMembersInjectedType(TypeMirror type) {
       return new AutoValue_Key(
           Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
           MoreTypes.equivalence().wrap(normalize(types, type)),
-          Optional.<BindingMethodIdentifier>absent());
+          Optional.<BindingIdentifier>absent());
     }
 
     Key forQualifiedType(Optional<AnnotationMirror> qualifier, TypeMirror type) {
       return new AutoValue_Key(
           wrapOptionalInEquivalence(qualifier),
           MoreTypes.equivalence().wrap(normalize(types, type)),
-          Optional.<BindingMethodIdentifier>absent());
+          Optional.<BindingIdentifier>absent());
     }
 
     Key forProductionExecutor() {
@@ -471,13 +486,25 @@ Key forProductionImplementationExecutor() {
           getClassElement(Executor.class).asType());
     }
 
+    /**
+     * If {@code requestKey} is for a {@code Map<K, V>} or {@code Map<K, Produced<V>>}, returns keys
+     * for {@code Map<K, Provider<V>>} and {@code Map<K, Producer<V>>} (if Dagger-Producers is on
+     * the classpath).
+     */
+    FluentIterable<Key> implicitFrameworkMapKeys(Key requestKey) {
+      return FluentIterable.from(
+          presentInstances(
+              ImmutableList.of(
+                  implicitMapProviderKeyFrom(requestKey), implicitMapProducerKeyFrom(requestKey))));
+    }
+
     /**
      * Optionally extract a {@link Key} for the underlying provision binding(s) if such a
      * valid key can be inferred from the given key.  Specifically, if the key represents a
      * {@link Map}{@code <K, V>}, a key of {@code Map<K, Provider<V>>} will be returned.
      */
     Optional<Key> implicitMapProviderKeyFrom(Key possibleMapKey) {
-      return maybeWrapMapValue(possibleMapKey, Provider.class);
+      return wrapMapKey(possibleMapKey, Provider.class);
     }
 
     /**
@@ -487,8 +514,8 @@ Key forProductionImplementationExecutor() {
      * {@code Map<K, Producer<V>>} will be returned.
      */
     Optional<Key> implicitMapProducerKeyFrom(Key possibleMapKey) {
-      return maybeRewrapMapValue(possibleMapKey, Produced.class, Producer.class)
-          .or(maybeWrapMapValue(possibleMapKey, Producer.class));
+      return rewrapMapKey(possibleMapKey, Produced.class, Producer.class)
+          .or(wrapMapKey(possibleMapKey, Producer.class));
     }
 
     /**
@@ -512,8 +539,7 @@ Key convertToDelegateKey(Key possibleMapKey) {
       } else {
         return possibleMapKey;
       }
-      return possibleMapKey.withType(
-          types, types.getDeclaredType(getMapElement(), mapType.keyType(), wrappedValueType));
+      return possibleMapKey.withType(types, mapOf(mapType.keyType(), wrappedValueType));
     }
 
     /**
@@ -523,14 +549,20 @@ private Key wrapMapValue(Key key, Class<?> newWrappingClass) {
       checkArgument(
           FrameworkTypes.isFrameworkType(
               elements.getTypeElement(newWrappingClass.getName()).asType()));
-      return maybeWrapMapValue(key, newWrappingClass).get();
+      return wrapMapKey(key, newWrappingClass).get();
     }
 
     /**
-     * Returns a key of {@link Map}{@code <K, NewWrappingClass<V>>} if the input key represents a
-     * {@code Map<K, CurrentWrappingClass<V>>}.
+     * If {@code key}'s type is {@code Map<K, CurrentWrappingClass<Bar>>}, returns a key with type
+     * {@code Map<K, NewWrappingClass<Bar>>} with the same qualifier. Otherwise returns {@link
+     * Optional#absent()}.
+     *
+     * <p>Returns {@link Optional#absent()} if {@code newWrappingClass} is not in the classpath.
+     *
+     * @throws IllegalArgumentException if {@code newWrappingClass} is the same as {@code
+     *     currentWrappingClass}
      */
-    private Optional<Key> maybeRewrapMapValue(
+    Optional<Key> rewrapMapKey(
         Key possibleMapKey, Class<?> currentWrappingClass, Class<?> newWrappingClass) {
       checkArgument(!currentWrappingClass.equals(newWrappingClass));
       if (MapType.isMap(possibleMapKey)) {
@@ -545,19 +577,21 @@ private Key wrapMapValue(Key key, Class<?> newWrappingClass) {
           DeclaredType wrappedValueType =
               types.getDeclaredType(
                   wrappingElement, mapType.unwrappedValueType(currentWrappingClass));
-          TypeMirror wrappedMapType =
-              types.getDeclaredType(getMapElement(), mapType.keyType(), wrappedValueType);
-          return Optional.of(possibleMapKey.withType(types, wrappedMapType));
+          return Optional.of(
+              possibleMapKey.withType(types, mapOf(mapType.keyType(), wrappedValueType)));
         }
       }
       return Optional.absent();
     }
 
     /**
-     * Returns a key of {@link Map}{@code <K, WrappingClass<V>>} if the input key represents a
-     * {@code Map<K, V>}.
+     * If {@code key}'s type is {@code Map<K, Foo>} and {@code Foo} is not {@code WrappingClass
+     * <Bar>}, returns a key with type {@code Map<K, WrappingClass<Foo>>} with the same qualifier.
+     * Otherwise returns {@link Optional#absent()}.
+     *
+     * <p>Returns {@link Optional#absent()} if {@code WrappingClass} is not in the classpath.
      */
-    private Optional<Key> maybeWrapMapValue(Key possibleMapKey, Class<?> wrappingClass) {
+    private Optional<Key> wrapMapKey(Key possibleMapKey, Class<?> wrappingClass) {
       if (MapType.isMap(possibleMapKey)) {
         MapType mapType = MapType.from(possibleMapKey);
         if (!mapType.valuesAreTypeOf(wrappingClass)) {
@@ -569,38 +603,26 @@ private Key wrapMapValue(Key key, Class<?> newWrappingClass) {
           }
           DeclaredType wrappedValueType =
               types.getDeclaredType(wrappingElement, mapType.valueType());
-          TypeMirror wrappedMapType =
-              types.getDeclaredType(getMapElement(), mapType.keyType(), wrappedValueType);
-          return Optional.of(possibleMapKey.withType(types, wrappedMapType));
+          return Optional.of(
+              possibleMapKey.withType(types, mapOf(mapType.keyType(), wrappedValueType)));
         }
       }
       return Optional.absent();
     }
 
     /**
-     * Optionally extract a {@link Key} for a {@code Set<T>} if the given key is for
-     * {@code Set<Produced<T>>}.
+     * If {@code key}'s type is {@code Set<WrappingClass<Bar>>}, returns a key with type {@code Set
+     * <Bar>} with the same qualifier. Otherwise returns {@link Optional#absent()}.
      */
-    Optional<Key> implicitSetKeyFromProduced(Key possibleSetOfProducedKey) {
-      if (MoreTypes.isType(possibleSetOfProducedKey.type())
-          && MoreTypes.isTypeOf(Set.class, possibleSetOfProducedKey.type())) {
-        TypeMirror argType =
-            MoreTypes.asDeclared(possibleSetOfProducedKey.type()).getTypeArguments().get(0);
-        if (MoreTypes.isType(argType) && MoreTypes.isTypeOf(Produced.class, argType)) {
-          TypeMirror producedArgType = MoreTypes.asDeclared(argType).getTypeArguments().get(0);
-          TypeMirror setType = types.getDeclaredType(getSetElement(), producedArgType);
-          return Optional.of(possibleSetOfProducedKey.withType(types, setType));
+    Optional<Key> unwrapSetKey(Key key, Class<?> wrappingClass) {
+      if (SetType.isSet(key)) {
+        SetType setType = SetType.from(key);
+        if (setType.elementsAreTypeOf(wrappingClass)) {
+          return Optional.of(
+              key.withType(types, setOf(setType.unwrappedElementType(wrappingClass))));
         }
       }
       return Optional.absent();
     }
-
-    /**
-     * Optionally extract a {@link Key} for a {@code Map<K, Provider<V>>} if the given key is for
-     * {@code Map<K, Producer<V>>}.
-     */
-    Optional<Key> implicitProviderMapKeyFromProducer(Key possibleMapOfProducerKey) {
-      return maybeRewrapMapValue(possibleMapOfProducerKey, Producer.class, Provider.class);
-    }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/KeyFormatter.java b/compiler/src/main/java/dagger/internal/codegen/KeyFormatter.java
index d329627a0..3be455fdd 100644
--- a/compiler/src/main/java/dagger/internal/codegen/KeyFormatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/KeyFormatter.java
@@ -31,9 +31,9 @@
 
   @Override
   public String format(Key key) {
-    if (key.bindingMethodIdentifier().isPresent()) {
-      // If there's a binding method, its signature is enough.
-      return methodSignatureFormatter.format(key.bindingMethodIdentifier().get());
+    if (key.bindingIdentifier().isPresent()) {
+      // If there's a binding identifier, use that.
+      return key.bindingIdentifier().get().toString();
     }
     StringBuilder builder = new StringBuilder();
     if (key.qualifier().isPresent()) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapType.java b/compiler/src/main/java/dagger/internal/codegen/MapType.java
index 70cc61fde..85ef2d199 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapType.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MapType.java
@@ -100,7 +100,7 @@ TypeMirror unwrappedValueType(Class<?> wrappingClass) {
         wrappingClass.getTypeParameters().length == 1,
         "%s must have exactly one type parameter",
         wrappingClass);
-    checkState(valuesAreTypeOf(wrappingClass));
+    checkState(valuesAreTypeOf(wrappingClass), "expected values to be %s: %s", wrappingClass, this);
     return MoreTypes.asDeclared(valueType()).getTypeArguments().get(0);
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
index 2429870e6..91c88aaa0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
@@ -67,6 +67,11 @@
   TypeElement membersInjectedType() {
     return MoreElements.asType(bindingElement());
   }
+  
+  @Override
+  Optional<TypeElement> contributingModule() {
+    return Optional.absent();
+  }
 
   @Override
   Set<DependencyRequest> implicitDependencies() {
@@ -221,7 +226,6 @@ public Key apply(DeclaredType superclass) {
       TypeElement typeElement = MoreElements.asType(declaredType.asElement());
       return new AutoValue_MembersInjectionBinding(
           typeElement,
-          Optional.<TypeElement>absent(),
           key,
           dependencies,
           hasNonDefaultTypeParameters(typeElement, key.type(), types)
diff --git a/compiler/src/main/java/dagger/internal/codegen/MethodSignatureFormatter.java b/compiler/src/main/java/dagger/internal/codegen/MethodSignatureFormatter.java
index fa2e55555..20c056a68 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MethodSignatureFormatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MethodSignatureFormatter.java
@@ -18,7 +18,6 @@
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.Optional;
-import dagger.internal.codegen.Key.BindingMethodIdentifier;
 import java.util.Iterator;
 import java.util.List;
 import javax.lang.model.element.AnnotationMirror;
@@ -94,12 +93,6 @@ public String format(ExecutableElement method, Optional<DeclaredType> container)
     return builder.toString();
   }
 
-  String format(BindingMethodIdentifier bindingMethodIdentifier) {
-    return format(
-        MoreElements.asExecutable(bindingMethodIdentifier.bindingMethod()),
-        Optional.of(MoreTypes.asDeclared(bindingMethodIdentifier.contributingModule().asType())));
-  }
-
   private static void appendParameter(StringBuilder builder, VariableElement parameter,
       TypeMirror type) {
     Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(parameter);
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
index 33fd0b82b..f86fac5d4 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
@@ -39,16 +39,14 @@
 /**
  * A {@link ProcessingStep} that validates module classes and generates factories for binding
  * methods.
- *
- * @param <B> the type of binding created from methods
  */
-final class ModuleProcessingStep<B extends Binding> implements ProcessingStep {
+final class ModuleProcessingStep implements ProcessingStep {
 
   /**
-   * A {@link ProcessingStep} for {@link Module @Module} classes that generates factories for
-   * {@link Provides @Provides} methods.
+   * A {@link ProcessingStep} for {@code @Module} classes that generates factories for {@code
+   * @Provides} methods.
    */
-  static ModuleProcessingStep<ProvisionBinding> moduleProcessingStep(
+  static ModuleProcessingStep moduleProcessingStep(
       Messager messager,
       ModuleValidator moduleValidator,
       final ProvisionBinding.Factory provisionBindingFactory,
@@ -56,56 +54,49 @@
       ProvidesMethodValidator providesMethodValidator,
       BindsMethodValidator bindsMethodValidator,
       MultibindsMethodValidator multibindsMethodValidator) {
-    return new ModuleProcessingStep<>(
+    return new ModuleProcessingStep(
         messager,
         Module.class,
         moduleValidator,
-        Provides.class,
-        new ModuleMethodBindingFactory<ProvisionBinding>() {
-          @Override
-          public ProvisionBinding bindingForModuleMethod(
-              ExecutableElement method, TypeElement module) {
-            return provisionBindingFactory.forProvidesMethod(method, module);
-          }
-        },
-        factoryGenerator,
+        ImmutableSet.<ModuleMethodFactoryGenerator>of(
+            new ProvisionModuleMethodFactoryGenerator(provisionBindingFactory, factoryGenerator)),
         ImmutableSet.of(providesMethodValidator, bindsMethodValidator, multibindsMethodValidator));
   }
 
   /**
-   * A {@link ProcessingStep} for {@link ProducerModule @ProducerModule} classes that generates
-   * factories for {@link Produces @Produces} methods.
+   * A {@link ProcessingStep} for {@code @ProducerModule} classes that generates factories for
+   * {@code @Provides} and {@code @Produces} methods.
    */
-  static ModuleProcessingStep<ProductionBinding> producerModuleProcessingStep(
+  static ModuleProcessingStep producerModuleProcessingStep(
       Messager messager,
       ModuleValidator moduleValidator,
-      final ProductionBinding.Factory productionBindingFactory,
+      ProvisionBinding.Factory provisionBindingFactory,
+      FactoryGenerator factoryGenerator,
+      ProvidesMethodValidator providesMethodValidator,
+      ProductionBinding.Factory productionBindingFactory,
       ProducerFactoryGenerator producerFactoryGenerator,
       ProducesMethodValidator producesMethodValidator,
       BindsMethodValidator bindsMethodValidator,
       MultibindsMethodValidator multibindsMethodValidator) {
-    return new ModuleProcessingStep<>(
+    return new ModuleProcessingStep(
         messager,
         ProducerModule.class,
         moduleValidator,
-        Produces.class,
-        new ModuleMethodBindingFactory<ProductionBinding>() {
-          @Override
-          public ProductionBinding bindingForModuleMethod(
-              ExecutableElement method, TypeElement module) {
-            return productionBindingFactory.forProducesMethod(method, module);
-          }
-        },
-        producerFactoryGenerator,
-        ImmutableSet.of(producesMethodValidator, bindsMethodValidator, multibindsMethodValidator));
+        ImmutableSet.of(
+            new ProvisionModuleMethodFactoryGenerator(provisionBindingFactory, factoryGenerator),
+            new ProductionModuleMethodFactoryGenerator(
+                productionBindingFactory, producerFactoryGenerator)),
+        ImmutableSet.of(
+            providesMethodValidator,
+            producesMethodValidator,
+            bindsMethodValidator,
+            multibindsMethodValidator));
   }
 
   private final Messager messager;
   private final Class<? extends Annotation> moduleAnnotation;
   private final ModuleValidator moduleValidator;
-  private final Class<? extends Annotation> factoryMethodAnnotation;
-  private final ModuleMethodBindingFactory<B> moduleMethodBindingFactory;
-  private final SourceFileGenerator<B> factoryGenerator;
+  private final ImmutableSet<ModuleMethodFactoryGenerator> moduleMethodFactoryGenerators;
   private final ImmutableSet<? extends BindingMethodValidator> methodValidators;
   private final Set<TypeElement> processedModuleElements = Sets.newLinkedHashSet();
 
@@ -113,23 +104,18 @@ public ProductionBinding bindingForModuleMethod(
    * Creates a new processing step.
    *
    * @param moduleAnnotation the annotation on the module class
-   * @param factoryMethodAnnotation the annotation on methods that need factories
    * @param methodValidators validators for binding methods
    */
   ModuleProcessingStep(
       Messager messager,
       Class<? extends Annotation> moduleAnnotation,
       ModuleValidator moduleValidator,
-      Class<? extends Annotation> factoryMethodAnnotation,
-      ModuleMethodBindingFactory<B> moduleMethodBindingFactory,
-      SourceFileGenerator<B> factoryGenerator,
+      ImmutableSet<ModuleMethodFactoryGenerator> moduleMethodFactoryGenerators,
       Iterable<? extends BindingMethodValidator> methodValidators) {
     this.messager = messager;
     this.moduleAnnotation = moduleAnnotation;
     this.moduleValidator = moduleValidator;
-    this.factoryMethodAnnotation = factoryMethodAnnotation;
-    this.moduleMethodBindingFactory = moduleMethodBindingFactory;
-    this.factoryGenerator = factoryGenerator;
+    this.moduleMethodFactoryGenerators = moduleMethodFactoryGenerators;
     this.methodValidators = ImmutableSet.copyOf(methodValidators);
   }
 
@@ -158,10 +144,15 @@ public ProductionBinding bindingForModuleMethod(
       if (report.isClean()) {
         List<ExecutableElement> moduleMethods = methodsIn(moduleElement.getEnclosedElements());
         if (moduleMethodsAreValid(validMethods, moduleMethods)) {
-          for (ExecutableElement method :
-              elementsWithAnnotation(moduleMethods, factoryMethodAnnotation)) {
-            generateFactory(
-                moduleMethodBindingFactory.bindingForModuleMethod(method, moduleElement));
+          for (ModuleMethodFactoryGenerator generator : moduleMethodFactoryGenerators) {
+            for (ExecutableElement method :
+                elementsWithAnnotation(moduleMethods, generator.factoryMethodAnnotation())) {
+              try {
+                generator.generate(method, moduleElement);
+              } catch (SourceFileGenerationException e) {
+                e.printMessageTo(messager);
+              }
+            }
           }
         }
       }
@@ -200,15 +191,62 @@ private boolean moduleMethodsAreValid(
     return true;
   }
 
-  private void generateFactory(B binding) {
-    try {
-      factoryGenerator.generate(binding);
-    } catch (SourceFileGenerationException e) {
-      e.printMessageTo(messager);
+  interface ModuleMethodFactoryGenerator {
+    /** Binding method annotation for which factories should be generated. */
+    Class<? extends Annotation> factoryMethodAnnotation();
+
+    /** Generates the factory source file for the given method and module. */
+    void generate(ExecutableElement method, TypeElement moduleElement)
+        throws SourceFileGenerationException;
+  }
+
+  private static final class ProvisionModuleMethodFactoryGenerator
+      implements ModuleMethodFactoryGenerator {
+
+    private final ProvisionBinding.Factory provisionBindingFactory;
+    private final FactoryGenerator factoryGenerator;
+
+    ProvisionModuleMethodFactoryGenerator(
+        ProvisionBinding.Factory provisionBindingFactory, FactoryGenerator factoryGenerator) {
+      this.provisionBindingFactory = provisionBindingFactory;
+      this.factoryGenerator = factoryGenerator;
+    }
+
+    @Override
+    public Class<? extends Annotation> factoryMethodAnnotation() {
+      return Provides.class;
+    }
+
+    @Override
+    public void generate(ExecutableElement method, TypeElement moduleElement)
+        throws SourceFileGenerationException {
+      factoryGenerator.generate(provisionBindingFactory.forProvidesMethod(method, moduleElement));
     }
   }
 
-  private interface ModuleMethodBindingFactory<B extends Binding> {
-    B bindingForModuleMethod(ExecutableElement method, TypeElement module);
+  private static final class ProductionModuleMethodFactoryGenerator
+      implements ModuleMethodFactoryGenerator {
+
+    private final ProductionBinding.Factory productionBindingFactory;
+    private final ProducerFactoryGenerator producerFactoryGenerator;
+
+    ProductionModuleMethodFactoryGenerator(
+        ProductionBinding.Factory productionBindingFactory,
+        ProducerFactoryGenerator productionFactoryGenerator) {
+      this.productionBindingFactory = productionBindingFactory;
+      this.producerFactoryGenerator = productionFactoryGenerator;
+    }
+
+    @Override
+    public Class<? extends Annotation> factoryMethodAnnotation() {
+      return Produces.class;
+    }
+
+    @Override
+    public void generate(ExecutableElement method, TypeElement moduleElement)
+        throws SourceFileGenerationException {
+      producerFactoryGenerator.generate(
+          productionBindingFactory.forProducesMethod(method, moduleElement));
+    }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
index b062789dc..8f91d14fd 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
@@ -17,18 +17,17 @@
 
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
-import com.google.common.base.Equivalence;
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
 import com.google.common.util.concurrent.ListenableFuture;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import dagger.producers.Producer;
 import java.util.Set;
-import javax.lang.model.element.AnnotationMirror;
+import javax.annotation.CheckReturnValue;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Types;
@@ -80,6 +79,26 @@ public BindingType bindingType() {
   /** If this production requires a monitor, this will be the corresponding request. */
   abstract Optional<DependencyRequest> monitorRequest();
 
+  private static Builder builder() {
+    return new AutoValue_ProductionBinding.Builder()
+        .dependencies(ImmutableList.<DependencyRequest>of())
+        .thrownTypes(ImmutableList.<TypeMirror>of());
+  }
+
+  @AutoValue.Builder
+  @CanIgnoreReturnValue
+  abstract static class Builder extends ContributionBinding.Builder<Builder> {
+
+    abstract Builder thrownTypes(Iterable<? extends TypeMirror> thrownTypes);
+
+    abstract Builder executorRequest(DependencyRequest executorRequest);
+
+    abstract Builder monitorRequest(DependencyRequest monitorRequest);
+
+    @CheckReturnValue
+    abstract ProductionBinding build();
+  }
+
   static final class Factory {
     private final Types types;
     private final Key.Factory keyFactory;
@@ -110,19 +129,19 @@ ProductionBinding forProducesMethod(
       Kind kind = MoreTypes.isTypeOf(ListenableFuture.class, producesMethod.getReturnType())
           ? Kind.FUTURE_PRODUCTION
           : Kind.IMMEDIATE;
-      return new AutoValue_ProductionBinding(
-          ContributionType.fromBindingMethod(producesMethod),
-          producesMethod,
-          Optional.of(contributedBy),
-          key,
-          dependencies,
-          Optional.<DeclaredType>absent(), // TODO(beder): Add nullability checking with Java 8.
-          Optional.<DependencyRequest>absent(),
-          wrapOptionalInEquivalence(getMapKey(producesMethod)),
-          kind,
-          ImmutableList.copyOf(producesMethod.getThrownTypes()),
-          Optional.of(executorRequest),
-          Optional.of(monitorRequest));
+      // TODO(beder): Add nullability checking with Java 8.
+      return ProductionBinding.builder()
+          .contributionType(ContributionType.fromBindingMethod(producesMethod))
+          .bindingElement(producesMethod)
+          .contributingModule(contributedBy)
+          .key(key)
+          .dependencies(dependencies)
+          .wrappedMapKey(wrapOptionalInEquivalence(getMapKey(producesMethod)))
+          .bindingKind(kind)
+          .thrownTypes(producesMethod.getThrownTypes())
+          .executorRequest(executorRequest)
+          .monitorRequest(monitorRequest)
+          .build();
     }
 
     /**
@@ -136,47 +155,37 @@ ProductionBinding syntheticMapOfValuesOrProducedBinding(
           keyFactory.implicitMapProducerKeyFrom(requestForMapOfValuesOrProduced.key());
       checkArgument(
           mapOfProducersKey.isPresent(),
-          "%s is not for a Map<K, V>",
+          "%s is not for a Map<K, V> or Map<K, Produced<V>>",
           requestForMapOfValuesOrProduced);
       DependencyRequest requestForMapOfProducers =
           dependencyRequestFactory.forImplicitMapBinding(
               requestForMapOfValuesOrProduced, mapOfProducersKey.get());
-      return new AutoValue_ProductionBinding(
-          ContributionType.UNIQUE,
-          requestForMapOfProducers.requestElement(),
-          Optional.<TypeElement>absent(),
-          requestForMapOfValuesOrProduced.key(),
-          ImmutableSet.of(requestForMapOfProducers),
-          Optional.<DeclaredType>absent(),
-          Optional.<DependencyRequest>absent(),
-          wrapOptionalInEquivalence(getMapKey(requestForMapOfProducers.requestElement())),
-          Kind.SYNTHETIC_MAP,
-          ImmutableList.<TypeMirror>of(),
-          Optional.<DependencyRequest>absent(),
-          Optional.<DependencyRequest>absent());
+      return ProductionBinding.builder()
+          .contributionType(ContributionType.UNIQUE)
+          .bindingElement(requestForMapOfProducers.requestElement())
+          .key(requestForMapOfValuesOrProduced.key())
+          .dependencies(requestForMapOfProducers)
+          .bindingKind(Kind.SYNTHETIC_MAP)
+          .build();
     }
 
     /**
      * A synthetic binding that depends explicitly on a set of individual provision or production
      * multibinding contribution methods.
-     * 
+     *
      * <p>Note that these could be set multibindings or map multibindings.
      */
     ProductionBinding syntheticMultibinding(
         DependencyRequest request, Iterable<ContributionBinding> multibindingContributions) {
-      return new AutoValue_ProductionBinding(
-          ContributionType.UNIQUE,
-          request.requestElement(),
-          Optional.<TypeElement>absent(),
-          request.key(),
-          dependencyRequestFactory.forMultibindingContributions(request, multibindingContributions),
-          Optional.<DeclaredType>absent(),
-          Optional.<DependencyRequest>absent(),
-          Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
-          Kind.forMultibindingRequest(request),
-          ImmutableList.<TypeMirror>of(),
-          Optional.<DependencyRequest>absent(),
-          Optional.<DependencyRequest>absent());
+      return ProductionBinding.builder()
+          .contributionType(ContributionType.UNIQUE)
+          .bindingElement(request.requestElement())
+          .key(request.key())
+          .dependencies(
+              dependencyRequestFactory.forMultibindingContributions(
+                  request, multibindingContributions))
+          .bindingKind(Kind.forMultibindingRequest(request))
+          .build();
     }
 
     ProductionBinding forComponentMethod(ExecutableElement componentMethod) {
@@ -184,37 +193,27 @@ ProductionBinding forComponentMethod(ExecutableElement componentMethod) {
       checkArgument(componentMethod.getKind().equals(METHOD));
       checkArgument(componentMethod.getParameters().isEmpty());
       checkArgument(MoreTypes.isTypeOf(ListenableFuture.class, componentMethod.getReturnType()));
-      return new AutoValue_ProductionBinding(
-          ContributionType.UNIQUE,
-          componentMethod,
-          Optional.<TypeElement>absent(),
-          keyFactory.forProductionComponentMethod(componentMethod),
-          ImmutableSet.<DependencyRequest>of(),
-          Optional.<DeclaredType>absent(),
-          Optional.<DependencyRequest>absent(),
-          Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
-          Kind.COMPONENT_PRODUCTION,
-          ImmutableList.copyOf(componentMethod.getThrownTypes()),
-          Optional.<DependencyRequest>absent(),
-          Optional.<DependencyRequest>absent());
+      return ProductionBinding.builder()
+          .contributionType(ContributionType.UNIQUE)
+          .bindingElement(componentMethod)
+          .key(keyFactory.forProductionComponentMethod(componentMethod))
+          .bindingKind(Kind.COMPONENT_PRODUCTION)
+          .thrownTypes(componentMethod.getThrownTypes())
+          .build();
     }
 
     ProductionBinding delegate(
         DelegateDeclaration delegateDeclaration, ProductionBinding delegateBinding) {
-      Key key = keyFactory.forDelegateBinding(delegateDeclaration, Producer.class);
-      return new AutoValue_ProductionBinding(
-          delegateDeclaration.contributionType(),
-          delegateDeclaration.bindingElement(),
-          delegateDeclaration.contributingModule(),
-          key,
-          ImmutableSet.of(delegateDeclaration.delegateRequest()),
-          delegateBinding.nullableType(),
-          Optional.<DependencyRequest>absent(),
-          delegateDeclaration.wrappedMapKey(),
-          Kind.SYNTHETIC_DELEGATE_BINDING,
-          ImmutableList.<TypeMirror>of(),
-          Optional.<DependencyRequest>absent(),
-          Optional.<DependencyRequest>absent());
+      return ProductionBinding.builder()
+          .contributionType(delegateDeclaration.contributionType())
+          .bindingElement(delegateDeclaration.bindingElement())
+          .contributingModule(delegateDeclaration.contributingModule().get())
+          .key(keyFactory.forDelegateBinding(delegateDeclaration, Producer.class))
+          .dependencies(delegateDeclaration.delegateRequest())
+          .nullableType(delegateBinding.nullableType())
+          .wrappedMapKey(delegateDeclaration.wrappedMapKey())
+          .bindingKind(Kind.SYNTHETIC_DELEGATE_BINDING)
+          .build();
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
index 4de6fd673..3c6b46e62 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
@@ -15,8 +15,10 @@
  */
 package dagger.internal.codegen;
 
+import com.google.common.collect.ImmutableSet;
 import dagger.Module;
 import dagger.Provides;
+import dagger.producers.ProducerModule;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.util.Elements;
@@ -35,7 +37,13 @@
 final class ProvidesMethodValidator extends BindingMethodValidator {
 
   ProvidesMethodValidator(Elements elements, Types types) {
-    super(elements, types, Provides.class, Module.class, MUST_BE_CONCRETE, RUNTIME_EXCEPTION);
+    super(
+        elements,
+        types,
+        Provides.class,
+        ImmutableSet.of(Module.class, ProducerModule.class),
+        MUST_BE_CONCRETE,
+        RUNTIME_EXCEPTION);
   }
 
   @Override
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index 8a8ac1cfd..ee03fd326 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -18,13 +18,13 @@
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
-import com.google.common.base.Equivalence;
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import javax.annotation.CheckReturnValue;
 import javax.inject.Inject;
 import javax.inject.Provider;
-import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
@@ -68,6 +68,23 @@ public BindingType bindingType() {
   @Override
   abstract Optional<Scope> scope();
 
+  private static Builder builder() {
+    return new AutoValue_ProvisionBinding.Builder()
+        .dependencies(ImmutableSet.<DependencyRequest>of());
+  }
+
+  @AutoValue.Builder
+  @CanIgnoreReturnValue
+  abstract static class Builder extends ContributionBinding.Builder<Builder> {
+
+    abstract Builder unresolved(ProvisionBinding unresolved);
+
+    abstract Builder scope(Optional<Scope> scope);
+
+    @CheckReturnValue
+    abstract ProvisionBinding build();
+  }
+
   static final class Factory {
     private final Elements elements;
     private final Types types;
@@ -115,25 +132,23 @@ ProvisionBinding forInjectConstructor(ExecutableElement constructorElement,
               constructorElement.getParameters(), cxtorType.getParameterTypes());
       Optional<DependencyRequest> membersInjectionRequest =
           membersInjectionRequest(enclosingCxtorType);
-      Optional<Scope> scope = Scope.uniqueScopeOf(constructorElement.getEnclosingElement());
+
+      ProvisionBinding.Builder builder =
+          ProvisionBinding.builder()
+              .contributionType(ContributionType.UNIQUE)
+              .bindingElement(constructorElement)
+              .key(key)
+              .dependencies(dependencies)
+              .membersInjectionRequest(membersInjectionRequest)
+              .bindingKind(Kind.INJECTION)
+              .scope(Scope.uniqueScopeOf(constructorElement.getEnclosingElement()));
 
       TypeElement bindingTypeElement =
           MoreElements.asType(constructorElement.getEnclosingElement());
-
-      return new AutoValue_ProvisionBinding(
-          ContributionType.UNIQUE,
-          constructorElement,
-          Optional.<TypeElement>absent(),
-          key,
-          dependencies,
-          Optional.<DeclaredType>absent(),
-          membersInjectionRequest,
-          Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
-          Kind.INJECTION,
-          hasNonDefaultTypeParameters(bindingTypeElement, key.type(), types)
-              ? Optional.of(forInjectConstructor(constructorElement, Optional.<TypeMirror>absent()))
-              : Optional.<ProvisionBinding>absent(),
-          scope);
+      if (hasNonDefaultTypeParameters(bindingTypeElement, key.type(), types)) {
+        builder.unresolved(forInjectConstructor(constructorElement, Optional.<TypeMirror>absent()));
+      }
+      return builder.build();
     }
 
     private static final ImmutableSet<ElementKind> MEMBER_KINDS =
@@ -165,19 +180,17 @@ ProvisionBinding forProvidesMethod(
           dependencyRequestFactory.forRequiredResolvedVariables(
               providesMethod.getParameters(),
               resolvedMethod.getParameterTypes());
-      Optional<Scope> scope = Scope.uniqueScopeOf(providesMethod);
-      return new AutoValue_ProvisionBinding(
-          ContributionType.fromBindingMethod(providesMethod),
-          providesMethod,
-          Optional.of(contributedBy),
-          key,
-          dependencies,
-          ConfigurationAnnotations.getNullableType(providesMethod),
-          Optional.<DependencyRequest>absent(),
-          wrapOptionalInEquivalence(getMapKey(providesMethod)),
-          Kind.PROVISION,
-          Optional.<ProvisionBinding>absent(),
-          scope);
+      return ProvisionBinding.builder()
+          .contributionType(ContributionType.fromBindingMethod(providesMethod))
+          .bindingElement(providesMethod)
+          .contributingModule(contributedBy)
+          .key(key)
+          .dependencies(dependencies)
+          .nullableType(ConfigurationAnnotations.getNullableType(providesMethod))
+          .wrappedMapKey(wrapOptionalInEquivalence(getMapKey(providesMethod)))
+          .bindingKind(Kind.PROVISION)
+          .scope(Scope.uniqueScopeOf(providesMethod))
+          .build();
     }
 
     /**
@@ -194,75 +207,60 @@ ProvisionBinding syntheticMapOfValuesBinding(DependencyRequest requestForMapOfVa
       DependencyRequest requestForMapOfProviders =
           dependencyRequestFactory.forImplicitMapBinding(
               requestForMapOfValues, mapOfProvidersKey.get());
-      return new AutoValue_ProvisionBinding(
-          ContributionType.UNIQUE,
-          requestForMapOfProviders.requestElement(),
-          Optional.<TypeElement>absent(),
-          requestForMapOfValues.key(),
-          ImmutableSet.of(requestForMapOfProviders),
-          Optional.<DeclaredType>absent(),
-          Optional.<DependencyRequest>absent(),
-          wrapOptionalInEquivalence(getMapKey(requestForMapOfProviders.requestElement())),
-          Kind.SYNTHETIC_MAP,
-          Optional.<ProvisionBinding>absent(),
-          Scope.uniqueScopeOf(requestForMapOfProviders.requestElement()));
+      return ProvisionBinding.builder()
+          .contributionType(ContributionType.UNIQUE)
+          .bindingElement(requestForMapOfProviders.requestElement())
+          .key(requestForMapOfValues.key())
+          .dependencies(requestForMapOfProviders)
+          .wrappedMapKey(
+              wrapOptionalInEquivalence(getMapKey(requestForMapOfProviders.requestElement())))
+          .bindingKind(Kind.SYNTHETIC_MAP)
+          .scope(Scope.uniqueScopeOf(requestForMapOfProviders.requestElement()))
+          .build();
     }
 
     /**
      * A synthetic binding that depends explicitly on a set of individual provision multibinding
      * contribution methods.
-     * 
+     *
      * <p>Note that these could be set multibindings or map multibindings.
      */
     ProvisionBinding syntheticMultibinding(
         DependencyRequest request, Iterable<ContributionBinding> multibindingContributions) {
-      return new AutoValue_ProvisionBinding(
-          ContributionType.UNIQUE,
-          request.requestElement(),
-          Optional.<TypeElement>absent(),
-          request.key(),
-          dependencyRequestFactory.forMultibindingContributions(request, multibindingContributions),
-          Optional.<DeclaredType>absent(),
-          Optional.<DependencyRequest>absent(),
-          Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
-          Kind.forMultibindingRequest(request),
-          Optional.<ProvisionBinding>absent(),
-          Scope.uniqueScopeOf(request.requestElement()));
+      return ProvisionBinding.builder()
+          .contributionType(ContributionType.UNIQUE)
+          .bindingElement(request.requestElement())
+          .key(request.key())
+          .dependencies(
+              dependencyRequestFactory.forMultibindingContributions(
+                  request, multibindingContributions))
+          .bindingKind(Kind.forMultibindingRequest(request))
+          .scope(Scope.uniqueScopeOf(request.requestElement()))
+          .build();
     }
 
     ProvisionBinding forComponent(TypeElement componentDefinitionType) {
       checkNotNull(componentDefinitionType);
-      return new AutoValue_ProvisionBinding(
-          ContributionType.UNIQUE,
-          componentDefinitionType,
-          Optional.<TypeElement>absent(),
-          keyFactory.forComponent(componentDefinitionType.asType()),
-          ImmutableSet.<DependencyRequest>of(),
-          Optional.<DeclaredType>absent(),
-          Optional.<DependencyRequest>absent(),
-          Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
-          Kind.COMPONENT,
-          Optional.<ProvisionBinding>absent(),
-          Optional.<Scope>absent());
+      return ProvisionBinding.builder()
+          .contributionType(ContributionType.UNIQUE)
+          .bindingElement(componentDefinitionType)
+          .key(keyFactory.forComponent(componentDefinitionType.asType()))
+          .bindingKind(Kind.COMPONENT)
+          .build();
     }
 
     ProvisionBinding forComponentMethod(ExecutableElement componentMethod) {
       checkNotNull(componentMethod);
       checkArgument(componentMethod.getKind().equals(METHOD));
       checkArgument(componentMethod.getParameters().isEmpty());
-      Optional<Scope> scope = Scope.uniqueScopeOf(componentMethod);
-      return new AutoValue_ProvisionBinding(
-          ContributionType.UNIQUE,
-          componentMethod,
-          Optional.<TypeElement>absent(),
-          keyFactory.forComponentMethod(componentMethod),
-          ImmutableSet.<DependencyRequest>of(),
-          ConfigurationAnnotations.getNullableType(componentMethod),
-          Optional.<DependencyRequest>absent(),
-          Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
-          Kind.COMPONENT_PROVISION,
-          Optional.<ProvisionBinding>absent(),
-          scope);
+      return ProvisionBinding.builder()
+          .contributionType(ContributionType.UNIQUE)
+          .bindingElement(componentMethod)
+          .key(keyFactory.forComponentMethod(componentMethod))
+          .nullableType(ConfigurationAnnotations.getNullableType(componentMethod))
+          .bindingKind(Kind.COMPONENT_PROVISION)
+          .scope(Scope.uniqueScopeOf(componentMethod))
+          .build();
     }
 
     ProvisionBinding forSubcomponentBuilderMethod(
@@ -271,35 +269,28 @@ ProvisionBinding forSubcomponentBuilderMethod(
       checkArgument(subcomponentBuilderMethod.getKind().equals(METHOD));
       checkArgument(subcomponentBuilderMethod.getParameters().isEmpty());
       DeclaredType declaredContainer = asDeclared(contributedBy.asType());
-      return new AutoValue_ProvisionBinding(
-          ContributionType.UNIQUE,
-          subcomponentBuilderMethod,
-          Optional.<TypeElement>absent(),
-          keyFactory.forSubcomponentBuilderMethod(subcomponentBuilderMethod, declaredContainer),
-          ImmutableSet.<DependencyRequest>of(),
-          Optional.<DeclaredType>absent(),
-          Optional.<DependencyRequest>absent(),
-          Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
-          Kind.SUBCOMPONENT_BUILDER,
-          Optional.<ProvisionBinding>absent(),
-          Optional.<Scope>absent());
+      return ProvisionBinding.builder()
+          .contributionType(ContributionType.UNIQUE)
+          .bindingElement(subcomponentBuilderMethod)
+          .key(
+              keyFactory.forSubcomponentBuilderMethod(subcomponentBuilderMethod, declaredContainer))
+          .bindingKind(Kind.SUBCOMPONENT_BUILDER)
+          .build();
     }
 
     ProvisionBinding delegate(
         DelegateDeclaration delegateDeclaration, ProvisionBinding delegate) {
-      Key key = keyFactory.forDelegateBinding(delegateDeclaration, Provider.class);
-      return new AutoValue_ProvisionBinding(
-          delegateDeclaration.contributionType(),
-          delegateDeclaration.bindingElement(),
-          delegateDeclaration.contributingModule(),
-          key,
-          ImmutableSet.of(delegateDeclaration.delegateRequest()),
-          delegate.nullableType(),
-          Optional.<DependencyRequest>absent(),
-          delegateDeclaration.wrappedMapKey(),
-          Kind.SYNTHETIC_DELEGATE_BINDING,
-          Optional.<ProvisionBinding>absent(),
-          Scope.uniqueScopeOf(delegateDeclaration.bindingElement()));
+      return ProvisionBinding.builder()
+          .contributionType(delegateDeclaration.contributionType())
+          .bindingElement(delegateDeclaration.bindingElement())
+          .contributingModule(delegateDeclaration.contributingModule().get())
+          .key(keyFactory.forDelegateBinding(delegateDeclaration, Provider.class))
+          .dependencies(delegateDeclaration.delegateRequest())
+          .nullableType(delegate.nullableType())
+          .wrappedMapKey(delegateDeclaration.wrappedMapKey())
+          .bindingKind(Kind.SYNTHETIC_DELEGATE_BINDING)
+          .scope(Scope.uniqueScopeOf(delegateDeclaration.bindingElement()))
+          .build();
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
index 49d465cb3..5a73f5367 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
@@ -34,7 +34,6 @@
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkState;
-import static com.google.common.collect.Iterables.concat;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.ContributionType.indexByContributionType;
 
@@ -268,18 +267,21 @@ ContributionBinding contributionBinding() {
   }
 
   /**
-   * The binding type for all {@link #bindings()} and {@link #multibindingDeclarations()}.
+   * The binding type for these bindings. If there are {@link #multibindingDeclarations()} but no
+   * {@link #bindings()}, returns {@link BindingType#PROVISION}.
    *
    * @throws IllegalStateException if {@link #isEmpty()} or the binding types conflict
    */
   @Override
   public BindingType bindingType() {
     checkState(!isEmpty(), "empty bindings for %s", bindingKey());
+    if (bindings().isEmpty() && !multibindingDeclarations().isEmpty()) {
+      // Only multibinding declarations, so assume provision.
+      return BindingType.PROVISION;
+    }
     ImmutableSet<BindingType> bindingTypes =
-        FluentIterable.from(concat(bindings(), multibindingDeclarations()))
-            .transform(BindingType.BINDING_TYPE)
-            .toSet();
-    checkState(bindingTypes.size() == 1, "conflicting binding types: %s", this);
+        FluentIterable.from(bindings()).transform(BindingType.BINDING_TYPE).toSet();
+    checkState(bindingTypes.size() == 1, "conflicting binding types: %s", bindings());
     return getOnlyElement(bindingTypes);
   }
 
@@ -349,6 +351,15 @@ public ContributionType contributionType() {
     return bindingType().frameworkClass();
   }
 
+  /**
+   * The scope associated with the single binding.
+   *
+   * @throws IllegalStateException if {@link #bindings()} does not have exactly one element
+   */
+  Optional<Scope> scope() {
+    return getOnlyElement(bindings()).scope();
+  }
+
   static final Function<ResolvedBindings, Set<ContributionBinding>> CONTRIBUTION_BINDINGS =
       new Function<ResolvedBindings, Set<ContributionBinding>>() {
         @Override
diff --git a/compiler/src/main/java/dagger/internal/codegen/Scope.java b/compiler/src/main/java/dagger/internal/codegen/Scope.java
index 0c136b3d7..f807a4fb2 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Scope.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Scope.java
@@ -19,7 +19,6 @@
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.Function;
 import com.google.common.base.Optional;
-import com.google.common.base.Preconditions;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
@@ -105,8 +104,8 @@ private static Scope scope(Elements elements, Class<? extends Annotation> scopeA
    * <p>It's readable source because it has had common package prefixes removed, e.g.
    * {@code @javax.inject.Singleton} is returned as {@code @Singleton}.
    *
-   * This does not return any annotation values as according to {@link javax.inject.Scope} scope
-   * annotations are not supposed to use them.
+   * <p>Does not return any annotation values, since {@link javax.inject.Scope @Scope}
+   * annotations are not supposed to have any.
    */
   public String getReadableSource() {
     return stripCommonTypePrefixes("@" + getQualifiedName());
@@ -116,10 +115,14 @@ public String getReadableSource() {
    * Returns the fully qualified name of the annotation type.
    */
   public String getQualifiedName() {
-    Preconditions.checkState(annotationMirror != null,
-        "Cannot create a stripped source representation of no annotation");
-    TypeElement typeElement = MoreTypes.asTypeElement(annotationMirror.getAnnotationType());
-    return typeElement.getQualifiedName().toString();
+    return scopeAnnotationElement().getQualifiedName().toString();
+  }
+
+  /**
+   * The scope annotation element.
+   */
+  public TypeElement scopeAnnotationElement() {
+    return MoreTypes.asTypeElement(annotationMirror.getAnnotationType());
   }
 
   /**
diff --git a/compiler/src/main/java/dagger/internal/codegen/SimpleAnnotationMirror.java b/compiler/src/main/java/dagger/internal/codegen/SimpleAnnotationMirror.java
index c94eafea6..8ba3704dc 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SimpleAnnotationMirror.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SimpleAnnotationMirror.java
@@ -16,7 +16,11 @@
 package dagger.internal.codegen;
 
 import com.google.auto.common.MoreTypes;
+import com.google.common.base.Functions;
+import com.google.common.base.Joiner;
+import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.Maps;
 import java.util.Map;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
@@ -26,33 +30,77 @@
 import javax.lang.model.type.DeclaredType;
 
 import static com.google.common.base.Preconditions.checkArgument;
+import static dagger.internal.codegen.Util.ELEMENT_SIMPLE_NAME;
+import static javax.lang.model.util.ElementFilter.methodsIn;
 
-/** A representation of an annotation with no fields. */
+/** A representation of an annotation. */
 final class SimpleAnnotationMirror implements AnnotationMirror {
-  private final DeclaredType type;
+  private final TypeElement annotationType;
+  private final ImmutableMap<String, ? extends AnnotationValue> namedValues;
+  private final ImmutableMap<ExecutableElement, ? extends AnnotationValue> elementValues;
 
-  private SimpleAnnotationMirror(DeclaredType type) {
-    this.type = type;
+  private SimpleAnnotationMirror(
+      TypeElement annotationType, Map<String, ? extends AnnotationValue> namedValues) {
+    checkArgument(
+        annotationType.getKind().equals(ElementKind.ANNOTATION_TYPE),
+        "annotationType must be an annotation: %s",
+        annotationType);
+    checkArgument(
+        FluentIterable.from(methodsIn(annotationType.getEnclosedElements()))
+            .transform(ELEMENT_SIMPLE_NAME)
+            .toSet()
+            .equals(namedValues.keySet()),
+        "namedValues must have values for exactly the members in %s: %s",
+        annotationType,
+        namedValues);
+    this.annotationType = annotationType;
+    this.namedValues = ImmutableMap.copyOf(namedValues);
+    this.elementValues =
+        Maps.toMap(
+            methodsIn(annotationType.getEnclosedElements()),
+            Functions.compose(Functions.forMap(namedValues), ELEMENT_SIMPLE_NAME));
   }
 
   @Override
   public DeclaredType getAnnotationType() {
-    return type;
+    return MoreTypes.asDeclared(annotationType.asType());
   }
 
   @Override
-  public Map<? extends ExecutableElement, ? extends AnnotationValue> getElementValues() {
-    return ImmutableMap.of();
+  public Map<ExecutableElement, ? extends AnnotationValue> getElementValues() {
+    return elementValues;
   }
 
   @Override
   public String toString() {
-    return "@" + type;
+    StringBuilder builder = new StringBuilder("@").append(annotationType.getQualifiedName());
+    if (!namedValues.isEmpty()) {
+      builder
+          .append('(')
+          .append(Joiner.on(", ").withKeyValueSeparator(" = ").join(namedValues))
+          .append(')');
+    }
+    return builder.toString();
   }
 
-  static AnnotationMirror of(TypeElement element) {
-    checkArgument(element.getKind().equals(ElementKind.ANNOTATION_TYPE));
-    checkArgument(element.getEnclosedElements().isEmpty());
-    return new SimpleAnnotationMirror(MoreTypes.asDeclared(element.asType()));
+  /**
+   * An object representing an annotation instance.
+   *
+   * @param annotationType must be an annotation type with no members
+   */
+  static AnnotationMirror of(TypeElement annotationType) {
+    return of(annotationType, ImmutableMap.<String, AnnotationValue>of());
+  }
+
+  /**
+   * An object representing an annotation instance.
+   *
+   * @param annotationType must be an annotation type
+   * @param namedValues a value for every annotation member, including those with defaults, indexed
+   *     by simple name
+   */
+  static AnnotationMirror of(
+      TypeElement annotationType, Map<String, ? extends AnnotationValue> namedValues) {
+    return new SimpleAnnotationMirror(annotationType, namedValues);
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/SimpleTypeAnnotationValue.java b/compiler/src/main/java/dagger/internal/codegen/SimpleTypeAnnotationValue.java
new file mode 100644
index 000000000..fee479074
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/SimpleTypeAnnotationValue.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import javax.lang.model.element.AnnotationValue;
+import javax.lang.model.element.AnnotationValueVisitor;
+import javax.lang.model.type.TypeMirror;
+
+/** An {@link AnnotationValue} that contains a {@link TypeMirror}. */
+final class SimpleTypeAnnotationValue implements AnnotationValue {
+  private final TypeMirror value;
+
+  SimpleTypeAnnotationValue(TypeMirror value) {
+    this.value = value;
+  }
+
+  @Override
+  public TypeMirror getValue() {
+    return value;
+  }
+
+  @Override
+  public String toString() {
+    return value + ".class";
+  }
+
+  @Override
+  public <R, P> R accept(AnnotationValueVisitor<R, P> visitor, P parameter) {
+    return visitor.visitType(getValue(), parameter);
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index d93fae3d9..6775ee13a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -170,7 +170,6 @@ public TypeElement visitType(TypeElement e, Void p) {
         }
       };
 
-      
   /**
    * Returns {@code true} iff the given element has an {@link AnnotationMirror} whose
    * {@linkplain AnnotationMirror#getAnnotationType() annotation type} has the same canonical name
@@ -203,5 +202,14 @@ public boolean apply(Element element) {
             });
   }
 
+  /** A function that returns the simple name of an element. */
+  static final Function<Element, String> ELEMENT_SIMPLE_NAME =
+      new Function<Element, String>() {
+        @Override
+        public String apply(Element element) {
+          return element.getSimpleName().toString();
+        }
+      };
+
   private Util() {}
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index 9dfe0a6c6..23dc40ff6 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -2054,6 +2054,7 @@ public void subcomponentOmitsInheritedBindings() {
         .withErrorContaining(
             "test.B<? extends test.A> cannot be provided without an @Provides-annotated method");
   }
+
   @Test
   public void componentImplicitlyDependsOnGeneratedType() {
     JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
@@ -2090,6 +2091,7 @@ public void componentImplicitlyDependsOnGeneratedType() {
         .and()
         .generatesFileNamed(SOURCE_OUTPUT, "test", "DaggerSimpleComponent.java");
   }
+
   @Test
   public void componentSupertypeDependsOnGeneratedType() {
     JavaFileObject componentFile =
diff --git a/compiler/src/test/java/dagger/internal/codegen/DependencyRequestMapperTest.java b/compiler/src/test/java/dagger/internal/codegen/DependencyRequestMapperTest.java
index 2bc5fc017..0bd1ec551 100644
--- a/compiler/src/test/java/dagger/internal/codegen/DependencyRequestMapperTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/DependencyRequestMapperTest.java
@@ -56,7 +56,7 @@
   @Before public void setUp() {
     this.types = compilationRule.getTypes();
     this.elements = compilationRule.getElements();
-    this.keyFactory = new Key.Factory(types, elements);
+    this.keyFactory = new Key.Factory(types, elements, new MethodSignatureFormatter(types));
     this.dependencyRequestFactory = new DependencyRequest.Factory(elements, keyFactory);
   }
 
diff --git a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
index ae7bb4b89..b5acc44fd 100644
--- a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
@@ -588,6 +588,56 @@ public void falsePositiveCyclicDependencyIndirectionDetected() {
         .withErrorContaining(expectedError).in(component).onLine(24);
   }
   
+  @Test
+  public void duplicateExplicitBindings_ProvidesVsBinds() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.Outer",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import javax.inject.Inject;",
+            "",
+            "final class Outer {",
+            "  interface A {}",
+            "",
+            "  static final class B implements A {",
+            "    @Inject B() {}",
+            "  }",
+            "",
+            "  @Module",
+            "  static class Module1 {",
+            "    @Provides A provideA1() { return new A() {}; }",
+            "  }",
+            "",
+            "  @Module",
+            "  static abstract class Module2 {",
+            "    @Binds abstract A bindA2(B b);",
+            "  }",
+            "",
+            "  @Component(modules = { Module1.class, Module2.class})",
+            "  interface TestComponent {",
+            "    A getA();",
+            "  }",
+            "}");
+
+    assertAbout(javaSource())
+        .that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            Joiner.on("\n      ")
+                .join(
+                    "test.Outer.A is bound multiple times:",
+                    "@Provides test.Outer.A test.Outer.Module1.provideA1()",
+                    "@Binds test.Outer.A test.Outer.Module2.bindA2(test.Outer.B)"))
+        .in(component)
+        .onLine(28);
+  }
+  
   @Test public void duplicateExplicitBindings_MultipleProvisionTypes() {
     JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
         "package test;",
diff --git a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
index 3592fbb17..865097ba7 100644
--- a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
@@ -23,7 +23,7 @@
 import com.google.testing.compile.CompilationRule;
 import dagger.Module;
 import dagger.Provides;
-import dagger.internal.codegen.Key.BindingMethodIdentifier;
+import dagger.internal.codegen.Key.BindingIdentifier;
 import dagger.multibindings.ElementsIntoSet;
 import dagger.multibindings.IntoSet;
 import dagger.producers.ProducerModule;
@@ -56,12 +56,14 @@
 
   private Elements elements;
   private Types types;
+  private MethodSignatureFormatter methodSignatureFormatter;
   private Key.Factory keyFactory;
 
   @Before public void setUp() {
     this.types = compilationRule.getTypes();
     this.elements = compilationRule.getElements();
-    this.keyFactory = new Key.Factory(types, elements);
+    this.methodSignatureFormatter = new MethodSignatureFormatter(types);
+    this.keyFactory = new Key.Factory(types, elements, methodSignatureFormatter);
   }
 
   @Test public void forInjectConstructorWithResolvedType() {
@@ -76,7 +78,7 @@
             new AutoValue_Key(
                 Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
                 MoreTypes.equivalence().wrap(typeElement.asType()),
-                Optional.<BindingMethodIdentifier>absent()));
+                Optional.<BindingIdentifier>absent()));
   }
 
   static final class InjectedClass {
@@ -95,7 +97,7 @@
             new AutoValue_Key(
                 Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
                 MoreTypes.equivalence().wrap(stringType),
-                Optional.<BindingMethodIdentifier>absent()));
+                Optional.<BindingIdentifier>absent()));
   }
 
   @Module
@@ -170,7 +172,11 @@ String provideQualifiedString() {
               new AutoValue_Key(
                   Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
                   MoreTypes.equivalence().wrap(setOfStringsType),
-                  Optional.of(BindingMethodIdentifier.create(providesMethod, moduleElement))));
+                  Optional.of(
+                      BindingIdentifier.create(
+                          methodSignatureFormatter.format(
+                              providesMethod,
+                              Optional.of(MoreTypes.asDeclared(moduleElement.asType())))))));
     }
   }
 
@@ -230,7 +236,7 @@ String provideQualifiedString() {
               new AutoValue_Key(
                   Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
                   MoreTypes.equivalence().wrap(stringType),
-                  Optional.<BindingMethodIdentifier>absent()));
+                  Optional.<BindingIdentifier>absent()));
     }
   }
 
@@ -258,7 +264,11 @@ String provideQualifiedString() {
               new AutoValue_Key(
                   Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
                   MoreTypes.equivalence().wrap(setOfStringsType),
-                  Optional.of(BindingMethodIdentifier.create(producesMethod, moduleElement))));
+                  Optional.of(
+                      BindingIdentifier.create(
+                          methodSignatureFormatter.format(
+                              producesMethod,
+                              Optional.of(MoreTypes.asDeclared(moduleElement.asType())))))));
     }
   }
 
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java
index 0206ec7fd..8317ad07a 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java
@@ -148,29 +148,31 @@
   }
 
   @Test public void provisionEntryPointDependsOnProduction() {
-    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestClass",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "import dagger.producers.ProductionComponent;",
-        "",
-        "final class TestClass {",
-        "  interface A {}",
-        "",
-        "  @ProducerModule",
-        "  final class AModule {",
-        "    @Produces ListenableFuture<A> a() {",
-        "      return null;",
-        "    }",
-        "  }",
-        "",
-        "  @ProductionComponent(modules = {ExecutorModule.class, AModule.class})",
-        "  interface AComponent {",
-        "    A getA();",
-        "  }",
-        "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestClass",
+            "package test;",
+            "",
+            "import com.google.common.util.concurrent.ListenableFuture;",
+            "import dagger.producers.ProducerModule;",
+            "import dagger.producers.Produces;",
+            "import dagger.producers.ProductionComponent;",
+            "",
+            "final class TestClass {",
+            "  interface A {}",
+            "",
+            "  @ProducerModule",
+            "  static final class AModule {",
+            "    @Produces ListenableFuture<A> a() {",
+            "      return null;",
+            "    }",
+            "  }",
+            "",
+            "  @ProductionComponent(modules = {ExecutorModule.class, AModule.class})",
+            "  interface AComponent {",
+            "    A getA();",
+            "  }",
+            "}");
     String expectedError =
         "test.TestClass.A is a provision entry-point, which cannot depend on a production.";
     assertAbout(javaSources()).that(ImmutableList.of(EXECUTOR_MODULE, component))
@@ -179,6 +181,65 @@
         .withErrorContaining(expectedError).in(component).onLine(20);
   }
 
+  @Test
+  public void providingMultibindingWithProductions() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestClass",
+            "package test;",
+            "",
+            "import com.google.common.util.concurrent.ListenableFuture;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.StringKey;",
+            "import dagger.producers.ProducerModule;",
+            "import dagger.producers.Produces;",
+            "import dagger.producers.ProductionComponent;",
+            "import java.util.Map;",
+            "import javax.inject.Provider;",
+            "",
+            "final class TestClass {",
+            "  interface A {}",
+            "  interface B {}",
+            "",
+            "  @Module",
+            "  static final class AModule {",
+            "    @Provides static A a(Map<String, Provider<Object>> map) {",
+            "      return null;",
+            "    }",
+            "",
+            "    @Provides @IntoMap @StringKey(\"a\") static Object aEntry() {",
+            "      return \"a\";",
+            "    }",
+            "  }",
+            "",
+            "  @ProducerModule",
+            "  static final class BModule {",
+            "    @Produces static B b(A a) {",
+            "      return null;",
+            "    }",
+            "",
+            "    @Produces @IntoMap @StringKey(\"b\") static Object bEntry() {",
+            "      return \"b\";",
+            "    }",
+            "  }",
+            "",
+            "  @ProductionComponent(",
+            "      modules = {ExecutorModule.class, AModule.class, BModule.class})",
+            "  interface AComponent {",
+            "    ListenableFuture<B> b();",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(EXECUTOR_MODULE, component))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("test.TestClass.A is a provision, which cannot depend on a production")
+        .in(component)
+        .onLine(43);
+  }
+
   @Test
   public void monitoringDependsOnUnboundType() {
     JavaFileObject component =
diff --git a/core/src/main/java/dagger/internal/GwtIncompatible.java b/core/src/main/java/dagger/internal/GwtIncompatible.java
new file mode 100644
index 000000000..8d60e3325
--- /dev/null
+++ b/core/src/main/java/dagger/internal/GwtIncompatible.java
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+/** Marks an element incompatible with GWT. */
+public @interface GwtIncompatible {}
diff --git a/core/src/main/java/dagger/releaseablereferences/package-info.java b/core/src/main/java/dagger/releaseablereferences/package-info.java
new file mode 100644
index 000000000..d53cccb88
--- /dev/null
+++ b/core/src/main/java/dagger/releaseablereferences/package-info.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * This package contains the API by which Dagger allows you
+ * <a href="http://google.github.io/dagger/users-guide.html#releasable-references">release
+ * references</a> held within some scopes.
+ * 
+ * <p><b>Note:</b>Releasable references uses Java's {@link java.lang.ref.WeakReference}, and so is
+ * not compatible with <a href="http://www.gwtproject.org/">GWT</a>.
+ *
+ * @since 2.NEXT
+ */
+package dagger.releaseablereferences;
diff --git a/examples/simple/src/main/java/coffee/PumpModule.java b/examples/simple/src/main/java/coffee/PumpModule.java
index 338ad33c2..df00b8624 100644
--- a/examples/simple/src/main/java/coffee/PumpModule.java
+++ b/examples/simple/src/main/java/coffee/PumpModule.java
@@ -1,11 +1,10 @@
 package coffee;
 
+import dagger.Binds;
 import dagger.Module;
-import dagger.Provides;
 
 @Module
-class PumpModule {
-  @Provides Pump providePump(Thermosiphon pump) {
-    return pump;
-  }
+abstract class PumpModule {
+  @Binds
+  abstract Pump providePump(Thermosiphon pump);
 }
diff --git a/pom.xml b/pom.xml
index b81f8c8b6..118533d96 100644
--- a/pom.xml
+++ b/pom.xml
@@ -50,7 +50,7 @@
     <auto.common.version>0.6</auto.common.version>
     <auto.factory.version>1.0-beta3</auto.factory.version>
     <auto.service.version>1.0-rc2</auto.service.version>
-    <auto.value.version>1.2</auto.value.version>
+    <auto.value.version>1.3-rc2</auto.value.version>
     <errorprone.version>2.0.8</errorprone.version>
     <guava.version>19.0</guava.version>
     <google.java.format.version>1.0</google.java.format.version>
@@ -205,6 +205,7 @@
         <configuration>
           <windowtitle>Dagger Dependency Injection ${project.version} API</windowtitle>
           <doctitle>Dagger Dependency Injection ${project.version} API</doctitle>
+          <docfilessubdirs>true</docfilessubdirs>
         </configuration>
       </plugin>
 
