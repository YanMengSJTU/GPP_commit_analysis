diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index e0425c925..ce0c3c909 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -19,7 +19,6 @@
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
-import com.google.common.base.Predicates;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
@@ -88,6 +87,7 @@
 import static com.google.common.base.CaseFormat.LOWER_CAMEL;
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
 import static com.google.common.base.Preconditions.checkState;
+import static com.google.common.collect.Iterables.any;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.DELEGATED;
 import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.INITIALIZED;
@@ -95,20 +95,21 @@
 import static dagger.internal.codegen.Binding.bindingPackageFor;
 import static dagger.internal.codegen.ComponentGenerator.MemberSelect.staticMethodInvocationWithCast;
 import static dagger.internal.codegen.ComponentGenerator.MemberSelect.staticSelect;
+import static dagger.internal.codegen.ContributionBinding.contributionTypeFor;
+import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.ENUM_INSTANCE;
+import static dagger.internal.codegen.ContributionBinding.Kind.PROVISION;
 import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD;
 import static dagger.internal.codegen.MapKeys.getMapKeySnippet;
 import static dagger.internal.codegen.MembersInjectionBinding.Strategy.NO_OP;
-import static dagger.internal.codegen.ProvisionBinding.FactoryCreationStrategy.ENUM_INSTANCE;
-import static dagger.internal.codegen.ProvisionBinding.Kind.PROVISION;
-import static dagger.internal.codegen.SourceFiles.factoryNameForProductionBinding;
-import static dagger.internal.codegen.SourceFiles.factoryNameForProvisionBinding;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
+import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
 import static dagger.internal.codegen.SourceFiles.indexDependenciesByUnresolvedKey;
 import static dagger.internal.codegen.SourceFiles.membersInjectorNameForType;
 import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
 import static dagger.internal.codegen.Util.getKeyTypeOfMap;
 import static dagger.internal.codegen.Util.getProvidedValueTypeOfMap;
 import static dagger.internal.codegen.Util.isMapWithNonProvidedValues;
+import static dagger.internal.codegen.writer.Snippet.makeParametersSnippet;
 import static dagger.internal.codegen.writer.Snippet.memberSelectSnippet;
 import static dagger.internal.codegen.writer.Snippet.nullCheck;
 import static javax.lang.model.element.Modifier.ABSTRACT;
@@ -526,7 +527,7 @@ private void addField(
     if (bindingKey.kind().equals(BindingKey.Kind.CONTRIBUTION)) {
       ImmutableSet<? extends ContributionBinding> contributionBindings =
           resolvedBindings.contributionBindings();
-      if (ContributionBinding.bindingTypeFor(contributionBindings).isMultibinding()) {
+      if (ContributionBinding.contributionTypeFor(contributionBindings).isMultibinding()) {
         // note that here we rely on the order of the resolved bindings being from parent to child
         // otherwise, the numbering wouldn't work
         int contributionNumber = 0;
@@ -585,16 +586,15 @@ private void addField(
       case CONTRIBUTION:
         ContributionBinding contributionBinding =
             getOnlyElement(resolvedBindings.contributionBindings());
-        if (contributionBinding.bindingType().isMultibinding()
-            || !(contributionBinding instanceof ProvisionBinding)) {
+        if (contributionBinding.contributionType().isMultibinding()
+            || !(contributionBinding.bindingType().equals(Binding.Type.PROVISION))) {
           return Optional.absent();
         }
-        ProvisionBinding provisionBinding = (ProvisionBinding) contributionBinding;
-        if (provisionBinding.factoryCreationStrategy().equals(ENUM_INSTANCE)
-            && !provisionBinding.scope().isPresent()) {
+        if (contributionBinding.factoryCreationStrategy().equals(ENUM_INSTANCE)
+            && !contributionBinding.scope().isPresent()) {
           return Optional.of(
               staticSelect(
-                  factoryNameForProvisionBinding(provisionBinding), Snippet.format("create()")));
+                  generatedClassNameForBinding(contributionBinding), Snippet.format("create()")));
         }
         break;
 
@@ -730,99 +730,25 @@ private void initializeFrameworkTypes() {
         ResolvedBindings resolvedBindings = graph.resolvedBindings().get(bindingKey);
         switch (bindingKey.kind()) {
           case CONTRIBUTION:
-            ImmutableSet<? extends ContributionBinding> bindings =
-                resolvedBindings.contributionBindings();
-
-            switch (ContributionBinding.bindingTypeFor(bindings)) {
+            switch (contributionTypeFor(resolvedBindings.contributionBindings())) {
               case SET:
-                boolean hasOnlyProvisions =
-                    Iterables.all(bindings, Predicates.instanceOf(ProvisionBinding.class));
-                ImmutableList.Builder<Snippet> parameterSnippets = ImmutableList.builder();
-                for (ContributionBinding binding : bindings) {
-                  Optional<MemberSelect> multibindingContributionSnippet =
-                      getMultibindingContributionSnippet(binding);
-                  checkState(
-                      multibindingContributionSnippet.isPresent(), "%s was not found", binding);
-                  Snippet snippet = multibindingContributionSnippet.get().getSnippetFor(name);
-                  if (multibindingContributionSnippet.get().owningClass().equals(name)) {
-                    Snippet initializeSnippet = initializeFactoryForContributionBinding(binding);
-                    initializeMethod.body().addSnippet("this.%s = %s;", snippet, initializeSnippet);
-                  }
-                  parameterSnippets.add(snippet);
-                }
-                Snippet initializeSetSnippet =
-                    Snippet.format(
-                        "%s.create(%s)",
-                        hasOnlyProvisions
-                            ? ClassName.fromClass(SetFactory.class)
-                            : ClassName.fromClass(SetProducer.class),
-                        Snippet.makeParametersSnippet(parameterSnippets.build()));
-                initializeMember(initializeMethod, bindingKey, initializeSetSnippet);
+                initializeSetMultibindings(initializeMethod, resolvedBindings);
                 break;
               case MAP:
-                if (Sets.filter(bindings, Predicates.instanceOf(ProductionBinding.class))
-                    .isEmpty()) {
-                  @SuppressWarnings("unchecked") // checked by the instanceof filter above
-                  ImmutableSet<ProvisionBinding> provisionBindings =
-                      (ImmutableSet<ProvisionBinding>) bindings;
-                  for (ProvisionBinding provisionBinding : provisionBindings) {
-                    Optional<MemberSelect> multibindingContributionSnippet =
-                        getMultibindingContributionSnippet(provisionBinding);
-                    if (!isMapWithNonProvidedValues(provisionBinding.key().type())
-                        && multibindingContributionSnippet.isPresent()
-                        && multibindingContributionSnippet.get().owningClass().equals(name)) {
-                      initializeMethod
-                          .body()
-                          .addSnippet(
-                              "this.%s = %s;",
-                              multibindingContributionSnippet.get().getSnippetFor(name),
-                              initializeFactoryForProvisionBinding(provisionBinding));
-                    }
-                  }
-                  initializeMember(
-                      initializeMethod, bindingKey, initializeMapBinding(provisionBindings));
-                } else {
-                  // TODO(beder): Implement producer map bindings.
-                  throw new IllegalStateException("producer map bindings not implemented yet");
-                }
+                initializeMapMultibindings(initializeMethod, resolvedBindings);
                 break;
               case UNIQUE:
-                if (!resolvedBindings.ownedContributionBindings().isEmpty()) {
-                  ContributionBinding binding = Iterables.getOnlyElement(bindings);
-                  if (binding instanceof ProvisionBinding) {
-                    ProvisionBinding provisionBinding = (ProvisionBinding) binding;
-                    if (!provisionBinding.factoryCreationStrategy().equals(ENUM_INSTANCE)
-                        || provisionBinding.scope().isPresent()) {
-                      initializeDelegateFactories(binding, initializeMethod);
-                      initializeMember(
-                          initializeMethod,
-                          bindingKey,
-                          initializeFactoryForProvisionBinding(provisionBinding));
-                    }
-                  } else if (binding instanceof ProductionBinding) {
-                    ProductionBinding productionBinding = (ProductionBinding) binding;
-                    initializeMember(
-                        initializeMethod,
-                        bindingKey,
-                        initializeFactoryForProductionBinding(productionBinding));
-                  } else {
-                    throw new AssertionError();
-                  }
-                }
+                initializeUniqueContributionBinding(initializeMethod, resolvedBindings);
                 break;
               default:
-                throw new IllegalStateException();
+                throw new AssertionError();
             }
             break;
+
           case MEMBERS_INJECTION:
-            MembersInjectionBinding binding =
-                Iterables.getOnlyElement(resolvedBindings.membersInjectionBindings());
-            if (!binding.injectionStrategy().equals(MembersInjectionBinding.Strategy.NO_OP)) {
-              initializeDelegateFactories(binding, initializeMethod);
-              initializeMember(
-                  initializeMethod, bindingKey, initializeMembersInjectorForBinding(binding));
-            }
+            initializeMembersInjectionBinding(initializeMethod, resolvedBindings);
             break;
+
           default:
             throw new AssertionError();
         }
@@ -830,6 +756,82 @@ private void initializeFrameworkTypes() {
     }
   }
 
+  private void initializeSetMultibindings(
+      MethodWriter initializeMethod, ResolvedBindings resolvedBindings) {
+    ImmutableList.Builder<Snippet> parameterSnippets = ImmutableList.builder();
+    for (ContributionBinding binding : resolvedBindings.contributionBindings()) {
+      Optional<MemberSelect> multibindingContributionSnippet =
+          getMultibindingContributionSnippet(binding);
+      checkState(multibindingContributionSnippet.isPresent(), "%s was not found", binding);
+      Snippet snippet = multibindingContributionSnippet.get().getSnippetFor(name);
+      if (multibindingContributionSnippet.get().owningClass().equals(name)) {
+        Snippet initializeSnippet = initializeFactoryForContributionBinding(binding);
+        initializeMethod.body().addSnippet("this.%s = %s;", snippet, initializeSnippet);
+      }
+      parameterSnippets.add(snippet);
+    }
+    Snippet initializeSetSnippet =
+        Snippet.format(
+            "%s.create(%s)",
+            Iterables.all(resolvedBindings.contributionBindings(), Binding.Type.PROVISION)
+                ? ClassName.fromClass(SetFactory.class)
+                : ClassName.fromClass(SetProducer.class),
+            makeParametersSnippet(parameterSnippets.build()));
+    initializeMember(initializeMethod, resolvedBindings.bindingKey(), initializeSetSnippet);
+  }
+
+  private void initializeMapMultibindings(
+      MethodWriter initializeMethod, ResolvedBindings resolvedBindings) {
+    if (any(resolvedBindings.contributionBindings(), Binding.Type.PRODUCTION)) {
+      // TODO(beder): Implement producer map bindings.
+      throw new IllegalStateException("producer map bindings not implemented yet");
+    }
+    for (ContributionBinding binding : resolvedBindings.contributionBindings()) {
+      Optional<MemberSelect> multibindingContributionSnippet =
+          getMultibindingContributionSnippet(binding);
+      if (!isMapWithNonProvidedValues(binding.key().type())
+          && multibindingContributionSnippet.isPresent()
+          && multibindingContributionSnippet.get().owningClass().equals(name)) {
+        initializeMethod
+            .body()
+            .addSnippet(
+                "this.%s = %s;",
+                multibindingContributionSnippet.get().getSnippetFor(name),
+                initializeFactoryForContributionBinding(binding));
+      }
+    }
+    initializeMember(
+        initializeMethod,
+        resolvedBindings.bindingKey(),
+        initializeMapBinding(resolvedBindings.contributionBindings()));
+  }
+
+  private void initializeUniqueContributionBinding(
+      MethodWriter initializeMethod, ResolvedBindings resolvedBindings) {
+    if (!resolvedBindings.ownedContributionBindings().isEmpty()) {
+      ContributionBinding binding = getOnlyElement(resolvedBindings.ownedContributionBindings());
+      if (!binding.factoryCreationStrategy().equals(ENUM_INSTANCE) || binding.scope().isPresent()) {
+        initializeDelegateFactories(binding, initializeMethod);
+        initializeMember(
+            initializeMethod,
+            resolvedBindings.bindingKey(),
+            initializeFactoryForContributionBinding(binding));
+      }
+    }
+  }
+
+  private void initializeMembersInjectionBinding(
+      MethodWriter initializeMethod, ResolvedBindings resolvedBindings) {
+    MembersInjectionBinding binding = getOnlyElement(resolvedBindings.membersInjectionBindings());
+    if (!binding.injectionStrategy().equals(MembersInjectionBinding.Strategy.NO_OP)) {
+      initializeDelegateFactories(binding, initializeMethod);
+      initializeMember(
+          initializeMethod,
+          resolvedBindings.bindingKey(),
+          initializeMembersInjectorForBinding(binding));
+    }
+  }
+
   private void initializeDelegateFactories(Binding binding, MethodWriter initializeMethod) {
     for (Collection<DependencyRequest> requestsForKey :
         indexDependenciesByUnresolvedKey(types, binding.dependencies()).asMap().values()) {
@@ -878,16 +880,6 @@ private Snippet delegateFactoryVariableSnippet(BindingKey key) {
   }
 
   private Snippet initializeFactoryForContributionBinding(ContributionBinding binding) {
-    if (binding instanceof ProvisionBinding) {
-      return initializeFactoryForProvisionBinding((ProvisionBinding) binding);
-    } else if (binding instanceof ProductionBinding) {
-      return initializeFactoryForProductionBinding((ProductionBinding) binding);
-    } else {
-      throw new AssertionError();
-    }
-  }
-
-  private Snippet initializeFactoryForProvisionBinding(ProvisionBinding binding) {
     TypeName bindingKeyTypeName = TypeNames.forTypeMirror(binding.key().type());
     switch (binding.bindingKind()) {
       case COMPONENT:
@@ -898,32 +890,17 @@ private Snippet initializeFactoryForProvisionBinding(ProvisionBinding binding) {
             bindingKeyTypeName.equals(componentDefinitionTypeName())
                 ? "this"
                 : getComponentContributionSnippet(MoreTypes.asTypeElement(binding.key().type())));
+
       case COMPONENT_PROVISION:
-        TypeElement bindingTypeElement =
-            graph.componentDescriptor().dependencyMethodIndex().get(binding.bindingElement());
-        if (binding.nullableType().isPresent()
-            || nullableValidationType.equals(Diagnostic.Kind.WARNING)) {
-          Snippet nullableSnippet =
-              binding.nullableType().isPresent()
-                  ? Snippet.format("@%s ", TypeNames.forTypeMirror(binding.nullableType().get()))
-                  : Snippet.format("");
-          return Snippet.format(
-              Joiner.on('\n')
-                  .join(
-                      "new %1$s<%2$s>() {",
-                      "  private final %6$s %7$s = %3$s;",
-                      "  %5$s@Override public %2$s get() {",
-                      "    return %7$s.%4$s();",
-                      "  }",
-                      "}"),
-              /* 1 */ ClassName.fromClass(Factory.class),
-              /* 2 */ bindingKeyTypeName,
-              /* 3 */ getComponentContributionSnippet(bindingTypeElement),
-              /* 4 */ binding.bindingElement().getSimpleName().toString(),
-              /* 5 */ nullableSnippet,
-              /* 6 */ TypeNames.forTypeMirror(bindingTypeElement.asType()),
-              /* 7 */ simpleVariableName(bindingTypeElement));
-        } else {
+        {
+          TypeElement bindingTypeElement =
+              graph.componentDescriptor().dependencyMethodIndex().get(binding.bindingElement());
+          String localFactoryVariable = simpleVariableName(bindingTypeElement);
+          Snippet callFactoryMethodSnippet =
+              Snippet.format(
+                  "%s.%s()",
+                  localFactoryVariable,
+                  binding.bindingElement().getSimpleName().toString());
           // TODO(sameb): This throws a very vague NPE right now.  The stack trace doesn't
           // help to figure out what the method or return type is.  If we include a string
           // of the return type or method name in the error message, that can defeat obfuscation.
@@ -932,95 +909,115 @@ private Snippet initializeFactoryForProvisionBinding(ProvisionBinding binding) {
           // What should we do?
           StringLiteral failMsg =
               StringLiteral.forValue(CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD);
+          Snippet getMethodBody =
+              binding.nullableType().isPresent()
+                      || nullableValidationType.equals(Diagnostic.Kind.WARNING)
+                  ? Snippet.format("return %s;", callFactoryMethodSnippet)
+                  : Snippet.format(
+                      Joiner.on('\n')
+                          .join(
+                              "%s provided = %s;",
+                              "if (provided == null) {",
+                              "  throw new NullPointerException(%s);",
+                              "}",
+                              "return provided;"),
+                      bindingKeyTypeName,
+                      callFactoryMethodSnippet,
+                      failMsg);
           return Snippet.format(
               Joiner.on('\n')
                   .join(
                       "new %1$s<%2$s>() {",
-                      "  private final %6$s %7$s = %3$s;",
-                      "  @Override public %2$s get() {",
-                      "    %2$s provided = %7$s.%4$s();",
-                      "    if (provided == null) {",
-                      "      throw new NullPointerException(%5$s);",
-                      "    }",
-                      "    return provided;",
+                      "  private final %5$s %6$s = %3$s;",
+                      "  %4$s@Override public %2$s get() {",
+                      "    %7$s",
                       "  }",
                       "}"),
               /* 1 */ ClassName.fromClass(Factory.class),
               /* 2 */ bindingKeyTypeName,
               /* 3 */ getComponentContributionSnippet(bindingTypeElement),
-              /* 4 */ binding.bindingElement().getSimpleName().toString(),
-              /* 5 */ failMsg,
-              /* 6 */ TypeNames.forTypeMirror(bindingTypeElement.asType()),
-              /* 7 */ simpleVariableName(bindingTypeElement));
+              /* 4 */ nullableSnippet(binding.nullableType()),
+              /* 5 */ TypeNames.forTypeMirror(bindingTypeElement.asType()),
+              /* 6 */ localFactoryVariable,
+              /* 7 */ getMethodBody);
         }
+
       case INJECTION:
       case PROVISION:
-        List<Snippet> parameters =
-            Lists.newArrayListWithCapacity(binding.dependencies().size() + 1);
-        if (binding.bindingKind().equals(PROVISION)
-            && !binding.bindingElement().getModifiers().contains(STATIC)) {
-          parameters.add(getComponentContributionSnippet(binding.contributedBy().get()));
+        {
+          List<Snippet> parameters =
+              Lists.newArrayListWithCapacity(binding.dependencies().size() + 1);
+          if (binding.bindingKind().equals(PROVISION)
+              && !binding.bindingElement().getModifiers().contains(STATIC)) {
+            parameters.add(getComponentContributionSnippet(binding.contributedBy().get()));
+          }
+          parameters.addAll(getDependencyParameters(binding));
+
+          Snippet factorySnippet =
+              Snippet.format(
+                  "%s.create(%s)",
+                  generatedClassNameForBinding(binding),
+                  Snippet.makeParametersSnippet(parameters));
+          return binding.scope().isPresent()
+              ? Snippet.format(
+                  "%s.create(%s)", ClassName.fromClass(ScopedProvider.class), factorySnippet)
+              : factorySnippet;
         }
-        parameters.addAll(getDependencyParameters(binding));
 
-        Snippet factorySnippet =
-            Snippet.format(
-                "%s.create(%s)",
-                factoryNameForProvisionBinding(binding),
-                Snippet.makeParametersSnippet(parameters));
-        return binding.scope().isPresent()
-            ? Snippet.format(
-                "%s.create(%s)", ClassName.fromClass(ScopedProvider.class), factorySnippet)
-            : factorySnippet;
-      default:
-        throw new AssertionError();
-    }
-  }
-
-  private Snippet initializeFactoryForProductionBinding(ProductionBinding binding) {
-    switch (binding.bindingKind()) {
       case COMPONENT_PRODUCTION:
-        TypeElement bindingTypeElement =
-            graph.componentDescriptor().dependencyMethodIndex().get(binding.bindingElement());
-        return Snippet.format(
-            Joiner.on('\n')
-                .join(
-                    "new %1$s<%2$s>() {",
-                    "  private final %6$s %7$s = %4$s;",
-                    "  @Override public %3$s<%2$s> get() {",
-                    "    return %7$s.%5$s();",
-                    "  }",
-                    "}"),
-            /* 1 */ ClassName.fromClass(Producer.class),
-            /* 2 */ TypeNames.forTypeMirror(binding.key().type()),
-            /* 3 */ ClassName.fromClass(ListenableFuture.class),
-            /* 4 */ getComponentContributionSnippet(bindingTypeElement),
-            /* 5 */ binding.bindingElement().getSimpleName().toString(),
-            /* 6 */ TypeNames.forTypeMirror(bindingTypeElement.asType()),
-            /* 7 */ simpleVariableName(bindingTypeElement));
+        {
+          TypeElement bindingTypeElement =
+              graph.componentDescriptor().dependencyMethodIndex().get(binding.bindingElement());
+          return Snippet.format(
+              Joiner.on('\n')
+                  .join(
+                      "new %1$s<%2$s>() {",
+                      "  private final %6$s %7$s = %4$s;",
+                      "  @Override public %3$s<%2$s> get() {",
+                      "    return %7$s.%5$s();",
+                      "  }",
+                      "}"),
+              /* 1 */ ClassName.fromClass(Producer.class),
+              /* 2 */ TypeNames.forTypeMirror(binding.key().type()),
+              /* 3 */ ClassName.fromClass(ListenableFuture.class),
+              /* 4 */ getComponentContributionSnippet(bindingTypeElement),
+              /* 5 */ binding.bindingElement().getSimpleName().toString(),
+              /* 6 */ TypeNames.forTypeMirror(bindingTypeElement.asType()),
+              /* 7 */ simpleVariableName(bindingTypeElement));
+        }
+
       case IMMEDIATE:
       case FUTURE_PRODUCTION:
-        List<Snippet> parameters =
-            Lists.newArrayListWithCapacity(binding.dependencies().size() + 3);
-        // TODO(beder): Pass the actual ProductionComponentMonitor.
-        parameters.add(Snippet.format("null"));
-        if (!binding.bindingElement().getModifiers().contains(STATIC)) {
-          parameters.add(getComponentContributionSnippet(binding.bindingTypeElement()));
+        {
+          List<Snippet> parameters =
+              Lists.newArrayListWithCapacity(binding.dependencies().size() + 3);
+          // TODO(beder): Pass the actual ProductionComponentMonitor.
+          parameters.add(Snippet.format("null"));
+          if (!binding.bindingElement().getModifiers().contains(STATIC)) {
+            parameters.add(getComponentContributionSnippet(binding.bindingTypeElement()));
+          }
+          parameters.add(
+              getComponentContributionSnippet(
+                  graph.componentDescriptor().executorDependency().get()));
+          parameters.addAll(getProducerDependencyParameters(binding));
+
+          return Snippet.format(
+              "new %s(%s)",
+              generatedClassNameForBinding(binding),
+              Snippet.makeParametersSnippet(parameters));
         }
-        parameters.add(
-            getComponentContributionSnippet(
-                graph.componentDescriptor().executorDependency().get()));
-        parameters.addAll(getProducerDependencyParameters(binding));
 
-        return Snippet.format(
-            "new %s(%s)",
-            factoryNameForProductionBinding(binding),
-            Snippet.makeParametersSnippet(parameters));
       default:
         throw new AssertionError();
     }
   }
 
+  private Snippet nullableSnippet(Optional<DeclaredType> nullableType) {
+    return nullableType.isPresent()
+        ? Snippet.format("@%s ", TypeNames.forTypeMirror(nullableType.get()))
+        : Snippet.format("");
+  }
+
   private Snippet initializeMembersInjectorForBinding(MembersInjectionBinding binding) {
     switch (binding.injectionStrategy()) {
       case NO_OP:
@@ -1097,9 +1094,9 @@ private TypeMirror typeMirrorAsMemberOf(TypeElement bindingTypeElement, Element
     return parameters.build();
   }
 
-  private Snippet initializeMapBinding(Set<ProvisionBinding> bindings) {
+  private Snippet initializeMapBinding(Set<? extends ContributionBinding> bindings) {
     // Get type information from the first binding.
-    ProvisionBinding firstBinding = bindings.iterator().next();
+    ContributionBinding firstBinding = bindings.iterator().next();
     DeclaredType mapType = asDeclared(firstBinding.key().type());
 
     if (isMapWithNonProvidedValues(mapType)) {
@@ -1117,7 +1114,7 @@ private Snippet initializeMapBinding(Set<ProvisionBinding> bindings) {
         TypeNames.forTypeMirror(getProvidedValueTypeOfMap(mapType)), // V of Map<K, Provider<V>>
         bindings.size()));
 
-    for (ProvisionBinding binding : bindings) {
+    for (ContributionBinding binding : bindings) {
       snippets.add(
           Snippet.format(
               "    .put(%s, %s)",
diff --git a/compiler/src/main/java/dagger/internal/codegen/Binding.java b/compiler/src/main/java/dagger/internal/codegen/Binding.java
index 29f17b3c5..afdfd23d4 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Binding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Binding.java
@@ -17,11 +17,15 @@
 
 import com.google.auto.common.MoreElements;
 import com.google.common.base.Optional;
+import com.google.common.base.Predicate;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Lists;
+import dagger.MembersInjector;
+import dagger.producers.Producer;
 import java.util.List;
 import java.util.Set;
+import javax.inject.Provider;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementVisitor;
 import javax.lang.model.element.Name;
@@ -36,6 +40,7 @@
 import javax.lang.model.util.SimpleTypeVisitor6;
 import javax.lang.model.util.Types;
 
+import static com.google.common.base.Preconditions.checkArgument;
 import static javax.lang.model.element.Modifier.PUBLIC;
 
 /**
@@ -48,6 +53,47 @@
  * @since 2.0
  */
 abstract class Binding {
+  
+  /**
+   * The subtype of this binding.
+   */
+  enum Type implements Predicate<Binding> {
+    /** A binding with this type is a {@link ProvisionBinding}. */
+    PROVISION(Provider.class),
+    /** A binding with this type is a {@link MembersInjectionBinding}. */
+    MEMBERS_INJECTION(MembersInjector.class),
+    /** A binding with this type is a {@link ProductionBinding}. */
+    PRODUCTION(Producer.class),
+    ;
+    
+    private final Class<?> frameworkClass;
+    
+    private Type(Class<?> frameworkClass) {
+      this.frameworkClass = frameworkClass;
+    }
+    
+    /**
+     * Returns the framework class associated with bindings of this type.
+     */
+    Class<?> frameworkClass() {
+      return frameworkClass;
+    }
+    
+    @Override
+    public boolean apply(Binding binding) {
+      return this.equals(binding.bindingType());
+    }
+  }
+
+  abstract Binding.Type bindingType();
+
+  /**
+   * Returns the framework class associated with this binding.
+   */
+  Class<?> frameworkClass() {
+    return bindingType().frameworkClass();
+  }
+
   static Optional<String> bindingPackageFor(Iterable<? extends Binding> bindings) {
     ImmutableSet.Builder<String> bindingPackagesBuilder = ImmutableSet.builder();
     for (Binding binding : bindings) {
@@ -164,6 +210,13 @@ public Void visitWildcard(WildcardType t, ImmutableSet.Builder<String> p) {
    */
   abstract boolean hasNonDefaultTypeParameters();
 
+  /**
+   * The scope of this binding.
+   */
+  Scope scope() {
+    return Scope.unscoped();
+  }
+
   // TODO(sameb): Remove the TypeElement parameter and pull it from the TypeMirror.
   static boolean hasNonDefaultTypeParameters(TypeElement element, TypeMirror type, Types types) {
     // If the element has no type parameters, nothing can be wrong.
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index c0d1d45aa..7084fb924 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -32,6 +32,7 @@
 import com.google.common.collect.TreeTraverser;
 import dagger.Component;
 import dagger.Subcomponent;
+import dagger.internal.codegen.Binding.Type;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.producers.Producer;
 import dagger.producers.ProductionComponent;
@@ -56,6 +57,8 @@
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static com.google.common.base.Predicates.in;
 import static com.google.common.base.Verify.verify;
+import static com.google.common.collect.Iterables.any;
+import static com.google.common.collect.Sets.union;
 import static dagger.internal.codegen.BindingKey.Kind.CONTRIBUTION;
 import static dagger.internal.codegen.ComponentDescriptor.isComponentContributionMethod;
 import static dagger.internal.codegen.ComponentDescriptor.isComponentProductionMethod;
@@ -168,16 +171,11 @@ BindingGraph create(ComponentDescriptor componentDescriptor) {
 
     private BindingGraph create(
         Optional<Resolver> parentResolver, ComponentDescriptor componentDescriptor) {
-      ImmutableSet.Builder<ProvisionBinding> explicitProvisionBindingsBuilder =
-          ImmutableSet.builder();
-      ImmutableSet.Builder<ProductionBinding> explicitProductionBindingsBuilder =
-          ImmutableSet.builder();
+      ImmutableSet.Builder<ContributionBinding> explicitBindingsBuilder = ImmutableSet.builder();
 
       // binding for the component itself
       TypeElement componentDefinitionType = componentDescriptor.componentDefinitionType();
-      ProvisionBinding componentBinding =
-          provisionBindingFactory.forComponent(componentDefinitionType);
-      explicitProvisionBindingsBuilder.add(componentBinding);
+      explicitBindingsBuilder.add(provisionBindingFactory.forComponent(componentDefinitionType));
 
       // Collect Component dependencies.
       Optional<AnnotationMirror> componentMirror =
@@ -187,21 +185,17 @@ private BindingGraph create(
           ? MoreTypes.asTypeElements(getComponentDependencies(componentMirror.get()))
           : ImmutableSet.<TypeElement>of();
       for (TypeElement componentDependency : componentDependencyTypes) {
-        explicitProvisionBindingsBuilder.add(
-            provisionBindingFactory.forComponent(componentDependency));
+        explicitBindingsBuilder.add(provisionBindingFactory.forComponent(componentDependency));
         List<ExecutableElement> dependencyMethods =
             ElementFilter.methodsIn(elements.getAllMembers(componentDependency));
         for (ExecutableElement method : dependencyMethods) {
           // MembersInjection methods aren't "provided" explicitly, so ignore them.
           if (isComponentContributionMethod(elements, method)) {
-            if (componentDescriptor.kind().equals(PRODUCTION_COMPONENT)
-                && isComponentProductionMethod(elements, method)) {
-              explicitProductionBindingsBuilder.add(
-                  productionBindingFactory.forComponentMethod(method));
-            } else {
-              explicitProvisionBindingsBuilder.add(
-                  provisionBindingFactory.forComponentMethod(method));
-            }
+            explicitBindingsBuilder.add(
+                componentDescriptor.kind().equals(PRODUCTION_COMPONENT)
+                        && isComponentProductionMethod(elements, method)
+                    ? productionBindingFactory.forComponentMethod(method)
+                    : provisionBindingFactory.forComponentMethod(method));
           }
         }
       }
@@ -209,12 +203,7 @@ private BindingGraph create(
       // Collect transitive module bindings.
       for (ModuleDescriptor moduleDescriptor : componentDescriptor.transitiveModules()) {
         for (ContributionBinding binding : moduleDescriptor.bindings()) {
-          if (binding instanceof ProvisionBinding) {
-            explicitProvisionBindingsBuilder.add((ProvisionBinding) binding);
-          }
-          if (binding instanceof ProductionBinding) {
-            explicitProductionBindingsBuilder.add((ProductionBinding) binding);
-          }
+          explicitBindingsBuilder.add(binding);
         }
       }
 
@@ -222,8 +211,7 @@ private BindingGraph create(
           new Resolver(
               parentResolver,
               componentDescriptor,
-              explicitBindingsByKey(explicitProvisionBindingsBuilder.build()),
-              explicitBindingsByKey(explicitProductionBindingsBuilder.build()));
+              explicitBindingsByKey(explicitBindingsBuilder.build()));
       for (ComponentMethodDescriptor componentMethod : componentDescriptor.componentMethods()) {
         Optional<DependencyRequest> componentMethodRequest = componentMethod.dependencyRequest();
         if (componentMethodRequest.isPresent()) {
@@ -268,9 +256,8 @@ private BindingGraph create(
     private final class Resolver {
       final Optional<Resolver> parentResolver;
       final ComponentDescriptor componentDescriptor;
-      final ImmutableSetMultimap<Key, ProvisionBinding> explicitProvisionBindings;
-      final ImmutableSet<ProvisionBinding> explicitProvisionBindingsSet;
-      final ImmutableSetMultimap<Key, ProductionBinding> explicitProductionBindings;
+      final ImmutableSetMultimap<Key, ContributionBinding> explicitBindings;
+      final ImmutableSet<ContributionBinding> explicitBindingsSet;
       final Map<BindingKey, ResolvedBindings> resolvedBindings;
       final Deque<BindingKey> cycleStack = new ArrayDeque<>();
       final Cache<BindingKey, Boolean> dependsOnLocalMultibindingsCache =
@@ -279,17 +266,14 @@ private BindingGraph create(
       Resolver(
           Optional<Resolver> parentResolver,
           ComponentDescriptor componentDescriptor,
-          ImmutableSetMultimap<Key, ProvisionBinding> explicitProvisionBindings,
-          ImmutableSetMultimap<Key, ProductionBinding> explicitProductionBindings) {
+          ImmutableSetMultimap<Key, ContributionBinding> explicitBindings) {
         assert parentResolver != null;
         this.parentResolver = parentResolver;
         assert componentDescriptor != null;
         this.componentDescriptor = componentDescriptor;
-        assert explicitProvisionBindings != null;
-        this.explicitProvisionBindings = explicitProvisionBindings;
-        this.explicitProvisionBindingsSet = ImmutableSet.copyOf(explicitProvisionBindings.values());
-        assert explicitProductionBindings != null;
-        this.explicitProductionBindings = explicitProductionBindings;
+        assert explicitBindings != null;
+        this.explicitBindings = explicitBindings;
+        this.explicitBindingsSet = ImmutableSet.copyOf(explicitBindings.values());
         this.resolvedBindings = Maps.newLinkedHashMap();
       }
 
@@ -308,51 +292,47 @@ ResolvedBindings lookUpBindings(DependencyRequest request) {
         switch (bindingKey.kind()) {
           case CONTRIBUTION:
             // First, check for explicit keys (those from modules and components)
-            ImmutableSet<ProvisionBinding> explicitProvisionBindingsForKey =
-                getExplicitProvisionBindings(bindingKey.key());
-            ImmutableSet<ProductionBinding> explicitProductionBindingsForKey =
-                getExplicitProductionBindings(bindingKey.key());
+            ImmutableSet<ContributionBinding> explicitBindingsForKey =
+                getExplicitBindings(bindingKey.key());
 
             // If the key is Map<K, V>, get its implicit binding keys, which are either
             // Map<K, Provider<V>> or Map<K, Producer<V>>, and grab their explicit bindings.
             Optional<Key> mapProviderKey = keyFactory.implicitMapProviderKeyFrom(bindingKey.key());
-            ImmutableSet<ProvisionBinding> explicitMapProvisionBindings = ImmutableSet.of();
+            ImmutableSet.Builder<ContributionBinding> explicitMapBindingsBuilder =
+                ImmutableSet.builder();
             if (mapProviderKey.isPresent()) {
-              explicitMapProvisionBindings = getExplicitProvisionBindings(mapProviderKey.get());
+              explicitMapBindingsBuilder.addAll(getExplicitBindings(mapProviderKey.get()));
             }
 
             Optional<Key> mapProducerKey = keyFactory.implicitMapProducerKeyFrom(bindingKey.key());
-            ImmutableSet<ProductionBinding> explicitMapProductionBindings = ImmutableSet.of();
             if (mapProducerKey.isPresent()) {
-              explicitMapProductionBindings = getExplicitProductionBindings(mapProducerKey.get());
+              explicitMapBindingsBuilder.addAll(getExplicitBindings(mapProducerKey.get()));
             }
+            ImmutableSet<ContributionBinding> explicitMapBindings =
+                explicitMapBindingsBuilder.build();
 
-            if (!explicitProvisionBindingsForKey.isEmpty()
-                || !explicitProductionBindingsForKey.isEmpty()) {
+            if (!explicitBindingsForKey.isEmpty()) {
               /* If there are any explicit bindings for this key, then combine those with any
                * conflicting Map<K, Provider<V>> bindings and let the validator fail. */
               ImmutableSet.Builder<ContributionBinding> ownedBindings = ImmutableSet.builder();
               ImmutableSetMultimap.Builder<ComponentDescriptor, ContributionBinding>
                   inheritedBindings = ImmutableSetMultimap.builder();
-              for (ProvisionBinding provisionBinding :
-                  Sets.union(explicitProvisionBindingsForKey, explicitMapProvisionBindings)) {
-                if (isResolvedInParent(request, provisionBinding)
-                    && !shouldOwnParentBinding(request, provisionBinding)) {
+              for (ContributionBinding binding :
+                  union(explicitBindingsForKey, explicitMapBindings)) {
+                if (isResolvedInParent(request, binding)
+                    && !shouldOwnParentBinding(request, binding)) {
                   inheritedBindings.put(
-                      getOwningResolver(provisionBinding).get().componentDescriptor,
-                      provisionBinding);
+                      getOwningResolver(binding).get().componentDescriptor, binding);
                 } else {
-                  ownedBindings.add(provisionBinding);
+                  ownedBindings.add(binding);
                 }
               }
-              return ResolvedBindings.create(bindingKey,
+              return ResolvedBindings.create(
+                  bindingKey,
                   componentDescriptor,
-                  ownedBindings
-                      .addAll(explicitProductionBindingsForKey)
-                      .addAll(explicitMapProductionBindings)
-                      .build(),
+                  ownedBindings.build(),
                   inheritedBindings.build());
-            } else if (!explicitMapProductionBindings.isEmpty()) {
+            } else if (any(explicitMapBindings, Binding.Type.PRODUCTION)) {
               /* If this binding is for Map<K, V> and there are no explicit Map<K, V> bindings but
                * some explicit Map<K, Producer<V>> bindings, then this binding must have only the
                * implicit dependency on Map<K, Producer<V>>. */
@@ -360,7 +340,7 @@ ResolvedBindings lookUpBindings(DependencyRequest request) {
                   bindingKey,
                   componentDescriptor,
                   productionBindingFactory.implicitMapOfProducerBinding(request));
-            } else if (!explicitMapProvisionBindings.isEmpty()) {
+            } else if (any(explicitMapBindings, Binding.Type.PROVISION)) {
               /* If this binding is for Map<K, V> and there are no explicit Map<K, V> bindings but
                * some explicit Map<K, Provider<V>> bindings, then this binding must have only the
                * implicit dependency on Map<K, Provider<V>>. */
@@ -391,24 +371,22 @@ ResolvedBindings lookUpBindings(DependencyRequest request) {
                     ImmutableSetMultimap.<ComponentDescriptor, Binding>of());
               }
             }
+
           case MEMBERS_INJECTION:
             // no explicit deps for members injection, so just look it up
             return ResolvedBindings.create(
-                bindingKey,
-                componentDescriptor,
-                rollUpMembersInjectionBindings(bindingKey.key()));
+                bindingKey, componentDescriptor, rollUpMembersInjectionBindings(bindingKey.key()));
           default:
             throw new AssertionError();
         }
       }
 
       /**
-       * Returns {@code true} if {@code provisionBinding} is owned by a parent resolver. If so,
-       * calls {@link #resolve(DependencyRequest) resolve(request)} on that resolver.
+       * Returns {@code true} if {@code binding} is owned by a parent resolver. If so, calls
+       * {@link #resolve(DependencyRequest) resolve(request)} on that resolver.
        */
-      private boolean isResolvedInParent(
-          DependencyRequest request, ProvisionBinding provisionBinding) {
-        Optional<Resolver> owningResolver = getOwningResolver(provisionBinding);
+      private boolean isResolvedInParent(DependencyRequest request, ContributionBinding binding) {
+        Optional<Resolver> owningResolver = getOwningResolver(binding);
         if (owningResolver.isPresent() && !owningResolver.get().equals(this)) {
           owningResolver.get().resolve(request);
           return true;
@@ -418,14 +396,14 @@ private boolean isResolvedInParent(
       }
 
       /**
-       * Returns {@code true} if {@code provisionBinding}, which was previously resolved by a parent
+       * Returns {@code true} if {@code binding}, which was previously resolved by a parent
        * resolver, should be moved into this resolver's bindings for {@code request} because it is
        * unscoped and {@linkplain #dependsOnLocalMultibindings(ResolvedBindings) depends on local
        * multibindings}, or {@code false} if it can satisfy {@code request} as an inherited binding.
        */
       private boolean shouldOwnParentBinding(
-          DependencyRequest request, ProvisionBinding provisionBinding) {
-        return !isScoped(provisionBinding)
+          DependencyRequest request, ContributionBinding binding) {
+        return !binding.scope().isPresent()
             && dependsOnLocalMultibindings(
                 getPreviouslyResolvedBindings(request.bindingKey()).get());
       }
@@ -447,9 +425,9 @@ private MembersInjectionBinding rollUpMembersInjectionBindings(Key key) {
         return membersInjectionBinding;
       }
 
-      private Optional<Resolver> getOwningResolver(ProvisionBinding provisionBinding) {
+      private Optional<Resolver> getOwningResolver(ContributionBinding provisionBinding) {
         for (Resolver requestResolver : getResolverLineage().reverse()) {
-          if (requestResolver.explicitProvisionBindingsSet.contains(provisionBinding)) {
+          if (requestResolver.explicitBindingsSet.contains(provisionBinding)) {
             return Optional.of(requestResolver);
           }
         }
@@ -478,18 +456,10 @@ private MembersInjectionBinding rollUpMembersInjectionBindings(Key key) {
         return ImmutableList.copyOf(Lists.reverse(resolverList));
       }
 
-      private ImmutableSet<ProvisionBinding> getExplicitProvisionBindings(Key requestKey) {
-        ImmutableSet.Builder<ProvisionBinding> explicitBindingsForKey = ImmutableSet.builder();
+      private ImmutableSet<ContributionBinding> getExplicitBindings(Key requestKey) {
+        ImmutableSet.Builder<ContributionBinding> explicitBindingsForKey = ImmutableSet.builder();
         for (Resolver resolver : getResolverLineage()) {
-          explicitBindingsForKey.addAll(resolver.explicitProvisionBindings.get(requestKey));
-        }
-        return explicitBindingsForKey.build();
-      }
-
-      private ImmutableSet<ProductionBinding> getExplicitProductionBindings(Key requestKey) {
-        ImmutableSet.Builder<ProductionBinding> explicitBindingsForKey = ImmutableSet.builder();
-        for (Resolver resolver : getResolverLineage()) {
-          explicitBindingsForKey.addAll(resolver.explicitProductionBindings.get(requestKey));
+          explicitBindingsForKey.addAll(resolver.explicitBindings.get(requestKey));
         }
         return explicitBindingsForKey.build();
       }
@@ -576,7 +546,8 @@ public Boolean call() {
                   }
 
                   for (Binding binding : previouslyResolvedBindings.bindings()) {
-                    if (!isScoped(binding) && !(binding instanceof ProductionBinding)) {
+                    if (!binding.scope().isPresent()
+                        && !binding.bindingType().equals(Type.PRODUCTION)) {
                       for (DependencyRequest dependency : binding.implicitDependencies()) {
                         if (dependsOnLocalMultibindings(
                             getPreviouslyResolvedBindings(dependency.bindingKey()).get(),
@@ -595,16 +566,7 @@ public Boolean call() {
       }
 
       private boolean hasLocalContributions(ResolvedBindings resolvedBindings) {
-        return !explicitProvisionBindings.get(resolvedBindings.bindingKey().key()).isEmpty()
-            || !explicitProductionBindings.get(resolvedBindings.bindingKey().key()).isEmpty();
-      }
-
-      private boolean isScoped(Binding binding) {
-        if (binding instanceof ProvisionBinding) {
-          ProvisionBinding provisionBinding = (ProvisionBinding) binding;
-          return provisionBinding.scope().isPresent();
-        }
-        return false;
+        return !explicitBindings.get(resolvedBindings.bindingKey().key()).isEmpty();
       }
 
       ImmutableMap<BindingKey, ResolvedBindings> getResolvedBindings() {
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 3af59d61b..519e1c486 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -40,7 +40,7 @@
 import dagger.MapKey;
 import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
-import dagger.internal.codegen.ContributionBinding.BindingType;
+import dagger.internal.codegen.ContributionBinding.ContributionType;
 import dagger.internal.codegen.writer.TypeNames;
 import java.util.ArrayDeque;
 import java.util.Arrays;
@@ -70,6 +70,8 @@
 import static com.google.common.base.Predicates.equalTo;
 import static com.google.common.base.Predicates.not;
 import static com.google.common.base.Verify.verify;
+import static com.google.common.collect.Iterables.all;
+import static com.google.common.collect.Iterables.any;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static com.google.common.collect.Iterables.indexOf;
 import static com.google.common.collect.Iterables.skip;
@@ -79,13 +81,13 @@
 import static dagger.internal.codegen.ErrorMessages.DUPLICATE_SIZE_LIMIT;
 import static dagger.internal.codegen.ErrorMessages.INDENT;
 import static dagger.internal.codegen.ErrorMessages.MEMBERS_INJECTION_WITH_UNBOUNDED_TYPE;
-import static dagger.internal.codegen.ErrorMessages.NULLABLE_TO_NON_NULLABLE;
 import static dagger.internal.codegen.ErrorMessages.REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_FORMAT;
 import static dagger.internal.codegen.ErrorMessages.REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_OR_PRODUCER_FORMAT;
 import static dagger.internal.codegen.ErrorMessages.REQUIRES_PROVIDER_FORMAT;
 import static dagger.internal.codegen.ErrorMessages.REQUIRES_PROVIDER_OR_PRODUCER_FORMAT;
 import static dagger.internal.codegen.ErrorMessages.duplicateMapKeysError;
 import static dagger.internal.codegen.ErrorMessages.inconsistentMapKeyAnnotationsError;
+import static dagger.internal.codegen.ErrorMessages.nullableToNonNullable;
 import static dagger.internal.codegen.ErrorMessages.stripCommonTypePrefixes;
 import static dagger.internal.codegen.Util.getKeyTypeOfMap;
 import static dagger.internal.codegen.Util.getProvidedValueTypeOfMap;
@@ -101,8 +103,7 @@
   private final InjectBindingRegistry injectBindingRegistry;
   private final ValidationType scopeCycleValidationType;
   private final Diagnostic.Kind nullableValidationType;
-  private final ProvisionBindingFormatter provisionBindingFormatter;
-  private final ProductionBindingFormatter productionBindingFormatter;
+  private final ContributionBindingFormatter contributionBindingFormatter;
   private final MethodSignatureFormatter methodSignatureFormatter;
   private final DependencyRequestFormatter dependencyRequestFormatter;
   private final KeyFormatter keyFormatter;
@@ -112,8 +113,7 @@
       InjectBindingRegistry injectBindingRegistry,
       ValidationType scopeCycleValidationType,
       Diagnostic.Kind nullableValidationType,
-      ProvisionBindingFormatter provisionBindingFormatter,
-      ProductionBindingFormatter productionBindingFormatter,
+      ContributionBindingFormatter contributionBindingFormatter,
       MethodSignatureFormatter methodSignatureFormatter,
       DependencyRequestFormatter dependencyRequestFormatter,
       KeyFormatter keyFormatter) {
@@ -121,8 +121,7 @@
     this.injectBindingRegistry = injectBindingRegistry;
     this.scopeCycleValidationType = scopeCycleValidationType;
     this.nullableValidationType = nullableValidationType;
-    this.provisionBindingFormatter = provisionBindingFormatter;
-    this.productionBindingFormatter = productionBindingFormatter;
+    this.contributionBindingFormatter = contributionBindingFormatter;
     this.methodSignatureFormatter = methodSignatureFormatter;
     this.dependencyRequestFormatter = dependencyRequestFormatter;
     this.keyFormatter = keyFormatter;
@@ -235,59 +234,39 @@ private boolean validateResolvedBinding(
         return false;
       }
 
-      ImmutableSet.Builder<ProvisionBinding> provisionBindingsBuilder =
-          ImmutableSet.builder();
-      ImmutableSet.Builder<ProductionBinding> productionBindingsBuilder =
-          ImmutableSet.builder();
-      ImmutableSet.Builder<MembersInjectionBinding> membersInjectionBindingsBuilder =
-          ImmutableSet.builder();
-      for (Binding binding : resolvedBinding.bindings()) {
-        if (binding instanceof ProvisionBinding) {
-          provisionBindingsBuilder.add((ProvisionBinding) binding);
-        }
-        if (binding instanceof ProductionBinding) {
-          productionBindingsBuilder.add((ProductionBinding) binding);
-        }
-        if (binding instanceof MembersInjectionBinding) {
-          membersInjectionBindingsBuilder.add((MembersInjectionBinding) binding);
-        }
-      }
-      ImmutableSet<ProvisionBinding> provisionBindings = provisionBindingsBuilder.build();
-      ImmutableSet<ProductionBinding> productionBindings = productionBindingsBuilder.build();
-      ImmutableSet<MembersInjectionBinding> membersInjectionBindings =
-          membersInjectionBindingsBuilder.build();
-
       switch (resolvedBinding.bindingKey().kind()) {
         case CONTRIBUTION:
-          if (!membersInjectionBindings.isEmpty()) {
+          ImmutableSet<? extends ContributionBinding> contributionBindings =
+              resolvedBinding.contributionBindings();
+          if (any(contributionBindings, Binding.Type.MEMBERS_INJECTION)) {
             throw new IllegalArgumentException(
                 "contribution binding keys should never have members injection bindings");
           }
-          Set<ContributionBinding> combined = Sets.union(provisionBindings, productionBindings);
-          if (!validateNullability(path.peek().request(), combined)) {
+          if (!validateNullability(path.peek().request(), contributionBindings)) {
             return false;
           }
-          if (!productionBindings.isEmpty() && doesPathRequireProvisionOnly(path)) {
+          if (any(contributionBindings, Binding.Type.PRODUCTION)
+              && doesPathRequireProvisionOnly(path)) {
             reportProviderMayNotDependOnProducer(path);
             return false;
           }
-          if (combined.size() <= 1) {
+          if (contributionBindings.size() <= 1) {
             return true;
           }
-          ImmutableListMultimap<BindingType, ContributionBinding> bindingsByType =
-              ContributionBinding.bindingTypesFor(combined);
-          if (bindingsByType.keySet().size() > 1) {
+          ImmutableListMultimap<ContributionType, ContributionBinding> contributionsByType =
+              ContributionBinding.contributionTypesFor(contributionBindings);
+          if (contributionsByType.keySet().size() > 1) {
             reportMultipleBindingTypes(path);
             return false;
           }
-          switch (getOnlyElement(bindingsByType.keySet())) {
+          switch (getOnlyElement(contributionsByType.keySet())) {
             case UNIQUE:
               reportDuplicateBindings(path);
               return false;
             case MAP:
-              boolean duplicateMapKeys = hasDuplicateMapKeys(path, combined);
+              boolean duplicateMapKeys = hasDuplicateMapKeys(path, contributionBindings);
               boolean inconsistentMapKeyAnnotationTypes =
-                  hasInconsistentMapKeyAnnotationTypes(path, combined);
+                  hasInconsistentMapKeyAnnotationTypes(path, contributionBindings);
               return !duplicateMapKeys && !inconsistentMapKeyAnnotationTypes;
             case SET:
               break;
@@ -296,21 +275,15 @@ private boolean validateResolvedBinding(
           }
           break;
         case MEMBERS_INJECTION:
-          if (!provisionBindings.isEmpty() || !productionBindings.isEmpty()) {
+          if (!all(resolvedBinding.bindings(), Binding.Type.MEMBERS_INJECTION)) {
             throw new IllegalArgumentException(
                 "members injection binding keys should never have contribution bindings");
           }
-          if (membersInjectionBindings.size() > 1) {
+          if (resolvedBinding.bindings().size() > 1) {
             reportDuplicateBindings(path);
             return false;
           }
-          if (membersInjectionBindings.size() == 1) {
-            MembersInjectionBinding binding = getOnlyElement(membersInjectionBindings);
-            if (!validateMembersInjectionBinding(binding, path)) {
-              return false;
-            }
-          }
-          break;
+          return validateMembersInjectionBinding(getOnlyElement(resolvedBinding.bindings()), path);
         default:
           throw new AssertionError();
       }
@@ -319,35 +292,28 @@ private boolean validateResolvedBinding(
 
     /** Ensures that if the request isn't nullable, then each contribution is also not nullable. */
     private boolean validateNullability(
-        DependencyRequest request, Set<ContributionBinding> bindings) {
+        DependencyRequest request, Set<? extends ContributionBinding> bindings) {
+      if (request.isNullable()) {
+        return true;
+      }
+
+      // Note: the method signature will include the @Nullable in it!
+      /* TODO(sameb): Sometimes javac doesn't include the Element in its output.
+       * (Maybe this happens if the code was already compiled before this point?)
+       * ... we manually print out the request in that case, otherwise the error
+       * message is kind of useless. */
+      String typeName = TypeNames.forTypeMirror(request.key().type()).toString();
+
       boolean valid = true;
-      if (!request.isNullable()) {
-        String typeName = null;
-        for (ContributionBinding binding : bindings) {
-          if (binding.nullableType().isPresent()) {
-            String methodSignature;
-            if (binding instanceof ProvisionBinding) {
-              ProvisionBinding provisionBinding = (ProvisionBinding) binding;
-              methodSignature = provisionBindingFormatter.format(provisionBinding);
-            } else {
-              ProductionBinding productionBinding = (ProductionBinding) binding;
-              methodSignature = productionBindingFormatter.format(productionBinding);
-            }
-            // Note: the method signature will include the @Nullable in it!
-            // TODO(sameb): Sometimes javac doesn't include the Element in its output.
-            // (Maybe this happens if the code was already compiled before this point?)
-            // ... we manually print ouf the request in that case, otherwise the error
-            // message is kind of useless.
-            if (typeName == null) {
-              typeName = TypeNames.forTypeMirror(request.key().type()).toString();
-            }
-            reportBuilder.addItem(
-                String.format(NULLABLE_TO_NON_NULLABLE, typeName, methodSignature)
-                + "\n at: " + dependencyRequestFormatter.format(request),
-                nullableValidationType,
-                request.requestElement());
-            valid = false;
-          }
+      for (ContributionBinding binding : bindings) {
+        if (binding.nullableType().isPresent()) {
+          reportBuilder.addItem(
+              nullableToNonNullable(typeName, contributionBindingFormatter.format(binding))
+                  + "\n at: "
+                  + dependencyRequestFormatter.format(request),
+              nullableValidationType,
+              request.requestElement());
+          valid = false;
         }
       }
       return valid;
@@ -358,7 +324,7 @@ private boolean validateNullability(
      * for the same map key.
      */
     private boolean hasDuplicateMapKeys(
-        Deque<ResolvedRequest> path, Set<ContributionBinding> mapBindings) {
+        Deque<ResolvedRequest> path, Set<? extends ContributionBinding> mapBindings) {
       boolean hasDuplicateMapKeys = false;
       for (Collection<ContributionBinding> mapBindingsForMapKey :
           indexMapBindingsByMapKey(mapBindings).asMap().values()) {
@@ -375,9 +341,9 @@ private boolean hasDuplicateMapKeys(
      * {@link MapKey} annotation type.
      */
     private boolean hasInconsistentMapKeyAnnotationTypes(
-        Deque<ResolvedRequest> path, Set<ContributionBinding> mapBindings) {
+        Deque<ResolvedRequest> path, Set<? extends ContributionBinding> contributionBindings) {
       ImmutableSetMultimap<Equivalence.Wrapper<DeclaredType>, ContributionBinding>
-          mapBindingsByAnnotationType = indexMapBindingsByAnnotationType(mapBindings);
+          mapBindingsByAnnotationType = indexMapBindingsByAnnotationType(contributionBindings);
       if (mapBindingsByAnnotationType.keySet().size() > 1) {
         reportInconsistentMapKeyAnnotations(path, mapBindingsByAnnotationType);
         return true;
@@ -390,7 +356,7 @@ private boolean hasInconsistentMapKeyAnnotationTypes(
      * valid.
      */
     private boolean validateMembersInjectionBinding(
-        MembersInjectionBinding binding, final Deque<ResolvedRequest> path) {
+        Binding binding, final Deque<ResolvedRequest> path) {
       return binding
           .key()
           .type()
@@ -705,28 +671,27 @@ void validateComponentScope() {
       for (ResolvedBindings bindings : resolvedBindings.values()) {
         if (bindings.bindingKey().kind().equals(BindingKey.Kind.CONTRIBUTION)) {
           for (ContributionBinding contributionBinding : bindings.ownedContributionBindings()) {
-            if (contributionBinding instanceof ProvisionBinding) {
-              ProvisionBinding provisionBinding = (ProvisionBinding) contributionBinding;
-              Scope bindingScope = provisionBinding.scope();
-              if (bindingScope.isPresent() && !componentScope.equals(bindingScope)) {
-                // Scoped components cannot reference bindings to @Provides methods or @Inject
-                // types decorated by a different scope annotation. Unscoped components cannot
-                // reference to scoped @Provides methods or @Inject types decorated by any
-                // scope annotation.
-                switch (provisionBinding.bindingKind()) {
-                  case PROVISION:
-                    ExecutableElement provisionMethod =
-                        MoreElements.asExecutable(provisionBinding.bindingElement());
-                    incompatiblyScopedMethodsBuilder.add(
-                        methodSignatureFormatter.format(provisionMethod));
-                    break;
-                  case INJECTION:
-                    incompatiblyScopedMethodsBuilder.add(bindingScope.getReadableSource()
-                        + " class " + provisionBinding.bindingTypeElement().getQualifiedName());
-                    break;
-                  default:
-                    throw new IllegalStateException();
-                }
+            Scope bindingScope = contributionBinding.scope();
+            if (bindingScope.isPresent() && !bindingScope.equals(componentScope)) {
+              // Scoped components cannot reference bindings to @Provides methods or @Inject
+              // types decorated by a different scope annotation. Unscoped components cannot
+              // reference to scoped @Provides methods or @Inject types decorated by any
+              // scope annotation.
+              switch (contributionBinding.bindingKind()) {
+                case PROVISION:
+                  ExecutableElement provisionMethod =
+                      MoreElements.asExecutable(contributionBinding.bindingElement());
+                  incompatiblyScopedMethodsBuilder.add(
+                      methodSignatureFormatter.format(provisionMethod));
+                  break;
+                case INJECTION:
+                  incompatiblyScopedMethodsBuilder.add(
+                      bindingScope.getReadableSource()
+                          + " class "
+                          + contributionBinding.bindingTypeElement().getQualifiedName());
+                  break;
+                default:
+                  throw new IllegalStateException();
               }
             }
           }
@@ -760,7 +725,7 @@ private void reportProviderMayNotDependOnProducer(Deque<ResolvedRequest> path) {
                 ErrorMessages.PROVIDER_ENTRY_POINT_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT,
                 formatRootRequestKey(path));
       } else {
-        ImmutableSet<ProvisionBinding> dependentProvisions =
+        ImmutableSet<? extends Binding> dependentProvisions =
             provisionsDependingOnLatestRequest(path);
         // TODO(beder): Consider displaying all dependent provisions in the error message. If we do
         // that, should we display all productions that depend on them also?
@@ -814,8 +779,9 @@ private void reportDuplicateBindings(Deque<ResolvedRequest> path) {
       StringBuilder builder = new StringBuilder();
       new Formatter(builder)
           .format(ErrorMessages.DUPLICATE_BINDINGS_FOR_KEY_FORMAT, formatRootRequestKey(path));
-      for (Binding binding : Iterables.limit(resolvedBinding.bindings(), DUPLICATE_SIZE_LIMIT)) {
-        builder.append('\n').append(INDENT).append(formatBinding(binding));
+      for (ContributionBinding binding :
+          Iterables.limit(resolvedBinding.contributionBindings(), DUPLICATE_SIZE_LIMIT)) {
+        builder.append('\n').append(INDENT).append(contributionBindingFormatter.format(binding));
       }
       int numberOfOtherBindings = resolvedBinding.bindings().size() - DUPLICATE_SIZE_LIMIT;
       if (numberOfOtherBindings > 0) {
@@ -834,21 +800,19 @@ private void reportMultipleBindingTypes(Deque<ResolvedRequest> path) {
       StringBuilder builder = new StringBuilder();
       new Formatter(builder)
           .format(ErrorMessages.MULTIPLE_BINDING_TYPES_FOR_KEY_FORMAT, formatRootRequestKey(path));
-      ImmutableListMultimap<BindingType, ContributionBinding> bindingsByType =
-          ContributionBinding.<ContributionBinding>bindingTypesFor(
-              resolvedBinding.contributionBindings());
-      for (BindingType type : Ordering.natural().immutableSortedCopy(bindingsByType.keySet())) {
+      ImmutableListMultimap<ContributionType, ContributionBinding> bindingsByType =
+          ContributionBinding.contributionTypesFor(resolvedBinding.contributionBindings());
+      for (ContributionType type :
+          Ordering.natural().immutableSortedCopy(bindingsByType.keySet())) {
         builder.append(INDENT);
         builder.append(formatBindingType(type));
         builder.append(" bindings:\n");
         for (ContributionBinding binding : bindingsByType.get(type)) {
-          builder.append(INDENT).append(INDENT);
-          if (binding instanceof ProvisionBinding) {
-            builder.append(provisionBindingFormatter.format((ProvisionBinding) binding));
-          } else if (binding instanceof ProductionBinding) {
-            builder.append(productionBindingFormatter.format((ProductionBinding) binding));
-          }
-          builder.append('\n');
+          builder
+              .append(INDENT)
+              .append(INDENT)
+              .append(contributionBindingFormatter.format(binding))
+              .append('\n');
         }
       }
       reportBuilder.addError(builder.toString(), path.getLast().request().requestElement());
@@ -1061,33 +1025,32 @@ private boolean doesPathRequireProvisionOnly(Deque<ResolvedRequest> path) {
     }
     // otherwise, the second-most-recent bindings determine whether the most recent one must be a
     // provision
-    ImmutableSet<ProvisionBinding> dependentProvisions = provisionsDependingOnLatestRequest(path);
-    return !dependentProvisions.isEmpty();
+    return !provisionsDependingOnLatestRequest(path).isEmpty();
   }
 
   /**
    * Returns any provision bindings resolved for the second-most-recent request in the given path;
    * that is, returns those provision bindings that depend on the latest request in the path.
    */
-  private ImmutableSet<ProvisionBinding> provisionsDependingOnLatestRequest(
+  private ImmutableSet<? extends Binding> provisionsDependingOnLatestRequest(
       Deque<ResolvedRequest> path) {
     Iterator<ResolvedRequest> iterator = path.iterator();
     final DependencyRequest request = iterator.next().request();
     ResolvedRequest previousResolvedRequest = iterator.next();
-    @SuppressWarnings("unchecked")  // validated by instanceof below
-    ImmutableSet<ProvisionBinding> bindings = (ImmutableSet<ProvisionBinding>) FluentIterable
-        .from(previousResolvedRequest.binding().bindings())
-        .filter(new Predicate<Binding>() {
-            @Override public boolean apply(Binding binding) {
-              return binding instanceof ProvisionBinding
-                  && binding.implicitDependencies().contains(request);
-            }
-        }).toSet();
-    return bindings;
+    return FluentIterable.from(previousResolvedRequest.binding().bindings())
+        .filter(Binding.Type.PROVISION)
+        .filter(
+            new Predicate<Binding>() {
+              @Override
+              public boolean apply(Binding binding) {
+                return binding.implicitDependencies().contains(request);
+              }
+            })
+        .toSet();
   }
 
-  private String formatBindingType(BindingType type) {
-    switch(type) {
+  private String formatBindingType(ContributionType type) {
+    switch (type) {
       case MAP:
         return "Map";
       case SET:
@@ -1099,30 +1062,18 @@ private String formatBindingType(BindingType type) {
     }
   }
 
-  private String formatBinding(Binding binding) {
-    // TODO(beder): Refactor the formatters so we don't need these instanceof checks.
-    if (binding instanceof ProvisionBinding) {
-      return provisionBindingFormatter.format((ProvisionBinding) binding);
-    } else if (binding instanceof ProductionBinding) {
-      return productionBindingFormatter.format((ProductionBinding) binding);
-    } else {
-      throw new IllegalArgumentException(
-          "Expected either a ProvisionBinding or a ProductionBinding, not " + binding);
-    }
-  }
-
   private String formatRootRequestKey(Deque<ResolvedRequest> path) {
     return keyFormatter.format(path.peek().request().key());
   }
 
   private void appendBindings(
-      StringBuilder builder, Collection<? extends Binding> bindings, int indentLevel) {
-    for (Binding binding : Iterables.limit(bindings, DUPLICATE_SIZE_LIMIT)) {
+      StringBuilder builder, Collection<? extends ContributionBinding> bindings, int indentLevel) {
+    for (ContributionBinding binding : Iterables.limit(bindings, DUPLICATE_SIZE_LIMIT)) {
       builder.append('\n');
       for (int i = 0; i < indentLevel; i++) {
         builder.append(INDENT);
       }
-      builder.append(formatBinding(binding));
+      builder.append(contributionBindingFormatter.format(binding));
     }
     int numberOfOtherBindings = bindings.size() - DUPLICATE_SIZE_LIMIT;
     if (numberOfOtherBindings > 0) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index e5bb1baba..92fe05913 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -80,10 +80,8 @@ public SourceVersion getSupportedSourceVersion() {
         nullableValidationType(processingEnv).diagnosticKind().get();
 
     MethodSignatureFormatter methodSignatureFormatter = new MethodSignatureFormatter(types);
-    ProvisionBindingFormatter provisionBindingFormatter =
-        new ProvisionBindingFormatter(methodSignatureFormatter);
-    ProductionBindingFormatter productionBindingFormatter =
-        new ProductionBindingFormatter(methodSignatureFormatter);
+    ContributionBindingFormatter contributionBindingFormatter =
+        new ContributionBindingFormatter(methodSignatureFormatter);
     DependencyRequestFormatter dependencyRequestFormatter = new DependencyRequestFormatter(types);
     KeyFormatter keyFormatter = new KeyFormatter();
 
@@ -167,8 +165,7 @@ public SourceVersion getSupportedSourceVersion() {
             injectBindingRegistry,
             scopeValidationType(processingEnv),
             nullableDiagnosticType,
-            provisionBindingFormatter,
-            productionBindingFormatter,
+            contributionBindingFormatter,
             methodSignatureFormatter,
             dependencyRequestFormatter,
             keyFormatter);
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
index a0a4dc148..379b65cdb 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
@@ -25,10 +25,16 @@
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Multimaps;
 import com.google.common.collect.Ordering;
+import com.google.common.collect.Sets;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.Component;
 import dagger.MapKey;
+import dagger.Provides;
+import dagger.producers.Produces;
+import dagger.producers.ProductionComponent;
 import java.util.EnumSet;
 import java.util.Set;
-import javax.inject.Provider;
+import javax.inject.Inject;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.element.TypeElement;
@@ -38,6 +44,7 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 import static dagger.internal.codegen.MapKeys.getMapKey;
 import static dagger.internal.codegen.MapKeys.unwrapValue;
+import static javax.lang.model.element.Modifier.STATIC;
 
 /**
  * An abstract class for a value object representing the mechanism by which a {@link Key} can be
@@ -47,7 +54,19 @@
  * @since 2.0
  */
 abstract class ContributionBinding extends Binding {
-  static enum BindingType {
+  
+  @Override
+  Set<DependencyRequest> implicitDependencies() {
+    // Optimization: If we don't need the memberInjectionRequest, don't create more objects.
+    if (!membersInjectionRequest().isPresent()) {
+      return dependencies();
+    } else {
+      // Optimization: Avoid creating an ImmutableSet+Builder just to union two things together.
+      return Sets.union(membersInjectionRequest().asSet(), dependencies());
+    }
+  }
+
+  static enum ContributionType {
     /** Represents map bindings. */
     MAP,
     /** Represents set bindings. */
@@ -60,8 +79,20 @@ boolean isMultibinding() {
     }
   }
 
-  abstract BindingType bindingType();
-
+  ContributionType contributionType() {
+    switch (provisionType()) {
+      case SET:
+      case SET_VALUES:
+        return ContributionType.SET;
+      case MAP:
+        return ContributionType.MAP;
+      case UNIQUE:
+        return ContributionType.UNIQUE;
+      default:
+        throw new AssertionError("Unknown provision type: " + provisionType());
+    }
+  }
+  
   /** Returns the type that specifies this' nullability, absent if not nullable. */
   abstract Optional<DeclaredType> nullableType();
 
@@ -77,46 +108,126 @@ boolean isMultibinding() {
    * Returns whether this binding is synthetic, i.e., not explicitly tied to code, but generated
    * implicitly by the framework.
    */
-  // TODO(user): Remove the SYNTHETIC enums from ProvisionBinding and ProductionBinding and make
-  // this field the source of truth for synthetic bindings.
-  abstract boolean isSyntheticBinding();
+  boolean isSyntheticBinding() {
+    return bindingKind().equals(Kind.SYNTHETIC);
+  }
+
+  /** If this provision requires members injection, this will be the corresponding request. */
+  abstract Optional<DependencyRequest> membersInjectionRequest();
 
   /**
-   * Returns the framework class associated with this binding, e.g., {@link Provider} for a
-   * ProvisionBinding.
+   * The kind of contribution this binding represents. Defines which elements can specify this kind
+   * of contribution.
    */
-  abstract Class<?> frameworkClass();
+  enum Kind {
+    /**
+     * A binding that is not explicitly tied to an element, but generated implicitly by the
+     * framework.
+     */
+    SYNTHETIC,
+
+    // Provision kinds
+
+    /** An {@link Inject}-annotated constructor. */
+    INJECTION,
+
+    /** A {@link Provides}-annotated method. */
+    PROVISION,
+
+    /** An implicit binding to a {@link Component @Component}-annotated type. */
+    COMPONENT,
+
+    /** A provision method on a component's {@linkplain Component#dependencies() dependency}. */
+    COMPONENT_PROVISION,
+
+    // Production kinds
+
+    /** A {@link Produces}-annotated method that doesn't return a {@link ListenableFuture}. */
+    IMMEDIATE,
+
+    /** A {@link Produces}-annotated method that returns a {@link ListenableFuture}. */
+    FUTURE_PRODUCTION,
+
+    /**
+     * A production method on a production component's
+     * {@linkplain ProductionComponent#dependencies() dependency} that returns a
+     * {@link ListenableFuture}. Methods on production component dependencies that don't return a
+     * {@link ListenableFuture} are considered {@linkplain #PROVISION provision bindings}.
+     */
+    COMPONENT_PRODUCTION,
+  }
+
+  /**
+   * The kind of this contribution binding.
+   */
+  protected abstract Kind bindingKind();
+
+  /** The provision type that was used to bind the key. */
+  abstract Provides.Type provisionType();
+
+  /**
+   * The strategy for getting an instance of a factory for a {@link ContributionBinding}.
+   */
+  enum FactoryCreationStrategy {
+    /** The factory class is an enum with one value named {@code INSTANCE}. */
+    ENUM_INSTANCE,
+    /** The factory must be created by calling the constructor. */
+    CLASS_CONSTRUCTOR,
+  }
+
+  /**
+   * Returns {@link FactoryCreationStrategy#ENUM_INSTANCE} if the binding has no dependencies and
+   * is a static provision binding or an {@link Inject @Inject} constructor binding. Otherwise
+   * returns {@link FactoryCreationStrategy#CLASS_CONSTRUCTOR}.
+   */
+  FactoryCreationStrategy factoryCreationStrategy() {
+    switch (bindingKind()) {
+      case PROVISION:
+        return implicitDependencies().isEmpty() && bindingElement().getModifiers().contains(STATIC)
+            ? FactoryCreationStrategy.ENUM_INSTANCE
+            : FactoryCreationStrategy.CLASS_CONSTRUCTOR;
+
+      case INJECTION:
+        return implicitDependencies().isEmpty()
+            ? FactoryCreationStrategy.ENUM_INSTANCE
+            : FactoryCreationStrategy.CLASS_CONSTRUCTOR;
+
+      default:
+        return FactoryCreationStrategy.CLASS_CONSTRUCTOR;
+    }
+  }
 
   /**
-   * Returns the set of {@link BindingType} enum values implied by a given
-   * {@link ContributionBinding} collection.
+   * Returns the {@link ContributionType}s represented by a given {@link ContributionBinding}
+   * collection.
    */
-  static <B extends ContributionBinding> ImmutableListMultimap<BindingType, B> bindingTypesFor(
-      Iterable<? extends B> bindings) {
-    ImmutableListMultimap.Builder<BindingType, B> builder =
-        ImmutableListMultimap.builder();
-    builder.orderKeysBy(Ordering.<BindingType>natural());
+  static <B extends ContributionBinding>
+      ImmutableListMultimap<ContributionType, B> contributionTypesFor(
+          Iterable<? extends B> bindings) {
+    ImmutableListMultimap.Builder<ContributionType, B> builder = ImmutableListMultimap.builder();
+    builder.orderKeysBy(Ordering.<ContributionType>natural());
     for (B binding : bindings) {
-      builder.put(binding.bindingType(), binding);
+      builder.put(binding.contributionType(), binding);
     }
     return builder.build();
   }
 
   /**
-   * Returns a single {@code BindingsType} represented by a given collection of
-   * {@code ContributionBindings} or throws an IllegalArgumentException if the given bindings
-   * are not all of one type.
+   * Returns a single {@link ContributionType} represented by a given collection of
+   * {@link ContributionBinding}s.
+   *
+   * @throws IllegalArgumentException if the given bindings are not all of one type
    */
-  static BindingType bindingTypeFor(Iterable<? extends ContributionBinding> bindings) {
+  static ContributionType contributionTypeFor(Iterable<? extends ContributionBinding> bindings) {
     checkNotNull(bindings);
     checkArgument(!Iterables.isEmpty(bindings), "no bindings");
-    Set<BindingType> types = EnumSet.noneOf(BindingType.class);
+    Set<ContributionType> types = EnumSet.noneOf(ContributionType.class);
     for (ContributionBinding binding : bindings) {
-      types.add(binding.bindingType());
+      types.add(binding.contributionType());
     }
     if (types.size() > 1) {
       throw new IllegalArgumentException(
-          String.format(ErrorMessages.MULTIPLE_BINDING_TYPES_FORMAT, types));
+          String.format(ErrorMessages.MULTIPLE_CONTRIBUTION_TYPES_FORMAT, types));
     }
     return Iterables.getOnlyElement(types);
   }
@@ -127,7 +238,7 @@ static BindingType bindingTypeFor(Iterable<? extends ContributionBinding> bindin
    * itself, depending on {@link MapKey#unwrapValue()}).
    */
   static ImmutableSetMultimap<Object, ContributionBinding> indexMapBindingsByMapKey(
-      Set<ContributionBinding> mapBindings) {
+      Set<? extends ContributionBinding> mapBindings) {
     return ImmutableSetMultimap.copyOf(
         Multimaps.index(
             mapBindings,
@@ -145,7 +256,7 @@ public Object apply(ContributionBinding mapBinding) {
    * Indexes map-multibindings by map key annotation type.
    */
   static ImmutableSetMultimap<Wrapper<DeclaredType>, ContributionBinding>
-      indexMapBindingsByAnnotationType(Set<ContributionBinding> mapBindings) {
+      indexMapBindingsByAnnotationType(Set<? extends ContributionBinding> mapBindings) {
     return ImmutableSetMultimap.copyOf(
         Multimaps.index(
             mapBindings,
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionBindingFormatter.java b/compiler/src/main/java/dagger/internal/codegen/ContributionBindingFormatter.java
similarity index 78%
rename from compiler/src/main/java/dagger/internal/codegen/ProductionBindingFormatter.java
rename to compiler/src/main/java/dagger/internal/codegen/ContributionBindingFormatter.java
index e7e7e778a..4e94bc946 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionBindingFormatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionBindingFormatter.java
@@ -21,26 +21,30 @@
 import static com.google.auto.common.MoreTypes.asDeclared;
 
 /**
- * Formats a {@link ProductionBinding} into a {@link String} suitable for use in error messages.
+ * Formats a {@link ContributionBinding} into a {@link String} suitable for use in error messages.
  *
- * @author Jesse Beder
+ * @author Christian Gruber
  * @since 2.0
  */
-final class ProductionBindingFormatter extends Formatter<ProductionBinding> {
+final class ContributionBindingFormatter extends Formatter<ContributionBinding> {
   private final MethodSignatureFormatter methodSignatureFormatter;
-
-  ProductionBindingFormatter(MethodSignatureFormatter methodSignatureFormatter) {
+  
+  ContributionBindingFormatter(MethodSignatureFormatter methodSignatureFormatter) { 
     this.methodSignatureFormatter = methodSignatureFormatter;
   }
 
-  @Override public String format(ProductionBinding binding) {
+  @Override public String format(ContributionBinding binding) {
     switch (binding.bindingKind()) {
+      case COMPONENT_PROVISION:
+      case COMPONENT_PRODUCTION:
+        return methodSignatureFormatter.format(asExecutable(binding.bindingElement()));
+
+      case PROVISION:
       case IMMEDIATE:
       case FUTURE_PRODUCTION:
         return methodSignatureFormatter.format(asExecutable(binding.bindingElement()),
             Optional.of(asDeclared(binding.contributedBy().get().asType())));
-      case COMPONENT_PRODUCTION:
-        return methodSignatureFormatter.format(asExecutable(binding.bindingElement()));
+
       default:
         throw new UnsupportedOperationException(
             "Not yet supporting " + binding.bindingKind() + " binding types.");
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index c025eb48a..5a923da45 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -185,7 +185,7 @@ static String inconsistentMapKeyAnnotationsError(String key) {
       "Map key annotations with unwrapped values cannot use arrays";
 
   /* collection binding errors */
-  static final String MULTIPLE_BINDING_TYPES_FORMAT =
+  static final String MULTIPLE_CONTRIBUTION_TYPES_FORMAT =
       "More than one binding present of different types %s";
 
   static final String MULTIPLE_BINDING_TYPES_FOR_KEY_FORMAT =
@@ -224,8 +224,12 @@ static String inconsistentMapKeyAnnotationsError(String key) {
   static final String MALFORMED_MODULE_METHOD_FORMAT =
       "Cannot generated a graph because method %s on module %s was malformed";
 
-  static final String NULLABLE_TO_NON_NULLABLE =
-      "%s is not nullable, but is being provided by %s";
+  static String nullableToNonNullable(String typeName, String bindingString) {
+    return String.format(
+            "%s is not nullable, but is being provided by %s",
+            typeName,
+            bindingString);
+  }
 
   static final String CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD =
       "Cannot return null from a non-@Nullable component method";
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index c7eb6326f..a0a48c81e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -52,11 +52,11 @@
 
 import static com.google.common.base.Preconditions.checkState;
 import static dagger.Provides.Type.SET;
+import static dagger.internal.codegen.ContributionBinding.Kind.PROVISION;
 import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD;
-import static dagger.internal.codegen.ProvisionBinding.Kind.PROVISION;
-import static dagger.internal.codegen.SourceFiles.factoryNameForProvisionBinding;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
-import static dagger.internal.codegen.SourceFiles.parameterizedFactoryNameForProvisionBinding;
+import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
+import static dagger.internal.codegen.SourceFiles.parameterizedGeneratedTypeNameForBinding;
 import static dagger.internal.codegen.writer.Snippet.makeParametersSnippet;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
@@ -83,7 +83,7 @@
 
   @Override
   ClassName nameGeneratedType(ProvisionBinding binding) {
-    return factoryNameForProvisionBinding(binding);
+    return generatedClassNameForBinding(binding);
   }
 
   @Override
@@ -156,7 +156,7 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
     getMethodWriter.annotate(Override.class);
     getMethodWriter.addModifiers(PUBLIC);
 
-    if (binding.memberInjectionRequest().isPresent()) {
+    if (binding.membersInjectionRequest().isPresent()) {
       ParameterizedTypeName membersInjectorType = ParameterizedTypeName.create(
           MembersInjector.class, providedTypeName);
       factoryWriter.addField(membersInjectorType, "membersInjector").addModifiers(PRIVATE, FINAL);
@@ -211,7 +211,7 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
             break;
           case CLASS_CONSTRUCTOR:
             createMethodWriter.body().addSnippet("return new %s(%s);",
-                parameterizedFactoryNameForProvisionBinding(binding),
+                parameterizedGeneratedTypeNameForBinding(binding),
                 Joiner.on(", ").join(params.keySet()));
             break;
           default:
@@ -262,7 +262,7 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
             providesMethodInvocation,
             failMsg));
       }
-    } else if (binding.memberInjectionRequest().isPresent()) {
+    } else if (binding.membersInjectionRequest().isPresent()) {
       getMethodWriter.body().addSnippet("%1$s instance = new %1$s(%2$s);",
           providedTypeName, parametersSnippet);
       getMethodWriter.body().addSnippet("membersInjector.injectMembers(instance);");
diff --git a/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java b/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
index b92cef796..cae7d35f5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
@@ -21,18 +21,19 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 import dagger.MembersInjector;
-import dagger.internal.codegen.ContributionBinding.BindingType;
+import dagger.internal.codegen.ContributionBinding.ContributionType;
 import dagger.internal.codegen.writer.ClassName;
 import dagger.internal.codegen.writer.ParameterizedTypeName;
 import dagger.internal.codegen.writer.TypeNames;
-import dagger.producers.Producer;
-import javax.inject.Provider;
 import javax.lang.model.element.ElementVisitor;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementKindVisitor6;
 
+import static com.google.common.collect.Iterables.any;
+import static dagger.internal.codegen.ContributionBinding.contributionTypeFor;
+
 /**
  * A value object that represents a field used by Dagger-generated code.
  *
@@ -65,25 +66,28 @@ private static FrameworkField createForMapBindingContribution(
 
   static FrameworkField createForSyntheticContributionBinding(
       BindingKey bindingKey, int contributionNumber, ContributionBinding contributionBinding) {
-    switch (contributionBinding.bindingType()) {
+    switch (contributionBinding.contributionType()) {
       case MAP:
         return createForMapBindingContribution(
             contributionBinding.frameworkClass(),
             BindingKey.create(bindingKey.kind(), contributionBinding.key()),
             KeyVariableNamer.INSTANCE.apply(bindingKey.key())
-                + "Contribution" + contributionNumber);
+                + "Contribution"
+                + contributionNumber);
       case SET:
         return createWithTypeFromKey(
             contributionBinding.frameworkClass(),
             bindingKey,
             KeyVariableNamer.INSTANCE.apply(bindingKey.key())
-                + "Contribution" + contributionNumber);
+                + "Contribution"
+                + contributionNumber);
       case UNIQUE:
         return createWithTypeFromKey(
             contributionBinding.frameworkClass(),
             bindingKey,
             KeyVariableNamer.INSTANCE.apply(bindingKey.key())
-                + "Contribution" + contributionNumber);
+                + "Contribution"
+                + contributionNumber);
       default:
         throw new AssertionError();
     }
@@ -95,8 +99,7 @@ static FrameworkField createForResolvedBindings(ResolvedBindings resolvedBinding
       case CONTRIBUTION:
         ImmutableSet<? extends ContributionBinding> contributionBindings =
             resolvedBindings.contributionBindings();
-        BindingType bindingsType = ProvisionBinding.bindingTypeFor(contributionBindings);
-        switch (bindingsType) {
+        switch (contributionTypeFor(contributionBindings)) {
           case SET:
           case MAP:
             return createWithTypeFromKey(
@@ -149,12 +152,9 @@ public String visitType(TypeElement e, Void p) {
   static Class<?> frameworkClassForResolvedBindings(ResolvedBindings resolvedBindings) {
     switch (resolvedBindings.bindingKey().kind()) {
       case CONTRIBUTION:
-        for (ContributionBinding binding : resolvedBindings.contributionBindings()) {
-          if (binding instanceof ProductionBinding) {
-            return Producer.class;
-          }
-        }
-        return Provider.class;
+        return any(resolvedBindings.contributionBindings(), Binding.Type.PRODUCTION)
+            ? Binding.Type.PRODUCTION.frameworkClass()
+            : Binding.Type.PROVISION.frameworkClass();
       case MEMBERS_INJECTION:
         return MembersInjector.class;
       default:
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
index b8e302e9a..f7ca429f3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
@@ -45,7 +45,7 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
-import static dagger.internal.codegen.SourceFiles.membersInjectorNameForType;
+import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
 
 /**
  * Maintains the collection of provision bindings from {@link Inject} constructors and members
@@ -85,15 +85,6 @@ B getBinding(Key key) {
       return bindingsByKey.get(key);
     }
 
-    /** Caches the binding and pretends a binding is generated without actually generating it. */
-    B pretendBindingGenerated(B binding, ClassName factoryName) {
-      tryToCacheBinding(binding);
-      if (shouldGenerateBinding(binding, factoryName)) {
-        materializedBindingKeys.add(binding.key());
-      }
-      return binding;
-    }
-
     /** Caches the binding and generates it if it needs generation. */
     void tryRegisterBinding(B binding, ClassName factoryName, boolean explicit) {
       tryToCacheBinding(binding);
@@ -180,7 +171,7 @@ MembersInjectionBinding registerBinding(MembersInjectionBinding binding) {
    * attempt to register an unresolved version of it.
    */
   private ProvisionBinding registerBinding(ProvisionBinding binding, boolean explicit) {
-    ClassName factoryName = SourceFiles.factoryNameForProvisionBinding(binding);
+    ClassName factoryName = generatedClassNameForBinding(binding);
     provisionBindings.tryRegisterBinding(binding, factoryName, explicit);
     if (binding.hasNonDefaultTypeParameters()) {
       provisionBindings.tryToGenerateBinding(provisionBindingFactory.unresolve(binding),
@@ -195,21 +186,11 @@ private ProvisionBinding registerBinding(ProvisionBinding binding, boolean expli
    */
   private MembersInjectionBinding registerBinding(
       MembersInjectionBinding binding, boolean explicit) {
-    ClassName membersInjectorName = membersInjectorNameForType(binding.bindingTypeElement());
-    if (binding.injectionSites().isEmpty()) {
-      // empty members injection bindings are special and don't need source files.
-      // so, we just pretend
-      membersInjectionBindings.pretendBindingGenerated(binding, membersInjectorName);
-      if (binding.hasNonDefaultTypeParameters()) {
-        membersInjectionBindings.pretendBindingGenerated(
-            membersInjectionBindingFactory.unresolve(binding), membersInjectorName);
-      }
-    } else {
-      membersInjectionBindings.tryRegisterBinding(binding, membersInjectorName, explicit);
-      if (binding.hasNonDefaultTypeParameters()) {
-        membersInjectionBindings.tryToGenerateBinding(
-            membersInjectionBindingFactory.unresolve(binding), membersInjectorName, explicit);
-      }
+    ClassName membersInjectorName = generatedClassNameForBinding(binding);
+    membersInjectionBindings.tryRegisterBinding(binding, membersInjectorName, explicit);
+    if (binding.hasNonDefaultTypeParameters()) {
+      membersInjectionBindings.tryToGenerateBinding(
+          membersInjectionBindingFactory.unresolve(binding), membersInjectorName, explicit);
     }
     return binding;
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
index 87b2ab187..7fbcf115d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
@@ -89,6 +89,11 @@ MembersInjectionBinding withoutParentInjectorRequest() {
           Optional.<DependencyRequest>absent());
   }
 
+  @Override
+  protected Binding.Type bindingType() {
+    return Binding.Type.MEMBERS_INJECTION;
+  }
+
   @AutoValue
   abstract static class InjectionSite {
     enum Kind {
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
index f7fcdee9d..3694d2e81 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
@@ -62,7 +62,7 @@
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
 import static dagger.internal.codegen.SourceFiles.membersInjectorNameForType;
-import static dagger.internal.codegen.SourceFiles.parameterizedMembersInjectorNameForMembersInjectionBinding;
+import static dagger.internal.codegen.SourceFiles.parameterizedGeneratedTypeNameForBinding;
 import static dagger.internal.codegen.writer.Snippet.makeParametersSnippet;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
@@ -109,6 +109,10 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
   
   @Override
   ImmutableSet<JavaWriter> write(ClassName generatedTypeName, MembersInjectionBinding binding) {
+    // Empty members injection bindings are special and don't need source files.
+    if (binding.injectionSites().isEmpty()) {
+      return ImmutableSet.of();
+    }
     Set<String> delegateMethods = new HashSet<>();
 
     // We don't want to write out resolved bindings -- we want to write out the generic version.
@@ -197,7 +201,7 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
         .body()
         .addSnippet(
             "  return new %s(%s);",
-            parameterizedMembersInjectorNameForMembersInjectionBinding(binding),
+            parameterizedGeneratedTypeNameForBinding(binding),
             Joiner.on(", ").join(constructorWriter.parameters().keySet()));
 
     ImmutableMap<BindingKey, FieldWriter> dependencyFields = dependencyFieldsBuilder.build();
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
index 5712a1e55..3291c6dc1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -29,6 +29,7 @@
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.Provides.Type;
+import dagger.internal.codegen.ContributionBinding.Kind;
 import dagger.internal.codegen.writer.ClassName;
 import dagger.internal.codegen.writer.ClassWriter;
 import dagger.internal.codegen.writer.ConstructorWriter;
@@ -54,8 +55,8 @@
 import javax.lang.model.element.Element;
 import javax.lang.model.type.TypeMirror;
 
-import static dagger.internal.codegen.SourceFiles.factoryNameForProductionBinding;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
+import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
 import static dagger.internal.codegen.writer.Snippet.makeParametersSnippet;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
@@ -79,7 +80,7 @@
 
   @Override
   ClassName nameGeneratedType(ProductionBinding binding) {
-    return factoryNameForProductionBinding(binding);
+    return generatedClassNameForBinding(binding);
   }
 
   @Override
@@ -157,7 +158,8 @@ ClassName nameGeneratedType(ProductionBinding binding) {
           .addSnippet("this.%1$s = %1$s;", field.name());
     }
 
-    boolean returnsFuture = binding.bindingKind().equals(ProductionBinding.Kind.FUTURE_PRODUCTION);
+    boolean returnsFuture =
+        binding.bindingKind().equals(ContributionBinding.Kind.FUTURE_PRODUCTION);
     ImmutableList<DependencyRequest> asyncDependencies = FluentIterable
         .from(binding.dependencies())
         .filter(new Predicate<DependencyRequest>() {
@@ -460,7 +462,7 @@ private Snippet getInvocationSnippet(
 
     final Snippet valueSnippet;
     if (binding.productionType().equals(Produces.Type.SET)) {
-      if (binding.bindingKind().equals(ProductionBinding.Kind.FUTURE_PRODUCTION)) {
+      if (binding.bindingKind().equals(ContributionBinding.Kind.FUTURE_PRODUCTION)) {
         valueSnippet =
             Snippet.format(
                 "%s.createFutureSingletonSet(%s)",
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
index f57eec4ab..624ebc7fd 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
@@ -21,7 +21,7 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.util.concurrent.ListenableFuture;
-import dagger.producers.Producer;
+import dagger.Provides;
 import dagger.producers.Produces;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
@@ -44,34 +44,17 @@
  */
 @AutoValue
 abstract class ProductionBinding extends ContributionBinding {
+  
   @Override
-  ImmutableSet<DependencyRequest> implicitDependencies() {
-    return dependencies();
+  Binding.Type bindingType() {
+    return Binding.Type.PRODUCTION;
   }
 
-  enum Kind {
-    /** Represents a binding configured by {@link Produces} that doesn't return a future. */
-    IMMEDIATE,
-    /** Represents a binding configured by {@link Produces} that returns a future. */
-    FUTURE_PRODUCTION,
-    /**
-     * Represents a binding that is not explicitly tied to code, but generated implicitly by the
-     * framework.
-     */
-    SYNTHETIC_PRODUCTION,
-    /**
-     * Represents a binding from a production method on a component dependency that returns a
-     * future. Methods that return immediate values are considered provision bindings.
-     */
-    COMPONENT_PRODUCTION,
+  @Override
+  Provides.Type provisionType() {
+    return Provides.Type.valueOf(productionType().name());
   }
-
-  /**
-   * The type of binding (whether the {@link Produces} method returns a future). For the particular
-   * type of production, use {@link #productionType}.
-   */
-  abstract Kind bindingKind();
-
+  
   /** Returns provision type that was used to bind the key. */
   abstract Produces.Type productionType();
 
@@ -79,30 +62,20 @@
   abstract ImmutableList<? extends TypeMirror> thrownTypes();
 
   @Override
-  BindingType bindingType() {
+  ContributionType contributionType() {
     switch (productionType()) {
       case SET:
       case SET_VALUES:
-        return BindingType.SET;
+        return ContributionType.SET;
       case MAP:
-        return BindingType.MAP;
+        return ContributionType.MAP;
       case UNIQUE:
-        return BindingType.UNIQUE;
+        return ContributionType.UNIQUE;
       default:
-        throw new IllegalStateException("Unknown production type: " + productionType());
+        throw new AssertionError("Unknown production type: " + productionType());
     }
   }
 
-  @Override
-  boolean isSyntheticBinding() {
-    return bindingKind().equals(Kind.SYNTHETIC_PRODUCTION);
-  }
-
-  @Override
-  Class<?> frameworkClass() {
-    return Producer.class;
-  }
-
   static final class Factory {
     private final Types types;
     private final Key.Factory keyFactory;
@@ -144,6 +117,7 @@ ProductionBinding forProducesMethod(
           false,
           ConfigurationAnnotations.getNullableType(producesMethod),
           Optional.of(MoreTypes.asTypeElement(declaredContainer)),
+          Optional.<DependencyRequest>absent(),
           kind,
           producesAnnotation.type(),
           ImmutableList.copyOf(producesMethod.getThrownTypes()));
@@ -166,7 +140,8 @@ ProductionBinding implicitMapOfProducerBinding(DependencyRequest mapOfValueReque
           false,
           Optional.<DeclaredType>absent(),
           Optional.<TypeElement>absent(),
-          Kind.SYNTHETIC_PRODUCTION,
+          Optional.<DependencyRequest>absent(),
+          Kind.SYNTHETIC,
           Produces.Type.MAP,
           ImmutableList.<TypeMirror>of());
     }
@@ -184,6 +159,7 @@ ProductionBinding forComponentMethod(ExecutableElement componentMethod) {
           false,
           Optional.<DeclaredType>absent(),
           Optional.<TypeElement>absent(),
+          Optional.<DependencyRequest>absent(),
           Kind.COMPONENT_PRODUCTION,
           Produces.Type.UNIQUE,
           ImmutableList.copyOf(componentMethod.getThrownTypes()));
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index f55613f20..257628e4f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -22,9 +22,7 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
 import dagger.Provides;
-import java.util.Set;
 import javax.inject.Inject;
-import javax.inject.Provider;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
@@ -41,13 +39,10 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
-import static dagger.internal.codegen.ProvisionBinding.Kind.INJECTION;
-import static dagger.internal.codegen.ProvisionBinding.Kind.PROVISION;
 import static dagger.internal.codegen.Scope.scopeOf;
 import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
 import static javax.lang.model.element.ElementKind.FIELD;
 import static javax.lang.model.element.ElementKind.METHOD;
-import static javax.lang.model.element.Modifier.STATIC;
 
 /**
  * A value object representing the mechanism by which a {@link Key} can be provided. New instances
@@ -58,91 +53,14 @@
  */
 @AutoValue
 abstract class ProvisionBinding extends ContributionBinding {
+  
   @Override
-  Set<DependencyRequest> implicitDependencies() {
-    // Optimization: If we don't need the memberInjectionRequest, don't create more objects.
-    if (!memberInjectionRequest().isPresent()) {
-      return dependencies();
-    } else {
-      // Optimization: Avoid creating an ImmutableSet+Builder just to union two things together.
-      return Sets.union(memberInjectionRequest().asSet(), dependencies());
-    }
-  }
-
-  enum Kind {
-    /** Represents an {@link Inject} binding. */
-    INJECTION,
-    /** Represents a binding configured by {@link Provides}. */
-    PROVISION,
-    /**
-     * Represents a binding that is not explicitly tied to code, but generated implicitly by the
-     * framework.
-     */
-    SYNTHETIC_PROVISON,
-    /** Represents the implicit binding to the component. */
-    COMPONENT,
-    /** Represents a binding from a provision method on a component dependency. */
-    COMPONENT_PROVISION,
-  }
-
-  /**
-   * The type of binding ({@link Inject} or {@link Provides}). For the particular type of provision,
-   * use {@link #provisionType}.
-   */
-  abstract Kind bindingKind();
-
-  /** Returns provision type that was used to bind the key. */
-  abstract Provides.Type provisionType();
-
-  /**
-   * The scope of the provider.
-   */
-  abstract Scope scope();
-
-  /** If this provision requires members injection, this will be the corresponding request. */
-  abstract Optional<DependencyRequest> memberInjectionRequest();
-
-  @Override
-  BindingType bindingType() {
-    switch (provisionType()) {
-      case SET:
-      case SET_VALUES:
-        return BindingType.SET;
-      case MAP:
-        return BindingType.MAP;
-      case UNIQUE:
-        return BindingType.UNIQUE;
-      default:
-        throw new IllegalStateException("Unknown provision type: " + provisionType());
-    }
+  Binding.Type bindingType() {
+    return Binding.Type.PROVISION;
   }
-
+  
   @Override
-  boolean isSyntheticBinding() {
-    return bindingKind().equals(Kind.SYNTHETIC_PROVISON);
-  }
-
-  @Override
-  Class<?> frameworkClass() {
-    return Provider.class;
-  }
-
-  enum FactoryCreationStrategy {
-    ENUM_INSTANCE,
-    CLASS_CONSTRUCTOR,
-  }
-
-  FactoryCreationStrategy factoryCreationStrategy() {
-    if (bindingKind().equals(INJECTION) && implicitDependencies().isEmpty()) {
-      return FactoryCreationStrategy.ENUM_INSTANCE;
-    }
-    if (bindingKind().equals(PROVISION)
-        && implicitDependencies().isEmpty()
-        && bindingElement().getModifiers().contains(STATIC)) {
-      return FactoryCreationStrategy.ENUM_INSTANCE;
-    }
-    return FactoryCreationStrategy.CLASS_CONSTRUCTOR;
-  }
+  abstract Scope scope();
 
   static final class Factory {
     private final Elements elements;
@@ -212,10 +130,10 @@ ProvisionBinding forInjectConstructor(ExecutableElement constructorElement,
           hasNonDefaultTypeParameters(bindingTypeElement, key.type(), types),
           Optional.<DeclaredType>absent(),
           Optional.<TypeElement>absent(),
+          membersInjectionRequest,
           Kind.INJECTION,
           Provides.Type.UNIQUE,
-          scope,
-          membersInjectionRequest);
+          scope);
     }
 
     private static final ImmutableSet<ElementKind> MEMBER_KINDS =
@@ -260,10 +178,10 @@ ProvisionBinding forProvidesMethod(ExecutableElement providesMethod, TypeMirror
           false /* no non-default parameter types */,
           ConfigurationAnnotations.getNullableType(providesMethod),
           Optional.of(MoreTypes.asTypeElement(declaredContainer)),
+          Optional.<DependencyRequest>absent(),
           Kind.PROVISION,
           providesAnnotation.type(),
-          scope,
-          Optional.<DependencyRequest>absent());
+          scope);
     }
 
     ProvisionBinding implicitMapOfProviderBinding(DependencyRequest mapOfValueRequest) {
@@ -285,10 +203,10 @@ ProvisionBinding implicitMapOfProviderBinding(DependencyRequest mapOfValueReques
           false /* no non-default parameter types */,
           Optional.<DeclaredType>absent(),
           Optional.<TypeElement>absent(),
-          Kind.SYNTHETIC_PROVISON,
+          Optional.<DependencyRequest>absent(),
+          Kind.SYNTHETIC,
           Provides.Type.MAP,
-          scopeOf(implicitMapOfProviderRequest.requestElement()),
-          Optional.<DependencyRequest>absent());
+          scopeOf(implicitMapOfProviderRequest.requestElement()));
     }
 
     ProvisionBinding forComponent(TypeElement componentDefinitionType) {
@@ -301,10 +219,10 @@ ProvisionBinding forComponent(TypeElement componentDefinitionType) {
           false /* no non-default parameter types */,
           Optional.<DeclaredType>absent(),
           Optional.<TypeElement>absent(),
+          Optional.<DependencyRequest>absent(),
           Kind.COMPONENT,
           Provides.Type.UNIQUE,
-          Scope.unscoped(),
-          Optional.<DependencyRequest>absent());
+          Scope.unscoped());
     }
 
     ProvisionBinding forComponentMethod(ExecutableElement componentMethod) {
@@ -320,10 +238,10 @@ ProvisionBinding forComponentMethod(ExecutableElement componentMethod) {
           false /* no non-default parameter types */,
           ConfigurationAnnotations.getNullableType(componentMethod),
           Optional.<TypeElement>absent(),
+          Optional.<DependencyRequest>absent(),
           Kind.COMPONENT_PROVISION,
           Provides.Type.UNIQUE,
-          scope,
-          Optional.<DependencyRequest>absent());
+          scope);
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBindingFormatter.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBindingFormatter.java
deleted file mode 100644
index 92d031042..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBindingFormatter.java
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import com.google.common.base.Optional;
-
-import static com.google.auto.common.MoreElements.asExecutable;
-import static com.google.auto.common.MoreTypes.asDeclared;
-
-/**
- * Formats a {@link ProvisionBinding} into a {@link String} suitable for use in error messages.
- *
- * @author Christian Gruber
- * @since 2.0
- */
-final class ProvisionBindingFormatter extends Formatter<ProvisionBinding> {
-  private final MethodSignatureFormatter methodSignatureFormatter;
-  
-  ProvisionBindingFormatter(MethodSignatureFormatter methodSignatureFormatter) { 
-    this.methodSignatureFormatter = methodSignatureFormatter;
-  }
-
-  @Override public String format(ProvisionBinding binding) {
-    switch (binding.bindingKind()) {
-      case PROVISION:
-        return methodSignatureFormatter.format(asExecutable(binding.bindingElement()),
-            Optional.of(asDeclared(binding.contributedBy().get().asType())));
-      case COMPONENT_PROVISION:
-        return methodSignatureFormatter.format(asExecutable(binding.bindingElement()));
-      default:
-        throw new UnsupportedOperationException(
-            "Not yet supporting " + binding.bindingKind() + " binding types.");
-    }
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
index 7ef4deb92..af9c59cfb 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
@@ -22,7 +22,7 @@
 import java.util.Set;
 
 import static com.google.common.base.Preconditions.checkState;
-import static dagger.internal.codegen.ContributionBinding.bindingTypeFor;
+import static dagger.internal.codegen.ContributionBinding.contributionTypeFor;
 
 /**
  * The collection of bindings that have been resolved for a binding key.
@@ -111,7 +111,7 @@ ResolvedBindings asInheritedIn(ComponentDescriptor owningComponent) {
   boolean isMultibindings() {
     return bindingKey().kind().equals(BindingKey.Kind.CONTRIBUTION)
         && !contributionBindings().isEmpty()
-        && bindingTypeFor(contributionBindings()).isMultibinding();
+        && contributionTypeFor(contributionBindings()).isMultibinding();
   }
 
   /**
@@ -120,6 +120,6 @@ boolean isMultibindings() {
   boolean isUniqueContribution() {
     return bindingKey().kind().equals(BindingKey.Kind.CONTRIBUTION)
         && !contributionBindings().isEmpty()
-        && !bindingTypeFor(contributionBindings()).isMultibinding();
+        && !contributionTypeFor(contributionBindings()).isMultibinding();
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index 890d3553b..834d400d3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -23,7 +23,6 @@
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Ordering;
 import dagger.internal.DoubleCheckLazy;
-import dagger.internal.codegen.ContributionBinding.BindingType;
 import dagger.internal.codegen.writer.ClassName;
 import dagger.internal.codegen.writer.ParameterizedTypeName;
 import dagger.internal.codegen.writer.Snippet;
@@ -31,7 +30,6 @@
 import dagger.internal.codegen.writer.TypeNames;
 import java.util.Collection;
 import java.util.Iterator;
-import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
 import javax.lang.model.element.ExecutableElement;
@@ -40,6 +38,7 @@
 import javax.lang.model.util.Types;
 
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
+import static com.google.common.base.Preconditions.checkArgument;
 
 /**
  * Utilities for generating files.
@@ -184,83 +183,96 @@ static Snippet frameworkTypeUsageStatement(Snippet frameworkTypeMemberSelect,
         throw new AssertionError();
     }
   }
-
-  static ClassName factoryNameForProvisionBinding(ProvisionBinding binding) {
-    TypeElement enclosingTypeElement = binding.bindingTypeElement();
-    ClassName enclosingClassName = ClassName.fromTypeElement(enclosingTypeElement);
-    switch (binding.bindingKind()) {
-      case INJECTION:
+  
+  /**
+   * Returns the generated factory or members injector name for a binding.
+   */
+  static ClassName generatedClassNameForBinding(Binding binding) {
+    switch (binding.bindingType()) {
       case PROVISION:
-        return enclosingClassName.topLevelClassName().peerNamed(
-            enclosingClassName.classFileName() + "_" + factoryPrefix(binding) + "Factory");
-      case SYNTHETIC_PROVISON:
-        throw new IllegalArgumentException();
+      case PRODUCTION:
+        ContributionBinding contribution = (ContributionBinding) binding;
+        checkArgument(!contribution.isSyntheticBinding());
+        ClassName enclosingClassName = ClassName.fromTypeElement(contribution.bindingTypeElement());
+        switch (contribution.bindingKind()) {
+          case INJECTION:
+          case PROVISION:
+          case IMMEDIATE:
+          case FUTURE_PRODUCTION:
+            return enclosingClassName
+                .topLevelClassName()
+                .peerNamed(
+                    enclosingClassName.classFileName()
+                        + "_"
+                        + factoryPrefix(contribution)
+                        + "Factory");
+
+          default:
+            throw new AssertionError();
+        }
+
+      case MEMBERS_INJECTION:
+        return membersInjectorNameForType(binding.bindingTypeElement());
+
       default:
         throw new AssertionError();
     }
   }
 
   /**
-   * Returns the factory name parameterized with the ProvisionBinding's parameters (if necessary).
+   * Returns the generated factory or members injector name parameterized with the proper type
+   * parameters if necessary.
    */
-  static TypeName parameterizedFactoryNameForProvisionBinding(
-      ProvisionBinding binding) {
-    ClassName factoryName = factoryNameForProvisionBinding(binding);
-    List<TypeName> parameters = ImmutableList.of();
-    if (binding.bindingType().equals(BindingType.UNIQUE)) {
-      switch(binding.bindingKind()) {
-        case INJECTION:
-          TypeName bindingName = TypeNames.forTypeMirror(binding.key().type());
-          // If the binding is parameterized, parameterize the factory.
-          if (bindingName instanceof ParameterizedTypeName) {
-            parameters = ((ParameterizedTypeName) bindingName).parameters();
-          }
-          break;
-        case PROVISION:
-          // For provision bindings, we parameterize creation on the types of
-          // the module, not the types of the binding.
-          // Consider: Module<A, B, C> { @Provides List<B> provideB(B b) { .. }}
-          // The binding is just parameterized on <B>, but we need all of <A, B, C>.
-          if (!binding.bindingTypeElement().getTypeParameters().isEmpty()) {
-            parameters = ((ParameterizedTypeName) TypeNames.forTypeMirror(
-                binding.bindingTypeElement().asType())).parameters();
-          }
-          break;
-        default: // fall through.
-      }
-    }
-    return parameters.isEmpty() ? factoryName
-        : ParameterizedTypeName.create(factoryName, parameters);
+  static TypeName parameterizedGeneratedTypeNameForBinding(Binding binding) {
+    return generatedClassNameForBinding(binding).withTypeParameters(bindingTypeParameters(binding));
   }
+  
+  private static ImmutableList<TypeName> bindingTypeParameters(Binding binding)
+      throws AssertionError {
+    TypeMirror bindingType;
+    switch (binding.bindingType()) {
+      case PROVISION:
+      case PRODUCTION:
+        ContributionBinding contributionBinding = (ContributionBinding) binding;
+        if (contributionBinding.contributionType().isMultibinding()) {
+          return ImmutableList.of();
+        }
+        switch (contributionBinding.bindingKind()) {
+          case INJECTION:
+            bindingType = contributionBinding.key().type();
+            break;
+            
+          case PROVISION:
+            // For provision bindings, we parameterize creation on the types of
+            // the module, not the types of the binding.
+            // Consider: Module<A, B, C> { @Provides List<B> provideB(B b) { .. }}
+            // The binding is just parameterized on <B>, but we need all of <A, B, C>.
+            bindingType = contributionBinding.bindingTypeElement().asType();
+            break;
+            
+          case IMMEDIATE:
+          case FUTURE_PRODUCTION:
+            // TODO(beder): Can these be treated just like PROVISION?
+            throw new UnsupportedOperationException();
+            
+          default:
+            return ImmutableList.of();
+        }
+        break;
+
+      case MEMBERS_INJECTION:
+        bindingType = binding.key().type();
+        break;
 
-  static ClassName factoryNameForProductionBinding(ProductionBinding binding) {
-    TypeElement enclosingTypeElement = binding.bindingTypeElement();
-    ClassName enclosingClassName = ClassName.fromTypeElement(enclosingTypeElement);
-    switch (binding.bindingKind()) {
-      case IMMEDIATE:
-      case FUTURE_PRODUCTION:
-        return enclosingClassName.topLevelClassName().peerNamed(
-            enclosingClassName.classFileName() + "_" + factoryPrefix(binding) + "Factory");
       default:
         throw new AssertionError();
     }
+    TypeName bindingTypeName = TypeNames.forTypeMirror(bindingType);
+    return bindingTypeName instanceof ParameterizedTypeName
+        ? ((ParameterizedTypeName) bindingTypeName).parameters()
+        : ImmutableList.<TypeName>of();
   }
-
-  /**
-   * Returns the members injector's name parameterized with the binding's parameters (if necessary).
-   */
-  static TypeName parameterizedMembersInjectorNameForMembersInjectionBinding(
-      MembersInjectionBinding binding) {
-    ClassName factoryName = membersInjectorNameForType(binding.bindingElement());
-    TypeName bindingName = TypeNames.forTypeMirror(binding.key().type());
-    // If the binding is parameterized, parameterize the MembersInjector.
-    if (bindingName instanceof ParameterizedTypeName) {
-      return ParameterizedTypeName.create(factoryName,
-          ((ParameterizedTypeName) bindingName).parameters());
-    }
-    return factoryName;
-  }
-
+  
   static ClassName membersInjectorNameForType(TypeElement typeElement) {
     ClassName injectedClassName = ClassName.fromTypeElement(typeElement);
     return injectedClassName
@@ -268,24 +280,17 @@ static ClassName membersInjectorNameForType(TypeElement typeElement) {
         .peerNamed(injectedClassName.classFileName() + "_MembersInjector");
   }
 
-  private static String factoryPrefix(ProvisionBinding binding) {
+  private static String factoryPrefix(ContributionBinding binding) {
     switch (binding.bindingKind()) {
       case INJECTION:
         return "";
-      case PROVISION:
-        return CaseFormat.LOWER_CAMEL.to(UPPER_CAMEL,
-            ((ExecutableElement) binding.bindingElement()).getSimpleName().toString());
-      default:
-        throw new IllegalArgumentException();
-    }
-  }
 
-  private static String factoryPrefix(ProductionBinding binding) {
-    switch (binding.bindingKind()) {
+      case PROVISION:
       case IMMEDIATE:
       case FUTURE_PRODUCTION:
-        return CaseFormat.LOWER_CAMEL.to(UPPER_CAMEL,
-            ((ExecutableElement) binding.bindingElement()).getSimpleName().toString());
+        return CaseFormat.LOWER_CAMEL.to(
+            UPPER_CAMEL, ((ExecutableElement) binding.bindingElement()).getSimpleName().toString());
+
       default:
         throw new IllegalArgumentException();
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/ClassName.java b/compiler/src/main/java/dagger/internal/codegen/writer/ClassName.java
index 5b7776853..e93e17b0c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/ClassName.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/ClassName.java
@@ -143,6 +143,14 @@ public ClassName peerNamed(String peerClassName) {
     return new ClassName(packageName(), enclosingSimpleNames(), peerClassName);
   }
 
+  /**
+   * Returns a parameterized type name with this as its raw type if {@code parameters} is not empty.
+   * If {@code parameters} is empty, returns this object.
+   */
+  public TypeName withTypeParameters(List<? extends TypeName> parameters) {
+    return parameters.isEmpty() ? this : ParameterizedTypeName.create(this, parameters);
+  }
+
   private static final ImmutableSet<NestingKind> ACCEPTABLE_NESTING_KINDS =
       Sets.immutableEnumSet(TOP_LEVEL, MEMBER);
 
diff --git a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
index 36303f1e9..8fd6ff6dc 100644
--- a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
@@ -28,8 +28,7 @@
 import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
-import static dagger.internal.codegen.ErrorMessages.NULLABLE_TO_NON_NULLABLE;
-import static java.util.Arrays.asList;
+import static dagger.internal.codegen.ErrorMessages.nullableToNonNullable;
 
 @RunWith(JUnit4.class)
 public class GraphValidationTest {
@@ -923,8 +922,10 @@ public void falsePositiveCyclicDependencyIndirectionDetected() {
     assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, a, module, component))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(String.format(NULLABLE_TO_NON_NULLABLE, "java.lang.String",
-            "@test.Nullable @Provides String test.TestModule.provideString()"));
+        .withErrorContaining(
+            nullableToNonNullable(
+                "java.lang.String",
+                "@test.Nullable @Provides String test.TestModule.provideString()"));
 
     // but if we disable the validation, then it compiles fine.
     assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, a, module, component))
@@ -965,8 +966,10 @@ public void falsePositiveCyclicDependencyIndirectionDetected() {
     assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, a, module, component))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(String.format(NULLABLE_TO_NON_NULLABLE, "java.lang.String",
-            "@test.Nullable @Provides String test.TestModule.provideString()"));
+        .withErrorContaining(
+            nullableToNonNullable(
+                "java.lang.String",
+                "@test.Nullable @Provides String test.TestModule.provideString()"));
 
     // but if we disable the validation, then it compiles fine.
     assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, a, module, component))
@@ -1007,8 +1010,10 @@ public void falsePositiveCyclicDependencyIndirectionDetected() {
     assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, a, module, component))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(String.format(NULLABLE_TO_NON_NULLABLE, "java.lang.String",
-            "@test.Nullable @Provides String test.TestModule.provideString()"));
+        .withErrorContaining(
+            nullableToNonNullable(
+                "java.lang.String",
+                "@test.Nullable @Provides String test.TestModule.provideString()"));
 
     // but if we disable the validation, then it compiles fine.
     assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, a, module, component))
@@ -1040,8 +1045,10 @@ public void falsePositiveCyclicDependencyIndirectionDetected() {
     assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, module, component))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(String.format(NULLABLE_TO_NON_NULLABLE, "java.lang.String",
-            "@test.Nullable @Provides String test.TestModule.provideString()"));
+        .withErrorContaining(
+            nullableToNonNullable(
+                "java.lang.String",
+                "@test.Nullable @Provides String test.TestModule.provideString()"));
 
     // but if we disable the validation, then it compiles fine.
     assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, module, component))
