diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index 1f2ecb6b5..0c6cd1a2c 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -290,6 +290,7 @@ java_library(
         "ProducerNodeInstanceBindingExpression.java",
         "ProductionExecutorModuleGenerator.java",
         "ProviderInstanceBindingExpression.java",
+        "PrunedConcreteMethodBindingExpression.java",
         "ReferenceReleasingManagerFields.java",
         "ReleasableReferenceManagerProviderCreationExpression.java",
         "ReleasableReferenceManagerSetProviderCreationExpression.java",
diff --git a/java/dagger/internal/codegen/ComponentModelBuilder.java b/java/dagger/internal/codegen/ComponentModelBuilder.java
index 33cbd0e7b..ba05ab9b5 100644
--- a/java/dagger/internal/codegen/ComponentModelBuilder.java
+++ b/java/dagger/internal/codegen/ComponentModelBuilder.java
@@ -92,7 +92,7 @@ static GeneratedComponentModel buildComponentModel(
           compilerOptions.aheadOfTimeSubcomponents(),
           "Calling 'buildComponentModel()' on %s when not generating ahead-of-time subcomponents.",
           graph.componentDescriptor().componentDefinitionType());
-      return new AbstractSubcomponentModelBuilder(
+      return new SubComponentModelBuilder(
               Optional.empty(), /* parent */
               types,
               elements,
@@ -302,42 +302,10 @@ private void addSubcomponents() {
       // TODO(b/72748365): Can an abstract inner subcomponent implementation be elided if it's
       // totally empty?
       generatedComponentModel.addSubcomponent(
-          subgraph.componentDescriptor(),
-          generatedComponentModel.isAbstract()
-              ? buildAbstractInnerSubcomponentModel(subgraph)
-              : buildSubcomponentModel(subgraph));
+          subgraph.componentDescriptor(), buildSubcomponentModel(subgraph));
     }
   }
 
-  private GeneratedComponentModel buildAbstractInnerSubcomponentModel(BindingGraph childGraph) {
-    GeneratedComponentModel supermodel =
-        getSubcomponentSupermodel(childGraph.componentDescriptor());
-    GeneratedComponentModel childModel =
-        GeneratedComponentModel.forAbstractSubcomponent(
-            childGraph.componentDescriptor(), supermodel, generatedComponentModel);
-    Optional<GeneratedComponentBuilderModel> childBuilderModel =
-        GeneratedComponentBuilderModel.create(childModel, childGraph, elements, types);
-    ComponentRequirementFields childComponentRequirementFields =
-        componentRequirementFields.forChildComponent(childGraph, childModel, childBuilderModel);
-    ComponentBindingExpressions childBindingExpressions =
-        bindingExpressions.forChildComponent(
-            childGraph, childModel, childComponentRequirementFields);
-    return new AbstractSubcomponentModelBuilder(
-            Optional.of(this),
-            types,
-            elements,
-            keyFactory,
-            childGraph,
-            childModel,
-            optionalFactories,
-            childBindingExpressions,
-            childComponentRequirementFields,
-            childBuilderModel,
-            bindingGraphFactory,
-            compilerOptions)
-        .build();
-  }
-
   private GeneratedComponentModel getSubcomponentSupermodel(ComponentDescriptor subcomponent) {
     // If the current model is for a subcomponent that has a defined supermodel, that supermodel
     // should contain a reference to a model for `subcomponent`
@@ -371,9 +339,18 @@ private GeneratedComponentModel getSubcomponentSupermodel(ComponentDescriptor su
   }
 
   private GeneratedComponentModel buildSubcomponentModel(BindingGraph childGraph) {
-    GeneratedComponentModel childModel =
-        GeneratedComponentModel.forSubcomponent(
-            childGraph.componentDescriptor(), generatedComponentModel);
+    GeneratedComponentModel childModel;
+    if (compilerOptions.aheadOfTimeSubcomponents()) {
+      childModel =
+          GeneratedComponentModel.forSubcomponent(
+              childGraph.componentDescriptor(),
+              generatedComponentModel,
+              getSubcomponentSupermodel(childGraph.componentDescriptor()));
+    } else {
+      childModel =
+          GeneratedComponentModel.forSubcomponent(
+              childGraph.componentDescriptor(), generatedComponentModel);
+    }
     Optional<GeneratedComponentBuilderModel> childBuilderModel =
         GeneratedComponentBuilderModel.create(childModel, childGraph, elements, types);
     ComponentRequirementFields childComponentRequirementFields =
@@ -382,12 +359,18 @@ private GeneratedComponentModel buildSubcomponentModel(BindingGraph childGraph)
         bindingExpressions.forChildComponent(
             childGraph, childModel, childComponentRequirementFields);
     return new SubComponentModelBuilder(
-            this,
+            Optional.of(this),
+            types,
+            elements,
+            keyFactory,
             childGraph,
             childModel,
+            optionalFactories,
             childBindingExpressions,
             childComponentRequirementFields,
-            childBuilderModel)
+            childBuilderModel,
+            bindingGraphFactory,
+            compilerOptions)
         .build();
   }
 
@@ -539,93 +522,17 @@ private boolean canInstantiateAllRequirements() {
   }
 
   /**
-   * Builds the model for a nested subcomponent. This is used when ahead-of-time components are not
-   * enabled (current default mode).
+   * Builds the model for a subcomponent. If generating ahead-of-time subcomponents this model may
+   * be for an abstract base class implementation, an abstract inner implementation, or a concrete
+   * implementation that extends an abstract base implementation. Otherwise it represents a private,
+   * inner, concrete, final implementation of a subcomponent which extends a user defined type.
    */
   private static final class SubComponentModelBuilder extends ComponentModelBuilder {
-    private final ComponentModelBuilder parent;
-
-    SubComponentModelBuilder(
-        ComponentModelBuilder parent,
-        BindingGraph graph,
-        GeneratedComponentModel generatedComponentModel,
-        ComponentBindingExpressions bindingExpressions,
-        ComponentRequirementFields componentRequirementFields,
-        Optional<GeneratedComponentBuilderModel> generatedComponentBuilderModel) {
-      super(
-          parent.types,
-          parent.elements,
-          parent.keyFactory,
-          graph,
-          generatedComponentModel,
-          parent.optionalFactories,
-          bindingExpressions,
-          componentRequirementFields,
-          generatedComponentBuilderModel,
-          parent.bindingGraphFactory,
-          parent.compilerOptions);
-      this.parent = parent;
-    }
-
-    @Override
-    protected void addBuilderClass(TypeSpec builder) {
-      parent.generatedComponentModel.addType(SUBCOMPONENT, builder);
-    }
-
-    @Override
-    protected void addFactoryMethods() {
-      // The parent's factory method to create this subcomponent if the
-      // subcomponent was not added via {@link dagger.Module#subcomponents()}.
-      super.graph.factoryMethod().ifPresent(this::createSubcomponentFactoryMethod);
-    }
-
-    private void createSubcomponentFactoryMethod(ExecutableElement factoryMethod) {
-      parent.generatedComponentModel.addMethod(
-          COMPONENT_METHOD,
-          MethodSpec.overriding(factoryMethod, parentType(), super.types)
-              .addStatement(
-                  "return new $T($L)",
-                  super.generatedComponentModel.name(),
-                  getFactoryMethodParameterSpecs(super.graph)
-                      .stream()
-                      .map(param -> CodeBlock.of("$N", param))
-                      .collect(toParametersCodeBlock()))
-              .build());
-    }
-
-    private DeclaredType parentType() {
-      return asDeclared(parent.graph.componentType().asType());
-    }
-
-    @Override
-    protected void addCancelParentStatement(MethodSpec.Builder methodBuilder) {
-      if (shouldPropagateCancellationToParent()) {
-        methodBuilder.addStatement(
-            "$T.this.$L($L)",
-            parent.generatedComponentModel.name(),
-            CANCELLATION_LISTENER_METHOD_NAME,
-            MAY_INTERRUPT_IF_RUNNING);
-      }
-    }
-
-    private boolean shouldPropagateCancellationToParent() {
-      return parent
-          .generatedComponentModel
-          .componentDescriptor()
-          .cancellationPolicy()
-          .map(CancellationPolicy::fromSubcomponents)
-          .orElse(IGNORE)
-          .equals(PROPAGATE);
-    }
-  }
-
-  /** Builds the model for abstract implementations of a subcomponent. */
-  private static final class AbstractSubcomponentModelBuilder extends ComponentModelBuilder {
     private final Optional<ComponentModelBuilder> parent;
     private final GeneratedComponentModel generatedComponentModel;
     private final ComponentBindingExpressions bindingExpressions;
 
-    AbstractSubcomponentModelBuilder(
+    SubComponentModelBuilder(
         Optional<ComponentModelBuilder> parent,
         DaggerTypes types,
         DaggerElements elements,
@@ -635,7 +542,7 @@ private boolean shouldPropagateCancellationToParent() {
         OptionalFactories optionalFactories,
         ComponentBindingExpressions bindingExpressions,
         ComponentRequirementFields componentRequirementFields,
-        Optional<GeneratedComponentBuilderModel> generatedComponentBuilderModel,
+        Optional<GeneratedComponentBuilderModel> builder,
         BindingGraphFactory bindingGraphFactory,
         CompilerOptions compilerOptions) {
       super(
@@ -647,7 +554,7 @@ private boolean shouldPropagateCancellationToParent() {
           optionalFactories,
           bindingExpressions,
           componentRequirementFields,
-          generatedComponentBuilderModel,
+          builder,
           bindingGraphFactory,
           compilerOptions);
       this.parent = parent;
@@ -658,7 +565,7 @@ private boolean shouldPropagateCancellationToParent() {
     @Override
     protected void addBuilderClass(TypeSpec builder) {
       if (parent.isPresent()) {
-        // If an inner implementation of a subcomponent the builder is a peer class.
+        // In an inner implementation of a subcomponent the builder is a peer class.
         parent.get().generatedComponentModel.addType(SUBCOMPONENT, builder);
       } else {
         generatedComponentModel.addType(SUBCOMPONENT, builder);
@@ -668,6 +575,32 @@ protected void addBuilderClass(TypeSpec builder) {
     @Override
     protected void addFactoryMethods() {
       // Only construct instances of subcomponents that have concrete implementations.
+      if (!generatedComponentModel.isAbstract()) {
+        // Use the parent's factory method to create this subcomponent if the
+        // subcomponent was not added via {@link dagger.Module#subcomponents()}.
+        super.graph.factoryMethod().ifPresent(this::createSubcomponentFactoryMethod);
+      }
+    }
+
+    private void createSubcomponentFactoryMethod(ExecutableElement factoryMethod) {
+      checkState(parent.isPresent());
+      parent
+          .get()
+          .generatedComponentModel
+          .addMethod(
+              COMPONENT_METHOD,
+              MethodSpec.overriding(factoryMethod, parentType(), super.types)
+                  .addStatement(
+                      "return new $T($L)",
+                      generatedComponentModel.name(),
+                      getFactoryMethodParameterSpecs(super.graph).stream()
+                          .map(param -> CodeBlock.of("$N", param))
+                          .collect(toParametersCodeBlock()))
+                  .build());
+    }
+
+    private DeclaredType parentType() {
+      return asDeclared(parent.get().graph.componentType().asType());
     }
 
     @Override
@@ -689,6 +622,29 @@ protected void addInterfaceMethods() {
         super.addInterfaceMethods();
       }
     }
+
+    @Override
+    protected void addCancelParentStatement(MethodSpec.Builder methodBuilder) {
+      if (shouldPropagateCancellationToParent()) {
+        methodBuilder.addStatement(
+            "$T.this.$L($L)",
+            parent.get().generatedComponentModel.name(),
+            CANCELLATION_LISTENER_METHOD_NAME,
+            MAY_INTERRUPT_IF_RUNNING);
+      }
+    }
+
+    private boolean shouldPropagateCancellationToParent() {
+      return parent.isPresent()
+          && parent
+              .get()
+              .generatedComponentModel
+              .componentDescriptor()
+              .cancellationPolicy()
+              .map(CancellationPolicy::fromSubcomponents)
+              .orElse(IGNORE)
+              .equals(PROPAGATE);
+    }
   }
 
   /** Returns the list of {@link ParameterSpec}s for the corresponding graph's factory method. */
diff --git a/java/dagger/internal/codegen/GeneratedComponentModel.java b/java/dagger/internal/codegen/GeneratedComponentModel.java
index 625edffe2..62a878a3c 100644
--- a/java/dagger/internal/codegen/GeneratedComponentModel.java
+++ b/java/dagger/internal/codegen/GeneratedComponentModel.java
@@ -229,13 +229,13 @@ static GeneratedComponentModel forSubcomponent(
   }
 
   /**
-   * Create a model for an inner abstract implementation of a subcomponent. This is applicable when
+   * Create a model for an inner implementation of a subcomponent. This is applicable when
    * generating ahead-of-time subcomponents.
    */
-  static GeneratedComponentModel forAbstractSubcomponent(
+  static GeneratedComponentModel forSubcomponent(
       ComponentDescriptor componentDescriptor,
-      GeneratedComponentModel supermodel,
-      GeneratedComponentModel parentModel) {
+      GeneratedComponentModel parentModel,
+      GeneratedComponentModel supermodel) {
     return new GeneratedComponentModel(
         componentDescriptor,
         parentModel.getSubcomponentName(componentDescriptor),
@@ -243,7 +243,7 @@ static GeneratedComponentModel forAbstractSubcomponent(
         Optional.of(supermodel),
         parentModel.subcomponentNames,
         PUBLIC,
-        ABSTRACT);
+        parentModel.isAbstract() ? ABSTRACT : FINAL);
   }
 
   /** Returns the descriptor for the component being generated. */
diff --git a/java/dagger/internal/codegen/ModifiableAbstractMethodBindingExpression.java b/java/dagger/internal/codegen/ModifiableAbstractMethodBindingExpression.java
index 0da08797d..095784f37 100644
--- a/java/dagger/internal/codegen/ModifiableAbstractMethodBindingExpression.java
+++ b/java/dagger/internal/codegen/ModifiableAbstractMethodBindingExpression.java
@@ -33,11 +33,6 @@
  * expression is requested. The method is overridden when generating the implementation of an
  * ancestor component.
  */
-// TODO(b/72748365): There may be unimplemented abstract binding methods even after considering a
-// complete binding graph: If there are @Provides-over-@Inject bindings then there could be branches
-// of dependencies (of the @Inject binding) that have induced abstract modifiable binding methods
-// that are missing in the full binding graph (given the @Provides binding). Such abstract
-// modifiable methods should be overridden and an exception thrown.
 abstract class ModifiableAbstractMethodBindingExpression extends BindingExpression {
   private final GeneratedComponentModel generatedComponentModel;
   private final ModifiableBindingType modifiableBindingType;
diff --git a/java/dagger/internal/codegen/ModifiableBindingExpressions.java b/java/dagger/internal/codegen/ModifiableBindingExpressions.java
index 2102909a6..c5916f729 100644
--- a/java/dagger/internal/codegen/ModifiableBindingExpressions.java
+++ b/java/dagger/internal/codegen/ModifiableBindingExpressions.java
@@ -173,18 +173,38 @@ private BindingExpression createModifiableBindingExpression(
         graph.componentDescriptor().findMatchingComponentMethod(request);
     switch (type) {
       case GENERATED_INSTANCE:
-        return new GeneratedInstanceBindingExpression(
-            generatedComponentModel,
+        // If the subcomponent is abstract then we need to define an (un-implemented)
+        // GeneratedInstanceBindingExpression.
+        if (generatedComponentModel.isAbstract()) {
+          return new GeneratedInstanceBindingExpression(
+              generatedComponentModel,
+              resolvedBindings,
+              request,
+              matchingModifiableBindingMethod,
+              matchingComponentMethod);
+        }
+        // Otherwise return a concrete implementation.
+        return bindingExpressions.wrapInMethod(
             resolvedBindings,
             request,
-            matchingModifiableBindingMethod,
-            matchingComponentMethod);
+            bindingExpressions.createBindingExpression(resolvedBindings, request));
       case MISSING:
-        return new MissingBindingExpression(
-            generatedComponentModel,
-            request,
-            matchingModifiableBindingMethod,
-            matchingComponentMethod);
+        // If we need an expression for a missing binding and the current implementation is
+        // abstract, then we need an (un-implemented) MissingBindingExpression.
+        if (generatedComponentModel.isAbstract()) {
+          return new MissingBindingExpression(
+              generatedComponentModel,
+              request,
+              matchingModifiableBindingMethod,
+              matchingComponentMethod);
+        }
+        // Otherwise we assume that it is valid to have a missing binding as it is part of a
+        // dependency chain that has been passively pruned.
+        // TODO(b/117833324): Identify pruned bindings when generating the subcomponent
+        //     implementation in which the bindings are pruned. If we hold a reference to the
+        //     binding graph used to generate a given model then we can compare a model's graph with
+        //     its supermodel graph to detect pruned dependency branches.
+        return new PrunedConcreteMethodBindingExpression();
       case OPTIONAL:
       case MULTIBINDING:
       case INJECTION:
@@ -209,9 +229,9 @@ private ModifiableBindingType getModifiableBindingType(BindingRequest request) {
       return ModifiableBindingType.NONE;
     }
 
-    // When generating a final (concrete) implementation of a (sub)component the binding is no
-    // longer considered modifiable. It cannot be further modified by a subclass implementation.
-    if (!generatedComponentModel.isAbstract()) {
+    // When generating a component the binding is not considered modifiable. Bindings are modifiable
+    // only across subcomponent implementations.
+    if (generatedComponentModel.componentDescriptor().kind().isTopLevel()) {
       return ModifiableBindingType.NONE;
     }
 
@@ -278,13 +298,18 @@ private boolean shouldModifyBinding(
     ResolvedBindings resolvedBindings = graph.resolvedBindings(request);
     switch (modifiableBindingType) {
       case GENERATED_INSTANCE:
-        return false;
+        return !generatedComponentModel.isAbstract();
       case MISSING:
         // TODO(b/72748365): investigate beder@'s comment about having intermediate component
         // ancestors satisfy missing bindings of their children with their own missing binding
         // methods so that we can minimize the cases where we need to reach into doubly-nested
-        // descendant component implementations
-        return resolvableBinding(request);
+        // descendant component implementations.
+
+        // Implement a missing binding if it is resolvable, or if we're generating a concrete
+        // subcomponent implementation. If a binding is still missing when the subcomponent
+        // implementation is concrete then it is assumed to be part of a dependency that would have
+        // been passively pruned when implementing the full component hierarchy.
+        return resolvableBinding(request) || !generatedComponentModel.isAbstract();
       case OPTIONAL:
         // Only override optional binding methods if we have a non-empty binding.
         return !resolvedBindings.contributionBinding().dependencies().isEmpty();
@@ -300,7 +325,8 @@ private boolean shouldModifyBinding(
         // the implementation has changed, so we implement the binding once in the base
         // implementation of the subcomponent. It will be re-implemented when generating the
         // component.
-        return !generatedComponentModel.supermodel().isPresent();
+        return !generatedComponentModel.supermodel().isPresent()
+            || !generatedComponentModel.isAbstract();
       default:
         throw new IllegalStateException(
             String.format(
diff --git a/java/dagger/internal/codegen/PrunedConcreteMethodBindingExpression.java b/java/dagger/internal/codegen/PrunedConcreteMethodBindingExpression.java
new file mode 100644
index 000000000..1fbf0fbde
--- /dev/null
+++ b/java/dagger/internal/codegen/PrunedConcreteMethodBindingExpression.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod;
+
+/**
+ * A {@link BindingExpression} that implements a method that encapsulates a binding that is not part
+ * of the binding graph when generating a final concrete implementation of a subcomponent. The
+ * implementation throws an exception. It is assumed that a binding may remain missing in a valid
+ * binding graph, because it's possible for there to be dependencies that are passively pruned when
+ * a non-leaf binding is re-defined (such as when {@code @Provides} bindings override
+ * {@code @Inject} bindings).
+ *
+ * <p>This method should never be invoked. If it is the exception indicates an issue within Dagger
+ * itself.
+ */
+final class PrunedConcreteMethodBindingExpression extends BindingExpression {
+  private static final CodeBlock METHOD_IMPLEMENTATION =
+      CodeBlock.of(
+          "throw new $T($S);",
+          UnsupportedOperationException.class,
+          "This binding is not part of the final binding graph. The key was requested by a binding "
+              + "that was believed to possibly be part of the graph, but is no longer requested.");
+
+  PrunedConcreteMethodBindingExpression() {}
+
+  @Override
+  CodeBlock getModifiableBindingMethodImplementation(
+      ModifiableBindingMethod modifiableBindingMethod, GeneratedComponentModel component) {
+    return METHOD_IMPLEMENTATION;
+  }
+
+  @Override
+  final Expression getDependencyExpression(ClassName requestingClass) {
+    throw new UnsupportedOperationException(
+        "Requesting a dependency expression for a pruned binding.");
+  }
+}
diff --git a/javatests/dagger/functional/BUILD b/javatests/dagger/functional/BUILD
index 306109bed..65bc0399c 100644
--- a/javatests/dagger/functional/BUILD
+++ b/javatests/dagger/functional/BUILD
@@ -56,6 +56,12 @@ GenJavaTests(
         ["**/*.java"],
         exclude = [
             "HjarTest.java",
+            # TODO(b/72748365): Remove these exclusions
+            "ReleasableReferencesComponentsTest.java",
+            "ReusableTest.java",
+            "ComponentWithReusableBindings.java",
+            "subcomponent/MultibindingSubcomponents.java",
+            "subcomponent/SubcomponentMultibindingsTest.java",
         ],
     ),
     javacopts = DOCLINT_HTML_AND_SYNTAX,
diff --git a/javatests/dagger/functional/guava/BUILD b/javatests/dagger/functional/guava/BUILD
index 3dacd5494..6c74837d7 100644
--- a/javatests/dagger/functional/guava/BUILD
+++ b/javatests/dagger/functional/guava/BUILD
@@ -35,18 +35,4 @@ GenJavaTests(
     ],
 )
 
-GenJavaTests(
-    name = "guava_tests_with_aot",
-    srcs = glob(["**/*.java"]),
-    javacopts = DOCLINT_HTML_AND_SYNTAX,
-    with_aot = True,
-    deps = [
-        "//:dagger_with_compiler",
-        "@google_bazel_common//third_party/java/auto:value",
-        "@google_bazel_common//third_party/java/guava",
-        "@google_bazel_common//third_party/java/jsr305_annotations",
-        "@google_bazel_common//third_party/java/jsr330_inject",
-        "@google_bazel_common//third_party/java/junit",
-        "@google_bazel_common//third_party/java/truth",
-    ],
-)
+# TODO(b/72748365): Add "with aot" tests, once they pass.
diff --git a/javatests/dagger/functional/jdk8/BUILD b/javatests/dagger/functional/jdk8/BUILD
index bcab113fe..05d3c1fe8 100644
--- a/javatests/dagger/functional/jdk8/BUILD
+++ b/javatests/dagger/functional/jdk8/BUILD
@@ -36,19 +36,4 @@ GenJavaTests(
     ],
 )
 
-GenJavaTests(
-    name = "jdk8_tests_with_aot",
-    srcs = glob(["**/*.java"]),
-    javacopts = DOCLINT_HTML_AND_SYNTAX,
-    test_only_deps = [
-        "@google_bazel_common//third_party/java/guava",
-        "@google_bazel_common//third_party/java/junit",
-        "@google_bazel_common//third_party/java/truth:truth8",
-    ],
-    with_aot = True,
-    deps = [
-        "//:dagger_with_compiler",
-        "@google_bazel_common//third_party/java/auto:value",
-        "@google_bazel_common//third_party/java/jsr305_annotations",
-    ],
-)
+# TODO(b/72748365): Add "with aot" tests, once they pass.
diff --git a/javatests/dagger/functional/producers/BUILD b/javatests/dagger/functional/producers/BUILD
index 3be99c262..5d595a3f4 100644
--- a/javatests/dagger/functional/producers/BUILD
+++ b/javatests/dagger/functional/producers/BUILD
@@ -43,7 +43,15 @@ GenJavaTests(
 
 GenJavaTests(
     name = "producers-functional-tests-with-aot",
-    srcs = glob(["**/*.java"]),
+    srcs = glob(
+        ["**/*.java"],
+        # TODO(b/72748365): Remove these exclusions
+        exclude = [
+            "subcomponent/*.java",
+            "subcomponent/pruning/*.java",
+            "cancellation/*.java",
+        ],
+    ),
     javacopts = SOURCE_7_TARGET_7 + DOCLINT_HTML_AND_SYNTAX + DOCLINT_REFERENCES,
     with_aot = True,
     deps = [
diff --git a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
index 4d578ae71..538d160b8 100644
--- a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
+++ b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
@@ -236,7 +236,7 @@ public void missingBindings_dependsOnMissingBinding() {
             "}"));
     JavaFileObject generatedAncestor =
         JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
+            "test.DaggerAncestor",
             "package test;",
             "",
             IMPORT_GENERATED_ANNOTATION,
@@ -437,6 +437,84 @@ public void moduleInstanceDependency() {
     assertThat(compilation)
         .generatedSourceFile("test.DaggerAncestor")
         .hasSourceEquivalentTo(generatedAncestor);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Root",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface Root {",
+            "  Ancestor ancestor();",
+            "}"));
+    JavaFileObject generatedRoot =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerRoot implements Root {",
+            "  private DaggerRoot(Builder builder) {}",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static Root create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Ancestor ancestor() {",
+            "    return new AncestorImpl();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {}",
+            "",
+            "    public Root build() {",
+            "      return new DaggerRoot(this);",
+            "    }",
+            "  }",
+            "",
+            "  public final class AncestorImpl extends DaggerAncestor {",
+            "    private AncestorImpl() {",
+            "      super();",
+            "    }",
+            "",
+            "    @Override",
+            "    public Leaf leaf() {",
+            "      return new LeafImpl();",
+            "    }",
+            "",
+            "    public final class LeafImpl extends DaggerAncestor.LeafImpl {",
+            "      private TestModule testModule;",
+            "",
+            "      private LeafImpl() {",
+            "        super();",
+            "        initialize();",
+            "      }",
+            "",
+            "      @SuppressWarnings(\"unchecked\")",
+            "      private void initialize() {",
+            "        this.testModule = new TestModule();",
+            "      }",
+            "",
+            "      @Override",
+            "      public String string() {",
+            "        return TestModule_ProvideStringFactory.proxyProvideString(testModule);",
+            "      }",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerRoot")
+        .hasSourceEquivalentTo(generatedRoot);
   }
 
   @Test
@@ -530,6 +608,86 @@ public void moduleInstanceDependency_withModuleParams() {
     assertThat(compilation)
         .generatedSourceFile("test.DaggerAncestor")
         .hasSourceEquivalentTo(generatedAncestor);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Root",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface Root {",
+            "  Ancestor ancestor();",
+            "}"));
+    JavaFileObject generatedRoot =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerRoot",
+            "package test;",
+            "",
+            "import dagger.internal.Preconditions;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerRoot implements Root {",
+            "  private DaggerRoot(Builder builder) {}",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static Root create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Ancestor ancestor() {",
+            "    return new AncestorImpl();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {}",
+            "",
+            "    public Root build() {",
+            "      return new DaggerRoot(this);",
+            "    }",
+            "  }",
+            "",
+            "  public final class AncestorImpl extends DaggerAncestor {",
+            "    private AncestorImpl() {",
+            "      super();",
+            "    }",
+            "",
+            "    @Override",
+            "    public Leaf leaf(TestModule module) {",
+            "      return new LeafImpl(module);",
+            "    }",
+            "",
+            "    public final class LeafImpl extends DaggerAncestor.LeafImpl {",
+            "      private TestModule testModule;",
+            "",
+            "      private LeafImpl(TestModule module) {",
+            "        super();",
+            "        initialize(module);",
+            "      }",
+            "",
+            "      @SuppressWarnings(\"unchecked\")",
+            "      private void initialize(final TestModule module) {",
+            "        this.testModule = Preconditions.checkNotNull(module);",
+            "      }",
+            "",
+            "      @Override",
+            "      public int getInt() {",
+            "        return testModule.provideInt();",
+            "      }",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerRoot")
+        .hasSourceEquivalentTo(generatedRoot);
   }
 
   @Test
@@ -605,6 +763,78 @@ public void generatedInstanceBinding() {
     assertThat(compilation)
         .generatedSourceFile("test.DaggerAncestor")
         .hasSourceEquivalentTo(generatedAncestor);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Root",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface Root {",
+            "  Ancestor ancestor();",
+            "}"));
+    JavaFileObject generatedRoot =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerRoot",
+            "package test;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerRoot implements Root {",
+            "  private DaggerRoot(Builder builder) {}",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static Root create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Ancestor ancestor() {",
+            "    return new AncestorImpl();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {}",
+            "",
+            "    public Root build() {",
+            "      return new DaggerRoot(this);",
+            "    }",
+            "  }",
+            "",
+            "  public final class AncestorImpl extends DaggerAncestor {",
+            "    private AncestorImpl() {",
+            "      super();",
+            "    }",
+            "",
+            "    @Override",
+            "    public Leaf.Builder leaf() {",
+            "      return new LeafBuilder();",
+            "    }",
+            "",
+            "    private final class LeafBuilder extends DaggerAncestor.LeafBuilder {",
+            "      @Override",
+            "      public Leaf build() {",
+            "        return new LeafImpl(this);",
+            "      }",
+            "    }",
+            "",
+            "    public final class LeafImpl extends DaggerAncestor.LeafImpl {",
+            "      private LeafImpl(LeafBuilder builder) {",
+            "        super(builder);",
+            "      }",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerRoot")
+        .hasSourceEquivalentTo(generatedRoot);
   }
 
   @Test
@@ -2781,6 +3011,452 @@ public void provisionOverInjection_indirectDependency() {
         .hasSourceEquivalentTo(generatedAncestor);
   }
 
+  @Test
+  public void provisionOverInjection_prunedIndirectDependency() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "PrunedDependency");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.InjectsPrunedDependency",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class InjectsPrunedDependency {",
+            "  @Inject",
+            "  InjectsPrunedDependency(PrunedDependency prunedDependency) {}",
+            "",
+            "  private InjectsPrunedDependency() { }",
+            "",
+            "  static InjectsPrunedDependency create() { return new InjectsPrunedDependency(); }",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Leaf {",
+            "  InjectsPrunedDependency injectsPrunedDependency();",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public InjectsPrunedDependency injectsPrunedDependency() {",
+            "    return new InjectsPrunedDependency(getPrunedDependency());",
+            "  }",
+            "",
+            "  public abstract PrunedDependency getPrunedDependency();",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Root",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = RootModule.class)",
+            "interface Root {",
+            "  Leaf leaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.RootModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "class RootModule {",
+            "  @Provides",
+            "  static InjectsPrunedDependency injectsPrunedDependency() {",
+            "    return InjectsPrunedDependency.create();",
+            "  }",
+            "}"));
+    JavaFileObject generatedRoot =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerRoot",
+            "package test;",
+            "",
+            "import dagger.internal.Preconditions;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerRoot implements Root {",
+            "  private DaggerRoot(Builder builder) {}",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static Root create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Leaf leaf() {",
+            "    return new LeafImpl();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {}",
+            "",
+            "    public Root build() {",
+            "      return new DaggerRoot(this);",
+            "    }",
+            "",
+            "    @Deprecated",
+            "    public Builder rootModule(RootModule rootModule) {",
+            "      Preconditions.checkNotNull(rootModule);",
+            "      return this;",
+            "    }",
+            "  }",
+            "",
+            "  public final class LeafImpl extends DaggerLeaf {",
+            "    private LeafImpl() {",
+            "      super();",
+            "    }",
+            "",
+            "    @Override",
+            "    public PrunedDependency getPrunedDependency() {",
+            "      throw new UnsupportedOperationException(",
+            "          \"This binding is not part of the final binding graph. The key was \"",
+            "              + \"requested by a binding that was believed to possibly be part of \"",
+            "              + \"the graph, but is no longer requested.\");",
+            "    }",
+            "",
+            "    @Override",
+            "    public InjectsPrunedDependency injectsPrunedDependency() {",
+            "      return RootModule_InjectsPrunedDependencyFactory",
+            "          .proxyInjectsPrunedDependency();",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerRoot")
+        .hasSourceEquivalentTo(generatedRoot);
+  }
+
+  @Test
+  public void productionSubcomponentAndModifiableFrameworkInstance() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "Response", "ResponseDependency");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import com.google.common.util.concurrent.ListenableFuture;",
+            "import dagger.producers.ProductionSubcomponent;",
+            "import java.util.Set;",
+            "",
+            "@ProductionSubcomponent(modules = ResponseProducerModule.class)",
+            "interface Leaf {",
+            "  ListenableFuture<Set<Response>> responses();",
+            "",
+            "  @ProductionSubcomponent.Builder",
+            "  interface Builder {",
+            "    Leaf build();",
+            "  }",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.ResponseProducerModule",
+            "package test;",
+            "",
+            "import dagger.multibindings.IntoSet;",
+            "import dagger.producers.ProducerModule;",
+            "import dagger.producers.Produces;",
+            "",
+            "@ProducerModule",
+            "final class ResponseProducerModule {",
+            "  @Produces",
+            "  @IntoSet",
+            "  static Response response(ResponseDependency responseDependency) {",
+            "    return new Response();",
+            "  }",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            "import com.google.common.util.concurrent.ListenableFuture;",
+            "import dagger.producers.Producer;",
+            "import dagger.producers.internal.CancellationListener;",
+            "import dagger.producers.internal.Producers;",
+            "import dagger.producers.internal.SetProducer;",
+            "import dagger.producers.monitoring.ProductionComponentMonitor;",
+            "import java.util.Set;",
+            "import java.util.concurrent.Executor;",
+            IMPORT_GENERATED_ANNOTATION,
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf, CancellationListener {",
+            "  private Producer<Set<Response>> responsesEntryPoint;",
+            "",
+            "  private ResponseProducerModule_ResponseFactory responseProducer;",
+            "",
+            "  private Producer<Set<Response>> setOfResponseProducer;",
+            "",
+            "  protected DaggerLeaf(Builder builder) {",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.responseProducer =",
+            "        ResponseProducerModule_ResponseFactory.create(",
+            "            getExecutorProvider(),",
+            "            getProductionComponentMonitorProvider(),",
+            "            getResponseDependencyProducernode());",
+            "    this.setOfResponseProducer =",
+            // TODO(b/72748365): This initialization should be encapsulated in a method to be
+            // modified.
+            "        SetProducer.<Response>builder(1, 0).addProducer(responseProducer).build();",
+            "    this.responsesEntryPoint =",
+            "        Producers.entryPointViewOf(setOfResponseProducer, this);",
+            "  }",
+            "",
+            "  @Override",
+            "  public ListenableFuture<Set<Response>> responses() {",
+            "    return responsesEntryPoint.get();",
+            "  }",
+            "",
+            "  public abstract Provider<Executor> getExecutorProvider();",
+            "",
+            "  public abstract Provider<ProductionComponentMonitor>",
+            "      getProductionComponentMonitorProvider();",
+            "",
+            // TODO(b/72748365): Why is the CamelCase wrong at 'node' here.
+            "  public abstract Producer<ResponseDependency> getResponseDependencyProducernode();",
+            "",
+            "  @Override",
+            "  public void onProducerFutureCancelled(boolean mayInterruptIfRunning) {",
+            "    Producers.cancel(setOfResponseProducer, mayInterruptIfRunning);",
+            "    Producers.cancel(responseProducer, mayInterruptIfRunning);",
+            "  }",
+            "",
+            "  public abstract static class Builder implements Leaf.Builder {}",
+            "}");
+
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.ExecutorModule",
+            "package test;",
+            "",
+            "import com.google.common.util.concurrent.MoreExecutors;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.producers.Production;",
+            "import java.util.concurrent.Executor;",
+            "",
+            "@Module",
+            "public final class ExecutorModule {",
+            "  @Provides",
+            "  @Production",
+            "  Executor executor() {",
+            "    return MoreExecutors.directExecutor();",
+            "  }",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.Root",
+            "package test;",
+            "",
+            "import com.google.common.util.concurrent.ListenableFuture;",
+            "import dagger.producers.ProductionComponent;",
+            "",
+            "@ProductionComponent(",
+            "    modules = {ResponseDependencyProducerModule.class, ExecutorModule.class})",
+            "interface Root {",
+            "  Leaf.Builder leaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.ResponseDependencyProducerModule",
+            "package test;",
+            "",
+            "import com.google.common.util.concurrent.Futures;",
+            "import com.google.common.util.concurrent.ListenableFuture;",
+            "import dagger.producers.ProducerModule;",
+            "import dagger.producers.Produces;",
+            "",
+            "@ProducerModule",
+            "final class ResponseDependencyProducerModule {",
+            "  @Produces",
+            "  static ListenableFuture<ResponseDependency> responseDependency() {",
+            "    return Futures.immediateFuture(new ResponseDependency());",
+            "  }",
+            "}"));
+    JavaFileObject generatedRoot =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerRoot",
+            "package test;",
+            "import dagger.internal.DoubleCheck;",
+            "import dagger.internal.InstanceFactory;",
+            "import dagger.internal.Preconditions;",
+            "import dagger.internal.SetFactory;",
+            "import dagger.producers.Producer;",
+            "import dagger.producers.internal.CancellationListener;",
+            "import dagger.producers.internal.Producers;",
+            "import dagger.producers.monitoring.ProductionComponentMonitor;",
+            "import java.util.concurrent.Executor;",
+            IMPORT_GENERATED_ANNOTATION,
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerRoot implements Root, CancellationListener {",
+            "  private ExecutorModule_ExecutorFactory executorProvider;",
+            "",
+            "  private Provider<Executor> executorProvider2;",
+            "",
+            "  private Provider<Root> rootProvider;",
+            "",
+            "  private Provider<ProductionComponentMonitor> monitorProvider;",
+            "",
+            "  private ResponseDependencyProducerModule_ResponseDependencyFactory",
+            "      responseDependencyProducer;",
+            "",
+            "  private DaggerRoot(Builder builder) {",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static Root create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.executorProvider =",
+            "        ExecutorModule_ExecutorFactory.create(builder.executorModule);",
+            "    this.executorProvider2 =",
+            "        DoubleCheck.provider(",
+            "            Root_ProductionExecutorModule_ExecutorFactory.create(executorProvider));",
+            "    this.rootProvider = InstanceFactory.create((Root) this);",
+            "    this.monitorProvider =",
+            "        DoubleCheck.provider(",
+            "            Root_MonitoringModule_MonitorFactory.create(",
+            "                rootProvider,",
+            "                SetFactory.<ProductionComponentMonitor.Factory>empty()));",
+            "    this.responseDependencyProducer =",
+            "        ResponseDependencyProducerModule_ResponseDependencyFactory.create(",
+            "            executorProvider2, monitorProvider);",
+            "  }",
+            "",
+            "  @Override",
+            "  public Leaf.Builder leaf() {",
+            "    return new LeafBuilder();",
+            "  }",
+            "",
+            "  @Override",
+            "  public void onProducerFutureCancelled(boolean mayInterruptIfRunning) {",
+            // TODO(b/72748365): Reference to DaggerRoot is redundant.
+            "    Producers.cancel(DaggerRoot.this.responseDependencyProducer,",
+            "        mayInterruptIfRunning);",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private ExecutorModule executorModule;",
+            "",
+            "    private Builder() {}",
+            "",
+            "    public Root build() {",
+            "      if (executorModule == null) {",
+            "        this.executorModule = new ExecutorModule();",
+            "      }",
+            "      return new DaggerRoot(this);",
+            "    }",
+            "",
+            "    @Deprecated",
+            "    public Builder responseDependencyProducerModule(",
+            "        ResponseDependencyProducerModule responseDependencyProducerModule) {",
+            "      Preconditions.checkNotNull(responseDependencyProducerModule);",
+            "      return this;",
+            "    }",
+            "",
+            "    public Builder executorModule(ExecutorModule executorModule) {",
+            "      this.executorModule = Preconditions.checkNotNull(executorModule);",
+            "      return this;",
+            "    }",
+            "",
+            "    @Deprecated",
+            "    public Builder root_ProductionExecutorModule(",
+            "        Root_ProductionExecutorModule root_ProductionExecutorModule) {",
+            "      Preconditions.checkNotNull(root_ProductionExecutorModule);",
+            "      return this;",
+            "    }",
+            "  }",
+            "",
+            "  private final class LeafBuilder extends DaggerLeaf.Builder {",
+            "    @Override",
+            "    public Leaf build() {",
+            "      return new LeafImpl(this);",
+            "    }",
+            "  }",
+            "",
+            "  public final class LeafImpl extends DaggerLeaf implements CancellationListener {",
+            "    private LeafImpl(LeafBuilder builder) {",
+            "      super(builder);",
+            "    }",
+            "",
+            "    @Override",
+            "    public Provider<Executor> getExecutorProvider() {",
+            "      return DaggerRoot.this.executorProvider2;",
+            "    }",
+            "",
+            "    @Override",
+            "    public Provider<ProductionComponentMonitor>",
+            "        getProductionComponentMonitorProvider() {",
+            "      return DaggerRoot.this.monitorProvider;",
+            "    }",
+            "",
+            "    @Override",
+            "    public Producer<ResponseDependency> getResponseDependencyProducernode() {",
+            "      return DaggerRoot.this.responseDependencyProducer;",
+            "    }",
+            "",
+            "    @Override",
+            "    public void onProducerFutureCancelled(boolean mayInterruptIfRunning) {",
+            // TODO(b/72748365): if this onProducerFutureCancelled method is just a super call, omit
+            // the method
+            "      super.onProducerFutureCancelled(mayInterruptIfRunning);",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerRoot")
+        .hasSourceEquivalentTo(generatedRoot);
+  }
+
   private void createAncillaryClasses(
       ImmutableList.Builder<JavaFileObject> filesBuilder, String... ancillaryClasses) {
     for (String className : ancillaryClasses) {
