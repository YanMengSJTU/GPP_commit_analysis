diff --git a/.gitignore b/.gitignore
index 46e4a89..1a25197 100644
--- a/.gitignore
+++ b/.gitignore
@@ -12,6 +12,7 @@
 bin/
 gen/
 target/
+.DS_Store
 
 # Local configuration file (sdk path, etc)
 local.properties
@@ -30,3 +31,6 @@ libs/
 
 # Maven
 release.properties
+
+#Gradle Build
+build/
diff --git a/build.gradle b/build.gradle
new file mode 100644
index 0000000..52629c9
--- /dev/null
+++ b/build.gradle
@@ -0,0 +1,30 @@
+apply plugin: 'android-sdk-manager'
+apply plugin: 'com.android.library'
+
+group 'com.mobsandgeeks'
+def version = '1.0.5'
+def versionCodeIncrement = 2
+
+dependencies {
+    compile 'com.android.support:support-v4:20.0.0'
+}
+
+android {
+    compileSdkVersion compileSdkVersionValue
+    buildToolsVersion buildToolsVersionValue
+
+    defaultConfig {
+        minSdkVersion 4
+        targetSdkVersion compileSdkVersionValue
+        versionCode versionCodeIncrement
+        versionName version
+    }
+    sourceSets {
+        main {
+            manifest.srcFile 'AndroidManifest.xml'
+            java.srcDirs = ['src']
+        }
+        androidTest.setRoot('tests')
+    }
+
+}
\ No newline at end of file
diff --git a/src/com/mobsandgeeks/saripaar/AnnotationRuleFactory.java b/src/com/mobsandgeeks/saripaar/AnnotationRuleFactory.java
index 36b86d0..4e3b038 100644
--- a/src/com/mobsandgeeks/saripaar/AnnotationRuleFactory.java
+++ b/src/com/mobsandgeeks/saripaar/AnnotationRuleFactory.java
@@ -26,6 +26,7 @@
 import com.mobsandgeeks.saripaar.annotation.Email;
 import com.mobsandgeeks.saripaar.annotation.IpAddress;
 import com.mobsandgeeks.saripaar.annotation.NumberRule;
+import com.mobsandgeeks.saripaar.annotation.Optional;
 import com.mobsandgeeks.saripaar.annotation.Password;
 import com.mobsandgeeks.saripaar.annotation.Regex;
 import com.mobsandgeeks.saripaar.annotation.Required;
@@ -46,7 +47,7 @@
 class AnnotationRuleFactory {
     // Debug
     static final String TAG = "AnnotationToRuleConverter";
- 
+
     // Constants
     static final String WARN_TEXT = "%s - @%s can only be applied to TextView and " +
             "its subclasses.";
@@ -63,6 +64,8 @@
             return getCheckedRule(field, view, (Checked) annotation);
         } else if (Required.class.equals(annotationType)) {
             return getRequiredRule(field, view, (Required) annotation);
+        } else if (Optional.class.equals(annotationType)) {
+            return getOptionalRule(field, view, (Optional) annotation);
         } else if (TextRule.class.equals(annotationType)) {
             return getTextRule(field, view, (TextRule) annotation);
         } else if (Regex.class.equals(annotationType)) {
@@ -118,11 +121,19 @@
 
         int messageResId = required.messageResId();
         String message = messageResId != 0 ? view.getContext().getString(messageResId) :
-            required.message();
+                required.message();
 
         return Rules.required(message, required.trim());
     }
 
+    private static Rule<?> getOptionalRule(Field field, View view, Optional annotation) {
+        if (!TextView.class.isAssignableFrom(view.getClass())) {
+            Log.w(TAG, String.format(WARN_TEXT, field.getName(), Optional.class.getSimpleName()));
+            return null;
+        }
+        return Rules.optional();
+    }
+
     private static Rule<View> getTextRule(Field field, View view, TextRule textRule) {
         if (!TextView.class.isAssignableFrom(view.getClass())) {
             Log.w(TAG, String.format(WARN_TEXT, field.getName(), TextRule.class.getSimpleName()));
@@ -132,13 +143,27 @@
         List<Rule<?>> rules = new ArrayList<Rule<?>>();
         int messageResId = textRule.messageResId();
         String message = messageResId != 0 ? view.getContext().getString(messageResId) :
-            textRule.message();
-
-        if (textRule.minLength() > 0) {
-            rules.add(Rules.minLength(null, textRule.minLength(), textRule.trim()));
+                textRule.message();
+        int minLength = textRule.minLength();
+        int maxLength = textRule.maxLength();
+
+        try {
+            MinMaxProvider minMaxProvider = (MinMaxProvider) textRule.minMaxProvider().newInstance();
+            minLength = minMaxProvider.getMin();
+            maxLength = minMaxProvider.getMax();
+            message = minMaxProvider.errorMessage();
+        } catch (InstantiationException e) {
+            e.printStackTrace();
+        } catch (IllegalAccessException e) {
+            e.printStackTrace();
+        } catch (ClassCastException e) {
+            e.printStackTrace();
+        }
+        if (minLength > 0) {
+            rules.add(Rules.minLength(null, minLength, textRule.trim()));
         }
-        if (textRule.maxLength() != Integer.MAX_VALUE) {
-            rules.add(Rules.maxLength(null, textRule.maxLength(), textRule.trim()));
+        if (maxLength != Integer.MAX_VALUE) {
+            rules.add(Rules.maxLength(null, maxLength, textRule.trim()));
         }
 
         Rule<?>[] ruleArray = new Rule<?>[rules.size()];
@@ -156,11 +181,21 @@
         Context context = view.getContext();
         int messageResId = regexRule.messageResId();
         String message = messageResId != 0 ? context.getString(messageResId) : regexRule.message();
-
+        String pattern = null;
         int patternResId = regexRule.patternResId();
-        String pattern = patternResId != 0 ? view.getContext().getString(patternResId) :
-            regexRule.pattern();
-
+        pattern = patternResId != 0 ? view.getContext().getString(patternResId) :
+                regexRule.pattern();
+        try {
+            PatternProvider patternProvider = (PatternProvider) regexRule.patternProvider().newInstance();
+            pattern = patternProvider.getPattern();
+            message = patternProvider.errorMessage();
+        } catch (InstantiationException e) {
+            e.printStackTrace();
+        } catch (IllegalAccessException e) {
+            e.printStackTrace();
+        }catch (ClassCastException e) {
+            e.printStackTrace();
+        }
         return Rules.regex(message, pattern, regexRule.trim());
     }
 
@@ -176,43 +211,71 @@
         List<Rule<?>> rules = new ArrayList<Rule<?>>();
         int messageResId = numberRule.messageResId();
         String message = messageResId != 0 ? view.getContext().getString(messageResId) :
-            numberRule.message();
+                numberRule.message();
 
         switch (numberRule.type()) {
-        case INTEGER: case LONG:
-            Rules.regex(null, Rules.REGEX_INTEGER, true); break;
-        case FLOAT: case DOUBLE:
-            Rules.regex(null, Rules.REGEX_DECIMAL, true); break;
+            case INTEGER:
+            case LONG:
+                Rules.regex(null, Rules.REGEX_INTEGER, true);
+                break;
+            case FLOAT:
+            case DOUBLE:
+                Rules.regex(null, Rules.REGEX_DECIMAL, true);
+                break;
         }
 
         if (numberRule.lt() != Double.MIN_VALUE) {
             String ltNumber = String.valueOf(numberRule.lt());
             double number = Double.parseDouble(ltNumber);
             switch (numberRule.type()) {
-            case INTEGER:   rules.add(Rules.lt(null, ((int) number)));   break;
-            case LONG:      rules.add(Rules.lt(null, ((long) number)));  break;
-            case FLOAT:     rules.add(Rules.lt(null, Float.parseFloat(ltNumber)));   break;
-            case DOUBLE:    rules.add(Rules.lt(null, Double.parseDouble(ltNumber))); break;
+                case INTEGER:
+                    rules.add(Rules.lt(null, ((int) number)));
+                    break;
+                case LONG:
+                    rules.add(Rules.lt(null, ((long) number)));
+                    break;
+                case FLOAT:
+                    rules.add(Rules.lt(null, Float.parseFloat(ltNumber)));
+                    break;
+                case DOUBLE:
+                    rules.add(Rules.lt(null, Double.parseDouble(ltNumber)));
+                    break;
             }
         }
         if (numberRule.gt() != Double.MAX_VALUE) {
             String gtNumber = String.valueOf(numberRule.gt());
             double number = Double.parseDouble(gtNumber);
             switch (numberRule.type()) {
-            case INTEGER:   rules.add(Rules.gt(null, ((int) number)));  break;
-            case LONG:      rules.add(Rules.gt(null, ((long) number))); break;
-            case FLOAT:     rules.add(Rules.gt(null, Float.parseFloat(gtNumber)));   break;
-            case DOUBLE:    rules.add(Rules.gt(null, Double.parseDouble(gtNumber))); break;
+                case INTEGER:
+                    rules.add(Rules.gt(null, ((int) number)));
+                    break;
+                case LONG:
+                    rules.add(Rules.gt(null, ((long) number)));
+                    break;
+                case FLOAT:
+                    rules.add(Rules.gt(null, Float.parseFloat(gtNumber)));
+                    break;
+                case DOUBLE:
+                    rules.add(Rules.gt(null, Double.parseDouble(gtNumber)));
+                    break;
             }
         }
         if (numberRule.eq() != Double.MAX_VALUE) {
             String eqNumber = String.valueOf(numberRule.eq());
             double number = Double.parseDouble(eqNumber);
             switch (numberRule.type()) {
-            case INTEGER:   rules.add(Rules.eq(null, ((int) number)));  break;
-            case LONG:      rules.add(Rules.eq(null, ((long) number))); break;
-            case FLOAT:     rules.add(Rules.eq(null, Float.parseFloat(eqNumber)));   break;
-            case DOUBLE:    rules.add(Rules.eq(null, Double.parseDouble(eqNumber))); break;
+                case INTEGER:
+                    rules.add(Rules.eq(null, ((int) number)));
+                    break;
+                case LONG:
+                    rules.add(Rules.eq(null, ((long) number)));
+                    break;
+                case FLOAT:
+                    rules.add(Rules.eq(null, Float.parseFloat(eqNumber)));
+                    break;
+                case DOUBLE:
+                    rules.add(Rules.eq(null, Double.parseDouble(eqNumber)));
+                    break;
             }
         }
 
@@ -230,13 +293,13 @@
 
         int messageResId = password.messageResId();
         String message = messageResId != 0 ? view.getContext().getString(messageResId) :
-            password.message();
+                password.message();
 
         return Rules.required(message, false);
     }
 
     private static Rule<TextView> getConfirmPasswordRule(Field field, View view,
-            ConfirmPassword confirmPassword, TextView passwordTextView) {
+                                                         ConfirmPassword confirmPassword, TextView passwordTextView) {
         if (!TextView.class.isAssignableFrom(view.getClass())) {
             Log.w(TAG, String.format(WARN_TEXT, field.getName(),
                     ConfirmPassword.class.getSimpleName()));
@@ -245,7 +308,7 @@
 
         int messageResId = confirmPassword.messageResId();
         String message = messageResId != 0 ? view.getContext().getString(messageResId) :
-            confirmPassword.message();
+                confirmPassword.message();
 
         return Rules.eq(message, passwordTextView);
     }
@@ -258,7 +321,7 @@
 
         int messageResId = email.messageResId();
         String message = messageResId != 0 ? view.getContext().getString(messageResId) :
-            email.message();
+                email.message();
 
         return Rules.or(message, Rules.eq(null, Rules.EMPTY_STRING),
                 Rules.regex(message, Rules.REGEX_EMAIL, true));
@@ -272,7 +335,7 @@
 
         int messageResId = ipAddress.messageResId();
         String message = messageResId != 0 ? view.getContext().getString(messageResId) :
-            ipAddress.message();
+                ipAddress.message();
 
         return Rules.or(message, Rules.eq(null, Rules.EMPTY_STRING),
                 Rules.regex(message, Rules.REGEX_IP_ADDRESS, true));
@@ -289,7 +352,7 @@
 
         int messageResId = checked.messageResId();
         String message = messageResId != 0 ? view.getContext().getString(messageResId) :
-            checked.message();
+                checked.message();
 
         return Rules.checked(message, checked.checked());
     }
diff --git a/src/com/mobsandgeeks/saripaar/MinMaxProvider.java b/src/com/mobsandgeeks/saripaar/MinMaxProvider.java
new file mode 100644
index 0000000..3c8ca0f
--- /dev/null
+++ b/src/com/mobsandgeeks/saripaar/MinMaxProvider.java
@@ -0,0 +1,12 @@
+package com.mobsandgeeks.saripaar;
+
+/**
+ * Created by maxchursin on 7/31/14.
+ */
+public interface MinMaxProvider {
+    int getMin();
+
+    int getMax();
+
+    String errorMessage();
+}
diff --git a/src/com/mobsandgeeks/saripaar/PatternProvider.java b/src/com/mobsandgeeks/saripaar/PatternProvider.java
new file mode 100644
index 0000000..486ee2b
--- /dev/null
+++ b/src/com/mobsandgeeks/saripaar/PatternProvider.java
@@ -0,0 +1,10 @@
+package com.mobsandgeeks.saripaar;
+
+/**
+ * Created by maxchursin on 7/31/14.
+ */
+public interface PatternProvider {
+    String getPattern();
+
+    String errorMessage();
+}
diff --git a/src/com/mobsandgeeks/saripaar/Rules.java b/src/com/mobsandgeeks/saripaar/Rules.java
index 65e3f81..e8b5dce 100644
--- a/src/com/mobsandgeeks/saripaar/Rules.java
+++ b/src/com/mobsandgeeks/saripaar/Rules.java
@@ -130,6 +130,16 @@ public boolean isValid(TextView textView) {
         };
     }
 
+    public static Rule<TextView> optional() {
+        return new Rule<TextView>(null) {
+
+            @Override
+            public boolean isValid(TextView textView) {
+                return !TextUtils.isEmpty(getText(textView, false));
+            }
+        };
+    }
+
     /**
      * Checks if the {@link TextView} or its subclass {@link View}'s displayed text matches the
      * given regular expression.
diff --git a/src/com/mobsandgeeks/saripaar/Validator.java b/src/com/mobsandgeeks/saripaar/Validator.java
index faadbb8..bb245ce 100644
--- a/src/com/mobsandgeeks/saripaar/Validator.java
+++ b/src/com/mobsandgeeks/saripaar/Validator.java
@@ -14,7 +14,11 @@
 
 package com.mobsandgeeks.saripaar;
 
+import android.annotation.TargetApi;
+import android.app.Activity;
 import android.os.AsyncTask;
+import android.os.Build;
+import android.support.v4.app.Fragment;
 import android.util.Log;
 import android.view.View;
 import android.widget.TextView;
@@ -23,7 +27,9 @@
 import com.mobsandgeeks.saripaar.annotation.ConfirmPassword;
 import com.mobsandgeeks.saripaar.annotation.Email;
 import com.mobsandgeeks.saripaar.annotation.IpAddress;
+import com.mobsandgeeks.saripaar.annotation.MatchServerErrors;
 import com.mobsandgeeks.saripaar.annotation.NumberRule;
+import com.mobsandgeeks.saripaar.annotation.Optional;
 import com.mobsandgeeks.saripaar.annotation.Password;
 import com.mobsandgeeks.saripaar.annotation.Regex;
 import com.mobsandgeeks.saripaar.annotation.Required;
@@ -33,6 +39,7 @@
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Field;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.HashMap;
@@ -50,10 +57,11 @@
     static final boolean DEBUG = false;
 
     private Object mController;
-    private boolean mAnnotationsProcessed;
-    private List<ViewRulePair> mViewsAndRules;
-    private Map<String, Object> mProperties;
-    private AsyncTask<Void, Void, ViewRulePair> mAsyncValidationTask;
+    private volatile boolean mAnnotationsProcessed;
+    private List<ViewRulePair> validationForm = new ArrayList<ViewRulePair>();
+    private List<ViewErrorKeyPair> serverValidationForm = new ArrayList<ViewErrorKeyPair>();
+    private Map<String, Object> mProperties = new HashMap<String, Object>();
+    private AsyncTask<Void, Void, List<ViewErrorPair>> mAsyncValidationTask;
     private ValidationListener mValidationListener;
 
     /**
@@ -61,23 +69,77 @@
      */
     private Validator() {
         mAnnotationsProcessed = false;
-        mViewsAndRules = new ArrayList<Validator.ViewRulePair>();
-        mProperties = new HashMap<String, Object>();
     }
 
-    /**
-     * Creates a new {@link Validator}.
-     *
-     * @param controller The instance that holds references to the Views that are
-     * being validated. Usually an {@code Activity} or a {@code Fragment}. Also accepts
-     * controller instances that have annotated {@code View} references.
-     */
-    public Validator(Object controller) {
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+    public <F extends android.app.Fragment> Validator(F fragment) {
+        this();
+        if (fragment == null) {
+            throw new IllegalArgumentException("'controller' cannot be null");
+        }
+        mController = fragment;
+        initForm();
+
+    }
+
+    public <F extends Fragment> Validator(F fragment) {
+        this();
+        if (fragment == null) {
+            throw new IllegalArgumentException("'controller' cannot be null");
+        }
+        mController = fragment;
+        initForm();
+    }
+
+    public <A extends Activity> Validator(A activity) {
         this();
-        if (controller == null) {
+        if (activity == null) {
             throw new IllegalArgumentException("'controller' cannot be null");
         }
-        mController = controller;
+        mController = activity;
+        initForm();
+    }
+
+    private void initForm() {
+        new AsyncTask<Void, Void, Void>() {
+
+            @Override
+            protected void onPreExecute() {
+                mAnnotationsProcessed = false;
+            }
+
+            @Override
+            protected Void doInBackground(Void... params) {
+                createRulesFromAnnotations(getSaripaarAnnotatedFields());
+                return null;
+            }
+
+            @Override
+            protected void onPostExecute(Void aVoid) {
+                mAnnotationsProcessed = true;
+                if (mValidationListener != null) {
+                    mValidationListener.onFormPrepared();
+                }
+            }
+        }.execute();
+    }
+
+    //Bundle[{email=has already been taken}]
+    //Bundle[{email=has already been taken, password=is too short (minimum is 6 characters)}]
+    public void mapServerErrors(Map<String, String> possibleField) {
+        List<ViewErrorPair> list = new ArrayList<ViewErrorPair>();
+        if (possibleField != null) {
+            for (String key : possibleField.keySet()) {
+                for (ViewErrorKeyPair viewErrorKeyPair : serverValidationForm) {
+                    if (viewErrorKeyPair.errorKeys.contains(key)) {
+                        list.add(new ViewErrorPair(viewErrorKeyPair.view, possibleField.get(key)));
+                    }
+                }
+            }
+        }
+        if (mValidationListener != null) {
+            mValidationListener.onServerMappingFinish(list);
+        }
     }
 
     /**
@@ -85,6 +147,8 @@ public Validator(Object controller) {
      */
     public interface ValidationListener {
 
+        public void onFormPrepared();
+
         /**
          * Called when all the {@link Rule}s added to this Validator are valid.
          */
@@ -92,11 +156,13 @@ public Validator(Object controller) {
 
         /**
          * Called if any of the {@link Rule}s fail.
-         *
-         * @param failedView The {@link View} that did not pass validation.
-         * @param failedRule The failed {@link Rule} associated with the {@link View}.
          */
-        public void onValidationFailed(View failedView, Rule<?> failedRule);
+        public void onValidationFailed(List<ViewErrorPair> failedResults);
+
+        /**
+         * Called after server return error and json mapped to fields
+         */
+        public void onServerMappingFinish(List<ViewErrorPair> mappingResults);
     }
 
     /**
@@ -104,23 +170,21 @@ public Validator(Object controller) {
      *
      * @param view The {@link View} to be validated.
      * @param rule The {@link Rule} associated with the view.
-     *
      * @throws IllegalArgumentException If {@code rule} is {@code null}.
      */
-    public void put(View view, Rule<?> rule) {
+    public void put(View view, Rule rule) {
         if (rule == null) {
             throw new IllegalArgumentException("'rule' cannot be null");
         }
 
-        mViewsAndRules.add(new ViewRulePair(view, rule));
+        validationForm.add(new ViewRulePair(view, Collections.singletonList(rule)));
     }
 
     /**
      * Convenience method for adding multiple {@link Rule}s for a single {@link View}.
      *
-     * @param view The {@link View} to be validated.
+     * @param view  The {@link View} to be validated.
      * @param rules {@link List} of {@link Rule}s associated with the view.
-     *
      * @throws IllegalArgumentException If {@code rules} is {@code null}.
      */
     public void put(View view, List<Rule<?>> rules) {
@@ -152,12 +216,11 @@ public synchronized void validate() {
             throw new IllegalStateException("Set a " + ValidationListener.class.getSimpleName() +
                     " before attempting to validate.");
         }
-
-        ViewRulePair failedViewRulePair = validateAllRules();
-        if (failedViewRulePair == null) {
-            mValidationListener.onValidationSucceeded();
+        List<ViewErrorPair> failedViewRulePair = validateAllRules();
+        if (failedViewRulePair != null && failedViewRulePair.size() > 0 || !mAnnotationsProcessed) {
+            mValidationListener.onValidationFailed(failedViewRulePair);
         } else {
-            mValidationListener.onValidationFailed(failedViewRulePair.view, failedViewRulePair.rule);
+            mValidationListener.onValidationSucceeded();
         }
     }
 
@@ -180,19 +243,19 @@ public void validateAsync() {
         }
 
         // Start a new one ;)
-        mAsyncValidationTask = new AsyncTask<Void, Void, ViewRulePair>() {
+        mAsyncValidationTask = new AsyncTask<Void, Void, List<ViewErrorPair>>() {
 
             @Override
-            protected ViewRulePair doInBackground(Void... params) {
+            protected List<ViewErrorPair> doInBackground(Void... params) {
                 return validateAllRules();
             }
 
             @Override
-            protected void onPostExecute(ViewRulePair pair) {
-                if (pair == null) {
-                    mValidationListener.onValidationSucceeded();
+            protected void onPostExecute(List<ViewErrorPair> pair) {
+                if (pair != null && pair.size() > 0 || !mAnnotationsProcessed) {
+                    mValidationListener.onValidationFailed(pair);
                 } else {
-                    mValidationListener.onValidationFailed(pair.view, pair.rule);
+                    mValidationListener.onValidationSucceeded();
                 }
 
                 mAsyncValidationTask = null;
@@ -255,9 +318,8 @@ public void setValidationListener(ValidationListener validationListener) {
     /**
      * Updates a property value if it exists, else creates a new one.
      *
-     * @param name The property name.
+     * @param name  The property name.
      * @param value Value of the property.
-     *
      * @throws IllegalArgumentException If {@code name} is {@code null}.
      */
     public void setProperty(String name, Object value) {
@@ -272,10 +334,8 @@ public void setProperty(String name, Object value) {
      * Retrieves the value of the given property.
      *
      * @param name The property name.
-     *
-     * @throws IllegalArgumentException If {@code name} is {@code null}.
-     *
      * @return Value of the property or {@code null} if the property does not exist.
+     * @throws IllegalArgumentException If {@code name} is {@code null}.
      */
     public Object getProperty(String name) {
         if (name == null) {
@@ -289,7 +349,6 @@ public Object getProperty(String name) {
      * Removes the property from this Validator.
      *
      * @param name The property name.
-     *
      * @return The value of the removed property or {@code null} if the property was not found.
      */
     public Object removeProperty(String name) {
@@ -300,7 +359,6 @@ public Object removeProperty(String name) {
      * Checks if the specified property exists in this Validator.
      *
      * @param name The property name.
-     *
      * @return True if the property exists.
      */
     public boolean containsProperty(String name) {
@@ -316,6 +374,7 @@ public void removeAllProperties() {
 
     /**
      * Removes all the rules for the matching {@link View}
+     *
      * @param view The {@code View} whose rules must be removed.
      */
     public void removeRulesFor(View view) {
@@ -324,10 +383,10 @@ public void removeRulesFor(View view) {
         }
 
         int index = 0;
-        while (index < mViewsAndRules.size()) {
-            ViewRulePair pair = mViewsAndRules.get(index);
-            if (pair.view == view) {
-                mViewsAndRules.remove(index);
+        while (index < validationForm.size()) {
+            ViewRulePair pair = validationForm.get(index);
+            if (pair.getView() == view) {
+                validationForm.remove(index);
                 continue;
             }
 
@@ -339,99 +398,108 @@ public void removeRulesFor(View view) {
      * Validates all rules added to this Validator.
      *
      * @return {@code null} if all {@code Rule}s are valid, else returns the failed
-     *          {@code ViewRulePair}.
+     * {@code ViewRulePair}.
      */
-    private ViewRulePair validateAllRules() {
-        if (!mAnnotationsProcessed) {
-            createRulesFromAnnotations(getSaripaarAnnotatedFields());
-            mAnnotationsProcessed = true;
-        }
-
-        if (mViewsAndRules.size() == 0) {
+    private List<ViewErrorPair> validateAllRules() {
+        if (!mAnnotationsProcessed || validationForm.size() == 0) {
             Log.i(TAG, "No rules found. Passing validation by default.");
             return null;
         }
-
-        ViewRulePair failedViewRulePair = null;
-        for (ViewRulePair pair : mViewsAndRules) {
+        List<ViewErrorPair> list = new ArrayList<ViewErrorPair>();
+        for (ViewRulePair pair : validationForm) {
             if (pair == null) continue;
 
             // Validate views only if they are visible and enabled
-            if (pair.view != null) {
-                if (!pair.view.isShown() || !pair.view.isEnabled()) continue;
+            View view = pair.getView();
+            if (view != null) {
+                if (view.getVisibility() != View.VISIBLE || !view.isEnabled()) continue;
             }
-
-            if (!pair.rule.isValid(pair.view)) {
-                failedViewRulePair = pair;
-                break;
+            for (Rule rule : pair.getRules()) {
+                if (!rule.isValid(view)) {
+                    if (rule.getFailureMessage() != null) {
+                        list.add(new ViewErrorPair(view, rule.getFailureMessage()));
+                    }
+                    break;
+                }
             }
         }
 
-        return failedViewRulePair;
+        return list;
     }
 
-    private void createRulesFromAnnotations(List<AnnotationFieldPair> annotationFieldPairs) {
+    private void createRulesFromAnnotations(List<FieldAnnotationsPair> fieldAnnotationsPairs) {
         TextView passwordTextView = null;
-        TextView confirmPasswordTextView = null;
-
-        for (AnnotationFieldPair pair : annotationFieldPairs) {
-            // Password
-            if (pair.annotation.annotationType().equals(Password.class)) {
-                if (passwordTextView == null) {
+        int passwordViewCount = 0;
+        int confirmPasswordViewCount = 0;
+        for (FieldAnnotationsPair pair : fieldAnnotationsPairs) {
+            for (Annotation annotation : pair.annotations) {
+                if (annotation.annotationType().equals(Password.class)) {
                     passwordTextView = (TextView) getView(pair.field);
-                } else {
-                    throw new IllegalStateException("You cannot annotate " +
-                            "two fields in the same Activity with @Password.");
-                }
-            }
+                    passwordViewCount++;
 
-            // Confirm password
-            if (pair.annotation.annotationType().equals(ConfirmPassword.class)) {
-                if (passwordTextView == null) {
-                    throw new IllegalStateException("A @Password annotated field is required " +
-                            "before you can use @ConfirmPassword.");
-                } else if (confirmPasswordTextView != null) {
-                    throw new IllegalStateException("You cannot annotate " +
-                            "two fields in the same Activity with @ConfirmPassword.");
-                } else if (confirmPasswordTextView == null) {
-                    confirmPasswordTextView = (TextView) getView(pair.field);
+                }
+                if (annotation.annotationType().equals(ConfirmPassword.class)) {
+                    confirmPasswordViewCount++;
                 }
             }
+        }
 
-            // Others
-            ViewRulePair viewRulePair = null;
-            if (pair.annotation.annotationType().equals(ConfirmPassword.class)) {
-                viewRulePair = getViewAndRule(pair.field, pair.annotation, passwordTextView);
-            } else {
-                viewRulePair = getViewAndRule(pair.field, pair.annotation);
+        if (passwordViewCount > 1) {
+            throw new IllegalStateException("You cannot annotate " +
+                    "two fields of the same form with @Password.");
+        }
+        if (confirmPasswordViewCount > 1) {
+            throw new IllegalStateException("You cannot annotate " +
+                    "two fields of the same form with @ConfirmPassword.");
+        }
+        if (confirmPasswordViewCount > 0 && passwordViewCount == 0) {
+            throw new IllegalStateException("A @Password annotated field is required " +
+                    "before you can use @ConfirmPassword.");
+        }
+
+        for (FieldAnnotationsPair pair : fieldAnnotationsPairs) {
+            View view = getView(pair.field);
+            if (view == null) {
+                Log.w(TAG, String.format("Your %s - %s is null. Please check your field assignment(s).",
+                        pair.field.getType().getSimpleName(), pair.field.getName()));
+                continue;
             }
-            if (viewRulePair != null) {
-                if (DEBUG) {
-                    Log.d(TAG, String.format("Added @%s rule for %s.",
-                            pair.annotation.annotationType().getSimpleName(),
-                            pair.field.getName()));
+            List<Rule> rules = new ArrayList<Rule>();
+            for (Annotation annotation : pair.annotations) {
+                Rule<?> rule = null;
+                Class<?> annotationType = annotation.annotationType();
+                if (annotationType.equals(ConfirmPassword.class)) {
+                    rule = AnnotationRuleFactory.getRule(pair.field, view, annotation, passwordTextView);
+                } else if (annotationType.equals(MatchServerErrors.class)) {
+                    serverValidationForm.add(getViewErrorKeyPair(pair.field, annotation));
+                } else {
+                    rule = AnnotationRuleFactory.getRule(pair.field, view, annotation);
+                }
+                if (rule != null) {
+                    rules.add(rule);
                 }
-                mViewsAndRules.add(viewRulePair);
             }
+            validationForm.add(new ViewRulePair(view, rules));
         }
     }
 
-    private ViewRulePair getViewAndRule(Field field, Annotation annotation, Object... params) {
+    private ViewErrorKeyPair getViewErrorKeyPair(Field field, Annotation annotation) {
         View view = getView(field);
         if (view == null) {
             Log.w(TAG, String.format("Your %s - %s is null. Please check your field assignment(s).",
                     field.getType().getSimpleName(), field.getName()));
             return null;
         }
-
-        Rule<?> rule = null;
-        if (params != null && params.length > 0) {
-            rule = AnnotationRuleFactory.getRule(field, view, annotation, params);
-        } else {
-            rule = AnnotationRuleFactory.getRule(field, view, annotation);
+        Class<?> annotationType = annotation.annotationType();
+        if (annotationType.equals(MatchServerErrors.class)) {
+            if (!TextView.class.isAssignableFrom(view.getClass())) {
+                //Log.w(TAG, String.format(WARN_TEXT, field.getName(), Regex.class.getSimpleName()));
+                return null;
+            }
+            List<String> errorKeys = Arrays.asList(((MatchServerErrors) annotation).value());
+            return new ViewErrorKeyPair(view, errorKeys);
         }
-
-        return rule != null ? new ViewRulePair(view, rule) : null;
+        return null;
     }
 
     private View getView(Field field) {
@@ -448,12 +516,13 @@ private View getView(Field field) {
         return null;
     }
 
-    private List<AnnotationFieldPair> getSaripaarAnnotatedFields() {
-        List<AnnotationFieldPair> annotationFieldPairs = new ArrayList<AnnotationFieldPair>();
+    private List<FieldAnnotationsPair> getSaripaarAnnotatedFields() {
+        List<FieldAnnotationsPair> fieldAnnotationsPairs = new ArrayList<FieldAnnotationsPair>();
         List<Field> fieldsWithAnnotations = getViewFieldsWithAnnotations();
 
         for (Field field : fieldsWithAnnotations) {
             Annotation[] annotations = field.getAnnotations();
+            List<Annotation> annotationsList = new ArrayList<Annotation>();
             for (Annotation annotation : annotations) {
                 if (isSaripaarAnnotation(annotation)) {
                     if (DEBUG) {
@@ -461,14 +530,14 @@ private View getView(Field field) {
                                 field.getType().getSimpleName(), field.getName(),
                                 annotation.annotationType().getSimpleName()));
                     }
-                    annotationFieldPairs.add(new AnnotationFieldPair(annotation, field));
+                    annotationsList.add(annotation);
                 }
             }
-        }
-
-        Collections.sort(annotationFieldPairs, new AnnotationFieldPairCompartor());
 
-        return annotationFieldPairs;
+            Collections.sort(annotationsList, new AnnotationComparator());
+            fieldAnnotationsPairs.add(new FieldAnnotationsPair(field, annotationsList));
+        }
+        return fieldAnnotationsPairs;
     }
 
     private List<Field> getViewFieldsWithAnnotations() {
@@ -528,36 +597,38 @@ private boolean isSaripaarAnnotation(Annotation annotation) {
                 annotationType.equals(Regex.class) ||
                 annotationType.equals(Required.class) ||
                 annotationType.equals(Select.class) ||
-                annotationType.equals(TextRule.class);
+                annotationType.equals(TextRule.class) ||
+                annotationType.equals(Optional.class) ||
+                annotationType.equals(MatchServerErrors.class);
     }
 
-    private class ViewRulePair {
+    private class ViewErrorKeyPair {
         public View view;
-        public Rule rule;
+        public List<String> errorKeys;
 
-        public ViewRulePair(View view, Rule<?> rule) {
+        private ViewErrorKeyPair(View view, List<String> errorKeys) {
             this.view = view;
-            this.rule = rule;
+            this.errorKeys = errorKeys;
         }
     }
 
-    private class AnnotationFieldPair {
-        public Annotation annotation;
+    private class FieldAnnotationsPair {
         public Field field;
+        public List<Annotation> annotations;
 
-        public AnnotationFieldPair(Annotation annotation, Field field) {
-            this.annotation = annotation;
+        public FieldAnnotationsPair(Field field, List<Annotation> annotations) {
+            this.annotations = annotations;
             this.field = field;
         }
     }
 
-    private class AnnotationFieldPairCompartor implements Comparator<AnnotationFieldPair> {
+    private class AnnotationComparator implements Comparator<Annotation> {
 
         @Override
-        public int compare(AnnotationFieldPair lhs, AnnotationFieldPair rhs) {
-            int lhsOrder = getAnnotationOrder(lhs.annotation);
-            int rhsOrder = getAnnotationOrder(rhs.annotation);
-            return lhsOrder < rhsOrder ? -1 : lhsOrder == rhsOrder ? 0 : 1;
+        public int compare(Annotation lhs, Annotation rhs) {
+            int lhsOrder = getAnnotationOrder(lhs);
+            int rhsOrder = getAnnotationOrder(rhs);
+            return lhsOrder < rhsOrder ? 1 : lhsOrder == rhsOrder ? 0 : -1;
         }
 
         private int getAnnotationOrder(Annotation annotation) {
@@ -592,11 +663,12 @@ private int getAnnotationOrder(Annotation annotation) {
             } else if (annotatedClass.equals(TextRule.class)) {
                 return ((TextRule) annotation).order();
 
+            } else if (annotatedClass.equals(Optional.class)) {
+                return ((Optional) annotation).order();
+
             } else {
-                throw new IllegalArgumentException(String.format("%s is not a Saripaar annotation",
-                        annotatedClass.getName()));
+                return Integer.MIN_VALUE;
             }
         }
     }
-
 }
diff --git a/src/com/mobsandgeeks/saripaar/ViewErrorPair.java b/src/com/mobsandgeeks/saripaar/ViewErrorPair.java
new file mode 100644
index 0000000..2f5985b
--- /dev/null
+++ b/src/com/mobsandgeeks/saripaar/ViewErrorPair.java
@@ -0,0 +1,32 @@
+package com.mobsandgeeks.saripaar;
+
+import android.view.View;
+
+/**
+ * Created by maxchursin on 7/31/14.
+ */
+public class ViewErrorPair {
+    private View view;
+    private String errors;
+
+    public ViewErrorPair(View view, String errors) {
+        this.view = view;
+        this.errors = errors;
+    }
+
+    public View getView() {
+        return view;
+    }
+
+    public void setView(View view) {
+        this.view = view;
+    }
+
+    public String getErrors() {
+        return errors;
+    }
+
+    public void setErrors(String errors) {
+        this.errors = errors;
+    }
+}
diff --git a/src/com/mobsandgeeks/saripaar/ViewRulePair.java b/src/com/mobsandgeeks/saripaar/ViewRulePair.java
new file mode 100644
index 0000000..d959925
--- /dev/null
+++ b/src/com/mobsandgeeks/saripaar/ViewRulePair.java
@@ -0,0 +1,35 @@
+package com.mobsandgeeks.saripaar;
+
+import android.view.View;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Created by maxchursin on 7/31/14.
+ */
+public class ViewRulePair {
+    private View view;
+    private List<Rule> rules = new ArrayList<Rule>();
+
+    public ViewRulePair(View view, List<Rule> rules) {
+        this.setView(view);
+        this.setRules(rules);
+    }
+
+    public View getView() {
+        return view;
+    }
+
+    public void setView(View view) {
+        this.view = view;
+    }
+
+    public List<Rule> getRules() {
+        return rules;
+    }
+
+    public void setRules(List<Rule> rules) {
+        this.rules = rules;
+    }
+}
diff --git a/src/com/mobsandgeeks/saripaar/annotation/Checked.java b/src/com/mobsandgeeks/saripaar/annotation/Checked.java
index e15ae40..8a438a4 100644
--- a/src/com/mobsandgeeks/saripaar/annotation/Checked.java
+++ b/src/com/mobsandgeeks/saripaar/annotation/Checked.java
@@ -16,13 +16,13 @@
 
 import android.widget.Checkable;
 
+import com.mobsandgeeks.saripaar.Rules;
+
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
 
-import com.mobsandgeeks.saripaar.Rules;
-
 /**
  * Annotation works with {@code Views} that implement the {@link Checkable} interface.
  *
@@ -31,8 +31,11 @@
 @Target(ElementType.FIELD)
 @Retention(RetentionPolicy.RUNTIME)
 public @interface Checked {
-    public int order();
-    public boolean checked()    default true;
-    public String message()     default Rules.EMPTY_STRING;
-    public int messageResId()   default 0;
+    public int order() default 0;
+
+    public boolean checked() default true;
+
+    public String message() default Rules.EMPTY_STRING;
+
+    public int messageResId() default 0;
 }
diff --git a/src/com/mobsandgeeks/saripaar/annotation/ConfirmPassword.java b/src/com/mobsandgeeks/saripaar/annotation/ConfirmPassword.java
index 407387e..0692aba 100644
--- a/src/com/mobsandgeeks/saripaar/annotation/ConfirmPassword.java
+++ b/src/com/mobsandgeeks/saripaar/annotation/ConfirmPassword.java
@@ -20,7 +20,7 @@
 import java.lang.annotation.Target;
 
 /**
- * Used along with the {@link Password} annotation. This annotation makes sure that the
+ * Used along with the {@link Password} annotations. This annotations makes sure that the
  * contents of the confirm password {@code EditText} matches the contents of the password
  * {@code EditText}.
  *
@@ -29,7 +29,9 @@
 @Target(ElementType.FIELD)
 @Retention(RetentionPolicy.RUNTIME)
 public @interface ConfirmPassword {
-    public int order();
-    public String message()     default "Passwords don't match";
-    public int messageResId()   default 0;
+    public int order() default 0;
+
+    public String message() default "Passwords don't match";
+
+    public int messageResId() default 0;
 }
diff --git a/src/com/mobsandgeeks/saripaar/annotation/Email.java b/src/com/mobsandgeeks/saripaar/annotation/Email.java
index 675d79c..fd03a6d 100644
--- a/src/com/mobsandgeeks/saripaar/annotation/Email.java
+++ b/src/com/mobsandgeeks/saripaar/annotation/Email.java
@@ -14,13 +14,13 @@
 
 package com.mobsandgeeks.saripaar.annotation;
 
+import com.mobsandgeeks.saripaar.Rules;
+
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
 
-import com.mobsandgeeks.saripaar.Rules;
-
 /**
  * Enforces email validation on the annotated {@code View}.
  *
@@ -29,7 +29,9 @@
 @Target(ElementType.FIELD)
 @Retention(RetentionPolicy.RUNTIME)
 public @interface Email {
-    public int order();
-    public String message()     default Rules.EMPTY_STRING;
-    public int messageResId()   default 0;
+    public int order() default 0;
+
+    public String message() default Rules.EMPTY_STRING;
+
+    public int messageResId() default 0;
 }
diff --git a/src/com/mobsandgeeks/saripaar/annotation/IpAddress.java b/src/com/mobsandgeeks/saripaar/annotation/IpAddress.java
index dfeb005..867d54e 100644
--- a/src/com/mobsandgeeks/saripaar/annotation/IpAddress.java
+++ b/src/com/mobsandgeeks/saripaar/annotation/IpAddress.java
@@ -14,13 +14,13 @@
 
 package com.mobsandgeeks.saripaar.annotation;
 
+import com.mobsandgeeks.saripaar.Rules;
+
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
 
-import com.mobsandgeeks.saripaar.Rules;
-
 /**
  * Allows only valid IP Addresses on the annotated {@code View}.
  *
@@ -29,7 +29,9 @@
 @Target(ElementType.FIELD)
 @Retention(RetentionPolicy.RUNTIME)
 public @interface IpAddress {
-    public int order();
-    public String message()     default Rules.EMPTY_STRING;
-    public int messageResId()   default 0;
+    public int order() default 0;
+
+    public String message() default Rules.EMPTY_STRING;
+
+    public int messageResId() default 0;
 }
diff --git a/src/com/mobsandgeeks/saripaar/annotation/MatchServerErrors.java b/src/com/mobsandgeeks/saripaar/annotation/MatchServerErrors.java
new file mode 100644
index 0000000..b4c1f47
--- /dev/null
+++ b/src/com/mobsandgeeks/saripaar/annotation/MatchServerErrors.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2012 Mobs and Geeks
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file 
+ * except in compliance with the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the 
+ * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, 
+ * either express or implied. See the License for the specific language governing permissions and 
+ * limitations under the License.
+ */
+
+package com.mobsandgeeks.saripaar.annotation;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Specifies constraints such as min length, max length and trim on textual data contained
+ * in {@code View}s.
+ *
+ * @author Ragunath Jawahar <rj@mobsandgeeks.com>
+ */
+@Target(ElementType.FIELD)
+@Retention(RetentionPolicy.RUNTIME)
+public @interface MatchServerErrors {
+    public String[] value();
+}
diff --git a/src/com/mobsandgeeks/saripaar/annotation/NumberRule.java b/src/com/mobsandgeeks/saripaar/annotation/NumberRule.java
index 3059e49..d68835b 100644
--- a/src/com/mobsandgeeks/saripaar/annotation/NumberRule.java
+++ b/src/com/mobsandgeeks/saripaar/annotation/NumberRule.java
@@ -14,29 +14,35 @@
 
 package com.mobsandgeeks.saripaar.annotation;
 
+import com.mobsandgeeks.saripaar.Rules;
+
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
 
-import com.mobsandgeeks.saripaar.Rules;
-
 /**
- * Number rule annotation. Allows a specific primitive type contained in {@link NumberType}.
- * Additional options such as greater than (>), less than (<) and equals (==) are available. 
+ * Number rule annotations. Allows a specific primitive type contained in {@link NumberType}.
+ * Additional options such as greater than (>), less than (<) and equals (==) are available.
  *
  * @author Ragunath Jawahar <rj@mobsandgeeks.com>
  */
 @Target(ElementType.FIELD)
 @Retention(RetentionPolicy.RUNTIME)
 public @interface NumberRule {
-    public int order();
+    public int order() default 0;
+
     public NumberType type();
-    public double gt()          default Double.MAX_VALUE;
-    public double lt()          default Double.MIN_VALUE;
-    public double eq()          default Double.MAX_VALUE;
-    public String message()     default Rules.EMPTY_STRING;
-    public int messageResId()   default 0;
+
+    public double gt() default Double.MAX_VALUE;
+
+    public double lt() default Double.MIN_VALUE;
+
+    public double eq() default Double.MAX_VALUE;
+
+    public String message() default Rules.EMPTY_STRING;
+
+    public int messageResId() default 0;
 
     public enum NumberType {
         INTEGER, LONG, FLOAT, DOUBLE
diff --git a/src/com/mobsandgeeks/saripaar/annotation/Optional.java b/src/com/mobsandgeeks/saripaar/annotation/Optional.java
new file mode 100644
index 0000000..ad76c2d
--- /dev/null
+++ b/src/com/mobsandgeeks/saripaar/annotation/Optional.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2012 Mobs and Geeks
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file 
+ * except in compliance with the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the 
+ * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, 
+ * either express or implied. See the License for the specific language governing permissions and 
+ * limitations under the License.
+ */
+
+package com.mobsandgeeks.saripaar.annotation;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * When used, the field cannot be empty.
+ *
+ * @author Ragunath Jawahar <rj@mobsandgeeks.com>
+ */
+@Target(ElementType.FIELD)
+@Retention(RetentionPolicy.RUNTIME)
+public @interface Optional {
+    public int order() default Integer.MAX_VALUE;
+}
diff --git a/src/com/mobsandgeeks/saripaar/annotation/Password.java b/src/com/mobsandgeeks/saripaar/annotation/Password.java
index f2275ad..a35daa5 100644
--- a/src/com/mobsandgeeks/saripaar/annotation/Password.java
+++ b/src/com/mobsandgeeks/saripaar/annotation/Password.java
@@ -27,7 +27,9 @@
 @Target(ElementType.FIELD)
 @Retention(RetentionPolicy.RUNTIME)
 public @interface Password {
-    public int order();
-    public String message()     default "Password is required";
-    public int messageResId()   default 0;
+    public int order() default 0;
+
+    public String message() default "Password is required";
+
+    public int messageResId() default 0;
 }
diff --git a/src/com/mobsandgeeks/saripaar/annotation/Regex.java b/src/com/mobsandgeeks/saripaar/annotation/Regex.java
index e549b3d..1e8a0e9 100644
--- a/src/com/mobsandgeeks/saripaar/annotation/Regex.java
+++ b/src/com/mobsandgeeks/saripaar/annotation/Regex.java
@@ -26,13 +26,20 @@
  *
  * @author Ragunath Jawahar <rj@mobsandgeeks.com>
  */
-@Target(ElementType.FIELD)
+@Target({ElementType.FIELD})
 @Retention(RetentionPolicy.RUNTIME)
 public @interface Regex {
-    public int order();
-    public String pattern()     default ".";
-    public int patternResId()   default 0;
-    public boolean trim()       default true;
-    public String message()     default Rules.EMPTY_STRING;
-    public int messageResId()   default 0;
+    public int order() default 0;
+
+    public String pattern() default ".";
+
+    public int patternResId() default 0;
+
+    public Class patternProvider() default Void.class;
+
+    public boolean trim() default true;
+
+    public String message() default Rules.EMPTY_STRING;
+
+    public int messageResId() default 0;
 }
diff --git a/src/com/mobsandgeeks/saripaar/annotation/Required.java b/src/com/mobsandgeeks/saripaar/annotation/Required.java
index 7f075b2..3a3d9bf 100644
--- a/src/com/mobsandgeeks/saripaar/annotation/Required.java
+++ b/src/com/mobsandgeeks/saripaar/annotation/Required.java
@@ -27,8 +27,11 @@
 @Target(ElementType.FIELD)
 @Retention(RetentionPolicy.RUNTIME)
 public @interface Required {
-    public int order();
-    public boolean trim()       default true;
-    public String message()     default "This field is required.";
-    public int messageResId()   default 0;
+    public int order() default Integer.MAX_VALUE;
+
+    public boolean trim() default true;
+
+    public String message() default "This field is required.";
+
+    public int messageResId() default 0;
 }
diff --git a/src/com/mobsandgeeks/saripaar/annotation/Select.java b/src/com/mobsandgeeks/saripaar/annotation/Select.java
index 07c0bfe..a2a7cb5 100644
--- a/src/com/mobsandgeeks/saripaar/annotation/Select.java
+++ b/src/com/mobsandgeeks/saripaar/annotation/Select.java
@@ -23,14 +23,17 @@
 
 /**
  * Used on a {@link Spinner} to check if the selected item is not the default.
- * 
+ *
  * @author Muhammad Hewedy
  */
 @Target(ElementType.FIELD)
 @Retention(RetentionPolicy.RUNTIME)
 public @interface Select {
-    public int order();
-    public int defaultSelection()   default 0;
-    public String message()         default "Select an item.";
-    public int messageResId()       default 0;
+    public int order() default 0;
+
+    public int defaultSelection() default 0;
+
+    public String message() default "Select an item.";
+
+    public int messageResId() default 0;
 }
diff --git a/src/com/mobsandgeeks/saripaar/annotation/TextRule.java b/src/com/mobsandgeeks/saripaar/annotation/TextRule.java
index e896a98..ccdddcc 100644
--- a/src/com/mobsandgeeks/saripaar/annotation/TextRule.java
+++ b/src/com/mobsandgeeks/saripaar/annotation/TextRule.java
@@ -14,13 +14,13 @@
 
 package com.mobsandgeeks.saripaar.annotation;
 
+import com.mobsandgeeks.saripaar.Rules;
+
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
 
-import com.mobsandgeeks.saripaar.Rules;
-
 /**
  * Specifies constraints such as min length, max length and trim on textual data contained
  * in {@code View}s.
@@ -30,10 +30,17 @@
 @Target(ElementType.FIELD)
 @Retention(RetentionPolicy.RUNTIME)
 public @interface TextRule {
-    public int order();
-    public int minLength()      default 0;
-    public int maxLength()      default Integer.MAX_VALUE;
-    public boolean trim()       default true;
-    public String message()     default Rules.EMPTY_STRING;
-    public int messageResId()   default 0;
+    public int order() default 0;
+
+    public Class minMaxProvider() default Void.class;
+
+    public int minLength() default 0;
+
+    public int maxLength() default Integer.MAX_VALUE;
+
+    public boolean trim() default true;
+
+    public String message() default Rules.EMPTY_STRING;
+
+    public int messageResId() default 0;
 }
diff --git a/tests/java/com/mobsandgeeks/saripaar/BaseTestActivity.java b/tests/java/com/mobsandgeeks/saripaar/BaseTestActivity.java
new file mode 100644
index 0000000..998d195
--- /dev/null
+++ b/tests/java/com/mobsandgeeks/saripaar/BaseTestActivity.java
@@ -0,0 +1,44 @@
+package com.mobsandgeeks.saripaar;
+
+import android.app.Activity;
+import android.os.Bundle;
+import android.view.ViewGroup;
+import android.widget.LinearLayout;
+import android.widget.TextView;
+
+import com.mobsandgeeks.saripaar.annotation.Required;
+
+/**
+ * Created by maxchursin on 8/3/14.
+ */
+public class BaseTestActivity extends Activity {
+
+    @Required
+    TextView textViewRequired;
+    Validator validator;
+    private LinearLayout rootView;
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        rootView = new LinearLayout(this);
+        rootView.setLayoutParams(
+                new LinearLayout.LayoutParams(
+                        ViewGroup.LayoutParams.MATCH_PARENT,
+                        ViewGroup.LayoutParams.MATCH_PARENT)
+        );
+        textViewRequired = new TextView(this);
+        addTestView(textViewRequired);
+        setContentView(rootView);
+        validator = new Validator(this);
+    }
+
+    protected void addTestView(TextView textViewRequired) {
+        textViewRequired.setLayoutParams(
+                new LinearLayout.LayoutParams(
+                        ViewGroup.LayoutParams.MATCH_PARENT,
+                        ViewGroup.LayoutParams.WRAP_CONTENT)
+        );
+        rootView.addView(textViewRequired);
+    }
+}
diff --git a/tests/java/com/mobsandgeeks/saripaar/RequiredActivity.java b/tests/java/com/mobsandgeeks/saripaar/RequiredActivity.java
new file mode 100644
index 0000000..6afb5fa
--- /dev/null
+++ b/tests/java/com/mobsandgeeks/saripaar/RequiredActivity.java
@@ -0,0 +1,17 @@
+package com.mobsandgeeks.saripaar;
+
+import android.os.Bundle;
+import android.widget.TextView;
+
+/**
+ * Created by maxchursin on 8/3/14.
+ */
+public class RequiredActivity extends BaseTestActivity {
+
+    TextView optionalTextView;
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+    }
+}
diff --git a/tests/java/com/mobsandgeeks/saripaar/ValidatorTest.java b/tests/java/com/mobsandgeeks/saripaar/ValidatorTest.java
new file mode 100644
index 0000000..0faa22c
--- /dev/null
+++ b/tests/java/com/mobsandgeeks/saripaar/ValidatorTest.java
@@ -0,0 +1,87 @@
+package com.mobsandgeeks.saripaar;
+
+import android.content.Intent;
+import android.test.ActivityUnitTestCase;
+
+import java.util.List;
+
+public class ValidatorTest extends ActivityUnitTestCase<BaseTestActivity> {
+
+    private Intent intent;
+
+    public ValidatorTest() {
+        super(BaseTestActivity.class);
+    }
+
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        intent = new Intent(getInstrumentation().getTargetContext(), BaseTestActivity.class);
+    }
+
+    public void testRequiredAnnotationPositive() {
+        startActivity(intent, null, null);
+        final BaseTestActivity activity = getActivity();
+        activity.textViewRequired.setText("Text required");
+        activity.validator.setValidationListener(new SuccessValidationListener() {
+            @Override
+            public void onFormPrepared() {
+                activity.validator.validate();
+            }
+        });
+    }
+
+    public void testRequiredAnnotationNegative() {
+        startActivity(intent, null, null);
+        final BaseTestActivity activity = getActivity();
+        activity.textViewRequired.setText(null);
+        activity.validator.setValidationListener(new FailureValidationListener() {
+            @Override
+            public void onFormPrepared() {
+                activity.validator.validate();
+            }
+        });
+    }
+
+    /**
+     * Created by maxchursin on 8/3/14.
+     */
+    static abstract class SuccessValidationListener implements Validator.ValidationListener {
+
+        @Override
+        public void onValidationSucceeded() {
+            assertTrue(true);
+        }
+
+        @Override
+        public void onValidationFailed(List<ViewErrorPair> failedResults) {
+            assertTrue(false);
+        }
+
+        @Override
+        public void onServerMappingFinish(List<ViewErrorPair> mappingResults) {
+            assertTrue(false);
+        }
+    }
+
+    /**
+     * Created by maxchursin on 8/3/14.
+     */
+    static abstract class FailureValidationListener implements Validator.ValidationListener {
+
+        @Override
+        public void onValidationSucceeded() {
+            assertTrue(false);
+        }
+
+        @Override
+        public void onValidationFailed(List<ViewErrorPair> failedResults) {
+            assertTrue(true);
+        }
+
+        @Override
+        public void onServerMappingFinish(List<ViewErrorPair> mappingResults) {
+            assertTrue(false);
+        }
+    }
+}
\ No newline at end of file
