diff --git a/README.md b/README.md
index 4f3a825..0d03dfa 100644
--- a/README.md
+++ b/README.md
@@ -93,13 +93,13 @@ Maven
     <dependency>
         <groupId>com.mobsandgeeks</groupId>
         <artifactId>android-saripaar</artifactId>
-        <version>1.0.0</version>
+        <version>1.0.2</version>
     </dependency>
 
 Gradle
 ---------------------
     dependencies {
-        compile 'com.mobsandgeeks:android-saripaar:1.0.0'
+        compile 'com.mobsandgeeks:android-saripaar:1.0.2'
     }
 
 Wiki
@@ -125,10 +125,14 @@ License
 
 <sub>Saripaar Logo Â© 2013, Mobs & Geeks.<sub>
 
-  [jar]: https://github.com/ragunathjawahar/android-saripaar/downloads
+  [jar]: http://search.maven.org/#search%7Cga%7C1%7Candroid%20saripaar
   [Saripaar Annotations]: https://github.com/ragunathjawahar/android-saripaar/tree/master/src/com/mobsandgeeks/saripaar/annotation
   [AndroidAnnotations]: https://github.com/excilys/androidannotations
   [RoboGuice]: http://code.google.com/p/roboguice/
   [Validator]: https://github.com/ragunathjawahar/android-saripaar/blob/master/src/com/mobsandgeeks/saripaar/Validator.java
   [ValidationListener]: https://github.com/ragunathjawahar/android-saripaar/blob/master/src/com/mobsandgeeks/saripaar/Validator.java
   [wiki]: https://github.com/ragunathjawahar/android-saripaar/wiki
+
+
+[![Bitdeli Badge](https://d2weczhvl823v0.cloudfront.net/ragunathjawahar/android-saripaar/trend.png)](https://bitdeli.com/free "Bitdeli Badge")
+
diff --git a/pom.xml b/pom.xml
index d00d0de..5d569af 100755
--- a/pom.xml
+++ b/pom.xml
@@ -11,7 +11,7 @@
     <groupId>com.mobsandgeeks</groupId>
     <artifactId>android-saripaar</artifactId>
     <packaging>jar</packaging>
-    <version>1.0.2-SNAPSHOT-tomlux</version>
+    <version>1.0.4-SNAPSHOT</version>
 
     <name>Android Saripaar</name>
     <description>Rule-based UI validation library for Android</description>
@@ -60,7 +60,7 @@
         <java.version>1.6</java.version>
         <android.version>4.1.1.4</android.version>
         <android.platform>16</android.platform>
-        <maven.compiler.plugin>2.5</maven.compiler.plugin>
+        <maven.compiler.plugin>3.0</maven.compiler.plugin>
         <android.maven.plugin>3.4.1</android.maven.plugin>
         <maven.gpg.plugin>1.4</maven.gpg.plugin>
         <maven.javadoc.plugin>2.9.1</maven.javadoc.plugin>
diff --git a/src/com/mobsandgeeks/saripaar/AnnotationRuleFactory.java b/src/com/mobsandgeeks/saripaar/AnnotationRuleFactory.java
new file mode 100644
index 0000000..36b86d0
--- /dev/null
+++ b/src/com/mobsandgeeks/saripaar/AnnotationRuleFactory.java
@@ -0,0 +1,297 @@
+/*
+ * Copyright (C) 2012 Mobs and Geeks
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file 
+ * except in compliance with the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the 
+ * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, 
+ * either express or implied. See the License for the specific language governing permissions and 
+ * limitations under the License.
+ */
+
+package com.mobsandgeeks.saripaar;
+
+import android.content.Context;
+import android.util.Log;
+import android.view.View;
+import android.widget.Checkable;
+import android.widget.Spinner;
+import android.widget.TextView;
+
+import com.mobsandgeeks.saripaar.annotation.Checked;
+import com.mobsandgeeks.saripaar.annotation.ConfirmPassword;
+import com.mobsandgeeks.saripaar.annotation.Email;
+import com.mobsandgeeks.saripaar.annotation.IpAddress;
+import com.mobsandgeeks.saripaar.annotation.NumberRule;
+import com.mobsandgeeks.saripaar.annotation.Password;
+import com.mobsandgeeks.saripaar.annotation.Regex;
+import com.mobsandgeeks.saripaar.annotation.Required;
+import com.mobsandgeeks.saripaar.annotation.Select;
+import com.mobsandgeeks.saripaar.annotation.TextRule;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Field;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Class contains {@code static} methods that return appropriate {@link Rule}s for Saripaar
+ * annotations.
+ *
+ * @author Ragunath Jawahar <rj@mobsandgeeks.com>
+ */
+class AnnotationRuleFactory {
+    // Debug
+    static final String TAG = "AnnotationToRuleConverter";
+ 
+    // Constants
+    static final String WARN_TEXT = "%s - @%s can only be applied to TextView and " +
+            "its subclasses.";
+    static final String WARN_CHECKABLE = "%s - @%s can only be applied to Checkable, " +
+            "its implementations and subclasses.";
+
+    static final String WARN_SPINNER = "%s - @%s can only be applied to Spinner, " +
+            "its implementations and subclasses.";
+
+    public static Rule<?> getRule(Field field, View view, Annotation annotation) {
+        Class<?> annotationType = annotation.annotationType();
+
+        if (Checked.class.equals(annotationType)) {
+            return getCheckedRule(field, view, (Checked) annotation);
+        } else if (Required.class.equals(annotationType)) {
+            return getRequiredRule(field, view, (Required) annotation);
+        } else if (TextRule.class.equals(annotationType)) {
+            return getTextRule(field, view, (TextRule) annotation);
+        } else if (Regex.class.equals(annotationType)) {
+            return getRegexRule(field, view, (Regex) annotation);
+        } else if (NumberRule.class.equals(annotationType)) {
+            return getNumberRule(field, view, (NumberRule) annotation);
+        } else if (Password.class.equals(annotationType)) {
+            return getPasswordRule(field, view, (Password) annotation);
+        } else if (Email.class.equals(annotationType)) {
+            return getEmailRule(field, view, (Email) annotation);
+        } else if (IpAddress.class.equals(annotationType)) {
+            return getIpAddressRule(field, view, (IpAddress) annotation);
+        } else if (Select.class.equals(annotationType)) {
+            return getSelectRule(field, view, (Select) annotation);
+        }
+
+        return null;
+    }
+
+    private static Rule<Spinner> getSelectRule(Field field, View view, Select select) {
+        if (!Spinner.class.isAssignableFrom(view.getClass())) {
+            Log.w(TAG, String.format(WARN_SPINNER, field.getName(),
+                    Spinner.class.getSimpleName()));
+            return null;
+        }
+
+        int messageResId = select.messageResId();
+        String message = messageResId != 0 ? view.getContext().getString(messageResId) :
+                select.message();
+
+        int unexpectedSelection = select.defaultSelection();
+
+        return Rules.spinnerNotEq(message, unexpectedSelection);
+    }
+
+    public static Rule<?> getRule(Field field, View view, Annotation annotation, Object... params) {
+        Class<?> annotationType = annotation.annotationType();
+
+        if (ConfirmPassword.class.equals(annotationType)) {
+            TextView passwordTextView = (TextView) params[0];
+            return getConfirmPasswordRule(field, view, (ConfirmPassword) annotation,
+                    passwordTextView);
+        }
+
+        return (params == null || params.length == 0) ? getRule(field, view, annotation) : null;
+    }
+
+    private static Rule<TextView> getRequiredRule(Field field, View view, Required required) {
+        if (!TextView.class.isAssignableFrom(view.getClass())) {
+            Log.w(TAG, String.format(WARN_TEXT, field.getName(), Required.class.getSimpleName()));
+            return null;
+        }
+
+        int messageResId = required.messageResId();
+        String message = messageResId != 0 ? view.getContext().getString(messageResId) :
+            required.message();
+
+        return Rules.required(message, required.trim());
+    }
+
+    private static Rule<View> getTextRule(Field field, View view, TextRule textRule) {
+        if (!TextView.class.isAssignableFrom(view.getClass())) {
+            Log.w(TAG, String.format(WARN_TEXT, field.getName(), TextRule.class.getSimpleName()));
+            return null;
+        }
+
+        List<Rule<?>> rules = new ArrayList<Rule<?>>();
+        int messageResId = textRule.messageResId();
+        String message = messageResId != 0 ? view.getContext().getString(messageResId) :
+            textRule.message();
+
+        if (textRule.minLength() > 0) {
+            rules.add(Rules.minLength(null, textRule.minLength(), textRule.trim()));
+        }
+        if (textRule.maxLength() != Integer.MAX_VALUE) {
+            rules.add(Rules.maxLength(null, textRule.maxLength(), textRule.trim()));
+        }
+
+        Rule<?>[] ruleArray = new Rule<?>[rules.size()];
+        rules.toArray(ruleArray);
+
+        return Rules.and(message, ruleArray);
+    }
+
+    private static Rule<TextView> getRegexRule(Field field, View view, Regex regexRule) {
+        if (!TextView.class.isAssignableFrom(view.getClass())) {
+            Log.w(TAG, String.format(WARN_TEXT, field.getName(), Regex.class.getSimpleName()));
+            return null;
+        }
+
+        Context context = view.getContext();
+        int messageResId = regexRule.messageResId();
+        String message = messageResId != 0 ? context.getString(messageResId) : regexRule.message();
+
+        int patternResId = regexRule.patternResId();
+        String pattern = patternResId != 0 ? view.getContext().getString(patternResId) :
+            regexRule.pattern();
+
+        return Rules.regex(message, pattern, regexRule.trim());
+    }
+
+    private static Rule<View> getNumberRule(Field field, View view, NumberRule numberRule) {
+        if (!TextView.class.isAssignableFrom(view.getClass())) {
+            Log.w(TAG, String.format(WARN_TEXT, field.getName(), NumberRule.class.getSimpleName()));
+            return null;
+        } else if (numberRule.type() == null) {
+            throw new IllegalArgumentException(String.format("@%s.type() cannot be null.",
+                    NumberRule.class.getSimpleName()));
+        }
+
+        List<Rule<?>> rules = new ArrayList<Rule<?>>();
+        int messageResId = numberRule.messageResId();
+        String message = messageResId != 0 ? view.getContext().getString(messageResId) :
+            numberRule.message();
+
+        switch (numberRule.type()) {
+        case INTEGER: case LONG:
+            Rules.regex(null, Rules.REGEX_INTEGER, true); break;
+        case FLOAT: case DOUBLE:
+            Rules.regex(null, Rules.REGEX_DECIMAL, true); break;
+        }
+
+        if (numberRule.lt() != Double.MIN_VALUE) {
+            String ltNumber = String.valueOf(numberRule.lt());
+            double number = Double.parseDouble(ltNumber);
+            switch (numberRule.type()) {
+            case INTEGER:   rules.add(Rules.lt(null, ((int) number)));   break;
+            case LONG:      rules.add(Rules.lt(null, ((long) number)));  break;
+            case FLOAT:     rules.add(Rules.lt(null, Float.parseFloat(ltNumber)));   break;
+            case DOUBLE:    rules.add(Rules.lt(null, Double.parseDouble(ltNumber))); break;
+            }
+        }
+        if (numberRule.gt() != Double.MAX_VALUE) {
+            String gtNumber = String.valueOf(numberRule.gt());
+            double number = Double.parseDouble(gtNumber);
+            switch (numberRule.type()) {
+            case INTEGER:   rules.add(Rules.gt(null, ((int) number)));  break;
+            case LONG:      rules.add(Rules.gt(null, ((long) number))); break;
+            case FLOAT:     rules.add(Rules.gt(null, Float.parseFloat(gtNumber)));   break;
+            case DOUBLE:    rules.add(Rules.gt(null, Double.parseDouble(gtNumber))); break;
+            }
+        }
+        if (numberRule.eq() != Double.MAX_VALUE) {
+            String eqNumber = String.valueOf(numberRule.eq());
+            double number = Double.parseDouble(eqNumber);
+            switch (numberRule.type()) {
+            case INTEGER:   rules.add(Rules.eq(null, ((int) number)));  break;
+            case LONG:      rules.add(Rules.eq(null, ((long) number))); break;
+            case FLOAT:     rules.add(Rules.eq(null, Float.parseFloat(eqNumber)));   break;
+            case DOUBLE:    rules.add(Rules.eq(null, Double.parseDouble(eqNumber))); break;
+            }
+        }
+
+        Rule<?>[] ruleArray = new Rule<?>[rules.size()];
+        rules.toArray(ruleArray);
+
+        return Rules.and(message, ruleArray);
+    }
+
+    private static Rule<TextView> getPasswordRule(Field field, View view, Password password) {
+        if (!TextView.class.isAssignableFrom(view.getClass())) {
+            Log.w(TAG, String.format(WARN_TEXT, field.getName(), Password.class.getSimpleName()));
+            return null;
+        }
+
+        int messageResId = password.messageResId();
+        String message = messageResId != 0 ? view.getContext().getString(messageResId) :
+            password.message();
+
+        return Rules.required(message, false);
+    }
+
+    private static Rule<TextView> getConfirmPasswordRule(Field field, View view,
+            ConfirmPassword confirmPassword, TextView passwordTextView) {
+        if (!TextView.class.isAssignableFrom(view.getClass())) {
+            Log.w(TAG, String.format(WARN_TEXT, field.getName(),
+                    ConfirmPassword.class.getSimpleName()));
+            return null;
+        }
+
+        int messageResId = confirmPassword.messageResId();
+        String message = messageResId != 0 ? view.getContext().getString(messageResId) :
+            confirmPassword.message();
+
+        return Rules.eq(message, passwordTextView);
+    }
+
+    private static Rule<View> getEmailRule(Field field, View view, Email email) {
+        if (!TextView.class.isAssignableFrom(view.getClass())) {
+            Log.w(TAG, String.format(WARN_TEXT, field.getName(), Regex.class.getSimpleName()));
+            return null;
+        }
+
+        int messageResId = email.messageResId();
+        String message = messageResId != 0 ? view.getContext().getString(messageResId) :
+            email.message();
+
+        return Rules.or(message, Rules.eq(null, Rules.EMPTY_STRING),
+                Rules.regex(message, Rules.REGEX_EMAIL, true));
+    }
+
+    private static Rule<View> getIpAddressRule(Field field, View view, IpAddress ipAddress) {
+        if (!TextView.class.isAssignableFrom(view.getClass())) {
+            Log.w(TAG, String.format(WARN_TEXT, field.getName(), IpAddress.class.getSimpleName()));
+            return null;
+        }
+
+        int messageResId = ipAddress.messageResId();
+        String message = messageResId != 0 ? view.getContext().getString(messageResId) :
+            ipAddress.message();
+
+        return Rules.or(message, Rules.eq(null, Rules.EMPTY_STRING),
+                Rules.regex(message, Rules.REGEX_IP_ADDRESS, true));
+    }
+
+    private static Rule<Checkable> getCheckedRule(
+            Field field, View view, Checked checked) {
+
+        if (!Checkable.class.isAssignableFrom(view.getClass())) {
+            Log.w(TAG, String.format(WARN_CHECKABLE, field.getName(),
+                    Checked.class.getSimpleName()));
+            return null;
+        }
+
+        int messageResId = checked.messageResId();
+        String message = messageResId != 0 ? view.getContext().getString(messageResId) :
+            checked.message();
+
+        return Rules.checked(message, checked.checked());
+    }
+
+}
diff --git a/src/com/mobsandgeeks/saripaar/AnnotationToRuleConverter.java b/src/com/mobsandgeeks/saripaar/AnnotationToRuleConverter.java
deleted file mode 100644
index 4496576..0000000
--- a/src/com/mobsandgeeks/saripaar/AnnotationToRuleConverter.java
+++ /dev/null
@@ -1,445 +0,0 @@
-/*
- * Copyright (C) 2012 Mobs and Geeks
- *
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file 
- * except in compliance with the License. You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the 
- * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, 
- * either express or implied. See the License for the specific language governing permissions and 
- * limitations under the License.
- */
-
-package com.mobsandgeeks.saripaar;
-
-import android.content.Context;
-import android.util.Log;
-import android.view.View;
-import android.widget.Checkable;
-import android.widget.RadioGroup;
-import android.widget.Spinner;
-import android.widget.TextView;
-import com.mobsandgeeks.saripaar.annotation.*;
-
-import java.lang.annotation.Annotation;
-import java.lang.reflect.Field;
-import java.text.DateFormat;
-import java.text.ParseException;
-import java.text.SimpleDateFormat;
-import java.util.*;
-
-/**
- * Class contains {@code static} methods that return appropriate {@link Rule}s for Saripaar
- * annotations.
- *
- * @author Ragunath Jawahar <rj@mobsandgeeks.com>
- */
-class AnnotationToRuleConverter {
-    // Debug
-    static final String TAG = AnnotationToRuleConverter.class.getSimpleName();
-
-    // Constants
-    static final String WARN_TEXT = "%s - @%s can only be applied to TextView and " +
-            "its subclasses.";
-    static final String WARN_Spinner_TEXT = "%s - @%s can only be applied to Spinner and " +
-            "its subclasses.";
-    static final String WARN_RadioGroup_TEXT = "%s - @%s can only be applied to RadioGroup and " +
-            "its subclasses.";
-    static final String WARN_CHECKABLE = "%s - @%s can only be applied to Checkable, " +
-            "its implementations and subclasses.";
-
-    public static Rule<?> getRule(Field field, View view, Annotation annotation) {
-        Class<?> annotationClass = annotation.getClass();
-
-        if (Required.class.isAssignableFrom(annotationClass)) {
-            if (view instanceof Spinner)
-                return getRequiredRule(field, (Spinner) view, (Required) annotation);
-            if (view instanceof RadioGroup)
-                return getRequiredRule(field, (RadioGroup) view, (Required) annotation);
-            return getRequiredRule(field, view, (Required) annotation);
-        } else if (Checked.class.isAssignableFrom(annotationClass)) {
-            return getCheckedRule(field, view, (Checked) annotation);
-        } else if (TextRule.class.isAssignableFrom(annotationClass)) {
-            return getTextRule(field, view, (TextRule) annotation);
-        } else if (Regex.class.isAssignableFrom(annotationClass)) {
-            return getRegexRule(field, view, (Regex) annotation);
-        } else if (NumberRule.class.isAssignableFrom(annotationClass)) {
-            return getNumberRule(field, view, (NumberRule) annotation);
-        } else if (Password.class.isAssignableFrom(annotationClass)) {
-            return getPasswordRule(field, view, (Password) annotation);
-        } else if (Email.class.isAssignableFrom(annotationClass)) {
-            return getEmailRule(field, view, (Email) annotation);
-        } else if (IpAddress.class.isAssignableFrom(annotationClass)) {
-            return getIpAddressRule(field, view, (IpAddress) annotation);
-        }
-
-        return null;
-    }
-
-    public static List<Rule<?>> getRules(Field field, View view, Annotation annotation) {
-        Class<?> annotationClass = annotation.getClass();
-        if (DateRule.class.isAssignableFrom(annotationClass)) {
-            return getDateRules(field, view, (DateRule) annotation);
-        }
-        return Collections.emptyList();
-    }
-
-    public static Rule<?> getRule(Field field, View view, Annotation annotation, Object... params) {
-        Class<?> annotationClass = annotation.getClass();
-
-        if (ConfirmPassword.class.isAssignableFrom(annotationClass)) {
-            TextView passwordTextView = (TextView) params[0];
-            return getConfirmPasswordRule(field, view, (ConfirmPassword) annotation,
-                    passwordTextView);
-        }
-
-        return (params == null || params.length == 0) ? getRule(field, view, annotation) : null;
-    }
-
-    private static Rule<TextView> getRequiredRule(Field field, View view, Required required) {
-        if (!TextView.class.isAssignableFrom(view.getClass())) {
-            Log.w(TAG, String.format(WARN_TEXT, field.getName(), Required.class.getSimpleName()));
-            return null;
-        }
-
-        int messageResId = required.messageResId();
-        String message = messageResId != 0 ? view.getContext().getString(messageResId) :
-                required.message();
-
-        return Rules.required(message, required.trim());
-    }
-
-    private static Rule<Spinner> getRequiredRule(Field field, Spinner spinner, Required required) {
-        if (!Spinner.class.isAssignableFrom(spinner.getClass())) {
-            Log.w(TAG, String.format(WARN_Spinner_TEXT, field.getName(), Required.class.getSimpleName()));
-            return null;
-        }
-
-        int messageResId = required.messageResId();
-        String message = messageResId != 0 ? spinner.getContext().getString(messageResId) :
-                required.message();
-
-        return Rules.requiredSpinner(message);
-    }
-
-    private static Rule<RadioGroup> getRequiredRule(Field field, RadioGroup radioGroup, Required required) {
-        if (!RadioGroup.class.isAssignableFrom(radioGroup.getClass())) {
-            Log.w(TAG, String.format(WARN_RadioGroup_TEXT, field.getName(), Required.class.getSimpleName()));
-            return null;
-        }
-
-        int messageResId = required.messageResId();
-        String message = messageResId != 0 ? radioGroup.getContext().getString(messageResId) :
-                required.message();
-
-        return Rules.requiredRadioGroup(message);
-    }
-
-    private static Rule<View> getTextRule(Field field, View view, TextRule textRule) {
-        if (!TextView.class.isAssignableFrom(view.getClass())) {
-            Log.w(TAG, String.format(WARN_TEXT, field.getName(), TextRule.class.getSimpleName()));
-            return null;
-        }
-
-        List<Rule<?>> rules = new ArrayList<Rule<?>>();
-        int messageResId = textRule.messageResId();
-        String message = messageResId != 0 ? view.getContext().getString(messageResId) :
-                textRule.message();
-
-        if (textRule.minLength() > 0) {
-            rules.add(Rules.minLength(null, textRule.minLength(), textRule.trim()));
-        }
-        if (textRule.maxLength() != Integer.MAX_VALUE) {
-            rules.add(Rules.maxLength(null, textRule.maxLength(), textRule.trim()));
-        }
-
-        Rule<?>[] ruleArray = new Rule<?>[rules.size()];
-        rules.toArray(ruleArray);
-
-        return Rules.and(message, ruleArray);
-    }
-
-    private static Rule<TextView> getRegexRule(Field field, View view, Regex regexRule) {
-        if (!TextView.class.isAssignableFrom(view.getClass())) {
-            Log.w(TAG, String.format(WARN_TEXT, field.getName(), Regex.class.getSimpleName()));
-            return null;
-        }
-
-        Context context = view.getContext();
-        int messageResId = regexRule.messageResId();
-        String message = messageResId != 0 ? context.getString(messageResId) : regexRule.message();
-
-        int patternResId = regexRule.patternResId();
-        String pattern = patternResId != 0 ? view.getContext().getString(patternResId) :
-                regexRule.pattern();
-
-        return Rules.regex(message, pattern, regexRule.trim());
-    }
-
-    private static Rule<View> getNumberRule(Field field, View view, NumberRule numberRule) {
-        if (!TextView.class.isAssignableFrom(view.getClass())) {
-            Log.w(TAG, String.format(WARN_TEXT, field.getName(), NumberRule.class.getSimpleName()));
-            return null;
-        } else if (numberRule.type() == null) {
-            throw new IllegalArgumentException(String.format("@%s.type() cannot be null.",
-                    NumberRule.class.getSimpleName()));
-        }
-
-        List<Rule<?>> rules = new ArrayList<Rule<?>>();
-        int messageResId = numberRule.messageResId();
-        String message = messageResId != 0 ? view.getContext().getString(messageResId) :
-                numberRule.message();
-
-        switch (numberRule.type()) {
-            case INTEGER:
-            case LONG:
-                Rules.regex(null, Rules.REGEX_INTEGER, true);
-                break;
-            case FLOAT:
-            case DOUBLE:
-                Rules.regex(null, Rules.REGEX_DECIMAL, true);
-                break;
-        }
-
-        if (numberRule.lt() != Double.MIN_VALUE) {
-            String ltNumber = String.valueOf(numberRule.lt());
-            double number = Double.parseDouble(ltNumber);
-            switch (numberRule.type()) {
-                case INTEGER:
-                    rules.add(Rules.lt(null, ((int) number)));
-                    break;
-                case LONG:
-                    rules.add(Rules.lt(null, ((long) number)));
-                    break;
-                case FLOAT:
-                    rules.add(Rules.lt(null, Float.parseFloat(ltNumber)));
-                    break;
-                case DOUBLE:
-                    rules.add(Rules.lt(null, Double.parseDouble(ltNumber)));
-                    break;
-            }
-        }
-        if (numberRule.gt() != Double.MAX_VALUE) {
-            String gtNumber = String.valueOf(numberRule.gt());
-            double number = Double.parseDouble(gtNumber);
-            switch (numberRule.type()) {
-                case INTEGER:
-                    rules.add(Rules.gt(null, ((int) number)));
-                    break;
-                case LONG:
-                    rules.add(Rules.gt(null, ((long) number)));
-                    break;
-                case FLOAT:
-                    rules.add(Rules.gt(null, Float.parseFloat(gtNumber)));
-                    break;
-                case DOUBLE:
-                    rules.add(Rules.gt(null, Double.parseDouble(gtNumber)));
-                    break;
-            }
-        }
-        if (numberRule.eq() != Double.MAX_VALUE) {
-            String eqNumber = String.valueOf(numberRule.eq());
-            double number = Double.parseDouble(eqNumber);
-            switch (numberRule.type()) {
-                case INTEGER:
-                    rules.add(Rules.eq(null, ((int) number)));
-                    break;
-                case LONG:
-                    rules.add(Rules.eq(null, ((long) number)));
-                    break;
-                case FLOAT:
-                    rules.add(Rules.eq(null, Float.parseFloat(eqNumber)));
-                    break;
-                case DOUBLE:
-                    rules.add(Rules.eq(null, Double.parseDouble(eqNumber)));
-                    break;
-            }
-        }
-
-        Rule<?>[] ruleArray = new Rule<?>[rules.size()];
-        rules.toArray(ruleArray);
-
-        return Rules.and(message, ruleArray);
-    }
-
-    private static Rule<TextView> getPasswordRule(Field field, View view, Password password) {
-        if (!TextView.class.isAssignableFrom(view.getClass())) {
-            Log.w(TAG, String.format(WARN_TEXT, field.getName(), Password.class.getSimpleName()));
-            return null;
-        }
-
-        int messageResId = password.messageResId();
-        String message = messageResId != 0 ? view.getContext().getString(messageResId) :
-                password.message();
-
-        return Rules.required(message, false);
-    }
-
-    private static Rule<TextView> getConfirmPasswordRule(Field field, View view,
-                                                         ConfirmPassword confirmPassword, TextView passwordTextView) {
-        if (!TextView.class.isAssignableFrom(view.getClass())) {
-            Log.w(TAG, String.format(WARN_TEXT, field.getName(),
-                    ConfirmPassword.class.getSimpleName()));
-            return null;
-        }
-
-        int messageResId = confirmPassword.messageResId();
-        String message = messageResId != 0 ? view.getContext().getString(messageResId) :
-                confirmPassword.message();
-
-        return Rules.eq(message, passwordTextView);
-    }
-
-    private static Rule<View> getEmailRule(Field field, View view, Email email) {
-        if (!TextView.class.isAssignableFrom(view.getClass())) {
-            Log.w(TAG, String.format(WARN_TEXT, field.getName(), Regex.class.getSimpleName()));
-            return null;
-        }
-
-        int messageResId = email.messageResId();
-        String message = messageResId != 0 ? view.getContext().getString(messageResId) :
-                email.message();
-
-        return Rules.or(message, Rules.eq(null, Rules.EMPTY_STRING),
-                Rules.regex(message, Rules.REGEX_EMAIL, true));
-    }
-
-    private static Rule<View> getIpAddressRule(Field field, View view, IpAddress ipAddress) {
-        if (!TextView.class.isAssignableFrom(view.getClass())) {
-            Log.w(TAG, String.format(WARN_TEXT, field.getName(), IpAddress.class.getSimpleName()));
-            return null;
-        }
-
-        int messageResId = ipAddress.messageResId();
-        String message = messageResId != 0 ? view.getContext().getString(messageResId) :
-                ipAddress.message();
-
-        return Rules.or(message, Rules.eq(null, Rules.EMPTY_STRING),
-                Rules.regex(message, Rules.REGEX_IP_ADDRESS, true));
-    }
-
-    private static Rule<Checkable> getCheckedRule(Field field, View view, Checked checked) {
-        if (!Checkable.class.isAssignableFrom(view.getClass())) {
-            Log.w(TAG, String.format(WARN_CHECKABLE, field.getName(),
-                    Checked.class.getSimpleName()));
-            return null;
-        }
-
-        int messageResId = checked.messageResId();
-        String message = messageResId != 0 ? view.getContext().getString(messageResId) :
-                checked.message();
-
-        return Rules.checked(message, checked.checked());
-    }
-
-    private static List<Rule<?>> getDateRules(Field field, View view, DateRule dateRule) {
-        if (!TextView.class.isAssignableFrom(view.getClass())) {
-            Log.w(TAG, String.format(WARN_TEXT, field.getName(), DateRule.class.getSimpleName()));
-            return Collections.emptyList();
-        } else if (dateRule.pattern() == null) {
-            throw new IllegalArgumentException(String.format("@%s.pattern() cannot be null.",
-                    DateRule.class.getSimpleName()));
-        }
-
-        String pattern = dateRule.pattern();
-        DateFormat dateFormat = new SimpleDateFormat(pattern);
-
-        List<Rule<?>> rules = new ArrayList<Rule<?>>();
-
-        int messageParseResId = dateRule.messageParseResId();
-        String messageParse = messageParseResId != 0 ? view.getContext().getString(messageParseResId) : dateRule.messageParse();
-        rules.add(Rules.formatDate(messageParse, dateFormat));
-
-        if (dateRule.lt().trim().length() > 0) {
-            String ltTxt = dateRule.lt();
-
-            try {
-                int messageLtResId = dateRule.messageLtResId();
-                String messageLt = messageLtResId != 0 ? view.getContext().getString(messageLtResId) : dateRule.messageLt();
-                Date ltDate = evaluateDate(ltTxt, dateFormat);
-                rules.add(Rules.ltDate(messageLt, ltDate, dateFormat));
-            } catch (ParseException e) {
-                throw new IllegalArgumentException(String.format("@%s.lt() cannot be parsed using pattern.",
-                        DateRule.class.getSimpleName()));
-            }
-        }
-
-        if (dateRule.gt().trim().length() > 0) {
-            String gtTxt = dateRule.gt();
-            try {
-                int messageGtResId = dateRule.messageGtResId();
-                String messageGt = messageGtResId != 0 ? view.getContext().getString(messageGtResId) : dateRule.messageGt();
-                Date gtDate = evaluateDate(gtTxt, dateFormat);
-                rules.add(Rules.gtDate(messageGt, gtDate, dateFormat));
-            } catch (ParseException e) {
-                throw new IllegalArgumentException(String.format("@%s.lt() cannot be parsed using pattern.",
-                        DateRule.class.getSimpleName()));
-            }
-        }
-
-        return rules;
-    }
-
-
-    public static void main(String[] args) {
-        DateFormat dateFormat = new SimpleDateFormat("dd/MM/yyyy HH:mm");
-        try {
-            System.out.println("new Date()            = " + dateFormat.format(new Date()));
-            System.out.println("now-1y+1M-1d+1h-1m+5s = " + dateFormat.format(evaluateDate("now-1y+1M-1d+1h-1m+5s", dateFormat)));
-            System.out.println("now-0y-1M+1d-1h+1m-3s = " + dateFormat.format(evaluateDate("now-0y-1M+1d-1h+1m-3s", dateFormat)));
-        } catch (Exception e) {
-            e.printStackTrace();
-        }
-    }
-
-    private static Date evaluateDate(String txt, DateFormat dateFormat) throws ParseException {
-        if (txt.startsWith("now")) {
-            List<String> splits = new ArrayList<String>();
-            txt = txt.substring(3);
-            String[] splittedPlus = txt.split("[+]");
-            for (String spitPlus : splittedPlus) {
-                if (spitPlus.length() > 0) {
-                    if (spitPlus.charAt(0) != '-') {
-                        spitPlus = "+" + spitPlus;
-                    }
-                    String[] splittedMinus = spitPlus.split("[-]");
-                    for (String splitMinus : splittedMinus) {
-                        if (splitMinus.length() > 0) {
-                            if (splitMinus.charAt(0) != '+') {
-                                splitMinus = "-" + splitMinus;
-                            }
-                            splits.add(splitMinus);
-                        }
-                    }
-                }
-            }
-            Calendar cal = GregorianCalendar.getInstance();
-            for (String split : splits) {
-                String operation = split.substring(0, 1);
-                String unit = split.substring(split.length() - 1, split.length());
-                String amount = split.substring(1, split.length() - 1);
-                int value = Integer.parseInt(amount) * (operation.equals("+") ? 1 : -1);
-                if (unit.equals("y")) {
-                    cal.add(Calendar.YEAR, value);
-                } else if (unit.equals("M")) {
-                    cal.add(Calendar.MONTH, value);
-                } else if (unit.equals("d")) {
-                    cal.add(Calendar.DAY_OF_YEAR, value);
-                } else if (unit.equals("h")) {
-                    cal.add(Calendar.HOUR_OF_DAY, value);
-                } else if (unit.equals("m")) {
-                    cal.add(Calendar.MINUTE, value);
-                } else if (unit.equals("s")) {
-                    cal.add(Calendar.SECOND, value);
-                } else {
-                    System.err.println("evaluateDate.invalid UNIT: '" + unit + "'");
-                }
-            }
-            return cal.getTime();
-        } else {
-            return dateFormat.parse(txt);
-        }
-    }
-}
diff --git a/src/com/mobsandgeeks/saripaar/Rule.java b/src/com/mobsandgeeks/saripaar/Rule.java
index 9cc9263..5aaca3b 100644
--- a/src/com/mobsandgeeks/saripaar/Rule.java
+++ b/src/com/mobsandgeeks/saripaar/Rule.java
@@ -15,23 +15,18 @@
 package com.mobsandgeeks.saripaar;
 
 import android.view.View;
-import android.widget.Checkable;
 
 /**
  * Abstract class that allows to define validation rules for {@link View}s.
  *
  * @author Ragunath Jawahar <rj@mobsandgeeks.com>
  *
- * @param <T> Usually the {@link View} this rule is applicable for. Sometimes may be interfaces
- * such as {@link Checkable} which are indeed {@link View} components or widgets.
+ * @param <T> The {@link View} this rule is applicable for.
  */
 public abstract class Rule<T> {
 
     private String mFailureMessage;
 
-    @SuppressWarnings("unused")
-    private Rule() { /* Cannot instantiate */ }
-
     /**
      * Creates a new validation Rule.
      *
diff --git a/src/com/mobsandgeeks/saripaar/Rules.java b/src/com/mobsandgeeks/saripaar/Rules.java
index 739b524..4d680fc 100644
--- a/src/com/mobsandgeeks/saripaar/Rules.java
+++ b/src/com/mobsandgeeks/saripaar/Rules.java
@@ -25,6 +25,9 @@
 import java.util.LinkedHashMap;
 import java.util.Set;
 
+import java.util.LinkedHashMap;
+import java.util.Set;
+
 /**
  * A built-in class with a collection of common rules. {@link TextView} references notable direct
  * and indirect subclasses that includes but not limited to {@link EditText},
@@ -38,14 +41,71 @@
  * @author Ragunath Jawahar <rj@mobsandgeeks.com>
  */
 public final class Rules {
+    // Constants
     public static final String EMPTY_STRING = "";
+
+    // Regular Expressions
+    private static final String GOOD_IRI_CHAR =
+            "a-zA-Z0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF"; // android.util.Patterns.java
+    private static final String TOP_LEVEL_DOMAIN_STR_FOR_WEB_URL =
+            "(?:"
+            + "(?:aero|arpa|asia|a[cdefgilmnoqrstuwxz])"
+            + "|(?:biz|b[abdefghijmnorstvwyz])"
+            + "|(?:cat|com|coop|c[acdfghiklmnoruvxyz])"
+            + "|d[ejkmoz]"
+            + "|(?:edu|e[cegrstu])"
+            + "|f[ijkmor]"
+            + "|(?:gov|g[abdefghilmnpqrstuwy])"
+            + "|h[kmnrtu]"
+            + "|(?:info|int|i[delmnoqrst])"
+            + "|(?:jobs|j[emop])"
+            + "|k[eghimnprwyz]"
+            + "|l[abcikrstuvy]"
+            + "|(?:mil|mobi|museum|m[acdeghklmnopqrstuvwxyz])"
+            + "|(?:name|net|n[acefgilopruz])"
+            + "|(?:org|om)"
+            + "|(?:pro|p[aefghklmnrstwy])"
+            + "|qa"
+            + "|r[eosuw]"
+            + "|s[abcdeghijklmnortuvyz]"
+            + "|(?:tel|travel|t[cdfghjklmnoprtvwz])"
+            + "|u[agksyz]"
+            + "|v[aceginu]"
+            + "|w[fs]"
+            + "|(?:xn\\-\\-0zwm56d|xn\\-\\-11b5bs3a9aj6g|xn\\-\\-80akhbyknj4f|xn\\-\\-9t4b11yi5a|xn\\-\\-deba0ad|xn\\-\\-g6w251d|xn\\-\\-hgbk6aj7f53bba|xn\\-\\-hlcj6aya9esc7a|xn\\-\\-jxalpdlp|xn\\-\\-kgbechtv|xn\\-\\-zckzah)"
+            + "|y[etu]"
+            + "|z[amw]))"; // android.util.Patterns.java
+
     public static final String REGEX_INTEGER = "\\d+";
+
     public static final String REGEX_DECIMAL = "[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?";
-    public static final String REGEX_EMAIL = "^[_A-Za-z0-9-]+(\\.[_A-Za-z0-9-]+)*@" +
-            "[A-Za-z0-9]+(\\.[A-Za-z0-9]+)*(\\.[A-Za-z]{2,})$";
-    public static final String REGEX_IP_ADDRESS = "^([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\." +
-            "([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\." +
-            "([01]?\\d\\d?|2[0-4]\\d|25[0-5])$";
+
+    public static final String REGEX_EMAIL =
+            "[a-zA-Z0-9\\+\\.\\_\\%\\-\\+]{1,256}"
+            + "\\@[a-zA-Z0-9][a-zA-Z0-9\\-]{0,64}"
+            + "(\\.[a-zA-Z0-9][a-zA-Z0-9\\-]{0,25})+"; // android.util.Patterns.java
+
+    public static final String REGEX_IP_ADDRESS =
+            "((25[0-5]|2[0-4][0-9]|[0-1][0-9]{2}|[1-9][0-9]|[1-9])\\.(25[0-5]|2[0-4]"
+            + "[0-9]|[0-1][0-9]{2}|[1-9][0-9]|[1-9]|0)\\.(25[0-5]|2[0-4][0-9]|[0-1]"
+            + "[0-9]{2}|[1-9][0-9]|[1-9]|0)\\.(25[0-5]|2[0-4][0-9]|[0-1][0-9]{2}"
+            + "|[1-9][0-9]|[0-9]))"; // android.util.Patterns.java
+
+    public static final String REGEX_WEB_URL =
+            "((?:(http|https|Http|Https|rtsp|Rtsp):\\/\\/(?:(?:[a-zA-Z0-9\\$\\-\\_\\.\\+\\!\\*\\'\\(\\)"
+            + "\\,\\;\\?\\&\\=]|(?:\\%[a-fA-F0-9]{2})){1,64}(?:\\:(?:[a-zA-Z0-9\\$\\-\\_"
+            + "\\.\\+\\!\\*\\'\\(\\)\\,\\;\\?\\&\\=]|(?:\\%[a-fA-F0-9]{2})){1,25})?\\@)?)?"
+            + "((?:(?:[" + GOOD_IRI_CHAR + "][" + GOOD_IRI_CHAR + "\\-]{0,64}\\.)+"   // named host
+            + TOP_LEVEL_DOMAIN_STR_FOR_WEB_URL
+            + "|(?:(?:25[0-5]|2[0-4]" // or ip address
+            + "[0-9]|[0-1][0-9]{2}|[1-9][0-9]|[1-9])\\.(?:25[0-5]|2[0-4][0-9]"
+            + "|[0-1][0-9]{2}|[1-9][0-9]|[1-9]|0)\\.(?:25[0-5]|2[0-4][0-9]|[0-1]"
+            + "[0-9]{2}|[1-9][0-9]|[1-9]|0)\\.(?:25[0-5]|2[0-4][0-9]|[0-1][0-9]{2}"
+            + "|[1-9][0-9]|[0-9])))"
+            + "(?:\\:\\d{1,5})?)" // plus option port number
+            + "(\\/(?:(?:[" + GOOD_IRI_CHAR + "\\;\\/\\?\\:\\@\\&\\=\\#\\~"  // plus option query params
+            + "\\-\\.\\+\\!\\*\\'\\(\\)\\,\\_])|(?:\\%[a-fA-F0-9]{2}))*)?"
+            + "(?:\\b|$)"; // android.util.Patterns.java
 
     /**
      * The classical required {@link Rule}. Checks if the {@link TextView} or its subclass
@@ -529,12 +589,13 @@ public boolean isValid(TextView view) {
      * @param checked        The expected state of the {@link Checkable} widget.
      * @return True if the state is same as {@code checked}.
      */
-    public static Rule<Checkable> checked(final String failureMessage, final boolean checked) {
+    public static Rule<Checkable> checked(final String failureMessage,
+            final boolean checked) {
         return new Rule<Checkable>(failureMessage) {
 
             @Override
-            public boolean isValid(Checkable checkableView) {
-                return checkableView.isChecked() == checked;
+            public boolean isValid(Checkable view) {
+                return view.isChecked() == checked;
             }
         };
     }
@@ -596,6 +657,27 @@ public boolean isValid(Spinner spinner) {
         };
     }
 
+    /**
+     * Checks if the {@link Spinner}'s item selection (obtained by calling
+     * {@code getSelectionItemPosition()}) is not equal to the specified selection.
+     *
+     * @param failureMessage The failure message for this {@link Rule}.
+     * @param selection The unexpected selection on the {@link Spinner}.
+     *
+     * @return {@code true} if the selection is not equal to the given position, 
+     *         {@code false} otherwise. 
+     */
+    public static Rule<Spinner> spinnerNotEq(final String failureMessage, final int selection) {
+
+        return new Rule<Spinner>(failureMessage) {
+
+            @Override
+            public boolean isValid(Spinner spinner) {
+                return spinner.getSelectedItemPosition() != selection;
+            }
+        };
+    }
+
     /**
      * Performs an '&&' (and) operation on the given array of {@link Rules}.
      *
@@ -788,4 +870,4 @@ public boolean isValid(TextView view) {
             }
         };
     }
-}
\ No newline at end of file
+}
diff --git a/src/com/mobsandgeeks/saripaar/Validator.java b/src/com/mobsandgeeks/saripaar/Validator.java
index c135a9b..faadbb8 100644
--- a/src/com/mobsandgeeks/saripaar/Validator.java
+++ b/src/com/mobsandgeeks/saripaar/Validator.java
@@ -18,11 +18,26 @@
 import android.util.Log;
 import android.view.View;
 import android.widget.TextView;
-import com.mobsandgeeks.saripaar.annotation.*;
+
+import com.mobsandgeeks.saripaar.annotation.Checked;
+import com.mobsandgeeks.saripaar.annotation.ConfirmPassword;
+import com.mobsandgeeks.saripaar.annotation.Email;
+import com.mobsandgeeks.saripaar.annotation.IpAddress;
+import com.mobsandgeeks.saripaar.annotation.NumberRule;
+import com.mobsandgeeks.saripaar.annotation.Password;
+import com.mobsandgeeks.saripaar.annotation.Regex;
+import com.mobsandgeeks.saripaar.annotation.Required;
+import com.mobsandgeeks.saripaar.annotation.Select;
+import com.mobsandgeeks.saripaar.annotation.TextRule;
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Field;
-import java.util.*;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
 
 /**
  * A processor that checks all the {@link Rule}s against their {@link View}s.
@@ -31,7 +46,7 @@
  */
 public class Validator {
     // Debug
-    static final String TAG = Validator.class.getSimpleName();
+    static final String TAG = "Validator";
     static final boolean DEBUG = false;
 
     private Object mController;
@@ -384,26 +399,24 @@ private void createRulesFromAnnotations(List<AnnotationFieldPair> annotationFiel
             }
 
             // Others
-            List<ViewRulePair> viewRulePairs = new ArrayList<ViewRulePair>();
+            ViewRulePair viewRulePair = null;
             if (pair.annotation.annotationType().equals(ConfirmPassword.class)) {
-                viewRulePairs.addAll(getViewAndRule(pair.field, pair.annotation, passwordTextView));
+                viewRulePair = getViewAndRule(pair.field, pair.annotation, passwordTextView);
             } else {
-                viewRulePairs.addAll(getViewAndRule(pair.field, pair.annotation));
+                viewRulePair = getViewAndRule(pair.field, pair.annotation);
             }
-            for (ViewRulePair viewRulePair : viewRulePairs) {
-                if (viewRulePair != null) {
-                    if (DEBUG) {
-                        Log.d(TAG, String.format("Added @%s rule for %s.",
-                                pair.annotation.annotationType().getSimpleName(),
-                                pair.field.getName()));
-                    }
-                    mViewsAndRules.add(viewRulePair);
+            if (viewRulePair != null) {
+                if (DEBUG) {
+                    Log.d(TAG, String.format("Added @%s rule for %s.",
+                            pair.annotation.annotationType().getSimpleName(),
+                            pair.field.getName()));
                 }
+                mViewsAndRules.add(viewRulePair);
             }
         }
     }
 
-    private List<ViewRulePair> getViewAndRule(Field field, Annotation annotation, Object... params) {
+    private ViewRulePair getViewAndRule(Field field, Annotation annotation, Object... params) {
         View view = getView(field);
         if (view == null) {
             Log.w(TAG, String.format("Your %s - %s is null. Please check your field assignment(s).",
@@ -411,19 +424,14 @@ private void createRulesFromAnnotations(List<AnnotationFieldPair> annotationFiel
             return null;
         }
 
-        List<Rule<?>> rules = new ArrayList<Rule<?>>();
+        Rule<?> rule = null;
         if (params != null && params.length > 0) {
-            rules.add(AnnotationToRuleConverter.getRule(field, view, annotation, params));
+            rule = AnnotationRuleFactory.getRule(field, view, annotation, params);
         } else {
-            rules.add(AnnotationToRuleConverter.getRule(field, view, annotation));
-            rules.addAll(AnnotationToRuleConverter.getRules(field, view, annotation));
-        }
-        List<ViewRulePair> retList = new ArrayList<ViewRulePair>();
-        for (Rule<?> rule : rules) {
-            if(rule!=null)
-                retList.add(new ViewRulePair(view, rule));
+            rule = AnnotationRuleFactory.getRule(field, view, annotation);
         }
-        return retList;
+
+        return rule != null ? new ViewRulePair(view, rule) : null;
     }
 
     private View getView(Field field) {
@@ -448,6 +456,11 @@ private View getView(Field field) {
             Annotation[] annotations = field.getAnnotations();
             for (Annotation annotation : annotations) {
                 if (isSaripaarAnnotation(annotation)) {
+                    if (DEBUG) {
+                        Log.d(TAG, String.format("%s %s is annotated with @%s",
+                                field.getType().getSimpleName(), field.getName(),
+                                annotation.annotationType().getSimpleName()));
+                    }
                     annotationFieldPairs.add(new AnnotationFieldPair(annotation, field));
                 }
             }
@@ -514,8 +527,8 @@ private boolean isSaripaarAnnotation(Annotation annotation) {
                 annotationType.equals(Password.class) ||
                 annotationType.equals(Regex.class) ||
                 annotationType.equals(Required.class) ||
-                annotationType.equals(TextRule.class) ||
-                annotationType.equals(DateRule.class);
+                annotationType.equals(Select.class) ||
+                annotationType.equals(TextRule.class);
     }
 
     private class ViewRulePair {
@@ -573,12 +586,12 @@ private int getAnnotationOrder(Annotation annotation) {
             } else if (annotatedClass.equals(Required.class)) {
                 return ((Required) annotation).order();
 
+            } else if (annotatedClass.equals(Select.class)) {
+                return ((Select) annotation).order();
+
             } else if (annotatedClass.equals(TextRule.class)) {
                 return ((TextRule) annotation).order();
 
-            } else if (annotatedClass.equals(DateRule.class)) {
-                return ((DateRule) annotation).order();
-
             } else {
                 throw new IllegalArgumentException(String.format("%s is not a Saripaar annotation",
                         annotatedClass.getName()));
diff --git a/src/com/mobsandgeeks/saripaar/annotation/Select.java b/src/com/mobsandgeeks/saripaar/annotation/Select.java
new file mode 100644
index 0000000..07c0bfe
--- /dev/null
+++ b/src/com/mobsandgeeks/saripaar/annotation/Select.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (c) 2013 Mobs and Geeks
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file 
+ * except in compliance with the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the 
+ * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, 
+ * either express or implied. See the License for the specific language governing permissions and 
+ * limitations under the License.
+ */
+
+package com.mobsandgeeks.saripaar.annotation;
+
+import android.widget.Spinner;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Used on a {@link Spinner} to check if the selected item is not the default.
+ * 
+ * @author Muhammad Hewedy
+ */
+@Target(ElementType.FIELD)
+@Retention(RetentionPolicy.RUNTIME)
+public @interface Select {
+    public int order();
+    public int defaultSelection()   default 0;
+    public String message()         default "Select an item.";
+    public int messageResId()       default 0;
+}
