diff --git a/src/com/mobsandgeeks/saripaar/AnnotationToRuleConverter.java b/src/com/mobsandgeeks/saripaar/AnnotationToRuleConverter.java
index cc1ad68..4496576 100644
--- a/src/com/mobsandgeeks/saripaar/AnnotationToRuleConverter.java
+++ b/src/com/mobsandgeeks/saripaar/AnnotationToRuleConverter.java
@@ -25,8 +25,10 @@
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Field;
-import java.util.ArrayList;
-import java.util.List;
+import java.text.DateFormat;
+import java.text.ParseException;
+import java.text.SimpleDateFormat;
+import java.util.*;
 
 /**
  * Class contains {@code static} methods that return appropriate {@link Rule}s for Saripaar
@@ -76,6 +78,14 @@
         return null;
     }
 
+    public static List<Rule<?>> getRules(Field field, View view, Annotation annotation) {
+        Class<?> annotationClass = annotation.getClass();
+        if (DateRule.class.isAssignableFrom(annotationClass)) {
+            return getDateRules(field, view, (DateRule) annotation);
+        }
+        return Collections.emptyList();
+    }
+
     public static Rule<?> getRule(Field field, View view, Annotation annotation, Object... params) {
         Class<?> annotationClass = annotation.getClass();
 
@@ -324,4 +334,112 @@
         return Rules.checked(message, checked.checked());
     }
 
+    private static List<Rule<?>> getDateRules(Field field, View view, DateRule dateRule) {
+        if (!TextView.class.isAssignableFrom(view.getClass())) {
+            Log.w(TAG, String.format(WARN_TEXT, field.getName(), DateRule.class.getSimpleName()));
+            return Collections.emptyList();
+        } else if (dateRule.pattern() == null) {
+            throw new IllegalArgumentException(String.format("@%s.pattern() cannot be null.",
+                    DateRule.class.getSimpleName()));
+        }
+
+        String pattern = dateRule.pattern();
+        DateFormat dateFormat = new SimpleDateFormat(pattern);
+
+        List<Rule<?>> rules = new ArrayList<Rule<?>>();
+
+        int messageParseResId = dateRule.messageParseResId();
+        String messageParse = messageParseResId != 0 ? view.getContext().getString(messageParseResId) : dateRule.messageParse();
+        rules.add(Rules.formatDate(messageParse, dateFormat));
+
+        if (dateRule.lt().trim().length() > 0) {
+            String ltTxt = dateRule.lt();
+
+            try {
+                int messageLtResId = dateRule.messageLtResId();
+                String messageLt = messageLtResId != 0 ? view.getContext().getString(messageLtResId) : dateRule.messageLt();
+                Date ltDate = evaluateDate(ltTxt, dateFormat);
+                rules.add(Rules.ltDate(messageLt, ltDate, dateFormat));
+            } catch (ParseException e) {
+                throw new IllegalArgumentException(String.format("@%s.lt() cannot be parsed using pattern.",
+                        DateRule.class.getSimpleName()));
+            }
+        }
+
+        if (dateRule.gt().trim().length() > 0) {
+            String gtTxt = dateRule.gt();
+            try {
+                int messageGtResId = dateRule.messageGtResId();
+                String messageGt = messageGtResId != 0 ? view.getContext().getString(messageGtResId) : dateRule.messageGt();
+                Date gtDate = evaluateDate(gtTxt, dateFormat);
+                rules.add(Rules.gtDate(messageGt, gtDate, dateFormat));
+            } catch (ParseException e) {
+                throw new IllegalArgumentException(String.format("@%s.lt() cannot be parsed using pattern.",
+                        DateRule.class.getSimpleName()));
+            }
+        }
+
+        return rules;
+    }
+
+
+    public static void main(String[] args) {
+        DateFormat dateFormat = new SimpleDateFormat("dd/MM/yyyy HH:mm");
+        try {
+            System.out.println("new Date()            = " + dateFormat.format(new Date()));
+            System.out.println("now-1y+1M-1d+1h-1m+5s = " + dateFormat.format(evaluateDate("now-1y+1M-1d+1h-1m+5s", dateFormat)));
+            System.out.println("now-0y-1M+1d-1h+1m-3s = " + dateFormat.format(evaluateDate("now-0y-1M+1d-1h+1m-3s", dateFormat)));
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+    }
+
+    private static Date evaluateDate(String txt, DateFormat dateFormat) throws ParseException {
+        if (txt.startsWith("now")) {
+            List<String> splits = new ArrayList<String>();
+            txt = txt.substring(3);
+            String[] splittedPlus = txt.split("[+]");
+            for (String spitPlus : splittedPlus) {
+                if (spitPlus.length() > 0) {
+                    if (spitPlus.charAt(0) != '-') {
+                        spitPlus = "+" + spitPlus;
+                    }
+                    String[] splittedMinus = spitPlus.split("[-]");
+                    for (String splitMinus : splittedMinus) {
+                        if (splitMinus.length() > 0) {
+                            if (splitMinus.charAt(0) != '+') {
+                                splitMinus = "-" + splitMinus;
+                            }
+                            splits.add(splitMinus);
+                        }
+                    }
+                }
+            }
+            Calendar cal = GregorianCalendar.getInstance();
+            for (String split : splits) {
+                String operation = split.substring(0, 1);
+                String unit = split.substring(split.length() - 1, split.length());
+                String amount = split.substring(1, split.length() - 1);
+                int value = Integer.parseInt(amount) * (operation.equals("+") ? 1 : -1);
+                if (unit.equals("y")) {
+                    cal.add(Calendar.YEAR, value);
+                } else if (unit.equals("M")) {
+                    cal.add(Calendar.MONTH, value);
+                } else if (unit.equals("d")) {
+                    cal.add(Calendar.DAY_OF_YEAR, value);
+                } else if (unit.equals("h")) {
+                    cal.add(Calendar.HOUR_OF_DAY, value);
+                } else if (unit.equals("m")) {
+                    cal.add(Calendar.MINUTE, value);
+                } else if (unit.equals("s")) {
+                    cal.add(Calendar.SECOND, value);
+                } else {
+                    System.err.println("evaluateDate.invalid UNIT: '" + unit + "'");
+                }
+            }
+            return cal.getTime();
+        } else {
+            return dateFormat.parse(txt);
+        }
+    }
 }
diff --git a/src/com/mobsandgeeks/saripaar/Rules.java b/src/com/mobsandgeeks/saripaar/Rules.java
index ad74bac..739b524 100644
--- a/src/com/mobsandgeeks/saripaar/Rules.java
+++ b/src/com/mobsandgeeks/saripaar/Rules.java
@@ -19,6 +19,9 @@
 import android.view.View;
 import android.widget.*;
 
+import java.text.DateFormat;
+import java.text.ParseException;
+import java.util.Date;
 import java.util.LinkedHashMap;
 import java.util.Set;
 
@@ -707,4 +710,82 @@ private static String getText(final TextView textView, final boolean trim) {
         return text != null ? text.toString() : null;
     }
 
-}
+    /**
+     * Checks if the {@link TextView} or its subclass {@link View}'s displayed text value is using
+     * the dateFormat {@code String} pattern.
+     *
+     * @param failureMessage The failure message for this {@link Rule}.
+     * @param dateFormat     {@code String} value to be used for date pattern gor the text returned by
+     *                       {@code getText()}.
+     * @return True if the input text is parseable using the {@code dateFormat} value.
+     */
+    public static Rule<TextView> formatDate(final String failureMessage, final DateFormat dateFormat) {
+        return new Rule<TextView>(failureMessage) {
+
+            @Override
+            public boolean isValid(TextView view) {
+                String actualDateTxt = getText(view, true);
+                try {
+                    Date actualDate = dateFormat.parse(actualDateTxt);
+                    return true;
+                } catch (ParseException e) {
+                    return false;
+                }
+            }
+        };
+    }
+
+    /**
+     * Checks if the {@link TextView} or its subclass {@link View}'s displayed text value is less
+     * than the specified {@code int} value.
+     *
+     * @param failureMessage The failure message for this {@link Rule}.
+     * @param greaterDate     {@code Date} value to be compared with the text returned by
+     *                       {@code getText()}.
+     * @param dateFormat     {@code String} value to be used for date pattern gor the text returned by
+     *                       {@code getText()}.
+     * @return True if the input text is less than the {@code expectedInt} value.
+     */
+    public static Rule<TextView> ltDate(final String failureMessage, final Date greaterDate, final DateFormat dateFormat) {
+        return new Rule<TextView>(failureMessage) {
+
+            @Override
+            public boolean isValid(TextView view) {
+                String actualDateTxt = getText(view, true);
+                try {
+                    Date actualDate = dateFormat.parse(actualDateTxt);
+                    return actualDate.before(greaterDate);
+                } catch (ParseException e) {
+                    return false;
+                }
+            }
+        };
+    }
+
+    /**
+     * Checks if the {@link TextView} or its subclass {@link View}'s displayed text value is less
+     * than the specified {@code int} value.
+     *
+     * @param failureMessage The failure message for this {@link Rule}.
+     * @param greaterDate     {@code Date} value to be compared with the text returned by
+     *                       {@code getText()}.
+     * @param dateFormat     {@code String} value to be used for date pattern gor the text returned by
+     *                       {@code getText()}.
+     * @return True if the input text is less than the {@code expectedInt} value.
+     */
+    public static Rule<TextView> gtDate(final String failureMessage, final Date greaterDate, final DateFormat dateFormat) {
+        return new Rule<TextView>(failureMessage) {
+
+            @Override
+            public boolean isValid(TextView view) {
+                String actualDateTxt = getText(view, true);
+                try {
+                    Date actualDate = dateFormat.parse(actualDateTxt);
+                    return actualDate.after(greaterDate);
+                } catch (ParseException e) {
+                    return false;
+                }
+            }
+        };
+    }
+}
\ No newline at end of file
diff --git a/src/com/mobsandgeeks/saripaar/Validator.java b/src/com/mobsandgeeks/saripaar/Validator.java
index 0e181d3..c135a9b 100644
--- a/src/com/mobsandgeeks/saripaar/Validator.java
+++ b/src/com/mobsandgeeks/saripaar/Validator.java
@@ -14,29 +14,15 @@
 
 package com.mobsandgeeks.saripaar;
 
-import java.lang.annotation.Annotation;
-import java.lang.reflect.Field;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
 import android.os.AsyncTask;
 import android.util.Log;
 import android.view.View;
 import android.widget.TextView;
+import com.mobsandgeeks.saripaar.annotation.*;
 
-import com.mobsandgeeks.saripaar.annotation.Checked;
-import com.mobsandgeeks.saripaar.annotation.ConfirmPassword;
-import com.mobsandgeeks.saripaar.annotation.Email;
-import com.mobsandgeeks.saripaar.annotation.IpAddress;
-import com.mobsandgeeks.saripaar.annotation.NumberRule;
-import com.mobsandgeeks.saripaar.annotation.Password;
-import com.mobsandgeeks.saripaar.annotation.Regex;
-import com.mobsandgeeks.saripaar.annotation.Required;
-import com.mobsandgeeks.saripaar.annotation.TextRule;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Field;
+import java.util.*;
 
 /**
  * A processor that checks all the {@link Rule}s against their {@link View}s.
@@ -398,24 +384,26 @@ private void createRulesFromAnnotations(List<AnnotationFieldPair> annotationFiel
             }
 
             // Others
-            ViewRulePair viewRulePair = null;
+            List<ViewRulePair> viewRulePairs = new ArrayList<ViewRulePair>();
             if (pair.annotation.annotationType().equals(ConfirmPassword.class)) {
-                viewRulePair = getViewAndRule(pair.field, pair.annotation, passwordTextView);
+                viewRulePairs.addAll(getViewAndRule(pair.field, pair.annotation, passwordTextView));
             } else {
-                viewRulePair = getViewAndRule(pair.field, pair.annotation);
+                viewRulePairs.addAll(getViewAndRule(pair.field, pair.annotation));
             }
-            if (viewRulePair != null) {
-                if (DEBUG) {
-                    Log.d(TAG, String.format("Added @%s rule for %s.",
-                            pair.annotation.annotationType().getSimpleName(),
-                            pair.field.getName()));
+            for (ViewRulePair viewRulePair : viewRulePairs) {
+                if (viewRulePair != null) {
+                    if (DEBUG) {
+                        Log.d(TAG, String.format("Added @%s rule for %s.",
+                                pair.annotation.annotationType().getSimpleName(),
+                                pair.field.getName()));
+                    }
+                    mViewsAndRules.add(viewRulePair);
                 }
-                mViewsAndRules.add(viewRulePair);
             }
         }
     }
 
-    private ViewRulePair getViewAndRule(Field field, Annotation annotation, Object... params) {
+    private List<ViewRulePair> getViewAndRule(Field field, Annotation annotation, Object... params) {
         View view = getView(field);
         if (view == null) {
             Log.w(TAG, String.format("Your %s - %s is null. Please check your field assignment(s).",
@@ -423,14 +411,19 @@ private ViewRulePair getViewAndRule(Field field, Annotation annotation, Object..
             return null;
         }
 
-        Rule<?> rule = null;
+        List<Rule<?>> rules = new ArrayList<Rule<?>>();
         if (params != null && params.length > 0) {
-            rule = AnnotationToRuleConverter.getRule(field, view, annotation, params);
+            rules.add(AnnotationToRuleConverter.getRule(field, view, annotation, params));
         } else {
-            rule = AnnotationToRuleConverter.getRule(field, view, annotation);
+            rules.add(AnnotationToRuleConverter.getRule(field, view, annotation));
+            rules.addAll(AnnotationToRuleConverter.getRules(field, view, annotation));
         }
-
-        return rule != null ? new ViewRulePair(view, rule) : null;
+        List<ViewRulePair> retList = new ArrayList<ViewRulePair>();
+        for (Rule<?> rule : rules) {
+            if(rule!=null)
+                retList.add(new ViewRulePair(view, rule));
+        }
+        return retList;
     }
 
     private View getView(Field field) {
@@ -521,7 +514,8 @@ private boolean isSaripaarAnnotation(Annotation annotation) {
                 annotationType.equals(Password.class) ||
                 annotationType.equals(Regex.class) ||
                 annotationType.equals(Required.class) ||
-                annotationType.equals(TextRule.class);
+                annotationType.equals(TextRule.class) ||
+                annotationType.equals(DateRule.class);
     }
 
     private class ViewRulePair {
@@ -582,6 +576,9 @@ private int getAnnotationOrder(Annotation annotation) {
             } else if (annotatedClass.equals(TextRule.class)) {
                 return ((TextRule) annotation).order();
 
+            } else if (annotatedClass.equals(DateRule.class)) {
+                return ((DateRule) annotation).order();
+
             } else {
                 throw new IllegalArgumentException(String.format("%s is not a Saripaar annotation",
                         annotatedClass.getName()));
diff --git a/src/com/mobsandgeeks/saripaar/annotation/DateRule.java b/src/com/mobsandgeeks/saripaar/annotation/DateRule.java
new file mode 100644
index 0000000..e234cc2
--- /dev/null
+++ b/src/com/mobsandgeeks/saripaar/annotation/DateRule.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2012 Mobs and Geeks
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file 
+ * except in compliance with the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the 
+ * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, 
+ * either express or implied. See the License for the specific language governing permissions and 
+ * limitations under the License.
+ */
+
+package com.mobsandgeeks.saripaar.annotation;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Date rule annotation. Allows to specify a specific pattern type.
+ * Additional options such as greater than (>), less than (<) and equals (==) are available.
+ *
+ * @author Schuller Tom <tom@schuller.lu>
+ */
+@Target(ElementType.FIELD)
+@Retention(RetentionPolicy.RUNTIME)
+public @interface DateRule {
+    public int order();
+    public String pattern();
+    public String gt() default "";
+    public String lt() default "";
+    public String messageParse()     default "Incorrect date format.";
+    public String messageGt()     default "Date to low.";
+    public String messageLt()     default "Date to high.";
+    public int messageParseResId()   default 0;
+    public int messageGtResId()   default 0;
+    public int messageLtResId()   default 0;
+}
