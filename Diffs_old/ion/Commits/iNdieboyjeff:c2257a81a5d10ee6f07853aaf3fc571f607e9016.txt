diff --git a/README.md b/README.md
index 8cba5619..0368081d 100644
--- a/README.md
+++ b/README.md
@@ -9,7 +9,7 @@
 
 #### Features
  * Asynchronously download:
-   * [Images](https://github.com/koush/ion#load-an-image-into-an-imageview) (into ImageViews or Bitmaps)
+   * [Images](https://github.com/koush/ion#load-an-image-into-an-imageview) into ImageViews or Bitmaps (animated GIFs supported too)
    * [JSON](https://github.com/koush/ion#get-json) (via [Gson](https://code.google.com/p/google-gson/))
    * Strings
    * [Files](https://github.com/koush/ion#download-a-file-with-a-progress-bar)
diff --git a/ion-sample/src/com/koushikdutta/ion/sample/ImageViewSample.java b/ion-sample/src/com/koushikdutta/ion/sample/ImageViewSample.java
index af922d42..9dc4ce9a 100644
--- a/ion-sample/src/com/koushikdutta/ion/sample/ImageViewSample.java
+++ b/ion-sample/src/com/koushikdutta/ion/sample/ImageViewSample.java
@@ -32,6 +32,24 @@ public void loadCenterInside() {
         .intoImageView(imageView);
     }
 
+    public void loadGifCenterCrop() {
+        Ion.with(this)
+        .load("https://raw.github.com/koush/ion/master/mark.gif")
+        .withBitmap()
+        .resize(512, 512)
+        .centerCrop()
+        .intoImageView(imageView);
+    }
+
+    public void loadGifCenterInside() {
+        Ion.with(this)
+        .load("https://raw.github.com/koush/ion/master/mark.gif")
+        .withBitmap()
+        .resize(512, 512)
+        .centerInside()
+        .intoImageView(imageView);
+    }
+
     Spinner fitChoices;
     ImageView imageView;
     @Override
@@ -45,14 +63,20 @@ protected void onCreate(Bundle savedInstanceState) {
         ArrayAdapter<String> adapter = new ArrayAdapter<String>(this, android.R.layout.simple_spinner_dropdown_item);
         adapter.add("centerCrop");
         adapter.add("centerInside");
+        adapter.add("gif centerCrop");
+        adapter.add("gif centerInside");
         fitChoices.setAdapter(adapter);
         fitChoices.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {
             @Override
             public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
                 if (position == 0)
                     loadCenterCrop();
-                else
+                else if (position == 1)
                     loadCenterInside();
+                else if (position == 2)
+                    loadGifCenterCrop();
+                else
+                    loadGifCenterInside();
             }
 
             @Override
diff --git a/ion/src/com/koushikdutta/ion/BitmapCallback.java b/ion/src/com/koushikdutta/ion/BitmapCallback.java
index ccea19a5..70e6df84 100644
--- a/ion/src/com/koushikdutta/ion/BitmapCallback.java
+++ b/ion/src/com/koushikdutta/ion/BitmapCallback.java
@@ -31,7 +31,7 @@ public void run() {
                 if (result == null) {
                     // cache errors
                     result = new BitmapInfo();
-                    result.bitmap = null;
+                    result.bitmaps = null;
                     result.key = key;
                     ion.getBitmapCache().put(result);
                 } else if (put()) {
diff --git a/ion/src/com/koushikdutta/ion/BitmapToBitmapInfo.java b/ion/src/com/koushikdutta/ion/BitmapToBitmapInfo.java
index cc2641f7..10cac6f0 100644
--- a/ion/src/com/koushikdutta/ion/BitmapToBitmapInfo.java
+++ b/ion/src/com/koushikdutta/ion/BitmapToBitmapInfo.java
@@ -24,7 +24,7 @@ public static void getBitmapSnapshot(final Ion ion, final String transformKey) {
         ion.getServer().getExecutorService().execute(new Runnable() {
             @Override
             public void run() {
-                final LoadBitmap callback = new LoadBitmap(ion, transformKey, true, -1, -1, Loader.LoaderEmitter.LOADED_FROM_CACHE);
+                final LoadBitmap callback = new LoadBitmap(ion, transformKey, true, -1, -1, null);
 
                 try {
                     DiskLruCache.Snapshot snapshot = ion.getResponseCache().getDiskLruCache().get(transformKey);
@@ -78,14 +78,15 @@ public void onCompleted(Exception e, final BitmapInfo result) {
             @Override
             public void run() {
                 BitmapInfo info = new BitmapInfo();
+                info.bitmaps = new Bitmap[result.bitmaps.length];
                 try {
-                    Bitmap tmpBitmap = result.bitmap;
-                    for (Transform transform : transforms) {
-//                            builder.request.logd("applying transform: " + transform.key());
-                        tmpBitmap = transform.transform(tmpBitmap);
+                    for (int i = 0; i < result.bitmaps.length; i++) {
+                        for (Transform transform : transforms) {
+                            info.bitmaps[i] = transform.transform(result.bitmaps[i]);
+                        }
                     }
+                    info.delays = result.delays;
                     info.loadedFrom = result.loadedFrom;
-                    info.bitmap = tmpBitmap;
                     info.key = key;
                     report(null, info);
                 } catch (Exception e) {
@@ -94,6 +95,9 @@ public void run() {
                 }
                 // the transformed bitmap was successfully load it, let's toss it into
                 // the disk lru cache.
+                // but don't persist gifs...
+                if (info.bitmaps.length > 1)
+                    return;
                 try {
                     DiskLruCache cache = ion.getResponseCache().getDiskLruCache();
                     if (cache == null)
@@ -106,8 +110,8 @@ public void run() {
                             editor.set(i, key);
                         }
                         OutputStream out = editor.newOutputStream(0);
-                        Bitmap.CompressFormat format = info.bitmap.hasAlpha() ? Bitmap.CompressFormat.PNG : Bitmap.CompressFormat.JPEG;
-                        info.bitmap.compress(format, 100, out);
+                        Bitmap.CompressFormat format = info.bitmaps[0].hasAlpha() ? Bitmap.CompressFormat.PNG : Bitmap.CompressFormat.JPEG;
+                        info.bitmaps[0].compress(format, 100, out);
                         out.close();
                         editor.commit();
                     }
diff --git a/ion/src/com/koushikdutta/ion/IonBitmapRequestBuilder.java b/ion/src/com/koushikdutta/ion/IonBitmapRequestBuilder.java
index b1b3f5e9..b00f046f 100644
--- a/ion/src/com/koushikdutta/ion/IonBitmapRequestBuilder.java
+++ b/ion/src/com/koushikdutta/ion/IonBitmapRequestBuilder.java
@@ -1,7 +1,6 @@
 package com.koushikdutta.ion;
 
 import android.graphics.Bitmap;
-import android.graphics.Canvas;
 import android.graphics.drawable.Drawable;
 import android.os.Looper;
 import android.view.animation.Animation;
@@ -13,7 +12,6 @@
 import com.koushikdutta.async.future.Future;
 import com.koushikdutta.async.future.SimpleFuture;
 import com.koushikdutta.async.future.TransformFuture;
-import com.koushikdutta.async.http.AsyncHttpRequest;
 import com.koushikdutta.async.http.ResponseCacheMiddleware;
 import com.koushikdutta.async.http.libcore.DiskLruCache;
 import com.koushikdutta.async.parser.ByteBufferListParser;
@@ -23,9 +21,7 @@
 import com.koushikdutta.ion.builder.Builders;
 import com.koushikdutta.ion.builder.ImageViewFutureBuilder;
 
-import java.io.InputStream;
 import java.lang.ref.WeakReference;
-import java.net.URI;
 import java.util.ArrayList;
 
 /**
@@ -130,7 +126,7 @@ public void run() {
                     });
                 }
             });
-            emitterTransform.setCallback(new LoadBitmap(ion, downloadKey, !hasTransforms, resizeWidth, resizeHeight, emitterTransform.loadedFrom()));
+            emitterTransform.setCallback(new LoadBitmap(ion, downloadKey, !hasTransforms, resizeWidth, resizeHeight, emitterTransform));
         }
 
         // if there's a transform, do it
@@ -208,7 +204,7 @@ private IonDrawable setIonDrawable(ImageView imageView, BitmapInfo info, int loa
     private static class BitmapInfoToBitmap extends TransformFuture<Bitmap, BitmapInfo> {
         @Override
         protected void transform(BitmapInfo result) throws Exception {
-            setComplete(result.bitmap);
+            setComplete(result.bitmaps[0]);
         }
     }
 
@@ -223,7 +219,7 @@ protected void transform(BitmapInfo result) throws Exception {
         BitmapInfo info = execute();
         if (info != null) {
             SimpleFuture<Bitmap> ret = new SimpleFuture<Bitmap>();
-            ret.setComplete(info.bitmap);
+            ret.setComplete(info.bitmaps[0]);
             return ret;
         }
 
diff --git a/ion/src/com/koushikdutta/ion/IonDrawable.java b/ion/src/com/koushikdutta/ion/IonDrawable.java
index 5a7ecfd5..a4add3f4 100644
--- a/ion/src/com/koushikdutta/ion/IonDrawable.java
+++ b/ion/src/com/koushikdutta/ion/IonDrawable.java
@@ -1,7 +1,11 @@
 package com.koushikdutta.ion;
 
 import android.content.res.Resources;
-import android.graphics.*;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.ColorFilter;
+import android.graphics.Paint;
+import android.graphics.PixelFormat;
 import android.graphics.drawable.Drawable;
 import android.os.Looper;
 import android.os.SystemClock;
@@ -9,20 +13,17 @@
 import android.view.animation.Animation;
 import android.widget.ImageView;
 
-import com.koushikdutta.async.future.Future;
 import com.koushikdutta.async.future.FutureCallback;
 import com.koushikdutta.async.future.SimpleFuture;
 import com.koushikdutta.ion.bitmap.BitmapInfo;
 
 import java.lang.ref.WeakReference;
-import java.util.ArrayList;
 
 /**
  * Created by koush on 6/8/13.
  */
 class IonDrawable extends Drawable {
     private Paint paint;
-    private Bitmap bitmap;
     private BitmapInfo info;
     private int placeholderResource;
     private Drawable placeholder;
@@ -125,7 +126,8 @@ public IonDrawable(Resources resources, ImageView imageView) {
         callback = new IonDrawableCallback(this, imageView);
     }
 
-
+    int currentFrame;
+    private boolean invalidateScheduled;
     public IonDrawable setBitmap(BitmapInfo info, int loadedFrom) {
         this.loadedFrom = loadedFrom;
 
@@ -135,14 +137,14 @@ public IonDrawable setBitmap(BitmapInfo info, int loadedFrom) {
         invalidateSelf();
 
         this.info = info;
+        currentFrame = 0;
+        invalidateScheduled = false;
         if (info == null) {
             callback.bitmapKey = null;
-            bitmap = null;
             return this;
         }
 
         callback.bitmapKey = info.key;
-        this.bitmap = info.bitmap;
         return this;
     }
 
@@ -181,8 +183,8 @@ public void setDither(boolean dither) {
 
     @Override
     public int getIntrinsicWidth() {
-        if (bitmap != null)
-            return bitmap.getScaledWidth(resources.getDisplayMetrics().densityDpi);
+        if (info != null && info.bitmaps != null)
+            return info.bitmaps[0].getScaledWidth(resources.getDisplayMetrics().densityDpi);
         if (error != null)
             return error.getIntrinsicWidth();
         if (placeholder != null)
@@ -192,8 +194,8 @@ public int getIntrinsicWidth() {
 
     @Override
     public int getIntrinsicHeight() {
-        if (bitmap != null)
-            return bitmap.getScaledHeight(resources.getDisplayMetrics().densityDpi);
+        if (info != null && info.bitmaps != null)
+            return info.bitmaps[0].getScaledHeight(resources.getDisplayMetrics().densityDpi);
         if (error != null)
             return error.getIntrinsicHeight();
         if (placeholder != null)
@@ -202,6 +204,14 @@ public int getIntrinsicHeight() {
     }
 
     public static final long FADE_DURATION = 200;
+    private Runnable invalidate = new Runnable() {
+        @Override
+        public void run() {
+            invalidateScheduled = false;
+            currentFrame++;
+            invalidateSelf();
+        }
+    };
 
     @Override
     public void draw(Canvas canvas) {
@@ -234,10 +244,18 @@ public void draw(Canvas canvas) {
             }
         }
 
-        if (bitmap != null) {
+        if (info.bitmaps != null) {
             paint.setAlpha((int)destAlpha);
-            canvas.drawBitmap(bitmap, null, getBounds(), paint);
+            canvas.drawBitmap(info.bitmaps[currentFrame % info.bitmaps.length], null, getBounds(), paint);
             paint.setAlpha(0xFF);
+            if (info.delays != null) {
+                int delay = info.delays[currentFrame % info.delays.length];
+                if (!invalidateScheduled) {
+                    invalidateScheduled = true;
+                    unscheduleSelf(invalidate);
+                    scheduleSelf(invalidate, SystemClock.uptimeMillis() + Math.max(delay, 100));
+                }
+            }
         }
         else {
             if (error == null && errorResource != 0)
@@ -297,7 +315,7 @@ public void setColorFilter(ColorFilter cf) {
 
     @Override
     public int getOpacity() {
-        return (bitmap == null || bitmap.hasAlpha() || paint.getAlpha() < 255) ?
+        return (info == null || info.bitmaps == null || info.bitmaps[0].hasAlpha() || paint.getAlpha() < 255) ?
                 PixelFormat.TRANSLUCENT : PixelFormat.OPAQUE;
     }
 
diff --git a/ion/src/com/koushikdutta/ion/IonRequestBuilder.java b/ion/src/com/koushikdutta/ion/IonRequestBuilder.java
index a52b44c0..32b74d5e 100644
--- a/ion/src/com/koushikdutta/ion/IonRequestBuilder.java
+++ b/ion/src/com/koushikdutta/ion/IonRequestBuilder.java
@@ -308,7 +308,7 @@ public void onProgress(final int downloaded, final int total) {
                             public void run() {
                                 if (ret.isCancelled() || ret.isDone())
                                     return;
-                                progressHandler.onProgress(downloaded, total);
+                                uploadProgressHandler.onProgress(downloaded, total);
                             }
                         });
                     }
@@ -329,10 +329,12 @@ public void run() {
         ret.setComplete(new Exception("Unknown uri scheme"));
     }
 
+    // transforms a LoaderEmitter, which is a DataEmitter and all associated properties about the data source
+    // into the final result.
     class EmitterTransform<T> extends TransformFuture<T, LoaderEmitter> implements ResponseFuture<T> {
-        private AsyncHttpRequest initialRequest;
-        private AsyncHttpRequest finalRequest;
-        private int loadedFrom;
+        AsyncHttpRequest initialRequest;
+        AsyncHttpRequest finalRequest;
+        int loadedFrom;
         Runnable cancelCallback;
         RawHeaders headers;
         DataEmitter emitter;
diff --git a/ion/src/com/koushikdutta/ion/LoadBitmap.java b/ion/src/com/koushikdutta/ion/LoadBitmap.java
index fe2bd597..17634aa7 100644
--- a/ion/src/com/koushikdutta/ion/LoadBitmap.java
+++ b/ion/src/com/koushikdutta/ion/LoadBitmap.java
@@ -7,7 +7,10 @@
 import com.koushikdutta.async.ByteBufferList;
 import com.koushikdutta.async.future.FutureCallback;
 import com.koushikdutta.ion.bitmap.BitmapInfo;
+import com.koushikdutta.ion.gif.GifAction;
+import com.koushikdutta.ion.gif.GifDecoder;
 
+import java.net.URI;
 import java.nio.ByteBuffer;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
@@ -15,7 +18,7 @@
 class LoadBitmap extends BitmapCallback implements FutureCallback<ByteBufferList> {
     int resizeWidth;
     int resizeHeight;
-    int loadedFrom;
+    IonRequestBuilder.EmitterTransform<ByteBufferList> emitterTransform;
     static ExecutorService singleExecutorService;
 
     static {
@@ -25,15 +28,28 @@
         }
     }
 
-    public LoadBitmap(Ion ion, String urlKey, boolean put, int resizeWidth, int resizeHeight, int loadedFrom) {
+    public LoadBitmap(Ion ion, String urlKey, boolean put, int resizeWidth, int resizeHeight, IonRequestBuilder.EmitterTransform<ByteBufferList> emitterTransform) {
         super(ion, urlKey, put);
         this.resizeWidth = resizeWidth;
         this.resizeHeight = resizeHeight;
-        this.loadedFrom = loadedFrom;
+        this.emitterTransform = emitterTransform;
 
         ion.bitmapsPending.tag(urlKey, this);
     }
 
+    private boolean isGif() {
+        if (emitterTransform == null)
+            return false;
+        if (emitterTransform.finalRequest != null) {
+            URI uri = emitterTransform.finalRequest.getUri();
+            if (uri != null && uri.toString().endsWith(".gif"))
+                return true;
+        }
+        if (emitterTransform.headers == null)
+            return false;
+        return "image/gif".equals(emitterTransform.headers.get("Content-Type"));
+    }
+
     @Override
     public void onCompleted(Exception e, final ByteBufferList result) {
         if (e != null) {
@@ -57,15 +73,38 @@ public void onCompleted(Exception e, final ByteBufferList result) {
             public void run() {
                 ByteBuffer bb = result.getAll();
                 try {
-                    Bitmap bitmap = ion.bitmapCache.loadBitmap(bb.array(), bb.arrayOffset() + bb.position(), bb.remaining(), resizeWidth, resizeHeight);
+                    Bitmap[] bitmaps;
+                    int[] delays;
+                    if (!isGif()) {
+                        bitmaps = new Bitmap[1];
+                        bitmaps[0] = ion.bitmapCache.loadBitmap(bb.array(), bb.arrayOffset() + bb.position(), bb.remaining(), resizeWidth, resizeHeight);
+                        delays = null;
+                    }
+                    else {
+                        GifDecoder decoder = new GifDecoder(bb.array(), bb.arrayOffset() + bb.position(), bb.remaining(), new GifAction() {
+                            @Override
+                            public void parseOk(boolean parseStatus, int frameIndex) {
+                            }
+                        });
+                        decoder.run();
+                        bitmaps = new Bitmap[decoder.getFrameCount()];
+                        delays = decoder.getDelays();
+                        for (int i = 0; i < decoder.getFrameCount(); i++) {
+                            bitmaps[i] = decoder.getFrameImage(i);
+                        }
+                    }
 
-                    if (bitmap == null)
+                    if (bitmaps[0] == null)
                         throw new Exception("bitmap failed to load");
 
                     BitmapInfo info = new BitmapInfo();
                     info.key = key;
-                    info.bitmap = bitmap;
-                    info.loadedFrom = loadedFrom;
+                    info.bitmaps = bitmaps;
+                    info.delays = delays;
+                    if (emitterTransform != null)
+                        info.loadedFrom = emitterTransform.loadedFrom();
+                    else
+                        info.loadedFrom = Loader.LoaderEmitter.LOADED_FROM_CACHE;
 
                     report(null, info);
                 } catch (Exception e) {
diff --git a/ion/src/com/koushikdutta/ion/LoadBitmapStream.java b/ion/src/com/koushikdutta/ion/LoadBitmapStream.java
index 0b46ed91..26fcc66e 100644
--- a/ion/src/com/koushikdutta/ion/LoadBitmapStream.java
+++ b/ion/src/com/koushikdutta/ion/LoadBitmapStream.java
@@ -27,7 +27,7 @@ public void loadInputStream(InputStream result) {
 
             BitmapInfo info = new BitmapInfo();
             info.key = key;
-            info.bitmap = bitmap;
+            info.bitmaps = new Bitmap[] { bitmap };
             info.loadedFrom = Loader.LoaderEmitter.LOADED_FROM_CACHE;
 
             report(null, info);
diff --git a/ion/src/com/koushikdutta/ion/bitmap/BitmapInfo.java b/ion/src/com/koushikdutta/ion/bitmap/BitmapInfo.java
index 38c976d5..3e9c486f 100644
--- a/ion/src/com/koushikdutta/ion/bitmap/BitmapInfo.java
+++ b/ion/src/com/koushikdutta/ion/bitmap/BitmapInfo.java
@@ -10,5 +10,12 @@
     public long drawTime;
     public String key;
     public int loadedFrom;
-    public Bitmap bitmap;
+    public Bitmap[] bitmaps;
+    public int[] delays;
+
+    public int sizeOf() {
+        if (bitmaps == null)
+            return 0;
+        return bitmaps[0].getRowBytes() * bitmaps[0].getHeight() * bitmaps.length;
+    }
 }
diff --git a/ion/src/com/koushikdutta/ion/bitmap/GifBitmapInfo.java b/ion/src/com/koushikdutta/ion/bitmap/GifBitmapInfo.java
new file mode 100644
index 00000000..deac6343
--- /dev/null
+++ b/ion/src/com/koushikdutta/ion/bitmap/GifBitmapInfo.java
@@ -0,0 +1,10 @@
+package com.koushikdutta.ion.bitmap;
+
+import android.graphics.Bitmap;
+
+/**
+ * Created by koush on 10/21/13.
+ */
+public class GifBitmapInfo extends BitmapInfo {
+
+}
diff --git a/ion/src/com/koushikdutta/ion/bitmap/IonBitmapCache.java b/ion/src/com/koushikdutta/ion/bitmap/IonBitmapCache.java
index 7627b198..ee53f69d 100644
--- a/ion/src/com/koushikdutta/ion/bitmap/IonBitmapCache.java
+++ b/ion/src/com/koushikdutta/ion/bitmap/IonBitmapCache.java
@@ -60,7 +60,7 @@ public BitmapInfo get(String key) {
             return null;
         assert Thread.currentThread() == Looper.getMainLooper().getThread();
         BitmapInfo ret = cache.get(key);
-        if (ret == null || ret.bitmap != null)
+        if (ret == null || ret.bitmaps != null)
             return ret;
 
         // if this bitmap load previously errored out, see if it is time to retry
diff --git a/ion/src/com/koushikdutta/ion/bitmap/LruBitmapCache.java b/ion/src/com/koushikdutta/ion/bitmap/LruBitmapCache.java
index fc7d51d8..2fa31cf1 100644
--- a/ion/src/com/koushikdutta/ion/bitmap/LruBitmapCache.java
+++ b/ion/src/com/koushikdutta/ion/bitmap/LruBitmapCache.java
@@ -1,26 +1,12 @@
 package com.koushikdutta.ion.bitmap;
 
-import android.graphics.Bitmap;
-import com.koushikdutta.ion.Ion;
-
 class LruBitmapCache extends LruCache<String, BitmapInfo> {
     public LruBitmapCache(int maxSize) {
         super(maxSize);
     }
 
-//    @Override
-//    protected void entryRemoved(boolean evicted, String key, Bitmap oldValue, Bitmap newValue) {
-//        super.entryRemoved(evicted, key, oldValue, newValue);
-//        if (evicted && oldValue != null) {
-//            oldValue.recycle();
-//        }
-//    }
-
     @Override
     protected int sizeOf(String key, BitmapInfo info) {
-        Bitmap value = info.bitmap;
-        if (value == null)
-            return 0;
-        return value.getRowBytes() * value.getHeight();
+        return info.sizeOf();
     }
 }
diff --git a/ion/src/com/koushikdutta/ion/gif/GifAction.java b/ion/src/com/koushikdutta/ion/gif/GifAction.java
new file mode 100755
index 00000000..b1ae2a16
--- /dev/null
+++ b/ion/src/com/koushikdutta/ion/gif/GifAction.java
@@ -0,0 +1,5 @@
+package com.koushikdutta.ion.gif;
+
+public interface GifAction {
+    public void parseOk(boolean parseStatus, int frameIndex);
+}
diff --git a/ion/src/com/koushikdutta/ion/gif/GifDecoder.java b/ion/src/com/koushikdutta/ion/gif/GifDecoder.java
new file mode 100755
index 00000000..36f77942
--- /dev/null
+++ b/ion/src/com/koushikdutta/ion/gif/GifDecoder.java
@@ -0,0 +1,705 @@
+package com.koushikdutta.ion.gif;
+
+import java.io.ByteArrayInputStream;
+import java.io.InputStream;
+
+import android.graphics.Bitmap;
+import android.graphics.Bitmap.Config;
+import android.util.Log;
+
+public class GifDecoder extends Thread{
+
+	public static final int STATUS_PARSING = 0;
+	public static final int STATUS_FORMAT_ERROR = 1;
+	public static final int STATUS_OPEN_ERROR = 2;
+	public static final int STATUS_FINISH = -1;
+	
+	private InputStream in;
+	private int status;
+
+	public int width; // full image width
+	public int height; // full image height
+	private boolean gctFlag; // global color table used
+	private int gctSize; // size of global color table
+	private int loopCount = 1; // iterations; 0 = repeat forever
+
+	private int[] gct; // global color table
+	private int[] lct; // local color table
+	private int[] act; // active color table
+
+	private int bgIndex; // background color index
+	private int bgColor; // background color
+	private int lastBgColor; // previous bg color
+	private int pixelAspect; // pixel aspect ratio
+
+	private boolean lctFlag; // local color table flag
+	private boolean interlace; // interlace flag
+	private int lctSize; // local color table size
+
+	private int ix, iy, iw, ih; // current image rectangle
+	private int lrx, lry, lrw, lrh;
+	private Bitmap image; // current frame
+	private Bitmap lastImage; // previous frame
+	private GifFrame currentFrame = null;
+
+	private boolean isShow = false;
+	
+
+	private byte[] block = new byte[256]; // current data block
+	private int blockSize = 0; // block size
+	private int dispose = 0;
+	private int lastDispose = 0;
+	private boolean transparency = false; // use transparent color
+	private int delay = 0; // delay in milliseconds
+	private int transIndex; // transparent color index
+
+	private static final int MaxStackSize = 4096;
+	// max decoder pixel stack size
+
+	// LZW decoder working arrays
+	private short[] prefix;
+	private byte[] suffix;
+	private byte[] pixelStack;
+	private byte[] pixels;
+
+	private GifFrame gifFrame; // frames read from current file
+	private int frameCount;
+
+	private GifAction action = null;
+	
+	
+	private byte[] gifData = null;
+	private int gifDataOffset;
+	private int gifDataLength;
+
+
+	public GifDecoder(byte[] data,GifAction act){
+		this(data, 0, data.length, act);
+	}
+
+	public GifDecoder(byte[] data,int offset,int length,GifAction act){
+		gifData = data;
+		action = act;
+		gifDataOffset = offset;
+		gifDataLength = length;
+	}
+	
+	public GifDecoder(InputStream is,GifAction act){
+		in = is;
+		action = act;
+	}
+
+	public void run(){
+		if(in != null){
+                  readStream();
+		}else if(gifData != null){
+                  readByte();
+		}
+	}
+	
+	public void free(){
+		GifFrame fg = gifFrame;
+		while(fg != null){
+            if (fg.image != null) {
+                fg.image.recycle();
+            }
+			fg.image = null;
+			fg = null;
+			gifFrame = gifFrame.nextFrame;
+			fg = gifFrame;
+		}
+		if(in != null){
+			try{
+			in.close();
+			}catch(Exception ex){}
+			in = null;
+		}
+		gifData = null;
+		if (image != null)
+		{
+            image.recycle();
+            image = null;
+		}
+		if (lastImage != null)
+		{
+            lastImage.recycle();
+            lastImage = null;
+		}		
+	}
+	
+	public int getStatus(){
+		return status;
+	}
+	
+	public boolean parseOk(){
+		return status == STATUS_FINISH;
+	}
+	
+	public int getDelay(int n) {
+		delay = -1;
+		if ((n >= 0) && (n < frameCount)) {
+			GifFrame f = getFrame(n);
+			if (f != null)
+				delay = f.delay;
+		}
+		return delay;
+	}
+	
+	public int[] getDelays(){
+		GifFrame f = gifFrame;
+		int[] d = new int[frameCount];
+		int i = 0;
+		while(f != null && i < frameCount){
+			d[i] = f.delay;
+			f = f.nextFrame;
+			i++;
+		}
+		return d;
+	}
+	
+	public int getFrameCount() {
+		return frameCount;
+	}
+
+	public Bitmap getImage() {
+		return getFrameImage(0);
+	}
+
+	public int getLoopCount() {
+		return loopCount;
+	}
+
+	private void setPixels() {
+		int[] dest = new int[width * height];
+		// fill in starting image contents based on last image's dispose code
+		if (lastDispose > 0) {
+			if (lastDispose == 3) {
+				// use image before last
+				int n = frameCount - 2;
+				if (n > 0) {
+					lastImage = getFrameImage(n - 1);
+				} else {
+					lastImage = null;
+				}
+			}
+			if (lastImage != null) {
+				lastImage.getPixels(dest, 0, width, 0, 0, width, height);
+				// copy pixels
+				if (lastDispose == 2) {
+					// fill last image rect area with background color
+					int c = 0;
+					if (!transparency) {
+						c = lastBgColor;
+					}
+					for (int i = 0; i < lrh; i++) {
+						int n1 = (lry + i) * width + lrx;
+						int n2 = n1 + lrw;
+						for (int k = n1; k < n2; k++) {
+							dest[k] = c;
+						}
+					}
+				}
+			}
+		}
+
+		// copy each source line to the appropriate place in the destination
+		int pass = 1;
+		int inc = 8;
+		int iline = 0;
+		for (int i = 0; i < ih; i++) {
+			int line = i;
+			if (interlace) {
+				if (iline >= ih) {
+					pass++;
+					switch (pass) {
+					case 2:
+						iline = 4;
+						break;
+					case 3:
+						iline = 2;
+						inc = 4;
+						break;
+					case 4:
+						iline = 1;
+						inc = 2;
+					}
+				}
+				line = iline;
+				iline += inc;
+			}
+			line += iy;
+			if (line < height) {
+				int k = line * width;
+				int dx = k + ix; // start of line in dest
+				int dlim = dx + iw; // end of dest line
+				if ((k + width) < dlim) {
+					dlim = k + width; // past dest edge
+				}
+				int sx = i * iw; // start of line in source
+				while (dx < dlim) {
+					// map color and insert in destination
+					int index = ((int) pixels[sx++]) & 0xff;
+					int c = act[index];
+					if (c != 0) {
+						dest[dx] = c;
+					}
+					dx++;
+				}
+			}
+		}
+		image = Bitmap.createBitmap(dest, width, height, Config.ARGB_4444);
+	}
+
+	public Bitmap getFrameImage(int n) {
+		GifFrame frame = getFrame(n);	
+		if (frame == null)
+			return null;
+		else
+			return frame.image;
+	}
+
+	public GifFrame getCurrentFrame(){
+		return currentFrame;
+	}
+	
+	public GifFrame getFrame(int n) {
+		GifFrame frame = gifFrame;
+		int i = 0;
+		while (frame != null) {
+			if (i == n) {
+				return frame;
+			} else {
+				frame = frame.nextFrame;
+			}
+			i++;
+		}
+		return null;
+	}
+
+	public void reset(){
+		currentFrame = gifFrame;
+	}
+	
+	public GifFrame next() {	
+		if(isShow == false){
+			isShow = true;
+			return gifFrame;
+		}else{	
+			if(status == STATUS_PARSING){
+				if(currentFrame.nextFrame != null)
+					currentFrame = currentFrame.nextFrame;			
+				//currentFrame = gifFrame;
+			}else{			
+				currentFrame = currentFrame.nextFrame;
+				if (currentFrame == null) {
+					currentFrame = gifFrame;
+				}
+			}
+			return currentFrame;
+		}
+	}
+
+	private int readByte(){
+		in = new ByteArrayInputStream(gifData,gifDataOffset,gifDataLength);
+		gifData = null;
+		return readStream();
+	}
+	
+	private int readStream(){
+		init();
+		if(in != null){
+			readHeader();
+			if(!err()){
+				readContents();
+				if(frameCount < 0){
+					status = STATUS_FORMAT_ERROR;
+					action.parseOk(false,-1);
+				}else{
+					status = STATUS_FINISH;
+					action.parseOk(true,-1);
+				}
+			}
+			try {
+				in.close();
+			} catch (Exception e) {
+				e.printStackTrace();
+			}
+			
+		}else {
+			status = STATUS_OPEN_ERROR;
+			action.parseOk(false,-1);
+		}
+		return status;
+	}
+
+	private void decodeImageData() {
+		int NullCode = -1;
+		int npix = iw * ih;
+		int available, clear, code_mask, code_size, end_of_information, in_code, old_code, bits, code, count, i, datum, data_size, first, top, bi, pi;
+
+		if ((pixels == null) || (pixels.length < npix)) {
+			pixels = new byte[npix]; // allocate new pixel array
+		}
+		if (prefix == null) {
+			prefix = new short[MaxStackSize];
+		}
+		if (suffix == null) {
+			suffix = new byte[MaxStackSize];
+		}
+		if (pixelStack == null) {
+			pixelStack = new byte[MaxStackSize + 1];
+		}
+		// Initialize GIF data stream decoder.
+		data_size = read();
+		clear = 1 << data_size;
+		end_of_information = clear + 1;
+		available = clear + 2;
+		old_code = NullCode;
+		code_size = data_size + 1;
+		code_mask = (1 << code_size) - 1;
+		for (code = 0; code < clear; code++) {
+			prefix[code] = 0;
+			suffix[code] = (byte) code;
+		}
+
+		// Decode GIF pixel stream.
+		datum = bits = count = first = top = pi = bi = 0;
+		for (i = 0; i < npix;) {
+			if (top == 0) {
+				if (bits < code_size) {
+					// Load bytes until there are enough bits for a code.
+					if (count == 0) {
+						// Read a new data block.
+						count = readBlock();
+						if (count <= 0) {
+							break;
+						}
+						bi = 0;
+					}
+					datum += (((int) block[bi]) & 0xff) << bits;
+					bits += 8;
+					bi++;
+					count--;
+					continue;
+				}
+				// Get the next code.
+				code = datum & code_mask;
+				datum >>= code_size;
+				bits -= code_size;
+
+				// Interpret the code
+				if ((code > available) || (code == end_of_information)) {
+					break;
+				}
+				if (code == clear) {
+					// Reset decoder.
+					code_size = data_size + 1;
+					code_mask = (1 << code_size) - 1;
+					available = clear + 2;
+					old_code = NullCode;
+					continue;
+				}
+				if (old_code == NullCode) {
+					pixelStack[top++] = suffix[code];
+					old_code = code;
+					first = code;
+					continue;
+				}
+				in_code = code;
+				if (code == available) {
+					pixelStack[top++] = (byte) first;
+					code = old_code;
+				}
+				while (code > clear) {
+					pixelStack[top++] = suffix[code];
+					code = prefix[code];
+				}
+				first = ((int) suffix[code]) & 0xff;
+				// Add a new string to the string table,
+				if (available >= MaxStackSize) {
+					break;
+				}
+				pixelStack[top++] = (byte) first;
+				prefix[available] = (short) old_code;
+				suffix[available] = (byte) first;
+				available++;
+				if (((available & code_mask) == 0)
+						&& (available < MaxStackSize)) {
+					code_size++;
+					code_mask += available;
+				}
+				old_code = in_code;
+			}
+
+			// Pop a pixel off the pixel stack.
+			top--;
+			pixels[pi++] = pixelStack[top];
+			i++;
+		}
+		for (i = pi; i < npix; i++) {
+			pixels[i] = 0; // clear missing pixels
+		}
+	}
+
+	private boolean err() {
+		return status != STATUS_PARSING;
+	}
+
+	private void init() {
+		status = STATUS_PARSING;
+		frameCount = 0;
+		gifFrame = null;
+		gct = null;
+		lct = null;
+	}
+
+	private int read() {
+		int curByte = 0;
+		try {
+			
+			curByte = in.read();
+		} catch (Exception e) {
+			status = STATUS_FORMAT_ERROR;
+		}
+		return curByte;
+	}
+	
+	private int readBlock() {
+		blockSize = read();
+		int n = 0;
+		if (blockSize > 0) {
+			try {
+				int count = 0;
+				while (n < blockSize) {
+					count = in.read(block, n, blockSize - n);
+					if (count == -1) {
+						break;
+					}
+					n += count;
+				}
+			} catch (Exception e) {
+				e.printStackTrace();
+			}
+			if (n < blockSize) {
+				status = STATUS_FORMAT_ERROR;
+			}
+		}
+		return n;
+	}
+
+	private int[] readColorTable(int ncolors) {
+		int nbytes = 3 * ncolors;
+		int[] tab = null;
+		byte[] c = new byte[nbytes];
+		int n = 0;
+		try {
+			n = in.read(c);
+		} catch (Exception e) {
+			e.printStackTrace();
+		}
+		if (n < nbytes) {
+			status = STATUS_FORMAT_ERROR;
+		} else {
+			tab = new int[256]; // max size to avoid bounds checks
+			int i = 0;
+			int j = 0;
+			while (i < ncolors) {
+				int r = ((int) c[j++]) & 0xff;
+				int g = ((int) c[j++]) & 0xff;
+				int b = ((int) c[j++]) & 0xff;
+				tab[i++] = 0xff000000 | (r << 16) | (g << 8) | b;
+			}
+		}
+		return tab;
+	}
+
+	private void readContents() {
+		// read GIF file content blocks
+		boolean done = false;
+		while (!(done || err())) {
+			int code = read();
+			switch (code) {
+			case 0x2C: // image separator
+				readImage();
+				break;
+			case 0x21: // extension
+				code = read();
+				switch (code) {
+				case 0xf9: // graphics control extension
+					readGraphicControlExt();
+					break;
+				case 0xff: // application extension
+					readBlock();
+					String app = "";
+					for (int i = 0; i < 11; i++) {
+						app += (char) block[i];
+					}
+					if (app.equals("NETSCAPE2.0")) {
+						readNetscapeExt();
+					} else {
+						skip(); // don't care
+					}
+					break;
+				default: // uninteresting extension
+					skip();
+				}
+				break;
+			case 0x3b: // terminator
+				done = true;
+				break;
+			case 0x00: // bad byte, but keep going and see what happens
+				break;
+			default:
+				status = STATUS_FORMAT_ERROR;
+			}
+		}
+	}
+
+	private void readGraphicControlExt() {
+		read(); // block size
+		int packed = read(); // packed fields
+		dispose = (packed & 0x1c) >> 2; // disposal method
+		if (dispose == 0) {
+			dispose = 1; // elect to keep old image if discretionary
+		}
+		transparency = (packed & 1) != 0;
+		delay = readShort() * 10; // delay in milliseconds
+		transIndex = read(); // transparent color index
+		read(); // block terminator
+	}
+
+	private void readHeader() {
+		String id = "";
+		for (int i = 0; i < 6; i++) {
+			id += (char) read();
+		}
+		if (!id.startsWith("GIF")) {
+			status = STATUS_FORMAT_ERROR;
+			return;
+		}
+		readLSD();
+		if (gctFlag && !err()) {
+			gct = readColorTable(gctSize);
+			bgColor = gct[bgIndex];
+		}
+	}
+
+	private void readImage() {
+		ix = readShort(); // (sub)image position & size
+		iy = readShort();
+		iw = readShort();
+		ih = readShort();
+		int packed = read();
+		lctFlag = (packed & 0x80) != 0; // 1 - local color table flag
+		interlace = (packed & 0x40) != 0; // 2 - interlace flag
+		// 3 - sort flag
+		// 4-5 - reserved
+		lctSize = 2 << (packed & 7); // 6-8 - local color table size
+		if (lctFlag) {
+			lct = readColorTable(lctSize); // read table
+			act = lct; // make local table active
+		} else {
+			act = gct; // make global table active
+			if (bgIndex == transIndex) {
+				bgColor = 0;
+			}
+		}
+		int save = 0;
+		if (transparency) {
+			save = act[transIndex];
+			act[transIndex] = 0; // set transparent color if specified
+		}
+		if (act == null) {
+			status = STATUS_FORMAT_ERROR; // no color table defined
+		}
+		if (err()) {
+			return;
+		}
+        try {
+    		decodeImageData(); // decode pixel data
+    		skip();
+    		if (err()) {
+    			return;
+    		}
+    		frameCount++;
+    		// create new image to receive frame data
+    		image = Bitmap.createBitmap(width, height, Config.ARGB_4444);
+    		// createImage(width, height);
+    		setPixels(); // transfer pixel data to image
+    		if (gifFrame == null) {
+    			gifFrame = new GifFrame(image, delay);
+    			currentFrame = gifFrame;
+    		} else {
+    			GifFrame f = gifFrame;
+    			while(f.nextFrame != null){
+    				f = f.nextFrame;
+    			}
+    			f.nextFrame = new GifFrame(image, delay);
+    		}
+    		// frames.addElement(new GifFrame(image, delay)); // add image to frame
+    		// list
+    		if (transparency) {
+    			act[transIndex] = save;
+    		}
+    		resetFrame();
+    		action.parseOk(true, frameCount);
+        }catch (OutOfMemoryError e) {
+            Log.e("GifDecoder", ">>> log  : " + e.toString());
+            e.printStackTrace();
+        }
+	}
+
+	private void readLSD() {
+		// logical screen size
+		width = readShort();
+		height = readShort();
+		// packed fields
+		int packed = read();
+		gctFlag = (packed & 0x80) != 0; // 1 : global color table flag
+		// 2-4 : color resolution
+		// 5 : gct sort flag
+		gctSize = 2 << (packed & 7); // 6-8 : gct size
+		bgIndex = read(); // background color index
+		pixelAspect = read(); // pixel aspect ratio
+	}
+
+	private void readNetscapeExt() {
+		do {
+			readBlock();
+			if (block[0] == 1) {
+				// loop count sub-block
+				int b1 = ((int) block[1]) & 0xff;
+				int b2 = ((int) block[2]) & 0xff;
+				loopCount = (b2 << 8) | b1;
+			}
+		} while ((blockSize > 0) && !err());
+	}
+
+	private int readShort() {
+		// read 16-bit value, LSB first
+		return read() | (read() << 8);
+	}
+
+	private void resetFrame() {
+		lastDispose = dispose;
+		lrx = ix;
+		lry = iy;
+		lrw = iw;
+		lrh = ih;
+		lastImage = image;
+		lastBgColor = bgColor;
+		dispose = 0;
+		transparency = false;
+		delay = 0;
+		lct = null;
+	}
+
+	/**
+	 * Skips variable length blocks up to and including next zero length block.
+	 */
+	private void skip() {
+		do {
+			readBlock();
+		} while ((blockSize > 0) && !err());
+	}
+}
diff --git a/ion/src/com/koushikdutta/ion/gif/GifFrame.java b/ion/src/com/koushikdutta/ion/gif/GifFrame.java
new file mode 100755
index 00000000..a81d3bb3
--- /dev/null
+++ b/ion/src/com/koushikdutta/ion/gif/GifFrame.java
@@ -0,0 +1,14 @@
+package com.koushikdutta.ion.gif;
+
+import android.graphics.Bitmap;
+
+public class GifFrame {
+    public GifFrame(Bitmap im, int del) {
+        image = im;
+        delay = del;
+    }
+	
+    public Bitmap image;
+    public int delay;
+    public GifFrame nextFrame = null;
+}
diff --git a/ion/src/com/koushikdutta/ion/gif/README b/ion/src/com/koushikdutta/ion/gif/README
new file mode 100644
index 00000000..b6b8d269
--- /dev/null
+++ b/ion/src/com/koushikdutta/ion/gif/README
@@ -0,0 +1,4 @@
+GIF support comes from Code Aurora Forums:
+https://www.codeaurora.org/cgit/quic/la/platform/packages/apps/Gallery2/tree/src/com/android/gallery3d/util?h=jb_chocolate_rb4.1&id=2b133c9747af26701a12d60caef3e7e14cf55536
+
+Repository is licensed under Apache.
\ No newline at end of file
diff --git a/mark.gif b/mark.gif
new file mode 100644
index 00000000..0b963ef2
Binary files /dev/null and b/mark.gif differ
