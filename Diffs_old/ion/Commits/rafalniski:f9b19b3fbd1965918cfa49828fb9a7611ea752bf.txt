diff --git a/.classpath b/.classpath
new file mode 100644
index 00000000..51769745
--- /dev/null
+++ b/.classpath
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="src" path="gen"/>
+	<classpathentry kind="output" path="bin/classes"/>
+</classpath>
diff --git a/.gitignore b/.gitignore
index 5d4269e9..3070adf1 100644
--- a/.gitignore
+++ b/.gitignore
@@ -4,8 +4,3 @@ local.properties
 gen
 .gradle
 build
-.DS_Store
-gradle
-gradlew
-gradlew.bat
-
diff --git a/.project b/.project
new file mode 100644
index 00000000..0d9ad2cc
--- /dev/null
+++ b/.project
@@ -0,0 +1,33 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>ion</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff --git a/Android.mk b/Android.mk
new file mode 100644
index 00000000..49b9fc64
--- /dev/null
+++ b/Android.mk
@@ -0,0 +1,27 @@
+#
+# Copyright (C) 2011 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+LOCAL_PATH := $(call my-dir)
+
+include $(CLEAR_VARS)
+
+LOCAL_STATIC_JAVA_LIBRARIES := AndroidAsync gson
+
+LOCAL_MODULE := ion
+LOCAL_SDK_VERSION := 19
+LOCAL_SRC_FILES := $(call all-java-files-under, src)
+
+include $(BUILD_STATIC_JAVA_LIBRARY)
diff --git a/AndroidManifest.xml b/AndroidManifest.xml
new file mode 100644
index 00000000..3699792f
--- /dev/null
+++ b/AndroidManifest.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+          package="com.koushikdutta.ion"
+          android:versionCode="124"
+          android:versionName="1.2.4">
+    <uses-sdk android:minSdkVersion="9" android:targetSdkVersion="18" />
+    <application />
+</manifest>
diff --git a/ant.properties b/ant.properties
new file mode 100644
index 00000000..2ce12461
--- /dev/null
+++ b/ant.properties
@@ -0,0 +1,17 @@
+# This file is used to override default values used by the Ant build system.
+#
+# This file must be checked intoImageView Version Control Systems, as it is
+# integral to the build system of your project.
+
+# This file is only used by the Ant script.
+
+# You can use this to override default values such as
+#  'source.dir' for the location of your java source folder and
+#  'out.dir' for the location of your output folder.
+
+# You can also use it define how the release builds are signed by declaring
+# the following properties:
+#  'key.store' for the location of your keystore and
+#  'key.alias' for the name of the key to use.
+# The password will be asked during the build when you use the 'release' target.
+
diff --git a/build.gradle b/build.gradle
new file mode 100644
index 00000000..7c72e8a8
--- /dev/null
+++ b/build.gradle
@@ -0,0 +1,49 @@
+task wrapper(type: Wrapper) {
+    gradleVersion = '1.6'
+}
+
+buildscript {
+    repositories {
+        mavenCentral()
+    }
+
+    dependencies {
+      classpath 'com.android.tools.build:gradle:0.4.+'
+    }
+}
+
+apply plugin: 'android-library'
+
+repositories {
+    mavenCentral()
+}
+
+dependencies {
+    compile project(':AndroidAsync')
+    compile 'com.google.code.gson:gson:2.2.4'
+}
+
+android {
+  sourceSets {
+      main {
+          manifest.srcFile 'AndroidManifest.xml'
+      
+          java {
+              srcDir 'src/'
+          }
+      }
+  }
+
+    compileSdkVersion 17
+    buildToolsVersion "17"
+
+    defaultConfig {
+        minSdkVersion 7
+        targetSdkVersion 16
+    }
+}
+
+// upload to maven task
+if (System.getenv().I_AM_KOUSH == 'true') {
+  apply from: 'https://raw.github.com/koush/mvn-repo/master/maven.gradle'
+}
diff --git a/build.xml b/build.xml
new file mode 100644
index 00000000..4123d62b
--- /dev/null
+++ b/build.xml
@@ -0,0 +1,92 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project name="ion" default="help">
+
+    <!-- The local.properties file is created and updated by the 'android' tool.
+         It contains the path to the SDK. It should *NOT* be checked intoImageView
+         Version Control Systems. -->
+    <property file="local.properties"/>
+
+    <!-- The ant.properties file can be created by you. It is only edited by the
+         'android' tool to add properties to it.
+         This is the place to change some Ant specific build properties.
+         Here are some properties you may want to change/update:
+
+         source.dir
+             The name of the source directory. Default is 'src'.
+         out.dir
+             The name of the output directory. Default is 'bin'.
+
+         For other overridable properties, look at the beginning of the rules
+         files in the SDK, at tools/ant/build.xml
+
+         Properties related to the SDK location or the project target should
+         be updated using the 'android' tool with the 'update' action.
+
+         This file is an integral part of the build system for your
+         application and should be checked intoImageView Version Control Systems.
+
+         -->
+    <property file="ant.properties"/>
+
+    <!-- if sdk.dir was not set from one of the property file, then
+         get it from the ANDROID_HOME env var.
+         This must be done before we load project.properties since
+         the proguard config can use sdk.dir -->
+    <property environment="env"/>
+    <condition property="sdk.dir" value="${env.ANDROID_HOME}">
+        <isset property="env.ANDROID_HOME"/>
+    </condition>
+
+    <!-- The project.properties file is created and updated by the 'android'
+         tool, as well as ADT.
+
+         This contains project specific properties such as project target, and library
+         dependencies. Lower level build properties are stored in ant.properties
+         (or in .classpath for Eclipse projects).
+
+         This file is an integral part of the build system for your
+         application and should be checked intoImageView Version Control Systems. -->
+    <loadproperties srcFile="project.properties"/>
+
+    <!-- quick check on sdk.dir -->
+    <fail
+            message="sdk.dir is missing. Make sure to generate local.properties using 'android update project' or to inject it through the ANDROID_HOME environment variable."
+            unless="sdk.dir"
+            />
+
+    <!--
+        Import per project custom build rules if present at the root of the project.
+        This is the place to put custom intermediary targets such as:
+            -pre-build
+            -pre-compile
+            -post-compile (This is typically used for code obfuscation.
+                           Compiled code location: ${out.classes.absolute.dir}
+                           If this is not done in place, override ${out.dex.input.absolute.dir})
+            -post-package
+            -post-build
+            -pre-clean
+    -->
+    <import file="custom_rules.xml" optional="true"/>
+
+    <!-- Import the actual build file.
+
+         To customize existing targets, there are two options:
+         - Customize only one target:
+             - copy/paste the target intoImageView this file, *before* the
+               <import> task.
+             - customize it to your needs.
+         - Customize the whole content of build.xml
+             - copy/paste the content of the rules files (minus the top node)
+               intoImageView this file, replacing the <import> task.
+             - customize to your needs.
+
+         ***********************
+         ****** IMPORTANT ******
+         ***********************
+         In all cases you must update the value of version-tag below to read 'custom' instead of an integer,
+         in order to avoid having your file be overridden by tools such as "android update project"
+    -->
+    <!-- version-tag: 1 -->
+    <import file="${sdk.dir}/tools/ant/build.xml"/>
+
+</project>
diff --git a/ion.iml b/ion.iml
new file mode 100644
index 00000000..a4121540
--- /dev/null
+++ b/ion.iml
@@ -0,0 +1,39 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module type="JAVA_MODULE" version="4">
+  <component name="FacetManager">
+    <facet type="android" name="Android">
+      <configuration>
+        <option name="LIBRARY_PROJECT" value="true" />
+        <option name="UPDATE_PROPERTY_FILES" value="true" />
+        <notImportedProperties>
+          <property>MANIFEST_FILE_PATH</property>
+          <property>RESOURCES_DIR_PATH</property>
+          <property>ASSETS_DIR_PATH</property>
+          <property>NATIVE_LIBS_DIR_PATH</property>
+        </notImportedProperties>
+      </configuration>
+    </facet>
+  </component>
+  <component name="NewModuleRootManager" inherit-compiler-output="true">
+    <exclude-output />
+    <content url="file://$MODULE_DIR$">
+      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/gen" isTestSource="false" generated="true" />
+    </content>
+    <orderEntry type="inheritedJdk" />
+    <orderEntry type="sourceFolder" forTests="false" />
+    <orderEntry type="module-library" exported="">
+      <library>
+        <CLASSES>
+          <root url="file://$MODULE_DIR$/libs" />
+        </CLASSES>
+        <JAVADOC />
+        <SOURCES />
+        <jarDirectory url="file://$MODULE_DIR$/libs" recursive="false" />
+      </library>
+    </orderEntry>
+    <orderEntry type="module" module-name="AndroidAsync" exported="" />
+    <orderEntry type="module" module-name="v4" exported="" />
+  </component>
+</module>
+
diff --git a/libs/gson-2.2.4.jar b/libs/gson-2.2.4.jar
new file mode 100644
index 00000000..75fe27c5
Binary files /dev/null and b/libs/gson-2.2.4.jar differ
diff --git a/proguard-project.txt b/proguard-project.txt
new file mode 100644
index 00000000..f2fe1559
--- /dev/null
+++ b/proguard-project.txt
@@ -0,0 +1,20 @@
+# To enable ProGuard in your project, edit project.properties
+# to define the proguard.config property as described in that file.
+#
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in ${sdk.dir}/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the ProGuard
+# include property in project.properties.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
diff --git a/project.properties b/project.properties
new file mode 100644
index 00000000..01ee1319
--- /dev/null
+++ b/project.properties
@@ -0,0 +1,18 @@
+# This file is automatically generated by Android Tools.
+# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
+#
+# This file must be checked in Version Control Systems.
+#
+# To customize properties used by the Ant build system edit
+# "ant.properties", and override values to adapt the script to your
+# project structure.
+#
+# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
+#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
+
+# Project target.
+target=android-19
+android.library=true
+
+
+
diff --git a/res/.gitignore b/res/.gitignore
new file mode 100644
index 00000000..e69de29b
diff --git a/settings.gradle b/settings.gradle
new file mode 100644
index 00000000..4e0c424d
--- /dev/null
+++ b/settings.gradle
@@ -0,0 +1,2 @@
+include ':AndroidAsync'
+project(':AndroidAsync').projectDir = new File('../../AndroidAsync/AndroidAsync')
diff --git a/src/com/koushikdutta/ion/BitmapCallback.java b/src/com/koushikdutta/ion/BitmapCallback.java
new file mode 100644
index 00000000..515c5fb2
--- /dev/null
+++ b/src/com/koushikdutta/ion/BitmapCallback.java
@@ -0,0 +1,62 @@
+package com.koushikdutta.ion;
+
+import android.graphics.Point;
+
+import com.koushikdutta.async.AsyncServer;
+import com.koushikdutta.async.future.FutureCallback;
+import com.koushikdutta.ion.bitmap.BitmapInfo;
+
+import java.util.ArrayList;
+import java.util.concurrent.CancellationException;
+
+abstract class BitmapCallback {
+    String key;
+    Ion ion;
+
+    protected BitmapCallback(Ion ion, String key, boolean put) {
+        this.key = key;
+        this.put = put;
+        this.ion = ion;
+
+        ion.bitmapsPending.tag(key, this);
+    }
+
+    boolean put;
+
+    boolean put() {
+        return put;
+    }
+
+    protected void onReported() {
+        ion.processDeferred();
+    }
+
+    protected void report(final Exception e, final BitmapInfo info) {
+        AsyncServer.post(Ion.mainHandler, new Runnable() {
+            @Override
+            public void run() {
+                BitmapInfo result = info;
+                if (result == null) {
+                    // cache errors, unless they were cancellation exceptions
+                    result = new BitmapInfo(key, null, null, new Point());
+                    result.exception = e;
+                    if (!(e instanceof CancellationException))
+                        ion.getBitmapCache().put(result);
+                } else if (put()) {
+                    ion.getBitmapCache().put(result);
+                }
+
+                final ArrayList<FutureCallback<BitmapInfo>> callbacks = ion.bitmapsPending.remove(key);
+                if (callbacks == null || callbacks.size() == 0) {
+                    onReported();
+                    return;
+                }
+
+                for (FutureCallback<BitmapInfo> callback : callbacks) {
+                    callback.onCompleted(e, result);
+                }
+                onReported();
+            }
+        });
+    }
+}
diff --git a/src/com/koushikdutta/ion/BitmapFetcher.java b/src/com/koushikdutta/ion/BitmapFetcher.java
new file mode 100644
index 00000000..3cba33e4
--- /dev/null
+++ b/src/com/koushikdutta/ion/BitmapFetcher.java
@@ -0,0 +1,154 @@
+package com.koushikdutta.ion;
+
+import com.koushikdutta.async.AsyncServer;
+import com.koushikdutta.async.ByteBufferList;
+import com.koushikdutta.async.future.Future;
+import com.koushikdutta.async.future.FutureCallback;
+import com.koushikdutta.async.http.AsyncHttpRequest;
+import com.koushikdutta.async.parser.ByteBufferListParser;
+import com.koushikdutta.async.util.FileCache;
+import com.koushikdutta.ion.bitmap.BitmapInfo;
+import com.koushikdutta.ion.bitmap.Transform;
+import com.koushikdutta.ion.loader.MediaFile;
+
+import java.io.File;
+import java.net.URI;
+import java.util.ArrayList;
+
+class BitmapFetcher implements IonRequestBuilder.LoadRequestCallback {
+    String downloadKey;
+    String bitmapKey;
+    BitmapInfo info;
+    boolean hasTransforms;
+    ArrayList<Transform> transforms;
+    IonRequestBuilder builder;
+    int resizeWidth;
+    int resizeHeight;
+    boolean animateGif;
+    boolean deepZoom;
+
+    private boolean fastLoad(String uri) {
+        Ion ion = builder.ion;
+        if (deepZoom) {
+            if (uri == null || !uri.startsWith("file:/"))
+                return false;
+            File file = new File(URI.create(uri));
+            if (!file.exists())
+                return false;
+            MediaFile.MediaFileType type = MediaFile.getFileType(file.getAbsolutePath());
+            if (type == null || !MediaFile.isVideoFileType(type.fileType)) {
+                LoadDeepZoom loadDeepZoom = new LoadDeepZoom(ion, downloadKey, animateGif, null, null);
+                loadDeepZoom.onCompleted(null, file);
+//                System.out.println("fastloading deepZoom");
+                return true;
+            }
+            // fall through to allow some other loader to open this, cause this is a video file
+        }
+
+        boolean put = !hasTransforms;
+
+        for (Loader loader: ion.configure().getLoaders()) {
+            Future<BitmapInfo> future = loader.loadBitmap(builder.contextReference.getContext(), ion, downloadKey, uri, resizeWidth, resizeHeight, animateGif);
+            if (future != null) {
+                final BitmapCallback callback = new LoadBitmapBase(ion, downloadKey, put);
+                future.setCallback(new FutureCallback<BitmapInfo>() {
+                    @Override
+                    public void onCompleted(Exception e, BitmapInfo result) {
+                        callback.report(e, result);
+                    }
+                });
+                return true;
+            }
+        }
+        return false;
+    }
+
+    public static final int MAX_IMAGEVIEW_LOAD = 5;
+
+    public static boolean shouldDeferImageView(Ion ion) {
+        if (ion.bitmapsPending.keySet().size() <= MAX_IMAGEVIEW_LOAD)
+            return false;
+        int loadCount = 0;
+        for (String key: ion.bitmapsPending.keySet()) {
+            Object owner = ion.bitmapsPending.tag(key);
+            if (owner instanceof LoadBitmapBase) {
+                loadCount++;
+                if (loadCount > MAX_IMAGEVIEW_LOAD)
+                    return true;
+            }
+        }
+        return false;
+    }
+
+    public DeferredLoadBitmap defer() {
+        DeferredLoadBitmap ret = new DeferredLoadBitmap(builder.ion, downloadKey, this);
+        executeTransforms(builder.ion);
+        return ret;
+    }
+
+    private void executeTransforms(Ion ion) {
+        // if there's a transform, do it
+        if (!hasTransforms)
+            return;
+
+        // verify this transform isn't already pending
+        // make sure that the parent download isn't cancelled (empty list)
+        // and also make sure there are waiters for this transformed bitmap
+        if (ion.bitmapsPending.tag(bitmapKey) == null) {
+            ion.bitmapsPending.add(downloadKey, new TransformBitmap(ion, bitmapKey, downloadKey, transforms));
+        }
+    }
+
+    @Override
+    public boolean loadRequest(AsyncHttpRequest request) {
+        return !fastLoad(request.getUri().toString());
+    }
+
+    public void execute() {
+        final Ion ion = builder.ion;
+
+        // bitmaps that were transformed are put into the FileCache to prevent
+        // subsequent retransformation. See if we can retrieve the bitmap from the disk cache.
+        // See TransformBitmap for where the cache is populated.
+        FileCache fileCache = ion.responseCache.getFileCache();
+        if (!builder.noCache && hasTransforms && fileCache.exists(bitmapKey) && !deepZoom) {
+            TransformBitmap.getBitmapSnapshot(ion, bitmapKey);
+            return;
+        }
+
+        // Perform a download as necessary.
+        if (ion.bitmapsPending.tag(downloadKey) == null && !fastLoad(builder.uri)) {
+            builder.setHandler(null);
+            builder.loadRequestCallback = this;
+
+            if (!deepZoom) {
+                IonRequestBuilder.EmitterTransform<ByteBufferList> emitterTransform = builder.execute(new ByteBufferListParser(), new Runnable() {
+                    @Override
+                    public void run() {
+                        AsyncServer.post(Ion.mainHandler, new Runnable() {
+                            @Override
+                            public void run() {
+                                ion.bitmapsPending.remove(downloadKey);
+                            }
+                        });
+                    }
+                });
+                emitterTransform.setCallback(new LoadBitmap(ion, downloadKey, !hasTransforms, resizeWidth, resizeHeight, animateGif, emitterTransform));
+            }
+            else {
+//                System.out.println("downloading file for deepZoom");
+                File file = fileCache.getTempFile();
+                IonRequestBuilder.EmitterTransform<File> emitterTransform = builder.write(file);
+                LoadDeepZoom loadDeepZoom = new LoadDeepZoom(ion, downloadKey, animateGif, emitterTransform, fileCache) {
+                    @Override
+                    public void onCompleted(Exception e, File file) {
+                        super.onCompleted(e, file);
+                    }
+                };
+                emitterTransform.setCallback(loadDeepZoom);
+            }
+        }
+
+        executeTransforms(ion);
+    }
+}
diff --git a/src/com/koushikdutta/ion/BitmapInfoToBitmap.java b/src/com/koushikdutta/ion/BitmapInfoToBitmap.java
new file mode 100644
index 00000000..e6a05462
--- /dev/null
+++ b/src/com/koushikdutta/ion/BitmapInfoToBitmap.java
@@ -0,0 +1,26 @@
+package com.koushikdutta.ion;
+
+import android.graphics.Bitmap;
+
+import com.koushikdutta.async.future.TransformFuture;
+import com.koushikdutta.ion.bitmap.BitmapInfo;
+
+class BitmapInfoToBitmap extends TransformFuture<Bitmap, BitmapInfo> {
+    ContextReference contextReference;
+    public BitmapInfoToBitmap(ContextReference contextReference) {
+        this.contextReference = contextReference;
+    }
+
+    @Override
+    protected void transform(BitmapInfo result) throws Exception {
+        if (contextReference.isAlive() != null) {
+            cancel();
+            return;
+        }
+
+        if (result.exception != null)
+            setComplete(result.exception);
+        else
+            setComplete(result.bitmaps[0]);
+    }
+}
\ No newline at end of file
diff --git a/src/com/koushikdutta/ion/ContextReference.java b/src/com/koushikdutta/ion/ContextReference.java
new file mode 100644
index 00000000..8d60d823
--- /dev/null
+++ b/src/com/koushikdutta/ion/ContextReference.java
@@ -0,0 +1,183 @@
+package com.koushikdutta.ion;
+
+import android.annotation.TargetApi;
+import android.app.Activity;
+import android.app.ActivityManager;
+import android.app.Fragment;
+import android.app.Service;
+import android.content.Context;
+import android.os.Build;
+import android.widget.ImageView;
+
+import java.lang.ref.WeakReference;
+import java.util.List;
+
+/**
+ * Created by koush on 4/15/14.
+ */
+abstract class ContextReference<T> extends WeakReference<T> {
+    ContextReference(T t) {
+        super(t);
+    }
+
+    abstract static class NormalContextReference<T extends Context> extends ContextReference<T> {
+        NormalContextReference(T context) {
+            super(context);
+        }
+
+        static String isAlive(Context context) {
+            if (context instanceof Service)
+                return ServiceContextReference.isAlive((Service) context);
+            if (context instanceof Activity)
+                return ActivityContextReference.isAlive((Activity) context);
+            return null;
+        }
+
+        @Override
+        public Context getContext() {
+            return get();
+        }
+    }
+
+    static class ServiceContextReference extends NormalContextReference<Service> {
+        public ServiceContextReference(Service service) {
+            super(service);
+        }
+
+        static String isAlive(Service candidate) {
+            if (candidate == null)
+                return "Service reference null";
+            ActivityManager manager = (ActivityManager)candidate.getSystemService(Context.ACTIVITY_SERVICE);
+            List<ActivityManager.RunningServiceInfo> services = manager.getRunningServices(Integer.MAX_VALUE);
+            if (services == null)
+                return "Could not retrieve services from service manager";
+            for (ActivityManager.RunningServiceInfo service: services) {
+                if (candidate.getClass().getName().equals(service.service.getClassName())) {
+                    return null;
+                }
+            }
+            return "Service stopped";
+        }
+
+        @Override
+        public String isAlive() {
+            return isAlive(get());
+        }
+    }
+
+    static class ActivityContextReference extends NormalContextReference<Activity> {
+        public ActivityContextReference(Activity activity) {
+            super(activity);
+        }
+
+        static String isAlive(Activity a) {
+            if (a == null)
+                return "Activity reference null";
+            if (a.isFinishing())
+                return "Activity finished";
+            return null;
+        }
+
+        @Override
+        public String isAlive() {
+            return isAlive(get());
+        }
+    }
+
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR2)
+    static class FragmentContextReference extends ContextReference<Fragment> {
+        public FragmentContextReference(Fragment fragment) {
+            super(fragment);
+        }
+
+        @Override
+        public Context getContext() {
+            Fragment fragment = get();
+            if (fragment == null)
+                return null;
+            return fragment.getActivity();
+        }
+
+        @Override
+        public String isAlive() {
+            Fragment fragment = get();
+            if (fragment == null)
+                return "Fragment reference null";
+            String ret = ActivityContextReference.isAlive(fragment.getActivity());
+            if (ret != null)
+                return ret;
+            if (fragment.isDetached())
+                return "Fragment detached";
+            return null;
+        }
+    }
+
+    static class SupportFragmentContextReference extends ContextReference<android.support.v4.app.Fragment> {
+        public SupportFragmentContextReference(android.support.v4.app.Fragment fragment) {
+            super(fragment);
+        }
+
+        @Override
+        public Context getContext() {
+            android.support.v4.app.Fragment fragment = get();
+            if (fragment == null)
+                return null;
+            return fragment.getActivity();
+        }
+
+        @Override
+        public String isAlive() {
+            android.support.v4.app.Fragment fragment = get();
+            if (fragment == null)
+                return "Fragment reference null";
+            String ret = ActivityContextReference.isAlive(fragment.getActivity());
+            if (ret != null)
+                return ret;
+            if (fragment.isDetached())
+                return "Fragment detached";
+            return null;
+        }
+    }
+
+    static class ImageViewContextReference extends ContextReference<ImageView> {
+        public ImageViewContextReference(ImageView imageView) {
+            super(imageView);
+        }
+
+        @Override
+        public String isAlive() {
+            ImageView iv = get();
+            if (iv == null)
+                return "ImageView reference null";
+            return NormalContextReference.isAlive(iv.getContext());
+        }
+
+        @Override
+        public Context getContext() {
+            ImageView iv = get();
+            if (iv == null)
+                return null;
+            return iv.getContext();
+        }
+    }
+
+    public static ContextReference fromContext(Context context) {
+        if (context instanceof Service)
+            return new ServiceContextReference((Service)context);
+        if (context instanceof Activity)
+            return new ActivityContextReference((Activity)context);
+
+        return new NormalContextReference<Context>(context) {
+            @Override
+            public String isAlive() {
+                Context context = get();
+                if (context == null)
+                    return "Context reference null";
+                return null;
+            }
+        };
+    }
+
+    public abstract String isAlive();
+    public abstract Context getContext();
+}
diff --git a/src/com/koushikdutta/ion/DefaultTransform.java b/src/com/koushikdutta/ion/DefaultTransform.java
new file mode 100644
index 00000000..f429a0a7
--- /dev/null
+++ b/src/com/koushikdutta/ion/DefaultTransform.java
@@ -0,0 +1,55 @@
+package com.koushikdutta.ion;
+
+import android.graphics.Bitmap;
+import android.graphics.Canvas;
+import android.graphics.RectF;
+
+import com.koushikdutta.ion.bitmap.Transform;
+
+import java.io.FileOutputStream;
+
+class DefaultTransform implements Transform {
+    ScaleMode scaleMode;
+    int resizeWidth;
+    int resizeHeight;
+
+    public DefaultTransform(int width, int height, ScaleMode scaleMode) {
+        resizeWidth = width;
+        resizeHeight = height;
+        this.scaleMode = scaleMode;
+    }
+
+    @Override
+    public Bitmap transform(Bitmap b) {
+        Bitmap.Config config = b.getConfig();
+        if (config == null)
+            config = Bitmap.Config.ARGB_8888;
+        Bitmap ret = Bitmap.createBitmap(resizeWidth, resizeHeight, config);
+        Canvas canvas = new Canvas(ret);
+
+        RectF destination = new RectF(0, 0, resizeWidth, resizeHeight);
+        if (scaleMode != ScaleMode.FitXY) {
+            float ratio;
+            float xratio = (float)resizeWidth / (float)b.getWidth();
+            float yratio = (float)resizeHeight / (float)b.getHeight();
+            if (scaleMode == ScaleMode.CenterCrop)
+                ratio = Math.max(xratio, yratio);
+            else
+                ratio = Math.min(xratio, yratio);
+
+            float postWidth = b.getWidth() * ratio;
+            float postHeight = b.getHeight() * ratio;
+            float transx = (resizeWidth - postWidth) / 2;
+            float transy = (resizeHeight - postHeight) / 2;
+            destination.set(transx, transy, resizeWidth - transx, resizeHeight - transy);
+        }
+
+        canvas.drawBitmap(b, null, destination, null);
+        return ret;
+    }
+
+    @Override
+    public String key() {
+        return scaleMode.name() + resizeWidth  + "x" + resizeHeight;
+    }
+}
diff --git a/src/com/koushikdutta/ion/DeferredLoadBitmap.java b/src/com/koushikdutta/ion/DeferredLoadBitmap.java
new file mode 100644
index 00000000..cd30a28d
--- /dev/null
+++ b/src/com/koushikdutta/ion/DeferredLoadBitmap.java
@@ -0,0 +1,12 @@
+package com.koushikdutta.ion;
+
+/**
+ * Created by koush on 1/18/14.
+ */
+public class DeferredLoadBitmap extends BitmapCallback {
+    BitmapFetcher fetcher;
+    public DeferredLoadBitmap(Ion ion, String key, BitmapFetcher fetcher)  {
+        super(ion, key, false);
+        this.fetcher = fetcher;
+    }
+}
diff --git a/src/com/koushikdutta/ion/FileCacheStore.java b/src/com/koushikdutta/ion/FileCacheStore.java
new file mode 100644
index 00000000..e83119ae
--- /dev/null
+++ b/src/com/koushikdutta/ion/FileCacheStore.java
@@ -0,0 +1,190 @@
+package com.koushikdutta.ion;
+
+import com.google.gson.JsonArray;
+import com.google.gson.JsonObject;
+import com.google.gson.reflect.TypeToken;
+import com.koushikdutta.async.callback.CompletedCallback;
+import com.koushikdutta.async.future.Future;
+import com.koushikdutta.async.future.SimpleFuture;
+import com.koushikdutta.async.parser.AsyncParser;
+import com.koushikdutta.async.parser.DocumentParser;
+import com.koushikdutta.async.parser.StringParser;
+import com.koushikdutta.async.stream.FileDataSink;
+import com.koushikdutta.async.util.FileCache;
+import com.koushikdutta.ion.gson.GsonParser;
+import com.koushikdutta.ion.gson.GsonSerializer;
+
+import org.w3c.dom.Document;
+
+import java.io.File;
+import java.util.Set;
+
+/**
+ * Created by koush on 11/17/13.
+ */
+public class FileCacheStore {
+    Ion ion;
+    FileCache cache;
+    String rawKey;
+    FileCacheStore(Ion ion, FileCache cache, String rawKey) {
+        this.ion = ion;
+        this.cache = cache;
+        this.rawKey = rawKey;
+    }
+
+    private <T> Future<T> put(final T value, final AsyncParser<T> parser) {
+        final SimpleFuture<T> ret = new SimpleFuture<T>();
+        Ion.getIoExecutorService().execute(new Runnable() {
+            @Override
+            public void run() {
+                final String key = computeKey();
+                final File file = cache.getTempFile();
+                final FileDataSink sink = new FileDataSink(ion.getServer(), file);
+                parser.write(sink, value, new CompletedCallback() {
+                    @Override
+                    public void onCompleted(Exception ex) {
+                        sink.close();
+                        if (ex != null) {
+                            file.delete();
+                            ret.setComplete(ex);
+                            return;
+                        }
+                        cache.commitTempFiles(key, file);
+                        ret.setComplete(value);
+                    }
+                });
+            }
+        });
+        return ret;
+    }
+
+    public Future<String> putString(String value) {
+        return put(value, new StringParser());
+    }
+
+    public Future<JsonObject> putJsonObject(JsonObject value) {
+        return put(value, new GsonParser<JsonObject>());
+    }
+
+    public Future<Document> putDocument(Document value) {
+        return put(value, new DocumentParser());
+    }
+
+    public Future<JsonArray> putJsonArray(JsonArray value) {
+        return put(value, new GsonParser<JsonArray>());
+    }
+
+    /*
+    public Future<InputStream> putInputStream(InputStream value) {
+        throw new AssertionError("not implemented");
+    }
+
+    public Future<byte[]> putByteArray(byte[] bytes) {
+        throw new AssertionError("not implemented");
+    }
+    */
+
+    public <T> Future<T> put(T value, Class<T> clazz) {
+        return put(value, new GsonSerializer<T>(ion.configure().getGson(), clazz));
+    }
+
+    public <T> Future<T> put(T value, TypeToken<T> token) {
+        return put(value, new GsonSerializer<T>(ion.configure().getGson(), token));
+    }
+
+    private <T> Future<T> as(final AsyncParser<T> parser) {
+        final SimpleFuture<T> ret = new SimpleFuture<T>();
+
+        Ion.getIoExecutorService().execute(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    final String key = computeKey();
+                    final File file = cache.getFile(key);
+                    if (!file.exists()) {
+                        ret.setComplete((T)null);
+                        return;
+                    }
+                    ion.build(ion.getContext(), file)
+                    .as(parser)
+                    .setCallback(ret.getCompletionCallback());
+                }
+                catch (Exception e) {
+                    ret.setComplete(e);
+                }
+            }
+        });
+        
+        return ret;
+    }
+
+    private <T> T get(final AsyncParser<T> parser) {
+        try {
+            final String key = computeKey();
+            final File file = cache.getFile(key);
+            return ion.build(ion.getContext(), file)
+            .as(parser)
+            .get();
+        }
+        catch (Exception e) {
+            return null;
+        }
+    }
+
+    public String getString() {
+        return get(new StringParser());
+    }
+
+    public Future<String> asString() {
+        return as(new StringParser());
+    }
+
+    public Future<JsonObject> asJsonObject() {
+        return as(new GsonParser<JsonObject>());
+    }
+
+    public JsonObject getJsonObject() {
+        return get(new GsonParser<JsonObject>());
+    }
+
+    public Future<JsonArray> asJsonArray() {
+        return as(new GsonParser<JsonArray>());
+    }
+
+    public JsonArray getJsonArray() {
+        return get(new GsonParser<JsonArray>());
+    }
+
+    public Future<Document> asDocument() {
+        return as(new DocumentParser());
+    }
+
+    public Document getDocument() {
+        return get(new DocumentParser());
+    }
+
+    public <T> Future<T> as(Class<T> clazz) {
+        return as(new GsonSerializer<T>(ion.configure().getGson(), clazz));
+    }
+
+    public <T> T get(Class<T> clazz) {
+        return get(new GsonSerializer<T>(ion.configure().getGson(), clazz));
+    }
+
+    public <T> Future<T> as(TypeToken<T> token) {
+        return as(new GsonSerializer<T>(ion.configure().getGson(), token));
+    }
+
+    public <T> T get(TypeToken<T> token) {
+        return get(new GsonSerializer<T>(ion.configure().getGson(), token));
+    }
+
+    private String computeKey() {
+        return rawKey.replace(":", "_");
+    }
+
+    public void remove() {
+        final String key = computeKey();
+        cache.remove(key);
+    }
+}
diff --git a/src/com/koushikdutta/ion/HeadersCallback.java b/src/com/koushikdutta/ion/HeadersCallback.java
new file mode 100644
index 00000000..5ab088b9
--- /dev/null
+++ b/src/com/koushikdutta/ion/HeadersCallback.java
@@ -0,0 +1,10 @@
+package com.koushikdutta.ion;
+
+import com.koushikdutta.async.http.libcore.RawHeaders;
+
+/**
+ * Created by koush on 6/30/13.
+ */
+public interface HeadersCallback {
+    public void onHeaders(RawHeaders headers);
+}
diff --git a/src/com/koushikdutta/ion/InputStreamParser.java b/src/com/koushikdutta/ion/InputStreamParser.java
new file mode 100644
index 00000000..af12d996
--- /dev/null
+++ b/src/com/koushikdutta/ion/InputStreamParser.java
@@ -0,0 +1,34 @@
+package com.koushikdutta.ion;
+
+import com.koushikdutta.async.ByteBufferList;
+import com.koushikdutta.async.DataEmitter;
+import com.koushikdutta.async.DataSink;
+import com.koushikdutta.async.callback.CompletedCallback;
+import com.koushikdutta.async.future.Future;
+import com.koushikdutta.async.future.TransformFuture;
+import com.koushikdutta.async.parser.AsyncParser;
+import com.koushikdutta.async.parser.ByteBufferListParser;
+import com.koushikdutta.async.stream.ByteBufferListInputStream;
+
+import java.io.InputStream;
+
+/**
+ * Created by koush on 11/3/13.
+ */
+public class InputStreamParser implements AsyncParser<InputStream> {
+    @Override
+    public Future<InputStream> parse(DataEmitter emitter) {
+        return new ByteBufferListParser().parse(emitter)
+        .then(new TransformFuture<InputStream, ByteBufferList>() {
+            @Override
+            protected void transform(ByteBufferList result) throws Exception {
+                setComplete(new ByteBufferListInputStream(result));
+            }
+        });
+    }
+
+    @Override
+    public void write(DataSink sink, InputStream value, CompletedCallback completed) {
+        throw new AssertionError("not implemented");
+    }
+}
diff --git a/src/com/koushikdutta/ion/Ion.java b/src/com/koushikdutta/ion/Ion.java
new file mode 100644
index 00000000..ee5f6a30
--- /dev/null
+++ b/src/com/koushikdutta/ion/Ion.java
@@ -0,0 +1,616 @@
+package com.koushikdutta.ion;
+
+import android.annotation.TargetApi;
+import android.app.Fragment;
+import android.content.Context;
+import android.os.Build;
+import android.os.Handler;
+import android.os.Looper;
+import android.text.TextUtils;
+import android.util.Log;
+import android.widget.ImageView;
+
+import com.google.gson.Gson;
+import com.koushikdutta.async.AsyncServer;
+import com.koushikdutta.async.future.Future;
+import com.koushikdutta.async.future.FutureCallback;
+import com.koushikdutta.async.http.AsyncHttpClient;
+import com.koushikdutta.async.http.AsyncHttpRequest;
+import com.koushikdutta.async.http.ResponseCacheMiddleware;
+import com.koushikdutta.async.http.libcore.RawHeaders;
+import com.koushikdutta.async.util.FileCache;
+import com.koushikdutta.async.util.FileUtility;
+import com.koushikdutta.async.util.HashList;
+import com.koushikdutta.ion.bitmap.BitmapInfo;
+import com.koushikdutta.ion.bitmap.IonBitmapCache;
+import com.koushikdutta.ion.builder.Builders;
+import com.koushikdutta.ion.builder.FutureBuilder;
+import com.koushikdutta.ion.builder.LoadBuilder;
+import com.koushikdutta.ion.cookie.CookieMiddleware;
+import com.koushikdutta.ion.loader.AsyncHttpRequestFactory;
+import com.koushikdutta.ion.loader.ContentLoader;
+import com.koushikdutta.ion.loader.FileLoader;
+import com.koushikdutta.ion.loader.HttpLoader;
+import com.koushikdutta.ion.loader.PackageIconLoader;
+import com.koushikdutta.ion.loader.VideoLoader;
+
+import java.io.File;
+import java.io.IOException;
+import java.net.URI;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.WeakHashMap;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+
+/**
+ * Created by koush on 5/21/13.
+ */
+public class Ion {
+    static final Handler mainHandler = new Handler(Looper.getMainLooper());
+    static int availableProcessors = Runtime.getRuntime().availableProcessors();
+    static ExecutorService ioExecutorService = Executors.newFixedThreadPool(4);
+    static ExecutorService bitmapExecutorService  = availableProcessors > 2 ? Executors.newFixedThreadPool(availableProcessors - 1) : Executors.newFixedThreadPool(1);
+    static HashMap<String, Ion> instances = new HashMap<String, Ion>();
+
+    /**
+     * Get the default Ion object instance and begin building a request
+     * @param context
+     * @return
+     */
+    public static LoadBuilder<Builders.Any.B> with(Context context) {
+        return getDefault(context).build(context);
+    }
+
+    /**
+     * the default Ion object instance and begin building a request
+     * @param fragment
+     * @return
+     */
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR2)
+    public static LoadBuilder<Builders.Any.B> with(Fragment fragment) {
+        return getDefault(fragment.getActivity()).build(fragment);
+    }
+
+    /**
+     * the default Ion object instance and begin building a request
+     * @param fragment
+     * @return
+     */
+    public static LoadBuilder<Builders.Any.B> with(android.support.v4.app.Fragment fragment) {
+        return getDefault(fragment.getActivity()).build(fragment);
+    }
+
+    /**
+     * Get the default Ion object instance and begin building a request
+     * with the given uri
+     * @param context
+     * @param uri
+     * @return
+     */
+    @Deprecated
+    public static Builders.Any.B with(Context context, String uri) {
+        return getDefault(context).build(context, uri);
+    }
+
+    /**
+     * Get the default Ion object instance and begin building an operation
+     * on the given file
+     * @param context
+     * @param file
+     * @return
+     */
+    @Deprecated
+    public static FutureBuilder with(Context context, File file) {
+        return getDefault(context).build(context, file);
+    }
+
+    /**
+     * Get the default Ion instance
+     * @param context
+     * @return
+     */
+    public static Ion getDefault(Context context) {
+        return getInstance(context, "ion");
+    }
+
+    /**
+     * Get the given Ion instance by name
+     * @param context
+     * @param name
+     * @return
+     */
+    public static Ion getInstance(Context context, String name) {
+        if (context == null)
+            throw new NullPointerException("Can not pass null context in to retrieve ion instance");
+        Ion instance = instances.get(name);
+        if (instance == null)
+            instances.put(name, instance = new Ion(context, name));
+        return instance;
+    }
+
+    /**
+     * Create a ImageView bitmap request builder
+     * @param imageView
+     * @return
+     */
+    public static Builders.IV.F<? extends Builders.IV.F<?>> with(ImageView imageView) {
+        return getDefault(imageView.getContext()).build(imageView);
+    }
+
+    AsyncHttpClient httpClient;
+    CookieMiddleware cookieMiddleware;
+    ResponseCacheMiddleware responseCache;
+    FileCache storeCache;
+    HttpLoader httpLoader;
+    ContentLoader contentLoader;
+    VideoLoader videoLoader;
+    PackageIconLoader packageIconLoader;
+    FileLoader fileLoader;
+    String logtag;
+    int logLevel;
+    Gson gson = new Gson();
+    String userAgent;
+    ArrayList<Loader> loaders = new ArrayList<Loader>();
+    String name;
+    HashList<FutureCallback<BitmapInfo>> bitmapsPending = new HashList<FutureCallback<BitmapInfo>>();
+    Config config = new Config();
+    IonBitmapCache bitmapCache;
+    Context context;
+    IonBitmapRequestBuilder bitmapBuilder = new IonBitmapRequestBuilder(this);
+
+    private Ion(Context context, String name) {
+        httpClient = new AsyncHttpClient(new AsyncServer("ion-" + name));
+        this.context = context = context.getApplicationContext();
+        this.name = name;
+
+        File ionCacheDir = new File(context.getCacheDir(), name);
+        try {
+            responseCache = ResponseCacheMiddleware.addCache(httpClient, ionCacheDir, 10L * 1024L * 1024L);
+        }
+        catch (IOException e) {
+            IonLog.w("unable to set up response cache, clearing", e);
+            FileUtility.deleteDirectory(ionCacheDir);
+            try {
+                responseCache = ResponseCacheMiddleware.addCache(httpClient, ionCacheDir, 10L * 1024L * 1024L);
+            }
+            catch (IOException ex) {
+                IonLog.w("unable to set up response cache, failing", e);
+            }
+        }
+
+        storeCache = new FileCache(new File(context.getFilesDir(), name), Long.MAX_VALUE, false);
+
+        // TODO: Support pre GB?
+        if (Build.VERSION.SDK_INT >= 9)
+            addCookieMiddleware();
+
+        httpClient.getSocketMiddleware().setConnectAllAddresses(true);
+        httpClient.getSSLSocketMiddleware().setConnectAllAddresses(true);
+
+        bitmapCache = new IonBitmapCache(this);
+
+        configure()
+                .addLoader(videoLoader = new VideoLoader())
+                .addLoader(packageIconLoader = new PackageIconLoader())
+                .addLoader(httpLoader = new HttpLoader())
+                .addLoader(contentLoader = new ContentLoader())
+                .addLoader(fileLoader = new FileLoader());
+    }
+
+    public static ExecutorService getBitmapLoadExecutorService() {
+        return bitmapExecutorService;
+    }
+
+    public static ExecutorService getIoExecutorService() {
+        return ioExecutorService;
+    }
+
+    /**
+     * Begin building an operation on the given file
+     * @param context
+     * @param file
+     * @return
+     */
+    @Deprecated
+    public FutureBuilder build(Context context, File file) {
+        return new IonRequestBuilder(ContextReference.fromContext(context), this).load(file);
+    }
+
+    /**
+     * Begin building a request with the given uri
+     * @param context
+     * @param uri
+     * @return
+     */
+    @Deprecated
+    public Builders.Any.B build(Context context, String uri) {
+        return new IonRequestBuilder(ContextReference.fromContext(context), this).load(uri);
+    }
+
+    /**
+     * Begin building a request
+     * @param context
+     * @return
+     */
+    public LoadBuilder<Builders.Any.B> build(Context context) {
+        return new IonRequestBuilder(ContextReference.fromContext(context), this);
+    }
+
+    /**
+     * Begin building a request
+     * @param fragment
+     * @return
+     */
+    public LoadBuilder<Builders.Any.B> build(Fragment fragment) {
+        return new IonRequestBuilder(new ContextReference.FragmentContextReference(fragment), this);
+    }
+
+    /**
+     * Begin building a request
+     * @param fragment
+     * @return
+     */
+    public LoadBuilder<Builders.Any.B> build(android.support.v4.app.Fragment fragment) {
+        return new IonRequestBuilder(new ContextReference.SupportFragmentContextReference(fragment), this);
+    }
+
+    /**
+     * Create a builder that can be used to build an network request
+     * @param imageView
+     * @return
+     */
+    public Builders.IV.F<? extends Builders.IV.F<?>> build(ImageView imageView) {
+        if (Thread.currentThread() != Looper.getMainLooper().getThread())
+            throw new IllegalStateException("must be called from UI thread");
+        bitmapBuilder.reset();
+        bitmapBuilder.ion = this;
+        return bitmapBuilder.withImageView(imageView);
+    }
+
+    int groupCount(Object group) {
+        FutureSet members;
+        synchronized (this) {
+            members = inFlight.get(group);
+        }
+
+        if (members == null)
+            return 0;
+
+        return members.size();
+    }
+
+    private Runnable processDeferred = new Runnable() {
+        @Override
+        public void run() {
+            if (BitmapFetcher.shouldDeferImageView(Ion.this))
+                return;
+            ArrayList<DeferredLoadBitmap> deferred = null;
+            for (String key: bitmapsPending.keySet()) {
+                Object owner = bitmapsPending.tag(key);
+                if (owner instanceof DeferredLoadBitmap) {
+                    DeferredLoadBitmap deferredLoadBitmap = (DeferredLoadBitmap)owner;
+                    if (deferred == null)
+                        deferred = new ArrayList<DeferredLoadBitmap>();
+                    deferred.add(deferredLoadBitmap);
+                }
+            }
+
+            if (deferred == null)
+                return;
+            int count = 0;
+            for (DeferredLoadBitmap deferredLoadBitmap: deferred) {
+                bitmapsPending.tag(deferredLoadBitmap.key, null);
+                bitmapsPending.tag(deferredLoadBitmap.fetcher.bitmapKey, null);
+                deferredLoadBitmap.fetcher.execute();
+                count++;
+                // do MAX_IMAGEVIEW_LOAD max. this may end up going over the MAX_IMAGEVIEW_LOAD threshhold
+                if (count > BitmapFetcher.MAX_IMAGEVIEW_LOAD)
+                    return;
+            }
+        }
+    };
+
+    void processDeferred() {
+        mainHandler.removeCallbacks(processDeferred);
+        mainHandler.post(processDeferred);
+    }
+
+    /**
+     * Cancel all pending requests associated with the request group
+     * @param group
+     */
+    public void cancelAll(Object group) {
+        FutureSet members;
+        synchronized (this) {
+            members = inFlight.remove(group);
+        }
+
+        if (members == null)
+            return;
+
+        for (Future future: members.keySet()) {
+            if (future != null)
+                future.cancel();
+        }
+    }
+
+    void addFutureInFlight(Future future, Object group) {
+        if (group == null || future == null || future.isDone() || future.isCancelled())
+            return;
+
+        FutureSet members;
+        synchronized (this) {
+            members = inFlight.get(group);
+            if (members == null) {
+                members = new FutureSet();
+                inFlight.put(group, members);
+            }
+        }
+
+        members.put(future, true);
+    }
+
+    /**
+     * Cancel all pending requests
+     */
+    public void cancelAll() {
+        ArrayList<Object> groups;
+
+        synchronized (this) {
+            groups = new ArrayList<Object>(inFlight.keySet());
+        }
+
+        for (Object group: groups)
+            cancelAll(group);
+    }
+
+    /**
+     * Cancel all pending requests associated with the given context
+     * @param context
+     */
+    public void cancelAll(Context context) {
+        cancelAll((Object)context);
+    }
+
+    public int getPendingRequestCount(Object group) {
+        synchronized (this) {
+            FutureSet members = inFlight.get(group);
+            if (members == null)
+                return 0;
+            int ret = 0;
+            for (Future future: members.keySet()) {
+                if (!future.isCancelled() && !future.isDone())
+                    ret++;
+            }
+            return ret;
+        }
+    }
+
+    public void dump() {
+        bitmapCache.dump();
+        Log.i(logtag, "Pending bitmaps: " + bitmapsPending.size());
+        Log.i(logtag, "Groups: " + inFlight.size());
+        for (FutureSet futures: inFlight.values()) {
+            Log.i(logtag, "Group size: " + futures.size());
+        }
+    }
+
+    /**
+     * Get the application Context object in use by this Ion instance
+     * @return
+     */
+    public Context getContext() {
+        return context;
+    }
+
+    static class FutureSet extends WeakHashMap<Future, Boolean> {
+    }
+    // maintain a list of futures that are in being processed, allow for bulk cancellation
+    WeakHashMap<Object, FutureSet> inFlight = new WeakHashMap<Object, FutureSet>();
+
+    private void addCookieMiddleware() {
+        httpClient.insertMiddleware(cookieMiddleware = new CookieMiddleware(context, name));
+    }
+
+    /**
+     * Get or put an item from the cache
+     * @return
+     */
+    public FileCacheStore cache(String key) {
+        return new FileCacheStore(this, responseCache.getFileCache(), key);
+    }
+
+    public FileCache getCache() {
+        return responseCache.getFileCache();
+    }
+
+    /**
+     * Get or put an item in the persistent store
+     * @return
+     */
+    public FileCacheStore store(String key) {
+        return new FileCacheStore(this, storeCache, key);
+    }
+
+    public FileCache getStore() {
+        return storeCache;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    /**
+     * Get the Cookie middleware that is attached to the AsyncHttpClient instance.
+     * @return
+     */
+    public CookieMiddleware getCookieMiddleware() {
+        return cookieMiddleware;
+    }
+
+    /**
+     * Get the AsyncHttpClient object in use by this Ion instance
+     * @return
+     */
+    public AsyncHttpClient getHttpClient() {
+        return httpClient;
+    }
+
+    /**
+     * Get the AsyncServer reactor in use by this Ion instance
+     * @return
+     */
+    public AsyncServer getServer() {
+        return httpClient.getServer();
+    }
+
+    public class Config {
+        public HttpLoader getHttpLoader() {
+            return httpLoader;
+        }
+
+        public VideoLoader getVideoLoader() {
+            return videoLoader;
+        }
+
+        public PackageIconLoader getPackageIconLoader() {
+            return packageIconLoader;
+        }
+
+        public ContentLoader getContentLoader() {
+            return contentLoader;
+        }
+
+        public FileLoader getFileLoader() {
+            return fileLoader;
+        }
+
+        public ResponseCacheMiddleware getResponseCache() {
+            return responseCache;
+        }
+
+        /**
+         * Get the Gson object in use by this Ion instance.
+         * This can be used to customize serialization and deserialization
+         * from java objects.
+         * @return
+         */
+        public Gson getGson() {
+            return gson;
+        }
+
+        /**
+         * Set the log level for all requests made by Ion.
+         * @param logtag
+         * @param logLevel
+         * @return
+         */
+        public Config setLogging(String logtag, int logLevel) {
+            Ion.this.logtag = logtag;
+            Ion.this.logLevel = logLevel;
+            return this;
+        }
+
+        /**
+         * Route all http requests through the given proxy.
+         * @param host
+         * @param port
+         */
+        public void proxy(String host, int port) {
+            httpClient.getSocketMiddleware().enableProxy(host, port);
+        }
+
+        /**
+         * Route all https requests through the given proxy.
+         * Note that https proxying requires that the Android device has the appropriate
+         * root certificate installed to function properly.
+         * @param host
+         * @param port
+         */
+        public void proxySecure(String host, int port) {
+            httpClient.getSSLSocketMiddleware().enableProxy(host, port);
+        }
+
+        /**
+         * Disable routing of http requests through a previous provided proxy
+         */
+        public void disableProxy() {
+            httpClient.getSocketMiddleware().disableProxy();
+        }
+
+        /**
+         * Disable routing of https requests through a previous provided proxy
+         */
+        public void disableSecureProxy() {
+            httpClient.getSocketMiddleware().disableProxy();
+        }
+
+        /**
+         * Set the Gson object in use by this Ion instance.
+         * This can be used to customize serialization and deserialization
+         * from java objects.
+         * @param gson
+         */
+        public void setGson(Gson gson) {
+            Ion.this.gson = gson;
+        }
+
+        AsyncHttpRequestFactory asyncHttpRequestFactory = new AsyncHttpRequestFactory() {
+            @Override
+            public AsyncHttpRequest createAsyncHttpRequest(URI uri, String method, RawHeaders headers) {
+                AsyncHttpRequest request = new AsyncHttpRequest(uri, method, headers);
+                if (!TextUtils.isEmpty(userAgent))
+                    request.getHeaders().setUserAgent(userAgent);
+                return request;
+            }
+        };
+
+        public AsyncHttpRequestFactory getAsyncHttpRequestFactory() {
+            return asyncHttpRequestFactory;
+        }
+
+        public Config setAsyncHttpRequestFactory(AsyncHttpRequestFactory asyncHttpRequestFactory) {
+            this.asyncHttpRequestFactory = asyncHttpRequestFactory;
+            return this;
+        }
+
+        public String userAgent() {
+            return userAgent;
+        }
+
+        public Config userAgent(String userAgent) {
+            Ion.this.userAgent = userAgent;
+            return this;
+        }
+
+        public Config addLoader(int index, Loader loader) {
+            loaders.add(index, loader);
+            return this;
+        }
+        public Config insertLoader(Loader loader) {
+            loaders.add(0, loader);
+            return this;
+        }
+        public Config addLoader(Loader loader) {
+            loaders.add(loader);
+            return this;
+        }
+        public List<Loader> getLoaders() {
+            return loaders;
+        }
+    }
+
+    public Config configure() {
+        return config;
+    }
+
+    /**
+     * Return the bitmap cache used by this Ion instance
+     * @return
+     */
+    public IonBitmapCache getBitmapCache() {
+        return bitmapCache;
+    }
+}
diff --git a/src/com/koushikdutta/ion/IonBitmapRequestBuilder.java b/src/com/koushikdutta/ion/IonBitmapRequestBuilder.java
new file mode 100644
index 00000000..7b03ac48
--- /dev/null
+++ b/src/com/koushikdutta/ion/IonBitmapRequestBuilder.java
@@ -0,0 +1,427 @@
+package com.koushikdutta.ion;
+
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.os.Build;
+import android.os.Looper;
+import android.view.animation.Animation;
+import android.view.animation.AnimationUtils;
+import android.widget.ImageView;
+
+import com.koushikdutta.async.future.Future;
+import com.koushikdutta.async.future.SimpleFuture;
+import com.koushikdutta.async.util.FileCache;
+import com.koushikdutta.ion.bitmap.BitmapInfo;
+import com.koushikdutta.ion.bitmap.Transform;
+import com.koushikdutta.ion.builder.BitmapFutureBuilder;
+import com.koushikdutta.ion.builder.Builders;
+import com.koushikdutta.ion.builder.ImageViewFutureBuilder;
+
+import java.util.ArrayList;
+
+/**
+ * Created by koush on 5/23/13.
+ */
+class IonBitmapRequestBuilder implements Builders.IV.F, ImageViewFutureBuilder, BitmapFutureBuilder, Builders.Any.BF {
+    private static final SimpleFuture<ImageView> FUTURE_IMAGEVIEW_NULL_URI = new SimpleFuture<ImageView>() {
+        {
+            setComplete(new NullPointerException("uri"));
+        }
+    };
+    private static final SimpleFuture<Bitmap> FUTURE_BITMAP_NULL_URI = new SimpleFuture<Bitmap>() {
+        {
+            setComplete(new NullPointerException("uri"));
+        }
+    };
+
+    IonRequestBuilder builder;
+    Ion ion;
+    ContextReference.ImageViewContextReference imageViewPostRef;
+    ArrayList<Transform> transforms;
+    Drawable placeholderDrawable;
+    int placeholderResource;
+    Drawable errorDrawable;
+    int errorResource;
+    Animation inAnimation;
+    Animation loadAnimation;
+    int loadAnimationResource;
+    int inAnimationResource;
+    ScaleMode scaleMode = ScaleMode.FitXY;
+    int resizeWidth;
+    int resizeHeight;
+    boolean disableFadeIn;
+    boolean animateGif = true;
+    boolean deepZoom;
+
+    void reset() {
+        placeholderDrawable = null;
+        placeholderResource = 0;
+        errorDrawable = null;
+        errorResource = 0;
+        ion = null;
+        imageViewPostRef = null;
+        transforms = null;
+        inAnimation = null;
+        inAnimationResource = 0;
+        loadAnimation = null;
+        loadAnimationResource = 0;
+        scaleMode = ScaleMode.FitXY;
+        resizeWidth = 0;
+        resizeHeight = 0;
+        disableFadeIn = false;
+        animateGif = true;
+        builder = null;
+        deepZoom = false;
+    }
+
+    public IonBitmapRequestBuilder(IonRequestBuilder builder) {
+        this.builder = builder;
+        ion = builder.ion;
+    }
+
+    public IonBitmapRequestBuilder(Ion ion) {
+        this.ion = ion;
+    }
+
+    static void doAnimation(ImageView imageView, Animation animation, int animationResource) {
+        if (imageView == null)
+            return;
+        if (animation == null && animationResource != 0)
+            animation = AnimationUtils.loadAnimation(imageView.getContext(), animationResource);
+        if (animation == null) {
+            imageView.setAnimation(null);
+            return;
+        }
+
+        imageView.startAnimation(animation);
+    }
+
+    private IonRequestBuilder ensureBuilder() {
+        if (builder == null)
+            builder = new IonRequestBuilder(ContextReference.fromContext(imageViewPostRef.getContext().getApplicationContext()), ion);
+        return builder;
+    }
+
+    @Override
+    public Future<ImageView> load(String uri) {
+        ensureBuilder();
+        builder.load(uri);
+        return intoImageView(imageViewPostRef.get());
+    }
+
+    @Override
+    public Future<ImageView> load(String method, String url) {
+        ensureBuilder();
+        builder.load(method, url);
+        return intoImageView(imageViewPostRef.get());
+    }
+
+    IonBitmapRequestBuilder withImageView(ImageView imageView) {
+        imageViewPostRef = new ContextReference.ImageViewContextReference(imageView);
+        return this;
+    }
+
+    @Override
+    public IonBitmapRequestBuilder transform(Transform transform) {
+        if (transform == null)
+            return this;
+        if (transforms == null)
+            transforms = new ArrayList<Transform>();
+        transforms.add(transform);
+        return this;
+    }
+
+    private String computeDownloadKey() {
+        String downloadKey = builder.uri;
+        // although a gif is always same download, the initial decode is different
+        if (!animateGif)
+            downloadKey += ":!animateGif";
+        if (deepZoom)
+            downloadKey += ":deepZoom";
+        return FileCache.toKeyString(downloadKey);
+    }
+
+    @Override
+    public BitmapInfo asCachedBitmap() {
+        final String downloadKey = computeDownloadKey();
+        assert Thread.currentThread() == Looper.getMainLooper().getThread() || imageViewPostRef == null;
+        assert downloadKey != null;
+
+        if (resizeHeight > 0 || resizeWidth > 0) {
+            if (transforms == null)
+                transforms = new ArrayList<Transform>();
+            transforms.add(0, new DefaultTransform(resizeWidth, resizeHeight, scaleMode));
+        }
+
+        // determine the key for this bitmap after all transformations
+        String bitmapKey = downloadKey;
+        boolean hasTransforms = transforms != null && transforms.size() > 0;
+        if (hasTransforms) {
+            for (Transform transform : transforms) {
+                bitmapKey += transform.key();
+            }
+            bitmapKey = FileCache.toKeyString(bitmapKey);
+        }
+
+        return builder.ion.bitmapCache.get(bitmapKey);
+    }
+
+    BitmapFetcher executeCache() {
+        final String downloadKey = computeDownloadKey();
+        assert Thread.currentThread() == Looper.getMainLooper().getThread() || imageViewPostRef == null;
+        assert downloadKey != null;
+
+        if (resizeHeight > 0 || resizeWidth > 0) {
+            if (transforms == null)
+                transforms = new ArrayList<Transform>();
+            transforms.add(0, new DefaultTransform(resizeWidth, resizeHeight, scaleMode));
+        }
+
+        // determine the key for this bitmap after all transformations
+        String bitmapKey = downloadKey;
+        boolean hasTransforms = transforms != null && transforms.size() > 0;
+        if (hasTransforms) {
+            for (Transform transform : transforms) {
+                bitmapKey += transform.key();
+            }
+            bitmapKey = FileCache.toKeyString(bitmapKey);
+        }
+
+        // TODO: eliminate this allocation?
+        BitmapFetcher ret = new BitmapFetcher();
+        ret.downloadKey = downloadKey;
+        ret.bitmapKey = bitmapKey;
+        ret.hasTransforms = hasTransforms;
+        ret.resizeWidth = resizeWidth;
+        ret.resizeHeight = resizeHeight;
+        ret.builder = builder;
+        ret.transforms = transforms;
+        ret.animateGif = animateGif;
+        ret.deepZoom = deepZoom;
+
+        // see if this request can be fulfilled from the cache
+        if (!builder.noCache) {
+            BitmapInfo bitmap = builder.ion.bitmapCache.get(bitmapKey);
+            if (bitmap != null) {
+                ret.info = bitmap;
+                return ret;
+            }
+        }
+
+        return ret;
+    }
+
+    private IonDrawable setIonDrawable(ImageView imageView, BitmapInfo info, int loadedFrom) {
+        IonDrawable ret = IonDrawable.getOrCreateIonDrawable(imageView)
+        .ion(ion)
+        .setBitmap(info, loadedFrom)
+        .setSize(resizeWidth, resizeHeight)
+        .setError(errorResource, errorDrawable)
+        .setPlaceholder(placeholderResource, placeholderDrawable)
+        .setInAnimation(inAnimation, inAnimationResource)
+        .setDisableFadeIn(disableFadeIn);
+        imageView.setImageDrawable(ret);
+        return ret;
+    }
+
+    @Override
+    public Future<ImageView> intoImageView(ImageView imageView) {
+        if (imageView == null)
+            throw new IllegalArgumentException("imageView");
+        assert Thread.currentThread() == Looper.getMainLooper().getThread();
+
+        if (builder.uri != null && builder.uri.startsWith("android.resource:/")) {
+            IonDrawable drawable = setIonDrawable(imageView, null, 0);
+            SimpleFuture<ImageView> imageViewFuture = drawable.getFuture();
+            imageViewFuture.reset();
+            imageView.setImageURI(Uri.parse(builder.uri));
+            imageViewFuture.setComplete(null, imageView);
+            return imageViewFuture;
+        }
+
+        // no uri? just set a placeholder and bail
+        if (builder.uri == null) {
+            setIonDrawable(imageView, null, 0).cancel();
+            return FUTURE_IMAGEVIEW_NULL_URI;
+        }
+
+        // executeCache the request, see if we get a bitmap from cache.
+        BitmapFetcher bitmapFetcher = executeCache();
+        if (bitmapFetcher.info != null) {
+            doAnimation(imageView, null, 0);
+            IonDrawable drawable = setIonDrawable(imageView, bitmapFetcher.info, Loader.LoaderEmitter.LOADED_FROM_MEMORY);
+            drawable.cancel();
+            SimpleFuture<ImageView> imageViewFuture = drawable.getFuture();
+            imageViewFuture.reset();
+            imageViewFuture.setComplete(bitmapFetcher.info.exception, imageView);
+            return imageViewFuture;
+        }
+
+        // nothing from cache, check to see if there's too many imageview loads
+        // already in progress
+        if (BitmapFetcher.shouldDeferImageView(ion)) {
+            bitmapFetcher.defer();
+        }
+        else {
+            bitmapFetcher.execute();
+        }
+
+        IonDrawable drawable = setIonDrawable(imageView, null, 0);
+        doAnimation(imageView, loadAnimation, loadAnimationResource);
+        SimpleFuture<ImageView> imageViewFuture = drawable.getFuture();
+        imageViewFuture.reset();
+        drawable.register(ion, bitmapFetcher.bitmapKey);
+        return imageViewFuture;
+    }
+
+    @Override
+    public Future<Bitmap> asBitmap() {
+        if (builder.uri == null) {
+            return FUTURE_BITMAP_NULL_URI;
+        }
+
+        // see if we get something back synchronously
+        BitmapFetcher bitmapFetcher = executeCache();
+        if (bitmapFetcher.info != null) {
+            SimpleFuture<Bitmap> ret = new SimpleFuture<Bitmap>();
+            Bitmap bitmap = bitmapFetcher.info.bitmaps == null ? null : bitmapFetcher.info.bitmaps[0];
+            ret.setComplete(bitmapFetcher.info.exception, bitmap);
+            return ret;
+        }
+
+        bitmapFetcher.execute();
+        // we're loading, so let's register for the result.
+        BitmapInfoToBitmap ret = new BitmapInfoToBitmap(builder.contextReference);
+        ion.bitmapsPending.add(bitmapFetcher.bitmapKey, ret);
+        return ret;
+    }
+
+    @Override
+    public IonBitmapRequestBuilder placeholder(Drawable drawable) {
+        placeholderDrawable = drawable;
+        return this;
+    }
+
+    @Override
+    public IonBitmapRequestBuilder placeholder(int resourceId) {
+        placeholderResource = resourceId;
+        return this;
+    }
+
+    @Override
+    public IonBitmapRequestBuilder error(Drawable drawable) {
+        errorDrawable = drawable;
+        return this;
+    }
+
+    @Override
+    public IonBitmapRequestBuilder error(int resourceId) {
+        errorResource = resourceId;
+        return this;
+    }
+
+    @Override
+    public IonBitmapRequestBuilder animateIn(Animation in) {
+        inAnimation = in;
+        return this;
+    }
+
+    @Override
+    public IonBitmapRequestBuilder animateLoad(Animation load) {
+        loadAnimation = load;
+        return this;
+    }
+
+    @Override
+    public IonBitmapRequestBuilder animateLoad(int animationResource) {
+        loadAnimationResource = animationResource;
+        return this;
+    }
+
+    @Override
+    public IonBitmapRequestBuilder animateIn(int animationResource) {
+        inAnimationResource = animationResource;
+        return this;
+    }
+
+    @Override
+    public IonBitmapRequestBuilder centerCrop() {
+        if (transforms != null && transforms.size() > 0)
+            throw new IllegalStateException("Can't apply centerCrop after transform has been called." +
+            "centerCrop is applied to the original resized bitmap.");
+        if (resizeWidth <= 0 || resizeHeight <= 0)
+            throw new IllegalStateException("must call resize first");
+        scaleMode = ScaleMode.CenterCrop;
+        return this;
+    }
+
+    @Override
+    public IonBitmapRequestBuilder centerInside() {
+        if (transforms != null && transforms.size() > 0)
+            throw new IllegalStateException("Can't apply centerInside after transform has been called." +
+            "centerInside is applied to the original resized bitmap.");
+        if (resizeWidth <= 0 || resizeHeight <= 0)
+            throw new IllegalStateException("must call resize first");
+        scaleMode = ScaleMode.CenterInside;
+        return this;
+    }
+
+    @Override
+    public IonBitmapRequestBuilder resize(int width, int height) {
+        // TODO: prevent multiple calls to resize and friends?
+        if (transforms != null && transforms.size() > 0)
+            throw new IllegalStateException("Can't apply resize after transform has been called." +
+                "resize is applied to the original bitmap.");
+        if (deepZoom)
+            throw new IllegalStateException("Can not resize with deepZoom.");
+        resizeWidth = width;
+        resizeHeight = height;
+        return this;
+    }
+
+    @Override
+    public IonBitmapRequestBuilder disableFadeIn() {
+        this.disableFadeIn = true;
+        return this;
+    }
+	
+	public IonBitmapRequestBuilder smartSize(boolean smartSize) {
+        //don't want to disable device resize if user has already resized the Bitmap.
+        if (resizeWidth > 0 || resizeHeight > 0)
+            throw new IllegalStateException("Can't set smart size after resize has been called.");
+
+        if (deepZoom)
+            throw new IllegalStateException("Can not smartSize with deepZoom.");
+
+        if (!smartSize) {
+			resizeWidth = -1;
+			resizeHeight = -1;
+		}
+        else {
+            resizeWidth = 0;
+            resizeHeight = 0;
+        }
+		return this;
+	}
+
+    @Override
+    public IonBitmapRequestBuilder animateGif(boolean animateGif) {
+        this.animateGif = animateGif;
+        return this;
+    }
+
+    @Override
+    public IonBitmapRequestBuilder deepZoom() {
+        if (Build.VERSION.SDK_INT < 10)
+            return this;
+        this.deepZoom = true;
+        if (resizeWidth > 0 || resizeHeight > 0)
+            throw new IllegalStateException("Can't deepZoom with resize.");
+        if (transforms != null && transforms.size() > 0)
+            throw new IllegalStateException("Can't deepZoom with transforms.");
+        resizeWidth = 0;
+        resizeHeight = 0;
+        return this;
+    }
+}
diff --git a/src/com/koushikdutta/ion/IonDrawable.java b/src/com/koushikdutta/ion/IonDrawable.java
new file mode 100644
index 00000000..89965b54
--- /dev/null
+++ b/src/com/koushikdutta/ion/IonDrawable.java
@@ -0,0 +1,596 @@
+package com.koushikdutta.ion;
+
+import android.content.res.Resources;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.ColorFilter;
+import android.graphics.Paint;
+import android.graphics.PixelFormat;
+import android.graphics.Rect;
+import android.graphics.drawable.Drawable;
+import android.os.Looper;
+import android.os.SystemClock;
+import android.text.TextUtils;
+import android.view.animation.Animation;
+import android.widget.ImageView;
+
+import com.koushikdutta.async.future.FutureCallback;
+import com.koushikdutta.async.future.SimpleFuture;
+import com.koushikdutta.async.util.FileCache;
+import com.koushikdutta.ion.bitmap.BitmapInfo;
+
+import java.lang.ref.WeakReference;
+
+/**
+ * Created by koush on 6/8/13.
+ */
+class IonDrawable extends Drawable {
+    private Paint paint;
+    private BitmapInfo info;
+    private int placeholderResource;
+    private Drawable placeholder;
+    private int errorResource;
+    private Drawable error;
+    private Resources resources;
+    private int loadedFrom;
+    private IonDrawableCallback callback;
+    private boolean disableFadeIn;
+    private int resizeWidth;
+    private int resizeHeight;
+    private Ion ion;
+
+    public IonDrawable cancel() {
+        requestCount++;
+        return this;
+    }
+
+    public IonDrawable ion(Ion ion) {
+        this.ion = ion;
+        return this;
+    }
+
+    public SimpleFuture<ImageView> getFuture() {
+        return callback.imageViewFuture;
+    }
+    
+    public IonDrawable setDisableFadeIn(boolean disableFadeIn) {
+        this.disableFadeIn = disableFadeIn;
+        return this;
+    }
+
+    public IonDrawable setInAnimation(Animation inAnimation, int inAnimationResource) {
+        callback.inAnimation = inAnimation;
+        callback.inAnimationResource = inAnimationResource;
+        return this;
+    }
+
+    // create an internal static class that can act as a callback.
+    // dont let it hold strong references to anything.
+    static class IonDrawableCallback implements FutureCallback<BitmapInfo> {
+        private WeakReference<IonDrawable> ionDrawableRef;
+        private ContextReference.ImageViewContextReference imageViewRef;
+        private String bitmapKey;
+        private SimpleFuture<ImageView> imageViewFuture = new SimpleFuture<ImageView>();
+        private Animation inAnimation;
+        private int inAnimationResource;
+        private int requestId;
+
+        public IonDrawableCallback(IonDrawable drawable, ImageView imageView) {
+            ionDrawableRef = new WeakReference<IonDrawable>(drawable);
+            imageViewRef = new ContextReference.ImageViewContextReference(imageView);
+        }
+
+        @Override
+        public void onCompleted(Exception e, BitmapInfo result) {
+            assert Thread.currentThread() == Looper.getMainLooper().getThread();
+            assert result != null;
+            // see if the imageview is still alive and cares about this result
+            ImageView imageView = imageViewRef.get();
+            if (imageView == null)
+                return;
+
+            IonDrawable drawable = ionDrawableRef.get();
+            if (drawable == null)
+                return;
+
+            if (imageView.getDrawable() != drawable)
+                return;
+
+            // see if the ImageView is still waiting for the same request
+            if (drawable.requestCount != requestId)
+                return;
+
+            imageView.setImageDrawable(null);
+            drawable.setBitmap(result, result.loadedFrom);
+            imageView.setImageDrawable(drawable);
+            IonBitmapRequestBuilder.doAnimation(imageView, inAnimation, inAnimationResource);
+
+            if (null != imageViewRef.isAlive()) {
+                imageViewFuture.cancelSilently();
+                return;
+            }
+
+            imageViewFuture.setComplete(e, imageView);
+        }
+    }
+
+    int requestCount;
+    public void register(Ion ion, String bitmapKey) {
+        callback.requestId = ++requestCount;
+        String previousKey = callback.bitmapKey;
+        if (TextUtils.equals(previousKey, bitmapKey))
+            return;
+        callback.bitmapKey = bitmapKey;
+        ion.bitmapsPending.add(bitmapKey, callback);
+        if (previousKey == null)
+            return;
+
+        // unregister this drawable from the bitmaps that are
+        // pending.
+
+        // if this drawable was the only thing waiting for this bitmap,
+        // then the removeItem call will return the TransformBitmap/LoadBitmap instance
+        // that was providing the result.
+        if (ion.bitmapsPending.removeItem(previousKey, callback)) {
+            // find out who owns this thing, to see if it is a candidate for removal
+            Object owner = ion.bitmapsPending.tag(previousKey);
+            if (owner instanceof TransformBitmap) {
+                TransformBitmap info = (TransformBitmap)owner;
+                ion.bitmapsPending.remove(info.key);
+                // this transform is also backed by a LoadBitmap* or a DeferredLoadBitmap, grab that
+                // if it is the only waiter
+                if (ion.bitmapsPending.removeItem(info.downloadKey, info))
+                    owner = ion.bitmapsPending.tag(info.downloadKey);
+            }
+            if (owner instanceof DeferredLoadBitmap) {
+                DeferredLoadBitmap defer = (DeferredLoadBitmap)owner;
+                ion.bitmapsPending.remove(defer.key);
+            }
+        }
+
+        ion.processDeferred();
+    }
+
+    private static final int DEFAULT_PAINT_FLAGS = Paint.FILTER_BITMAP_FLAG | Paint.DITHER_FLAG;
+
+    public IonDrawable(Resources resources, ImageView imageView) {
+        this.resources = resources;
+        paint = new Paint(DEFAULT_PAINT_FLAGS);
+        callback = new IonDrawableCallback(this, imageView);
+    }
+
+    int currentFrame;
+    private boolean invalidateScheduled;
+    private int textureDim;
+    private int maxLevel;
+    public IonDrawable setBitmap(BitmapInfo info, int loadedFrom) {
+        this.loadedFrom = loadedFrom;
+        requestCount++;
+
+        if (this.info == info)
+            return this;
+
+        invalidateSelf();
+
+        this.info = info;
+        currentFrame = 0;
+        invalidateScheduled = false;
+        if (info == null) {
+            callback.bitmapKey = null;
+            return this;
+        }
+
+        if (info.decoder != null) {
+            // find number of tiles across to fit
+            double wlevel = (double)info.originalSize.x / TILE_DIM;
+            double hlevel = (double)info.originalSize.y / TILE_DIM;
+
+            // find the level: find how many power of 2 tiles are necessary
+            // to fit the entire image. ie, fit it into a square.
+            double level = Math.max(wlevel, hlevel);
+            level = Math.log(level) / LOG_2;
+
+            maxLevel = (int)Math.ceil(level);
+
+            // now, we know the entire image will fit in a square image of
+            // this dimension:
+            textureDim = TILE_DIM << maxLevel;
+        }
+
+        callback.bitmapKey = info.key;
+        return this;
+    }
+
+    public IonDrawable setSize(int resizeWidth, int resizeHeight) {
+        if (this.resizeWidth == resizeWidth && this.resizeHeight == resizeHeight)
+            return this;
+        this.resizeWidth = resizeWidth;
+        this.resizeHeight = resizeHeight;
+        invalidateSelf();
+        return this;
+    }
+
+    public IonDrawable setError(int resource, Drawable drawable) {
+        if ((drawable != null && drawable == this.error) || (resource != 0 && resource == errorResource))
+            return this;
+
+        this.errorResource = resource;
+        this.error = drawable;
+        invalidateSelf();
+        return this;
+    }
+
+    public IonDrawable setPlaceholder(int resource, Drawable drawable) {
+        if ((drawable != null && drawable == this.placeholder) || (resource != 0 && resource == placeholderResource))
+            return this;
+
+        this.placeholderResource = resource;
+        this.placeholder = drawable;
+        invalidateSelf();
+
+        return this;
+    }
+
+    @Override
+    public void setFilterBitmap(boolean filter) {
+        paint.setFilterBitmap(filter);
+        invalidateSelf();
+    }
+
+    @Override
+    public void setDither(boolean dither) {
+        paint.setDither(dither);
+        invalidateSelf();
+    }
+
+    private Drawable tryGetErrorResource() {
+        if (error != null)
+            return error;
+        if (errorResource == 0)
+            return null;
+        return error = resources.getDrawable(errorResource);
+    }
+
+    @Override
+    public int getIntrinsicWidth() {
+        if (info != null) {
+            if (info.decoder != null)
+                return info.originalSize.x;
+            if (info.bitmaps != null)
+                return info.bitmaps[0].getScaledWidth(resources.getDisplayMetrics().densityDpi);
+        }
+        if (resizeWidth > 0)
+            return resizeWidth;
+        if (info != null) {
+            Drawable error = tryGetErrorResource();
+            if (error != null)
+                return error.getIntrinsicWidth();
+        }
+        if (placeholder != null) {
+            return placeholder.getIntrinsicWidth();
+        } else if (placeholderResource != 0) {
+            Drawable d = resources.getDrawable(placeholderResource);
+            assert d != null;
+            return d.getIntrinsicWidth();
+        }
+        return -1;
+    }
+
+    @Override
+    public int getIntrinsicHeight() {
+        if (info != null) {
+            if (info.decoder != null)
+                return info.originalSize.y;
+            if (info.bitmaps != null)
+                return info.bitmaps[0].getScaledHeight(resources.getDisplayMetrics().densityDpi);
+        }
+        if (resizeHeight > 0)
+            return resizeHeight;
+        if (info != null) {
+            if (error != null) {
+                return error.getIntrinsicHeight();
+            } else if (errorResource != 0) {
+                Drawable d = resources.getDrawable(errorResource);
+                assert d != null;
+                return d.getIntrinsicHeight();
+            }
+        }
+        if (placeholder != null) {
+            return placeholder.getIntrinsicHeight();
+        } else if (placeholderResource != 0) {
+            Drawable d = resources.getDrawable(placeholderResource);
+            assert d != null;
+            return d.getIntrinsicHeight();
+        }
+        return -1;
+    }
+
+    public static final long FADE_DURATION = 200;
+    private Runnable invalidate = new Runnable() {
+        @Override
+        public void run() {
+            invalidateScheduled = false;
+            currentFrame++;
+            invalidateSelf();
+        }
+    };
+
+    private static final double LOG_2 = Math.log(2);
+    private static final int TILE_DIM = 256;
+
+    FutureCallback<BitmapInfo> tileCallback = new FutureCallback<BitmapInfo>() {
+        @Override
+        public void onCompleted(Exception e, BitmapInfo result) {
+            invalidateSelf();
+        }
+    };
+
+    @Override
+    public void draw(Canvas canvas) {
+        if (info == null) {
+            if (placeholder == null && placeholderResource != 0)
+                placeholder = resources.getDrawable(placeholderResource);
+            if (placeholder != null) {
+                placeholder.setBounds(getBounds());
+                placeholder.draw(canvas);
+            }
+            return;
+        }
+
+        if (info.drawTime == 0)
+            info.drawTime = SystemClock.uptimeMillis();
+
+        long destAlpha = 0xFF;
+
+        if(!disableFadeIn) {
+            destAlpha = ((SystemClock.uptimeMillis() - info.drawTime) << 8) / FADE_DURATION;
+            destAlpha = Math.min(destAlpha, 0xFF);
+        }
+
+        if (destAlpha != 255) {
+            if (placeholder == null && placeholderResource != 0)
+                placeholder = resources.getDrawable(placeholderResource);
+            if (placeholder != null) {
+                placeholder.setBounds(getBounds());
+                placeholder.draw(canvas);
+            }
+        }
+
+        if (info.decoder != null) {
+            // zoom 0: entire image fits in a TILE_DIMxTILE_DIM square
+
+            // draw base bitmap for empty tiles
+            // figure out zoom level
+            // figure out which tiles need rendering
+            // draw stuff that needs drawing
+            // missing tile? fetch it
+            // use parent level tiles for tiles that do not exist
+
+            // TODO: crossfading?
+
+            Rect clip = canvas.getClipBounds();
+            Rect bounds = getBounds();
+
+            float zoom = (float)canvas.getWidth() / (float)clip.width();
+
+            float zoomWidth = zoom * bounds.width();
+            float zoomHeight = zoom * bounds.height();
+
+            double wlevel = Math.log(zoomWidth / TILE_DIM) / LOG_2;
+            double hlevel = Math.log(zoomHeight/ TILE_DIM) / LOG_2;
+            double maxLevel = Math.max(wlevel, hlevel);
+
+            int visibleLeft = Math.max(0, clip.left);
+            int visibleRight = Math.min(bounds.width(), clip.right);
+            int visibleTop = Math.max(0, clip.top);
+            int visibleBottom = Math.min(bounds.height(), clip.bottom);
+            int level = (int)Math.floor(maxLevel);
+            level = Math.min(this.maxLevel, level);
+            level = Math.max(level, 0);
+            int levelTiles = 1 << level;
+            int textureTileDim = textureDim / levelTiles;
+//            System.out.println("textureTileDim: " + textureTileDim);
+
+//            System.out.println(info.key + " visible: " + new Rect(visibleLeft, visibleTop, visibleRight, visibleBottom));
+
+            final boolean DEBUG_ZOOM = false;
+            if (info.bitmaps != null && info.bitmaps[0] != null) {
+                canvas.drawBitmap(info.bitmaps[0], null, getBounds(), paint);
+                if (DEBUG_ZOOM) {
+                    paint.setColor(Color.RED);
+                    paint.setAlpha(0x80);
+                    canvas.drawRect(getBounds(), paint);
+                    paint.setAlpha(0xFF);
+                }
+            }
+            else {
+                paint.setColor(Color.BLACK);
+                canvas.drawRect(getBounds(), paint);
+            }
+
+            int sampleSize = 1;
+            while (textureTileDim / sampleSize > TILE_DIM)
+                sampleSize <<= 1;
+
+            for (int y = 0; y < levelTiles; y++) {
+                int top = textureTileDim * y;
+                int bottom = textureTileDim * (y + 1);
+                bottom = Math.min(bottom, bounds.bottom);
+                // TODO: start at visible pos
+                if (bottom < visibleTop)
+                    continue;
+                if (top > visibleBottom)
+                    break;
+                for (int x = 0; x < levelTiles; x++) {
+                    int left = textureTileDim * x;
+                    int right = textureTileDim * (x + 1);
+                    right = Math.min(right, bounds.right);
+                    // TODO: start at visible pos
+                    if (right < visibleLeft)
+                        continue;
+                    if (left > visibleRight)
+                        break;
+
+                    Rect texRect = new Rect(left, top, right, bottom);
+
+                    // find, render/fetch
+//                    System.out.println("rendering: " + texRect + " for: " + bounds);
+                    String tileKey = FileCache.toKeyString(info.key, ",", level, ",", x, ",", y);
+                    BitmapInfo tile = ion.bitmapCache.get(tileKey);
+                    if (tile != null && tile.bitmaps != null) {
+                        // render it
+//                        System.out.println("bitmap is: " + tile.bitmaps[0].getWidth() + "x" + tile.bitmaps[0].getHeight());
+                        canvas.drawBitmap(tile.bitmaps[0], null, texRect, paint);
+                        continue;
+                    }
+
+                    // TODO: cancellation of unnecessary regions when fast pan/zooming
+                    if (ion.bitmapsPending.tag(tileKey) == null) {
+                        // fetch it
+//                        System.out.println(info.key + ": fetching region: " + texRect + " sample size: " + sampleSize);
+                        LoadBitmapRegion region = new LoadBitmapRegion(ion, tileKey, info.decoder, texRect, sampleSize);
+                    }
+                    ion.bitmapsPending.add(tileKey, tileCallback);
+
+                    int parentLeft = 0;
+                    int parentTop = 0;
+                    int parentUp = 1;
+                    int parentLevel = level - parentUp;
+                    if (x % 2 == 1)
+                        parentLeft++;
+                    if (y % 2 == 1)
+                        parentTop++;
+                    int parentX = x >> 1;
+                    int parentY = y >> 1;
+
+                    while (parentLevel >= 0) {
+                        tileKey = FileCache.toKeyString(info.key, ",", parentLevel, ",", parentX, ",", parentY);
+                        tile = ion.bitmapCache.get(tileKey);
+                        if (tile != null && tile.bitmaps != null)
+                            break;
+                        if (parentX % 2 == 1) {
+                            parentLeft += 1 << parentUp;
+                        }
+                        if (parentY % 2 == 1) {
+                            parentTop += 1 << parentUp;
+                        }
+                        parentLevel--;
+                        parentUp++;
+                        parentX >>= 1;
+                        parentY >>= 1;
+                    }
+
+                    // well, i give up
+                    if (tile == null || tile.bitmaps == null)
+                        continue;
+
+
+                    int subLevelTiles = 1 << parentLevel;
+                    int subtileDim = textureDim / subLevelTiles;
+                    int subSampleSize = 1;
+                    while (subtileDim / subSampleSize > TILE_DIM)
+                        subSampleSize <<= 1;
+                    int subTextureDim = subtileDim / subSampleSize;
+//                    System.out.println(String.format("falling back for %s,%s,%s to %s,%s,%s: %s,%s (%s to %s)", x, y, level, parentX, parentY, parentLevel, parentLeft, parentTop, subTextureDim, subTextureDim >> parentUp));
+                    subTextureDim >>= parentUp;
+                    int sourceLeft = subTextureDim * parentLeft;
+                    int sourceTop = subTextureDim * parentTop;
+                    Rect sourceRect = new Rect(sourceLeft, sourceTop, sourceLeft + subTextureDim, sourceTop + subTextureDim);
+                    canvas.drawBitmap(tile.bitmaps[0], sourceRect, texRect, paint);
+
+                    if (DEBUG_ZOOM) {
+                        paint.setColor(Color.RED);
+                        paint.setAlpha(0x80);
+                        canvas.drawRect(texRect, paint);
+                        paint.setAlpha(0xFF);
+                    }
+                }
+            }
+        }
+        else if (info.bitmaps != null) {
+            paint.setAlpha((int)destAlpha);
+            canvas.drawBitmap(info.bitmaps[currentFrame % info.bitmaps.length], null, getBounds(), paint);
+            paint.setAlpha(0xFF);
+            if (info.delays != null) {
+                int delay = info.delays[currentFrame % info.delays.length];
+                if (!invalidateScheduled) {
+                    invalidateScheduled = true;
+                    unscheduleSelf(invalidate);
+                    scheduleSelf(invalidate, SystemClock.uptimeMillis() + Math.max(delay, 100));
+                }
+            }
+        }
+        else {
+            Drawable error = tryGetErrorResource();
+            if (error != null) {
+                error.setAlpha((int)destAlpha);
+                error.setBounds(getBounds());
+                error.draw(canvas);
+                error.setAlpha(0xFF);
+            }
+        }
+
+        if (destAlpha != 255)
+            invalidateSelf();
+
+        if (true)
+            return;
+
+        // stolen from picasso
+        canvas.save();
+        canvas.rotate(45);
+
+        paint.setColor(Color.WHITE);
+        canvas.drawRect(0, -10, 7.5f, 10, paint);
+
+        int sourceColor;
+        switch (loadedFrom) {
+            case Loader.LoaderEmitter.LOADED_FROM_CACHE:
+                sourceColor = Color.CYAN;
+                break;
+            case Loader.LoaderEmitter.LOADED_FROM_CONDITIONAL_CACHE:
+                sourceColor = Color.YELLOW;
+                break;
+            case Loader.LoaderEmitter.LOADED_FROM_MEMORY:
+                sourceColor = Color.GREEN;
+                break;
+            default:
+                sourceColor = Color.RED;
+                break;
+        }
+
+        paint.setColor(sourceColor);
+        canvas.drawRect(0, -9, 6.5f, 9, paint);
+
+        canvas.restore();
+    }
+
+    @Override
+    public void setAlpha(int alpha) {
+       paint.setAlpha(alpha);
+    }
+
+    @Override
+    public void setColorFilter(ColorFilter cf) {
+        paint.setColorFilter(cf);
+    }
+
+    @Override
+    public int getOpacity() {
+        return (info == null || info.bitmaps == null || info.bitmaps[0].hasAlpha() || paint.getAlpha() < 255) ?
+                PixelFormat.TRANSLUCENT : PixelFormat.OPAQUE;
+    }
+
+    static IonDrawable getOrCreateIonDrawable(ImageView imageView) {
+        Drawable current = imageView.getDrawable();
+        IonDrawable ret;
+        if (current == null || !(current instanceof IonDrawable))
+            ret = new IonDrawable(imageView.getResources(), imageView);
+        else
+            ret = (IonDrawable)current;
+        // invalidate self doesn't seem to trigger the dimension check to be called by imageview.
+        // are drawable dimensions supposed to be immutable?
+        imageView.setImageDrawable(null);
+        return ret;
+    }
+}
\ No newline at end of file
diff --git a/src/com/koushikdutta/ion/IonLog.java b/src/com/koushikdutta/ion/IonLog.java
new file mode 100644
index 00000000..3b70adba
--- /dev/null
+++ b/src/com/koushikdutta/ion/IonLog.java
@@ -0,0 +1,44 @@
+package com.koushikdutta.ion;
+
+import android.util.Log;
+
+/**
+ * Created by koush on 5/21/13.
+ */
+class IonLog {
+    public static final String LOGTAG = "ION";
+    public static boolean debug = true;
+    public static void d(String message, Exception e) {
+        if (debug)
+            Log.d(LOGTAG, message, e);
+    }
+
+    public static void e(String message, Exception e) {
+        Log.e(LOGTAG, message, e);
+    }
+
+    public static void i(String message, Exception e) {
+        Log.i(LOGTAG, message, e);
+    }
+
+    public static void w(String message, Exception e) {
+        Log.w(LOGTAG, message, e);
+    }
+
+    public static void d(String message) {
+        if (debug)
+            Log.d(LOGTAG, message);
+    }
+
+    public static void e(String message) {
+        Log.e(LOGTAG, message);
+    }
+
+    public static void i(String message) {
+        Log.i(LOGTAG, message);
+    }
+
+    public static void w(String message) {
+        Log.w(LOGTAG, message);
+    }
+}
diff --git a/src/com/koushikdutta/ion/IonRequestBuilder.java b/src/com/koushikdutta/ion/IonRequestBuilder.java
new file mode 100644
index 00000000..e100e901
--- /dev/null
+++ b/src/com/koushikdutta/ion/IonRequestBuilder.java
@@ -0,0 +1,928 @@
+package com.koushikdutta.ion;
+
+import android.app.ProgressDialog;
+import android.graphics.Bitmap;
+import android.net.Uri;
+import android.os.Handler;
+import android.os.Looper;
+import android.text.TextUtils;
+import android.util.Base64;
+import android.util.Log;
+import android.widget.ImageView;
+import android.widget.ProgressBar;
+
+import com.google.gson.JsonArray;
+import com.google.gson.JsonObject;
+import com.google.gson.reflect.TypeToken;
+import com.koushikdutta.async.AsyncServer;
+import com.koushikdutta.async.ByteBufferList;
+import com.koushikdutta.async.DataEmitter;
+import com.koushikdutta.async.DataSink;
+import com.koushikdutta.async.DataTrackingEmitter;
+import com.koushikdutta.async.DataTrackingEmitter.DataTracker;
+import com.koushikdutta.async.FilteredDataEmitter;
+import com.koushikdutta.async.Util;
+import com.koushikdutta.async.callback.CompletedCallback;
+import com.koushikdutta.async.future.Future;
+import com.koushikdutta.async.future.FutureCallback;
+import com.koushikdutta.async.future.SimpleFuture;
+import com.koushikdutta.async.future.TransformFuture;
+import com.koushikdutta.async.http.AsyncHttpGet;
+import com.koushikdutta.async.http.AsyncHttpPost;
+import com.koushikdutta.async.http.AsyncHttpRequest;
+import com.koushikdutta.async.http.Multimap;
+import com.koushikdutta.async.http.body.AsyncHttpRequestBody;
+import com.koushikdutta.async.http.body.DocumentBody;
+import com.koushikdutta.async.http.body.FileBody;
+import com.koushikdutta.async.http.body.FilePart;
+import com.koushikdutta.async.http.body.MultipartFormDataBody;
+import com.koushikdutta.async.http.body.StreamBody;
+import com.koushikdutta.async.http.body.StringBody;
+import com.koushikdutta.async.http.body.UrlEncodedFormBody;
+import com.koushikdutta.async.http.libcore.RawHeaders;
+import com.koushikdutta.async.http.server.AsyncHttpServer;
+import com.koushikdutta.async.parser.AsyncParser;
+import com.koushikdutta.async.parser.ByteBufferListParser;
+import com.koushikdutta.async.parser.DocumentParser;
+import com.koushikdutta.async.parser.StringParser;
+import com.koushikdutta.async.stream.FileDataSink;
+import com.koushikdutta.async.stream.OutputStreamDataSink;
+import com.koushikdutta.ion.Loader.LoaderEmitter;
+import com.koushikdutta.ion.bitmap.BitmapInfo;
+import com.koushikdutta.ion.builder.Builders;
+import com.koushikdutta.ion.builder.FutureBuilder;
+import com.koushikdutta.ion.builder.LoadBuilder;
+import com.koushikdutta.ion.future.ResponseFuture;
+import com.koushikdutta.ion.gson.GsonBody;
+import com.koushikdutta.ion.gson.GsonParser;
+import com.koushikdutta.ion.gson.GsonSerializer;
+import com.koushikdutta.ion.gson.PojoBody;
+
+import org.apache.http.NameValuePair;
+import org.w3c.dom.Document;
+
+import java.io.ByteArrayInputStream;
+import java.io.File;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.lang.ref.WeakReference;
+import java.net.URI;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Created by koush on 5/21/13.
+ */
+class IonRequestBuilder implements Builders.Any.B, Builders.Any.F, Builders.Any.M, Builders.Any.U, LoadBuilder<Builders.Any.B> {
+    Ion ion;
+    ContextReference contextReference;
+    Handler handler = Ion.mainHandler;
+    String method = AsyncHttpGet.METHOD;
+    String uri;
+
+    public IonRequestBuilder(ContextReference contextReference, Ion ion) {
+        String alive = contextReference.isAlive();
+        if (null != alive)
+            Log.w("Ion", "Building request with dead context: " + alive);
+        this.ion = ion;
+        this.contextReference = contextReference;
+    }
+
+    @Override
+    public IonRequestBuilder load(String url) {
+        return loadInternal(AsyncHttpGet.METHOD, url);
+    }
+
+    private IonRequestBuilder loadInternal(String method, String url) {
+        this.method = method;
+        if (!TextUtils.isEmpty(url) && url.startsWith("/"))
+            url = new File(url).toURI().toString();
+        this.uri = url;
+        return this;
+    }
+
+    boolean methodWasSet;
+    @Override
+    public IonRequestBuilder load(String method, String url) {
+        methodWasSet = true;
+        return loadInternal(method, url);
+    }
+
+    RawHeaders headers;
+    private RawHeaders getHeaders() {
+        if (headers == null) {
+            headers = new RawHeaders();
+            AsyncHttpRequest.setDefaultHeaders(headers, uri == null ? null : URI.create(uri));
+        }
+        return headers;
+    }
+
+    @Override
+    public IonRequestBuilder userAgent(String userAgent) {
+        if (TextUtils.isEmpty(userAgent))
+            return this;
+        return setHeader("User-Agent", userAgent);
+    }
+
+    @Override
+    public IonRequestBuilder setHeader(String name, String value) {
+        if (value == null)
+            getHeaders().removeAll(name);
+        else
+            getHeaders().set(name, value);
+        return this;
+    }
+
+    @Override
+    public IonRequestBuilder addHeader(String name, String value) {
+        if (value != null)
+            getHeaders().add(name, value);
+        return this;
+    }
+
+    @Override
+    public IonRequestBuilder addHeaders(Map<String, List<String>> params) {
+        RawHeaders headers = getHeaders();
+        for (Map.Entry<String, List<String>> entry: params.entrySet()) {
+            headers.addAll(entry.getKey(), entry.getValue());
+        }
+        return this;
+    }
+
+    boolean noCache;
+    @Override
+    public Builders.Any.B noCache() {
+        noCache = true;
+        return setHeader("Cache-Control", "no-cache");
+    }
+
+    Multimap query;
+    @Override
+    public IonRequestBuilder addQuery(String name, String value) {
+        if (value == null)
+            return this;
+        if (query == null)
+            query = new Multimap();
+        query.add(name, value);
+        return this;
+    }
+
+    @Override
+    public IonRequestBuilder addQueries(Map<String, List<String>> params) {
+       if (query == null)
+          query = new Multimap();
+       query.putAll(params);
+       return this;
+    }
+
+    int timeoutMilliseconds = AsyncHttpRequest.DEFAULT_TIMEOUT;
+    @Override
+    public IonRequestBuilder setTimeout(int timeoutMilliseconds) {
+        this.timeoutMilliseconds = timeoutMilliseconds;
+        return this;
+    }
+
+    @Override
+    public IonRequestBuilder setHandler(Handler handler) {
+        this.handler = handler;
+        return this;
+    }
+
+    AsyncHttpRequestBody body;
+    private <T> IonRequestBuilder setBody(AsyncHttpRequestBody<T> body) {
+        if (!methodWasSet)
+            method = AsyncHttpPost.METHOD;
+        this.body = body;
+        return this;
+    }
+
+    @Override
+    public IonRequestBuilder setJsonObjectBody(JsonObject jsonObject) {
+        return setBody(new GsonBody<JsonObject>(ion.configure().getGson(), jsonObject));
+    }
+
+    @Override
+    public IonRequestBuilder setJsonArrayBody(JsonArray jsonArray) {
+        return setBody(new GsonBody<JsonArray>(ion.configure().getGson(), jsonArray));
+    }
+
+    @Override
+    public IonRequestBuilder setStringBody(String string) {
+        return setBody(new StringBody(string));
+    }
+
+    boolean followRedirect = true;
+    @Override
+    public IonRequestBuilder followRedirect(boolean follow) {
+        followRedirect = follow;
+        return this;
+    }
+
+    private <T> void postExecute(final EmitterTransform<T> future, final Exception ex, final T value) {
+        final Runnable runner = new Runnable() {
+            @Override
+            public void run() {
+                // check if the context is still alive...
+                String deadReason = contextReference.isAlive();
+                if (deadReason != null) {
+                    future.initialRequest.logd("context has died: " + deadReason);
+                    future.cancelSilently();
+                    return;
+                }
+
+                // unless we're invoked onto the handler/main/service thread, there's no frakking way to avoid a
+                // race condition where the service or activity dies before this callback is invoked.
+                if (ex != null)
+                    future.setComplete(ex);
+                else
+                    future.setComplete(value);
+            }
+        };
+
+        if (handler == null)
+            ion.httpClient.getServer().post(runner);
+        else
+            AsyncServer.post(handler, runner);
+    }
+
+    private URI prepareURI() {
+        URI uri;
+        try {
+            if (query != null) {
+                Uri.Builder builder = Uri.parse(this.uri).buildUpon();
+                for (String key: query.keySet()) {
+                    for (String value: query.get(key)) {
+                        builder = builder.appendQueryParameter(key, value);
+                    }
+                }
+                uri = URI.create(builder.toString());
+            }
+            else {
+                uri = URI.create(this.uri);
+            }
+        }
+        catch (Exception e) {
+            uri = null;
+        }
+        if (uri == null || uri.getScheme() == null)
+            return null;
+
+        return uri;
+    }
+
+    private AsyncHttpRequest prepareRequest(URI uri, AsyncHttpRequestBody wrappedBody) {
+        AsyncHttpRequest request = ion.configure().getAsyncHttpRequestFactory().createAsyncHttpRequest(uri, method, headers);
+        request.setFollowRedirect(followRedirect);
+        request.setBody(wrappedBody);
+        request.setLogging(ion.logtag, ion.logLevel);
+        if (logTag != null)
+            request.setLogging(logTag, logLevel);
+        request.enableProxy(proxyHost, proxyPort);
+        request.setTimeout(timeoutMilliseconds);
+        request.logd("preparing request");
+        return request;
+    }
+
+    static interface LoadRequestCallback {
+        boolean loadRequest(AsyncHttpRequest request);
+    }
+
+    LoadRequestCallback loadRequestCallback;
+
+    private <T> void getLoaderEmitter(final EmitterTransform<T> ret) {
+        URI uri = prepareURI();
+        if (uri == null) {
+            ret.setComplete(new Exception("Invalid URI"));
+            return;
+        }
+
+        AsyncHttpRequestBody wrappedBody = body;
+        if (uploadProgressHandler != null || uploadProgressBar != null || uploadProgress != null || uploadProgressDialog != null) {
+            wrappedBody = new RequestBodyUploadObserver(body, new ProgressCallback() {
+                @Override
+                public void onProgress(final int downloaded, final int total) {
+                    assert Thread.currentThread() != Looper.getMainLooper().getThread();
+
+                    final int percent = (int)((float)downloaded / total * 100f);
+
+                    if (uploadProgressBar != null)
+                        uploadProgressBar.setProgress(percent);
+
+                    if (uploadProgressDialog != null)
+                        uploadProgressDialog.setProgress(percent);
+
+                    if (uploadProgress != null)
+                        uploadProgress.onProgress(downloaded, total);
+
+                    if (uploadProgressHandler != null) {
+                        AsyncServer.post(Ion.mainHandler, new Runnable() {
+                            @Override
+                            public void run() {
+                                if (ret.isCancelled() || ret.isDone())
+                                    return;
+                                uploadProgressHandler.onProgress(downloaded, total);
+                            }
+                        });
+                    }
+                }
+            });
+        }
+
+        AsyncHttpRequest request = prepareRequest(uri, wrappedBody);
+        ret.initialRequest = request;
+        resolveAndLoadRequest(request, ret);
+    }
+
+    <T> void resolveAndLoadRequest(final AsyncHttpRequest request, final EmitterTransform<T> ret) {
+        Future<AsyncHttpRequest> resolved = resolveRequest(request, ret);
+        if (resolved != null) {
+            resolved.setCallback(new FutureCallback<AsyncHttpRequest>() {
+                @Override
+                public void onCompleted(Exception e, final AsyncHttpRequest result) {
+                    if (e != null) {
+                        ret.setComplete(e);
+                        return;
+                    }
+                    ret.finalRequest = result;
+                    resolveAndLoadRequest(result, ret);
+                }
+            });
+            return;
+        }
+        if (Looper.getMainLooper().getThread() != Thread.currentThread()) {
+            AsyncServer.post(Ion.mainHandler, new Runnable() {
+                @Override
+                public void run() {
+                    invokeLoadRequest(request, ret);
+                }
+            });
+            return;
+        }
+        invokeLoadRequest(request, ret);
+    }
+
+    <T> void invokeLoadRequest(final AsyncHttpRequest request, final EmitterTransform<T> ret) {
+        if (loadRequestCallback == null || loadRequestCallback.loadRequest(request))
+            loadRequest(request, ret);
+    }
+
+    <T> void loadRequest(AsyncHttpRequest request, final EmitterTransform<T> ret) {
+        // now attempt to fetch it directly
+        for (Loader loader: ion.loaders) {
+            Future<DataEmitter> emitter = loader.load(ion, request, ret);
+            if (emitter != null) {
+                request.logi("Using loader: " + loader);
+                ret.setParent(emitter);
+                return;
+            }
+        }
+        ret.setComplete(new Exception("Unknown uri scheme"));
+    }
+
+    <T> Future<AsyncHttpRequest> resolveRequest(AsyncHttpRequest request, final EmitterTransform<T> ret) {
+        // first attempt to resolve the url
+        for (Loader loader: ion.loaders) {
+            Future<AsyncHttpRequest> resolved = loader.resolve(contextReference.getContext(), ion, request);
+            if (resolved != null)
+                return resolved;
+
+        }
+        return null;
+    }
+
+    // transforms a LoaderEmitter, which is a DataEmitter and all associated properties about the data source
+    // into the final result.
+    class EmitterTransform<T> extends TransformFuture<T, LoaderEmitter> implements ResponseFuture<T> {
+        AsyncHttpRequest initialRequest;
+        AsyncHttpRequest finalRequest;
+        int loadedFrom;
+        Runnable cancelCallback;
+        RawHeaders headers;
+        DataEmitter emitter;
+
+        @Override
+        public Future<Response<T>> withResponse() {
+            final SimpleFuture<Response<T>> ret = new SimpleFuture<Response<T>>();
+            setCallback(new FutureCallback<T>() {
+                @Override
+                public void onCompleted(Exception e, T result) {
+                    if (emitter != null) {
+                        Response<T> response = new Response<T>();
+                        response.headers = headers;
+                        response.request = finalRequest;
+                        response.result = result;
+                        response.exception = e;
+                        ret.setComplete(response);
+                        return;
+                    }
+                    ret.setComplete(e, null);
+                }
+            });
+            ret.setParent(this);
+            return ret;
+        }
+
+        public int loadedFrom() {
+            return loadedFrom;
+        }
+
+        public EmitterTransform(Runnable cancelCallback) {
+            this.cancelCallback = cancelCallback;
+            ion.addFutureInFlight(this, contextReference.getContext());
+            if (groups == null)
+                return;
+            for (WeakReference<Object> ref: groups) {
+                Object group = ref.get();
+                if (group != null)
+                    ion.addFutureInFlight(this, group);
+            }
+        }
+
+        @Override
+        protected void cancelCleanup() {
+            super.cancelCleanup();
+            if (emitter != null)
+                emitter.close();
+            if (cancelCallback != null)
+                cancelCallback.run();
+        }
+
+        @Override
+        protected void error(Exception e) {
+            // don't call superclass which calls setComplete... get onto handler thread.
+            postExecute(this, e, null);
+        }
+
+        @Override
+        protected void transform(LoaderEmitter emitter) throws Exception {
+            this.emitter = emitter.getDataEmitter();
+            this.loadedFrom = emitter.loadedFrom();
+            this.headers = emitter.getHeaders();
+            this.finalRequest = emitter.getRequest();
+
+            if (headersCallback != null) {
+                final RawHeaders headers = emitter.getHeaders();
+                // what do we do on loaders that don't have headers? files, content://, etc.
+                AsyncServer.post(handler, new Runnable() {
+                    @Override
+                    public void run() {
+                        headersCallback.onHeaders(headers);
+                    }
+                });
+            }
+
+            // hook up data progress callbacks
+            final int total = emitter.length();
+            DataTrackingEmitter tracker;
+            if (!(emitter instanceof DataTrackingEmitter)) {
+                tracker = new FilteredDataEmitter();
+                tracker.setDataEmitter(this.emitter);
+            }
+            else {
+                tracker = (DataTrackingEmitter)this.emitter;
+            }
+            this.emitter = tracker;
+            tracker.setDataTracker(new DataTracker() {
+                int lastPercent;
+                @Override
+                public void onData(final int totalBytesRead) {
+                    assert Thread.currentThread() != Looper.getMainLooper().getThread();
+                    // if the requesting context dies during the transfer... cancel
+                    String deadReason = contextReference.isAlive();
+                    if (deadReason != null) {
+                        initialRequest.logd("context has died, cancelling");
+                        cancelSilently();
+                        return;
+                    }
+
+                    final int percent = (int)((float)totalBytesRead / total * 100f);
+
+                    if ((progressBar != null || progressDialog != null) && percent != lastPercent) {
+                        AsyncServer.post(Ion.mainHandler, new Runnable() {
+                            @Override
+                            public void run() {
+                                if (progressBar != null) {
+                                    ProgressBar bar = progressBar.get();
+                                    if (bar != null)
+                                        bar.setProgress(percent);
+                                }
+                                if (progressDialog != null) {
+                                    ProgressDialog dlg = progressDialog.get();
+                                    if (dlg != null)
+                                        dlg.setProgress(percent);
+                                }
+                            }
+                        });
+                    }
+                    lastPercent = percent;
+
+                    if (progress != null)
+                        progress.onProgress(totalBytesRead, total);
+
+                    if (progressHandler != null) {
+                        AsyncServer.post(Ion.mainHandler, new Runnable() {
+                            @Override
+                            public void run() {
+                                if (isCancelled() || isDone())
+                                    return;
+                                progressHandler.onProgress(totalBytesRead, total);
+                            }
+                        });
+                    }
+                }
+            });
+        }
+    }
+
+    @Override
+    public IonRequestBuilder progressBar(ProgressBar progressBar) {
+        this.progressBar = new WeakReference<ProgressBar>(progressBar);
+        return this;
+    }
+
+    @Override
+    public IonRequestBuilder progressDialog(ProgressDialog progressDialog) {
+        this.progressDialog = new WeakReference<ProgressDialog>(progressDialog);
+        return this;
+    }
+
+    WeakReference<ProgressBar> progressBar;
+    WeakReference<ProgressDialog> progressDialog;
+
+    ProgressCallback progress;
+    @Override
+    public IonRequestBuilder progress(ProgressCallback callback) {
+        progress = callback;
+        return this;
+    }
+
+    ProgressCallback progressHandler;
+    @Override
+    public IonRequestBuilder progressHandler(ProgressCallback callback) {
+        progressHandler = callback;
+        return this;
+    }
+
+    <T> EmitterTransform<T> execute(final DataSink sink, final boolean close, final T result) {
+        return execute(sink, close, result, null);
+    }
+
+
+    <T> EmitterTransform<T> execute(final DataSink sink, final boolean close, final T result, final Runnable cancel) {
+        EmitterTransform<T> ret = new EmitterTransform<T>(cancel) {
+            @Override
+            protected void cleanup() {
+                super.cleanup();
+                if (close)
+                    sink.close();
+            }
+
+            EmitterTransform<T> self = this;
+            @Override
+            protected void transform(LoaderEmitter emitter) throws Exception {
+                super.transform(emitter);
+                Util.pump(this.emitter, sink, new CompletedCallback() {
+                    @Override
+                    public void onCompleted(Exception ex) {
+                        postExecute(self, ex, result);
+                    }
+                });
+            }
+        };
+        getLoaderEmitter(ret);
+        return ret;
+    }
+
+    <T> EmitterTransform<T> execute(final AsyncParser<T> parser) {
+        return execute(parser, null);
+    }
+
+    <T> EmitterTransform<T> execute(final AsyncParser<T> parser, Runnable cancel) {
+        assert parser != null;
+        EmitterTransform<T> ret = new EmitterTransform<T>(cancel) {
+            EmitterTransform<T> self = this;
+            @Override
+            protected void transform(LoaderEmitter emitter) throws Exception {
+                super.transform(emitter);
+                parser.parse(this.emitter).setCallback(new FutureCallback<T>() {
+                    @Override
+                    public void onCompleted(Exception e, T result) {
+                        postExecute(self, e, result);
+                    }
+                });
+            }
+        };
+        getLoaderEmitter(ret);
+        return ret;
+    }
+
+    Future<InputStream> execute() {
+        URI uri = prepareURI();
+        if (uri == null)
+            return null;
+
+        AsyncHttpRequest request = prepareRequest(uri, null);
+
+        for (Loader loader: ion.loaders) {
+            Future<InputStream> ret = loader.load(ion, request);
+            if (ret != null)
+                return ret;
+        }
+        return null;
+    }
+
+    @Override
+    public ResponseFuture<JsonObject> asJsonObject() {
+        return execute(new GsonParser<JsonObject>());
+    }
+
+    @Override
+    public ResponseFuture<JsonArray> asJsonArray() {
+        return execute(new GsonParser<JsonArray>());
+    }
+
+    @Override
+    public ResponseFuture<String> asString() {
+        return execute(new StringParser());
+    }
+
+    @Override
+    public ResponseFuture<byte[]> asByteArray() {
+        return execute(new AsyncParser<byte[]>() {
+            @Override
+            public Future<byte[]> parse(DataEmitter emitter) {
+                return new ByteBufferListParser().parse(emitter)
+                .then(new TransformFuture<byte[], ByteBufferList>() {
+                    @Override
+                    protected void transform(ByteBufferList result) throws Exception {
+                        setComplete(result.getAllByteArray());
+                    }
+                });
+            }
+
+            @Override
+            public void write(DataSink sink, byte[] value, CompletedCallback completed) {
+                new ByteBufferListParser().write(sink, new ByteBufferList(value), completed);
+            }
+        });
+    }
+
+    @Override
+    public ResponseFuture<InputStream> asInputStream() {
+        return execute(new InputStreamParser());
+    }
+
+    @Override
+    public <T> ResponseFuture<T> as(AsyncParser<T> parser) {
+        return execute(parser);
+    }
+
+    @Override
+    public <F extends OutputStream> ResponseFuture<F> write(F outputStream, boolean close) {
+        return execute(new OutputStreamDataSink(ion.getServer(), outputStream), close, outputStream);
+    }
+
+    @Override
+    public <F extends OutputStream> ResponseFuture<F> write(F outputStream) {
+        return execute(new OutputStreamDataSink(ion.getServer(), outputStream), true, outputStream);
+    }
+
+    @Override
+    public EmitterTransform<File> write(final File file) {
+        return execute(new FileDataSink(ion.getServer(), file), true, file, new Runnable() {
+            @Override
+            public void run() {
+                file.delete();
+            }
+        });
+    }
+
+    Multimap bodyParameters;
+    @Override
+    public IonRequestBuilder setBodyParameter(String name, String value) {
+        if (bodyParameters == null) {
+            bodyParameters = new Multimap();
+            setBody(new UrlEncodedFormBody(bodyParameters));
+        }
+        if (value != null)
+            bodyParameters.add(name, value);
+        return this;
+    }
+
+    public IonRequestBuilder setBodyParameters(Map<String, List<String>> params) {
+       if (bodyParameters == null) {
+           bodyParameters = new Multimap();
+           setBody(new UrlEncodedFormBody(bodyParameters));
+       }
+       bodyParameters.putAll(params);
+       return this;
+    }
+
+    MultipartFormDataBody multipartBody;
+    @Override
+    public IonRequestBuilder setMultipartFile(String name, File file) {
+        return setMultipartFile(name, null, file);
+    }
+
+    @Override
+    public IonRequestBuilder setMultipartFile(String name, String contentType, File file) {
+        if (multipartBody == null) {
+            multipartBody = new MultipartFormDataBody();
+            setBody(multipartBody);
+        }
+
+        FilePart part = new FilePart(name, file);
+
+        if (contentType == null)
+            contentType = AsyncHttpServer.tryGetContentType(file.getAbsolutePath());
+
+        if (contentType != null)
+            part.setContentType(contentType);
+
+        multipartBody.addPart(part);
+        return this;
+    }
+
+    @Override
+    public IonRequestBuilder setMultipartParameter(String name, String value) {
+        if (multipartBody == null) {
+            multipartBody = new MultipartFormDataBody();
+            setBody(multipartBody);
+        }
+        if (value != null)
+            multipartBody.addStringPart(name, value);
+        return this;
+    }
+
+    @Override
+    public IonRequestBuilder setMultipartParameters(Map<String, List<String>> params) {
+        for (String key: params.keySet()) {
+            for (String value: params.get(key)) {
+                if (value != null)
+                    setMultipartParameter(key, value);
+            }
+        }
+        return this;
+    }
+
+    @Override
+    public IonBitmapRequestBuilder withBitmap() {
+        return new IonBitmapRequestBuilder(this);
+    }
+
+    @Override
+    public Future<ImageView> intoImageView(ImageView imageView) {
+        return new IonBitmapRequestBuilder(this).intoImageView(imageView);
+    }
+
+    @Override
+    public IonRequestBuilder load(File file) {
+        loadInternal(null, file.toURI().toString());
+        return this;
+    }
+
+    @Override
+    public BitmapInfo asCachedBitmap() {
+        return new IonBitmapRequestBuilder(this).asCachedBitmap();
+    }
+
+    @Override
+    public Future<Bitmap> asBitmap() {
+        return new IonBitmapRequestBuilder(this).asBitmap();
+    }
+
+    String logTag;
+    int logLevel;
+    @Override
+    public IonRequestBuilder setLogging(String tag, int level) {
+        logTag = tag;
+        logLevel = level;
+        return this;
+    }
+
+    @Override
+    public <T> ResponseFuture<T> as(Class<T> clazz) {
+        return execute(new GsonSerializer<T>(ion.configure().getGson(), clazz));
+    }
+
+    @Override
+    public <T> ResponseFuture<T> as(TypeToken<T> token) {
+        return execute(new GsonSerializer<T>(ion.configure().getGson(), token));
+    }
+
+    ArrayList<WeakReference<Object>> groups;
+    @Override
+    public FutureBuilder group(Object groupKey) {
+        if (groups == null)
+            groups = new ArrayList<WeakReference<Object>>();
+        groups.add(new WeakReference<Object>(groupKey));
+        return this;
+    }
+
+    String proxyHost;
+    int proxyPort;
+    @Override
+    public IonRequestBuilder proxy(String host, int port) {
+        proxyHost = host;
+        proxyPort = port;
+        return this;
+    }
+
+    @Override
+    public IonRequestBuilder setJsonObjectBody(Object object, TypeToken token) {
+        setBody(new PojoBody(ion.configure().getGson(), object, token));
+        return this;
+    }
+
+    @Override
+    public IonRequestBuilder setJsonObjectBody(Object object) {
+        setBody(new PojoBody(ion.configure().getGson(), object, null));
+        return this;
+    }
+
+    @Override
+    public IonRequestBuilder basicAuthentication(String username, String password) {
+        return setHeader("Authorization", "Basic " + Base64.encodeToString(String.format("%s:%s", username, password).getBytes(), Base64.NO_WRAP));
+    }
+
+    ProgressCallback uploadProgress;
+    @Override
+    public Builders.Any.B uploadProgress(ProgressCallback callback) {
+        uploadProgress = callback;
+        return this;
+    }
+
+    ProgressBar uploadProgressBar;
+    @Override
+    public Builders.Any.B uploadProgressBar(ProgressBar progressBar) {
+        uploadProgressBar = progressBar;
+        return this;
+    }
+
+    ProgressDialog uploadProgressDialog;
+    @Override
+    public Builders.Any.B uploadProgressDialog(ProgressDialog progressDialog) {
+        uploadProgressDialog = progressDialog;
+        return this;
+    }
+
+    ProgressCallback uploadProgressHandler;
+    @Override
+    public Builders.Any.B uploadProgressHandler(ProgressCallback callback) {
+        uploadProgressHandler = callback;
+        return this;
+    }
+
+    HeadersCallback headersCallback;
+    @Override
+    public Builders.Any.B onHeaders(HeadersCallback callback) {
+        headersCallback = callback;
+        return this;
+    }
+
+    @Override
+    public Builders.Any.F setDocumentBody(Document document) {
+        setBody(new DocumentBody(document));
+        return this;
+    }
+
+    @Override
+    public ResponseFuture<Document> asDocument() {
+        return execute(new DocumentParser());
+    }
+
+    @Override
+    public Builders.Any.F setFileBody(File file) {
+        setBody(new FileBody(file));
+        return this;
+    }
+
+    @Override
+    public Builders.Any.F setByteArrayBody(byte[] bytes) {
+        if (bytes != null)
+            setBody(new StreamBody(new ByteArrayInputStream(bytes), bytes.length));
+        return this;
+    }
+
+    @Override
+    public Builders.Any.F setStreamBody(InputStream inputStream) {
+        setBody(new StreamBody(inputStream, -1));
+        return this;
+    }
+
+    @Override
+    public Builders.Any.F setStreamBody(InputStream inputStream, int length) {
+        setBody(new StreamBody(inputStream, length));
+        return this;
+    }
+
+    @Override
+    public Builders.Any.B setHeader(NameValuePair... header) {
+        RawHeaders headers = getHeaders();
+        for (NameValuePair h: header) {
+            headers.set(h.getName(), h.getValue());
+        }
+        return this;
+    }
+}
diff --git a/src/com/koushikdutta/ion/LoadBitmap.java b/src/com/koushikdutta/ion/LoadBitmap.java
new file mode 100644
index 00000000..44c65bff
--- /dev/null
+++ b/src/com/koushikdutta/ion/LoadBitmap.java
@@ -0,0 +1,111 @@
+package com.koushikdutta.ion;
+
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.Point;
+import android.os.Looper;
+import android.text.TextUtils;
+import android.util.Log;
+
+import com.koushikdutta.async.ByteBufferList;
+import com.koushikdutta.async.future.FutureCallback;
+import com.koushikdutta.ion.bitmap.BitmapInfo;
+import com.koushikdutta.ion.gif.GifAction;
+import com.koushikdutta.ion.gif.GifDecoder;
+
+import java.net.URI;
+import java.nio.ByteBuffer;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+
+class LoadBitmap extends LoadBitmapEmitter implements FutureCallback<ByteBufferList> {
+    int resizeWidth;
+    int resizeHeight;
+
+    public LoadBitmap(Ion ion, String urlKey, boolean put, int resizeWidth, int resizeHeight, boolean animateGif, IonRequestBuilder.EmitterTransform<ByteBufferList> emitterTransform) {
+        super(ion, urlKey, put, animateGif, emitterTransform);
+        this.resizeWidth = resizeWidth;
+        this.resizeHeight = resizeHeight;
+        this.animateGif = animateGif;
+        this.emitterTransform = emitterTransform;
+    }
+
+    @Override
+    public void onCompleted(Exception e, final ByteBufferList result) {
+        if (e != null) {
+            report(e, null);
+            return;
+        }
+
+        if (ion.bitmapsPending.tag(key) != this) {
+            result.recycle();
+            return;
+        }
+
+        Ion.getBitmapLoadExecutorService().execute(new Runnable() {
+            @Override
+            public void run() {
+                if (ion.bitmapsPending.tag(key) != LoadBitmap.this) {
+                    result.recycle();
+                    return;
+                }
+
+                ByteBuffer bb = result.getAll();
+                try {
+                    Bitmap[] bitmaps;
+                    int[] delays;
+                    BitmapFactory.Options options = ion.bitmapCache.prepareBitmapOptions(bb.array(), bb.arrayOffset() + bb.position(), bb.remaining(), resizeWidth, resizeHeight);
+                    if (options == null)
+                        throw new Exception("BitmapFactory.Options failed to load");
+                    final Point size = new Point(options.outWidth, options.outHeight);
+                    if (animateGif && TextUtils.equals("image/gif", options.outMimeType)) {
+                        GifDecoder decoder = new GifDecoder(bb.array(), bb.arrayOffset() + bb.position(), bb.remaining(), new GifAction() {
+                            @Override
+                            public boolean parseOk(boolean parseStatus, int frameIndex) {
+                                return animateGif;
+                            }
+                        });
+                        decoder.run();
+                        if (decoder.getFrameCount() == 0)
+                            throw new Exception("failed to load gif");
+                        bitmaps = new Bitmap[decoder.getFrameCount()];
+                        delays = decoder.getDelays();
+                        for (int i = 0; i < decoder.getFrameCount(); i++) {
+                            Bitmap bitmap = decoder.getFrameImage(i);
+                            if (bitmap == null)
+                                throw new Exception("failed to load gif frame");
+                            bitmaps[i] = bitmap;
+                        }
+                    }
+                    else {
+                        Bitmap bitmap = ion.bitmapCache.loadBitmap(bb.array(), bb.arrayOffset() + bb.position(), bb.remaining(), options);
+                        if (bitmap == null)
+                            throw new Exception("failed to load bitmap");
+                        bitmaps = new Bitmap[] { bitmap };
+                        delays = null;
+                    }
+
+                    BitmapInfo info = new BitmapInfo(key, options.outMimeType, bitmaps, size);
+                    info.delays = delays;
+                    if (emitterTransform != null)
+                        info.loadedFrom = emitterTransform.loadedFrom();
+                    else
+                        info.loadedFrom = Loader.LoaderEmitter.LOADED_FROM_CACHE;
+
+                    report(null, info);
+                }
+                catch (OutOfMemoryError e) {
+                    report(new Exception(e), null);
+                }
+                catch (Exception e) {
+                    report(e, null);
+                }
+                finally {
+                    ByteBufferList.reclaim(bb);
+                }
+            }
+        });
+    }
+}
+
+    
\ No newline at end of file
diff --git a/src/com/koushikdutta/ion/LoadBitmapBase.java b/src/com/koushikdutta/ion/LoadBitmapBase.java
new file mode 100644
index 00000000..c6397157
--- /dev/null
+++ b/src/com/koushikdutta/ion/LoadBitmapBase.java
@@ -0,0 +1,10 @@
+package com.koushikdutta.ion;
+
+/**
+ * Created by koush on 1/18/14.
+ */
+public class LoadBitmapBase extends BitmapCallback {
+    public LoadBitmapBase(Ion ion, String key, boolean put)  {
+        super(ion, key, put);
+    }
+}
diff --git a/src/com/koushikdutta/ion/LoadBitmapEmitter.java b/src/com/koushikdutta/ion/LoadBitmapEmitter.java
new file mode 100644
index 00000000..6f1888d9
--- /dev/null
+++ b/src/com/koushikdutta/ion/LoadBitmapEmitter.java
@@ -0,0 +1,12 @@
+package com.koushikdutta.ion;
+
+class LoadBitmapEmitter extends LoadBitmapBase {
+    IonRequestBuilder.EmitterTransform emitterTransform;
+    boolean animateGif;
+
+    public LoadBitmapEmitter(Ion ion, String urlKey, boolean put, boolean animateGif, IonRequestBuilder.EmitterTransform emitterTransform) {
+        super(ion, urlKey, put);
+        this.animateGif = animateGif;
+        this.emitterTransform = emitterTransform;
+    }
+}
\ No newline at end of file
diff --git a/src/com/koushikdutta/ion/LoadBitmapRegion.java b/src/com/koushikdutta/ion/LoadBitmapRegion.java
new file mode 100644
index 00000000..81bf6734
--- /dev/null
+++ b/src/com/koushikdutta/ion/LoadBitmapRegion.java
@@ -0,0 +1,33 @@
+package com.koushikdutta.ion;
+
+import android.graphics.Bitmap;
+import android.graphics.BitmapRegionDecoder;
+import android.graphics.Point;
+import android.graphics.Rect;
+
+import com.koushikdutta.ion.bitmap.BitmapInfo;
+
+/**
+ * Created by koush on 1/29/14.
+ */
+public class LoadBitmapRegion extends BitmapCallback {
+    public LoadBitmapRegion(final Ion ion, final String key, final BitmapRegionDecoder decoder, final Rect region, final int inSampleSize) {
+        super(ion, key, true);
+
+        Ion.getBitmapLoadExecutorService().execute(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    Bitmap bitmap = ion.bitmapCache.loadRegion(decoder, region, inSampleSize);
+                    if (bitmap == null)
+                        throw new Exception("failed to load bitmap region");
+                    BitmapInfo info = new BitmapInfo(key, null, new Bitmap[] { bitmap }, new Point(bitmap.getWidth(), bitmap.getHeight()));
+                    report(null, info);
+                }
+                catch (Exception e) {
+                    report(e, null);
+                }
+            }
+        });
+    }
+}
diff --git a/src/com/koushikdutta/ion/LoadDeepZoom.java b/src/com/koushikdutta/ion/LoadDeepZoom.java
new file mode 100644
index 00000000..4293d41e
--- /dev/null
+++ b/src/com/koushikdutta/ion/LoadDeepZoom.java
@@ -0,0 +1,105 @@
+package com.koushikdutta.ion;
+
+import android.annotation.TargetApi;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.BitmapRegionDecoder;
+import android.graphics.Point;
+import android.graphics.Rect;
+import android.os.Build;
+import android.text.TextUtils;
+
+import com.koushikdutta.async.future.FutureCallback;
+import com.koushikdutta.async.util.FileCache;
+import com.koushikdutta.async.util.StreamUtility;
+import com.koushikdutta.ion.bitmap.BitmapInfo;
+import com.koushikdutta.ion.gif.GifAction;
+import com.koushikdutta.ion.gif.GifDecoder;
+
+import java.io.File;
+import java.io.FileInputStream;
+
+/**
+ * Created by koush on 1/5/14.
+ */
+@TargetApi(Build.VERSION_CODES.GINGERBREAD_MR1)
+public class LoadDeepZoom extends LoadBitmapEmitter implements FutureCallback<File> {
+    FileCache fileCache;
+    public LoadDeepZoom(Ion ion, String urlKey, boolean animateGif, IonRequestBuilder.EmitterTransform<File> emitterTransform, FileCache fileCache) {
+        super(ion, urlKey, true, animateGif, emitterTransform);
+        this.fileCache = fileCache;
+    }
+
+    @Override
+    public void onCompleted(Exception e, final File tempFile) {
+        if (e != null) {
+            report(e, null);
+            return;
+        }
+
+        if (ion.bitmapsPending.tag(key) != this) {
+//            Log.d("IonBitmapLoader", "Bitmap load cancelled (no longer needed)");
+            return;
+        }
+
+        Ion.getBitmapLoadExecutorService().execute(new Runnable() {
+            @Override
+            public void run() {
+                FileInputStream fin = null;
+                try {
+                    fileCache.commitTempFiles(key, tempFile);
+                    File file = fileCache.getFile(key);
+                    BitmapFactory.Options options = ion.getBitmapCache().prepareBitmapOptions(file, 0, 0);
+                    if (options == null)
+                        throw new Exception("BitmapFactory.Options failed to load");
+                    final Point size = new Point(options.outWidth, options.outHeight);
+                    if (animateGif && TextUtils.equals("image/gif", options.outMimeType)) {
+                        fin = fileCache.get(key);
+                        GifDecoder decoder = new GifDecoder(fin, new GifAction() {
+                            @Override
+                            public boolean parseOk(boolean parseStatus, int frameIndex) {
+                                return animateGif;
+                            }
+                        });
+                        decoder.run();
+                        if (decoder.getFrameCount() == 0)
+                            throw new Exception("failed to load gif");
+                        Bitmap[] bitmaps = new Bitmap[decoder.getFrameCount()];
+                        int[] delays = decoder.getDelays();
+                        for (int i = 0; i < decoder.getFrameCount(); i++) {
+                            Bitmap bitmap = decoder.getFrameImage(i);
+                            if (bitmap == null)
+                                throw new Exception("failed to load gif frame");
+                            bitmaps[i] = bitmap;
+                        }
+                        BitmapInfo info = new BitmapInfo(key, options.outMimeType, bitmaps, size);
+                        info.delays = delays;
+                        if (emitterTransform != null)
+                            info.loadedFrom = emitterTransform.loadedFrom();
+                        else
+                            info.loadedFrom = Loader.LoaderEmitter.LOADED_FROM_CACHE;
+                        report(null, info);
+                        return;
+                    }
+
+                    BitmapRegionDecoder decoder = BitmapRegionDecoder.newInstance(file.toString(), false);
+                    Bitmap bitmap = decoder.decodeRegion(new Rect(0, 0, size.x, size.y), options);
+                    if (bitmap == null)
+                        throw new Exception("unable to load decoder");
+                    Bitmap[] bitmaps = new Bitmap[] { bitmap };
+
+                    BitmapInfo info = new BitmapInfo(key, options.outMimeType, bitmaps, size);
+                    info.decoder = decoder;
+                    info.decoderFile = file;
+                    info.loadedFrom = Loader.LoaderEmitter.LOADED_FROM_NETWORK;
+                    report(null, info);
+                } catch (Exception e) {
+                    report(e, null);
+                }
+                finally {
+                    StreamUtility.closeQuietly(fin);
+                }
+            }
+        });
+    }
+}
diff --git a/src/com/koushikdutta/ion/Loader.java b/src/com/koushikdutta/ion/Loader.java
new file mode 100644
index 00000000..000aebb3
--- /dev/null
+++ b/src/com/koushikdutta/ion/Loader.java
@@ -0,0 +1,92 @@
+package com.koushikdutta.ion;
+
+import android.content.Context;
+
+import com.koushikdutta.async.DataEmitter;
+import com.koushikdutta.async.future.Future;
+import com.koushikdutta.async.future.FutureCallback;
+import com.koushikdutta.async.http.AsyncHttpRequest;
+import com.koushikdutta.async.http.libcore.RawHeaders;
+import com.koushikdutta.ion.bitmap.BitmapInfo;
+
+import java.io.InputStream;
+
+/**
+ * Created by koush on 5/22/13.
+ */
+public interface Loader {
+    public static class LoaderEmitter {
+        public static final int LOADED_FROM_MEMORY = 0;
+        public static final int LOADED_FROM_CACHE = 1;
+        public static final int LOADED_FROM_CONDITIONAL_CACHE = 2;
+        public static final int LOADED_FROM_NETWORK = 3;
+
+        public LoaderEmitter(DataEmitter emitter, int length, int loadedFrom, RawHeaders headers, AsyncHttpRequest request) {
+            this.length = length;
+            this.emitter = emitter;
+            this.loadedFrom = loadedFrom;
+            this.headers = headers;
+            this.request = request;
+        }
+        DataEmitter emitter;
+        int length;
+        public DataEmitter getDataEmitter() {
+            return emitter;
+        }
+        public int length() {
+            return length;
+        }
+        int loadedFrom;
+        public int loadedFrom() {
+            return loadedFrom;
+        }
+        RawHeaders headers;
+        public RawHeaders getHeaders() {
+            return headers;
+        }
+        AsyncHttpRequest request;
+        public AsyncHttpRequest getRequest() {
+            return request;
+        }
+    }
+
+    /**
+     * returns a Future if this loader can handle a request as a stream.
+     * this implies that the stream is essentially non blocking...
+     * ie file or memory based.
+     * @param ion
+     * @param request
+     * @return
+     */
+    public Future<InputStream> load(Ion ion, AsyncHttpRequest request);
+
+    /**
+     * returns a Future if this loader can handle a request
+     * otherwise it returns null, and Ion continues to the next loader.
+     * @param ion
+     * @param request
+     * @param callback
+     * @return
+     */
+    public Future<DataEmitter> load(Ion ion, AsyncHttpRequest request, FutureCallback<LoaderEmitter> callback);
+
+    /**
+     * returns a future if the laoder can handle the request as a bitmap
+     * otherwise it returns null
+     * @param ion
+     * @param key
+     * @param uri
+     * @param resizeWidth
+     * @param resizeHeight
+     * @return
+     */
+    public Future<BitmapInfo> loadBitmap(Context context, Ion ion, String key, String uri, int resizeWidth, int resizeHeight, boolean animateGif);
+
+    /**
+     * Resolve a request into another request.
+     * @param ion
+     * @param request
+     * @return
+     */
+    public Future<AsyncHttpRequest> resolve(Context context, Ion ion, AsyncHttpRequest request);
+}
diff --git a/src/com/koushikdutta/ion/ProgressCallback.java b/src/com/koushikdutta/ion/ProgressCallback.java
new file mode 100644
index 00000000..bed62bf4
--- /dev/null
+++ b/src/com/koushikdutta/ion/ProgressCallback.java
@@ -0,0 +1,13 @@
+package com.koushikdutta.ion;
+
+/**
+ * Callback that is invoked on download progress
+ */
+public interface ProgressCallback {
+    /**
+     * onProgress is invoked periodically during a request download
+     * @param downloaded The number of bytes currently downloaded
+     * @param total The total number of bytes in this request, or -1 if unknown
+     */
+    void onProgress(int downloaded, int total);
+}
diff --git a/src/com/koushikdutta/ion/RequestBodyUploadObserver.java b/src/com/koushikdutta/ion/RequestBodyUploadObserver.java
new file mode 100644
index 00000000..f3498b0a
--- /dev/null
+++ b/src/com/koushikdutta/ion/RequestBodyUploadObserver.java
@@ -0,0 +1,114 @@
+package com.koushikdutta.ion;
+
+import com.koushikdutta.async.AsyncServer;
+import com.koushikdutta.async.ByteBufferList;
+import com.koushikdutta.async.DataEmitter;
+import com.koushikdutta.async.DataSink;
+import com.koushikdutta.async.callback.CompletedCallback;
+import com.koushikdutta.async.callback.WritableCallback;
+import com.koushikdutta.async.http.AsyncHttpRequest;
+import com.koushikdutta.async.http.body.AsyncHttpRequestBody;
+
+import java.nio.ByteBuffer;
+
+/**
+ * Created by koush on 6/13/13.
+ */
+class RequestBodyUploadObserver implements AsyncHttpRequestBody {
+    AsyncHttpRequestBody body;
+    ProgressCallback callback;
+    public RequestBodyUploadObserver(AsyncHttpRequestBody body, ProgressCallback callback) {
+        this.body = body;
+        this.callback = callback;
+    }
+
+    @Override
+    public void write(AsyncHttpRequest request, final DataSink sink, final CompletedCallback completed) {
+        final int length = body.length();
+        body.write(request, new DataSink() {
+            int totalWritten;
+            @Override
+            public void write(ByteBuffer bb) {
+                int start = bb.remaining();
+                sink.write(bb);
+                int wrote = start - bb.remaining();
+                totalWritten += wrote;
+                callback.onProgress(totalWritten, length);
+            }
+
+            @Override
+            public void write(ByteBufferList bb) {
+                int start = bb.remaining();
+                sink.write(bb);
+                int wrote = start - bb.remaining();
+                totalWritten += wrote;
+                callback.onProgress(totalWritten, length);
+            }
+
+            @Override
+            public void setWriteableCallback(WritableCallback handler) {
+                sink.setWriteableCallback(handler);
+            }
+
+            @Override
+            public WritableCallback getWriteableCallback() {
+                return sink.getWriteableCallback();
+            }
+
+            @Override
+            public boolean isOpen() {
+                return sink.isOpen();
+            }
+
+            @Override
+            public void close() {
+                sink.close();
+            }
+
+            @Override
+            public void end() {
+                sink.end();
+            }
+
+            @Override
+            public void setClosedCallback(CompletedCallback handler) {
+                sink.setClosedCallback(handler);
+            }
+
+            @Override
+            public CompletedCallback getClosedCallback() {
+                return sink.getClosedCallback();
+            }
+
+            @Override
+            public AsyncServer getServer() {
+                return sink.getServer();
+            }
+        }, completed);
+    }
+
+    @Override
+    public void parse(DataEmitter emitter, CompletedCallback completed) {
+        body.parse(emitter, completed);
+    }
+
+    @Override
+    public String getContentType() {
+        return body.getContentType();
+    }
+
+    @Override
+    public boolean readFullyOnRequest() {
+        return body.readFullyOnRequest();
+    }
+
+    @Override
+    public int length() {
+        return body.length();
+    }
+
+    @Override
+    public Object get() {
+        return body.get();
+    }
+}
diff --git a/src/com/koushikdutta/ion/Response.java b/src/com/koushikdutta/ion/Response.java
new file mode 100644
index 00000000..a7df64cc
--- /dev/null
+++ b/src/com/koushikdutta/ion/Response.java
@@ -0,0 +1,29 @@
+package com.koushikdutta.ion;
+
+import com.koushikdutta.async.http.AsyncHttpRequest;
+import com.koushikdutta.async.http.libcore.RawHeaders;
+
+/**
+ * Created by koush on 7/6/13.
+ */
+public class Response<T> {
+    T result;
+    public T getResult() {
+        return result;
+    }
+
+    Exception exception;
+    public Exception getException() {
+        return exception;
+    }
+
+    RawHeaders headers;
+    public RawHeaders getHeaders() {
+        return headers;
+    }
+
+    AsyncHttpRequest request;
+    public AsyncHttpRequest getRequest() {
+        return request;
+    }
+}
diff --git a/src/com/koushikdutta/ion/ScaleMode.java b/src/com/koushikdutta/ion/ScaleMode.java
new file mode 100644
index 00000000..077e7b96
--- /dev/null
+++ b/src/com/koushikdutta/ion/ScaleMode.java
@@ -0,0 +1,7 @@
+package com.koushikdutta.ion;
+
+enum ScaleMode {
+    FitXY,
+    CenterCrop,
+    CenterInside
+}
\ No newline at end of file
diff --git a/src/com/koushikdutta/ion/TransformBitmap.java b/src/com/koushikdutta/ion/TransformBitmap.java
new file mode 100644
index 00000000..2f449f24
--- /dev/null
+++ b/src/com/koushikdutta/ion/TransformBitmap.java
@@ -0,0 +1,134 @@
+package com.koushikdutta.ion;
+
+import android.graphics.Bitmap;
+import android.graphics.Point;
+
+import com.koushikdutta.async.future.FutureCallback;
+import com.koushikdutta.async.util.FileCache;
+import com.koushikdutta.ion.bitmap.BitmapInfo;
+import com.koushikdutta.ion.bitmap.Transform;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.util.ArrayList;
+
+class TransformBitmap extends BitmapCallback implements FutureCallback<BitmapInfo> {
+    ArrayList<Transform> transforms;
+
+    public static void getBitmapSnapshot(final Ion ion, final String transformKey) {
+        // don't do this if this is already loading
+        if (ion.bitmapsPending.tag(transformKey) != null)
+            return;
+        final BitmapCallback callback = new LoadBitmapBase(ion, transformKey, true);
+        Ion.getBitmapLoadExecutorService().execute(new Runnable() {
+            @Override
+            public void run() {
+                if (ion.bitmapsPending.tag(transformKey) != callback) {
+//                    Log.d("IonBitmapLoader", "Bitmap cache load cancelled (no longer needed)");
+                    return;
+                }
+
+                try {
+                    File file = ion.responseCache.getFileCache().getFile(transformKey);
+                    Bitmap bitmap = ion.getBitmapCache().loadBitmap(file, null);
+                    if (bitmap == null)
+                        throw new Exception("Bitmap failed to load");
+                    Point size = new Point(bitmap.getWidth(), bitmap.getHeight());
+                    BitmapInfo info = new BitmapInfo(transformKey, "image/jpeg", new Bitmap[] { bitmap }, size);
+                    info.loadedFrom =  Loader.LoaderEmitter.LOADED_FROM_CACHE;
+                    callback.report(null, info);
+                }
+                catch (OutOfMemoryError e) {
+                    callback.report(new Exception(e), null);
+                }
+                catch (Exception e) {
+                    callback.report(e, null);
+                    try {
+                        ion.responseCache.getFileCache().remove(transformKey);
+                    } catch (Exception ex) {
+                    }
+                }
+            }
+        });
+    }
+
+    String downloadKey;
+    public TransformBitmap(Ion ion, String transformKey, String downloadKey, ArrayList<Transform> transforms) {
+        super(ion, transformKey, true);
+        this.transforms = transforms;
+        this.downloadKey = downloadKey;
+    }
+
+    @Override
+    public void onCompleted(Exception e, final BitmapInfo result) {
+        if (e != null) {
+            report(e, null);
+            return;
+        }
+
+        if (ion.bitmapsPending.tag(key) != this) {
+//            Log.d("IonBitmapLoader", "Bitmap transform cancelled (no longer needed)");
+            return;
+        }
+
+        Ion.getBitmapLoadExecutorService().execute(new Runnable() {
+            @Override
+            public void run() {
+                if (ion.bitmapsPending.tag(key) != TransformBitmap.this) {
+//            Log.d("IonBitmapLoader", "Bitmap transform cancelled (no longer needed)");
+                    return;
+                }
+
+                BitmapInfo info;
+                try {
+                    Point size = null;
+                    Bitmap bitmaps[] = new Bitmap[result.bitmaps.length];
+                    for (int i = 0; i < result.bitmaps.length; i++) {
+                        bitmaps[i] = result.bitmaps[i];
+                        for (Transform transform : transforms) {
+                            Bitmap bitmap = transform.transform(bitmaps[i]);
+                            if (bitmap == null)
+                                throw new Exception("failed to transform bitmap");
+                            bitmaps[i] = bitmap;
+                            if (size == null)
+                                size = new Point(bitmap.getWidth(), bitmap.getHeight());
+                        }
+                    }
+                    info = new BitmapInfo(key, result.mimeType, bitmaps, size);
+                    info.delays = result.delays;
+                    info.loadedFrom = result.loadedFrom;
+                    report(null, info);
+                }
+                catch (OutOfMemoryError e) {
+                    report(new Exception(e), null);
+                    return;
+                }
+                catch (Exception e) {
+                    report(e, null);
+                    return;
+                }
+                // the transformed bitmap was successfully load it, let's toss it into
+                // the disk lru cache.
+                // but don't persist gifs...
+                if (info.bitmaps.length > 1)
+                    return;
+                FileCache cache = ion.responseCache.getFileCache();
+                if (cache == null)
+                    return;
+                File tempFile = cache.getTempFile();
+                try {
+                    FileOutputStream out = new FileOutputStream(tempFile);
+                    Bitmap.CompressFormat format = info.bitmaps[0].hasAlpha() ? Bitmap.CompressFormat.PNG : Bitmap.CompressFormat.JPEG;
+                    info.bitmaps[0].compress(format, 100, out);
+                    out.close();
+                    cache.commitTempFiles(key, tempFile);
+                }
+                catch (Exception ex) {
+                }
+                finally {
+                    tempFile.delete();
+                }
+            }
+        });
+    }
+}
\ No newline at end of file
diff --git a/src/com/koushikdutta/ion/bitmap/BitmapInfo.java b/src/com/koushikdutta/ion/bitmap/BitmapInfo.java
new file mode 100644
index 00000000..3db88e4c
--- /dev/null
+++ b/src/com/koushikdutta/ion/bitmap/BitmapInfo.java
@@ -0,0 +1,38 @@
+package com.koushikdutta.ion.bitmap;
+
+import android.graphics.Bitmap;
+import android.graphics.BitmapRegionDecoder;
+import android.graphics.Point;
+
+import java.io.File;
+import java.lang.ref.WeakReference;
+
+/**
+ * Created by koush on 6/12/13.
+ */
+public class BitmapInfo {
+    public BitmapInfo(String key, String mimeType, Bitmap[] bitmaps, Point originalSize) {
+        this.originalSize = originalSize;
+        this.bitmaps = bitmaps;
+        this.key = key;
+        this.mimeType = mimeType;
+    }
+
+    final public Point originalSize;
+    public long loadTime = System.currentTimeMillis();
+    public long drawTime;
+    final public String key;
+    public int loadedFrom;
+    final public Bitmap[] bitmaps;
+    public int[] delays;
+    public Exception exception;
+    public BitmapRegionDecoder decoder;
+    public File decoderFile;
+    public final String mimeType;
+
+    public int sizeOf() {
+        if (bitmaps == null)
+            return 0;
+        return bitmaps[0].getRowBytes() * bitmaps[0].getHeight() * bitmaps.length;
+    }
+}
diff --git a/src/com/koushikdutta/ion/bitmap/Exif.java b/src/com/koushikdutta/ion/bitmap/Exif.java
new file mode 100644
index 00000000..1b819c61
--- /dev/null
+++ b/src/com/koushikdutta/ion/bitmap/Exif.java
@@ -0,0 +1,137 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.koushikdutta.ion.bitmap;
+
+import android.util.Log;
+
+public class Exif {
+    private static final String TAG = "CameraExif";
+
+    // Returns the degrees in clockwise. Values are 0, 90, 180, or 270.
+    public static int getOrientation(byte[] jpeg, int offset, int size) {
+        if (jpeg == null) {
+            return 0;
+        }
+
+        int length = 0;
+        int last = offset + size;
+
+        // ISO/IEC 10918-1:1993(E)
+        while (offset + 3 < last && (jpeg[offset++] & 0xFF) == 0xFF) {
+            int marker = jpeg[offset] & 0xFF;
+
+            // Check if the marker is a padding.
+            if (marker == 0xFF) {
+                continue;
+            }
+            offset++;
+
+            // Check if the marker is SOI or TEM.
+            if (marker == 0xD8 || marker == 0x01) {
+                continue;
+            }
+            // Check if the marker is EOI or SOS.
+            if (marker == 0xD9 || marker == 0xDA) {
+                break;
+            }
+
+            // Get the length and check if it is reasonable.
+            length = pack(jpeg, offset, 2, false);
+            if (length < 2 || offset + length > last) {
+                Log.e(TAG, "Invalid length");
+                return 0;
+            }
+
+            // Break if the marker is EXIF in APP1.
+            if (marker == 0xE1 && length >= 8 &&
+            pack(jpeg, offset + 2, 4, false) == 0x45786966 &&
+            pack(jpeg, offset + 6, 2, false) == 0) {
+                offset += 8;
+                length -= 8;
+                break;
+            }
+
+            // Skip other markers.
+            offset += length;
+            length = 0;
+        }
+
+        // JEITA CP-3451 Exif Version 2.2
+        if (length > 8) {
+            // Identify the byte order.
+            int tag = pack(jpeg, offset, 4, false);
+            if (tag != 0x49492A00 && tag != 0x4D4D002A) {
+                Log.e(TAG, "Invalid byte order");
+                return 0;
+            }
+            boolean littleEndian = (tag == 0x49492A00);
+
+            // Get the offset and check if it is reasonable.
+            int count = pack(jpeg, offset + 4, 4, littleEndian) + 2;
+            if (count < 10 || count > length) {
+                Log.e(TAG, "Invalid offset");
+                return 0;
+            }
+            offset += count;
+            length -= count;
+
+            // Get the count and go through all the elements.
+            count = pack(jpeg, offset - 2, 2, littleEndian);
+            while (count-- > 0 && length >= 12) {
+                // Get the tag and check if it is orientation.
+                tag = pack(jpeg, offset, 2, littleEndian);
+                if (tag == 0x0112) {
+                    // We do not really care about type and count, do we?
+                    int orientation = pack(jpeg, offset + 8, 2, littleEndian);
+                    switch (orientation) {
+                        case 1:
+                            return 0;
+                        case 3:
+                            return 180;
+                        case 6:
+                            return 90;
+                        case 8:
+                            return 270;
+                    }
+                    Log.i(TAG, "Unsupported orientation");
+                    return 0;
+                }
+                offset += 12;
+                length -= 12;
+            }
+        }
+
+//        Log.i(TAG, "Orientation not found");
+        return 0;
+    }
+
+    private static int pack(byte[] bytes, int offset, int length,
+                            boolean littleEndian) {
+        int step = 1;
+        if (littleEndian) {
+            offset += length - 1;
+            step = -1;
+        }
+
+        int value = 0;
+        while (length-- > 0) {
+            value = (value << 8) | (bytes[offset] & 0xFF);
+            offset += step;
+        }
+        return value;
+    }
+}
\ No newline at end of file
diff --git a/src/com/koushikdutta/ion/bitmap/IonBitmapCache.java b/src/com/koushikdutta/ion/bitmap/IonBitmapCache.java
new file mode 100644
index 00000000..b9dfec29
--- /dev/null
+++ b/src/com/koushikdutta/ion/bitmap/IonBitmapCache.java
@@ -0,0 +1,202 @@
+package com.koushikdutta.ion.bitmap;
+
+import android.annotation.TargetApi;
+import android.app.ActivityManager;
+import android.content.Context;
+import android.content.res.AssetManager;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.BitmapRegionDecoder;
+import android.graphics.Matrix;
+import android.graphics.Point;
+import android.graphics.Rect;
+import android.os.Build;
+import android.os.Looper;
+import android.util.DisplayMetrics;
+import android.util.Log;
+import android.view.WindowManager;
+
+import com.koushikdutta.async.util.StreamUtility;
+import com.koushikdutta.ion.Ion;
+
+import java.io.File;
+import java.io.FileInputStream;
+
+/**
+ * Created by koush on 5/23/13.
+ */
+public class IonBitmapCache {
+    public static final long DEFAULT_ERROR_CACHE_DURATION = 30000L;
+
+    Resources resources;
+    DisplayMetrics metrics;
+    LruBitmapCache cache;
+    Ion ion;
+    long errorCacheDuration = DEFAULT_ERROR_CACHE_DURATION;
+
+    public long getErrorCacheDuration() {
+        return errorCacheDuration;
+    }
+
+    public void setErrorCacheDuration(long errorCacheDuration) {
+        this.errorCacheDuration = errorCacheDuration;
+    }
+
+    public IonBitmapCache(Ion ion) {
+        Context context = ion.getContext();
+        this.ion = ion;
+        metrics = new DisplayMetrics();
+        ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE))
+                .getDefaultDisplay().getMetrics(metrics);
+        final AssetManager mgr = context.getAssets();
+        resources = new Resources(mgr, metrics, context.getResources().getConfiguration());
+        cache = new LruBitmapCache(getHeapSize(context) / 7);
+    }
+
+    public BitmapInfo remove(String key) {
+        return cache.removeBitmapInfo(key);
+    }
+
+    public void clear() {
+        cache.evictAllBitmapInfo();
+    }
+
+    double heapRatio = 1d / 7d;
+    public double getHeapRatio() {
+        return heapRatio;
+    }
+
+    public void setHeapRatio(double heapRatio) {
+        this.heapRatio = heapRatio;
+    }
+
+    public void put(BitmapInfo info) {
+        assert Thread.currentThread() == Looper.getMainLooper().getThread();
+        int maxSize = (int)(getHeapSize(ion.getContext()) * heapRatio);
+        if (maxSize != cache.maxSize())
+            cache.setMaxSize(maxSize);
+        cache.put(info.key, info);
+    }
+
+    public BitmapInfo get(String key) {
+        if (key == null)
+            return null;
+
+        // see if this thing has an immediate cache hit
+        BitmapInfo ret = cache.getBitmapInfo(key);
+        if (ret == null || ret.bitmaps != null)
+            return ret;
+
+        // if this bitmap load previously errored out, see if it is time to retry
+        // the fetch. connectivity error, server failure, etc, shouldn't be
+        // cached indefinitely...
+        if (ret.loadTime + errorCacheDuration > System.currentTimeMillis())
+            return ret;
+
+        cache.remove(key);
+        return null;
+    }
+
+    public void dump() {
+        Log.i("IonBitmapCache", "bitmap cache: " + cache.size());
+        Log.i("IonBitmapCache", "freeMemory: " + Runtime.getRuntime().freeMemory());
+    }
+
+    private Point computeTarget(int minx, int miny) {
+        int targetWidth = minx;
+        int targetHeight = miny;
+        if (targetWidth == 0)
+            targetWidth = metrics.widthPixels;
+        if (targetWidth <= 0)
+            targetWidth = Integer.MAX_VALUE;
+        if (targetHeight == 0)
+            targetHeight = metrics.heightPixels;
+        if (targetHeight <= 0)
+            targetHeight = Integer.MAX_VALUE;
+        return new Point(targetWidth, targetHeight);
+    }
+
+    public BitmapFactory.Options prepareBitmapOptions(File file, int minx, int miny) {
+        BitmapFactory.Options o = new BitmapFactory.Options();
+        o.inJustDecodeBounds = true;
+        BitmapFactory.decodeFile(file.toString(), o);
+        return prepareBitmapOptions(o, minx, miny);
+    }
+
+    private BitmapFactory.Options prepareBitmapOptions(BitmapFactory.Options o, int minx, int miny) {
+        if (o.outWidth < 0 || o.outHeight < 0)
+            return null;
+        Point target = computeTarget(minx, miny);
+        int scale = Math.max(o.outWidth / target.x, o.outHeight / target.y);
+        BitmapFactory.Options ret = new BitmapFactory.Options();
+        ret.inSampleSize = scale;
+        ret.outWidth = o.outWidth;
+        ret.outHeight = o.outHeight;
+        ret.outMimeType = o.outMimeType;
+        return ret;
+    }
+
+    public BitmapFactory.Options prepareBitmapOptions(byte[] bytes, int offset, int length, int minx, int miny) {
+        BitmapFactory.Options o = new BitmapFactory.Options();
+        o.inJustDecodeBounds = true;
+        BitmapFactory.decodeByteArray(bytes, offset, length, o);
+        return prepareBitmapOptions(o, minx, miny);
+    }
+
+    public Bitmap loadBitmap(byte[] bytes, int offset, int length, BitmapFactory.Options o) {
+        assert Thread.currentThread() != Looper.getMainLooper().getThread();
+
+        Bitmap bitmap = BitmapFactory.decodeByteArray(bytes, offset, length, o);
+        if (bitmap == null)
+            return null;
+
+        int rotation = Exif.getOrientation(bytes, offset, length);
+        if (rotation == 0)
+            return bitmap;
+
+        Matrix matrix = new Matrix();
+        matrix.postRotate(rotation);
+        return Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(), bitmap.getHeight(), matrix, true);
+    }
+
+    @TargetApi(Build.VERSION_CODES.GINGERBREAD_MR1)
+    public Bitmap loadRegion(final BitmapRegionDecoder decoder, Rect sourceRect, int inSampleSize) {
+        BitmapFactory.Options options = new BitmapFactory.Options();
+        options.inSampleSize = inSampleSize;
+        return decoder.decodeRegion(sourceRect, options);
+    }
+
+    public Bitmap loadBitmap(File file, BitmapFactory.Options o) {
+//        stream = new BufferedInputStream(stream, 64 * 1024);
+        assert Thread.currentThread() != Looper.getMainLooper().getThread();
+
+        int rotation;
+        FileInputStream fin = null;
+        try {
+            fin = new FileInputStream(file);
+            byte[] bytes = new byte[50000];
+            int length = fin.read(bytes);
+            rotation = Exif.getOrientation(bytes, 0, length);
+        }
+        catch (Exception e) {
+            rotation = 0;
+        }
+        StreamUtility.closeQuietly(fin);
+
+        Bitmap bitmap = BitmapFactory.decodeFile(file.toString(), o);
+        if (bitmap == null)
+            return null;
+
+        if (rotation == 0)
+            return bitmap;
+
+        Matrix matrix = new Matrix();
+        matrix.postRotate(rotation);
+        return Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(), bitmap.getHeight(), matrix, true);
+    }
+
+    private static int getHeapSize(final Context context) {
+        return ((ActivityManager)context.getSystemService(Context.ACTIVITY_SERVICE)).getMemoryClass() * 1024 * 1024;
+    }
+}
diff --git a/src/com/koushikdutta/ion/bitmap/LruBitmapCache.java b/src/com/koushikdutta/ion/bitmap/LruBitmapCache.java
new file mode 100644
index 00000000..4893da3e
--- /dev/null
+++ b/src/com/koushikdutta/ion/bitmap/LruBitmapCache.java
@@ -0,0 +1,50 @@
+package com.koushikdutta.ion.bitmap;
+
+import com.koushikdutta.async.util.LruCache;
+
+class LruBitmapCache extends LruCache<String, BitmapInfo> {
+    private SoftReferenceHashtable<String, BitmapInfo> soft = new SoftReferenceHashtable<String, BitmapInfo>();
+
+    public LruBitmapCache(int maxSize) {
+        super(maxSize);
+    }
+
+    @Override
+    protected long sizeOf(String key, BitmapInfo info) {
+        return info.sizeOf();
+    }
+
+    public BitmapInfo getBitmapInfo(String key) {
+        BitmapInfo ret = get(key);
+        if (ret != null)
+            return ret;
+
+        ret = soft.remove(key);
+        if (ret != null)
+            put(key, ret);
+
+        return ret;
+    }
+
+    public BitmapInfo removeBitmapInfo(String key) {
+        BitmapInfo i1 = soft.remove(key);
+        BitmapInfo i2 = remove(key);
+        if (i2 != null)
+            return i2;
+        return i1;
+    }
+
+    public void evictAllBitmapInfo() {
+        evictAll();
+        soft.clear();
+    }
+
+    @Override
+    protected void entryRemoved(boolean evicted, String key, BitmapInfo oldValue, BitmapInfo newValue) {
+        super.entryRemoved(evicted, key, oldValue, newValue);
+
+        // on eviction, put the bitmaps into the soft ref table
+        if (evicted)
+            soft.put(key, oldValue);
+    }
+}
diff --git a/src/com/koushikdutta/ion/bitmap/MarkableInputStream.java b/src/com/koushikdutta/ion/bitmap/MarkableInputStream.java
new file mode 100644
index 00000000..284a7808
--- /dev/null
+++ b/src/com/koushikdutta/ion/bitmap/MarkableInputStream.java
@@ -0,0 +1,157 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.koushikdutta.ion.bitmap;
+
+import java.io.BufferedInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+
+/**
+ * An input stream wrapper that supports unlimited independent cursors for
+ * marking and resetting. Each cursor is a token, and it's the caller's
+ * responsibility to keep track of these.
+ */
+final class MarkableInputStream extends InputStream {
+    private final InputStream in;
+
+    private long offset;
+    private long reset;
+    private long limit;
+
+    private long defaultMark = -1;
+
+    public MarkableInputStream(InputStream in) {
+        if (!in.markSupported()) {
+            in = new BufferedInputStream(in);
+        }
+        this.in = in;
+    }
+
+    /** Marks this place in the stream so we can reset back to it later. */
+    @Override public void mark(int readLimit) {
+        defaultMark = savePosition(readLimit);
+    }
+
+    /**
+     * Returns an opaque token representing the current position in the stream.
+     * Call {@link #reset(long)} to return to this position in the stream later.
+     * It is an error to call {@link #reset(long)} after consuming more than
+     * {@code readLimit} bytes from this stream.
+     */
+    public long savePosition(int readLimit) {
+        long offsetLimit = offset + readLimit;
+        if (limit < offsetLimit) {
+            setLimit(offsetLimit);
+        }
+        return offset;
+    }
+
+    /**
+     * Makes sure that the underlying stream can backtrack the full range from
+     * {@code reset} thru {@code limit}. Since we can't call {@code mark()}
+     * without also adjusting the reset-to-position on the underlying stream this
+     * method resets first and then marks the union of the two byte ranges. On
+     * buffered streams this additional cursor motion shouldn't result in any
+     * additional I/O.
+     */
+    private void setLimit(long limit) {
+        try {
+            if (reset < offset && offset <= this.limit) {
+                in.reset();
+                in.mark((int) (limit - reset));
+                skip(reset, offset);
+            } else {
+                reset = offset;
+                in.mark((int) (limit - offset));
+            }
+            this.limit = limit;
+        } catch (IOException e) {
+            throw new IllegalStateException("Unable to mark: " + e);
+        }
+    }
+
+    /** Resets the stream to the most recent {@link #mark mark}. */
+    @Override public void reset() throws IOException {
+        reset(defaultMark);
+    }
+
+    /** Resets the stream to the position recorded by {@code token}. */
+    public void reset(long token) throws IOException {
+        if (offset > limit || token < reset) {
+            throw new IOException("Cannot reset");
+        }
+        in.reset();
+        skip(reset, token);
+        offset = token;
+    }
+
+    /** Skips {@code target - current} bytes and returns. */
+    private void skip(long current, long target) throws IOException {
+        while (current < target) {
+            long skipped = in.skip(target - current);
+            if (skipped == 0) {
+                if (read() == -1) {
+                    break; // EOF
+                } else {
+                    skipped = 1;
+                }
+            }
+            current += skipped;
+        }
+    }
+
+    @Override public int read() throws IOException {
+        int result = in.read();
+        if (result != -1) {
+            offset++;
+        }
+        return result;
+    }
+
+    @Override public int read(byte[] buffer) throws IOException {
+        int count = in.read(buffer);
+        if (count != -1) {
+            offset += count;
+        }
+        return count;
+    }
+
+    @Override public int read(byte[] buffer, int offset, int length) throws IOException {
+        int count = in.read(buffer, offset, length);
+        if (count != -1) {
+            this.offset += count;
+        }
+        return count;
+    }
+
+    @Override public long skip(long byteCount) throws IOException {
+        long skipped = in.skip(byteCount);
+        offset += skipped;
+        return skipped;
+    }
+
+    @Override public int available() throws IOException {
+        return in.available();
+    }
+
+    @Override public void close() throws IOException {
+        in.close();
+    }
+
+    @Override public boolean markSupported() {
+        return in.markSupported();
+    }
+}
\ No newline at end of file
diff --git a/src/com/koushikdutta/ion/bitmap/SoftReferenceHashtable.java b/src/com/koushikdutta/ion/bitmap/SoftReferenceHashtable.java
new file mode 100644
index 00000000..6d8c855d
--- /dev/null
+++ b/src/com/koushikdutta/ion/bitmap/SoftReferenceHashtable.java
@@ -0,0 +1,36 @@
+package com.koushikdutta.ion.bitmap;
+
+import java.lang.ref.SoftReference;
+import java.util.Hashtable;
+
+public class SoftReferenceHashtable<K,V> {
+    Hashtable<K, SoftReference<V>> mTable = new Hashtable<K, SoftReference<V>>();
+
+    public V put(K key, V value) {
+        SoftReference<V> old = mTable.put(key, new SoftReference<V>(value));
+        if (old == null)
+            return null;
+        return old.get();
+    }
+
+    public V get(K key) {
+        SoftReference<V> val = mTable.get(key);
+        if (val == null)
+            return null;
+        V ret = val.get();
+        if (ret == null)
+            mTable.remove(key);
+        return ret;
+    }
+
+    public V remove(K k) {
+        SoftReference<V> v = mTable.remove(k);
+        if (v == null)
+            return null;
+        return v.get();
+    }
+
+    public void clear() {
+        mTable.clear();
+    }
+}
\ No newline at end of file
diff --git a/src/com/koushikdutta/ion/bitmap/Transform.java b/src/com/koushikdutta/ion/bitmap/Transform.java
new file mode 100644
index 00000000..0e0562c2
--- /dev/null
+++ b/src/com/koushikdutta/ion/bitmap/Transform.java
@@ -0,0 +1,11 @@
+package com.koushikdutta.ion.bitmap;
+
+import android.graphics.Bitmap;
+
+/**
+ * Created by koush on 5/23/13.
+ */
+public interface Transform {
+    public Bitmap transform(Bitmap b);
+    public String key();
+}
diff --git a/src/com/koushikdutta/ion/builder/BitmapBuilder.java b/src/com/koushikdutta/ion/builder/BitmapBuilder.java
new file mode 100644
index 00000000..596fc03d
--- /dev/null
+++ b/src/com/koushikdutta/ion/builder/BitmapBuilder.java
@@ -0,0 +1,46 @@
+package com.koushikdutta.ion.builder;
+
+import com.koushikdutta.ion.bitmap.Transform;
+
+/**
+* Created by koush on 5/30/13.
+*/
+public interface BitmapBuilder<B extends BitmapBuilder<?>> {
+    /**
+     * Apply a transformation to a Bitmap
+     * @param transform Transform to apply
+     * @return
+     */
+    public B transform(Transform transform);
+
+    /**
+     * Resize the bitmap to the given dimensions.
+     * @param width
+     * @param height
+     * @return
+     */
+    public B resize(int width, int height);
+
+    /**
+     * Center the image inside of the bounds specified by the ImageView or resize
+     * operation. This will scale the image so that it fills the bounds, and crops
+     * the extra.
+     * @return
+     */
+    public B centerCrop();
+
+    /**
+     * Center the image inside of the bounds specified by the ImageView or resize
+     * operation. This will scale the image so that one dimension is as large as the requested
+     * bounds.
+     * @return
+     */
+    public B centerInside();
+
+    /**
+     * Enable/disable automatic resizing to the dimensions of the device when loading the image.
+     * @param smartSize
+     * @return
+     */
+    public B smartSize(boolean smartSize);
+}
diff --git a/src/com/koushikdutta/ion/builder/BitmapFutureBuilder.java b/src/com/koushikdutta/ion/builder/BitmapFutureBuilder.java
new file mode 100644
index 00000000..14f36e3f
--- /dev/null
+++ b/src/com/koushikdutta/ion/builder/BitmapFutureBuilder.java
@@ -0,0 +1,23 @@
+package com.koushikdutta.ion.builder;
+
+import android.graphics.Bitmap;
+
+import com.koushikdutta.async.future.Future;
+import com.koushikdutta.ion.bitmap.BitmapInfo;
+
+/**
+* Created by koush on 5/30/13.
+*/
+public interface BitmapFutureBuilder {
+    /**
+     * Perform the request and get the result as a Bitmap
+     * @return
+     */
+    public Future<Bitmap> asBitmap();
+
+    /**
+     * Attempt to immediately retrieve the cached Bitmap info
+     * @return
+     */
+    public BitmapInfo asCachedBitmap();
+}
diff --git a/src/com/koushikdutta/ion/builder/Builders.java b/src/com/koushikdutta/ion/builder/Builders.java
new file mode 100644
index 00000000..7675a2de
--- /dev/null
+++ b/src/com/koushikdutta/ion/builder/Builders.java
@@ -0,0 +1,38 @@
+package com.koushikdutta.ion.builder;
+
+/**
+ * Created by koush on 6/10/13.
+ */
+public interface Builders {
+
+    public interface IV {
+        public interface F<A extends F<?>> extends ImageViewBuilder<A>, BitmapBuilder<A>, LoadImageViewFutureBuilder {
+        }
+    }
+
+    public interface Any {
+        // restrict to image view builder
+        public interface IF<A extends IF<?>> extends ImageViewBuilder<A>, ImageViewFutureBuilder {
+        }
+
+        // restrict to bitmap future builder
+        public interface BF<A extends BF<?>> extends BitmapBuilder<A>, BitmapFutureBuilder, IF<A> {
+        }
+
+        // restrict to future builder
+        public interface F extends FutureBuilder, ImageViewFutureBuilder {
+        }
+
+        // restrict to multipart builder
+        public interface M extends MultipartBodyBuilder<M>, F {
+        }
+
+        // restrict to url encoded builder builder
+        public interface U extends UrlEncodedBuilder<U>, F {
+        }
+
+        // top level builder
+        public interface B extends RequestBuilder<F, B, M, U>, F {
+        }
+    }
+}
diff --git a/src/com/koushikdutta/ion/builder/FutureBuilder.java b/src/com/koushikdutta/ion/builder/FutureBuilder.java
new file mode 100644
index 00000000..ec80d761
--- /dev/null
+++ b/src/com/koushikdutta/ion/builder/FutureBuilder.java
@@ -0,0 +1,90 @@
+package com.koushikdutta.ion.builder;
+
+import com.google.gson.JsonArray;
+import com.google.gson.JsonObject;
+import com.google.gson.reflect.TypeToken;
+import com.koushikdutta.async.parser.AsyncParser;
+import com.koushikdutta.ion.future.ResponseFuture;
+
+import org.w3c.dom.Document;
+
+import java.io.File;
+import java.io.InputStream;
+import java.io.OutputStream;
+
+/**
+* Created by koush on 5/30/13.
+*/ // get the result, transformed to how you want it
+public interface FutureBuilder extends BitmapFutureBuilder, ImageViewFutureBuilder, GsonFutureBuilder {
+    /**
+     * Execute the request and get the result as a String
+     * @return
+     */
+    public ResponseFuture<String> asString();
+
+    /**
+     * Execute the request and get the result as an InputStream.
+     * This method will load the entire response into memory
+     * and should not be used for large responses.
+     * @return
+     */
+    public ResponseFuture<InputStream> asInputStream();
+
+    /**
+     * Execute the request and get the result as an XML Document
+     * @return
+     */
+    public ResponseFuture<Document> asDocument();
+
+    /**
+     * Use the request as a Bitmap which can then be modified and/or applied to an ImageView.
+     * @return
+     */
+    public Builders.Any.BF<? extends Builders.Any.BF<?>> withBitmap();
+
+    /**
+     * Execute the request and write it to the given OutputStream.
+     * The OutputStream will be closed upon finishing.
+     * @param outputStream OutputStream to write the request
+     * @return
+     */
+    public <T extends OutputStream> ResponseFuture<T> write(T outputStream);
+
+    /**
+     * Execute the request and write it to the given OutputStream.
+     * Specify whether the OutputStream will be closed upon finishing.
+     * @param outputStream OutputStream to write the request
+     * @param close Indicate whether the OutputStream should be closed on completion.
+     * @return
+     */
+    public <T extends OutputStream> ResponseFuture<T> write(T outputStream, boolean close);
+
+    /**
+     * Execute the request and write the results to a file
+     * @param file File to write
+     * @return
+     */
+    public ResponseFuture<File> write(File file);
+
+    /**
+     * Deserialize a response into an object given a custom parser.
+     * @param parser
+     * @param <T>
+     * @return
+     */
+    public <T> ResponseFuture<T> as(AsyncParser<T> parser);
+
+    /**
+     * Execute the request and get the result as a byte array
+     * @return
+     */
+    public ResponseFuture<byte[]> asByteArray();
+
+    /**
+     * Add this request to a group specified by groupKey. This key can be used in a later call to
+     * Ion.cancelAll(groupKey) to cancel all the requests in the same group.
+     * @param groupKey
+     * @return
+     */
+    public FutureBuilder group(Object groupKey);
+}
diff --git a/src/com/koushikdutta/ion/builder/GsonFutureBuilder.java b/src/com/koushikdutta/ion/builder/GsonFutureBuilder.java
new file mode 100644
index 00000000..d2d8fe0a
--- /dev/null
+++ b/src/com/koushikdutta/ion/builder/GsonFutureBuilder.java
@@ -0,0 +1,38 @@
+package com.koushikdutta.ion.builder;
+
+import com.google.gson.JsonArray;
+import com.google.gson.JsonObject;
+import com.google.gson.reflect.TypeToken;
+import com.koushikdutta.ion.future.ResponseFuture;
+
+/**
+ * Created by koush on 3/10/14.
+ */
+public interface GsonFutureBuilder {
+    /**
+     * Execute the request and get the result as a (Gson) JsonArray
+     * @return
+     */
+    public ResponseFuture<JsonArray> asJsonArray();
+
+    /**
+     * Execute the request and get the result as a (Gson) JsonObject
+     * @return
+     */
+    public ResponseFuture<JsonObject> asJsonObject();
+
+    /**
+     * Deserialize the JSON request into a Java object of the given class using Gson.
+     * @param <T>
+     * @return
+     */
+    public <T> ResponseFuture<T> as(Class<T> clazz);
+
+    /**
+     * Deserialize the JSON request into a Java object of the given class using Gson.
+     * @param token
+     * @param <T>
+     * @return
+     */
+    public <T> ResponseFuture<T> as(TypeToken<T> token);
+}
diff --git a/src/com/koushikdutta/ion/builder/ImageViewBuilder.java b/src/com/koushikdutta/ion/builder/ImageViewBuilder.java
new file mode 100644
index 00000000..741cf66a
--- /dev/null
+++ b/src/com/koushikdutta/ion/builder/ImageViewBuilder.java
@@ -0,0 +1,96 @@
+package com.koushikdutta.ion.builder;
+
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.view.animation.Animation;
+
+/**
+* Created by koush on 5/30/13.
+*/
+public interface ImageViewBuilder<I extends ImageViewBuilder<?>> {
+    /**
+     * Set a placeholder on the ImageView while the request is loading
+     * @param drawable
+     * @return
+     */
+    public I placeholder(Drawable drawable);
+
+    /**
+     * Set a placeholder on the ImageView while the request is loading
+     * @param resourceId
+     * @return
+     */
+    public I placeholder(int resourceId);
+
+    /**
+     * Set an error image on the ImageView if the request fails to load
+     * @param drawable
+     * @return
+     */
+    public I error(Drawable drawable);
+
+    /**
+     * Set an error image on the ImageView if the request fails to load
+     * @param resourceId
+     * @return
+     */
+    public I error(int resourceId);
+
+    /**
+     * If an ImageView is loaded successfully from a remote source or file storage,
+     * animate it in using the given Animation. The default animation is to fade
+     * in.
+     * @param in Animation to apply to the ImageView after the request has loaded
+     *           and the Bitmap has been retrieved.
+     * @return
+     */
+    public I animateIn(Animation in);
+
+    /**
+     * If an ImageView is loaded successfully from a remote source or file storage,
+     * animate it in using the given Animation resource. The default animation is to fade
+     * in.
+     * @param animationResource Animation resource to apply to the ImageView after the request has loaded
+     *           and the Bitmap has been retrieved.
+     * @return
+     */
+    public I animateIn(int animationResource);
+
+    /**
+     * If the ImageView needs to load from a remote source or file storage,
+     * the given Animation will be used while it is loading.
+     * @param load Animation to apply to the imageView while the request is loading.
+     * @return
+     */
+    public I animateLoad(Animation load);
+
+    /**
+     * If the ImageView needs to load from a remote source or file storage,
+     * the given Animation resource will be used while it is loading.
+     * @param animationResource Animation resource to apply to the imageView while the request is loading.
+     * @return
+     */
+    public I animateLoad(int animationResource);
+
+    /**
+     * Disable fadeIn when the image loads.
+     * @return
+     */
+    public I disableFadeIn();
+
+    /**
+     * Flag to enable or disable animation of GIFs
+     * @param animateGif
+     * @return
+     */
+    public I animateGif(boolean animateGif);
+
+    /**
+     * Load the ImageView with a deep zoomable image. This allows extremely large images
+     * to be loaded, at full fidelity. Only portions of the image will be decoded,
+     * on an as needed basis when rendering.
+     * This only works on API level 10+, where BitmapRegionDecoder is available.
+     * @return
+     */
+    public I deepZoom();
+}
diff --git a/src/com/koushikdutta/ion/builder/ImageViewFutureBuilder.java b/src/com/koushikdutta/ion/builder/ImageViewFutureBuilder.java
new file mode 100644
index 00000000..3870c245
--- /dev/null
+++ b/src/com/koushikdutta/ion/builder/ImageViewFutureBuilder.java
@@ -0,0 +1,18 @@
+package com.koushikdutta.ion.builder;
+
+import android.widget.ImageView;
+
+import com.koushikdutta.async.future.Future;
+
+/**
+* Created by koush on 5/30/13.
+*/
+public interface ImageViewFutureBuilder {
+    /**
+     * Perform the request and get the result as a Bitmap, which will then be loaded
+     * into the given ImageView
+     * @param imageView ImageView to set once the request completes
+     * @return
+     */
+    public Future<ImageView> intoImageView(ImageView imageView);
+}
diff --git a/src/com/koushikdutta/ion/builder/LoadBuilder.java b/src/com/koushikdutta/ion/builder/LoadBuilder.java
new file mode 100644
index 00000000..c438475b
--- /dev/null
+++ b/src/com/koushikdutta/ion/builder/LoadBuilder.java
@@ -0,0 +1,38 @@
+package com.koushikdutta.ion.builder;
+
+import com.google.gson.JsonArray;
+import com.google.gson.JsonObject;
+import com.google.gson.reflect.TypeToken;
+import com.koushikdutta.async.future.Future;
+
+import org.w3c.dom.Document;
+
+import java.io.File;
+import java.io.InputStream;
+
+/**
+* Created by koush on 5/30/13.
+*/ // .load
+public interface LoadBuilder<B> {
+    /**
+     * Load an uri.
+     * @param uri Uri to load. This may be a http(s), file, or content uri.
+     * @return
+     */
+    public B load(String uri);
+
+    /**
+     * Load an url using the given an HTTP method such as GET or POST.
+     * @param method HTTP method such as GET or POST.
+     * @param url Url to load.
+     * @return
+     */
+    public B load(String method, String url);
+
+    /**
+     * Load a file.
+     * @param file File to load.
+     * @return
+     */
+    public B load(File file);
+}
diff --git a/src/com/koushikdutta/ion/builder/LoadImageViewFutureBuilder.java b/src/com/koushikdutta/ion/builder/LoadImageViewFutureBuilder.java
new file mode 100644
index 00000000..04314514
--- /dev/null
+++ b/src/com/koushikdutta/ion/builder/LoadImageViewFutureBuilder.java
@@ -0,0 +1,27 @@
+package com.koushikdutta.ion.builder;
+
+import android.widget.ImageView;
+
+import com.koushikdutta.async.future.Future;
+
+/**
+* Created by koush on 5/30/13.
+*/
+public interface LoadImageViewFutureBuilder {
+    /**
+     * Perform the request and get the result as a Bitmap, which will then be loaded
+     * into the given ImageView
+     * @param url
+     * @return
+     */
+    public Future<ImageView> load(String url);
+
+    /**
+     * Perform the request and get the result as a Bitmap, which will then be loaded
+     * into the given ImageView
+     * @param method
+     * @param url
+     * @return
+     */
+    public Future<ImageView> load(String method, String url);
+}
diff --git a/src/com/koushikdutta/ion/builder/MultipartBodyBuilder.java b/src/com/koushikdutta/ion/builder/MultipartBodyBuilder.java
new file mode 100644
index 00000000..6de6f096
--- /dev/null
+++ b/src/com/koushikdutta/ion/builder/MultipartBodyBuilder.java
@@ -0,0 +1,46 @@
+package com.koushikdutta.ion.builder;
+
+import java.io.File;
+import java.util.List;
+import java.util.Map;
+
+/**
+* Created by koush on 5/30/13.
+*/ // set additional body parameters for multipart/form-data
+public interface MultipartBodyBuilder<M extends MultipartBodyBuilder> {
+    /**
+     * Specify a multipart/form-data parameter to send to the HTTP server. If no HTTP method was explicitly
+     * provided in the load call, the default HTTP method, POST, is used.
+     * @param name Multipart name
+     * @param value Multipart String value
+     * @return
+     */
+    public M setMultipartParameter(String name, String value);
+
+    /**
+     * Specify a multipart/form-data parameter to send to the HTTP server. If no HTTP method was explicitly
+     * provided in the load call, the default HTTP method, POST, is used.
+     * @param params The map containing key value pairs
+     * @return
+     */
+    public M setMultipartParameters(Map<String, List<String>> params);
+
+    /**
+     * Specify a multipart/form-data file to send to the HTTP server. If no HTTP method was explicitly
+     * provided in the load call, the default HTTP method, POST, is used.
+     * @param name Multipart name
+     * @param file Multipart file to send
+     * @return
+     */
+    public M setMultipartFile(String name, File file);
+
+    /**
+     * Specify a multipart/form-data file to send to the HTTP server. If no HTTP method was explicitly
+     * provided in the load call, the default HTTP method, POST, is used.
+     * @param name Multipart name
+     * @param file Multipart Content-Type
+     * @param file Multipart file to send
+     * @return
+     */
+    public M setMultipartFile(String name, String contentType, File file);
+}
diff --git a/src/com/koushikdutta/ion/builder/RequestBuilder.java b/src/com/koushikdutta/ion/builder/RequestBuilder.java
new file mode 100644
index 00000000..daa02c6b
--- /dev/null
+++ b/src/com/koushikdutta/ion/builder/RequestBuilder.java
@@ -0,0 +1,277 @@
+package com.koushikdutta.ion.builder;
+
+import android.app.ProgressDialog;
+import android.os.Handler;
+import android.widget.ProgressBar;
+
+import com.google.gson.JsonArray;
+import com.google.gson.JsonObject;
+import com.google.gson.reflect.TypeToken;
+import com.koushikdutta.ion.HeadersCallback;
+import com.koushikdutta.ion.ProgressCallback;
+
+import org.apache.http.NameValuePair;
+import org.w3c.dom.Document;
+
+import java.io.File;
+import java.io.InputStream;
+import java.util.List;
+import java.util.Map;
+
+/**
+* Created by koush on 5/30/13.
+*/ // set parameters
+public interface RequestBuilder<F, R extends RequestBuilder, M extends MultipartBodyBuilder, U extends UrlEncodedBuilder> extends MultipartBodyBuilder<M>, UrlEncodedBuilder<U> {
+    /**
+     * Enable logging for this request
+     * @param tag LOGTAG to use
+     * @param level Log level of messages to display
+     * @return
+     */
+    public R setLogging(String tag, int level);
+
+    /**
+     * Route the request through the given proxy server.
+     * @param host
+     * @param port
+     */
+    public R proxy(String host, int port);
+
+    /**
+     * Specify a callback that is invoked on download progress. This will not be invoked
+     * on the UI thread.
+     * @param callback
+     * @return
+     */
+    public R progress(ProgressCallback callback);
+
+    /**
+     * Specify a callback that is invoked on download progress. This will be invoked
+     * on the UI thread.
+     * @param callback
+     * @return
+     */
+    public R progressHandler(ProgressCallback callback);
+
+    /**
+     * Specify a ProgressBar to update during the request
+     * @param progressBar
+     * @return
+     */
+    public R progressBar(ProgressBar progressBar);
+
+    /**
+     * Specify a ProgressDialog to update during the request
+     * @param progressDialog
+     * @return
+     */
+    public R progressDialog(ProgressDialog progressDialog);
+
+    /**
+     * Specify a callback that is invoked on upload progress of a HTTP
+     * request body.
+     * @param callback
+     * @return
+     */
+    public R uploadProgress(ProgressCallback callback);
+
+    /**
+     * Specify a callback that is invoked on upload progress of a HTTP
+     * request body. This will be invoked on the UI thread.
+     * @param callback
+     * @return
+     */
+    public R uploadProgressHandler(ProgressCallback callback);
+
+    /**
+     * Specify a ProgressBar to update while uploading
+     * a request body.
+     * @param progressBar
+     * @return
+     */
+    public R uploadProgressBar(ProgressBar progressBar);
+
+    /**
+     * Specify a ProgressDialog to update while uploading
+     * a request body.
+     * @param progressDialog
+     * @return
+     */
+    public R uploadProgressDialog(ProgressDialog progressDialog);
+
+    /**
+     * Post the Future callback onto the given handler. Not specifying this explicitly
+     * results in the default handle of Thread.currentThread to be used, if one exists.
+     * @param handler Handler to use or null
+     * @return
+     */
+    public R setHandler(Handler handler);
+
+    /**
+     * Set a HTTP header
+     * @param name Header name
+     * @param value Header value
+     * @return
+     */
+    public R setHeader(String name, String value);
+
+    /**
+     * Set HTTP headers
+     * @param header
+     * @return
+     */
+    public R setHeader(NameValuePair... header);
+
+    /**
+     * Disable usage of the cache for this request
+     * @return
+     */
+    public R noCache();
+
+    /**
+     * Set whether this request will follow redirects
+     */
+    public R followRedirect(boolean follow);
+
+    /**
+     * Add an HTTP header
+     * @param name Header name
+     * @param value Header value
+     * @return
+     */
+    public R addHeader(String name, String value);
+
+    /**
+     * Add multiple headers at once
+     * @param params
+     * @return
+     */
+    public R addHeaders(Map<String, List<String>> params);
+
+    /**
+     * Add a query parameter
+     * @param name
+     * @param value
+     * @return
+     */
+    public R addQuery(String name, String value);
+
+    /**
+     * Add multiple query parameters at once
+     * @param params
+     * @return
+     */
+    public R addQueries(Map<String, List<String>> params);
+
+    /**
+     * Set the user agent of this request.
+     * @param userAgent
+     * @return
+     */
+    public R userAgent(String userAgent);
+
+    /**
+     * Specify the timeout in milliseconds before the request will cancel.
+     * A CancellationException will be returned as the result.
+     * @param timeoutMilliseconds Timeout in milliseconds
+     * @return
+     */
+    public R setTimeout(int timeoutMilliseconds);
+
+    /**
+     * Invoke the given callback when the http request headers are received.
+     * @param callback
+     * @return
+     */
+    public R onHeaders(HeadersCallback callback);
+
+    /**
+     * Provide Basic authentication credentials to be sent with the request.
+     * @param username
+     * @param password
+     * @return
+     */
+    public R basicAuthentication(String username, String password);
+
+    /**
+     * Specify a JsonObject to send to the HTTP server. If no HTTP method was explicitly
+     * provided in the load call, the default HTTP method, POST, is used.
+     * @param jsonObject JsonObject to send with the request
+     * @return
+     */
+    public F setJsonObjectBody(JsonObject jsonObject);
+
+    /**
+     * Specify a JsonObject to send to the HTTP server. If no HTTP method was explicitly
+     * provided in the load call, the default HTTP method, POST, is used.
+     * @param object Object to serialize with Json and send with the request
+     * @param token Type token to assist with generic type serialization
+     * @return
+     */
+    public <T> F setJsonObjectBody(T object, TypeToken<T> token);
+
+    /**
+     * Specify a JsonObject to send to the HTTP server. If no HTTP method was explicitly
+     * provided in the load call, the default HTTP method, POST, is used.
+     * @param object Object to serialize with Json and send with the request
+     * @return
+     */
+    public <T> F setJsonObjectBody(T object);
+
+    /**
+     * Specify a JsonArray to send to the HTTP server. If no HTTP method was explicitly
+     * provided in the load call, the default HTTP method, POST, is used.
+     * @param jsonArray JsonObject to send with the request
+     * @return
+     */
+    public F setJsonArrayBody(JsonArray jsonArray);
+
+    /**
+     * Specify a String to send to the HTTP server. If no HTTP method was explicitly
+     * provided in the load call, the default HTTP method, POST, is used.
+     * @param string String to send with the request
+     * @return
+     */
+    public F setStringBody(String string);
+
+    /**
+     * Specify an XML Document to send to the HTTP server. If no HTTP method was explicitly
+     * provided in the load call, the default HTTP method, POST, is used.
+     * @param document Document to send with the request
+     * @return
+     */
+    public F setDocumentBody(Document document);
+
+    /**
+     * Specify a File to send to the HTTP server. If no HTTP method was explicitly
+     * provided in the load call, the default HTTP method, POST, is used.
+     * @param file File to send with the request
+     * @return
+     */
+    public F setFileBody(File file);
+
+    /**
+     * Specify a byte array to send to the HTTP server. If no HTTP method was explicitly
+     * provided in the load call, the default HTTP method, POST, is used.
+     * @param bytes Bytes to send with the request
+     * @return
+     */
+    public F setByteArrayBody(byte[] bytes);
+
+    /**
+     * Specify an InputStream to send to the HTTP server. If no HTTP method was explicitly
+     * provided in the load call, the default HTTP method, POST, is used.
+     * @param inputStream InputStream to send with the request
+     * @return
+     */
+    public Builders.Any.F setStreamBody(InputStream inputStream);
+
+    /**
+     * Specify an InputStream to send to the HTTP server. If no HTTP method was explicitly
+     * provided in the load call, the default HTTP method, POST, is used.
+     * @param inputStream InputStream to send with the request
+     * @param length length of the input stream (in bytes) to read
+     * @return
+     */
+    public Builders.Any.F setStreamBody(InputStream inputStream, int length);
+}
diff --git a/src/com/koushikdutta/ion/builder/UrlEncodedBuilder.java b/src/com/koushikdutta/ion/builder/UrlEncodedBuilder.java
new file mode 100644
index 00000000..6802d610
--- /dev/null
+++ b/src/com/koushikdutta/ion/builder/UrlEncodedBuilder.java
@@ -0,0 +1,25 @@
+package com.koushikdutta.ion.builder;
+
+import java.util.List;
+import java.util.Map;
+
+/**
+* Created by koush on 5/30/13.
+*/ // set additional body parameters for url form encoded
+public interface UrlEncodedBuilder<U extends UrlEncodedBuilder> {
+    /**
+     * Specify a application/x-www-form-urlencoded name and value pair to send to the HTTP server.
+     * If no HTTP method was explicitly provided in the load call, the default HTTP method, POST, is used.
+     * @param name Form field name
+     * @param value Form field String value
+     * @return
+     */
+    public U setBodyParameter(String name, String value);
+    /**
+     * Specifies a map with application/x-www-form-urlencoded name and value pairs to send to the HTTP server.
+     * If no HTTP method was explicitly provided in the load call, the default HTTP method, POST, is used.
+     * @param params The map containing key value pairs
+     * @return
+     */
+    public U setBodyParameters(Map<String, List<String>> params);
+}
diff --git a/src/com/koushikdutta/ion/cookie/CookieMiddleware.java b/src/com/koushikdutta/ion/cookie/CookieMiddleware.java
new file mode 100644
index 00000000..3baaf9bf
--- /dev/null
+++ b/src/com/koushikdutta/ion/cookie/CookieMiddleware.java
@@ -0,0 +1,108 @@
+package com.koushikdutta.ion.cookie;
+
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.text.TextUtils;
+import android.util.Log;
+
+import com.koushikdutta.async.http.Multimap;
+import com.koushikdutta.async.http.SimpleMiddleware;
+import com.koushikdutta.async.http.libcore.RawHeaders;
+
+import java.net.CookieManager;
+import java.net.CookieStore;
+import java.net.HttpCookie;
+import java.net.URI;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Created by koush on 5/29/13.
+ */
+public class CookieMiddleware extends SimpleMiddleware {
+    CookieManager manager;
+    SharedPreferences preferences;
+
+    public CookieStore getCookieStore() {
+        return manager.getCookieStore();
+    }
+
+    public void clear() {
+        getCookieStore().removeAll();
+        preferences.edit().clear().commit();
+    }
+
+    public CookieManager getCookieManager() {
+        return manager;
+    }
+
+    public CookieMiddleware(Context context, String name) {
+        reinit(context, name);
+    }
+
+    public void reinit(Context context, String name) {
+        manager = new CookieManager(null, null);
+        preferences = context.getSharedPreferences(name + "-cookies", Context.MODE_PRIVATE);
+
+        Map<String, ?> allPrefs = preferences.getAll();
+        for (String key: allPrefs.keySet()) {
+            try {
+                String value = preferences.getString(key, null);
+                RawHeaders headers = new RawHeaders();
+                String[] lines = value.split("\n");
+                boolean first = true;
+                for (String line: lines) {
+                    if (first) {
+                        first = false;
+                        headers.setStatusLine(line);
+                    }
+                    else if (!TextUtils.isEmpty(line)) {
+                        headers.addLine(line);
+                    }
+                }
+                manager.put(URI.create(key), headers.toMultimap());
+            }
+            catch (Exception e) {
+                Log.e("Ion", "unable to load cookies", e);
+            }
+        }
+    }
+
+    @Override
+    public void onSocket(OnSocketData data) {
+        try {
+            Map<String, List<String>> cookies = manager.get (data.request.getUri(), data.request.getHeaders().getHeaders().toMultimap());
+            data.request.getHeaders().addCookies(cookies);
+        }
+        catch (Exception e) {
+        }
+    }
+
+    @Override
+    public void onHeadersReceived(OnHeadersReceivedData data) {
+        put(data.request.getUri(), data.headers.getHeaders());
+    }
+
+    public void put(URI uri, RawHeaders headers) {
+        try {
+            manager.put(uri, headers.toMultimap());
+
+            // no cookies to persist.
+            if (headers.get("Set-Cookie") == null)
+                return;
+
+            List<HttpCookie> cookies = manager.getCookieStore().get(uri);
+
+            RawHeaders dump = new RawHeaders();
+            dump.setStatusLine("HTTP/1.1 200 OK");
+            for (HttpCookie cookie: cookies) {
+                dump.add("Set-Cookie", cookie.getName() + "=" + cookie.getValue());
+            }
+
+            String key = uri.getScheme() + "://" + uri.getAuthority();
+            preferences.edit().putString(key, dump.toHeaderString()).commit();
+        }
+        catch (Exception e) {
+        }
+    }
+}
diff --git a/src/com/koushikdutta/ion/future/ResponseFuture.java b/src/com/koushikdutta/ion/future/ResponseFuture.java
new file mode 100644
index 00000000..c3676fac
--- /dev/null
+++ b/src/com/koushikdutta/ion/future/ResponseFuture.java
@@ -0,0 +1,11 @@
+package com.koushikdutta.ion.future;
+
+import com.koushikdutta.async.future.Future;
+import com.koushikdutta.ion.Response;
+
+/**
+ * Created by koush on 7/2/13.
+ */
+public interface ResponseFuture<T> extends Future<T> {
+    Future<Response<T>> withResponse();
+}
diff --git a/src/com/koushikdutta/ion/gif/GifAction.java b/src/com/koushikdutta/ion/gif/GifAction.java
new file mode 100755
index 00000000..856e5d6d
--- /dev/null
+++ b/src/com/koushikdutta/ion/gif/GifAction.java
@@ -0,0 +1,5 @@
+package com.koushikdutta.ion.gif;
+
+public interface GifAction {
+    public boolean parseOk(boolean parseStatus, int frameIndex);
+}
diff --git a/src/com/koushikdutta/ion/gif/GifDecoder.java b/src/com/koushikdutta/ion/gif/GifDecoder.java
new file mode 100755
index 00000000..41b71475
--- /dev/null
+++ b/src/com/koushikdutta/ion/gif/GifDecoder.java
@@ -0,0 +1,707 @@
+package com.koushikdutta.ion.gif;
+
+import java.io.ByteArrayInputStream;
+import java.io.InputStream;
+import java.lang.reflect.Array;
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.nio.IntBuffer;
+import java.util.Arrays;
+
+import android.graphics.Bitmap;
+import android.graphics.Bitmap.Config;
+import android.util.Log;
+
+public class GifDecoder extends Thread{
+
+	public static final int STATUS_PARSING = 0;
+	public static final int STATUS_FORMAT_ERROR = 1;
+	public static final int STATUS_OPEN_ERROR = 2;
+	public static final int STATUS_FINISH = -1;
+	
+	private InputStream in;
+	private int status;
+
+	public int width; // full image width
+	public int height; // full image height
+	private boolean gctFlag; // global color table used
+	private int gctSize; // size of global color table
+	private int loopCount = 1; // iterations; 0 = repeat forever
+
+	private int[] gct; // global color table
+	private int[] lct; // local color table
+	private int[] act; // active color table
+
+	private int bgIndex; // background color index
+	private int bgColor; // background color
+	private int lastBgColor; // previous bg color
+	private int pixelAspect; // pixel aspect ratio
+
+	private boolean lctFlag; // local color table flag
+	private boolean interlace; // interlace flag
+	private int lctSize; // local color table size
+
+	private int ix, iy, iw, ih; // current image rectangle
+	private int lrx, lry, lrw, lrh;
+	private GifFrame currentFrame = null;
+
+	private boolean isShow = false;
+	
+
+	private byte[] block = new byte[256]; // current data block
+	private int blockSize = 0; // block size
+	private int dispose = 0;
+	private int lastDispose = 0;
+	private boolean transparency = false; // use transparent color
+	private int delay = 0; // delay in milliseconds
+	private int transIndex; // transparent color index
+
+	private static final int MaxStackSize = 10000;
+	// max decoder pixel stack size
+
+	// LZW decoder working arrays
+	private short[] prefix;
+	private byte[] suffix;
+	private byte[] pixelStack;
+	private byte[] pixels;
+
+	private GifFrame gifFrame; // frames read from current file
+	private int frameCount;
+
+	private GifAction action = null;
+	
+	
+	private byte[] gifData = null;
+	private int gifDataOffset;
+	private int gifDataLength;
+
+
+	public GifDecoder(byte[] data,GifAction act){
+		this(data, 0, data.length, act);
+	}
+
+	public GifDecoder(byte[] data,int offset,int length,GifAction act){
+		gifData = data;
+		action = act;
+		gifDataOffset = offset;
+		gifDataLength = length;
+	}
+	
+	public GifDecoder(InputStream is,GifAction act){
+		in = is;
+		action = act;
+	}
+
+	public void run(){
+		if(in != null){
+                  readStream();
+		}else if(gifData != null){
+                  readByte();
+		}
+	}
+	
+	public void free(){
+		GifFrame fg = gifFrame;
+		while(fg != null){
+            if (fg.image != null) {
+                fg.image.recycle();
+            }
+			fg.image = null;
+			fg = null;
+			gifFrame = gifFrame.nextFrame;
+			fg = gifFrame;
+		}
+		if(in != null){
+			try{
+			in.close();
+			}catch(Exception ex){}
+			in = null;
+		}
+		gifData = null;
+	}
+	
+	public int getStatus(){
+		return status;
+	}
+	
+	public boolean parseOk(){
+		return status == STATUS_FINISH;
+	}
+	
+	public int getDelay(int n) {
+		delay = -1;
+		if ((n >= 0) && (n < frameCount)) {
+			GifFrame f = getFrame(n);
+			if (f != null)
+				delay = f.delay;
+		}
+		return delay;
+	}
+	
+	public int[] getDelays(){
+		GifFrame f = gifFrame;
+		int[] d = new int[frameCount];
+		int i = 0;
+		while(f != null && i < frameCount){
+			d[i] = f.delay;
+			f = f.nextFrame;
+			i++;
+		}
+		return d;
+	}
+	
+	public int getFrameCount() {
+		return frameCount;
+	}
+
+	public Bitmap getImage() {
+		return getFrameImage(0);
+	}
+
+	public int getLoopCount() {
+		return loopCount;
+	}
+
+    int[] lastPixels;
+    int[] dest;
+	private Bitmap setPixels() {
+        if (dest == null)
+            dest = new int[width * height];
+		// fill in starting image contents based on last image's dispose code
+		if (lastDispose > 0) {
+			if (lastDispose == 3) {
+				// use image before last
+				int n = frameCount - 2;
+				if (n > 0) {
+					Bitmap lastImage = getFrameImage(n - 1);
+                    if (lastPixels == null)
+                        lastPixels = new int[width * height];
+                    lastImage.getPixels(lastPixels, 0, width, 0, 0, width, height);
+				}
+                else {
+                    lastPixels = null;
+                }
+            }
+			if (lastPixels != null) {
+                dest = Arrays.copyOf(lastPixels, lastPixels.length);
+                // copy pixels
+				if (lastDispose == 2) {
+					// fill last image rect area with background color
+					int c = 0;
+					if (!transparency) {
+						c = lastBgColor;
+					}
+					for (int i = 0; i < lrh; i++) {
+						int n1 = (lry + i) * width + lrx;
+						int n2 = n1 + lrw;
+						for (int k = n1; k < n2; k++) {
+							dest[k] = c;
+						}
+					}
+				}
+			}
+		}
+
+		// copy each source line to the appropriate place in the destination
+		int pass = 1;
+		int inc = 8;
+		int iline = 0;
+		for (int i = 0; i < ih; i++) {
+			int line = i;
+			if (interlace) {
+				if (iline >= ih) {
+					pass++;
+					switch (pass) {
+					case 2:
+						iline = 4;
+						break;
+					case 3:
+						iline = 2;
+						inc = 4;
+						break;
+					case 4:
+						iline = 1;
+						inc = 2;
+					}
+				}
+				line = iline;
+				iline += inc;
+			}
+			line += iy;
+			if (line < height) {
+				int k = line * width;
+				int dx = k + ix; // start of line in dest
+				int dlim = dx + iw; // end of dest line
+				if ((k + width) < dlim) {
+					dlim = k + width; // past dest edge
+				}
+				int sx = i * iw; // start of line in source
+				while (dx < dlim) {
+					// map color and insert in destination
+					int index = ((int) pixels[sx++]) & 0xff;
+					int c = act[index];
+					if (c != 0) {
+						dest[dx] = c;
+					}
+					dx++;
+				}
+			}
+		}
+		return Bitmap.createBitmap(dest, width, height, Config.ARGB_4444);
+	}
+
+	public Bitmap getFrameImage(int n) {
+		GifFrame frame = getFrame(n);	
+		if (frame == null)
+			return null;
+		else
+			return frame.image;
+	}
+
+	public GifFrame getCurrentFrame(){
+		return currentFrame;
+	}
+	
+	public GifFrame getFrame(int n) {
+		GifFrame frame = gifFrame;
+		int i = 0;
+		while (frame != null) {
+			if (i == n) {
+				return frame;
+			} else {
+				frame = frame.nextFrame;
+			}
+			i++;
+		}
+		return null;
+	}
+
+	public void reset(){
+		currentFrame = gifFrame;
+	}
+	
+	public GifFrame next() {	
+		if(isShow == false){
+			isShow = true;
+			return gifFrame;
+		}else{	
+			if(status == STATUS_PARSING){
+				if(currentFrame.nextFrame != null)
+					currentFrame = currentFrame.nextFrame;			
+				//currentFrame = gifFrame;
+			}else{			
+				currentFrame = currentFrame.nextFrame;
+				if (currentFrame == null) {
+					currentFrame = gifFrame;
+				}
+			}
+			return currentFrame;
+		}
+	}
+
+	private int readByte(){
+		in = new ByteArrayInputStream(gifData,gifDataOffset,gifDataLength);
+		gifData = null;
+		return readStream();
+	}
+	
+	private int readStream(){
+		init();
+		if(in != null){
+			readHeader();
+			if(!err()){
+				readContents();
+				if(frameCount < 0){
+					status = STATUS_FORMAT_ERROR;
+					action.parseOk(false,-1);
+				}else{
+					status = STATUS_FINISH;
+					action.parseOk(true,-1);
+				}
+			}
+			try {
+				in.close();
+			} catch (Exception e) {
+				e.printStackTrace();
+			}
+			
+		}else {
+			status = STATUS_OPEN_ERROR;
+			action.parseOk(false,-1);
+		}
+		return status;
+	}
+
+	private void decodeImageData() {
+		int NullCode = -1;
+		int npix = iw * ih;
+		int available, clear, code_mask, code_size, end_of_information, in_code, old_code, bits, code, count, i, datum, data_size, first, top, bi, pi;
+
+		if ((pixels == null) || (pixels.length < npix)) {
+			pixels = new byte[npix]; // allocate new pixel array
+		}
+		if (prefix == null) {
+			prefix = new short[MaxStackSize];
+		}
+		if (suffix == null) {
+			suffix = new byte[MaxStackSize];
+		}
+		if (pixelStack == null) {
+			pixelStack = new byte[MaxStackSize + 1];
+		}
+		// Initialize GIF data stream decoder.
+		data_size = read();
+		clear = 1 << data_size;
+		end_of_information = clear + 1;
+		available = clear + 2;
+		old_code = NullCode;
+		code_size = data_size + 1;
+		code_mask = (1 << code_size) - 1;
+		for (code = 0; code < clear; code++) {
+			prefix[code] = 0;
+			suffix[code] = (byte) code;
+		}
+
+		// Decode GIF pixel stream.
+		datum = bits = count = first = top = pi = bi = 0;
+		for (i = 0; i < npix;) {
+			if (top == 0) {
+				if (bits < code_size) {
+					// Load bytes until there are enough bits for a code.
+					if (count == 0) {
+						// Read a new data block.
+						count = readBlock();
+						if (count <= 0) {
+							break;
+						}
+						bi = 0;
+					}
+					datum += (((int) block[bi]) & 0xff) << bits;
+					bits += 8;
+					bi++;
+					count--;
+					continue;
+				}
+				// Get the next code.
+				code = datum & code_mask;
+				datum >>= code_size;
+				bits -= code_size;
+
+				// Interpret the code
+				if ((code > available) || (code == end_of_information)) {
+					break;
+				}
+				if (code == clear) {
+					// Reset decoder.
+					code_size = data_size + 1;
+					code_mask = (1 << code_size) - 1;
+					available = clear + 2;
+					old_code = NullCode;
+					continue;
+				}
+				if (old_code == NullCode) {
+					pixelStack[top++] = suffix[code];
+					old_code = code;
+					first = code;
+					continue;
+				}
+				in_code = code;
+				if (code == available) {
+					pixelStack[top++] = (byte) first;
+					code = old_code;
+				}
+				while (code > clear) {
+					pixelStack[top++] = suffix[code];
+					code = prefix[code];
+				}
+				first = ((int) suffix[code]) & 0xff;
+				// Add a new string to the string table,
+				if (available >= MaxStackSize) {
+					break;
+				}
+				pixelStack[top++] = (byte) first;
+				prefix[available] = (short) old_code;
+				suffix[available] = (byte) first;
+				available++;
+				if (((available & code_mask) == 0)
+						&& (available < MaxStackSize)) {
+					code_size++;
+					code_mask += available;
+				}
+				old_code = in_code;
+			}
+
+			// Pop a pixel off the pixel stack.
+			top--;
+			pixels[pi++] = pixelStack[top];
+			i++;
+		}
+		for (i = pi; i < npix; i++) {
+			pixels[i] = 0; // clear missing pixels
+		}
+	}
+
+	private boolean err() {
+		return status != STATUS_PARSING;
+	}
+
+	private void init() {
+		status = STATUS_PARSING;
+		frameCount = 0;
+		gifFrame = null;
+		gct = null;
+		lct = null;
+	}
+
+	private int read() {
+		int curByte = 0;
+		try {
+			
+			curByte = in.read();
+		} catch (Exception e) {
+			status = STATUS_FORMAT_ERROR;
+		}
+		return curByte;
+	}
+	
+	private int readBlock() {
+		blockSize = read();
+		int n = 0;
+		if (blockSize > 0) {
+			try {
+				int count = 0;
+				while (n < blockSize) {
+					count = in.read(block, n, blockSize - n);
+					if (count == -1) {
+						break;
+					}
+					n += count;
+				}
+			} catch (Exception e) {
+				e.printStackTrace();
+			}
+			if (n < blockSize) {
+				status = STATUS_FORMAT_ERROR;
+			}
+		}
+		return n;
+	}
+
+	private int[] readColorTable(int ncolors) {
+		int nbytes = 3 * ncolors;
+		int[] tab = null;
+		byte[] c = new byte[nbytes];
+		int n = 0;
+		try {
+			n = in.read(c);
+		} catch (Exception e) {
+			e.printStackTrace();
+		}
+		if (n < nbytes) {
+			status = STATUS_FORMAT_ERROR;
+		} else {
+			tab = new int[256]; // max size to avoid bounds checks
+			int i = 0;
+			int j = 0;
+			while (i < ncolors) {
+				int r = ((int) c[j++]) & 0xff;
+				int g = ((int) c[j++]) & 0xff;
+				int b = ((int) c[j++]) & 0xff;
+				tab[i++] = 0xff000000 | (r << 16) | (g << 8) | b;
+			}
+		}
+		return tab;
+	}
+
+	private void readContents() {
+		// read GIF file content blocks
+		boolean done = false;
+		while (!(done || err())) {
+			int code = read();
+			switch (code) {
+			case 0x2C: // image separator
+				readImage();
+				break;
+			case 0x21: // extension
+				code = read();
+				switch (code) {
+				case 0xf9: // graphics control extension
+					readGraphicControlExt();
+					break;
+				case 0xff: // application extension
+					readBlock();
+					String app = "";
+					for (int i = 0; i < 11; i++) {
+						app += (char) block[i];
+					}
+					if (app.equals("NETSCAPE2.0")) {
+						readNetscapeExt();
+					} else {
+						skip(); // don't care
+					}
+					break;
+				default: // uninteresting extension
+					skip();
+				}
+				break;
+			case 0x3b: // terminator
+				done = true;
+				break;
+			case 0x00: // bad byte, but keep going and see what happens
+				break;
+			default:
+				status = STATUS_FORMAT_ERROR;
+			}
+		}
+	}
+
+	private void readGraphicControlExt() {
+		read(); // block size
+		int packed = read(); // packed fields
+		dispose = (packed & 0x1c) >> 2; // disposal method
+		if (dispose == 0) {
+			dispose = 1; // elect to keep old image if discretionary
+		}
+		transparency = (packed & 1) != 0;
+		delay = readShort() * 10; // delay in milliseconds
+		transIndex = read(); // transparent color index
+		read(); // block terminator
+	}
+
+	private void readHeader() {
+		String id = "";
+		for (int i = 0; i < 6; i++) {
+			id += (char) read();
+		}
+		if (!id.startsWith("GIF")) {
+			status = STATUS_FORMAT_ERROR;
+			return;
+		}
+		readLSD();
+		if (gctFlag && !err()) {
+			gct = readColorTable(gctSize);
+			bgColor = gct[bgIndex];
+		}
+	}
+
+	private void readImage() {
+		ix = readShort(); // (sub)image position & size
+		iy = readShort();
+		iw = readShort();
+		ih = readShort();
+		int packed = read();
+		lctFlag = (packed & 0x80) != 0; // 1 - local color table flag
+		interlace = (packed & 0x40) != 0; // 2 - interlace flag
+		// 3 - sort flag
+		// 4-5 - reserved
+		lctSize = 2 << (packed & 7); // 6-8 - local color table size
+		if (lctFlag) {
+			lct = readColorTable(lctSize); // read table
+			act = lct; // make local table active
+		} else {
+			act = gct; // make global table active
+			if (bgIndex == transIndex) {
+				bgColor = 0;
+			}
+		}
+		int save = 0;
+		if (transparency) {
+			save = act[transIndex];
+			act[transIndex] = 0; // set transparent color if specified
+		}
+		if (act == null) {
+			status = STATUS_FORMAT_ERROR; // no color table defined
+		}
+		if (err()) {
+			return;
+		}
+        try {
+    		decodeImageData(); // decode pixel data
+    		skip();
+    		if (err()) {
+    			return;
+    		}
+    		frameCount++;
+    		// create new image to receive frame data
+    		// createImage(width, height);
+    		Bitmap image = setPixels(); // transfer pixel data to image
+    		if (gifFrame == null) {
+    			gifFrame = new GifFrame(image, delay);
+    			currentFrame = gifFrame;
+    		} else {
+    			GifFrame f = gifFrame;
+    			while(f.nextFrame != null){
+    				f = f.nextFrame;
+    			}
+    			f.nextFrame = new GifFrame(image, delay);
+    		}
+    		// frames.addElement(new GifFrame(image, delay)); // add image to frame
+    		// list
+    		if (transparency) {
+    			act[transIndex] = save;
+    		}
+    		resetFrame();
+    		if (!action.parseOk(true, frameCount)) {
+                status = STATUS_FINISH;
+                return;
+            }
+        }catch (OutOfMemoryError e) {
+            Log.e("GifDecoder", ">>> log  : " + e.toString());
+            e.printStackTrace();
+        }
+	}
+
+	private void readLSD() {
+		// logical screen size
+		width = readShort();
+		height = readShort();
+		// packed fields
+		int packed = read();
+		gctFlag = (packed & 0x80) != 0; // 1 : global color table flag
+		// 2-4 : color resolution
+		// 5 : gct sort flag
+		gctSize = 2 << (packed & 7); // 6-8 : gct size
+		bgIndex = read(); // background color index
+		pixelAspect = read(); // pixel aspect ratio
+	}
+
+	private void readNetscapeExt() {
+		do {
+			readBlock();
+			if (block[0] == 1) {
+				// loop count sub-block
+				int b1 = ((int) block[1]) & 0xff;
+				int b2 = ((int) block[2]) & 0xff;
+				loopCount = (b2 << 8) | b1;
+			}
+		} while ((blockSize > 0) && !err());
+	}
+
+	private int readShort() {
+		// read 16-bit value, LSB first
+		return read() | (read() << 8);
+	}
+
+	private void resetFrame() {
+		lastDispose = dispose;
+		lrx = ix;
+		lry = iy;
+		lrw = iw;
+		lrh = ih;
+        lastPixels = dest;
+		lastBgColor = bgColor;
+		dispose = 0;
+		transparency = false;
+		delay = 0;
+		lct = null;
+	}
+
+	/**
+	 * Skips variable length blocks up to and including next zero length block.
+	 */
+	private void skip() {
+		do {
+			readBlock();
+		} while ((blockSize > 0) && !err());
+	}
+}
diff --git a/src/com/koushikdutta/ion/gif/GifFrame.java b/src/com/koushikdutta/ion/gif/GifFrame.java
new file mode 100755
index 00000000..a81d3bb3
--- /dev/null
+++ b/src/com/koushikdutta/ion/gif/GifFrame.java
@@ -0,0 +1,14 @@
+package com.koushikdutta.ion.gif;
+
+import android.graphics.Bitmap;
+
+public class GifFrame {
+    public GifFrame(Bitmap im, int del) {
+        image = im;
+        delay = del;
+    }
+	
+    public Bitmap image;
+    public int delay;
+    public GifFrame nextFrame = null;
+}
diff --git a/src/com/koushikdutta/ion/gif/README b/src/com/koushikdutta/ion/gif/README
new file mode 100644
index 00000000..b6b8d269
--- /dev/null
+++ b/src/com/koushikdutta/ion/gif/README
@@ -0,0 +1,4 @@
+GIF support comes from Code Aurora Forums:
+https://www.codeaurora.org/cgit/quic/la/platform/packages/apps/Gallery2/tree/src/com/android/gallery3d/util?h=jb_chocolate_rb4.1&id=2b133c9747af26701a12d60caef3e7e14cf55536
+
+Repository is licensed under Apache.
\ No newline at end of file
diff --git a/src/com/koushikdutta/ion/gson/GsonBody.java b/src/com/koushikdutta/ion/gson/GsonBody.java
new file mode 100644
index 00000000..1727090a
--- /dev/null
+++ b/src/com/koushikdutta/ion/gson/GsonBody.java
@@ -0,0 +1,72 @@
+package com.koushikdutta.ion.gson;
+
+import com.google.gson.Gson;
+import com.google.gson.JsonElement;
+import com.koushikdutta.async.DataEmitter;
+import com.koushikdutta.async.DataSink;
+import com.koushikdutta.async.Util;
+import com.koushikdutta.async.callback.CompletedCallback;
+import com.koushikdutta.async.future.FutureCallback;
+import com.koushikdutta.async.http.AsyncHttpRequest;
+import com.koushikdutta.async.http.body.AsyncHttpRequestBody;
+import com.koushikdutta.async.http.body.JSONObjectBody;
+
+import java.io.ByteArrayOutputStream;
+import java.io.OutputStreamWriter;
+
+public class GsonBody<T extends JsonElement> implements AsyncHttpRequestBody<T> {
+    byte[] mBodyBytes;
+    T json;
+    Gson gson;
+    public GsonBody(Gson gson, T json) {
+        this.json = json;
+        this.gson = gson;
+    }
+
+    @Override
+    public void parse(DataEmitter emitter, final CompletedCallback completed) {
+        new GsonParser<T>().parse(emitter).setCallback(new FutureCallback<T>() {
+            @Override
+            public void onCompleted(Exception e, T result) {
+                json = result;
+                completed.onCompleted(e);
+            }
+        });
+    }
+
+    @Override
+    public void write(AsyncHttpRequest request, DataSink sink, final CompletedCallback completed) {
+        if (mBodyBytes == null) {
+            ByteArrayOutputStream bout = new ByteArrayOutputStream();
+            OutputStreamWriter out = new OutputStreamWriter(bout);
+            gson.toJson(json, out);
+            mBodyBytes = bout.toByteArray();
+        }
+        Util.writeAll(sink, mBodyBytes, completed);
+    }
+
+    @Override
+    public String getContentType() {
+        return CONTENT_TYPE;
+    }
+
+    @Override
+    public boolean readFullyOnRequest() {
+        return true;
+    }
+
+    @Override
+    public int length() {
+        if (mBodyBytes == null)
+            mBodyBytes = json.toString().getBytes();
+        return mBodyBytes.length;
+    }
+
+    public static final String CONTENT_TYPE = JSONObjectBody.CONTENT_TYPE;
+
+    @Override
+    public T get() {
+        return json;
+    }
+}
+
diff --git a/src/com/koushikdutta/ion/gson/GsonParser.java b/src/com/koushikdutta/ion/gson/GsonParser.java
new file mode 100644
index 00000000..c51b8ba1
--- /dev/null
+++ b/src/com/koushikdutta/ion/gson/GsonParser.java
@@ -0,0 +1,45 @@
+package com.koushikdutta.ion.gson;
+
+import com.google.gson.JsonElement;
+import com.google.gson.JsonParseException;
+import com.google.gson.JsonParser;
+import com.google.gson.stream.JsonReader;
+import com.koushikdutta.async.ByteBufferList;
+import com.koushikdutta.async.DataEmitter;
+import com.koushikdutta.async.DataSink;
+import com.koushikdutta.async.callback.CompletedCallback;
+import com.koushikdutta.async.future.Future;
+import com.koushikdutta.async.future.TransformFuture;
+import com.koushikdutta.async.parser.AsyncParser;
+import com.koushikdutta.async.parser.ByteBufferListParser;
+import com.koushikdutta.async.parser.StringParser;
+import com.koushikdutta.async.stream.ByteBufferListInputStream;
+
+import java.io.InputStreamReader;
+
+/**
+ * Created by koush on 5/27/13.
+ */
+public class GsonParser<T extends JsonElement> implements AsyncParser<T> {
+    public GsonParser() {
+    }
+    @Override
+    public Future<T> parse(DataEmitter emitter) {
+        return new ByteBufferListParser().parse(emitter)
+        .then(new TransformFuture<T, ByteBufferList>() {
+            @Override
+            protected void transform(ByteBufferList result) throws Exception {
+                JsonParser parser = new JsonParser();
+                T parsed = (T)parser.parse(new JsonReader(new InputStreamReader(new ByteBufferListInputStream(result))));
+                if (parsed.isJsonNull() || parsed.isJsonPrimitive())
+                    throw new JsonParseException("unable to parse json");
+                setComplete(null, parsed);
+            }
+        });
+    }
+
+    @Override
+    public void write(DataSink sink, T value, CompletedCallback completed) {
+        new StringParser().write(sink, value.toString(), completed);
+    }
+}
diff --git a/src/com/koushikdutta/ion/gson/GsonSerializer.java b/src/com/koushikdutta/ion/gson/GsonSerializer.java
new file mode 100644
index 00000000..805aa3ac
--- /dev/null
+++ b/src/com/koushikdutta/ion/gson/GsonSerializer.java
@@ -0,0 +1,62 @@
+package com.koushikdutta.ion.gson;
+
+import com.google.gson.Gson;
+import com.google.gson.reflect.TypeToken;
+import com.google.gson.stream.JsonReader;
+import com.koushikdutta.async.ByteBufferList;
+import com.koushikdutta.async.DataEmitter;
+import com.koushikdutta.async.DataSink;
+import com.koushikdutta.async.Util;
+import com.koushikdutta.async.callback.CompletedCallback;
+import com.koushikdutta.async.future.Future;
+import com.koushikdutta.async.future.TransformFuture;
+import com.koushikdutta.async.parser.AsyncParser;
+import com.koushikdutta.async.parser.ByteBufferListParser;
+import com.koushikdutta.async.stream.ByteBufferListInputStream;
+
+import java.io.ByteArrayOutputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStreamWriter;
+import java.lang.reflect.Type;
+
+/**
+ * Created by koush on 6/1/13.
+ */
+public class GsonSerializer<T> implements AsyncParser<T> {
+    Gson gson;
+    Type type;
+    public GsonSerializer(Gson gson, Class<T> clazz) {
+        this.gson = gson;
+        type = clazz;
+    }
+    public GsonSerializer(Gson gson, TypeToken<T> token) {
+        this.gson = gson;
+        type = token.getType();
+    }
+    @Override
+    public Future<T> parse(DataEmitter emitter) {
+        return new ByteBufferListParser().parse(emitter)
+        .then(new TransformFuture<T, ByteBufferList>() {
+            @Override
+            protected void transform(ByteBufferList result) throws Exception {
+                ByteBufferListInputStream bin = new ByteBufferListInputStream(result);
+                T ret = (T)gson.fromJson(new JsonReader(new InputStreamReader(bin)), type);
+                setComplete(ret);
+            }
+        });
+    }
+
+    @Override
+    public void write(DataSink sink, T pojo, CompletedCallback completed) {
+        ByteArrayOutputStream bout = new ByteArrayOutputStream();
+        OutputStreamWriter out = new OutputStreamWriter(bout);
+        gson.toJson(pojo, type, out);
+        try {
+            out.flush();
+        }
+        catch (final Exception e) {
+            throw new AssertionError(e);
+        }
+        Util.writeAll(sink, bout.toByteArray(), completed);
+    }
+}
diff --git a/src/com/koushikdutta/ion/gson/PojoBody.java b/src/com/koushikdutta/ion/gson/PojoBody.java
new file mode 100644
index 00000000..255244c1
--- /dev/null
+++ b/src/com/koushikdutta/ion/gson/PojoBody.java
@@ -0,0 +1,82 @@
+package com.koushikdutta.ion.gson;
+
+import com.google.gson.Gson;
+import com.google.gson.reflect.TypeToken;
+import com.koushikdutta.async.DataEmitter;
+import com.koushikdutta.async.DataSink;
+import com.koushikdutta.async.Util;
+import com.koushikdutta.async.callback.CompletedCallback;
+import com.koushikdutta.async.http.AsyncHttpRequest;
+import com.koushikdutta.async.http.body.AsyncHttpRequestBody;
+
+import java.io.ByteArrayOutputStream;
+import java.io.OutputStreamWriter;
+import java.lang.reflect.Type;
+
+/**
+ * Created by koush on 6/5/13.
+ */
+public class PojoBody<T> implements AsyncHttpRequestBody<T> {
+    T pojo;
+    byte[] bodyBytes;
+    Type type;
+    Gson gson;
+    public PojoBody(Gson gson, T pojo, TypeToken<T> token) {
+        this.pojo = pojo;
+        if (token != null)
+            this.type = token.getType();
+        this.gson = gson;
+    }
+
+    byte[] getBodyBytes() {
+        if (bodyBytes != null)
+            return bodyBytes;
+        ByteArrayOutputStream bout = new ByteArrayOutputStream();
+        OutputStreamWriter out = new OutputStreamWriter(bout);
+        if (type == null)
+            gson.toJson(pojo, out);
+        else
+            gson.toJson(pojo, type, out);
+        try {
+            out.flush();
+            bout.flush();
+        }
+        catch (Exception e) {
+
+        }
+        bodyBytes = bout.toByteArray();
+        return bodyBytes;
+    }
+
+    @Override
+    public void write(AsyncHttpRequest request, DataSink sink, final CompletedCallback completed) {
+        Util.writeAll(sink, getBodyBytes(), completed);
+    }
+
+    @Override
+    public void parse(DataEmitter emitter, CompletedCallback completed) {
+
+    }
+
+    @Override
+    public String getContentType() {
+        return CONTENT_TYPE;
+    }
+
+    @Override
+    public boolean readFullyOnRequest() {
+        return true;
+    }
+
+    @Override
+    public int length() {
+        return getBodyBytes().length;
+    }
+
+    @Override
+    public T get() {
+        return pojo;
+    }
+
+    public static final String CONTENT_TYPE = "application/json";
+}
diff --git a/src/com/koushikdutta/ion/loader/AsyncHttpRequestFactory.java b/src/com/koushikdutta/ion/loader/AsyncHttpRequestFactory.java
new file mode 100644
index 00000000..3573598c
--- /dev/null
+++ b/src/com/koushikdutta/ion/loader/AsyncHttpRequestFactory.java
@@ -0,0 +1,13 @@
+package com.koushikdutta.ion.loader;
+
+import com.koushikdutta.async.http.AsyncHttpRequest;
+import com.koushikdutta.async.http.libcore.RawHeaders;
+
+import java.net.URI;
+
+/**
+ * Created by koush on 7/15/13.
+ */
+public interface AsyncHttpRequestFactory {
+    public AsyncHttpRequest createAsyncHttpRequest(URI uri, String method, RawHeaders headers);
+}
diff --git a/src/com/koushikdutta/ion/loader/ContentLoader.java b/src/com/koushikdutta/ion/loader/ContentLoader.java
new file mode 100644
index 00000000..06354e14
--- /dev/null
+++ b/src/com/koushikdutta/ion/loader/ContentLoader.java
@@ -0,0 +1,49 @@
+package com.koushikdutta.ion.loader;
+
+import android.net.Uri;
+import com.koushikdutta.async.DataEmitter;
+import com.koushikdutta.async.future.Future;
+import com.koushikdutta.async.future.FutureCallback;
+import com.koushikdutta.async.future.SimpleFuture;
+import com.koushikdutta.async.http.AsyncHttpRequest;
+import com.koushikdutta.async.stream.InputStreamDataEmitter;
+import com.koushikdutta.ion.Ion;
+import com.koushikdutta.ion.Loader;
+import com.koushikdutta.ion.bitmap.BitmapInfo;
+
+import java.io.InputStream;
+
+/**
+ * Created by koush on 5/22/13.
+ */
+public class ContentLoader extends SimpleLoader {
+    private static final class InputStreamDataEmitterFuture extends SimpleFuture<DataEmitter> {
+    }
+
+    @Override
+    public Future<DataEmitter> load(final Ion ion, final AsyncHttpRequest request, final FutureCallback<LoaderEmitter> callback) {
+        if (!request.getUri().getScheme().startsWith("content"))
+            return null;
+
+        final InputStreamDataEmitterFuture ret = new InputStreamDataEmitterFuture();
+        ion.getHttpClient().getServer().post(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    InputStream stream = ion.getContext().getContentResolver().openInputStream(Uri.parse(request.getUri().toString()));
+                    if (stream == null)
+                        throw new Exception("Unable to load content stream");
+                    int available = stream.available();
+                    InputStreamDataEmitter emitter = new InputStreamDataEmitter(ion.getHttpClient().getServer(), stream);
+                    ret.setComplete(emitter);
+                    callback.onCompleted(null, new LoaderEmitter(emitter, available, LoaderEmitter.LOADED_FROM_CACHE, null, null));
+                }
+                catch (Exception e) {
+                    ret.setComplete(e);
+                    callback.onCompleted(e, null);
+                }
+            }
+        });
+        return ret;
+    }
+}
diff --git a/src/com/koushikdutta/ion/loader/FileLoader.java b/src/com/koushikdutta/ion/loader/FileLoader.java
new file mode 100644
index 00000000..5b6444da
--- /dev/null
+++ b/src/com/koushikdutta/ion/loader/FileLoader.java
@@ -0,0 +1,138 @@
+package com.koushikdutta.ion.loader;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.Point;
+import android.text.TextUtils;
+
+import com.koushikdutta.async.DataEmitter;
+import com.koushikdutta.async.FileDataEmitter;
+import com.koushikdutta.async.future.Future;
+import com.koushikdutta.async.future.FutureCallback;
+import com.koushikdutta.async.future.SimpleFuture;
+import com.koushikdutta.async.http.AsyncHttpRequest;
+import com.koushikdutta.async.util.StreamUtility;
+import com.koushikdutta.ion.Ion;
+import com.koushikdutta.ion.Loader;
+import com.koushikdutta.ion.bitmap.BitmapInfo;
+import com.koushikdutta.ion.gif.GifAction;
+import com.koushikdutta.ion.gif.GifDecoder;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.InputStream;
+import java.net.URI;
+
+/**
+ * Created by koush on 5/22/13.
+ */
+public class FileLoader extends SimpleLoader {
+    private static final class FileFuture extends SimpleFuture<DataEmitter> {
+    }
+
+    @Override
+    public Future<BitmapInfo> loadBitmap(final Context context, final Ion ion, final String key, final String uri, final int resizeWidth, final int resizeHeight,
+                                         final boolean animateGif) {
+        if (uri == null || !uri.startsWith("file:/"))
+            return null;
+
+        final SimpleFuture<BitmapInfo> ret = new SimpleFuture<BitmapInfo>();
+
+//        Log.d("FileLoader", "Loading file bitmap " + uri + " " + resizeWidth + "," + resizeHeight);
+        Ion.getBitmapLoadExecutorService().execute(new Runnable() {
+            @Override
+            public void run() {
+                if (ret.isCancelled()) {
+//                    Log.d("FileLoader", "Bitmap load cancelled (no longer needed)");
+                    return;
+                }
+                try {
+                    File file = new File(URI.create(uri));
+                    BitmapFactory.Options options = ion.getBitmapCache().prepareBitmapOptions(file, resizeWidth, resizeHeight);
+                    if (options == null)
+                        throw new Exception("BitmapFactory.Options failed to load");
+                    Point size = new Point(options.outWidth, options.outHeight);
+                    Bitmap[] bitmaps;
+                    int[] delays;
+                    if (animateGif && TextUtils.equals("image/gif", options.outMimeType)) {
+                        FileInputStream fin = new FileInputStream(file);
+                        GifDecoder decoder = new GifDecoder(fin, new GifAction() {
+                            @Override
+                            public boolean parseOk(boolean parseStatus, int frameIndex) {
+                                return animateGif;
+                            }
+                        });
+                        decoder.run();
+                        StreamUtility.closeQuietly(fin);
+                        if (decoder.getFrameCount() == 0)
+                            throw new Exception("failed to load gif");
+                        bitmaps = new Bitmap[decoder.getFrameCount()];
+                        delays = decoder.getDelays();
+                        for (int i = 0; i < decoder.getFrameCount(); i++) {
+                            Bitmap bitmap = decoder.getFrameImage(i);
+                            if (bitmap == null)
+                                throw new Exception("failed to load gif frame");
+                            bitmaps[i] = bitmap;
+                        }
+                    }
+                    else {
+                        Bitmap bitmap = ion.getBitmapCache().loadBitmap(file, options);
+                        if (bitmap == null)
+                            throw new Exception("Bitmap failed to load");
+                        bitmaps = new Bitmap[] { bitmap };
+                        delays = null;
+                    }
+                    BitmapInfo info = new BitmapInfo(key, options.outMimeType, bitmaps, size);
+                    info.delays = delays;
+                    info.loadedFrom =  Loader.LoaderEmitter.LOADED_FROM_CACHE;
+                    ret.setComplete(info);
+                }
+                catch (OutOfMemoryError e) {
+                    ret.setComplete(new Exception(e), null);
+                }
+                catch (Exception e) {
+                    ret.setComplete(e);
+                }
+            }
+        });
+
+        return ret;
+    }
+
+    @Override
+    public Future<InputStream> load(final Ion ion, final AsyncHttpRequest request) {
+        if (!request.getUri().getScheme().startsWith("file"))
+            return null;
+        final SimpleFuture<InputStream> ret = new SimpleFuture<InputStream>();
+        Ion.getIoExecutorService().execute(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    InputStream stream = new FileInputStream(new File(request.getUri()));
+                    ret.setComplete(stream);
+                } catch (Exception e) {
+                    ret.setComplete(e);
+                }
+            }
+        });
+        return ret;
+    }
+
+    @Override
+    public Future<DataEmitter> load(final Ion ion, final AsyncHttpRequest request, final FutureCallback<LoaderEmitter> callback) {
+        if (!request.getUri().getScheme().startsWith("file"))
+            return null;
+        final FileFuture ret = new FileFuture();
+        ion.getHttpClient().getServer().post(new Runnable() {
+            @Override
+            public void run() {
+                File file = new File(request.getUri());
+                FileDataEmitter emitter = new FileDataEmitter(ion.getHttpClient().getServer(), file);
+                ret.setComplete(emitter);
+                callback.onCompleted(null, new LoaderEmitter(emitter, (int)file.length(), LoaderEmitter.LOADED_FROM_CACHE, null, request));
+            }
+        });
+        return ret;
+    }
+}
diff --git a/src/com/koushikdutta/ion/loader/HttpLoader.java b/src/com/koushikdutta/ion/loader/HttpLoader.java
new file mode 100644
index 00000000..d01dea56
--- /dev/null
+++ b/src/com/koushikdutta/ion/loader/HttpLoader.java
@@ -0,0 +1,45 @@
+package com.koushikdutta.ion.loader;
+
+import android.text.TextUtils;
+
+import com.koushikdutta.async.DataEmitter;
+import com.koushikdutta.async.future.Future;
+import com.koushikdutta.async.future.FutureCallback;
+import com.koushikdutta.async.http.AsyncHttpRequest;
+import com.koushikdutta.async.http.AsyncHttpResponse;
+import com.koushikdutta.async.http.ResponseCacheMiddleware;
+import com.koushikdutta.async.http.callback.HttpConnectCallback;
+import com.koushikdutta.async.http.libcore.RawHeaders;
+import com.koushikdutta.ion.Ion;
+
+/**
+ * Created by koush on 5/22/13.
+ */
+public class HttpLoader extends SimpleLoader {
+    @SuppressWarnings("unchecked")
+    @Override
+    public Future<DataEmitter> load(Ion ion, AsyncHttpRequest request, final FutureCallback<LoaderEmitter> callback) {
+        if (!request.getUri().getScheme().startsWith("http"))
+            return null;
+        return (Future< DataEmitter >)(Future)ion.getHttpClient().execute(request, new HttpConnectCallback() {
+            @Override
+            public void onConnectCompleted(Exception ex, AsyncHttpResponse response) {
+                int length = -1;
+                int loadedFrom = LoaderEmitter.LOADED_FROM_NETWORK;
+                RawHeaders headers = null;
+                AsyncHttpRequest request = null;
+                if (response != null) {
+                    request = response.getRequest();
+                    headers = response.getHeaders().getHeaders();
+                    length = response.getHeaders().getContentLength();
+                    String servedFrom = response.getHeaders().getHeaders().get(ResponseCacheMiddleware.SERVED_FROM);
+                    if (TextUtils.equals(servedFrom, ResponseCacheMiddleware.CACHE))
+                        loadedFrom = LoaderEmitter.LOADED_FROM_CACHE;
+                    else if (TextUtils.equals(servedFrom, ResponseCacheMiddleware.CONDITIONAL_CACHE))
+                        loadedFrom = LoaderEmitter.LOADED_FROM_CONDITIONAL_CACHE;
+                }
+                callback.onCompleted(ex, new LoaderEmitter(response, length, loadedFrom, headers, request));
+            }
+        });
+    }
+}
diff --git a/src/com/koushikdutta/ion/loader/MediaFile.java b/src/com/koushikdutta/ion/loader/MediaFile.java
new file mode 100644
index 00000000..b8a96832
--- /dev/null
+++ b/src/com/koushikdutta/ion/loader/MediaFile.java
@@ -0,0 +1,364 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ * Copyright (c) 2012, The Linux Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.koushikdutta.ion.loader;
+
+import java.util.HashMap;
+import java.util.Locale;
+
+/**
+ * MediaScanner helper class.
+ *
+ * {@hide}
+ */
+public class MediaFile {
+
+    // Audio file types
+    public static final int FILE_TYPE_MP3     = 1;
+    public static final int FILE_TYPE_M4A     = 2;
+    public static final int FILE_TYPE_WAV     = 3;
+    public static final int FILE_TYPE_AMR     = 4;
+    public static final int FILE_TYPE_AWB     = 5;
+    public static final int FILE_TYPE_WMA     = 6;
+    public static final int FILE_TYPE_OGG     = 7;
+    public static final int FILE_TYPE_AAC     = 8;
+    public static final int FILE_TYPE_MKA     = 9;
+    public static final int FILE_TYPE_FLAC    = 10;
+    public static final int FILE_TYPE_3GPA    = 11;
+    public static final int FILE_TYPE_AC3     = 12;
+    public static final int FILE_TYPE_QCP     = 13;
+    public static final int FILE_TYPE_WEBMA   = 14;
+    public static final int FILE_TYPE_PCM     = 15;
+    public static final int FILE_TYPE_EC3     = 16;
+    private static final int FIRST_AUDIO_FILE_TYPE = FILE_TYPE_MP3;
+    private static final int LAST_AUDIO_FILE_TYPE = FILE_TYPE_EC3;
+
+    // More audio file types
+    public static final int FILE_TYPE_DTS   = 300;
+    private static final int FIRST_AUDIO_FILE_TYPE2 = FILE_TYPE_DTS;
+    private static final int LAST_AUDIO_FILE_TYPE2 = FILE_TYPE_DTS;
+
+    // MIDI file types
+    public static final int FILE_TYPE_MID     = 17;
+    public static final int FILE_TYPE_SMF     = 18;
+    public static final int FILE_TYPE_IMY     = 19;
+    private static final int FIRST_MIDI_FILE_TYPE = FILE_TYPE_MID;
+    private static final int LAST_MIDI_FILE_TYPE = FILE_TYPE_IMY;
+
+    // Video file types
+    public static final int FILE_TYPE_MP4     = 21;
+    public static final int FILE_TYPE_M4V     = 22;
+    public static final int FILE_TYPE_3GPP    = 23;
+    public static final int FILE_TYPE_3GPP2   = 24;
+    public static final int FILE_TYPE_WMV     = 25;
+    public static final int FILE_TYPE_ASF     = 26;
+    public static final int FILE_TYPE_MKV     = 27;
+    public static final int FILE_TYPE_MP2TS   = 28;
+    public static final int FILE_TYPE_AVI     = 29;
+    public static final int FILE_TYPE_WEBM    = 30;
+    public static final int FILE_TYPE_DIVX    = 31;
+    private static final int FIRST_VIDEO_FILE_TYPE = FILE_TYPE_MP4;
+    private static final int LAST_VIDEO_FILE_TYPE = FILE_TYPE_DIVX;
+
+    // More video file types
+    public static final int FILE_TYPE_MP2PS   = 200;
+    private static final int FIRST_VIDEO_FILE_TYPE2 = FILE_TYPE_MP2PS;
+    private static final int LAST_VIDEO_FILE_TYPE2 = FILE_TYPE_MP2PS;
+
+    // Image file types
+    public static final int FILE_TYPE_JPEG    = 32;
+    public static final int FILE_TYPE_GIF     = 33;
+    public static final int FILE_TYPE_PNG     = 34;
+    public static final int FILE_TYPE_BMP     = 35;
+    public static final int FILE_TYPE_WBMP    = 36;
+    public static final int FILE_TYPE_WEBP    = 37;
+    private static final int FIRST_IMAGE_FILE_TYPE = FILE_TYPE_JPEG;
+    private static final int LAST_IMAGE_FILE_TYPE = FILE_TYPE_WEBP;
+
+    // Playlist file types
+    public static final int FILE_TYPE_M3U      = 41;
+    public static final int FILE_TYPE_PLS      = 42;
+    public static final int FILE_TYPE_WPL      = 43;
+    public static final int FILE_TYPE_HTTPLIVE = 44;
+
+    private static final int FIRST_PLAYLIST_FILE_TYPE = FILE_TYPE_M3U;
+    private static final int LAST_PLAYLIST_FILE_TYPE = FILE_TYPE_HTTPLIVE;
+
+    // Drm file types
+    public static final int FILE_TYPE_FL      = 51;
+    private static final int FIRST_DRM_FILE_TYPE = FILE_TYPE_FL;
+    private static final int LAST_DRM_FILE_TYPE = FILE_TYPE_FL;
+
+    // Other popular file types
+    public static final int FILE_TYPE_TEXT          = 100;
+    public static final int FILE_TYPE_HTML          = 101;
+    public static final int FILE_TYPE_PDF           = 102;
+    public static final int FILE_TYPE_XML           = 103;
+    public static final int FILE_TYPE_MS_WORD       = 104;
+    public static final int FILE_TYPE_MS_EXCEL      = 105;
+    public static final int FILE_TYPE_MS_POWERPOINT = 106;
+    public static final int FILE_TYPE_ZIP           = 107;
+
+    public static class MediaFileType {
+        public final int fileType;
+        public final String mimeType;
+
+        MediaFileType(int fileType, String mimeType) {
+            this.fileType = fileType;
+            this.mimeType = mimeType;
+        }
+    }
+
+    private static final HashMap<String, MediaFileType> sFileTypeMap
+            = new HashMap<String, MediaFileType>();
+    private static final HashMap<String, Integer> sMimeTypeMap
+            = new HashMap<String, Integer>();
+    // maps file extension to MTP format code
+    private static final HashMap<String, Integer> sFileTypeToFormatMap
+            = new HashMap<String, Integer>();
+    // maps mime type to MTP format code
+    private static final HashMap<String, Integer> sMimeTypeToFormatMap
+            = new HashMap<String, Integer>();
+    // maps MTP format code to mime type
+    private static final HashMap<Integer, String> sFormatToMimeTypeMap
+            = new HashMap<Integer, String>();
+    private static final HashMap<String, String> sMimeTypeToExtensionMap
+            = new HashMap<String, String>();
+
+    static void addFileType(String extension, int fileType, String mimeType) {
+        sFileTypeMap.put(extension, new MediaFileType(fileType, mimeType));
+        sMimeTypeMap.put(mimeType, Integer.valueOf(fileType));
+    }
+
+    static void addFileType(String extension, int fileType, String mimeType, int mtpFormatCode) {
+        addFileType(extension, fileType, mimeType);
+        sFileTypeToFormatMap.put(extension, Integer.valueOf(mtpFormatCode));
+        sMimeTypeToFormatMap.put(mimeType, Integer.valueOf(mtpFormatCode));
+        sFormatToMimeTypeMap.put(mtpFormatCode, mimeType);
+        sMimeTypeToExtensionMap.put(mimeType, extension);
+    }
+
+    /*
+    private static boolean isWMAEnabled() {
+        List<AudioDecoder> decoders = DecoderCapabilities.getAudioDecoders();
+        int count = decoders.size();
+        for (int i = 0; i < count; i++) {
+            AudioDecoder decoder = decoders.get(i);
+            if (decoder == AudioDecoder.AUDIO_DECODER_WMA) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private static boolean isWMVEnabled() {
+        List<VideoDecoder> decoders = DecoderCapabilities.getVideoDecoders();
+        int count = decoders.size();
+        for (int i = 0; i < count; i++) {
+            VideoDecoder decoder = decoders.get(i);
+            if (decoder == VideoDecoder.VIDEO_DECODER_WMV) {
+                return true;
+            }
+        }
+        return false;
+    }
+    */
+
+    static {
+        addFileType("MP3", FILE_TYPE_MP3, "audio/mpeg", MtpConstants.FORMAT_MP3);
+        addFileType("MPGA", FILE_TYPE_MP3, "audio/mpeg", MtpConstants.FORMAT_MP3);
+        addFileType("M4A", FILE_TYPE_M4A, "audio/mp4", MtpConstants.FORMAT_MPEG);
+        addFileType("WAV", FILE_TYPE_WAV, "audio/x-wav", MtpConstants.FORMAT_WAV);
+        addFileType("WAV", FILE_TYPE_PCM, "audio/wav");
+        addFileType("AMR", FILE_TYPE_AMR, "audio/amr");
+        addFileType("AWB", FILE_TYPE_AWB, "audio/amr-wb");
+        addFileType("DIVX", FILE_TYPE_DIVX, "video/divx");
+        /*
+        if (isWMAEnabled()) {
+            addFileType("WMA", FILE_TYPE_WMA, "audio/x-ms-wma", MtpConstants.FORMAT_WMA);
+        }
+        */
+        addFileType("QCP", FILE_TYPE_QCP, "audio/qcelp");
+        addFileType("OGG", FILE_TYPE_OGG, "audio/ogg", MtpConstants.FORMAT_OGG);
+        addFileType("OGG", FILE_TYPE_OGG, "application/ogg", MtpConstants.FORMAT_OGG);
+        addFileType("OGA", FILE_TYPE_OGG, "audio/ogg", MtpConstants.FORMAT_OGG);
+        addFileType("OGA", FILE_TYPE_OGG, "application/ogg", MtpConstants.FORMAT_OGG);
+        addFileType("AAC", FILE_TYPE_AAC, "audio/aac", MtpConstants.FORMAT_AAC);
+        addFileType("AAC", FILE_TYPE_AAC, "audio/aac-adts", MtpConstants.FORMAT_AAC);
+        addFileType("MKA", FILE_TYPE_MKA, "audio/x-matroska");
+
+        addFileType("MID", FILE_TYPE_MID, "audio/midi");
+        addFileType("MIDI", FILE_TYPE_MID, "audio/midi");
+        addFileType("XMF", FILE_TYPE_MID, "audio/midi");
+        addFileType("RTTTL", FILE_TYPE_MID, "audio/midi");
+        addFileType("SMF", FILE_TYPE_SMF, "audio/sp-midi");
+        addFileType("IMY", FILE_TYPE_IMY, "audio/imelody");
+        addFileType("RTX", FILE_TYPE_MID, "audio/midi");
+        addFileType("OTA", FILE_TYPE_MID, "audio/midi");
+        addFileType("MXMF", FILE_TYPE_MID, "audio/midi");
+
+        addFileType("MPEG", FILE_TYPE_MP4, "video/mpeg", MtpConstants.FORMAT_MPEG);
+        addFileType("MPG", FILE_TYPE_MP4, "video/mpeg", MtpConstants.FORMAT_MPEG);
+        addFileType("MP4", FILE_TYPE_MP4, "video/mp4", MtpConstants.FORMAT_MPEG);
+        addFileType("M4V", FILE_TYPE_M4V, "video/m4v", MtpConstants.FORMAT_MPEG);
+        addFileType("3GP", FILE_TYPE_3GPP, "video/3gpp",  MtpConstants.FORMAT_3GP_CONTAINER);
+        addFileType("3GPP", FILE_TYPE_3GPP, "video/3gpp", MtpConstants.FORMAT_3GP_CONTAINER);
+        addFileType("3G2", FILE_TYPE_3GPP2, "video/3gpp2", MtpConstants.FORMAT_3GP_CONTAINER);
+        addFileType("3GPP2", FILE_TYPE_3GPP2, "video/3gpp2", MtpConstants.FORMAT_3GP_CONTAINER);
+        addFileType("MKV", FILE_TYPE_MKV, "video/x-matroska");
+        addFileType("WEBM", FILE_TYPE_WEBM, "video/webm");
+        addFileType("TS", FILE_TYPE_MP2TS, "video/mp2ts");
+        addFileType("MPG", FILE_TYPE_MP2TS, "video/mp2ts");
+
+        addFileType("AVI", FILE_TYPE_AVI, "video/avi");
+
+        /*
+        if (isWMVEnabled()) {
+            addFileType("WMV", FILE_TYPE_WMV, "video/x-ms-wmv", MtpConstants.FORMAT_WMV);
+            addFileType("ASF", FILE_TYPE_ASF, "video/x-ms-asf");
+        }
+        */
+
+        addFileType("JPG", FILE_TYPE_JPEG, "image/jpeg", MtpConstants.FORMAT_EXIF_JPEG);
+        addFileType("JPEG", FILE_TYPE_JPEG, "image/jpeg", MtpConstants.FORMAT_EXIF_JPEG);
+        addFileType("GIF", FILE_TYPE_GIF, "image/gif", MtpConstants.FORMAT_GIF);
+        addFileType("PNG", FILE_TYPE_PNG, "image/png", MtpConstants.FORMAT_PNG);
+        addFileType("BMP", FILE_TYPE_BMP, "image/x-ms-bmp", MtpConstants.FORMAT_BMP);
+        addFileType("WBMP", FILE_TYPE_WBMP, "image/vnd.wap.wbmp");
+        addFileType("WEBP", FILE_TYPE_WEBP, "image/webp");
+
+        addFileType("M3U", FILE_TYPE_M3U, "audio/x-mpegurl", MtpConstants.FORMAT_M3U_PLAYLIST);
+        addFileType("M3U", FILE_TYPE_M3U, "application/x-mpegurl", MtpConstants.FORMAT_M3U_PLAYLIST);
+        addFileType("PLS", FILE_TYPE_PLS, "audio/x-scpls", MtpConstants.FORMAT_PLS_PLAYLIST);
+        addFileType("WPL", FILE_TYPE_WPL, "application/vnd.ms-wpl", MtpConstants.FORMAT_WPL_PLAYLIST);
+        addFileType("M3U8", FILE_TYPE_HTTPLIVE, "application/vnd.apple.mpegurl");
+        addFileType("M3U8", FILE_TYPE_HTTPLIVE, "audio/mpegurl");
+        addFileType("M3U8", FILE_TYPE_HTTPLIVE, "audio/x-mpegurl");
+
+        addFileType("FL", FILE_TYPE_FL, "application/x-android-drm-fl");
+
+        addFileType("TXT", FILE_TYPE_TEXT, "text/plain", MtpConstants.FORMAT_TEXT);
+        addFileType("HTM", FILE_TYPE_HTML, "text/html", MtpConstants.FORMAT_HTML);
+        addFileType("HTML", FILE_TYPE_HTML, "text/html", MtpConstants.FORMAT_HTML);
+        addFileType("PDF", FILE_TYPE_PDF, "application/pdf");
+        addFileType("DOC", FILE_TYPE_MS_WORD, "application/msword", MtpConstants.FORMAT_MS_WORD_DOCUMENT);
+        addFileType("XLS", FILE_TYPE_MS_EXCEL, "application/vnd.ms-excel", MtpConstants.FORMAT_MS_EXCEL_SPREADSHEET);
+        addFileType("PPT", FILE_TYPE_MS_POWERPOINT, "application/mspowerpoint", MtpConstants.FORMAT_MS_POWERPOINT_PRESENTATION);
+        addFileType("FLAC", FILE_TYPE_FLAC, "audio/flac", MtpConstants.FORMAT_FLAC);
+        addFileType("ZIP", FILE_TYPE_ZIP, "application/zip");
+        addFileType("MPG", FILE_TYPE_MP2PS, "video/mp2p");
+        addFileType("MPEG", FILE_TYPE_MP2PS, "video/mp2p");
+    }
+
+    public static boolean isAudioFileType(int fileType) {
+        return ((fileType >= FIRST_AUDIO_FILE_TYPE &&
+                fileType <= LAST_AUDIO_FILE_TYPE) ||
+                (fileType >= FIRST_MIDI_FILE_TYPE &&
+                fileType <= LAST_MIDI_FILE_TYPE) ||
+                (fileType >= FIRST_AUDIO_FILE_TYPE2 &&
+                fileType <= LAST_AUDIO_FILE_TYPE2));
+    }
+
+    public static boolean isVideoFileType(int fileType) {
+        return (fileType >= FIRST_VIDEO_FILE_TYPE &&
+                fileType <= LAST_VIDEO_FILE_TYPE)
+            || (fileType >= FIRST_VIDEO_FILE_TYPE2 &&
+                fileType <= LAST_VIDEO_FILE_TYPE2);
+    }
+
+    public static boolean isImageFileType(int fileType) {
+        return (fileType >= FIRST_IMAGE_FILE_TYPE &&
+                fileType <= LAST_IMAGE_FILE_TYPE);
+    }
+
+    public static boolean isPlayListFileType(int fileType) {
+        return (fileType >= FIRST_PLAYLIST_FILE_TYPE &&
+                fileType <= LAST_PLAYLIST_FILE_TYPE);
+    }
+
+    public static boolean isDrmFileType(int fileType) {
+        return (fileType >= FIRST_DRM_FILE_TYPE &&
+                fileType <= LAST_DRM_FILE_TYPE);
+    }
+
+    public static MediaFileType getFileType(String path) {
+        int lastDot = path.lastIndexOf('.');
+        if (lastDot < 0)
+            return null;
+        return sFileTypeMap.get(path.substring(lastDot + 1).toUpperCase(Locale.ROOT));
+    }
+
+    public static boolean isMimeTypeMedia(String mimeType) {
+        int fileType = getFileTypeForMimeType(mimeType);
+        return isAudioFileType(fileType) || isVideoFileType(fileType)
+                || isImageFileType(fileType) || isPlayListFileType(fileType);
+    }
+
+    public static String getExtensionForMimeType(String mimeType) {
+        return sMimeTypeToExtensionMap.get(mimeType).toLowerCase();
+    }
+
+    // generates a title based on file name
+    public static String getFileTitle(String path) {
+        // extract file name after last slash
+        int lastSlash = path.lastIndexOf('/');
+        if (lastSlash >= 0) {
+            lastSlash++;
+            if (lastSlash < path.length()) {
+                path = path.substring(lastSlash);
+            }
+        }
+        // truncate the file extension (if any)
+        int lastDot = path.lastIndexOf('.');
+        if (lastDot > 0) {
+            path = path.substring(0, lastDot);
+        }
+        return path;
+    }
+
+    public static int getFileTypeForMimeType(String mimeType) {
+        Integer value = sMimeTypeMap.get(mimeType);
+        return (value == null ? 0 : value.intValue());
+    }
+
+    public static String getMimeTypeForFile(String path) {
+        MediaFileType mediaFileType = getFileType(path);
+        return (mediaFileType == null ? null : mediaFileType.mimeType);
+    }
+
+    public static int getFormatCode(String fileName, String mimeType) {
+        if (mimeType != null) {
+            Integer value = sMimeTypeToFormatMap.get(mimeType);
+            if (value != null) {
+                return value.intValue();
+            }
+        }
+        int lastDot = fileName.lastIndexOf('.');
+        if (lastDot > 0) {
+            String extension = fileName.substring(lastDot + 1).toUpperCase(Locale.ROOT);
+            Integer value = sFileTypeToFormatMap.get(extension);
+            if (value != null) {
+                return value.intValue();
+            }
+        }
+        return MtpConstants.FORMAT_UNDEFINED;
+    }
+
+    public static String getMimeTypeForFormatCode(int formatCode) {
+        return sFormatToMimeTypeMap.get(formatCode);
+    }
+}
diff --git a/src/com/koushikdutta/ion/loader/MtpConstants.java b/src/com/koushikdutta/ion/loader/MtpConstants.java
new file mode 100644
index 00000000..6aaf9f96
--- /dev/null
+++ b/src/com/koushikdutta/ion/loader/MtpConstants.java
@@ -0,0 +1,578 @@
+package com.koushikdutta.ion.loader;
+
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+/**
+ * A class containing constants in the MTP and PTP specifications.
+ */
+public final class MtpConstants {
+
+    // MTP Data Types
+    /** @hide */
+    public static final int TYPE_UNDEFINED = 0x0000;
+    /** @hide */
+    public static final int TYPE_INT8 = 0x0001;
+    /** @hide */
+    public static final int TYPE_UINT8 = 0x0002;
+    /** @hide */
+    public static final int TYPE_INT16 = 0x0003;
+    /** @hide */
+    public static final int TYPE_UINT16 = 0x0004;
+    /** @hide */
+    public static final int TYPE_INT32 = 0x0005;
+    /** @hide */
+    public static final int TYPE_UINT32 = 0x0006;
+    /** @hide */
+    public static final int TYPE_INT64 = 0x0007;
+    /** @hide */
+    public static final int TYPE_UINT64 = 0x0008;
+    /** @hide */
+    public static final int TYPE_INT128 = 0x0009;
+    /** @hide */
+    public static final int TYPE_UINT128 = 0x000A;
+    /** @hide */
+    public static final int TYPE_AINT8 = 0x4001;
+    /** @hide */
+    public static final int TYPE_AUINT8 = 0x4002;
+    /** @hide */
+    public static final int TYPE_AINT16 = 0x4003;
+    /** @hide */
+    public static final int TYPE_AUINT16 = 0x4004;
+    /** @hide */
+    public static final int TYPE_AINT32 = 0x4005;
+    /** @hide */
+    public static final int TYPE_AUINT32 = 0x4006;
+    /** @hide */
+    public static final int TYPE_AINT64 = 0x4007;
+    /** @hide */
+    public static final int TYPE_AUINT64 = 0x4008;
+    /** @hide */
+    public static final int TYPE_AINT128 = 0x4009;
+    /** @hide */
+    public static final int TYPE_AUINT128 = 0x400A;
+    /** @hide */
+    public static final int TYPE_STR = 0xFFFF;
+
+    // MTP Response Codes
+    /** @hide */
+    public static final int RESPONSE_UNDEFINED = 0x2000;
+    /** @hide */
+    public static final int RESPONSE_OK = 0x2001;
+    /** @hide */
+    public static final int RESPONSE_GENERAL_ERROR = 0x2002;
+    /** @hide */
+    public static final int RESPONSE_SESSION_NOT_OPEN = 0x2003;
+    /** @hide */
+    public static final int RESPONSE_INVALID_TRANSACTION_ID = 0x2004;
+    /** @hide */
+    public static final int RESPONSE_OPERATION_NOT_SUPPORTED = 0x2005;
+    /** @hide */
+    public static final int RESPONSE_PARAMETER_NOT_SUPPORTED = 0x2006;
+    /** @hide */
+    public static final int RESPONSE_INCOMPLETE_TRANSFER = 0x2007;
+    /** @hide */
+    public static final int RESPONSE_INVALID_STORAGE_ID = 0x2008;
+    /** @hide */
+    public static final int RESPONSE_INVALID_OBJECT_HANDLE = 0x2009;
+    /** @hide */
+    public static final int RESPONSE_DEVICE_PROP_NOT_SUPPORTED = 0x200A;
+    /** @hide */
+    public static final int RESPONSE_INVALID_OBJECT_FORMAT_CODE = 0x200B;
+    /** @hide */
+    public static final int RESPONSE_STORAGE_FULL = 0x200C;
+    /** @hide */
+    public static final int RESPONSE_OBJECT_WRITE_PROTECTED = 0x200D;
+    /** @hide */
+    public static final int RESPONSE_STORE_READ_ONLY = 0x200E;
+    /** @hide */
+    public static final int RESPONSE_ACCESS_DENIED = 0x200F;
+    /** @hide */
+    public static final int RESPONSE_NO_THUMBNAIL_PRESENT = 0x2010;
+    /** @hide */
+    public static final int RESPONSE_SELF_TEST_FAILED = 0x2011;
+    /** @hide */
+    public static final int RESPONSE_PARTIAL_DELETION = 0x2012;
+    /** @hide */
+    public static final int RESPONSE_STORE_NOT_AVAILABLE = 0x2013;
+    /** @hide */
+    public static final int RESPONSE_SPECIFICATION_BY_FORMAT_UNSUPPORTED = 0x2014;
+    /** @hide */
+    public static final int RESPONSE_NO_VALID_OBJECT_INFO = 0x2015;
+    /** @hide */
+    public static final int RESPONSE_INVALID_CODE_FORMAT = 0x2016;
+    /** @hide */
+    public static final int RESPONSE_UNKNOWN_VENDOR_CODE = 0x2017;
+    /** @hide */
+    public static final int RESPONSE_CAPTURE_ALREADY_TERMINATED = 0x2018;
+    /** @hide */
+    public static final int RESPONSE_DEVICE_BUSY = 0x2019;
+    /** @hide */
+    public static final int RESPONSE_INVALID_PARENT_OBJECT = 0x201A;
+    /** @hide */
+    public static final int RESPONSE_INVALID_DEVICE_PROP_FORMAT = 0x201B;
+    /** @hide */
+    public static final int RESPONSE_INVALID_DEVICE_PROP_VALUE = 0x201C;
+    /** @hide */
+    public static final int RESPONSE_INVALID_PARAMETER = 0x201D;
+    /** @hide */
+    public static final int RESPONSE_SESSION_ALREADY_OPEN = 0x201E;
+    /** @hide */
+    public static final int RESPONSE_TRANSACTION_CANCELLED = 0x201F;
+    /** @hide */
+    public static final int RESPONSE_SPECIFICATION_OF_DESTINATION_UNSUPPORTED = 0x2020;
+    /** @hide */
+    public static final int RESPONSE_INVALID_OBJECT_PROP_CODE = 0xA801;
+    /** @hide */
+    public static final int RESPONSE_INVALID_OBJECT_PROP_FORMAT = 0xA802;
+    /** @hide */
+    public static final int RESPONSE_INVALID_OBJECT_PROP_VALUE = 0xA803;
+    /** @hide */
+    public static final int RESPONSE_INVALID_OBJECT_REFERENCE = 0xA804;
+    /** @hide */
+    public static final int RESPONSE_GROUP_NOT_SUPPORTED = 0xA805;
+    /** @hide */
+    public static final int RESPONSE_INVALID_DATASET = 0xA806;
+    /** @hide */
+    public static final int RESPONSE_SPECIFICATION_BY_GROUP_UNSUPPORTED = 0xA807;
+    /** @hide */
+    public static final int RESPONSE_SPECIFICATION_BY_DEPTH_UNSUPPORTED = 0xA808;
+    /** @hide */
+    public static final int RESPONSE_OBJECT_TOO_LARGE = 0xA809;
+    /** @hide */
+    public static final int RESPONSE_OBJECT_PROP_NOT_SUPPORTED = 0xA80A;
+
+    // MTP format codes
+    /** Undefined format code */
+    public static final int FORMAT_UNDEFINED = 0x3000;
+    /** Format code for associations (folders and directories) */
+    public static final int FORMAT_ASSOCIATION = 0x3001;
+    /** Format code for script files */
+    public static final int FORMAT_SCRIPT = 0x3002;
+    /** Format code for executable files */
+    public static final int FORMAT_EXECUTABLE = 0x3003;
+    /** Format code for text files */
+    public static final int FORMAT_TEXT = 0x3004;
+    /** Format code for HTML files */
+    public static final int FORMAT_HTML = 0x3005;
+    /** Format code for DPOF files */
+    public static final int FORMAT_DPOF = 0x3006;
+    /** Format code for AIFF audio files */
+    public static final int FORMAT_AIFF = 0x3007;
+    /** Format code for WAV audio files */
+    public static final int FORMAT_WAV = 0x3008;
+    /** Format code for MP3 audio files */
+    public static final int FORMAT_MP3 = 0x3009;
+    /** Format code for AVI video files */
+    public static final int FORMAT_AVI = 0x300A;
+    /** Format code for MPEG video files */
+    public static final int FORMAT_MPEG = 0x300B;
+    /** Format code for ASF files */
+    public static final int FORMAT_ASF = 0x300C;
+    /** Format code for JPEG image files */
+    public static final int FORMAT_EXIF_JPEG = 0x3801;
+    /** Format code for TIFF EP image files */
+    public static final int FORMAT_TIFF_EP = 0x3802;
+    /** Format code for BMP image files */
+    public static final int FORMAT_BMP = 0x3804;
+    /** Format code for GIF image files */
+    public static final int FORMAT_GIF = 0x3807;
+    /** Format code for JFIF image files */
+    public static final int FORMAT_JFIF = 0x3808;
+    /** Format code for PICT image files */
+    public static final int FORMAT_PICT = 0x380A;
+    /** Format code for PNG image files */
+    public static final int FORMAT_PNG = 0x380B;
+    /** Format code for TIFF image files */
+    public static final int FORMAT_TIFF = 0x380D;
+    /** Format code for JP2 files */
+    public static final int FORMAT_JP2 = 0x380F;
+    /** Format code for JPX files */
+    public static final int FORMAT_JPX = 0x3810;
+    /** Format code for firmware files */
+    public static final int FORMAT_UNDEFINED_FIRMWARE = 0xB802;
+    /** Format code for Windows image files */
+    public static final int FORMAT_WINDOWS_IMAGE_FORMAT = 0xB881;
+    /** Format code for undefined audio files files */
+    public static final int FORMAT_UNDEFINED_AUDIO = 0xB900;
+    /** Format code for WMA audio files */
+    public static final int FORMAT_WMA = 0xB901;
+    /** Format code for OGG audio files */
+    public static final int FORMAT_OGG = 0xB902;
+    /** Format code for AAC audio files */
+    public static final int FORMAT_AAC = 0xB903;
+    /** Format code for Audible audio files */
+    public static final int FORMAT_AUDIBLE = 0xB904;
+    /** Format code for FLAC audio files */
+    public static final int FORMAT_FLAC = 0xB906;
+    /** Format code for undefined video files */
+    public static final int FORMAT_UNDEFINED_VIDEO = 0xB980;
+    /** Format code for WMV video files */
+    public static final int FORMAT_WMV = 0xB981;
+    /** Format code for MP4 files */
+    public static final int FORMAT_MP4_CONTAINER = 0xB982;
+    /** Format code for MP2 files */
+    public static final int FORMAT_MP2 = 0xB983;
+    /** Format code for 3GP files */
+    public static final int FORMAT_3GP_CONTAINER = 0xB984;
+    /** Format code for undefined collections */
+    public static final int FORMAT_UNDEFINED_COLLECTION = 0xBA00;
+    /** Format code for multimedia albums */
+    public static final int FORMAT_ABSTRACT_MULTIMEDIA_ALBUM = 0xBA01;
+    /** Format code for image albums */
+    public static final int FORMAT_ABSTRACT_IMAGE_ALBUM = 0xBA02;
+    /** Format code for audio albums */
+    public static final int FORMAT_ABSTRACT_AUDIO_ALBUM = 0xBA03;
+    /** Format code for video albums */
+    public static final int FORMAT_ABSTRACT_VIDEO_ALBUM = 0xBA04;
+    /** Format code for abstract AV playlists */
+    public static final int FORMAT_ABSTRACT_AV_PLAYLIST = 0xBA05;
+    /** Format code for abstract audio playlists */
+    public static final int FORMAT_ABSTRACT_AUDIO_PLAYLIST = 0xBA09;
+    /** Format code for abstract video playlists */
+    public static final int FORMAT_ABSTRACT_VIDEO_PLAYLIST = 0xBA0A;
+    /** Format code for abstract mediacasts */
+    public static final int FORMAT_ABSTRACT_MEDIACAST = 0xBA0B;
+    /** Format code for WPL playlist files */
+    public static final int FORMAT_WPL_PLAYLIST = 0xBA10;
+    /** Format code for M3u playlist files */
+    public static final int FORMAT_M3U_PLAYLIST = 0xBA11;
+    /** Format code for MPL playlist files */
+    public static final int FORMAT_MPL_PLAYLIST = 0xBA12;
+    /** Format code for ASX playlist files */
+    public static final int FORMAT_ASX_PLAYLIST = 0xBA13;
+    /** Format code for PLS playlist files */
+    public static final int FORMAT_PLS_PLAYLIST = 0xBA14;
+    /** Format code for undefined document files */
+    public static final int FORMAT_UNDEFINED_DOCUMENT = 0xBA80;
+    /** Format code for abstract documents */
+    public static final int FORMAT_ABSTRACT_DOCUMENT = 0xBA81;
+    /** Format code for XML documents */
+    public static final int FORMAT_XML_DOCUMENT = 0xBA82;
+    /** Format code for MS Word documents */
+    public static final int FORMAT_MS_WORD_DOCUMENT = 0xBA83;
+    /** Format code for MS Excel spreadsheets */
+    public static final int FORMAT_MS_EXCEL_SPREADSHEET = 0xBA85;
+    /** Format code for MS PowerPoint presentatiosn */
+    public static final int FORMAT_MS_POWERPOINT_PRESENTATION = 0xBA86;
+
+    /**
+     * Returns true if the object is abstract (that is, it has no representation
+     * in the underlying file system).
+     *
+     * @param format the format of the object
+     * @return true if the object is abstract
+     */
+    public static boolean isAbstractObject(int format) {
+        switch (format) {
+            case FORMAT_ABSTRACT_MULTIMEDIA_ALBUM:
+            case FORMAT_ABSTRACT_IMAGE_ALBUM:
+            case FORMAT_ABSTRACT_AUDIO_ALBUM:
+            case FORMAT_ABSTRACT_VIDEO_ALBUM:
+            case FORMAT_ABSTRACT_AV_PLAYLIST:
+            case FORMAT_ABSTRACT_AUDIO_PLAYLIST:
+            case FORMAT_ABSTRACT_VIDEO_PLAYLIST:
+            case FORMAT_ABSTRACT_MEDIACAST:
+            case FORMAT_ABSTRACT_DOCUMENT:
+                return true;
+            default:
+                return false;
+        }
+    }
+
+    // MTP object properties
+    /** @hide */
+    public static final int PROPERTY_STORAGE_ID = 0xDC01;
+    /** @hide */
+    public static final int PROPERTY_OBJECT_FORMAT = 0xDC02;
+    /** @hide */
+    public static final int PROPERTY_PROTECTION_STATUS = 0xDC03;
+    /** @hide */
+    public static final int PROPERTY_OBJECT_SIZE = 0xDC04;
+    /** @hide */
+    public static final int PROPERTY_ASSOCIATION_TYPE = 0xDC05;
+    /** @hide */
+    public static final int PROPERTY_ASSOCIATION_DESC = 0xDC06;
+    /** @hide */
+    public static final int PROPERTY_OBJECT_FILE_NAME = 0xDC07;
+    /** @hide */
+    public static final int PROPERTY_DATE_CREATED = 0xDC08;
+    /** @hide */
+    public static final int PROPERTY_DATE_MODIFIED = 0xDC09;
+    /** @hide */
+    public static final int PROPERTY_KEYWORDS = 0xDC0A;
+    /** @hide */
+    public static final int PROPERTY_PARENT_OBJECT = 0xDC0B;
+    /** @hide */
+    public static final int PROPERTY_ALLOWED_FOLDER_CONTENTS = 0xDC0C;
+    /** @hide */
+    public static final int PROPERTY_HIDDEN = 0xDC0D;
+    /** @hide */
+    public static final int PROPERTY_SYSTEM_OBJECT = 0xDC0E;
+    /** @hide */
+    public static final int PROPERTY_PERSISTENT_UID = 0xDC41;
+    /** @hide */
+    public static final int PROPERTY_SYNC_ID = 0xDC42;
+    /** @hide */
+    public static final int PROPERTY_PROPERTY_BAG = 0xDC43;
+    /** @hide */
+    public static final int PROPERTY_NAME = 0xDC44;
+    /** @hide */
+    public static final int PROPERTY_CREATED_BY = 0xDC45;
+    /** @hide */
+    public static final int PROPERTY_ARTIST = 0xDC46;
+    /** @hide */
+    public static final int PROPERTY_DATE_AUTHORED = 0xDC47;
+    /** @hide */
+    public static final int PROPERTY_DESCRIPTION = 0xDC48;
+    /** @hide */
+    public static final int PROPERTY_URL_REFERENCE = 0xDC49;
+    /** @hide */
+    public static final int PROPERTY_LANGUAGE_LOCALE = 0xDC4A;
+    /** @hide */
+    public static final int PROPERTY_COPYRIGHT_INFORMATION = 0xDC4B;
+    /** @hide */
+    public static final int PROPERTY_SOURCE = 0xDC4C;
+    /** @hide */
+    public static final int PROPERTY_ORIGIN_LOCATION = 0xDC4D;
+    /** @hide */
+    public static final int PROPERTY_DATE_ADDED = 0xDC4E;
+    /** @hide */
+    public static final int PROPERTY_NON_CONSUMABLE = 0xDC4F;
+    /** @hide */
+    public static final int PROPERTY_CORRUPT_UNPLAYABLE = 0xDC50;
+    /** @hide */
+    public static final int PROPERTY_PRODUCER_SERIAL_NUMBER = 0xDC51;
+    /** @hide */
+    public static final int PROPERTY_REPRESENTATIVE_SAMPLE_FORMAT = 0xDC81;
+    /** @hide */
+    public static final int PROPERTY_REPRESENTATIVE_SAMPLE_SIZE = 0xDC82;
+    /** @hide */
+    public static final int PROPERTY_REPRESENTATIVE_SAMPLE_HEIGHT = 0xDC83;
+    /** @hide */
+    public static final int PROPERTY_REPRESENTATIVE_SAMPLE_WIDTH = 0xDC84;
+    /** @hide */
+    public static final int PROPERTY_REPRESENTATIVE_SAMPLE_DURATION = 0xDC85;
+    /** @hide */
+    public static final int PROPERTY_REPRESENTATIVE_SAMPLE_DATA = 0xDC86;
+    /** @hide */
+    public static final int PROPERTY_WIDTH = 0xDC87;
+    /** @hide */
+    public static final int PROPERTY_HEIGHT = 0xDC88;
+    /** @hide */
+    public static final int PROPERTY_DURATION = 0xDC89;
+    /** @hide */
+    public static final int PROPERTY_RATING = 0xDC8A;
+    /** @hide */
+    public static final int PROPERTY_TRACK = 0xDC8B;
+    /** @hide */
+    public static final int PROPERTY_GENRE = 0xDC8C;
+    /** @hide */
+    public static final int PROPERTY_CREDITS = 0xDC8D;
+    /** @hide */
+    public static final int PROPERTY_LYRICS = 0xDC8E;
+    /** @hide */
+    public static final int PROPERTY_SUBSCRIPTION_CONTENT_ID = 0xDC8F;
+    /** @hide */
+    public static final int PROPERTY_PRODUCED_BY = 0xDC90;
+    /** @hide */
+    public static final int PROPERTY_USE_COUNT = 0xDC91;
+    /** @hide */
+    public static final int PROPERTY_SKIP_COUNT = 0xDC92;
+    /** @hide */
+    public static final int PROPERTY_LAST_ACCESSED = 0xDC93;
+    /** @hide */
+    public static final int PROPERTY_PARENTAL_RATING = 0xDC94;
+    /** @hide */
+    public static final int PROPERTY_META_GENRE = 0xDC95;
+    /** @hide */
+    public static final int PROPERTY_COMPOSER = 0xDC96;
+    /** @hide */
+    public static final int PROPERTY_EFFECTIVE_RATING = 0xDC97;
+    /** @hide */
+    public static final int PROPERTY_SUBTITLE = 0xDC98;
+    /** @hide */
+    public static final int PROPERTY_ORIGINAL_RELEASE_DATE = 0xDC99;
+    /** @hide */
+    public static final int PROPERTY_ALBUM_NAME = 0xDC9A;
+    /** @hide */
+    public static final int PROPERTY_ALBUM_ARTIST = 0xDC9B;
+    /** @hide */
+    public static final int PROPERTY_MOOD = 0xDC9C;
+    /** @hide */
+    public static final int PROPERTY_DRM_STATUS = 0xDC9D;
+    /** @hide */
+    public static final int PROPERTY_SUB_DESCRIPTION = 0xDC9E;
+    /** @hide */
+    public static final int PROPERTY_IS_CROPPED = 0xDCD1;
+    /** @hide */
+    public static final int PROPERTY_IS_COLOUR_CORRECTED = 0xDCD2;
+    /** @hide */
+    public static final int PROPERTY_IMAGE_BIT_DEPTH = 0xDCD3;
+    /** @hide */
+    public static final int PROPERTY_F_NUMBER = 0xDCD4;
+    /** @hide */
+    public static final int PROPERTY_EXPOSURE_TIME = 0xDCD5;
+    /** @hide */
+    public static final int PROPERTY_EXPOSURE_INDEX = 0xDCD6;
+    /** @hide */
+    public static final int PROPERTY_TOTAL_BITRATE = 0xDE91;
+    /** @hide */
+    public static final int PROPERTY_BITRATE_TYPE = 0xDE92;
+    /** @hide */
+    public static final int PROPERTY_SAMPLE_RATE = 0xDE93;
+    /** @hide */
+    public static final int PROPERTY_NUMBER_OF_CHANNELS = 0xDE94;
+    /** @hide */
+    public static final int PROPERTY_AUDIO_BIT_DEPTH = 0xDE95;
+    /** @hide */
+    public static final int PROPERTY_SCAN_TYPE = 0xDE97;
+    /** @hide */
+    public static final int PROPERTY_AUDIO_WAVE_CODEC = 0xDE99;
+    /** @hide */
+    public static final int PROPERTY_AUDIO_BITRATE = 0xDE9A;
+    /** @hide */
+    public static final int PROPERTY_VIDEO_FOURCC_CODEC = 0xDE9B;
+    /** @hide */
+    public static final int PROPERTY_VIDEO_BITRATE = 0xDE9C;
+    /** @hide */
+    public static final int PROPERTY_FRAMES_PER_THOUSAND_SECONDS = 0xDE9D;
+    /** @hide */
+    public static final int PROPERTY_KEYFRAME_DISTANCE = 0xDE9E;
+    /** @hide */
+    public static final int PROPERTY_BUFFER_SIZE = 0xDE9F;
+    /** @hide */
+    public static final int PROPERTY_ENCODING_QUALITY = 0xDEA0;
+    /** @hide */
+    public static final int PROPERTY_ENCODING_PROFILE = 0xDEA1;
+    /** @hide */
+    public static final int PROPERTY_DISPLAY_NAME = 0xDCE0;
+
+    // MTP device properties
+    /** @hide */
+    public static final int DEVICE_PROPERTY_UNDEFINED = 0x5000;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_BATTERY_LEVEL = 0x5001;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_FUNCTIONAL_MODE = 0x5002;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_IMAGE_SIZE = 0x5003;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_COMPRESSION_SETTING = 0x5004;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_WHITE_BALANCE = 0x5005;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_RGB_GAIN = 0x5006;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_F_NUMBER = 0x5007;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_FOCAL_LENGTH = 0x5008;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_FOCUS_DISTANCE = 0x5009;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_FOCUS_MODE = 0x500A;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_EXPOSURE_METERING_MODE = 0x500B;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_FLASH_MODE = 0x500C;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_EXPOSURE_TIME = 0x500D;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_EXPOSURE_PROGRAM_MODE = 0x500E;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_EXPOSURE_INDEX = 0x500F;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_EXPOSURE_BIAS_COMPENSATION = 0x5010;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_DATETIME = 0x5011;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_CAPTURE_DELAY = 0x5012;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_STILL_CAPTURE_MODE = 0x5013;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_CONTRAST = 0x5014;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_SHARPNESS = 0x5015;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_DIGITAL_ZOOM = 0x5016;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_EFFECT_MODE = 0x5017;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_BURST_NUMBER= 0x5018;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_BURST_INTERVAL = 0x5019;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_TIMELAPSE_NUMBER = 0x501A;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_TIMELAPSE_INTERVAL = 0x501B;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_FOCUS_METERING_MODE = 0x501C;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_UPLOAD_URL = 0x501D;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_ARTIST = 0x501E;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_COPYRIGHT_INFO = 0x501F;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_SYNCHRONIZATION_PARTNER = 0xD401;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_DEVICE_FRIENDLY_NAME = 0xD402;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_VOLUME = 0xD403;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_SUPPORTED_FORMATS_ORDERED = 0xD404;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_DEVICE_ICON = 0xD405;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_PLAYBACK_RATE = 0xD410;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_PLAYBACK_OBJECT = 0xD411;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_PLAYBACK_CONTAINER_INDEX = 0xD412;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_SESSION_INITIATOR_VERSION_INFO = 0xD406;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_PERCEIVED_DEVICE_TYPE = 0xD407;
+
+    /**
+     * Object is not protected. It may be modified and deleted, and its properties
+     * may be modified.
+     */
+    public static final int PROTECTION_STATUS_NONE = 0;
+
+    /**
+     * Object can not be modified or deleted and its properties can not be modified.
+     */
+    public static final int PROTECTION_STATUS_READ_ONLY = 0x8001;
+
+    /**
+     * Object can not be modified or deleted but its properties are modifiable.
+     */
+    public static final int PROTECTION_STATUS_READ_ONLY_DATA = 0x8002;
+
+    /**
+     * Object's contents can not be transfered from the device, but the object
+     * may be moved or deleted and its properties may be modified.
+     */
+    public static final int PROTECTION_STATUS_NON_TRANSFERABLE_DATA = 0x8003;
+
+    /**
+     * Association type for objects representing file system directories.
+     */
+    public static final int ASSOCIATION_TYPE_GENERIC_FOLDER = 0x0001;
+}
+
diff --git a/src/com/koushikdutta/ion/loader/PackageIconLoader.java b/src/com/koushikdutta/ion/loader/PackageIconLoader.java
new file mode 100644
index 00000000..ede717a9
--- /dev/null
+++ b/src/com/koushikdutta/ion/loader/PackageIconLoader.java
@@ -0,0 +1,50 @@
+package com.koushikdutta.ion.loader;
+
+
+import android.content.Context;
+import android.content.pm.PackageManager;
+import android.graphics.Bitmap;
+import android.graphics.Point;
+import android.graphics.drawable.BitmapDrawable;
+
+import com.koushikdutta.async.future.Future;
+import com.koushikdutta.async.future.SimpleFuture;
+import com.koushikdutta.ion.Ion;
+import com.koushikdutta.ion.Loader;
+import com.koushikdutta.ion.bitmap.BitmapInfo;
+
+import java.net.URI;
+
+/**
+ * Created by koush on 11/3/13.
+ */
+public class PackageIconLoader extends SimpleLoader {
+    @Override
+    public Future<BitmapInfo> loadBitmap(Context context, final Ion ion, final String key, final String uri, int resizeWidth, int resizeHeight, boolean animateGif) {
+        if (uri == null || !uri.startsWith("package:"))
+            return null;
+
+        final SimpleFuture<BitmapInfo> ret = new SimpleFuture<BitmapInfo>();
+        Ion.getBitmapLoadExecutorService().execute(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    final URI request = URI.create(uri);
+                    String pkg = request.getHost();
+                    PackageManager pm = ion.getContext().getPackageManager();
+                    Bitmap bmp = ((BitmapDrawable)pm.getPackageInfo(pkg, 0).applicationInfo.loadIcon(pm)).getBitmap();
+                    if (bmp == null)
+                        throw new Exception("package icon failed to load");
+                    BitmapInfo info = new BitmapInfo(key, null, new Bitmap[] { bmp }, new Point(bmp.getWidth(), bmp.getHeight()));
+                    info.loadedFrom =  Loader.LoaderEmitter.LOADED_FROM_CACHE;
+                    ret.setComplete(info);
+                }
+                catch (Exception e) {
+                    ret.setComplete(e);
+                }
+            }
+        });
+
+        return ret;
+    }
+}
diff --git a/src/com/koushikdutta/ion/loader/SimpleLoader.java b/src/com/koushikdutta/ion/loader/SimpleLoader.java
new file mode 100644
index 00000000..8d285a1b
--- /dev/null
+++ b/src/com/koushikdutta/ion/loader/SimpleLoader.java
@@ -0,0 +1,38 @@
+package com.koushikdutta.ion.loader;
+
+import android.content.Context;
+
+import com.koushikdutta.async.DataEmitter;
+import com.koushikdutta.async.future.Future;
+import com.koushikdutta.async.future.FutureCallback;
+import com.koushikdutta.async.http.AsyncHttpRequest;
+import com.koushikdutta.ion.Ion;
+import com.koushikdutta.ion.Loader;
+import com.koushikdutta.ion.bitmap.BitmapInfo;
+
+import java.io.InputStream;
+
+/**
+ * Created by koush on 12/22/13.
+ */
+public class SimpleLoader implements Loader {
+    @Override
+    public Future<InputStream> load(Ion ion, AsyncHttpRequest request) {
+        return null;
+    }
+
+    @Override
+    public Future<DataEmitter> load(Ion ion, AsyncHttpRequest request, FutureCallback<LoaderEmitter> callback) {
+        return null;
+    }
+
+    @Override
+    public Future<BitmapInfo> loadBitmap(Context context, Ion ion, String key, String uri, int resizeWidth, int resizeHeight, boolean animateGif) {
+        return null;
+    }
+
+    @Override
+    public Future<AsyncHttpRequest> resolve(Context context, Ion ion, AsyncHttpRequest request) {
+        return null;
+    }
+}
diff --git a/src/com/koushikdutta/ion/loader/VideoLoader.java b/src/com/koushikdutta/ion/loader/VideoLoader.java
new file mode 100644
index 00000000..ae31cbb8
--- /dev/null
+++ b/src/com/koushikdutta/ion/loader/VideoLoader.java
@@ -0,0 +1,75 @@
+package com.koushikdutta.ion.loader;
+
+import android.annotation.TargetApi;
+import android.content.ContentResolver;
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.Point;
+import android.media.MediaMetadataRetriever;
+import android.media.ThumbnailUtils;
+import android.os.Build;
+import android.provider.MediaStore;
+
+import com.koushikdutta.async.future.Future;
+import com.koushikdutta.async.future.SimpleFuture;
+import com.koushikdutta.ion.Ion;
+import com.koushikdutta.ion.bitmap.BitmapInfo;
+
+import java.io.File;
+import java.net.URI;
+
+/**
+ * Created by koush on 11/6/13.
+ */
+public class VideoLoader extends SimpleLoader {
+    @TargetApi(Build.VERSION_CODES.GINGERBREAD_MR1)
+    public static Bitmap createVideoThumbnail(String filePath) throws Exception {
+        MediaMetadataRetriever retriever = new MediaMetadataRetriever();
+        retriever.setDataSource(filePath);
+        return retriever.getFrameAtTime();
+    }
+
+    static boolean mustUseThumbnailUtils() {
+        // http://developer.samsung.com/forum/thread/mediametadataretriever-getframeattime-to-retrieve-video-frame-fails/77/202945
+        // https://codereview.chromium.org/107523005
+        return Build.MANUFACTURER.toLowerCase().contains("samsung");
+    }
+
+    @Override
+    public Future<BitmapInfo> loadBitmap(Context context, Ion ion, final String key, final String uri, int resizeWidth, int resizeHeight, boolean animateGif) {
+        if (!uri.startsWith(ContentResolver.SCHEME_FILE))
+            return null;
+
+        final MediaFile.MediaFileType type = MediaFile.getFileType(uri);
+        if (type == null || !MediaFile.isVideoFileType(type.fileType))
+            return null;
+
+        final SimpleFuture<BitmapInfo> ret = new SimpleFuture<BitmapInfo>();
+        Ion.getBitmapLoadExecutorService().execute(new Runnable() {
+            @Override
+            public void run() {
+                final File file = new File(URI.create(uri));
+                if (ret.isCancelled()) {
+//                    Log.d("VideoLoader", "Bitmap load cancelled (no longer needed)");
+                    return;
+                }
+                try {
+                    Bitmap bmp;
+
+                    if (mustUseThumbnailUtils() || Build.VERSION.SDK_INT < Build.VERSION_CODES.GINGERBREAD_MR1)
+                        bmp = ThumbnailUtils.createVideoThumbnail(file.getAbsolutePath(), MediaStore.Video.Thumbnails.MINI_KIND);
+                    else
+                        bmp = createVideoThumbnail(file.getAbsolutePath());
+                    if (bmp == null)
+                        throw new Exception("video bitmap failed to load");
+                    BitmapInfo info = new BitmapInfo(key, type.mimeType, new Bitmap[] { bmp }, new Point(bmp.getWidth(), bmp.getHeight()));
+                    info.loadedFrom = LoaderEmitter.LOADED_FROM_CACHE;
+                    ret.setComplete(info);
+                } catch (Exception e) {
+                    ret.setComplete(e);
+                }
+            }
+        });
+        return ret;
+    }
+}
diff --git a/stylesheet.css b/stylesheet.css
new file mode 100644
index 00000000..09fc4a5e
--- /dev/null
+++ b/stylesheet.css
@@ -0,0 +1,55 @@
+/* Javadoc style sheet */
+
+/* Define colors, fonts and other style attributes here to override the defaults */
+
+/* Page background color */
+body { background-color: #FFFFFF; color:#333; font-size: 100%; }
+
+body { font-size: 0.875em; line-height: 1.286em; font-family:   "Helvetica", "Arial", sans-serif; }
+
+code { color: #777; line-height: 1.286em; font-family: "Consolas", "Lucida Console", "Droid Sans Mono", "Andale Mono", "Monaco", "Lucida Sans Typewriter"; }
+
+a { text-decoration: none; color: #16569A; /* also try #2E85ED, #0033FF, #6C93C6, #1D7BBE, #1D8DD2 */ }
+a:hover { color: #EEEEEE; background-color: #16569A; }
+a:visited { color: #CC3300; }
+a:visited:hover { color: #fff; background-color: #CC3300; }
+
+table[border="1"] { border: 1px solid #ddd; }
+table[border="1"] td, table[border="1"] th { border: 1px solid #ddd; }
+table[cellpadding="3"] td { padding: 0.5em; }
+
+font[size="-1"] { font-size: 0.85em; line-height: 1.5em; }
+font[size="-2"] { font-size: 0.8em; }
+font[size="+2"] { font-size: 1.4em; line-height: 1.3em; padding: 0.4em 0; }
+
+/* Headings */
+h1 { font-size: 1.5em; line-height: 1.286em;}
+
+/* Table colors */
+.TableHeadingColor     { background: #ccc; color:#444; } /* Dark mauve */
+.TableSubHeadingColor  { background: #ddd; color:#444; } /* Light mauve */
+.TableRowColor         { background: #FFFFFF; color:#666; font-size: 0.95em; } /* White */
+.TableRowColor code    { color:#000; } /* White */
+
+/* Font used in left-hand frame lists */
+.FrameTitleFont   { font-size: 100%; }
+.FrameHeadingFont { font-size:  90%; }
+.FrameItemFont { font-size:  0.9em; line-height: 1.3em; 
+}
+/* Java Interfaces */
+.FrameItemFont a i {
+  font-style: normal; color: #666;
+}
+.FrameItemFont a:hover i {
+  font-style: normal; color: #fff; background-color: #666;
+}
+
+/* Navigation bar fonts and colors */
+.NavBarCell1    { background-color:#E0E6DF; } /* Light mauve */
+.NavBarCell1Rev { background-color:#16569A; color:#FFFFFF} /* Dark Blue */
+.NavBarFont1    { }
+.NavBarFont1Rev { color:#FFFFFF; }
+
+.NavBarCell2    { background-color:#FFFFFF; color:#000000}
+.NavBarCell3    { background-color:#FFFFFF; color:#000000}
+
