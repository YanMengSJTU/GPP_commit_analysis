diff --git a/README.md b/README.md
index d69134b7..58ee9755 100644
--- a/README.md
+++ b/README.md
@@ -362,14 +362,14 @@ Ion.with(getContext())
 <dependency>
    <groupId>com.koushikdutta.ion</groupId>
    <artifactId>ion</artifactId>
-   <version>1.1.5</version>
+   <version>1.2.0</version>
 </dependency>
 ```
 
 ##### Gradle
 ```groovy
 dependencies {
-   compile 'com.koushikdutta.ion:ion:1.1.5'
+   compile 'com.koushikdutta.ion:ion:1.2.0'
 }
 ````
 
@@ -378,10 +378,16 @@ dependencies {
 git clone git://github.com/koush/AndroidAsync.git
 git clone git://github.com/koush/ion.git
 cd ion/ion
-ant release install
+ant -Dsdk.dir=$ANDROID_HOME release install
 ```
 Jars are at
  * ion/ion/bin/classes.jar
  * AndroidAsync/AndroidAsync/bin/classes.jar
 
-
+#### Hack in Eclipse
+```
+git clone git://github.com/koush/AndroidAsync.git
+git clone git://github.com/koush/ion.git
+```
+* Import the project from AndroidAsync/AndroidAsync into your workspace
+* Import all the ion projects (ion/ion, ion/ion-test, ion/ion-sample) into your workspace.
diff --git a/ion-sample/AndroidManifest.xml b/ion-sample/AndroidManifest.xml
index fef3c2d1..0a964c5b 100644
--- a/ion-sample/AndroidManifest.xml
+++ b/ion-sample/AndroidManifest.xml
@@ -24,6 +24,9 @@
         <activity
                 android:name=".ProgressBarDownload"
                 android:label="Progress Bar Download"/>
+        <activity
+                android:name=".ProgressBarUpload"
+                android:label="Progress Bar Upload"/>
         <activity
             android:name=".GoogleImageSearch"
             android:label="Google Image Search"/>
diff --git a/ion-sample/res/layout/progress_upload.xml b/ion-sample/res/layout/progress_upload.xml
new file mode 100644
index 00000000..c85b0d48
--- /dev/null
+++ b/ion-sample/res/layout/progress_upload.xml
@@ -0,0 +1,40 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              android:orientation="vertical"
+              android:gravity="center"
+              android:layout_width="match_parent"
+              android:layout_height="match_parent">
+
+    <TextView
+            style="@android:style/TextAppearance.Large"
+            android:layout_gravity="center"
+            android:text="File Upload"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            />
+
+    <ProgressBar
+            android:minHeight="20dp"
+            android:maxHeight="20dp"
+            android:id="@+id/progress"
+            style="?android:attr/progressBarStyleHorizontal"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:layout_gravity="center"/>
+
+    <TextView
+            android:layout_gravity="center"
+            android:id="@+id/upload_count"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            />
+
+    <Button
+            android:layout_gravity="center"
+            android:id="@+id/upload"
+            android:text="Upload"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            />
+</LinearLayout>
\ No newline at end of file
diff --git a/ion-sample/res/layout/samples.xml b/ion-sample/res/layout/samples.xml
index d0d2bc38..09b0bbf3 100644
--- a/ion-sample/res/layout/samples.xml
+++ b/ion-sample/res/layout/samples.xml
@@ -18,6 +18,10 @@
             android:layout_height="wrap_content"
             android:text="Progress Bar Download"
             />
+    <Button android:id="@+id/upload" android:layout_width="240dp"
+            android:layout_height="wrap_content"
+            android:text="Progress Bar Upload"
+            />
     <Button android:id="@+id/image_view" android:layout_width="240dp"
             android:layout_height="wrap_content"
             android:text="ImageView Sample"
diff --git a/ion-sample/src/com/koushikdutta/ion/sample/GallerySample.java b/ion-sample/src/com/koushikdutta/ion/sample/GallerySample.java
index 235fb968..c1a3807f 100644
--- a/ion-sample/src/com/koushikdutta/ion/sample/GallerySample.java
+++ b/ion-sample/src/com/koushikdutta/ion/sample/GallerySample.java
@@ -76,14 +76,21 @@ public void onCreate(Bundle savedInstanceState) {
     Cursor mediaCursor;
     public void loadMore() {
         if (mediaCursor == null) {
-            mediaCursor = getContentResolver().query(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, null, null, null, null);
+            mediaCursor = getContentResolver().query(MediaStore.Files.getContentUri("external"), null, null, null, null);
         }
 
         int loaded = 0;
         while (mediaCursor.moveToNext() && loaded < 10) {
+            // get the media type. ion can show images for both regular images AND video.
+            int mediaType = mediaCursor.getInt(mediaCursor.getColumnIndex(MediaStore.Files.FileColumns.MEDIA_TYPE));
+            if (mediaType != MediaStore.Files.FileColumns.MEDIA_TYPE_IMAGE
+                && mediaType != MediaStore.Files.FileColumns.MEDIA_TYPE_VIDEO) {
+                continue;
+            }
+
             loaded++;
 
-            String uri = mediaCursor.getString(mediaCursor.getColumnIndex(MediaStore.Images.ImageColumns.DATA));
+            String uri = mediaCursor.getString(mediaCursor.getColumnIndex(MediaStore.Files.FileColumns.DATA));
             File file = new File(uri);
             // turn this into a file uri if necessary/possible
             if (file.exists())
diff --git a/ion-sample/src/com/koushikdutta/ion/sample/ProgressBarDownload.java b/ion-sample/src/com/koushikdutta/ion/sample/ProgressBarDownload.java
index b0c36567..9b72179d 100644
--- a/ion-sample/src/com/koushikdutta/ion/sample/ProgressBarDownload.java
+++ b/ion-sample/src/com/koushikdutta/ion/sample/ProgressBarDownload.java
@@ -69,10 +69,10 @@ public void onProgress(int downloaded, int total) {
                         public void onCompleted(Exception e, File result) {
                             resetDownload();
                             if (e != null) {
-                                Toast.makeText(ProgressBarDownload.this, "Error downloading file", Toast.LENGTH_LONG).show();
+                                Toast.makeText(ProgressBarDownload.this, "Error uploading file", Toast.LENGTH_LONG).show();
                                 return;
                             }
-                            Toast.makeText(ProgressBarDownload.this, "File download complete", Toast.LENGTH_LONG).show();
+                            Toast.makeText(ProgressBarDownload.this, "File upload complete", Toast.LENGTH_LONG).show();
                         }
                     });
             }
@@ -80,7 +80,7 @@ public void onCompleted(Exception e, File result) {
     }
 
     void resetDownload() {
-        // cancel any pending download
+        // cancel any pending upload
         downloading.cancel();
         downloading = null;
 
diff --git a/ion-sample/src/com/koushikdutta/ion/sample/ProgressBarUpload.java b/ion-sample/src/com/koushikdutta/ion/sample/ProgressBarUpload.java
new file mode 100644
index 00000000..a9660171
--- /dev/null
+++ b/ion-sample/src/com/koushikdutta/ion/sample/ProgressBarUpload.java
@@ -0,0 +1,104 @@
+package com.koushikdutta.ion.sample;
+
+import android.app.Activity;
+import android.os.Bundle;
+import android.util.Log;
+import android.view.View;
+import android.widget.Button;
+import android.widget.ProgressBar;
+import android.widget.TextView;
+import android.widget.Toast;
+
+import com.koushikdutta.async.future.Future;
+import com.koushikdutta.async.future.FutureCallback;
+import com.koushikdutta.ion.Ion;
+import com.koushikdutta.ion.ProgressCallback;
+
+import java.io.File;
+import java.io.RandomAccessFile;
+
+/**
+ * Created by koush on 5/31/13.
+ */
+public class ProgressBarUpload extends Activity {
+    Button upload;
+    TextView uploadCount;
+    ProgressBar progressBar;
+
+    Future<File> uploading;
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        // Enable global Ion logging
+        Ion.getDefault(this).configure().setLogging("ion-sample", Log.DEBUG);
+
+        setContentView(R.layout.progress_upload);
+
+        upload = (Button)findViewById(R.id.upload);
+        uploadCount = (TextView)findViewById(R.id.upload_count);
+        progressBar = (ProgressBar)findViewById(R.id.progress);
+
+        upload.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                if (uploading != null && !uploading.isCancelled()) {
+                    resetUpload();
+                    return;
+                }
+
+                File f = getFileStreamPath("largefile");
+                try {
+                    RandomAccessFile rf = new RandomAccessFile(f, "rw");
+                    rf.setLength(1024 * 1024 * 2);
+                } catch (Exception e) {
+                    System.err.println(e);
+                }
+                File echoedFile = getFileStreamPath("echo");
+
+                upload.setText("Cancel");
+                // this is a 180MB zip file to test with
+                uploading = Ion.with(ProgressBarUpload.this, "http://koush.clockworkmod.com/test/echo")
+                // attach the percentage report to a progress bar.
+                // can also attach to a ProgressDialog with progressDialog.
+                .uploadProgressBar(progressBar)
+                // callbacks on progress can happen on the UI thread
+                // via progressHandler. This is useful if you need to update a TextView.
+                // Updates to TextViews MUST happen on the UI thread.
+                .uploadProgressHandler(new ProgressCallback() {
+                    @Override
+                    public void onProgress(int downloaded, int total) {
+                        uploadCount.setText("" + downloaded + " / " + total);
+                    }
+                })
+                // write to a file
+                .setMultipartFile("largefile", f)
+                .write(echoedFile)
+                // run a callback on completion
+                .setCallback(new FutureCallback<File>() {
+                    @Override
+                    public void onCompleted(Exception e, File result) {
+                        resetUpload();
+                        if (e != null) {
+                            Toast.makeText(ProgressBarUpload.this, "Error uploading file", Toast.LENGTH_LONG).show();
+                            return;
+                        }
+                        Toast.makeText(ProgressBarUpload.this, "File upload complete", Toast.LENGTH_LONG).show();
+                    }
+                });
+            }
+        });
+    }
+
+    void resetUpload() {
+        // cancel any pending upload
+        uploading.cancel();
+        uploading = null;
+
+        // reset the ui
+        upload.setText("Upload");
+        uploadCount.setText(null);
+        progressBar.setProgress(0);
+    }
+}
diff --git a/ion-sample/src/com/koushikdutta/ion/sample/Samples.java b/ion-sample/src/com/koushikdutta/ion/sample/Samples.java
index f54db0d1..3a7172f5 100644
--- a/ion-sample/src/com/koushikdutta/ion/sample/Samples.java
+++ b/ion-sample/src/com/koushikdutta/ion/sample/Samples.java
@@ -40,6 +40,14 @@ public void onClick(View v) {
             }
         });
 
+        Button fileUpload = (Button)findViewById(R.id.upload);
+        fileUpload.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                startActivity(new Intent(Samples.this, ProgressBarUpload.class));
+            }
+        });
+
         Button googleImageSearch = (Button)findViewById(R.id.google_image_search);
         googleImageSearch.setOnClickListener(new View.OnClickListener() {
             @Override
diff --git a/ion-test/res/.gitignore b/ion-test/res/.gitignore
new file mode 100644
index 00000000..e69de29b
diff --git a/ion-test/src/com/koushikdutta/ion/test/BitmapTests.java b/ion-test/src/com/koushikdutta/ion/test/BitmapTests.java
index 156dfe05..a6e4ab30 100644
--- a/ion-test/src/com/koushikdutta/ion/test/BitmapTests.java
+++ b/ion-test/src/com/koushikdutta/ion/test/BitmapTests.java
@@ -66,4 +66,21 @@ public void onCompleted(Exception e, Bitmap result) {
             AsyncServer.getDefault().stop();
         }
     }
+
+    public void testCropping() throws Exception {
+        Bitmap result = Ion.with(getContext())
+        .load("https://raw.github.com/koush/ion/master/ion-test/testdata/exif.jpg")
+        .withBitmap()
+        .resize(1080, 1845)
+        .centerCrop()
+        .asBitmap()
+        .get();
+
+        assertEquals(result.getWidth(), 1080);
+        assertEquals(result.getHeight(), 1845);
+        // pixel should not be clear
+        int pixel = result.getPixel(1079, 1844);
+        System.out.println(String.format("%x", pixel));
+        assertFalse(0 == pixel);
+    }
 }
diff --git a/ion-test/src/com/koushikdutta/ion/test/CustomParserTests.java b/ion-test/src/com/koushikdutta/ion/test/CustomParserTests.java
new file mode 100644
index 00000000..e42f28bc
--- /dev/null
+++ b/ion-test/src/com/koushikdutta/ion/test/CustomParserTests.java
@@ -0,0 +1,16 @@
+package com.koushikdutta.ion.test;
+
+import android.test.AndroidTestCase;
+
+import com.koushikdutta.async.parser.StringParser;
+import com.koushikdutta.ion.Ion;
+
+/**
+ * Created by koush on 12/17/13.
+ */
+public class CustomParserTests extends AndroidTestCase {
+    public void testCustomParser() throws Exception {
+        assertNotNull(Ion.with(getContext(), "https://raw.github.com/koush/AndroidAsync/master/AndroidAsyncTest/testdata/test.json")
+        .as(new StringParser()).get());
+    }
+}
diff --git a/ion-test/src/com/koushikdutta/ion/test/Issue74.java b/ion-test/src/com/koushikdutta/ion/test/Issues.java
similarity index 58%
rename from ion-test/src/com/koushikdutta/ion/test/Issue74.java
rename to ion-test/src/com/koushikdutta/ion/test/Issues.java
index da41005a..77ff7588 100644
--- a/ion-test/src/com/koushikdutta/ion/test/Issue74.java
+++ b/ion-test/src/com/koushikdutta/ion/test/Issues.java
@@ -1,5 +1,6 @@
 package com.koushikdutta.ion.test;
 
+import android.graphics.Bitmap;
 import android.test.AndroidTestCase;
 import android.util.Log;
 
@@ -8,8 +9,8 @@
 /**
  * Created by koush on 10/27/13.
  */
-public class Issue74 extends AndroidTestCase {
-    public void testIssue() throws Exception {
+public class Issues extends AndroidTestCase {
+    public void testIssue74() throws Exception {
         String data = Ion.with(getContext(), "https://raw.github.com/koush/AndroidAsync/master/AndroidAsyncTest/testdata/test.json")
         .setLogging("MyLogs", Log.VERBOSE)
         .asString().get();
@@ -20,4 +21,15 @@ public void testIssue() throws Exception {
 
         assertEquals(data, data2);
     }
+
+    public void testIssue126() throws Exception {
+        Bitmap bitmap = Ion.with(getContext())
+        .load("http://bdc.tsingyuan.cn/api/img?w=advanced")
+        .setLogging("Issue126", Log.VERBOSE)
+        .asBitmap()
+        .get();
+
+        assertNotNull(bitmap);
+        assertTrue(bitmap.getWidth() > 0);
+    }
 }
diff --git a/ion/Android.mk b/ion/Android.mk
index 5310f095..49b9fc64 100644
--- a/ion/Android.mk
+++ b/ion/Android.mk
@@ -21,7 +21,7 @@ include $(CLEAR_VARS)
 LOCAL_STATIC_JAVA_LIBRARIES := AndroidAsync gson
 
 LOCAL_MODULE := ion
-LOCAL_SDK_VERSION := 9
+LOCAL_SDK_VERSION := 19
 LOCAL_SRC_FILES := $(call all-java-files-under, src)
 
 include $(BUILD_STATIC_JAVA_LIBRARY)
diff --git a/ion/AndroidManifest.xml b/ion/AndroidManifest.xml
index d2f318a2..6d5cb869 100644
--- a/ion/AndroidManifest.xml
+++ b/ion/AndroidManifest.xml
@@ -1,8 +1,8 @@
 <?xml version="1.0" encoding="utf-8"?>
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
           package="com.koushikdutta.ion"
-          android:versionCode="120"
-          android:versionName="1.2.0">
+          android:versionCode="121"
+          android:versionName="1.2.1">
     <uses-sdk android:minSdkVersion="9" android:targetSdkVersion="18" />
     <application />
 </manifest>
diff --git a/ion/src/com/koushikdutta/ion/BitmapToBitmapInfo.java b/ion/src/com/koushikdutta/ion/BitmapToBitmapInfo.java
index 72739cb7..cd225460 100644
--- a/ion/src/com/koushikdutta/ion/BitmapToBitmapInfo.java
+++ b/ion/src/com/koushikdutta/ion/BitmapToBitmapInfo.java
@@ -9,7 +9,9 @@
 import com.koushikdutta.async.http.libcore.DiskLruCache;
 import com.koushikdutta.ion.bitmap.BitmapInfo;
 import com.koushikdutta.ion.bitmap.Transform;
+import com.koushikdutta.ion.loader.FileLoader;
 
+import java.io.BufferedInputStream;
 import java.io.DataInputStream;
 import java.io.FileInputStream;
 import java.io.InputStream;
@@ -21,32 +23,42 @@
     ArrayList<Transform> transforms;
 
     public static void getBitmapSnapshot(final Ion ion, final String transformKey) {
-        ion.getServer().getExecutorService().execute(new Runnable() {
+        final BitmapCallback callback = new BitmapCallback(ion, transformKey, true);
+        Ion.getBitmapLoadExecutorService().execute(new Runnable() {
             @Override
             public void run() {
-                final LoadBitmap callback = new LoadBitmap(ion, transformKey, true, -1, -1, null);
+                if (ion.bitmapsPending.tag(transformKey) != callback) {
+                    Log.d("IonBitmapLoader", "Bitmap cache load cancelled (no longer needed)");
+                    return;
+                }
 
                 try {
                     DiskLruCache.Snapshot snapshot = ion.responseCache.getDiskLruCache().get(transformKey);
                     try {
                         InputStream in = snapshot.getInputStream(0);
                         assert in instanceof FileInputStream;
-                        int available = in.available();
-                        ByteBuffer b = ByteBufferList.obtain(available);
-                        new DataInputStream(in).readFully(b.array(), 0, available);
-                        b.limit(available);
-                        callback.onCompleted(null, new ByteBufferList(b));
-                    }
-                    finally {
+                        Bitmap bitmap = ion.getBitmapCache().loadBitmap(in, -1, -1);
+                        in.close();
+                        if (bitmap == null)
+                            throw new Exception("Bitmap failed to load");
+
+                        BitmapInfo info = new BitmapInfo();
+                        info.bitmaps = new Bitmap[] { bitmap };
+                        info.loadedFrom =  Loader.LoaderEmitter.LOADED_FROM_CACHE;
+                        info.key = transformKey;
+                        callback.report(null, info);
+                    } finally {
                         snapshot.close();
                     }
                 }
+                catch (OutOfMemoryError e) {
+                    callback.report(new Exception(e), null);
+                }
                 catch (Exception e) {
-                    callback.onCompleted(e, null);
+                    callback.report(e, null);
                     try {
                         ion.responseCache.getDiskLruCache().remove(transformKey);
-                    }
-                    catch (Exception ex) {
+                    } catch (Exception ex) {
                     }
                 }
             }
@@ -72,7 +84,7 @@ public void onCompleted(Exception e, final BitmapInfo result) {
             return;
         }
 
-        ion.getServer().getExecutorService().execute(new Runnable() {
+        Ion.getBitmapLoadExecutorService().execute(new Runnable() {
             @Override
             public void run() {
                 BitmapInfo info = new BitmapInfo();
@@ -80,14 +92,22 @@ public void run() {
                 try {
                     for (int i = 0; i < result.bitmaps.length; i++) {
                         for (Transform transform : transforms) {
-                            info.bitmaps[i] = transform.transform(result.bitmaps[i]);
+                            Bitmap bitmap = transform.transform(result.bitmaps[i]);
+                            if (bitmap == null)
+                                throw new Exception("failed to transform bitmap");
+                            info.bitmaps[i] = bitmap;
                         }
                     }
                     info.delays = result.delays;
                     info.loadedFrom = result.loadedFrom;
                     info.key = key;
                     report(null, info);
-                } catch (Exception e) {
+                }
+                catch (OutOfMemoryError e) {
+                    report(new Exception(e), null);
+                    return;
+                }
+                catch (Exception e) {
                     report(e, null);
                     return;
                 }
@@ -112,12 +132,10 @@ public void run() {
                         info.bitmaps[0].compress(format, 100, out);
                         out.close();
                         editor.commit();
-                    }
-                    catch (Exception ex) {
+                    } catch (Exception ex) {
                         editor.abort();
                     }
-                }
-                catch (Exception e) {
+                } catch (Exception e) {
                 }
             }
         });
diff --git a/ion/src/com/koushikdutta/ion/DefaultTransform.java b/ion/src/com/koushikdutta/ion/DefaultTransform.java
index 24e92878..c60a4824 100644
--- a/ion/src/com/koushikdutta/ion/DefaultTransform.java
+++ b/ion/src/com/koushikdutta/ion/DefaultTransform.java
@@ -38,7 +38,7 @@ public Bitmap transform(Bitmap b) {
             float postHeight = b.getHeight() * ratio;
             float transx = (resizeWidth - postWidth) / 2;
             float transy = (resizeHeight - postHeight) / 2;
-            destination.set(transx, transy, transx + postWidth, transy + postHeight);
+            destination.set(transx, transy, resizeWidth - transx, resizeHeight - transy);
         }
 
         canvas.drawBitmap(b, null, destination, null);
diff --git a/ion/src/com/koushikdutta/ion/DiskLruCacheStore.java b/ion/src/com/koushikdutta/ion/DiskLruCacheStore.java
index c0563b32..c3ea3e45 100644
--- a/ion/src/com/koushikdutta/ion/DiskLruCacheStore.java
+++ b/ion/src/com/koushikdutta/ion/DiskLruCacheStore.java
@@ -36,7 +36,7 @@
 
     private <T> Future<T> put(final String rawKey, final T value, final AsyncParser<T> parser) {
         final SimpleFuture<T> ret = new SimpleFuture<T>();
-        ion.getServer().getExecutorService().execute(new Runnable() {
+        Ion.getIoExecutorService().execute(new Runnable() {
             @Override
             public void run() {
                 final DiskLruCache.Editor editor;
@@ -132,8 +132,8 @@ public void onCompleted(Exception ex) {
     
     private <T> Future<T> get(final String rawKey, final AsyncParser<T> parser) {
         final SimpleFuture<T> ret = new SimpleFuture<T>();
-        
-        ion.getServer().getExecutorService().execute(new Runnable() {
+
+        Ion.getIoExecutorService().execute(new Runnable() {
             @Override
             public void run() {
                 try {
@@ -190,7 +190,7 @@ public void onCompleted(Exception e, T result) {
 
     public Future<String> remove(final String key) {
         final SimpleFuture<String> ret = new SimpleFuture<String>();
-        ion.getServer().getExecutorService().execute(new Runnable() {
+        Ion.getIoExecutorService().execute(new Runnable() {
             @Override
             public void run() {
                 try {
diff --git a/ion/src/com/koushikdutta/ion/Ion.java b/ion/src/com/koushikdutta/ion/Ion.java
index e12654f6..0d1a22b4 100644
--- a/ion/src/com/koushikdutta/ion/Ion.java
+++ b/ion/src/com/koushikdutta/ion/Ion.java
@@ -38,6 +38,7 @@
 import com.koushikdutta.ion.loader.FileLoader;
 import com.koushikdutta.ion.loader.HttpLoader;
 import com.koushikdutta.ion.loader.PackageIconLoader;
+import com.koushikdutta.ion.loader.VideoLoader;
 
 /**
  * Created by koush on 5/21/13.
@@ -45,7 +46,8 @@
 public class Ion {
     static final Handler mainHandler = new Handler(Looper.getMainLooper());
     static int availableProcessors = Runtime.getRuntime().availableProcessors();
-    static ExecutorService singleExecutorService  = availableProcessors > 2 ? null : Executors.newFixedThreadPool(1);
+    static ExecutorService ioExecutorService = Executors.newFixedThreadPool(4);
+    static ExecutorService bitmapExecutorService  = availableProcessors > 2 ? Executors.newFixedThreadPool(availableProcessors - 1) : Executors.newFixedThreadPool(1);
     static HashMap<String, Ion> instances = new HashMap<String, Ion>();
 
     /**
@@ -116,6 +118,8 @@ public static Ion getInstance(Context context, String name) {
     DiskLruCache storeCache;
     HttpLoader httpLoader;
     ContentLoader contentLoader;
+    VideoLoader videoLoader;
+    PackageIconLoader packageIconLoader;
     FileLoader fileLoader;
     String logtag;
     int logLevel;
@@ -156,19 +160,19 @@ private Ion(Context context, String name) {
         bitmapCache = new IonBitmapCache(this);
 
         configure()
-                .addLoader(new PackageIconLoader())
+                .addLoader(videoLoader = new VideoLoader())
+                .addLoader(packageIconLoader = new PackageIconLoader())
                 .addLoader(httpLoader = new HttpLoader())
                 .addLoader(contentLoader = new ContentLoader())
                 .addLoader(fileLoader = new FileLoader());
     }
 
-    // todo: make this static by moving the server's executor service to static
-    public ExecutorService getBitmapLoadExecutorService() {
-        ExecutorService executorService = singleExecutorService;
-        if (executorService == null) {
-            executorService = getServer().getExecutorService();
-        }
-        return executorService;
+    public static ExecutorService getBitmapLoadExecutorService() {
+        return bitmapExecutorService;
+    }
+
+    public static ExecutorService getIoExecutorService() {
+        return ioExecutorService;
     }
 
     /**
@@ -312,7 +316,6 @@ private void addCookieMiddleware() {
 
     /**
      * Get or put an item from the cache
-     * @param key
      * @return
      */
     public DiskLruCacheStore cache() {
@@ -321,7 +324,6 @@ public DiskLruCacheStore cache() {
 
     /**
      * Get or put an item in the persistent store
-     * @param key
      * @return
      */
     public DiskLruCacheStore store() {
@@ -361,6 +363,14 @@ public HttpLoader getHttpLoader() {
             return httpLoader;
         }
 
+        public VideoLoader getVideoLoader() {
+            return videoLoader;
+        }
+
+        public PackageIconLoader getPackageIconLoader() {
+            return packageIconLoader;
+        }
+
         public ContentLoader getContentLoader() {
             return contentLoader;
         }
diff --git a/ion/src/com/koushikdutta/ion/IonBitmapRequestBuilder.java b/ion/src/com/koushikdutta/ion/IonBitmapRequestBuilder.java
index 994f1eb0..49f0c1da 100644
--- a/ion/src/com/koushikdutta/ion/IonBitmapRequestBuilder.java
+++ b/ion/src/com/koushikdutta/ion/IonBitmapRequestBuilder.java
@@ -1,8 +1,10 @@
 package com.koushikdutta.ion;
 
+import android.content.Context;
 import android.graphics.Bitmap;
 import android.graphics.drawable.Drawable;
 import android.os.Looper;
+import android.util.Pair;
 import android.view.animation.Animation;
 import android.view.animation.AnimationUtils;
 import android.widget.ImageView;
@@ -20,6 +22,7 @@
 import com.koushikdutta.ion.bitmap.Transform;
 import com.koushikdutta.ion.builder.BitmapFutureBuilder;
 import com.koushikdutta.ion.builder.Builders;
+import com.koushikdutta.ion.builder.ImageViewBuilder;
 import com.koushikdutta.ion.builder.ImageViewFutureBuilder;
 
 import java.lang.ref.WeakReference;
@@ -29,8 +32,77 @@
  * Created by koush on 5/23/13.
  */
 class IonBitmapRequestBuilder implements Builders.ImageView.F, ImageViewFutureBuilder, BitmapFutureBuilder, Builders.Any.BF {
+    private static final SimpleFuture<ImageView> FUTURE_IMAGEVIEW_NULL_URI = new SimpleFuture<ImageView>() {
+        {
+            setComplete(new NullPointerException("uri"));
+        }
+    };
+    private static final SimpleFuture<Bitmap> FUTURE_BITMAP_NULL_URI = new SimpleFuture<Bitmap>() {
+        {
+            setComplete(new NullPointerException("uri"));
+        }
+    };
+
     IonRequestBuilder builder;
     Ion ion;
+    WeakReference<ImageView> imageViewPostRef;
+    ArrayList<Transform> transforms;
+    Drawable placeholderDrawable;
+    int placeholderResource;
+    Drawable errorDrawable;
+    int errorResource;
+    Animation inAnimation;
+    Animation loadAnimation;
+    int loadAnimationResource;
+    int inAnimationResource;
+    ScaleMode scaleMode = ScaleMode.FitXY;
+    int resizeWidth;
+    int resizeHeight;
+    boolean disableFadeIn;
+    boolean animateGif = true;
+
+
+    void reset() {
+        placeholderDrawable = null;
+        placeholderResource = 0;
+        errorDrawable = null;
+        errorResource = 0;
+        ion = null;
+        imageViewPostRef = null;
+        transforms = null;
+        inAnimation = null;
+        inAnimationResource = 0;
+        loadAnimation = null;
+        loadAnimationResource = 0;
+        scaleMode = ScaleMode.FitXY;
+        resizeWidth = 0;
+        resizeHeight = 0;
+        disableFadeIn = false;
+        animateGif = true;
+        builder = null;
+    }
+
+    public IonBitmapRequestBuilder(IonRequestBuilder builder) {
+        this.builder = builder;
+        ion = builder.ion;
+    }
+
+    public IonBitmapRequestBuilder(Ion ion) {
+        this.ion = ion;
+    }
+
+    static void doAnimation(ImageView imageView, Animation animation, int animationResource) {
+        if (imageView == null)
+            return;
+        if (animation == null && animationResource != 0)
+            animation = AnimationUtils.loadAnimation(imageView.getContext(), animationResource);
+        if (animation == null) {
+            imageView.setAnimation(null);
+            return;
+        }
+
+        imageView.startAnimation(animation);
+    }
 
     private IonRequestBuilder ensureBuilder() {
         if (builder == null)
@@ -52,23 +124,11 @@ private IonRequestBuilder ensureBuilder() {
         return intoImageView(imageViewPostRef.get());
     }
 
-    WeakReference<ImageView> imageViewPostRef;
     IonBitmapRequestBuilder withImageView(ImageView imageView) {
         imageViewPostRef = new WeakReference<ImageView>(imageView);
         return this;
     }
 
-    public IonBitmapRequestBuilder(IonRequestBuilder builder) {
-        this.builder = builder;
-        ion = builder.ion;
-    }
-
-    public IonBitmapRequestBuilder(Ion ion) {
-        this.ion = ion;
-    }
-
-    ArrayList<Transform> transforms;
-
     @Override
     public IonBitmapRequestBuilder transform(Transform transform) {
         if (transforms == null)
@@ -79,7 +139,7 @@ public IonBitmapRequestBuilder transform(Transform transform) {
 
     boolean fastLoad(final String downloadKey, boolean put) {
         for (Loader loader: ion.configure().getLoaders()) {
-            Future<BitmapInfo> future = loader.loadBitmap(ion, builder.uri);
+            Future<BitmapInfo> future = loader.loadBitmap(ion, builder.uri, resizeWidth, resizeHeight);
             if (future != null) {
                 final BitmapCallback callback = new BitmapCallback(ion, downloadKey, put);
                 future.setCallback(new FutureCallback<BitmapInfo>() {
@@ -96,18 +156,25 @@ public void onCompleted(Exception e, BitmapInfo result) {
         return false;
     }
 
-    String bitmapKey;
-    BitmapInfo execute() {
-        final String downloadKey = ResponseCacheMiddleware.toKeyString(builder.uri);
+    private String computeDownloadKey() {
+        String downloadKey = builder.uri;
+        // although a gif is always same download, the initial decode is different
+        if (!animateGif)
+            downloadKey += ":!animateGif";
+        return ResponseCacheMiddleware.toKeyString(downloadKey);
+    }
+
+    Pair<String, BitmapInfo> execute() {
+        final String downloadKey = computeDownloadKey();
         assert Thread.currentThread() == Looper.getMainLooper().getThread() || imageViewPostRef == null;
         assert downloadKey != null;
 
-        if (resizeHeight != 0 || resizeWidth != 0) {
+        if (resizeHeight > 0 || resizeWidth > 0) {
             transform(new DefaultTransform(resizeWidth, resizeHeight, scaleMode));
         }
 
         // determine the key for this bitmap after all transformations
-        bitmapKey = downloadKey;
+        String bitmapKey = downloadKey;
         boolean hasTransforms = transforms != null && transforms.size() > 0;
         if (hasTransforms) {
             for (Transform transform : transforms) {
@@ -120,16 +187,18 @@ BitmapInfo execute() {
         if (!builder.noCache) {
             BitmapInfo bitmap = builder.ion.bitmapCache.get(bitmapKey);
             if (bitmap != null)
-                return bitmap;
+                return new Pair<String, BitmapInfo>(bitmapKey, bitmap);
         }
 
+        Pair<String, BitmapInfo> ret = new Pair<String, BitmapInfo>(bitmapKey, null);
+
         // bitmaps that were transformed are put into the DiskLruCache to prevent
         // subsequent retransformation. See if we can retrieve the bitmap from the disk cache.
         // See BitmapToBitmapInfo for where the cache is populated.
         DiskLruCache diskLruCache = ion.responseCache.getDiskLruCache();
         if (!builder.noCache && hasTransforms && diskLruCache.containsKey(bitmapKey)) {
             BitmapToBitmapInfo.getBitmapSnapshot(ion, bitmapKey);
-            return null;
+            return ret;
         }
 
         // Perform a download as necessary.
@@ -147,12 +216,12 @@ public void run() {
                     });
                 }
             });
-            emitterTransform.setCallback(new LoadBitmap(ion, downloadKey, !hasTransforms, resizeWidth, resizeHeight, emitterTransform));
+            emitterTransform.setCallback(new LoadBitmap(ion, downloadKey, !hasTransforms, resizeWidth, resizeHeight, animateGif, emitterTransform));
         }
 
         // if there's a transform, do it
         if (!hasTransforms)
-            return null;
+            return ret;
 
         // verify this transform isn't already pending
         // make sure that the parent download isn't cancelled (empty list)
@@ -161,21 +230,9 @@ public void run() {
             ion.bitmapsPending.add(downloadKey, new BitmapToBitmapInfo(ion, bitmapKey, downloadKey, transforms));
         }
 
-        return null;
+        return ret;
     }
 
-    private static final SimpleFuture<ImageView> FUTURE_IMAGEVIEW_NULL_URI = new SimpleFuture<ImageView>() {
-        {
-            setComplete(new NullPointerException("uri"));
-        }
-    };
-
-    private static final SimpleFuture<Bitmap> FUTURE_BITMAP_NULL_URI = new SimpleFuture<Bitmap>() {
-        {
-            setComplete(new NullPointerException("uri"));
-        }
-    };
-
     private IonDrawable setIonDrawable(ImageView imageView, BitmapInfo info, int loadedFrom) {
         IonDrawable ret = IonDrawable.getOrCreateIonDrawable(imageView);
         ret.setBitmap(info, loadedFrom);
@@ -196,16 +253,15 @@ private IonDrawable setIonDrawable(ImageView imageView, BitmapInfo info, int loa
 
         // no uri? just set a placeholder and bail
         if (builder.uri == null) {
-            bitmapKey = null;
             setIonDrawable(imageView, null, 0).cancel();
             return FUTURE_IMAGEVIEW_NULL_URI;
         }
 
         // execute the request, see if we get a bitmap from cache.
-        BitmapInfo info = execute();
-        if (info != null) {
+        Pair<String, BitmapInfo> pair = execute();
+        if (pair.second != null) {
             doAnimation(imageView, null, 0);
-            IonDrawable drawable = setIonDrawable(imageView, info, Loader.LoaderEmitter.LOADED_FROM_MEMORY);
+            IonDrawable drawable = setIonDrawable(imageView, pair.second, Loader.LoaderEmitter.LOADED_FROM_MEMORY);
             drawable.cancel();
             SimpleFuture<ImageView> imageViewFuture = drawable.getFuture();
             imageViewFuture.reset();
@@ -218,21 +274,11 @@ private IonDrawable setIonDrawable(ImageView imageView, BitmapInfo info, int loa
         SimpleFuture<ImageView> imageViewFuture = drawable.getFuture();
         imageViewFuture.reset();
 
-        drawable.register(ion, bitmapKey);
+        drawable.register(ion, pair.first);
 
         return imageViewFuture;
     }
 
-    private static class BitmapInfoToBitmap extends TransformFuture<Bitmap, BitmapInfo> {
-        @Override
-        protected void transform(BitmapInfo result) throws Exception {
-            if (result.exception != null)
-                setComplete(result.exception);
-            else
-                setComplete(result.bitmaps[0]);
-        }
-    }
-
     @Override
     public Future<Bitmap> asBitmap() {
         // no uri? just set a placeholder and bail
@@ -241,96 +287,71 @@ protected void transform(BitmapInfo result) throws Exception {
         }
 
         // see if we get something back synchronously
-        BitmapInfo info = execute();
-        if (info != null) {
+        Pair<String, BitmapInfo> pair = execute();
+        if (pair.second != null) {
             SimpleFuture<Bitmap> ret = new SimpleFuture<Bitmap>();
-            Bitmap bitmap = info.bitmaps == null ? null : info.bitmaps[0];
-            ret.setComplete(info.exception, bitmap);
+            Bitmap bitmap = pair.second.bitmaps == null ? null : pair.second.bitmaps[0];
+            ret.setComplete(pair.second.exception, bitmap);
             return ret;
         }
 
         // we're loading, so let's register for the result.
-        BitmapInfoToBitmap ret = new BitmapInfoToBitmap();
-        ion.bitmapsPending.add(bitmapKey, ret);
+        BitmapInfoToBitmap ret = new BitmapInfoToBitmap(builder.context);
+        ion.bitmapsPending.add(pair.first, ret);
         return ret;
     }
 
-    Drawable placeholderDrawable;
-
     @Override
     public IonBitmapRequestBuilder placeholder(Drawable drawable) {
         placeholderDrawable = drawable;
         return this;
     }
 
-    int placeholderResource;
     @Override
     public IonBitmapRequestBuilder placeholder(int resourceId) {
         placeholderResource = resourceId;
         return this;
     }
 
-    Drawable errorDrawable;
     @Override
     public IonBitmapRequestBuilder error(Drawable drawable) {
         errorDrawable = drawable;
         return this;
     }
 
-    int errorResource;
     @Override
     public IonBitmapRequestBuilder error(int resourceId) {
         errorResource = resourceId;
         return this;
     }
 
-    Animation inAnimation;
-
     @Override
     public IonBitmapRequestBuilder animateIn(Animation in) {
         inAnimation = in;
         return this;
     }
 
-    Animation loadAnimation;
-
     @Override
     public IonBitmapRequestBuilder animateLoad(Animation load) {
         loadAnimation = load;
         return this;
     }
 
-    static void doAnimation(ImageView imageView, Animation animation, int animationResource) {
-        if (imageView == null)
-            return;
-        if (animation == null && animationResource != 0)
-            animation = AnimationUtils.loadAnimation(imageView.getContext(), animationResource);
-        if (animation == null) {
-            imageView.setAnimation(null);
-            return;
-        }
-
-        imageView.startAnimation(animation);
-    }
-
-    int loadAnimationResource;
     @Override
     public IonBitmapRequestBuilder animateLoad(int animationResource) {
         loadAnimationResource = animationResource;
         return this;
     }
 
-    int inAnimationResource;
     @Override
     public IonBitmapRequestBuilder animateIn(int animationResource) {
         inAnimationResource = animationResource;
         return this;
     }
 
-    ScaleMode scaleMode = ScaleMode.FitXY;
     @Override
     public IonBitmapRequestBuilder centerCrop() {
-        if (resizeWidth == 0 || resizeHeight == 0)
+        if (resizeWidth <= 0 || resizeHeight <= 0)
             throw new IllegalStateException("must call resize first");
         scaleMode = ScaleMode.CenterCrop;
         return this;
@@ -338,15 +359,12 @@ public IonBitmapRequestBuilder centerCrop() {
 
     @Override
     public IonBitmapRequestBuilder centerInside() {
-        if (resizeWidth == 0 || resizeHeight == 0)
+        if (resizeWidth <= 0 || resizeHeight <= 0)
             throw new IllegalStateException("must call resize first");
         scaleMode = ScaleMode.CenterInside;
         return this;
     }
 
-    int resizeWidth;
-    int resizeHeight;
-
     @Override
     public IonBitmapRequestBuilder resize(int width, int height) {
         resizeWidth = width;
@@ -356,31 +374,51 @@ public IonBitmapRequestBuilder resize(int width, int height) {
         return this;
     }
 
-    private boolean disableFadeIn;
-
     @Override
     public IonBitmapRequestBuilder disableFadeIn() {
         this.disableFadeIn = true;
         return this;
     }
+	
+	public IonBitmapRequestBuilder smartSize(boolean smartSize) {
+        //don't want to disable device resize if user has already resized the Bitmap.
+        if (resizeWidth > 0 || resizeHeight > 0)
+            throw new IllegalStateException("Can't change smart size after resize has been called.");
+
+        if (!smartSize) {
+			resizeWidth = -1;
+			resizeHeight = -1;
+		}
+        else {
+            resizeWidth = 0;
+            resizeHeight = 0;
+        }
+		return this;
+	}
 
-    void reset() {
-        placeholderDrawable = null;
-        placeholderResource = 0;
-        errorDrawable = null;
-        errorResource = 0;
-        ion = null;
-        imageViewPostRef = null;
-        transforms = null;
-        bitmapKey = null;
-        inAnimation = null;
-        inAnimationResource = 0;
-        loadAnimation = null;
-        loadAnimationResource = 0;
-        scaleMode = ScaleMode.FitXY;
-        resizeWidth = 0;
-        resizeHeight = 0;
-        disableFadeIn = false;
-        builder = null;
+    @Override
+    public IonBitmapRequestBuilder animateGif(boolean animateGif) {
+        this.animateGif = animateGif;
+        return this;
+    }
+
+    private static class BitmapInfoToBitmap extends TransformFuture<Bitmap, BitmapInfo> {
+        WeakReference<Context> context;
+        public BitmapInfoToBitmap(WeakReference<Context> context) {
+            this.context = context;
+        }
+
+        @Override
+        protected void transform(BitmapInfo result) throws Exception {
+            if (!IonRequestBuilder.checkContext(context)) {
+                cancel();
+                return;
+            }
+
+            if (result.exception != null)
+                setComplete(result.exception);
+            else
+                setComplete(result.bitmaps[0]);
+        }
     }
 }
diff --git a/ion/src/com/koushikdutta/ion/IonDrawable.java b/ion/src/com/koushikdutta/ion/IonDrawable.java
index fd61a795..be573749 100644
--- a/ion/src/com/koushikdutta/ion/IonDrawable.java
+++ b/ion/src/com/koushikdutta/ion/IonDrawable.java
@@ -60,7 +60,6 @@ public void setInAnimation(Animation inAnimation, int inAnimationResource) {
         private WeakReference<IonDrawable> ionDrawableRef;
         private WeakReference<ImageView> imageViewRef;
         private String bitmapKey;
-        private String parentKey;
         private SimpleFuture<ImageView> imageViewFuture = new SimpleFuture<ImageView>();
         private Animation inAnimation;
         private int inAnimationResource;
@@ -97,6 +96,12 @@ public void onCompleted(Exception e, BitmapInfo result) {
             drawable.setBitmap(result, result.loadedFrom);
             imageView.setImageDrawable(drawable);
             IonBitmapRequestBuilder.doAnimation(imageView, inAnimation, inAnimationResource);
+
+            if (!IonRequestBuilder.checkContext(imageView.getContext())) {
+                imageViewFuture.cancel();
+                return;
+            }
+
             imageViewFuture.setComplete(e, imageView);
         }
     }
@@ -191,16 +196,32 @@ public void setDither(boolean dither) {
         invalidateSelf();
     }
 
+    private Drawable tryGetErrorResource() {
+        if (error != null)
+            return error;
+        if (errorResource == 0)
+            return null;
+        return error = resources.getDrawable(errorResource);
+    }
+
     @Override
     public int getIntrinsicWidth() {
         if (info != null && info.bitmaps != null)
             return info.bitmaps[0].getScaledWidth(resources.getDisplayMetrics().densityDpi);
         if (resizeWidth > 0)
             return resizeWidth;
-        if (error != null)
-            return error.getIntrinsicWidth();
-        if (placeholder != null)
+        if (info != null) {
+            Drawable error = tryGetErrorResource();
+            if (error != null)
+                return error.getIntrinsicWidth();
+        }
+        if (placeholder != null) {
             return placeholder.getIntrinsicWidth();
+        } else if (placeholderResource != 0) {
+            Drawable d = resources.getDrawable(placeholderResource);
+            assert d != null;
+            return d.getIntrinsicWidth();
+        }
         return -1;
     }
 
@@ -210,10 +231,22 @@ public int getIntrinsicHeight() {
             return info.bitmaps[0].getScaledHeight(resources.getDisplayMetrics().densityDpi);
         if (resizeHeight > 0)
             return resizeHeight;
-        if (error != null)
-            return error.getIntrinsicHeight();
-        if (placeholder != null)
+        if (info != null) {
+            if (error != null) {
+                return error.getIntrinsicHeight();
+            } else if (errorResource != 0) {
+                Drawable d = resources.getDrawable(errorResource);
+                assert d != null;
+                return d.getIntrinsicHeight();
+            }
+        }
+        if (placeholder != null) {
             return placeholder.getIntrinsicHeight();
+        } else if (placeholderResource != 0) {
+            Drawable d = resources.getDrawable(placeholderResource);
+            assert d != null;
+            return d.getIntrinsicHeight();
+        }
         return -1;
     }
 
@@ -272,8 +305,7 @@ public void draw(Canvas canvas) {
             }
         }
         else {
-            if (error == null && errorResource != 0)
-                error = resources.getDrawable(errorResource);
+            Drawable error = tryGetErrorResource();
             if (error != null) {
                 error.setAlpha((int)destAlpha);
                 error.setBounds(getBounds());
diff --git a/ion/src/com/koushikdutta/ion/IonRequestBuilder.java b/ion/src/com/koushikdutta/ion/IonRequestBuilder.java
index a2f4ca46..dbdf78fc 100644
--- a/ion/src/com/koushikdutta/ion/IonRequestBuilder.java
+++ b/ion/src/com/koushikdutta/ion/IonRequestBuilder.java
@@ -208,10 +208,14 @@ private static boolean isServiceRunning(Service candidate) {
         return false;
     }
 
-    private boolean checkContext() {
-        Context context = IonRequestBuilder.this.context.get();
+    static boolean checkContext(WeakReference<Context> contextWeakReference) {
+        Context context = contextWeakReference.get();
         if (context == null)
             return false;
+        return checkContext(context);
+    }
+
+    static boolean checkContext(Context context) {
         if (context instanceof Activity) {
             Activity activity = (Activity)context;
             if (activity.isFinishing())
@@ -226,6 +230,10 @@ else if (context instanceof Service) {
         return true;
     }
 
+    private boolean checkContext() {
+        return checkContext(context);
+    }
+
     private <T> void postExecute(final EmitterTransform<T> future, final Exception ex, final T value) {
         final Runnable runner = new Runnable() {
             @Override
@@ -304,7 +312,7 @@ private AsyncHttpRequest prepareRequest(URI uri, AsyncHttpRequestBody wrappedBod
                 public void onProgress(final int downloaded, final int total) {
                     assert Thread.currentThread() != Looper.getMainLooper().getThread();
 
-                    int percent = (int)((float)total / total * 100f);
+                    final int percent = (int)((float)downloaded / total * 100f);
 
                     if (uploadProgressBar != null)
                         uploadProgressBar.setProgress(percent);
@@ -602,14 +610,19 @@ public void onCompleted(Exception e, T result) {
         return execute(new InputStreamParser());
     }
 
+    @Override
+    public <T> ResponseFuture<T> as(AsyncParser<T> parser) {
+        return execute(parser);
+    }
+
     @Override
     public <F extends OutputStream> ResponseFuture<F> write(F outputStream, boolean close) {
-        return execute(new OutputStreamDataSink(ion.getServer(), outputStream, false), close, outputStream);
+        return execute(new OutputStreamDataSink(ion.getServer(), outputStream), close, outputStream);
     }
 
     @Override
     public <F extends OutputStream> ResponseFuture<F> write(F outputStream) {
-        return execute(new OutputStreamDataSink(ion.getServer(), outputStream, false), true, outputStream);
+        return execute(new OutputStreamDataSink(ion.getServer(), outputStream), true, outputStream);
     }
 
     @Override
diff --git a/ion/src/com/koushikdutta/ion/LoadBitmap.java b/ion/src/com/koushikdutta/ion/LoadBitmap.java
index 8d5323d1..0133e85a 100644
--- a/ion/src/com/koushikdutta/ion/LoadBitmap.java
+++ b/ion/src/com/koushikdutta/ion/LoadBitmap.java
@@ -19,12 +19,13 @@
     int resizeWidth;
     int resizeHeight;
     IonRequestBuilder.EmitterTransform<ByteBufferList> emitterTransform;
+    boolean animateGif;
 
-
-    public LoadBitmap(Ion ion, String urlKey, boolean put, int resizeWidth, int resizeHeight, IonRequestBuilder.EmitterTransform<ByteBufferList> emitterTransform) {
+    public LoadBitmap(Ion ion, String urlKey, boolean put, int resizeWidth, int resizeHeight, boolean animateGif, IonRequestBuilder.EmitterTransform<ByteBufferList> emitterTransform) {
         super(ion, urlKey, put);
         this.resizeWidth = resizeWidth;
         this.resizeHeight = resizeHeight;
+        this.animateGif = animateGif;
         this.emitterTransform = emitterTransform;
     }
 
@@ -49,14 +50,12 @@ public void onCompleted(Exception e, final ByteBufferList result) {
         }
 
         if (ion.bitmapsPending.tag(key) != this) {
-            Log.d("IonBitmapLoader", "Bitmap load cancelled (no longer needed)");
+//            Log.d("IonBitmapLoader", "Bitmap load cancelled (no longer needed)");
             result.recycle();
             return;
         }
 
-        ExecutorService executorService = ion.getBitmapLoadExecutorService();
-
-        executorService.execute(new Runnable() {
+        Ion.getBitmapLoadExecutorService().execute(new Runnable() {
             @Override
             public void run() {
                 ByteBuffer bb = result.getAll();
@@ -64,28 +63,30 @@ public void run() {
                     Bitmap[] bitmaps;
                     int[] delays;
                     if (!isGif()) {
-                        bitmaps = new Bitmap[1];
-                        bitmaps[0] = ion.bitmapCache.loadBitmap(bb.array(), bb.arrayOffset() + bb.position(), bb.remaining(), resizeWidth, resizeHeight);
+                        Bitmap bitmap = ion.bitmapCache.loadBitmap(bb.array(), bb.arrayOffset() + bb.position(), bb.remaining(), resizeWidth, resizeHeight);
+                        if (bitmap == null)
+                            throw new Exception("failed to transform bitmap");
+                        bitmaps = new Bitmap[] { bitmap };
                         delays = null;
                     }
                     else {
                         GifDecoder decoder = new GifDecoder(bb.array(), bb.arrayOffset() + bb.position(), bb.remaining(), new GifAction() {
                             @Override
                             public boolean parseOk(boolean parseStatus, int frameIndex) {
-                                return frameIndex < 100;
+                                return animateGif;
                             }
                         });
                         decoder.run();
                         bitmaps = new Bitmap[decoder.getFrameCount()];
                         delays = decoder.getDelays();
                         for (int i = 0; i < decoder.getFrameCount(); i++) {
-                            bitmaps[i] = decoder.getFrameImage(i);
+                            Bitmap bitmap = decoder.getFrameImage(i);
+                            if (bitmap == null)
+                                throw new Exception("failed to transform bitmap");
+                            bitmaps[i] = bitmap;
                         }
                     }
 
-                    if (bitmaps[0] == null)
-                        throw new Exception("bitmap failed to load");
-
                     BitmapInfo info = new BitmapInfo();
                     info.key = key;
                     info.bitmaps = bitmaps;
@@ -96,7 +97,11 @@ public boolean parseOk(boolean parseStatus, int frameIndex) {
                         info.loadedFrom = Loader.LoaderEmitter.LOADED_FROM_CACHE;
 
                     report(null, info);
-                } catch (Exception e) {
+                }
+                catch (OutOfMemoryError e) {
+                    report(new Exception(e), null);
+                }
+                catch (Exception e) {
                     report(e, null);
                 }
                 finally {
diff --git a/ion/src/com/koushikdutta/ion/LoadBitmapStream.java b/ion/src/com/koushikdutta/ion/LoadBitmapStream.java
index 26fcc66e..a8994e13 100644
--- a/ion/src/com/koushikdutta/ion/LoadBitmapStream.java
+++ b/ion/src/com/koushikdutta/ion/LoadBitmapStream.java
@@ -43,7 +43,7 @@ public void onCompleted(Exception e, final InputStream result) {
             return;
         }
 
-        ion.getServer().getExecutorService().execute(new Runnable() {
+        Ion.getBitmapLoadExecutorService().execute(new Runnable() {
             @Override
             public void run() {
                 loadInputStream(result);
diff --git a/ion/src/com/koushikdutta/ion/Loader.java b/ion/src/com/koushikdutta/ion/Loader.java
index 655a3018..98da1c84 100644
--- a/ion/src/com/koushikdutta/ion/Loader.java
+++ b/ion/src/com/koushikdutta/ion/Loader.java
@@ -1,7 +1,5 @@
 package com.koushikdutta.ion;
 
-import android.graphics.Bitmap;
-
 import com.koushikdutta.async.DataEmitter;
 import com.koushikdutta.async.future.Future;
 import com.koushikdutta.async.future.FutureCallback;
@@ -59,5 +57,5 @@ public AsyncHttpRequest getRequest() {
     // otherwise it returns null, and Ion continues to the next loader.
     public Future<DataEmitter> load(Ion ion, AsyncHttpRequest request, FutureCallback<LoaderEmitter> callback);
 
-    public Future<BitmapInfo> loadBitmap(Ion ion, String uri);
+    public Future<BitmapInfo> loadBitmap(Ion ion, String uri, int resizeWidth, int resizeHeight);
 }
diff --git a/ion/src/com/koushikdutta/ion/bitmap/BitmapInfo.java b/ion/src/com/koushikdutta/ion/bitmap/BitmapInfo.java
index 088028ab..c0eb8ac4 100644
--- a/ion/src/com/koushikdutta/ion/bitmap/BitmapInfo.java
+++ b/ion/src/com/koushikdutta/ion/bitmap/BitmapInfo.java
@@ -15,7 +15,6 @@
     public Bitmap[] bitmaps;
     public int[] delays;
     public Exception exception;
-    public WeakReference<Bitmap> bitmapRef;
 
     public int sizeOf() {
         if (bitmaps == null)
diff --git a/ion/src/com/koushikdutta/ion/bitmap/IonBitmapCache.java b/ion/src/com/koushikdutta/ion/bitmap/IonBitmapCache.java
index 76f4b76f..b2035f4d 100644
--- a/ion/src/com/koushikdutta/ion/bitmap/IonBitmapCache.java
+++ b/ion/src/com/koushikdutta/ion/bitmap/IonBitmapCache.java
@@ -6,9 +6,8 @@
 import android.content.res.Resources;
 import android.graphics.Bitmap;
 import android.graphics.BitmapFactory;
-import android.graphics.Canvas;
 import android.graphics.Matrix;
-import android.graphics.Paint;
+import android.graphics.Point;
 import android.os.Looper;
 import android.util.DisplayMetrics;
 import android.util.Log;
@@ -16,6 +15,7 @@
 
 import com.koushikdutta.ion.Ion;
 
+import java.io.BufferedInputStream;
 import java.io.InputStream;
 
 /**
@@ -50,13 +50,27 @@ public IonBitmapCache(Ion ion) {
     }
 
     public BitmapInfo remove(String key) {
-        return cache.remove(key);
+        return cache.removeBitmapInfo(key);
+    }
+
+    public void clear() {
+        cache.evictAllBitmapInfo();
+    }
+
+    double heapRatio = 1d / 7d;
+    public double getHeapRatio() {
+        return heapRatio;
+    }
+
+    public void setHeapRatio(double heapRatio) {
+        this.heapRatio = heapRatio;
     }
 
     public void put(BitmapInfo info) {
         assert Thread.currentThread() == Looper.getMainLooper().getThread();
-        if (getHeapSize(ion.getContext()) != cache.maxSize())
-            cache.setMaxSize(getHeapSize(ion.getContext()) / 7);
+        int maxSize = (int)(getHeapSize(ion.getContext()) * heapRatio);
+        if (maxSize != cache.maxSize())
+            cache.setMaxSize(maxSize);
         cache.put(info.key, info);
     }
 
@@ -65,31 +79,16 @@ public BitmapInfo get(String key) {
             return null;
 
         // see if this thing has an immediate cache hit
-        BitmapInfo ret = cache.get(key);
+        BitmapInfo ret = cache.getBitmapInfo(key);
         if (ret == null || ret.bitmaps != null)
             return ret;
 
-        // see if the the bitmap got evicted and put into a weak ref
-        if (ret.bitmapRef != null) {
-            Bitmap bitmap = ret.bitmapRef.get();
-            // see if we successfully repopulated from the weak ref
-            if (ret.bitmaps != null) {
-                cache.remove(key);
-                ret.bitmaps = new Bitmap[] { bitmap };
-                ret.bitmapRef = null;
-                cache.put(key, ret);
-                System.out.println("===== SUCCESSFULLY GRABBED FROM WEAK REF CACHE! ====");
-                return ret;
-            }
-            // ok, fall through and toss this, it's useless.
-        }
-        else {
-            // if this bitmap load previously errored out, see if it is time to retry
-            // the fetch. connectivity error, server failure, etc, shouldn't be
-            // cached indefinitely...
-            if (ret.loadTime + errorCacheDuration > System.currentTimeMillis())
-                return ret;
-        }
+        // if this bitmap load previously errored out, see if it is time to retry
+        // the fetch. connectivity error, server failure, etc, shouldn't be
+        // cached indefinitely...
+        if (ret.loadTime + errorCacheDuration > System.currentTimeMillis())
+            return ret;
+
         cache.remove(key);
         return null;
     }
@@ -99,8 +98,7 @@ public void dump() {
         Log.i("IonBitmapCache", "freeMemory: " + Runtime.getRuntime().freeMemory());
     }
 
-    public Bitmap loadBitmap(byte[] bytes, int offset, int length, int minx, int miny) {
-        assert Thread.currentThread() != Looper.getMainLooper().getThread();
+    private Point computeTarget(int minx, int miny) {
         int targetWidth = minx;
         int targetHeight = miny;
         if (targetWidth == 0)
@@ -111,19 +109,28 @@ public Bitmap loadBitmap(byte[] bytes, int offset, int length, int minx, int min
             targetHeight = metrics.heightPixels;
         if (targetHeight <= 0)
             targetHeight = Integer.MAX_VALUE;
+        return new Point(targetWidth, targetHeight);
+    }
+
+    public Bitmap loadBitmap(byte[] bytes, int offset, int length, int minx, int miny) {
+        assert Thread.currentThread() != Looper.getMainLooper().getThread();
+        Point target = computeTarget(minx, miny);
 
         BitmapFactory.Options o = null;
-        if (targetWidth != Integer.MAX_VALUE || targetHeight != Integer.MAX_VALUE) {
+        if (target.x != Integer.MAX_VALUE || target.y != Integer.MAX_VALUE) {
             o = new BitmapFactory.Options();
             o.inJustDecodeBounds = true;
             BitmapFactory.decodeByteArray(bytes, offset, length, o);
             if (o.outWidth < 0 || o.outHeight < 0)
                 return null;
-            int scale = Math.max(o.outWidth / targetWidth, o.outHeight / targetHeight);
+            int scale = Math.max(o.outWidth / target.x, o.outHeight / target.y);
             o = new BitmapFactory.Options();
             o.inSampleSize = scale;
         }
+
         Bitmap bitmap = BitmapFactory.decodeByteArray(bytes, offset, length, o);
+        if (bitmap == null)
+            return null;
 
         int rotation = Exif.getOrientation(bytes, offset, length);
         if (rotation == 0)
@@ -135,22 +142,24 @@ public Bitmap loadBitmap(byte[] bytes, int offset, int length, int minx, int min
     }
 
     public Bitmap loadBitmap(InputStream stream, int minx, int miny) {
-        if (!stream.markSupported())
-            stream = new MarkableInputStream(stream);
+        stream = new BufferedInputStream(stream, 64 * 1024);
         assert Thread.currentThread() != Looper.getMainLooper().getThread();
-        int targetWidth = minx;
-        int targetHeight = miny;
-        if (targetWidth == 0)
-            targetWidth = metrics.widthPixels;
-        if (targetWidth <= 0)
-            targetWidth = Integer.MAX_VALUE;
-        if (targetHeight == 0)
-            targetHeight = metrics.heightPixels;
-        if (targetHeight <= 0)
-            targetHeight = Integer.MAX_VALUE;
+        Point target = computeTarget(minx, miny);
+
+        int rotation;
+        try {
+            byte[] bytes = new byte[50000];
+            stream.mark(Integer.MAX_VALUE);
+            int length = stream.read(bytes);
+            rotation = Exif.getOrientation(bytes, 0, length);
+            stream.reset();
+        }
+        catch (Exception e) {
+            rotation = 0;
+        }
 
         BitmapFactory.Options o = null;
-        if (targetWidth != Integer.MAX_VALUE || targetHeight != Integer.MAX_VALUE) {
+        if (target.x != Integer.MAX_VALUE || target.y != Integer.MAX_VALUE) {
             o = new BitmapFactory.Options();
             o.inJustDecodeBounds = true;
             stream.mark(Integer.MAX_VALUE);
@@ -163,11 +172,21 @@ public Bitmap loadBitmap(InputStream stream, int minx, int miny) {
             catch (Exception e) {
                 return null;
             }
-            int scale = Math.max(o.outWidth / targetWidth, o.outHeight / targetHeight);
+            int scale = Math.max(o.outWidth / target.x, o.outHeight / target.y);
             o = new BitmapFactory.Options();
             o.inSampleSize = scale;
         }
-        return BitmapFactory.decodeStream(stream, null, o);
+
+        Bitmap bitmap = BitmapFactory.decodeStream(stream, null, o);
+        if (bitmap == null)
+            return null;
+
+        if (rotation == 0)
+            return bitmap;
+
+        Matrix matrix = new Matrix();
+        matrix.postRotate(rotation);
+        return Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(), bitmap.getHeight(), matrix, true);
     }
 
     private static int getHeapSize(final Context context) {
diff --git a/ion/src/com/koushikdutta/ion/bitmap/LruBitmapCache.java b/ion/src/com/koushikdutta/ion/bitmap/LruBitmapCache.java
index a72316a1..8213e32c 100644
--- a/ion/src/com/koushikdutta/ion/bitmap/LruBitmapCache.java
+++ b/ion/src/com/koushikdutta/ion/bitmap/LruBitmapCache.java
@@ -1,56 +1,48 @@
 package com.koushikdutta.ion.bitmap;
 
-import android.graphics.Bitmap;
-import android.util.Log;
-
-import java.lang.ref.WeakReference;
-
 class LruBitmapCache extends LruCache<String, BitmapInfo> {
-	public LruBitmapCache(int maxSize) {
-		super(maxSize);
-	}
-
-	@Override
-	protected int sizeOf(String key, BitmapInfo info) {
-		return info.sizeOf();
-	}
-
-	@Override
-	protected void entryRemoved(boolean evicted, String key, BitmapInfo oldValue, BitmapInfo newValue) {
-		super.entryRemoved(evicted, key, oldValue, newValue);
-/*
-		if( oldValue.bitmaps != null ) {
-			for(Bitmap b:oldValue.bitmaps) {
-				Log.i("LruCache", "Recycling entry in " + key);
-				b.recycle();
-			}
-		}
-*/
-		//TODO keep an eye on this -jake
-		System.gc();
-
-		// this shit is broken
-		if (true)
-			return;
-
-		// on eviction, put the bitmaps into a weak ref
-		if (!evicted)
-			return;
-
-		// toss the oldValue into a weak ref, and play with that.
-		if (oldValue == null)
-			return;
-		if (oldValue.bitmaps == null)
-			return;
-		// don't try to weak ref on gifs, because only one bitmap
-		// ref total will be held.
-		if (oldValue.bitmaps.length > 1)
-			return;
-
-		oldValue.bitmapRef = new WeakReference<Bitmap>(oldValue.bitmaps[0]);
-		oldValue.bitmaps = null;
-		put(key, oldValue);
-	}
-
-
+    private SoftReferenceHashtable<String, BitmapInfo> soft = new SoftReferenceHashtable<String, BitmapInfo>();
+
+    public LruBitmapCache(int maxSize) {
+        super(maxSize);
+    }
+
+    @Override
+    protected int sizeOf(String key, BitmapInfo info) {
+        return info.sizeOf();
+    }
+
+    public BitmapInfo getBitmapInfo(String key) {
+        BitmapInfo ret = get(key);
+        if (ret != null)
+            return ret;
+
+        ret = soft.remove(key);
+        if (ret != null)
+            put(key, ret);
+
+        return ret;
+    }
+
+    public BitmapInfo removeBitmapInfo(String key) {
+        BitmapInfo i1 = soft.remove(key);
+        BitmapInfo i2 = remove(key);
+        if (i2 != null)
+            return i2;
+        return i1;
+    }
+
+    public void evictAllBitmapInfo() {
+        evictAll();
+        soft.clear();
+    }
+
+    @Override
+    protected void entryRemoved(boolean evicted, String key, BitmapInfo oldValue, BitmapInfo newValue) {
+        super.entryRemoved(evicted, key, oldValue, newValue);
+
+        // on eviction, put the bitmaps into the soft ref table
+        if (evicted)
+            soft.put(key, oldValue);
+    }
 }
diff --git a/ion/src/com/koushikdutta/ion/bitmap/MarkableInputStream.java b/ion/src/com/koushikdutta/ion/bitmap/MarkableInputStream.java
index ce4d042d..284a7808 100644
--- a/ion/src/com/koushikdutta/ion/bitmap/MarkableInputStream.java
+++ b/ion/src/com/koushikdutta/ion/bitmap/MarkableInputStream.java
@@ -102,6 +102,13 @@ public void reset(long token) throws IOException {
     private void skip(long current, long target) throws IOException {
         while (current < target) {
             long skipped = in.skip(target - current);
+            if (skipped == 0) {
+                if (read() == -1) {
+                    break; // EOF
+                } else {
+                    skipped = 1;
+                }
+            }
             current += skipped;
         }
     }
diff --git a/ion/src/com/koushikdutta/ion/bitmap/SoftReferenceHashtable.java b/ion/src/com/koushikdutta/ion/bitmap/SoftReferenceHashtable.java
new file mode 100644
index 00000000..6d8c855d
--- /dev/null
+++ b/ion/src/com/koushikdutta/ion/bitmap/SoftReferenceHashtable.java
@@ -0,0 +1,36 @@
+package com.koushikdutta.ion.bitmap;
+
+import java.lang.ref.SoftReference;
+import java.util.Hashtable;
+
+public class SoftReferenceHashtable<K,V> {
+    Hashtable<K, SoftReference<V>> mTable = new Hashtable<K, SoftReference<V>>();
+
+    public V put(K key, V value) {
+        SoftReference<V> old = mTable.put(key, new SoftReference<V>(value));
+        if (old == null)
+            return null;
+        return old.get();
+    }
+
+    public V get(K key) {
+        SoftReference<V> val = mTable.get(key);
+        if (val == null)
+            return null;
+        V ret = val.get();
+        if (ret == null)
+            mTable.remove(key);
+        return ret;
+    }
+
+    public V remove(K k) {
+        SoftReference<V> v = mTable.remove(k);
+        if (v == null)
+            return null;
+        return v.get();
+    }
+
+    public void clear() {
+        mTable.clear();
+    }
+}
\ No newline at end of file
diff --git a/ion/src/com/koushikdutta/ion/builder/BitmapBuilder.java b/ion/src/com/koushikdutta/ion/builder/BitmapBuilder.java
index a542b5ba..596fc03d 100644
--- a/ion/src/com/koushikdutta/ion/builder/BitmapBuilder.java
+++ b/ion/src/com/koushikdutta/ion/builder/BitmapBuilder.java
@@ -36,4 +36,11 @@
      * @return
      */
     public B centerInside();
+
+    /**
+     * Enable/disable automatic resizing to the dimensions of the device when loading the image.
+     * @param smartSize
+     * @return
+     */
+    public B smartSize(boolean smartSize);
 }
diff --git a/ion/src/com/koushikdutta/ion/builder/FutureBuilder.java b/ion/src/com/koushikdutta/ion/builder/FutureBuilder.java
index f18dcb84..dad38128 100644
--- a/ion/src/com/koushikdutta/ion/builder/FutureBuilder.java
+++ b/ion/src/com/koushikdutta/ion/builder/FutureBuilder.java
@@ -5,6 +5,7 @@
 import com.google.gson.JsonArray;
 import com.google.gson.JsonObject;
 import com.google.gson.reflect.TypeToken;
+import com.koushikdutta.async.parser.AsyncParser;
 import com.koushikdutta.ion.future.ResponseFuture;
 
 import org.w3c.dom.Document;
@@ -94,6 +95,14 @@
      */
     public <T> ResponseFuture<T> as(TypeToken<T> token);
 
+    /**
+     * Deserialize a response into an object given a custom parser.
+     * @param parser
+     * @param <T>
+     * @return
+     */
+    public <T> ResponseFuture<T> as(AsyncParser<T> parser);
+
     /**
      * Add this request to a group specified by groupKey. This key can be used in a later call to
      * Ion.cancelAll(groupKey) to cancel all the requests in the same group.
diff --git a/ion/src/com/koushikdutta/ion/builder/ImageViewBuilder.java b/ion/src/com/koushikdutta/ion/builder/ImageViewBuilder.java
index 7756ee00..16a5f40c 100644
--- a/ion/src/com/koushikdutta/ion/builder/ImageViewBuilder.java
+++ b/ion/src/com/koushikdutta/ion/builder/ImageViewBuilder.java
@@ -78,4 +78,10 @@
      */
     public I disableFadeIn();
 
+    /**
+     * Flag to enable or disable animation of GIFs
+     * @param animateGif
+     * @return
+     */
+    public I animateGif(boolean animateGif);
 }
diff --git a/ion/src/com/koushikdutta/ion/loader/ContentLoader.java b/ion/src/com/koushikdutta/ion/loader/ContentLoader.java
index 9ebea232..06354e14 100644
--- a/ion/src/com/koushikdutta/ion/loader/ContentLoader.java
+++ b/ion/src/com/koushikdutta/ion/loader/ContentLoader.java
@@ -16,20 +16,10 @@
 /**
  * Created by koush on 5/22/13.
  */
-public class ContentLoader implements Loader {
+public class ContentLoader extends SimpleLoader {
     private static final class InputStreamDataEmitterFuture extends SimpleFuture<DataEmitter> {
     }
 
-    @Override
-    public Future<BitmapInfo> loadBitmap(Ion ion, final String uri) {
-        return null;
-    }
-
-    @Override
-    public Future<InputStream> load(final Ion ion, final AsyncHttpRequest request) {
-        return null;
-    }
-
     @Override
     public Future<DataEmitter> load(final Ion ion, final AsyncHttpRequest request, final FutureCallback<LoaderEmitter> callback) {
         if (!request.getUri().getScheme().startsWith("content"))
diff --git a/ion/src/com/koushikdutta/ion/loader/FileLoader.java b/ion/src/com/koushikdutta/ion/loader/FileLoader.java
index 904120c0..450556db 100644
--- a/ion/src/com/koushikdutta/ion/loader/FileLoader.java
+++ b/ion/src/com/koushikdutta/ion/loader/FileLoader.java
@@ -1,6 +1,7 @@
 package com.koushikdutta.ion.loader;
 
-import android.net.Uri;
+import android.graphics.Bitmap;
+import android.util.Log;
 
 import com.koushikdutta.async.DataEmitter;
 import com.koushikdutta.async.FileDataEmitter;
@@ -12,20 +13,55 @@
 import com.koushikdutta.ion.Loader;
 import com.koushikdutta.ion.bitmap.BitmapInfo;
 
+import java.io.BufferedInputStream;
 import java.io.File;
 import java.io.FileInputStream;
+import java.io.IOException;
 import java.io.InputStream;
+import java.net.URI;
 
 /**
  * Created by koush on 5/22/13.
  */
-public class FileLoader implements Loader {
+public class FileLoader extends SimpleLoader {
     private static final class FileFuture extends SimpleFuture<DataEmitter> {
     }
 
     @Override
-    public Future<BitmapInfo> loadBitmap(Ion ion, final String uri) {
-        return null;
+    public Future<BitmapInfo> loadBitmap(final Ion ion, final String uri, final int resizeWidth, final int resizeHeight) {
+        if (uri == null || !uri.startsWith("file:/"))
+            return null;
+
+        final SimpleFuture<BitmapInfo> ret = new SimpleFuture<BitmapInfo>();
+
+        Ion.getBitmapLoadExecutorService().execute(new Runnable() {
+            @Override
+            public void run() {
+                if (ret.isCancelled()) {
+//                    Log.d("FileLoader", "Bitmap load cancelled (no longer needed)");
+                    return;
+                }
+                try {
+                    FileInputStream fin = new FileInputStream(new File(URI.create(uri)));
+                    Bitmap bitmap = ion.getBitmapCache().loadBitmap(fin, resizeWidth, resizeHeight);
+                    if (bitmap == null)
+                        throw new Exception("Bitmap failed to load");
+                    BitmapInfo info = new BitmapInfo();
+                    info.bitmaps = new Bitmap[] { bitmap };
+                    info.loadedFrom =  Loader.LoaderEmitter.LOADED_FROM_CACHE;
+                    fin.close();
+                    ret.setComplete(info);
+                }
+                catch (OutOfMemoryError e) {
+                    ret.setComplete(new Exception(e), null);
+                }
+                catch (Exception e) {
+                    ret.setComplete(e);
+                }
+            }
+        });
+
+        return ret;
     }
 
     @Override
@@ -33,14 +69,13 @@
         if (!request.getUri().getScheme().startsWith("file"))
             return null;
         final SimpleFuture<InputStream> ret = new SimpleFuture<InputStream>();
-        ion.getServer().getExecutorService().execute(new Runnable() {
+        Ion.getIoExecutorService().execute(new Runnable() {
             @Override
             public void run() {
                 try {
                     InputStream stream = new FileInputStream(new File(request.getUri()));
                     ret.setComplete(stream);
-                }
-                catch (Exception e) {
+                } catch (Exception e) {
                     ret.setComplete(e);
                 }
             }
diff --git a/ion/src/com/koushikdutta/ion/loader/HttpLoader.java b/ion/src/com/koushikdutta/ion/loader/HttpLoader.java
index 8ea2d22c..0d291d66 100644
--- a/ion/src/com/koushikdutta/ion/loader/HttpLoader.java
+++ b/ion/src/com/koushikdutta/ion/loader/HttpLoader.java
@@ -18,17 +18,7 @@
 /**
  * Created by koush on 5/22/13.
  */
-public class HttpLoader implements Loader {
-    @Override
-    public Future<BitmapInfo> loadBitmap(Ion ion, final String uri) {
-        return null;
-    }
-
-    @Override
-    public Future<InputStream> load(Ion ion, AsyncHttpRequest request) {
-        return null;
-    }
-
+public class HttpLoader extends SimpleLoader {
     @SuppressWarnings("unchecked")
     @Override
     public Future<DataEmitter> load(Ion ion, AsyncHttpRequest request, final FutureCallback<LoaderEmitter> callback) {
diff --git a/ion/src/com/koushikdutta/ion/loader/MediaFile.java b/ion/src/com/koushikdutta/ion/loader/MediaFile.java
new file mode 100644
index 00000000..b8a96832
--- /dev/null
+++ b/ion/src/com/koushikdutta/ion/loader/MediaFile.java
@@ -0,0 +1,364 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ * Copyright (c) 2012, The Linux Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.koushikdutta.ion.loader;
+
+import java.util.HashMap;
+import java.util.Locale;
+
+/**
+ * MediaScanner helper class.
+ *
+ * {@hide}
+ */
+public class MediaFile {
+
+    // Audio file types
+    public static final int FILE_TYPE_MP3     = 1;
+    public static final int FILE_TYPE_M4A     = 2;
+    public static final int FILE_TYPE_WAV     = 3;
+    public static final int FILE_TYPE_AMR     = 4;
+    public static final int FILE_TYPE_AWB     = 5;
+    public static final int FILE_TYPE_WMA     = 6;
+    public static final int FILE_TYPE_OGG     = 7;
+    public static final int FILE_TYPE_AAC     = 8;
+    public static final int FILE_TYPE_MKA     = 9;
+    public static final int FILE_TYPE_FLAC    = 10;
+    public static final int FILE_TYPE_3GPA    = 11;
+    public static final int FILE_TYPE_AC3     = 12;
+    public static final int FILE_TYPE_QCP     = 13;
+    public static final int FILE_TYPE_WEBMA   = 14;
+    public static final int FILE_TYPE_PCM     = 15;
+    public static final int FILE_TYPE_EC3     = 16;
+    private static final int FIRST_AUDIO_FILE_TYPE = FILE_TYPE_MP3;
+    private static final int LAST_AUDIO_FILE_TYPE = FILE_TYPE_EC3;
+
+    // More audio file types
+    public static final int FILE_TYPE_DTS   = 300;
+    private static final int FIRST_AUDIO_FILE_TYPE2 = FILE_TYPE_DTS;
+    private static final int LAST_AUDIO_FILE_TYPE2 = FILE_TYPE_DTS;
+
+    // MIDI file types
+    public static final int FILE_TYPE_MID     = 17;
+    public static final int FILE_TYPE_SMF     = 18;
+    public static final int FILE_TYPE_IMY     = 19;
+    private static final int FIRST_MIDI_FILE_TYPE = FILE_TYPE_MID;
+    private static final int LAST_MIDI_FILE_TYPE = FILE_TYPE_IMY;
+
+    // Video file types
+    public static final int FILE_TYPE_MP4     = 21;
+    public static final int FILE_TYPE_M4V     = 22;
+    public static final int FILE_TYPE_3GPP    = 23;
+    public static final int FILE_TYPE_3GPP2   = 24;
+    public static final int FILE_TYPE_WMV     = 25;
+    public static final int FILE_TYPE_ASF     = 26;
+    public static final int FILE_TYPE_MKV     = 27;
+    public static final int FILE_TYPE_MP2TS   = 28;
+    public static final int FILE_TYPE_AVI     = 29;
+    public static final int FILE_TYPE_WEBM    = 30;
+    public static final int FILE_TYPE_DIVX    = 31;
+    private static final int FIRST_VIDEO_FILE_TYPE = FILE_TYPE_MP4;
+    private static final int LAST_VIDEO_FILE_TYPE = FILE_TYPE_DIVX;
+
+    // More video file types
+    public static final int FILE_TYPE_MP2PS   = 200;
+    private static final int FIRST_VIDEO_FILE_TYPE2 = FILE_TYPE_MP2PS;
+    private static final int LAST_VIDEO_FILE_TYPE2 = FILE_TYPE_MP2PS;
+
+    // Image file types
+    public static final int FILE_TYPE_JPEG    = 32;
+    public static final int FILE_TYPE_GIF     = 33;
+    public static final int FILE_TYPE_PNG     = 34;
+    public static final int FILE_TYPE_BMP     = 35;
+    public static final int FILE_TYPE_WBMP    = 36;
+    public static final int FILE_TYPE_WEBP    = 37;
+    private static final int FIRST_IMAGE_FILE_TYPE = FILE_TYPE_JPEG;
+    private static final int LAST_IMAGE_FILE_TYPE = FILE_TYPE_WEBP;
+
+    // Playlist file types
+    public static final int FILE_TYPE_M3U      = 41;
+    public static final int FILE_TYPE_PLS      = 42;
+    public static final int FILE_TYPE_WPL      = 43;
+    public static final int FILE_TYPE_HTTPLIVE = 44;
+
+    private static final int FIRST_PLAYLIST_FILE_TYPE = FILE_TYPE_M3U;
+    private static final int LAST_PLAYLIST_FILE_TYPE = FILE_TYPE_HTTPLIVE;
+
+    // Drm file types
+    public static final int FILE_TYPE_FL      = 51;
+    private static final int FIRST_DRM_FILE_TYPE = FILE_TYPE_FL;
+    private static final int LAST_DRM_FILE_TYPE = FILE_TYPE_FL;
+
+    // Other popular file types
+    public static final int FILE_TYPE_TEXT          = 100;
+    public static final int FILE_TYPE_HTML          = 101;
+    public static final int FILE_TYPE_PDF           = 102;
+    public static final int FILE_TYPE_XML           = 103;
+    public static final int FILE_TYPE_MS_WORD       = 104;
+    public static final int FILE_TYPE_MS_EXCEL      = 105;
+    public static final int FILE_TYPE_MS_POWERPOINT = 106;
+    public static final int FILE_TYPE_ZIP           = 107;
+
+    public static class MediaFileType {
+        public final int fileType;
+        public final String mimeType;
+
+        MediaFileType(int fileType, String mimeType) {
+            this.fileType = fileType;
+            this.mimeType = mimeType;
+        }
+    }
+
+    private static final HashMap<String, MediaFileType> sFileTypeMap
+            = new HashMap<String, MediaFileType>();
+    private static final HashMap<String, Integer> sMimeTypeMap
+            = new HashMap<String, Integer>();
+    // maps file extension to MTP format code
+    private static final HashMap<String, Integer> sFileTypeToFormatMap
+            = new HashMap<String, Integer>();
+    // maps mime type to MTP format code
+    private static final HashMap<String, Integer> sMimeTypeToFormatMap
+            = new HashMap<String, Integer>();
+    // maps MTP format code to mime type
+    private static final HashMap<Integer, String> sFormatToMimeTypeMap
+            = new HashMap<Integer, String>();
+    private static final HashMap<String, String> sMimeTypeToExtensionMap
+            = new HashMap<String, String>();
+
+    static void addFileType(String extension, int fileType, String mimeType) {
+        sFileTypeMap.put(extension, new MediaFileType(fileType, mimeType));
+        sMimeTypeMap.put(mimeType, Integer.valueOf(fileType));
+    }
+
+    static void addFileType(String extension, int fileType, String mimeType, int mtpFormatCode) {
+        addFileType(extension, fileType, mimeType);
+        sFileTypeToFormatMap.put(extension, Integer.valueOf(mtpFormatCode));
+        sMimeTypeToFormatMap.put(mimeType, Integer.valueOf(mtpFormatCode));
+        sFormatToMimeTypeMap.put(mtpFormatCode, mimeType);
+        sMimeTypeToExtensionMap.put(mimeType, extension);
+    }
+
+    /*
+    private static boolean isWMAEnabled() {
+        List<AudioDecoder> decoders = DecoderCapabilities.getAudioDecoders();
+        int count = decoders.size();
+        for (int i = 0; i < count; i++) {
+            AudioDecoder decoder = decoders.get(i);
+            if (decoder == AudioDecoder.AUDIO_DECODER_WMA) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private static boolean isWMVEnabled() {
+        List<VideoDecoder> decoders = DecoderCapabilities.getVideoDecoders();
+        int count = decoders.size();
+        for (int i = 0; i < count; i++) {
+            VideoDecoder decoder = decoders.get(i);
+            if (decoder == VideoDecoder.VIDEO_DECODER_WMV) {
+                return true;
+            }
+        }
+        return false;
+    }
+    */
+
+    static {
+        addFileType("MP3", FILE_TYPE_MP3, "audio/mpeg", MtpConstants.FORMAT_MP3);
+        addFileType("MPGA", FILE_TYPE_MP3, "audio/mpeg", MtpConstants.FORMAT_MP3);
+        addFileType("M4A", FILE_TYPE_M4A, "audio/mp4", MtpConstants.FORMAT_MPEG);
+        addFileType("WAV", FILE_TYPE_WAV, "audio/x-wav", MtpConstants.FORMAT_WAV);
+        addFileType("WAV", FILE_TYPE_PCM, "audio/wav");
+        addFileType("AMR", FILE_TYPE_AMR, "audio/amr");
+        addFileType("AWB", FILE_TYPE_AWB, "audio/amr-wb");
+        addFileType("DIVX", FILE_TYPE_DIVX, "video/divx");
+        /*
+        if (isWMAEnabled()) {
+            addFileType("WMA", FILE_TYPE_WMA, "audio/x-ms-wma", MtpConstants.FORMAT_WMA);
+        }
+        */
+        addFileType("QCP", FILE_TYPE_QCP, "audio/qcelp");
+        addFileType("OGG", FILE_TYPE_OGG, "audio/ogg", MtpConstants.FORMAT_OGG);
+        addFileType("OGG", FILE_TYPE_OGG, "application/ogg", MtpConstants.FORMAT_OGG);
+        addFileType("OGA", FILE_TYPE_OGG, "audio/ogg", MtpConstants.FORMAT_OGG);
+        addFileType("OGA", FILE_TYPE_OGG, "application/ogg", MtpConstants.FORMAT_OGG);
+        addFileType("AAC", FILE_TYPE_AAC, "audio/aac", MtpConstants.FORMAT_AAC);
+        addFileType("AAC", FILE_TYPE_AAC, "audio/aac-adts", MtpConstants.FORMAT_AAC);
+        addFileType("MKA", FILE_TYPE_MKA, "audio/x-matroska");
+
+        addFileType("MID", FILE_TYPE_MID, "audio/midi");
+        addFileType("MIDI", FILE_TYPE_MID, "audio/midi");
+        addFileType("XMF", FILE_TYPE_MID, "audio/midi");
+        addFileType("RTTTL", FILE_TYPE_MID, "audio/midi");
+        addFileType("SMF", FILE_TYPE_SMF, "audio/sp-midi");
+        addFileType("IMY", FILE_TYPE_IMY, "audio/imelody");
+        addFileType("RTX", FILE_TYPE_MID, "audio/midi");
+        addFileType("OTA", FILE_TYPE_MID, "audio/midi");
+        addFileType("MXMF", FILE_TYPE_MID, "audio/midi");
+
+        addFileType("MPEG", FILE_TYPE_MP4, "video/mpeg", MtpConstants.FORMAT_MPEG);
+        addFileType("MPG", FILE_TYPE_MP4, "video/mpeg", MtpConstants.FORMAT_MPEG);
+        addFileType("MP4", FILE_TYPE_MP4, "video/mp4", MtpConstants.FORMAT_MPEG);
+        addFileType("M4V", FILE_TYPE_M4V, "video/m4v", MtpConstants.FORMAT_MPEG);
+        addFileType("3GP", FILE_TYPE_3GPP, "video/3gpp",  MtpConstants.FORMAT_3GP_CONTAINER);
+        addFileType("3GPP", FILE_TYPE_3GPP, "video/3gpp", MtpConstants.FORMAT_3GP_CONTAINER);
+        addFileType("3G2", FILE_TYPE_3GPP2, "video/3gpp2", MtpConstants.FORMAT_3GP_CONTAINER);
+        addFileType("3GPP2", FILE_TYPE_3GPP2, "video/3gpp2", MtpConstants.FORMAT_3GP_CONTAINER);
+        addFileType("MKV", FILE_TYPE_MKV, "video/x-matroska");
+        addFileType("WEBM", FILE_TYPE_WEBM, "video/webm");
+        addFileType("TS", FILE_TYPE_MP2TS, "video/mp2ts");
+        addFileType("MPG", FILE_TYPE_MP2TS, "video/mp2ts");
+
+        addFileType("AVI", FILE_TYPE_AVI, "video/avi");
+
+        /*
+        if (isWMVEnabled()) {
+            addFileType("WMV", FILE_TYPE_WMV, "video/x-ms-wmv", MtpConstants.FORMAT_WMV);
+            addFileType("ASF", FILE_TYPE_ASF, "video/x-ms-asf");
+        }
+        */
+
+        addFileType("JPG", FILE_TYPE_JPEG, "image/jpeg", MtpConstants.FORMAT_EXIF_JPEG);
+        addFileType("JPEG", FILE_TYPE_JPEG, "image/jpeg", MtpConstants.FORMAT_EXIF_JPEG);
+        addFileType("GIF", FILE_TYPE_GIF, "image/gif", MtpConstants.FORMAT_GIF);
+        addFileType("PNG", FILE_TYPE_PNG, "image/png", MtpConstants.FORMAT_PNG);
+        addFileType("BMP", FILE_TYPE_BMP, "image/x-ms-bmp", MtpConstants.FORMAT_BMP);
+        addFileType("WBMP", FILE_TYPE_WBMP, "image/vnd.wap.wbmp");
+        addFileType("WEBP", FILE_TYPE_WEBP, "image/webp");
+
+        addFileType("M3U", FILE_TYPE_M3U, "audio/x-mpegurl", MtpConstants.FORMAT_M3U_PLAYLIST);
+        addFileType("M3U", FILE_TYPE_M3U, "application/x-mpegurl", MtpConstants.FORMAT_M3U_PLAYLIST);
+        addFileType("PLS", FILE_TYPE_PLS, "audio/x-scpls", MtpConstants.FORMAT_PLS_PLAYLIST);
+        addFileType("WPL", FILE_TYPE_WPL, "application/vnd.ms-wpl", MtpConstants.FORMAT_WPL_PLAYLIST);
+        addFileType("M3U8", FILE_TYPE_HTTPLIVE, "application/vnd.apple.mpegurl");
+        addFileType("M3U8", FILE_TYPE_HTTPLIVE, "audio/mpegurl");
+        addFileType("M3U8", FILE_TYPE_HTTPLIVE, "audio/x-mpegurl");
+
+        addFileType("FL", FILE_TYPE_FL, "application/x-android-drm-fl");
+
+        addFileType("TXT", FILE_TYPE_TEXT, "text/plain", MtpConstants.FORMAT_TEXT);
+        addFileType("HTM", FILE_TYPE_HTML, "text/html", MtpConstants.FORMAT_HTML);
+        addFileType("HTML", FILE_TYPE_HTML, "text/html", MtpConstants.FORMAT_HTML);
+        addFileType("PDF", FILE_TYPE_PDF, "application/pdf");
+        addFileType("DOC", FILE_TYPE_MS_WORD, "application/msword", MtpConstants.FORMAT_MS_WORD_DOCUMENT);
+        addFileType("XLS", FILE_TYPE_MS_EXCEL, "application/vnd.ms-excel", MtpConstants.FORMAT_MS_EXCEL_SPREADSHEET);
+        addFileType("PPT", FILE_TYPE_MS_POWERPOINT, "application/mspowerpoint", MtpConstants.FORMAT_MS_POWERPOINT_PRESENTATION);
+        addFileType("FLAC", FILE_TYPE_FLAC, "audio/flac", MtpConstants.FORMAT_FLAC);
+        addFileType("ZIP", FILE_TYPE_ZIP, "application/zip");
+        addFileType("MPG", FILE_TYPE_MP2PS, "video/mp2p");
+        addFileType("MPEG", FILE_TYPE_MP2PS, "video/mp2p");
+    }
+
+    public static boolean isAudioFileType(int fileType) {
+        return ((fileType >= FIRST_AUDIO_FILE_TYPE &&
+                fileType <= LAST_AUDIO_FILE_TYPE) ||
+                (fileType >= FIRST_MIDI_FILE_TYPE &&
+                fileType <= LAST_MIDI_FILE_TYPE) ||
+                (fileType >= FIRST_AUDIO_FILE_TYPE2 &&
+                fileType <= LAST_AUDIO_FILE_TYPE2));
+    }
+
+    public static boolean isVideoFileType(int fileType) {
+        return (fileType >= FIRST_VIDEO_FILE_TYPE &&
+                fileType <= LAST_VIDEO_FILE_TYPE)
+            || (fileType >= FIRST_VIDEO_FILE_TYPE2 &&
+                fileType <= LAST_VIDEO_FILE_TYPE2);
+    }
+
+    public static boolean isImageFileType(int fileType) {
+        return (fileType >= FIRST_IMAGE_FILE_TYPE &&
+                fileType <= LAST_IMAGE_FILE_TYPE);
+    }
+
+    public static boolean isPlayListFileType(int fileType) {
+        return (fileType >= FIRST_PLAYLIST_FILE_TYPE &&
+                fileType <= LAST_PLAYLIST_FILE_TYPE);
+    }
+
+    public static boolean isDrmFileType(int fileType) {
+        return (fileType >= FIRST_DRM_FILE_TYPE &&
+                fileType <= LAST_DRM_FILE_TYPE);
+    }
+
+    public static MediaFileType getFileType(String path) {
+        int lastDot = path.lastIndexOf('.');
+        if (lastDot < 0)
+            return null;
+        return sFileTypeMap.get(path.substring(lastDot + 1).toUpperCase(Locale.ROOT));
+    }
+
+    public static boolean isMimeTypeMedia(String mimeType) {
+        int fileType = getFileTypeForMimeType(mimeType);
+        return isAudioFileType(fileType) || isVideoFileType(fileType)
+                || isImageFileType(fileType) || isPlayListFileType(fileType);
+    }
+
+    public static String getExtensionForMimeType(String mimeType) {
+        return sMimeTypeToExtensionMap.get(mimeType).toLowerCase();
+    }
+
+    // generates a title based on file name
+    public static String getFileTitle(String path) {
+        // extract file name after last slash
+        int lastSlash = path.lastIndexOf('/');
+        if (lastSlash >= 0) {
+            lastSlash++;
+            if (lastSlash < path.length()) {
+                path = path.substring(lastSlash);
+            }
+        }
+        // truncate the file extension (if any)
+        int lastDot = path.lastIndexOf('.');
+        if (lastDot > 0) {
+            path = path.substring(0, lastDot);
+        }
+        return path;
+    }
+
+    public static int getFileTypeForMimeType(String mimeType) {
+        Integer value = sMimeTypeMap.get(mimeType);
+        return (value == null ? 0 : value.intValue());
+    }
+
+    public static String getMimeTypeForFile(String path) {
+        MediaFileType mediaFileType = getFileType(path);
+        return (mediaFileType == null ? null : mediaFileType.mimeType);
+    }
+
+    public static int getFormatCode(String fileName, String mimeType) {
+        if (mimeType != null) {
+            Integer value = sMimeTypeToFormatMap.get(mimeType);
+            if (value != null) {
+                return value.intValue();
+            }
+        }
+        int lastDot = fileName.lastIndexOf('.');
+        if (lastDot > 0) {
+            String extension = fileName.substring(lastDot + 1).toUpperCase(Locale.ROOT);
+            Integer value = sFileTypeToFormatMap.get(extension);
+            if (value != null) {
+                return value.intValue();
+            }
+        }
+        return MtpConstants.FORMAT_UNDEFINED;
+    }
+
+    public static String getMimeTypeForFormatCode(int formatCode) {
+        return sFormatToMimeTypeMap.get(formatCode);
+    }
+}
diff --git a/ion/src/com/koushikdutta/ion/loader/MtpConstants.java b/ion/src/com/koushikdutta/ion/loader/MtpConstants.java
new file mode 100644
index 00000000..6aaf9f96
--- /dev/null
+++ b/ion/src/com/koushikdutta/ion/loader/MtpConstants.java
@@ -0,0 +1,578 @@
+package com.koushikdutta.ion.loader;
+
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+/**
+ * A class containing constants in the MTP and PTP specifications.
+ */
+public final class MtpConstants {
+
+    // MTP Data Types
+    /** @hide */
+    public static final int TYPE_UNDEFINED = 0x0000;
+    /** @hide */
+    public static final int TYPE_INT8 = 0x0001;
+    /** @hide */
+    public static final int TYPE_UINT8 = 0x0002;
+    /** @hide */
+    public static final int TYPE_INT16 = 0x0003;
+    /** @hide */
+    public static final int TYPE_UINT16 = 0x0004;
+    /** @hide */
+    public static final int TYPE_INT32 = 0x0005;
+    /** @hide */
+    public static final int TYPE_UINT32 = 0x0006;
+    /** @hide */
+    public static final int TYPE_INT64 = 0x0007;
+    /** @hide */
+    public static final int TYPE_UINT64 = 0x0008;
+    /** @hide */
+    public static final int TYPE_INT128 = 0x0009;
+    /** @hide */
+    public static final int TYPE_UINT128 = 0x000A;
+    /** @hide */
+    public static final int TYPE_AINT8 = 0x4001;
+    /** @hide */
+    public static final int TYPE_AUINT8 = 0x4002;
+    /** @hide */
+    public static final int TYPE_AINT16 = 0x4003;
+    /** @hide */
+    public static final int TYPE_AUINT16 = 0x4004;
+    /** @hide */
+    public static final int TYPE_AINT32 = 0x4005;
+    /** @hide */
+    public static final int TYPE_AUINT32 = 0x4006;
+    /** @hide */
+    public static final int TYPE_AINT64 = 0x4007;
+    /** @hide */
+    public static final int TYPE_AUINT64 = 0x4008;
+    /** @hide */
+    public static final int TYPE_AINT128 = 0x4009;
+    /** @hide */
+    public static final int TYPE_AUINT128 = 0x400A;
+    /** @hide */
+    public static final int TYPE_STR = 0xFFFF;
+
+    // MTP Response Codes
+    /** @hide */
+    public static final int RESPONSE_UNDEFINED = 0x2000;
+    /** @hide */
+    public static final int RESPONSE_OK = 0x2001;
+    /** @hide */
+    public static final int RESPONSE_GENERAL_ERROR = 0x2002;
+    /** @hide */
+    public static final int RESPONSE_SESSION_NOT_OPEN = 0x2003;
+    /** @hide */
+    public static final int RESPONSE_INVALID_TRANSACTION_ID = 0x2004;
+    /** @hide */
+    public static final int RESPONSE_OPERATION_NOT_SUPPORTED = 0x2005;
+    /** @hide */
+    public static final int RESPONSE_PARAMETER_NOT_SUPPORTED = 0x2006;
+    /** @hide */
+    public static final int RESPONSE_INCOMPLETE_TRANSFER = 0x2007;
+    /** @hide */
+    public static final int RESPONSE_INVALID_STORAGE_ID = 0x2008;
+    /** @hide */
+    public static final int RESPONSE_INVALID_OBJECT_HANDLE = 0x2009;
+    /** @hide */
+    public static final int RESPONSE_DEVICE_PROP_NOT_SUPPORTED = 0x200A;
+    /** @hide */
+    public static final int RESPONSE_INVALID_OBJECT_FORMAT_CODE = 0x200B;
+    /** @hide */
+    public static final int RESPONSE_STORAGE_FULL = 0x200C;
+    /** @hide */
+    public static final int RESPONSE_OBJECT_WRITE_PROTECTED = 0x200D;
+    /** @hide */
+    public static final int RESPONSE_STORE_READ_ONLY = 0x200E;
+    /** @hide */
+    public static final int RESPONSE_ACCESS_DENIED = 0x200F;
+    /** @hide */
+    public static final int RESPONSE_NO_THUMBNAIL_PRESENT = 0x2010;
+    /** @hide */
+    public static final int RESPONSE_SELF_TEST_FAILED = 0x2011;
+    /** @hide */
+    public static final int RESPONSE_PARTIAL_DELETION = 0x2012;
+    /** @hide */
+    public static final int RESPONSE_STORE_NOT_AVAILABLE = 0x2013;
+    /** @hide */
+    public static final int RESPONSE_SPECIFICATION_BY_FORMAT_UNSUPPORTED = 0x2014;
+    /** @hide */
+    public static final int RESPONSE_NO_VALID_OBJECT_INFO = 0x2015;
+    /** @hide */
+    public static final int RESPONSE_INVALID_CODE_FORMAT = 0x2016;
+    /** @hide */
+    public static final int RESPONSE_UNKNOWN_VENDOR_CODE = 0x2017;
+    /** @hide */
+    public static final int RESPONSE_CAPTURE_ALREADY_TERMINATED = 0x2018;
+    /** @hide */
+    public static final int RESPONSE_DEVICE_BUSY = 0x2019;
+    /** @hide */
+    public static final int RESPONSE_INVALID_PARENT_OBJECT = 0x201A;
+    /** @hide */
+    public static final int RESPONSE_INVALID_DEVICE_PROP_FORMAT = 0x201B;
+    /** @hide */
+    public static final int RESPONSE_INVALID_DEVICE_PROP_VALUE = 0x201C;
+    /** @hide */
+    public static final int RESPONSE_INVALID_PARAMETER = 0x201D;
+    /** @hide */
+    public static final int RESPONSE_SESSION_ALREADY_OPEN = 0x201E;
+    /** @hide */
+    public static final int RESPONSE_TRANSACTION_CANCELLED = 0x201F;
+    /** @hide */
+    public static final int RESPONSE_SPECIFICATION_OF_DESTINATION_UNSUPPORTED = 0x2020;
+    /** @hide */
+    public static final int RESPONSE_INVALID_OBJECT_PROP_CODE = 0xA801;
+    /** @hide */
+    public static final int RESPONSE_INVALID_OBJECT_PROP_FORMAT = 0xA802;
+    /** @hide */
+    public static final int RESPONSE_INVALID_OBJECT_PROP_VALUE = 0xA803;
+    /** @hide */
+    public static final int RESPONSE_INVALID_OBJECT_REFERENCE = 0xA804;
+    /** @hide */
+    public static final int RESPONSE_GROUP_NOT_SUPPORTED = 0xA805;
+    /** @hide */
+    public static final int RESPONSE_INVALID_DATASET = 0xA806;
+    /** @hide */
+    public static final int RESPONSE_SPECIFICATION_BY_GROUP_UNSUPPORTED = 0xA807;
+    /** @hide */
+    public static final int RESPONSE_SPECIFICATION_BY_DEPTH_UNSUPPORTED = 0xA808;
+    /** @hide */
+    public static final int RESPONSE_OBJECT_TOO_LARGE = 0xA809;
+    /** @hide */
+    public static final int RESPONSE_OBJECT_PROP_NOT_SUPPORTED = 0xA80A;
+
+    // MTP format codes
+    /** Undefined format code */
+    public static final int FORMAT_UNDEFINED = 0x3000;
+    /** Format code for associations (folders and directories) */
+    public static final int FORMAT_ASSOCIATION = 0x3001;
+    /** Format code for script files */
+    public static final int FORMAT_SCRIPT = 0x3002;
+    /** Format code for executable files */
+    public static final int FORMAT_EXECUTABLE = 0x3003;
+    /** Format code for text files */
+    public static final int FORMAT_TEXT = 0x3004;
+    /** Format code for HTML files */
+    public static final int FORMAT_HTML = 0x3005;
+    /** Format code for DPOF files */
+    public static final int FORMAT_DPOF = 0x3006;
+    /** Format code for AIFF audio files */
+    public static final int FORMAT_AIFF = 0x3007;
+    /** Format code for WAV audio files */
+    public static final int FORMAT_WAV = 0x3008;
+    /** Format code for MP3 audio files */
+    public static final int FORMAT_MP3 = 0x3009;
+    /** Format code for AVI video files */
+    public static final int FORMAT_AVI = 0x300A;
+    /** Format code for MPEG video files */
+    public static final int FORMAT_MPEG = 0x300B;
+    /** Format code for ASF files */
+    public static final int FORMAT_ASF = 0x300C;
+    /** Format code for JPEG image files */
+    public static final int FORMAT_EXIF_JPEG = 0x3801;
+    /** Format code for TIFF EP image files */
+    public static final int FORMAT_TIFF_EP = 0x3802;
+    /** Format code for BMP image files */
+    public static final int FORMAT_BMP = 0x3804;
+    /** Format code for GIF image files */
+    public static final int FORMAT_GIF = 0x3807;
+    /** Format code for JFIF image files */
+    public static final int FORMAT_JFIF = 0x3808;
+    /** Format code for PICT image files */
+    public static final int FORMAT_PICT = 0x380A;
+    /** Format code for PNG image files */
+    public static final int FORMAT_PNG = 0x380B;
+    /** Format code for TIFF image files */
+    public static final int FORMAT_TIFF = 0x380D;
+    /** Format code for JP2 files */
+    public static final int FORMAT_JP2 = 0x380F;
+    /** Format code for JPX files */
+    public static final int FORMAT_JPX = 0x3810;
+    /** Format code for firmware files */
+    public static final int FORMAT_UNDEFINED_FIRMWARE = 0xB802;
+    /** Format code for Windows image files */
+    public static final int FORMAT_WINDOWS_IMAGE_FORMAT = 0xB881;
+    /** Format code for undefined audio files files */
+    public static final int FORMAT_UNDEFINED_AUDIO = 0xB900;
+    /** Format code for WMA audio files */
+    public static final int FORMAT_WMA = 0xB901;
+    /** Format code for OGG audio files */
+    public static final int FORMAT_OGG = 0xB902;
+    /** Format code for AAC audio files */
+    public static final int FORMAT_AAC = 0xB903;
+    /** Format code for Audible audio files */
+    public static final int FORMAT_AUDIBLE = 0xB904;
+    /** Format code for FLAC audio files */
+    public static final int FORMAT_FLAC = 0xB906;
+    /** Format code for undefined video files */
+    public static final int FORMAT_UNDEFINED_VIDEO = 0xB980;
+    /** Format code for WMV video files */
+    public static final int FORMAT_WMV = 0xB981;
+    /** Format code for MP4 files */
+    public static final int FORMAT_MP4_CONTAINER = 0xB982;
+    /** Format code for MP2 files */
+    public static final int FORMAT_MP2 = 0xB983;
+    /** Format code for 3GP files */
+    public static final int FORMAT_3GP_CONTAINER = 0xB984;
+    /** Format code for undefined collections */
+    public static final int FORMAT_UNDEFINED_COLLECTION = 0xBA00;
+    /** Format code for multimedia albums */
+    public static final int FORMAT_ABSTRACT_MULTIMEDIA_ALBUM = 0xBA01;
+    /** Format code for image albums */
+    public static final int FORMAT_ABSTRACT_IMAGE_ALBUM = 0xBA02;
+    /** Format code for audio albums */
+    public static final int FORMAT_ABSTRACT_AUDIO_ALBUM = 0xBA03;
+    /** Format code for video albums */
+    public static final int FORMAT_ABSTRACT_VIDEO_ALBUM = 0xBA04;
+    /** Format code for abstract AV playlists */
+    public static final int FORMAT_ABSTRACT_AV_PLAYLIST = 0xBA05;
+    /** Format code for abstract audio playlists */
+    public static final int FORMAT_ABSTRACT_AUDIO_PLAYLIST = 0xBA09;
+    /** Format code for abstract video playlists */
+    public static final int FORMAT_ABSTRACT_VIDEO_PLAYLIST = 0xBA0A;
+    /** Format code for abstract mediacasts */
+    public static final int FORMAT_ABSTRACT_MEDIACAST = 0xBA0B;
+    /** Format code for WPL playlist files */
+    public static final int FORMAT_WPL_PLAYLIST = 0xBA10;
+    /** Format code for M3u playlist files */
+    public static final int FORMAT_M3U_PLAYLIST = 0xBA11;
+    /** Format code for MPL playlist files */
+    public static final int FORMAT_MPL_PLAYLIST = 0xBA12;
+    /** Format code for ASX playlist files */
+    public static final int FORMAT_ASX_PLAYLIST = 0xBA13;
+    /** Format code for PLS playlist files */
+    public static final int FORMAT_PLS_PLAYLIST = 0xBA14;
+    /** Format code for undefined document files */
+    public static final int FORMAT_UNDEFINED_DOCUMENT = 0xBA80;
+    /** Format code for abstract documents */
+    public static final int FORMAT_ABSTRACT_DOCUMENT = 0xBA81;
+    /** Format code for XML documents */
+    public static final int FORMAT_XML_DOCUMENT = 0xBA82;
+    /** Format code for MS Word documents */
+    public static final int FORMAT_MS_WORD_DOCUMENT = 0xBA83;
+    /** Format code for MS Excel spreadsheets */
+    public static final int FORMAT_MS_EXCEL_SPREADSHEET = 0xBA85;
+    /** Format code for MS PowerPoint presentatiosn */
+    public static final int FORMAT_MS_POWERPOINT_PRESENTATION = 0xBA86;
+
+    /**
+     * Returns true if the object is abstract (that is, it has no representation
+     * in the underlying file system).
+     *
+     * @param format the format of the object
+     * @return true if the object is abstract
+     */
+    public static boolean isAbstractObject(int format) {
+        switch (format) {
+            case FORMAT_ABSTRACT_MULTIMEDIA_ALBUM:
+            case FORMAT_ABSTRACT_IMAGE_ALBUM:
+            case FORMAT_ABSTRACT_AUDIO_ALBUM:
+            case FORMAT_ABSTRACT_VIDEO_ALBUM:
+            case FORMAT_ABSTRACT_AV_PLAYLIST:
+            case FORMAT_ABSTRACT_AUDIO_PLAYLIST:
+            case FORMAT_ABSTRACT_VIDEO_PLAYLIST:
+            case FORMAT_ABSTRACT_MEDIACAST:
+            case FORMAT_ABSTRACT_DOCUMENT:
+                return true;
+            default:
+                return false;
+        }
+    }
+
+    // MTP object properties
+    /** @hide */
+    public static final int PROPERTY_STORAGE_ID = 0xDC01;
+    /** @hide */
+    public static final int PROPERTY_OBJECT_FORMAT = 0xDC02;
+    /** @hide */
+    public static final int PROPERTY_PROTECTION_STATUS = 0xDC03;
+    /** @hide */
+    public static final int PROPERTY_OBJECT_SIZE = 0xDC04;
+    /** @hide */
+    public static final int PROPERTY_ASSOCIATION_TYPE = 0xDC05;
+    /** @hide */
+    public static final int PROPERTY_ASSOCIATION_DESC = 0xDC06;
+    /** @hide */
+    public static final int PROPERTY_OBJECT_FILE_NAME = 0xDC07;
+    /** @hide */
+    public static final int PROPERTY_DATE_CREATED = 0xDC08;
+    /** @hide */
+    public static final int PROPERTY_DATE_MODIFIED = 0xDC09;
+    /** @hide */
+    public static final int PROPERTY_KEYWORDS = 0xDC0A;
+    /** @hide */
+    public static final int PROPERTY_PARENT_OBJECT = 0xDC0B;
+    /** @hide */
+    public static final int PROPERTY_ALLOWED_FOLDER_CONTENTS = 0xDC0C;
+    /** @hide */
+    public static final int PROPERTY_HIDDEN = 0xDC0D;
+    /** @hide */
+    public static final int PROPERTY_SYSTEM_OBJECT = 0xDC0E;
+    /** @hide */
+    public static final int PROPERTY_PERSISTENT_UID = 0xDC41;
+    /** @hide */
+    public static final int PROPERTY_SYNC_ID = 0xDC42;
+    /** @hide */
+    public static final int PROPERTY_PROPERTY_BAG = 0xDC43;
+    /** @hide */
+    public static final int PROPERTY_NAME = 0xDC44;
+    /** @hide */
+    public static final int PROPERTY_CREATED_BY = 0xDC45;
+    /** @hide */
+    public static final int PROPERTY_ARTIST = 0xDC46;
+    /** @hide */
+    public static final int PROPERTY_DATE_AUTHORED = 0xDC47;
+    /** @hide */
+    public static final int PROPERTY_DESCRIPTION = 0xDC48;
+    /** @hide */
+    public static final int PROPERTY_URL_REFERENCE = 0xDC49;
+    /** @hide */
+    public static final int PROPERTY_LANGUAGE_LOCALE = 0xDC4A;
+    /** @hide */
+    public static final int PROPERTY_COPYRIGHT_INFORMATION = 0xDC4B;
+    /** @hide */
+    public static final int PROPERTY_SOURCE = 0xDC4C;
+    /** @hide */
+    public static final int PROPERTY_ORIGIN_LOCATION = 0xDC4D;
+    /** @hide */
+    public static final int PROPERTY_DATE_ADDED = 0xDC4E;
+    /** @hide */
+    public static final int PROPERTY_NON_CONSUMABLE = 0xDC4F;
+    /** @hide */
+    public static final int PROPERTY_CORRUPT_UNPLAYABLE = 0xDC50;
+    /** @hide */
+    public static final int PROPERTY_PRODUCER_SERIAL_NUMBER = 0xDC51;
+    /** @hide */
+    public static final int PROPERTY_REPRESENTATIVE_SAMPLE_FORMAT = 0xDC81;
+    /** @hide */
+    public static final int PROPERTY_REPRESENTATIVE_SAMPLE_SIZE = 0xDC82;
+    /** @hide */
+    public static final int PROPERTY_REPRESENTATIVE_SAMPLE_HEIGHT = 0xDC83;
+    /** @hide */
+    public static final int PROPERTY_REPRESENTATIVE_SAMPLE_WIDTH = 0xDC84;
+    /** @hide */
+    public static final int PROPERTY_REPRESENTATIVE_SAMPLE_DURATION = 0xDC85;
+    /** @hide */
+    public static final int PROPERTY_REPRESENTATIVE_SAMPLE_DATA = 0xDC86;
+    /** @hide */
+    public static final int PROPERTY_WIDTH = 0xDC87;
+    /** @hide */
+    public static final int PROPERTY_HEIGHT = 0xDC88;
+    /** @hide */
+    public static final int PROPERTY_DURATION = 0xDC89;
+    /** @hide */
+    public static final int PROPERTY_RATING = 0xDC8A;
+    /** @hide */
+    public static final int PROPERTY_TRACK = 0xDC8B;
+    /** @hide */
+    public static final int PROPERTY_GENRE = 0xDC8C;
+    /** @hide */
+    public static final int PROPERTY_CREDITS = 0xDC8D;
+    /** @hide */
+    public static final int PROPERTY_LYRICS = 0xDC8E;
+    /** @hide */
+    public static final int PROPERTY_SUBSCRIPTION_CONTENT_ID = 0xDC8F;
+    /** @hide */
+    public static final int PROPERTY_PRODUCED_BY = 0xDC90;
+    /** @hide */
+    public static final int PROPERTY_USE_COUNT = 0xDC91;
+    /** @hide */
+    public static final int PROPERTY_SKIP_COUNT = 0xDC92;
+    /** @hide */
+    public static final int PROPERTY_LAST_ACCESSED = 0xDC93;
+    /** @hide */
+    public static final int PROPERTY_PARENTAL_RATING = 0xDC94;
+    /** @hide */
+    public static final int PROPERTY_META_GENRE = 0xDC95;
+    /** @hide */
+    public static final int PROPERTY_COMPOSER = 0xDC96;
+    /** @hide */
+    public static final int PROPERTY_EFFECTIVE_RATING = 0xDC97;
+    /** @hide */
+    public static final int PROPERTY_SUBTITLE = 0xDC98;
+    /** @hide */
+    public static final int PROPERTY_ORIGINAL_RELEASE_DATE = 0xDC99;
+    /** @hide */
+    public static final int PROPERTY_ALBUM_NAME = 0xDC9A;
+    /** @hide */
+    public static final int PROPERTY_ALBUM_ARTIST = 0xDC9B;
+    /** @hide */
+    public static final int PROPERTY_MOOD = 0xDC9C;
+    /** @hide */
+    public static final int PROPERTY_DRM_STATUS = 0xDC9D;
+    /** @hide */
+    public static final int PROPERTY_SUB_DESCRIPTION = 0xDC9E;
+    /** @hide */
+    public static final int PROPERTY_IS_CROPPED = 0xDCD1;
+    /** @hide */
+    public static final int PROPERTY_IS_COLOUR_CORRECTED = 0xDCD2;
+    /** @hide */
+    public static final int PROPERTY_IMAGE_BIT_DEPTH = 0xDCD3;
+    /** @hide */
+    public static final int PROPERTY_F_NUMBER = 0xDCD4;
+    /** @hide */
+    public static final int PROPERTY_EXPOSURE_TIME = 0xDCD5;
+    /** @hide */
+    public static final int PROPERTY_EXPOSURE_INDEX = 0xDCD6;
+    /** @hide */
+    public static final int PROPERTY_TOTAL_BITRATE = 0xDE91;
+    /** @hide */
+    public static final int PROPERTY_BITRATE_TYPE = 0xDE92;
+    /** @hide */
+    public static final int PROPERTY_SAMPLE_RATE = 0xDE93;
+    /** @hide */
+    public static final int PROPERTY_NUMBER_OF_CHANNELS = 0xDE94;
+    /** @hide */
+    public static final int PROPERTY_AUDIO_BIT_DEPTH = 0xDE95;
+    /** @hide */
+    public static final int PROPERTY_SCAN_TYPE = 0xDE97;
+    /** @hide */
+    public static final int PROPERTY_AUDIO_WAVE_CODEC = 0xDE99;
+    /** @hide */
+    public static final int PROPERTY_AUDIO_BITRATE = 0xDE9A;
+    /** @hide */
+    public static final int PROPERTY_VIDEO_FOURCC_CODEC = 0xDE9B;
+    /** @hide */
+    public static final int PROPERTY_VIDEO_BITRATE = 0xDE9C;
+    /** @hide */
+    public static final int PROPERTY_FRAMES_PER_THOUSAND_SECONDS = 0xDE9D;
+    /** @hide */
+    public static final int PROPERTY_KEYFRAME_DISTANCE = 0xDE9E;
+    /** @hide */
+    public static final int PROPERTY_BUFFER_SIZE = 0xDE9F;
+    /** @hide */
+    public static final int PROPERTY_ENCODING_QUALITY = 0xDEA0;
+    /** @hide */
+    public static final int PROPERTY_ENCODING_PROFILE = 0xDEA1;
+    /** @hide */
+    public static final int PROPERTY_DISPLAY_NAME = 0xDCE0;
+
+    // MTP device properties
+    /** @hide */
+    public static final int DEVICE_PROPERTY_UNDEFINED = 0x5000;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_BATTERY_LEVEL = 0x5001;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_FUNCTIONAL_MODE = 0x5002;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_IMAGE_SIZE = 0x5003;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_COMPRESSION_SETTING = 0x5004;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_WHITE_BALANCE = 0x5005;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_RGB_GAIN = 0x5006;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_F_NUMBER = 0x5007;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_FOCAL_LENGTH = 0x5008;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_FOCUS_DISTANCE = 0x5009;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_FOCUS_MODE = 0x500A;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_EXPOSURE_METERING_MODE = 0x500B;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_FLASH_MODE = 0x500C;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_EXPOSURE_TIME = 0x500D;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_EXPOSURE_PROGRAM_MODE = 0x500E;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_EXPOSURE_INDEX = 0x500F;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_EXPOSURE_BIAS_COMPENSATION = 0x5010;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_DATETIME = 0x5011;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_CAPTURE_DELAY = 0x5012;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_STILL_CAPTURE_MODE = 0x5013;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_CONTRAST = 0x5014;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_SHARPNESS = 0x5015;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_DIGITAL_ZOOM = 0x5016;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_EFFECT_MODE = 0x5017;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_BURST_NUMBER= 0x5018;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_BURST_INTERVAL = 0x5019;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_TIMELAPSE_NUMBER = 0x501A;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_TIMELAPSE_INTERVAL = 0x501B;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_FOCUS_METERING_MODE = 0x501C;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_UPLOAD_URL = 0x501D;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_ARTIST = 0x501E;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_COPYRIGHT_INFO = 0x501F;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_SYNCHRONIZATION_PARTNER = 0xD401;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_DEVICE_FRIENDLY_NAME = 0xD402;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_VOLUME = 0xD403;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_SUPPORTED_FORMATS_ORDERED = 0xD404;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_DEVICE_ICON = 0xD405;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_PLAYBACK_RATE = 0xD410;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_PLAYBACK_OBJECT = 0xD411;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_PLAYBACK_CONTAINER_INDEX = 0xD412;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_SESSION_INITIATOR_VERSION_INFO = 0xD406;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_PERCEIVED_DEVICE_TYPE = 0xD407;
+
+    /**
+     * Object is not protected. It may be modified and deleted, and its properties
+     * may be modified.
+     */
+    public static final int PROTECTION_STATUS_NONE = 0;
+
+    /**
+     * Object can not be modified or deleted and its properties can not be modified.
+     */
+    public static final int PROTECTION_STATUS_READ_ONLY = 0x8001;
+
+    /**
+     * Object can not be modified or deleted but its properties are modifiable.
+     */
+    public static final int PROTECTION_STATUS_READ_ONLY_DATA = 0x8002;
+
+    /**
+     * Object's contents can not be transfered from the device, but the object
+     * may be moved or deleted and its properties may be modified.
+     */
+    public static final int PROTECTION_STATUS_NON_TRANSFERABLE_DATA = 0x8003;
+
+    /**
+     * Association type for objects representing file system directories.
+     */
+    public static final int ASSOCIATION_TYPE_GENERIC_FOLDER = 0x0001;
+}
+
diff --git a/ion/src/com/koushikdutta/ion/loader/PackageIconLoader.java b/ion/src/com/koushikdutta/ion/loader/PackageIconLoader.java
index 0f9a0930..147d0b3a 100644
--- a/ion/src/com/koushikdutta/ion/loader/PackageIconLoader.java
+++ b/ion/src/com/koushikdutta/ion/loader/PackageIconLoader.java
@@ -1,51 +1,38 @@
 package com.koushikdutta.ion.loader;
 
 
-import android.content.pm.PackageInfo;
 import android.content.pm.PackageManager;
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
 
-import com.koushikdutta.async.DataEmitter;
 import com.koushikdutta.async.future.Future;
-import com.koushikdutta.async.future.FutureCallback;
 import com.koushikdutta.async.future.SimpleFuture;
-import com.koushikdutta.async.http.AsyncHttpRequest;
 import com.koushikdutta.ion.Ion;
 import com.koushikdutta.ion.Loader;
 import com.koushikdutta.ion.bitmap.BitmapInfo;
 
-import java.io.InputStream;
 import java.net.URI;
 
 /**
  * Created by koush on 11/3/13.
  */
-public class PackageIconLoader implements Loader {
+public class PackageIconLoader extends SimpleLoader {
     @Override
-    public Future<InputStream> load(Ion ion, AsyncHttpRequest request) {
-        return null;
-    }
-
-    @Override
-    public Future<DataEmitter> load(Ion ion, AsyncHttpRequest request, FutureCallback<LoaderEmitter> callback) {
-        return null;
-    }
-
-    @Override
-    public Future<BitmapInfo> loadBitmap(final Ion ion, final String uri) {
+    public Future<BitmapInfo> loadBitmap(final Ion ion, final String uri, int resizeWidth, int resizeHeight) {
         final URI request = URI.create(uri);
         if (request == null || request.getScheme() == null || !request.getScheme().startsWith("package"))
             return null;
 
         final SimpleFuture<BitmapInfo> ret = new SimpleFuture<BitmapInfo>();
-        ion.getBitmapLoadExecutorService().execute(new Runnable() {
+        Ion.getBitmapLoadExecutorService().execute(new Runnable() {
             @Override
             public void run() {
                 try {
                     String pkg = request.getHost();
                     PackageManager pm = ion.getContext().getPackageManager();
                     Bitmap bmp = ((BitmapDrawable)pm.getPackageInfo(pkg, 0).applicationInfo.loadIcon(pm)).getBitmap();
+                    if (bmp == null)
+                        throw new Exception("package icon failed to load");
                     BitmapInfo info = new BitmapInfo();
                     info.bitmaps = new Bitmap[] { bmp };
                     info.loadedFrom =  Loader.LoaderEmitter.LOADED_FROM_CACHE;
diff --git a/ion/src/com/koushikdutta/ion/loader/SimpleLoader.java b/ion/src/com/koushikdutta/ion/loader/SimpleLoader.java
new file mode 100644
index 00000000..934e16d1
--- /dev/null
+++ b/ion/src/com/koushikdutta/ion/loader/SimpleLoader.java
@@ -0,0 +1,31 @@
+package com.koushikdutta.ion.loader;
+
+import com.koushikdutta.async.DataEmitter;
+import com.koushikdutta.async.future.Future;
+import com.koushikdutta.async.future.FutureCallback;
+import com.koushikdutta.async.http.AsyncHttpRequest;
+import com.koushikdutta.ion.Ion;
+import com.koushikdutta.ion.Loader;
+import com.koushikdutta.ion.bitmap.BitmapInfo;
+
+import java.io.InputStream;
+
+/**
+ * Created by koush on 12/22/13.
+ */
+public class SimpleLoader implements Loader {
+    @Override
+    public Future<InputStream> load(Ion ion, AsyncHttpRequest request) {
+        return null;
+    }
+
+    @Override
+    public Future<DataEmitter> load(Ion ion, AsyncHttpRequest request, FutureCallback<LoaderEmitter> callback) {
+        return null;
+    }
+
+    @Override
+    public Future<BitmapInfo> loadBitmap(Ion ion, String uri, int resizeWidth, int resizeHeight) {
+        return null;
+    }
+}
diff --git a/ion/src/com/koushikdutta/ion/loader/VideoLoader.java b/ion/src/com/koushikdutta/ion/loader/VideoLoader.java
new file mode 100644
index 00000000..1b4ef523
--- /dev/null
+++ b/ion/src/com/koushikdutta/ion/loader/VideoLoader.java
@@ -0,0 +1,112 @@
+package com.koushikdutta.ion.loader;
+
+import android.content.ContentResolver;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.os.Build;
+import android.util.Log;
+
+import com.koushikdutta.async.DataEmitter;
+import com.koushikdutta.async.future.Future;
+import com.koushikdutta.async.future.FutureCallback;
+import com.koushikdutta.async.future.SimpleFuture;
+import com.koushikdutta.async.http.AsyncHttpRequest;
+import com.koushikdutta.ion.Ion;
+import com.koushikdutta.ion.Loader;
+import com.koushikdutta.ion.bitmap.BitmapInfo;
+
+import java.io.File;
+import java.io.InputStream;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.net.URI;
+
+/**
+ * Created by koush on 11/6/13.
+ */
+public class VideoLoader extends SimpleLoader {
+    private static final String TAG = "IonVideoLoader";
+
+    public static Bitmap createVideoThumbnail(String filePath) {
+        // MediaMetadataRetriever is available on API Level 8
+        // but is hidden until API Level 10
+        Class<?> clazz = null;
+        Object instance = null;
+        try {
+            clazz = Class.forName("android.media.MediaMetadataRetriever");
+            instance = clazz.newInstance();
+
+            Method method = clazz.getMethod("setDataSource", String.class);
+            method.invoke(instance, filePath);
+
+            // The method name changes between API Level 9 and 10.
+            if (Build.VERSION.SDK_INT <= 9) {
+                return (Bitmap) clazz.getMethod("captureFrame").invoke(instance);
+            } else {
+                byte[] data = (byte[]) clazz.getMethod("getEmbeddedPicture").invoke(instance);
+                if (data != null) {
+                    Bitmap bitmap = BitmapFactory.decodeByteArray(data, 0, data.length);
+                    if (bitmap != null) return bitmap;
+                }
+                return (Bitmap) clazz.getMethod("getFrameAtTime").invoke(instance);
+            }
+        } catch (IllegalArgumentException ex) {
+            // Assume this is a corrupt video file
+        } catch (RuntimeException ex) {
+            // Assume this is a corrupt video file.
+        } catch (InstantiationException e) {
+            Log.e(TAG, "createVideoThumbnail", e);
+        } catch (InvocationTargetException e) {
+            Log.e(TAG, "createVideoThumbnail", e);
+        } catch (ClassNotFoundException e) {
+            Log.e(TAG, "createVideoThumbnail", e);
+        } catch (NoSuchMethodException e) {
+            Log.e(TAG, "createVideoThumbnail", e);
+        } catch (IllegalAccessException e) {
+            Log.e(TAG, "createVideoThumbnail", e);
+        } finally {
+            try {
+                if (instance != null) {
+                    clazz.getMethod("release").invoke(instance);
+                }
+            } catch (Exception ignored) {
+            }
+        }
+        return null;
+    }
+
+    @Override
+    public Future<BitmapInfo> loadBitmap(Ion ion, String uri, int resizeWidth, int resizeHeight) {
+        if (!uri.startsWith(ContentResolver.SCHEME_FILE))
+            return null;
+
+        final File file = new File(URI.create(uri));
+
+        MediaFile.MediaFileType type = MediaFile.getFileType(file.getAbsolutePath());
+        if (type == null || !MediaFile.isVideoFileType(type.fileType))
+            return null;
+
+        final SimpleFuture<BitmapInfo> ret = new SimpleFuture<BitmapInfo>();
+        Ion.getBitmapLoadExecutorService().execute(new Runnable() {
+            @Override
+            public void run() {
+                if (ret.isCancelled()) {
+//                    Log.d("VideoLoader", "Bitmap load cancelled (no longer needed)");
+                    return;
+                }
+                try {
+                    Bitmap bmp = createVideoThumbnail(file.getAbsolutePath());
+                    if (bmp == null)
+                        throw new Exception("video bitmap failed to load");
+                    BitmapInfo info = new BitmapInfo();
+                    info.bitmaps = new Bitmap[] {bmp};
+                    info.loadedFrom = LoaderEmitter.LOADED_FROM_CACHE;
+                    ret.setComplete(info);
+                } catch (Exception e) {
+                    ret.setComplete(e);
+                }
+            }
+        });
+        return ret;
+    }
+}
