diff --git a/ion/src/com/koushikdutta/ion/IonDrawable.java b/ion/src/com/koushikdutta/ion/IonDrawable.java
index a3329640..e77e7134 100644
--- a/ion/src/com/koushikdutta/ion/IonDrawable.java
+++ b/ion/src/com/koushikdutta/ion/IonDrawable.java
@@ -386,6 +386,7 @@ public void draw(Canvas canvas) {
             int visibleBottom = Math.min(bounds.height(), clip.bottom);
             int level = (int)Math.floor(maxLevel);
             level = Math.min(this.maxLevel, level);
+            level = Math.max(level, 0);
             int levelTiles = 1 << level;
             int textureTileDim = textureDim / levelTiles;
 //            System.out.println("textureTileDim: " + textureTileDim);
diff --git a/ion/src/com/koushikdutta/ion/IonRequestBuilder.java b/ion/src/com/koushikdutta/ion/IonRequestBuilder.java
index 0328b8ca..b71d9a40 100644
--- a/ion/src/com/koushikdutta/ion/IonRequestBuilder.java
+++ b/ion/src/com/koushikdutta/ion/IonRequestBuilder.java
@@ -9,6 +9,7 @@
 import android.net.Uri;
 import android.os.Handler;
 import android.os.Looper;
+import android.text.TextUtils;
 import android.util.Base64;
 import android.widget.ImageView;
 import android.widget.ProgressBar;
@@ -17,6 +18,7 @@
 import com.google.gson.JsonObject;
 import com.google.gson.reflect.TypeToken;
 import com.koushikdutta.async.AsyncServer;
+import com.koushikdutta.async.ByteBufferList;
 import com.koushikdutta.async.DataEmitter;
 import com.koushikdutta.async.DataSink;
 import com.koushikdutta.async.DataTrackingEmitter;
@@ -43,6 +45,7 @@
 import com.koushikdutta.async.http.libcore.RawHeaders;
 import com.koushikdutta.async.http.server.AsyncHttpServer;
 import com.koushikdutta.async.parser.AsyncParser;
+import com.koushikdutta.async.parser.ByteBufferListParser;
 import com.koushikdutta.async.parser.DocumentParser;
 import com.koushikdutta.async.parser.StringParser;
 import com.koushikdutta.async.stream.FileDataSink;
@@ -61,11 +64,13 @@
 import org.apache.http.NameValuePair;
 import org.w3c.dom.Document;
 
+import java.io.ByteArrayInputStream;
 import java.io.File;
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.lang.ref.WeakReference;
 import java.net.URI;
+import java.nio.ByteBuffer;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
@@ -114,6 +119,8 @@ private RawHeaders getHeaders() {
 
     @Override
     public IonRequestBuilder userAgent(String userAgent) {
+        if (TextUtils.isEmpty(userAgent))
+            return this;
         return setHeader("User-Agent", userAgent);
     }
 
@@ -129,6 +136,15 @@ public IonRequestBuilder addHeader(String name, String value) {
         return this;
     }
 
+    @Override
+    public IonRequestBuilder addHeaders(Map<String, List<String>> params) {
+        RawHeaders headers = getHeaders();
+        for (Map.Entry<String, List<String>> entry: params.entrySet()) {
+            headers.addAll(entry.getKey(), entry.getValue());
+        }
+        return this;
+    }
+
     boolean noCache;
     @Override
     public Builders.Any.B noCache() {
@@ -660,6 +676,27 @@ public void onCompleted(Exception e, T result) {
         return execute(new StringParser());
     }
 
+    @Override
+    public ResponseFuture<byte[]> asByteArray() {
+        return execute(new AsyncParser<byte[]>() {
+            @Override
+            public Future<byte[]> parse(DataEmitter emitter) {
+                return new ByteBufferListParser().parse(emitter)
+                .then(new TransformFuture<byte[], ByteBufferList>() {
+                    @Override
+                    protected void transform(ByteBufferList result) throws Exception {
+                        setComplete(result.getAllByteArray());
+                    }
+                });
+            }
+
+            @Override
+            public void write(DataSink sink, byte[] value, CompletedCallback completed) {
+                new ByteBufferListParser().write(sink, new ByteBufferList(value), completed);
+            }
+        });
+    }
+
     @Override
     public ResponseFuture<InputStream> asInputStream() {
         return execute(new InputStreamParser());
@@ -891,6 +928,13 @@ public IonRequestBuilder basicAuthentication(String username, String password) {
         return this;
     }
 
+    @Override
+    public Builders.Any.F setByteArrayBody(byte[] bytes) {
+        if (bytes != null)
+            setBody(new StreamBody(new ByteArrayInputStream(bytes), bytes.length));
+        return this;
+    }
+
     @Override
     public Builders.Any.F setStreamBody(InputStream inputStream) {
         setBody(new StreamBody(inputStream, -1));
diff --git a/ion/src/com/koushikdutta/ion/LoadBitmap.java b/ion/src/com/koushikdutta/ion/LoadBitmap.java
index a723bed4..44c65bff 100644
--- a/ion/src/com/koushikdutta/ion/LoadBitmap.java
+++ b/ion/src/com/koushikdutta/ion/LoadBitmap.java
@@ -54,12 +54,11 @@ public void run() {
                 try {
                     Bitmap[] bitmaps;
                     int[] delays;
-                    Point size;
                     BitmapFactory.Options options = ion.bitmapCache.prepareBitmapOptions(bb.array(), bb.arrayOffset() + bb.position(), bb.remaining(), resizeWidth, resizeHeight);
                     if (options == null)
                         throw new Exception("BitmapFactory.Options failed to load");
+                    final Point size = new Point(options.outWidth, options.outHeight);
                     if (animateGif && TextUtils.equals("image/gif", options.outMimeType)) {
-                        size = null;
                         GifDecoder decoder = new GifDecoder(bb.array(), bb.arrayOffset() + bb.position(), bb.remaining(), new GifAction() {
                             @Override
                             public boolean parseOk(boolean parseStatus, int frameIndex) {
@@ -76,12 +75,9 @@ public boolean parseOk(boolean parseStatus, int frameIndex) {
                             if (bitmap == null)
                                 throw new Exception("failed to load gif frame");
                             bitmaps[i] = bitmap;
-                            if (size == null)
-                                size = new Point(bitmap.getWidth(), bitmap.getHeight());
                         }
                     }
                     else {
-                        size = new Point(options.outWidth, options.outHeight);
                         Bitmap bitmap = ion.bitmapCache.loadBitmap(bb.array(), bb.arrayOffset() + bb.position(), bb.remaining(), options);
                         if (bitmap == null)
                             throw new Exception("failed to load bitmap");
diff --git a/ion/src/com/koushikdutta/ion/LoadDeepZoom.java b/ion/src/com/koushikdutta/ion/LoadDeepZoom.java
index 13160baf..c95ac236 100644
--- a/ion/src/com/koushikdutta/ion/LoadDeepZoom.java
+++ b/ion/src/com/koushikdutta/ion/LoadDeepZoom.java
@@ -57,6 +57,7 @@ public void run() {
                     BitmapFactory.Options options = ion.getBitmapCache().prepareBitmapOptions(file, 0, 0);
                     if (options == null)
                         throw new Exception("BitmapFactory.Options failed to load");
+                    final Point size = new Point(options.outWidth, options.outHeight);
                     if (animateGif && TextUtils.equals("image/gif", options.outMimeType)) {
                         fin = new FileInputStream(file);
                         GifDecoder decoder = new GifDecoder(fin, new GifAction() {
@@ -70,14 +71,11 @@ public boolean parseOk(boolean parseStatus, int frameIndex) {
                             throw new Exception("failed to load gif");
                         Bitmap[] bitmaps = new Bitmap[decoder.getFrameCount()];
                         int[] delays = decoder.getDelays();
-                        Point size = null;
                         for (int i = 0; i < decoder.getFrameCount(); i++) {
                             Bitmap bitmap = decoder.getFrameImage(i);
                             if (bitmap == null)
                                 throw new Exception("failed to load gif frame");
                             bitmaps[i] = bitmap;
-                            if (size == null)
-                                size = new Point(bitmap.getWidth(), bitmap.getHeight());
                         }
                         BitmapInfo info = new BitmapInfo(key, options.outMimeType, bitmaps, size);
                         info.delays = delays;
@@ -90,7 +88,6 @@ public boolean parseOk(boolean parseStatus, int frameIndex) {
                     }
 
                     BitmapRegionDecoder decoder = BitmapRegionDecoder.newInstance(file.toString(), false);
-                    Point size = new Point(decoder.getWidth(), decoder.getHeight());
                     Bitmap bitmap = decoder.decodeRegion(new Rect(0, 0, size.x, size.y), options);
                     if (bitmap == null)
                         throw new Exception("unable to load decoder");
diff --git a/ion/src/com/koushikdutta/ion/builder/FutureBuilder.java b/ion/src/com/koushikdutta/ion/builder/FutureBuilder.java
index dad38128..feba3788 100644
--- a/ion/src/com/koushikdutta/ion/builder/FutureBuilder.java
+++ b/ion/src/com/koushikdutta/ion/builder/FutureBuilder.java
@@ -103,6 +103,12 @@
      */
     public <T> ResponseFuture<T> as(AsyncParser<T> parser);
 
+    /**
+     * Execute the request and get the result as a byte array
+     * @return
+     */
+    public ResponseFuture<byte[]> asByteArray();
+
     /**
      * Add this request to a group specified by groupKey. This key can be used in a later call to
      * Ion.cancelAll(groupKey) to cancel all the requests in the same group.
diff --git a/ion/src/com/koushikdutta/ion/builder/RequestBuilder.java b/ion/src/com/koushikdutta/ion/builder/RequestBuilder.java
index 1c76c61b..daa02c6b 100644
--- a/ion/src/com/koushikdutta/ion/builder/RequestBuilder.java
+++ b/ion/src/com/koushikdutta/ion/builder/RequestBuilder.java
@@ -141,6 +141,13 @@
      */
     public R addHeader(String name, String value);
 
+    /**
+     * Add multiple headers at once
+     * @param params
+     * @return
+     */
+    public R addHeaders(Map<String, List<String>> params);
+
     /**
      * Add a query parameter
      * @param name
@@ -243,6 +250,14 @@
      */
     public F setFileBody(File file);
 
+    /**
+     * Specify a byte array to send to the HTTP server. If no HTTP method was explicitly
+     * provided in the load call, the default HTTP method, POST, is used.
+     * @param bytes Bytes to send with the request
+     * @return
+     */
+    public F setByteArrayBody(byte[] bytes);
+
     /**
      * Specify an InputStream to send to the HTTP server. If no HTTP method was explicitly
      * provided in the load call, the default HTTP method, POST, is used.
diff --git a/ion/src/com/koushikdutta/ion/loader/PackageIconLoader.java b/ion/src/com/koushikdutta/ion/loader/PackageIconLoader.java
index d3d0fe29..0c07bb26 100644
--- a/ion/src/com/koushikdutta/ion/loader/PackageIconLoader.java
+++ b/ion/src/com/koushikdutta/ion/loader/PackageIconLoader.java
@@ -20,8 +20,7 @@
 public class PackageIconLoader extends SimpleLoader {
     @Override
     public Future<BitmapInfo> loadBitmap(final Ion ion, final String key, final String uri, int resizeWidth, int resizeHeight) {
-        final URI request = URI.create(uri);
-        if (request == null || request.getScheme() == null || !request.getScheme().startsWith("package"))
+        if (uri == null || !uri.startsWith("package:"))
             return null;
 
         final SimpleFuture<BitmapInfo> ret = new SimpleFuture<BitmapInfo>();
@@ -29,6 +28,7 @@
             @Override
             public void run() {
                 try {
+                    final URI request = URI.create(uri);
                     String pkg = request.getHost();
                     PackageManager pm = ion.getContext().getPackageManager();
                     Bitmap bmp = ((BitmapDrawable)pm.getPackageInfo(pkg, 0).applicationInfo.loadIcon(pm)).getBitmap();
