diff --git a/ion-test/src/com/koushikdutta/ion/test/Md5.java b/ion-test/src/com/koushikdutta/ion/test/Md5.java
index f6fb3ef1..2fa0aa3e 100644
--- a/ion-test/src/com/koushikdutta/ion/test/Md5.java
+++ b/ion-test/src/com/koushikdutta/ion/test/Md5.java
@@ -2,6 +2,10 @@
 
 import com.koushikdutta.async.ByteBufferList;
 
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.IOException;
 import java.math.BigInteger;
 import java.nio.ByteBuffer;
 import java.security.MessageDigest;
@@ -14,17 +18,30 @@ public static Md5 createInstance() throws NoSuchAlgorithmException {
         md5.digest = MessageDigest.getInstance("MD5");
         return md5;
     }
+
+    public static String digest(File file) throws NoSuchAlgorithmException, IOException {
+        byte[] bytes = StreamUtility.readToEndAsArray(new FileInputStream(file));
+        Md5 md5 = Md5.createInstance();
+        md5.digest.update(bytes);
+        return md5.digest();
+    }
     
     private Md5() {
         
     }
-    public void update(ByteBufferList bb) {
+    public Md5 update(ByteBufferList bb) {
         while (bb.size() > 0) {
             ByteBuffer b = bb.remove();
             digest.update(b);
         }
+        return this;
     }
-    
+
+    public Md5 update(byte[] bytes) {
+        digest.update(bytes);
+        return this;
+    }
+
     public String digest() {
         String hash = new BigInteger(digest.digest()).toString(16);
         return hash;
diff --git a/ion-test/src/com/koushikdutta/ion/test/StreamTests.java b/ion-test/src/com/koushikdutta/ion/test/StreamTests.java
new file mode 100644
index 00000000..0eab820e
--- /dev/null
+++ b/ion-test/src/com/koushikdutta/ion/test/StreamTests.java
@@ -0,0 +1,74 @@
+package com.koushikdutta.ion.test;
+
+import android.test.AndroidTestCase;
+
+import com.koushikdutta.async.AsyncServer;
+import com.koushikdutta.async.ByteBufferList;
+import com.koushikdutta.async.Util;
+import com.koushikdutta.async.callback.CompletedCallback;
+import com.koushikdutta.async.http.server.AsyncHttpServer;
+import com.koushikdutta.async.http.server.AsyncHttpServerRequest;
+import com.koushikdutta.async.http.server.AsyncHttpServerResponse;
+import com.koushikdutta.async.http.server.HttpServerRequestCallback;
+import com.koushikdutta.ion.Ion;
+
+import java.io.FileOutputStream;
+import java.io.InputStream;
+import java.nio.ByteBuffer;
+import java.util.Random;
+
+/**
+ * Created by koush on 11/3/13.
+ */
+public class StreamTests extends AndroidTestCase {
+    byte[] random = new byte[100000];
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        AsyncHttpServer server = new AsyncHttpServer();
+        server.listen(5555);
+        server.get("/", new HttpServerRequestCallback() {
+            @Override
+            public void onRequest(AsyncHttpServerRequest request, final AsyncHttpServerResponse response) {
+                ByteBuffer b = ByteBufferList.obtain(random.length);
+                b.put(random);
+                b.flip();
+                ByteBufferList list = new ByteBufferList(b);
+                Util.writeAll(response, list, new CompletedCallback() {
+                    @Override
+                    public void onCompleted(Exception ex) {
+                        response.end();
+                    }
+                });
+            }
+        });
+    }
+
+    @Override
+    protected void tearDown() throws Exception {
+        super.tearDown();
+        AsyncServer.getDefault().stop();
+    }
+
+    public void testStream() throws Exception {
+        new Random(39548394).nextBytes(random);
+        Ion.with(getContext())
+        .load("http://localhost:5555/")
+        .write(new FileOutputStream(getContext().getFileStreamPath("test")), true)
+        .get();
+
+        assertEquals(Md5.createInstance().update(random).digest(), Md5.digest(getContext().getFileStreamPath("test")));
+    }
+
+
+    public void testInputStream() throws Exception {
+        new Random(39548394).nextBytes(random);
+        InputStream is = Ion.with(getContext())
+        .load("http://localhost:5555/")
+        .asInputStream()
+        .get();
+
+        assertEquals(Md5.createInstance().update(random).digest(),
+            Md5.createInstance().update(StreamUtility.readToEndAsArray(is)).digest());
+    }
+}
diff --git a/ion-test/testdata/df692b2d8d2bd156b5f0a998d07f8b2a b/ion-test/testdata/df692b2d8d2bd156b5f0a998d07f8b2a
new file mode 100644
index 00000000..c6695a0d
Binary files /dev/null and b/ion-test/testdata/df692b2d8d2bd156b5f0a998d07f8b2a differ
diff --git a/ion/src/com/koushikdutta/ion/BitmapCallback.java b/ion/src/com/koushikdutta/ion/BitmapCallback.java
index 70e6df84..6fecf7e5 100644
--- a/ion/src/com/koushikdutta/ion/BitmapCallback.java
+++ b/ion/src/com/koushikdutta/ion/BitmapCallback.java
@@ -15,6 +15,8 @@ public BitmapCallback(Ion ion, String key, boolean put) {
         this.key = key;
         this.put = put;
         this.ion = ion;
+
+        ion.bitmapsPending.tag(key, this);
     }
 
     boolean put;
diff --git a/ion/src/com/koushikdutta/ion/BitmapToBitmapInfo.java b/ion/src/com/koushikdutta/ion/BitmapToBitmapInfo.java
index 10cac6f0..02fb0aba 100644
--- a/ion/src/com/koushikdutta/ion/BitmapToBitmapInfo.java
+++ b/ion/src/com/koushikdutta/ion/BitmapToBitmapInfo.java
@@ -58,8 +58,6 @@ public BitmapToBitmapInfo(Ion ion, String transformKey, String downloadKey, Arra
         super(ion, transformKey, true);
         this.transforms = transforms;
         this.downloadKey = downloadKey;
-
-        ion.bitmapsPending.tag(transformKey, this);
     }
 
     @Override
diff --git a/ion/src/com/koushikdutta/ion/InputStreamParser.java b/ion/src/com/koushikdutta/ion/InputStreamParser.java
new file mode 100644
index 00000000..9ceb8cfb
--- /dev/null
+++ b/ion/src/com/koushikdutta/ion/InputStreamParser.java
@@ -0,0 +1,34 @@
+package com.koushikdutta.ion;
+
+import com.koushikdutta.async.ByteBufferList;
+import com.koushikdutta.async.DataEmitter;
+import com.koushikdutta.async.DataSink;
+import com.koushikdutta.async.callback.CompletedCallback;
+import com.koushikdutta.async.future.Future;
+import com.koushikdutta.async.future.TransformFuture;
+import com.koushikdutta.async.parser.AsyncParser;
+import com.koushikdutta.async.parser.ByteBufferListParser;
+import com.koushikdutta.async.stream.ByteBufferListInputStream;
+
+import java.io.InputStream;
+
+/**
+ * Created by koush on 11/3/13.
+ */
+public class InputStreamParser implements AsyncParser<InputStream> {
+    @Override
+    public Future<InputStream> parse(DataEmitter emitter) {
+        return new TransformFuture<InputStream, ByteBufferList>() {
+            @Override
+            protected void transform(ByteBufferList result) throws Exception {
+                setComplete(new ByteBufferListInputStream(result));
+            }
+        }
+        .from(new ByteBufferListParser().parse(emitter));
+    }
+
+    @Override
+    public void write(DataSink sink, InputStream value, CompletedCallback completed) {
+        throw new AssertionError("not implemented");
+    }
+}
diff --git a/ion/src/com/koushikdutta/ion/Ion.java b/ion/src/com/koushikdutta/ion/Ion.java
index 726a38e8..54f59b0b 100644
--- a/ion/src/com/koushikdutta/ion/Ion.java
+++ b/ion/src/com/koushikdutta/ion/Ion.java
@@ -5,11 +5,14 @@
 import java.util.ArrayList;
 import java.util.List;
 import java.util.WeakHashMap;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
 
 import android.content.Context;
 import android.os.Build;
 import android.os.Handler;
 import android.os.Looper;
+import android.text.TextUtils;
 import android.util.Log;
 import android.view.ContextThemeWrapper;
 import android.widget.ImageView;
@@ -33,12 +36,24 @@
 import com.koushikdutta.ion.loader.ContentLoader;
 import com.koushikdutta.ion.loader.FileLoader;
 import com.koushikdutta.ion.loader.HttpLoader;
+import com.koushikdutta.ion.loader.PackageIconLoader;
 
 /**
  * Created by koush on 5/21/13.
  */
 public class Ion {
     public static final Handler mainHandler = new Handler(Looper.getMainLooper());
+    private static ExecutorService singleExecutorService  = Runtime.getRuntime().availableProcessors() < 2 ? null : Executors.newFixedThreadPool(1);
+
+    // todo: make this static by moving the server's executor service to static
+    public ExecutorService getBitmapLoadExecutorService() {
+        ExecutorService executorService = singleExecutorService;
+        if (executorService == null) {
+            executorService = getServer().getExecutorService();
+        }
+        return executorService;
+    }
+
 
     /**
      * Get the default Ion object instance and begin building a request
@@ -261,13 +276,6 @@ public Context getContext() {
         return context;
     }
 
-    private static class AsyncHttpRequestFactoryImpl implements AsyncHttpRequestFactory {
-        @Override
-        public AsyncHttpRequest createAsyncHttpRequest(URI uri, String method, RawHeaders headers) {
-            return new AsyncHttpRequest(uri, method, headers);
-        }
-    }
-
     AsyncHttpClient httpClient;
     CookieMiddleware cookieMiddleware;
     ResponseCacheMiddleware responseCache;
@@ -329,6 +337,7 @@ private Ion(Context context, String name) {
         bitmapCache = new IonBitmapCache(this);
 
         configure()
+        .addLoader(new PackageIconLoader())
         .addLoader(httpLoader = new HttpLoader())
         .addLoader(contentLoader = new ContentLoader())
         .addLoader(fileLoader = new FileLoader());
@@ -380,7 +389,14 @@ public void setGson(Gson gson) {
             this.gson = gson;
         }
 
-        AsyncHttpRequestFactory asyncHttpRequestFactory = new AsyncHttpRequestFactoryImpl();
+        AsyncHttpRequestFactory asyncHttpRequestFactory = new AsyncHttpRequestFactory() {
+            @Override
+            public AsyncHttpRequest createAsyncHttpRequest(URI uri, String method, RawHeaders headers) {
+                if (!TextUtils.isEmpty(userAgent))
+                    headers.set("User-Agent", userAgent);
+                return new AsyncHttpRequest(uri, method, headers);
+            }
+        };
 
         public AsyncHttpRequestFactory getAsyncHttpRequestFactory() {
             return asyncHttpRequestFactory;
@@ -391,6 +407,16 @@ public Config setAsyncHttpRequestFactory(AsyncHttpRequestFactory asyncHttpReques
             return this;
         }
 
+        private String userAgent;
+        public String userAgent() {
+            return userAgent;
+        }
+
+        public Config userAgent(String userAgent) {
+            this.userAgent = userAgent;
+            return this;
+        }
+
         ArrayList<Loader> loaders = new ArrayList<Loader>();
         public Config addLoader(int index, Loader loader) {
             loaders.add(index, loader);
diff --git a/ion/src/com/koushikdutta/ion/IonBitmapRequestBuilder.java b/ion/src/com/koushikdutta/ion/IonBitmapRequestBuilder.java
index b00f046f..14019388 100644
--- a/ion/src/com/koushikdutta/ion/IonBitmapRequestBuilder.java
+++ b/ion/src/com/koushikdutta/ion/IonBitmapRequestBuilder.java
@@ -10,6 +10,7 @@
 import com.koushikdutta.async.AsyncServer;
 import com.koushikdutta.async.ByteBufferList;
 import com.koushikdutta.async.future.Future;
+import com.koushikdutta.async.future.FutureCallback;
 import com.koushikdutta.async.future.SimpleFuture;
 import com.koushikdutta.async.future.TransformFuture;
 import com.koushikdutta.async.http.ResponseCacheMiddleware;
@@ -75,6 +76,25 @@ public IonBitmapRequestBuilder transform(Transform transform) {
         return this;
     }
 
+    boolean fastLoad(final String downloadKey, boolean put) {
+        for (Loader loader: ion.configure().getLoaders()) {
+            Future<BitmapInfo> future = loader.loadBitmap(ion, builder.uri);
+            if (future != null) {
+                final BitmapCallback callback = new BitmapCallback(ion, downloadKey, put);
+                future.setCallback(new FutureCallback<BitmapInfo>() {
+                    @Override
+                    public void onCompleted(Exception e, BitmapInfo result) {
+                        if (result != null)
+                            result.key = downloadKey;
+                        callback.report(e, result);
+                    }
+                });
+                return true;
+            }
+        }
+        return false;
+    }
+
     String bitmapKey;
     BitmapInfo execute() {
         final String downloadKey = ResponseCacheMiddleware.toKeyString(builder.uri);
@@ -112,7 +132,7 @@ BitmapInfo execute() {
         }
 
         // Perform a download as necessary.
-        if (!ion.bitmapsPending.contains(downloadKey)) {
+        if (!ion.bitmapsPending.contains(downloadKey) && !fastLoad(downloadKey, !hasTransforms)) {
             builder.setHandler(null);
             // if we cancel, gotta remove any waiters.
             IonRequestBuilder.EmitterTransform<ByteBufferList> emitterTransform = builder.execute(new ByteBufferListParser(), new Runnable() {
diff --git a/ion/src/com/koushikdutta/ion/IonRequestBuilder.java b/ion/src/com/koushikdutta/ion/IonRequestBuilder.java
index 56f1e5e6..d1274800 100644
--- a/ion/src/com/koushikdutta/ion/IonRequestBuilder.java
+++ b/ion/src/com/koushikdutta/ion/IonRequestBuilder.java
@@ -54,6 +54,7 @@
 import com.koushikdutta.ion.gson.GsonSerializer;
 import com.koushikdutta.ion.gson.PojoBody;
 
+import org.apache.http.NameValuePair;
 import org.w3c.dom.Document;
 
 import java.io.File;
@@ -584,14 +585,19 @@ public void onCompleted(Exception e, T result) {
         return execute(new StringParser());
     }
 
+    @Override
+    public ResponseFuture<InputStream> asInputStream() {
+        return execute(new InputStreamParser());
+    }
+
     @Override
     public <F extends OutputStream> ResponseFuture<F> write(F outputStream, boolean close) {
-        return execute(new OutputStreamDataSink(ion.getServer(), outputStream, true), close, outputStream);
+        return execute(new OutputStreamDataSink(ion.getServer(), outputStream, false), close, outputStream);
     }
 
     @Override
     public <F extends OutputStream> ResponseFuture<F> write(F outputStream) {
-        return execute(new OutputStreamDataSink(ion.getServer(), outputStream, true), true, outputStream);
+        return execute(new OutputStreamDataSink(ion.getServer(), outputStream, false), true, outputStream);
     }
 
     @Override
@@ -785,4 +791,12 @@ public IonRequestBuilder basicAuthentication(String username, String password) {
         setBody(new StreamBody(inputStream, length));
         return this;
     }
+
+    @Override
+    public Builders.Any.B setHeader(NameValuePair... header) {
+        for (NameValuePair h: header) {
+            this.headers.set(h.getName(), h.getValue());
+        }
+        return this;
+    }
 }
diff --git a/ion/src/com/koushikdutta/ion/LoadBitmap.java b/ion/src/com/koushikdutta/ion/LoadBitmap.java
index 17634aa7..1cfdce67 100644
--- a/ion/src/com/koushikdutta/ion/LoadBitmap.java
+++ b/ion/src/com/koushikdutta/ion/LoadBitmap.java
@@ -19,22 +19,13 @@
     int resizeWidth;
     int resizeHeight;
     IonRequestBuilder.EmitterTransform<ByteBufferList> emitterTransform;
-    static ExecutorService singleExecutorService;
 
-    static {
-        int numProcs = Runtime.getRuntime().availableProcessors();
-        if (numProcs <= 2) {
-            singleExecutorService = Executors.newFixedThreadPool(1);
-        }
-    }
 
     public LoadBitmap(Ion ion, String urlKey, boolean put, int resizeWidth, int resizeHeight, IonRequestBuilder.EmitterTransform<ByteBufferList> emitterTransform) {
         super(ion, urlKey, put);
         this.resizeWidth = resizeWidth;
         this.resizeHeight = resizeHeight;
         this.emitterTransform = emitterTransform;
-
-        ion.bitmapsPending.tag(urlKey, this);
     }
 
     private boolean isGif() {
@@ -63,10 +54,7 @@ public void onCompleted(Exception e, final ByteBufferList result) {
             return;
         }
 
-        ExecutorService executorService = singleExecutorService;
-        if (executorService == null) {
-            executorService = ion.getServer().getExecutorService();
-        }
+        ExecutorService executorService = ion.getBitmapLoadExecutorService();
 
         executorService.execute(new Runnable() {
             @Override
diff --git a/ion/src/com/koushikdutta/ion/Loader.java b/ion/src/com/koushikdutta/ion/Loader.java
index 1098e80b..655a3018 100644
--- a/ion/src/com/koushikdutta/ion/Loader.java
+++ b/ion/src/com/koushikdutta/ion/Loader.java
@@ -1,10 +1,13 @@
 package com.koushikdutta.ion;
 
+import android.graphics.Bitmap;
+
 import com.koushikdutta.async.DataEmitter;
 import com.koushikdutta.async.future.Future;
 import com.koushikdutta.async.future.FutureCallback;
 import com.koushikdutta.async.http.AsyncHttpRequest;
 import com.koushikdutta.async.http.libcore.RawHeaders;
+import com.koushikdutta.ion.bitmap.BitmapInfo;
 
 import java.io.InputStream;
 
@@ -55,4 +58,6 @@ public AsyncHttpRequest getRequest() {
     // returns a Future if this loader can handle a request
     // otherwise it returns null, and Ion continues to the next loader.
     public Future<DataEmitter> load(Ion ion, AsyncHttpRequest request, FutureCallback<LoaderEmitter> callback);
+
+    public Future<BitmapInfo> loadBitmap(Ion ion, String uri);
 }
diff --git a/ion/src/com/koushikdutta/ion/builder/FutureBuilder.java b/ion/src/com/koushikdutta/ion/builder/FutureBuilder.java
index 1e85ab53..f18dcb84 100644
--- a/ion/src/com/koushikdutta/ion/builder/FutureBuilder.java
+++ b/ion/src/com/koushikdutta/ion/builder/FutureBuilder.java
@@ -10,6 +10,7 @@
 import org.w3c.dom.Document;
 
 import java.io.File;
+import java.io.InputStream;
 import java.io.OutputStream;
 
 /**
@@ -22,6 +23,14 @@
      */
     public ResponseFuture<String> asString();
 
+    /**
+     * Execute the request and get the result as an InputStream.
+     * This method will load the entire response into memory
+     * and should not be used for large responses.
+     * @return
+     */
+    public ResponseFuture<InputStream> asInputStream();
+
     /**
      * Execute the request and get the result as a (Gson) JsonArray
      * @return
diff --git a/ion/src/com/koushikdutta/ion/builder/RequestBuilder.java b/ion/src/com/koushikdutta/ion/builder/RequestBuilder.java
index 2abaa6c2..52367f8d 100644
--- a/ion/src/com/koushikdutta/ion/builder/RequestBuilder.java
+++ b/ion/src/com/koushikdutta/ion/builder/RequestBuilder.java
@@ -13,6 +13,7 @@
 import com.koushikdutta.ion.HeadersCallback;
 import com.koushikdutta.ion.ProgressCallback;
 
+import org.apache.http.NameValuePair;
 import org.w3c.dom.Document;
 
 import java.io.File;
@@ -115,6 +116,13 @@
      */
     public R setHeader(String name, String value);
 
+    /**
+     * Set HTTP headers
+     * @param header
+     * @return
+     */
+    public R setHeader(NameValuePair... header);
+
     /**
      * Disable usage of the cache for this request
      * @return
diff --git a/ion/src/com/koushikdutta/ion/loader/ContentLoader.java b/ion/src/com/koushikdutta/ion/loader/ContentLoader.java
index 5c3f2dc8..9ebea232 100644
--- a/ion/src/com/koushikdutta/ion/loader/ContentLoader.java
+++ b/ion/src/com/koushikdutta/ion/loader/ContentLoader.java
@@ -9,6 +9,7 @@
 import com.koushikdutta.async.stream.InputStreamDataEmitter;
 import com.koushikdutta.ion.Ion;
 import com.koushikdutta.ion.Loader;
+import com.koushikdutta.ion.bitmap.BitmapInfo;
 
 import java.io.InputStream;
 
@@ -19,6 +20,11 @@
     private static final class InputStreamDataEmitterFuture extends SimpleFuture<DataEmitter> {
     }
 
+    @Override
+    public Future<BitmapInfo> loadBitmap(Ion ion, final String uri) {
+        return null;
+    }
+
     @Override
     public Future<InputStream> load(final Ion ion, final AsyncHttpRequest request) {
         return null;
diff --git a/ion/src/com/koushikdutta/ion/loader/FileLoader.java b/ion/src/com/koushikdutta/ion/loader/FileLoader.java
index af2130fe..904120c0 100644
--- a/ion/src/com/koushikdutta/ion/loader/FileLoader.java
+++ b/ion/src/com/koushikdutta/ion/loader/FileLoader.java
@@ -10,6 +10,7 @@
 import com.koushikdutta.async.http.AsyncHttpRequest;
 import com.koushikdutta.ion.Ion;
 import com.koushikdutta.ion.Loader;
+import com.koushikdutta.ion.bitmap.BitmapInfo;
 
 import java.io.File;
 import java.io.FileInputStream;
@@ -22,6 +23,11 @@
     private static final class FileFuture extends SimpleFuture<DataEmitter> {
     }
 
+    @Override
+    public Future<BitmapInfo> loadBitmap(Ion ion, final String uri) {
+        return null;
+    }
+
     @Override
     public Future<InputStream> load(final Ion ion, final AsyncHttpRequest request) {
         if (!request.getUri().getScheme().startsWith("file"))
diff --git a/ion/src/com/koushikdutta/ion/loader/HttpLoader.java b/ion/src/com/koushikdutta/ion/loader/HttpLoader.java
index f0129f39..8ea2d22c 100644
--- a/ion/src/com/koushikdutta/ion/loader/HttpLoader.java
+++ b/ion/src/com/koushikdutta/ion/loader/HttpLoader.java
@@ -11,6 +11,7 @@
 import com.koushikdutta.async.http.libcore.RawHeaders;
 import com.koushikdutta.ion.Ion;
 import com.koushikdutta.ion.Loader;
+import com.koushikdutta.ion.bitmap.BitmapInfo;
 
 import java.io.InputStream;
 
@@ -18,6 +19,11 @@
  * Created by koush on 5/22/13.
  */
 public class HttpLoader implements Loader {
+    @Override
+    public Future<BitmapInfo> loadBitmap(Ion ion, final String uri) {
+        return null;
+    }
+
     @Override
     public Future<InputStream> load(Ion ion, AsyncHttpRequest request) {
         return null;
diff --git a/ion/src/com/koushikdutta/ion/loader/PackageIconLoader.java b/ion/src/com/koushikdutta/ion/loader/PackageIconLoader.java
new file mode 100644
index 00000000..8b914b83
--- /dev/null
+++ b/ion/src/com/koushikdutta/ion/loader/PackageIconLoader.java
@@ -0,0 +1,62 @@
+package com.koushikdutta.ion.loader;
+
+
+import android.content.pm.PackageInfo;
+import android.content.pm.PackageManager;
+import android.graphics.Bitmap;
+import android.graphics.drawable.BitmapDrawable;
+
+import com.koushikdutta.async.DataEmitter;
+import com.koushikdutta.async.future.Future;
+import com.koushikdutta.async.future.FutureCallback;
+import com.koushikdutta.async.future.SimpleFuture;
+import com.koushikdutta.async.http.AsyncHttpRequest;
+import com.koushikdutta.ion.Ion;
+import com.koushikdutta.ion.Loader;
+import com.koushikdutta.ion.bitmap.BitmapInfo;
+
+import java.io.InputStream;
+import java.net.URI;
+
+/**
+ * Created by koush on 11/3/13.
+ */
+public class PackageIconLoader implements Loader {
+    @Override
+    public Future<InputStream> load(Ion ion, AsyncHttpRequest request) {
+        return null;
+    }
+
+    @Override
+    public Future<DataEmitter> load(Ion ion, AsyncHttpRequest request, FutureCallback<LoaderEmitter> callback) {
+        return null;
+    }
+
+    @Override
+    public Future<BitmapInfo> loadBitmap(final Ion ion, final String uri) {
+        final URI request = URI.create(uri);
+        if (!request.getScheme().startsWith("package"))
+            return null;
+
+        final SimpleFuture<BitmapInfo> ret = new SimpleFuture<BitmapInfo>();
+        ion.getBitmapLoadExecutorService().execute(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    String pkg = request.getHost();
+                    PackageManager pm = ion.getContext().getPackageManager();
+                    Bitmap bmp = ((BitmapDrawable)pm.getPackageInfo(pkg, 0).applicationInfo.loadIcon(pm)).getBitmap();
+                    BitmapInfo info = new BitmapInfo();
+                    info.bitmaps = new Bitmap[] { bmp };
+                    info.loadedFrom =  Loader.LoaderEmitter.LOADED_FROM_CACHE;
+                    ret.setComplete(info);
+                }
+                catch (Exception e) {
+                    ret.setComplete(e);
+                }
+            }
+        });
+
+        return ret;
+    }
+}
