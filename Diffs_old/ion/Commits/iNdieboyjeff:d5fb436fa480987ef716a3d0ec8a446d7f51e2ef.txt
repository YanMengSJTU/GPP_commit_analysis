diff --git a/ion/src/com/koushikdutta/ion/IonBitmapRequestBuilder.java b/ion/src/com/koushikdutta/ion/IonBitmapRequestBuilder.java
index ae607c00..24a3b36c 100644
--- a/ion/src/com/koushikdutta/ion/IonBitmapRequestBuilder.java
+++ b/ion/src/com/koushikdutta/ion/IonBitmapRequestBuilder.java
@@ -236,6 +236,7 @@ BitmapFetcher executeCache() {
 
     private IonDrawable setIonDrawable(ImageView imageView, BitmapInfo info, int loadedFrom) {
         IonDrawable ret = IonDrawable.getOrCreateIonDrawable(imageView)
+        .ion(ion)
         .setBitmap(info, loadedFrom)
         .setSize(resizeWidth, resizeHeight)
         .setError(errorResource, errorDrawable)
diff --git a/ion/src/com/koushikdutta/ion/IonDrawable.java b/ion/src/com/koushikdutta/ion/IonDrawable.java
index bf1036b7..f35bc3f2 100644
--- a/ion/src/com/koushikdutta/ion/IonDrawable.java
+++ b/ion/src/com/koushikdutta/ion/IonDrawable.java
@@ -39,12 +39,18 @@
     private boolean disableFadeIn;
     private int resizeWidth;
     private int resizeHeight;
+    private Ion ion;
 
     public IonDrawable cancel() {
         requestCount++;
         return this;
     }
 
+    public IonDrawable ion(Ion ion) {
+        this.ion = ion;
+        return this;
+    }
+
     public SimpleFuture<ImageView> getFuture() {
         return callback.imageViewFuture;
     }
@@ -395,14 +401,17 @@ else if (info.mipmap != null) {
             int levelTiles = 1 << level;
             int levelDim = levelTiles * TILE_DIM;
             Rect visible = new Rect(visibleLeft, visibleTop, visibleRight, visibleBottom);
-            System.out.println("visible: " + visible);
-
+//            System.out.println("visible: " + visible);
 
             int textureTileDim = textureDim / levelTiles;
 
+            paint.setColor(Color.BLACK);
+            canvas.drawRect(getBounds(), paint);
+
             for (int y = 0; y < levelTiles; y++) {
                 int top = textureTileDim * y;
                 int bottom = textureTileDim * (y + 1);
+                bottom = Math.min(bottom, bounds.bottom);
                 if (bottom < visibleTop)
                     continue;
                 if (top > visibleBottom)
@@ -410,23 +419,39 @@ else if (info.mipmap != null) {
                 for (int x = 0; x < levelTiles; x++) {
                     int left = textureTileDim * x;
                     int right = textureTileDim * (x + 1);
+                    right = Math.min(right, bounds.right);
                     if (right < visibleLeft)
                         continue;
                     if (left > visibleRight)
                         continue;
 
-                    // fetch render
-                    Rect render = new Rect(left, top, right, bottom);
-                    System.out.println("rendering: " + render);
-                    String tileKey = ResponseCacheMiddleware.toKeyString(info.key + x + "," + y);
-//                    BitmapInfo tile =
+                    Rect texRect = new Rect(left, top, right, bottom);
+
+                    // find, render/fetch
+                    System.out.println("rendering: " + texRect + " for: " + bounds);
+                    String tileKey = ResponseCacheMiddleware.toKeyString(info.key + "," + level + "," + x + "," + y);
+                    BitmapInfo tile = ion.bitmapCache.get(tileKey);
+                    if (tile != null) {
+                        // render it
+                        if (tile.bitmaps != null) {
+                            System.out.println("bitmap is: " + tile.bitmaps[0].getWidth() + "x" + tile.bitmaps[0].getHeight());
+                            canvas.drawBitmap(tile.bitmaps[0], null, texRect, paint);
+                        }
+                        continue;
+                    }
+
+                    if (ion.bitmapsPending.tag(tileKey) == null) {
+                        // fetch it
+                        LoadBitmapRegion region = new LoadBitmapRegion(ion, tileKey, info.mipmap, texRect, level);
+                    }
+                    ion.bitmapsPending.add(tileKey, tileCallback);
                 }
             }
 
 
-            paint.setColor(Color.RED);
-            canvas.drawRect(getBounds(), paint);
-            paint.reset();
+//            paint.setColor(Color.RED);
+//            canvas.drawRect(getBounds(), paint);
+//            paint.reset();
         }
         else {
             Drawable error = tryGetErrorResource();
diff --git a/ion/src/com/koushikdutta/ion/bitmap/IonBitmapCache.java b/ion/src/com/koushikdutta/ion/bitmap/IonBitmapCache.java
index b3325854..6e9687ea 100644
--- a/ion/src/com/koushikdutta/ion/bitmap/IonBitmapCache.java
+++ b/ion/src/com/koushikdutta/ion/bitmap/IonBitmapCache.java
@@ -1,5 +1,6 @@
 package com.koushikdutta.ion.bitmap;
 
+import android.annotation.TargetApi;
 import android.app.ActivityManager;
 import android.content.Context;
 import android.content.res.AssetManager;
@@ -10,6 +11,7 @@
 import android.graphics.Matrix;
 import android.graphics.Point;
 import android.graphics.Rect;
+import android.os.Build;
 import android.os.Looper;
 import android.util.DisplayMetrics;
 import android.util.Log;
@@ -150,9 +152,11 @@ public Bitmap loadBitmap(byte[] bytes, int offset, int length, int minx, int min
         return Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(), bitmap.getHeight(), matrix, true);
     }
 
-    public Bitmap loadRegion(BitmapRegionDecoder decoder, Rect sourceRect) {
-//        decoder.decodeRegion()
-        return null;
+    @TargetApi(Build.VERSION_CODES.GINGERBREAD_MR1)
+    public Bitmap loadRegion(BitmapRegionDecoder decoder, Rect sourceRect, int level) {
+        BitmapFactory.Options options = new BitmapFactory.Options();
+        options.inSampleSize = 1 << level;
+        return decoder.decodeRegion(sourceRect, options);
     }
 
     public Bitmap loadBitmap(InputStream stream, int minx, int miny, Point outSize) {
