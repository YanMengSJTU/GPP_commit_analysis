diff --git a/ion/src/com/koushikdutta/ion/BitmapToBitmapInfo.java b/ion/src/com/koushikdutta/ion/BitmapToBitmapInfo.java
index 1e89a0da..c2db9f0e 100644
--- a/ion/src/com/koushikdutta/ion/BitmapToBitmapInfo.java
+++ b/ion/src/com/koushikdutta/ion/BitmapToBitmapInfo.java
@@ -3,6 +3,7 @@
 import android.graphics.Bitmap;
 import android.graphics.BitmapFactory;
 
+import com.koushikdutta.async.ByteBufferList;
 import com.koushikdutta.async.future.Future;
 import com.koushikdutta.async.future.FutureCallback;
 import com.koushikdutta.async.future.SimpleFuture;
@@ -11,8 +12,11 @@
 import com.koushikdutta.ion.bitmap.BitmapInfo;
 import com.koushikdutta.ion.bitmap.Transform;
 
+import java.io.DataInputStream;
+import java.io.FileInputStream;
 import java.io.InputStream;
 import java.io.OutputStream;
+import java.nio.ByteBuffer;
 import java.util.ArrayList;
 
 class BitmapToBitmapInfo extends BitmapCallback implements FutureCallback<BitmapInfo> {
@@ -22,11 +26,18 @@ public static void getBitmapSnapshot(final Ion ion, final String transformKey) {
         ion.getServer().getExecutorService().execute(new Runnable() {
             @Override
             public void run() {
-                final LoadBitmapStream callback = new LoadBitmapStream(ion, transformKey, true, 0, 0);
+                final LoadBitmap callback = new LoadBitmap(ion, transformKey, true, 0, 0, Loader.LoaderEmitter.LOADED_FROM_CACHE);
+
                 try {
                     DiskLruCache.Snapshot snapshot = ion.getResponseCache().getDiskLruCache().get(transformKey);
                     try {
-                        callback.loadInputStream(snapshot.getInputStream(0));
+                        InputStream in = snapshot.getInputStream(0);
+                        assert in instanceof FileInputStream;
+                        int available = in.available();
+                        ByteBuffer b = ByteBufferList.obtain(available);
+                        new DataInputStream(in).readFully(b.array(), 0, available);
+                        b.limit(available);
+                        callback.onCompleted(null, new ByteBufferList(b));
                     }
                     finally {
                         snapshot.close();
diff --git a/ion/src/com/koushikdutta/ion/IonBitmapRequestBuilder.java b/ion/src/com/koushikdutta/ion/IonBitmapRequestBuilder.java
index 8fed2466..cb482809 100644
--- a/ion/src/com/koushikdutta/ion/IonBitmapRequestBuilder.java
+++ b/ion/src/com/koushikdutta/ion/IonBitmapRequestBuilder.java
@@ -114,30 +114,20 @@ BitmapInfo execute() {
 
         // Perform a download as necessary.
         if (!ion.bitmapsPending.contains(downloadKey)) {
-            // see if we can get a direct input stream. This should be a seekable InputStream
-            // that will not block on read. Ie, it needs to be fully downloaded, before returning
-            // the stream.
-            // Otherwise, just grab the asynchronous DataEmitter.
-            Future<InputStream> inputStreamFuture = builder.execute();
-            if (inputStreamFuture != null) {
-                inputStreamFuture.setCallback(new LoadBitmapStream(ion, downloadKey, !hasTransforms, resizeWidth, resizeHeight));
-            }
-            else {
-                builder.setHandler(null);
-                // if we cancel, gotta remove any waiters.
-                IonRequestBuilder.EmitterTransform<ByteBufferList> emitterTransform = builder.execute(new ByteBufferListParser(), new Runnable() {
-                    @Override
-                    public void run() {
-                        AsyncServer.post(Ion.mainHandler, new Runnable() {
-                            @Override
-                            public void run() {
-                                ion.bitmapsPending.remove(downloadKey);
-                            }
-                        });
-                    }
-                });
-                emitterTransform.setCallback(new LoadBitmap(ion, downloadKey, !hasTransforms, resizeWidth, resizeHeight, emitterTransform));
-            }
+            builder.setHandler(null);
+            // if we cancel, gotta remove any waiters.
+            IonRequestBuilder.EmitterTransform<ByteBufferList> emitterTransform = builder.execute(new ByteBufferListParser(), new Runnable() {
+                @Override
+                public void run() {
+                    AsyncServer.post(Ion.mainHandler, new Runnable() {
+                        @Override
+                        public void run() {
+                            ion.bitmapsPending.remove(downloadKey);
+                        }
+                    });
+                }
+            });
+            emitterTransform.setCallback(new LoadBitmap(ion, downloadKey, !hasTransforms, resizeWidth, resizeHeight, emitterTransform.loadedFrom()));
         }
 
         // if there's a transform, do it
diff --git a/ion/src/com/koushikdutta/ion/LoadBitmap.java b/ion/src/com/koushikdutta/ion/LoadBitmap.java
index d1e59f76..07a2ef14 100644
--- a/ion/src/com/koushikdutta/ion/LoadBitmap.java
+++ b/ion/src/com/koushikdutta/ion/LoadBitmap.java
@@ -12,13 +12,13 @@
 class LoadBitmap extends BitmapCallback implements FutureCallback<ByteBufferList> {
     int resizeWidth;
     int resizeHeight;
-    IonRequestBuilder.EmitterTransform<ByteBufferList> emitterTransform;
+    int loadedFrom;
 
-    public LoadBitmap(Ion ion, String urlKey, boolean put, int resizeWidth, int resizeHeight, IonRequestBuilder.EmitterTransform<ByteBufferList> emitterTransform) {
+    public LoadBitmap(Ion ion, String urlKey, boolean put, int resizeWidth, int resizeHeight, int loadedFrom) {
         super(ion, urlKey, put);
         this.resizeWidth = resizeWidth;
         this.resizeHeight = resizeHeight;
-        this.emitterTransform = emitterTransform;
+        this.loadedFrom = loadedFrom;
     }
 
     @Override
@@ -41,7 +41,7 @@ public void run() {
                     BitmapInfo info = new BitmapInfo();
                     info.key = key;
                     info.bitmap = bitmap;
-                    info.loadedFrom = emitterTransform.loadedFrom();
+                    info.loadedFrom = loadedFrom;
 
                     report(null, info);
                 } catch (Exception e) {
