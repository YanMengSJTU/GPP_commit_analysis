diff --git a/ion-sample/ion-sample.iml b/ion-sample/ion-sample.iml
index 0a766461..f99e4e75 100644
--- a/ion-sample/ion-sample.iml
+++ b/ion-sample/ion-sample.iml
@@ -3,6 +3,9 @@
   <component name="FacetManager">
     <facet type="android" name="Android">
       <configuration>
+        <proGuardCfgFiles>
+          <file>file://$APPLICATION_HOME_DIR$/sdk/tools/proguard/proguard-android.txt</file>
+        </proGuardCfgFiles>
         <option name="UPDATE_PROPERTY_FILES" value="true" />
         <notImportedProperties>
           <property>MANIFEST_FILE_PATH</property>
diff --git a/ion-sample/res/drawable/borg.gif b/ion-sample/res/drawable/borg.gif
new file mode 100644
index 00000000..f67922be
Binary files /dev/null and b/ion-sample/res/drawable/borg.gif differ
diff --git a/ion-sample/src/com/koushikdutta/ion/sample/ImageViewSample.java b/ion-sample/src/com/koushikdutta/ion/sample/ImageViewSample.java
index c18f39e8..c6f6bacc 100644
--- a/ion-sample/src/com/koushikdutta/ion/sample/ImageViewSample.java
+++ b/ion-sample/src/com/koushikdutta/ion/sample/ImageViewSample.java
@@ -50,12 +50,27 @@ public void loadGifCenterInside() {
         .intoImageView(imageView);
     }
 
+    public void loadGifResource() {
+        Ion.with(this)
+        .load("android.resource://" + getPackageName() + "/" + R.drawable.borg)
+        .withBitmap()
+        .resize(512, 512)
+        .centerInside()
+        .intoImageView(imageView);
+    }
+
     public void loadExifRotated() {
         Ion.with(this)
         .load("https://raw.github.com/koush/ion/master/ion-test/testdata/exif.jpg")
         .intoImageView(imageView);
     }
 
+    public void loadTwitterResource() {
+        Ion.with(this)
+        .load("android.resource://" + getPackageName() + "/drawable/twitter")
+        .intoImageView(imageView);
+    }
+
     Spinner fitChoices;
     ImageView imageView;
     @Override
@@ -71,7 +86,9 @@ protected void onCreate(Bundle savedInstanceState) {
         adapter.add("centerInside");
         adapter.add("gif centerCrop");
         adapter.add("gif centerInside");
+        adapter.add("gif resource");
         adapter.add("exif rotated");
+        adapter.add("twitter drawable resource");
         fitChoices.setAdapter(adapter);
         fitChoices.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {
             @Override
@@ -85,7 +102,11 @@ else if (position == 2)
                 else if (position == 3)
                     loadGifCenterInside();
                 else if (position == 4)
+                    loadGifResource();
+                else if (position == 5)
                     loadExifRotated();
+                else if (position == 6)
+                    loadTwitterResource();
             }
 
             @Override
diff --git a/ion-test/testdata/exif.jpg b/ion-test/assets/exif.jpg
similarity index 100%
rename from ion-test/testdata/exif.jpg
rename to ion-test/assets/exif.jpg
diff --git a/ion-test/ion-test.iml b/ion-test/ion-test.iml
index 8b83fd1e..08cc3fc3 100644
--- a/ion-test/ion-test.iml
+++ b/ion-test/ion-test.iml
@@ -3,6 +3,9 @@
   <component name="FacetManager">
     <facet type="android" name="Android">
       <configuration>
+        <proGuardCfgFiles>
+          <file>file://$APPLICATION_HOME_DIR$/sdk/tools/proguard/proguard-android.txt</file>
+        </proGuardCfgFiles>
         <option name="UPDATE_PROPERTY_FILES" value="true" />
         <notImportedProperties>
           <property>MANIFEST_FILE_PATH</property>
diff --git a/ion-test/src/com/koushikdutta/ion/test/AssetTests.java b/ion-test/src/com/koushikdutta/ion/test/AssetTests.java
new file mode 100644
index 00000000..c9cc4a0a
--- /dev/null
+++ b/ion-test/src/com/koushikdutta/ion/test/AssetTests.java
@@ -0,0 +1,20 @@
+package com.koushikdutta.ion.test;
+
+import android.graphics.Bitmap;
+import android.test.AndroidTestCase;
+
+import com.koushikdutta.ion.Ion;
+
+/**
+ * Created by koush on 6/28/14.
+ */
+public class AssetTests extends AndroidTestCase {
+    public void testAsset() throws Exception {
+        Bitmap bitmap = Ion.with(getContext())
+        .load("file://android_asset/exif.jpg")
+        .asBitmap()
+        .get();
+
+        assertNotNull(bitmap);
+    }
+}
diff --git a/ion-test/src/com/koushikdutta/ion/test/AuthTests.java b/ion-test/src/com/koushikdutta/ion/test/AuthTests.java
index 01cb201e..2b37f168 100644
--- a/ion-test/src/com/koushikdutta/ion/test/AuthTests.java
+++ b/ion-test/src/com/koushikdutta/ion/test/AuthTests.java
@@ -47,6 +47,7 @@ public void onRequest(AsyncHttpServerRequest request, AsyncHttpServerResponse re
                     response.send(json.toString());
                 }
                 catch (Exception e) {
+                    e.printStackTrace();
                     fail();
                 }
             }
diff --git a/ion-test/src/com/koushikdutta/ion/test/BitmapTests.java b/ion-test/src/com/koushikdutta/ion/test/BitmapTests.java
index a6e4ab30..3d9800d7 100644
--- a/ion-test/src/com/koushikdutta/ion/test/BitmapTests.java
+++ b/ion-test/src/com/koushikdutta/ion/test/BitmapTests.java
@@ -69,7 +69,7 @@ public void onCompleted(Exception e, Bitmap result) {
 
     public void testCropping() throws Exception {
         Bitmap result = Ion.with(getContext())
-        .load("https://raw.github.com/koush/ion/master/ion-test/testdata/exif.jpg")
+        .load("https://raw.githubusercontent.com/koush/ion/master/ion-test/assets/exif.jpg")
         .withBitmap()
         .resize(1080, 1845)
         .centerCrop()
diff --git a/ion-test/src/com/koushikdutta/ion/test/ExifTests.java b/ion-test/src/com/koushikdutta/ion/test/ExifTests.java
index 0e7c09d3..642d3732 100644
--- a/ion-test/src/com/koushikdutta/ion/test/ExifTests.java
+++ b/ion-test/src/com/koushikdutta/ion/test/ExifTests.java
@@ -11,7 +11,7 @@
 public class ExifTests extends AndroidTestCase {
     public void testRotated() throws Exception {
         Bitmap bitmap = Ion.with(getContext())
-        .load("https://raw.github.com/koush/ion/master/ion-test/testdata/exif.jpg")
+        .load("https://raw.github.com/koush/ion/master/ion-test/assets/exif.jpg")
         .asBitmap()
         .get();
 
diff --git a/ion-test/src/com/koushikdutta/ion/test/GsonTests.java b/ion-test/src/com/koushikdutta/ion/test/GsonTests.java
index b29530bc..772bdfd5 100644
--- a/ion-test/src/com/koushikdutta/ion/test/GsonTests.java
+++ b/ion-test/src/com/koushikdutta/ion/test/GsonTests.java
@@ -4,19 +4,22 @@
 
 import com.google.gson.JsonObject;
 import com.google.gson.JsonParseException;
-import com.google.gson.annotations.SerializedName;
 import com.google.gson.reflect.TypeToken;
 import com.koushikdutta.async.AsyncServer;
+import com.koushikdutta.async.ByteBufferList;
+import com.koushikdutta.async.FilteredDataEmitter;
 import com.koushikdutta.async.future.Future;
+import com.koushikdutta.async.future.FutureCallback;
 import com.koushikdutta.async.http.server.AsyncHttpServer;
 import com.koushikdutta.async.http.server.AsyncHttpServerRequest;
 import com.koushikdutta.async.http.server.AsyncHttpServerResponse;
 import com.koushikdutta.async.http.server.HttpServerRequestCallback;
 import com.koushikdutta.ion.Ion;
+import com.koushikdutta.ion.gson.GsonObjectParser;
 
-import junit.framework.Test;
-
+import java.nio.ByteBuffer;
 import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Semaphore;
 
 /**
  * Created by koush on 6/5/13.
@@ -62,4 +65,67 @@ public void onRequest(AsyncHttpServerRequest request, final AsyncHttpServerRespo
             AsyncServer.getDefault().stop();
         }
     }
+
+    public void testParserCastingSuccess() throws Exception {
+        ByteBufferList b = new ByteBufferList(ByteBuffer.wrap("{}".getBytes()));
+        FilteredDataEmitter emitter = new FilteredDataEmitter() {
+            @Override
+            public boolean isPaused() {
+                return false;
+            }
+        };
+        GsonObjectParser g = new GsonObjectParser();
+        Future<JsonObject> ret = g.parse(emitter);
+        emitter.onDataAvailable(emitter, b);
+        emitter.getEndCallback().onCompleted(null);
+        JsonObject j = ret.get();
+        assertNotNull(j);
+    }
+
+
+    public void testParserCastingError() throws Exception {
+        ByteBufferList b = new ByteBufferList(ByteBuffer.wrap("[]".getBytes()));
+        FilteredDataEmitter emitter = new FilteredDataEmitter() {
+            @Override
+            public boolean isPaused() {
+                return false;
+            }
+        };
+        GsonObjectParser g = new GsonObjectParser();
+        Future<JsonObject> ret = g.parse(emitter);
+        emitter.onDataAvailable(emitter, b);
+        emitter.getEndCallback().onCompleted(null);
+        try {
+            JsonObject j = ret.get();
+            fail(j.toString());
+        }
+        catch (Exception e) {
+            e.printStackTrace();
+        }
+    }
+
+    public void testParserCastingCallbackError() throws Exception {
+        ByteBufferList b = new ByteBufferList(ByteBuffer.wrap("[]".getBytes()));
+        FilteredDataEmitter emitter = new FilteredDataEmitter() {
+            @Override
+            public boolean isPaused() {
+                return false;
+            }
+        };
+        GsonObjectParser g = new GsonObjectParser();
+        Future<JsonObject> ret = g.parse(emitter);
+        emitter.onDataAvailable(emitter, b);
+        emitter.getEndCallback().onCompleted(null);
+        final Semaphore s = new Semaphore(0);
+        ret.setCallback(new FutureCallback<JsonObject>() {
+            @Override
+            public void onCompleted(Exception e, JsonObject result) {
+                assertNull(result);
+                assertNotNull(e);
+                assertTrue(e instanceof ClassCastException);
+                s.release();
+            }
+        });
+        s.acquire();
+    }
 }
diff --git a/ion-test/testdata/df692b2d8d2bd156b5f0a998d07f8b2a b/ion-test/testdata/df692b2d8d2bd156b5f0a998d07f8b2a
deleted file mode 100644
index c6695a0d..00000000
Binary files a/ion-test/testdata/df692b2d8d2bd156b5f0a998d07f8b2a and /dev/null differ
diff --git a/ion-test/testdata/test.json b/ion-test/testdata/test.json
deleted file mode 100644
index b42f309e..00000000
--- a/ion-test/testdata/test.json
+++ /dev/null
@@ -1,3 +0,0 @@
-{
-  "foo": "bar"
-}
\ No newline at end of file
diff --git a/ion/ion.iml b/ion/ion.iml
index a4121540..3752d127 100644
--- a/ion/ion.iml
+++ b/ion/ion.iml
@@ -4,6 +4,9 @@
     <facet type="android" name="Android">
       <configuration>
         <option name="LIBRARY_PROJECT" value="true" />
+        <proGuardCfgFiles>
+          <file>file://$APPLICATION_HOME_DIR$/sdk/tools/proguard/proguard-android.txt</file>
+        </proGuardCfgFiles>
         <option name="UPDATE_PROPERTY_FILES" value="true" />
         <notImportedProperties>
           <property>MANIFEST_FILE_PATH</property>
diff --git a/ion/src/com/koushikdutta/ion/FileCacheStore.java b/ion/src/com/koushikdutta/ion/FileCacheStore.java
index e83119ae..f86290cd 100644
--- a/ion/src/com/koushikdutta/ion/FileCacheStore.java
+++ b/ion/src/com/koushikdutta/ion/FileCacheStore.java
@@ -1,6 +1,7 @@
 package com.koushikdutta.ion;
 
 import com.google.gson.JsonArray;
+import com.google.gson.JsonElement;
 import com.google.gson.JsonObject;
 import com.google.gson.reflect.TypeToken;
 import com.koushikdutta.async.callback.CompletedCallback;
@@ -11,6 +12,8 @@
 import com.koushikdutta.async.parser.StringParser;
 import com.koushikdutta.async.stream.FileDataSink;
 import com.koushikdutta.async.util.FileCache;
+import com.koushikdutta.ion.gson.GsonArrayParser;
+import com.koushikdutta.ion.gson.GsonObjectParser;
 import com.koushikdutta.ion.gson.GsonParser;
 import com.koushikdutta.ion.gson.GsonSerializer;
 
@@ -63,7 +66,7 @@ public void onCompleted(Exception ex) {
     }
 
     public Future<JsonObject> putJsonObject(JsonObject value) {
-        return put(value, new GsonParser<JsonObject>());
+        return put(value, new GsonObjectParser());
     }
 
     public Future<Document> putDocument(Document value) {
@@ -71,7 +74,7 @@ public void onCompleted(Exception ex) {
     }
 
     public Future<JsonArray> putJsonArray(JsonArray value) {
-        return put(value, new GsonParser<JsonArray>());
+        return put(value, new GsonArrayParser());
     }
 
     /*
@@ -140,19 +143,19 @@ public String getString() {
     }
 
     public Future<JsonObject> asJsonObject() {
-        return as(new GsonParser<JsonObject>());
+        return as(new GsonObjectParser());
     }
 
     public JsonObject getJsonObject() {
-        return get(new GsonParser<JsonObject>());
+        return get(new GsonObjectParser());
     }
 
     public Future<JsonArray> asJsonArray() {
-        return as(new GsonParser<JsonArray>());
+        return as(new GsonArrayParser());
     }
 
     public JsonArray getJsonArray() {
-        return get(new GsonParser<JsonArray>());
+        return get(new GsonArrayParser());
     }
 
     public Future<Document> asDocument() {
diff --git a/ion/src/com/koushikdutta/ion/Ion.java b/ion/src/com/koushikdutta/ion/Ion.java
index 02b613c6..fad87f38 100644
--- a/ion/src/com/koushikdutta/ion/Ion.java
+++ b/ion/src/com/koushikdutta/ion/Ion.java
@@ -28,11 +28,13 @@
 import com.koushikdutta.ion.builder.FutureBuilder;
 import com.koushikdutta.ion.builder.LoadBuilder;
 import com.koushikdutta.ion.cookie.CookieMiddleware;
+import com.koushikdutta.ion.loader.AssetLoader;
 import com.koushikdutta.ion.loader.AsyncHttpRequestFactory;
 import com.koushikdutta.ion.loader.ContentLoader;
 import com.koushikdutta.ion.loader.FileLoader;
 import com.koushikdutta.ion.loader.HttpLoader;
 import com.koushikdutta.ion.loader.PackageIconLoader;
+import com.koushikdutta.ion.loader.ResourceLoader;
 import com.koushikdutta.ion.loader.VideoLoader;
 
 import java.io.File;
@@ -146,6 +148,8 @@ public static Ion getInstance(Context context, String name) {
     FileCache storeCache;
     HttpLoader httpLoader;
     ContentLoader contentLoader;
+    ResourceLoader resourceLoader;
+    AssetLoader assetLoader;
     VideoLoader videoLoader;
     PackageIconLoader packageIconLoader;
     FileLoader fileLoader;
@@ -197,6 +201,8 @@ private Ion(Context context, String name) {
                 .addLoader(packageIconLoader = new PackageIconLoader())
                 .addLoader(httpLoader = new HttpLoader())
                 .addLoader(contentLoader = new ContentLoader())
+                .addLoader(resourceLoader = new ResourceLoader())
+                .addLoader(assetLoader = new AssetLoader())
                 .addLoader(fileLoader = new FileLoader());
     }
 
diff --git a/ion/src/com/koushikdutta/ion/IonBitmapRequestBuilder.java b/ion/src/com/koushikdutta/ion/IonBitmapRequestBuilder.java
index 55a6baf3..26fb2763 100644
--- a/ion/src/com/koushikdutta/ion/IonBitmapRequestBuilder.java
+++ b/ion/src/com/koushikdutta/ion/IonBitmapRequestBuilder.java
@@ -13,6 +13,7 @@
 import com.koushikdutta.async.future.SimpleFuture;
 import com.koushikdutta.async.util.FileCache;
 import com.koushikdutta.ion.bitmap.BitmapInfo;
+import com.koushikdutta.ion.bitmap.LocallyCachedStatus;
 import com.koushikdutta.ion.bitmap.Transform;
 import com.koushikdutta.ion.builder.BitmapFutureBuilder;
 import com.koushikdutta.ion.builder.Builders;
@@ -135,7 +136,7 @@ public IonBitmapRequestBuilder transform(Transform transform) {
 
     private String computeDownloadKey() {
         String downloadKey = builder.uri;
-        // although a gif is always same download, the initial decode is different
+        // although a gif is always same download, the decode (non/animated) result may different
         if (!animateGif)
             downloadKey += ":!animateGif";
         if (deepZoom)
@@ -143,12 +144,8 @@ private String computeDownloadKey() {
         return FileCache.toKeyString(downloadKey);
     }
 
-    @Override
-    public BitmapInfo asCachedBitmap() {
-        final String downloadKey = computeDownloadKey();
-        assert Thread.currentThread() == Looper.getMainLooper().getThread() || imageViewPostRef == null;
+    public String computeBitmapKey(String downloadKey) {
         assert downloadKey != null;
-
         if (resizeHeight > 0 || resizeWidth > 0) {
             if (transforms == null)
                 transforms = new ArrayList<Transform>();
@@ -164,36 +161,44 @@ public BitmapInfo asCachedBitmap() {
             }
             bitmapKey = FileCache.toKeyString(bitmapKey);
         }
+        return bitmapKey;
+    }
 
+    @Override
+    public LocallyCachedStatus isLocallyCached() {
+        if (builder.noCache || deepZoom)
+            return LocallyCachedStatus.NOT_CACHED;
+        final String downloadKey = computeDownloadKey();
+        String bitmapKey = computeBitmapKey(downloadKey);
+        BitmapInfo info = builder.ion.bitmapCache.get(bitmapKey);
+        // memory cache
+        if (info != null && info.bitmaps != null)
+            return LocallyCachedStatus.CACHED;
+        FileCache fileCache = ion.responseCache.getFileCache();
+        if (transforms != null && fileCache.exists(bitmapKey))
+            return LocallyCachedStatus.CACHED;
+        if (fileCache.exists(downloadKey))
+            return LocallyCachedStatus.MAYBE_CACHED;
+        return LocallyCachedStatus.NOT_CACHED;
+    }
+
+    @Override
+    public BitmapInfo asCachedBitmap() {
+        assert Thread.currentThread() == Looper.getMainLooper().getThread() || imageViewPostRef == null;
+        final String downloadKey = computeDownloadKey();
+        String bitmapKey = computeBitmapKey(downloadKey);
         return builder.ion.bitmapCache.get(bitmapKey);
     }
 
     BitmapFetcher executeCache() {
         final String downloadKey = computeDownloadKey();
-        assert Thread.currentThread() == Looper.getMainLooper().getThread() || imageViewPostRef == null;
-        assert downloadKey != null;
-
-        if (resizeHeight > 0 || resizeWidth > 0) {
-            if (transforms == null)
-                transforms = new ArrayList<Transform>();
-            transforms.add(0, new DefaultTransform(resizeWidth, resizeHeight, scaleMode));
-        }
-
-        // determine the key for this bitmap after all transformations
-        String bitmapKey = downloadKey;
-        boolean hasTransforms = transforms != null && transforms.size() > 0;
-        if (hasTransforms) {
-            for (Transform transform : transforms) {
-                bitmapKey += transform.key();
-            }
-            bitmapKey = FileCache.toKeyString(bitmapKey);
-        }
+        String bitmapKey = computeBitmapKey(downloadKey);
 
         // TODO: eliminate this allocation?
         BitmapFetcher ret = new BitmapFetcher();
         ret.downloadKey = downloadKey;
         ret.bitmapKey = bitmapKey;
-        ret.hasTransforms = hasTransforms;
+        ret.hasTransforms = hasTransforms();
         ret.resizeWidth = resizeWidth;
         ret.resizeHeight = resizeHeight;
         ret.builder = builder;
@@ -228,18 +233,9 @@ private IonDrawable setIonDrawable(ImageView imageView, BitmapInfo info, int loa
 
     @Override
     public Future<ImageView> intoImageView(ImageView imageView) {
-        if (imageView == null)
-            throw new IllegalArgumentException("imageView");
         assert Thread.currentThread() == Looper.getMainLooper().getThread();
-
-        if (builder.uri != null && builder.uri.startsWith("android.resource:/")) {
-            IonDrawable drawable = setIonDrawable(imageView, null, 0);
-            SimpleFuture<ImageView> imageViewFuture = drawable.getFuture();
-            imageViewFuture.reset();
-            imageView.setImageURI(Uri.parse(builder.uri));
-            imageViewFuture.setComplete(null, imageView);
-            return imageViewFuture;
-        }
+        if (imageView == null)
+            throw new NullPointerException("imageView");
 
         // no uri? just set a placeholder and bail
         if (builder.uri == null) {
@@ -359,9 +355,10 @@ public IonBitmapRequestBuilder animateIn(int animationResource) {
 
     @Override
     public IonBitmapRequestBuilder centerCrop() {
-        if (transforms != null && transforms.size() > 0)
+        if (hasTransforms()) {
             throw new IllegalStateException("Can't apply centerCrop after transform has been called." +
             "centerCrop is applied to the original resized bitmap.");
+        }
         if (resizeWidth <= 0 || resizeHeight <= 0)
             throw new IllegalStateException("must call resize first");
         scaleMode = ScaleMode.CenterCrop;
@@ -370,9 +367,10 @@ public IonBitmapRequestBuilder centerCrop() {
 
     @Override
     public IonBitmapRequestBuilder centerInside() {
-        if (transforms != null && transforms.size() > 0)
+        if (hasTransforms()) {
             throw new IllegalStateException("Can't apply centerInside after transform has been called." +
             "centerInside is applied to the original resized bitmap.");
+        }
         if (resizeWidth <= 0 || resizeHeight <= 0)
             throw new IllegalStateException("must call resize first");
         scaleMode = ScaleMode.CenterInside;
@@ -382,9 +380,10 @@ public IonBitmapRequestBuilder centerInside() {
     @Override
     public IonBitmapRequestBuilder resize(int width, int height) {
         // TODO: prevent multiple calls to resize and friends?
-        if (transforms != null && transforms.size() > 0)
+        if (hasTransforms()) {
             throw new IllegalStateException("Can't apply resize after transform has been called." +
-                "resize is applied to the original bitmap.");
+            "resize is applied to the original bitmap.");
+        }
         if (deepZoom)
             throw new IllegalStateException("Can not resize with deepZoom.");
         resizeWidth = width;
@@ -430,10 +429,14 @@ public IonBitmapRequestBuilder deepZoom() {
         this.deepZoom = true;
         if (resizeWidth > 0 || resizeHeight > 0)
             throw new IllegalStateException("Can't deepZoom with resize.");
-        if (transforms != null && transforms.size() > 0)
+        if (hasTransforms())
             throw new IllegalStateException("Can't deepZoom with transforms.");
         resizeWidth = 0;
         resizeHeight = 0;
         return this;
     }
+
+    boolean hasTransforms() {
+        return transforms != null && transforms.size() > 0;
+    }
 }
diff --git a/ion/src/com/koushikdutta/ion/IonRequestBuilder.java b/ion/src/com/koushikdutta/ion/IonRequestBuilder.java
index a3eff833..e219429f 100644
--- a/ion/src/com/koushikdutta/ion/IonRequestBuilder.java
+++ b/ion/src/com/koushikdutta/ion/IonRequestBuilder.java
@@ -50,11 +50,14 @@
 import com.koushikdutta.async.stream.OutputStreamDataSink;
 import com.koushikdutta.ion.Loader.LoaderEmitter;
 import com.koushikdutta.ion.bitmap.BitmapInfo;
+import com.koushikdutta.ion.bitmap.LocallyCachedStatus;
 import com.koushikdutta.ion.builder.Builders;
 import com.koushikdutta.ion.builder.FutureBuilder;
 import com.koushikdutta.ion.builder.LoadBuilder;
 import com.koushikdutta.ion.future.ResponseFuture;
+import com.koushikdutta.ion.gson.GsonArrayParser;
 import com.koushikdutta.ion.gson.GsonBody;
+import com.koushikdutta.ion.gson.GsonObjectParser;
 import com.koushikdutta.ion.gson.GsonParser;
 import com.koushikdutta.ion.gson.GsonSerializer;
 import com.koushikdutta.ion.gson.PojoBody;
@@ -67,7 +70,6 @@
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.lang.ref.WeakReference;
-import java.net.URI;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
@@ -402,6 +404,15 @@ public void run() {
         RawHeaders headers;
         DataEmitter emitter;
 
+        public Response<T> getResponse(Exception e, T result) {
+            Response<T> response = new Response<T>();
+            response.headers = headers;
+            response.request = finalRequest;
+            response.result = result;
+            response.exception = e;
+            return response;
+        }
+
         @Override
         public Future<Response<T>> withResponse() {
             final SimpleFuture<Response<T>> ret = new SimpleFuture<Response<T>>();
@@ -409,12 +420,7 @@ public void run() {
                 @Override
                 public void onCompleted(Exception e, T result) {
                     if (emitter != null) {
-                        Response<T> response = new Response<T>();
-                        response.headers = headers;
-                        response.request = finalRequest;
-                        response.result = result;
-                        response.exception = e;
-                        ret.setComplete(response);
+                        ret.setComplete(getResponse(e, result));
                         return;
                     }
                     ret.setComplete(e, null);
@@ -635,12 +641,12 @@ public void onCompleted(Exception e, T result) {
 
     @Override
     public ResponseFuture<JsonObject> asJsonObject() {
-        return execute(new GsonParser<JsonObject>());
+        return execute(new GsonObjectParser());
     }
 
     @Override
     public ResponseFuture<JsonArray> asJsonArray() {
-        return execute(new GsonParser<JsonArray>());
+        return execute(new GsonArrayParser());
     }
 
     @Override
@@ -768,7 +774,7 @@ public IonRequestBuilder setMultipartParameters(Map<String, List<String>> params
     }
 
     @Override
-    public Builders.Any.M addMultipartParts(List<Part> parameters) {
+    public IonRequestBuilder addMultipartParts(Iterable<Part> parameters) {
         if (multipartBody == null) {
             multipartBody = new MultipartFormDataBody();
             setBody(multipartBody);
@@ -780,6 +786,29 @@ public IonRequestBuilder setMultipartParameters(Map<String, List<String>> params
         return this;
     }
 
+    @Override
+    public Builders.Any.M addMultipartParts(Part... parameters) {
+        if (multipartBody == null) {
+            multipartBody = new MultipartFormDataBody();
+            setBody(multipartBody);
+        }
+
+        for (Part part: parameters) {
+            multipartBody.addPart(part);
+        }
+        return this;
+    }
+
+    @Override
+    public IonRequestBuilder setMultipartContentType(String contentType) {
+        if (multipartBody == null) {
+            multipartBody = new MultipartFormDataBody();
+            setBody(multipartBody);
+        }
+        multipartBody.setContentType(contentType);
+        return this;
+    }
+
     @Override
     public IonBitmapRequestBuilder withBitmap() {
         return new IonBitmapRequestBuilder(this);
@@ -801,6 +830,11 @@ public BitmapInfo asCachedBitmap() {
         return new IonBitmapRequestBuilder(this).asCachedBitmap();
     }
 
+    @Override
+    public LocallyCachedStatus isLocallyCached() {
+        return new IonBitmapRequestBuilder(this).isLocallyCached();
+    }
+
     @Override
     public Future<Bitmap> asBitmap() {
         return new IonBitmapRequestBuilder(this).asBitmap();
diff --git a/ion/src/com/koushikdutta/ion/LoadBitmap.java b/ion/src/com/koushikdutta/ion/LoadBitmap.java
index 44c65bff..9d21b154 100644
--- a/ion/src/com/koushikdutta/ion/LoadBitmap.java
+++ b/ion/src/com/koushikdutta/ion/LoadBitmap.java
@@ -10,6 +10,7 @@
 import com.koushikdutta.async.ByteBufferList;
 import com.koushikdutta.async.future.FutureCallback;
 import com.koushikdutta.ion.bitmap.BitmapInfo;
+import com.koushikdutta.ion.bitmap.IonBitmapCache;
 import com.koushikdutta.ion.gif.GifAction;
 import com.koushikdutta.ion.gif.GifDecoder;
 
@@ -78,7 +79,7 @@ public boolean parseOk(boolean parseStatus, int frameIndex) {
                         }
                     }
                     else {
-                        Bitmap bitmap = ion.bitmapCache.loadBitmap(bb.array(), bb.arrayOffset() + bb.position(), bb.remaining(), options);
+                        Bitmap bitmap = IonBitmapCache.loadBitmap(bb.array(), bb.arrayOffset() + bb.position(), bb.remaining(), options);
                         if (bitmap == null)
                             throw new Exception("failed to load bitmap");
                         bitmaps = new Bitmap[] { bitmap };
diff --git a/ion/src/com/koushikdutta/ion/LoadBitmapRegion.java b/ion/src/com/koushikdutta/ion/LoadBitmapRegion.java
index 81bf6734..454999b4 100644
--- a/ion/src/com/koushikdutta/ion/LoadBitmapRegion.java
+++ b/ion/src/com/koushikdutta/ion/LoadBitmapRegion.java
@@ -6,6 +6,7 @@
 import android.graphics.Rect;
 
 import com.koushikdutta.ion.bitmap.BitmapInfo;
+import com.koushikdutta.ion.bitmap.IonBitmapCache;
 
 /**
  * Created by koush on 1/29/14.
@@ -18,7 +19,7 @@ public LoadBitmapRegion(final Ion ion, final String key, final BitmapRegionDecod
             @Override
             public void run() {
                 try {
-                    Bitmap bitmap = ion.bitmapCache.loadRegion(decoder, region, inSampleSize);
+                    Bitmap bitmap = IonBitmapCache.loadRegion(decoder, region, inSampleSize);
                     if (bitmap == null)
                         throw new Exception("failed to load bitmap region");
                     BitmapInfo info = new BitmapInfo(key, null, new Bitmap[] { bitmap }, new Point(bitmap.getWidth(), bitmap.getHeight()));
diff --git a/ion/src/com/koushikdutta/ion/TransformBitmap.java b/ion/src/com/koushikdutta/ion/TransformBitmap.java
index 2f449f24..519a2471 100644
--- a/ion/src/com/koushikdutta/ion/TransformBitmap.java
+++ b/ion/src/com/koushikdutta/ion/TransformBitmap.java
@@ -6,6 +6,7 @@
 import com.koushikdutta.async.future.FutureCallback;
 import com.koushikdutta.async.util.FileCache;
 import com.koushikdutta.ion.bitmap.BitmapInfo;
+import com.koushikdutta.ion.bitmap.IonBitmapCache;
 import com.koushikdutta.ion.bitmap.Transform;
 
 import java.io.File;
@@ -30,7 +31,7 @@ public void run() {
 
                 try {
                     File file = ion.responseCache.getFileCache().getFile(transformKey);
-                    Bitmap bitmap = ion.getBitmapCache().loadBitmap(file, null);
+                    Bitmap bitmap = IonBitmapCache.loadBitmap(file, null);
                     if (bitmap == null)
                         throw new Exception("Bitmap failed to load");
                     Point size = new Point(bitmap.getWidth(), bitmap.getHeight());
diff --git a/ion/src/com/koushikdutta/ion/bitmap/IonBitmapCache.java b/ion/src/com/koushikdutta/ion/bitmap/IonBitmapCache.java
index b9dfec29..fd48041d 100644
--- a/ion/src/com/koushikdutta/ion/bitmap/IonBitmapCache.java
+++ b/ion/src/com/koushikdutta/ion/bitmap/IonBitmapCache.java
@@ -11,6 +11,7 @@
 import android.graphics.Matrix;
 import android.graphics.Point;
 import android.graphics.Rect;
+import android.net.Uri;
 import android.os.Build;
 import android.os.Looper;
 import android.util.DisplayMetrics;
@@ -21,7 +22,10 @@
 import com.koushikdutta.ion.Ion;
 
 import java.io.File;
+import java.io.FileDescriptor;
 import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
 
 /**
  * Created by koush on 5/23/13.
@@ -117,13 +121,6 @@ private Point computeTarget(int minx, int miny) {
         return new Point(targetWidth, targetHeight);
     }
 
-    public BitmapFactory.Options prepareBitmapOptions(File file, int minx, int miny) {
-        BitmapFactory.Options o = new BitmapFactory.Options();
-        o.inJustDecodeBounds = true;
-        BitmapFactory.decodeFile(file.toString(), o);
-        return prepareBitmapOptions(o, minx, miny);
-    }
-
     private BitmapFactory.Options prepareBitmapOptions(BitmapFactory.Options o, int minx, int miny) {
         if (o.outWidth < 0 || o.outHeight < 0)
             return null;
@@ -137,6 +134,13 @@ private Point computeTarget(int minx, int miny) {
         return ret;
     }
 
+    public BitmapFactory.Options prepareBitmapOptions(File file, int minx, int miny) {
+        BitmapFactory.Options o = new BitmapFactory.Options();
+        o.inJustDecodeBounds = true;
+        BitmapFactory.decodeFile(file.toString(), o);
+        return prepareBitmapOptions(o, minx, miny);
+    }
+
     public BitmapFactory.Options prepareBitmapOptions(byte[] bytes, int offset, int length, int minx, int miny) {
         BitmapFactory.Options o = new BitmapFactory.Options();
         o.inJustDecodeBounds = true;
@@ -144,14 +148,23 @@ private Point computeTarget(int minx, int miny) {
         return prepareBitmapOptions(o, minx, miny);
     }
 
-    public Bitmap loadBitmap(byte[] bytes, int offset, int length, BitmapFactory.Options o) {
-        assert Thread.currentThread() != Looper.getMainLooper().getThread();
+    public BitmapFactory.Options prepareBitmapOptions(Resources res, int id, int minx, int miny) {
+        BitmapFactory.Options o = new BitmapFactory.Options();
+        o.inJustDecodeBounds = true;
+        BitmapFactory.decodeResource(res, id, o);
+        return prepareBitmapOptions(o, minx, miny);
+    }
 
-        Bitmap bitmap = BitmapFactory.decodeByteArray(bytes, offset, length, o);
+    public BitmapFactory.Options prepareBitmapOptions(InputStream in, int minx, int miny) {
+        BitmapFactory.Options o = new BitmapFactory.Options();
+        o.inJustDecodeBounds = true;
+        BitmapFactory.decodeStream(in, null, o);
+        return prepareBitmapOptions(o, minx, miny);
+    }
+
+    private static Bitmap getRotatedBitmap(Bitmap bitmap, int rotation) {
         if (bitmap == null)
             return null;
-
-        int rotation = Exif.getOrientation(bytes, offset, length);
         if (rotation == 0)
             return bitmap;
 
@@ -160,15 +173,64 @@ public Bitmap loadBitmap(byte[] bytes, int offset, int length, BitmapFactory.Opt
         return Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(), bitmap.getHeight(), matrix, true);
     }
 
+    public static Bitmap loadBitmap(byte[] bytes, int offset, int length, BitmapFactory.Options o) {
+        assert Thread.currentThread() != Looper.getMainLooper().getThread();
+
+        Bitmap bitmap = BitmapFactory.decodeByteArray(bytes, offset, length, o);
+        if (bitmap == null)
+            return null;
+        int rotation = Exif.getOrientation(bytes, offset, length);
+        return getRotatedBitmap(bitmap, rotation);
+    }
+
     @TargetApi(Build.VERSION_CODES.GINGERBREAD_MR1)
-    public Bitmap loadRegion(final BitmapRegionDecoder decoder, Rect sourceRect, int inSampleSize) {
+    public static Bitmap loadRegion(final BitmapRegionDecoder decoder, Rect sourceRect, int inSampleSize) {
         BitmapFactory.Options options = new BitmapFactory.Options();
         options.inSampleSize = inSampleSize;
         return decoder.decodeRegion(sourceRect, options);
     }
 
-    public Bitmap loadBitmap(File file, BitmapFactory.Options o) {
-//        stream = new BufferedInputStream(stream, 64 * 1024);
+    public static Bitmap loadBitmap(Resources res, int id, BitmapFactory.Options o) {
+        assert Thread.currentThread() != Looper.getMainLooper().getThread();
+
+        int rotation;
+        InputStream in = null;
+        try {
+            in = res.openRawResource(id);
+            byte[] bytes = new byte[50000];
+            int length = in.read(bytes);
+            rotation = Exif.getOrientation(bytes, 0, length);
+        }
+        catch (Exception e) {
+            rotation = 0;
+        }
+        StreamUtility.closeQuietly(in);
+
+        Bitmap bitmap = BitmapFactory.decodeResource(res, id, o);
+        return getRotatedBitmap(bitmap, rotation);
+    }
+
+    public static Bitmap loadBitmap(InputStream stream, BitmapFactory.Options o) throws IOException {
+        assert Thread.currentThread() != Looper.getMainLooper().getThread();
+
+        int rotation;
+        MarkableInputStream in = new MarkableInputStream(stream);
+        in.mark(50000);
+        try {
+            byte[] bytes = new byte[50000];
+            int length = in.read(bytes);
+            rotation = Exif.getOrientation(bytes, 0, length);
+        }
+        catch (Exception e) {
+            rotation = 0;
+        }
+        in.reset();
+
+        Bitmap bitmap = BitmapFactory.decodeStream(in, null, o);
+        return getRotatedBitmap(bitmap, rotation);
+    }
+
+    public static Bitmap loadBitmap(File file, BitmapFactory.Options o) {
         assert Thread.currentThread() != Looper.getMainLooper().getThread();
 
         int rotation;
@@ -185,15 +247,7 @@ public Bitmap loadBitmap(File file, BitmapFactory.Options o) {
         StreamUtility.closeQuietly(fin);
 
         Bitmap bitmap = BitmapFactory.decodeFile(file.toString(), o);
-        if (bitmap == null)
-            return null;
-
-        if (rotation == 0)
-            return bitmap;
-
-        Matrix matrix = new Matrix();
-        matrix.postRotate(rotation);
-        return Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(), bitmap.getHeight(), matrix, true);
+        return getRotatedBitmap(bitmap, rotation);
     }
 
     private static int getHeapSize(final Context context) {
diff --git a/ion/src/com/koushikdutta/ion/bitmap/LocallyCachedStatus.java b/ion/src/com/koushikdutta/ion/bitmap/LocallyCachedStatus.java
new file mode 100644
index 00000000..cee1e5ee
--- /dev/null
+++ b/ion/src/com/koushikdutta/ion/bitmap/LocallyCachedStatus.java
@@ -0,0 +1,10 @@
+package com.koushikdutta.ion.bitmap;
+
+/**
+ * Created by koush on 6/20/14.
+ */
+public enum LocallyCachedStatus {
+    CACHED,
+    NOT_CACHED,
+    MAYBE_CACHED
+}
diff --git a/ion/src/com/koushikdutta/ion/builder/BitmapFutureBuilder.java b/ion/src/com/koushikdutta/ion/builder/BitmapFutureBuilder.java
index 14f36e3f..e61cc905 100644
--- a/ion/src/com/koushikdutta/ion/builder/BitmapFutureBuilder.java
+++ b/ion/src/com/koushikdutta/ion/builder/BitmapFutureBuilder.java
@@ -4,6 +4,7 @@
 
 import com.koushikdutta.async.future.Future;
 import com.koushikdutta.ion.bitmap.BitmapInfo;
+import com.koushikdutta.ion.bitmap.LocallyCachedStatus;
 
 /**
 * Created by koush on 5/30/13.
@@ -16,8 +17,14 @@
     public Future<Bitmap> asBitmap();
 
     /**
-     * Attempt to immediately retrieve the cached Bitmap info
+     * Attempt to immediately retrieve the cached Bitmap info from the memory cache
      * @return
      */
     public BitmapInfo asCachedBitmap();
+
+    /**
+     * Check whether the Bitmap can be loaded from either the file or memory cache
+     * @return
+     */
+    public LocallyCachedStatus isLocallyCached();
 }
diff --git a/ion/src/com/koushikdutta/ion/builder/MultipartBodyBuilder.java b/ion/src/com/koushikdutta/ion/builder/MultipartBodyBuilder.java
index 561ef14f..4e959c86 100644
--- a/ion/src/com/koushikdutta/ion/builder/MultipartBodyBuilder.java
+++ b/ion/src/com/koushikdutta/ion/builder/MultipartBodyBuilder.java
@@ -52,5 +52,21 @@
      * @param parameters
      * @return
      */
-    public M addMultipartParts(List<Part> parameters);
+    public M addMultipartParts(Iterable<Part> parameters);
+
+    /**
+     * Specify multipart/form-data parameters to send to the HTTP server. If no HTTP method was explicitly
+     * provided in the load call, the default HTTP method, POST, is used.
+     * @param parameters
+     * @return
+     */
+    public M addMultipartParts(Part... parameters);
+
+    /**
+     * Specify the content type to use in this request. By default it is
+     * multipart/form-data
+     * @param contentType
+     * @return
+     */
+    public M setMultipartContentType(String contentType);
 }
diff --git a/ion/src/com/koushikdutta/ion/gson/GsonArrayParser.java b/ion/src/com/koushikdutta/ion/gson/GsonArrayParser.java
new file mode 100644
index 00000000..1779d019
--- /dev/null
+++ b/ion/src/com/koushikdutta/ion/gson/GsonArrayParser.java
@@ -0,0 +1,12 @@
+package com.koushikdutta.ion.gson;
+
+import com.google.gson.JsonArray;
+
+/**
+ * Created by koush on 6/23/14.
+ */
+public class GsonArrayParser extends GsonParser<JsonArray> {
+    public GsonArrayParser() {
+        super(JsonArray.class);
+    }
+}
diff --git a/ion/src/com/koushikdutta/ion/gson/GsonBody.java b/ion/src/com/koushikdutta/ion/gson/GsonBody.java
index 1727090a..8d7a46ab 100644
--- a/ion/src/com/koushikdutta/ion/gson/GsonBody.java
+++ b/ion/src/com/koushikdutta/ion/gson/GsonBody.java
@@ -25,13 +25,7 @@ public GsonBody(Gson gson, T json) {
 
     @Override
     public void parse(DataEmitter emitter, final CompletedCallback completed) {
-        new GsonParser<T>().parse(emitter).setCallback(new FutureCallback<T>() {
-            @Override
-            public void onCompleted(Exception e, T result) {
-                json = result;
-                completed.onCompleted(e);
-            }
-        });
+        throw new AssertionError("not implemented");
     }
 
     @Override
diff --git a/ion/src/com/koushikdutta/ion/gson/GsonObjectParser.java b/ion/src/com/koushikdutta/ion/gson/GsonObjectParser.java
new file mode 100644
index 00000000..ffc3f4f7
--- /dev/null
+++ b/ion/src/com/koushikdutta/ion/gson/GsonObjectParser.java
@@ -0,0 +1,12 @@
+package com.koushikdutta.ion.gson;
+
+import com.google.gson.JsonObject;
+
+/**
+ * Created by koush on 6/23/14.
+ */
+public class GsonObjectParser extends GsonParser<JsonObject> {
+    public GsonObjectParser() {
+        super(JsonObject.class);
+    }
+}
diff --git a/ion/src/com/koushikdutta/ion/gson/GsonParser.java b/ion/src/com/koushikdutta/ion/gson/GsonParser.java
index c51b8ba1..4b0fa0de 100644
--- a/ion/src/com/koushikdutta/ion/gson/GsonParser.java
+++ b/ion/src/com/koushikdutta/ion/gson/GsonParser.java
@@ -20,9 +20,12 @@
 /**
  * Created by koush on 5/27/13.
  */
-public class GsonParser<T extends JsonElement> implements AsyncParser<T> {
-    public GsonParser() {
+public abstract class GsonParser<T extends JsonElement> implements AsyncParser<T> {
+    Class<? extends JsonElement> clazz;
+    public GsonParser(Class<? extends T> clazz) {
+        this.clazz = clazz;
     }
+
     @Override
     public Future<T> parse(DataEmitter emitter) {
         return new ByteBufferListParser().parse(emitter)
@@ -30,10 +33,12 @@ public GsonParser() {
             @Override
             protected void transform(ByteBufferList result) throws Exception {
                 JsonParser parser = new JsonParser();
-                T parsed = (T)parser.parse(new JsonReader(new InputStreamReader(new ByteBufferListInputStream(result))));
+                JsonElement parsed = parser.parse(new JsonReader(new InputStreamReader(new ByteBufferListInputStream(result))));
                 if (parsed.isJsonNull() || parsed.isJsonPrimitive())
                     throw new JsonParseException("unable to parse json");
-                setComplete(null, parsed);
+                if (!clazz.isInstance(parsed))
+                    throw new ClassCastException(parsed.getClass().getCanonicalName() + " can not be casted to " + clazz.getCanonicalName());
+                setComplete(null, (T)parsed);
             }
         });
     }
diff --git a/ion/src/com/koushikdutta/ion/loader/AssetLoader.java b/ion/src/com/koushikdutta/ion/loader/AssetLoader.java
new file mode 100644
index 00000000..11aaf26a
--- /dev/null
+++ b/ion/src/com/koushikdutta/ion/loader/AssetLoader.java
@@ -0,0 +1,59 @@
+package com.koushikdutta.ion.loader;
+
+import android.content.Context;
+import android.net.Uri;
+
+import com.koushikdutta.async.DataEmitter;
+import com.koushikdutta.async.future.Future;
+import com.koushikdutta.async.future.FutureCallback;
+import com.koushikdutta.async.http.AsyncHttpRequest;
+import com.koushikdutta.async.stream.InputStreamDataEmitter;
+import com.koushikdutta.ion.Ion;
+import com.koushikdutta.ion.bitmap.BitmapInfo;
+
+import java.io.InputStream;
+
+/**
+ * Created by koush on 6/27/14.
+ */
+public class AssetLoader extends StreamLoader {
+    @Override
+    public Future<BitmapInfo> loadBitmap(final Context context, final Ion ion, final String key, final String uri, final int resizeWidth, final int resizeHeight, final boolean animateGif) {
+        if (!uri.startsWith("file://android_asset/"))
+            return null;
+
+        return super.loadBitmap(context, ion, key, uri, resizeWidth, resizeHeight, animateGif);
+    }
+
+    @Override
+    protected InputStream getInputStream(Context context, String uri) throws Exception {
+        return context.getAssets().open(Uri.parse(uri).getPath().substring(1));
+    }
+
+    @Override
+    public Future<DataEmitter> load(final Ion ion, final AsyncHttpRequest request, final FutureCallback<LoaderEmitter> callback) {
+        if (!request.getUri().getScheme().startsWith("file://android_asset/"))
+            return null;
+
+        final InputStreamDataEmitterFuture ret = new InputStreamDataEmitterFuture();
+        ion.getHttpClient().getServer().post(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    InputStream stream = ion.getContext().getContentResolver().openInputStream(Uri.parse(request.getUri().toString()));
+                    if (stream == null)
+                        throw new Exception("Unable to load content stream");
+                    int available = stream.available();
+                    InputStreamDataEmitter emitter = new InputStreamDataEmitter(ion.getHttpClient().getServer(), stream);
+                    ret.setComplete(emitter);
+                    callback.onCompleted(null, new LoaderEmitter(emitter, available, LoaderEmitter.LOADED_FROM_CACHE, null, null));
+                }
+                catch (Exception e) {
+                    ret.setComplete(e);
+                    callback.onCompleted(e, null);
+                }
+            }
+        });
+        return ret;
+    }
+}
diff --git a/ion/src/com/koushikdutta/ion/loader/ContentLoader.java b/ion/src/com/koushikdutta/ion/loader/ContentLoader.java
index 06354e14..270992f6 100644
--- a/ion/src/com/koushikdutta/ion/loader/ContentLoader.java
+++ b/ion/src/com/koushikdutta/ion/loader/ContentLoader.java
@@ -1,14 +1,14 @@
 package com.koushikdutta.ion.loader;
 
+import android.content.Context;
 import android.net.Uri;
+
 import com.koushikdutta.async.DataEmitter;
 import com.koushikdutta.async.future.Future;
 import com.koushikdutta.async.future.FutureCallback;
-import com.koushikdutta.async.future.SimpleFuture;
 import com.koushikdutta.async.http.AsyncHttpRequest;
 import com.koushikdutta.async.stream.InputStreamDataEmitter;
 import com.koushikdutta.ion.Ion;
-import com.koushikdutta.ion.Loader;
 import com.koushikdutta.ion.bitmap.BitmapInfo;
 
 import java.io.InputStream;
@@ -16,8 +16,18 @@
 /**
  * Created by koush on 5/22/13.
  */
-public class ContentLoader extends SimpleLoader {
-    private static final class InputStreamDataEmitterFuture extends SimpleFuture<DataEmitter> {
+public class ContentLoader extends StreamLoader {
+    @Override
+    public Future<BitmapInfo> loadBitmap(final Context context, final Ion ion, final String key, final String uri, final int resizeWidth, final int resizeHeight, final boolean animateGif) {
+        if (!uri.startsWith("content:/"))
+            return null;
+
+        return super.loadBitmap(context, ion, key, uri, resizeWidth, resizeHeight, animateGif);
+    }
+
+    @Override
+    protected InputStream getInputStream(Context context, String uri) throws Exception {
+        return context.getContentResolver().openInputStream(Uri.parse(uri));
     }
 
     @Override
diff --git a/ion/src/com/koushikdutta/ion/loader/FileLoader.java b/ion/src/com/koushikdutta/ion/loader/FileLoader.java
index 4741403a..6b2c9bb4 100644
--- a/ion/src/com/koushikdutta/ion/loader/FileLoader.java
+++ b/ion/src/com/koushikdutta/ion/loader/FileLoader.java
@@ -16,6 +16,7 @@
 import com.koushikdutta.ion.Ion;
 import com.koushikdutta.ion.Loader;
 import com.koushikdutta.ion.bitmap.BitmapInfo;
+import com.koushikdutta.ion.bitmap.IonBitmapCache;
 import com.koushikdutta.ion.gif.GifAction;
 import com.koushikdutta.ion.gif.GifDecoder;
 
@@ -27,7 +28,7 @@
 /**
  * Created by koush on 5/22/13.
  */
-public class FileLoader extends SimpleLoader {
+public class FileLoader extends StreamLoader {
     private static final class FileFuture extends SimpleFuture<DataEmitter> {
     }
 
@@ -53,38 +54,22 @@ public void run() {
                     if (options == null)
                         throw new Exception("BitmapFactory.Options failed to load");
                     Point size = new Point(options.outWidth, options.outHeight);
-                    Bitmap[] bitmaps;
-                    int[] delays;
+                    BitmapInfo info;
                     if (animateGif && TextUtils.equals("image/gif", options.outMimeType)) {
                         FileInputStream fin = new FileInputStream(file);
-                        GifDecoder decoder = new GifDecoder(fin, new GifAction() {
-                            @Override
-                            public boolean parseOk(boolean parseStatus, int frameIndex) {
-                                return animateGif;
-                            }
-                        });
-                        decoder.run();
-                        StreamUtility.closeQuietly(fin);
-                        if (decoder.getFrameCount() == 0)
-                            throw new Exception("failed to load gif");
-                        bitmaps = new Bitmap[decoder.getFrameCount()];
-                        delays = decoder.getDelays();
-                        for (int i = 0; i < decoder.getFrameCount(); i++) {
-                            Bitmap bitmap = decoder.getFrameImage(i);
-                            if (bitmap == null)
-                                throw new Exception("failed to load gif frame");
-                            bitmaps[i] = bitmap;
+                        try {
+                            info = loadGif(key, size, fin, options);
+                        }
+                        finally {
+                            StreamUtility.closeQuietly(fin);
                         }
                     }
                     else {
-                        Bitmap bitmap = ion.getBitmapCache().loadBitmap(file, options);
+                        Bitmap bitmap = IonBitmapCache.loadBitmap(file, options);
                         if (bitmap == null)
                             throw new Exception("Bitmap failed to load");
-                        bitmaps = new Bitmap[] { bitmap };
-                        delays = null;
+                        info = new BitmapInfo(key, options.outMimeType, new Bitmap[] { bitmap }, size);
                     }
-                    BitmapInfo info = new BitmapInfo(key, options.outMimeType, bitmaps, size);
-                    info.delays = delays;
                     info.loadedFrom =  Loader.LoaderEmitter.LOADED_FROM_CACHE;
                     ret.setComplete(info);
                 }
diff --git a/ion/src/com/koushikdutta/ion/loader/InputStreamDataEmitterFuture.java b/ion/src/com/koushikdutta/ion/loader/InputStreamDataEmitterFuture.java
new file mode 100644
index 00000000..eeb245ec
--- /dev/null
+++ b/ion/src/com/koushikdutta/ion/loader/InputStreamDataEmitterFuture.java
@@ -0,0 +1,7 @@
+package com.koushikdutta.ion.loader;
+
+import com.koushikdutta.async.DataEmitter;
+import com.koushikdutta.async.future.SimpleFuture;
+
+final class InputStreamDataEmitterFuture extends SimpleFuture<DataEmitter> {
+}
diff --git a/ion/src/com/koushikdutta/ion/loader/ResourceLoader.java b/ion/src/com/koushikdutta/ion/loader/ResourceLoader.java
new file mode 100644
index 00000000..f0752c8d
--- /dev/null
+++ b/ion/src/com/koushikdutta/ion/loader/ResourceLoader.java
@@ -0,0 +1,139 @@
+package com.koushikdutta.ion.loader;
+
+import android.content.Context;
+import android.content.pm.PackageManager;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.Point;
+import android.net.Uri;
+import android.text.TextUtils;
+
+import com.koushikdutta.async.DataEmitter;
+import com.koushikdutta.async.future.Future;
+import com.koushikdutta.async.future.FutureCallback;
+import com.koushikdutta.async.future.SimpleFuture;
+import com.koushikdutta.async.http.AsyncHttpRequest;
+import com.koushikdutta.async.stream.InputStreamDataEmitter;
+import com.koushikdutta.async.util.StreamUtility;
+import com.koushikdutta.ion.Ion;
+import com.koushikdutta.ion.Loader;
+import com.koushikdutta.ion.bitmap.BitmapInfo;
+import com.koushikdutta.ion.bitmap.IonBitmapCache;
+import com.koushikdutta.ion.gif.GifAction;
+import com.koushikdutta.ion.gif.GifDecoder;
+
+import java.io.FileInputStream;
+import java.io.InputStream;
+
+/**
+ * Created by koush on 6/20/14.
+ */
+public class ResourceLoader extends StreamLoader {
+    private static class Resource {
+        Resources res;
+        int id;
+    }
+
+    private static Resource lookupResource(Context context, String uri) throws Exception {
+        Uri u = Uri.parse(uri);
+        if (u.getPathSegments() == null)
+            throw new IllegalArgumentException("uri is not a valid resource uri");
+        String pkg = u.getAuthority();
+        Context ctx = context.createPackageContext(pkg, 0);
+        Resources res = ctx.getResources();
+        int id;
+        if (u.getPathSegments().size() == 1)
+            id = Integer.valueOf(u.getPathSegments().get(0));
+        else if (u.getPathSegments().size() == 2) {
+            String type = u.getPathSegments().get(0);
+            String name = u.getPathSegments().get(1);
+            id = res.getIdentifier(name, type, pkg);
+            if (id == 0)
+                throw new IllegalArgumentException("resource not found in given package");
+        }
+        else {
+            throw new IllegalArgumentException("uri is not a valid resource uri");
+        }
+        Resource ret = new Resource();
+        ret.res = res;
+        ret.id = id;
+        return ret;
+    }
+
+    @Override
+    public Future<BitmapInfo> loadBitmap(final Context context, final Ion ion, final String key, final String uri, final int resizeWidth, final int resizeHeight, final boolean animateGif) {
+        if (uri == null || !uri.startsWith("android.resource:/"))
+            return null;
+
+        final SimpleFuture<BitmapInfo> ret = new SimpleFuture<BitmapInfo>();
+
+//        Log.d("FileLoader", "Loading file bitmap " + uri + " " + resizeWidth + "," + resizeHeight);
+        Ion.getBitmapLoadExecutorService().execute(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    Resource res = lookupResource(context, uri);
+                    BitmapFactory.Options options = ion.getBitmapCache().prepareBitmapOptions(res.res, res.id, resizeWidth, resizeHeight);
+                    if (options == null)
+                        throw new Exception("BitmapFactory.Options failed to load");
+                    Point size = new Point(options.outWidth, options.outHeight);
+                    BitmapInfo info;
+                    if (animateGif && TextUtils.equals("image/gif", options.outMimeType)) {
+                        InputStream in = res.res.openRawResource(res.id);
+                        try {
+                            info = loadGif(key, size, in, options);
+                        }
+                        finally {
+                            StreamUtility.closeQuietly(in);
+                        }
+                    }
+                    else {
+                        Bitmap bitmap = IonBitmapCache.loadBitmap(res.res, res.id, options);
+                        if (bitmap == null)
+                            throw new Exception("Bitmap failed to load");
+                        info = new BitmapInfo(key, options.outMimeType, new Bitmap[] { bitmap }, size);
+                    }
+                    info.loadedFrom =  Loader.LoaderEmitter.LOADED_FROM_CACHE;
+                    ret.setComplete(info);
+                }
+                catch (OutOfMemoryError e) {
+                    ret.setComplete(new Exception(e), null);
+                }
+                catch (Exception e) {
+                    ret.setComplete(e);
+                }
+            }
+        });
+
+        return ret;
+    }
+
+    @Override
+    public Future<DataEmitter> load(final Ion ion, final AsyncHttpRequest request, final FutureCallback<LoaderEmitter> callback) {
+        if (!request.getUri().getScheme().startsWith("android.resource:/"))
+            return null;
+
+        final InputStreamDataEmitterFuture ret = new InputStreamDataEmitterFuture();
+        ion.getHttpClient().getServer().post(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    Resource res = lookupResource(ion.getContext(), request.getUri().toString());
+                    InputStream stream = res.res.openRawResource(res.id);
+                    if (stream == null)
+                        throw new Exception("Unable to load content stream");
+                    int available = stream.available();
+                    InputStreamDataEmitter emitter = new InputStreamDataEmitter(ion.getHttpClient().getServer(), stream);
+                    ret.setComplete(emitter);
+                    callback.onCompleted(null, new LoaderEmitter(emitter, available, LoaderEmitter.LOADED_FROM_CACHE, null, null));
+                }
+                catch (Exception e) {
+                    ret.setComplete(e);
+                    callback.onCompleted(e, null);
+                }
+            }
+        });
+        return ret;
+    }
+}
diff --git a/ion/src/com/koushikdutta/ion/loader/StreamLoader.java b/ion/src/com/koushikdutta/ion/loader/StreamLoader.java
new file mode 100644
index 00000000..e49fabd7
--- /dev/null
+++ b/ion/src/com/koushikdutta/ion/loader/StreamLoader.java
@@ -0,0 +1,98 @@
+package com.koushikdutta.ion.loader;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.Point;
+import android.net.Uri;
+import android.text.TextUtils;
+
+import com.koushikdutta.async.future.Future;
+import com.koushikdutta.async.future.SimpleFuture;
+import com.koushikdutta.async.util.StreamUtility;
+import com.koushikdutta.ion.Ion;
+import com.koushikdutta.ion.Loader;
+import com.koushikdutta.ion.bitmap.BitmapInfo;
+import com.koushikdutta.ion.bitmap.IonBitmapCache;
+import com.koushikdutta.ion.gif.GifAction;
+import com.koushikdutta.ion.gif.GifDecoder;
+
+import java.io.InputStream;
+
+/**
+ * Created by koush on 6/27/14.
+ */
+public class StreamLoader extends SimpleLoader {
+    protected BitmapInfo loadGif(String key, Point size, InputStream in, BitmapFactory.Options options) throws Exception {
+        GifDecoder decoder = new GifDecoder(in, new GifAction() {
+            @Override
+            public boolean parseOk(boolean parseStatus, int frameIndex) {
+                return true;
+            }
+        });
+        decoder.run();
+        StreamUtility.closeQuietly(in);
+        if (decoder.getFrameCount() == 0)
+            throw new Exception("failed to load gif");
+        Bitmap[] bitmaps = new Bitmap[decoder.getFrameCount()];
+        int[] delays = decoder.getDelays();
+        for (int i = 0; i < decoder.getFrameCount(); i++) {
+            Bitmap bitmap = decoder.getFrameImage(i);
+            if (bitmap == null)
+                throw new Exception("failed to load gif frame");
+            bitmaps[i] = bitmap;
+        }
+        BitmapInfo info = new BitmapInfo(key, options.outMimeType, bitmaps, size);
+        info.delays = delays;
+        return info;
+    }
+
+    protected InputStream getInputStream(Context context, String uri) throws Exception {
+        return null;
+    }
+
+    @Override
+    public Future<BitmapInfo> loadBitmap(final Context context, final Ion ion, final String key, final String uri, final int resizeWidth, final int resizeHeight, final boolean animateGif) {
+        final SimpleFuture<BitmapInfo> ret = new SimpleFuture<BitmapInfo>();
+
+//        Log.d("FileLoader", "Loading file bitmap " + uri + " " + resizeWidth + "," + resizeHeight);
+        Ion.getBitmapLoadExecutorService().execute(new Runnable() {
+            @Override
+            public void run() {
+                InputStream in = null;
+                try {
+                    in = getInputStream(context, uri);
+                    BitmapFactory.Options options = ion.getBitmapCache().prepareBitmapOptions(in, resizeWidth, resizeHeight);
+                    if (options == null)
+                        throw new Exception("BitmapFactory.Options failed to load");
+                    StreamUtility.closeQuietly(in);
+                    Point size = new Point(options.outWidth, options.outHeight);
+                    BitmapInfo info;
+                    in = getInputStream(context, uri);
+                    if (animateGif && TextUtils.equals("image/gif", options.outMimeType)) {
+                        info = loadGif(key, size, in, options);
+                    }
+                    else {
+                        Bitmap bitmap = IonBitmapCache.loadBitmap(in, options);
+                        if (bitmap == null)
+                            throw new Exception("Bitmap failed to load");
+                        info = new BitmapInfo(key, options.outMimeType, new Bitmap[] { bitmap }, size);
+                    }
+                    info.loadedFrom =  Loader.LoaderEmitter.LOADED_FROM_CACHE;
+                    ret.setComplete(info);
+                }
+                catch (OutOfMemoryError e) {
+                    ret.setComplete(new Exception(e), null);
+                }
+                catch (Exception e) {
+                    ret.setComplete(e);
+                }
+                finally {
+                    StreamUtility.closeQuietly(in);
+                }
+            }
+        });
+
+        return ret;
+    }
+}
