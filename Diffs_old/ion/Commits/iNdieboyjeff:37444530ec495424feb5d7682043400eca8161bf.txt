diff --git a/README.md b/README.md
index f93c5f01..58ee9755 100644
--- a/README.md
+++ b/README.md
@@ -362,14 +362,14 @@ Ion.with(getContext())
 <dependency>
    <groupId>com.koushikdutta.ion</groupId>
    <artifactId>ion</artifactId>
-   <version>1.1.5</version>
+   <version>1.2.0</version>
 </dependency>
 ```
 
 ##### Gradle
 ```groovy
 dependencies {
-   compile 'com.koushikdutta.ion:ion:1.1.5'
+   compile 'com.koushikdutta.ion:ion:1.2.0'
 }
 ````
 
diff --git a/ion-sample/src/com/koushikdutta/ion/sample/GallerySample.java b/ion-sample/src/com/koushikdutta/ion/sample/GallerySample.java
index 235fb968..c1a3807f 100644
--- a/ion-sample/src/com/koushikdutta/ion/sample/GallerySample.java
+++ b/ion-sample/src/com/koushikdutta/ion/sample/GallerySample.java
@@ -76,14 +76,21 @@ public void onCreate(Bundle savedInstanceState) {
     Cursor mediaCursor;
     public void loadMore() {
         if (mediaCursor == null) {
-            mediaCursor = getContentResolver().query(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, null, null, null, null);
+            mediaCursor = getContentResolver().query(MediaStore.Files.getContentUri("external"), null, null, null, null);
         }
 
         int loaded = 0;
         while (mediaCursor.moveToNext() && loaded < 10) {
+            // get the media type. ion can show images for both regular images AND video.
+            int mediaType = mediaCursor.getInt(mediaCursor.getColumnIndex(MediaStore.Files.FileColumns.MEDIA_TYPE));
+            if (mediaType != MediaStore.Files.FileColumns.MEDIA_TYPE_IMAGE
+                && mediaType != MediaStore.Files.FileColumns.MEDIA_TYPE_VIDEO) {
+                continue;
+            }
+
             loaded++;
 
-            String uri = mediaCursor.getString(mediaCursor.getColumnIndex(MediaStore.Images.ImageColumns.DATA));
+            String uri = mediaCursor.getString(mediaCursor.getColumnIndex(MediaStore.Files.FileColumns.DATA));
             File file = new File(uri);
             // turn this into a file uri if necessary/possible
             if (file.exists())
diff --git a/ion/src/com/koushikdutta/ion/BitmapToBitmapInfo.java b/ion/src/com/koushikdutta/ion/BitmapToBitmapInfo.java
index 72739cb7..28062b11 100644
--- a/ion/src/com/koushikdutta/ion/BitmapToBitmapInfo.java
+++ b/ion/src/com/koushikdutta/ion/BitmapToBitmapInfo.java
@@ -9,7 +9,9 @@
 import com.koushikdutta.async.http.libcore.DiskLruCache;
 import com.koushikdutta.ion.bitmap.BitmapInfo;
 import com.koushikdutta.ion.bitmap.Transform;
+import com.koushikdutta.ion.loader.FileLoader;
 
+import java.io.BufferedInputStream;
 import java.io.DataInputStream;
 import java.io.FileInputStream;
 import java.io.InputStream;
@@ -21,32 +23,37 @@
     ArrayList<Transform> transforms;
 
     public static void getBitmapSnapshot(final Ion ion, final String transformKey) {
-        ion.getServer().getExecutorService().execute(new Runnable() {
+        Ion.getBitmapLoadExecutorService().execute(new Runnable() {
             @Override
             public void run() {
-                final LoadBitmap callback = new LoadBitmap(ion, transformKey, true, -1, -1, null);
-
+                final BitmapCallback callback = new BitmapCallback(ion, transformKey, true);
                 try {
                     DiskLruCache.Snapshot snapshot = ion.responseCache.getDiskLruCache().get(transformKey);
                     try {
                         InputStream in = snapshot.getInputStream(0);
                         assert in instanceof FileInputStream;
-                        int available = in.available();
-                        ByteBuffer b = ByteBufferList.obtain(available);
-                        new DataInputStream(in).readFully(b.array(), 0, available);
-                        b.limit(available);
-                        callback.onCompleted(null, new ByteBufferList(b));
-                    }
-                    finally {
+                        Bitmap bitmap = ion.getBitmapCache().loadBitmap(new BufferedInputStream((FileInputStream)in, 1024 * 64), -1, -1);
+                        in.close();
+                        if (bitmap == null)
+                            throw new Exception("Bitmap failed to load");
+
+                        BitmapInfo info = new BitmapInfo();
+                        info.bitmaps = new Bitmap[] { bitmap };
+                        info.loadedFrom =  Loader.LoaderEmitter.LOADED_FROM_CACHE;
+                        info.key = transformKey;
+                        callback.report(null, info);
+                    } finally {
                         snapshot.close();
                     }
                 }
+                catch (OutOfMemoryError e) {
+                    callback.report(new Exception(e), null);
+                }
                 catch (Exception e) {
-                    callback.onCompleted(e, null);
+                    callback.report(e, null);
                     try {
                         ion.responseCache.getDiskLruCache().remove(transformKey);
-                    }
-                    catch (Exception ex) {
+                    } catch (Exception ex) {
                     }
                 }
             }
@@ -72,7 +79,7 @@ public void onCompleted(Exception e, final BitmapInfo result) {
             return;
         }
 
-        ion.getServer().getExecutorService().execute(new Runnable() {
+        Ion.getBitmapLoadExecutorService().execute(new Runnable() {
             @Override
             public void run() {
                 BitmapInfo info = new BitmapInfo();
@@ -87,7 +94,12 @@ public void run() {
                     info.loadedFrom = result.loadedFrom;
                     info.key = key;
                     report(null, info);
-                } catch (Exception e) {
+                }
+                catch (OutOfMemoryError e) {
+                    report(new Exception(e), null);
+                    return;
+                }
+                catch (Exception e) {
                     report(e, null);
                     return;
                 }
@@ -112,12 +124,10 @@ public void run() {
                         info.bitmaps[0].compress(format, 100, out);
                         out.close();
                         editor.commit();
-                    }
-                    catch (Exception ex) {
+                    } catch (Exception ex) {
                         editor.abort();
                     }
-                }
-                catch (Exception e) {
+                } catch (Exception e) {
                 }
             }
         });
diff --git a/ion/src/com/koushikdutta/ion/DiskLruCacheStore.java b/ion/src/com/koushikdutta/ion/DiskLruCacheStore.java
index 566b8508..f508a7a7 100644
--- a/ion/src/com/koushikdutta/ion/DiskLruCacheStore.java
+++ b/ion/src/com/koushikdutta/ion/DiskLruCacheStore.java
@@ -36,7 +36,7 @@
 
     private <T> Future<T> put(final String rawKey, final T value, final AsyncParser<T> parser) {
         final SimpleFuture<T> ret = new SimpleFuture<T>();
-        ion.getServer().getExecutorService().execute(new Runnable() {
+        Ion.getIoExecutorService().execute(new Runnable() {
             @Override
             public void run() {
                 final DiskLruCache.Editor editor;
@@ -132,8 +132,8 @@ public void onCompleted(Exception ex) {
     
     private <T> Future<T> get(final String rawKey, final AsyncParser<T> parser) {
         final SimpleFuture<T> ret = new SimpleFuture<T>();
-        
-        ion.getServer().getExecutorService().execute(new Runnable() {
+
+        Ion.getIoExecutorService().execute(new Runnable() {
             @Override
             public void run() {
                 try {
@@ -190,7 +190,7 @@ public void onCompleted(Exception e, T result) {
 
     public Future<String> remove(final String key) {
         final SimpleFuture<String> ret = new SimpleFuture<String>();
-        ion.getServer().getExecutorService().execute(new Runnable() {
+        Ion.getIoExecutorService().execute(new Runnable() {
             @Override
             public void run() {
                 try {
diff --git a/ion/src/com/koushikdutta/ion/Ion.java b/ion/src/com/koushikdutta/ion/Ion.java
index 41d8a524..0d1a22b4 100644
--- a/ion/src/com/koushikdutta/ion/Ion.java
+++ b/ion/src/com/koushikdutta/ion/Ion.java
@@ -46,7 +46,8 @@
 public class Ion {
     static final Handler mainHandler = new Handler(Looper.getMainLooper());
     static int availableProcessors = Runtime.getRuntime().availableProcessors();
-    static ExecutorService singleExecutorService  = availableProcessors > 2 ? null : Executors.newFixedThreadPool(1);
+    static ExecutorService ioExecutorService = Executors.newFixedThreadPool(4);
+    static ExecutorService bitmapExecutorService  = availableProcessors > 2 ? Executors.newFixedThreadPool(availableProcessors - 1) : Executors.newFixedThreadPool(1);
     static HashMap<String, Ion> instances = new HashMap<String, Ion>();
 
     /**
@@ -166,13 +167,12 @@ private Ion(Context context, String name) {
                 .addLoader(fileLoader = new FileLoader());
     }
 
-    // todo: make this static by moving the server's executor service to static
-    public ExecutorService getBitmapLoadExecutorService() {
-        ExecutorService executorService = singleExecutorService;
-        if (executorService == null) {
-            executorService = getServer().getExecutorService();
-        }
-        return executorService;
+    public static ExecutorService getBitmapLoadExecutorService() {
+        return bitmapExecutorService;
+    }
+
+    public static ExecutorService getIoExecutorService() {
+        return ioExecutorService;
     }
 
     /**
diff --git a/ion/src/com/koushikdutta/ion/IonBitmapRequestBuilder.java b/ion/src/com/koushikdutta/ion/IonBitmapRequestBuilder.java
index 62883c30..490b1073 100644
--- a/ion/src/com/koushikdutta/ion/IonBitmapRequestBuilder.java
+++ b/ion/src/com/koushikdutta/ion/IonBitmapRequestBuilder.java
@@ -80,7 +80,7 @@ public IonBitmapRequestBuilder transform(Transform transform) {
 
     boolean fastLoad(final String downloadKey, boolean put) {
         for (Loader loader: ion.configure().getLoaders()) {
-            Future<BitmapInfo> future = loader.loadBitmap(ion, builder.uri);
+            Future<BitmapInfo> future = loader.loadBitmap(ion, builder.uri, resizeWidth, resizeHeight);
             if (future != null) {
                 final BitmapCallback callback = new BitmapCallback(ion, downloadKey, put);
                 future.setCallback(new FutureCallback<BitmapInfo>() {
diff --git a/ion/src/com/koushikdutta/ion/IonRequestBuilder.java b/ion/src/com/koushikdutta/ion/IonRequestBuilder.java
index 75408ac8..dbdf78fc 100644
--- a/ion/src/com/koushikdutta/ion/IonRequestBuilder.java
+++ b/ion/src/com/koushikdutta/ion/IonRequestBuilder.java
@@ -617,12 +617,12 @@ public void onCompleted(Exception e, T result) {
 
     @Override
     public <F extends OutputStream> ResponseFuture<F> write(F outputStream, boolean close) {
-        return execute(new OutputStreamDataSink(ion.getServer(), outputStream, false), close, outputStream);
+        return execute(new OutputStreamDataSink(ion.getServer(), outputStream), close, outputStream);
     }
 
     @Override
     public <F extends OutputStream> ResponseFuture<F> write(F outputStream) {
-        return execute(new OutputStreamDataSink(ion.getServer(), outputStream, false), true, outputStream);
+        return execute(new OutputStreamDataSink(ion.getServer(), outputStream), true, outputStream);
     }
 
     @Override
diff --git a/ion/src/com/koushikdutta/ion/LoadBitmap.java b/ion/src/com/koushikdutta/ion/LoadBitmap.java
index 8d5323d1..7dbe9f67 100644
--- a/ion/src/com/koushikdutta/ion/LoadBitmap.java
+++ b/ion/src/com/koushikdutta/ion/LoadBitmap.java
@@ -54,9 +54,7 @@ public void onCompleted(Exception e, final ByteBufferList result) {
             return;
         }
 
-        ExecutorService executorService = ion.getBitmapLoadExecutorService();
-
-        executorService.execute(new Runnable() {
+        Ion.getBitmapLoadExecutorService().execute(new Runnable() {
             @Override
             public void run() {
                 ByteBuffer bb = result.getAll();
@@ -96,7 +94,11 @@ public boolean parseOk(boolean parseStatus, int frameIndex) {
                         info.loadedFrom = Loader.LoaderEmitter.LOADED_FROM_CACHE;
 
                     report(null, info);
-                } catch (Exception e) {
+                }
+                catch (OutOfMemoryError e) {
+                    report(new Exception(e), null);
+                }
+                catch (Exception e) {
                     report(e, null);
                 }
                 finally {
diff --git a/ion/src/com/koushikdutta/ion/LoadBitmapStream.java b/ion/src/com/koushikdutta/ion/LoadBitmapStream.java
index 26fcc66e..a8994e13 100644
--- a/ion/src/com/koushikdutta/ion/LoadBitmapStream.java
+++ b/ion/src/com/koushikdutta/ion/LoadBitmapStream.java
@@ -43,7 +43,7 @@ public void onCompleted(Exception e, final InputStream result) {
             return;
         }
 
-        ion.getServer().getExecutorService().execute(new Runnable() {
+        Ion.getBitmapLoadExecutorService().execute(new Runnable() {
             @Override
             public void run() {
                 loadInputStream(result);
diff --git a/ion/src/com/koushikdutta/ion/Loader.java b/ion/src/com/koushikdutta/ion/Loader.java
index 655a3018..98da1c84 100644
--- a/ion/src/com/koushikdutta/ion/Loader.java
+++ b/ion/src/com/koushikdutta/ion/Loader.java
@@ -1,7 +1,5 @@
 package com.koushikdutta.ion;
 
-import android.graphics.Bitmap;
-
 import com.koushikdutta.async.DataEmitter;
 import com.koushikdutta.async.future.Future;
 import com.koushikdutta.async.future.FutureCallback;
@@ -59,5 +57,5 @@ public AsyncHttpRequest getRequest() {
     // otherwise it returns null, and Ion continues to the next loader.
     public Future<DataEmitter> load(Ion ion, AsyncHttpRequest request, FutureCallback<LoaderEmitter> callback);
 
-    public Future<BitmapInfo> loadBitmap(Ion ion, String uri);
+    public Future<BitmapInfo> loadBitmap(Ion ion, String uri, int resizeWidth, int resizeHeight);
 }
diff --git a/ion/src/com/koushikdutta/ion/bitmap/BitmapInfo.java b/ion/src/com/koushikdutta/ion/bitmap/BitmapInfo.java
index 088028ab..c0eb8ac4 100644
--- a/ion/src/com/koushikdutta/ion/bitmap/BitmapInfo.java
+++ b/ion/src/com/koushikdutta/ion/bitmap/BitmapInfo.java
@@ -15,7 +15,6 @@
     public Bitmap[] bitmaps;
     public int[] delays;
     public Exception exception;
-    public WeakReference<Bitmap> bitmapRef;
 
     public int sizeOf() {
         if (bitmaps == null)
diff --git a/ion/src/com/koushikdutta/ion/bitmap/IonBitmapCache.java b/ion/src/com/koushikdutta/ion/bitmap/IonBitmapCache.java
index 76f4b76f..d18bcf84 100644
--- a/ion/src/com/koushikdutta/ion/bitmap/IonBitmapCache.java
+++ b/ion/src/com/koushikdutta/ion/bitmap/IonBitmapCache.java
@@ -6,9 +6,8 @@
 import android.content.res.Resources;
 import android.graphics.Bitmap;
 import android.graphics.BitmapFactory;
-import android.graphics.Canvas;
 import android.graphics.Matrix;
-import android.graphics.Paint;
+import android.graphics.Point;
 import android.os.Looper;
 import android.util.DisplayMetrics;
 import android.util.Log;
@@ -50,7 +49,11 @@ public IonBitmapCache(Ion ion) {
     }
 
     public BitmapInfo remove(String key) {
-        return cache.remove(key);
+        return cache.removeBitmapInfo(key);
+    }
+
+    public void clear() {
+        cache.evictAllBitmapInfo();
     }
 
     public void put(BitmapInfo info) {
@@ -65,31 +68,16 @@ public BitmapInfo get(String key) {
             return null;
 
         // see if this thing has an immediate cache hit
-        BitmapInfo ret = cache.get(key);
+        BitmapInfo ret = cache.getBitmapInfo(key);
         if (ret == null || ret.bitmaps != null)
             return ret;
 
-        // see if the the bitmap got evicted and put into a weak ref
-        if (ret.bitmapRef != null) {
-            Bitmap bitmap = ret.bitmapRef.get();
-            // see if we successfully repopulated from the weak ref
-            if (ret.bitmaps != null) {
-                cache.remove(key);
-                ret.bitmaps = new Bitmap[] { bitmap };
-                ret.bitmapRef = null;
-                cache.put(key, ret);
-                System.out.println("===== SUCCESSFULLY GRABBED FROM WEAK REF CACHE! ====");
-                return ret;
-            }
-            // ok, fall through and toss this, it's useless.
-        }
-        else {
-            // if this bitmap load previously errored out, see if it is time to retry
-            // the fetch. connectivity error, server failure, etc, shouldn't be
-            // cached indefinitely...
-            if (ret.loadTime + errorCacheDuration > System.currentTimeMillis())
-                return ret;
-        }
+        // if this bitmap load previously errored out, see if it is time to retry
+        // the fetch. connectivity error, server failure, etc, shouldn't be
+        // cached indefinitely...
+        if (ret.loadTime + errorCacheDuration > System.currentTimeMillis())
+            return ret;
+
         cache.remove(key);
         return null;
     }
@@ -99,8 +87,7 @@ public void dump() {
         Log.i("IonBitmapCache", "freeMemory: " + Runtime.getRuntime().freeMemory());
     }
 
-    public Bitmap loadBitmap(byte[] bytes, int offset, int length, int minx, int miny) {
-        assert Thread.currentThread() != Looper.getMainLooper().getThread();
+    private Point computeTarget(int minx, int miny) {
         int targetWidth = minx;
         int targetHeight = miny;
         if (targetWidth == 0)
@@ -111,19 +98,28 @@ public Bitmap loadBitmap(byte[] bytes, int offset, int length, int minx, int min
             targetHeight = metrics.heightPixels;
         if (targetHeight <= 0)
             targetHeight = Integer.MAX_VALUE;
+        return new Point(targetWidth, targetHeight);
+    }
+
+    public Bitmap loadBitmap(byte[] bytes, int offset, int length, int minx, int miny) {
+        assert Thread.currentThread() != Looper.getMainLooper().getThread();
+        Point target = computeTarget(minx, miny);
 
         BitmapFactory.Options o = null;
-        if (targetWidth != Integer.MAX_VALUE || targetHeight != Integer.MAX_VALUE) {
+        if (target.x != Integer.MAX_VALUE || target.y != Integer.MAX_VALUE) {
             o = new BitmapFactory.Options();
             o.inJustDecodeBounds = true;
             BitmapFactory.decodeByteArray(bytes, offset, length, o);
             if (o.outWidth < 0 || o.outHeight < 0)
                 return null;
-            int scale = Math.max(o.outWidth / targetWidth, o.outHeight / targetHeight);
+            int scale = Math.max(o.outWidth / target.x, o.outHeight / target.y);
             o = new BitmapFactory.Options();
             o.inSampleSize = scale;
         }
+
         Bitmap bitmap = BitmapFactory.decodeByteArray(bytes, offset, length, o);
+        if (bitmap == null)
+            return null;
 
         int rotation = Exif.getOrientation(bytes, offset, length);
         if (rotation == 0)
@@ -138,19 +134,22 @@ public Bitmap loadBitmap(InputStream stream, int minx, int miny) {
         if (!stream.markSupported())
             stream = new MarkableInputStream(stream);
         assert Thread.currentThread() != Looper.getMainLooper().getThread();
-        int targetWidth = minx;
-        int targetHeight = miny;
-        if (targetWidth == 0)
-            targetWidth = metrics.widthPixels;
-        if (targetWidth <= 0)
-            targetWidth = Integer.MAX_VALUE;
-        if (targetHeight == 0)
-            targetHeight = metrics.heightPixels;
-        if (targetHeight <= 0)
-            targetHeight = Integer.MAX_VALUE;
+        Point target = computeTarget(minx, miny);
+
+        int rotation;
+        try {
+            byte[] bytes = new byte[50000];
+            stream.mark(Integer.MAX_VALUE);
+            int length = stream.read(bytes);
+            rotation = Exif.getOrientation(bytes, 0, length);
+            stream.reset();
+        }
+        catch (Exception e) {
+            rotation = 0;
+        }
 
         BitmapFactory.Options o = null;
-        if (targetWidth != Integer.MAX_VALUE || targetHeight != Integer.MAX_VALUE) {
+        if (target.x != Integer.MAX_VALUE || target.y != Integer.MAX_VALUE) {
             o = new BitmapFactory.Options();
             o.inJustDecodeBounds = true;
             stream.mark(Integer.MAX_VALUE);
@@ -163,11 +162,21 @@ public Bitmap loadBitmap(InputStream stream, int minx, int miny) {
             catch (Exception e) {
                 return null;
             }
-            int scale = Math.max(o.outWidth / targetWidth, o.outHeight / targetHeight);
+            int scale = Math.max(o.outWidth / target.x, o.outHeight / target.y);
             o = new BitmapFactory.Options();
             o.inSampleSize = scale;
         }
-        return BitmapFactory.decodeStream(stream, null, o);
+
+        Bitmap bitmap = BitmapFactory.decodeStream(stream, null, o);
+        if (bitmap == null)
+            return null;
+
+        if (rotation == 0)
+            return bitmap;
+
+        Matrix matrix = new Matrix();
+        matrix.postRotate(rotation);
+        return Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(), bitmap.getHeight(), matrix, true);
     }
 
     private static int getHeapSize(final Context context) {
diff --git a/ion/src/com/koushikdutta/ion/bitmap/LruBitmapCache.java b/ion/src/com/koushikdutta/ion/bitmap/LruBitmapCache.java
index 3b804341..8213e32c 100644
--- a/ion/src/com/koushikdutta/ion/bitmap/LruBitmapCache.java
+++ b/ion/src/com/koushikdutta/ion/bitmap/LruBitmapCache.java
@@ -1,10 +1,8 @@
 package com.koushikdutta.ion.bitmap;
 
-import android.graphics.Bitmap;
-
-import java.lang.ref.WeakReference;
-
 class LruBitmapCache extends LruCache<String, BitmapInfo> {
+    private SoftReferenceHashtable<String, BitmapInfo> soft = new SoftReferenceHashtable<String, BitmapInfo>();
+
     public LruBitmapCache(int maxSize) {
         super(maxSize);
     }
@@ -14,32 +12,37 @@ protected int sizeOf(String key, BitmapInfo info) {
         return info.sizeOf();
     }
 
+    public BitmapInfo getBitmapInfo(String key) {
+        BitmapInfo ret = get(key);
+        if (ret != null)
+            return ret;
+
+        ret = soft.remove(key);
+        if (ret != null)
+            put(key, ret);
+
+        return ret;
+    }
+
+    public BitmapInfo removeBitmapInfo(String key) {
+        BitmapInfo i1 = soft.remove(key);
+        BitmapInfo i2 = remove(key);
+        if (i2 != null)
+            return i2;
+        return i1;
+    }
+
+    public void evictAllBitmapInfo() {
+        evictAll();
+        soft.clear();
+    }
+
     @Override
     protected void entryRemoved(boolean evicted, String key, BitmapInfo oldValue, BitmapInfo newValue) {
         super.entryRemoved(evicted, key, oldValue, newValue);
 
-        // this shit is broken
-        if (true)
-            return;
-
-        // on eviction, put the bitmaps into a weak ref
-        if (!evicted)
-            return;
-
-        // toss the oldValue into a weak ref, and play with that.
-        if (oldValue == null)
-            return;
-        if (oldValue.bitmaps == null)
-            return;
-        // don't try to weak ref on gifs, because only one bitmap
-        // ref total will be held.
-        if (oldValue.bitmaps.length > 1)
-            return;
-
-        oldValue.bitmapRef = new WeakReference<Bitmap>(oldValue.bitmaps[0]);
-        oldValue.bitmaps = null;
-        put(key, oldValue);
+        // on eviction, put the bitmaps into the soft ref table
+        if (evicted)
+            soft.put(key, oldValue);
     }
-
-
 }
diff --git a/ion/src/com/koushikdutta/ion/bitmap/MarkableInputStream.java b/ion/src/com/koushikdutta/ion/bitmap/MarkableInputStream.java
index ce4d042d..284a7808 100644
--- a/ion/src/com/koushikdutta/ion/bitmap/MarkableInputStream.java
+++ b/ion/src/com/koushikdutta/ion/bitmap/MarkableInputStream.java
@@ -102,6 +102,13 @@ public void reset(long token) throws IOException {
     private void skip(long current, long target) throws IOException {
         while (current < target) {
             long skipped = in.skip(target - current);
+            if (skipped == 0) {
+                if (read() == -1) {
+                    break; // EOF
+                } else {
+                    skipped = 1;
+                }
+            }
             current += skipped;
         }
     }
diff --git a/ion/src/com/koushikdutta/ion/bitmap/SoftReferenceHashtable.java b/ion/src/com/koushikdutta/ion/bitmap/SoftReferenceHashtable.java
new file mode 100644
index 00000000..6d8c855d
--- /dev/null
+++ b/ion/src/com/koushikdutta/ion/bitmap/SoftReferenceHashtable.java
@@ -0,0 +1,36 @@
+package com.koushikdutta.ion.bitmap;
+
+import java.lang.ref.SoftReference;
+import java.util.Hashtable;
+
+public class SoftReferenceHashtable<K,V> {
+    Hashtable<K, SoftReference<V>> mTable = new Hashtable<K, SoftReference<V>>();
+
+    public V put(K key, V value) {
+        SoftReference<V> old = mTable.put(key, new SoftReference<V>(value));
+        if (old == null)
+            return null;
+        return old.get();
+    }
+
+    public V get(K key) {
+        SoftReference<V> val = mTable.get(key);
+        if (val == null)
+            return null;
+        V ret = val.get();
+        if (ret == null)
+            mTable.remove(key);
+        return ret;
+    }
+
+    public V remove(K k) {
+        SoftReference<V> v = mTable.remove(k);
+        if (v == null)
+            return null;
+        return v.get();
+    }
+
+    public void clear() {
+        mTable.clear();
+    }
+}
\ No newline at end of file
diff --git a/ion/src/com/koushikdutta/ion/loader/ContentLoader.java b/ion/src/com/koushikdutta/ion/loader/ContentLoader.java
index 9ebea232..06354e14 100644
--- a/ion/src/com/koushikdutta/ion/loader/ContentLoader.java
+++ b/ion/src/com/koushikdutta/ion/loader/ContentLoader.java
@@ -16,20 +16,10 @@
 /**
  * Created by koush on 5/22/13.
  */
-public class ContentLoader implements Loader {
+public class ContentLoader extends SimpleLoader {
     private static final class InputStreamDataEmitterFuture extends SimpleFuture<DataEmitter> {
     }
 
-    @Override
-    public Future<BitmapInfo> loadBitmap(Ion ion, final String uri) {
-        return null;
-    }
-
-    @Override
-    public Future<InputStream> load(final Ion ion, final AsyncHttpRequest request) {
-        return null;
-    }
-
     @Override
     public Future<DataEmitter> load(final Ion ion, final AsyncHttpRequest request, final FutureCallback<LoaderEmitter> callback) {
         if (!request.getUri().getScheme().startsWith("content"))
diff --git a/ion/src/com/koushikdutta/ion/loader/FileLoader.java b/ion/src/com/koushikdutta/ion/loader/FileLoader.java
index 904120c0..480f5259 100644
--- a/ion/src/com/koushikdutta/ion/loader/FileLoader.java
+++ b/ion/src/com/koushikdutta/ion/loader/FileLoader.java
@@ -1,6 +1,6 @@
 package com.koushikdutta.ion.loader;
 
-import android.net.Uri;
+import android.graphics.Bitmap;
 
 import com.koushikdutta.async.DataEmitter;
 import com.koushikdutta.async.FileDataEmitter;
@@ -12,20 +12,51 @@
 import com.koushikdutta.ion.Loader;
 import com.koushikdutta.ion.bitmap.BitmapInfo;
 
+import java.io.BufferedInputStream;
 import java.io.File;
 import java.io.FileInputStream;
+import java.io.IOException;
 import java.io.InputStream;
+import java.net.URI;
 
 /**
  * Created by koush on 5/22/13.
  */
-public class FileLoader implements Loader {
+public class FileLoader extends SimpleLoader {
     private static final class FileFuture extends SimpleFuture<DataEmitter> {
     }
 
     @Override
-    public Future<BitmapInfo> loadBitmap(Ion ion, final String uri) {
-        return null;
+    public Future<BitmapInfo> loadBitmap(final Ion ion, final String uri, final int resizeWidth, final int resizeHeight) {
+        if (uri == null || !uri.startsWith("file:/"))
+            return null;
+
+        final SimpleFuture<BitmapInfo> ret = new SimpleFuture<BitmapInfo>();
+
+        Ion.getBitmapLoadExecutorService().execute(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    FileInputStream fin = new FileInputStream(new File(URI.create(uri)));
+                    Bitmap bitmap = ion.getBitmapCache().loadBitmap(new BufferedInputStream(fin, 1024 * 64), resizeWidth, resizeHeight);
+                    if (bitmap == null)
+                        throw new Exception("Bitmap failed to load");
+                    BitmapInfo info = new BitmapInfo();
+                    info.bitmaps = new Bitmap[] { bitmap };
+                    info.loadedFrom =  Loader.LoaderEmitter.LOADED_FROM_CACHE;
+                    fin.close();
+                    ret.setComplete(info);
+                }
+                catch (OutOfMemoryError e) {
+                    ret.setComplete(new Exception(e), null);
+                }
+                catch (Exception e) {
+                    ret.setComplete(e);
+                }
+            }
+        });
+
+        return ret;
     }
 
     @Override
@@ -33,14 +64,13 @@
         if (!request.getUri().getScheme().startsWith("file"))
             return null;
         final SimpleFuture<InputStream> ret = new SimpleFuture<InputStream>();
-        ion.getServer().getExecutorService().execute(new Runnable() {
+        Ion.getIoExecutorService().execute(new Runnable() {
             @Override
             public void run() {
                 try {
                     InputStream stream = new FileInputStream(new File(request.getUri()));
                     ret.setComplete(stream);
-                }
-                catch (Exception e) {
+                } catch (Exception e) {
                     ret.setComplete(e);
                 }
             }
diff --git a/ion/src/com/koushikdutta/ion/loader/HttpLoader.java b/ion/src/com/koushikdutta/ion/loader/HttpLoader.java
index 8ea2d22c..0d291d66 100644
--- a/ion/src/com/koushikdutta/ion/loader/HttpLoader.java
+++ b/ion/src/com/koushikdutta/ion/loader/HttpLoader.java
@@ -18,17 +18,7 @@
 /**
  * Created by koush on 5/22/13.
  */
-public class HttpLoader implements Loader {
-    @Override
-    public Future<BitmapInfo> loadBitmap(Ion ion, final String uri) {
-        return null;
-    }
-
-    @Override
-    public Future<InputStream> load(Ion ion, AsyncHttpRequest request) {
-        return null;
-    }
-
+public class HttpLoader extends SimpleLoader {
     @SuppressWarnings("unchecked")
     @Override
     public Future<DataEmitter> load(Ion ion, AsyncHttpRequest request, final FutureCallback<LoaderEmitter> callback) {
diff --git a/ion/src/com/koushikdutta/ion/loader/MediaFile.java b/ion/src/com/koushikdutta/ion/loader/MediaFile.java
index 2cdbcaa7..b8a96832 100644
--- a/ion/src/com/koushikdutta/ion/loader/MediaFile.java
+++ b/ion/src/com/koushikdutta/ion/loader/MediaFile.java
@@ -17,8 +17,6 @@
 
 package com.koushikdutta.ion.loader;
 
-import android.mtp.MtpConstants;
-
 import java.util.HashMap;
 import java.util.Locale;
 
diff --git a/ion/src/com/koushikdutta/ion/loader/MtpConstants.java b/ion/src/com/koushikdutta/ion/loader/MtpConstants.java
new file mode 100644
index 00000000..6aaf9f96
--- /dev/null
+++ b/ion/src/com/koushikdutta/ion/loader/MtpConstants.java
@@ -0,0 +1,578 @@
+package com.koushikdutta.ion.loader;
+
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+/**
+ * A class containing constants in the MTP and PTP specifications.
+ */
+public final class MtpConstants {
+
+    // MTP Data Types
+    /** @hide */
+    public static final int TYPE_UNDEFINED = 0x0000;
+    /** @hide */
+    public static final int TYPE_INT8 = 0x0001;
+    /** @hide */
+    public static final int TYPE_UINT8 = 0x0002;
+    /** @hide */
+    public static final int TYPE_INT16 = 0x0003;
+    /** @hide */
+    public static final int TYPE_UINT16 = 0x0004;
+    /** @hide */
+    public static final int TYPE_INT32 = 0x0005;
+    /** @hide */
+    public static final int TYPE_UINT32 = 0x0006;
+    /** @hide */
+    public static final int TYPE_INT64 = 0x0007;
+    /** @hide */
+    public static final int TYPE_UINT64 = 0x0008;
+    /** @hide */
+    public static final int TYPE_INT128 = 0x0009;
+    /** @hide */
+    public static final int TYPE_UINT128 = 0x000A;
+    /** @hide */
+    public static final int TYPE_AINT8 = 0x4001;
+    /** @hide */
+    public static final int TYPE_AUINT8 = 0x4002;
+    /** @hide */
+    public static final int TYPE_AINT16 = 0x4003;
+    /** @hide */
+    public static final int TYPE_AUINT16 = 0x4004;
+    /** @hide */
+    public static final int TYPE_AINT32 = 0x4005;
+    /** @hide */
+    public static final int TYPE_AUINT32 = 0x4006;
+    /** @hide */
+    public static final int TYPE_AINT64 = 0x4007;
+    /** @hide */
+    public static final int TYPE_AUINT64 = 0x4008;
+    /** @hide */
+    public static final int TYPE_AINT128 = 0x4009;
+    /** @hide */
+    public static final int TYPE_AUINT128 = 0x400A;
+    /** @hide */
+    public static final int TYPE_STR = 0xFFFF;
+
+    // MTP Response Codes
+    /** @hide */
+    public static final int RESPONSE_UNDEFINED = 0x2000;
+    /** @hide */
+    public static final int RESPONSE_OK = 0x2001;
+    /** @hide */
+    public static final int RESPONSE_GENERAL_ERROR = 0x2002;
+    /** @hide */
+    public static final int RESPONSE_SESSION_NOT_OPEN = 0x2003;
+    /** @hide */
+    public static final int RESPONSE_INVALID_TRANSACTION_ID = 0x2004;
+    /** @hide */
+    public static final int RESPONSE_OPERATION_NOT_SUPPORTED = 0x2005;
+    /** @hide */
+    public static final int RESPONSE_PARAMETER_NOT_SUPPORTED = 0x2006;
+    /** @hide */
+    public static final int RESPONSE_INCOMPLETE_TRANSFER = 0x2007;
+    /** @hide */
+    public static final int RESPONSE_INVALID_STORAGE_ID = 0x2008;
+    /** @hide */
+    public static final int RESPONSE_INVALID_OBJECT_HANDLE = 0x2009;
+    /** @hide */
+    public static final int RESPONSE_DEVICE_PROP_NOT_SUPPORTED = 0x200A;
+    /** @hide */
+    public static final int RESPONSE_INVALID_OBJECT_FORMAT_CODE = 0x200B;
+    /** @hide */
+    public static final int RESPONSE_STORAGE_FULL = 0x200C;
+    /** @hide */
+    public static final int RESPONSE_OBJECT_WRITE_PROTECTED = 0x200D;
+    /** @hide */
+    public static final int RESPONSE_STORE_READ_ONLY = 0x200E;
+    /** @hide */
+    public static final int RESPONSE_ACCESS_DENIED = 0x200F;
+    /** @hide */
+    public static final int RESPONSE_NO_THUMBNAIL_PRESENT = 0x2010;
+    /** @hide */
+    public static final int RESPONSE_SELF_TEST_FAILED = 0x2011;
+    /** @hide */
+    public static final int RESPONSE_PARTIAL_DELETION = 0x2012;
+    /** @hide */
+    public static final int RESPONSE_STORE_NOT_AVAILABLE = 0x2013;
+    /** @hide */
+    public static final int RESPONSE_SPECIFICATION_BY_FORMAT_UNSUPPORTED = 0x2014;
+    /** @hide */
+    public static final int RESPONSE_NO_VALID_OBJECT_INFO = 0x2015;
+    /** @hide */
+    public static final int RESPONSE_INVALID_CODE_FORMAT = 0x2016;
+    /** @hide */
+    public static final int RESPONSE_UNKNOWN_VENDOR_CODE = 0x2017;
+    /** @hide */
+    public static final int RESPONSE_CAPTURE_ALREADY_TERMINATED = 0x2018;
+    /** @hide */
+    public static final int RESPONSE_DEVICE_BUSY = 0x2019;
+    /** @hide */
+    public static final int RESPONSE_INVALID_PARENT_OBJECT = 0x201A;
+    /** @hide */
+    public static final int RESPONSE_INVALID_DEVICE_PROP_FORMAT = 0x201B;
+    /** @hide */
+    public static final int RESPONSE_INVALID_DEVICE_PROP_VALUE = 0x201C;
+    /** @hide */
+    public static final int RESPONSE_INVALID_PARAMETER = 0x201D;
+    /** @hide */
+    public static final int RESPONSE_SESSION_ALREADY_OPEN = 0x201E;
+    /** @hide */
+    public static final int RESPONSE_TRANSACTION_CANCELLED = 0x201F;
+    /** @hide */
+    public static final int RESPONSE_SPECIFICATION_OF_DESTINATION_UNSUPPORTED = 0x2020;
+    /** @hide */
+    public static final int RESPONSE_INVALID_OBJECT_PROP_CODE = 0xA801;
+    /** @hide */
+    public static final int RESPONSE_INVALID_OBJECT_PROP_FORMAT = 0xA802;
+    /** @hide */
+    public static final int RESPONSE_INVALID_OBJECT_PROP_VALUE = 0xA803;
+    /** @hide */
+    public static final int RESPONSE_INVALID_OBJECT_REFERENCE = 0xA804;
+    /** @hide */
+    public static final int RESPONSE_GROUP_NOT_SUPPORTED = 0xA805;
+    /** @hide */
+    public static final int RESPONSE_INVALID_DATASET = 0xA806;
+    /** @hide */
+    public static final int RESPONSE_SPECIFICATION_BY_GROUP_UNSUPPORTED = 0xA807;
+    /** @hide */
+    public static final int RESPONSE_SPECIFICATION_BY_DEPTH_UNSUPPORTED = 0xA808;
+    /** @hide */
+    public static final int RESPONSE_OBJECT_TOO_LARGE = 0xA809;
+    /** @hide */
+    public static final int RESPONSE_OBJECT_PROP_NOT_SUPPORTED = 0xA80A;
+
+    // MTP format codes
+    /** Undefined format code */
+    public static final int FORMAT_UNDEFINED = 0x3000;
+    /** Format code for associations (folders and directories) */
+    public static final int FORMAT_ASSOCIATION = 0x3001;
+    /** Format code for script files */
+    public static final int FORMAT_SCRIPT = 0x3002;
+    /** Format code for executable files */
+    public static final int FORMAT_EXECUTABLE = 0x3003;
+    /** Format code for text files */
+    public static final int FORMAT_TEXT = 0x3004;
+    /** Format code for HTML files */
+    public static final int FORMAT_HTML = 0x3005;
+    /** Format code for DPOF files */
+    public static final int FORMAT_DPOF = 0x3006;
+    /** Format code for AIFF audio files */
+    public static final int FORMAT_AIFF = 0x3007;
+    /** Format code for WAV audio files */
+    public static final int FORMAT_WAV = 0x3008;
+    /** Format code for MP3 audio files */
+    public static final int FORMAT_MP3 = 0x3009;
+    /** Format code for AVI video files */
+    public static final int FORMAT_AVI = 0x300A;
+    /** Format code for MPEG video files */
+    public static final int FORMAT_MPEG = 0x300B;
+    /** Format code for ASF files */
+    public static final int FORMAT_ASF = 0x300C;
+    /** Format code for JPEG image files */
+    public static final int FORMAT_EXIF_JPEG = 0x3801;
+    /** Format code for TIFF EP image files */
+    public static final int FORMAT_TIFF_EP = 0x3802;
+    /** Format code for BMP image files */
+    public static final int FORMAT_BMP = 0x3804;
+    /** Format code for GIF image files */
+    public static final int FORMAT_GIF = 0x3807;
+    /** Format code for JFIF image files */
+    public static final int FORMAT_JFIF = 0x3808;
+    /** Format code for PICT image files */
+    public static final int FORMAT_PICT = 0x380A;
+    /** Format code for PNG image files */
+    public static final int FORMAT_PNG = 0x380B;
+    /** Format code for TIFF image files */
+    public static final int FORMAT_TIFF = 0x380D;
+    /** Format code for JP2 files */
+    public static final int FORMAT_JP2 = 0x380F;
+    /** Format code for JPX files */
+    public static final int FORMAT_JPX = 0x3810;
+    /** Format code for firmware files */
+    public static final int FORMAT_UNDEFINED_FIRMWARE = 0xB802;
+    /** Format code for Windows image files */
+    public static final int FORMAT_WINDOWS_IMAGE_FORMAT = 0xB881;
+    /** Format code for undefined audio files files */
+    public static final int FORMAT_UNDEFINED_AUDIO = 0xB900;
+    /** Format code for WMA audio files */
+    public static final int FORMAT_WMA = 0xB901;
+    /** Format code for OGG audio files */
+    public static final int FORMAT_OGG = 0xB902;
+    /** Format code for AAC audio files */
+    public static final int FORMAT_AAC = 0xB903;
+    /** Format code for Audible audio files */
+    public static final int FORMAT_AUDIBLE = 0xB904;
+    /** Format code for FLAC audio files */
+    public static final int FORMAT_FLAC = 0xB906;
+    /** Format code for undefined video files */
+    public static final int FORMAT_UNDEFINED_VIDEO = 0xB980;
+    /** Format code for WMV video files */
+    public static final int FORMAT_WMV = 0xB981;
+    /** Format code for MP4 files */
+    public static final int FORMAT_MP4_CONTAINER = 0xB982;
+    /** Format code for MP2 files */
+    public static final int FORMAT_MP2 = 0xB983;
+    /** Format code for 3GP files */
+    public static final int FORMAT_3GP_CONTAINER = 0xB984;
+    /** Format code for undefined collections */
+    public static final int FORMAT_UNDEFINED_COLLECTION = 0xBA00;
+    /** Format code for multimedia albums */
+    public static final int FORMAT_ABSTRACT_MULTIMEDIA_ALBUM = 0xBA01;
+    /** Format code for image albums */
+    public static final int FORMAT_ABSTRACT_IMAGE_ALBUM = 0xBA02;
+    /** Format code for audio albums */
+    public static final int FORMAT_ABSTRACT_AUDIO_ALBUM = 0xBA03;
+    /** Format code for video albums */
+    public static final int FORMAT_ABSTRACT_VIDEO_ALBUM = 0xBA04;
+    /** Format code for abstract AV playlists */
+    public static final int FORMAT_ABSTRACT_AV_PLAYLIST = 0xBA05;
+    /** Format code for abstract audio playlists */
+    public static final int FORMAT_ABSTRACT_AUDIO_PLAYLIST = 0xBA09;
+    /** Format code for abstract video playlists */
+    public static final int FORMAT_ABSTRACT_VIDEO_PLAYLIST = 0xBA0A;
+    /** Format code for abstract mediacasts */
+    public static final int FORMAT_ABSTRACT_MEDIACAST = 0xBA0B;
+    /** Format code for WPL playlist files */
+    public static final int FORMAT_WPL_PLAYLIST = 0xBA10;
+    /** Format code for M3u playlist files */
+    public static final int FORMAT_M3U_PLAYLIST = 0xBA11;
+    /** Format code for MPL playlist files */
+    public static final int FORMAT_MPL_PLAYLIST = 0xBA12;
+    /** Format code for ASX playlist files */
+    public static final int FORMAT_ASX_PLAYLIST = 0xBA13;
+    /** Format code for PLS playlist files */
+    public static final int FORMAT_PLS_PLAYLIST = 0xBA14;
+    /** Format code for undefined document files */
+    public static final int FORMAT_UNDEFINED_DOCUMENT = 0xBA80;
+    /** Format code for abstract documents */
+    public static final int FORMAT_ABSTRACT_DOCUMENT = 0xBA81;
+    /** Format code for XML documents */
+    public static final int FORMAT_XML_DOCUMENT = 0xBA82;
+    /** Format code for MS Word documents */
+    public static final int FORMAT_MS_WORD_DOCUMENT = 0xBA83;
+    /** Format code for MS Excel spreadsheets */
+    public static final int FORMAT_MS_EXCEL_SPREADSHEET = 0xBA85;
+    /** Format code for MS PowerPoint presentatiosn */
+    public static final int FORMAT_MS_POWERPOINT_PRESENTATION = 0xBA86;
+
+    /**
+     * Returns true if the object is abstract (that is, it has no representation
+     * in the underlying file system).
+     *
+     * @param format the format of the object
+     * @return true if the object is abstract
+     */
+    public static boolean isAbstractObject(int format) {
+        switch (format) {
+            case FORMAT_ABSTRACT_MULTIMEDIA_ALBUM:
+            case FORMAT_ABSTRACT_IMAGE_ALBUM:
+            case FORMAT_ABSTRACT_AUDIO_ALBUM:
+            case FORMAT_ABSTRACT_VIDEO_ALBUM:
+            case FORMAT_ABSTRACT_AV_PLAYLIST:
+            case FORMAT_ABSTRACT_AUDIO_PLAYLIST:
+            case FORMAT_ABSTRACT_VIDEO_PLAYLIST:
+            case FORMAT_ABSTRACT_MEDIACAST:
+            case FORMAT_ABSTRACT_DOCUMENT:
+                return true;
+            default:
+                return false;
+        }
+    }
+
+    // MTP object properties
+    /** @hide */
+    public static final int PROPERTY_STORAGE_ID = 0xDC01;
+    /** @hide */
+    public static final int PROPERTY_OBJECT_FORMAT = 0xDC02;
+    /** @hide */
+    public static final int PROPERTY_PROTECTION_STATUS = 0xDC03;
+    /** @hide */
+    public static final int PROPERTY_OBJECT_SIZE = 0xDC04;
+    /** @hide */
+    public static final int PROPERTY_ASSOCIATION_TYPE = 0xDC05;
+    /** @hide */
+    public static final int PROPERTY_ASSOCIATION_DESC = 0xDC06;
+    /** @hide */
+    public static final int PROPERTY_OBJECT_FILE_NAME = 0xDC07;
+    /** @hide */
+    public static final int PROPERTY_DATE_CREATED = 0xDC08;
+    /** @hide */
+    public static final int PROPERTY_DATE_MODIFIED = 0xDC09;
+    /** @hide */
+    public static final int PROPERTY_KEYWORDS = 0xDC0A;
+    /** @hide */
+    public static final int PROPERTY_PARENT_OBJECT = 0xDC0B;
+    /** @hide */
+    public static final int PROPERTY_ALLOWED_FOLDER_CONTENTS = 0xDC0C;
+    /** @hide */
+    public static final int PROPERTY_HIDDEN = 0xDC0D;
+    /** @hide */
+    public static final int PROPERTY_SYSTEM_OBJECT = 0xDC0E;
+    /** @hide */
+    public static final int PROPERTY_PERSISTENT_UID = 0xDC41;
+    /** @hide */
+    public static final int PROPERTY_SYNC_ID = 0xDC42;
+    /** @hide */
+    public static final int PROPERTY_PROPERTY_BAG = 0xDC43;
+    /** @hide */
+    public static final int PROPERTY_NAME = 0xDC44;
+    /** @hide */
+    public static final int PROPERTY_CREATED_BY = 0xDC45;
+    /** @hide */
+    public static final int PROPERTY_ARTIST = 0xDC46;
+    /** @hide */
+    public static final int PROPERTY_DATE_AUTHORED = 0xDC47;
+    /** @hide */
+    public static final int PROPERTY_DESCRIPTION = 0xDC48;
+    /** @hide */
+    public static final int PROPERTY_URL_REFERENCE = 0xDC49;
+    /** @hide */
+    public static final int PROPERTY_LANGUAGE_LOCALE = 0xDC4A;
+    /** @hide */
+    public static final int PROPERTY_COPYRIGHT_INFORMATION = 0xDC4B;
+    /** @hide */
+    public static final int PROPERTY_SOURCE = 0xDC4C;
+    /** @hide */
+    public static final int PROPERTY_ORIGIN_LOCATION = 0xDC4D;
+    /** @hide */
+    public static final int PROPERTY_DATE_ADDED = 0xDC4E;
+    /** @hide */
+    public static final int PROPERTY_NON_CONSUMABLE = 0xDC4F;
+    /** @hide */
+    public static final int PROPERTY_CORRUPT_UNPLAYABLE = 0xDC50;
+    /** @hide */
+    public static final int PROPERTY_PRODUCER_SERIAL_NUMBER = 0xDC51;
+    /** @hide */
+    public static final int PROPERTY_REPRESENTATIVE_SAMPLE_FORMAT = 0xDC81;
+    /** @hide */
+    public static final int PROPERTY_REPRESENTATIVE_SAMPLE_SIZE = 0xDC82;
+    /** @hide */
+    public static final int PROPERTY_REPRESENTATIVE_SAMPLE_HEIGHT = 0xDC83;
+    /** @hide */
+    public static final int PROPERTY_REPRESENTATIVE_SAMPLE_WIDTH = 0xDC84;
+    /** @hide */
+    public static final int PROPERTY_REPRESENTATIVE_SAMPLE_DURATION = 0xDC85;
+    /** @hide */
+    public static final int PROPERTY_REPRESENTATIVE_SAMPLE_DATA = 0xDC86;
+    /** @hide */
+    public static final int PROPERTY_WIDTH = 0xDC87;
+    /** @hide */
+    public static final int PROPERTY_HEIGHT = 0xDC88;
+    /** @hide */
+    public static final int PROPERTY_DURATION = 0xDC89;
+    /** @hide */
+    public static final int PROPERTY_RATING = 0xDC8A;
+    /** @hide */
+    public static final int PROPERTY_TRACK = 0xDC8B;
+    /** @hide */
+    public static final int PROPERTY_GENRE = 0xDC8C;
+    /** @hide */
+    public static final int PROPERTY_CREDITS = 0xDC8D;
+    /** @hide */
+    public static final int PROPERTY_LYRICS = 0xDC8E;
+    /** @hide */
+    public static final int PROPERTY_SUBSCRIPTION_CONTENT_ID = 0xDC8F;
+    /** @hide */
+    public static final int PROPERTY_PRODUCED_BY = 0xDC90;
+    /** @hide */
+    public static final int PROPERTY_USE_COUNT = 0xDC91;
+    /** @hide */
+    public static final int PROPERTY_SKIP_COUNT = 0xDC92;
+    /** @hide */
+    public static final int PROPERTY_LAST_ACCESSED = 0xDC93;
+    /** @hide */
+    public static final int PROPERTY_PARENTAL_RATING = 0xDC94;
+    /** @hide */
+    public static final int PROPERTY_META_GENRE = 0xDC95;
+    /** @hide */
+    public static final int PROPERTY_COMPOSER = 0xDC96;
+    /** @hide */
+    public static final int PROPERTY_EFFECTIVE_RATING = 0xDC97;
+    /** @hide */
+    public static final int PROPERTY_SUBTITLE = 0xDC98;
+    /** @hide */
+    public static final int PROPERTY_ORIGINAL_RELEASE_DATE = 0xDC99;
+    /** @hide */
+    public static final int PROPERTY_ALBUM_NAME = 0xDC9A;
+    /** @hide */
+    public static final int PROPERTY_ALBUM_ARTIST = 0xDC9B;
+    /** @hide */
+    public static final int PROPERTY_MOOD = 0xDC9C;
+    /** @hide */
+    public static final int PROPERTY_DRM_STATUS = 0xDC9D;
+    /** @hide */
+    public static final int PROPERTY_SUB_DESCRIPTION = 0xDC9E;
+    /** @hide */
+    public static final int PROPERTY_IS_CROPPED = 0xDCD1;
+    /** @hide */
+    public static final int PROPERTY_IS_COLOUR_CORRECTED = 0xDCD2;
+    /** @hide */
+    public static final int PROPERTY_IMAGE_BIT_DEPTH = 0xDCD3;
+    /** @hide */
+    public static final int PROPERTY_F_NUMBER = 0xDCD4;
+    /** @hide */
+    public static final int PROPERTY_EXPOSURE_TIME = 0xDCD5;
+    /** @hide */
+    public static final int PROPERTY_EXPOSURE_INDEX = 0xDCD6;
+    /** @hide */
+    public static final int PROPERTY_TOTAL_BITRATE = 0xDE91;
+    /** @hide */
+    public static final int PROPERTY_BITRATE_TYPE = 0xDE92;
+    /** @hide */
+    public static final int PROPERTY_SAMPLE_RATE = 0xDE93;
+    /** @hide */
+    public static final int PROPERTY_NUMBER_OF_CHANNELS = 0xDE94;
+    /** @hide */
+    public static final int PROPERTY_AUDIO_BIT_DEPTH = 0xDE95;
+    /** @hide */
+    public static final int PROPERTY_SCAN_TYPE = 0xDE97;
+    /** @hide */
+    public static final int PROPERTY_AUDIO_WAVE_CODEC = 0xDE99;
+    /** @hide */
+    public static final int PROPERTY_AUDIO_BITRATE = 0xDE9A;
+    /** @hide */
+    public static final int PROPERTY_VIDEO_FOURCC_CODEC = 0xDE9B;
+    /** @hide */
+    public static final int PROPERTY_VIDEO_BITRATE = 0xDE9C;
+    /** @hide */
+    public static final int PROPERTY_FRAMES_PER_THOUSAND_SECONDS = 0xDE9D;
+    /** @hide */
+    public static final int PROPERTY_KEYFRAME_DISTANCE = 0xDE9E;
+    /** @hide */
+    public static final int PROPERTY_BUFFER_SIZE = 0xDE9F;
+    /** @hide */
+    public static final int PROPERTY_ENCODING_QUALITY = 0xDEA0;
+    /** @hide */
+    public static final int PROPERTY_ENCODING_PROFILE = 0xDEA1;
+    /** @hide */
+    public static final int PROPERTY_DISPLAY_NAME = 0xDCE0;
+
+    // MTP device properties
+    /** @hide */
+    public static final int DEVICE_PROPERTY_UNDEFINED = 0x5000;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_BATTERY_LEVEL = 0x5001;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_FUNCTIONAL_MODE = 0x5002;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_IMAGE_SIZE = 0x5003;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_COMPRESSION_SETTING = 0x5004;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_WHITE_BALANCE = 0x5005;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_RGB_GAIN = 0x5006;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_F_NUMBER = 0x5007;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_FOCAL_LENGTH = 0x5008;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_FOCUS_DISTANCE = 0x5009;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_FOCUS_MODE = 0x500A;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_EXPOSURE_METERING_MODE = 0x500B;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_FLASH_MODE = 0x500C;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_EXPOSURE_TIME = 0x500D;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_EXPOSURE_PROGRAM_MODE = 0x500E;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_EXPOSURE_INDEX = 0x500F;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_EXPOSURE_BIAS_COMPENSATION = 0x5010;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_DATETIME = 0x5011;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_CAPTURE_DELAY = 0x5012;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_STILL_CAPTURE_MODE = 0x5013;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_CONTRAST = 0x5014;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_SHARPNESS = 0x5015;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_DIGITAL_ZOOM = 0x5016;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_EFFECT_MODE = 0x5017;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_BURST_NUMBER= 0x5018;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_BURST_INTERVAL = 0x5019;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_TIMELAPSE_NUMBER = 0x501A;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_TIMELAPSE_INTERVAL = 0x501B;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_FOCUS_METERING_MODE = 0x501C;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_UPLOAD_URL = 0x501D;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_ARTIST = 0x501E;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_COPYRIGHT_INFO = 0x501F;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_SYNCHRONIZATION_PARTNER = 0xD401;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_DEVICE_FRIENDLY_NAME = 0xD402;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_VOLUME = 0xD403;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_SUPPORTED_FORMATS_ORDERED = 0xD404;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_DEVICE_ICON = 0xD405;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_PLAYBACK_RATE = 0xD410;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_PLAYBACK_OBJECT = 0xD411;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_PLAYBACK_CONTAINER_INDEX = 0xD412;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_SESSION_INITIATOR_VERSION_INFO = 0xD406;
+    /** @hide */
+    public static final int DEVICE_PROPERTY_PERCEIVED_DEVICE_TYPE = 0xD407;
+
+    /**
+     * Object is not protected. It may be modified and deleted, and its properties
+     * may be modified.
+     */
+    public static final int PROTECTION_STATUS_NONE = 0;
+
+    /**
+     * Object can not be modified or deleted and its properties can not be modified.
+     */
+    public static final int PROTECTION_STATUS_READ_ONLY = 0x8001;
+
+    /**
+     * Object can not be modified or deleted but its properties are modifiable.
+     */
+    public static final int PROTECTION_STATUS_READ_ONLY_DATA = 0x8002;
+
+    /**
+     * Object's contents can not be transfered from the device, but the object
+     * may be moved or deleted and its properties may be modified.
+     */
+    public static final int PROTECTION_STATUS_NON_TRANSFERABLE_DATA = 0x8003;
+
+    /**
+     * Association type for objects representing file system directories.
+     */
+    public static final int ASSOCIATION_TYPE_GENERIC_FOLDER = 0x0001;
+}
+
diff --git a/ion/src/com/koushikdutta/ion/loader/PackageIconLoader.java b/ion/src/com/koushikdutta/ion/loader/PackageIconLoader.java
index 0f9a0930..241d0367 100644
--- a/ion/src/com/koushikdutta/ion/loader/PackageIconLoader.java
+++ b/ion/src/com/koushikdutta/ion/loader/PackageIconLoader.java
@@ -1,45 +1,30 @@
 package com.koushikdutta.ion.loader;
 
 
-import android.content.pm.PackageInfo;
 import android.content.pm.PackageManager;
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
 
-import com.koushikdutta.async.DataEmitter;
 import com.koushikdutta.async.future.Future;
-import com.koushikdutta.async.future.FutureCallback;
 import com.koushikdutta.async.future.SimpleFuture;
-import com.koushikdutta.async.http.AsyncHttpRequest;
 import com.koushikdutta.ion.Ion;
 import com.koushikdutta.ion.Loader;
 import com.koushikdutta.ion.bitmap.BitmapInfo;
 
-import java.io.InputStream;
 import java.net.URI;
 
 /**
  * Created by koush on 11/3/13.
  */
-public class PackageIconLoader implements Loader {
+public class PackageIconLoader extends SimpleLoader {
     @Override
-    public Future<InputStream> load(Ion ion, AsyncHttpRequest request) {
-        return null;
-    }
-
-    @Override
-    public Future<DataEmitter> load(Ion ion, AsyncHttpRequest request, FutureCallback<LoaderEmitter> callback) {
-        return null;
-    }
-
-    @Override
-    public Future<BitmapInfo> loadBitmap(final Ion ion, final String uri) {
+    public Future<BitmapInfo> loadBitmap(final Ion ion, final String uri, int resizeWidth, int resizeHeight) {
         final URI request = URI.create(uri);
         if (request == null || request.getScheme() == null || !request.getScheme().startsWith("package"))
             return null;
 
         final SimpleFuture<BitmapInfo> ret = new SimpleFuture<BitmapInfo>();
-        ion.getBitmapLoadExecutorService().execute(new Runnable() {
+        Ion.getBitmapLoadExecutorService().execute(new Runnable() {
             @Override
             public void run() {
                 try {
diff --git a/ion/src/com/koushikdutta/ion/loader/SimpleLoader.java b/ion/src/com/koushikdutta/ion/loader/SimpleLoader.java
new file mode 100644
index 00000000..934e16d1
--- /dev/null
+++ b/ion/src/com/koushikdutta/ion/loader/SimpleLoader.java
@@ -0,0 +1,31 @@
+package com.koushikdutta.ion.loader;
+
+import com.koushikdutta.async.DataEmitter;
+import com.koushikdutta.async.future.Future;
+import com.koushikdutta.async.future.FutureCallback;
+import com.koushikdutta.async.http.AsyncHttpRequest;
+import com.koushikdutta.ion.Ion;
+import com.koushikdutta.ion.Loader;
+import com.koushikdutta.ion.bitmap.BitmapInfo;
+
+import java.io.InputStream;
+
+/**
+ * Created by koush on 12/22/13.
+ */
+public class SimpleLoader implements Loader {
+    @Override
+    public Future<InputStream> load(Ion ion, AsyncHttpRequest request) {
+        return null;
+    }
+
+    @Override
+    public Future<DataEmitter> load(Ion ion, AsyncHttpRequest request, FutureCallback<LoaderEmitter> callback) {
+        return null;
+    }
+
+    @Override
+    public Future<BitmapInfo> loadBitmap(Ion ion, String uri, int resizeWidth, int resizeHeight) {
+        return null;
+    }
+}
diff --git a/ion/src/com/koushikdutta/ion/loader/VideoLoader.java b/ion/src/com/koushikdutta/ion/loader/VideoLoader.java
index b1b9128c..e58a4c27 100644
--- a/ion/src/com/koushikdutta/ion/loader/VideoLoader.java
+++ b/ion/src/com/koushikdutta/ion/loader/VideoLoader.java
@@ -24,17 +24,8 @@
 /**
  * Created by koush on 11/6/13.
  */
-public class VideoLoader implements Loader {
+public class VideoLoader extends SimpleLoader {
     private static final String TAG = "IonVideoLoader";
-    @Override
-    public Future<DataEmitter> load(Ion ion, AsyncHttpRequest request, FutureCallback<LoaderEmitter> callback) {
-        return null;
-    }
-
-    @Override
-    public Future<InputStream> load(Ion ion, AsyncHttpRequest request) {
-        return null;
-    }
 
     public static Bitmap createVideoThumbnail(String filePath) {
         // MediaMetadataRetriever is available on API Level 8
@@ -85,21 +76,18 @@ public static Bitmap createVideoThumbnail(String filePath) {
     }
 
     @Override
-    public Future<BitmapInfo> loadBitmap(Ion ion, String uri) {
-        if (Build.VERSION.SDK_INT < 12)
-            return null;
-
+    public Future<BitmapInfo> loadBitmap(Ion ion, String uri, int resizeWidth, int resizeHeight) {
         if (!uri.startsWith(ContentResolver.SCHEME_FILE))
             return null;
 
         final File file = new File(URI.create(uri));
 
         MediaFile.MediaFileType type = MediaFile.getFileType(file.getAbsolutePath());
-        if (!MediaFile.isVideoFileType(type.fileType))
+        if (type == null || !MediaFile.isVideoFileType(type.fileType))
             return null;
 
         final SimpleFuture<BitmapInfo> ret = new SimpleFuture<BitmapInfo>();
-        ion.getBitmapLoadExecutorService().execute(new Runnable() {
+        Ion.getBitmapLoadExecutorService().execute(new Runnable() {
             @Override
             public void run() {
                 try {
