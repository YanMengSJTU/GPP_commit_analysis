diff --git a/README.md b/README.md
index aa88a4e6..8cba5619 100644
--- a/README.md
+++ b/README.md
@@ -225,7 +225,7 @@ public static class Tweet {
 
 public void getTweets() throws Exception {
     Ion.with(context, "http://example.com/api/tweets")
-    .as(new TypeToken<List<Tweet>>(){});
+    .as(new TypeToken<List<Tweet>>(){})
     .setCallback(new FutureCallback<List<Tweet>>() {
        @Override
         public void onCompleted(Exception e, List<Tweet> tweets) {
diff --git a/ion-sample/src/com/koushikdutta/ion/sample/Twitter.java b/ion-sample/src/com/koushikdutta/ion/sample/Twitter.java
index 741f467d..e613f1dc 100644
--- a/ion-sample/src/com/koushikdutta/ion/sample/Twitter.java
+++ b/ion-sample/src/com/koushikdutta/ion/sample/Twitter.java
@@ -31,7 +31,7 @@ public void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
 
         // Enable global Ion logging
-        Ion.getDefault(this).setLogging("ion-sample", Log.DEBUG);
+//        Ion.getDefault(this).setLogging("ion-sample", Log.DEBUG);
 
         // create a tweet adapter for our list view
         tweetAdapter = new ArrayAdapter<JsonObject>(this, 0) {
diff --git a/ion/src/com/koushikdutta/ion/BitmapCallback.java b/ion/src/com/koushikdutta/ion/BitmapCallback.java
index 410b2de2..ccea19a5 100644
--- a/ion/src/com/koushikdutta/ion/BitmapCallback.java
+++ b/ion/src/com/koushikdutta/ion/BitmapCallback.java
@@ -23,7 +23,7 @@ boolean put() {
         return put;
     }
 
-    void report(final Exception e, final BitmapInfo info) {
+    protected void report(final Exception e, final BitmapInfo info) {
         AsyncServer.post(Ion.mainHandler, new Runnable() {
             @Override
             public void run() {
diff --git a/ion/src/com/koushikdutta/ion/BitmapToBitmapInfo.java b/ion/src/com/koushikdutta/ion/BitmapToBitmapInfo.java
index c2db9f0e..cc2641f7 100644
--- a/ion/src/com/koushikdutta/ion/BitmapToBitmapInfo.java
+++ b/ion/src/com/koushikdutta/ion/BitmapToBitmapInfo.java
@@ -1,12 +1,10 @@
 package com.koushikdutta.ion;
 
 import android.graphics.Bitmap;
-import android.graphics.BitmapFactory;
+import android.util.Log;
 
 import com.koushikdutta.async.ByteBufferList;
-import com.koushikdutta.async.future.Future;
 import com.koushikdutta.async.future.FutureCallback;
-import com.koushikdutta.async.future.SimpleFuture;
 import com.koushikdutta.async.http.ResponseCacheMiddleware;
 import com.koushikdutta.async.http.libcore.DiskLruCache;
 import com.koushikdutta.ion.bitmap.BitmapInfo;
@@ -26,7 +24,7 @@ public static void getBitmapSnapshot(final Ion ion, final String transformKey) {
         ion.getServer().getExecutorService().execute(new Runnable() {
             @Override
             public void run() {
-                final LoadBitmap callback = new LoadBitmap(ion, transformKey, true, 0, 0, Loader.LoaderEmitter.LOADED_FROM_CACHE);
+                final LoadBitmap callback = new LoadBitmap(ion, transformKey, true, -1, -1, Loader.LoaderEmitter.LOADED_FROM_CACHE);
 
                 try {
                     DiskLruCache.Snapshot snapshot = ion.getResponseCache().getDiskLruCache().get(transformKey);
@@ -44,7 +42,7 @@ public void run() {
                     }
                 }
                 catch (Exception e) {
-                    callback.report(e, null);
+                    callback.onCompleted(e, null);
                     try {
                         ion.getResponseCache().getDiskLruCache().remove(transformKey);
                     }
@@ -55,9 +53,13 @@ public void run() {
         });
     }
 
-    public BitmapToBitmapInfo(Ion ion, String transformKey, ArrayList<Transform> transforms) {
+    String downloadKey;
+    public BitmapToBitmapInfo(Ion ion, String transformKey, String downloadKey, ArrayList<Transform> transforms) {
         super(ion, transformKey, true);
         this.transforms = transforms;
+        this.downloadKey = downloadKey;
+
+        ion.bitmapsPending.tag(transformKey, this);
     }
 
     @Override
@@ -67,6 +69,11 @@ public void onCompleted(Exception e, final BitmapInfo result) {
             return;
         }
 
+        if (ion.bitmapsPending.tag(key) != this) {
+            Log.d("IonBitmapLoader", "Bitmap transform cancelled (no longer needed)");
+            return;
+        }
+
         ion.getServer().getExecutorService().execute(new Runnable() {
             @Override
             public void run() {
diff --git a/ion/src/com/koushikdutta/ion/DefaultTransform.java b/ion/src/com/koushikdutta/ion/DefaultTransform.java
index c1d4bdee..24e92878 100644
--- a/ion/src/com/koushikdutta/ion/DefaultTransform.java
+++ b/ion/src/com/koushikdutta/ion/DefaultTransform.java
@@ -34,11 +34,11 @@ public Bitmap transform(Bitmap b) {
             else
                 ratio = Math.min(xratio, yratio);
 
-            float postx = b.getWidth() * ratio;
-            float posty = b.getHeight() * ratio;
-            float transx = (resizeWidth - postx) / 2;
-            float transy = (resizeHeight - posty) / 2;
-            destination.set(transx, transy, postx, posty);
+            float postWidth = b.getWidth() * ratio;
+            float postHeight = b.getHeight() * ratio;
+            float transx = (resizeWidth - postWidth) / 2;
+            float transy = (resizeHeight - postHeight) / 2;
+            destination.set(transx, transy, transx + postWidth, transy + postHeight);
         }
 
         canvas.drawBitmap(b, null, destination, null);
diff --git a/ion/src/com/koushikdutta/ion/IonBitmapRequestBuilder.java b/ion/src/com/koushikdutta/ion/IonBitmapRequestBuilder.java
index cb482809..c28122e5 100644
--- a/ion/src/com/koushikdutta/ion/IonBitmapRequestBuilder.java
+++ b/ion/src/com/koushikdutta/ion/IonBitmapRequestBuilder.java
@@ -138,7 +138,7 @@ public void run() {
         // make sure that the parent download isn't cancelled (empty list)
         // and also make sure there are waiters for this transformed bitmap
         if (!ion.bitmapsPending.contains(downloadKey) || !ion.bitmapsPending.contains(bitmapKey)) {
-            ion.bitmapsPending.add(downloadKey, new BitmapToBitmapInfo(ion, bitmapKey, transforms));
+            ion.bitmapsPending.add(downloadKey, new BitmapToBitmapInfo(ion, bitmapKey, downloadKey, transforms));
         }
 
         return null;
diff --git a/ion/src/com/koushikdutta/ion/IonDrawable.java b/ion/src/com/koushikdutta/ion/IonDrawable.java
index aeca16e0..5a7ecfd5 100644
--- a/ion/src/com/koushikdutta/ion/IonDrawable.java
+++ b/ion/src/com/koushikdutta/ion/IonDrawable.java
@@ -9,6 +9,7 @@
 import android.view.animation.Animation;
 import android.widget.ImageView;
 
+import com.koushikdutta.async.future.Future;
 import com.koushikdutta.async.future.FutureCallback;
 import com.koushikdutta.async.future.SimpleFuture;
 import com.koushikdutta.ion.bitmap.BitmapInfo;
@@ -56,6 +57,7 @@ public void setInAnimation(Animation inAnimation, int inAnimationResource) {
         private WeakReference<IonDrawable> ionDrawableRef;
         private WeakReference<ImageView> imageViewRef;
         private String bitmapKey;
+        private String parentKey;
         private SimpleFuture<ImageView> imageViewFuture = new SimpleFuture<ImageView>();
         private Animation inAnimation;
         private int inAnimationResource;
@@ -92,7 +94,7 @@ public void onCompleted(Exception e, BitmapInfo result) {
             drawable.setBitmap(result, result.loadedFrom);
             imageView.setImageDrawable(drawable);
             IonBitmapRequestBuilder.doAnimation(imageView, inAnimation, inAnimationResource);
-            imageViewFuture.setComplete(imageView);
+            imageViewFuture.setComplete(e, imageView);
 
         }
     }
@@ -108,13 +110,11 @@ public void register(Ion ion, String bitmapKey) {
         if (previousKey == null)
             return;
 
-        ArrayList<FutureCallback<BitmapInfo>> cbs = ion.bitmapsPending.get(previousKey);
-        if (cbs == null)
-            return;
-
-        cbs.remove(callback);
-        if (cbs.size() == 0)
-            ion.bitmapsPending.remove(previousKey);
+        Object owner = ion.bitmapsPending.removeItem(previousKey, callback);
+        if (owner instanceof BitmapToBitmapInfo) {
+            BitmapToBitmapInfo info = (BitmapToBitmapInfo)owner;
+            ion.bitmapsPending.removeItem(info.downloadKey, info);
+        }
     }
 
     private static final int DEFAULT_PAINT_FLAGS = Paint.FILTER_BITMAP_FLAG | Paint.DITHER_FLAG;
diff --git a/ion/src/com/koushikdutta/ion/LoadBitmap.java b/ion/src/com/koushikdutta/ion/LoadBitmap.java
index 07a2ef14..fe2bd597 100644
--- a/ion/src/com/koushikdutta/ion/LoadBitmap.java
+++ b/ion/src/com/koushikdutta/ion/LoadBitmap.java
@@ -2,23 +2,36 @@
 
 import android.graphics.Bitmap;
 import android.os.Looper;
+import android.util.Log;
 
 import com.koushikdutta.async.ByteBufferList;
 import com.koushikdutta.async.future.FutureCallback;
 import com.koushikdutta.ion.bitmap.BitmapInfo;
 
 import java.nio.ByteBuffer;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
 
 class LoadBitmap extends BitmapCallback implements FutureCallback<ByteBufferList> {
     int resizeWidth;
     int resizeHeight;
     int loadedFrom;
+    static ExecutorService singleExecutorService;
+
+    static {
+        int numProcs = Runtime.getRuntime().availableProcessors();
+        if (numProcs <= 2) {
+            singleExecutorService = Executors.newFixedThreadPool(1);
+        }
+    }
 
     public LoadBitmap(Ion ion, String urlKey, boolean put, int resizeWidth, int resizeHeight, int loadedFrom) {
         super(ion, urlKey, put);
         this.resizeWidth = resizeWidth;
         this.resizeHeight = resizeHeight;
         this.loadedFrom = loadedFrom;
+
+        ion.bitmapsPending.tag(urlKey, this);
     }
 
     @Override
@@ -28,7 +41,18 @@ public void onCompleted(Exception e, final ByteBufferList result) {
             return;
         }
 
-        ion.getServer().getExecutorService().execute(new Runnable() {
+        if (ion.bitmapsPending.tag(key) != this) {
+            Log.d("IonBitmapLoader", "Bitmap load cancelled (no longer needed)");
+            result.recycle();
+            return;
+        }
+
+        ExecutorService executorService = singleExecutorService;
+        if (executorService == null) {
+            executorService = ion.getServer().getExecutorService();
+        }
+
+        executorService.execute(new Runnable() {
             @Override
             public void run() {
                 ByteBuffer bb = result.getAll();
diff --git a/ion/src/com/koushikdutta/ion/bitmap/IonBitmapCache.java b/ion/src/com/koushikdutta/ion/bitmap/IonBitmapCache.java
index 6c3c81fb..7627b198 100644
--- a/ion/src/com/koushikdutta/ion/bitmap/IonBitmapCache.java
+++ b/ion/src/com/koushikdutta/ion/bitmap/IonBitmapCache.java
@@ -81,11 +81,11 @@ public Bitmap loadBitmap(byte[] bytes, int offset, int length, int minx, int min
         assert Thread.currentThread() != Looper.getMainLooper().getThread();
         int targetWidth = minx;
         int targetHeight = miny;
-        if (targetWidth <= 0)
+        if (targetWidth == 0)
             targetWidth = metrics.widthPixels;
         if (targetWidth <= 0)
             targetWidth = Integer.MAX_VALUE;
-        if (targetHeight <= 0)
+        if (targetHeight == 0)
             targetHeight = metrics.heightPixels;
         if (targetHeight <= 0)
             targetHeight = Integer.MAX_VALUE;
@@ -97,7 +97,7 @@ public Bitmap loadBitmap(byte[] bytes, int offset, int length, int minx, int min
             BitmapFactory.decodeByteArray(bytes, offset, length, o);
             if (o.outWidth < 0 || o.outHeight < 0)
                 return null;
-            int scale = Math.min(o.outWidth / targetWidth, o.outHeight / targetHeight);
+            int scale = Math.max(o.outWidth / targetWidth, o.outHeight / targetHeight);
             o = new BitmapFactory.Options();
             o.inSampleSize = scale;
         }
@@ -133,7 +133,7 @@ public Bitmap loadBitmap(InputStream stream, int minx, int miny) {
             catch (Exception e) {
                 return null;
             }
-            int scale = Math.min(o.outWidth / targetWidth, o.outHeight / targetHeight);
+            int scale = Math.max(o.outWidth / targetWidth, o.outHeight / targetHeight);
             o = new BitmapFactory.Options();
             o.inSampleSize = scale;
         }
