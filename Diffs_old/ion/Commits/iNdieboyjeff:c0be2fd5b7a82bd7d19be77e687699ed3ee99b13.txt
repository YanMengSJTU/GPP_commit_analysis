diff --git a/ion-sample/src/com/koushikdutta/ion/sample/ImageViewSample.java b/ion-sample/src/com/koushikdutta/ion/sample/ImageViewSample.java
index a9d3d4a1..8e602029 100644
--- a/ion-sample/src/com/koushikdutta/ion/sample/ImageViewSample.java
+++ b/ion-sample/src/com/koushikdutta/ion/sample/ImageViewSample.java
@@ -18,8 +18,9 @@ public void loadCenterCrop() {
         Ion.with(this)
         .load("http://media.salon.com/2013/05/original.jpg")
         .withBitmap()
-        .resize(512, 512)
-        .centerCrop()
+//        .resize(512, 512)
+//        .centerCrop()
+        .mipmap()
         .intoImageView(imageView);
     }
 
diff --git a/ion/src/com/koushikdutta/ion/BitmapCallback.java b/ion/src/com/koushikdutta/ion/BitmapCallback.java
index a5a1ba3b..2b7c87cb 100644
--- a/ion/src/com/koushikdutta/ion/BitmapCallback.java
+++ b/ion/src/com/koushikdutta/ion/BitmapCallback.java
@@ -1,5 +1,7 @@
 package com.koushikdutta.ion;
 
+import android.graphics.Point;
+
 import com.koushikdutta.async.AsyncServer;
 import com.koushikdutta.async.future.FutureCallback;
 import com.koushikdutta.ion.Ion;
@@ -7,11 +9,11 @@
 
 import java.util.ArrayList;
 
-class BitmapCallback {
+abstract class BitmapCallback {
     String key;
     Ion ion;
 
-    public BitmapCallback(Ion ion, String key, boolean put) {
+    protected BitmapCallback(Ion ion, String key, boolean put) {
         this.key = key;
         this.put = put;
         this.ion = ion;
@@ -25,6 +27,10 @@ boolean put() {
         return put;
     }
 
+    protected void onReported() {
+        BitmapFetcher.processDeferred(ion);
+    }
+
     protected void report(final Exception e, final BitmapInfo info) {
         AsyncServer.post(Ion.mainHandler, new Runnable() {
             @Override
@@ -32,8 +38,7 @@ public void run() {
                 BitmapInfo result = info;
                 if (result == null) {
                     // cache errors
-                    result = new BitmapInfo();
-                    result.bitmaps = null;
+                    result = new BitmapInfo(null, new Point());
                     result.key = key;
                     result.exception = e;
                     ion.getBitmapCache().put(result);
@@ -42,12 +47,15 @@ public void run() {
                 }
 
                 final ArrayList<FutureCallback<BitmapInfo>> callbacks = ion.bitmapsPending.remove(key);
-                if (callbacks == null || callbacks.size() == 0)
+                if (callbacks == null || callbacks.size() == 0) {
+                    onReported();
                     return;
+                }
 
                 for (FutureCallback<BitmapInfo> callback : callbacks) {
                     callback.onCompleted(e, result);
                 }
+                onReported();
             }
         });
     }
diff --git a/ion/src/com/koushikdutta/ion/BitmapFetcher.java b/ion/src/com/koushikdutta/ion/BitmapFetcher.java
new file mode 100644
index 00000000..479d6cc1
--- /dev/null
+++ b/ion/src/com/koushikdutta/ion/BitmapFetcher.java
@@ -0,0 +1,143 @@
+package com.koushikdutta.ion;
+
+import com.koushikdutta.async.AsyncServer;
+import com.koushikdutta.async.ByteBufferList;
+import com.koushikdutta.async.future.Future;
+import com.koushikdutta.async.future.FutureCallback;
+import com.koushikdutta.async.http.libcore.DiskLruCache;
+import com.koushikdutta.async.parser.ByteBufferListParser;
+import com.koushikdutta.ion.bitmap.BitmapInfo;
+import com.koushikdutta.ion.bitmap.Transform;
+
+import java.util.ArrayList;
+
+class BitmapFetcher {
+    String downloadKey;
+    String bitmapKey;
+    BitmapInfo info;
+    boolean hasTransforms;
+    ArrayList<Transform> transforms;
+    IonRequestBuilder builder;
+    int resizeWidth;
+    int resizeHeight;
+    boolean animateGif;
+
+    boolean fastLoad() {
+        Ion ion = builder.ion;
+        boolean put = !hasTransforms;
+
+        for (Loader loader: ion.configure().getLoaders()) {
+            Future<BitmapInfo> future = loader.loadBitmap(ion, builder.uri, resizeWidth, resizeHeight);
+            if (future != null) {
+                final BitmapCallback callback = new LoadBitmapBase(ion, downloadKey, put);
+                future.setCallback(new FutureCallback<BitmapInfo>() {
+                    @Override
+                    public void onCompleted(Exception e, BitmapInfo result) {
+                        if (result != null)
+                            result.key = downloadKey;
+                        callback.report(e, result);
+                    }
+                });
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private static final int MAX_IMAGEVIEW_LOAD = 5;
+
+    static boolean shouldDeferImageView(Ion ion) {
+        if (ion.bitmapsPending.keySet().size() <= MAX_IMAGEVIEW_LOAD)
+            return false;
+        int loadCount = 0;
+        for (String key: ion.bitmapsPending.keySet()) {
+            Object owner = ion.bitmapsPending.tag(key);
+            if (owner instanceof LoadBitmapBase) {
+                loadCount++;
+                if (loadCount > MAX_IMAGEVIEW_LOAD)
+                    return true;
+            }
+        }
+        return false;
+    }
+
+    static void processDeferred(Ion ion) {
+        if (shouldDeferImageView(ion))
+            return;
+        ArrayList<DeferredLoadBitmap> deferred = null;
+        for (String key: ion.bitmapsPending.keySet()) {
+            Object owner = ion.bitmapsPending.tag(key);
+            if (owner instanceof DeferredLoadBitmap) {
+                DeferredLoadBitmap deferredLoadBitmap = (DeferredLoadBitmap)owner;
+                if (deferred == null)
+                    deferred = new ArrayList<DeferredLoadBitmap>();
+                deferred.add(deferredLoadBitmap);
+            }
+        }
+
+        if (deferred == null)
+            return;
+        int count = 0;
+        for (DeferredLoadBitmap deferredLoadBitmap: deferred) {
+            ion.bitmapsPending.tag(deferredLoadBitmap.key, null);
+            ion.bitmapsPending.tag(deferredLoadBitmap.fetcher.bitmapKey, null);
+            deferredLoadBitmap.fetcher.executeNetwork();
+            count++;
+            // do MAX_IMAGEVIEW_LOAD max. this may end up going over the MAX_IMAGEVIEW_LOAD threshhold
+            if (count > MAX_IMAGEVIEW_LOAD)
+                return;
+        }
+    }
+
+    DeferredLoadBitmap executeDeferred() {
+        DeferredLoadBitmap ret = new DeferredLoadBitmap(builder.ion, downloadKey, this);
+        executeTransforms(builder.ion);
+        return ret;
+    }
+
+    private void executeTransforms(Ion ion) {
+        // if there's a transform, do it
+        if (!hasTransforms)
+            return;
+
+        // verify this transform isn't already pending
+        // make sure that the parent download isn't cancelled (empty list)
+        // and also make sure there are waiters for this transformed bitmap
+        if (ion.bitmapsPending.tag(bitmapKey) == null) {
+            ion.bitmapsPending.add(downloadKey, new TransformBitmap(ion, bitmapKey, downloadKey, transforms));
+        }
+    }
+
+    void executeNetwork() {
+        final Ion ion = builder.ion;
+
+        // bitmaps that were transformed are put into the DiskLruCache to prevent
+        // subsequent retransformation. See if we can retrieve the bitmap from the disk cache.
+        // See TransformBitmap for where the cache is populated.
+        DiskLruCache diskLruCache = ion.responseCache.getDiskLruCache();
+        if (!builder.noCache && hasTransforms && diskLruCache.containsKey(bitmapKey)) {
+            TransformBitmap.getBitmapSnapshot(ion, bitmapKey);
+            return;
+        }
+
+        // Perform a download as necessary.
+        if (ion.bitmapsPending.tag(downloadKey) == null && !fastLoad()) {
+            builder.setHandler(null);
+            // if we cancel, gotta remove any waiters.
+            IonRequestBuilder.EmitterTransform<ByteBufferList> emitterTransform = builder.execute(new ByteBufferListParser(), new Runnable() {
+                @Override
+                public void run() {
+                    AsyncServer.post(Ion.mainHandler, new Runnable() {
+                        @Override
+                        public void run() {
+                            ion.bitmapsPending.remove(downloadKey);
+                        }
+                    });
+                }
+            });
+            emitterTransform.setCallback(new LoadBitmap(ion, downloadKey, !hasTransforms, resizeWidth, resizeHeight, animateGif, emitterTransform));
+        }
+
+        executeTransforms(ion);
+    }
+}
diff --git a/ion/src/com/koushikdutta/ion/BitmapInfoToBitmap.java b/ion/src/com/koushikdutta/ion/BitmapInfoToBitmap.java
new file mode 100644
index 00000000..ffcf300c
--- /dev/null
+++ b/ion/src/com/koushikdutta/ion/BitmapInfoToBitmap.java
@@ -0,0 +1,29 @@
+package com.koushikdutta.ion;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+
+import com.koushikdutta.async.future.TransformFuture;
+import com.koushikdutta.ion.bitmap.BitmapInfo;
+
+import java.lang.ref.WeakReference;
+
+class BitmapInfoToBitmap extends TransformFuture<Bitmap, BitmapInfo> {
+    WeakReference<Context> context;
+    public BitmapInfoToBitmap(WeakReference<Context> context) {
+        this.context = context;
+    }
+
+    @Override
+    protected void transform(BitmapInfo result) throws Exception {
+        if (!IonRequestBuilder.checkContext(context)) {
+            cancel();
+            return;
+        }
+
+        if (result.exception != null)
+            setComplete(result.exception);
+        else
+            setComplete(result.bitmaps[0]);
+    }
+}
\ No newline at end of file
diff --git a/ion/src/com/koushikdutta/ion/DeferredLoadBitmap.java b/ion/src/com/koushikdutta/ion/DeferredLoadBitmap.java
new file mode 100644
index 00000000..cd30a28d
--- /dev/null
+++ b/ion/src/com/koushikdutta/ion/DeferredLoadBitmap.java
@@ -0,0 +1,12 @@
+package com.koushikdutta.ion;
+
+/**
+ * Created by koush on 1/18/14.
+ */
+public class DeferredLoadBitmap extends BitmapCallback {
+    BitmapFetcher fetcher;
+    public DeferredLoadBitmap(Ion ion, String key, BitmapFetcher fetcher)  {
+        super(ion, key, false);
+        this.fetcher = fetcher;
+    }
+}
diff --git a/ion/src/com/koushikdutta/ion/Ion.java b/ion/src/com/koushikdutta/ion/Ion.java
index 0d1a22b4..1c22ae32 100644
--- a/ion/src/com/koushikdutta/ion/Ion.java
+++ b/ion/src/com/koushikdutta/ion/Ion.java
@@ -217,6 +217,18 @@ public FutureBuilder build(Context context, File file) {
         return bitmapBuilder.withImageView(imageView);
     }
 
+    int groupCount(Object group) {
+        FutureSet members;
+        synchronized (this) {
+            members = inFlight.get(group);
+        }
+
+        if (members == null)
+            return 0;
+
+        return members.size();
+    }
+
     /**
      * Cancel all pending requests associated with the request group
      * @param group
diff --git a/ion/src/com/koushikdutta/ion/IonBitmapRequestBuilder.java b/ion/src/com/koushikdutta/ion/IonBitmapRequestBuilder.java
index 49f0c1da..9d3ead86 100644
--- a/ion/src/com/koushikdutta/ion/IonBitmapRequestBuilder.java
+++ b/ion/src/com/koushikdutta/ion/IonBitmapRequestBuilder.java
@@ -4,7 +4,6 @@
 import android.graphics.Bitmap;
 import android.graphics.drawable.Drawable;
 import android.os.Looper;
-import android.util.Pair;
 import android.view.animation.Animation;
 import android.view.animation.AnimationUtils;
 import android.widget.ImageView;
@@ -14,7 +13,6 @@
 import com.koushikdutta.async.future.Future;
 import com.koushikdutta.async.future.FutureCallback;
 import com.koushikdutta.async.future.SimpleFuture;
-import com.koushikdutta.async.future.TransformFuture;
 import com.koushikdutta.async.http.ResponseCacheMiddleware;
 import com.koushikdutta.async.http.libcore.DiskLruCache;
 import com.koushikdutta.async.parser.ByteBufferListParser;
@@ -22,9 +20,9 @@
 import com.koushikdutta.ion.bitmap.Transform;
 import com.koushikdutta.ion.builder.BitmapFutureBuilder;
 import com.koushikdutta.ion.builder.Builders;
-import com.koushikdutta.ion.builder.ImageViewBuilder;
 import com.koushikdutta.ion.builder.ImageViewFutureBuilder;
 
+import java.io.File;
 import java.lang.ref.WeakReference;
 import java.util.ArrayList;
 
@@ -60,7 +58,7 @@
     int resizeHeight;
     boolean disableFadeIn;
     boolean animateGif = true;
-
+    boolean mipmap;
 
     void reset() {
         placeholderDrawable = null;
@@ -80,6 +78,7 @@ void reset() {
         disableFadeIn = false;
         animateGif = true;
         builder = null;
+        mipmap = false;
     }
 
     public IonBitmapRequestBuilder(IonRequestBuilder builder) {
@@ -137,34 +136,17 @@ public IonBitmapRequestBuilder transform(Transform transform) {
         return this;
     }
 
-    boolean fastLoad(final String downloadKey, boolean put) {
-        for (Loader loader: ion.configure().getLoaders()) {
-            Future<BitmapInfo> future = loader.loadBitmap(ion, builder.uri, resizeWidth, resizeHeight);
-            if (future != null) {
-                final BitmapCallback callback = new BitmapCallback(ion, downloadKey, put);
-                future.setCallback(new FutureCallback<BitmapInfo>() {
-                    @Override
-                    public void onCompleted(Exception e, BitmapInfo result) {
-                        if (result != null)
-                            result.key = downloadKey;
-                        callback.report(e, result);
-                    }
-                });
-                return true;
-            }
-        }
-        return false;
-    }
-
     private String computeDownloadKey() {
         String downloadKey = builder.uri;
         // although a gif is always same download, the initial decode is different
         if (!animateGif)
             downloadKey += ":!animateGif";
+        if (mipmap)
+            downloadKey += ":mipmap";
         return ResponseCacheMiddleware.toKeyString(downloadKey);
     }
 
-    Pair<String, BitmapInfo> execute() {
+    BitmapFetcher executeCache() {
         final String downloadKey = computeDownloadKey();
         assert Thread.currentThread() == Looper.getMainLooper().getThread() || imageViewPostRef == null;
         assert downloadKey != null;
@@ -183,64 +165,84 @@ private String computeDownloadKey() {
             bitmapKey = ResponseCacheMiddleware.toKeyString(bitmapKey);
         }
 
+        BitmapFetcher ret = new BitmapFetcher();
+        ret.downloadKey = downloadKey;
+        ret.bitmapKey = bitmapKey;
+        ret.hasTransforms = hasTransforms;
+        ret.resizeWidth = resizeWidth;
+        ret.resizeHeight = resizeHeight;
+        ret.builder = builder;
+        ret.transforms = transforms;
+        ret.animateGif = animateGif;
+
         // see if this request can be fulfilled from the cache
         if (!builder.noCache) {
             BitmapInfo bitmap = builder.ion.bitmapCache.get(bitmapKey);
-            if (bitmap != null)
-                return new Pair<String, BitmapInfo>(bitmapKey, bitmap);
+            if (bitmap != null) {
+                ret.info = bitmap;
+                return ret;
+            }
         }
 
-        Pair<String, BitmapInfo> ret = new Pair<String, BitmapInfo>(bitmapKey, null);
+        return ret;
+    }
 
-        // bitmaps that were transformed are put into the DiskLruCache to prevent
-        // subsequent retransformation. See if we can retrieve the bitmap from the disk cache.
-        // See BitmapToBitmapInfo for where the cache is populated.
-        DiskLruCache diskLruCache = ion.responseCache.getDiskLruCache();
-        if (!builder.noCache && hasTransforms && diskLruCache.containsKey(bitmapKey)) {
-            BitmapToBitmapInfo.getBitmapSnapshot(ion, bitmapKey);
-            return ret;
-        }
+    Future<ImageView> executeMipmap(ImageView imageView) {
+        final String downloadKey = computeDownloadKey();
 
-        // Perform a download as necessary.
-        if (!ion.bitmapsPending.contains(downloadKey) && !fastLoad(downloadKey, !hasTransforms)) {
-            builder.setHandler(null);
-            // if we cancel, gotta remove any waiters.
-            IonRequestBuilder.EmitterTransform<ByteBufferList> emitterTransform = builder.execute(new ByteBufferListParser(), new Runnable() {
-                @Override
-                public void run() {
-                    AsyncServer.post(Ion.mainHandler, new Runnable() {
-                        @Override
-                        public void run() {
-                            ion.bitmapsPending.remove(downloadKey);
-                        }
-                    });
-                }
-            });
-            emitterTransform.setCallback(new LoadBitmap(ion, downloadKey, !hasTransforms, resizeWidth, resizeHeight, animateGif, emitterTransform));
+        // try to grab the master tile
+        BitmapInfo bitmap = builder.ion.bitmapCache.get(downloadKey);
+        if (bitmap != null) {
+            doAnimation(imageView, null, 0);
+            IonDrawable drawable = setIonDrawable(imageView, bitmap, Loader.LoaderEmitter.LOADED_FROM_MEMORY);
+            drawable.cancel();
+            SimpleFuture<ImageView> imageViewFuture = drawable.getFuture();
+            imageViewFuture.reset();
+            imageViewFuture.setComplete(imageView);
+            return imageViewFuture;
         }
 
-        // if there's a transform, do it
-        if (!hasTransforms)
-            return ret;
+        // see if something is downloading this
+        if (!ion.bitmapsPending.contains(downloadKey)) {
+            final LoadMipmap loadMipmap = new LoadMipmap(ion, downloadKey);
+            // nothing downloading, see if a file already exists
+            DiskLruCache diskLruCache = ion.responseCache.getDiskLruCache();
+            File file = diskLruCache.getFile(downloadKey, 0);
+            if (diskLruCache.containsKey(downloadKey)) {
+                if (file != null && file.exists()) {
+                    loadMipmap.onCompleted(null, file);
+                    IonDrawable drawable = setIonDrawable(imageView, null, 0);
+                    doAnimation(imageView, loadAnimation, loadAnimationResource);
+                    SimpleFuture<ImageView> imageViewFuture = drawable.getFuture();
+                    imageViewFuture.reset();
+                    drawable.register(ion, downloadKey);
+                    return imageViewFuture;
+                }
+            }
 
-        // verify this transform isn't already pending
-        // make sure that the parent download isn't cancelled (empty list)
-        // and also make sure there are waiters for this transformed bitmap
-        if (!ion.bitmapsPending.contains(downloadKey) || !ion.bitmapsPending.contains(bitmapKey)) {
-            ion.bitmapsPending.add(downloadKey, new BitmapToBitmapInfo(ion, bitmapKey, downloadKey, transforms));
+            // ok, now we gotta download it.
+            builder.setHandler(null);
+            builder.write(file)
+            .setCallback(loadMipmap);
         }
 
-        return ret;
+        IonDrawable drawable = setIonDrawable(imageView, null, 0);
+        doAnimation(imageView, loadAnimation, loadAnimationResource);
+        SimpleFuture<ImageView> imageViewFuture = drawable.getFuture();
+        imageViewFuture.reset();
+        drawable.register(ion, downloadKey);
+        return imageViewFuture;
     }
 
     private IonDrawable setIonDrawable(ImageView imageView, BitmapInfo info, int loadedFrom) {
-        IonDrawable ret = IonDrawable.getOrCreateIonDrawable(imageView);
-        ret.setBitmap(info, loadedFrom);
-        ret.setSize(resizeWidth, resizeHeight);
-        ret.setError(errorResource, errorDrawable);
-        ret.setPlaceholder(placeholderResource, placeholderDrawable);
-        ret.setInAnimation(inAnimation, inAnimationResource);
-        ret.setDisableFadeIn(disableFadeIn);
+        IonDrawable ret = IonDrawable.getOrCreateIonDrawable(imageView)
+        .setMipmap(mipmap)
+        .setBitmap(info, loadedFrom)
+        .setSize(resizeWidth, resizeHeight)
+        .setError(errorResource, errorDrawable)
+        .setPlaceholder(placeholderResource, placeholderDrawable)
+        .setInAnimation(inAnimation, inAnimationResource)
+        .setDisableFadeIn(disableFadeIn);
         imageView.setImageDrawable(ret);
         return ret;
     }
@@ -257,11 +259,17 @@ private IonDrawable setIonDrawable(ImageView imageView, BitmapInfo info, int loa
             return FUTURE_IMAGEVIEW_NULL_URI;
         }
 
-        // execute the request, see if we get a bitmap from cache.
-        Pair<String, BitmapInfo> pair = execute();
-        if (pair.second != null) {
+        // if we're mip mapping this image, let's download the image to a file first
+        // then we'll talk.
+        if (mipmap) {
+            return executeMipmap(imageView);
+        }
+
+        // executeCache the request, see if we get a bitmap from cache.
+        BitmapFetcher bitmapFetcher = executeCache();
+        if (bitmapFetcher.info != null) {
             doAnimation(imageView, null, 0);
-            IonDrawable drawable = setIonDrawable(imageView, pair.second, Loader.LoaderEmitter.LOADED_FROM_MEMORY);
+            IonDrawable drawable = setIonDrawable(imageView, bitmapFetcher.info, Loader.LoaderEmitter.LOADED_FROM_MEMORY);
             drawable.cancel();
             SimpleFuture<ImageView> imageViewFuture = drawable.getFuture();
             imageViewFuture.reset();
@@ -269,35 +277,44 @@ private IonDrawable setIonDrawable(ImageView imageView, BitmapInfo info, int loa
             return imageViewFuture;
         }
 
+        // nothing from cache, check to see if there's too many imageview loads
+        // already in progress
+        if (BitmapFetcher.shouldDeferImageView(ion)) {
+            bitmapFetcher.executeDeferred();
+        }
+        else {
+            bitmapFetcher.executeNetwork();
+        }
+
         IonDrawable drawable = setIonDrawable(imageView, null, 0);
         doAnimation(imageView, loadAnimation, loadAnimationResource);
         SimpleFuture<ImageView> imageViewFuture = drawable.getFuture();
         imageViewFuture.reset();
 
-        drawable.register(ion, pair.first);
+        drawable.register(ion, bitmapFetcher.bitmapKey);
 
         return imageViewFuture;
     }
 
     @Override
     public Future<Bitmap> asBitmap() {
-        // no uri? just set a placeholder and bail
         if (builder.uri == null) {
             return FUTURE_BITMAP_NULL_URI;
         }
 
         // see if we get something back synchronously
-        Pair<String, BitmapInfo> pair = execute();
-        if (pair.second != null) {
+        BitmapFetcher bitmapFetcher = executeCache();
+        if (bitmapFetcher.info != null) {
             SimpleFuture<Bitmap> ret = new SimpleFuture<Bitmap>();
-            Bitmap bitmap = pair.second.bitmaps == null ? null : pair.second.bitmaps[0];
-            ret.setComplete(pair.second.exception, bitmap);
+            Bitmap bitmap = bitmapFetcher.info.bitmaps == null ? null : bitmapFetcher.info.bitmaps[0];
+            ret.setComplete(bitmapFetcher.info.exception, bitmap);
             return ret;
         }
 
+        bitmapFetcher.executeNetwork();
         // we're loading, so let's register for the result.
         BitmapInfoToBitmap ret = new BitmapInfoToBitmap(builder.context);
-        ion.bitmapsPending.add(pair.first, ret);
+        ion.bitmapsPending.add(bitmapFetcher.bitmapKey, ret);
         return ret;
     }
 
@@ -369,8 +386,6 @@ public IonBitmapRequestBuilder centerInside() {
     public IonBitmapRequestBuilder resize(int width, int height) {
         resizeWidth = width;
         resizeHeight = height;
-        ensureBuilder().setHeader("X-Ion-Width", String.valueOf(width));
-        ensureBuilder().setHeader("X-Ion-Height", String.valueOf(height));
         return this;
     }
 
@@ -402,23 +417,13 @@ public IonBitmapRequestBuilder animateGif(boolean animateGif) {
         return this;
     }
 
-    private static class BitmapInfoToBitmap extends TransformFuture<Bitmap, BitmapInfo> {
-        WeakReference<Context> context;
-        public BitmapInfoToBitmap(WeakReference<Context> context) {
-            this.context = context;
-        }
-
-        @Override
-        protected void transform(BitmapInfo result) throws Exception {
-            if (!IonRequestBuilder.checkContext(context)) {
-                cancel();
-                return;
-            }
-
-            if (result.exception != null)
-                setComplete(result.exception);
-            else
-                setComplete(result.bitmaps[0]);
-        }
+    @Override
+    public IonBitmapRequestBuilder mipmap() {
+        if (resizeWidth > 0 || resizeHeight > 0)
+            throw new IllegalStateException("Can't mipmap after resize has been called.");
+        mipmap = true;
+        resizeWidth = 0;
+        resizeHeight = 0;
+        return this;
     }
 }
diff --git a/ion/src/com/koushikdutta/ion/IonDrawable.java b/ion/src/com/koushikdutta/ion/IonDrawable.java
index be573749..870a4f20 100644
--- a/ion/src/com/koushikdutta/ion/IonDrawable.java
+++ b/ion/src/com/koushikdutta/ion/IonDrawable.java
@@ -35,6 +35,7 @@
     private boolean disableFadeIn;
     private int resizeWidth;
     private int resizeHeight;
+    private boolean mipmap;
 
     public IonDrawable cancel() {
         requestCount++;
@@ -45,13 +46,15 @@ public IonDrawable cancel() {
         return callback.imageViewFuture;
     }
     
-    public void setDisableFadeIn(boolean disableFadeIn) {
+    public IonDrawable setDisableFadeIn(boolean disableFadeIn) {
         this.disableFadeIn = disableFadeIn;
+        return this;
     }
 
-    public void setInAnimation(Animation inAnimation, int inAnimationResource) {
+    public IonDrawable setInAnimation(Animation inAnimation, int inAnimationResource) {
         callback.inAnimation = inAnimation;
         callback.inAnimationResource = inAnimationResource;
+        return this;
     }
 
     // create an internal static class that can act as a callback.
@@ -74,7 +77,6 @@ public IonDrawableCallback(IonDrawable drawable, ImageView imageView) {
         public void onCompleted(Exception e, BitmapInfo result) {
             assert Thread.currentThread() == Looper.getMainLooper().getThread();
             assert result != null;
-
             // see if the imageview is still alive and cares about this result
             ImageView imageView = imageViewRef.get();
             if (imageView == null)
@@ -92,6 +94,7 @@ public void onCompleted(Exception e, BitmapInfo result) {
                 return;
 
             drawable.requestCount++;
+
             imageView.setImageDrawable(null);
             drawable.setBitmap(result, result.loadedFrom);
             imageView.setImageDrawable(drawable);
@@ -117,10 +120,27 @@ public void register(Ion ion, String bitmapKey) {
         if (previousKey == null)
             return;
 
+        // unregister this drawable from the bitmaps that are
+        // pending.
         Object owner = ion.bitmapsPending.removeItem(previousKey, callback);
-        if (owner instanceof BitmapToBitmapInfo) {
-            BitmapToBitmapInfo info = (BitmapToBitmapInfo)owner;
-            ion.bitmapsPending.removeItem(info.downloadKey, info);
+
+        // if this drawable was the only thing waiting for this bitmap,
+        // then the removeItem call will return the TransformBitmap/LoadBitmap instance
+        // that was providing the result.
+
+        // cancel/remove the transform
+        if (owner instanceof TransformBitmap) {
+            TransformBitmap info = (TransformBitmap)owner;
+            // this transform is also backed by a LoadBitmap, grab that
+            // if it is the only waiter
+            owner = ion.bitmapsPending.removeItem(info.downloadKey, info);
+        }
+
+        // cancel the load
+        if (owner instanceof LoadBitmap) {
+//            LoadBitmap load = (LoadBitmap)owner;
+//            load.emitterTransform.cancel();
+            BitmapFetcher.processDeferred(ion);
         }
     }
 
@@ -206,8 +226,11 @@ private Drawable tryGetErrorResource() {
 
     @Override
     public int getIntrinsicWidth() {
-        if (info != null && info.bitmaps != null)
-            return info.bitmaps[0].getScaledWidth(resources.getDisplayMetrics().densityDpi);
+        if (info != null && info.bitmaps != null) {
+            if (!mipmap)
+                return info.bitmaps[0].getScaledWidth(resources.getDisplayMetrics().densityDpi);
+            return info.originalSize.x;
+        }
         if (resizeWidth > 0)
             return resizeWidth;
         if (info != null) {
@@ -227,8 +250,11 @@ public int getIntrinsicWidth() {
 
     @Override
     public int getIntrinsicHeight() {
-        if (info != null && info.bitmaps != null)
-            return info.bitmaps[0].getScaledHeight(resources.getDisplayMetrics().densityDpi);
+        if (info != null && info.bitmaps != null) {
+            if (!mipmap)
+                return info.bitmaps[0].getScaledHeight(resources.getDisplayMetrics().densityDpi);
+            return info.originalSize.y;
+        }
         if (resizeHeight > 0)
             return resizeHeight;
         if (info != null) {
@@ -260,6 +286,11 @@ public void run() {
         }
     };
 
+    public IonDrawable setMipmap(boolean mipmap) {
+        this.mipmap = mipmap;
+        return this;
+    }
+
     @Override
     public void draw(Canvas canvas) {
         if (info == null) {
@@ -368,13 +399,10 @@ public int getOpacity() {
     static IonDrawable getOrCreateIonDrawable(ImageView imageView) {
         Drawable current = imageView.getDrawable();
         IonDrawable ret;
-        if (current == null || !(current instanceof IonDrawable)) {
+        if (current == null || !(current instanceof IonDrawable))
             ret = new IonDrawable(imageView.getResources(), imageView);
-            imageView.setImageDrawable(ret);
-        }
-        else {
+        else
             ret = (IonDrawable)current;
-        }
         // invalidate self doesn't seem to trigger the dimension check to be called by imageview.
         // are drawable dimensions supposed to be immutable?
         imageView.setImageDrawable(null);
diff --git a/ion/src/com/koushikdutta/ion/LoadBitmap.java b/ion/src/com/koushikdutta/ion/LoadBitmap.java
index 0133e85a..7819bc44 100644
--- a/ion/src/com/koushikdutta/ion/LoadBitmap.java
+++ b/ion/src/com/koushikdutta/ion/LoadBitmap.java
@@ -1,6 +1,7 @@
 package com.koushikdutta.ion;
 
 import android.graphics.Bitmap;
+import android.graphics.Point;
 import android.os.Looper;
 import android.util.Log;
 
@@ -15,7 +16,7 @@
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 
-class LoadBitmap extends BitmapCallback implements FutureCallback<ByteBufferList> {
+class LoadBitmap extends LoadBitmapBase implements FutureCallback<ByteBufferList> {
     int resizeWidth;
     int resizeHeight;
     IonRequestBuilder.EmitterTransform<ByteBufferList> emitterTransform;
@@ -50,7 +51,6 @@ public void onCompleted(Exception e, final ByteBufferList result) {
         }
 
         if (ion.bitmapsPending.tag(key) != this) {
-//            Log.d("IonBitmapLoader", "Bitmap load cancelled (no longer needed)");
             result.recycle();
             return;
         }
@@ -58,18 +58,26 @@ public void onCompleted(Exception e, final ByteBufferList result) {
         Ion.getBitmapLoadExecutorService().execute(new Runnable() {
             @Override
             public void run() {
+                if (ion.bitmapsPending.tag(key) != LoadBitmap.this) {
+                    result.recycle();
+                    return;
+                }
+
                 ByteBuffer bb = result.getAll();
                 try {
                     Bitmap[] bitmaps;
                     int[] delays;
+                    Point size;
                     if (!isGif()) {
-                        Bitmap bitmap = ion.bitmapCache.loadBitmap(bb.array(), bb.arrayOffset() + bb.position(), bb.remaining(), resizeWidth, resizeHeight);
+                        size = new Point();
+                        Bitmap bitmap = ion.bitmapCache.loadBitmap(bb.array(), bb.arrayOffset() + bb.position(), bb.remaining(), resizeWidth, resizeHeight, size);
                         if (bitmap == null)
-                            throw new Exception("failed to transform bitmap");
+                            throw new Exception("failed to load bitmap");
                         bitmaps = new Bitmap[] { bitmap };
                         delays = null;
                     }
                     else {
+                        size = null;
                         GifDecoder decoder = new GifDecoder(bb.array(), bb.arrayOffset() + bb.position(), bb.remaining(), new GifAction() {
                             @Override
                             public boolean parseOk(boolean parseStatus, int frameIndex) {
@@ -77,19 +85,22 @@ public boolean parseOk(boolean parseStatus, int frameIndex) {
                             }
                         });
                         decoder.run();
+                        if (decoder.getFrameCount() == 0)
+                            throw new Exception("failed to load gif");
                         bitmaps = new Bitmap[decoder.getFrameCount()];
                         delays = decoder.getDelays();
                         for (int i = 0; i < decoder.getFrameCount(); i++) {
                             Bitmap bitmap = decoder.getFrameImage(i);
                             if (bitmap == null)
-                                throw new Exception("failed to transform bitmap");
+                                throw new Exception("failed to load gif frame");
                             bitmaps[i] = bitmap;
+                            if (size == null)
+                                size = new Point(bitmap.getWidth(), bitmap.getHeight());
                         }
                     }
 
-                    BitmapInfo info = new BitmapInfo();
+                    BitmapInfo info = new BitmapInfo(bitmaps, size);
                     info.key = key;
-                    info.bitmaps = bitmaps;
                     info.delays = delays;
                     if (emitterTransform != null)
                         info.loadedFrom = emitterTransform.loadedFrom();
diff --git a/ion/src/com/koushikdutta/ion/LoadBitmapBase.java b/ion/src/com/koushikdutta/ion/LoadBitmapBase.java
new file mode 100644
index 00000000..c6397157
--- /dev/null
+++ b/ion/src/com/koushikdutta/ion/LoadBitmapBase.java
@@ -0,0 +1,10 @@
+package com.koushikdutta.ion;
+
+/**
+ * Created by koush on 1/18/14.
+ */
+public class LoadBitmapBase extends BitmapCallback {
+    public LoadBitmapBase(Ion ion, String key, boolean put)  {
+        super(ion, key, put);
+    }
+}
diff --git a/ion/src/com/koushikdutta/ion/LoadBitmapStream.java b/ion/src/com/koushikdutta/ion/LoadBitmapStream.java
deleted file mode 100644
index a8994e13..00000000
--- a/ion/src/com/koushikdutta/ion/LoadBitmapStream.java
+++ /dev/null
@@ -1,55 +0,0 @@
-package com.koushikdutta.ion;
-
-import android.graphics.Bitmap;
-
-import com.koushikdutta.async.future.Future;
-import com.koushikdutta.async.future.FutureCallback;
-import com.koushikdutta.ion.bitmap.BitmapInfo;
-
-import java.io.InputStream;
-
-class LoadBitmapStream extends BitmapCallback implements FutureCallback<InputStream> {
-    int resizeWidth;
-    int resizeHeight;
-
-    public LoadBitmapStream(Ion ion, String urlKey, boolean put, int resizeWidth, int resizeHeight) {
-        super(ion, urlKey, put);
-        this.resizeWidth = resizeWidth;
-        this.resizeHeight = resizeHeight;
-    }
-
-    public void loadInputStream(InputStream result) {
-        try {
-            Bitmap bitmap = ion.bitmapCache.loadBitmap(result, resizeWidth, resizeHeight);
-
-            if (bitmap == null)
-                throw new Exception("bitmap failed to load");
-
-            BitmapInfo info = new BitmapInfo();
-            info.key = key;
-            info.bitmaps = new Bitmap[] { bitmap };
-            info.loadedFrom = Loader.LoaderEmitter.LOADED_FROM_CACHE;
-
-            report(null, info);
-        } catch (Exception e) {
-            report(e, null);
-        }
-    }
-
-    @Override
-    public void onCompleted(Exception e, final InputStream result) {
-        if (e != null) {
-            report(e, null);
-            return;
-        }
-
-        Ion.getBitmapLoadExecutorService().execute(new Runnable() {
-            @Override
-            public void run() {
-                loadInputStream(result);
-            }
-        });
-    }
-}
-
-    
\ No newline at end of file
diff --git a/ion/src/com/koushikdutta/ion/LoadMipmap.java b/ion/src/com/koushikdutta/ion/LoadMipmap.java
new file mode 100644
index 00000000..f4f95935
--- /dev/null
+++ b/ion/src/com/koushikdutta/ion/LoadMipmap.java
@@ -0,0 +1,38 @@
+package com.koushikdutta.ion;
+
+import com.koushikdutta.async.future.FutureCallback;
+import com.koushikdutta.ion.bitmap.BitmapInfo;
+
+import java.io.File;
+
+/**
+ * Created by koush on 1/5/14.
+ */
+public class LoadMipmap extends BitmapCallback implements FutureCallback<File> {
+    public LoadMipmap(Ion ion, String key) {
+        super(ion, key, true);
+    }
+
+    @Override
+    public void onCompleted(Exception e, File result) {
+        if (e != null) {
+            report(e, null);
+            return;
+        }
+
+        if (ion.bitmapsPending.tag(key) != this) {
+//            Log.d("IonBitmapLoader", "Bitmap load cancelled (no longer needed)");
+            return;
+        }
+
+        ion.configure().getFileLoader().loadBitmap(ion, result.toURI().toString(), 256, 256)
+        .setCallback(new FutureCallback<BitmapInfo>() {
+            @Override
+            public void onCompleted(Exception e, BitmapInfo result) {
+                if (result != null)
+                    result.key = key;
+                report(e, result);
+            }
+        });
+    }
+}
diff --git a/ion/src/com/koushikdutta/ion/Loader.java b/ion/src/com/koushikdutta/ion/Loader.java
index 98da1c84..bd95ea1b 100644
--- a/ion/src/com/koushikdutta/ion/Loader.java
+++ b/ion/src/com/koushikdutta/ion/Loader.java
@@ -48,14 +48,34 @@ public AsyncHttpRequest getRequest() {
         }
     }
 
-    // returns a Future if this loader can handle a request as a stream.
-    // this implies that the stream is essentially non blocking...
-    // ie file or memory based.
+    /**
+     * returns a Future if this loader can handle a request as a stream.
+     * this implies that the stream is essentially non blocking...
+     * ie file or memory based.
+     * @param ion
+     * @param request
+     * @return
+     */
     public Future<InputStream> load(Ion ion, AsyncHttpRequest request);
 
-    // returns a Future if this loader can handle a request
-    // otherwise it returns null, and Ion continues to the next loader.
+    /**
+     * returns a Future if this loader can handle a request
+     * otherwise it returns null, and Ion continues to the next loader.
+     * @param ion
+     * @param request
+     * @param callback
+     * @return
+     */
     public Future<DataEmitter> load(Ion ion, AsyncHttpRequest request, FutureCallback<LoaderEmitter> callback);
 
+    /**
+     * returns a future if the laoder can handle the request as a bitmap
+     * otherwise it returns null
+     * @param ion
+     * @param uri
+     * @param resizeWidth
+     * @param resizeHeight
+     * @return
+     */
     public Future<BitmapInfo> loadBitmap(Ion ion, String uri, int resizeWidth, int resizeHeight);
 }
diff --git a/ion/src/com/koushikdutta/ion/BitmapToBitmapInfo.java b/ion/src/com/koushikdutta/ion/TransformBitmap.java
similarity index 76%
rename from ion/src/com/koushikdutta/ion/BitmapToBitmapInfo.java
rename to ion/src/com/koushikdutta/ion/TransformBitmap.java
index cd225460..2b85d8ea 100644
--- a/ion/src/com/koushikdutta/ion/BitmapToBitmapInfo.java
+++ b/ion/src/com/koushikdutta/ion/TransformBitmap.java
@@ -1,34 +1,33 @@
 package com.koushikdutta.ion;
 
 import android.graphics.Bitmap;
+import android.graphics.Point;
 import android.util.Log;
 
-import com.koushikdutta.async.ByteBufferList;
 import com.koushikdutta.async.future.FutureCallback;
 import com.koushikdutta.async.http.ResponseCacheMiddleware;
 import com.koushikdutta.async.http.libcore.DiskLruCache;
 import com.koushikdutta.ion.bitmap.BitmapInfo;
 import com.koushikdutta.ion.bitmap.Transform;
-import com.koushikdutta.ion.loader.FileLoader;
 
-import java.io.BufferedInputStream;
-import java.io.DataInputStream;
 import java.io.FileInputStream;
 import java.io.InputStream;
 import java.io.OutputStream;
-import java.nio.ByteBuffer;
 import java.util.ArrayList;
 
-class BitmapToBitmapInfo extends BitmapCallback implements FutureCallback<BitmapInfo> {
+class TransformBitmap extends BitmapCallback implements FutureCallback<BitmapInfo> {
     ArrayList<Transform> transforms;
 
     public static void getBitmapSnapshot(final Ion ion, final String transformKey) {
-        final BitmapCallback callback = new BitmapCallback(ion, transformKey, true);
+        // don't do this if this is already loading
+        if (ion.bitmapsPending.tag(transformKey) != null)
+            return;
+        final BitmapCallback callback = new LoadBitmapBase(ion, transformKey, true);
         Ion.getBitmapLoadExecutorService().execute(new Runnable() {
             @Override
             public void run() {
                 if (ion.bitmapsPending.tag(transformKey) != callback) {
-                    Log.d("IonBitmapLoader", "Bitmap cache load cancelled (no longer needed)");
+//                    Log.d("IonBitmapLoader", "Bitmap cache load cancelled (no longer needed)");
                     return;
                 }
 
@@ -37,13 +36,13 @@ public void run() {
                     try {
                         InputStream in = snapshot.getInputStream(0);
                         assert in instanceof FileInputStream;
-                        Bitmap bitmap = ion.getBitmapCache().loadBitmap(in, -1, -1);
+                        Point size = new Point();
+                        Bitmap bitmap = ion.getBitmapCache().loadBitmap(in, -1, -1, size);
                         in.close();
                         if (bitmap == null)
                             throw new Exception("Bitmap failed to load");
 
-                        BitmapInfo info = new BitmapInfo();
-                        info.bitmaps = new Bitmap[] { bitmap };
+                        BitmapInfo info = new BitmapInfo(new Bitmap[] { bitmap }, size);
                         info.loadedFrom =  Loader.LoaderEmitter.LOADED_FROM_CACHE;
                         info.key = transformKey;
                         callback.report(null, info);
@@ -66,7 +65,7 @@ public void run() {
     }
 
     String downloadKey;
-    public BitmapToBitmapInfo(Ion ion, String transformKey, String downloadKey, ArrayList<Transform> transforms) {
+    public TransformBitmap(Ion ion, String transformKey, String downloadKey, ArrayList<Transform> transforms) {
         super(ion, transformKey, true);
         this.transforms = transforms;
         this.downloadKey = downloadKey;
@@ -80,24 +79,33 @@ public void onCompleted(Exception e, final BitmapInfo result) {
         }
 
         if (ion.bitmapsPending.tag(key) != this) {
-            Log.d("IonBitmapLoader", "Bitmap transform cancelled (no longer needed)");
+//            Log.d("IonBitmapLoader", "Bitmap transform cancelled (no longer needed)");
             return;
         }
 
         Ion.getBitmapLoadExecutorService().execute(new Runnable() {
             @Override
             public void run() {
-                BitmapInfo info = new BitmapInfo();
-                info.bitmaps = new Bitmap[result.bitmaps.length];
+                if (ion.bitmapsPending.tag(key) != TransformBitmap.this) {
+//            Log.d("IonBitmapLoader", "Bitmap transform cancelled (no longer needed)");
+                    return;
+                }
+
+                BitmapInfo info;
                 try {
+                    Point size = null;
+                    Bitmap bitmaps[] = new Bitmap[result.bitmaps.length];
                     for (int i = 0; i < result.bitmaps.length; i++) {
                         for (Transform transform : transforms) {
                             Bitmap bitmap = transform.transform(result.bitmaps[i]);
                             if (bitmap == null)
                                 throw new Exception("failed to transform bitmap");
-                            info.bitmaps[i] = bitmap;
+                            bitmaps[i] = bitmap;
+                            if (size == null)
+                                size = new Point(bitmap.getWidth(), bitmap.getHeight());
                         }
                     }
+                    info = new BitmapInfo(bitmaps, size);
                     info.delays = result.delays;
                     info.loadedFrom = result.loadedFrom;
                     info.key = key;
@@ -135,7 +143,8 @@ public void run() {
                     } catch (Exception ex) {
                         editor.abort();
                     }
-                } catch (Exception e) {
+                }
+                catch (Exception e) {
                 }
             }
         });
diff --git a/ion/src/com/koushikdutta/ion/bitmap/BitmapInfo.java b/ion/src/com/koushikdutta/ion/bitmap/BitmapInfo.java
index c0eb8ac4..484f66ec 100644
--- a/ion/src/com/koushikdutta/ion/bitmap/BitmapInfo.java
+++ b/ion/src/com/koushikdutta/ion/bitmap/BitmapInfo.java
@@ -1,6 +1,7 @@
 package com.koushikdutta.ion.bitmap;
 
 import android.graphics.Bitmap;
+import android.graphics.Point;
 
 import java.lang.ref.WeakReference;
 
@@ -8,11 +9,17 @@
  * Created by koush on 6/12/13.
  */
 public class BitmapInfo {
+    public BitmapInfo(Bitmap[] bitmaps, Point originalSize) {
+        this.originalSize = originalSize;
+        this.bitmaps = bitmaps;
+    }
+
+    final public Point originalSize;
     public long loadTime = System.currentTimeMillis();
     public long drawTime;
     public String key;
     public int loadedFrom;
-    public Bitmap[] bitmaps;
+    final public Bitmap[] bitmaps;
     public int[] delays;
     public Exception exception;
 
diff --git a/ion/src/com/koushikdutta/ion/bitmap/GifBitmapInfo.java b/ion/src/com/koushikdutta/ion/bitmap/GifBitmapInfo.java
deleted file mode 100644
index deac6343..00000000
--- a/ion/src/com/koushikdutta/ion/bitmap/GifBitmapInfo.java
+++ /dev/null
@@ -1,10 +0,0 @@
-package com.koushikdutta.ion.bitmap;
-
-import android.graphics.Bitmap;
-
-/**
- * Created by koush on 10/21/13.
- */
-public class GifBitmapInfo extends BitmapInfo {
-
-}
diff --git a/ion/src/com/koushikdutta/ion/bitmap/IonBitmapCache.java b/ion/src/com/koushikdutta/ion/bitmap/IonBitmapCache.java
index b2035f4d..bd2359e0 100644
--- a/ion/src/com/koushikdutta/ion/bitmap/IonBitmapCache.java
+++ b/ion/src/com/koushikdutta/ion/bitmap/IonBitmapCache.java
@@ -112,15 +112,18 @@ private Point computeTarget(int minx, int miny) {
         return new Point(targetWidth, targetHeight);
     }
 
-    public Bitmap loadBitmap(byte[] bytes, int offset, int length, int minx, int miny) {
+    public Bitmap loadBitmap(byte[] bytes, int offset, int length, int minx, int miny, Point outSize) {
         assert Thread.currentThread() != Looper.getMainLooper().getThread();
         Point target = computeTarget(minx, miny);
 
-        BitmapFactory.Options o = null;
+        boolean decodedBounds = false;
+        BitmapFactory.Options o = new BitmapFactory.Options();
         if (target.x != Integer.MAX_VALUE || target.y != Integer.MAX_VALUE) {
-            o = new BitmapFactory.Options();
+            decodedBounds = true;
             o.inJustDecodeBounds = true;
             BitmapFactory.decodeByteArray(bytes, offset, length, o);
+            outSize.x = o.outWidth;
+            outSize.y = o.outHeight;
             if (o.outWidth < 0 || o.outHeight < 0)
                 return null;
             int scale = Math.max(o.outWidth / target.x, o.outHeight / target.y);
@@ -129,6 +132,10 @@ public Bitmap loadBitmap(byte[] bytes, int offset, int length, int minx, int min
         }
 
         Bitmap bitmap = BitmapFactory.decodeByteArray(bytes, offset, length, o);
+        if (!decodedBounds) {
+            outSize.x = o.outWidth;
+            outSize.y = o.outHeight;
+        }
         if (bitmap == null)
             return null;
 
@@ -141,7 +148,7 @@ public Bitmap loadBitmap(byte[] bytes, int offset, int length, int minx, int min
         return Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(), bitmap.getHeight(), matrix, true);
     }
 
-    public Bitmap loadBitmap(InputStream stream, int minx, int miny) {
+    public Bitmap loadBitmap(InputStream stream, int minx, int miny, Point outSize) {
         stream = new BufferedInputStream(stream, 64 * 1024);
         assert Thread.currentThread() != Looper.getMainLooper().getThread();
         Point target = computeTarget(minx, miny);
@@ -158,12 +165,15 @@ public Bitmap loadBitmap(InputStream stream, int minx, int miny) {
             rotation = 0;
         }
 
-        BitmapFactory.Options o = null;
+        boolean decodedBounds = false;
+        BitmapFactory.Options o = new BitmapFactory.Options();
         if (target.x != Integer.MAX_VALUE || target.y != Integer.MAX_VALUE) {
-            o = new BitmapFactory.Options();
+            decodedBounds = true;
             o.inJustDecodeBounds = true;
             stream.mark(Integer.MAX_VALUE);
             BitmapFactory.decodeStream(stream, null, o);
+            outSize.x = o.outWidth;
+            outSize.y = o.outHeight;
             if (o.outWidth < 0 || o.outHeight < 0)
                 return null;
             try {
@@ -178,6 +188,10 @@ public Bitmap loadBitmap(InputStream stream, int minx, int miny) {
         }
 
         Bitmap bitmap = BitmapFactory.decodeStream(stream, null, o);
+        if (!decodedBounds) {
+            outSize.x = o.outWidth;
+            outSize.y = o.outHeight;
+        }
         if (bitmap == null)
             return null;
 
diff --git a/ion/src/com/koushikdutta/ion/builder/ImageViewBuilder.java b/ion/src/com/koushikdutta/ion/builder/ImageViewBuilder.java
index 16a5f40c..df97d2b1 100644
--- a/ion/src/com/koushikdutta/ion/builder/ImageViewBuilder.java
+++ b/ion/src/com/koushikdutta/ion/builder/ImageViewBuilder.java
@@ -84,4 +84,13 @@
      * @return
      */
     public I animateGif(boolean animateGif);
+
+    /**
+     * Load the image view as a mipmap image. This allows extremely large images
+     * to be loaded, at full fidelity. Only portions of the image will be decoded,
+     * on an as needed basis when rendering.
+     * This only works on API level 10+, where BitmapRegionDecoder is available.
+     * @return
+     */
+    public I mipmap();
 }
diff --git a/ion/src/com/koushikdutta/ion/loader/FileLoader.java b/ion/src/com/koushikdutta/ion/loader/FileLoader.java
index 450556db..a8dd25ec 100644
--- a/ion/src/com/koushikdutta/ion/loader/FileLoader.java
+++ b/ion/src/com/koushikdutta/ion/loader/FileLoader.java
@@ -1,6 +1,7 @@
 package com.koushikdutta.ion.loader;
 
 import android.graphics.Bitmap;
+import android.graphics.Point;
 import android.util.Log;
 
 import com.koushikdutta.async.DataEmitter;
@@ -43,11 +44,11 @@ public void run() {
                 }
                 try {
                     FileInputStream fin = new FileInputStream(new File(URI.create(uri)));
-                    Bitmap bitmap = ion.getBitmapCache().loadBitmap(fin, resizeWidth, resizeHeight);
+                    Point size = new Point();
+                    Bitmap bitmap = ion.getBitmapCache().loadBitmap(fin, resizeWidth, resizeHeight, size);
                     if (bitmap == null)
                         throw new Exception("Bitmap failed to load");
-                    BitmapInfo info = new BitmapInfo();
-                    info.bitmaps = new Bitmap[] { bitmap };
+                    BitmapInfo info = new BitmapInfo(new Bitmap[] { bitmap }, size);
                     info.loadedFrom =  Loader.LoaderEmitter.LOADED_FROM_CACHE;
                     fin.close();
                     ret.setComplete(info);
@@ -94,7 +95,7 @@ public void run() {
                 File file = new File(request.getUri());
                 FileDataEmitter emitter = new FileDataEmitter(ion.getHttpClient().getServer(), file);
                 ret.setComplete(emitter);
-                callback.onCompleted(null, new LoaderEmitter(emitter, (int)file.length(), LoaderEmitter.LOADED_FROM_CACHE, null, null));
+                callback.onCompleted(null, new LoaderEmitter(emitter, (int)file.length(), LoaderEmitter.LOADED_FROM_CACHE, null, request));
             }
         });
         return ret;
diff --git a/ion/src/com/koushikdutta/ion/loader/PackageIconLoader.java b/ion/src/com/koushikdutta/ion/loader/PackageIconLoader.java
index 147d0b3a..c43d7785 100644
--- a/ion/src/com/koushikdutta/ion/loader/PackageIconLoader.java
+++ b/ion/src/com/koushikdutta/ion/loader/PackageIconLoader.java
@@ -3,6 +3,7 @@
 
 import android.content.pm.PackageManager;
 import android.graphics.Bitmap;
+import android.graphics.Point;
 import android.graphics.drawable.BitmapDrawable;
 
 import com.koushikdutta.async.future.Future;
@@ -33,8 +34,7 @@ public void run() {
                     Bitmap bmp = ((BitmapDrawable)pm.getPackageInfo(pkg, 0).applicationInfo.loadIcon(pm)).getBitmap();
                     if (bmp == null)
                         throw new Exception("package icon failed to load");
-                    BitmapInfo info = new BitmapInfo();
-                    info.bitmaps = new Bitmap[] { bmp };
+                    BitmapInfo info = new BitmapInfo(new Bitmap[] { bmp }, new Point(bmp.getWidth(), bmp.getHeight()));
                     info.loadedFrom =  Loader.LoaderEmitter.LOADED_FROM_CACHE;
                     ret.setComplete(info);
                 }
diff --git a/ion/src/com/koushikdutta/ion/loader/VideoLoader.java b/ion/src/com/koushikdutta/ion/loader/VideoLoader.java
index 1b4ef523..443cb0ee 100644
--- a/ion/src/com/koushikdutta/ion/loader/VideoLoader.java
+++ b/ion/src/com/koushikdutta/ion/loader/VideoLoader.java
@@ -3,6 +3,7 @@
 import android.content.ContentResolver;
 import android.graphics.Bitmap;
 import android.graphics.BitmapFactory;
+import android.graphics.Point;
 import android.os.Build;
 import android.util.Log;
 
@@ -98,8 +99,7 @@ public void run() {
                     Bitmap bmp = createVideoThumbnail(file.getAbsolutePath());
                     if (bmp == null)
                         throw new Exception("video bitmap failed to load");
-                    BitmapInfo info = new BitmapInfo();
-                    info.bitmaps = new Bitmap[] {bmp};
+                    BitmapInfo info = new BitmapInfo(new Bitmap[] { bmp }, new Point(bmp.getWidth(), bmp.getHeight()));
                     info.loadedFrom = LoaderEmitter.LOADED_FROM_CACHE;
                     ret.setComplete(info);
                 } catch (Exception e) {
