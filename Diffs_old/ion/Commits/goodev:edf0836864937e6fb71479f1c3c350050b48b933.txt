diff --git a/ion-sample/project.properties b/ion-sample/project.properties
index bda53d0d..fc12c4df 100644
--- a/ion-sample/project.properties
+++ b/ion-sample/project.properties
@@ -11,6 +11,6 @@
 #proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
 
 # Project target.
-target=android-L
-android.library.reference.1=../../../../AndroidStudio/ion/ion
+target=android-19
+android.library.reference.1=../ion
 
diff --git a/ion-sample/res/layout/image_view.xml b/ion-sample/res/layout/image_view.xml
index 19b16780..8fa3ae3e 100644
--- a/ion-sample/res/layout/image_view.xml
+++ b/ion-sample/res/layout/image_view.xml
@@ -4,7 +4,38 @@
               android:orientation="vertical"
               android:layout_width="match_parent"
               android:layout_height="match_parent">
-
+    <com.koushikdutta.ion.sample.FontTextView
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:text="abcdefghijklmnopqrstuvwxyz"
+            android:id="@+id/image1"
+            />
+    <com.koushikdutta.ion.sample.FontTextView
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:text="abcdefghijklmnopqrstuvwxyz"
+            android:id="@+id/image2"
+            />
+    <com.koushikdutta.ion.sample.FontTextView
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:text="abcdefghijklmnopqrstuvwxyz"
+            android:id="@+id/image3"
+            />
+    <com.koushikdutta.ion.sample.FontTextView
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:text="abcdefghijklmnopqrstuvwxyz"
+            android:id="@+id/image4"
+            />
+    <com.koushikdutta.ion.sample.FontTextView
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:text="abcdefghijklmnopqrstuvwxyz"
+            android:id="@+id/image5"
+            />
+    <!-- 
+     -->
     <Spinner
             android:layout_width="match_parent"
             android:layout_height="wrap_content"
@@ -13,8 +44,9 @@
 
     <ImageView
             android:layout_width="match_parent"
-            android:layout_height="match_parent"
+            android:layout_height="wrap_content"
             android:id="@+id/image"
             />
 
+
 </LinearLayout>
\ No newline at end of file
diff --git a/ion-sample/res/values/ids.xml b/ion-sample/res/values/ids.xml
new file mode 100644
index 00000000..045e125f
--- /dev/null
+++ b/ion-sample/res/values/ids.xml
@@ -0,0 +1,3 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+</resources>
diff --git a/ion-sample/src/com/koushikdutta/ion/sample/FontTextView.java b/ion-sample/src/com/koushikdutta/ion/sample/FontTextView.java
new file mode 100644
index 00000000..f9829ef1
--- /dev/null
+++ b/ion-sample/src/com/koushikdutta/ion/sample/FontTextView.java
@@ -0,0 +1,203 @@
+
+package com.koushikdutta.ion.sample;
+
+import android.content.Context;
+import android.graphics.Typeface;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.Message;
+import android.util.AttributeSet;
+import android.util.Log;
+import android.widget.TextView;
+
+import com.koushikdutta.async.util.StreamUtility;
+import com.koushikdutta.ion.Loader;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.net.URI;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipInputStream;
+
+public class FontTextView extends TextView {
+    public static final String TEST_PRE_URL = "http://upaicdn.xinmei365.com/wfs/2014-06/shijiebeiyulan.zip";
+    public static final String TEST_PRE_NAME = "世界杯字体";
+
+    public FontTextView(Context context) {
+        super(context);
+        mCtx = context.getApplicationContext();
+    }
+
+    public FontTextView(Context context, AttributeSet attrs) {
+        super(context, attrs);
+        mCtx = context.getApplicationContext();
+    }
+
+    public FontTextView(Context context, AttributeSet attrs, int defStyle) {
+        super(context, attrs, defStyle);
+        mCtx = context.getApplicationContext();
+    }
+
+    private static final int LOADING_THREADS = 4;
+    private static ExecutorService threadPool = Executors.newFixedThreadPool(LOADING_THREADS);
+
+//    private DownloadPreviewFontTask currentTask;
+    private Context mCtx;
+    private String mFontUrl;
+
+    public String getFontUrl() {
+        return mFontUrl;
+    }
+
+    public void setFontUrl(String uri) {
+        try {
+            String zipUri = uri;
+            String ttfUri = FontUtils.getTtfFilePath(uri);
+            File file = new File( ttfUri);
+            System.out.println("..... 11"+ ttfUri);
+            if (!file.exists()) {
+                File zipFile = new File( zipUri);
+                ZipInputStream zis = new ZipInputStream(new FileInputStream(zipFile));
+                try {
+                    ZipEntry ze = null;
+                    while ((ze = zis.getNextEntry()) != null) {
+                        if (ze.getName().endsWith(FontUtils.TTF_SUFFIX)) {
+                            FileOutputStream fout = new FileOutputStream(file, false);
+                            try {
+                                for (int c = zis.read(); c != -1; c = zis.read()) {
+                                    fout.write(c);
+                                }
+                                zis.closeEntry();
+                            } finally {
+                                fout.close();
+                            }
+                        }
+                    }
+
+                } catch (Exception e) {
+                    Log.e("FileLoader", "Unzip exception", e);
+                } finally {
+                    StreamUtility.closeQuietly(zis);
+                }
+            }
+            try {
+                Typeface typeface = Typeface.createFromFile(file);
+                setTypeface(typeface);
+            } catch (Exception e) {
+                Log.e("FileLoader", "create typeface from file exception", e);
+                throw new Exception("create typeface from file exception");
+            }
+
+        } catch (OutOfMemoryError e) {
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+    }
+//    public void setFontUrl(String url) {
+//        if(!url.startsWith("http:")) {
+//            try {
+//                Typeface type = Typeface.createFromFile(url);
+//                if(type != null) {
+//                    setTypeface(type);
+//                }
+//            } catch (Exception e) {
+//                e.printStackTrace();
+//            }
+//            return;
+//        }
+//        Typeface typeface = PreviewFontCache.getInstance(mCtx).get(url);
+//        if (typeface != null) {
+//            setTypeface(typeface);
+//            return;
+//        }
+//        mFontUrl = url;
+//        setFont(new PreviewFont(url));
+//    }
+
+//    public void setFont(final PreviewFont image) {
+//        if (currentTask != null) {
+//            currentTask.cancel();
+//            currentTask = null;
+//        }
+//
+//        // Set up the new task
+//        currentTask = new DownloadPreviewFontTask(getContext(), image);
+//        currentTask.setOnCompleteHandler(new DownloadPreviewFontTask.OnCompleteHandler() {
+//            @Override
+//            public void onComplete(Typeface typeface, String filePath) {
+//                if (typeface != null) {
+//                    setTypeface(typeface);
+//                }
+//
+//            }
+//        });
+//        // Run the task in a threadpool
+//        threadPool.execute(currentTask);
+//    }
+
+    public static void cancelAllTasks() {
+        threadPool.shutdownNow();
+        threadPool = Executors.newFixedThreadPool(LOADING_THREADS);
+    }
+
+//    static class DownloadPreviewFontTask implements Runnable {
+//        private static final int FONT_READY = 0;
+//
+//        private boolean cancelled = false;
+//        private OnCompleteHandler onCompleteHandler;
+//        private PreviewFont font;
+//        private Context context;
+//
+//        public static class OnCompleteHandler extends Handler {
+//            @Override
+//            public void handleMessage(Message msg) {
+//                Typeface typeface = (Typeface) msg.obj;
+//                Bundle bundle = msg.getData();
+//                onComplete(typeface, bundle.getString("cachePath"));
+//            }
+//
+//            public void onComplete(Typeface typeface, String filePath) {
+//            };
+//        }
+//
+//        public abstract static class OnCompleteListener {
+//            public abstract void onComplete(String cachePath);
+//        }
+//
+//        public DownloadPreviewFontTask(Context context, PreviewFont font) {
+//            this.font = font;
+//            this.context = context;
+//        }
+//
+//        @Override
+//        public void run() {
+//            if (font != null) {
+//                complete(font.getTypeface(context));
+//                context = null;
+//            }
+//        }
+//
+//        public void setOnCompleteHandler(OnCompleteHandler handler) {
+//            this.onCompleteHandler = handler;
+//        }
+//
+//        public void cancel() {
+//            cancelled = true;
+//        }
+//
+//        public void complete(Typeface typeface) {
+//            if (onCompleteHandler != null && !cancelled) {
+//                Message msg = onCompleteHandler.obtainMessage(FONT_READY, typeface);
+//                Bundle bundle = new Bundle();
+//                bundle.putString("cachePath", font.getCachePath());
+//                msg.setData(bundle);
+//                onCompleteHandler.sendMessage(msg);
+//            }
+//        }
+//
+//    }
+
+}
diff --git a/ion-sample/src/com/koushikdutta/ion/sample/FontUtils.java b/ion-sample/src/com/koushikdutta/ion/sample/FontUtils.java
new file mode 100644
index 00000000..be8f2649
--- /dev/null
+++ b/ion-sample/src/com/koushikdutta/ion/sample/FontUtils.java
@@ -0,0 +1,19 @@
+package com.koushikdutta.ion.sample;
+
+public class FontUtils {
+
+    
+    public static final String ZIP_SUFFIX = ".zip";
+    public static final String TTF_SUFFIX = ".ttf";
+
+    public static boolean isZipFile(String path) {
+        return path != null && path.endsWith(ZIP_SUFFIX);
+    }
+    public static boolean isTtfFile(String path) {
+        return path != null && path.endsWith(TTF_SUFFIX);
+    }
+    
+    public static String getTtfFilePath(String path) {
+        return path.replace(ZIP_SUFFIX, TTF_SUFFIX);
+    }
+}
diff --git a/ion-sample/src/com/koushikdutta/ion/sample/ImageViewSample.java b/ion-sample/src/com/koushikdutta/ion/sample/ImageViewSample.java
index c6f6bacc..ab4ecf2a 100644
--- a/ion-sample/src/com/koushikdutta/ion/sample/ImageViewSample.java
+++ b/ion-sample/src/com/koushikdutta/ion/sample/ImageViewSample.java
@@ -1,15 +1,20 @@
 package com.koushikdutta.ion.sample;
 
 import android.app.Activity;
+import android.graphics.Typeface;
 import android.os.Bundle;
+import android.util.Log;
 import android.view.View;
 import android.widget.AdapterView;
 import android.widget.ArrayAdapter;
 import android.widget.ImageView;
 import android.widget.Spinner;
 
+import com.koushikdutta.async.future.FutureCallback;
 import com.koushikdutta.ion.Ion;
 
+import java.io.File;
+
 /**
  * Created by koush on 6/9/13.
  */
@@ -62,22 +67,76 @@ public void loadGifResource() {
     public void loadExifRotated() {
         Ion.with(this)
         .load("https://raw.github.com/koush/ion/master/ion-test/testdata/exif.jpg")
-        .intoImageView(imageView);
+        .intoImageView(imageView)
+        ;
     }
 
     public void loadTwitterResource() {
         Ion.with(this)
         .load("android.resource://" + getPackageName() + "/drawable/twitter")
-        .intoImageView(imageView);
+        .intoImageView(imageView)
+        ;
+    }
+    
+    public void loadText(int id) {
+        String uri = "http://ftp.jaist.ac.jp/pub/sourceforge/a/ab/abucket/pre/ee79ac74bc5b0d19175d1d992bcf12aa.zip";
+        String uri2 = "http://ftp.jaist.ac.jp/pub/sourceforge/a/ab/abucket/pre/05c3164d5c6bdceb7b249f0e1771ed00.zip";
+        String uri3 = "http://ftp.jaist.ac.jp/pub/sourceforge/a/ab/abucket/pre/fb3c1efba20a0c7e406978370d7136fd.zip";
+        String uri4 = "http://ftp.jaist.ac.jp/pub/sourceforge/a/ab/abucket/pre/45cc032eadf858058698731ea5ae6412.zip";
+        String uri5 = "http://ftp.jaist.ac.jp/pub/sourceforge/a/ab/abucket/pre/d16ff0a5446b360ade089b1e23798c2c.zip";
+        Ion.with(this)
+        .load(uri)
+        .addHeader("Connection", "close")
+        .setLogging("tf", Log.VERBOSE)
+        .withTypeface()
+        .intoTextView(textView);
+        
+        Ion.with(this)
+        .load(uri2)
+        .addHeader("Connection", "close")
+        .setLogging("tf", Log.VERBOSE)
+        .withTypeface()
+        .intoTextView(textView2);
+        
+        Ion.with(this)
+        .load(uri3)
+        .addHeader("Connection", "close")
+        .setLogging("tf", Log.VERBOSE)
+        .withTypeface()
+        .intoTextView(textView3);
+        
+        Ion.with(this)
+        .load(uri4)
+        .addHeader("Connection", "close")
+        .setLogging("tf", Log.VERBOSE)
+        .withTypeface()
+        .intoTextView(textView5);
+        
+        Ion.with(this)
+        .load(uri5)
+        .addHeader("Connection", "close")
+        .setLogging("tf", Log.VERBOSE)
+        .withTypeface()
+        .intoTextView(textView4);
     }
 
     Spinner fitChoices;
     ImageView imageView;
+    FontTextView textView;
+    FontTextView textView2;
+    FontTextView textView3;
+    FontTextView textView4;
+    FontTextView textView5;
     @Override
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.image_view);
 
+        textView = (FontTextView) findViewById(R.id.image1);
+        textView2 = (FontTextView) findViewById(R.id.image2);
+        textView3 = (FontTextView) findViewById(R.id.image3);
+        textView4 = (FontTextView) findViewById(R.id.image4);
+        textView5 = (FontTextView) findViewById(R.id.image5);
         imageView = (ImageView)findViewById(R.id.image);
         fitChoices = (Spinner)findViewById(R.id.fit_choices);
 
@@ -93,20 +152,22 @@ protected void onCreate(Bundle savedInstanceState) {
         fitChoices.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {
             @Override
             public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
-                if (position == 0)
-                    loadCenterCrop();
-                else if (position == 1)
-                    loadCenterInside();
-                else if (position == 2)
-                    loadGifCenterCrop();
-                else if (position == 3)
-                    loadGifCenterInside();
-                else if (position == 4)
-                    loadGifResource();
-                else if (position == 5)
-                    loadExifRotated();
-                else if (position == 6)
-                    loadTwitterResource();
+//                if (position == 0)
+//                    loadCenterCrop();
+//                else if (position == 1)
+//                    loadCenterInside();
+//                else if (position == 2)
+//                    loadGifCenterCrop();
+//                else if (position == 3)
+//                    loadGifCenterInside();
+//                else if (position == 4)
+//                    loadGifResource();
+//                else if (position == 5)
+//                    loadExifRotated();
+//                else if (position == 6)
+//                    loadTwitterResource();
+                
+                loadText(1);
             }
 
             @Override
diff --git a/ion/AndroidManifest.xml b/ion/AndroidManifest.xml
index 06c6d3b8..6dc65337 100644
--- a/ion/AndroidManifest.xml
+++ b/ion/AndroidManifest.xml
@@ -5,6 +5,7 @@
           android:versionCode="138"
           android:versionName="1.3.8">
     <uses-sdk
+        android:minSdkVersion="11"
             tools:node="replace" />
     <application />
 </manifest>
diff --git a/ion/res/values/ids.xml b/ion/res/values/ids.xml
new file mode 100644
index 00000000..acaa0115
--- /dev/null
+++ b/ion/res/values/ids.xml
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <item type="id" name="font_key"></item>
+</resources>
diff --git a/ion/src/com/koushikdutta/ion/ContextReference.java b/ion/src/com/koushikdutta/ion/ContextReference.java
index 8d60d823..ee435e49 100644
--- a/ion/src/com/koushikdutta/ion/ContextReference.java
+++ b/ion/src/com/koushikdutta/ion/ContextReference.java
@@ -8,6 +8,7 @@
 import android.content.Context;
 import android.os.Build;
 import android.widget.ImageView;
+import android.widget.TextView;
 
 import java.lang.ref.WeakReference;
 import java.util.List;
@@ -15,7 +16,7 @@
 /**
  * Created by koush on 4/15/14.
  */
-abstract class ContextReference<T> extends WeakReference<T> {
+public abstract class ContextReference<T> extends WeakReference<T> {
     ContextReference(T t) {
         super(t);
     }
@@ -139,6 +140,27 @@ public String isAlive() {
         }
     }
 
+    public static class TextViewContextReference extends ContextReference<TextView> {
+        public TextViewContextReference(TextView textView) {
+            super(textView);
+        }
+        
+        @Override
+        public String isAlive() {
+            TextView iv = get();
+            if (iv == null)
+                return "TextView reference null";
+            return NormalContextReference.isAlive(iv.getContext());
+        }
+        
+        @Override
+        public Context getContext() {
+            TextView iv = get();
+            if (iv == null)
+                return null;
+            return iv.getContext();
+        }
+    }
     static class ImageViewContextReference extends ContextReference<ImageView> {
         public ImageViewContextReference(ImageView imageView) {
             super(imageView);
diff --git a/ion/src/com/koushikdutta/ion/Ion.java b/ion/src/com/koushikdutta/ion/Ion.java
index 05a616a3..927f0294 100644
--- a/ion/src/com/koushikdutta/ion/Ion.java
+++ b/ion/src/com/koushikdutta/ion/Ion.java
@@ -29,6 +29,10 @@
 import com.koushikdutta.ion.builder.LoadBuilder;
 import com.koushikdutta.ion.conscrypt.ConscryptMiddleware;
 import com.koushikdutta.ion.cookie.CookieMiddleware;
+import com.koushikdutta.ion.font.DeferredLoadTypeface;
+import com.koushikdutta.ion.font.IonTypefaceCache;
+import com.koushikdutta.ion.font.TypefaceFetcher;
+import com.koushikdutta.ion.font.TypefaceInfo;
 import com.koushikdutta.ion.loader.AssetLoader;
 import com.koushikdutta.ion.loader.AsyncHttpRequestFactory;
 import com.koushikdutta.ion.loader.ContentLoader;
@@ -53,7 +57,7 @@
  * Created by koush on 5/21/13.
  */
 public class Ion {
-    static final Handler mainHandler = new Handler(Looper.getMainLooper());
+    public static final Handler mainHandler = new Handler(Looper.getMainLooper());
     static int availableProcessors = Runtime.getRuntime().availableProcessors();
     static ExecutorService ioExecutorService = Executors.newFixedThreadPool(4);
     static ExecutorService bitmapExecutorService  = availableProcessors > 2 ? Executors.newFixedThreadPool(availableProcessors - 1) : Executors.newFixedThreadPool(1);
@@ -163,8 +167,10 @@ public static Ion getInstance(Context context, String name) {
     ArrayList<Loader> loaders = new ArrayList<Loader>();
     String name;
     HashList<FutureCallback<BitmapInfo>> bitmapsPending = new HashList<FutureCallback<BitmapInfo>>();
+    public HashList<FutureCallback<TypefaceInfo>> typefacesPending = new HashList<FutureCallback<TypefaceInfo>>();
     Config config = new Config();
     IonBitmapCache bitmapCache;
+    public IonTypefaceCache typefaceCache;
     Context context;
     IonImageViewRequestBuilder bitmapBuilder = new IonImageViewRequestBuilder(this);
 
@@ -201,6 +207,7 @@ private Ion(Context context, String name) {
         httpClient.getSSLSocketMiddleware().setConnectAllAddresses(true);
 
         bitmapCache = new IonBitmapCache(this);
+        typefaceCache = new IonTypefaceCache(this);
 
         configure()
                 .addLoader(videoLoader = new VideoLoader())
@@ -325,6 +332,45 @@ public void run() {
         }
     };
 
+    private Runnable processTypefaceDeferred = new Runnable() {
+        @Override
+        public void run() {
+            L.d("processTypefaceDeferred ...");
+            if (TypefaceFetcher.shouldDeferTextView(Ion.this))
+                return;
+            L.d("processTypefaceDeferred ... .... 1 ");
+            ArrayList<DeferredLoadTypeface> deferred = null;
+            for (String key: typefacesPending.keySet()) {
+                Object owner = typefacesPending.tag(key);
+                L.d("processTypefaceDeferred ... .... 2 "+owner);
+                if (owner instanceof DeferredLoadTypeface) {
+                    DeferredLoadTypeface deferredLoadBitmap = (DeferredLoadTypeface)owner;
+                    if (deferred == null)
+                        deferred = new ArrayList<DeferredLoadTypeface>();
+                    deferred.add(deferredLoadBitmap);
+                }
+            }
+
+            L.d("processTypefaceDeferred ... .... 3 "+deferred);
+            if (deferred == null)
+                return;
+            int count = 0;
+            for (DeferredLoadTypeface deferredLoadBitmap: deferred) {
+                typefacesPending.tag(deferredLoadBitmap.key, null);
+                typefacesPending.tag(deferredLoadBitmap.fetcher.bitmapKey, null);
+                L.d("processTypefaceDeferred ... .... 4 execute");
+                deferredLoadBitmap.fetcher.execute();
+                count++;
+                // do MAX_IMAGEVIEW_LOAD max. this may end up going over the MAX_IMAGEVIEW_LOAD threshhold
+                if (count > TypefaceFetcher.MAX_TYPEFACE_LOAD)
+                    return;
+            }
+        }
+    };
+    public void processTypefaceDeferred() {
+        mainHandler.removeCallbacks(processTypefaceDeferred);
+        mainHandler.post(processTypefaceDeferred);
+    }
     void processDeferred() {
         mainHandler.removeCallbacks(processDeferred);
         mainHandler.post(processDeferred);
diff --git a/ion/src/com/koushikdutta/ion/IonDrawable.java b/ion/src/com/koushikdutta/ion/IonDrawable.java
index 7b2411b6..3181009f 100644
--- a/ion/src/com/koushikdutta/ion/IonDrawable.java
+++ b/ion/src/com/koushikdutta/ion/IonDrawable.java
@@ -23,7 +23,6 @@
 import com.koushikdutta.async.future.SimpleFuture;
 import com.koushikdutta.async.util.FileCache;
 import com.koushikdutta.ion.bitmap.BitmapInfo;
-import com.koushikdutta.ion.future.ImageViewFuture;
 
 import java.lang.ref.WeakReference;
 
@@ -66,32 +65,32 @@ public BitmapInfo getBitmapInfo() {
         return info;
     }
 
-    public static class ImageViewFutureImpl extends SimpleFuture<ImageView> implements ImageViewFuture {
-        @Override
-        public Future<ImageViewBitmapInfo> withBitmapInfo() {
-            final SimpleFuture<ImageViewBitmapInfo> ret = new SimpleFuture<ImageViewBitmapInfo>();
-            setCallback(new FutureCallback<ImageView>() {
-                @Override
-                public void onCompleted(Exception e, ImageView result) {
-                    ImageViewBitmapInfo val = new ImageViewBitmapInfo();
-                    Drawable d = null;
-                    if (result != null)
-                        d = result.getDrawable();
-                    if (d instanceof IonDrawable) {
-                        IonDrawable id = (IonDrawable)d;
-                        val.info = id.info;
-                    }
-                    val.exception = e;
-                    val.imageView = result;
-                    ret.setComplete(val);
-                }
-            });
-            ret.setParent(this);
-            return ret;
-        }
-    }
-
-    public ImageViewFutureImpl getFuture() {
+//    public static class ImageViewFutureImpl extends SimpleFuture<ImageView> implements ImageViewFuture {
+//        @Override
+//        public Future<ImageViewBitmapInfo> withBitmapInfo() {
+//            final SimpleFuture<ImageViewBitmapInfo> ret = new SimpleFuture<ImageViewBitmapInfo>();
+//            setCallback(new FutureCallback<ImageView>() {
+//                @Override
+//                public void onCompleted(Exception e, ImageView result) {
+//                    ImageViewBitmapInfo val = new ImageViewBitmapInfo();
+//                    Drawable d = null;
+//                    if (result != null)
+//                        d = result.getDrawable();
+//                    if (d instanceof IonDrawable) {
+//                        IonDrawable id = (IonDrawable)d;
+//                        val.info = id.info;
+//                    }
+//                    val.exception = e;
+//                    val.imageView = result;
+//                    ret.setComplete(val);
+//                }
+//            });
+//            ret.setParent(this);
+//            return ret;
+//        }
+//    }
+
+    public SimpleFuture<ImageView> getFuture() {
         return callback.imageViewFuture;
     }
     
@@ -112,7 +111,7 @@ public IonDrawable setInAnimation(Animation inAnimation, int inAnimationResource
         private WeakReference<IonDrawable> ionDrawableRef;
         private ContextReference.ImageViewContextReference imageViewRef;
         private String bitmapKey;
-        private ImageViewFutureImpl imageViewFuture = new ImageViewFutureImpl();
+        private SimpleFuture<ImageView> imageViewFuture = new SimpleFuture<ImageView>();
         private Animation inAnimation;
         private int inAnimationResource;
 
diff --git a/ion/src/com/koushikdutta/ion/IonImageViewRequestBuilder.java b/ion/src/com/koushikdutta/ion/IonImageViewRequestBuilder.java
index 389a8c0b..d49dc493 100644
--- a/ion/src/com/koushikdutta/ion/IonImageViewRequestBuilder.java
+++ b/ion/src/com/koushikdutta/ion/IonImageViewRequestBuilder.java
@@ -9,16 +9,16 @@
 import android.widget.ImageView;
 
 import com.koushikdutta.async.future.Future;
+import com.koushikdutta.async.future.SimpleFuture;
 import com.koushikdutta.ion.bitmap.BitmapInfo;
 import com.koushikdutta.ion.builder.Builders;
 import com.koushikdutta.ion.builder.ImageViewFutureBuilder;
-import com.koushikdutta.ion.future.ImageViewFuture;
 
 /**
  * Created by koush on 7/4/14.
  */
 public class IonImageViewRequestBuilder extends IonBitmapRequestBuilder implements Builders.IV.F, ImageViewFutureBuilder {
-    private static final IonDrawable.ImageViewFutureImpl FUTURE_IMAGEVIEW_NULL_URI = new IonDrawable.ImageViewFutureImpl() {
+    private static final SimpleFuture<ImageView> FUTURE_IMAGEVIEW_NULL_URI = new SimpleFuture<ImageView>() {
         {
             setComplete(new NullPointerException("uri"));
         }
@@ -64,7 +64,7 @@ protected IonRequestBuilder ensureBuilder() {
     }
 
     @Override
-    public ImageViewFuture load(String uri) {
+    public SimpleFuture<ImageView> load(String uri) {
         ensureBuilder();
         builder.load(uri);
         return intoImageView(imageViewPostRef.get());
@@ -96,7 +96,7 @@ private IonDrawable setIonDrawable(ImageView imageView, BitmapInfo info, int loa
     }
 
     @Override
-    public ImageViewFuture intoImageView(ImageView imageView) {
+    public SimpleFuture<ImageView> intoImageView(ImageView imageView) {
         assert Thread.currentThread() == Looper.getMainLooper().getThread();
         if (imageView == null)
             throw new NullPointerException("imageView");
@@ -115,7 +115,7 @@ public ImageViewFuture intoImageView(ImageView imageView) {
             doAnimation(imageView, null, 0);
             IonDrawable drawable = setIonDrawable(imageView, bitmapFetcher.info, Loader.LoaderEmitter.LOADED_FROM_MEMORY);
             drawable.cancel();
-            IonDrawable.ImageViewFutureImpl imageViewFuture = drawable.getFuture();
+            SimpleFuture<ImageView> imageViewFuture = drawable.getFuture();
             imageViewFuture.reset();
             imageViewFuture.setComplete(bitmapFetcher.info.exception, imageView);
             return imageViewFuture;
@@ -123,7 +123,7 @@ public ImageViewFuture intoImageView(ImageView imageView) {
 
         IonDrawable drawable = setIonDrawable(imageView, null, 0);
         doAnimation(imageView, loadAnimation, loadAnimationResource);
-        IonDrawable.ImageViewFutureImpl imageViewFuture = drawable.getFuture();
+        SimpleFuture<ImageView> imageViewFuture = drawable.getFuture();
         imageViewFuture.reset();
         drawable.register(ion, bitmapFetcher.bitmapKey);
 
diff --git a/ion/src/com/koushikdutta/ion/IonRequestBuilder.java b/ion/src/com/koushikdutta/ion/IonRequestBuilder.java
index 361b4a17..1601dff9 100644
--- a/ion/src/com/koushikdutta/ion/IonRequestBuilder.java
+++ b/ion/src/com/koushikdutta/ion/IonRequestBuilder.java
@@ -10,6 +10,7 @@
 import android.util.Log;
 import android.widget.ImageView;
 import android.widget.ProgressBar;
+import android.widget.TextView;
 
 import com.google.gson.JsonArray;
 import com.google.gson.JsonObject;
@@ -54,7 +55,8 @@
 import com.koushikdutta.ion.builder.Builders;
 import com.koushikdutta.ion.builder.FutureBuilder;
 import com.koushikdutta.ion.builder.LoadBuilder;
-import com.koushikdutta.ion.future.ImageViewFuture;
+import com.koushikdutta.ion.font.IonTypefaceRequestBuilder;
+import com.koushikdutta.ion.font.TypefaceFutureBuilder;
 import com.koushikdutta.ion.future.ResponseFuture;
 import com.koushikdutta.ion.gson.GsonArrayParser;
 import com.koushikdutta.ion.gson.GsonBody;
@@ -77,12 +79,12 @@
 /**
  * Created by koush on 5/21/13.
  */
-class IonRequestBuilder implements Builders.Any.B, Builders.Any.F, Builders.Any.M, Builders.Any.U, LoadBuilder<Builders.Any.B> {
-    Ion ion;
-    ContextReference contextReference;
+public class IonRequestBuilder implements Builders.Any.B, Builders.Any.F, Builders.Any.M, Builders.Any.U, LoadBuilder<Builders.Any.B> {
+    public Ion ion;
+    public ContextReference contextReference;
     Handler handler = Ion.mainHandler;
     String method = AsyncHttpGet.METHOD;
-    String uri;
+    public String uri;
 
     public IonRequestBuilder(ContextReference contextReference, Ion ion) {
         String alive = contextReference.isAlive();
@@ -153,7 +155,7 @@ public IonRequestBuilder addHeaders(Map<String, List<String>> params) {
         return this;
     }
 
-    boolean noCache;
+    public boolean noCache;
     @Override
     public Builders.Any.B noCache() {
         noCache = true;
@@ -287,11 +289,11 @@ private AsyncHttpRequest prepareRequest(Uri uri, AsyncHttpRequestBody wrappedBod
         return request;
     }
 
-    static interface LoadRequestCallback {
+    public static interface LoadRequestCallback {
         boolean loadRequest(AsyncHttpRequest request);
     }
 
-    LoadRequestCallback loadRequestCallback;
+    public LoadRequestCallback loadRequestCallback;
 
     private <T> void getLoaderEmitter(final EmitterTransform<T> ret) {
         Uri uri = prepareURI();
@@ -396,7 +398,7 @@ public void run() {
 
     // transforms a LoaderEmitter, which is a DataEmitter and all associated properties about the data source
     // into the final result.
-    class EmitterTransform<T> extends TransformFuture<T, LoaderEmitter> implements ResponseFuture<T> {
+   public class EmitterTransform<T> extends TransformFuture<T, LoaderEmitter> implements ResponseFuture<T> {
         AsyncHttpRequest initialRequest;
         AsyncHttpRequest finalRequest;
         int loadedFrom;
@@ -576,7 +578,7 @@ public IonRequestBuilder progressHandler(ProgressCallback callback) {
     }
 
 
-    <T> EmitterTransform<T> execute(final DataSink sink, final boolean close, final T result, final Runnable cancel) {
+    public <T> EmitterTransform<T> execute(final DataSink sink, final boolean close, final T result, final Runnable cancel) {
         EmitterTransform<T> ret = new EmitterTransform<T>(cancel) {
             @Override
             protected void cleanup() {
@@ -589,6 +591,7 @@ protected void cleanup() {
             @Override
             protected void transform(LoaderEmitter emitter) throws Exception {
                 super.transform(emitter);
+                L.d("transform .....");
                 Util.pump(this.emitter, sink, new CompletedCallback() {
                     @Override
                     public void onCompleted(Exception ex) {
@@ -605,7 +608,7 @@ public void onCompleted(Exception ex) {
         return execute(parser, null);
     }
 
-    <T> EmitterTransform<T> execute(final AsyncParser<T> parser, Runnable cancel) {
+    public <T> EmitterTransform<T> execute(final AsyncParser<T> parser, Runnable cancel) {
         assert parser != null;
         EmitterTransform<T> ret = new EmitterTransform<T>(cancel) {
             EmitterTransform<T> self = this;
@@ -815,7 +818,7 @@ public IonImageViewRequestBuilder withBitmap() {
     }
 
     @Override
-    public ImageViewFuture intoImageView(ImageView imageView) {
+    public SimpleFuture<ImageView> intoImageView(ImageView imageView) {
         return new IonImageViewRequestBuilder(this).withImageView(imageView).intoImageView(imageView);
     }
 
@@ -973,4 +976,14 @@ public IonRequestBuilder basicAuthentication(String username, String password) {
         }
         return this;
     }
+    
+    public IonTypefaceRequestBuilder withTypeface() {
+        return new IonTypefaceRequestBuilder(this);
+    }
+
+
+    @Override
+    public SimpleFuture<TextView> intoTextView(TextView textView) {
+        return new IonTypefaceRequestBuilder(this).withTextView(textView).intoTextView(textView);
+    }
 }
diff --git a/ion/src/com/koushikdutta/ion/L.java b/ion/src/com/koushikdutta/ion/L.java
new file mode 100644
index 00000000..ecc4e697
--- /dev/null
+++ b/ion/src/com/koushikdutta/ion/L.java
@@ -0,0 +1,173 @@
+
+package com.koushikdutta.ion;
+
+import android.util.Log;
+
+/**
+ * https://github.com/ANDLABS-Git/AndlabsAndroidUtils/blob/master/library/src/
+ * com/andlabs/androidutils/logging/L.java
+ * 
+ * <pre>
+ * Logging: Log simple strings or formatted strings in one simple call:
+ * 
+ *     final String formattedTestString = "first argument = %s, second argument = %s";
+ *     final String firstArgument = "abc";
+ *     final Object secondArgument = new  Object() {
+ *         public String toString() {
+ *             return "123";
+ *         };
+ *     };
+ * 
+ *     L.d(formattedTestString, firstArgument, secondArgument);
+ * Which results in a log output 09-23 17:41:30.508: D/TestActivity:26(18510): onCreate(): first argument = abc, second argument = 123
+ * </pre>
+ * 
+ * Convenience class for logging. Logs the given parameters plus the calling
+ * class and line as a tag and the calling method's name
+ */
+public class L {
+
+    public static void v(Throwable t) {
+        log(Log.VERBOSE, t, null);
+    }
+
+    public static void v(Object s1, Object... args) {
+        log(Log.VERBOSE, null, s1, args);
+    }
+
+    public static void v(Throwable t, Object s1, Object... args) {
+        log(Log.VERBOSE, t, s1, args);
+    }
+
+    public static void d(Throwable t) {
+        log(Log.DEBUG, t, null);
+    }
+
+    public static void d(Object s1, Object... args) {
+        log(Log.DEBUG, null, s1, args);
+    }
+
+    public static void d(Throwable t, Object s1, Object... args) {
+        log(Log.DEBUG, t, s1, args);
+    }
+
+    public static void i(Throwable t) {
+        log(Log.INFO, t, null);
+    }
+
+    public static void i(Object s1, Object... args) {
+        log(Log.INFO, null, s1, args);
+    }
+
+    public static void i(Throwable t, Object s1, Object... args) {
+        log(Log.INFO, t, s1, args);
+    }
+
+    public static void w(Throwable t) {
+        log(Log.WARN, t, null);
+    }
+
+    public static void w(Object s1, Object... args) {
+        log(Log.WARN, null, s1, args);
+    }
+
+    public static void w(Throwable t, Object s1, Object... args) {
+        log(Log.WARN, t, s1, args);
+    }
+
+    public static void e(Throwable t) {
+        log(Log.ERROR, t, null);
+    }
+
+    public static void e(Object s1, Object... args) {
+        log(Log.ERROR, null, s1, args);
+    }
+
+    public static void e(Throwable t, Object s1, Object... args) {
+        log(Log.ERROR, t, s1, args);
+    }
+
+    private static void log(final int pType, final Throwable t, final Object s1, final Object... args) {
+        if (pType == Log.ERROR || BuildConfig.DEBUG) {
+            final StackTraceElement stackTraceElement = Thread.currentThread().getStackTrace()[4];
+
+            final String fullClassName = stackTraceElement.getClassName();
+            final String className = fullClassName.substring(fullClassName.lastIndexOf(".") + 1);
+            final int lineNumber = stackTraceElement.getLineNumber();
+            final String method = stackTraceElement.getMethodName();
+
+            final String tag = className + ":" + lineNumber;
+
+            final StringBuilder stringBuilder = new StringBuilder();
+            stringBuilder.append(method);
+            stringBuilder.append("(): ");
+
+            if (s1 != null) {
+                final String message = (args == null) ? s1.toString() : String.format((String) s1, args);
+                stringBuilder.append(message);
+            }
+
+            switch (pType) {
+                case Log.VERBOSE:
+                    if (t != null) {
+                        Log.v(tag, stringBuilder.toString(), t);
+                    } else {
+                        Log.v(tag, stringBuilder.toString());
+                    }
+                    break;
+
+                case Log.DEBUG:
+                    if (t != null) {
+                        Log.d(tag, stringBuilder.toString(), t);
+                    } else {
+                        Log.d(tag, stringBuilder.toString());
+                    }
+                    break;
+
+                case Log.INFO:
+                    if (t != null) {
+                        Log.i(tag, stringBuilder.toString(), t);
+                    } else {
+                        Log.i(tag, stringBuilder.toString());
+                    }
+                    break;
+
+                case Log.WARN:
+                    if (t != null) {
+                        Log.w(tag, stringBuilder.toString(), t);
+                    } else {
+                        Log.w(tag, stringBuilder.toString());
+                    }
+                    break;
+
+                case Log.ERROR:
+                    if (t != null) {
+                        Log.e(tag, stringBuilder.toString(), t);
+                    } else {
+                        Log.e(tag, stringBuilder.toString());
+                    }
+                    break;
+            }
+        }
+    }
+
+    public static void i() {
+        i("... ...");
+    }
+
+    public static void d() {
+        d("... ...");
+    }
+
+    public static void e() {
+        e("... ...");
+    }
+
+    public static void v() {
+        v("... ...");
+    }
+
+    public static void w() {
+        w("... ...");
+    }
+}
diff --git a/ion/src/com/koushikdutta/ion/Loader.java b/ion/src/com/koushikdutta/ion/Loader.java
index 2f389303..c51bb3bd 100644
--- a/ion/src/com/koushikdutta/ion/Loader.java
+++ b/ion/src/com/koushikdutta/ion/Loader.java
@@ -8,6 +8,7 @@
 import com.koushikdutta.async.http.AsyncHttpRequest;
 import com.koushikdutta.async.http.libcore.RawHeaders;
 import com.koushikdutta.ion.bitmap.BitmapInfo;
+import com.koushikdutta.ion.font.TypefaceInfo;
 
 import java.io.InputStream;
 
@@ -81,6 +82,7 @@ public AsyncHttpRequest getRequest() {
      * @return
      */
     public Future<BitmapInfo> loadBitmap(Context context, Ion ion, String key, String uri, int resizeWidth, int resizeHeight, boolean animateGif);
+    public Future<TypefaceInfo> loadTypeface(Context context, Ion ion, String key, String uri);
 
     /**
      * Resolve a request into another request.
diff --git a/ion/src/com/koushikdutta/ion/builder/Builders.java b/ion/src/com/koushikdutta/ion/builder/Builders.java
index 6e6a0b5b..a5737ab0 100644
--- a/ion/src/com/koushikdutta/ion/builder/Builders.java
+++ b/ion/src/com/koushikdutta/ion/builder/Builders.java
@@ -3,6 +3,7 @@
 import android.graphics.Bitmap;
 
 import com.koushikdutta.ion.bitmap.BitmapInfo;
+import com.koushikdutta.ion.font.TypefaceFutureBuilder;
 
 /**
  * Created by koush on 6/10/13.
@@ -24,9 +25,11 @@
         // restrict to bitmap future builder
         public interface BF<A extends BF<?>> extends BitmapBuilder<A>, BitmapFutureBuilder, IF<A> {
         }
+        public interface TF<A extends TF<?>> extends TypefaceFutureBuilder {
+        }
 
         // restrict to future builder
-        public interface F extends FutureBuilder, ImageViewFutureBuilder {
+        public interface F extends FutureBuilder, ImageViewFutureBuilder, TypefaceFutureBuilder {
         }
 
         // restrict to multipart builder
diff --git a/ion/src/com/koushikdutta/ion/builder/FutureBuilder.java b/ion/src/com/koushikdutta/ion/builder/FutureBuilder.java
index ec80d761..8d361937 100644
--- a/ion/src/com/koushikdutta/ion/builder/FutureBuilder.java
+++ b/ion/src/com/koushikdutta/ion/builder/FutureBuilder.java
@@ -4,6 +4,7 @@
 import com.google.gson.JsonObject;
 import com.google.gson.reflect.TypeToken;
 import com.koushikdutta.async.parser.AsyncParser;
+import com.koushikdutta.ion.font.TypefaceFutureBuilder;
 import com.koushikdutta.ion.future.ResponseFuture;
 
 import org.w3c.dom.Document;
@@ -15,7 +16,7 @@
 /**
 * Created by koush on 5/30/13.
 */ // get the result, transformed to how you want it
-public interface FutureBuilder extends BitmapFutureBuilder, ImageViewFutureBuilder, GsonFutureBuilder {
+public interface FutureBuilder extends BitmapFutureBuilder, ImageViewFutureBuilder, GsonFutureBuilder, TypefaceFutureBuilder {
     /**
      * Execute the request and get the result as a String
      * @return
@@ -41,6 +42,7 @@
      * @return
      */
     public Builders.Any.BF<? extends Builders.Any.BF<?>> withBitmap();
+    public Builders.Any.TF<? extends Builders.Any.TF<?>> withTypeface();
 
     /**
      * Execute the request and write it to the given OutputStream.
diff --git a/ion/src/com/koushikdutta/ion/builder/ImageViewFutureBuilder.java b/ion/src/com/koushikdutta/ion/builder/ImageViewFutureBuilder.java
index 2c01273f..bc10f441 100644
--- a/ion/src/com/koushikdutta/ion/builder/ImageViewFutureBuilder.java
+++ b/ion/src/com/koushikdutta/ion/builder/ImageViewFutureBuilder.java
@@ -3,7 +3,7 @@
 import android.widget.ImageView;
 
 import com.koushikdutta.async.future.Future;
-import com.koushikdutta.ion.future.ImageViewFuture;
+import com.koushikdutta.async.future.SimpleFuture;
 
 /**
 * Created by koush on 5/30/13.
@@ -15,5 +15,5 @@
      * @param imageView ImageView to set once the request completes
      * @return
      */
-    public ImageViewFuture intoImageView(ImageView imageView);
+    public SimpleFuture<ImageView> intoImageView(ImageView imageView);
 }
diff --git a/ion/src/com/koushikdutta/ion/builder/LoadImageViewFutureBuilder.java b/ion/src/com/koushikdutta/ion/builder/LoadImageViewFutureBuilder.java
index 542c79ed..26f8e20b 100644
--- a/ion/src/com/koushikdutta/ion/builder/LoadImageViewFutureBuilder.java
+++ b/ion/src/com/koushikdutta/ion/builder/LoadImageViewFutureBuilder.java
@@ -3,7 +3,7 @@
 import android.widget.ImageView;
 
 import com.koushikdutta.async.future.Future;
-import com.koushikdutta.ion.future.ImageViewFuture;
+import com.koushikdutta.async.future.SimpleFuture;
 
 /**
 * Created by koush on 5/30/13.
@@ -15,7 +15,7 @@
      * @param url
      * @return
      */
-    public ImageViewFuture load(String url);
+    public SimpleFuture<ImageView> load(String url);
 
     /**
      * Perform the request and get the result as a Bitmap, which will then be loaded
diff --git a/ion/src/com/koushikdutta/ion/font/DeferredLoadTypeface.java b/ion/src/com/koushikdutta/ion/font/DeferredLoadTypeface.java
new file mode 100644
index 00000000..ddcf1189
--- /dev/null
+++ b/ion/src/com/koushikdutta/ion/font/DeferredLoadTypeface.java
@@ -0,0 +1,13 @@
+
+package com.koushikdutta.ion.font;
+
+import com.koushikdutta.ion.Ion;
+
+public class DeferredLoadTypeface extends TypefaceCallback {
+    public TypefaceFetcher fetcher;
+
+    public DeferredLoadTypeface(Ion ion, String key, TypefaceFetcher fetcher) {
+        super(ion, key, false);
+        this.fetcher = fetcher;
+    }
+}
diff --git a/ion/src/com/koushikdutta/ion/font/IonTypeface.java b/ion/src/com/koushikdutta/ion/font/IonTypeface.java
new file mode 100644
index 00000000..16a9dbb4
--- /dev/null
+++ b/ion/src/com/koushikdutta/ion/font/IonTypeface.java
@@ -0,0 +1,164 @@
+
+package com.koushikdutta.ion.font;
+
+import android.annotation.SuppressLint;
+import android.os.Looper;
+import android.text.TextUtils;
+import android.widget.TextView;
+
+import com.koushikdutta.async.future.FutureCallback;
+import com.koushikdutta.async.future.SimpleFuture;
+import com.koushikdutta.ion.ContextReference;
+import com.koushikdutta.ion.Ion;
+import com.koushikdutta.ion.L;
+import com.koushikdutta.ion.R;
+
+import java.lang.ref.WeakReference;
+
+public class IonTypeface {
+
+    private TypefaceInfo info;
+    @SuppressWarnings("unused")
+    private int loadedFrom;
+    private IonDrawableCallback callback;
+    private Ion ion;
+
+    public IonTypeface ion(Ion ion) {
+        this.ion = ion;
+        return this;
+    }
+
+    public TypefaceInfo getTypefaceInfo() {
+        return info;
+    }
+
+    public SimpleFuture<TextView> getFuture() {
+        return callback.imageViewFuture;
+    }
+
+    public static final int TAG = R.id.font_key;
+
+    // create an internal static class that can act as a callback.
+    // dont let it hold strong references to anything.
+    static class IonDrawableCallback implements FutureCallback<TypefaceInfo> {
+        private WeakReference<IonTypeface> ionDrawableRef;
+        private ContextReference.TextViewContextReference imageViewRef;
+        private String bitmapKey;
+        private SimpleFuture<TextView> imageViewFuture = new SimpleFuture<TextView>();
+
+        public IonDrawableCallback(IonTypeface drawable, TextView imageView) {
+            ionDrawableRef = new WeakReference<IonTypeface>(drawable);
+            imageViewRef = new ContextReference.TextViewContextReference(imageView);
+        }
+
+        @SuppressLint("Assert")
+        @Override
+        public void onCompleted(Exception e, TypefaceInfo result) {
+            assert Thread.currentThread() == Looper.getMainLooper().getThread();
+            assert result != null;
+            // see if the imageview is still alive and cares about this result
+            TextView imageView = imageViewRef.get();
+            L.d("textView..."+imageView);
+            if (imageView == null)
+                return;
+
+            IonTypeface drawable = ionDrawableRef.get();
+            L.d("IonTypeface..."+drawable);
+            if (drawable == null)
+                return;
+
+            L.d("IonTypeface tag..."+imageView.getTag(TAG));
+            if (imageView.getTag(TAG) != drawable)
+                return;
+
+            imageView.setTag(TAG, null);
+            drawable.setBitmap(result, result.loadedFrom);
+            imageView.setTag(TAG, drawable);
+            imageView.setTypeface(result.typeface);
+
+            L.d("textView alive ..."+imageViewRef.isAlive());
+            if (null != imageViewRef.isAlive()) {
+                imageViewFuture.cancelSilently();
+                return;
+            }
+
+            imageViewFuture.setComplete(e, imageView);
+        }
+    }
+
+    public void cancel() {
+        unregister(ion, callback.bitmapKey, callback);
+        callback.bitmapKey = null;
+    }
+
+    private static void unregister(Ion ion, String key, IonDrawableCallback callback) {
+        if (key == null)
+            return;
+        // unregister this drawable from the bitmaps that are
+        // pending.
+
+        // if this drawable was the only thing waiting for this bitmap,
+        // then the removeItem call will return the TransformBitmap/LoadBitmap
+        // instance
+        // that was providing the result.
+        if (ion.typefacesPending.removeItem(key, callback)) {
+            // find out who owns this thing, to see if it is a candidate for
+            // removal
+            Object owner = ion.typefacesPending.tag(key);
+            // only cancel deferred loads... LoadBitmap means a download is
+            // already in progress.
+            // due to view recycling, cancelling that may be bad, as it may be
+            // rerequested again
+            // during the recycle process.
+            if (owner instanceof DeferredLoadTypeface) {
+                DeferredLoadTypeface defer = (DeferredLoadTypeface) owner;
+                ion.typefacesPending.remove(defer.key);
+            }
+        }
+
+        ion.processTypefaceDeferred();
+    }
+
+    public void register(Ion ion, String bitmapKey) {
+        String previousKey = callback.bitmapKey;
+        if (TextUtils.equals(previousKey, bitmapKey))
+            return;
+        callback.bitmapKey = bitmapKey;
+        ion.typefacesPending.add(bitmapKey, callback);
+        unregister(ion, previousKey, callback);
+    }
+
+    public IonTypeface(TextView imageView) {
+        callback = new IonDrawableCallback(this, imageView);
+    }
+
+    public IonTypeface setBitmap(TypefaceInfo info, int loadedFrom) {
+        if (this.info == info)
+            return this;
+
+        cancel();
+        this.loadedFrom = loadedFrom;
+        this.info = info;
+        if (info == null) {
+            callback.bitmapKey = null;
+            return this;
+        }
+
+        callback.bitmapKey = info.key;
+        return this;
+    }
+
+    static IonTypeface getOrCreateIonDrawable(TextView imageView) {
+        IonTypeface current = (IonTypeface) imageView.getTag(TAG);
+        IonTypeface ret;
+        if (current == null)
+            ret = new IonTypeface(imageView);
+        else
+            ret = (IonTypeface) current;
+        // invalidate self doesn't seem to trigger the dimension check to be
+        // called by imageview.
+        // are drawable dimensions supposed to be immutable?
+        imageView.setTag(TAG, null);
+        return ret;
+    }
+}
diff --git a/ion/src/com/koushikdutta/ion/font/IonTypefaceCache.java b/ion/src/com/koushikdutta/ion/font/IonTypefaceCache.java
new file mode 100644
index 00000000..4c98a3a7
--- /dev/null
+++ b/ion/src/com/koushikdutta/ion/font/IonTypefaceCache.java
@@ -0,0 +1,108 @@
+
+package com.koushikdutta.ion.font;
+
+import android.annotation.SuppressLint;
+import android.app.ActivityManager;
+import android.content.Context;
+import android.content.res.AssetManager;
+import android.content.res.Resources;
+import android.graphics.Typeface;
+import android.os.Looper;
+import android.util.DisplayMetrics;
+import android.util.Log;
+import android.view.WindowManager;
+
+import com.koushikdutta.ion.Ion;
+
+import java.io.File;
+
+public class IonTypefaceCache {
+    public static final long DEFAULT_ERROR_CACHE_DURATION = 30000L;
+
+    Resources resources;
+    DisplayMetrics metrics;
+    LruTypefaceCache cache;
+    Ion ion;
+    long errorCacheDuration = DEFAULT_ERROR_CACHE_DURATION;
+
+    public long getErrorCacheDuration() {
+        return errorCacheDuration;
+    }
+
+    public void setErrorCacheDuration(long errorCacheDuration) {
+        this.errorCacheDuration = errorCacheDuration;
+    }
+
+    public IonTypefaceCache(Ion ion) {
+        Context context = ion.getContext();
+        this.ion = ion;
+        metrics = new DisplayMetrics();
+        ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay().getMetrics(metrics);
+        final AssetManager mgr = context.getAssets();
+        resources = new Resources(mgr, metrics, context.getResources().getConfiguration());
+        cache = new LruTypefaceCache(getHeapSize(context) / 7);
+    }
+
+    public TypefaceInfo remove(String key) {
+        return cache.removeTypefaceInfo(key);
+    }
+
+    public void clear() {
+        cache.evictAllTypefaceInfo();
+    }
+
+    double heapRatio = 1d / 7d;
+
+    public double getHeapRatio() {
+        return heapRatio;
+    }
+
+    public void setHeapRatio(double heapRatio) {
+        this.heapRatio = heapRatio;
+    }
+
+    @SuppressLint("Assert")
+    public void put(TypefaceInfo info) {
+        assert Thread.currentThread() == Looper.getMainLooper().getThread();
+        int maxSize = (int) (getHeapSize(ion.getContext()) * heapRatio);
+        if (maxSize != cache.maxSize())
+            cache.setMaxSize(maxSize);
+        cache.put(info.key, info);
+    }
+
+    public TypefaceInfo get(String key) {
+        if (key == null)
+            return null;
+
+        // see if this thing has an immediate cache hit
+        TypefaceInfo ret = cache.getTypefaceInfo(key);
+        if (ret == null || ret.typeface != null)
+            return ret;
+
+        // if this bitmap load previously errored out, see if it is time to
+        // retry
+        // the fetch. connectivity error, server failure, etc, shouldn't be
+        // cached indefinitely...
+        if (ret.loadTime + errorCacheDuration > System.currentTimeMillis())
+            return ret;
+
+        cache.remove(key);
+        return null;
+    }
+
+    public void dump() {
+        Log.i("IonBitmapCache", "bitmap cache: " + cache.size());
+        Log.i("IonBitmapCache", "freeMemory: " + Runtime.getRuntime().freeMemory());
+    }
+
+    @SuppressLint("Assert")
+    public static Typeface loadTypeface(File file) {
+        assert Thread.currentThread() != Looper.getMainLooper().getThread();
+
+        return Typeface.createFromFile(file);
+    }
+
+    private static int getHeapSize(final Context context) {
+        return ((ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE)).getMemoryClass() * 1024 * 1024;
+    }
+}
diff --git a/ion/src/com/koushikdutta/ion/font/IonTypefaceRequestBuilder.java b/ion/src/com/koushikdutta/ion/font/IonTypefaceRequestBuilder.java
new file mode 100644
index 00000000..7bf0574a
--- /dev/null
+++ b/ion/src/com/koushikdutta/ion/font/IonTypefaceRequestBuilder.java
@@ -0,0 +1,147 @@
+
+package com.koushikdutta.ion.font;
+
+import android.annotation.SuppressLint;
+import android.os.Looper;
+import android.widget.TextView;
+
+import com.koushikdutta.async.future.SimpleFuture;
+import com.koushikdutta.async.util.FileCache;
+import com.koushikdutta.ion.ContextReference;
+import com.koushikdutta.ion.Ion;
+import com.koushikdutta.ion.IonRequestBuilder;
+import com.koushikdutta.ion.L;
+import com.koushikdutta.ion.Loader;
+import com.koushikdutta.ion.builder.Builders;
+
+@SuppressWarnings("rawtypes")
+public class IonTypefaceRequestBuilder implements Builders.Any.TF, TypefaceFutureBuilder {
+    private static final SimpleFuture<TextView> FUTURE_TEXTVIEW_NULL_URI = new SimpleFuture<TextView>() {
+        {
+            setComplete(new NullPointerException("uri"));
+        }
+    };
+
+    IonRequestBuilder builder;
+    Ion ion;
+    ContextReference.TextViewContextReference imageViewPostRef;
+
+    public IonTypefaceRequestBuilder(IonRequestBuilder builder) {
+        this.builder = builder;
+        ion = builder.ion;
+    }
+
+    public IonTypefaceRequestBuilder(Ion ion) {
+        this.ion = ion;
+    }
+
+    public IonTypefaceRequestBuilder withTextView(TextView imageView) {
+        imageViewPostRef = new ContextReference.TextViewContextReference(imageView);
+        return this;
+    }
+
+    @SuppressLint("Assert")
+    @Override
+    public SimpleFuture<TextView> intoTextView(TextView imageView) {
+        L.d("------------- 1");
+        assert Thread.currentThread() == Looper.getMainLooper().getThread();
+        L.d("------------- 2");
+        if (imageView == null)
+            throw new NullPointerException("imageView");
+
+        // no uri? just set a placeholder and bail
+        if (builder.uri == null) {
+            return FUTURE_TEXTVIEW_NULL_URI;
+        }
+
+        L.d("------------- 3");
+        withTextView(imageView);
+
+        L.d("------------- 4");
+        // executeCache the request, see if we get a bitmap from cache.
+        TypefaceFetcher bitmapFetcher = executeCache();
+        L.d("------------- 5");
+        if (bitmapFetcher.info != null) {
+            IonTypeface drawable = setIonDrawable(imageView, bitmapFetcher.info, Loader.LoaderEmitter.LOADED_FROM_MEMORY);
+            drawable.cancel();
+            SimpleFuture<TextView> imageViewFuture = drawable.getFuture();
+            imageViewFuture.reset();
+            L.d("---- load from cache.... " + bitmapFetcher.info.typeface);
+            imageView.setTypeface(bitmapFetcher.info.typeface);
+            imageViewFuture.setComplete(bitmapFetcher.info.exception, imageView);
+            return imageViewFuture;
+        }
+        L.d("------------- 6");
+        // TODO TextViewFutureImpl 想办法和 textview 关联起来
+        // TextViewFutureImpl imageViewFuture = new TextViewFutureImpl();
+        // IonDrawable drawable = setIonDrawable(imageView, null, 0);
+        // doAnimation(imageView, loadAnimation, loadAnimationResource);
+        // IonDrawable.ImageViewFutureImpl imageViewFuture =
+        // drawable.getFuture();
+        // imageViewFuture.reset();
+        // drawable.register(ion, bitmapFetcher.bitmapKey);
+        IonTypeface drawable = setIonDrawable(imageView, null, 0);
+        SimpleFuture<TextView> imageViewFuture = drawable.getFuture();
+        imageViewFuture.reset();
+        drawable.register(ion, bitmapFetcher.bitmapKey);
+        // nothing from cache, check to see if there's too many imageview loads
+        // already in progress
+        L.d("------------- 7");
+        if (TypefaceFetcher.shouldDeferTextView(ion)) {
+            bitmapFetcher.defer();
+        } else {
+            L.d("------------- 8");
+            bitmapFetcher.execute();
+        }
+        L.d("------------- 9");
+
+        return imageViewFuture;
+    }
+
+    private IonTypeface setIonDrawable(TextView imageView, TypefaceInfo info, int loadedFrom) {
+        IonTypeface ret = IonTypeface.getOrCreateIonDrawable(imageView).ion(ion);
+        imageView.setTag(IonTypeface.TAG, ret);
+        return ret;
+    }
+
+    public String computeBitmapKey(String downloadKey) {
+        assert downloadKey != null;
+
+        // determine the key for this bitmap after all transformations
+        String bitmapKey = downloadKey;
+
+        return bitmapKey;
+    }
+
+    private String computeDownloadKey() {
+        String downloadKey = builder.uri;
+        // although a gif is always same download, the decode (non/animated)
+        // result may different
+        return FileCache.toKeyString(downloadKey);
+    }
+
+    TypefaceFetcher executeCache() {
+        final String downloadKey = computeDownloadKey();
+        String bitmapKey = computeBitmapKey(downloadKey);
+
+        // TODO: eliminate this allocation?
+        TypefaceFetcher ret = new TypefaceFetcher();
+        ret.downloadKey = downloadKey;
+        ret.bitmapKey = bitmapKey;
+        ret.builder = builder;
+        // ret.postProcess = postProcess;
+
+        // see if this request can be fulfilled from the cache
+        if (!builder.noCache) {
+            TypefaceInfo bitmap = builder.ion.typefaceCache.get(bitmapKey);
+            L.d("get cache..... " + bitmap);
+            if (bitmap != null) {
+                ret.info = bitmap;
+                return ret;
+            }
+        }
+
+        return ret;
+    }
+
+}
diff --git a/ion/src/com/koushikdutta/ion/font/LoadTypeface.java b/ion/src/com/koushikdutta/ion/font/LoadTypeface.java
new file mode 100644
index 00000000..0c5732bd
--- /dev/null
+++ b/ion/src/com/koushikdutta/ion/font/LoadTypeface.java
@@ -0,0 +1,54 @@
+
+package com.koushikdutta.ion.font;
+
+import android.graphics.Typeface;
+
+import com.koushikdutta.async.future.FutureCallback;
+import com.koushikdutta.ion.Ion;
+import com.koushikdutta.ion.IonRequestBuilder;
+import com.koushikdutta.ion.L;
+import com.koushikdutta.ion.Loader;
+
+import java.io.File;
+
+public class LoadTypeface extends /* LoadTypefaceEmitter */LoadTypefaceBase implements FutureCallback<File> {
+
+    public LoadTypeface(Ion ion, String urlKey, boolean put, IonRequestBuilder.EmitterTransform<File> emitterTransform) {
+        // super(ion, urlKey, put, emitterTransform);
+        // this.emitterTransform = emitterTransform;
+        super(ion, urlKey, put);
+    }
+
+    @Override
+    public void onCompleted(Exception e, final File result) {
+        L.d("load file completed..." + e + "  " + result);
+        if (e != null) {
+            report(e, null);
+            return;
+        }
+
+        if (ion.typefacesPending.tag(key) != this) {
+            return;
+        }
+
+        Ion.getBitmapLoadExecutorService().execute(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    L.d("------------===aaa");
+                    if (ion.typefacesPending.tag(key) != LoadTypeface.this) {
+                        return;
+                    }
+                    Typeface typeface = Typeface.createFromFile(result);
+                    TypefaceInfo info = new TypefaceInfo(key, typeface, (int) result.length());
+                    info.loadedFrom = Loader.LoaderEmitter.LOADED_FROM_NETWORK;
+                    report(null, info);
+                } catch (Exception e) {
+                    L.d("----------------");
+                    report(e, null);
+                } finally {
+                }
+            }
+        });
+    }
+}
diff --git a/ion/src/com/koushikdutta/ion/font/LoadTypefaceBase.java b/ion/src/com/koushikdutta/ion/font/LoadTypefaceBase.java
new file mode 100644
index 00000000..f496cc45
--- /dev/null
+++ b/ion/src/com/koushikdutta/ion/font/LoadTypefaceBase.java
@@ -0,0 +1,10 @@
+
+package com.koushikdutta.ion.font;
+
+import com.koushikdutta.ion.Ion;
+
+public class LoadTypefaceBase extends TypefaceCallback {
+    public LoadTypefaceBase(Ion ion, String key, boolean put) {
+        super(ion, key, put);
+    }
+}
diff --git a/ion/src/com/koushikdutta/ion/font/LoadTypefaceEmitter.java_ b/ion/src/com/koushikdutta/ion/font/LoadTypefaceEmitter.java_
new file mode 100644
index 00000000..df2727ef
--- /dev/null
+++ b/ion/src/com/koushikdutta/ion/font/LoadTypefaceEmitter.java_
@@ -0,0 +1,14 @@
+
+package com.koushikdutta.ion.font;
+
+import com.koushikdutta.ion.Ion;
+import com.koushikdutta.ion.IonRequestBuilder;
+
+public class LoadTypefaceEmitter extends LoadTypefaceBase {
+    IonRequestBuilder.EmitterTransform emitterTransform;
+
+    public LoadTypefaceEmitter(Ion ion, String urlKey, boolean put, IonRequestBuilder.EmitterTransform emitterTransform) {
+        super(ion, urlKey, put);
+        this.emitterTransform = emitterTransform;
+    }
+}
diff --git a/ion/src/com/koushikdutta/ion/font/LruTypefaceCache.java b/ion/src/com/koushikdutta/ion/font/LruTypefaceCache.java
new file mode 100644
index 00000000..728cfa63
--- /dev/null
+++ b/ion/src/com/koushikdutta/ion/font/LruTypefaceCache.java
@@ -0,0 +1,54 @@
+
+package com.koushikdutta.ion.font;
+
+import com.koushikdutta.async.util.LruCache;
+import com.koushikdutta.ion.L;
+import com.koushikdutta.ion.bitmap.SoftReferenceHashtable;
+
+public class LruTypefaceCache extends LruCache<String, TypefaceInfo> {
+    private SoftReferenceHashtable<String, TypefaceInfo> soft = new SoftReferenceHashtable<String, TypefaceInfo>();
+
+    public LruTypefaceCache(int maxSize) {
+        super(maxSize);
+    }
+
+    @Override
+    protected long sizeOf(String key, TypefaceInfo info) {
+        return info.sizeOf();
+    }
+
+    public TypefaceInfo getTypefaceInfo(String key) {
+        TypefaceInfo ret = get(key);
+        L.d("... "+ key+" ... "+ ret);
+        if (ret != null)
+            return ret;
+
+        ret = soft.remove(key);
+        if (ret != null)
+            put(key, ret);
+
+        return ret;
+    }
+
+    public TypefaceInfo removeTypefaceInfo(String key) {
+        TypefaceInfo i1 = soft.remove(key);
+        TypefaceInfo i2 = remove(key);
+        if (i2 != null)
+            return i2;
+        return i1;
+    }
+
+    public void evictAllTypefaceInfo() {
+        evictAll();
+        soft.clear();
+    }
+
+    @Override
+    protected void entryRemoved(boolean evicted, String key, TypefaceInfo oldValue, TypefaceInfo newValue) {
+        super.entryRemoved(evicted, key, oldValue, newValue);
+
+        // on eviction, put the bitmaps into the soft ref table
+        if (evicted)
+            soft.put(key, oldValue);
+    }
+}
diff --git a/ion/src/com/koushikdutta/ion/font/TextViewTypefaceInfo.java_ b/ion/src/com/koushikdutta/ion/font/TextViewTypefaceInfo.java_
new file mode 100644
index 00000000..ac366ec6
--- /dev/null
+++ b/ion/src/com/koushikdutta/ion/font/TextViewTypefaceInfo.java_
@@ -0,0 +1,26 @@
+
+package com.koushikdutta.ion.font;
+
+import android.widget.TextView;
+
+public class TextViewTypefaceInfo {
+
+    Exception exception;
+
+    public Exception getException() {
+        return exception;
+    }
+
+    TextView textView;
+
+    public TextView getTextView() {
+        return textView;
+    }
+
+    TypefaceInfo info;
+
+    public TypefaceInfo getTypefaceInfo() {
+        return info;
+    }
+
+}
diff --git a/ion/src/com/koushikdutta/ion/font/TypefaceCallback.java b/ion/src/com/koushikdutta/ion/font/TypefaceCallback.java
new file mode 100644
index 00000000..31f9fd65
--- /dev/null
+++ b/ion/src/com/koushikdutta/ion/font/TypefaceCallback.java
@@ -0,0 +1,63 @@
+
+package com.koushikdutta.ion.font;
+
+import com.koushikdutta.async.AsyncServer;
+import com.koushikdutta.async.future.FutureCallback;
+import com.koushikdutta.ion.Ion;
+
+import java.util.ArrayList;
+import java.util.concurrent.CancellationException;
+
+public class TypefaceCallback {
+
+    public String key;
+    public Ion ion;
+
+    protected TypefaceCallback(Ion ion, String key, boolean put) {
+        this.key = key;
+        this.put = put;
+        this.ion = ion;
+
+        ion.typefacesPending.tag(key, this);
+    }
+
+    boolean put;
+
+    boolean put() {
+        return put;
+    }
+
+    protected void onReported() {
+        ion.processTypefaceDeferred();
+    }
+
+    protected void report(final Exception e, final TypefaceInfo info) {
+        AsyncServer.post(Ion.mainHandler, new Runnable() {
+            @Override
+            public void run() {
+                TypefaceInfo result = info;
+                if (result == null) {
+                    // cache errors, unless they were cancellation exceptions
+                    result = new TypefaceInfo(key, null, 0);
+                    result.exception = e;
+                    if (!(e instanceof CancellationException))
+                        ion.typefaceCache.put(result);
+                } else if (put()) {
+                    ion.typefaceCache.put(result);
+                }
+
+                final ArrayList<FutureCallback<TypefaceInfo>> callbacks = ion.typefacesPending.remove(key);
+                if (callbacks == null || callbacks.size() == 0) {
+                    onReported();
+                    return;
+                }
+
+                for (FutureCallback<TypefaceInfo> callback : callbacks) {
+                    callback.onCompleted(e, result);
+                }
+                onReported();
+            }
+        });
+    }
+
+}
diff --git a/ion/src/com/koushikdutta/ion/font/TypefaceFetcher.java b/ion/src/com/koushikdutta/ion/font/TypefaceFetcher.java
new file mode 100644
index 00000000..f86ff403
--- /dev/null
+++ b/ion/src/com/koushikdutta/ion/font/TypefaceFetcher.java
@@ -0,0 +1,286 @@
+
+package com.koushikdutta.ion.font;
+
+import android.graphics.Typeface;
+import android.util.Log;
+
+import com.koushikdutta.async.AsyncServer;
+import com.koushikdutta.async.future.Future;
+import com.koushikdutta.async.future.FutureCallback;
+import com.koushikdutta.async.future.SimpleFuture;
+import com.koushikdutta.async.future.TransformFuture;
+import com.koushikdutta.async.http.AsyncHttpRequest;
+import com.koushikdutta.async.util.FileCache;
+import com.koushikdutta.async.util.StreamUtility;
+import com.koushikdutta.ion.InputStreamParser;
+import com.koushikdutta.ion.Ion;
+import com.koushikdutta.ion.IonRequestBuilder;
+import com.koushikdutta.ion.L;
+import com.koushikdutta.ion.Loader;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.InputStream;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipInputStream;
+
+public class TypefaceFetcher implements IonRequestBuilder.LoadRequestCallback {
+    String downloadKey;
+    public String bitmapKey;
+    TypefaceInfo info;
+    IonRequestBuilder builder;
+
+    private boolean fastLoad(String uri) {
+        Ion ion = builder.ion;
+
+        for (Loader loader : ion.configure().getLoaders()) {
+            Future<TypefaceInfo> future = loader.loadTypeface(builder.contextReference.getContext(), ion, downloadKey, uri);
+
+            L.d("loader .... " + future);
+            if (future != null) {
+                final LoadTypefaceBase callback = new LoadTypefaceBase(ion, downloadKey, true);
+                future.setCallback(new FutureCallback<TypefaceInfo>() {
+                    @Override
+                    public void onCompleted(Exception e, TypefaceInfo result) {
+                        L.d("report....");
+                        callback.report(e, result);
+                    }
+                });
+                return true;
+            }
+        }
+        return false;
+    }
+
+    public static final int MAX_TYPEFACE_LOAD = 2;
+
+    public static boolean shouldDeferTextView(Ion ion) {
+        int size = ion.typefacesPending.keySet().size();
+        L.d("shouldDeferTextView ... "+size);
+        if (size <= MAX_TYPEFACE_LOAD)
+            return false;
+        int loadCount = 0;
+        for (String key : ion.typefacesPending.keySet()) {
+            Object owner = ion.typefacesPending.tag(key);
+            if (owner instanceof LoadTypefaceBase) {
+                loadCount++;
+                if (loadCount > MAX_TYPEFACE_LOAD)
+                    return true;
+            }
+        }
+        return false;
+    }
+
+    public DeferredLoadTypeface defer() {
+        DeferredLoadTypeface ret = new DeferredLoadTypeface(builder.ion, downloadKey, this);
+        return ret;
+    }
+
+    @Override
+    public boolean loadRequest(AsyncHttpRequest request) {
+        return !fastLoad(request.getUri().toString());
+    }
+
+    public static void getTypefaceFromFile(final Ion ion, final String transformKey, final String file) {
+        // don't do this if this is already loading
+        if (ion.typefacesPending.tag(transformKey) != null)
+            return;
+        final TypefaceCallback callback = new TypefaceCallback(ion, transformKey, true);
+        Ion.getBitmapLoadExecutorService().execute(new Runnable() {
+            @Override
+            public void run() {
+                if (ion.typefacesPending.tag(transformKey) != callback) {
+                    Log.d("IonTypefaceLoader", "Typeface cache load cancelled (no longer needed)");
+                    return;
+                }
+
+                try {
+                    L.d("cache file -- " + file);
+                    try {
+                        L.d("------------==1111=");
+                        Typeface typeface = Typeface.createFromFile(file);
+                        TypefaceInfo info = new TypefaceInfo(transformKey, typeface, (int) new File(file).length());
+                        info.loadedFrom = Loader.LoaderEmitter.LOADED_FROM_CACHE;
+                        callback.report(null, info);
+                    } catch (Exception e) {
+                        L.d("e ----------------");
+                        callback.report(e, null);
+                    } finally {
+                    }
+                } catch (OutOfMemoryError e) {
+                    callback.report(new Exception(e), null);
+                } catch (Exception e) {
+                    callback.report(e, null);
+                    try {
+                        ion.getCache().remove(transformKey);
+                    } catch (Exception ex) {
+                    }
+                }
+            }
+        });
+    }
+
+    public static void getTypefaceFromHttpCache(final Ion ion, final String transformKey, final File ttf) {
+        // don't do this if this is already loading
+        if (ion.typefacesPending.tag(transformKey) != null)
+            return;
+        final TypefaceCallback callback = new TypefaceCallback(ion, transformKey, true);
+        Ion.getBitmapLoadExecutorService().execute(new Runnable() {
+            @Override
+            public void run() {
+                if (ion.typefacesPending.tag(transformKey) != callback) {
+                     Log.d("IonTypefaceLoader", "Typeface cache load cancelled (no longer needed)");
+                    return;
+                }
+
+                try {
+                    File file = ion.getCache().getFile(transformKey);
+                    L.d("cache file " + file.getAbsolutePath());
+                    
+                  if (file.exists()) {
+
+                      ZipInputStream zis = new ZipInputStream(new FileInputStream(file));
+                      try {
+                          ZipEntry ze = null;
+                          while ((ze = zis.getNextEntry()) != null) {
+                              if (ze.getName().endsWith(".ttf")) {
+                                  FileOutputStream fout = new FileOutputStream(ttf, false);
+                                  try {
+                                      for (int c = zis.read(); c != -1; c = zis.read()) {
+                                          fout.write(c);
+                                      }
+                                      zis.closeEntry();
+                                  } finally {
+                                      fout.close();
+                                  }
+                              }
+                          }
+
+                      } catch (Exception e) {
+                          Log.e("FileLoader", "Unzip exception", e);
+                      } finally {
+                          StreamUtility.closeQuietly(zis);
+                      }
+                  }
+                    
+                    Typeface bitmap = IonTypefaceCache.loadTypeface(ttf);
+                    if (bitmap == null)
+                        throw new Exception("Bitmap failed to load");
+                    TypefaceInfo info = new TypefaceInfo(transformKey, bitmap, (int) file.length());
+                    info.loadedFrom = Loader.LoaderEmitter.LOADED_FROM_CACHE;
+                    //ttf.delete();//TODO 为了避免占用太多空间， 生成typeface后再删除预览文件
+                    // 提供空间管理界面，让用户可以选择删除 预览字体
+                    callback.report(null, info);
+                } catch (OutOfMemoryError e) {
+                    callback.report(new Exception(e), null);
+                } catch (Exception e) {
+                    callback.report(e, null);
+                    try {
+                        ion.getCache().remove(transformKey);
+                    } catch (Exception ex) {
+                    }
+                }
+            }
+        });
+    }
+
+    public void execute() {
+        final Ion ion = builder.ion;
+
+        final File file = getFileFromUri(builder.uri);
+        final File ttf = new File(file.getAbsolutePath().replace(".zip", ".ttf"));
+        if (!builder.noCache && (/*file.exists() ||*/ ttf.exists())) {
+            L.d("get font from file " + ttf.getAbsolutePath());
+            getTypefaceFromFile(ion, bitmapKey, ttf.getAbsolutePath());
+            return;
+        }
+
+        // bitmaps that were transformed are put into the FileCache to prevent
+        // subsequent retransformation. See if we can retrieve the bitmap from
+        // the disk cache.
+        // See TransformBitmap for where the cache is populated.
+        FileCache fileCache = ion.getCache();
+        L.d("cache..............||| " + fileCache);
+        if (!builder.noCache && fileCache.exists(bitmapKey)) {
+            getTypefaceFromHttpCache(ion, bitmapKey, ttf);
+            return;
+        }
+
+        L.d("cache..............11" + fileCache);
+        // Perform a download as necessary.
+        if (ion.typefacesPending.tag(downloadKey) == null && !fastLoad(builder.uri)) {
+            builder.setHandler(null);
+            builder.loadRequestCallback = this;
+
+            L.d("http excute...." + file.getAbsolutePath());
+            L.d("http excute uri --- ...." +builder.uri);
+
+            SimpleFuture<File> ff = builder.execute(new InputStreamParser(), new Runnable() {
+                @Override
+                public void run() {
+                    AsyncServer.post(Ion.mainHandler, new Runnable() {
+                        @Override
+                        public void run() {
+                            ion.typefacesPending.remove(downloadKey);
+                        }
+                    });
+                }
+            }).then(new TransformFuture<File, InputStream>() {
+
+                @Override
+                protected void transform(InputStream result) throws Exception {
+                    try {
+                        L.d("------------===");
+                        ZipInputStream zis = new ZipInputStream(result);
+                        try {
+                            ZipEntry ze = null;
+                            while ((ze = zis.getNextEntry()) != null) {
+                                if (ze.getName().endsWith(".ttf")) {
+                                    FileOutputStream fout = new FileOutputStream(ttf, false);
+                                    try {
+                                        for (int c = zis.read(); c != -1; c = zis.read()) {
+                                            fout.write(c);
+                                        }
+                                        zis.closeEntry();
+                                    } finally {
+                                        fout.close();
+                                    }
+                                }
+                            }
+
+                        } catch (Exception e) {
+                            Log.e("FileLoader", "Unzip exception", e);
+                        } finally {
+                            StreamUtility.closeQuietly(zis);
+                        }
+
+                        Typeface typeface = Typeface.createFromFile(ttf);
+                        L.d("typeface.... " + typeface);
+                        setComplete(null, ttf);
+                    } catch (Exception e) {
+                        L.d("----------------");
+                        setComplete(e, null);
+                    } finally {
+                    }
+
+                }
+            });
+
+            L.d("set .. LoadTypeface  callback...");
+            ff.setCallback(new LoadTypeface(ion, downloadKey, true, null));
+        }
+
+    }
+
+    private File getFileFromUri(String uri) {
+        int index = uri.lastIndexOf("/");
+        String name = uri.substring(index, uri.length());
+        File dir = builder.contextReference.getContext().getFilesDir();
+        dir = new File(dir, "prettf");
+        if(!dir.exists()) {
+            dir.mkdirs();
+        }
+        return new File(dir, name);
+    }
+}
diff --git a/ion/src/com/koushikdutta/ion/font/TypefaceFuture.java_ b/ion/src/com/koushikdutta/ion/font/TypefaceFuture.java_
new file mode 100644
index 00000000..7bf707fd
--- /dev/null
+++ b/ion/src/com/koushikdutta/ion/font/TypefaceFuture.java_
@@ -0,0 +1,11 @@
+
+package com.koushikdutta.ion.font;
+
+import android.widget.TextView;
+
+import com.koushikdutta.async.future.Future;
+import com.koushikdutta.ion.ImageViewBitmapInfo;
+
+public interface TypefaceFuture extends Future<TextView> {
+    Future<TextViewTypefaceInfo> withTypefaceInfo();
+}
diff --git a/ion/src/com/koushikdutta/ion/font/TypefaceFutureBuilder.java b/ion/src/com/koushikdutta/ion/font/TypefaceFutureBuilder.java
new file mode 100644
index 00000000..e5dee13d
--- /dev/null
+++ b/ion/src/com/koushikdutta/ion/font/TypefaceFutureBuilder.java
@@ -0,0 +1,9 @@
+package com.koushikdutta.ion.font;
+
+import android.widget.TextView;
+
+import com.koushikdutta.async.future.SimpleFuture;
+
+public interface TypefaceFutureBuilder {
+    public SimpleFuture<TextView> intoTextView(TextView textView);
+}
diff --git a/ion/src/com/koushikdutta/ion/font/TypefaceInfo.java b/ion/src/com/koushikdutta/ion/font/TypefaceInfo.java
new file mode 100644
index 00000000..11280b4f
--- /dev/null
+++ b/ion/src/com/koushikdutta/ion/font/TypefaceInfo.java
@@ -0,0 +1,27 @@
+
+package com.koushikdutta.ion.font;
+
+import android.graphics.Typeface;
+
+import java.io.File;
+
+public class TypefaceInfo {
+    public Typeface typeface;
+    public int fileSize;
+    public long loadTime = System.currentTimeMillis();
+    public long drawTime;
+    final public String key;
+    public int loadedFrom;
+    public Exception exception;
+    public File fontFile;
+
+    public TypefaceInfo(String key, Typeface typeface, int fileSize) {
+        this.typeface = typeface;
+        this.key = key;
+        this.fileSize = fileSize;
+    }
+
+    public int sizeOf() {
+        return fileSize;
+    }
+}
diff --git a/ion/src/com/koushikdutta/ion/future/ImageViewFuture.java b/ion/src/com/koushikdutta/ion/future/ImageViewFuture.java_
similarity index 91%
rename from ion/src/com/koushikdutta/ion/future/ImageViewFuture.java
rename to ion/src/com/koushikdutta/ion/future/ImageViewFuture.java_
index ab7711d8..2bde7c1d 100644
--- a/ion/src/com/koushikdutta/ion/future/ImageViewFuture.java
+++ b/ion/src/com/koushikdutta/ion/future/ImageViewFuture.java_
@@ -7,6 +7,7 @@
 
 /**
  * Created by koush on 7/1/14.
+  TODO  这个好像没啥用
  */
 public interface ImageViewFuture extends Future<ImageView> {
     Future<ImageViewBitmapInfo> withBitmapInfo();
diff --git a/ion/src/com/koushikdutta/ion/gif/GifAction.java b/ion/src/com/koushikdutta/ion/gif/GifAction.java
index 856e5d6d..50187f09 100755
--- a/ion/src/com/koushikdutta/ion/gif/GifAction.java
+++ b/ion/src/com/koushikdutta/ion/gif/GifAction.java
@@ -1,5 +1,5 @@
-package com.koushikdutta.ion.gif;
-
-public interface GifAction {
-    public boolean parseOk(boolean parseStatus, int frameIndex);
-}
+package com.koushikdutta.ion.gif;
+
+public interface GifAction {
+    public boolean parseOk(boolean parseStatus, int frameIndex);
+}
diff --git a/ion/src/com/koushikdutta/ion/gif/GifDecoder.java b/ion/src/com/koushikdutta/ion/gif/GifDecoder.java
index 6bda5129..b6e71eb2 100755
--- a/ion/src/com/koushikdutta/ion/gif/GifDecoder.java
+++ b/ion/src/com/koushikdutta/ion/gif/GifDecoder.java
@@ -1,707 +1,707 @@
-package com.koushikdutta.ion.gif;
-
-import java.io.ByteArrayInputStream;
-import java.io.InputStream;
-import java.lang.reflect.Array;
-import java.nio.ByteBuffer;
-import java.nio.ByteOrder;
-import java.nio.IntBuffer;
-import java.util.Arrays;
-
-import android.graphics.Bitmap;
-import android.graphics.Bitmap.Config;
-import android.util.Log;
-
-public class GifDecoder extends Thread{
-
-	public static final int STATUS_PARSING = 0;
-	public static final int STATUS_FORMAT_ERROR = 1;
-	public static final int STATUS_OPEN_ERROR = 2;
-	public static final int STATUS_FINISH = -1;
-	
-	private InputStream in;
-	private int status;
-
-	public int width; // full image width
-	public int height; // full image height
-	private boolean gctFlag; // global color table used
-	private int gctSize; // size of global color table
-	private int loopCount = 1; // iterations; 0 = repeat forever
-
-	private int[] gct; // global color table
-	private int[] lct; // local color table
-	private int[] act; // active color table
-
-	private int bgIndex; // background color index
-	private int bgColor; // background color
-	private int lastBgColor; // previous bg color
-	private int pixelAspect; // pixel aspect ratio
-
-	private boolean lctFlag; // local color table flag
-	private boolean interlace; // interlace flag
-	private int lctSize; // local color table size
-
-	private int ix, iy, iw, ih; // current image rectangle
-	private int lrx, lry, lrw, lrh;
-	private GifFrame currentFrame = null;
-
-	private boolean isShow = false;
-	
-
-	private byte[] block = new byte[256]; // current data block
-	private int blockSize = 0; // block size
-	private int dispose = 0;
-	private int lastDispose = 0;
-	private boolean transparency = false; // use transparent color
-	private int delay = 0; // delay in milliseconds
-	private int transIndex; // transparent color index
-
-	private static final int MaxStackSize = 4096;
-	// max decoder pixel stack size
-
-	// LZW decoder working arrays
-	private short[] prefix;
-	private byte[] suffix;
-	private byte[] pixelStack;
-	private byte[] pixels;
-
-	private GifFrame gifFrame; // frames read from current file
-	private int frameCount;
-
-	private GifAction action = null;
-	
-	
-	private byte[] gifData = null;
-	private int gifDataOffset;
-	private int gifDataLength;
-
-
-	public GifDecoder(byte[] data,GifAction act){
-		this(data, 0, data.length, act);
-	}
-
-	public GifDecoder(byte[] data,int offset,int length,GifAction act){
-		gifData = data;
-		action = act;
-		gifDataOffset = offset;
-		gifDataLength = length;
-	}
-	
-	public GifDecoder(InputStream is,GifAction act){
-		in = is;
-		action = act;
-	}
-
-	public void run(){
-		if(in != null){
-                  readStream();
-		}else if(gifData != null){
-                  readByte();
-		}
-	}
-	
-	public void free(){
-		GifFrame fg = gifFrame;
-		while(fg != null){
-            if (fg.image != null) {
-                fg.image.recycle();
-            }
-			fg.image = null;
-			fg = null;
-			gifFrame = gifFrame.nextFrame;
-			fg = gifFrame;
-		}
-		if(in != null){
-			try{
-			in.close();
-			}catch(Exception ex){}
-			in = null;
-		}
-		gifData = null;
-	}
-	
-	public int getStatus(){
-		return status;
-	}
-	
-	public boolean parseOk(){
-		return status == STATUS_FINISH;
-	}
-	
-	public int getDelay(int n) {
-		delay = -1;
-		if ((n >= 0) && (n < frameCount)) {
-			GifFrame f = getFrame(n);
-			if (f != null)
-				delay = f.delay;
-		}
-		return delay;
-	}
-	
-	public int[] getDelays(){
-		GifFrame f = gifFrame;
-		int[] d = new int[frameCount];
-		int i = 0;
-		while(f != null && i < frameCount){
-			d[i] = f.delay;
-			f = f.nextFrame;
-			i++;
-		}
-		return d;
-	}
-	
-	public int getFrameCount() {
-		return frameCount;
-	}
-
-	public Bitmap getImage() {
-		return getFrameImage(0);
-	}
-
-	public int getLoopCount() {
-		return loopCount;
-	}
-
-    int[] lastPixels;
-    int[] dest;
-	private Bitmap setPixels() {
-        if (dest == null)
-            dest = new int[width * height];
-		// fill in starting image contents based on last image's dispose code
-		if (lastDispose > 0) {
-			if (lastDispose == 3) {
-				// use image before last
-				int n = frameCount - 2;
-				if (n > 0) {
-					Bitmap lastImage = getFrameImage(n - 1);
-                    if (lastPixels == null)
-                        lastPixels = new int[width * height];
-                    lastImage.getPixels(lastPixels, 0, width, 0, 0, width, height);
-				}
-                else {
-                    lastPixels = null;
-                }
-            }
-			if (lastPixels != null) {
-                dest = Arrays.copyOf(lastPixels, lastPixels.length);
-                // copy pixels
-				if (lastDispose == 2) {
-					// fill last image rect area with background color
-					int c = 0;
-					if (!transparency) {
-						c = lastBgColor;
-					}
-					for (int i = 0; i < lrh; i++) {
-						int n1 = (lry + i) * width + lrx;
-						int n2 = n1 + lrw;
-						for (int k = n1; k < n2; k++) {
-							dest[k] = c;
-						}
-					}
-				}
-			}
-		}
-
-		// copy each source line to the appropriate place in the destination
-		int pass = 1;
-		int inc = 8;
-		int iline = 0;
-		for (int i = 0; i < ih; i++) {
-			int line = i;
-			if (interlace) {
-				if (iline >= ih) {
-					pass++;
-					switch (pass) {
-					case 2:
-						iline = 4;
-						break;
-					case 3:
-						iline = 2;
-						inc = 4;
-						break;
-					case 4:
-						iline = 1;
-						inc = 2;
-					}
-				}
-				line = iline;
-				iline += inc;
-			}
-			line += iy;
-			if (line < height) {
-				int k = line * width;
-				int dx = k + ix; // start of line in dest
-				int dlim = dx + iw; // end of dest line
-				if ((k + width) < dlim) {
-					dlim = k + width; // past dest edge
-				}
-				int sx = i * iw; // start of line in source
-				while (dx < dlim) {
-					// map color and insert in destination
-					int index = ((int) pixels[sx++]) & 0xff;
-					int c = act[index];
-					if (c != 0) {
-						dest[dx] = c;
-					}
-					dx++;
-				}
-			}
-		}
-		return Bitmap.createBitmap(dest, width, height, Config.ARGB_4444);
-	}
-
-	public Bitmap getFrameImage(int n) {
-		GifFrame frame = getFrame(n);	
-		if (frame == null)
-			return null;
-		else
-			return frame.image;
-	}
-
-	public GifFrame getCurrentFrame(){
-		return currentFrame;
-	}
-	
-	public GifFrame getFrame(int n) {
-		GifFrame frame = gifFrame;
-		int i = 0;
-		while (frame != null) {
-			if (i == n) {
-				return frame;
-			} else {
-				frame = frame.nextFrame;
-			}
-			i++;
-		}
-		return null;
-	}
-
-	public void reset(){
-		currentFrame = gifFrame;
-	}
-	
-	public GifFrame next() {	
-		if(isShow == false){
-			isShow = true;
-			return gifFrame;
-		}else{	
-			if(status == STATUS_PARSING){
-				if(currentFrame.nextFrame != null)
-					currentFrame = currentFrame.nextFrame;			
-				//currentFrame = gifFrame;
-			}else{			
-				currentFrame = currentFrame.nextFrame;
-				if (currentFrame == null) {
-					currentFrame = gifFrame;
-				}
-			}
-			return currentFrame;
-		}
-	}
-
-	private int readByte(){
-		in = new ByteArrayInputStream(gifData,gifDataOffset,gifDataLength);
-		gifData = null;
-		return readStream();
-	}
-	
-	private int readStream(){
-		init();
-		if(in != null){
-			readHeader();
-			if(!err()){
-				readContents();
-				if(frameCount < 0){
-					status = STATUS_FORMAT_ERROR;
-					action.parseOk(false,-1);
-				}else{
-					status = STATUS_FINISH;
-					action.parseOk(true,-1);
-				}
-			}
-			try {
-				in.close();
-			} catch (Exception e) {
-				e.printStackTrace();
-			}
-			
-		}else {
-			status = STATUS_OPEN_ERROR;
-			action.parseOk(false,-1);
-		}
-		return status;
-	}
-
-	private void decodeImageData() {
-		int NullCode = -1;
-		int npix = iw * ih;
-		int available, clear, code_mask, code_size, end_of_information, in_code, old_code, bits, code, count, i, datum, data_size, first, top, bi, pi;
-
-		if ((pixels == null) || (pixels.length < npix)) {
-			pixels = new byte[npix]; // allocate new pixel array
-		}
-		if (prefix == null) {
-			prefix = new short[MaxStackSize];
-		}
-		if (suffix == null) {
-			suffix = new byte[MaxStackSize];
-		}
-		if (pixelStack == null) {
-			pixelStack = new byte[MaxStackSize + 1];
-		}
-		// Initialize GIF data stream decoder.
-		data_size = read();
-		clear = 1 << data_size;
-		end_of_information = clear + 1;
-		available = clear + 2;
-		old_code = NullCode;
-		code_size = data_size + 1;
-		code_mask = (1 << code_size) - 1;
-		for (code = 0; code < clear; code++) {
-			prefix[code] = 0;
-			suffix[code] = (byte) code;
-		}
-
-		// Decode GIF pixel stream.
-		datum = bits = count = first = top = pi = bi = 0;
-		for (i = 0; i < npix;) {
-			if (top == 0) {
-				if (bits < code_size) {
-					// Load bytes until there are enough bits for a code.
-					if (count == 0) {
-						// Read a new data block.
-						count = readBlock();
-						if (count <= 0) {
-							break;
-						}
-						bi = 0;
-					}
-					datum += (((int) block[bi]) & 0xff) << bits;
-					bits += 8;
-					bi++;
-					count--;
-					continue;
-				}
-				// Get the next code.
-				code = datum & code_mask;
-				datum >>= code_size;
-				bits -= code_size;
-
-				// Interpret the code
-				if ((code > available) || (code == end_of_information)) {
-					break;
-				}
-				if (code == clear) {
-					// Reset decoder.
-					code_size = data_size + 1;
-					code_mask = (1 << code_size) - 1;
-					available = clear + 2;
-					old_code = NullCode;
-					continue;
-				}
-				if (old_code == NullCode) {
-					pixelStack[top++] = suffix[code];
-					old_code = code;
-					first = code;
-					continue;
-				}
-				in_code = code;
-				if (code == available) {
-					pixelStack[top++] = (byte) first;
-					code = old_code;
-				}
-				while (code > clear) {
-					pixelStack[top++] = suffix[code];
-					code = prefix[code];
-				}
-				first = ((int) suffix[code]) & 0xff;
-				// Add a new string to the string table,
-				if (available >= MaxStackSize) {
-					break;
-				}
-				pixelStack[top++] = (byte) first;
-				prefix[available] = (short) old_code;
-				suffix[available] = (byte) first;
-				available++;
-				if (((available & code_mask) == 0)
-						&& (available < MaxStackSize)) {
-					code_size++;
-					code_mask += available;
-				}
-				old_code = in_code;
-			}
-
-			// Pop a pixel off the pixel stack.
-			top--;
-			pixels[pi++] = pixelStack[top];
-			i++;
-		}
-		for (i = pi; i < npix; i++) {
-			pixels[i] = 0; // clear missing pixels
-		}
-	}
-
-	private boolean err() {
-		return status != STATUS_PARSING;
-	}
-
-	private void init() {
-		status = STATUS_PARSING;
-		frameCount = 0;
-		gifFrame = null;
-		gct = null;
-		lct = null;
-	}
-
-	private int read() {
-		int curByte = 0;
-		try {
-			
-			curByte = in.read();
-		} catch (Exception e) {
-			status = STATUS_FORMAT_ERROR;
-		}
-		return curByte;
-	}
-	
-	private int readBlock() {
-		blockSize = read();
-		int n = 0;
-		if (blockSize > 0) {
-			try {
-				int count = 0;
-				while (n < blockSize) {
-					count = in.read(block, n, blockSize - n);
-					if (count == -1) {
-						break;
-					}
-					n += count;
-				}
-			} catch (Exception e) {
-				e.printStackTrace();
-			}
-			if (n < blockSize) {
-				status = STATUS_FORMAT_ERROR;
-			}
-		}
-		return n;
-	}
-
-	private int[] readColorTable(int ncolors) {
-		int nbytes = 3 * ncolors;
-		int[] tab = null;
-		byte[] c = new byte[nbytes];
-		int n = 0;
-		try {
-			n = in.read(c);
-		} catch (Exception e) {
-			e.printStackTrace();
-		}
-		if (n < nbytes) {
-			status = STATUS_FORMAT_ERROR;
-		} else {
-			tab = new int[256]; // max size to avoid bounds checks
-			int i = 0;
-			int j = 0;
-			while (i < ncolors) {
-				int r = ((int) c[j++]) & 0xff;
-				int g = ((int) c[j++]) & 0xff;
-				int b = ((int) c[j++]) & 0xff;
-				tab[i++] = 0xff000000 | (r << 16) | (g << 8) | b;
-			}
-		}
-		return tab;
-	}
-
-	private void readContents() {
-		// read GIF file content blocks
-		boolean done = false;
-		while (!(done || err())) {
-			int code = read();
-			switch (code) {
-			case 0x2C: // image separator
-				readImage();
-				break;
-			case 0x21: // extension
-				code = read();
-				switch (code) {
-				case 0xf9: // graphics control extension
-					readGraphicControlExt();
-					break;
-				case 0xff: // application extension
-					readBlock();
-					String app = "";
-					for (int i = 0; i < 11; i++) {
-						app += (char) block[i];
-					}
-					if (app.equals("NETSCAPE2.0")) {
-						readNetscapeExt();
-					} else {
-						skip(); // don't care
-					}
-					break;
-				default: // uninteresting extension
-					skip();
-				}
-				break;
-			case 0x3b: // terminator
-				done = true;
-				break;
-			case 0x00: // bad byte, but keep going and see what happens
-				break;
-			default:
-				status = STATUS_FORMAT_ERROR;
-			}
-		}
-	}
-
-	private void readGraphicControlExt() {
-		read(); // block size
-		int packed = read(); // packed fields
-		dispose = (packed & 0x1c) >> 2; // disposal method
-		if (dispose == 0) {
-			dispose = 1; // elect to keep old image if discretionary
-		}
-		transparency = (packed & 1) != 0;
-		delay = readShort() * 10; // delay in milliseconds
-		transIndex = read(); // transparent color index
-		read(); // block terminator
-	}
-
-	private void readHeader() {
-		String id = "";
-		for (int i = 0; i < 6; i++) {
-			id += (char) read();
-		}
-		if (!id.startsWith("GIF")) {
-			status = STATUS_FORMAT_ERROR;
-			return;
-		}
-		readLSD();
-		if (gctFlag && !err()) {
-			gct = readColorTable(gctSize);
-			bgColor = gct[bgIndex];
-		}
-	}
-
-	private void readImage() {
-		ix = readShort(); // (sub)image position & size
-		iy = readShort();
-		iw = readShort();
-		ih = readShort();
-		int packed = read();
-		lctFlag = (packed & 0x80) != 0; // 1 - local color table flag
-		interlace = (packed & 0x40) != 0; // 2 - interlace flag
-		// 3 - sort flag
-		// 4-5 - reserved
-		lctSize = 2 << (packed & 7); // 6-8 - local color table size
-		if (lctFlag) {
-			lct = readColorTable(lctSize); // read table
-			act = lct; // make local table active
-		} else {
-			act = gct; // make global table active
-			if (bgIndex == transIndex) {
-				bgColor = 0;
-			}
-		}
-		int save = 0;
-		if (transparency) {
-			save = act[transIndex];
-			act[transIndex] = 0; // set transparent color if specified
-		}
-		if (act == null) {
-			status = STATUS_FORMAT_ERROR; // no color table defined
-		}
-		if (err()) {
-			return;
-		}
-        try {
-    		decodeImageData(); // decode pixel data
-    		skip();
-    		if (err()) {
-    			return;
-    		}
-    		frameCount++;
-    		// create new image to receive frame data
-    		// createImage(width, height);
-    		Bitmap image = setPixels(); // transfer pixel data to image
-    		if (gifFrame == null) {
-    			gifFrame = new GifFrame(image, delay);
-    			currentFrame = gifFrame;
-    		} else {
-    			GifFrame f = gifFrame;
-    			while(f.nextFrame != null){
-    				f = f.nextFrame;
-    			}
-    			f.nextFrame = new GifFrame(image, delay);
-    		}
-    		// frames.addElement(new GifFrame(image, delay)); // add image to frame
-    		// list
-    		if (transparency) {
-    			act[transIndex] = save;
-    		}
-    		resetFrame();
-    		if (!action.parseOk(true, frameCount)) {
-                status = STATUS_FINISH;
-                return;
-            }
-        }catch (OutOfMemoryError e) {
-            Log.e("GifDecoder", ">>> log  : " + e.toString());
-            e.printStackTrace();
-        }
-	}
-
-	private void readLSD() {
-		// logical screen size
-		width = readShort();
-		height = readShort();
-		// packed fields
-		int packed = read();
-		gctFlag = (packed & 0x80) != 0; // 1 : global color table flag
-		// 2-4 : color resolution
-		// 5 : gct sort flag
-		gctSize = 2 << (packed & 7); // 6-8 : gct size
-		bgIndex = read(); // background color index
-		pixelAspect = read(); // pixel aspect ratio
-	}
-
-	private void readNetscapeExt() {
-		do {
-			readBlock();
-			if (block[0] == 1) {
-				// loop count sub-block
-				int b1 = ((int) block[1]) & 0xff;
-				int b2 = ((int) block[2]) & 0xff;
-				loopCount = (b2 << 8) | b1;
-			}
-		} while ((blockSize > 0) && !err());
-	}
-
-	private int readShort() {
-		// read 16-bit value, LSB first
-		return read() | (read() << 8);
-	}
-
-	private void resetFrame() {
-		lastDispose = dispose;
-		lrx = ix;
-		lry = iy;
-		lrw = iw;
-		lrh = ih;
-        lastPixels = dest;
-		lastBgColor = bgColor;
-		dispose = 0;
-		transparency = false;
-		delay = 0;
-		lct = null;
-	}
-
-	/**
-	 * Skips variable length blocks up to and including next zero length block.
-	 */
-	private void skip() {
-		do {
-			readBlock();
-		} while ((blockSize > 0) && !err());
-	}
-}
+package com.koushikdutta.ion.gif;
+
+import java.io.ByteArrayInputStream;
+import java.io.InputStream;
+import java.lang.reflect.Array;
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.nio.IntBuffer;
+import java.util.Arrays;
+
+import android.graphics.Bitmap;
+import android.graphics.Bitmap.Config;
+import android.util.Log;
+
+public class GifDecoder extends Thread{
+
+	public static final int STATUS_PARSING = 0;
+	public static final int STATUS_FORMAT_ERROR = 1;
+	public static final int STATUS_OPEN_ERROR = 2;
+	public static final int STATUS_FINISH = -1;
+	
+	private InputStream in;
+	private int status;
+
+	public int width; // full image width
+	public int height; // full image height
+	private boolean gctFlag; // global color table used
+	private int gctSize; // size of global color table
+	private int loopCount = 1; // iterations; 0 = repeat forever
+
+	private int[] gct; // global color table
+	private int[] lct; // local color table
+	private int[] act; // active color table
+
+	private int bgIndex; // background color index
+	private int bgColor; // background color
+	private int lastBgColor; // previous bg color
+	private int pixelAspect; // pixel aspect ratio
+
+	private boolean lctFlag; // local color table flag
+	private boolean interlace; // interlace flag
+	private int lctSize; // local color table size
+
+	private int ix, iy, iw, ih; // current image rectangle
+	private int lrx, lry, lrw, lrh;
+	private GifFrame currentFrame = null;
+
+	private boolean isShow = false;
+	
+
+	private byte[] block = new byte[256]; // current data block
+	private int blockSize = 0; // block size
+	private int dispose = 0;
+	private int lastDispose = 0;
+	private boolean transparency = false; // use transparent color
+	private int delay = 0; // delay in milliseconds
+	private int transIndex; // transparent color index
+
+	private static final int MaxStackSize = 4096;
+	// max decoder pixel stack size
+
+	// LZW decoder working arrays
+	private short[] prefix;
+	private byte[] suffix;
+	private byte[] pixelStack;
+	private byte[] pixels;
+
+	private GifFrame gifFrame; // frames read from current file
+	private int frameCount;
+
+	private GifAction action = null;
+	
+	
+	private byte[] gifData = null;
+	private int gifDataOffset;
+	private int gifDataLength;
+
+
+	public GifDecoder(byte[] data,GifAction act){
+		this(data, 0, data.length, act);
+	}
+
+	public GifDecoder(byte[] data,int offset,int length,GifAction act){
+		gifData = data;
+		action = act;
+		gifDataOffset = offset;
+		gifDataLength = length;
+	}
+	
+	public GifDecoder(InputStream is,GifAction act){
+		in = is;
+		action = act;
+	}
+
+	public void run(){
+		if(in != null){
+                  readStream();
+		}else if(gifData != null){
+                  readByte();
+		}
+	}
+	
+	public void free(){
+		GifFrame fg = gifFrame;
+		while(fg != null){
+            if (fg.image != null) {
+                fg.image.recycle();
+            }
+			fg.image = null;
+			fg = null;
+			gifFrame = gifFrame.nextFrame;
+			fg = gifFrame;
+		}
+		if(in != null){
+			try{
+			in.close();
+			}catch(Exception ex){}
+			in = null;
+		}
+		gifData = null;
+	}
+	
+	public int getStatus(){
+		return status;
+	}
+	
+	public boolean parseOk(){
+		return status == STATUS_FINISH;
+	}
+	
+	public int getDelay(int n) {
+		delay = -1;
+		if ((n >= 0) && (n < frameCount)) {
+			GifFrame f = getFrame(n);
+			if (f != null)
+				delay = f.delay;
+		}
+		return delay;
+	}
+	
+	public int[] getDelays(){
+		GifFrame f = gifFrame;
+		int[] d = new int[frameCount];
+		int i = 0;
+		while(f != null && i < frameCount){
+			d[i] = f.delay;
+			f = f.nextFrame;
+			i++;
+		}
+		return d;
+	}
+	
+	public int getFrameCount() {
+		return frameCount;
+	}
+
+	public Bitmap getImage() {
+		return getFrameImage(0);
+	}
+
+	public int getLoopCount() {
+		return loopCount;
+	}
+
+    int[] lastPixels;
+    int[] dest;
+	private Bitmap setPixels() {
+        if (dest == null)
+            dest = new int[width * height];
+		// fill in starting image contents based on last image's dispose code
+		if (lastDispose > 0) {
+			if (lastDispose == 3) {
+				// use image before last
+				int n = frameCount - 2;
+				if (n > 0) {
+					Bitmap lastImage = getFrameImage(n - 1);
+                    if (lastPixels == null)
+                        lastPixels = new int[width * height];
+                    lastImage.getPixels(lastPixels, 0, width, 0, 0, width, height);
+				}
+                else {
+                    lastPixels = null;
+                }
+            }
+			if (lastPixels != null) {
+                dest = Arrays.copyOf(lastPixels, lastPixels.length);
+                // copy pixels
+				if (lastDispose == 2) {
+					// fill last image rect area with background color
+					int c = 0;
+					if (!transparency) {
+						c = lastBgColor;
+					}
+					for (int i = 0; i < lrh; i++) {
+						int n1 = (lry + i) * width + lrx;
+						int n2 = n1 + lrw;
+						for (int k = n1; k < n2; k++) {
+							dest[k] = c;
+						}
+					}
+				}
+			}
+		}
+
+		// copy each source line to the appropriate place in the destination
+		int pass = 1;
+		int inc = 8;
+		int iline = 0;
+		for (int i = 0; i < ih; i++) {
+			int line = i;
+			if (interlace) {
+				if (iline >= ih) {
+					pass++;
+					switch (pass) {
+					case 2:
+						iline = 4;
+						break;
+					case 3:
+						iline = 2;
+						inc = 4;
+						break;
+					case 4:
+						iline = 1;
+						inc = 2;
+					}
+				}
+				line = iline;
+				iline += inc;
+			}
+			line += iy;
+			if (line < height) {
+				int k = line * width;
+				int dx = k + ix; // start of line in dest
+				int dlim = dx + iw; // end of dest line
+				if ((k + width) < dlim) {
+					dlim = k + width; // past dest edge
+				}
+				int sx = i * iw; // start of line in source
+				while (dx < dlim) {
+					// map color and insert in destination
+					int index = ((int) pixels[sx++]) & 0xff;
+					int c = act[index];
+					if (c != 0) {
+						dest[dx] = c;
+					}
+					dx++;
+				}
+			}
+		}
+		return Bitmap.createBitmap(dest, width, height, Config.ARGB_4444);
+	}
+
+	public Bitmap getFrameImage(int n) {
+		GifFrame frame = getFrame(n);	
+		if (frame == null)
+			return null;
+		else
+			return frame.image;
+	}
+
+	public GifFrame getCurrentFrame(){
+		return currentFrame;
+	}
+	
+	public GifFrame getFrame(int n) {
+		GifFrame frame = gifFrame;
+		int i = 0;
+		while (frame != null) {
+			if (i == n) {
+				return frame;
+			} else {
+				frame = frame.nextFrame;
+			}
+			i++;
+		}
+		return null;
+	}
+
+	public void reset(){
+		currentFrame = gifFrame;
+	}
+	
+	public GifFrame next() {	
+		if(isShow == false){
+			isShow = true;
+			return gifFrame;
+		}else{	
+			if(status == STATUS_PARSING){
+				if(currentFrame.nextFrame != null)
+					currentFrame = currentFrame.nextFrame;			
+				//currentFrame = gifFrame;
+			}else{			
+				currentFrame = currentFrame.nextFrame;
+				if (currentFrame == null) {
+					currentFrame = gifFrame;
+				}
+			}
+			return currentFrame;
+		}
+	}
+
+	private int readByte(){
+		in = new ByteArrayInputStream(gifData,gifDataOffset,gifDataLength);
+		gifData = null;
+		return readStream();
+	}
+	
+	private int readStream(){
+		init();
+		if(in != null){
+			readHeader();
+			if(!err()){
+				readContents();
+				if(frameCount < 0){
+					status = STATUS_FORMAT_ERROR;
+					action.parseOk(false,-1);
+				}else{
+					status = STATUS_FINISH;
+					action.parseOk(true,-1);
+				}
+			}
+			try {
+				in.close();
+			} catch (Exception e) {
+				e.printStackTrace();
+			}
+			
+		}else {
+			status = STATUS_OPEN_ERROR;
+			action.parseOk(false,-1);
+		}
+		return status;
+	}
+
+	private void decodeImageData() {
+		int NullCode = -1;
+		int npix = iw * ih;
+		int available, clear, code_mask, code_size, end_of_information, in_code, old_code, bits, code, count, i, datum, data_size, first, top, bi, pi;
+
+		if ((pixels == null) || (pixels.length < npix)) {
+			pixels = new byte[npix]; // allocate new pixel array
+		}
+		if (prefix == null) {
+			prefix = new short[MaxStackSize];
+		}
+		if (suffix == null) {
+			suffix = new byte[MaxStackSize];
+		}
+		if (pixelStack == null) {
+			pixelStack = new byte[MaxStackSize + 1];
+		}
+		// Initialize GIF data stream decoder.
+		data_size = read();
+		clear = 1 << data_size;
+		end_of_information = clear + 1;
+		available = clear + 2;
+		old_code = NullCode;
+		code_size = data_size + 1;
+		code_mask = (1 << code_size) - 1;
+		for (code = 0; code < clear; code++) {
+			prefix[code] = 0;
+			suffix[code] = (byte) code;
+		}
+
+		// Decode GIF pixel stream.
+		datum = bits = count = first = top = pi = bi = 0;
+		for (i = 0; i < npix;) {
+			if (top == 0) {
+				if (bits < code_size) {
+					// Load bytes until there are enough bits for a code.
+					if (count == 0) {
+						// Read a new data block.
+						count = readBlock();
+						if (count <= 0) {
+							break;
+						}
+						bi = 0;
+					}
+					datum += (((int) block[bi]) & 0xff) << bits;
+					bits += 8;
+					bi++;
+					count--;
+					continue;
+				}
+				// Get the next code.
+				code = datum & code_mask;
+				datum >>= code_size;
+				bits -= code_size;
+
+				// Interpret the code
+				if ((code > available) || (code == end_of_information)) {
+					break;
+				}
+				if (code == clear) {
+					// Reset decoder.
+					code_size = data_size + 1;
+					code_mask = (1 << code_size) - 1;
+					available = clear + 2;
+					old_code = NullCode;
+					continue;
+				}
+				if (old_code == NullCode) {
+					pixelStack[top++] = suffix[code];
+					old_code = code;
+					first = code;
+					continue;
+				}
+				in_code = code;
+				if (code == available) {
+					pixelStack[top++] = (byte) first;
+					code = old_code;
+				}
+				while (code > clear) {
+					pixelStack[top++] = suffix[code];
+					code = prefix[code];
+				}
+				first = ((int) suffix[code]) & 0xff;
+				// Add a new string to the string table,
+				if (available >= MaxStackSize) {
+					break;
+				}
+				pixelStack[top++] = (byte) first;
+				prefix[available] = (short) old_code;
+				suffix[available] = (byte) first;
+				available++;
+				if (((available & code_mask) == 0)
+						&& (available < MaxStackSize)) {
+					code_size++;
+					code_mask += available;
+				}
+				old_code = in_code;
+			}
+
+			// Pop a pixel off the pixel stack.
+			top--;
+			pixels[pi++] = pixelStack[top];
+			i++;
+		}
+		for (i = pi; i < npix; i++) {
+			pixels[i] = 0; // clear missing pixels
+		}
+	}
+
+	private boolean err() {
+		return status != STATUS_PARSING;
+	}
+
+	private void init() {
+		status = STATUS_PARSING;
+		frameCount = 0;
+		gifFrame = null;
+		gct = null;
+		lct = null;
+	}
+
+	private int read() {
+		int curByte = 0;
+		try {
+			
+			curByte = in.read();
+		} catch (Exception e) {
+			status = STATUS_FORMAT_ERROR;
+		}
+		return curByte;
+	}
+	
+	private int readBlock() {
+		blockSize = read();
+		int n = 0;
+		if (blockSize > 0) {
+			try {
+				int count = 0;
+				while (n < blockSize) {
+					count = in.read(block, n, blockSize - n);
+					if (count == -1) {
+						break;
+					}
+					n += count;
+				}
+			} catch (Exception e) {
+				e.printStackTrace();
+			}
+			if (n < blockSize) {
+				status = STATUS_FORMAT_ERROR;
+			}
+		}
+		return n;
+	}
+
+	private int[] readColorTable(int ncolors) {
+		int nbytes = 3 * ncolors;
+		int[] tab = null;
+		byte[] c = new byte[nbytes];
+		int n = 0;
+		try {
+			n = in.read(c);
+		} catch (Exception e) {
+			e.printStackTrace();
+		}
+		if (n < nbytes) {
+			status = STATUS_FORMAT_ERROR;
+		} else {
+			tab = new int[256]; // max size to avoid bounds checks
+			int i = 0;
+			int j = 0;
+			while (i < ncolors) {
+				int r = ((int) c[j++]) & 0xff;
+				int g = ((int) c[j++]) & 0xff;
+				int b = ((int) c[j++]) & 0xff;
+				tab[i++] = 0xff000000 | (r << 16) | (g << 8) | b;
+			}
+		}
+		return tab;
+	}
+
+	private void readContents() {
+		// read GIF file content blocks
+		boolean done = false;
+		while (!(done || err())) {
+			int code = read();
+			switch (code) {
+			case 0x2C: // image separator
+				readImage();
+				break;
+			case 0x21: // extension
+				code = read();
+				switch (code) {
+				case 0xf9: // graphics control extension
+					readGraphicControlExt();
+					break;
+				case 0xff: // application extension
+					readBlock();
+					String app = "";
+					for (int i = 0; i < 11; i++) {
+						app += (char) block[i];
+					}
+					if (app.equals("NETSCAPE2.0")) {
+						readNetscapeExt();
+					} else {
+						skip(); // don't care
+					}
+					break;
+				default: // uninteresting extension
+					skip();
+				}
+				break;
+			case 0x3b: // terminator
+				done = true;
+				break;
+			case 0x00: // bad byte, but keep going and see what happens
+				break;
+			default:
+				status = STATUS_FORMAT_ERROR;
+			}
+		}
+	}
+
+	private void readGraphicControlExt() {
+		read(); // block size
+		int packed = read(); // packed fields
+		dispose = (packed & 0x1c) >> 2; // disposal method
+		if (dispose == 0) {
+			dispose = 1; // elect to keep old image if discretionary
+		}
+		transparency = (packed & 1) != 0;
+		delay = readShort() * 10; // delay in milliseconds
+		transIndex = read(); // transparent color index
+		read(); // block terminator
+	}
+
+	private void readHeader() {
+		String id = "";
+		for (int i = 0; i < 6; i++) {
+			id += (char) read();
+		}
+		if (!id.startsWith("GIF")) {
+			status = STATUS_FORMAT_ERROR;
+			return;
+		}
+		readLSD();
+		if (gctFlag && !err()) {
+			gct = readColorTable(gctSize);
+			bgColor = gct[bgIndex];
+		}
+	}
+
+	private void readImage() {
+		ix = readShort(); // (sub)image position & size
+		iy = readShort();
+		iw = readShort();
+		ih = readShort();
+		int packed = read();
+		lctFlag = (packed & 0x80) != 0; // 1 - local color table flag
+		interlace = (packed & 0x40) != 0; // 2 - interlace flag
+		// 3 - sort flag
+		// 4-5 - reserved
+		lctSize = 2 << (packed & 7); // 6-8 - local color table size
+		if (lctFlag) {
+			lct = readColorTable(lctSize); // read table
+			act = lct; // make local table active
+		} else {
+			act = gct; // make global table active
+			if (bgIndex == transIndex) {
+				bgColor = 0;
+			}
+		}
+		int save = 0;
+		if (transparency) {
+			save = act[transIndex];
+			act[transIndex] = 0; // set transparent color if specified
+		}
+		if (act == null) {
+			status = STATUS_FORMAT_ERROR; // no color table defined
+		}
+		if (err()) {
+			return;
+		}
+        try {
+    		decodeImageData(); // decode pixel data
+    		skip();
+    		if (err()) {
+    			return;
+    		}
+    		frameCount++;
+    		// create new image to receive frame data
+    		// createImage(width, height);
+    		Bitmap image = setPixels(); // transfer pixel data to image
+    		if (gifFrame == null) {
+    			gifFrame = new GifFrame(image, delay);
+    			currentFrame = gifFrame;
+    		} else {
+    			GifFrame f = gifFrame;
+    			while(f.nextFrame != null){
+    				f = f.nextFrame;
+    			}
+    			f.nextFrame = new GifFrame(image, delay);
+    		}
+    		// frames.addElement(new GifFrame(image, delay)); // add image to frame
+    		// list
+    		if (transparency) {
+    			act[transIndex] = save;
+    		}
+    		resetFrame();
+    		if (!action.parseOk(true, frameCount)) {
+                status = STATUS_FINISH;
+                return;
+            }
+        }catch (OutOfMemoryError e) {
+            Log.e("GifDecoder", ">>> log  : " + e.toString());
+            e.printStackTrace();
+        }
+	}
+
+	private void readLSD() {
+		// logical screen size
+		width = readShort();
+		height = readShort();
+		// packed fields
+		int packed = read();
+		gctFlag = (packed & 0x80) != 0; // 1 : global color table flag
+		// 2-4 : color resolution
+		// 5 : gct sort flag
+		gctSize = 2 << (packed & 7); // 6-8 : gct size
+		bgIndex = read(); // background color index
+		pixelAspect = read(); // pixel aspect ratio
+	}
+
+	private void readNetscapeExt() {
+		do {
+			readBlock();
+			if (block[0] == 1) {
+				// loop count sub-block
+				int b1 = ((int) block[1]) & 0xff;
+				int b2 = ((int) block[2]) & 0xff;
+				loopCount = (b2 << 8) | b1;
+			}
+		} while ((blockSize > 0) && !err());
+	}
+
+	private int readShort() {
+		// read 16-bit value, LSB first
+		return read() | (read() << 8);
+	}
+
+	private void resetFrame() {
+		lastDispose = dispose;
+		lrx = ix;
+		lry = iy;
+		lrw = iw;
+		lrh = ih;
+        lastPixels = dest;
+		lastBgColor = bgColor;
+		dispose = 0;
+		transparency = false;
+		delay = 0;
+		lct = null;
+	}
+
+	/**
+	 * Skips variable length blocks up to and including next zero length block.
+	 */
+	private void skip() {
+		do {
+			readBlock();
+		} while ((blockSize > 0) && !err());
+	}
+}
diff --git a/ion/src/com/koushikdutta/ion/gif/GifFrame.java b/ion/src/com/koushikdutta/ion/gif/GifFrame.java
index a81d3bb3..d6f97dca 100755
--- a/ion/src/com/koushikdutta/ion/gif/GifFrame.java
+++ b/ion/src/com/koushikdutta/ion/gif/GifFrame.java
@@ -1,14 +1,14 @@
-package com.koushikdutta.ion.gif;
-
-import android.graphics.Bitmap;
-
-public class GifFrame {
-    public GifFrame(Bitmap im, int del) {
-        image = im;
-        delay = del;
-    }
-	
-    public Bitmap image;
-    public int delay;
-    public GifFrame nextFrame = null;
-}
+package com.koushikdutta.ion.gif;
+
+import android.graphics.Bitmap;
+
+public class GifFrame {
+    public GifFrame(Bitmap im, int del) {
+        image = im;
+        delay = del;
+    }
+	
+    public Bitmap image;
+    public int delay;
+    public GifFrame nextFrame = null;
+}
diff --git a/ion/src/com/koushikdutta/ion/loader/FileLoader.java b/ion/src/com/koushikdutta/ion/loader/FileLoader.java
index 6b2c9bb4..263db818 100644
--- a/ion/src/com/koushikdutta/ion/loader/FileLoader.java
+++ b/ion/src/com/koushikdutta/ion/loader/FileLoader.java
@@ -4,6 +4,7 @@
 import android.graphics.Bitmap;
 import android.graphics.BitmapFactory;
 import android.graphics.Point;
+import android.graphics.Typeface;
 import android.text.TextUtils;
 
 import com.koushikdutta.async.DataEmitter;
@@ -17,6 +18,7 @@
 import com.koushikdutta.ion.Loader;
 import com.koushikdutta.ion.bitmap.BitmapInfo;
 import com.koushikdutta.ion.bitmap.IonBitmapCache;
+import com.koushikdutta.ion.font.TypefaceInfo;
 import com.koushikdutta.ion.gif.GifAction;
 import com.koushikdutta.ion.gif.GifDecoder;
 
@@ -33,8 +35,41 @@
     }
 
     @Override
-    public Future<BitmapInfo> loadBitmap(final Context context, final Ion ion, final String key, final String uri, final int resizeWidth, final int resizeHeight,
-                                         final boolean animateGif) {
+    public Future<TypefaceInfo> loadTypeface(final Context context, final Ion ion, final String key, final String uri) {
+        if (uri == null || !uri.startsWith("file:/"))
+            return null;
+
+        final SimpleFuture<TypefaceInfo> ret = new SimpleFuture<TypefaceInfo>();
+
+        Ion.getBitmapLoadExecutorService().execute(new Runnable() {
+            @Override
+            public void run() {
+                if (ret.isCancelled()) {
+                    // Log.d("FileLoader", "Bitmap load cancelled (no longer needed)");
+                    return;
+                }
+                try {
+                    File file = new File(URI.create(uri));
+                    TypefaceInfo info;
+                    Typeface bitmap = Typeface.createFromFile(file);
+                    if (bitmap == null)
+                        throw new Exception("Bitmap failed to load");
+                    info = new TypefaceInfo(key, bitmap, (int) file.length());
+                    info.loadedFrom = Loader.LoaderEmitter.LOADED_FROM_CACHE;
+                    ret.setComplete(info);
+                } catch (OutOfMemoryError e) {
+                    ret.setComplete(new Exception(e), null);
+                } catch (Exception e) {
+                    ret.setComplete(e);
+                }
+            }
+        });
+
+        return ret;
+    }
+
+    @Override
+    public Future<BitmapInfo> loadBitmap(final Context context, final Ion ion, final String key, final String uri, final int resizeWidth, final int resizeHeight, final boolean animateGif) {
         if (uri == null || !uri.startsWith("file:/"))
             return null;
 
diff --git a/ion/src/com/koushikdutta/ion/loader/SimpleLoader.java b/ion/src/com/koushikdutta/ion/loader/SimpleLoader.java
index 8d285a1b..4ea4e530 100644
--- a/ion/src/com/koushikdutta/ion/loader/SimpleLoader.java
+++ b/ion/src/com/koushikdutta/ion/loader/SimpleLoader.java
@@ -9,6 +9,7 @@
 import com.koushikdutta.ion.Ion;
 import com.koushikdutta.ion.Loader;
 import com.koushikdutta.ion.bitmap.BitmapInfo;
+import com.koushikdutta.ion.font.TypefaceInfo;
 
 import java.io.InputStream;
 
@@ -35,4 +36,9 @@
     public Future<AsyncHttpRequest> resolve(Context context, Ion ion, AsyncHttpRequest request) {
         return null;
     }
+
+    @Override
+    public Future<TypefaceInfo> loadTypeface(Context context, Ion ion, String key, String uri) {
+        return null;
+    }
 }
