diff --git a/ion-sample/AndroidManifest.xml b/ion-sample/AndroidManifest.xml
index c1ced350..24d7fca0 100644
--- a/ion-sample/AndroidManifest.xml
+++ b/ion-sample/AndroidManifest.xml
@@ -24,8 +24,11 @@
                 android:name=".ProgressBarDownload"
                 android:label="Progress Bar Download"/>
         <activity
-                android:name=".GoogleImageSearch"
-                android:label="Google Image Search"/>
+            android:name=".GoogleImageSearch"
+            android:label="Google Image Search"/>
+        <activity
+            android:name=".GallerySample"
+            android:label="Gallery Sample"/>
         <activity
             android:name=".ImageViewSample"
             android:label="ImageView Sample"/>
diff --git a/ion-sample/res/layout/gallery.xml b/ion-sample/res/layout/gallery.xml
new file mode 100644
index 00000000..fa655a85
--- /dev/null
+++ b/ion-sample/res/layout/gallery.xml
@@ -0,0 +1,13 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:orientation="vertical" >
+
+    <GridView
+        android:listSelector="@null"
+        android:id="@+id/results"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent" />
+
+</LinearLayout>
\ No newline at end of file
diff --git a/ion-sample/res/layout/gallery_image.xml b/ion-sample/res/layout/gallery_image.xml
new file mode 100644
index 00000000..fc9d042b
--- /dev/null
+++ b/ion-sample/res/layout/gallery_image.xml
@@ -0,0 +1,16 @@
+<?xml version="1.0" encoding="utf-8"?>
+<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:layout_gravity="center"
+    android:gravity="center" >
+
+    <com.koushikdutta.ion.sample.SquaredImageView
+        android:id="@+id/image"
+        android:scaleType="fitCenter"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:layout_gravity="center"
+        android:gravity="center" />
+
+</FrameLayout>
\ No newline at end of file
diff --git a/ion-sample/res/layout/samples.xml b/ion-sample/res/layout/samples.xml
index e0b8f0c5..d0d2bc38 100644
--- a/ion-sample/res/layout/samples.xml
+++ b/ion-sample/res/layout/samples.xml
@@ -26,5 +26,9 @@
             android:layout_height="wrap_content"
             android:text="Google Image Search"
             />
+    <Button android:id="@+id/gallery" android:layout_width="240dp"
+        android:layout_height="wrap_content"
+        android:text="Gallery"
+        />
 
 </LinearLayout>
\ No newline at end of file
diff --git a/ion-sample/src/com/koushikdutta/ion/sample/GallerySample.java b/ion-sample/src/com/koushikdutta/ion/sample/GallerySample.java
new file mode 100644
index 00000000..30517ae7
--- /dev/null
+++ b/ion-sample/src/com/koushikdutta/ion/sample/GallerySample.java
@@ -0,0 +1,95 @@
+package com.koushikdutta.ion.sample;
+
+import android.app.Activity;
+import android.content.Context;
+import android.database.Cursor;
+import android.os.Bundle;
+import android.provider.MediaStore;
+import android.util.Log;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.ArrayAdapter;
+import android.widget.GridView;
+import android.widget.ImageView;
+
+import com.koushikdutta.ion.Ion;
+
+import java.io.File;
+
+/**
+ * Created by koush on 9/4/13.
+ */
+public class GallerySample extends Activity {
+    private MyAdapter mAdapter;
+
+    // Adapter to populate and imageview from an url contained in the array adapter
+    private class MyAdapter extends ArrayAdapter<String> {
+        public MyAdapter(Context context) {
+            super(context, 0);
+        }
+
+        @Override
+        public View getView(int position, View convertView, ViewGroup parent) {
+            // see if we need to load more to get 40, otherwise populate the adapter
+            if (position > getCount() - 4)
+                loadMore();
+
+            if (convertView == null)
+                convertView = getLayoutInflater().inflate(R.layout.google_image, null);
+
+            // find the image view
+            final ImageView iv = (ImageView) convertView.findViewById(R.id.image);
+
+            // select the image view
+            Ion.with(iv)
+                    .resize(256, 256)
+                    .centerCrop()
+                    .placeholder(R.drawable.placeholder)
+                    .error(R.drawable.error)
+                    .load(getItem(position));
+
+            return convertView;
+        }
+    }
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+//        StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder()
+//        .detectAll()
+//        .penaltyLog()
+//        .build());
+        super.onCreate(savedInstanceState);
+
+        Ion.getDefault(this).setLogging("ion-sample", Log.DEBUG);
+
+        setContentView(R.layout.gallery);
+
+        int cols = getResources().getDisplayMetrics().widthPixels / getResources().getDisplayMetrics().densityDpi * 2;
+        GridView view = (GridView) findViewById(R.id.results);
+        view.setNumColumns(cols);
+        mAdapter = new MyAdapter(this);
+        view.setAdapter(mAdapter);
+
+        loadMore();
+    }
+
+    Cursor mediaCursor;
+    public void loadMore() {
+        if (mediaCursor == null) {
+            mediaCursor = getContentResolver().query(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, null, null, null, null);
+        }
+
+        int loaded = 0;
+        while (mediaCursor.moveToNext() && loaded < 10) {
+            loaded++;
+
+            String uri = mediaCursor.getString(mediaCursor.getColumnIndex(MediaStore.Images.ImageColumns.DATA));
+            File file = new File(uri);
+            // turn this into a file uri if necessary/possible
+            if (file.exists())
+                mAdapter.add(file.toURI().toString());
+            else
+                mAdapter.add(uri);
+        }
+    }
+}
diff --git a/ion-sample/src/com/koushikdutta/ion/sample/Samples.java b/ion-sample/src/com/koushikdutta/ion/sample/Samples.java
index af290b9f..f54db0d1 100644
--- a/ion-sample/src/com/koushikdutta/ion/sample/Samples.java
+++ b/ion-sample/src/com/koushikdutta/ion/sample/Samples.java
@@ -55,5 +55,13 @@ public void onClick(View v) {
                 startActivity(new Intent(Samples.this, ImageViewSample.class));
             }
         });
+
+        Button gallerySample = (Button)findViewById(R.id.gallery);
+        gallerySample.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                startActivity(new Intent(Samples.this, GallerySample.class));
+            }
+        });
     }
 }
diff --git a/ion-test/ion-test.iml b/ion-test/ion-test.iml
index 751611c4..c089e12a 100644
--- a/ion-test/ion-test.iml
+++ b/ion-test/ion-test.iml
@@ -19,7 +19,7 @@
       <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
       <sourceFolder url="file://$MODULE_DIR$/gen" isTestSource="false" />
     </content>
-    <orderEntry type="jdk" jdkName="Android 4.2.2 Platform" jdkType="Android SDK" />
+    <orderEntry type="jdk" jdkName="Android 4.3 Platform" jdkType="Android SDK" />
     <orderEntry type="sourceFolder" forTests="false" />
     <orderEntry type="module" module-name="ion" />
   </component>
diff --git a/ion-test/project.properties b/ion-test/project.properties
index b2d07eb1..66efd6aa 100644
--- a/ion-test/project.properties
+++ b/ion-test/project.properties
@@ -1,5 +1,5 @@
 # This file is automatically generated by IntelliJ IDEA
 # Project target.
-target=android-17
+target=android-18
 android.library.reference.1=../ion
 
diff --git a/ion-test/src/com/koushikdutta/ion/test/AuthTests.java b/ion-test/src/com/koushikdutta/ion/test/AuthTests.java
index bb9b8c32..01cb201e 100644
--- a/ion-test/src/com/koushikdutta/ion/test/AuthTests.java
+++ b/ion-test/src/com/koushikdutta/ion/test/AuthTests.java
@@ -52,7 +52,6 @@ public void onRequest(AsyncHttpServerRequest request, AsyncHttpServerResponse re
             }
         });
 
-
         JsonObject result = Ion.with(getContext(), "http://localhost:5555")
         .setTimeout(500)
         .basicAuthentication("foo", "bar")
diff --git a/ion-test/src/com/koushikdutta/ion/test/ContentTests.java b/ion-test/src/com/koushikdutta/ion/test/ContentTests.java
index 68380615..5d1e5fa7 100644
--- a/ion-test/src/com/koushikdutta/ion/test/ContentTests.java
+++ b/ion-test/src/com/koushikdutta/ion/test/ContentTests.java
@@ -1,6 +1,7 @@
 package com.koushikdutta.ion.test;
 
 import android.database.Cursor;
+import android.graphics.Bitmap;
 import android.provider.ContactsContract;
 import android.test.AndroidTestCase;
 import com.koushikdutta.ion.Ion;
@@ -39,4 +40,20 @@ public void testContactToFile() throws Exception {
         assertNotNull(id);
         assertNotNull(c);
     }
+
+    public void testContactBitmap() throws Exception {
+        Cursor c = getContext().getContentResolver().query(ContactsContract.Contacts.CONTENT_URI, null, null, null, null);
+        String id = null;
+        while (c.moveToNext()) {
+            id = c.getString(c.getColumnIndex(ContactsContract.Contacts.PHOTO_URI));
+            if (id != null)
+                break;
+        }
+        Bitmap b = Ion.with(getContext(), id)
+                .asBitmap()
+                .get();
+        assertNotNull(b);
+        assertNotNull(id);
+        assertNotNull(c);
+    }
 }
diff --git a/ion/src/com/koushikdutta/ion/BitmapToBitmapInfo.java b/ion/src/com/koushikdutta/ion/BitmapToBitmapInfo.java
index 404c93c6..da8102c3 100644
--- a/ion/src/com/koushikdutta/ion/BitmapToBitmapInfo.java
+++ b/ion/src/com/koushikdutta/ion/BitmapToBitmapInfo.java
@@ -1,16 +1,49 @@
 package com.koushikdutta.ion;
 
 import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
 
+import com.koushikdutta.async.future.Future;
 import com.koushikdutta.async.future.FutureCallback;
+import com.koushikdutta.async.future.SimpleFuture;
+import com.koushikdutta.async.http.ResponseCacheMiddleware;
+import com.koushikdutta.async.http.libcore.DiskLruCache;
 import com.koushikdutta.ion.bitmap.BitmapInfo;
 import com.koushikdutta.ion.bitmap.Transform;
 
+import java.io.InputStream;
+import java.io.OutputStream;
 import java.util.ArrayList;
 
 class BitmapToBitmapInfo extends BitmapCallback implements FutureCallback<BitmapInfo> {
     ArrayList<Transform> transforms;
 
+    public static void getBitmapSnapshot(final Ion ion, final String transformKey) {
+        ion.getServer().getExecutorService().execute(new Runnable() {
+            @Override
+            public void run() {
+                final LoadBitmapStream callback = new LoadBitmapStream(ion, transformKey, true, 0, 0);
+                try {
+                    DiskLruCache.Snapshot snapshot = ion.getResponseCache().getDiskLruCache().get(transformKey);
+                    try {
+                        callback.loadInputStream(snapshot.getInputStream(ResponseCacheMiddleware.ENTRY_COUNT - 1));
+                    }
+                    finally {
+                        snapshot.close();
+                    }
+                }
+                catch (Exception e) {
+                    callback.report(e, null);
+                    try {
+                        ion.getResponseCache().getDiskLruCache().remove(transformKey);
+                    }
+                    catch (Exception ex) {
+                    }
+                }
+            }
+        });
+    }
+
     public BitmapToBitmapInfo(Ion ion, String transformKey, ArrayList<Transform> transforms) {
         super(ion, transformKey, true);
         this.transforms = transforms;
@@ -26,19 +59,45 @@ public void onCompleted(Exception e, final BitmapInfo result) {
         ion.getServer().getExecutorService().execute(new Runnable() {
             @Override
             public void run() {
+                BitmapInfo info = new BitmapInfo();
                 try {
                     Bitmap tmpBitmap = result.bitmap;
                     for (Transform transform : transforms) {
 //                            builder.request.logd("applying transform: " + transform.key());
                         tmpBitmap = transform.transform(tmpBitmap);
                     }
-                    BitmapInfo info = new BitmapInfo();
                     info.loadedFrom = result.loadedFrom;
                     info.bitmap = tmpBitmap;
                     info.key = key;
                     report(null, info);
                 } catch (Exception e) {
                     report(e, null);
+                    return;
+                }
+                // the transformed bitmap was successfully load it, let's toss it into
+                // the disk lru cache.
+                try {
+                    DiskLruCache cache = ion.getResponseCache().getDiskLruCache();
+                    if (cache == null)
+                        return;
+                    DiskLruCache.Editor editor = cache.edit(key);
+                    if (editor == null)
+                        return;
+                    try {
+                        for (int i = 0; i < ResponseCacheMiddleware.ENTRY_COUNT - 1; i++) {
+                            editor.set(0, key);
+                        }
+                        OutputStream out = editor.newOutputStream(ResponseCacheMiddleware.ENTRY_COUNT - 1);
+                        Bitmap.CompressFormat format = info.bitmap.hasAlpha() ? Bitmap.CompressFormat.PNG : Bitmap.CompressFormat.JPEG;
+                        info.bitmap.compress(format, 100, out);
+                        out.close();
+                        editor.commit();
+                    }
+                    catch (Exception ex) {
+                        editor.abort();
+                    }
+                }
+                catch (Exception e) {
                 }
             }
         });
diff --git a/ion/src/com/koushikdutta/ion/Ion.java b/ion/src/com/koushikdutta/ion/Ion.java
index aaaaabc7..41daebda 100644
--- a/ion/src/com/koushikdutta/ion/Ion.java
+++ b/ion/src/com/koushikdutta/ion/Ion.java
@@ -297,6 +297,10 @@ public FileLoader getFileLoader() {
         return fileLoader;
     }
 
+    public ResponseCacheMiddleware getResponseCache() {
+        return responseCache;
+    }
+
     String name;
     public String getName() {
         return name;
diff --git a/ion/src/com/koushikdutta/ion/IonBitmapRequestBuilder.java b/ion/src/com/koushikdutta/ion/IonBitmapRequestBuilder.java
index 93f476b8..2be36642 100644
--- a/ion/src/com/koushikdutta/ion/IonBitmapRequestBuilder.java
+++ b/ion/src/com/koushikdutta/ion/IonBitmapRequestBuilder.java
@@ -13,6 +13,8 @@
 import com.koushikdutta.async.future.Future;
 import com.koushikdutta.async.future.SimpleFuture;
 import com.koushikdutta.async.future.TransformFuture;
+import com.koushikdutta.async.http.ResponseCacheMiddleware;
+import com.koushikdutta.async.http.libcore.DiskLruCache;
 import com.koushikdutta.async.parser.ByteBufferListParser;
 import com.koushikdutta.ion.bitmap.BitmapInfo;
 import com.koushikdutta.ion.bitmap.Transform;
@@ -20,6 +22,7 @@
 import com.koushikdutta.ion.builder.Builders;
 import com.koushikdutta.ion.builder.ImageViewFutureBuilder;
 
+import java.io.InputStream;
 import java.lang.ref.WeakReference;
 import java.util.ArrayList;
 
@@ -76,7 +79,7 @@ public IonBitmapRequestBuilder transform(Transform transform) {
 
     String bitmapKey;
     BitmapInfo execute() {
-        final String downloadKey = builder.uri;
+        final String downloadKey = ResponseCacheMiddleware.toKeyString(builder.uri);
         assert Thread.currentThread() == Looper.getMainLooper().getThread();
         assert downloadKey != null;
 
@@ -91,6 +94,7 @@ BitmapInfo execute() {
             for (Transform transform : transforms) {
                 bitmapKey += transform.key();
             }
+            bitmapKey = ResponseCacheMiddleware.toKeyString(bitmapKey);
         }
 
         // see if this request can be fulfilled from the cache
@@ -99,22 +103,41 @@ BitmapInfo execute() {
             return bitmap;
         }
 
-        // find/create the future for this download.
+        // bitmaps that were transformed are put into the DiskLruCache to prevent
+        // subsequent retransformation. See if we can retrieve the bitmap from the disk cache.
+        // See BitmapToBitmapInfo for where the cache is populated.
+        DiskLruCache diskLruCache = ion.getResponseCache().getDiskLruCache();
+        if (diskLruCache.containsKey(bitmapKey)) {
+            BitmapToBitmapInfo.getBitmapSnapshot(ion, bitmapKey);
+            return null;
+        }
+
+        // Perform a download as necessary.
         if (!ion.bitmapsPending.contains(downloadKey)) {
-            builder.setHandler(null);
-            // if we cancel, gotta remove any waiters.
-            IonRequestBuilder.EmitterTransform<ByteBufferList> emitterTransform = builder.execute(new ByteBufferListParser(), new Runnable() {
-                @Override
-                public void run() {
-                    AsyncServer.post(Ion.mainHandler, new Runnable() {
-                        @Override
-                        public void run() {
-                            ion.bitmapsPending.remove(downloadKey);
-                        }
-                    });
-                }
-            });
-            emitterTransform.setCallback(new LoadBitmap(ion, downloadKey, !hasTransforms, resizeWidth, resizeHeight, emitterTransform));
+            // see if we can get a direct input stream. This should be a seekable InputStream
+            // that will not block on read. Ie, it needs to be fully downloaded, before returning
+            // the stream.
+            // Otherwise, just grab the asynchronous DataEmitter.
+            Future<InputStream> inputStreamFuture = builder.execute();
+            if (inputStreamFuture != null) {
+                inputStreamFuture.setCallback(new LoadBitmapStream(ion, downloadKey, !hasTransforms, resizeWidth, resizeHeight));
+            }
+            else {
+                builder.setHandler(null);
+                // if we cancel, gotta remove any waiters.
+                IonRequestBuilder.EmitterTransform<ByteBufferList> emitterTransform = builder.execute(new ByteBufferListParser(), new Runnable() {
+                    @Override
+                    public void run() {
+                        AsyncServer.post(Ion.mainHandler, new Runnable() {
+                            @Override
+                            public void run() {
+                                ion.bitmapsPending.remove(downloadKey);
+                            }
+                        });
+                    }
+                });
+                emitterTransform.setCallback(new LoadBitmap(ion, downloadKey, !hasTransforms, resizeWidth, resizeHeight, emitterTransform));
+            }
         }
 
         // if there's a transform, do it
@@ -149,6 +172,7 @@ private IonDrawable setIonDrawable(ImageView imageView, BitmapInfo info, int loa
         ret.setError(errorResource, errorDrawable);
         ret.setPlaceholder(placeholderResource, placeholderDrawable);
         ret.setInAnimation(inAnimation, inAnimationResource);
+        ret.setDisableFadeIn(disableFadeIn);
         imageView.setImageDrawable(ret);
         return ret;
     }
@@ -369,6 +393,14 @@ public String key() {
         }
     }
 
+    private boolean disableFadeIn;
+
+    @Override
+    public IonBitmapRequestBuilder disableFadeIn() {
+        this.disableFadeIn = true;
+        return this;
+    }
+
     void reset() {
         placeholderDrawable = null;
         placeholderResource = 0;
@@ -385,6 +417,7 @@ void reset() {
         scaleMode = ScaleMode.FitXY;
         resizeWidth = 0;
         resizeHeight = 0;
+        disableFadeIn = false;
         builder = null;
     }
 }
diff --git a/ion/src/com/koushikdutta/ion/IonDrawable.java b/ion/src/com/koushikdutta/ion/IonDrawable.java
index b4bbf81f..aeca16e0 100644
--- a/ion/src/com/koushikdutta/ion/IonDrawable.java
+++ b/ion/src/com/koushikdutta/ion/IonDrawable.java
@@ -30,6 +30,7 @@
     private Resources resources;
     private int loadedFrom;
     private IonDrawableCallback callback;
+    private boolean disableFadeIn;
 
     public IonDrawable cancel() {
         requestCount++;
@@ -39,6 +40,10 @@ public IonDrawable cancel() {
     public SimpleFuture<ImageView> getFuture() {
         return callback.imageViewFuture;
     }
+    
+    public void setDisableFadeIn(boolean disableFadeIn) {
+        this.disableFadeIn = disableFadeIn;
+    }
 
     public void setInAnimation(Animation inAnimation, int inAnimationResource) {
         callback.inAnimation = inAnimation;
@@ -212,8 +217,13 @@ public void draw(Canvas canvas) {
 
         if (info.drawTime == 0)
             info.drawTime = SystemClock.uptimeMillis();
-        long destAlpha = ((SystemClock.uptimeMillis() - info.drawTime) << 8) / FADE_DURATION;
-        destAlpha = Math.min(destAlpha, 0xFF);
+
+        long destAlpha = 0xFF;
+
+        if(!disableFadeIn) {
+            destAlpha = ((SystemClock.uptimeMillis() - info.drawTime) << 8) / FADE_DURATION;
+            destAlpha = Math.min(destAlpha, 0xFF);
+        }
 
         if (destAlpha != 255) {
             if (placeholder == null && placeholderResource != 0)
diff --git a/ion/src/com/koushikdutta/ion/IonRequestBuilder.java b/ion/src/com/koushikdutta/ion/IonRequestBuilder.java
index 533dc62c..26d93b66 100644
--- a/ion/src/com/koushikdutta/ion/IonRequestBuilder.java
+++ b/ion/src/com/koushikdutta/ion/IonRequestBuilder.java
@@ -56,6 +56,7 @@
 
 import java.io.File;
 import java.io.FileOutputStream;
+import java.io.InputStream;
 import java.io.OutputStream;
 import java.lang.ref.WeakReference;
 import java.net.URI;
@@ -227,7 +228,7 @@ public void run() {
             AsyncServer.post(handler, runner);
     }
 
-    private <T> void getLoaderEmitter(final EmitterTransform<T> ret) {
+    private URI prepareURI() {
         URI uri;
         try {
             if (query != null) {
@@ -246,7 +247,29 @@ public void run() {
         catch (Exception e) {
             uri = null;
         }
-        if (uri == null || uri.getScheme() == null) {
+        if (uri == null || uri.getScheme() == null)
+            return null;
+
+        return uri;
+    }
+
+    private AsyncHttpRequest prepareRequest(URI uri, AsyncHttpRequestBody wrappedBody) {
+        AsyncHttpRequest request = ion.configure().getAsyncHttpRequestFactory().createAsyncHttpRequest(uri, method, headers);
+        request.setFollowRedirect(followRedirect);
+        request.setBody(wrappedBody);
+        request.setLogging(ion.LOGTAG, ion.logLevel);
+        if (logTag != null)
+            request.setLogging(logTag, logLevel);
+        request.enableProxy(proxyHost, proxyPort);
+        request.setTimeout(timeoutMilliseconds);
+        request.setHandler(null);
+        request.logd("preparing request");
+        return request;
+    }
+
+    private <T> void getLoaderEmitter(final EmitterTransform<T> ret) {
+        URI uri = prepareURI();
+        if (uri == null) {
             ret.setComplete(new Exception("Invalid URI"));
             return;
         }
@@ -283,17 +306,7 @@ public void run() {
             });
         }
 
-        AsyncHttpRequest request = ion.configure().getAsyncHttpRequestFactory().createAsyncHttpRequest(uri, method, headers);
-        request.setFollowRedirect(followRedirect);
-        request.setBody(wrappedBody);
-        request.setLogging(ion.LOGTAG, ion.logLevel);
-        if (logTag != null)
-            request.setLogging(logTag, logLevel);
-        request.enableProxy(proxyHost, proxyPort);
-        request.setTimeout(timeoutMilliseconds);
-        request.setHandler(null);
-        request.logd("preparing request");
-
+        AsyncHttpRequest request = prepareRequest(uri, wrappedBody);
         ret.initialRequest = request;
 
         for (Loader loader: ion.config.loaders) {
@@ -525,6 +538,21 @@ public void onCompleted(Exception e, T result) {
         return ret;
     }
 
+    Future<InputStream> execute() {
+        URI uri = prepareURI();
+        if (uri == null)
+            return null;
+
+        AsyncHttpRequest request = prepareRequest(uri, null);
+
+        for (Loader loader: ion.config.loaders) {
+            Future<InputStream> ret = loader.load(ion, request);
+            if (ret != null)
+                return ret;
+        }
+        return null;
+    }
+
     @Override
     public ResponseFuture<JsonObject> asJsonObject() {
         return execute(new GsonParser<JsonObject>());
diff --git a/ion/src/com/koushikdutta/ion/LoadBitmapStream.java b/ion/src/com/koushikdutta/ion/LoadBitmapStream.java
new file mode 100644
index 00000000..0b46ed91
--- /dev/null
+++ b/ion/src/com/koushikdutta/ion/LoadBitmapStream.java
@@ -0,0 +1,55 @@
+package com.koushikdutta.ion;
+
+import android.graphics.Bitmap;
+
+import com.koushikdutta.async.future.Future;
+import com.koushikdutta.async.future.FutureCallback;
+import com.koushikdutta.ion.bitmap.BitmapInfo;
+
+import java.io.InputStream;
+
+class LoadBitmapStream extends BitmapCallback implements FutureCallback<InputStream> {
+    int resizeWidth;
+    int resizeHeight;
+
+    public LoadBitmapStream(Ion ion, String urlKey, boolean put, int resizeWidth, int resizeHeight) {
+        super(ion, urlKey, put);
+        this.resizeWidth = resizeWidth;
+        this.resizeHeight = resizeHeight;
+    }
+
+    public void loadInputStream(InputStream result) {
+        try {
+            Bitmap bitmap = ion.bitmapCache.loadBitmap(result, resizeWidth, resizeHeight);
+
+            if (bitmap == null)
+                throw new Exception("bitmap failed to load");
+
+            BitmapInfo info = new BitmapInfo();
+            info.key = key;
+            info.bitmap = bitmap;
+            info.loadedFrom = Loader.LoaderEmitter.LOADED_FROM_CACHE;
+
+            report(null, info);
+        } catch (Exception e) {
+            report(e, null);
+        }
+    }
+
+    @Override
+    public void onCompleted(Exception e, final InputStream result) {
+        if (e != null) {
+            report(e, null);
+            return;
+        }
+
+        ion.getServer().getExecutorService().execute(new Runnable() {
+            @Override
+            public void run() {
+                loadInputStream(result);
+            }
+        });
+    }
+}
+
+    
\ No newline at end of file
diff --git a/ion/src/com/koushikdutta/ion/Loader.java b/ion/src/com/koushikdutta/ion/Loader.java
index 6d34ab6b..75c055f6 100644
--- a/ion/src/com/koushikdutta/ion/Loader.java
+++ b/ion/src/com/koushikdutta/ion/Loader.java
@@ -6,6 +6,8 @@
 import com.koushikdutta.async.http.AsyncHttpRequest;
 import com.koushikdutta.async.http.libcore.RawHeaders;
 
+import java.io.InputStream;
+
 /**
  * Created by koush on 5/22/13.
  */
@@ -44,6 +46,11 @@ public AsyncHttpRequest getRequest() {
             return request;
         }
     }
+
+    // returns a Future if this loader can handle a request as a stream.
+    // this implies that the stream is
+    public Future<InputStream> load(Ion ion, AsyncHttpRequest request);
+
     // returns a Future if this loader can handle a request
     // otherwise it returns null, and Ion continues to the next loader.
     public Future<DataEmitter> load(Ion ion, AsyncHttpRequest request, FutureCallback<LoaderEmitter> callback);
diff --git a/ion/src/com/koushikdutta/ion/bitmap/IonBitmapCache.java b/ion/src/com/koushikdutta/ion/bitmap/IonBitmapCache.java
index 9a7a68e7..6c3c81fb 100644
--- a/ion/src/com/koushikdutta/ion/bitmap/IonBitmapCache.java
+++ b/ion/src/com/koushikdutta/ion/bitmap/IonBitmapCache.java
@@ -13,6 +13,8 @@
 
 import com.koushikdutta.ion.Ion;
 
+import java.io.InputStream;
+
 /**
  * Created by koush on 5/23/13.
  */
@@ -93,6 +95,8 @@ public Bitmap loadBitmap(byte[] bytes, int offset, int length, int minx, int min
             o = new BitmapFactory.Options();
             o.inJustDecodeBounds = true;
             BitmapFactory.decodeByteArray(bytes, offset, length, o);
+            if (o.outWidth < 0 || o.outHeight < 0)
+                return null;
             int scale = Math.min(o.outWidth / targetWidth, o.outHeight / targetHeight);
             o = new BitmapFactory.Options();
             o.inSampleSize = scale;
@@ -100,6 +104,42 @@ public Bitmap loadBitmap(byte[] bytes, int offset, int length, int minx, int min
         return BitmapFactory.decodeByteArray(bytes, offset, length, o);
     }
 
+    public Bitmap loadBitmap(InputStream stream, int minx, int miny) {
+        if (!stream.markSupported())
+            stream = new MarkableInputStream(stream);
+        assert Thread.currentThread() != Looper.getMainLooper().getThread();
+        int targetWidth = minx;
+        int targetHeight = miny;
+        if (targetWidth <= 0)
+            targetWidth = metrics.widthPixels;
+        if (targetWidth <= 0)
+            targetWidth = Integer.MAX_VALUE;
+        if (targetHeight <= 0)
+            targetHeight = metrics.heightPixels;
+        if (targetHeight <= 0)
+            targetHeight = Integer.MAX_VALUE;
+
+        BitmapFactory.Options o = null;
+        if (targetWidth != Integer.MAX_VALUE || targetHeight != Integer.MAX_VALUE) {
+            o = new BitmapFactory.Options();
+            o.inJustDecodeBounds = true;
+            stream.mark(Integer.MAX_VALUE);
+            BitmapFactory.decodeStream(stream, null, o);
+            if (o.outWidth < 0 || o.outHeight < 0)
+                return null;
+            try {
+                stream.reset();
+            }
+            catch (Exception e) {
+                return null;
+            }
+            int scale = Math.min(o.outWidth / targetWidth, o.outHeight / targetHeight);
+            o = new BitmapFactory.Options();
+            o.inSampleSize = scale;
+        }
+        return BitmapFactory.decodeStream(stream, null, o);
+    }
+
     private static int getHeapSize(final Context context) {
         return ((ActivityManager)context.getSystemService(Context.ACTIVITY_SERVICE)).getMemoryClass() * 1024 * 1024;
     }
diff --git a/ion/src/com/koushikdutta/ion/bitmap/MarkableInputStream.java b/ion/src/com/koushikdutta/ion/bitmap/MarkableInputStream.java
new file mode 100644
index 00000000..ce4d042d
--- /dev/null
+++ b/ion/src/com/koushikdutta/ion/bitmap/MarkableInputStream.java
@@ -0,0 +1,150 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.koushikdutta.ion.bitmap;
+
+import java.io.BufferedInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+
+/**
+ * An input stream wrapper that supports unlimited independent cursors for
+ * marking and resetting. Each cursor is a token, and it's the caller's
+ * responsibility to keep track of these.
+ */
+final class MarkableInputStream extends InputStream {
+    private final InputStream in;
+
+    private long offset;
+    private long reset;
+    private long limit;
+
+    private long defaultMark = -1;
+
+    public MarkableInputStream(InputStream in) {
+        if (!in.markSupported()) {
+            in = new BufferedInputStream(in);
+        }
+        this.in = in;
+    }
+
+    /** Marks this place in the stream so we can reset back to it later. */
+    @Override public void mark(int readLimit) {
+        defaultMark = savePosition(readLimit);
+    }
+
+    /**
+     * Returns an opaque token representing the current position in the stream.
+     * Call {@link #reset(long)} to return to this position in the stream later.
+     * It is an error to call {@link #reset(long)} after consuming more than
+     * {@code readLimit} bytes from this stream.
+     */
+    public long savePosition(int readLimit) {
+        long offsetLimit = offset + readLimit;
+        if (limit < offsetLimit) {
+            setLimit(offsetLimit);
+        }
+        return offset;
+    }
+
+    /**
+     * Makes sure that the underlying stream can backtrack the full range from
+     * {@code reset} thru {@code limit}. Since we can't call {@code mark()}
+     * without also adjusting the reset-to-position on the underlying stream this
+     * method resets first and then marks the union of the two byte ranges. On
+     * buffered streams this additional cursor motion shouldn't result in any
+     * additional I/O.
+     */
+    private void setLimit(long limit) {
+        try {
+            if (reset < offset && offset <= this.limit) {
+                in.reset();
+                in.mark((int) (limit - reset));
+                skip(reset, offset);
+            } else {
+                reset = offset;
+                in.mark((int) (limit - offset));
+            }
+            this.limit = limit;
+        } catch (IOException e) {
+            throw new IllegalStateException("Unable to mark: " + e);
+        }
+    }
+
+    /** Resets the stream to the most recent {@link #mark mark}. */
+    @Override public void reset() throws IOException {
+        reset(defaultMark);
+    }
+
+    /** Resets the stream to the position recorded by {@code token}. */
+    public void reset(long token) throws IOException {
+        if (offset > limit || token < reset) {
+            throw new IOException("Cannot reset");
+        }
+        in.reset();
+        skip(reset, token);
+        offset = token;
+    }
+
+    /** Skips {@code target - current} bytes and returns. */
+    private void skip(long current, long target) throws IOException {
+        while (current < target) {
+            long skipped = in.skip(target - current);
+            current += skipped;
+        }
+    }
+
+    @Override public int read() throws IOException {
+        int result = in.read();
+        if (result != -1) {
+            offset++;
+        }
+        return result;
+    }
+
+    @Override public int read(byte[] buffer) throws IOException {
+        int count = in.read(buffer);
+        if (count != -1) {
+            offset += count;
+        }
+        return count;
+    }
+
+    @Override public int read(byte[] buffer, int offset, int length) throws IOException {
+        int count = in.read(buffer, offset, length);
+        if (count != -1) {
+            this.offset += count;
+        }
+        return count;
+    }
+
+    @Override public long skip(long byteCount) throws IOException {
+        long skipped = in.skip(byteCount);
+        offset += skipped;
+        return skipped;
+    }
+
+    @Override public int available() throws IOException {
+        return in.available();
+    }
+
+    @Override public void close() throws IOException {
+        in.close();
+    }
+
+    @Override public boolean markSupported() {
+        return in.markSupported();
+    }
+}
\ No newline at end of file
diff --git a/ion/src/com/koushikdutta/ion/builder/ImageViewBuilder.java b/ion/src/com/koushikdutta/ion/builder/ImageViewBuilder.java
index 7c54db46..7756ee00 100644
--- a/ion/src/com/koushikdutta/ion/builder/ImageViewBuilder.java
+++ b/ion/src/com/koushikdutta/ion/builder/ImageViewBuilder.java
@@ -71,4 +71,11 @@
      * @return
      */
     public I animateLoad(int animationResource);
+
+    /**
+     * Disable fadeIn when the image loads.
+     * @return
+     */
+    public I disableFadeIn();
+
 }
diff --git a/ion/src/com/koushikdutta/ion/loader/ContentLoader.java b/ion/src/com/koushikdutta/ion/loader/ContentLoader.java
index bea398e0..6d3930da 100644
--- a/ion/src/com/koushikdutta/ion/loader/ContentLoader.java
+++ b/ion/src/com/koushikdutta/ion/loader/ContentLoader.java
@@ -19,6 +19,29 @@
     private static final class InputStreamDataEmitterFuture extends SimpleFuture<DataEmitter> {
     }
 
+    @Override
+    public Future<InputStream> load(final Ion ion, final AsyncHttpRequest request) {
+        if (!request.getUri().getScheme().startsWith("content"))
+            return null;
+
+        final SimpleFuture<InputStream> ret = new SimpleFuture<InputStream>();
+        ion.getServer().getExecutorService().execute(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    InputStream stream = ion.getContext().getContentResolver().openInputStream(Uri.parse(request.getUri().toString()));
+                    if (stream == null)
+                        throw new Exception("Unable to load content stream");
+                    ret.setComplete(stream);
+                }
+                catch (Exception e) {
+                    ret.setComplete(e);
+                }
+            }
+        });
+        return ret;
+    }
+
     @Override
     public Future<DataEmitter> load(final Ion ion, final AsyncHttpRequest request, final FutureCallback<LoaderEmitter> callback) {
         if (!request.getUri().getScheme().startsWith("content"))
diff --git a/ion/src/com/koushikdutta/ion/loader/FileLoader.java b/ion/src/com/koushikdutta/ion/loader/FileLoader.java
index bc6bb970..af2130fe 100644
--- a/ion/src/com/koushikdutta/ion/loader/FileLoader.java
+++ b/ion/src/com/koushikdutta/ion/loader/FileLoader.java
@@ -1,5 +1,7 @@
 package com.koushikdutta.ion.loader;
 
+import android.net.Uri;
+
 import com.koushikdutta.async.DataEmitter;
 import com.koushikdutta.async.FileDataEmitter;
 import com.koushikdutta.async.future.Future;
@@ -10,6 +12,8 @@
 import com.koushikdutta.ion.Loader;
 
 import java.io.File;
+import java.io.FileInputStream;
+import java.io.InputStream;
 
 /**
  * Created by koush on 5/22/13.
@@ -18,6 +22,26 @@
     private static final class FileFuture extends SimpleFuture<DataEmitter> {
     }
 
+    @Override
+    public Future<InputStream> load(final Ion ion, final AsyncHttpRequest request) {
+        if (!request.getUri().getScheme().startsWith("file"))
+            return null;
+        final SimpleFuture<InputStream> ret = new SimpleFuture<InputStream>();
+        ion.getServer().getExecutorService().execute(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    InputStream stream = new FileInputStream(new File(request.getUri()));
+                    ret.setComplete(stream);
+                }
+                catch (Exception e) {
+                    ret.setComplete(e);
+                }
+            }
+        });
+        return ret;
+    }
+
     @Override
     public Future<DataEmitter> load(final Ion ion, final AsyncHttpRequest request, final FutureCallback<LoaderEmitter> callback) {
         if (!request.getUri().getScheme().startsWith("file"))
diff --git a/ion/src/com/koushikdutta/ion/loader/HttpLoader.java b/ion/src/com/koushikdutta/ion/loader/HttpLoader.java
index ed258f72..f0129f39 100644
--- a/ion/src/com/koushikdutta/ion/loader/HttpLoader.java
+++ b/ion/src/com/koushikdutta/ion/loader/HttpLoader.java
@@ -12,10 +12,17 @@
 import com.koushikdutta.ion.Ion;
 import com.koushikdutta.ion.Loader;
 
+import java.io.InputStream;
+
 /**
  * Created by koush on 5/22/13.
  */
 public class HttpLoader implements Loader {
+    @Override
+    public Future<InputStream> load(Ion ion, AsyncHttpRequest request) {
+        return null;
+    }
+
     @SuppressWarnings("unchecked")
     @Override
     public Future<DataEmitter> load(Ion ion, AsyncHttpRequest request, final FutureCallback<LoaderEmitter> callback) {
