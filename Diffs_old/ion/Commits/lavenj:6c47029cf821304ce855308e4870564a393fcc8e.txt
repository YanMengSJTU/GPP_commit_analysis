diff --git a/README.md b/README.md
index 58ee9755..6fe113e0 100644
--- a/README.md
+++ b/README.md
@@ -1,4 +1,4 @@
-*Android Asynchronous Networking Made Easy*
+*Android Asynchronous Networking and Image Loading*
 
 ![](ion-sample/ion-sample.png)
 
@@ -57,7 +57,8 @@ at 30+ ion unit tests in the [ion-test](https://github.com/koush/ion/tree/master
 #### Get JSON
 
 ```java
-Ion.with(context, "http://example.com/thing.json")
+Ion.with(context)
+.load("http://example.com/thing.json")
 .asJsonObject()
 .setCallback(new FutureCallback<JsonObject>() {
    @Override
@@ -73,7 +74,8 @@ Ion.with(context, "http://example.com/thing.json")
 JsonObject json = new JsonObject();
 json.addProperty("foo", "bar");
 
-Ion.with(context, "http://example.com/post")
+Ion.with(context)
+.load("http://example.com/post")
 .setJsonObjectBody(json)
 .asJsonObject()
 .setCallback(new FutureCallback<JsonObject>() {
@@ -108,7 +110,8 @@ Ion.with(getContext(), "https://koush.clockworkmod.com/test/echo")
 #### Download a File with a progress bar
 
 ```java
-Ion.with(context, "http://example.com/really-big-file.zip")
+Ion.with(context)
+.load("http://example.com/really-big-file.zip")
 // have a ProgressBar get updated automatically with the percent
 .progressBar(progressBar)
 // and a ProgressDialog
@@ -132,7 +135,8 @@ Ion.with(context, "http://example.com/really-big-file.zip")
 #### Setting Headers
 
 ```java
-Ion.with(context, "http://example.com/test.txt")
+Ion.with(context)
+.load("http://example.com/test.txt")
 // set the header
 .setHeader("foo", "bar")
 .asString()
@@ -143,7 +147,8 @@ Ion.with(context, "http://example.com/test.txt")
 
 ```java
 // This is the "long" way to do build an ImageView request... it allows you to set headers, etc.
-Ion.with(context, "http://example.com/image.png")
+Ion.with(context)
+.load("http://example.com/image.png")
 .withBitmap()
 .placeholder(R.drawable.placeholder_image)
 .error(R.drawable.error_image)
@@ -166,6 +171,7 @@ The Ion Image load API has the following features:
  * ListView Adapter recycling support
  * Bitmap transformations via the .transform(Transform)
  * Animate loading and loaded ImageView states
+ * [DeepZoom](http://www.youtube.com/watch?v=yIMltNEAKZY) for extremely large images
 
 #### Futures
 
@@ -182,18 +188,21 @@ public interface Future<T> extends Cancellable, java.util.concurrent.Future<T> {
     public Future<T> setCallback(FutureCallback<T> callback);
 }
 
-Future<String> string = Ion.with(context, "http://example.com/string.txt")
-    .asString();
-
-Future<JsonObject> json = Ion.with(context, "http://example.com/json.json")
-    .asJsonObject();
+Future<String> string = Ion.with(context)
+.load("http://example.com/string.txt")
+.asString();
 
-Future<File> file = Ion.with(context, "http://example.com/file.zip")
-    .write(new File("/sdcard/file.zip"));
+Future<JsonObject> json = Ion.with(context)
+.load("http://example.com/json.json")
+.asJsonObject();
 
-Future<Bitmap> bitmap = Ion.with(context, "http://example.com/image.png")
-    .intoImageView(imageView);
+Future<File> file = Ion.with(context)
+.load("http://example.com/file.zip")
+.write(new File("/sdcard/file.zip"));
 
+Future<Bitmap> bitmap = Ion.with(context)
+.load("http://example.com/image.png")
+.intoImageView(imageView);
 ```
 
 #### Cancelling Requests
@@ -211,7 +220,8 @@ Though you should try to use callbacks for handling requests whenever possible,
 All Futures have a Future<T>.get() method that waits for the result of the request, by blocking if necessary.
 
 ```java
-JsonObject json = Ion.with(context, "http://example.com/thing.json").asJsonObject().get();
+JsonObject json = Ion.with(context)
+.load("http://example.com/thing.json").asJsonObject().get();
 ```
 
 #### Seamlessly use your own Java classes with [Gson](https://code.google.com/p/google-gson/)
@@ -224,7 +234,8 @@ public static class Tweet {
 }
 
 public void getTweets() throws Exception {
-    Ion.with(context, "http://example.com/api/tweets")
+    Ion.with(context)
+    .load("http://example.com/api/tweets")
     .as(new TypeToken<List<Tweet>>(){})
     .setCallback(new FutureCallback<List<Tweet>>() {
        @Override
@@ -242,13 +253,14 @@ Wondering why your app is slow? Ion lets you do both global and request level lo
 To enable it globally:
 
 ```java
-Ion.getDefault(getContext()).setLogging("MyLogs", Log.DEBUG);
+Ion.getDefault(getContext()).configure().setLogging("MyLogs", Log.DEBUG);
 ```
 
 Or to enable it on just a single request:
 
 ```java
-Ion.with(context, "http://example.com/thing.json")
+Ion.with(context)
+.load("http://example.com/thing.json")
 .setLogging("MyLogs", Log.DEBUG)
 .asJsonObject();
 ```
@@ -316,10 +328,11 @@ Proxy server settings can be enabled all Ion requests, or on a per request basis
 
 ```java
 // proxy all requests
-Ion.getDefault(context).proxy("mycomputer", 8888);
+Ion.getDefault(context).configure().proxy("mycomputer", 8888);
 
 // or... to proxy specific requests
-Ion.with(context, "http://example.com/proxied.html")
+Ion.with(context)
+.load("http://example.com/proxied.html")
 .proxy("mycomputer", 8888)
 .getString();
 ```
@@ -362,14 +375,14 @@ Ion.with(getContext())
 <dependency>
    <groupId>com.koushikdutta.ion</groupId>
    <artifactId>ion</artifactId>
-   <version>1.2.0</version>
+   <version>1.2.4</version>
 </dependency>
 ```
 
 ##### Gradle
 ```groovy
 dependencies {
-   compile 'com.koushikdutta.ion:ion:1.2.0'
+   compile 'com.koushikdutta.ion:ion:1.2.4'
 }
 ````
 
diff --git a/ion-sample/AndroidManifest.xml b/ion-sample/AndroidManifest.xml
index 0a964c5b..19d4ed09 100644
--- a/ion-sample/AndroidManifest.xml
+++ b/ion-sample/AndroidManifest.xml
@@ -34,8 +34,11 @@
             android:name=".GallerySample"
             android:label="Gallery Sample"/>
         <activity
-            android:name=".ImageViewSample"
-            android:label="ImageView Sample"/>
+                android:name=".ImageViewSample"
+                android:label="ImageView Sample"/>
+        <activity
+                android:name=".DeepZoomSample"
+                android:label="DeepZoom Sample"/>
         <activity
                 android:name=".Samples"
                 android:label="ion samples">
diff --git a/ion-sample/ion-sample.iml b/ion-sample/ion-sample.iml
index d91d4670..0a766461 100644
--- a/ion-sample/ion-sample.iml
+++ b/ion-sample/ion-sample.iml
@@ -13,15 +13,27 @@
       </configuration>
     </facet>
   </component>
-  <component name="NewModuleRootManager" inherit-compiler-output="true">
+  <component name="NewModuleRootManager" inherit-compiler-output="false">
+    <output url="file://$MODULE_DIR$/build/classes/main" />
+    <output-test url="file://$MODULE_DIR$/build/classes/test" />
     <exclude-output />
     <content url="file://$MODULE_DIR$">
       <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
       <sourceFolder url="file://$MODULE_DIR$/gen" isTestSource="false" generated="true" />
     </content>
-    <orderEntry type="jdk" jdkName="Android API 19 Platform" jdkType="Android SDK" />
+    <orderEntry type="inheritedJdk" />
     <orderEntry type="sourceFolder" forTests="false" />
     <orderEntry type="module" module-name="ion" />
+    <orderEntry type="module-library">
+      <library>
+        <CLASSES>
+          <root url="file://$MODULE_DIR$/libs" />
+        </CLASSES>
+        <JAVADOC />
+        <SOURCES />
+        <jarDirectory url="file://$MODULE_DIR$/libs" recursive="false" />
+      </library>
+    </orderEntry>
   </component>
 </module>
 
diff --git a/ion-sample/libs/photo-view.jar b/ion-sample/libs/photo-view.jar
new file mode 100755
index 00000000..4f5519c3
Binary files /dev/null and b/ion-sample/libs/photo-view.jar differ
diff --git a/mark.gif b/ion-sample/mark.gif
similarity index 100%
rename from mark.gif
rename to ion-sample/mark.gif
diff --git a/ion-sample/res/layout/samples.xml b/ion-sample/res/layout/samples.xml
index 09b0bbf3..dd05f057 100644
--- a/ion-sample/res/layout/samples.xml
+++ b/ion-sample/res/layout/samples.xml
@@ -6,33 +6,60 @@
               android:layout_width="match_parent"
               android:layout_height="match_parent">
 
-    <Button android:id="@+id/twitter" android:layout_width="240dp"
+    <Button
+            android:id="@+id/twitter"
+            android:layout_width="240dp"
             android:layout_height="wrap_content"
             android:text="Twitter Client Sample"
             />
-    <Button android:id="@+id/twitter_gson" android:layout_width="240dp"
+
+    <Button
+            android:id="@+id/twitter_gson"
+            android:layout_width="240dp"
             android:layout_height="wrap_content"
             android:text="Twitter Gson Client Sample"
             />
-    <Button android:id="@+id/download" android:layout_width="240dp"
+
+    <Button
+            android:id="@+id/download"
+            android:layout_width="240dp"
             android:layout_height="wrap_content"
             android:text="Progress Bar Download"
             />
-    <Button android:id="@+id/upload" android:layout_width="240dp"
+
+    <Button
+            android:id="@+id/upload"
+            android:layout_width="240dp"
             android:layout_height="wrap_content"
             android:text="Progress Bar Upload"
             />
-    <Button android:id="@+id/image_view" android:layout_width="240dp"
+
+    <Button
+            android:id="@+id/image_view"
+            android:layout_width="240dp"
             android:layout_height="wrap_content"
             android:text="ImageView Sample"
             />
-    <Button android:id="@+id/google_image_search" android:layout_width="240dp"
+
+    <Button
+            android:id="@+id/google_image_search"
+            android:layout_width="240dp"
             android:layout_height="wrap_content"
             android:text="Google Image Search"
             />
-    <Button android:id="@+id/gallery" android:layout_width="240dp"
-        android:layout_height="wrap_content"
-        android:text="Gallery"
-        />
+
+    <Button
+            android:id="@+id/gallery"
+            android:layout_width="240dp"
+            android:layout_height="wrap_content"
+            android:text="Gallery"
+            />
+
+    <Button
+            android:id="@+id/deepzoom"
+            android:layout_width="240dp"
+            android:layout_height="wrap_content"
+            android:text="DeepZoom"
+            />
 
 </LinearLayout>
\ No newline at end of file
diff --git a/ion-sample/src/com/koushikdutta/ion/sample/DeepZoomSample.java b/ion-sample/src/com/koushikdutta/ion/sample/DeepZoomSample.java
new file mode 100644
index 00000000..7a9453ec
--- /dev/null
+++ b/ion-sample/src/com/koushikdutta/ion/sample/DeepZoomSample.java
@@ -0,0 +1,47 @@
+package com.koushikdutta.ion.sample;
+
+import android.app.Activity;
+import android.app.AlertDialog;
+import android.app.ProgressDialog;
+import android.os.Bundle;
+import android.util.Log;
+import android.widget.ImageView;
+
+import com.koushikdutta.async.future.FutureCallback;
+import com.koushikdutta.ion.Ion;
+
+import uk.co.senab.photoview.PhotoView;
+
+/**
+ * Created by koush on 2/1/14.
+ */
+public class DeepZoomSample extends Activity {
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        PhotoView photoView = new PhotoView(this);
+        photoView.setMaximumScale(16);
+        setContentView(photoView);
+
+        final ProgressDialog dlg = new ProgressDialog(this);
+        dlg.setTitle("Loading...");
+        dlg.setIndeterminate(false);
+        dlg.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);
+        dlg.show();
+
+        // this is going to load a 30mb download...
+        Ion.with(this)
+        .load("https://raw2.github.com/koush/ion/master/ion-sample/telescope.jpg")
+        .progressDialog(dlg)
+        .setLogging("DeepZoom", Log.VERBOSE)
+        .withBitmap()
+        .deepZoom()
+        .intoImageView(photoView)
+        .setCallback(new FutureCallback<ImageView>() {
+            @Override
+            public void onCompleted(Exception e, ImageView result) {
+                dlg.cancel();
+            }
+        });
+    }
+}
diff --git a/ion-sample/src/com/koushikdutta/ion/sample/ImageViewSample.java b/ion-sample/src/com/koushikdutta/ion/sample/ImageViewSample.java
index a9d3d4a1..c18f39e8 100644
--- a/ion-sample/src/com/koushikdutta/ion/sample/ImageViewSample.java
+++ b/ion-sample/src/com/koushikdutta/ion/sample/ImageViewSample.java
@@ -34,7 +34,7 @@ public void loadCenterInside() {
 
     public void loadGifCenterCrop() {
         Ion.with(this)
-        .load("https://raw.github.com/koush/ion/master/mark.gif")
+        .load("https://raw2.github.com/koush/ion/master/ion-sample/mark.gif")
         .withBitmap()
         .resize(512, 512)
         .centerCrop()
@@ -43,7 +43,7 @@ public void loadGifCenterCrop() {
 
     public void loadGifCenterInside() {
         Ion.with(this)
-        .load("https://raw.github.com/koush/ion/master/mark.gif")
+        .load("https://raw2.github.com/koush/ion/master/ion-sample/mark.gif")
         .withBitmap()
         .resize(512, 512)
         .centerInside()
diff --git a/ion-sample/src/com/koushikdutta/ion/sample/ProgressBarUpload.java b/ion-sample/src/com/koushikdutta/ion/sample/ProgressBarUpload.java
index a9660171..060981af 100644
--- a/ion-sample/src/com/koushikdutta/ion/sample/ProgressBarUpload.java
+++ b/ion-sample/src/com/koushikdutta/ion/sample/ProgressBarUpload.java
@@ -59,7 +59,8 @@ public void onClick(View v) {
 
                 upload.setText("Cancel");
                 // this is a 180MB zip file to test with
-                uploading = Ion.with(ProgressBarUpload.this, "http://koush.clockworkmod.com/test/echo")
+                uploading = Ion.with(ProgressBarUpload.this)
+                .load("http://koush.clockworkmod.com/test/echo")
                 // attach the percentage report to a progress bar.
                 // can also attach to a ProgressDialog with progressDialog.
                 .uploadProgressBar(progressBar)
diff --git a/ion-sample/src/com/koushikdutta/ion/sample/Samples.java b/ion-sample/src/com/koushikdutta/ion/sample/Samples.java
index 3a7172f5..8e15c2ed 100644
--- a/ion-sample/src/com/koushikdutta/ion/sample/Samples.java
+++ b/ion-sample/src/com/koushikdutta/ion/sample/Samples.java
@@ -71,5 +71,13 @@ public void onClick(View v) {
                 startActivity(new Intent(Samples.this, GallerySample.class));
             }
         });
+
+        Button deepZoomSample = (Button)findViewById(R.id.deepzoom);
+        deepZoomSample.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                startActivity(new Intent(Samples.this, DeepZoomSample.class));
+            }
+        });
     }
 }
diff --git a/ion-sample/src/com/koushikdutta/ion/sample/Twitter.java b/ion-sample/src/com/koushikdutta/ion/sample/Twitter.java
index e613f1dc..cc30d7e7 100644
--- a/ion-sample/src/com/koushikdutta/ion/sample/Twitter.java
+++ b/ion-sample/src/com/koushikdutta/ion/sample/Twitter.java
@@ -96,7 +96,8 @@ public View getView(int position, View convertView, ViewGroup parent) {
 
     String accessToken;
     private void getCredentials() {
-        Ion.with(this, "https://api.twitter.com/oauth2/token")
+        Ion.with(this)
+        .load("https://api.twitter.com/oauth2/token")
         // embedding twitter api key and secret is a bad idea, but this isn't a real twitter app :)
         .basicAuthentication("e4LrcHB55R3WamRYHpNfA", "MIABn1DU5db3Aj0xXzhthsf4aUKMAdoWJTMxJJcY")
         .setBodyParameter("grant_type", "client_credentials")
@@ -120,7 +121,7 @@ private void load() {
             return;
 
         // load the tweets
-        String url = "https://api.twitter.com/1.1/statuses/user_timeline.json?screen_name=favstar50&count=20";
+        String url = "https://api.twitter.com/1.1/statuses/user_timeline.json?screen_name=BestAt&count=20";
         if (tweetAdapter.getCount() > 0) {
             // load from the "last" id
             JsonObject last = tweetAdapter.getItem(tweetAdapter.getCount() - 1);
diff --git a/ion-sample/src/com/koushikdutta/ion/sample/TwitterGson.java b/ion-sample/src/com/koushikdutta/ion/sample/TwitterGson.java
index d36fcd47..10adc1b3 100644
--- a/ion-sample/src/com/koushikdutta/ion/sample/TwitterGson.java
+++ b/ion-sample/src/com/koushikdutta/ion/sample/TwitterGson.java
@@ -130,7 +130,7 @@ private void load() {
             return;
 
         // load the tweets
-        String url = "https://api.twitter.com/1.1/statuses/user_timeline.json?screen_name=favstar50&count=20";
+        String url = "https://api.twitter.com/1.1/statuses/user_timeline.json?screen_name=BestAt&count=20";
         if (tweetAdapter.getCount() > 0) {
             // load from the "last" id
             Tweet last = tweetAdapter.getItem(tweetAdapter.getCount() - 1);
diff --git a/ion-sample/telescope.jpg b/ion-sample/telescope.jpg
new file mode 100644
index 00000000..7bd22bd8
Binary files /dev/null and b/ion-sample/telescope.jpg differ
diff --git a/ion-test/ion-test.iml b/ion-test/ion-test.iml
index d91d4670..8b83fd1e 100644
--- a/ion-test/ion-test.iml
+++ b/ion-test/ion-test.iml
@@ -19,7 +19,7 @@
       <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
       <sourceFolder url="file://$MODULE_DIR$/gen" isTestSource="false" generated="true" />
     </content>
-    <orderEntry type="jdk" jdkName="Android API 19 Platform" jdkType="Android SDK" />
+    <orderEntry type="inheritedJdk" />
     <orderEntry type="sourceFolder" forTests="false" />
     <orderEntry type="module" module-name="ion" />
   </component>
diff --git a/ion-test/src/com/koushikdutta/ion/test/CookieTests.java b/ion-test/src/com/koushikdutta/ion/test/CookieTests.java
index 8c9d2069..366fce61 100644
--- a/ion-test/src/com/koushikdutta/ion/test/CookieTests.java
+++ b/ion-test/src/com/koushikdutta/ion/test/CookieTests.java
@@ -1,11 +1,11 @@
 package com.koushikdutta.ion.test;
 
-import android.os.SystemClock;
 import android.test.AndroidTestCase;
 
 import com.koushikdutta.async.http.libcore.RawHeaders;
 import com.koushikdutta.async.http.libcore.RequestHeaders;
 import com.koushikdutta.ion.Ion;
+import com.koushikdutta.ion.cookie.CookieMiddleware;
 
 import java.net.CookieManager;
 import java.net.URI;
@@ -45,4 +45,36 @@ public void testCookies() throws Exception {
         assertTrue(newHeaders.get("Cookie").contains("poop=scoop"));
         assertFalse(newHeaders.get("Cookie").contains("bar"));
     }
+
+    public void testReinit() throws Exception {
+        CookieMiddleware middleware = Ion.getDefault(getContext()).getCookieMiddleware();
+        Ion ion = Ion.getDefault(getContext());
+
+        ion.getCookieMiddleware().clear();
+
+        RawHeaders headers = new RawHeaders();
+        headers.setStatusLine("HTTP/1.1 200 OK");
+        headers.set("Set-Cookie", "foo=bar");
+
+        URI uri = URI.create("http://example.com");
+        middleware.put(uri, headers);
+
+        headers.set("Set-Cookie", "poop=scoop");
+        middleware.put(uri, headers);
+
+        headers.set("Set-Cookie", "foo=goop");
+        middleware.put(uri, headers);
+
+        middleware.reinit(getContext(), Ion.getDefault(getContext()).getName());
+        CookieManager manager = middleware.getCookieManager();
+
+        RawHeaders newHeaders = new RawHeaders();
+        RequestHeaders requestHeaders = new RequestHeaders(uri, newHeaders);
+        Map<String, List<String>> cookies = manager.get(uri, newHeaders.toMultimap());
+        manager.get(uri, cookies);
+        requestHeaders.addCookies(cookies);
+        assertTrue(newHeaders.get("Cookie").contains("foo=goop"));
+        assertTrue(newHeaders.get("Cookie").contains("poop=scoop"));
+        assertFalse(newHeaders.get("Cookie").contains("bar"));
+    }
 }
diff --git a/ion-test/src/com/koushikdutta/ion/test/HttpTests.java b/ion-test/src/com/koushikdutta/ion/test/HttpTests.java
index 4475d99b..b64fd9de 100644
--- a/ion-test/src/com/koushikdutta/ion/test/HttpTests.java
+++ b/ion-test/src/com/koushikdutta/ion/test/HttpTests.java
@@ -12,6 +12,7 @@
 import com.koushikdutta.async.future.Future;
 import com.koushikdutta.async.future.FutureCallback;
 import com.koushikdutta.async.http.AsyncHttpClient;
+import com.koushikdutta.async.http.AsyncHttpGet;
 import com.koushikdutta.async.http.AsyncHttpResponse;
 import com.koushikdutta.async.http.Multimap;
 import com.koushikdutta.async.http.body.FilePart;
@@ -108,11 +109,21 @@ public void testPostJsonObject() throws Exception {
 
     public void testUrlEncodedFormBody() throws Exception {
         JsonObject ret = Ion.with(getContext(),"https://koush.clockworkmod.com/test/echo")
-                .setBodyParameter("blit", "bip")
-                .asJsonObject().get();
+        .setBodyParameter("blit", "bip")
+        .asJsonObject().get();
         assertEquals("bip", ret.get("blit").getAsString());
     }
 
+    public void testUrlEncodedFormBodyWithNull() throws Exception {
+        JsonObject ret = Ion.with(getContext(),"https://koush.clockworkmod.com/test/echo")
+        .setTimeout(3000000)
+        .setBodyParameter("blit", null)
+        .setBodyParameter("foo", "bar")
+        .asJsonObject().get();
+        assertTrue(!ret.has("blit"));
+        assertEquals("bar", ret.get("foo").getAsString());
+    }
+
     public void testMultipart() throws Exception {
         JsonObject ret = Ion.with(getContext(),"https://koush.clockworkmod.com/test/echo")
                 .setMultipartParameter("goop", "noop")
@@ -210,7 +221,7 @@ public void onRequest(AsyncHttpServerRequest request, final AsyncHttpServerRespo
                     AsyncHttpClient proxying = new AsyncHttpClient(proxyServer);
 
                     String url = request.getPath();
-                    proxying.get(url, new AsyncHttpClient.StringCallback() {
+                    proxying.executeString(new AsyncHttpGet(url), new AsyncHttpClient.StringCallback() {
                         @Override
                         public void onCompleted(Exception e, AsyncHttpResponse source, String result) {
                             response.send(result);
diff --git a/ion-test/src/com/koushikdutta/ion/test/Issues.java b/ion-test/src/com/koushikdutta/ion/test/Issues.java
index 77ff7588..e5ba78a1 100644
--- a/ion-test/src/com/koushikdutta/ion/test/Issues.java
+++ b/ion-test/src/com/koushikdutta/ion/test/Issues.java
@@ -4,8 +4,19 @@
 import android.test.AndroidTestCase;
 import android.util.Log;
 
+import com.koushikdutta.async.AsyncServer;
+import com.koushikdutta.async.http.server.AsyncHttpServer;
+import com.koushikdutta.async.http.server.AsyncHttpServerRequest;
+import com.koushikdutta.async.http.server.AsyncHttpServerResponse;
+import com.koushikdutta.async.http.server.HttpServerRequestCallback;
 import com.koushikdutta.ion.Ion;
 
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.TimeUnit;
+
 /**
  * Created by koush on 10/27/13.
  */
@@ -32,4 +43,59 @@ public void testIssue126() throws Exception {
         assertNotNull(bitmap);
         assertTrue(bitmap.getWidth() > 0);
     }
+
+    public void testIssue146() throws Exception {
+        AsyncHttpServer httpServer = new AsyncHttpServer();
+        httpServer.get("/", new HttpServerRequestCallback() {
+            @Override
+            public void onRequest(AsyncHttpServerRequest request, AsyncHttpServerResponse response) {
+                response.getHeaders().getHeaders().set("Cache-Control", "max-age=300");
+                response.send(request.getQuery().size() + "");
+            }
+        });
+        AsyncServer asyncServer = new AsyncServer();
+        try {
+            int localPort = httpServer.listen(asyncServer, 0).getLocalPort();
+            String s1 = Ion.with(getContext())
+            .load("http://localhost:" + localPort)
+            .addQuery("query1", "q")
+            .asString()
+            .get();
+
+            String s2 = Ion.with(getContext())
+            .load("http://localhost:" + localPort)
+            .addQuery("query1", "q")
+            .addQuery("query2", "qq")
+            .asString()
+            .get();
+
+            String s3 = Ion.with(getContext())
+            .load("http://localhost:" + localPort)
+            .addQuery("query1", "q")
+            .asString()
+            .get();
+
+            assertEquals(s1, "1");
+            assertEquals(s2, "2");
+            assertEquals(s3, "1");
+        }
+        finally {
+            asyncServer.stop();
+        }
+    }
+
+    public void testIssue200() throws Exception {
+        Map<String, List<String>> params = new HashMap<String, List<String>>();
+        params.put("email", Arrays.asList("mail@mail.pl"));
+        params.put("password", Arrays.asList("pass"));
+
+        String val = Ion.with(getContext())
+        .load("https://koush.clockworkmod.com/test/echo")
+        .setLogging("Issue200", Log.VERBOSE)
+        .setBodyParameters(params)
+        .asString()
+        .get(2000, TimeUnit.MILLISECONDS);
+
+        System.out.println(val);
+    }
 }
diff --git a/ion-test/src/com/koushikdutta/ion/test/StoreTests.java b/ion-test/src/com/koushikdutta/ion/test/StoreTests.java
index c95d3f79..ebca0571 100644
--- a/ion-test/src/com/koushikdutta/ion/test/StoreTests.java
+++ b/ion-test/src/com/koushikdutta/ion/test/StoreTests.java
@@ -13,41 +13,37 @@
 public class StoreTests extends AndroidTestCase {
     public void testString() throws Exception {
         Ion.getDefault(getContext())
-        .store()
-        .remove("foo")
-        .get(1000, TimeUnit.MILLISECONDS);
+        .store("foo")
+        .remove();
 
         Ion.getDefault(getContext())
-        .store()
-        .putString("foo", "bar")
+        .store("foo")
+        .putString("bar")
         .get(1000, TimeUnit.MILLISECONDS);
 
         String result = Ion.getDefault(getContext())
-        .store()
-        .getString("foo")
-        .get(1000, TimeUnit.MILLISECONDS);
+        .store("foo")
+        .getString();
 
         assertEquals(result, "bar");
     }
 
     public void testJson() throws Exception {
         Ion.getDefault(getContext())
-        .store()
-        .remove("foo")
-        .get(1000, TimeUnit.MILLISECONDS);
+        .store("foo")
+        .remove();
 
         JsonObject json = new JsonObject();
         json.addProperty("foo", "bar");
 
         Ion.getDefault(getContext())
-        .store()
-        .putJsonObject("foo", json)
+        .store("foo")
+        .putJsonObject(json)
         .get(1000, TimeUnit.MILLISECONDS);
 
         JsonObject result = Ion.getDefault(getContext())
-        .store()
-        .getJsonObject("foo")
-        .get(1000, TimeUnit.MILLISECONDS);
+        .store("foo")
+        .getJsonObject();
 
         assertEquals(result.get("foo").getAsString(), "bar");
     }
@@ -58,22 +54,20 @@ public void testJson() throws Exception {
 
     public void testGson() throws Exception {
         Ion.getDefault(getContext())
-        .store()
-        .remove("foo")
-        .get(1000, TimeUnit.MILLISECONDS);
+        .store("foo")
+        .remove();
 
         TestClass test = new TestClass();
         test.foo = "bar";
 
         Ion.getDefault(getContext())
-        .store()
-        .put("foo", test, TestClass.class)
+        .store("foo")
+        .put(test, TestClass.class)
         .get(1000, TimeUnit.MILLISECONDS);
 
         TestClass result = Ion.getDefault(getContext())
-        .store()
-        .get("foo", TestClass.class)
-        .get(1000, TimeUnit.MILLISECONDS);
+        .store("foo")
+        .get(TestClass.class);
 
         assertEquals(result.foo, "bar");
     }
diff --git a/ion/Android.mk b/ion/Android.mk
index 49b9fc64..3362a0c9 100644
--- a/ion/Android.mk
+++ b/ion/Android.mk
@@ -18,7 +18,7 @@ LOCAL_PATH := $(call my-dir)
 
 include $(CLEAR_VARS)
 
-LOCAL_STATIC_JAVA_LIBRARIES := AndroidAsync gson
+LOCAL_STATIC_JAVA_LIBRARIES := AndroidAsync gson android-support-v4
 
 LOCAL_MODULE := ion
 LOCAL_SDK_VERSION := 19
diff --git a/ion/AndroidManifest.xml b/ion/AndroidManifest.xml
index 6d5cb869..f99f969f 100644
--- a/ion/AndroidManifest.xml
+++ b/ion/AndroidManifest.xml
@@ -1,8 +1,8 @@
 <?xml version="1.0" encoding="utf-8"?>
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
           package="com.koushikdutta.ion"
-          android:versionCode="121"
-          android:versionName="1.2.1">
+          android:versionCode="125"
+          android:versionName="1.2.5">
     <uses-sdk android:minSdkVersion="9" android:targetSdkVersion="18" />
     <application />
 </manifest>
diff --git a/ion/build.gradle b/ion/build.gradle
index 992a8cb6..e80caf53 100644
--- a/ion/build.gradle
+++ b/ion/build.gradle
@@ -5,7 +5,7 @@ buildscript {
     }
 
     dependencies {
-      classpath 'com.android.tools.build:gradle:0.9.+'
+      classpath 'com.android.tools.build:gradle:0.10.+'
     }
 }
 
diff --git a/ion/ion.iml b/ion/ion.iml
index 2494382d..a4121540 100644
--- a/ion/ion.iml
+++ b/ion/ion.iml
@@ -20,7 +20,7 @@
       <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
       <sourceFolder url="file://$MODULE_DIR$/gen" isTestSource="false" generated="true" />
     </content>
-    <orderEntry type="jdk" jdkName="Android API 19 Platform" jdkType="Android SDK" />
+    <orderEntry type="inheritedJdk" />
     <orderEntry type="sourceFolder" forTests="false" />
     <orderEntry type="module-library" exported="">
       <library>
@@ -33,6 +33,7 @@
       </library>
     </orderEntry>
     <orderEntry type="module" module-name="AndroidAsync" exported="" />
+    <orderEntry type="module" module-name="v4" exported="" />
   </component>
 </module>
 
diff --git a/ion/project.properties b/ion/project.properties
index 22cd8d31..14e09e94 100644
--- a/ion/project.properties
+++ b/ion/project.properties
@@ -17,3 +17,4 @@ android.library=true
 
 
 android.library.reference.1=../../AndroidAsync/AndroidAsync
+android.library.reference.2=../../android-support/v4
diff --git a/ion/src/com/koushikdutta/ion/BitmapCallback.java b/ion/src/com/koushikdutta/ion/BitmapCallback.java
index a5a1ba3b..515c5fb2 100644
--- a/ion/src/com/koushikdutta/ion/BitmapCallback.java
+++ b/ion/src/com/koushikdutta/ion/BitmapCallback.java
@@ -1,17 +1,19 @@
 package com.koushikdutta.ion;
 
+import android.graphics.Point;
+
 import com.koushikdutta.async.AsyncServer;
 import com.koushikdutta.async.future.FutureCallback;
-import com.koushikdutta.ion.Ion;
 import com.koushikdutta.ion.bitmap.BitmapInfo;
 
 import java.util.ArrayList;
+import java.util.concurrent.CancellationException;
 
-class BitmapCallback {
+abstract class BitmapCallback {
     String key;
     Ion ion;
 
-    public BitmapCallback(Ion ion, String key, boolean put) {
+    protected BitmapCallback(Ion ion, String key, boolean put) {
         this.key = key;
         this.put = put;
         this.ion = ion;
@@ -25,29 +27,35 @@ boolean put() {
         return put;
     }
 
+    protected void onReported() {
+        ion.processDeferred();
+    }
+
     protected void report(final Exception e, final BitmapInfo info) {
         AsyncServer.post(Ion.mainHandler, new Runnable() {
             @Override
             public void run() {
                 BitmapInfo result = info;
                 if (result == null) {
-                    // cache errors
-                    result = new BitmapInfo();
-                    result.bitmaps = null;
-                    result.key = key;
+                    // cache errors, unless they were cancellation exceptions
+                    result = new BitmapInfo(key, null, null, new Point());
                     result.exception = e;
-                    ion.getBitmapCache().put(result);
+                    if (!(e instanceof CancellationException))
+                        ion.getBitmapCache().put(result);
                 } else if (put()) {
                     ion.getBitmapCache().put(result);
                 }
 
                 final ArrayList<FutureCallback<BitmapInfo>> callbacks = ion.bitmapsPending.remove(key);
-                if (callbacks == null || callbacks.size() == 0)
+                if (callbacks == null || callbacks.size() == 0) {
+                    onReported();
                     return;
+                }
 
                 for (FutureCallback<BitmapInfo> callback : callbacks) {
                     callback.onCompleted(e, result);
                 }
+                onReported();
             }
         });
     }
diff --git a/ion/src/com/koushikdutta/ion/BitmapFetcher.java b/ion/src/com/koushikdutta/ion/BitmapFetcher.java
new file mode 100644
index 00000000..3cba33e4
--- /dev/null
+++ b/ion/src/com/koushikdutta/ion/BitmapFetcher.java
@@ -0,0 +1,154 @@
+package com.koushikdutta.ion;
+
+import com.koushikdutta.async.AsyncServer;
+import com.koushikdutta.async.ByteBufferList;
+import com.koushikdutta.async.future.Future;
+import com.koushikdutta.async.future.FutureCallback;
+import com.koushikdutta.async.http.AsyncHttpRequest;
+import com.koushikdutta.async.parser.ByteBufferListParser;
+import com.koushikdutta.async.util.FileCache;
+import com.koushikdutta.ion.bitmap.BitmapInfo;
+import com.koushikdutta.ion.bitmap.Transform;
+import com.koushikdutta.ion.loader.MediaFile;
+
+import java.io.File;
+import java.net.URI;
+import java.util.ArrayList;
+
+class BitmapFetcher implements IonRequestBuilder.LoadRequestCallback {
+    String downloadKey;
+    String bitmapKey;
+    BitmapInfo info;
+    boolean hasTransforms;
+    ArrayList<Transform> transforms;
+    IonRequestBuilder builder;
+    int resizeWidth;
+    int resizeHeight;
+    boolean animateGif;
+    boolean deepZoom;
+
+    private boolean fastLoad(String uri) {
+        Ion ion = builder.ion;
+        if (deepZoom) {
+            if (uri == null || !uri.startsWith("file:/"))
+                return false;
+            File file = new File(URI.create(uri));
+            if (!file.exists())
+                return false;
+            MediaFile.MediaFileType type = MediaFile.getFileType(file.getAbsolutePath());
+            if (type == null || !MediaFile.isVideoFileType(type.fileType)) {
+                LoadDeepZoom loadDeepZoom = new LoadDeepZoom(ion, downloadKey, animateGif, null, null);
+                loadDeepZoom.onCompleted(null, file);
+//                System.out.println("fastloading deepZoom");
+                return true;
+            }
+            // fall through to allow some other loader to open this, cause this is a video file
+        }
+
+        boolean put = !hasTransforms;
+
+        for (Loader loader: ion.configure().getLoaders()) {
+            Future<BitmapInfo> future = loader.loadBitmap(builder.contextReference.getContext(), ion, downloadKey, uri, resizeWidth, resizeHeight, animateGif);
+            if (future != null) {
+                final BitmapCallback callback = new LoadBitmapBase(ion, downloadKey, put);
+                future.setCallback(new FutureCallback<BitmapInfo>() {
+                    @Override
+                    public void onCompleted(Exception e, BitmapInfo result) {
+                        callback.report(e, result);
+                    }
+                });
+                return true;
+            }
+        }
+        return false;
+    }
+
+    public static final int MAX_IMAGEVIEW_LOAD = 5;
+
+    public static boolean shouldDeferImageView(Ion ion) {
+        if (ion.bitmapsPending.keySet().size() <= MAX_IMAGEVIEW_LOAD)
+            return false;
+        int loadCount = 0;
+        for (String key: ion.bitmapsPending.keySet()) {
+            Object owner = ion.bitmapsPending.tag(key);
+            if (owner instanceof LoadBitmapBase) {
+                loadCount++;
+                if (loadCount > MAX_IMAGEVIEW_LOAD)
+                    return true;
+            }
+        }
+        return false;
+    }
+
+    public DeferredLoadBitmap defer() {
+        DeferredLoadBitmap ret = new DeferredLoadBitmap(builder.ion, downloadKey, this);
+        executeTransforms(builder.ion);
+        return ret;
+    }
+
+    private void executeTransforms(Ion ion) {
+        // if there's a transform, do it
+        if (!hasTransforms)
+            return;
+
+        // verify this transform isn't already pending
+        // make sure that the parent download isn't cancelled (empty list)
+        // and also make sure there are waiters for this transformed bitmap
+        if (ion.bitmapsPending.tag(bitmapKey) == null) {
+            ion.bitmapsPending.add(downloadKey, new TransformBitmap(ion, bitmapKey, downloadKey, transforms));
+        }
+    }
+
+    @Override
+    public boolean loadRequest(AsyncHttpRequest request) {
+        return !fastLoad(request.getUri().toString());
+    }
+
+    public void execute() {
+        final Ion ion = builder.ion;
+
+        // bitmaps that were transformed are put into the FileCache to prevent
+        // subsequent retransformation. See if we can retrieve the bitmap from the disk cache.
+        // See TransformBitmap for where the cache is populated.
+        FileCache fileCache = ion.responseCache.getFileCache();
+        if (!builder.noCache && hasTransforms && fileCache.exists(bitmapKey) && !deepZoom) {
+            TransformBitmap.getBitmapSnapshot(ion, bitmapKey);
+            return;
+        }
+
+        // Perform a download as necessary.
+        if (ion.bitmapsPending.tag(downloadKey) == null && !fastLoad(builder.uri)) {
+            builder.setHandler(null);
+            builder.loadRequestCallback = this;
+
+            if (!deepZoom) {
+                IonRequestBuilder.EmitterTransform<ByteBufferList> emitterTransform = builder.execute(new ByteBufferListParser(), new Runnable() {
+                    @Override
+                    public void run() {
+                        AsyncServer.post(Ion.mainHandler, new Runnable() {
+                            @Override
+                            public void run() {
+                                ion.bitmapsPending.remove(downloadKey);
+                            }
+                        });
+                    }
+                });
+                emitterTransform.setCallback(new LoadBitmap(ion, downloadKey, !hasTransforms, resizeWidth, resizeHeight, animateGif, emitterTransform));
+            }
+            else {
+//                System.out.println("downloading file for deepZoom");
+                File file = fileCache.getTempFile();
+                IonRequestBuilder.EmitterTransform<File> emitterTransform = builder.write(file);
+                LoadDeepZoom loadDeepZoom = new LoadDeepZoom(ion, downloadKey, animateGif, emitterTransform, fileCache) {
+                    @Override
+                    public void onCompleted(Exception e, File file) {
+                        super.onCompleted(e, file);
+                    }
+                };
+                emitterTransform.setCallback(loadDeepZoom);
+            }
+        }
+
+        executeTransforms(ion);
+    }
+}
diff --git a/ion/src/com/koushikdutta/ion/BitmapInfoToBitmap.java b/ion/src/com/koushikdutta/ion/BitmapInfoToBitmap.java
new file mode 100644
index 00000000..e6a05462
--- /dev/null
+++ b/ion/src/com/koushikdutta/ion/BitmapInfoToBitmap.java
@@ -0,0 +1,26 @@
+package com.koushikdutta.ion;
+
+import android.graphics.Bitmap;
+
+import com.koushikdutta.async.future.TransformFuture;
+import com.koushikdutta.ion.bitmap.BitmapInfo;
+
+class BitmapInfoToBitmap extends TransformFuture<Bitmap, BitmapInfo> {
+    ContextReference contextReference;
+    public BitmapInfoToBitmap(ContextReference contextReference) {
+        this.contextReference = contextReference;
+    }
+
+    @Override
+    protected void transform(BitmapInfo result) throws Exception {
+        if (contextReference.isAlive() != null) {
+            cancel();
+            return;
+        }
+
+        if (result.exception != null)
+            setComplete(result.exception);
+        else
+            setComplete(result.bitmaps[0]);
+    }
+}
\ No newline at end of file
diff --git a/ion/src/com/koushikdutta/ion/BitmapToBitmapInfo.java b/ion/src/com/koushikdutta/ion/BitmapToBitmapInfo.java
deleted file mode 100644
index cd225460..00000000
--- a/ion/src/com/koushikdutta/ion/BitmapToBitmapInfo.java
+++ /dev/null
@@ -1,143 +0,0 @@
-package com.koushikdutta.ion;
-
-import android.graphics.Bitmap;
-import android.util.Log;
-
-import com.koushikdutta.async.ByteBufferList;
-import com.koushikdutta.async.future.FutureCallback;
-import com.koushikdutta.async.http.ResponseCacheMiddleware;
-import com.koushikdutta.async.http.libcore.DiskLruCache;
-import com.koushikdutta.ion.bitmap.BitmapInfo;
-import com.koushikdutta.ion.bitmap.Transform;
-import com.koushikdutta.ion.loader.FileLoader;
-
-import java.io.BufferedInputStream;
-import java.io.DataInputStream;
-import java.io.FileInputStream;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.nio.ByteBuffer;
-import java.util.ArrayList;
-
-class BitmapToBitmapInfo extends BitmapCallback implements FutureCallback<BitmapInfo> {
-    ArrayList<Transform> transforms;
-
-    public static void getBitmapSnapshot(final Ion ion, final String transformKey) {
-        final BitmapCallback callback = new BitmapCallback(ion, transformKey, true);
-        Ion.getBitmapLoadExecutorService().execute(new Runnable() {
-            @Override
-            public void run() {
-                if (ion.bitmapsPending.tag(transformKey) != callback) {
-                    Log.d("IonBitmapLoader", "Bitmap cache load cancelled (no longer needed)");
-                    return;
-                }
-
-                try {
-                    DiskLruCache.Snapshot snapshot = ion.responseCache.getDiskLruCache().get(transformKey);
-                    try {
-                        InputStream in = snapshot.getInputStream(0);
-                        assert in instanceof FileInputStream;
-                        Bitmap bitmap = ion.getBitmapCache().loadBitmap(in, -1, -1);
-                        in.close();
-                        if (bitmap == null)
-                            throw new Exception("Bitmap failed to load");
-
-                        BitmapInfo info = new BitmapInfo();
-                        info.bitmaps = new Bitmap[] { bitmap };
-                        info.loadedFrom =  Loader.LoaderEmitter.LOADED_FROM_CACHE;
-                        info.key = transformKey;
-                        callback.report(null, info);
-                    } finally {
-                        snapshot.close();
-                    }
-                }
-                catch (OutOfMemoryError e) {
-                    callback.report(new Exception(e), null);
-                }
-                catch (Exception e) {
-                    callback.report(e, null);
-                    try {
-                        ion.responseCache.getDiskLruCache().remove(transformKey);
-                    } catch (Exception ex) {
-                    }
-                }
-            }
-        });
-    }
-
-    String downloadKey;
-    public BitmapToBitmapInfo(Ion ion, String transformKey, String downloadKey, ArrayList<Transform> transforms) {
-        super(ion, transformKey, true);
-        this.transforms = transforms;
-        this.downloadKey = downloadKey;
-    }
-
-    @Override
-    public void onCompleted(Exception e, final BitmapInfo result) {
-        if (e != null) {
-            report(e, null);
-            return;
-        }
-
-        if (ion.bitmapsPending.tag(key) != this) {
-            Log.d("IonBitmapLoader", "Bitmap transform cancelled (no longer needed)");
-            return;
-        }
-
-        Ion.getBitmapLoadExecutorService().execute(new Runnable() {
-            @Override
-            public void run() {
-                BitmapInfo info = new BitmapInfo();
-                info.bitmaps = new Bitmap[result.bitmaps.length];
-                try {
-                    for (int i = 0; i < result.bitmaps.length; i++) {
-                        for (Transform transform : transforms) {
-                            Bitmap bitmap = transform.transform(result.bitmaps[i]);
-                            if (bitmap == null)
-                                throw new Exception("failed to transform bitmap");
-                            info.bitmaps[i] = bitmap;
-                        }
-                    }
-                    info.delays = result.delays;
-                    info.loadedFrom = result.loadedFrom;
-                    info.key = key;
-                    report(null, info);
-                }
-                catch (OutOfMemoryError e) {
-                    report(new Exception(e), null);
-                    return;
-                }
-                catch (Exception e) {
-                    report(e, null);
-                    return;
-                }
-                // the transformed bitmap was successfully load it, let's toss it into
-                // the disk lru cache.
-                // but don't persist gifs...
-                if (info.bitmaps.length > 1)
-                    return;
-                try {
-                    DiskLruCache cache = ion.responseCache.getDiskLruCache();
-                    if (cache == null)
-                        return;
-                    DiskLruCache.Editor editor = cache.edit(key);
-                    if (editor == null)
-                        return;
-                    try {
-                        for (int i = 1; i < ResponseCacheMiddleware.ENTRY_COUNT; i++) {
-                            editor.set(i, key);
-                        }
-                        OutputStream out = editor.newOutputStream(0);
-                        Bitmap.CompressFormat format = info.bitmaps[0].hasAlpha() ? Bitmap.CompressFormat.PNG : Bitmap.CompressFormat.JPEG;
-                        info.bitmaps[0].compress(format, 100, out);
-                        out.close();
-                        editor.commit();
-                    } catch (Exception ex) {
-                        editor.abort();
-                    }
-                } catch (Exception e) {
-                }
-            }
-        });
-    }
-}
\ No newline at end of file
diff --git a/ion/src/com/koushikdutta/ion/ContextReference.java b/ion/src/com/koushikdutta/ion/ContextReference.java
new file mode 100644
index 00000000..8d60d823
--- /dev/null
+++ b/ion/src/com/koushikdutta/ion/ContextReference.java
@@ -0,0 +1,183 @@
+package com.koushikdutta.ion;
+
+import android.annotation.TargetApi;
+import android.app.Activity;
+import android.app.ActivityManager;
+import android.app.Fragment;
+import android.app.Service;
+import android.content.Context;
+import android.os.Build;
+import android.widget.ImageView;
+
+import java.lang.ref.WeakReference;
+import java.util.List;
+
+/**
+ * Created by koush on 4/15/14.
+ */
+abstract class ContextReference<T> extends WeakReference<T> {
+    ContextReference(T t) {
+        super(t);
+    }
+
+    abstract static class NormalContextReference<T extends Context> extends ContextReference<T> {
+        NormalContextReference(T context) {
+            super(context);
+        }
+
+        static String isAlive(Context context) {
+            if (context instanceof Service)
+                return ServiceContextReference.isAlive((Service) context);
+            if (context instanceof Activity)
+                return ActivityContextReference.isAlive((Activity) context);
+            return null;
+        }
+
+        @Override
+        public Context getContext() {
+            return get();
+        }
+    }
+
+    static class ServiceContextReference extends NormalContextReference<Service> {
+        public ServiceContextReference(Service service) {
+            super(service);
+        }
+
+        static String isAlive(Service candidate) {
+            if (candidate == null)
+                return "Service reference null";
+            ActivityManager manager = (ActivityManager)candidate.getSystemService(Context.ACTIVITY_SERVICE);
+            List<ActivityManager.RunningServiceInfo> services = manager.getRunningServices(Integer.MAX_VALUE);
+            if (services == null)
+                return "Could not retrieve services from service manager";
+            for (ActivityManager.RunningServiceInfo service: services) {
+                if (candidate.getClass().getName().equals(service.service.getClassName())) {
+                    return null;
+                }
+            }
+            return "Service stopped";
+        }
+
+        @Override
+        public String isAlive() {
+            return isAlive(get());
+        }
+    }
+
+    static class ActivityContextReference extends NormalContextReference<Activity> {
+        public ActivityContextReference(Activity activity) {
+            super(activity);
+        }
+
+        static String isAlive(Activity a) {
+            if (a == null)
+                return "Activity reference null";
+            if (a.isFinishing())
+                return "Activity finished";
+            return null;
+        }
+
+        @Override
+        public String isAlive() {
+            return isAlive(get());
+        }
+    }
+
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR2)
+    static class FragmentContextReference extends ContextReference<Fragment> {
+        public FragmentContextReference(Fragment fragment) {
+            super(fragment);
+        }
+
+        @Override
+        public Context getContext() {
+            Fragment fragment = get();
+            if (fragment == null)
+                return null;
+            return fragment.getActivity();
+        }
+
+        @Override
+        public String isAlive() {
+            Fragment fragment = get();
+            if (fragment == null)
+                return "Fragment reference null";
+            String ret = ActivityContextReference.isAlive(fragment.getActivity());
+            if (ret != null)
+                return ret;
+            if (fragment.isDetached())
+                return "Fragment detached";
+            return null;
+        }
+    }
+
+    static class SupportFragmentContextReference extends ContextReference<android.support.v4.app.Fragment> {
+        public SupportFragmentContextReference(android.support.v4.app.Fragment fragment) {
+            super(fragment);
+        }
+
+        @Override
+        public Context getContext() {
+            android.support.v4.app.Fragment fragment = get();
+            if (fragment == null)
+                return null;
+            return fragment.getActivity();
+        }
+
+        @Override
+        public String isAlive() {
+            android.support.v4.app.Fragment fragment = get();
+            if (fragment == null)
+                return "Fragment reference null";
+            String ret = ActivityContextReference.isAlive(fragment.getActivity());
+            if (ret != null)
+                return ret;
+            if (fragment.isDetached())
+                return "Fragment detached";
+            return null;
+        }
+    }
+
+    static class ImageViewContextReference extends ContextReference<ImageView> {
+        public ImageViewContextReference(ImageView imageView) {
+            super(imageView);
+        }
+
+        @Override
+        public String isAlive() {
+            ImageView iv = get();
+            if (iv == null)
+                return "ImageView reference null";
+            return NormalContextReference.isAlive(iv.getContext());
+        }
+
+        @Override
+        public Context getContext() {
+            ImageView iv = get();
+            if (iv == null)
+                return null;
+            return iv.getContext();
+        }
+    }
+
+    public static ContextReference fromContext(Context context) {
+        if (context instanceof Service)
+            return new ServiceContextReference((Service)context);
+        if (context instanceof Activity)
+            return new ActivityContextReference((Activity)context);
+
+        return new NormalContextReference<Context>(context) {
+            @Override
+            public String isAlive() {
+                Context context = get();
+                if (context == null)
+                    return "Context reference null";
+                return null;
+            }
+        };
+    }
+
+    public abstract String isAlive();
+    public abstract Context getContext();
+}
diff --git a/ion/src/com/koushikdutta/ion/DefaultTransform.java b/ion/src/com/koushikdutta/ion/DefaultTransform.java
index c60a4824..f429a0a7 100644
--- a/ion/src/com/koushikdutta/ion/DefaultTransform.java
+++ b/ion/src/com/koushikdutta/ion/DefaultTransform.java
@@ -21,7 +21,10 @@ public DefaultTransform(int width, int height, ScaleMode scaleMode) {
 
     @Override
     public Bitmap transform(Bitmap b) {
-        Bitmap ret = Bitmap.createBitmap(resizeWidth, resizeHeight, b.getConfig());
+        Bitmap.Config config = b.getConfig();
+        if (config == null)
+            config = Bitmap.Config.ARGB_8888;
+        Bitmap ret = Bitmap.createBitmap(resizeWidth, resizeHeight, config);
         Canvas canvas = new Canvas(ret);
 
         RectF destination = new RectF(0, 0, resizeWidth, resizeHeight);
diff --git a/ion/src/com/koushikdutta/ion/DeferredLoadBitmap.java b/ion/src/com/koushikdutta/ion/DeferredLoadBitmap.java
new file mode 100644
index 00000000..cd30a28d
--- /dev/null
+++ b/ion/src/com/koushikdutta/ion/DeferredLoadBitmap.java
@@ -0,0 +1,12 @@
+package com.koushikdutta.ion;
+
+/**
+ * Created by koush on 1/18/14.
+ */
+public class DeferredLoadBitmap extends BitmapCallback {
+    BitmapFetcher fetcher;
+    public DeferredLoadBitmap(Ion ion, String key, BitmapFetcher fetcher)  {
+        super(ion, key, false);
+        this.fetcher = fetcher;
+    }
+}
diff --git a/ion/src/com/koushikdutta/ion/DiskLruCacheStore.java b/ion/src/com/koushikdutta/ion/DiskLruCacheStore.java
deleted file mode 100644
index c3ea3e45..00000000
--- a/ion/src/com/koushikdutta/ion/DiskLruCacheStore.java
+++ /dev/null
@@ -1,207 +0,0 @@
-package com.koushikdutta.ion;
-
-import com.google.gson.JsonArray;
-import com.google.gson.JsonObject;
-import com.google.gson.reflect.TypeToken;
-import com.koushikdutta.async.callback.CompletedCallback;
-import com.koushikdutta.async.future.Future;
-import com.koushikdutta.async.future.FutureCallback;
-import com.koushikdutta.async.future.SimpleFuture;
-import com.koushikdutta.async.http.ResponseCacheMiddleware;
-import com.koushikdutta.async.http.libcore.DiskLruCache;
-import com.koushikdutta.async.parser.AsyncParser;
-import com.koushikdutta.async.parser.DocumentParser;
-import com.koushikdutta.async.parser.StringParser;
-import com.koushikdutta.async.stream.InputStreamDataEmitter;
-import com.koushikdutta.async.stream.OutputStreamDataSink;
-import com.koushikdutta.ion.gson.GsonParser;
-import com.koushikdutta.ion.gson.GsonSerializer;
-
-import org.w3c.dom.Document;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-
-/**
- * Created by koush on 11/17/13.
- */
-public class DiskLruCacheStore {
-    Ion ion;
-    DiskLruCache cache;
-    DiskLruCacheStore(Ion ion, DiskLruCache cache) {
-        this.ion = ion;
-        this.cache = cache;
-    }
-
-    private <T> Future<T> put(final String rawKey, final T value, final AsyncParser<T> parser) {
-        final SimpleFuture<T> ret = new SimpleFuture<T>();
-        Ion.getIoExecutorService().execute(new Runnable() {
-            @Override
-            public void run() {
-                final DiskLruCache.Editor editor;
-                try {
-                    final String key = ResponseCacheMiddleware.toKeyString("ion-store:" + rawKey);
-                    editor = cache.edit(key);
-                }
-                catch (Exception e) {
-                    ret.setComplete(e);
-                    return;
-                }
-                final OutputStream out;
-                try {
-                    out = editor.newOutputStream(0);
-                    for (int i = 1; i < cache.getValueCount(); i++) {
-                        editor.newOutputStream(i).close();
-                    }
-                }
-                catch (Exception e) {
-                    try {
-                        editor.abort();
-                    }
-                    catch (Exception ex) {
-                    }
-                    ret.setComplete(e);
-                    return;
-                }
-
-                if (editor == null) {
-                    ret.setComplete(new Exception("unable to edit"));
-                    return;
-                }
-                parser.write(new OutputStreamDataSink(ion.getServer(), out), value, new CompletedCallback() {
-                    @Override
-                    public void onCompleted(Exception ex) {
-                        if (ex == null) {
-                            try {
-                                out.close();
-                                editor.commit();
-                                ret.setComplete(value);
-                                return;
-                            }
-                            catch (Exception e) {
-                                ex = e;
-                            }
-                        }
-                        try {
-                            editor.abort();
-                        }
-                        catch (Exception e) {
-                        }
-                        ret.setComplete(ex);
-                    }
-                });
-            }
-        });
-        return ret;
-    }
-
-    public Future<String> putString(String key, String value) {
-        return put(key, value, new StringParser());
-    }
-
-    public Future<JsonObject> putJsonObject(String key, JsonObject value) {
-        return put(key, value, new GsonParser<JsonObject>());
-    }
-
-    public Future<Document> putDocument(String key, Document value) {
-        return put(key, value, new DocumentParser());
-    }
-
-    public Future<JsonArray> putJsonArray(String key, JsonArray value) {
-        return put(key, value, new GsonParser<JsonArray>());
-    }
-
-    /*
-    public Future<InputStream> putInputStream(InputStream value) {
-        throw new AssertionError("not implemented");
-    }
-
-    public Future<byte[]> putByteArray(byte[] bytes) {
-        throw new AssertionError("not implemented");
-    }
-    */
-
-    public <T> Future<T> put(String key, T value, Class<T> clazz) {
-        return put(key, value, new GsonSerializer<T>(ion.configure().getGson(), clazz));
-    }
-
-    public <T> Future<T> put(String key, T value, TypeToken<T> token) {
-        return put(key, value, new GsonSerializer<T>(ion.configure().getGson(), token));
-    }
-    
-    private <T> Future<T> get(final String rawKey, final AsyncParser<T> parser) {
-        final SimpleFuture<T> ret = new SimpleFuture<T>();
-
-        Ion.getIoExecutorService().execute(new Runnable() {
-            @Override
-            public void run() {
-                try {
-                    final String key = ResponseCacheMiddleware.toKeyString("ion-store:" + rawKey);
-                    final DiskLruCache.Snapshot snapshot = cache.get(key);
-                    if (snapshot == null) {
-                        ret.setComplete((T)null);
-                        return;
-                    }
-                    InputStream inputStream = snapshot.getInputStream(0);
-                    InputStreamDataEmitter emitter = new InputStreamDataEmitter(ion.getServer(), inputStream);
-                    parser.parse(emitter).setCallback(new FutureCallback<T>() {
-                        @Override
-                        public void onCompleted(Exception e, T result) {
-                            snapshot.close();
-                            if (e != null)
-                                ret.setComplete(e);
-                            else
-                                ret.setComplete(result);
-                        }
-                    });
-                }
-                catch (Exception e) {
-                }
-            }
-        });
-        
-        return ret;
-    }
-    
-    public Future<String> getString(String key) {
-        return get(key, new StringParser());
-    }
-
-    public Future<JsonObject> getJsonObject(String key) {
-        return get(key, new GsonParser<JsonObject>());
-    }
-
-    public Future<JsonArray> getJsonArray(String key) {
-        return get(key, new GsonParser<JsonArray>());
-    }
-
-    public Future<Document> getDocument(String key) {
-        return get(key, new DocumentParser());
-    }
-
-    public <T> Future<T> get(String key, Class<T> clazz) {
-        return get(key, new GsonSerializer<T>(ion.configure().getGson(), clazz));
-    }
-
-    public <T> Future<T> get(String key, TypeToken<T> token) {
-        return get(key, new GsonSerializer<T>(ion.configure().getGson(), token));
-    }
-
-    public Future<String> remove(final String key) {
-        final SimpleFuture<String> ret = new SimpleFuture<String>();
-        Ion.getIoExecutorService().execute(new Runnable() {
-            @Override
-            public void run() {
-                try {
-                    cache.remove(key);
-                    ret.setComplete(key);
-                }
-                catch (Exception e) {
-                    ret.setComplete(e);
-                }
-            }
-        });
-        return ret;
-    }
-}
diff --git a/ion/src/com/koushikdutta/ion/FileCacheStore.java b/ion/src/com/koushikdutta/ion/FileCacheStore.java
new file mode 100644
index 00000000..e83119ae
--- /dev/null
+++ b/ion/src/com/koushikdutta/ion/FileCacheStore.java
@@ -0,0 +1,190 @@
+package com.koushikdutta.ion;
+
+import com.google.gson.JsonArray;
+import com.google.gson.JsonObject;
+import com.google.gson.reflect.TypeToken;
+import com.koushikdutta.async.callback.CompletedCallback;
+import com.koushikdutta.async.future.Future;
+import com.koushikdutta.async.future.SimpleFuture;
+import com.koushikdutta.async.parser.AsyncParser;
+import com.koushikdutta.async.parser.DocumentParser;
+import com.koushikdutta.async.parser.StringParser;
+import com.koushikdutta.async.stream.FileDataSink;
+import com.koushikdutta.async.util.FileCache;
+import com.koushikdutta.ion.gson.GsonParser;
+import com.koushikdutta.ion.gson.GsonSerializer;
+
+import org.w3c.dom.Document;
+
+import java.io.File;
+import java.util.Set;
+
+/**
+ * Created by koush on 11/17/13.
+ */
+public class FileCacheStore {
+    Ion ion;
+    FileCache cache;
+    String rawKey;
+    FileCacheStore(Ion ion, FileCache cache, String rawKey) {
+        this.ion = ion;
+        this.cache = cache;
+        this.rawKey = rawKey;
+    }
+
+    private <T> Future<T> put(final T value, final AsyncParser<T> parser) {
+        final SimpleFuture<T> ret = new SimpleFuture<T>();
+        Ion.getIoExecutorService().execute(new Runnable() {
+            @Override
+            public void run() {
+                final String key = computeKey();
+                final File file = cache.getTempFile();
+                final FileDataSink sink = new FileDataSink(ion.getServer(), file);
+                parser.write(sink, value, new CompletedCallback() {
+                    @Override
+                    public void onCompleted(Exception ex) {
+                        sink.close();
+                        if (ex != null) {
+                            file.delete();
+                            ret.setComplete(ex);
+                            return;
+                        }
+                        cache.commitTempFiles(key, file);
+                        ret.setComplete(value);
+                    }
+                });
+            }
+        });
+        return ret;
+    }
+
+    public Future<String> putString(String value) {
+        return put(value, new StringParser());
+    }
+
+    public Future<JsonObject> putJsonObject(JsonObject value) {
+        return put(value, new GsonParser<JsonObject>());
+    }
+
+    public Future<Document> putDocument(Document value) {
+        return put(value, new DocumentParser());
+    }
+
+    public Future<JsonArray> putJsonArray(JsonArray value) {
+        return put(value, new GsonParser<JsonArray>());
+    }
+
+    /*
+    public Future<InputStream> putInputStream(InputStream value) {
+        throw new AssertionError("not implemented");
+    }
+
+    public Future<byte[]> putByteArray(byte[] bytes) {
+        throw new AssertionError("not implemented");
+    }
+    */
+
+    public <T> Future<T> put(T value, Class<T> clazz) {
+        return put(value, new GsonSerializer<T>(ion.configure().getGson(), clazz));
+    }
+
+    public <T> Future<T> put(T value, TypeToken<T> token) {
+        return put(value, new GsonSerializer<T>(ion.configure().getGson(), token));
+    }
+
+    private <T> Future<T> as(final AsyncParser<T> parser) {
+        final SimpleFuture<T> ret = new SimpleFuture<T>();
+
+        Ion.getIoExecutorService().execute(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    final String key = computeKey();
+                    final File file = cache.getFile(key);
+                    if (!file.exists()) {
+                        ret.setComplete((T)null);
+                        return;
+                    }
+                    ion.build(ion.getContext(), file)
+                    .as(parser)
+                    .setCallback(ret.getCompletionCallback());
+                }
+                catch (Exception e) {
+                    ret.setComplete(e);
+                }
+            }
+        });
+        
+        return ret;
+    }
+
+    private <T> T get(final AsyncParser<T> parser) {
+        try {
+            final String key = computeKey();
+            final File file = cache.getFile(key);
+            return ion.build(ion.getContext(), file)
+            .as(parser)
+            .get();
+        }
+        catch (Exception e) {
+            return null;
+        }
+    }
+
+    public String getString() {
+        return get(new StringParser());
+    }
+
+    public Future<String> asString() {
+        return as(new StringParser());
+    }
+
+    public Future<JsonObject> asJsonObject() {
+        return as(new GsonParser<JsonObject>());
+    }
+
+    public JsonObject getJsonObject() {
+        return get(new GsonParser<JsonObject>());
+    }
+
+    public Future<JsonArray> asJsonArray() {
+        return as(new GsonParser<JsonArray>());
+    }
+
+    public JsonArray getJsonArray() {
+        return get(new GsonParser<JsonArray>());
+    }
+
+    public Future<Document> asDocument() {
+        return as(new DocumentParser());
+    }
+
+    public Document getDocument() {
+        return get(new DocumentParser());
+    }
+
+    public <T> Future<T> as(Class<T> clazz) {
+        return as(new GsonSerializer<T>(ion.configure().getGson(), clazz));
+    }
+
+    public <T> T get(Class<T> clazz) {
+        return get(new GsonSerializer<T>(ion.configure().getGson(), clazz));
+    }
+
+    public <T> Future<T> as(TypeToken<T> token) {
+        return as(new GsonSerializer<T>(ion.configure().getGson(), token));
+    }
+
+    public <T> T get(TypeToken<T> token) {
+        return get(new GsonSerializer<T>(ion.configure().getGson(), token));
+    }
+
+    private String computeKey() {
+        return rawKey.replace(":", "_");
+    }
+
+    public void remove() {
+        final String key = computeKey();
+        cache.remove(key);
+    }
+}
diff --git a/ion/src/com/koushikdutta/ion/Ion.java b/ion/src/com/koushikdutta/ion/Ion.java
index 0d1a22b4..ee5f6a30 100644
--- a/ion/src/com/koushikdutta/ion/Ion.java
+++ b/ion/src/com/koushikdutta/ion/Ion.java
@@ -1,14 +1,7 @@
 package com.koushikdutta.ion;
 
-import java.io.File;
-import java.net.URI;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.WeakHashMap;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-
+import android.annotation.TargetApi;
+import android.app.Fragment;
 import android.content.Context;
 import android.os.Build;
 import android.os.Handler;
@@ -24,8 +17,9 @@
 import com.koushikdutta.async.http.AsyncHttpClient;
 import com.koushikdutta.async.http.AsyncHttpRequest;
 import com.koushikdutta.async.http.ResponseCacheMiddleware;
-import com.koushikdutta.async.http.libcore.DiskLruCache;
 import com.koushikdutta.async.http.libcore.RawHeaders;
+import com.koushikdutta.async.util.FileCache;
+import com.koushikdutta.async.util.FileUtility;
 import com.koushikdutta.async.util.HashList;
 import com.koushikdutta.ion.bitmap.BitmapInfo;
 import com.koushikdutta.ion.bitmap.IonBitmapCache;
@@ -40,6 +34,16 @@
 import com.koushikdutta.ion.loader.PackageIconLoader;
 import com.koushikdutta.ion.loader.VideoLoader;
 
+import java.io.File;
+import java.io.IOException;
+import java.net.URI;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.WeakHashMap;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+
 /**
  * Created by koush on 5/21/13.
  */
@@ -52,22 +56,42 @@
 
     /**
      * Get the default Ion object instance and begin building a request
-     * with the given uri
      * @param context
-     * @param uri
      * @return
      */
-    public static Builders.Any.B with(Context context, String uri) {
-        return getDefault(context).build(context, uri);
+    public static LoadBuilder<Builders.Any.B> with(Context context) {
+        return getDefault(context).build(context);
+    }
+
+    /**
+     * the default Ion object instance and begin building a request
+     * @param fragment
+     * @return
+     */
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR2)
+    public static LoadBuilder<Builders.Any.B> with(Fragment fragment) {
+        return getDefault(fragment.getActivity()).build(fragment);
+    }
+
+    /**
+     * the default Ion object instance and begin building a request
+     * @param fragment
+     * @return
+     */
+    public static LoadBuilder<Builders.Any.B> with(android.support.v4.app.Fragment fragment) {
+        return getDefault(fragment.getActivity()).build(fragment);
     }
 
     /**
      * Get the default Ion object instance and begin building a request
+     * with the given uri
      * @param context
+     * @param uri
      * @return
      */
-    public static LoadBuilder<Builders.Any.B> with(Context context) {
-        return getDefault(context).build(context);
+    @Deprecated
+    public static Builders.Any.B with(Context context, String uri) {
+        return getDefault(context).build(context, uri);
     }
 
     /**
@@ -77,9 +101,11 @@
      * @param file
      * @return
      */
+    @Deprecated
     public static FutureBuilder with(Context context, File file) {
         return getDefault(context).build(context, file);
     }
+
     /**
      * Get the default Ion instance
      * @param context
@@ -96,6 +122,8 @@ public static Ion getDefault(Context context) {
      * @return
      */
     public static Ion getInstance(Context context, String name) {
+        if (context == null)
+            throw new NullPointerException("Can not pass null context in to retrieve ion instance");
         Ion instance = instances.get(name);
         if (instance == null)
             instances.put(name, instance = new Ion(context, name));
@@ -107,15 +135,14 @@ public static Ion getInstance(Context context, String name) {
      * @param imageView
      * @return
      */
-    public static Builders.ImageView.F<? extends Builders.ImageView.F<?>> with(ImageView imageView) {
-        Ion ion = getDefault(imageView.getContext());
-        return ion.build(imageView);
+    public static Builders.IV.F<? extends Builders.IV.F<?>> with(ImageView imageView) {
+        return getDefault(imageView.getContext()).build(imageView);
     }
 
     AsyncHttpClient httpClient;
     CookieMiddleware cookieMiddleware;
     ResponseCacheMiddleware responseCache;
-    DiskLruCache storeCache;
+    FileCache storeCache;
     HttpLoader httpLoader;
     ContentLoader contentLoader;
     VideoLoader videoLoader;
@@ -134,22 +161,27 @@ public static Ion getInstance(Context context, String name) {
     IonBitmapRequestBuilder bitmapBuilder = new IonBitmapRequestBuilder(this);
 
     private Ion(Context context, String name) {
-        httpClient = new AsyncHttpClient(new AsyncServer());
+        httpClient = new AsyncHttpClient(new AsyncServer("ion-" + name));
         this.context = context = context.getApplicationContext();
         this.name = name;
 
+        File ionCacheDir = new File(context.getCacheDir(), name);
         try {
-            responseCache = ResponseCacheMiddleware.addCache(httpClient, new File(context.getCacheDir(), name), 10L * 1024L * 1024L);
-        }
-        catch (Exception e) {
-            IonLog.w("unable to set up response cache", e);
+            responseCache = ResponseCacheMiddleware.addCache(httpClient, ionCacheDir, 10L * 1024L * 1024L);
         }
-        try {
-            storeCache = DiskLruCache.open(new File(context.getFilesDir(), name), 1, 1, Long.MAX_VALUE);
-        }
-        catch (Exception e) {
+        catch (IOException e) {
+            IonLog.w("unable to set up response cache, clearing", e);
+            FileUtility.deleteDirectory(ionCacheDir);
+            try {
+                responseCache = ResponseCacheMiddleware.addCache(httpClient, ionCacheDir, 10L * 1024L * 1024L);
+            }
+            catch (IOException ex) {
+                IonLog.w("unable to set up response cache, failing", e);
+            }
         }
 
+        storeCache = new FileCache(new File(context.getFilesDir(), name), Long.MAX_VALUE, false);
+
         // TODO: Support pre GB?
         if (Build.VERSION.SDK_INT >= 9)
             addCookieMiddleware();
@@ -181,8 +213,9 @@ public static ExecutorService getIoExecutorService() {
      * @param file
      * @return
      */
+    @Deprecated
     public FutureBuilder build(Context context, File file) {
-        return new IonRequestBuilder(context, this).load(file);
+        return new IonRequestBuilder(ContextReference.fromContext(context), this).load(file);
     }
 
     /**
@@ -191,8 +224,9 @@ public FutureBuilder build(Context context, File file) {
      * @param uri
      * @return
      */
+    @Deprecated
     public Builders.Any.B build(Context context, String uri) {
-        return new IonRequestBuilder(context, this).load(uri);
+        return new IonRequestBuilder(ContextReference.fromContext(context), this).load(uri);
     }
 
     /**
@@ -201,7 +235,25 @@ public FutureBuilder build(Context context, File file) {
      * @return
      */
     public LoadBuilder<Builders.Any.B> build(Context context) {
-        return new IonRequestBuilder(context, this);
+        return new IonRequestBuilder(ContextReference.fromContext(context), this);
+    }
+
+    /**
+     * Begin building a request
+     * @param fragment
+     * @return
+     */
+    public LoadBuilder<Builders.Any.B> build(Fragment fragment) {
+        return new IonRequestBuilder(new ContextReference.FragmentContextReference(fragment), this);
+    }
+
+    /**
+     * Begin building a request
+     * @param fragment
+     * @return
+     */
+    public LoadBuilder<Builders.Any.B> build(android.support.v4.app.Fragment fragment) {
+        return new IonRequestBuilder(new ContextReference.SupportFragmentContextReference(fragment), this);
     }
 
     /**
@@ -209,7 +261,7 @@ public FutureBuilder build(Context context, File file) {
      * @param imageView
      * @return
      */
-    public Builders.ImageView.F<? extends Builders.ImageView.F<?>> build(ImageView imageView) {
+    public Builders.IV.F<? extends Builders.IV.F<?>> build(ImageView imageView) {
         if (Thread.currentThread() != Looper.getMainLooper().getThread())
             throw new IllegalStateException("must be called from UI thread");
         bitmapBuilder.reset();
@@ -217,6 +269,54 @@ public FutureBuilder build(Context context, File file) {
         return bitmapBuilder.withImageView(imageView);
     }
 
+    int groupCount(Object group) {
+        FutureSet members;
+        synchronized (this) {
+            members = inFlight.get(group);
+        }
+
+        if (members == null)
+            return 0;
+
+        return members.size();
+    }
+
+    private Runnable processDeferred = new Runnable() {
+        @Override
+        public void run() {
+            if (BitmapFetcher.shouldDeferImageView(Ion.this))
+                return;
+            ArrayList<DeferredLoadBitmap> deferred = null;
+            for (String key: bitmapsPending.keySet()) {
+                Object owner = bitmapsPending.tag(key);
+                if (owner instanceof DeferredLoadBitmap) {
+                    DeferredLoadBitmap deferredLoadBitmap = (DeferredLoadBitmap)owner;
+                    if (deferred == null)
+                        deferred = new ArrayList<DeferredLoadBitmap>();
+                    deferred.add(deferredLoadBitmap);
+                }
+            }
+
+            if (deferred == null)
+                return;
+            int count = 0;
+            for (DeferredLoadBitmap deferredLoadBitmap: deferred) {
+                bitmapsPending.tag(deferredLoadBitmap.key, null);
+                bitmapsPending.tag(deferredLoadBitmap.fetcher.bitmapKey, null);
+                deferredLoadBitmap.fetcher.execute();
+                count++;
+                // do MAX_IMAGEVIEW_LOAD max. this may end up going over the MAX_IMAGEVIEW_LOAD threshhold
+                if (count > BitmapFetcher.MAX_IMAGEVIEW_LOAD)
+                    return;
+            }
+        }
+    };
+
+    void processDeferred() {
+        mainHandler.removeCallbacks(processDeferred);
+        mainHandler.post(processDeferred);
+    }
+
     /**
      * Cancel all pending requests associated with the request group
      * @param group
@@ -318,16 +418,24 @@ private void addCookieMiddleware() {
      * Get or put an item from the cache
      * @return
      */
-    public DiskLruCacheStore cache() {
-        return new DiskLruCacheStore(this, responseCache.getDiskLruCache());
+    public FileCacheStore cache(String key) {
+        return new FileCacheStore(this, responseCache.getFileCache(), key);
+    }
+
+    public FileCache getCache() {
+        return responseCache.getFileCache();
     }
 
     /**
      * Get or put an item in the persistent store
      * @return
      */
-    public DiskLruCacheStore store() {
-        return new DiskLruCacheStore(this, responseCache.getDiskLruCache());
+    public FileCacheStore store(String key) {
+        return new FileCacheStore(this, storeCache, key);
+    }
+
+    public FileCache getStore() {
+        return storeCache;
     }
 
     public String getName() {
diff --git a/ion/src/com/koushikdutta/ion/IonBitmapRequestBuilder.java b/ion/src/com/koushikdutta/ion/IonBitmapRequestBuilder.java
index 49f0c1da..7b03ac48 100644
--- a/ion/src/com/koushikdutta/ion/IonBitmapRequestBuilder.java
+++ b/ion/src/com/koushikdutta/ion/IonBitmapRequestBuilder.java
@@ -1,37 +1,29 @@
 package com.koushikdutta.ion;
 
-import android.content.Context;
 import android.graphics.Bitmap;
 import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.os.Build;
 import android.os.Looper;
-import android.util.Pair;
 import android.view.animation.Animation;
 import android.view.animation.AnimationUtils;
 import android.widget.ImageView;
 
-import com.koushikdutta.async.AsyncServer;
-import com.koushikdutta.async.ByteBufferList;
 import com.koushikdutta.async.future.Future;
-import com.koushikdutta.async.future.FutureCallback;
 import com.koushikdutta.async.future.SimpleFuture;
-import com.koushikdutta.async.future.TransformFuture;
-import com.koushikdutta.async.http.ResponseCacheMiddleware;
-import com.koushikdutta.async.http.libcore.DiskLruCache;
-import com.koushikdutta.async.parser.ByteBufferListParser;
+import com.koushikdutta.async.util.FileCache;
 import com.koushikdutta.ion.bitmap.BitmapInfo;
 import com.koushikdutta.ion.bitmap.Transform;
 import com.koushikdutta.ion.builder.BitmapFutureBuilder;
 import com.koushikdutta.ion.builder.Builders;
-import com.koushikdutta.ion.builder.ImageViewBuilder;
 import com.koushikdutta.ion.builder.ImageViewFutureBuilder;
 
-import java.lang.ref.WeakReference;
 import java.util.ArrayList;
 
 /**
  * Created by koush on 5/23/13.
  */
-class IonBitmapRequestBuilder implements Builders.ImageView.F, ImageViewFutureBuilder, BitmapFutureBuilder, Builders.Any.BF {
+class IonBitmapRequestBuilder implements Builders.IV.F, ImageViewFutureBuilder, BitmapFutureBuilder, Builders.Any.BF {
     private static final SimpleFuture<ImageView> FUTURE_IMAGEVIEW_NULL_URI = new SimpleFuture<ImageView>() {
         {
             setComplete(new NullPointerException("uri"));
@@ -45,7 +37,7 @@
 
     IonRequestBuilder builder;
     Ion ion;
-    WeakReference<ImageView> imageViewPostRef;
+    ContextReference.ImageViewContextReference imageViewPostRef;
     ArrayList<Transform> transforms;
     Drawable placeholderDrawable;
     int placeholderResource;
@@ -60,7 +52,7 @@
     int resizeHeight;
     boolean disableFadeIn;
     boolean animateGif = true;
-
+    boolean deepZoom;
 
     void reset() {
         placeholderDrawable = null;
@@ -80,6 +72,7 @@ void reset() {
         disableFadeIn = false;
         animateGif = true;
         builder = null;
+        deepZoom = false;
     }
 
     public IonBitmapRequestBuilder(IonRequestBuilder builder) {
@@ -106,7 +99,7 @@ static void doAnimation(ImageView imageView, Animation animation, int animationR
 
     private IonRequestBuilder ensureBuilder() {
         if (builder == null)
-            builder = new IonRequestBuilder(imageViewPostRef.get().getContext(), ion);
+            builder = new IonRequestBuilder(ContextReference.fromContext(imageViewPostRef.getContext().getApplicationContext()), ion);
         return builder;
     }
 
@@ -125,52 +118,40 @@ private IonRequestBuilder ensureBuilder() {
     }
 
     IonBitmapRequestBuilder withImageView(ImageView imageView) {
-        imageViewPostRef = new WeakReference<ImageView>(imageView);
+        imageViewPostRef = new ContextReference.ImageViewContextReference(imageView);
         return this;
     }
 
     @Override
     public IonBitmapRequestBuilder transform(Transform transform) {
+        if (transform == null)
+            return this;
         if (transforms == null)
             transforms = new ArrayList<Transform>();
         transforms.add(transform);
         return this;
     }
 
-    boolean fastLoad(final String downloadKey, boolean put) {
-        for (Loader loader: ion.configure().getLoaders()) {
-            Future<BitmapInfo> future = loader.loadBitmap(ion, builder.uri, resizeWidth, resizeHeight);
-            if (future != null) {
-                final BitmapCallback callback = new BitmapCallback(ion, downloadKey, put);
-                future.setCallback(new FutureCallback<BitmapInfo>() {
-                    @Override
-                    public void onCompleted(Exception e, BitmapInfo result) {
-                        if (result != null)
-                            result.key = downloadKey;
-                        callback.report(e, result);
-                    }
-                });
-                return true;
-            }
-        }
-        return false;
-    }
-
     private String computeDownloadKey() {
         String downloadKey = builder.uri;
         // although a gif is always same download, the initial decode is different
         if (!animateGif)
             downloadKey += ":!animateGif";
-        return ResponseCacheMiddleware.toKeyString(downloadKey);
+        if (deepZoom)
+            downloadKey += ":deepZoom";
+        return FileCache.toKeyString(downloadKey);
     }
 
-    Pair<String, BitmapInfo> execute() {
+    @Override
+    public BitmapInfo asCachedBitmap() {
         final String downloadKey = computeDownloadKey();
         assert Thread.currentThread() == Looper.getMainLooper().getThread() || imageViewPostRef == null;
         assert downloadKey != null;
 
         if (resizeHeight > 0 || resizeWidth > 0) {
-            transform(new DefaultTransform(resizeWidth, resizeHeight, scaleMode));
+            if (transforms == null)
+                transforms = new ArrayList<Transform>();
+            transforms.add(0, new DefaultTransform(resizeWidth, resizeHeight, scaleMode));
         }
 
         // determine the key for this bitmap after all transformations
@@ -180,67 +161,66 @@ private String computeDownloadKey() {
             for (Transform transform : transforms) {
                 bitmapKey += transform.key();
             }
-            bitmapKey = ResponseCacheMiddleware.toKeyString(bitmapKey);
+            bitmapKey = FileCache.toKeyString(bitmapKey);
         }
 
-        // see if this request can be fulfilled from the cache
-        if (!builder.noCache) {
-            BitmapInfo bitmap = builder.ion.bitmapCache.get(bitmapKey);
-            if (bitmap != null)
-                return new Pair<String, BitmapInfo>(bitmapKey, bitmap);
-        }
+        return builder.ion.bitmapCache.get(bitmapKey);
+    }
 
-        Pair<String, BitmapInfo> ret = new Pair<String, BitmapInfo>(bitmapKey, null);
+    BitmapFetcher executeCache() {
+        final String downloadKey = computeDownloadKey();
+        assert Thread.currentThread() == Looper.getMainLooper().getThread() || imageViewPostRef == null;
+        assert downloadKey != null;
 
-        // bitmaps that were transformed are put into the DiskLruCache to prevent
-        // subsequent retransformation. See if we can retrieve the bitmap from the disk cache.
-        // See BitmapToBitmapInfo for where the cache is populated.
-        DiskLruCache diskLruCache = ion.responseCache.getDiskLruCache();
-        if (!builder.noCache && hasTransforms && diskLruCache.containsKey(bitmapKey)) {
-            BitmapToBitmapInfo.getBitmapSnapshot(ion, bitmapKey);
-            return ret;
+        if (resizeHeight > 0 || resizeWidth > 0) {
+            if (transforms == null)
+                transforms = new ArrayList<Transform>();
+            transforms.add(0, new DefaultTransform(resizeWidth, resizeHeight, scaleMode));
         }
 
-        // Perform a download as necessary.
-        if (!ion.bitmapsPending.contains(downloadKey) && !fastLoad(downloadKey, !hasTransforms)) {
-            builder.setHandler(null);
-            // if we cancel, gotta remove any waiters.
-            IonRequestBuilder.EmitterTransform<ByteBufferList> emitterTransform = builder.execute(new ByteBufferListParser(), new Runnable() {
-                @Override
-                public void run() {
-                    AsyncServer.post(Ion.mainHandler, new Runnable() {
-                        @Override
-                        public void run() {
-                            ion.bitmapsPending.remove(downloadKey);
-                        }
-                    });
-                }
-            });
-            emitterTransform.setCallback(new LoadBitmap(ion, downloadKey, !hasTransforms, resizeWidth, resizeHeight, animateGif, emitterTransform));
+        // determine the key for this bitmap after all transformations
+        String bitmapKey = downloadKey;
+        boolean hasTransforms = transforms != null && transforms.size() > 0;
+        if (hasTransforms) {
+            for (Transform transform : transforms) {
+                bitmapKey += transform.key();
+            }
+            bitmapKey = FileCache.toKeyString(bitmapKey);
         }
 
-        // if there's a transform, do it
-        if (!hasTransforms)
-            return ret;
+        // TODO: eliminate this allocation?
+        BitmapFetcher ret = new BitmapFetcher();
+        ret.downloadKey = downloadKey;
+        ret.bitmapKey = bitmapKey;
+        ret.hasTransforms = hasTransforms;
+        ret.resizeWidth = resizeWidth;
+        ret.resizeHeight = resizeHeight;
+        ret.builder = builder;
+        ret.transforms = transforms;
+        ret.animateGif = animateGif;
+        ret.deepZoom = deepZoom;
 
-        // verify this transform isn't already pending
-        // make sure that the parent download isn't cancelled (empty list)
-        // and also make sure there are waiters for this transformed bitmap
-        if (!ion.bitmapsPending.contains(downloadKey) || !ion.bitmapsPending.contains(bitmapKey)) {
-            ion.bitmapsPending.add(downloadKey, new BitmapToBitmapInfo(ion, bitmapKey, downloadKey, transforms));
+        // see if this request can be fulfilled from the cache
+        if (!builder.noCache) {
+            BitmapInfo bitmap = builder.ion.bitmapCache.get(bitmapKey);
+            if (bitmap != null) {
+                ret.info = bitmap;
+                return ret;
+            }
         }
 
         return ret;
     }
 
     private IonDrawable setIonDrawable(ImageView imageView, BitmapInfo info, int loadedFrom) {
-        IonDrawable ret = IonDrawable.getOrCreateIonDrawable(imageView);
-        ret.setBitmap(info, loadedFrom);
-        ret.setSize(resizeWidth, resizeHeight);
-        ret.setError(errorResource, errorDrawable);
-        ret.setPlaceholder(placeholderResource, placeholderDrawable);
-        ret.setInAnimation(inAnimation, inAnimationResource);
-        ret.setDisableFadeIn(disableFadeIn);
+        IonDrawable ret = IonDrawable.getOrCreateIonDrawable(imageView)
+        .ion(ion)
+        .setBitmap(info, loadedFrom)
+        .setSize(resizeWidth, resizeHeight)
+        .setError(errorResource, errorDrawable)
+        .setPlaceholder(placeholderResource, placeholderDrawable)
+        .setInAnimation(inAnimation, inAnimationResource)
+        .setDisableFadeIn(disableFadeIn);
         imageView.setImageDrawable(ret);
         return ret;
     }
@@ -251,53 +231,69 @@ private IonDrawable setIonDrawable(ImageView imageView, BitmapInfo info, int loa
             throw new IllegalArgumentException("imageView");
         assert Thread.currentThread() == Looper.getMainLooper().getThread();
 
+        if (builder.uri != null && builder.uri.startsWith("android.resource:/")) {
+            IonDrawable drawable = setIonDrawable(imageView, null, 0);
+            SimpleFuture<ImageView> imageViewFuture = drawable.getFuture();
+            imageViewFuture.reset();
+            imageView.setImageURI(Uri.parse(builder.uri));
+            imageViewFuture.setComplete(null, imageView);
+            return imageViewFuture;
+        }
+
         // no uri? just set a placeholder and bail
         if (builder.uri == null) {
             setIonDrawable(imageView, null, 0).cancel();
             return FUTURE_IMAGEVIEW_NULL_URI;
         }
 
-        // execute the request, see if we get a bitmap from cache.
-        Pair<String, BitmapInfo> pair = execute();
-        if (pair.second != null) {
+        // executeCache the request, see if we get a bitmap from cache.
+        BitmapFetcher bitmapFetcher = executeCache();
+        if (bitmapFetcher.info != null) {
             doAnimation(imageView, null, 0);
-            IonDrawable drawable = setIonDrawable(imageView, pair.second, Loader.LoaderEmitter.LOADED_FROM_MEMORY);
+            IonDrawable drawable = setIonDrawable(imageView, bitmapFetcher.info, Loader.LoaderEmitter.LOADED_FROM_MEMORY);
             drawable.cancel();
             SimpleFuture<ImageView> imageViewFuture = drawable.getFuture();
             imageViewFuture.reset();
-            imageViewFuture.setComplete(imageView);
+            imageViewFuture.setComplete(bitmapFetcher.info.exception, imageView);
             return imageViewFuture;
         }
 
+        // nothing from cache, check to see if there's too many imageview loads
+        // already in progress
+        if (BitmapFetcher.shouldDeferImageView(ion)) {
+            bitmapFetcher.defer();
+        }
+        else {
+            bitmapFetcher.execute();
+        }
+
         IonDrawable drawable = setIonDrawable(imageView, null, 0);
         doAnimation(imageView, loadAnimation, loadAnimationResource);
         SimpleFuture<ImageView> imageViewFuture = drawable.getFuture();
         imageViewFuture.reset();
-
-        drawable.register(ion, pair.first);
-
+        drawable.register(ion, bitmapFetcher.bitmapKey);
         return imageViewFuture;
     }
 
     @Override
     public Future<Bitmap> asBitmap() {
-        // no uri? just set a placeholder and bail
         if (builder.uri == null) {
             return FUTURE_BITMAP_NULL_URI;
         }
 
         // see if we get something back synchronously
-        Pair<String, BitmapInfo> pair = execute();
-        if (pair.second != null) {
+        BitmapFetcher bitmapFetcher = executeCache();
+        if (bitmapFetcher.info != null) {
             SimpleFuture<Bitmap> ret = new SimpleFuture<Bitmap>();
-            Bitmap bitmap = pair.second.bitmaps == null ? null : pair.second.bitmaps[0];
-            ret.setComplete(pair.second.exception, bitmap);
+            Bitmap bitmap = bitmapFetcher.info.bitmaps == null ? null : bitmapFetcher.info.bitmaps[0];
+            ret.setComplete(bitmapFetcher.info.exception, bitmap);
             return ret;
         }
 
+        bitmapFetcher.execute();
         // we're loading, so let's register for the result.
-        BitmapInfoToBitmap ret = new BitmapInfoToBitmap(builder.context);
-        ion.bitmapsPending.add(pair.first, ret);
+        BitmapInfoToBitmap ret = new BitmapInfoToBitmap(builder.contextReference);
+        ion.bitmapsPending.add(bitmapFetcher.bitmapKey, ret);
         return ret;
     }
 
@@ -351,6 +347,9 @@ public IonBitmapRequestBuilder animateIn(int animationResource) {
 
     @Override
     public IonBitmapRequestBuilder centerCrop() {
+        if (transforms != null && transforms.size() > 0)
+            throw new IllegalStateException("Can't apply centerCrop after transform has been called." +
+            "centerCrop is applied to the original resized bitmap.");
         if (resizeWidth <= 0 || resizeHeight <= 0)
             throw new IllegalStateException("must call resize first");
         scaleMode = ScaleMode.CenterCrop;
@@ -359,6 +358,9 @@ public IonBitmapRequestBuilder centerCrop() {
 
     @Override
     public IonBitmapRequestBuilder centerInside() {
+        if (transforms != null && transforms.size() > 0)
+            throw new IllegalStateException("Can't apply centerInside after transform has been called." +
+            "centerInside is applied to the original resized bitmap.");
         if (resizeWidth <= 0 || resizeHeight <= 0)
             throw new IllegalStateException("must call resize first");
         scaleMode = ScaleMode.CenterInside;
@@ -367,10 +369,14 @@ public IonBitmapRequestBuilder centerInside() {
 
     @Override
     public IonBitmapRequestBuilder resize(int width, int height) {
+        // TODO: prevent multiple calls to resize and friends?
+        if (transforms != null && transforms.size() > 0)
+            throw new IllegalStateException("Can't apply resize after transform has been called." +
+                "resize is applied to the original bitmap.");
+        if (deepZoom)
+            throw new IllegalStateException("Can not resize with deepZoom.");
         resizeWidth = width;
         resizeHeight = height;
-        ensureBuilder().setHeader("X-Ion-Width", String.valueOf(width));
-        ensureBuilder().setHeader("X-Ion-Height", String.valueOf(height));
         return this;
     }
 
@@ -383,7 +389,10 @@ public IonBitmapRequestBuilder disableFadeIn() {
 	public IonBitmapRequestBuilder smartSize(boolean smartSize) {
         //don't want to disable device resize if user has already resized the Bitmap.
         if (resizeWidth > 0 || resizeHeight > 0)
-            throw new IllegalStateException("Can't change smart size after resize has been called.");
+            throw new IllegalStateException("Can't set smart size after resize has been called.");
+
+        if (deepZoom)
+            throw new IllegalStateException("Can not smartSize with deepZoom.");
 
         if (!smartSize) {
 			resizeWidth = -1;
@@ -402,23 +411,17 @@ public IonBitmapRequestBuilder animateGif(boolean animateGif) {
         return this;
     }
 
-    private static class BitmapInfoToBitmap extends TransformFuture<Bitmap, BitmapInfo> {
-        WeakReference<Context> context;
-        public BitmapInfoToBitmap(WeakReference<Context> context) {
-            this.context = context;
-        }
-
-        @Override
-        protected void transform(BitmapInfo result) throws Exception {
-            if (!IonRequestBuilder.checkContext(context)) {
-                cancel();
-                return;
-            }
-
-            if (result.exception != null)
-                setComplete(result.exception);
-            else
-                setComplete(result.bitmaps[0]);
-        }
+    @Override
+    public IonBitmapRequestBuilder deepZoom() {
+        if (Build.VERSION.SDK_INT < 10)
+            return this;
+        this.deepZoom = true;
+        if (resizeWidth > 0 || resizeHeight > 0)
+            throw new IllegalStateException("Can't deepZoom with resize.");
+        if (transforms != null && transforms.size() > 0)
+            throw new IllegalStateException("Can't deepZoom with transforms.");
+        resizeWidth = 0;
+        resizeHeight = 0;
+        return this;
     }
 }
diff --git a/ion/src/com/koushikdutta/ion/IonDrawable.java b/ion/src/com/koushikdutta/ion/IonDrawable.java
index be573749..89965b54 100644
--- a/ion/src/com/koushikdutta/ion/IonDrawable.java
+++ b/ion/src/com/koushikdutta/ion/IonDrawable.java
@@ -6,6 +6,7 @@
 import android.graphics.ColorFilter;
 import android.graphics.Paint;
 import android.graphics.PixelFormat;
+import android.graphics.Rect;
 import android.graphics.drawable.Drawable;
 import android.os.Looper;
 import android.os.SystemClock;
@@ -15,6 +16,7 @@
 
 import com.koushikdutta.async.future.FutureCallback;
 import com.koushikdutta.async.future.SimpleFuture;
+import com.koushikdutta.async.util.FileCache;
 import com.koushikdutta.ion.bitmap.BitmapInfo;
 
 import java.lang.ref.WeakReference;
@@ -35,30 +37,38 @@
     private boolean disableFadeIn;
     private int resizeWidth;
     private int resizeHeight;
+    private Ion ion;
 
     public IonDrawable cancel() {
         requestCount++;
         return this;
     }
 
+    public IonDrawable ion(Ion ion) {
+        this.ion = ion;
+        return this;
+    }
+
     public SimpleFuture<ImageView> getFuture() {
         return callback.imageViewFuture;
     }
     
-    public void setDisableFadeIn(boolean disableFadeIn) {
+    public IonDrawable setDisableFadeIn(boolean disableFadeIn) {
         this.disableFadeIn = disableFadeIn;
+        return this;
     }
 
-    public void setInAnimation(Animation inAnimation, int inAnimationResource) {
+    public IonDrawable setInAnimation(Animation inAnimation, int inAnimationResource) {
         callback.inAnimation = inAnimation;
         callback.inAnimationResource = inAnimationResource;
+        return this;
     }
 
     // create an internal static class that can act as a callback.
     // dont let it hold strong references to anything.
     static class IonDrawableCallback implements FutureCallback<BitmapInfo> {
         private WeakReference<IonDrawable> ionDrawableRef;
-        private WeakReference<ImageView> imageViewRef;
+        private ContextReference.ImageViewContextReference imageViewRef;
         private String bitmapKey;
         private SimpleFuture<ImageView> imageViewFuture = new SimpleFuture<ImageView>();
         private Animation inAnimation;
@@ -67,14 +77,13 @@ public void setInAnimation(Animation inAnimation, int inAnimationResource) {
 
         public IonDrawableCallback(IonDrawable drawable, ImageView imageView) {
             ionDrawableRef = new WeakReference<IonDrawable>(drawable);
-            imageViewRef = new WeakReference<ImageView>(imageView);
+            imageViewRef = new ContextReference.ImageViewContextReference(imageView);
         }
 
         @Override
         public void onCompleted(Exception e, BitmapInfo result) {
             assert Thread.currentThread() == Looper.getMainLooper().getThread();
             assert result != null;
-
             // see if the imageview is still alive and cares about this result
             ImageView imageView = imageViewRef.get();
             if (imageView == null)
@@ -91,14 +100,13 @@ public void onCompleted(Exception e, BitmapInfo result) {
             if (drawable.requestCount != requestId)
                 return;
 
-            drawable.requestCount++;
             imageView.setImageDrawable(null);
             drawable.setBitmap(result, result.loadedFrom);
             imageView.setImageDrawable(drawable);
             IonBitmapRequestBuilder.doAnimation(imageView, inAnimation, inAnimationResource);
 
-            if (!IonRequestBuilder.checkContext(imageView.getContext())) {
-                imageViewFuture.cancel();
+            if (null != imageViewRef.isAlive()) {
+                imageViewFuture.cancelSilently();
                 return;
             }
 
@@ -117,11 +125,30 @@ public void register(Ion ion, String bitmapKey) {
         if (previousKey == null)
             return;
 
-        Object owner = ion.bitmapsPending.removeItem(previousKey, callback);
-        if (owner instanceof BitmapToBitmapInfo) {
-            BitmapToBitmapInfo info = (BitmapToBitmapInfo)owner;
-            ion.bitmapsPending.removeItem(info.downloadKey, info);
+        // unregister this drawable from the bitmaps that are
+        // pending.
+
+        // if this drawable was the only thing waiting for this bitmap,
+        // then the removeItem call will return the TransformBitmap/LoadBitmap instance
+        // that was providing the result.
+        if (ion.bitmapsPending.removeItem(previousKey, callback)) {
+            // find out who owns this thing, to see if it is a candidate for removal
+            Object owner = ion.bitmapsPending.tag(previousKey);
+            if (owner instanceof TransformBitmap) {
+                TransformBitmap info = (TransformBitmap)owner;
+                ion.bitmapsPending.remove(info.key);
+                // this transform is also backed by a LoadBitmap* or a DeferredLoadBitmap, grab that
+                // if it is the only waiter
+                if (ion.bitmapsPending.removeItem(info.downloadKey, info))
+                    owner = ion.bitmapsPending.tag(info.downloadKey);
+            }
+            if (owner instanceof DeferredLoadBitmap) {
+                DeferredLoadBitmap defer = (DeferredLoadBitmap)owner;
+                ion.bitmapsPending.remove(defer.key);
+            }
         }
+
+        ion.processDeferred();
     }
 
     private static final int DEFAULT_PAINT_FLAGS = Paint.FILTER_BITMAP_FLAG | Paint.DITHER_FLAG;
@@ -134,8 +161,11 @@ public IonDrawable(Resources resources, ImageView imageView) {
 
     int currentFrame;
     private boolean invalidateScheduled;
+    private int textureDim;
+    private int maxLevel;
     public IonDrawable setBitmap(BitmapInfo info, int loadedFrom) {
         this.loadedFrom = loadedFrom;
+        requestCount++;
 
         if (this.info == info)
             return this;
@@ -150,6 +180,23 @@ public IonDrawable setBitmap(BitmapInfo info, int loadedFrom) {
             return this;
         }
 
+        if (info.decoder != null) {
+            // find number of tiles across to fit
+            double wlevel = (double)info.originalSize.x / TILE_DIM;
+            double hlevel = (double)info.originalSize.y / TILE_DIM;
+
+            // find the level: find how many power of 2 tiles are necessary
+            // to fit the entire image. ie, fit it into a square.
+            double level = Math.max(wlevel, hlevel);
+            level = Math.log(level) / LOG_2;
+
+            maxLevel = (int)Math.ceil(level);
+
+            // now, we know the entire image will fit in a square image of
+            // this dimension:
+            textureDim = TILE_DIM << maxLevel;
+        }
+
         callback.bitmapKey = info.key;
         return this;
     }
@@ -206,8 +253,12 @@ private Drawable tryGetErrorResource() {
 
     @Override
     public int getIntrinsicWidth() {
-        if (info != null && info.bitmaps != null)
-            return info.bitmaps[0].getScaledWidth(resources.getDisplayMetrics().densityDpi);
+        if (info != null) {
+            if (info.decoder != null)
+                return info.originalSize.x;
+            if (info.bitmaps != null)
+                return info.bitmaps[0].getScaledWidth(resources.getDisplayMetrics().densityDpi);
+        }
         if (resizeWidth > 0)
             return resizeWidth;
         if (info != null) {
@@ -227,8 +278,12 @@ public int getIntrinsicWidth() {
 
     @Override
     public int getIntrinsicHeight() {
-        if (info != null && info.bitmaps != null)
-            return info.bitmaps[0].getScaledHeight(resources.getDisplayMetrics().densityDpi);
+        if (info != null) {
+            if (info.decoder != null)
+                return info.originalSize.y;
+            if (info.bitmaps != null)
+                return info.bitmaps[0].getScaledHeight(resources.getDisplayMetrics().densityDpi);
+        }
         if (resizeHeight > 0)
             return resizeHeight;
         if (info != null) {
@@ -260,6 +315,16 @@ public void run() {
         }
     };
 
+    private static final double LOG_2 = Math.log(2);
+    private static final int TILE_DIM = 256;
+
+    FutureCallback<BitmapInfo> tileCallback = new FutureCallback<BitmapInfo>() {
+        @Override
+        public void onCompleted(Exception e, BitmapInfo result) {
+            invalidateSelf();
+        }
+    };
+
     @Override
     public void draw(Canvas canvas) {
         if (info == null) {
@@ -291,7 +356,158 @@ public void draw(Canvas canvas) {
             }
         }
 
-        if (info.bitmaps != null) {
+        if (info.decoder != null) {
+            // zoom 0: entire image fits in a TILE_DIMxTILE_DIM square
+
+            // draw base bitmap for empty tiles
+            // figure out zoom level
+            // figure out which tiles need rendering
+            // draw stuff that needs drawing
+            // missing tile? fetch it
+            // use parent level tiles for tiles that do not exist
+
+            // TODO: crossfading?
+
+            Rect clip = canvas.getClipBounds();
+            Rect bounds = getBounds();
+
+            float zoom = (float)canvas.getWidth() / (float)clip.width();
+
+            float zoomWidth = zoom * bounds.width();
+            float zoomHeight = zoom * bounds.height();
+
+            double wlevel = Math.log(zoomWidth / TILE_DIM) / LOG_2;
+            double hlevel = Math.log(zoomHeight/ TILE_DIM) / LOG_2;
+            double maxLevel = Math.max(wlevel, hlevel);
+
+            int visibleLeft = Math.max(0, clip.left);
+            int visibleRight = Math.min(bounds.width(), clip.right);
+            int visibleTop = Math.max(0, clip.top);
+            int visibleBottom = Math.min(bounds.height(), clip.bottom);
+            int level = (int)Math.floor(maxLevel);
+            level = Math.min(this.maxLevel, level);
+            level = Math.max(level, 0);
+            int levelTiles = 1 << level;
+            int textureTileDim = textureDim / levelTiles;
+//            System.out.println("textureTileDim: " + textureTileDim);
+
+//            System.out.println(info.key + " visible: " + new Rect(visibleLeft, visibleTop, visibleRight, visibleBottom));
+
+            final boolean DEBUG_ZOOM = false;
+            if (info.bitmaps != null && info.bitmaps[0] != null) {
+                canvas.drawBitmap(info.bitmaps[0], null, getBounds(), paint);
+                if (DEBUG_ZOOM) {
+                    paint.setColor(Color.RED);
+                    paint.setAlpha(0x80);
+                    canvas.drawRect(getBounds(), paint);
+                    paint.setAlpha(0xFF);
+                }
+            }
+            else {
+                paint.setColor(Color.BLACK);
+                canvas.drawRect(getBounds(), paint);
+            }
+
+            int sampleSize = 1;
+            while (textureTileDim / sampleSize > TILE_DIM)
+                sampleSize <<= 1;
+
+            for (int y = 0; y < levelTiles; y++) {
+                int top = textureTileDim * y;
+                int bottom = textureTileDim * (y + 1);
+                bottom = Math.min(bottom, bounds.bottom);
+                // TODO: start at visible pos
+                if (bottom < visibleTop)
+                    continue;
+                if (top > visibleBottom)
+                    break;
+                for (int x = 0; x < levelTiles; x++) {
+                    int left = textureTileDim * x;
+                    int right = textureTileDim * (x + 1);
+                    right = Math.min(right, bounds.right);
+                    // TODO: start at visible pos
+                    if (right < visibleLeft)
+                        continue;
+                    if (left > visibleRight)
+                        break;
+
+                    Rect texRect = new Rect(left, top, right, bottom);
+
+                    // find, render/fetch
+//                    System.out.println("rendering: " + texRect + " for: " + bounds);
+                    String tileKey = FileCache.toKeyString(info.key, ",", level, ",", x, ",", y);
+                    BitmapInfo tile = ion.bitmapCache.get(tileKey);
+                    if (tile != null && tile.bitmaps != null) {
+                        // render it
+//                        System.out.println("bitmap is: " + tile.bitmaps[0].getWidth() + "x" + tile.bitmaps[0].getHeight());
+                        canvas.drawBitmap(tile.bitmaps[0], null, texRect, paint);
+                        continue;
+                    }
+
+                    // TODO: cancellation of unnecessary regions when fast pan/zooming
+                    if (ion.bitmapsPending.tag(tileKey) == null) {
+                        // fetch it
+//                        System.out.println(info.key + ": fetching region: " + texRect + " sample size: " + sampleSize);
+                        LoadBitmapRegion region = new LoadBitmapRegion(ion, tileKey, info.decoder, texRect, sampleSize);
+                    }
+                    ion.bitmapsPending.add(tileKey, tileCallback);
+
+                    int parentLeft = 0;
+                    int parentTop = 0;
+                    int parentUp = 1;
+                    int parentLevel = level - parentUp;
+                    if (x % 2 == 1)
+                        parentLeft++;
+                    if (y % 2 == 1)
+                        parentTop++;
+                    int parentX = x >> 1;
+                    int parentY = y >> 1;
+
+                    while (parentLevel >= 0) {
+                        tileKey = FileCache.toKeyString(info.key, ",", parentLevel, ",", parentX, ",", parentY);
+                        tile = ion.bitmapCache.get(tileKey);
+                        if (tile != null && tile.bitmaps != null)
+                            break;
+                        if (parentX % 2 == 1) {
+                            parentLeft += 1 << parentUp;
+                        }
+                        if (parentY % 2 == 1) {
+                            parentTop += 1 << parentUp;
+                        }
+                        parentLevel--;
+                        parentUp++;
+                        parentX >>= 1;
+                        parentY >>= 1;
+                    }
+
+                    // well, i give up
+                    if (tile == null || tile.bitmaps == null)
+                        continue;
+
+
+                    int subLevelTiles = 1 << parentLevel;
+                    int subtileDim = textureDim / subLevelTiles;
+                    int subSampleSize = 1;
+                    while (subtileDim / subSampleSize > TILE_DIM)
+                        subSampleSize <<= 1;
+                    int subTextureDim = subtileDim / subSampleSize;
+//                    System.out.println(String.format("falling back for %s,%s,%s to %s,%s,%s: %s,%s (%s to %s)", x, y, level, parentX, parentY, parentLevel, parentLeft, parentTop, subTextureDim, subTextureDim >> parentUp));
+                    subTextureDim >>= parentUp;
+                    int sourceLeft = subTextureDim * parentLeft;
+                    int sourceTop = subTextureDim * parentTop;
+                    Rect sourceRect = new Rect(sourceLeft, sourceTop, sourceLeft + subTextureDim, sourceTop + subTextureDim);
+                    canvas.drawBitmap(tile.bitmaps[0], sourceRect, texRect, paint);
+
+                    if (DEBUG_ZOOM) {
+                        paint.setColor(Color.RED);
+                        paint.setAlpha(0x80);
+                        canvas.drawRect(texRect, paint);
+                        paint.setAlpha(0xFF);
+                    }
+                }
+            }
+        }
+        else if (info.bitmaps != null) {
             paint.setAlpha((int)destAlpha);
             canvas.drawBitmap(info.bitmaps[currentFrame % info.bitmaps.length], null, getBounds(), paint);
             paint.setAlpha(0xFF);
@@ -368,13 +584,10 @@ public int getOpacity() {
     static IonDrawable getOrCreateIonDrawable(ImageView imageView) {
         Drawable current = imageView.getDrawable();
         IonDrawable ret;
-        if (current == null || !(current instanceof IonDrawable)) {
+        if (current == null || !(current instanceof IonDrawable))
             ret = new IonDrawable(imageView.getResources(), imageView);
-            imageView.setImageDrawable(ret);
-        }
-        else {
+        else
             ret = (IonDrawable)current;
-        }
         // invalidate self doesn't seem to trigger the dimension check to be called by imageview.
         // are drawable dimensions supposed to be immutable?
         imageView.setImageDrawable(null);
diff --git a/ion/src/com/koushikdutta/ion/IonRequestBuilder.java b/ion/src/com/koushikdutta/ion/IonRequestBuilder.java
index dbdf78fc..e100e901 100644
--- a/ion/src/com/koushikdutta/ion/IonRequestBuilder.java
+++ b/ion/src/com/koushikdutta/ion/IonRequestBuilder.java
@@ -1,15 +1,13 @@
 package com.koushikdutta.ion;
 
-import android.app.Activity;
-import android.app.ActivityManager;
 import android.app.ProgressDialog;
-import android.app.Service;
-import android.content.Context;
 import android.graphics.Bitmap;
 import android.net.Uri;
 import android.os.Handler;
 import android.os.Looper;
+import android.text.TextUtils;
 import android.util.Base64;
+import android.util.Log;
 import android.widget.ImageView;
 import android.widget.ProgressBar;
 
@@ -17,6 +15,7 @@
 import com.google.gson.JsonObject;
 import com.google.gson.reflect.TypeToken;
 import com.koushikdutta.async.AsyncServer;
+import com.koushikdutta.async.ByteBufferList;
 import com.koushikdutta.async.DataEmitter;
 import com.koushikdutta.async.DataSink;
 import com.koushikdutta.async.DataTrackingEmitter;
@@ -43,13 +42,16 @@
 import com.koushikdutta.async.http.libcore.RawHeaders;
 import com.koushikdutta.async.http.server.AsyncHttpServer;
 import com.koushikdutta.async.parser.AsyncParser;
+import com.koushikdutta.async.parser.ByteBufferListParser;
 import com.koushikdutta.async.parser.DocumentParser;
 import com.koushikdutta.async.parser.StringParser;
+import com.koushikdutta.async.stream.FileDataSink;
 import com.koushikdutta.async.stream.OutputStreamDataSink;
 import com.koushikdutta.ion.Loader.LoaderEmitter;
-import com.koushikdutta.ion.builder.LoadBuilder;
+import com.koushikdutta.ion.bitmap.BitmapInfo;
 import com.koushikdutta.ion.builder.Builders;
 import com.koushikdutta.ion.builder.FutureBuilder;
+import com.koushikdutta.ion.builder.LoadBuilder;
 import com.koushikdutta.ion.future.ResponseFuture;
 import com.koushikdutta.ion.gson.GsonBody;
 import com.koushikdutta.ion.gson.GsonParser;
@@ -59,8 +61,8 @@
 import org.apache.http.NameValuePair;
 import org.w3c.dom.Document;
 
+import java.io.ByteArrayInputStream;
 import java.io.File;
-import java.io.FileOutputStream;
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.lang.ref.WeakReference;
@@ -74,14 +76,17 @@
  */
 class IonRequestBuilder implements Builders.Any.B, Builders.Any.F, Builders.Any.M, Builders.Any.U, LoadBuilder<Builders.Any.B> {
     Ion ion;
-    WeakReference<Context> context;
+    ContextReference contextReference;
     Handler handler = Ion.mainHandler;
     String method = AsyncHttpGet.METHOD;
     String uri;
 
-    public IonRequestBuilder(Context context, Ion ion) {
+    public IonRequestBuilder(ContextReference contextReference, Ion ion) {
+        String alive = contextReference.isAlive();
+        if (null != alive)
+            Log.w("Ion", "Building request with dead context: " + alive);
         this.ion = ion;
-        this.context = new WeakReference<Context>(context);
+        this.contextReference = contextReference;
     }
 
     @Override
@@ -91,6 +96,8 @@ public IonRequestBuilder load(String url) {
 
     private IonRequestBuilder loadInternal(String method, String url) {
         this.method = method;
+        if (!TextUtils.isEmpty(url) && url.startsWith("/"))
+            url = new File(url).toURI().toString();
         this.uri = url;
         return this;
     }
@@ -113,18 +120,33 @@ private RawHeaders getHeaders() {
 
     @Override
     public IonRequestBuilder userAgent(String userAgent) {
+        if (TextUtils.isEmpty(userAgent))
+            return this;
         return setHeader("User-Agent", userAgent);
     }
 
     @Override
     public IonRequestBuilder setHeader(String name, String value) {
-        getHeaders().set(name, value);
+        if (value == null)
+            getHeaders().removeAll(name);
+        else
+            getHeaders().set(name, value);
         return this;
     }
 
     @Override
     public IonRequestBuilder addHeader(String name, String value) {
-        getHeaders().add(name, value);
+        if (value != null)
+            getHeaders().add(name, value);
+        return this;
+    }
+
+    @Override
+    public IonRequestBuilder addHeaders(Map<String, List<String>> params) {
+        RawHeaders headers = getHeaders();
+        for (Map.Entry<String, List<String>> entry: params.entrySet()) {
+            headers.addAll(entry.getKey(), entry.getValue());
+        }
         return this;
     }
 
@@ -138,6 +160,8 @@ public IonRequestBuilder addHeader(String name, String value) {
     Multimap query;
     @Override
     public IonRequestBuilder addQuery(String name, String value) {
+        if (value == null)
+            return this;
         if (query == null)
             query = new Multimap();
         query.add(name, value);
@@ -195,52 +219,15 @@ public IonRequestBuilder followRedirect(boolean follow) {
         return this;
     }
 
-    private static boolean isServiceRunning(Service candidate) {
-        ActivityManager manager = (ActivityManager)candidate.getSystemService(Context.ACTIVITY_SERVICE);
-        List<ActivityManager.RunningServiceInfo> services = manager.getRunningServices(Integer.MAX_VALUE);
-        if (services == null)
-            return false;
-        for (ActivityManager.RunningServiceInfo service: services) {
-            if (candidate.getClass().getName().equals(service.service.getClassName())) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    static boolean checkContext(WeakReference<Context> contextWeakReference) {
-        Context context = contextWeakReference.get();
-        if (context == null)
-            return false;
-        return checkContext(context);
-    }
-
-    static boolean checkContext(Context context) {
-        if (context instanceof Activity) {
-            Activity activity = (Activity)context;
-            if (activity.isFinishing())
-                return false;
-        }
-        else if (context instanceof Service) {
-            Service service = (Service)context;
-            if (!isServiceRunning(service))
-                return false;
-        }
-
-        return true;
-    }
-
-    private boolean checkContext() {
-        return checkContext(context);
-    }
-
     private <T> void postExecute(final EmitterTransform<T> future, final Exception ex, final T value) {
         final Runnable runner = new Runnable() {
             @Override
             public void run() {
                 // check if the context is still alive...
-                if (!checkContext()) {
-                    future.initialRequest.logd("context has died");
+                String deadReason = contextReference.isAlive();
+                if (deadReason != null) {
+                    future.initialRequest.logd("context has died: " + deadReason);
+                    future.cancelSilently();
                     return;
                 }
 
@@ -293,11 +280,16 @@ private AsyncHttpRequest prepareRequest(URI uri, AsyncHttpRequestBody wrappedBod
             request.setLogging(logTag, logLevel);
         request.enableProxy(proxyHost, proxyPort);
         request.setTimeout(timeoutMilliseconds);
-        request.setHandler(null);
         request.logd("preparing request");
         return request;
     }
 
+    static interface LoadRequestCallback {
+        boolean loadRequest(AsyncHttpRequest request);
+    }
+
+    LoadRequestCallback loadRequestCallback;
+
     private <T> void getLoaderEmitter(final EmitterTransform<T> ret) {
         URI uri = prepareURI();
         if (uri == null) {
@@ -339,7 +331,44 @@ public void run() {
 
         AsyncHttpRequest request = prepareRequest(uri, wrappedBody);
         ret.initialRequest = request;
+        resolveAndLoadRequest(request, ret);
+    }
+
+    <T> void resolveAndLoadRequest(final AsyncHttpRequest request, final EmitterTransform<T> ret) {
+        Future<AsyncHttpRequest> resolved = resolveRequest(request, ret);
+        if (resolved != null) {
+            resolved.setCallback(new FutureCallback<AsyncHttpRequest>() {
+                @Override
+                public void onCompleted(Exception e, final AsyncHttpRequest result) {
+                    if (e != null) {
+                        ret.setComplete(e);
+                        return;
+                    }
+                    ret.finalRequest = result;
+                    resolveAndLoadRequest(result, ret);
+                }
+            });
+            return;
+        }
+        if (Looper.getMainLooper().getThread() != Thread.currentThread()) {
+            AsyncServer.post(Ion.mainHandler, new Runnable() {
+                @Override
+                public void run() {
+                    invokeLoadRequest(request, ret);
+                }
+            });
+            return;
+        }
+        invokeLoadRequest(request, ret);
+    }
 
+    <T> void invokeLoadRequest(final AsyncHttpRequest request, final EmitterTransform<T> ret) {
+        if (loadRequestCallback == null || loadRequestCallback.loadRequest(request))
+            loadRequest(request, ret);
+    }
+
+    <T> void loadRequest(AsyncHttpRequest request, final EmitterTransform<T> ret) {
+        // now attempt to fetch it directly
         for (Loader loader: ion.loaders) {
             Future<DataEmitter> emitter = loader.load(ion, request, ret);
             if (emitter != null) {
@@ -351,6 +380,17 @@ public void run() {
         ret.setComplete(new Exception("Unknown uri scheme"));
     }
 
+    <T> Future<AsyncHttpRequest> resolveRequest(AsyncHttpRequest request, final EmitterTransform<T> ret) {
+        // first attempt to resolve the url
+        for (Loader loader: ion.loaders) {
+            Future<AsyncHttpRequest> resolved = loader.resolve(contextReference.getContext(), ion, request);
+            if (resolved != null)
+                return resolved;
+
+        }
+        return null;
+    }
+
     // transforms a LoaderEmitter, which is a DataEmitter and all associated properties about the data source
     // into the final result.
     class EmitterTransform<T> extends TransformFuture<T, LoaderEmitter> implements ResponseFuture<T> {
@@ -379,6 +419,7 @@ public void onCompleted(Exception e, T result) {
                     ret.setComplete(e, null);
                 }
             });
+            ret.setParent(this);
             return ret;
         }
 
@@ -388,7 +429,7 @@ public int loadedFrom() {
 
         public EmitterTransform(Runnable cancelCallback) {
             this.cancelCallback = cancelCallback;
-            ion.addFutureInFlight(this, context.get());
+            ion.addFutureInFlight(this, contextReference.getContext());
             if (groups == null)
                 return;
             for (WeakReference<Object> ref: groups) {
@@ -448,9 +489,10 @@ public void run() {
                 public void onData(final int totalBytesRead) {
                     assert Thread.currentThread() != Looper.getMainLooper().getThread();
                     // if the requesting context dies during the transfer... cancel
-                    if (!checkContext()) {
+                    String deadReason = contextReference.isAlive();
+                    if (deadReason != null) {
                         initialRequest.logd("context has died, cancelling");
-                        cancel();
+                        cancelSilently();
                         return;
                     }
 
@@ -605,6 +647,27 @@ public void onCompleted(Exception e, T result) {
         return execute(new StringParser());
     }
 
+    @Override
+    public ResponseFuture<byte[]> asByteArray() {
+        return execute(new AsyncParser<byte[]>() {
+            @Override
+            public Future<byte[]> parse(DataEmitter emitter) {
+                return new ByteBufferListParser().parse(emitter)
+                .then(new TransformFuture<byte[], ByteBufferList>() {
+                    @Override
+                    protected void transform(ByteBufferList result) throws Exception {
+                        setComplete(result.getAllByteArray());
+                    }
+                });
+            }
+
+            @Override
+            public void write(DataSink sink, byte[] value, CompletedCallback completed) {
+                new ByteBufferListParser().write(sink, new ByteBufferList(value), completed);
+            }
+        });
+    }
+
     @Override
     public ResponseFuture<InputStream> asInputStream() {
         return execute(new InputStreamParser());
@@ -626,20 +689,13 @@ public void onCompleted(Exception e, T result) {
     }
 
     @Override
-    public ResponseFuture<File> write(final File file) {
-        try {
-            return execute(new OutputStreamDataSink(ion.getServer(), new FileOutputStream(file)), true, file, new Runnable() {
-                @Override
-                public void run() {
-                    file.delete();
-                }
-            });
-        }
-        catch (Exception e) {
-            EmitterTransform<File> ret = new EmitterTransform<File>(null);
-            ret.setComplete(e);
-            return ret;
-        }
+    public EmitterTransform<File> write(final File file) {
+        return execute(new FileDataSink(ion.getServer(), file), true, file, new Runnable() {
+            @Override
+            public void run() {
+                file.delete();
+            }
+        });
     }
 
     Multimap bodyParameters;
@@ -649,7 +705,8 @@ public IonRequestBuilder setBodyParameter(String name, String value) {
             bodyParameters = new Multimap();
             setBody(new UrlEncodedFormBody(bodyParameters));
         }
-        bodyParameters.add(name, value);
+        if (value != null)
+            bodyParameters.add(name, value);
         return this;
     }
 
@@ -693,7 +750,8 @@ public IonRequestBuilder setMultipartParameter(String name, String value) {
             multipartBody = new MultipartFormDataBody();
             setBody(multipartBody);
         }
-        multipartBody.addStringPart(name, value);
+        if (value != null)
+            multipartBody.addStringPart(name, value);
         return this;
     }
 
@@ -701,7 +759,8 @@ public IonRequestBuilder setMultipartParameter(String name, String value) {
     public IonRequestBuilder setMultipartParameters(Map<String, List<String>> params) {
         for (String key: params.keySet()) {
             for (String value: params.get(key)) {
-                setMultipartParameter(key, value);
+                if (value != null)
+                    setMultipartParameter(key, value);
             }
         }
         return this;
@@ -712,10 +771,6 @@ public IonBitmapRequestBuilder withBitmap() {
         return new IonBitmapRequestBuilder(this);
     }
 
-    IonBitmapRequestBuilder withImageView(ImageView imageView) {
-        return new IonBitmapRequestBuilder(this).withImageView(imageView);
-    }
-
     @Override
     public Future<ImageView> intoImageView(ImageView imageView) {
         return new IonBitmapRequestBuilder(this).intoImageView(imageView);
@@ -727,6 +782,11 @@ public IonRequestBuilder load(File file) {
         return this;
     }
 
+    @Override
+    public BitmapInfo asCachedBitmap() {
+        return new IonBitmapRequestBuilder(this).asCachedBitmap();
+    }
+
     @Override
     public Future<Bitmap> asBitmap() {
         return new IonBitmapRequestBuilder(this).asBitmap();
@@ -838,6 +898,13 @@ public IonRequestBuilder basicAuthentication(String username, String password) {
         return this;
     }
 
+    @Override
+    public Builders.Any.F setByteArrayBody(byte[] bytes) {
+        if (bytes != null)
+            setBody(new StreamBody(new ByteArrayInputStream(bytes), bytes.length));
+        return this;
+    }
+
     @Override
     public Builders.Any.F setStreamBody(InputStream inputStream) {
         setBody(new StreamBody(inputStream, -1));
@@ -852,8 +919,9 @@ public IonRequestBuilder basicAuthentication(String username, String password) {
 
     @Override
     public Builders.Any.B setHeader(NameValuePair... header) {
+        RawHeaders headers = getHeaders();
         for (NameValuePair h: header) {
-            this.headers.set(h.getName(), h.getValue());
+            headers.set(h.getName(), h.getValue());
         }
         return this;
     }
diff --git a/ion/src/com/koushikdutta/ion/LoadBitmap.java b/ion/src/com/koushikdutta/ion/LoadBitmap.java
index 0133e85a..44c65bff 100644
--- a/ion/src/com/koushikdutta/ion/LoadBitmap.java
+++ b/ion/src/com/koushikdutta/ion/LoadBitmap.java
@@ -1,7 +1,10 @@
 package com.koushikdutta.ion;
 
 import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.Point;
 import android.os.Looper;
+import android.text.TextUtils;
 import android.util.Log;
 
 import com.koushikdutta.async.ByteBufferList;
@@ -15,33 +18,18 @@
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 
-class LoadBitmap extends BitmapCallback implements FutureCallback<ByteBufferList> {
+class LoadBitmap extends LoadBitmapEmitter implements FutureCallback<ByteBufferList> {
     int resizeWidth;
     int resizeHeight;
-    IonRequestBuilder.EmitterTransform<ByteBufferList> emitterTransform;
-    boolean animateGif;
 
     public LoadBitmap(Ion ion, String urlKey, boolean put, int resizeWidth, int resizeHeight, boolean animateGif, IonRequestBuilder.EmitterTransform<ByteBufferList> emitterTransform) {
-        super(ion, urlKey, put);
+        super(ion, urlKey, put, animateGif, emitterTransform);
         this.resizeWidth = resizeWidth;
         this.resizeHeight = resizeHeight;
         this.animateGif = animateGif;
         this.emitterTransform = emitterTransform;
     }
 
-    private boolean isGif() {
-        if (emitterTransform == null)
-            return false;
-        if (emitterTransform.finalRequest != null) {
-            URI uri = emitterTransform.finalRequest.getUri();
-            if (uri != null && uri.toString().endsWith(".gif"))
-                return true;
-        }
-        if (emitterTransform.headers == null)
-            return false;
-        return "image/gif".equals(emitterTransform.headers.get("Content-Type"));
-    }
-
     @Override
     public void onCompleted(Exception e, final ByteBufferList result) {
         if (e != null) {
@@ -50,7 +38,6 @@ public void onCompleted(Exception e, final ByteBufferList result) {
         }
 
         if (ion.bitmapsPending.tag(key) != this) {
-//            Log.d("IonBitmapLoader", "Bitmap load cancelled (no longer needed)");
             result.recycle();
             return;
         }
@@ -58,18 +45,20 @@ public void onCompleted(Exception e, final ByteBufferList result) {
         Ion.getBitmapLoadExecutorService().execute(new Runnable() {
             @Override
             public void run() {
+                if (ion.bitmapsPending.tag(key) != LoadBitmap.this) {
+                    result.recycle();
+                    return;
+                }
+
                 ByteBuffer bb = result.getAll();
                 try {
                     Bitmap[] bitmaps;
                     int[] delays;
-                    if (!isGif()) {
-                        Bitmap bitmap = ion.bitmapCache.loadBitmap(bb.array(), bb.arrayOffset() + bb.position(), bb.remaining(), resizeWidth, resizeHeight);
-                        if (bitmap == null)
-                            throw new Exception("failed to transform bitmap");
-                        bitmaps = new Bitmap[] { bitmap };
-                        delays = null;
-                    }
-                    else {
+                    BitmapFactory.Options options = ion.bitmapCache.prepareBitmapOptions(bb.array(), bb.arrayOffset() + bb.position(), bb.remaining(), resizeWidth, resizeHeight);
+                    if (options == null)
+                        throw new Exception("BitmapFactory.Options failed to load");
+                    final Point size = new Point(options.outWidth, options.outHeight);
+                    if (animateGif && TextUtils.equals("image/gif", options.outMimeType)) {
                         GifDecoder decoder = new GifDecoder(bb.array(), bb.arrayOffset() + bb.position(), bb.remaining(), new GifAction() {
                             @Override
                             public boolean parseOk(boolean parseStatus, int frameIndex) {
@@ -77,19 +66,26 @@ public boolean parseOk(boolean parseStatus, int frameIndex) {
                             }
                         });
                         decoder.run();
+                        if (decoder.getFrameCount() == 0)
+                            throw new Exception("failed to load gif");
                         bitmaps = new Bitmap[decoder.getFrameCount()];
                         delays = decoder.getDelays();
                         for (int i = 0; i < decoder.getFrameCount(); i++) {
                             Bitmap bitmap = decoder.getFrameImage(i);
                             if (bitmap == null)
-                                throw new Exception("failed to transform bitmap");
+                                throw new Exception("failed to load gif frame");
                             bitmaps[i] = bitmap;
                         }
                     }
+                    else {
+                        Bitmap bitmap = ion.bitmapCache.loadBitmap(bb.array(), bb.arrayOffset() + bb.position(), bb.remaining(), options);
+                        if (bitmap == null)
+                            throw new Exception("failed to load bitmap");
+                        bitmaps = new Bitmap[] { bitmap };
+                        delays = null;
+                    }
 
-                    BitmapInfo info = new BitmapInfo();
-                    info.key = key;
-                    info.bitmaps = bitmaps;
+                    BitmapInfo info = new BitmapInfo(key, options.outMimeType, bitmaps, size);
                     info.delays = delays;
                     if (emitterTransform != null)
                         info.loadedFrom = emitterTransform.loadedFrom();
diff --git a/ion/src/com/koushikdutta/ion/LoadBitmapBase.java b/ion/src/com/koushikdutta/ion/LoadBitmapBase.java
new file mode 100644
index 00000000..c6397157
--- /dev/null
+++ b/ion/src/com/koushikdutta/ion/LoadBitmapBase.java
@@ -0,0 +1,10 @@
+package com.koushikdutta.ion;
+
+/**
+ * Created by koush on 1/18/14.
+ */
+public class LoadBitmapBase extends BitmapCallback {
+    public LoadBitmapBase(Ion ion, String key, boolean put)  {
+        super(ion, key, put);
+    }
+}
diff --git a/ion/src/com/koushikdutta/ion/LoadBitmapEmitter.java b/ion/src/com/koushikdutta/ion/LoadBitmapEmitter.java
new file mode 100644
index 00000000..6f1888d9
--- /dev/null
+++ b/ion/src/com/koushikdutta/ion/LoadBitmapEmitter.java
@@ -0,0 +1,12 @@
+package com.koushikdutta.ion;
+
+class LoadBitmapEmitter extends LoadBitmapBase {
+    IonRequestBuilder.EmitterTransform emitterTransform;
+    boolean animateGif;
+
+    public LoadBitmapEmitter(Ion ion, String urlKey, boolean put, boolean animateGif, IonRequestBuilder.EmitterTransform emitterTransform) {
+        super(ion, urlKey, put);
+        this.animateGif = animateGif;
+        this.emitterTransform = emitterTransform;
+    }
+}
\ No newline at end of file
diff --git a/ion/src/com/koushikdutta/ion/LoadBitmapRegion.java b/ion/src/com/koushikdutta/ion/LoadBitmapRegion.java
new file mode 100644
index 00000000..81bf6734
--- /dev/null
+++ b/ion/src/com/koushikdutta/ion/LoadBitmapRegion.java
@@ -0,0 +1,33 @@
+package com.koushikdutta.ion;
+
+import android.graphics.Bitmap;
+import android.graphics.BitmapRegionDecoder;
+import android.graphics.Point;
+import android.graphics.Rect;
+
+import com.koushikdutta.ion.bitmap.BitmapInfo;
+
+/**
+ * Created by koush on 1/29/14.
+ */
+public class LoadBitmapRegion extends BitmapCallback {
+    public LoadBitmapRegion(final Ion ion, final String key, final BitmapRegionDecoder decoder, final Rect region, final int inSampleSize) {
+        super(ion, key, true);
+
+        Ion.getBitmapLoadExecutorService().execute(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    Bitmap bitmap = ion.bitmapCache.loadRegion(decoder, region, inSampleSize);
+                    if (bitmap == null)
+                        throw new Exception("failed to load bitmap region");
+                    BitmapInfo info = new BitmapInfo(key, null, new Bitmap[] { bitmap }, new Point(bitmap.getWidth(), bitmap.getHeight()));
+                    report(null, info);
+                }
+                catch (Exception e) {
+                    report(e, null);
+                }
+            }
+        });
+    }
+}
diff --git a/ion/src/com/koushikdutta/ion/LoadBitmapStream.java b/ion/src/com/koushikdutta/ion/LoadBitmapStream.java
deleted file mode 100644
index a8994e13..00000000
--- a/ion/src/com/koushikdutta/ion/LoadBitmapStream.java
+++ /dev/null
@@ -1,55 +0,0 @@
-package com.koushikdutta.ion;
-
-import android.graphics.Bitmap;
-
-import com.koushikdutta.async.future.Future;
-import com.koushikdutta.async.future.FutureCallback;
-import com.koushikdutta.ion.bitmap.BitmapInfo;
-
-import java.io.InputStream;
-
-class LoadBitmapStream extends BitmapCallback implements FutureCallback<InputStream> {
-    int resizeWidth;
-    int resizeHeight;
-
-    public LoadBitmapStream(Ion ion, String urlKey, boolean put, int resizeWidth, int resizeHeight) {
-        super(ion, urlKey, put);
-        this.resizeWidth = resizeWidth;
-        this.resizeHeight = resizeHeight;
-    }
-
-    public void loadInputStream(InputStream result) {
-        try {
-            Bitmap bitmap = ion.bitmapCache.loadBitmap(result, resizeWidth, resizeHeight);
-
-            if (bitmap == null)
-                throw new Exception("bitmap failed to load");
-
-            BitmapInfo info = new BitmapInfo();
-            info.key = key;
-            info.bitmaps = new Bitmap[] { bitmap };
-            info.loadedFrom = Loader.LoaderEmitter.LOADED_FROM_CACHE;
-
-            report(null, info);
-        } catch (Exception e) {
-            report(e, null);
-        }
-    }
-
-    @Override
-    public void onCompleted(Exception e, final InputStream result) {
-        if (e != null) {
-            report(e, null);
-            return;
-        }
-
-        Ion.getBitmapLoadExecutorService().execute(new Runnable() {
-            @Override
-            public void run() {
-                loadInputStream(result);
-            }
-        });
-    }
-}
-
-    
\ No newline at end of file
diff --git a/ion/src/com/koushikdutta/ion/LoadDeepZoom.java b/ion/src/com/koushikdutta/ion/LoadDeepZoom.java
new file mode 100644
index 00000000..4293d41e
--- /dev/null
+++ b/ion/src/com/koushikdutta/ion/LoadDeepZoom.java
@@ -0,0 +1,105 @@
+package com.koushikdutta.ion;
+
+import android.annotation.TargetApi;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.BitmapRegionDecoder;
+import android.graphics.Point;
+import android.graphics.Rect;
+import android.os.Build;
+import android.text.TextUtils;
+
+import com.koushikdutta.async.future.FutureCallback;
+import com.koushikdutta.async.util.FileCache;
+import com.koushikdutta.async.util.StreamUtility;
+import com.koushikdutta.ion.bitmap.BitmapInfo;
+import com.koushikdutta.ion.gif.GifAction;
+import com.koushikdutta.ion.gif.GifDecoder;
+
+import java.io.File;
+import java.io.FileInputStream;
+
+/**
+ * Created by koush on 1/5/14.
+ */
+@TargetApi(Build.VERSION_CODES.GINGERBREAD_MR1)
+public class LoadDeepZoom extends LoadBitmapEmitter implements FutureCallback<File> {
+    FileCache fileCache;
+    public LoadDeepZoom(Ion ion, String urlKey, boolean animateGif, IonRequestBuilder.EmitterTransform<File> emitterTransform, FileCache fileCache) {
+        super(ion, urlKey, true, animateGif, emitterTransform);
+        this.fileCache = fileCache;
+    }
+
+    @Override
+    public void onCompleted(Exception e, final File tempFile) {
+        if (e != null) {
+            report(e, null);
+            return;
+        }
+
+        if (ion.bitmapsPending.tag(key) != this) {
+//            Log.d("IonBitmapLoader", "Bitmap load cancelled (no longer needed)");
+            return;
+        }
+
+        Ion.getBitmapLoadExecutorService().execute(new Runnable() {
+            @Override
+            public void run() {
+                FileInputStream fin = null;
+                try {
+                    fileCache.commitTempFiles(key, tempFile);
+                    File file = fileCache.getFile(key);
+                    BitmapFactory.Options options = ion.getBitmapCache().prepareBitmapOptions(file, 0, 0);
+                    if (options == null)
+                        throw new Exception("BitmapFactory.Options failed to load");
+                    final Point size = new Point(options.outWidth, options.outHeight);
+                    if (animateGif && TextUtils.equals("image/gif", options.outMimeType)) {
+                        fin = fileCache.get(key);
+                        GifDecoder decoder = new GifDecoder(fin, new GifAction() {
+                            @Override
+                            public boolean parseOk(boolean parseStatus, int frameIndex) {
+                                return animateGif;
+                            }
+                        });
+                        decoder.run();
+                        if (decoder.getFrameCount() == 0)
+                            throw new Exception("failed to load gif");
+                        Bitmap[] bitmaps = new Bitmap[decoder.getFrameCount()];
+                        int[] delays = decoder.getDelays();
+                        for (int i = 0; i < decoder.getFrameCount(); i++) {
+                            Bitmap bitmap = decoder.getFrameImage(i);
+                            if (bitmap == null)
+                                throw new Exception("failed to load gif frame");
+                            bitmaps[i] = bitmap;
+                        }
+                        BitmapInfo info = new BitmapInfo(key, options.outMimeType, bitmaps, size);
+                        info.delays = delays;
+                        if (emitterTransform != null)
+                            info.loadedFrom = emitterTransform.loadedFrom();
+                        else
+                            info.loadedFrom = Loader.LoaderEmitter.LOADED_FROM_CACHE;
+                        report(null, info);
+                        return;
+                    }
+
+                    BitmapRegionDecoder decoder = BitmapRegionDecoder.newInstance(file.toString(), false);
+                    Bitmap bitmap = decoder.decodeRegion(new Rect(0, 0, size.x, size.y), options);
+                    if (bitmap == null)
+                        throw new Exception("unable to load decoder");
+                    Bitmap[] bitmaps = new Bitmap[] { bitmap };
+
+                    BitmapInfo info = new BitmapInfo(key, options.outMimeType, bitmaps, size);
+                    info.decoder = decoder;
+                    info.decoderFile = file;
+                    info.loadedFrom = Loader.LoaderEmitter.LOADED_FROM_NETWORK;
+                    report(null, info);
+                } catch (Exception e) {
+                    report(e, null);
+                }
+                finally {
+                    StreamUtility.closeQuietly(fin);
+                }
+            }
+        });
+    }
+}
diff --git a/ion/src/com/koushikdutta/ion/Loader.java b/ion/src/com/koushikdutta/ion/Loader.java
index 98da1c84..000aebb3 100644
--- a/ion/src/com/koushikdutta/ion/Loader.java
+++ b/ion/src/com/koushikdutta/ion/Loader.java
@@ -1,5 +1,7 @@
 package com.koushikdutta.ion;
 
+import android.content.Context;
+
 import com.koushikdutta.async.DataEmitter;
 import com.koushikdutta.async.future.Future;
 import com.koushikdutta.async.future.FutureCallback;
@@ -48,14 +50,43 @@ public AsyncHttpRequest getRequest() {
         }
     }
 
-    // returns a Future if this loader can handle a request as a stream.
-    // this implies that the stream is essentially non blocking...
-    // ie file or memory based.
+    /**
+     * returns a Future if this loader can handle a request as a stream.
+     * this implies that the stream is essentially non blocking...
+     * ie file or memory based.
+     * @param ion
+     * @param request
+     * @return
+     */
     public Future<InputStream> load(Ion ion, AsyncHttpRequest request);
 
-    // returns a Future if this loader can handle a request
-    // otherwise it returns null, and Ion continues to the next loader.
+    /**
+     * returns a Future if this loader can handle a request
+     * otherwise it returns null, and Ion continues to the next loader.
+     * @param ion
+     * @param request
+     * @param callback
+     * @return
+     */
     public Future<DataEmitter> load(Ion ion, AsyncHttpRequest request, FutureCallback<LoaderEmitter> callback);
 
-    public Future<BitmapInfo> loadBitmap(Ion ion, String uri, int resizeWidth, int resizeHeight);
+    /**
+     * returns a future if the laoder can handle the request as a bitmap
+     * otherwise it returns null
+     * @param ion
+     * @param key
+     * @param uri
+     * @param resizeWidth
+     * @param resizeHeight
+     * @return
+     */
+    public Future<BitmapInfo> loadBitmap(Context context, Ion ion, String key, String uri, int resizeWidth, int resizeHeight, boolean animateGif);
+
+    /**
+     * Resolve a request into another request.
+     * @param ion
+     * @param request
+     * @return
+     */
+    public Future<AsyncHttpRequest> resolve(Context context, Ion ion, AsyncHttpRequest request);
 }
diff --git a/ion/src/com/koushikdutta/ion/NetworkImageView.java b/ion/src/com/koushikdutta/ion/NetworkImageView.java
deleted file mode 100644
index bded8ba0..00000000
--- a/ion/src/com/koushikdutta/ion/NetworkImageView.java
+++ /dev/null
@@ -1,198 +0,0 @@
-/**
- * Copyright (C) 2013 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.koushikdutta.ion;
-
-import android.content.Context;
-import android.text.TextUtils;
-import android.util.AttributeSet;
-import android.widget.ImageView;
-
-import com.koushikdutta.async.future.Future;
-
-import java.lang.ref.WeakReference;
-
-/**
- * Handles fetching an image from a URL as well as the life-cycle of the
- * associated request.
- */
-public class NetworkImageView extends ImageView {
-    /** The URL of the network image to load */
-    private String mUrl;
-
-    /**
-     * Resource ID of the image to be used as a placeholder until the network image is loaded.
-     */
-    private int mDefaultImageId;
-
-    /**
-     * Resource ID of the image to be used if the network response fails.
-     */
-    private int mErrorImageId;
-
-    /** Local copy of the Ion. */
-    private Ion mIon;
-
-    /** Current Future<Bitmap. (either in-flight or finished) */
-    private WeakReference<Future<ImageView>> mFuture;
-
-    public NetworkImageView(Context context) {
-        this(context, null);
-    }
-
-    public NetworkImageView(Context context, AttributeSet attrs) {
-        this(context, attrs, 0);
-    }
-
-    public NetworkImageView(Context context, AttributeSet attrs, int defStyle) {
-        super(context, attrs, defStyle);
-    }
-
-    /**
-     * Sets URL of the image that should be loaded into this view. Note that calling this will
-     * immediately either set the cached image (if available) or the default image specified by
-     * {@link NetworkImageView#setDefaultImageResId(int)} on the view.
-     *
-     * NOTE: If applicable, {@link NetworkImageView#setDefaultImageResId(int)} and
-     * {@link NetworkImageView#setErrorImageResId(int)} should be called prior to calling
-     * this function.
-     *
-     * @param url The URL that should be loaded into this ImageView.
-     * @param ion ImageLoader that will be used to make the request.
-     */
-    public void setImageUrl(String url, Ion ion) {
-        mIon = ion;
-        // The URL has potentially changed. See if we need to load it.
-        loadImageIfNecessary(url);
-    }
-
-    /**
-     * Sets URL of the image that should be loaded into this view. Note that calling this will
-     * immediately either set the cached image (if available) or the default image specified by
-     * {@link NetworkImageView#setDefaultImageResId(int)} on the view.
-     *
-     * NOTE: If applicable, {@link NetworkImageView#setDefaultImageResId(int)} and
-     * {@link NetworkImageView#setErrorImageResId(int)} should be called prior to calling
-     * this function.
-     *
-     * @param url The URL that should be loaded into this ImageView.
-     */
-    public void setImageUrl(String url) {
-        mIon = Ion.getDefault(getContext());
-        // The URL has potentially changed. See if we need to load it.
-        loadImageIfNecessary(url);
-    }
-
-    /**
-     * Sets the default image resource ID to be used for this view until the attempt to load it
-     * completes.
-     */
-    public void setDefaultImageResId(int defaultImage) {
-        mDefaultImageId = defaultImage;
-    }
-
-    /**
-     * Sets the error image resource ID to be used for this view in the event that the image
-     * requested fails to load.
-     */
-    public void setErrorImageResId(int errorImage) {
-        mErrorImageId = errorImage;
-    }
-
-    /**
-     * Loads the image for the view if it isn't already loaded.
-     */
-    private void loadImageIfNecessary(String url) {
-        int width = getWidth();
-        int height = getHeight();
-
-        String oldUrl = mUrl;
-        mUrl = url;
-
-        // if the view's bounds aren't known yet, hold off on loading the image.
-        if (width == 0 && height == 0) {
-            return;
-        }
-
-        Future<ImageView> future;
-        if (mFuture == null)
-            future = null;
-        else
-            future = mFuture.get();
-
-        // if the URL to be loaded in this view is empty, cancel any old requests and recycle the
-        // currently loaded image.
-        if (TextUtils.isEmpty(mUrl)) {
-            if (future != null) {
-                future.cancel();
-                mFuture = null;
-            }
-            setImageBitmap(null);
-            return;
-        }
-
-        // if there was an old request in this view, check if it needs to be canceled.
-        if (future != null && oldUrl != null) {
-            if (oldUrl.equals(mUrl)) {
-                // if the request is from the same URL, return.
-                return;
-            } else {
-                // if there is a pre-existing request, cancel it if it's fetching a different URL.
-                future.cancel();
-                setImageBitmap(null);
-            }
-        }
-
-        // The pre-existing content of this view didn't match the current URL. Load the new image
-        // from the network.
-        future = mIon.build(this)
-            .placeholder(mDefaultImageId)
-            .error(mErrorImageId)
-            .load(mUrl);
-
-        mFuture = new WeakReference<Future<ImageView>>(future);
-    }
-
-    @Override
-    protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
-        super.onLayout(changed, left, top, right, bottom);
-        loadImageIfNecessary(mUrl);
-    }
-
-    @Override
-    protected void onDetachedFromWindow() {
-        Future<ImageView> future;
-        if (mFuture == null)
-            future = null;
-        else
-            future = mFuture.get();
-
-        if (future != null) {
-            // If the view was bound to an image request, cancel it and recycle
-            // out the image from the view.
-            future.cancel();
-            setImageBitmap(null);
-            // also recycle out the container so we can reload the image if necessary.
-            mFuture = null;
-        }
-        super.onDetachedFromWindow();
-    }
-
-    @Override
-    protected void drawableStateChanged() {
-        super.drawableStateChanged();
-        invalidate();
-    }
-}
diff --git a/ion/src/com/koushikdutta/ion/TransformBitmap.java b/ion/src/com/koushikdutta/ion/TransformBitmap.java
new file mode 100644
index 00000000..2f449f24
--- /dev/null
+++ b/ion/src/com/koushikdutta/ion/TransformBitmap.java
@@ -0,0 +1,134 @@
+package com.koushikdutta.ion;
+
+import android.graphics.Bitmap;
+import android.graphics.Point;
+
+import com.koushikdutta.async.future.FutureCallback;
+import com.koushikdutta.async.util.FileCache;
+import com.koushikdutta.ion.bitmap.BitmapInfo;
+import com.koushikdutta.ion.bitmap.Transform;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.util.ArrayList;
+
+class TransformBitmap extends BitmapCallback implements FutureCallback<BitmapInfo> {
+    ArrayList<Transform> transforms;
+
+    public static void getBitmapSnapshot(final Ion ion, final String transformKey) {
+        // don't do this if this is already loading
+        if (ion.bitmapsPending.tag(transformKey) != null)
+            return;
+        final BitmapCallback callback = new LoadBitmapBase(ion, transformKey, true);
+        Ion.getBitmapLoadExecutorService().execute(new Runnable() {
+            @Override
+            public void run() {
+                if (ion.bitmapsPending.tag(transformKey) != callback) {
+//                    Log.d("IonBitmapLoader", "Bitmap cache load cancelled (no longer needed)");
+                    return;
+                }
+
+                try {
+                    File file = ion.responseCache.getFileCache().getFile(transformKey);
+                    Bitmap bitmap = ion.getBitmapCache().loadBitmap(file, null);
+                    if (bitmap == null)
+                        throw new Exception("Bitmap failed to load");
+                    Point size = new Point(bitmap.getWidth(), bitmap.getHeight());
+                    BitmapInfo info = new BitmapInfo(transformKey, "image/jpeg", new Bitmap[] { bitmap }, size);
+                    info.loadedFrom =  Loader.LoaderEmitter.LOADED_FROM_CACHE;
+                    callback.report(null, info);
+                }
+                catch (OutOfMemoryError e) {
+                    callback.report(new Exception(e), null);
+                }
+                catch (Exception e) {
+                    callback.report(e, null);
+                    try {
+                        ion.responseCache.getFileCache().remove(transformKey);
+                    } catch (Exception ex) {
+                    }
+                }
+            }
+        });
+    }
+
+    String downloadKey;
+    public TransformBitmap(Ion ion, String transformKey, String downloadKey, ArrayList<Transform> transforms) {
+        super(ion, transformKey, true);
+        this.transforms = transforms;
+        this.downloadKey = downloadKey;
+    }
+
+    @Override
+    public void onCompleted(Exception e, final BitmapInfo result) {
+        if (e != null) {
+            report(e, null);
+            return;
+        }
+
+        if (ion.bitmapsPending.tag(key) != this) {
+//            Log.d("IonBitmapLoader", "Bitmap transform cancelled (no longer needed)");
+            return;
+        }
+
+        Ion.getBitmapLoadExecutorService().execute(new Runnable() {
+            @Override
+            public void run() {
+                if (ion.bitmapsPending.tag(key) != TransformBitmap.this) {
+//            Log.d("IonBitmapLoader", "Bitmap transform cancelled (no longer needed)");
+                    return;
+                }
+
+                BitmapInfo info;
+                try {
+                    Point size = null;
+                    Bitmap bitmaps[] = new Bitmap[result.bitmaps.length];
+                    for (int i = 0; i < result.bitmaps.length; i++) {
+                        bitmaps[i] = result.bitmaps[i];
+                        for (Transform transform : transforms) {
+                            Bitmap bitmap = transform.transform(bitmaps[i]);
+                            if (bitmap == null)
+                                throw new Exception("failed to transform bitmap");
+                            bitmaps[i] = bitmap;
+                            if (size == null)
+                                size = new Point(bitmap.getWidth(), bitmap.getHeight());
+                        }
+                    }
+                    info = new BitmapInfo(key, result.mimeType, bitmaps, size);
+                    info.delays = result.delays;
+                    info.loadedFrom = result.loadedFrom;
+                    report(null, info);
+                }
+                catch (OutOfMemoryError e) {
+                    report(new Exception(e), null);
+                    return;
+                }
+                catch (Exception e) {
+                    report(e, null);
+                    return;
+                }
+                // the transformed bitmap was successfully load it, let's toss it into
+                // the disk lru cache.
+                // but don't persist gifs...
+                if (info.bitmaps.length > 1)
+                    return;
+                FileCache cache = ion.responseCache.getFileCache();
+                if (cache == null)
+                    return;
+                File tempFile = cache.getTempFile();
+                try {
+                    FileOutputStream out = new FileOutputStream(tempFile);
+                    Bitmap.CompressFormat format = info.bitmaps[0].hasAlpha() ? Bitmap.CompressFormat.PNG : Bitmap.CompressFormat.JPEG;
+                    info.bitmaps[0].compress(format, 100, out);
+                    out.close();
+                    cache.commitTempFiles(key, tempFile);
+                }
+                catch (Exception ex) {
+                }
+                finally {
+                    tempFile.delete();
+                }
+            }
+        });
+    }
+}
\ No newline at end of file
diff --git a/ion/src/com/koushikdutta/ion/bitmap/BitmapInfo.java b/ion/src/com/koushikdutta/ion/bitmap/BitmapInfo.java
index c0eb8ac4..3db88e4c 100644
--- a/ion/src/com/koushikdutta/ion/bitmap/BitmapInfo.java
+++ b/ion/src/com/koushikdutta/ion/bitmap/BitmapInfo.java
@@ -1,20 +1,34 @@
 package com.koushikdutta.ion.bitmap;
 
 import android.graphics.Bitmap;
+import android.graphics.BitmapRegionDecoder;
+import android.graphics.Point;
 
+import java.io.File;
 import java.lang.ref.WeakReference;
 
 /**
  * Created by koush on 6/12/13.
  */
 public class BitmapInfo {
+    public BitmapInfo(String key, String mimeType, Bitmap[] bitmaps, Point originalSize) {
+        this.originalSize = originalSize;
+        this.bitmaps = bitmaps;
+        this.key = key;
+        this.mimeType = mimeType;
+    }
+
+    final public Point originalSize;
     public long loadTime = System.currentTimeMillis();
     public long drawTime;
-    public String key;
+    final public String key;
     public int loadedFrom;
-    public Bitmap[] bitmaps;
+    final public Bitmap[] bitmaps;
     public int[] delays;
     public Exception exception;
+    public BitmapRegionDecoder decoder;
+    public File decoderFile;
+    public final String mimeType;
 
     public int sizeOf() {
         if (bitmaps == null)
diff --git a/ion/src/com/koushikdutta/ion/bitmap/GifBitmapInfo.java b/ion/src/com/koushikdutta/ion/bitmap/GifBitmapInfo.java
deleted file mode 100644
index deac6343..00000000
--- a/ion/src/com/koushikdutta/ion/bitmap/GifBitmapInfo.java
+++ /dev/null
@@ -1,10 +0,0 @@
-package com.koushikdutta.ion.bitmap;
-
-import android.graphics.Bitmap;
-
-/**
- * Created by koush on 10/21/13.
- */
-public class GifBitmapInfo extends BitmapInfo {
-
-}
diff --git a/ion/src/com/koushikdutta/ion/bitmap/IonBitmapCache.java b/ion/src/com/koushikdutta/ion/bitmap/IonBitmapCache.java
index b2035f4d..b9dfec29 100644
--- a/ion/src/com/koushikdutta/ion/bitmap/IonBitmapCache.java
+++ b/ion/src/com/koushikdutta/ion/bitmap/IonBitmapCache.java
@@ -1,22 +1,27 @@
 package com.koushikdutta.ion.bitmap;
 
+import android.annotation.TargetApi;
 import android.app.ActivityManager;
 import android.content.Context;
 import android.content.res.AssetManager;
 import android.content.res.Resources;
 import android.graphics.Bitmap;
 import android.graphics.BitmapFactory;
+import android.graphics.BitmapRegionDecoder;
 import android.graphics.Matrix;
 import android.graphics.Point;
+import android.graphics.Rect;
+import android.os.Build;
 import android.os.Looper;
 import android.util.DisplayMetrics;
 import android.util.Log;
 import android.view.WindowManager;
 
+import com.koushikdutta.async.util.StreamUtility;
 import com.koushikdutta.ion.Ion;
 
-import java.io.BufferedInputStream;
-import java.io.InputStream;
+import java.io.File;
+import java.io.FileInputStream;
 
 /**
  * Created by koush on 5/23/13.
@@ -112,21 +117,35 @@ private Point computeTarget(int minx, int miny) {
         return new Point(targetWidth, targetHeight);
     }
 
-    public Bitmap loadBitmap(byte[] bytes, int offset, int length, int minx, int miny) {
-        assert Thread.currentThread() != Looper.getMainLooper().getThread();
+    public BitmapFactory.Options prepareBitmapOptions(File file, int minx, int miny) {
+        BitmapFactory.Options o = new BitmapFactory.Options();
+        o.inJustDecodeBounds = true;
+        BitmapFactory.decodeFile(file.toString(), o);
+        return prepareBitmapOptions(o, minx, miny);
+    }
+
+    private BitmapFactory.Options prepareBitmapOptions(BitmapFactory.Options o, int minx, int miny) {
+        if (o.outWidth < 0 || o.outHeight < 0)
+            return null;
         Point target = computeTarget(minx, miny);
+        int scale = Math.max(o.outWidth / target.x, o.outHeight / target.y);
+        BitmapFactory.Options ret = new BitmapFactory.Options();
+        ret.inSampleSize = scale;
+        ret.outWidth = o.outWidth;
+        ret.outHeight = o.outHeight;
+        ret.outMimeType = o.outMimeType;
+        return ret;
+    }
 
-        BitmapFactory.Options o = null;
-        if (target.x != Integer.MAX_VALUE || target.y != Integer.MAX_VALUE) {
-            o = new BitmapFactory.Options();
-            o.inJustDecodeBounds = true;
-            BitmapFactory.decodeByteArray(bytes, offset, length, o);
-            if (o.outWidth < 0 || o.outHeight < 0)
-                return null;
-            int scale = Math.max(o.outWidth / target.x, o.outHeight / target.y);
-            o = new BitmapFactory.Options();
-            o.inSampleSize = scale;
-        }
+    public BitmapFactory.Options prepareBitmapOptions(byte[] bytes, int offset, int length, int minx, int miny) {
+        BitmapFactory.Options o = new BitmapFactory.Options();
+        o.inJustDecodeBounds = true;
+        BitmapFactory.decodeByteArray(bytes, offset, length, o);
+        return prepareBitmapOptions(o, minx, miny);
+    }
+
+    public Bitmap loadBitmap(byte[] bytes, int offset, int length, BitmapFactory.Options o) {
+        assert Thread.currentThread() != Looper.getMainLooper().getThread();
 
         Bitmap bitmap = BitmapFactory.decodeByteArray(bytes, offset, length, o);
         if (bitmap == null)
@@ -141,43 +160,31 @@ public Bitmap loadBitmap(byte[] bytes, int offset, int length, int minx, int min
         return Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(), bitmap.getHeight(), matrix, true);
     }
 
-    public Bitmap loadBitmap(InputStream stream, int minx, int miny) {
-        stream = new BufferedInputStream(stream, 64 * 1024);
+    @TargetApi(Build.VERSION_CODES.GINGERBREAD_MR1)
+    public Bitmap loadRegion(final BitmapRegionDecoder decoder, Rect sourceRect, int inSampleSize) {
+        BitmapFactory.Options options = new BitmapFactory.Options();
+        options.inSampleSize = inSampleSize;
+        return decoder.decodeRegion(sourceRect, options);
+    }
+
+    public Bitmap loadBitmap(File file, BitmapFactory.Options o) {
+//        stream = new BufferedInputStream(stream, 64 * 1024);
         assert Thread.currentThread() != Looper.getMainLooper().getThread();
-        Point target = computeTarget(minx, miny);
 
         int rotation;
+        FileInputStream fin = null;
         try {
+            fin = new FileInputStream(file);
             byte[] bytes = new byte[50000];
-            stream.mark(Integer.MAX_VALUE);
-            int length = stream.read(bytes);
+            int length = fin.read(bytes);
             rotation = Exif.getOrientation(bytes, 0, length);
-            stream.reset();
         }
         catch (Exception e) {
             rotation = 0;
         }
+        StreamUtility.closeQuietly(fin);
 
-        BitmapFactory.Options o = null;
-        if (target.x != Integer.MAX_VALUE || target.y != Integer.MAX_VALUE) {
-            o = new BitmapFactory.Options();
-            o.inJustDecodeBounds = true;
-            stream.mark(Integer.MAX_VALUE);
-            BitmapFactory.decodeStream(stream, null, o);
-            if (o.outWidth < 0 || o.outHeight < 0)
-                return null;
-            try {
-                stream.reset();
-            }
-            catch (Exception e) {
-                return null;
-            }
-            int scale = Math.max(o.outWidth / target.x, o.outHeight / target.y);
-            o = new BitmapFactory.Options();
-            o.inSampleSize = scale;
-        }
-
-        Bitmap bitmap = BitmapFactory.decodeStream(stream, null, o);
+        Bitmap bitmap = BitmapFactory.decodeFile(file.toString(), o);
         if (bitmap == null)
             return null;
 
diff --git a/ion/src/com/koushikdutta/ion/bitmap/LruBitmapCache.java b/ion/src/com/koushikdutta/ion/bitmap/LruBitmapCache.java
index 8213e32c..4893da3e 100644
--- a/ion/src/com/koushikdutta/ion/bitmap/LruBitmapCache.java
+++ b/ion/src/com/koushikdutta/ion/bitmap/LruBitmapCache.java
@@ -1,5 +1,7 @@
 package com.koushikdutta.ion.bitmap;
 
+import com.koushikdutta.async.util.LruCache;
+
 class LruBitmapCache extends LruCache<String, BitmapInfo> {
     private SoftReferenceHashtable<String, BitmapInfo> soft = new SoftReferenceHashtable<String, BitmapInfo>();
 
@@ -8,7 +10,7 @@ public LruBitmapCache(int maxSize) {
     }
 
     @Override
-    protected int sizeOf(String key, BitmapInfo info) {
+    protected long sizeOf(String key, BitmapInfo info) {
         return info.sizeOf();
     }
 
diff --git a/ion/src/com/koushikdutta/ion/bitmap/LruCache.java b/ion/src/com/koushikdutta/ion/bitmap/LruCache.java
deleted file mode 100644
index 12bfec53..00000000
--- a/ion/src/com/koushikdutta/ion/bitmap/LruCache.java
+++ /dev/null
@@ -1,327 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.koushikdutta.ion.bitmap;
-
-import java.util.LinkedHashMap;
-import java.util.Map;
-
-/**
- * Static library version of {@link android.util.LruCache}. Used to write apps
- * that run on API levels prior to 12. When running on API level 12 or above,
- * this implementation is still used; it does not try to switch to the
- * framework's implementation. See the framework SDK documentation for a class
- * overview.
- */
-class LruCache<K, V> {
-    private final LinkedHashMap<K, V> map;
-
-    /** Size of this cache in units. Not necessarily the number of elements. */
-    private int size;
-    private int maxSize;
-
-    private int putCount;
-    private int createCount;
-    private int evictionCount;
-    private int hitCount;
-    private int missCount;
-
-    /**
-     * @param maxSize for caches that do not override {@link #sizeOf}, this is
-     *     the maximum number of entries in the cache. For all other caches,
-     *     this is the maximum sum of the sizes of the entries in this cache.
-     */
-    public LruCache(int maxSize) {
-        if (maxSize <= 0) {
-            throw new IllegalArgumentException("maxSize <= 0");
-        }
-        this.maxSize = maxSize;
-        this.map = new LinkedHashMap<K, V>(0, 0.75f, true);
-    }
-
-    /**
-     * Returns the value for {@code key} if it exists in the cache or can be
-     * created by {@code #create}. If a value was returned, it is moved to the
-     * head of the queue. This returns null if a value is not cached and cannot
-     * be created.
-     */
-    public final V get(K key) {
-        if (key == null) {
-            throw new NullPointerException("key == null");
-        }
-
-        V mapValue;
-        synchronized (this) {
-            mapValue = map.get(key);
-            if (mapValue != null) {
-                hitCount++;
-                return mapValue;
-            }
-            missCount++;
-        }
-
-        /*
-         * Attempt to create a value. This may take a long time, and the map
-         * may be different when create() returns. If a conflicting value was
-         * added to the map while create() was working, we leave that value in
-         * the map and release the created value.
-         */
-
-        V createdValue = create(key);
-        if (createdValue == null) {
-            return null;
-        }
-
-        synchronized (this) {
-            createCount++;
-            mapValue = map.put(key, createdValue);
-
-            if (mapValue != null) {
-                // There was a conflict so undo that last put
-                map.put(key, mapValue);
-            } else {
-                size += safeSizeOf(key, createdValue);
-            }
-        }
-
-        if (mapValue != null) {
-            entryRemoved(false, key, createdValue, mapValue);
-            return mapValue;
-        } else {
-            trimToSize(maxSize);
-            return createdValue;
-        }
-    }
-
-    /**
-     * Caches {@code value} for {@code key}. The value is moved to the head of
-     * the queue.
-     *
-     * @return the previous value mapped by {@code key}.
-     */
-    public final V put(K key, V value) {
-        if (key == null || value == null) {
-            throw new NullPointerException("key == null || value == null");
-        }
-
-        V previous;
-        synchronized (this) {
-            putCount++;
-            size += safeSizeOf(key, value);
-            previous = map.put(key, value);
-            if (previous != null) {
-                size -= safeSizeOf(key, previous);
-            }
-        }
-
-        if (previous != null) {
-            entryRemoved(false, key, previous, value);
-        }
-
-        trimToSize(maxSize);
-        return previous;
-    }
-
-    /**
-     * @param maxSize the maximum size of the cache before returning. May be -1
-     *     to evict even 0-sized elements.
-     */
-    private void trimToSize(int maxSize) {
-        while (true) {
-            K key;
-            V value;
-            synchronized (this) {
-                if (size < 0 || (map.isEmpty() && size != 0)) {
-                    throw new IllegalStateException(getClass().getName()
-                            + ".sizeOf() is reporting inconsistent results!");
-                }
-
-                if (size <= maxSize || map.isEmpty()) {
-                    break;
-                }
-
-                Map.Entry<K, V> toEvict = map.entrySet().iterator().next();
-                key = toEvict.getKey();
-                value = toEvict.getValue();
-                map.remove(key);
-                size -= safeSizeOf(key, value);
-                evictionCount++;
-            }
-
-            entryRemoved(true, key, value, null);
-        }
-    }
-
-    /**
-     * Removes the entry for {@code key} if it exists.
-     *
-     * @return the previous value mapped by {@code key}.
-     */
-    public final V remove(K key) {
-        if (key == null) {
-            throw new NullPointerException("key == null");
-        }
-
-        V previous;
-        synchronized (this) {
-            previous = map.remove(key);
-            if (previous != null) {
-                size -= safeSizeOf(key, previous);
-            }
-        }
-
-        if (previous != null) {
-            entryRemoved(false, key, previous, null);
-        }
-
-        return previous;
-    }
-
-    /**
-     * Called for entries that have been evicted or removed. This method is
-     * invoked when a value is evicted to make space, removed by a call to
-     * {@link #remove}, or replaced by a call to {@link #put}. The default
-     * implementation does nothing.
-     *
-     * <p>The method is called without synchronization: other threads may
-     * access the cache while this method is executing.
-     *
-     * @param evicted true if the entry is being removed to make space, false
-     *     if the removal was caused by a {@link #put} or {@link #remove}.
-     * @param newValue the new value for {@code key}, if it exists. If non-null,
-     *     this removal was caused by a {@link #put}. Otherwise it was caused by
-     *     an eviction or a {@link #remove}.
-     */
-    protected void entryRemoved(boolean evicted, K key, V oldValue, V newValue) {}
-
-    /**
-     * Called after a cache miss to compute a value for the corresponding key.
-     * Returns the computed value or null if no value can be computed. The
-     * default implementation returns null.
-     *
-     * <p>The method is called without synchronization: other threads may
-     * access the cache while this method is executing.
-     *
-     * <p>If a value for {@code key} exists in the cache when this method
-     * returns, the created value will be released with {@link #entryRemoved}
-     * and discarded. This can occur when multiple threads request the same key
-     * at the same time (causing multiple values to be created), or when one
-     * thread calls {@link #put} while another is creating a value for the same
-     * key.
-     */
-    protected V create(K key) {
-        return null;
-    }
-
-    private int safeSizeOf(K key, V value) {
-        int result = sizeOf(key, value);
-        if (result < 0) {
-            throw new IllegalStateException("Negative size: " + key + "=" + value);
-        }
-        return result;
-    }
-
-    /**
-     * Returns the size of the entry for {@code key} and {@code value} in
-     * user-defined units.  The default implementation returns 1 so that size
-     * is the number of entries and max size is the maximum number of entries.
-     *
-     * <p>An entry's size must not change while it is in the cache.
-     */
-    protected int sizeOf(K key, V value) {
-        return 1;
-    }
-
-    /**
-     * Clear the cache, calling {@link #entryRemoved} on each removed entry.
-     */
-    public final void evictAll() {
-        trimToSize(-1); // -1 will evict 0-sized elements
-    }
-
-    /**
-     * For caches that do not override {@link #sizeOf}, this returns the number
-     * of entries in the cache. For all other caches, this returns the sum of
-     * the sizes of the entries in this cache.
-     */
-    public synchronized final int size() {
-        return size;
-    }
-
-    public void setMaxSize(int maxSize) {
-        this.maxSize = maxSize;
-    }
-
-    /**
-     * For caches that do not override {@link #sizeOf}, this returns the maximum
-     * number of entries in the cache. For all other caches, this returns the
-     * maximum sum of the sizes of the entries in this cache.
-     */
-    public synchronized final int maxSize() {
-        return maxSize;
-    }
-
-    /**
-     * Returns the number of times {@link #get} returned a value.
-     */
-    public synchronized final int hitCount() {
-        return hitCount;
-    }
-
-    /**
-     * Returns the number of times {@link #get} returned null or required a new
-     * value to be created.
-     */
-    public synchronized final int missCount() {
-        return missCount;
-    }
-
-    /**
-     * Returns the number of times {@link #create(Object)} returned a value.
-     */
-    public synchronized final int createCount() {
-        return createCount;
-    }
-
-    /**
-     * Returns the number of times {@link #put} was called.
-     */
-    public synchronized final int putCount() {
-        return putCount;
-    }
-
-    /**
-     * Returns the number of values that have been evicted.
-     */
-    public synchronized final int evictionCount() {
-        return evictionCount;
-    }
-
-    /**
-     * Returns a copy of the current contents of the cache, ordered from least
-     * recently accessed to most recently accessed.
-     */
-    public synchronized final Map<K, V> snapshot() {
-        return new LinkedHashMap<K, V>(map);
-    }
-
-    @Override public synchronized final String toString() {
-        int accesses = hitCount + missCount;
-        int hitPercent = accesses != 0 ? (100 * hitCount / accesses) : 0;
-        return String.format("LruCache[maxSize=%d,hits=%d,misses=%d,hitRate=%d%%]",
-                maxSize, hitCount, missCount, hitPercent);
-    }
-}
diff --git a/ion/src/com/koushikdutta/ion/builder/BitmapFutureBuilder.java b/ion/src/com/koushikdutta/ion/builder/BitmapFutureBuilder.java
index c20cfda5..14f36e3f 100644
--- a/ion/src/com/koushikdutta/ion/builder/BitmapFutureBuilder.java
+++ b/ion/src/com/koushikdutta/ion/builder/BitmapFutureBuilder.java
@@ -3,6 +3,7 @@
 import android.graphics.Bitmap;
 
 import com.koushikdutta.async.future.Future;
+import com.koushikdutta.ion.bitmap.BitmapInfo;
 
 /**
 * Created by koush on 5/30/13.
@@ -13,4 +14,10 @@
      * @return
      */
     public Future<Bitmap> asBitmap();
+
+    /**
+     * Attempt to immediately retrieve the cached Bitmap info
+     * @return
+     */
+    public BitmapInfo asCachedBitmap();
 }
diff --git a/ion/src/com/koushikdutta/ion/builder/Builders.java b/ion/src/com/koushikdutta/ion/builder/Builders.java
index 9c1592af..7675a2de 100644
--- a/ion/src/com/koushikdutta/ion/builder/Builders.java
+++ b/ion/src/com/koushikdutta/ion/builder/Builders.java
@@ -5,27 +5,33 @@
  */
 public interface Builders {
 
-    public interface ImageView {
+    public interface IV {
         public interface F<A extends F<?>> extends ImageViewBuilder<A>, BitmapBuilder<A>, LoadImageViewFutureBuilder {
         }
     }
 
     public interface Any {
+        // restrict to image view builder
         public interface IF<A extends IF<?>> extends ImageViewBuilder<A>, ImageViewFutureBuilder {
         }
 
+        // restrict to bitmap future builder
         public interface BF<A extends BF<?>> extends BitmapBuilder<A>, BitmapFutureBuilder, IF<A> {
         }
 
+        // restrict to future builder
         public interface F extends FutureBuilder, ImageViewFutureBuilder {
         }
 
+        // restrict to multipart builder
         public interface M extends MultipartBodyBuilder<M>, F {
         }
 
+        // restrict to url encoded builder builder
         public interface U extends UrlEncodedBuilder<U>, F {
         }
 
+        // top level builder
         public interface B extends RequestBuilder<F, B, M, U>, F {
         }
     }
diff --git a/ion/src/com/koushikdutta/ion/builder/FutureBuilder.java b/ion/src/com/koushikdutta/ion/builder/FutureBuilder.java
index dad38128..ec80d761 100644
--- a/ion/src/com/koushikdutta/ion/builder/FutureBuilder.java
+++ b/ion/src/com/koushikdutta/ion/builder/FutureBuilder.java
@@ -1,7 +1,5 @@
 package com.koushikdutta.ion.builder;
 
-import android.util.Xml;
-
 import com.google.gson.JsonArray;
 import com.google.gson.JsonObject;
 import com.google.gson.reflect.TypeToken;
@@ -17,7 +15,7 @@
 /**
 * Created by koush on 5/30/13.
 */ // get the result, transformed to how you want it
-public interface FutureBuilder extends BitmapFutureBuilder, ImageViewFutureBuilder {
+public interface FutureBuilder extends BitmapFutureBuilder, ImageViewFutureBuilder, GsonFutureBuilder {
     /**
      * Execute the request and get the result as a String
      * @return
@@ -32,18 +30,6 @@
      */
     public ResponseFuture<InputStream> asInputStream();
 
-    /**
-     * Execute the request and get the result as a (Gson) JsonArray
-     * @return
-     */
-    public ResponseFuture<JsonArray> asJsonArray();
-
-    /**
-     * Execute the request and get the result as a (Gson) JsonObject
-     * @return
-     */
-    public ResponseFuture<JsonObject> asJsonObject();
-
     /**
      * Execute the request and get the result as an XML Document
      * @return
@@ -81,27 +67,18 @@
     public ResponseFuture<File> write(File file);
 
     /**
-     * Deserialize the JSON request into a Java object of the given class using Gson.
-     * @param <T>
-     * @return
-     */
-    public <T> ResponseFuture<T> as(Class<T> clazz);
-
-    /**
-     * Deserialize the JSON request into a Java object of the given class using Gson.
-     * @param token
+     * Deserialize a response into an object given a custom parser.
+     * @param parser
      * @param <T>
      * @return
      */
-    public <T> ResponseFuture<T> as(TypeToken<T> token);
+    public <T> ResponseFuture<T> as(AsyncParser<T> parser);
 
     /**
-     * Deserialize a response into an object given a custom parser.
-     * @param parser
-     * @param <T>
+     * Execute the request and get the result as a byte array
      * @return
      */
-    public <T> ResponseFuture<T> as(AsyncParser<T> parser);
+    public ResponseFuture<byte[]> asByteArray();
 
     /**
      * Add this request to a group specified by groupKey. This key can be used in a later call to
diff --git a/ion/src/com/koushikdutta/ion/builder/GsonFutureBuilder.java b/ion/src/com/koushikdutta/ion/builder/GsonFutureBuilder.java
new file mode 100644
index 00000000..d2d8fe0a
--- /dev/null
+++ b/ion/src/com/koushikdutta/ion/builder/GsonFutureBuilder.java
@@ -0,0 +1,38 @@
+package com.koushikdutta.ion.builder;
+
+import com.google.gson.JsonArray;
+import com.google.gson.JsonObject;
+import com.google.gson.reflect.TypeToken;
+import com.koushikdutta.ion.future.ResponseFuture;
+
+/**
+ * Created by koush on 3/10/14.
+ */
+public interface GsonFutureBuilder {
+    /**
+     * Execute the request and get the result as a (Gson) JsonArray
+     * @return
+     */
+    public ResponseFuture<JsonArray> asJsonArray();
+
+    /**
+     * Execute the request and get the result as a (Gson) JsonObject
+     * @return
+     */
+    public ResponseFuture<JsonObject> asJsonObject();
+
+    /**
+     * Deserialize the JSON request into a Java object of the given class using Gson.
+     * @param <T>
+     * @return
+     */
+    public <T> ResponseFuture<T> as(Class<T> clazz);
+
+    /**
+     * Deserialize the JSON request into a Java object of the given class using Gson.
+     * @param token
+     * @param <T>
+     * @return
+     */
+    public <T> ResponseFuture<T> as(TypeToken<T> token);
+}
diff --git a/ion/src/com/koushikdutta/ion/builder/ImageViewBuilder.java b/ion/src/com/koushikdutta/ion/builder/ImageViewBuilder.java
index 16a5f40c..741cf66a 100644
--- a/ion/src/com/koushikdutta/ion/builder/ImageViewBuilder.java
+++ b/ion/src/com/koushikdutta/ion/builder/ImageViewBuilder.java
@@ -84,4 +84,13 @@
      * @return
      */
     public I animateGif(boolean animateGif);
+
+    /**
+     * Load the ImageView with a deep zoomable image. This allows extremely large images
+     * to be loaded, at full fidelity. Only portions of the image will be decoded,
+     * on an as needed basis when rendering.
+     * This only works on API level 10+, where BitmapRegionDecoder is available.
+     * @return
+     */
+    public I deepZoom();
 }
diff --git a/ion/src/com/koushikdutta/ion/builder/RequestBuilder.java b/ion/src/com/koushikdutta/ion/builder/RequestBuilder.java
index 1c76c61b..daa02c6b 100644
--- a/ion/src/com/koushikdutta/ion/builder/RequestBuilder.java
+++ b/ion/src/com/koushikdutta/ion/builder/RequestBuilder.java
@@ -141,6 +141,13 @@
      */
     public R addHeader(String name, String value);
 
+    /**
+     * Add multiple headers at once
+     * @param params
+     * @return
+     */
+    public R addHeaders(Map<String, List<String>> params);
+
     /**
      * Add a query parameter
      * @param name
@@ -243,6 +250,14 @@
      */
     public F setFileBody(File file);
 
+    /**
+     * Specify a byte array to send to the HTTP server. If no HTTP method was explicitly
+     * provided in the load call, the default HTTP method, POST, is used.
+     * @param bytes Bytes to send with the request
+     * @return
+     */
+    public F setByteArrayBody(byte[] bytes);
+
     /**
      * Specify an InputStream to send to the HTTP server. If no HTTP method was explicitly
      * provided in the load call, the default HTTP method, POST, is used.
diff --git a/ion/src/com/koushikdutta/ion/cookie/CookieMiddleware.java b/ion/src/com/koushikdutta/ion/cookie/CookieMiddleware.java
index e8b8ff24..3baaf9bf 100644
--- a/ion/src/com/koushikdutta/ion/cookie/CookieMiddleware.java
+++ b/ion/src/com/koushikdutta/ion/cookie/CookieMiddleware.java
@@ -5,6 +5,7 @@
 import android.text.TextUtils;
 import android.util.Log;
 
+import com.koushikdutta.async.http.Multimap;
 import com.koushikdutta.async.http.SimpleMiddleware;
 import com.koushikdutta.async.http.libcore.RawHeaders;
 
@@ -14,7 +15,6 @@
 import java.net.URI;
 import java.util.List;
 import java.util.Map;
-import java.util.Set;
 
 /**
  * Created by koush on 5/29/13.
@@ -37,6 +37,10 @@ public CookieManager getCookieManager() {
     }
 
     public CookieMiddleware(Context context, String name) {
+        reinit(context, name);
+    }
+
+    public void reinit(Context context, String name) {
         manager = new CookieManager(null, null);
         preferences = context.getSharedPreferences(name + "-cookies", Context.MODE_PRIVATE);
 
@@ -76,16 +80,27 @@ public void onSocket(OnSocketData data) {
 
     @Override
     public void onHeadersReceived(OnHeadersReceivedData data) {
+        put(data.request.getUri(), data.headers.getHeaders());
+    }
+
+    public void put(URI uri, RawHeaders headers) {
         try {
-            manager.put(data.request.getUri(), data.headers.getHeaders().toMultimap());
+            manager.put(uri, headers.toMultimap());
 
             // no cookies to persist.
-            if (data.headers.getHeaders().get("Set-Cookie") == null)
+            if (headers.get("Set-Cookie") == null)
                 return;
 
-            URI uri = data.request.getUri();
+            List<HttpCookie> cookies = manager.getCookieStore().get(uri);
+
+            RawHeaders dump = new RawHeaders();
+            dump.setStatusLine("HTTP/1.1 200 OK");
+            for (HttpCookie cookie: cookies) {
+                dump.add("Set-Cookie", cookie.getName() + "=" + cookie.getValue());
+            }
+
             String key = uri.getScheme() + "://" + uri.getAuthority();
-            preferences.edit().putString(key, data.headers.getHeaders().toHeaderString()).commit();
+            preferences.edit().putString(key, dump.toHeaderString()).commit();
         }
         catch (Exception e) {
         }
diff --git a/ion/src/com/koushikdutta/ion/loader/FileLoader.java b/ion/src/com/koushikdutta/ion/loader/FileLoader.java
index 450556db..5b6444da 100644
--- a/ion/src/com/koushikdutta/ion/loader/FileLoader.java
+++ b/ion/src/com/koushikdutta/ion/loader/FileLoader.java
@@ -1,7 +1,10 @@
 package com.koushikdutta.ion.loader;
 
+import android.content.Context;
 import android.graphics.Bitmap;
-import android.util.Log;
+import android.graphics.BitmapFactory;
+import android.graphics.Point;
+import android.text.TextUtils;
 
 import com.koushikdutta.async.DataEmitter;
 import com.koushikdutta.async.FileDataEmitter;
@@ -9,14 +12,15 @@
 import com.koushikdutta.async.future.FutureCallback;
 import com.koushikdutta.async.future.SimpleFuture;
 import com.koushikdutta.async.http.AsyncHttpRequest;
+import com.koushikdutta.async.util.StreamUtility;
 import com.koushikdutta.ion.Ion;
 import com.koushikdutta.ion.Loader;
 import com.koushikdutta.ion.bitmap.BitmapInfo;
+import com.koushikdutta.ion.gif.GifAction;
+import com.koushikdutta.ion.gif.GifDecoder;
 
-import java.io.BufferedInputStream;
 import java.io.File;
 import java.io.FileInputStream;
-import java.io.IOException;
 import java.io.InputStream;
 import java.net.URI;
 
@@ -28,12 +32,14 @@
     }
 
     @Override
-    public Future<BitmapInfo> loadBitmap(final Ion ion, final String uri, final int resizeWidth, final int resizeHeight) {
+    public Future<BitmapInfo> loadBitmap(final Context context, final Ion ion, final String key, final String uri, final int resizeWidth, final int resizeHeight,
+                                         final boolean animateGif) {
         if (uri == null || !uri.startsWith("file:/"))
             return null;
 
         final SimpleFuture<BitmapInfo> ret = new SimpleFuture<BitmapInfo>();
 
+//        Log.d("FileLoader", "Loading file bitmap " + uri + " " + resizeWidth + "," + resizeHeight);
         Ion.getBitmapLoadExecutorService().execute(new Runnable() {
             @Override
             public void run() {
@@ -42,14 +48,44 @@ public void run() {
                     return;
                 }
                 try {
-                    FileInputStream fin = new FileInputStream(new File(URI.create(uri)));
-                    Bitmap bitmap = ion.getBitmapCache().loadBitmap(fin, resizeWidth, resizeHeight);
-                    if (bitmap == null)
-                        throw new Exception("Bitmap failed to load");
-                    BitmapInfo info = new BitmapInfo();
-                    info.bitmaps = new Bitmap[] { bitmap };
+                    File file = new File(URI.create(uri));
+                    BitmapFactory.Options options = ion.getBitmapCache().prepareBitmapOptions(file, resizeWidth, resizeHeight);
+                    if (options == null)
+                        throw new Exception("BitmapFactory.Options failed to load");
+                    Point size = new Point(options.outWidth, options.outHeight);
+                    Bitmap[] bitmaps;
+                    int[] delays;
+                    if (animateGif && TextUtils.equals("image/gif", options.outMimeType)) {
+                        FileInputStream fin = new FileInputStream(file);
+                        GifDecoder decoder = new GifDecoder(fin, new GifAction() {
+                            @Override
+                            public boolean parseOk(boolean parseStatus, int frameIndex) {
+                                return animateGif;
+                            }
+                        });
+                        decoder.run();
+                        StreamUtility.closeQuietly(fin);
+                        if (decoder.getFrameCount() == 0)
+                            throw new Exception("failed to load gif");
+                        bitmaps = new Bitmap[decoder.getFrameCount()];
+                        delays = decoder.getDelays();
+                        for (int i = 0; i < decoder.getFrameCount(); i++) {
+                            Bitmap bitmap = decoder.getFrameImage(i);
+                            if (bitmap == null)
+                                throw new Exception("failed to load gif frame");
+                            bitmaps[i] = bitmap;
+                        }
+                    }
+                    else {
+                        Bitmap bitmap = ion.getBitmapCache().loadBitmap(file, options);
+                        if (bitmap == null)
+                            throw new Exception("Bitmap failed to load");
+                        bitmaps = new Bitmap[] { bitmap };
+                        delays = null;
+                    }
+                    BitmapInfo info = new BitmapInfo(key, options.outMimeType, bitmaps, size);
+                    info.delays = delays;
                     info.loadedFrom =  Loader.LoaderEmitter.LOADED_FROM_CACHE;
-                    fin.close();
                     ret.setComplete(info);
                 }
                 catch (OutOfMemoryError e) {
@@ -94,7 +130,7 @@ public void run() {
                 File file = new File(request.getUri());
                 FileDataEmitter emitter = new FileDataEmitter(ion.getHttpClient().getServer(), file);
                 ret.setComplete(emitter);
-                callback.onCompleted(null, new LoaderEmitter(emitter, (int)file.length(), LoaderEmitter.LOADED_FROM_CACHE, null, null));
+                callback.onCompleted(null, new LoaderEmitter(emitter, (int)file.length(), LoaderEmitter.LOADED_FROM_CACHE, null, request));
             }
         });
         return ret;
diff --git a/ion/src/com/koushikdutta/ion/loader/HttpLoader.java b/ion/src/com/koushikdutta/ion/loader/HttpLoader.java
index 0d291d66..d01dea56 100644
--- a/ion/src/com/koushikdutta/ion/loader/HttpLoader.java
+++ b/ion/src/com/koushikdutta/ion/loader/HttpLoader.java
@@ -1,6 +1,7 @@
 package com.koushikdutta.ion.loader;
 
 import android.text.TextUtils;
+
 import com.koushikdutta.async.DataEmitter;
 import com.koushikdutta.async.future.Future;
 import com.koushikdutta.async.future.FutureCallback;
@@ -10,10 +11,6 @@
 import com.koushikdutta.async.http.callback.HttpConnectCallback;
 import com.koushikdutta.async.http.libcore.RawHeaders;
 import com.koushikdutta.ion.Ion;
-import com.koushikdutta.ion.Loader;
-import com.koushikdutta.ion.bitmap.BitmapInfo;
-
-import java.io.InputStream;
 
 /**
  * Created by koush on 5/22/13.
@@ -24,7 +21,6 @@
     public Future<DataEmitter> load(Ion ion, AsyncHttpRequest request, final FutureCallback<LoaderEmitter> callback) {
         if (!request.getUri().getScheme().startsWith("http"))
             return null;
-        assert request.getHandler() == null;
         return (Future< DataEmitter >)(Future)ion.getHttpClient().execute(request, new HttpConnectCallback() {
             @Override
             public void onConnectCompleted(Exception ex, AsyncHttpResponse response) {
diff --git a/ion/src/com/koushikdutta/ion/loader/MediaFile.java b/ion/src/com/koushikdutta/ion/loader/MediaFile.java
index b8a96832..4be18786 100644
--- a/ion/src/com/koushikdutta/ion/loader/MediaFile.java
+++ b/ion/src/com/koushikdutta/ion/loader/MediaFile.java
@@ -214,6 +214,7 @@ private static boolean isWMVEnabled() {
         addFileType("MPEG", FILE_TYPE_MP4, "video/mpeg", MtpConstants.FORMAT_MPEG);
         addFileType("MPG", FILE_TYPE_MP4, "video/mpeg", MtpConstants.FORMAT_MPEG);
         addFileType("MP4", FILE_TYPE_MP4, "video/mp4", MtpConstants.FORMAT_MPEG);
+        addFileType("MPEG4", FILE_TYPE_MP4, "video/mpeg4", MtpConstants.FORMAT_MPEG);
         addFileType("M4V", FILE_TYPE_M4V, "video/m4v", MtpConstants.FORMAT_MPEG);
         addFileType("3GP", FILE_TYPE_3GPP, "video/3gpp",  MtpConstants.FORMAT_3GP_CONTAINER);
         addFileType("3GPP", FILE_TYPE_3GPP, "video/3gpp", MtpConstants.FORMAT_3GP_CONTAINER);
diff --git a/ion/src/com/koushikdutta/ion/loader/PackageIconLoader.java b/ion/src/com/koushikdutta/ion/loader/PackageIconLoader.java
index 147d0b3a..ede717a9 100644
--- a/ion/src/com/koushikdutta/ion/loader/PackageIconLoader.java
+++ b/ion/src/com/koushikdutta/ion/loader/PackageIconLoader.java
@@ -1,8 +1,10 @@
 package com.koushikdutta.ion.loader;
 
 
+import android.content.Context;
 import android.content.pm.PackageManager;
 import android.graphics.Bitmap;
+import android.graphics.Point;
 import android.graphics.drawable.BitmapDrawable;
 
 import com.koushikdutta.async.future.Future;
@@ -18,9 +20,8 @@
  */
 public class PackageIconLoader extends SimpleLoader {
     @Override
-    public Future<BitmapInfo> loadBitmap(final Ion ion, final String uri, int resizeWidth, int resizeHeight) {
-        final URI request = URI.create(uri);
-        if (request == null || request.getScheme() == null || !request.getScheme().startsWith("package"))
+    public Future<BitmapInfo> loadBitmap(Context context, final Ion ion, final String key, final String uri, int resizeWidth, int resizeHeight, boolean animateGif) {
+        if (uri == null || !uri.startsWith("package:"))
             return null;
 
         final SimpleFuture<BitmapInfo> ret = new SimpleFuture<BitmapInfo>();
@@ -28,13 +29,13 @@
             @Override
             public void run() {
                 try {
+                    final URI request = URI.create(uri);
                     String pkg = request.getHost();
                     PackageManager pm = ion.getContext().getPackageManager();
                     Bitmap bmp = ((BitmapDrawable)pm.getPackageInfo(pkg, 0).applicationInfo.loadIcon(pm)).getBitmap();
                     if (bmp == null)
                         throw new Exception("package icon failed to load");
-                    BitmapInfo info = new BitmapInfo();
-                    info.bitmaps = new Bitmap[] { bmp };
+                    BitmapInfo info = new BitmapInfo(key, null, new Bitmap[] { bmp }, new Point(bmp.getWidth(), bmp.getHeight()));
                     info.loadedFrom =  Loader.LoaderEmitter.LOADED_FROM_CACHE;
                     ret.setComplete(info);
                 }
diff --git a/ion/src/com/koushikdutta/ion/loader/SimpleLoader.java b/ion/src/com/koushikdutta/ion/loader/SimpleLoader.java
index 934e16d1..8d285a1b 100644
--- a/ion/src/com/koushikdutta/ion/loader/SimpleLoader.java
+++ b/ion/src/com/koushikdutta/ion/loader/SimpleLoader.java
@@ -1,5 +1,7 @@
 package com.koushikdutta.ion.loader;
 
+import android.content.Context;
+
 import com.koushikdutta.async.DataEmitter;
 import com.koushikdutta.async.future.Future;
 import com.koushikdutta.async.future.FutureCallback;
@@ -25,7 +27,12 @@
     }
 
     @Override
-    public Future<BitmapInfo> loadBitmap(Ion ion, String uri, int resizeWidth, int resizeHeight) {
+    public Future<BitmapInfo> loadBitmap(Context context, Ion ion, String key, String uri, int resizeWidth, int resizeHeight, boolean animateGif) {
+        return null;
+    }
+
+    @Override
+    public Future<AsyncHttpRequest> resolve(Context context, Ion ion, AsyncHttpRequest request) {
         return null;
     }
 }
diff --git a/ion/src/com/koushikdutta/ion/loader/VideoLoader.java b/ion/src/com/koushikdutta/ion/loader/VideoLoader.java
index 1b4ef523..ae31cbb8 100644
--- a/ion/src/com/koushikdutta/ion/loader/VideoLoader.java
+++ b/ion/src/com/koushikdutta/ion/loader/VideoLoader.java
@@ -1,88 +1,46 @@
 package com.koushikdutta.ion.loader;
 
+import android.annotation.TargetApi;
 import android.content.ContentResolver;
+import android.content.Context;
 import android.graphics.Bitmap;
-import android.graphics.BitmapFactory;
+import android.graphics.Point;
+import android.media.MediaMetadataRetriever;
+import android.media.ThumbnailUtils;
 import android.os.Build;
-import android.util.Log;
+import android.provider.MediaStore;
 
-import com.koushikdutta.async.DataEmitter;
 import com.koushikdutta.async.future.Future;
-import com.koushikdutta.async.future.FutureCallback;
 import com.koushikdutta.async.future.SimpleFuture;
-import com.koushikdutta.async.http.AsyncHttpRequest;
 import com.koushikdutta.ion.Ion;
-import com.koushikdutta.ion.Loader;
 import com.koushikdutta.ion.bitmap.BitmapInfo;
 
 import java.io.File;
-import java.io.InputStream;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
 import java.net.URI;
 
 /**
  * Created by koush on 11/6/13.
  */
 public class VideoLoader extends SimpleLoader {
-    private static final String TAG = "IonVideoLoader";
-
-    public static Bitmap createVideoThumbnail(String filePath) {
-        // MediaMetadataRetriever is available on API Level 8
-        // but is hidden until API Level 10
-        Class<?> clazz = null;
-        Object instance = null;
-        try {
-            clazz = Class.forName("android.media.MediaMetadataRetriever");
-            instance = clazz.newInstance();
-
-            Method method = clazz.getMethod("setDataSource", String.class);
-            method.invoke(instance, filePath);
+    @TargetApi(Build.VERSION_CODES.GINGERBREAD_MR1)
+    public static Bitmap createVideoThumbnail(String filePath) throws Exception {
+        MediaMetadataRetriever retriever = new MediaMetadataRetriever();
+        retriever.setDataSource(filePath);
+        return retriever.getFrameAtTime();
+    }
 
-            // The method name changes between API Level 9 and 10.
-            if (Build.VERSION.SDK_INT <= 9) {
-                return (Bitmap) clazz.getMethod("captureFrame").invoke(instance);
-            } else {
-                byte[] data = (byte[]) clazz.getMethod("getEmbeddedPicture").invoke(instance);
-                if (data != null) {
-                    Bitmap bitmap = BitmapFactory.decodeByteArray(data, 0, data.length);
-                    if (bitmap != null) return bitmap;
-                }
-                return (Bitmap) clazz.getMethod("getFrameAtTime").invoke(instance);
-            }
-        } catch (IllegalArgumentException ex) {
-            // Assume this is a corrupt video file
-        } catch (RuntimeException ex) {
-            // Assume this is a corrupt video file.
-        } catch (InstantiationException e) {
-            Log.e(TAG, "createVideoThumbnail", e);
-        } catch (InvocationTargetException e) {
-            Log.e(TAG, "createVideoThumbnail", e);
-        } catch (ClassNotFoundException e) {
-            Log.e(TAG, "createVideoThumbnail", e);
-        } catch (NoSuchMethodException e) {
-            Log.e(TAG, "createVideoThumbnail", e);
-        } catch (IllegalAccessException e) {
-            Log.e(TAG, "createVideoThumbnail", e);
-        } finally {
-            try {
-                if (instance != null) {
-                    clazz.getMethod("release").invoke(instance);
-                }
-            } catch (Exception ignored) {
-            }
-        }
-        return null;
+    static boolean mustUseThumbnailUtils() {
+        // http://developer.samsung.com/forum/thread/mediametadataretriever-getframeattime-to-retrieve-video-frame-fails/77/202945
+        // https://codereview.chromium.org/107523005
+        return Build.MANUFACTURER.toLowerCase().contains("samsung");
     }
 
     @Override
-    public Future<BitmapInfo> loadBitmap(Ion ion, String uri, int resizeWidth, int resizeHeight) {
+    public Future<BitmapInfo> loadBitmap(Context context, Ion ion, final String key, final String uri, int resizeWidth, int resizeHeight, boolean animateGif) {
         if (!uri.startsWith(ContentResolver.SCHEME_FILE))
             return null;
 
-        final File file = new File(URI.create(uri));
-
-        MediaFile.MediaFileType type = MediaFile.getFileType(file.getAbsolutePath());
+        final MediaFile.MediaFileType type = MediaFile.getFileType(uri);
         if (type == null || !MediaFile.isVideoFileType(type.fileType))
             return null;
 
@@ -90,16 +48,21 @@ public static Bitmap createVideoThumbnail(String filePath) {
         Ion.getBitmapLoadExecutorService().execute(new Runnable() {
             @Override
             public void run() {
+                final File file = new File(URI.create(uri));
                 if (ret.isCancelled()) {
 //                    Log.d("VideoLoader", "Bitmap load cancelled (no longer needed)");
                     return;
                 }
                 try {
-                    Bitmap bmp = createVideoThumbnail(file.getAbsolutePath());
+                    Bitmap bmp;
+
+                    if (mustUseThumbnailUtils() || Build.VERSION.SDK_INT < Build.VERSION_CODES.GINGERBREAD_MR1)
+                        bmp = ThumbnailUtils.createVideoThumbnail(file.getAbsolutePath(), MediaStore.Video.Thumbnails.MINI_KIND);
+                    else
+                        bmp = createVideoThumbnail(file.getAbsolutePath());
                     if (bmp == null)
                         throw new Exception("video bitmap failed to load");
-                    BitmapInfo info = new BitmapInfo();
-                    info.bitmaps = new Bitmap[] {bmp};
+                    BitmapInfo info = new BitmapInfo(key, type.mimeType, new Bitmap[] { bmp }, new Point(bmp.getWidth(), bmp.getHeight()));
                     info.loadedFrom = LoaderEmitter.LOADED_FROM_CACHE;
                     ret.setComplete(info);
                 } catch (Exception e) {
