diff --git a/ion/src/com/koushikdutta/ion/BitmapCallback.java b/ion/src/com/koushikdutta/ion/BitmapCallback.java
index 1fe97af1..b525bb4b 100644
--- a/ion/src/com/koushikdutta/ion/BitmapCallback.java
+++ b/ion/src/com/koushikdutta/ion/BitmapCallback.java
@@ -38,8 +38,7 @@ public void run() {
                 BitmapInfo result = info;
                 if (result == null) {
                     // cache errors
-                    result = new BitmapInfo(null, new Point());
-                    result.key = key;
+                    result = new BitmapInfo(key, null, new Point());
                     result.exception = e;
                     ion.getBitmapCache().put(result);
                 } else if (put()) {
diff --git a/ion/src/com/koushikdutta/ion/BitmapFetcher.java b/ion/src/com/koushikdutta/ion/BitmapFetcher.java
index 38ff182c..eea3aae1 100644
--- a/ion/src/com/koushikdutta/ion/BitmapFetcher.java
+++ b/ion/src/com/koushikdutta/ion/BitmapFetcher.java
@@ -4,14 +4,18 @@
 import com.koushikdutta.async.ByteBufferList;
 import com.koushikdutta.async.future.Future;
 import com.koushikdutta.async.future.FutureCallback;
+import com.koushikdutta.async.http.AsyncHttpRequest;
 import com.koushikdutta.async.http.libcore.DiskLruCache;
 import com.koushikdutta.async.parser.ByteBufferListParser;
 import com.koushikdutta.ion.bitmap.BitmapInfo;
 import com.koushikdutta.ion.bitmap.Transform;
+import com.koushikdutta.ion.loader.MediaFile;
 
+import java.io.File;
+import java.net.URI;
 import java.util.ArrayList;
 
-class BitmapFetcher {
+class BitmapFetcher implements IonRequestBuilder.LoadRequestCallback {
     String downloadKey;
     String bitmapKey;
     BitmapInfo info;
@@ -21,20 +25,35 @@
     int resizeWidth;
     int resizeHeight;
     boolean animateGif;
+    boolean deepZoom;
 
-    boolean fastLoad() {
+    private boolean fastLoad(String uri) {
         Ion ion = builder.ion;
+        if (deepZoom) {
+            if (uri == null || !uri.startsWith("file:/"))
+                return false;
+            File file = new File(URI.create(uri));
+            if (!file.exists())
+                return false;
+            MediaFile.MediaFileType type = MediaFile.getFileType(file.getAbsolutePath());
+            if (type == null || !MediaFile.isVideoFileType(type.fileType)) {
+                LoadDeepZoom loadDeepZoom = new LoadDeepZoom(ion, downloadKey, animateGif, null);
+                loadDeepZoom.onCompleted(null, file);
+//                System.out.println("fastloading deepZoom");
+                return true;
+            }
+            // fall through to allow some other loader to open this, cause this is a video file
+        }
+
         boolean put = !hasTransforms;
 
         for (Loader loader: ion.configure().getLoaders()) {
-            Future<BitmapInfo> future = loader.loadBitmap(ion, builder.uri, resizeWidth, resizeHeight);
+            Future<BitmapInfo> future = loader.loadBitmap(ion, downloadKey, uri, resizeWidth, resizeHeight);
             if (future != null) {
                 final BitmapCallback callback = new LoadBitmapBase(ion, downloadKey, put);
                 future.setCallback(new FutureCallback<BitmapInfo>() {
                     @Override
                     public void onCompleted(Exception e, BitmapInfo result) {
-                        if (result != null)
-                            result.key = downloadKey;
                         callback.report(e, result);
                     }
                 });
@@ -44,9 +63,9 @@ public void onCompleted(Exception e, BitmapInfo result) {
         return false;
     }
 
-    static final int MAX_IMAGEVIEW_LOAD = 5;
+    public static final int MAX_IMAGEVIEW_LOAD = 5;
 
-    static boolean shouldDeferImageView(Ion ion) {
+    public static boolean shouldDeferImageView(Ion ion) {
         if (ion.bitmapsPending.keySet().size() <= MAX_IMAGEVIEW_LOAD)
             return false;
         int loadCount = 0;
@@ -61,7 +80,7 @@ static boolean shouldDeferImageView(Ion ion) {
         return false;
     }
 
-    DeferredLoadBitmap executeDeferred() {
+    public DeferredLoadBitmap defer() {
         DeferredLoadBitmap ret = new DeferredLoadBitmap(builder.ion, downloadKey, this);
         executeTransforms(builder.ion);
         return ret;
@@ -80,34 +99,49 @@ private void executeTransforms(Ion ion) {
         }
     }
 
-    void executeNetwork() {
+    @Override
+    public boolean loadRequest(AsyncHttpRequest request) {
+        return !fastLoad(request.getUri().toString());
+    }
+
+    public void execute() {
         final Ion ion = builder.ion;
 
         // bitmaps that were transformed are put into the DiskLruCache to prevent
         // subsequent retransformation. See if we can retrieve the bitmap from the disk cache.
         // See TransformBitmap for where the cache is populated.
         DiskLruCache diskLruCache = ion.responseCache.getDiskLruCache();
-        if (!builder.noCache && hasTransforms && diskLruCache.containsKey(bitmapKey)) {
+        if (!builder.noCache && hasTransforms && diskLruCache.containsKey(bitmapKey) && !deepZoom) {
             TransformBitmap.getBitmapSnapshot(ion, bitmapKey);
             return;
         }
 
         // Perform a download as necessary.
-        if (ion.bitmapsPending.tag(downloadKey) == null && !fastLoad()) {
+        if (ion.bitmapsPending.tag(downloadKey) == null && !fastLoad(builder.uri)) {
             builder.setHandler(null);
-            // if we cancel, gotta remove any waiters.
-            IonRequestBuilder.EmitterTransform<ByteBufferList> emitterTransform = builder.execute(new ByteBufferListParser(), new Runnable() {
-                @Override
-                public void run() {
-                    AsyncServer.post(Ion.mainHandler, new Runnable() {
-                        @Override
-                        public void run() {
-                            ion.bitmapsPending.remove(downloadKey);
-                        }
-                    });
-                }
-            });
-            emitterTransform.setCallback(new LoadBitmap(ion, downloadKey, !hasTransforms, resizeWidth, resizeHeight, animateGif, emitterTransform));
+            builder.loadRequestCallback = this;
+
+            if (!deepZoom) {
+                IonRequestBuilder.EmitterTransform<ByteBufferList> emitterTransform = builder.execute(new ByteBufferListParser(), new Runnable() {
+                    @Override
+                    public void run() {
+                        AsyncServer.post(Ion.mainHandler, new Runnable() {
+                            @Override
+                            public void run() {
+                                ion.bitmapsPending.remove(downloadKey);
+                            }
+                        });
+                    }
+                });
+                emitterTransform.setCallback(new LoadBitmap(ion, downloadKey, !hasTransforms, resizeWidth, resizeHeight, animateGif, emitterTransform));
+            }
+            else {
+//                System.out.println("downloading file for deepZoom");
+                File file = diskLruCache.getFile(downloadKey, 0);
+                IonRequestBuilder.EmitterTransform<File> emitterTransform = builder.write(file);
+                LoadDeepZoom loadDeepZoom = new LoadDeepZoom(ion, downloadKey, animateGif, emitterTransform);
+                emitterTransform.setCallback(loadDeepZoom);
+            }
         }
 
         executeTransforms(ion);
diff --git a/ion/src/com/koushikdutta/ion/DefaultTransform.java b/ion/src/com/koushikdutta/ion/DefaultTransform.java
index c60a4824..f429a0a7 100644
--- a/ion/src/com/koushikdutta/ion/DefaultTransform.java
+++ b/ion/src/com/koushikdutta/ion/DefaultTransform.java
@@ -21,7 +21,10 @@ public DefaultTransform(int width, int height, ScaleMode scaleMode) {
 
     @Override
     public Bitmap transform(Bitmap b) {
-        Bitmap ret = Bitmap.createBitmap(resizeWidth, resizeHeight, b.getConfig());
+        Bitmap.Config config = b.getConfig();
+        if (config == null)
+            config = Bitmap.Config.ARGB_8888;
+        Bitmap ret = Bitmap.createBitmap(resizeWidth, resizeHeight, config);
         Canvas canvas = new Canvas(ret);
 
         RectF destination = new RectF(0, 0, resizeWidth, resizeHeight);
diff --git a/ion/src/com/koushikdutta/ion/Ion.java b/ion/src/com/koushikdutta/ion/Ion.java
index 22296d89..1519db8e 100644
--- a/ion/src/com/koushikdutta/ion/Ion.java
+++ b/ion/src/com/koushikdutta/ion/Ion.java
@@ -21,6 +21,8 @@
 import com.koushikdutta.async.AsyncServer;
 import com.koushikdutta.async.future.Future;
 import com.koushikdutta.async.future.FutureCallback;
+import com.koushikdutta.async.future.SimpleFuture;
+import com.koushikdutta.async.future.TransformFuture;
 import com.koushikdutta.async.http.AsyncHttpClient;
 import com.koushikdutta.async.http.AsyncHttpRequest;
 import com.koushikdutta.async.http.ResponseCacheMiddleware;
@@ -251,7 +253,7 @@ public void run() {
             for (DeferredLoadBitmap deferredLoadBitmap: deferred) {
                 bitmapsPending.tag(deferredLoadBitmap.key, null);
                 bitmapsPending.tag(deferredLoadBitmap.fetcher.bitmapKey, null);
-                deferredLoadBitmap.fetcher.executeNetwork();
+                deferredLoadBitmap.fetcher.execute();
                 count++;
                 // do MAX_IMAGEVIEW_LOAD max. this may end up going over the MAX_IMAGEVIEW_LOAD threshhold
                 if (count > BitmapFetcher.MAX_IMAGEVIEW_LOAD)
@@ -553,4 +555,34 @@ public Config configure() {
     public IonBitmapCache getBitmapCache() {
         return bitmapCache;
     }
+
+    Future<AsyncHttpRequest> resolveRequest(AsyncHttpRequest request) {
+        return resolveRequest(request, null);
+    }
+
+    Future<AsyncHttpRequest> resolveRequest(AsyncHttpRequest request, SimpleFuture<AsyncHttpRequest> ret) {
+        // first attempt to resolve the url
+        for (Loader loader: loaders) {
+            Future<AsyncHttpRequest> resolved = loader.resolve(this, request);
+            if (resolved != null) {
+                if (ret == null)
+                    ret = new SimpleFuture<AsyncHttpRequest>();
+                final SimpleFuture<AsyncHttpRequest> future = ret;
+                resolved.setCallback(new FutureCallback<AsyncHttpRequest>() {
+                    @Override
+                    public void onCompleted(Exception e, AsyncHttpRequest result) {
+                        if (e != null) {
+                            future.setComplete(e);
+                            return;
+                        }
+                        resolveRequest(result, future);
+                    }
+                });
+                return ret;
+            }
+        }
+        if (ret != null)
+            ret.setComplete(request);
+        return ret;
+    }
 }
diff --git a/ion/src/com/koushikdutta/ion/IonBitmapRequestBuilder.java b/ion/src/com/koushikdutta/ion/IonBitmapRequestBuilder.java
index 24a3b36c..fbe24480 100644
--- a/ion/src/com/koushikdutta/ion/IonBitmapRequestBuilder.java
+++ b/ion/src/com/koushikdutta/ion/IonBitmapRequestBuilder.java
@@ -1,6 +1,5 @@
 package com.koushikdutta.ion;
 
-import android.content.Context;
 import android.graphics.Bitmap;
 import android.graphics.drawable.Drawable;
 import android.os.Looper;
@@ -8,14 +7,10 @@
 import android.view.animation.AnimationUtils;
 import android.widget.ImageView;
 
-import com.koushikdutta.async.AsyncServer;
-import com.koushikdutta.async.ByteBufferList;
 import com.koushikdutta.async.future.Future;
-import com.koushikdutta.async.future.FutureCallback;
 import com.koushikdutta.async.future.SimpleFuture;
 import com.koushikdutta.async.http.ResponseCacheMiddleware;
 import com.koushikdutta.async.http.libcore.DiskLruCache;
-import com.koushikdutta.async.parser.ByteBufferListParser;
 import com.koushikdutta.ion.bitmap.BitmapInfo;
 import com.koushikdutta.ion.bitmap.Transform;
 import com.koushikdutta.ion.builder.BitmapFutureBuilder;
@@ -58,7 +53,7 @@
     int resizeHeight;
     boolean disableFadeIn;
     boolean animateGif = true;
-    boolean mipmap;
+    boolean deepZoom;
 
     void reset() {
         placeholderDrawable = null;
@@ -78,7 +73,7 @@ void reset() {
         disableFadeIn = false;
         animateGif = true;
         builder = null;
-        mipmap = false;
+        deepZoom = false;
     }
 
     public IonBitmapRequestBuilder(IonRequestBuilder builder) {
@@ -141,8 +136,8 @@ private String computeDownloadKey() {
         // although a gif is always same download, the initial decode is different
         if (!animateGif)
             downloadKey += ":!animateGif";
-        if (mipmap)
-            downloadKey += ":mipmap";
+        if (deepZoom)
+            downloadKey += ":deepZoom";
         return ResponseCacheMiddleware.toKeyString(downloadKey);
     }
 
@@ -165,6 +160,7 @@ BitmapFetcher executeCache() {
             bitmapKey = ResponseCacheMiddleware.toKeyString(bitmapKey);
         }
 
+        // TODO: eliminate this allocation?
         BitmapFetcher ret = new BitmapFetcher();
         ret.downloadKey = downloadKey;
         ret.bitmapKey = bitmapKey;
@@ -174,6 +170,7 @@ BitmapFetcher executeCache() {
         ret.builder = builder;
         ret.transforms = transforms;
         ret.animateGif = animateGif;
+        ret.deepZoom = deepZoom;
 
         // see if this request can be fulfilled from the cache
         if (!builder.noCache) {
@@ -187,53 +184,6 @@ BitmapFetcher executeCache() {
         return ret;
     }
 
-    Future<ImageView> executeMipmap(ImageView imageView) {
-        final String downloadKey = computeDownloadKey();
-
-        // try to grab the master tile
-        BitmapInfo bitmap = builder.ion.bitmapCache.get(downloadKey);
-        if (bitmap != null) {
-            doAnimation(imageView, null, 0);
-            IonDrawable drawable = setIonDrawable(imageView, bitmap, Loader.LoaderEmitter.LOADED_FROM_MEMORY);
-            drawable.cancel();
-            SimpleFuture<ImageView> imageViewFuture = drawable.getFuture();
-            imageViewFuture.reset();
-            imageViewFuture.setComplete(imageView);
-            return imageViewFuture;
-        }
-
-        // see if something is downloading this
-        if (ion.bitmapsPending.tag(downloadKey) == null) {
-            final LoadMipmap loadMipmap = new LoadMipmap(ion, downloadKey);
-            // nothing downloading, see if a file already exists
-            DiskLruCache diskLruCache = ion.responseCache.getDiskLruCache();
-            File file = diskLruCache.getFile(downloadKey, 0);
-            if (diskLruCache.containsKey(downloadKey)) {
-                if (file != null && file.exists()) {
-                    loadMipmap.onCompleted(null, file);
-                    IonDrawable drawable = setIonDrawable(imageView, null, 0);
-                    doAnimation(imageView, loadAnimation, loadAnimationResource);
-                    SimpleFuture<ImageView> imageViewFuture = drawable.getFuture();
-                    imageViewFuture.reset();
-                    drawable.register(ion, downloadKey);
-                    return imageViewFuture;
-                }
-            }
-
-            // ok, now we gotta download it.
-            builder.setHandler(null);
-            builder.write(file)
-            .setCallback(loadMipmap);
-        }
-
-        IonDrawable drawable = setIonDrawable(imageView, null, 0);
-        doAnimation(imageView, loadAnimation, loadAnimationResource);
-        SimpleFuture<ImageView> imageViewFuture = drawable.getFuture();
-        imageViewFuture.reset();
-        drawable.register(ion, downloadKey);
-        return imageViewFuture;
-    }
-
     private IonDrawable setIonDrawable(ImageView imageView, BitmapInfo info, int loadedFrom) {
         IonDrawable ret = IonDrawable.getOrCreateIonDrawable(imageView)
         .ion(ion)
@@ -259,12 +209,6 @@ private IonDrawable setIonDrawable(ImageView imageView, BitmapInfo info, int loa
             return FUTURE_IMAGEVIEW_NULL_URI;
         }
 
-        // if we're mip mapping this image, let's download the image to a file first
-        // then we'll talk.
-        if (mipmap) {
-            return executeMipmap(imageView);
-        }
-
         // executeCache the request, see if we get a bitmap from cache.
         BitmapFetcher bitmapFetcher = executeCache();
         if (bitmapFetcher.info != null) {
@@ -273,26 +217,24 @@ private IonDrawable setIonDrawable(ImageView imageView, BitmapInfo info, int loa
             drawable.cancel();
             SimpleFuture<ImageView> imageViewFuture = drawable.getFuture();
             imageViewFuture.reset();
-            imageViewFuture.setComplete(imageView);
+            imageViewFuture.setComplete(bitmapFetcher.info.exception, imageView);
             return imageViewFuture;
         }
 
         // nothing from cache, check to see if there's too many imageview loads
         // already in progress
         if (BitmapFetcher.shouldDeferImageView(ion)) {
-            bitmapFetcher.executeDeferred();
+            bitmapFetcher.defer();
         }
         else {
-            bitmapFetcher.executeNetwork();
+            bitmapFetcher.execute();
         }
 
         IonDrawable drawable = setIonDrawable(imageView, null, 0);
         doAnimation(imageView, loadAnimation, loadAnimationResource);
         SimpleFuture<ImageView> imageViewFuture = drawable.getFuture();
         imageViewFuture.reset();
-
         drawable.register(ion, bitmapFetcher.bitmapKey);
-
         return imageViewFuture;
     }
 
@@ -311,7 +253,7 @@ private IonDrawable setIonDrawable(ImageView imageView, BitmapInfo info, int loa
             return ret;
         }
 
-        bitmapFetcher.executeNetwork();
+        bitmapFetcher.execute();
         // we're loading, so let's register for the result.
         BitmapInfoToBitmap ret = new BitmapInfoToBitmap(builder.context);
         ion.bitmapsPending.add(bitmapFetcher.bitmapKey, ret);
@@ -418,12 +360,19 @@ public IonBitmapRequestBuilder animateGif(boolean animateGif) {
     }
 
     @Override
-    public IonBitmapRequestBuilder mipmap() {
-        if (resizeWidth > 0 || resizeHeight > 0)
-            throw new IllegalStateException("Can't mipmap after resize has been called.");
-        mipmap = true;
-        resizeWidth = 0;
-        resizeHeight = 0;
+    public IonBitmapRequestBuilder deepZoom() {
+        return deepZoom(true);
+    }
+
+    @Override
+    public IonBitmapRequestBuilder deepZoom(boolean deepZoom) {
+        this.deepZoom = deepZoom;
+        if (deepZoom) {
+            if (resizeWidth > 0 || resizeHeight > 0)
+                throw new IllegalStateException("Can't decoder after resize has been called.");
+            resizeWidth = 0;
+            resizeHeight = 0;
+        }
         return this;
     }
 }
diff --git a/ion/src/com/koushikdutta/ion/IonDrawable.java b/ion/src/com/koushikdutta/ion/IonDrawable.java
index a5afd51e..8818d580 100644
--- a/ion/src/com/koushikdutta/ion/IonDrawable.java
+++ b/ion/src/com/koushikdutta/ion/IonDrawable.java
@@ -6,7 +6,6 @@
 import android.graphics.ColorFilter;
 import android.graphics.Paint;
 import android.graphics.PixelFormat;
-import android.graphics.Point;
 import android.graphics.Rect;
 import android.graphics.drawable.Drawable;
 import android.os.Looper;
@@ -21,7 +20,6 @@
 import com.koushikdutta.ion.bitmap.BitmapInfo;
 
 import java.lang.ref.WeakReference;
-import java.net.ResponseCache;
 
 /**
  * Created by koush on 6/8/13.
@@ -157,6 +155,7 @@ public IonDrawable(Resources resources, ImageView imageView) {
     int currentFrame;
     private boolean invalidateScheduled;
     private int textureDim;
+    private int maxLevel;
     public IonDrawable setBitmap(BitmapInfo info, int loadedFrom) {
         this.loadedFrom = loadedFrom;
         requestCount++;
@@ -174,7 +173,7 @@ public IonDrawable setBitmap(BitmapInfo info, int loadedFrom) {
             return this;
         }
 
-        if (info.mipmap != null) {
+        if (info.decoder != null) {
             // find number of tiles across to fit
             double wlevel = (double)info.originalSize.x / TILE_DIM;
             double hlevel = (double)info.originalSize.y / TILE_DIM;
@@ -184,11 +183,11 @@ public IonDrawable setBitmap(BitmapInfo info, int loadedFrom) {
             double level = Math.max(wlevel, hlevel);
             level = Math.log(level) / LOG_2;
 
-            int l = (int)Math.ceil(level);
+            maxLevel = (int)Math.ceil(level);
 
             // now, we know the entire image will fit in a square image of
             // this dimension:
-            textureDim = TILE_DIM << l;
+            textureDim = TILE_DIM << maxLevel;
         }
 
         callback.bitmapKey = info.key;
@@ -248,10 +247,10 @@ private Drawable tryGetErrorResource() {
     @Override
     public int getIntrinsicWidth() {
         if (info != null) {
+            if (info.decoder != null)
+                return info.originalSize.x;
             if (info.bitmaps != null)
                 return info.bitmaps[0].getScaledWidth(resources.getDisplayMetrics().densityDpi);
-            if (info.mipmap != null)
-                return info.originalSize.x;
         }
         if (resizeWidth > 0)
             return resizeWidth;
@@ -273,10 +272,10 @@ public int getIntrinsicWidth() {
     @Override
     public int getIntrinsicHeight() {
         if (info != null) {
+            if (info.decoder != null)
+                return info.originalSize.y;
             if (info.bitmaps != null)
                 return info.bitmaps[0].getScaledHeight(resources.getDisplayMetrics().densityDpi);
-            if (info.mipmap != null)
-                return info.originalSize.y;
         }
         if (resizeHeight > 0)
             return resizeHeight;
@@ -350,36 +349,22 @@ public void draw(Canvas canvas) {
             }
         }
 
-        if (info.bitmaps != null) {
-            paint.setAlpha((int)destAlpha);
-            canvas.drawBitmap(info.bitmaps[currentFrame % info.bitmaps.length], null, getBounds(), paint);
-            paint.setAlpha(0xFF);
-            if (info.delays != null) {
-                int delay = info.delays[currentFrame % info.delays.length];
-                if (!invalidateScheduled) {
-                    invalidateScheduled = true;
-                    unscheduleSelf(invalidate);
-                    scheduleSelf(invalidate, SystemClock.uptimeMillis() + Math.max(delay, 100));
-                }
-            }
-        }
-        else if (info.mipmap != null) {
+        if (info.decoder != null) {
             // zoom 0: entire image fits in a TILE_DIMxTILE_DIM square
 
-
+            // draw base bitmap for empty tiles
             // figure out zoom level
             // figure out which tiles need rendering
-            // fetch anything that needs fetching
             // draw stuff that needs drawing
+            // missing tile? fetch it
             // use parent level tiles for tiles that do not exist
-            // crossfading?
-//            System.out.println(info.mipmap);
+
+            // TODO: crossfading?
 
             Rect clip = canvas.getClipBounds();
             Rect bounds = getBounds();
 
             float zoom = (float)canvas.getWidth() / (float)clip.width();
-//            double level = Math.abs(Math.round(Math.log(zoom) / Math.log(2)));
 
             float zoomWidth = zoom * bounds.width();
             float zoomHeight = zoom * bounds.height();
@@ -388,25 +373,32 @@ else if (info.mipmap != null) {
             double hlevel = Math.log(zoomHeight/ TILE_DIM) / LOG_2;
             double maxLevel = Math.max(wlevel, hlevel);
 
-//            System.out.println("clip: " + clip);
-//            System.out.println("zoomWidth: " + zoomWidth);
-//            System.out.println("zoomHeight: " + zoomHeight);
-//            System.out.println("level: " + maxLevel);
-
             int visibleLeft = Math.max(0, clip.left);
             int visibleRight = Math.min(bounds.width(), clip.right);
             int visibleTop = Math.max(0, clip.top);
             int visibleBottom = Math.min(bounds.height(), clip.bottom);
             int level = (int)Math.ceil(maxLevel);
+            level = Math.min(this.maxLevel, level);
             int levelTiles = 1 << level;
-            int levelDim = levelTiles * TILE_DIM;
-            Rect visible = new Rect(visibleLeft, visibleTop, visibleRight, visibleBottom);
-//            System.out.println("visible: " + visible);
-
             int textureTileDim = textureDim / levelTiles;
-
-            paint.setColor(Color.BLACK);
-            canvas.drawRect(getBounds(), paint);
+//            System.out.println("textureTileDim: " + textureTileDim);
+
+//            System.out.println(info.key + " visible: " + new Rect(visibleLeft, visibleTop, visibleRight, visibleBottom));
+
+            final boolean DEBUG_ZOOM = false;
+            if (info.bitmaps != null && info.bitmaps[0] != null) {
+                canvas.drawBitmap(info.bitmaps[0], null, getBounds(), paint);
+                if (DEBUG_ZOOM) {
+                    paint.setColor(Color.RED);
+                    paint.setAlpha(0x80);
+                    canvas.drawRect(getBounds(), paint);
+                    paint.setAlpha(0xFF);
+                }
+            }
+            else {
+                paint.setColor(Color.BLACK);
+                canvas.drawRect(getBounds(), paint);
+            }
 
             int sampleSize = 1;
             while (textureTileDim / sampleSize > TILE_DIM)
@@ -416,18 +408,20 @@ else if (info.mipmap != null) {
                 int top = textureTileDim * y;
                 int bottom = textureTileDim * (y + 1);
                 bottom = Math.min(bottom, bounds.bottom);
+                // TODO: start at visible pos
                 if (bottom < visibleTop)
                     continue;
                 if (top > visibleBottom)
-                    continue;
+                    break;
                 for (int x = 0; x < levelTiles; x++) {
                     int left = textureTileDim * x;
                     int right = textureTileDim * (x + 1);
                     right = Math.min(right, bounds.right);
+                    // TODO: start at visible pos
                     if (right < visibleLeft)
                         continue;
                     if (left > visibleRight)
-                        continue;
+                        break;
 
                     Rect texRect = new Rect(left, top, right, bottom);
 
@@ -435,27 +429,88 @@ else if (info.mipmap != null) {
 //                    System.out.println("rendering: " + texRect + " for: " + bounds);
                     String tileKey = ResponseCacheMiddleware.toKeyString(info.key + "," + level + "," + x + "," + y);
                     BitmapInfo tile = ion.bitmapCache.get(tileKey);
-                    if (tile != null) {
+                    if (tile != null && tile.bitmaps != null) {
                         // render it
-                        if (tile.bitmaps != null) {
-//                            System.out.println("bitmap is: " + tile.bitmaps[0].getWidth() + "x" + tile.bitmaps[0].getHeight());
-                            canvas.drawBitmap(tile.bitmaps[0], null, texRect, paint);
-                        }
+//                        System.out.println("bitmap is: " + tile.bitmaps[0].getWidth() + "x" + tile.bitmaps[0].getHeight());
+                        canvas.drawBitmap(tile.bitmaps[0], null, texRect, paint);
                         continue;
                     }
 
+                    // TODO: cancellation of unnecessary regions when fast pan/zooming
                     if (ion.bitmapsPending.tag(tileKey) == null) {
                         // fetch it
-                        LoadBitmapRegion region = new LoadBitmapRegion(ion, tileKey, info.mipmap, texRect, sampleSize);
+//                        System.out.println(info.key + ": fetching region: " + texRect + " sample size: " + sampleSize);
+                        LoadBitmapRegion region = new LoadBitmapRegion(ion, tileKey, info.decoder, texRect, sampleSize);
                     }
                     ion.bitmapsPending.add(tileKey, tileCallback);
-                }
-            }
 
+                    int parentLeft = 0;
+                    int parentTop = 0;
+                    int parentUp = 1;
+                    int parentLevel = level - parentUp;
+                    if (x % 2 == 1)
+                        parentLeft++;
+                    if (y % 2 == 1)
+                        parentTop++;
+                    int parentX = x >> 1;
+                    int parentY = y >> 1;
+
+                    while (parentLevel >= 0) {
+                        tileKey = ResponseCacheMiddleware.toKeyString(info.key + "," + parentLevel + "," + parentX + "," + parentY);
+                        tile = ion.bitmapCache.get(tileKey);
+                        if (tile != null && tile.bitmaps != null)
+                            break;
+                        if (parentX % 2 == 1) {
+                            parentLeft += 1 << parentUp;
+                        }
+                        if (parentY % 2 == 1) {
+                            parentTop += 1 << parentUp;
+                        }
+                        parentLevel--;
+                        parentUp++;
+                        parentX >>= 1;
+                        parentY >>= 1;
+                    }
 
-//            paint.setColor(Color.RED);
-//            canvas.drawRect(getBounds(), paint);
-//            paint.reset();
+                    // well, i give up
+                    if (tile == null || tile.bitmaps == null)
+                        continue;
+
+
+                    int subLevelTiles = 1 << parentLevel;
+                    int subtileDim = textureDim / subLevelTiles;
+                    int subSampleSize = 1;
+                    while (subtileDim / subSampleSize > TILE_DIM)
+                        subSampleSize <<= 1;
+                    int subTextureDim = subtileDim / subSampleSize;
+//                    System.out.println(String.format("falling back for %s,%s,%s to %s,%s,%s: %s,%s (%s to %s)", x, y, level, parentX, parentY, parentLevel, parentLeft, parentTop, subTextureDim, subTextureDim >> parentUp));
+                    subTextureDim >>= parentUp;
+                    int sourceLeft = subTextureDim * parentLeft;
+                    int sourceTop = subTextureDim * parentTop;
+                    Rect sourceRect = new Rect(sourceLeft, sourceTop, sourceLeft + subTextureDim, sourceTop + subTextureDim);
+                    canvas.drawBitmap(tile.bitmaps[0], sourceRect, texRect, paint);
+
+                    if (DEBUG_ZOOM) {
+                        paint.setColor(Color.RED);
+                        paint.setAlpha(0x80);
+                        canvas.drawRect(texRect, paint);
+                        paint.setAlpha(0xFF);
+                    }
+                }
+            }
+        }
+        else if (info.bitmaps != null) {
+            paint.setAlpha((int)destAlpha);
+            canvas.drawBitmap(info.bitmaps[currentFrame % info.bitmaps.length], null, getBounds(), paint);
+            paint.setAlpha(0xFF);
+            if (info.delays != null) {
+                int delay = info.delays[currentFrame % info.delays.length];
+                if (!invalidateScheduled) {
+                    invalidateScheduled = true;
+                    unscheduleSelf(invalidate);
+                    scheduleSelf(invalidate, SystemClock.uptimeMillis() + Math.max(delay, 100));
+                }
+            }
         }
         else {
             Drawable error = tryGetErrorResource();
diff --git a/ion/src/com/koushikdutta/ion/IonRequestBuilder.java b/ion/src/com/koushikdutta/ion/IonRequestBuilder.java
index a3a58392..9aedd7ed 100644
--- a/ion/src/com/koushikdutta/ion/IonRequestBuilder.java
+++ b/ion/src/com/koushikdutta/ion/IonRequestBuilder.java
@@ -45,11 +45,12 @@
 import com.koushikdutta.async.parser.AsyncParser;
 import com.koushikdutta.async.parser.DocumentParser;
 import com.koushikdutta.async.parser.StringParser;
+import com.koushikdutta.async.stream.FileDataSink;
 import com.koushikdutta.async.stream.OutputStreamDataSink;
 import com.koushikdutta.ion.Loader.LoaderEmitter;
-import com.koushikdutta.ion.builder.LoadBuilder;
 import com.koushikdutta.ion.builder.Builders;
 import com.koushikdutta.ion.builder.FutureBuilder;
+import com.koushikdutta.ion.builder.LoadBuilder;
 import com.koushikdutta.ion.future.ResponseFuture;
 import com.koushikdutta.ion.gson.GsonBody;
 import com.koushikdutta.ion.gson.GsonParser;
@@ -60,7 +61,6 @@
 import org.w3c.dom.Document;
 
 import java.io.File;
-import java.io.FileOutputStream;
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.lang.ref.WeakReference;
@@ -298,6 +298,12 @@ private AsyncHttpRequest prepareRequest(URI uri, AsyncHttpRequestBody wrappedBod
         return request;
     }
 
+    static interface LoadRequestCallback {
+        boolean loadRequest(AsyncHttpRequest request);
+    }
+
+    LoadRequestCallback loadRequestCallback;
+
     private <T> void getLoaderEmitter(final EmitterTransform<T> ret) {
         URI uri = prepareURI();
         if (uri == null) {
@@ -339,7 +345,44 @@ public void run() {
 
         AsyncHttpRequest request = prepareRequest(uri, wrappedBody);
         ret.initialRequest = request;
+        resolveAndLoadRequest(request, ret);
+    }
+
+    <T> void resolveAndLoadRequest(final AsyncHttpRequest request, final EmitterTransform<T> ret) {
+        Future<AsyncHttpRequest> resolved = resolveRequest(request, ret);
+        if (resolved != null) {
+            resolved.setCallback(new FutureCallback<AsyncHttpRequest>() {
+                @Override
+                public void onCompleted(Exception e, final AsyncHttpRequest result) {
+                    if (e != null) {
+                        ret.setComplete(e);
+                        return;
+                    }
+                    ret.finalRequest = result;
+                    resolveAndLoadRequest(result, ret);
+                }
+            });
+            return;
+        }
+        if (Looper.getMainLooper().getThread() != Thread.currentThread()) {
+            AsyncServer.post(Ion.mainHandler, new Runnable() {
+                @Override
+                public void run() {
+                    invokeLoadRequest(request, ret);
+                }
+            });
+            return;
+        }
+        invokeLoadRequest(request, ret);
+    }
 
+    <T> void invokeLoadRequest(final AsyncHttpRequest request, final EmitterTransform<T> ret) {
+        if (loadRequestCallback == null || loadRequestCallback.loadRequest(request))
+            loadRequest(request, ret);
+    }
+
+    <T> void loadRequest(AsyncHttpRequest request, final EmitterTransform<T> ret) {
+        // now attempt to fetch it directly
         for (Loader loader: ion.loaders) {
             Future<DataEmitter> emitter = loader.load(ion, request, ret);
             if (emitter != null) {
@@ -351,6 +394,17 @@ public void run() {
         ret.setComplete(new Exception("Unknown uri scheme"));
     }
 
+    <T> Future<AsyncHttpRequest> resolveRequest(AsyncHttpRequest request, final EmitterTransform<T> ret) {
+        // first attempt to resolve the url
+        for (Loader loader: ion.loaders) {
+            Future<AsyncHttpRequest> resolved = loader.resolve(ion, request);
+            if (resolved != null)
+                return resolved;
+
+        }
+        return null;
+    }
+
     // transforms a LoaderEmitter, which is a DataEmitter and all associated properties about the data source
     // into the final result.
     class EmitterTransform<T> extends TransformFuture<T, LoaderEmitter> implements ResponseFuture<T> {
@@ -627,20 +681,13 @@ public void onCompleted(Exception e, T result) {
     }
 
     @Override
-    public ResponseFuture<File> write(final File file) {
-        try {
-            return execute(new OutputStreamDataSink(ion.getServer(), new FileOutputStream(file)), true, file, new Runnable() {
-                @Override
-                public void run() {
-                    file.delete();
-                }
-            });
-        }
-        catch (Exception e) {
-            EmitterTransform<File> ret = new EmitterTransform<File>(null);
-            ret.setComplete(e);
-            return ret;
-        }
+    public EmitterTransform<File> write(final File file) {
+        return execute(new FileDataSink(ion.getServer(), file), true, file, new Runnable() {
+            @Override
+            public void run() {
+                file.delete();
+            }
+        });
     }
 
     Multimap bodyParameters;
diff --git a/ion/src/com/koushikdutta/ion/LoadBitmap.java b/ion/src/com/koushikdutta/ion/LoadBitmap.java
index 7819bc44..140724c7 100644
--- a/ion/src/com/koushikdutta/ion/LoadBitmap.java
+++ b/ion/src/com/koushikdutta/ion/LoadBitmap.java
@@ -1,8 +1,10 @@
 package com.koushikdutta.ion;
 
 import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
 import android.graphics.Point;
 import android.os.Looper;
+import android.text.TextUtils;
 import android.util.Log;
 
 import com.koushikdutta.async.ByteBufferList;
@@ -16,33 +18,18 @@
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 
-class LoadBitmap extends LoadBitmapBase implements FutureCallback<ByteBufferList> {
+class LoadBitmap extends LoadBitmapEmitter implements FutureCallback<ByteBufferList> {
     int resizeWidth;
     int resizeHeight;
-    IonRequestBuilder.EmitterTransform<ByteBufferList> emitterTransform;
-    boolean animateGif;
 
     public LoadBitmap(Ion ion, String urlKey, boolean put, int resizeWidth, int resizeHeight, boolean animateGif, IonRequestBuilder.EmitterTransform<ByteBufferList> emitterTransform) {
-        super(ion, urlKey, put);
+        super(ion, urlKey, put, animateGif, emitterTransform);
         this.resizeWidth = resizeWidth;
         this.resizeHeight = resizeHeight;
         this.animateGif = animateGif;
         this.emitterTransform = emitterTransform;
     }
 
-    private boolean isGif() {
-        if (emitterTransform == null)
-            return false;
-        if (emitterTransform.finalRequest != null) {
-            URI uri = emitterTransform.finalRequest.getUri();
-            if (uri != null && uri.toString().endsWith(".gif"))
-                return true;
-        }
-        if (emitterTransform.headers == null)
-            return false;
-        return "image/gif".equals(emitterTransform.headers.get("Content-Type"));
-    }
-
     @Override
     public void onCompleted(Exception e, final ByteBufferList result) {
         if (e != null) {
@@ -68,15 +55,10 @@ public void run() {
                     Bitmap[] bitmaps;
                     int[] delays;
                     Point size;
-                    if (!isGif()) {
-                        size = new Point();
-                        Bitmap bitmap = ion.bitmapCache.loadBitmap(bb.array(), bb.arrayOffset() + bb.position(), bb.remaining(), resizeWidth, resizeHeight, size);
-                        if (bitmap == null)
-                            throw new Exception("failed to load bitmap");
-                        bitmaps = new Bitmap[] { bitmap };
-                        delays = null;
-                    }
-                    else {
+                    BitmapFactory.Options options = ion.bitmapCache.prepareBitmapOptions(bb.array(), bb.arrayOffset() + bb.position(), bb.remaining(), resizeWidth, resizeHeight);
+                    if (options == null)
+                        throw new Exception("BitmapFactory.Options failed to load");
+                    if (animateGif && TextUtils.equals("image/gif", options.outMimeType)) {
                         size = null;
                         GifDecoder decoder = new GifDecoder(bb.array(), bb.arrayOffset() + bb.position(), bb.remaining(), new GifAction() {
                             @Override
@@ -98,9 +80,16 @@ public boolean parseOk(boolean parseStatus, int frameIndex) {
                                 size = new Point(bitmap.getWidth(), bitmap.getHeight());
                         }
                     }
+                    else {
+                        size = new Point(options.outWidth, options.outHeight);
+                        Bitmap bitmap = ion.bitmapCache.loadBitmap(bb.array(), bb.arrayOffset() + bb.position(), bb.remaining(), options);
+                        if (bitmap == null)
+                            throw new Exception("failed to load bitmap");
+                        bitmaps = new Bitmap[] { bitmap };
+                        delays = null;
+                    }
 
-                    BitmapInfo info = new BitmapInfo(bitmaps, size);
-                    info.key = key;
+                    BitmapInfo info = new BitmapInfo(key, bitmaps, size);
                     info.delays = delays;
                     if (emitterTransform != null)
                         info.loadedFrom = emitterTransform.loadedFrom();
diff --git a/ion/src/com/koushikdutta/ion/LoadBitmapEmitter.java b/ion/src/com/koushikdutta/ion/LoadBitmapEmitter.java
new file mode 100644
index 00000000..6f1888d9
--- /dev/null
+++ b/ion/src/com/koushikdutta/ion/LoadBitmapEmitter.java
@@ -0,0 +1,12 @@
+package com.koushikdutta.ion;
+
+class LoadBitmapEmitter extends LoadBitmapBase {
+    IonRequestBuilder.EmitterTransform emitterTransform;
+    boolean animateGif;
+
+    public LoadBitmapEmitter(Ion ion, String urlKey, boolean put, boolean animateGif, IonRequestBuilder.EmitterTransform emitterTransform) {
+        super(ion, urlKey, put);
+        this.animateGif = animateGif;
+        this.emitterTransform = emitterTransform;
+    }
+}
\ No newline at end of file
diff --git a/ion/src/com/koushikdutta/ion/LoadBitmapRegion.java b/ion/src/com/koushikdutta/ion/LoadBitmapRegion.java
new file mode 100644
index 00000000..2d87bf86
--- /dev/null
+++ b/ion/src/com/koushikdutta/ion/LoadBitmapRegion.java
@@ -0,0 +1,33 @@
+package com.koushikdutta.ion;
+
+import android.graphics.Bitmap;
+import android.graphics.BitmapRegionDecoder;
+import android.graphics.Point;
+import android.graphics.Rect;
+
+import com.koushikdutta.ion.bitmap.BitmapInfo;
+
+/**
+ * Created by koush on 1/29/14.
+ */
+public class LoadBitmapRegion extends BitmapCallback {
+    public LoadBitmapRegion(final Ion ion, final String key, final BitmapRegionDecoder decoder, final Rect region, final int inSampleSize) {
+        super(ion, key, true);
+
+        Ion.getBitmapLoadExecutorService().execute(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    Bitmap bitmap = ion.bitmapCache.loadRegion(decoder, region, inSampleSize);
+                    if (bitmap == null)
+                        throw new Exception("failed to load bitmap region");
+                    BitmapInfo info = new BitmapInfo(key, new Bitmap[] { bitmap }, new Point(bitmap.getWidth(), bitmap.getHeight()));
+                    report(null, info);
+                }
+                catch (Exception e) {
+                    report(e, null);
+                }
+            }
+        });
+    }
+}
diff --git a/ion/src/com/koushikdutta/ion/LoadDeepZoom.java b/ion/src/com/koushikdutta/ion/LoadDeepZoom.java
new file mode 100644
index 00000000..54fdeff9
--- /dev/null
+++ b/ion/src/com/koushikdutta/ion/LoadDeepZoom.java
@@ -0,0 +1,102 @@
+package com.koushikdutta.ion;
+
+import android.annotation.TargetApi;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.BitmapRegionDecoder;
+import android.graphics.Point;
+import android.graphics.Rect;
+import android.os.Build;
+import android.text.TextUtils;
+
+import com.koushikdutta.async.future.FutureCallback;
+import com.koushikdutta.async.http.libcore.IoUtils;
+import com.koushikdutta.ion.bitmap.BitmapInfo;
+import com.koushikdutta.ion.gif.GifAction;
+import com.koushikdutta.ion.gif.GifDecoder;
+
+import java.io.File;
+import java.io.FileInputStream;
+
+/**
+ * Created by koush on 1/5/14.
+ */
+@TargetApi(Build.VERSION_CODES.GINGERBREAD_MR1)
+public class LoadDeepZoom extends LoadBitmapEmitter implements FutureCallback<File> {
+    public LoadDeepZoom(Ion ion, String urlKey, boolean animateGif, IonRequestBuilder.EmitterTransform<File> emitterTransform) {
+        super(ion, urlKey, true, animateGif, emitterTransform);
+    }
+
+    @Override
+    public void onCompleted(Exception e, final File file) {
+        if (e != null) {
+            report(e, null);
+            return;
+        }
+
+        if (ion.bitmapsPending.tag(key) != this) {
+//            Log.d("IonBitmapLoader", "Bitmap load cancelled (no longer needed)");
+            return;
+        }
+
+        Ion.getBitmapLoadExecutorService().execute(new Runnable() {
+            @Override
+            public void run() {
+                FileInputStream fin = null;
+                try {
+                    BitmapFactory.Options options = ion.getBitmapCache().prepareBitmapOptions(file, 0, 0);
+                    if (options == null)
+                        throw new Exception("BitmapFactory.Options failed to load");
+                    if (animateGif && TextUtils.equals("image/gif", options.outMimeType)) {
+                        fin = new FileInputStream(file);
+                        GifDecoder decoder = new GifDecoder(fin, new GifAction() {
+                            @Override
+                            public boolean parseOk(boolean parseStatus, int frameIndex) {
+                                return animateGif;
+                            }
+                        });
+                        decoder.run();
+                        if (decoder.getFrameCount() == 0)
+                            throw new Exception("failed to load gif");
+                        Bitmap[] bitmaps = new Bitmap[decoder.getFrameCount()];
+                        int[] delays = decoder.getDelays();
+                        Point size = null;
+                        for (int i = 0; i < decoder.getFrameCount(); i++) {
+                            Bitmap bitmap = decoder.getFrameImage(i);
+                            if (bitmap == null)
+                                throw new Exception("failed to load gif frame");
+                            bitmaps[i] = bitmap;
+                            if (size == null)
+                                size = new Point(bitmap.getWidth(), bitmap.getHeight());
+                        }
+                        BitmapInfo info = new BitmapInfo(key, bitmaps, size);
+                        info.delays = delays;
+                        if (emitterTransform != null)
+                            info.loadedFrom = emitterTransform.loadedFrom();
+                        else
+                            info.loadedFrom = Loader.LoaderEmitter.LOADED_FROM_CACHE;
+                        report(null, info);
+                        return;
+                    }
+
+                    BitmapRegionDecoder decoder = BitmapRegionDecoder.newInstance(file.toString(), false);
+                    Point size = new Point(decoder.getWidth(), decoder.getHeight());
+                    Bitmap bitmap = decoder.decodeRegion(new Rect(0, 0, size.x, size.y), options);
+                    if (bitmap == null)
+                        throw new Exception("unable to load decoder");
+                    Bitmap[] bitmaps = new Bitmap[] { bitmap };
+
+                    BitmapInfo info = new BitmapInfo(key, bitmaps, size);
+                    info.decoder = decoder;
+                    info.loadedFrom = Loader.LoaderEmitter.LOADED_FROM_NETWORK;
+                    report(null, info);
+                } catch (Exception e) {
+                    report(e, null);
+                }
+                finally {
+                    IoUtils.closeQuietly(fin);
+                }
+            }
+        });
+    }
+}
diff --git a/ion/src/com/koushikdutta/ion/Loader.java b/ion/src/com/koushikdutta/ion/Loader.java
index bd95ea1b..1d612b4e 100644
--- a/ion/src/com/koushikdutta/ion/Loader.java
+++ b/ion/src/com/koushikdutta/ion/Loader.java
@@ -72,10 +72,19 @@ public AsyncHttpRequest getRequest() {
      * returns a future if the laoder can handle the request as a bitmap
      * otherwise it returns null
      * @param ion
+     * @param key
      * @param uri
      * @param resizeWidth
      * @param resizeHeight
      * @return
      */
-    public Future<BitmapInfo> loadBitmap(Ion ion, String uri, int resizeWidth, int resizeHeight);
+    public Future<BitmapInfo> loadBitmap(Ion ion, String key, String uri, int resizeWidth, int resizeHeight);
+
+    /**
+     * Resolve a request into another request.
+     * @param ion
+     * @param request
+     * @return
+     */
+    public Future<AsyncHttpRequest> resolve(Ion ion, AsyncHttpRequest request);
 }
diff --git a/ion/src/com/koushikdutta/ion/TransformBitmap.java b/ion/src/com/koushikdutta/ion/TransformBitmap.java
index 2b85d8ea..d08e3d18 100644
--- a/ion/src/com/koushikdutta/ion/TransformBitmap.java
+++ b/ion/src/com/koushikdutta/ion/TransformBitmap.java
@@ -10,6 +10,7 @@
 import com.koushikdutta.ion.bitmap.BitmapInfo;
 import com.koushikdutta.ion.bitmap.Transform;
 
+import java.io.File;
 import java.io.FileInputStream;
 import java.io.InputStream;
 import java.io.OutputStream;
@@ -32,23 +33,14 @@ public void run() {
                 }
 
                 try {
-                    DiskLruCache.Snapshot snapshot = ion.responseCache.getDiskLruCache().get(transformKey);
-                    try {
-                        InputStream in = snapshot.getInputStream(0);
-                        assert in instanceof FileInputStream;
-                        Point size = new Point();
-                        Bitmap bitmap = ion.getBitmapCache().loadBitmap(in, -1, -1, size);
-                        in.close();
-                        if (bitmap == null)
-                            throw new Exception("Bitmap failed to load");
-
-                        BitmapInfo info = new BitmapInfo(new Bitmap[] { bitmap }, size);
-                        info.loadedFrom =  Loader.LoaderEmitter.LOADED_FROM_CACHE;
-                        info.key = transformKey;
-                        callback.report(null, info);
-                    } finally {
-                        snapshot.close();
-                    }
+                    File file = ion.responseCache.getDiskLruCache().getFile(transformKey, 0);
+                    Bitmap bitmap = ion.getBitmapCache().loadBitmap(file, null);
+                    if (bitmap == null)
+                        throw new Exception("Bitmap failed to load");
+                    Point size = new Point(bitmap.getWidth(), bitmap.getHeight());
+                    BitmapInfo info = new BitmapInfo(transformKey, new Bitmap[] { bitmap }, size);
+                    info.loadedFrom =  Loader.LoaderEmitter.LOADED_FROM_CACHE;
+                    callback.report(null, info);
                 }
                 catch (OutOfMemoryError e) {
                     callback.report(new Exception(e), null);
@@ -105,10 +97,9 @@ public void run() {
                                 size = new Point(bitmap.getWidth(), bitmap.getHeight());
                         }
                     }
-                    info = new BitmapInfo(bitmaps, size);
+                    info = new BitmapInfo(key, bitmaps, size);
                     info.delays = result.delays;
                     info.loadedFrom = result.loadedFrom;
-                    info.key = key;
                     report(null, info);
                 }
                 catch (OutOfMemoryError e) {
diff --git a/ion/src/com/koushikdutta/ion/bitmap/BitmapInfo.java b/ion/src/com/koushikdutta/ion/bitmap/BitmapInfo.java
index 47adce4f..1af37ce5 100644
--- a/ion/src/com/koushikdutta/ion/bitmap/BitmapInfo.java
+++ b/ion/src/com/koushikdutta/ion/bitmap/BitmapInfo.java
@@ -11,20 +11,21 @@
  * Created by koush on 6/12/13.
  */
 public class BitmapInfo {
-    public BitmapInfo(Bitmap[] bitmaps, Point originalSize) {
+    public BitmapInfo(String key, Bitmap[] bitmaps, Point originalSize) {
         this.originalSize = originalSize;
         this.bitmaps = bitmaps;
+        this.key = key;
     }
 
     final public Point originalSize;
     public long loadTime = System.currentTimeMillis();
     public long drawTime;
-    public String key;
+    final public String key;
     public int loadedFrom;
     final public Bitmap[] bitmaps;
     public int[] delays;
     public Exception exception;
-    public BitmapRegionDecoder mipmap;
+    public BitmapRegionDecoder decoder;
 
     public int sizeOf() {
         if (bitmaps == null)
diff --git a/ion/src/com/koushikdutta/ion/bitmap/IonBitmapCache.java b/ion/src/com/koushikdutta/ion/bitmap/IonBitmapCache.java
index 9ec6e077..68c11fd0 100644
--- a/ion/src/com/koushikdutta/ion/bitmap/IonBitmapCache.java
+++ b/ion/src/com/koushikdutta/ion/bitmap/IonBitmapCache.java
@@ -17,9 +17,12 @@
 import android.util.Log;
 import android.view.WindowManager;
 
+import com.koushikdutta.async.http.libcore.IoUtils;
 import com.koushikdutta.ion.Ion;
 
 import java.io.BufferedInputStream;
+import java.io.File;
+import java.io.FileInputStream;
 import java.io.InputStream;
 
 /**
@@ -116,30 +119,37 @@ private Point computeTarget(int minx, int miny) {
         return new Point(targetWidth, targetHeight);
     }
 
-    public Bitmap loadBitmap(byte[] bytes, int offset, int length, int minx, int miny, Point outSize) {
-        assert Thread.currentThread() != Looper.getMainLooper().getThread();
+    public BitmapFactory.Options prepareBitmapOptions(File file, int minx, int miny) {
+        BitmapFactory.Options o = new BitmapFactory.Options();
+        o.inJustDecodeBounds = true;
+        BitmapFactory.decodeFile(file.toString(), o);
+        return prepareBitmapOptions(o, minx, miny);
+    }
+
+    private BitmapFactory.Options prepareBitmapOptions(BitmapFactory.Options o, int minx, int miny) {
+        if (o.outWidth < 0 || o.outHeight < 0)
+            return null;
         Point target = computeTarget(minx, miny);
+        int scale = Math.max(o.outWidth / target.x, o.outHeight / target.y);
+        BitmapFactory.Options ret = new BitmapFactory.Options();
+        ret.inSampleSize = scale;
+        ret.outWidth = o.outWidth;
+        ret.outHeight = o.outHeight;
+        ret.outMimeType = o.outMimeType;
+        return ret;
+    }
 
-        boolean decodedBounds = false;
+    public BitmapFactory.Options prepareBitmapOptions(byte[] bytes, int offset, int length, int minx, int miny) {
         BitmapFactory.Options o = new BitmapFactory.Options();
-        if (target.x != Integer.MAX_VALUE || target.y != Integer.MAX_VALUE) {
-            decodedBounds = true;
-            o.inJustDecodeBounds = true;
-            BitmapFactory.decodeByteArray(bytes, offset, length, o);
-            outSize.x = o.outWidth;
-            outSize.y = o.outHeight;
-            if (o.outWidth < 0 || o.outHeight < 0)
-                return null;
-            int scale = Math.max(o.outWidth / target.x, o.outHeight / target.y);
-            o = new BitmapFactory.Options();
-            o.inSampleSize = scale;
-        }
+        o.inJustDecodeBounds = true;
+        BitmapFactory.decodeByteArray(bytes, offset, length, o);
+        return prepareBitmapOptions(o, minx, miny);
+    }
+
+    public Bitmap loadBitmap(byte[] bytes, int offset, int length, BitmapFactory.Options o) {
+        assert Thread.currentThread() != Looper.getMainLooper().getThread();
 
         Bitmap bitmap = BitmapFactory.decodeByteArray(bytes, offset, length, o);
-        if (!decodedBounds) {
-            outSize.x = o.outWidth;
-            outSize.y = o.outHeight;
-        }
         if (bitmap == null)
             return null;
 
@@ -153,56 +163,30 @@ public Bitmap loadBitmap(byte[] bytes, int offset, int length, int minx, int min
     }
 
     @TargetApi(Build.VERSION_CODES.GINGERBREAD_MR1)
-    public Bitmap loadRegion(BitmapRegionDecoder decoder, Rect sourceRect, int inSampleSize) {
+    public Bitmap loadRegion(final BitmapRegionDecoder decoder, Rect sourceRect, int inSampleSize) {
         BitmapFactory.Options options = new BitmapFactory.Options();
         options.inSampleSize = inSampleSize;
         return decoder.decodeRegion(sourceRect, options);
     }
 
-    public Bitmap loadBitmap(InputStream stream, int minx, int miny, Point outSize) {
-        stream = new BufferedInputStream(stream, 64 * 1024);
+    public Bitmap loadBitmap(File file, BitmapFactory.Options o) {
+//        stream = new BufferedInputStream(stream, 64 * 1024);
         assert Thread.currentThread() != Looper.getMainLooper().getThread();
-        Point target = computeTarget(minx, miny);
 
         int rotation;
+        FileInputStream fin = null;
         try {
+            fin = new FileInputStream(file);
             byte[] bytes = new byte[50000];
-            stream.mark(Integer.MAX_VALUE);
-            int length = stream.read(bytes);
+            int length = fin.read(bytes);
             rotation = Exif.getOrientation(bytes, 0, length);
-            stream.reset();
         }
         catch (Exception e) {
             rotation = 0;
         }
+        IoUtils.closeQuietly(fin);
 
-        boolean decodedBounds = false;
-        BitmapFactory.Options o = new BitmapFactory.Options();
-        if (target.x != Integer.MAX_VALUE || target.y != Integer.MAX_VALUE) {
-            decodedBounds = true;
-            o.inJustDecodeBounds = true;
-            stream.mark(Integer.MAX_VALUE);
-            BitmapFactory.decodeStream(stream, null, o);
-            outSize.x = o.outWidth;
-            outSize.y = o.outHeight;
-            if (o.outWidth < 0 || o.outHeight < 0)
-                return null;
-            try {
-                stream.reset();
-            }
-            catch (Exception e) {
-                return null;
-            }
-            int scale = Math.max(o.outWidth / target.x, o.outHeight / target.y);
-            o = new BitmapFactory.Options();
-            o.inSampleSize = scale;
-        }
-
-        Bitmap bitmap = BitmapFactory.decodeStream(stream, null, o);
-        if (!decodedBounds) {
-            outSize.x = o.outWidth;
-            outSize.y = o.outHeight;
-        }
+        Bitmap bitmap = BitmapFactory.decodeFile(file.toString(), o);
         if (bitmap == null)
             return null;
 
diff --git a/ion/src/com/koushikdutta/ion/builder/ImageViewBuilder.java b/ion/src/com/koushikdutta/ion/builder/ImageViewBuilder.java
index df97d2b1..84c80751 100644
--- a/ion/src/com/koushikdutta/ion/builder/ImageViewBuilder.java
+++ b/ion/src/com/koushikdutta/ion/builder/ImageViewBuilder.java
@@ -86,11 +86,21 @@
     public I animateGif(boolean animateGif);
 
     /**
-     * Load the image view as a mipmap image. This allows extremely large images
+     * Load the ImageView with a deep zoomable image. This allows extremely large images
      * to be loaded, at full fidelity. Only portions of the image will be decoded,
      * on an as needed basis when rendering.
      * This only works on API level 10+, where BitmapRegionDecoder is available.
      * @return
      */
-    public I mipmap();
+    public I deepZoom();
+
+    /**
+     * If true, load the ImageView with a deep zoomable image. This allows extremely large images
+     * to be loaded, at full fidelity. Only portions of the image will be decoded,
+     * on an as needed basis when rendering.
+     * This only works on API level 10+, where BitmapRegionDecoder is available.
+     * @param deepZoom
+     * @return
+     */
+    public I deepZoom(boolean deepZoom);
 }
diff --git a/ion/src/com/koushikdutta/ion/loader/FileLoader.java b/ion/src/com/koushikdutta/ion/loader/FileLoader.java
index a8dd25ec..131913bf 100644
--- a/ion/src/com/koushikdutta/ion/loader/FileLoader.java
+++ b/ion/src/com/koushikdutta/ion/loader/FileLoader.java
@@ -1,6 +1,7 @@
 package com.koushikdutta.ion.loader;
 
 import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
 import android.graphics.Point;
 import android.util.Log;
 
@@ -29,12 +30,13 @@
     }
 
     @Override
-    public Future<BitmapInfo> loadBitmap(final Ion ion, final String uri, final int resizeWidth, final int resizeHeight) {
+    public Future<BitmapInfo> loadBitmap(final Ion ion, final String key, final String uri, final int resizeWidth, final int resizeHeight) {
         if (uri == null || !uri.startsWith("file:/"))
             return null;
 
         final SimpleFuture<BitmapInfo> ret = new SimpleFuture<BitmapInfo>();
 
+//        Log.d("FileLoader", "Loading file bitmap " + uri + " " + resizeWidth + "," + resizeHeight);
         Ion.getBitmapLoadExecutorService().execute(new Runnable() {
             @Override
             public void run() {
@@ -43,14 +45,16 @@ public void run() {
                     return;
                 }
                 try {
-                    FileInputStream fin = new FileInputStream(new File(URI.create(uri)));
-                    Point size = new Point();
-                    Bitmap bitmap = ion.getBitmapCache().loadBitmap(fin, resizeWidth, resizeHeight, size);
+                    File file = new File(URI.create(uri));
+                    BitmapFactory.Options options = ion.getBitmapCache().prepareBitmapOptions(file, resizeWidth, resizeHeight);
+                    if (options == null)
+                        throw new Exception("BitmapFactory.Options failed to load");
+                    Point size = new Point(options.outWidth, options.outHeight);
+                    Bitmap bitmap = ion.getBitmapCache().loadBitmap(file, options);
                     if (bitmap == null)
                         throw new Exception("Bitmap failed to load");
-                    BitmapInfo info = new BitmapInfo(new Bitmap[] { bitmap }, size);
+                    BitmapInfo info = new BitmapInfo(key, new Bitmap[] { bitmap }, size);
                     info.loadedFrom =  Loader.LoaderEmitter.LOADED_FROM_CACHE;
-                    fin.close();
                     ret.setComplete(info);
                 }
                 catch (OutOfMemoryError e) {
diff --git a/ion/src/com/koushikdutta/ion/loader/PackageIconLoader.java b/ion/src/com/koushikdutta/ion/loader/PackageIconLoader.java
index c43d7785..36550440 100644
--- a/ion/src/com/koushikdutta/ion/loader/PackageIconLoader.java
+++ b/ion/src/com/koushikdutta/ion/loader/PackageIconLoader.java
@@ -19,7 +19,7 @@
  */
 public class PackageIconLoader extends SimpleLoader {
     @Override
-    public Future<BitmapInfo> loadBitmap(final Ion ion, final String uri, int resizeWidth, int resizeHeight) {
+    public Future<BitmapInfo> loadBitmap(final Ion ion, final String key, final String uri, int resizeWidth, int resizeHeight) {
         final URI request = URI.create(uri);
         if (request == null || request.getScheme() == null || !request.getScheme().startsWith("package"))
             return null;
@@ -34,7 +34,7 @@ public void run() {
                     Bitmap bmp = ((BitmapDrawable)pm.getPackageInfo(pkg, 0).applicationInfo.loadIcon(pm)).getBitmap();
                     if (bmp == null)
                         throw new Exception("package icon failed to load");
-                    BitmapInfo info = new BitmapInfo(new Bitmap[] { bmp }, new Point(bmp.getWidth(), bmp.getHeight()));
+                    BitmapInfo info = new BitmapInfo(key, new Bitmap[] { bmp }, new Point(bmp.getWidth(), bmp.getHeight()));
                     info.loadedFrom =  Loader.LoaderEmitter.LOADED_FROM_CACHE;
                     ret.setComplete(info);
                 }
diff --git a/ion/src/com/koushikdutta/ion/loader/SimpleLoader.java b/ion/src/com/koushikdutta/ion/loader/SimpleLoader.java
index 934e16d1..0d6d8b18 100644
--- a/ion/src/com/koushikdutta/ion/loader/SimpleLoader.java
+++ b/ion/src/com/koushikdutta/ion/loader/SimpleLoader.java
@@ -25,7 +25,12 @@
     }
 
     @Override
-    public Future<BitmapInfo> loadBitmap(Ion ion, String uri, int resizeWidth, int resizeHeight) {
+    public Future<BitmapInfo> loadBitmap(Ion ion, String key, String uri, int resizeWidth, int resizeHeight) {
+        return null;
+    }
+
+    @Override
+    public Future<AsyncHttpRequest> resolve(Ion ion, AsyncHttpRequest request) {
         return null;
     }
 }
diff --git a/ion/src/com/koushikdutta/ion/loader/VideoLoader.java b/ion/src/com/koushikdutta/ion/loader/VideoLoader.java
index 443cb0ee..b5fd3cfb 100644
--- a/ion/src/com/koushikdutta/ion/loader/VideoLoader.java
+++ b/ion/src/com/koushikdutta/ion/loader/VideoLoader.java
@@ -77,7 +77,7 @@ public static Bitmap createVideoThumbnail(String filePath) {
     }
 
     @Override
-    public Future<BitmapInfo> loadBitmap(Ion ion, String uri, int resizeWidth, int resizeHeight) {
+    public Future<BitmapInfo> loadBitmap(Ion ion, final String key, String uri, int resizeWidth, int resizeHeight) {
         if (!uri.startsWith(ContentResolver.SCHEME_FILE))
             return null;
 
@@ -99,7 +99,7 @@ public void run() {
                     Bitmap bmp = createVideoThumbnail(file.getAbsolutePath());
                     if (bmp == null)
                         throw new Exception("video bitmap failed to load");
-                    BitmapInfo info = new BitmapInfo(new Bitmap[] { bmp }, new Point(bmp.getWidth(), bmp.getHeight()));
+                    BitmapInfo info = new BitmapInfo(key, new Bitmap[] { bmp }, new Point(bmp.getWidth(), bmp.getHeight()));
                     info.loadedFrom = LoaderEmitter.LOADED_FROM_CACHE;
                     ret.setComplete(info);
                 } catch (Exception e) {
