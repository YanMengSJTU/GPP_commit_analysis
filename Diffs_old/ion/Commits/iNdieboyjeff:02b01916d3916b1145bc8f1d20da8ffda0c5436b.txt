diff --git a/ion/src/com/koushikdutta/ion/IonBitmapRequestBuilder.java b/ion/src/com/koushikdutta/ion/IonBitmapRequestBuilder.java
index ed5c07bd..ae607c00 100644
--- a/ion/src/com/koushikdutta/ion/IonBitmapRequestBuilder.java
+++ b/ion/src/com/koushikdutta/ion/IonBitmapRequestBuilder.java
@@ -236,7 +236,6 @@ BitmapFetcher executeCache() {
 
     private IonDrawable setIonDrawable(ImageView imageView, BitmapInfo info, int loadedFrom) {
         IonDrawable ret = IonDrawable.getOrCreateIonDrawable(imageView)
-        .setMipmap(mipmap)
         .setBitmap(info, loadedFrom)
         .setSize(resizeWidth, resizeHeight)
         .setError(errorResource, errorDrawable)
diff --git a/ion/src/com/koushikdutta/ion/IonDrawable.java b/ion/src/com/koushikdutta/ion/IonDrawable.java
index 1f2969f8..bf1036b7 100644
--- a/ion/src/com/koushikdutta/ion/IonDrawable.java
+++ b/ion/src/com/koushikdutta/ion/IonDrawable.java
@@ -17,9 +17,11 @@
 
 import com.koushikdutta.async.future.FutureCallback;
 import com.koushikdutta.async.future.SimpleFuture;
+import com.koushikdutta.async.http.ResponseCacheMiddleware;
 import com.koushikdutta.ion.bitmap.BitmapInfo;
 
 import java.lang.ref.WeakReference;
+import java.net.ResponseCache;
 
 /**
  * Created by koush on 6/8/13.
@@ -37,7 +39,6 @@
     private boolean disableFadeIn;
     private int resizeWidth;
     private int resizeHeight;
-    private boolean mipmap;
 
     public IonDrawable cancel() {
         requestCount++;
@@ -149,6 +150,7 @@ public IonDrawable(Resources resources, ImageView imageView) {
 
     int currentFrame;
     private boolean invalidateScheduled;
+    private int textureDim;
     public IonDrawable setBitmap(BitmapInfo info, int loadedFrom) {
         this.loadedFrom = loadedFrom;
         requestCount++;
@@ -166,6 +168,23 @@ public IonDrawable setBitmap(BitmapInfo info, int loadedFrom) {
             return this;
         }
 
+        if (info.mipmap != null) {
+            // find number of tiles across to fit
+            double wlevel = (double)info.originalSize.x / TILE_DIM;
+            double hlevel = (double)info.originalSize.y / TILE_DIM;
+
+            // find the level: find how many power of 2 tiles are necessary
+            // to fit the entire image. ie, fit it into a square.
+            double level = Math.max(wlevel, hlevel);
+            level = Math.log(level) / LOG_2;
+
+            int l = (int)Math.ceil(level);
+
+            // now, we know the entire image will fit in a square image of
+            // this dimension:
+            textureDim = TILE_DIM << l;
+        }
+
         callback.bitmapKey = info.key;
         return this;
     }
@@ -284,10 +303,15 @@ public void run() {
         }
     };
 
-    public IonDrawable setMipmap(boolean mipmap) {
-        this.mipmap = mipmap;
-        return this;
-    }
+    private static final double LOG_2 = Math.log(2);
+    private static final int TILE_DIM = 512;
+
+    FutureCallback<BitmapInfo> tileCallback = new FutureCallback<BitmapInfo>() {
+        @Override
+        public void onCompleted(Exception e, BitmapInfo result) {
+            invalidateSelf();
+        }
+    };
 
     @Override
     public void draw(Canvas canvas) {
@@ -348,47 +372,54 @@ else if (info.mipmap != null) {
             Rect clip = canvas.getClipBounds();
             Rect bounds = getBounds();
 
-            final int TILE_DIM = 1024;
-
             float zoom = (float)canvas.getWidth() / (float)clip.width();
 //            double level = Math.abs(Math.round(Math.log(zoom) / Math.log(2)));
 
             float zoomWidth = zoom * bounds.width();
             float zoomHeight = zoom * bounds.height();
 
-            double wlevel = Math.log(zoomWidth / TILE_DIM) / Math.log(2);
-            double hlevel = Math.log(zoomHeight/ TILE_DIM) / Math.log(2);
+            double wlevel = Math.log(zoomWidth / TILE_DIM) / LOG_2;
+            double hlevel = Math.log(zoomHeight/ TILE_DIM) / LOG_2;
             double maxLevel = Math.max(wlevel, hlevel);
 
-
-            Point p = new Point(canvas.getWidth(), canvas.getHeight());
-
-//            System.out.println("width: " + clip.width());
-//            System.out.println("height: " + clip.height());
 //            System.out.println("clip: " + clip);
-//            System.out.println("zoom: " + zoom);
-//            System.out.println("bounds: " + bounds);
-            System.out.println("clip: " + clip);
-            System.out.println("canvas: " + p);
-            System.out.println("zoomWidth: " + zoomWidth);
-            System.out.println("zoomHeight: " + zoomHeight);
-            System.out.println("level: " + maxLevel);
+//            System.out.println("zoomWidth: " + zoomWidth);
+//            System.out.println("zoomHeight: " + zoomHeight);
+//            System.out.println("level: " + maxLevel);
 
             int visibleLeft = Math.max(0, clip.left);
             int visibleRight = Math.min(bounds.width(), clip.right);
             int visibleTop = Math.max(0, clip.top);
             int visibleBottom = Math.min(bounds.height(), clip.bottom);
             int level = (int)maxLevel;
-            int levelDim = TILE_DIM << level;
+            int levelTiles = 1 << level;
+            int levelDim = levelTiles * TILE_DIM;
             Rect visible = new Rect(visibleLeft, visibleTop, visibleRight, visibleBottom);
             System.out.println("visible: " + visible);
 
-            for (int y = 0; y < visibleBottom; y += TILE_DIM) {
-                if (y + TILE_DIM < visibleTop)
+
+            int textureTileDim = textureDim / levelTiles;
+
+            for (int y = 0; y < levelTiles; y++) {
+                int top = textureTileDim * y;
+                int bottom = textureTileDim * (y + 1);
+                if (bottom < visibleTop)
+                    continue;
+                if (top > visibleBottom)
                     continue;
-                for (int x = 0; x < visibleRight; x += TILE_DIM) {
-                    if (x + TILE_DIM < visibleLeft)
+                for (int x = 0; x < levelTiles; x++) {
+                    int left = textureTileDim * x;
+                    int right = textureTileDim * (x + 1);
+                    if (right < visibleLeft)
                         continue;
+                    if (left > visibleRight)
+                        continue;
+
+                    // fetch render
+                    Rect render = new Rect(left, top, right, bottom);
+                    System.out.println("rendering: " + render);
+                    String tileKey = ResponseCacheMiddleware.toKeyString(info.key + x + "," + y);
+//                    BitmapInfo tile =
                 }
             }
 
