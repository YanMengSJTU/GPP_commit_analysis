diff --git a/ion/src/com/koushikdutta/ion/IonBitmapRequestBuilder.java b/ion/src/com/koushikdutta/ion/IonBitmapRequestBuilder.java
index 9d3ead86..24a3b36c 100644
--- a/ion/src/com/koushikdutta/ion/IonBitmapRequestBuilder.java
+++ b/ion/src/com/koushikdutta/ion/IonBitmapRequestBuilder.java
@@ -203,7 +203,7 @@ BitmapFetcher executeCache() {
         }
 
         // see if something is downloading this
-        if (!ion.bitmapsPending.contains(downloadKey)) {
+        if (ion.bitmapsPending.tag(downloadKey) == null) {
             final LoadMipmap loadMipmap = new LoadMipmap(ion, downloadKey);
             // nothing downloading, see if a file already exists
             DiskLruCache diskLruCache = ion.responseCache.getDiskLruCache();
@@ -236,7 +236,7 @@ BitmapFetcher executeCache() {
 
     private IonDrawable setIonDrawable(ImageView imageView, BitmapInfo info, int loadedFrom) {
         IonDrawable ret = IonDrawable.getOrCreateIonDrawable(imageView)
-        .setMipmap(mipmap)
+        .ion(ion)
         .setBitmap(info, loadedFrom)
         .setSize(resizeWidth, resizeHeight)
         .setError(errorResource, errorDrawable)
diff --git a/ion/src/com/koushikdutta/ion/IonDrawable.java b/ion/src/com/koushikdutta/ion/IonDrawable.java
index 2fdea264..a5afd51e 100644
--- a/ion/src/com/koushikdutta/ion/IonDrawable.java
+++ b/ion/src/com/koushikdutta/ion/IonDrawable.java
@@ -6,6 +6,8 @@
 import android.graphics.ColorFilter;
 import android.graphics.Paint;
 import android.graphics.PixelFormat;
+import android.graphics.Point;
+import android.graphics.Rect;
 import android.graphics.drawable.Drawable;
 import android.os.Looper;
 import android.os.SystemClock;
@@ -15,9 +17,11 @@
 
 import com.koushikdutta.async.future.FutureCallback;
 import com.koushikdutta.async.future.SimpleFuture;
+import com.koushikdutta.async.http.ResponseCacheMiddleware;
 import com.koushikdutta.ion.bitmap.BitmapInfo;
 
 import java.lang.ref.WeakReference;
+import java.net.ResponseCache;
 
 /**
  * Created by koush on 6/8/13.
@@ -35,13 +39,18 @@
     private boolean disableFadeIn;
     private int resizeWidth;
     private int resizeHeight;
-    private boolean mipmap;
+    private Ion ion;
 
     public IonDrawable cancel() {
         requestCount++;
         return this;
     }
 
+    public IonDrawable ion(Ion ion) {
+        this.ion = ion;
+        return this;
+    }
+
     public SimpleFuture<ImageView> getFuture() {
         return callback.imageViewFuture;
     }
@@ -93,8 +102,6 @@ public void onCompleted(Exception e, BitmapInfo result) {
             if (drawable.requestCount != requestId)
                 return;
 
-            drawable.requestCount++;
-
             imageView.setImageDrawable(null);
             drawable.setBitmap(result, result.loadedFrom);
             imageView.setImageDrawable(drawable);
@@ -149,8 +156,10 @@ public IonDrawable(Resources resources, ImageView imageView) {
 
     int currentFrame;
     private boolean invalidateScheduled;
+    private int textureDim;
     public IonDrawable setBitmap(BitmapInfo info, int loadedFrom) {
         this.loadedFrom = loadedFrom;
+        requestCount++;
 
         if (this.info == info)
             return this;
@@ -165,6 +174,23 @@ public IonDrawable setBitmap(BitmapInfo info, int loadedFrom) {
             return this;
         }
 
+        if (info.mipmap != null) {
+            // find number of tiles across to fit
+            double wlevel = (double)info.originalSize.x / TILE_DIM;
+            double hlevel = (double)info.originalSize.y / TILE_DIM;
+
+            // find the level: find how many power of 2 tiles are necessary
+            // to fit the entire image. ie, fit it into a square.
+            double level = Math.max(wlevel, hlevel);
+            level = Math.log(level) / LOG_2;
+
+            int l = (int)Math.ceil(level);
+
+            // now, we know the entire image will fit in a square image of
+            // this dimension:
+            textureDim = TILE_DIM << l;
+        }
+
         callback.bitmapKey = info.key;
         return this;
     }
@@ -221,10 +247,11 @@ private Drawable tryGetErrorResource() {
 
     @Override
     public int getIntrinsicWidth() {
-        if (info != null && info.bitmaps != null) {
-            if (!mipmap)
+        if (info != null) {
+            if (info.bitmaps != null)
                 return info.bitmaps[0].getScaledWidth(resources.getDisplayMetrics().densityDpi);
-            return info.originalSize.x;
+            if (info.mipmap != null)
+                return info.originalSize.x;
         }
         if (resizeWidth > 0)
             return resizeWidth;
@@ -245,10 +272,11 @@ public int getIntrinsicWidth() {
 
     @Override
     public int getIntrinsicHeight() {
-        if (info != null && info.bitmaps != null) {
-            if (!mipmap)
+        if (info != null) {
+            if (info.bitmaps != null)
                 return info.bitmaps[0].getScaledHeight(resources.getDisplayMetrics().densityDpi);
-            return info.originalSize.y;
+            if (info.mipmap != null)
+                return info.originalSize.y;
         }
         if (resizeHeight > 0)
             return resizeHeight;
@@ -281,10 +309,15 @@ public void run() {
         }
     };
 
-    public IonDrawable setMipmap(boolean mipmap) {
-        this.mipmap = mipmap;
-        return this;
-    }
+    private static final double LOG_2 = Math.log(2);
+    private static final int TILE_DIM = 512;
+
+    FutureCallback<BitmapInfo> tileCallback = new FutureCallback<BitmapInfo>() {
+        @Override
+        public void onCompleted(Exception e, BitmapInfo result) {
+            invalidateSelf();
+        }
+    };
 
     @Override
     public void draw(Canvas canvas) {
@@ -330,6 +363,100 @@ public void draw(Canvas canvas) {
                 }
             }
         }
+        else if (info.mipmap != null) {
+            // zoom 0: entire image fits in a TILE_DIMxTILE_DIM square
+
+
+            // figure out zoom level
+            // figure out which tiles need rendering
+            // fetch anything that needs fetching
+            // draw stuff that needs drawing
+            // use parent level tiles for tiles that do not exist
+            // crossfading?
+//            System.out.println(info.mipmap);
+
+            Rect clip = canvas.getClipBounds();
+            Rect bounds = getBounds();
+
+            float zoom = (float)canvas.getWidth() / (float)clip.width();
+//            double level = Math.abs(Math.round(Math.log(zoom) / Math.log(2)));
+
+            float zoomWidth = zoom * bounds.width();
+            float zoomHeight = zoom * bounds.height();
+
+            double wlevel = Math.log(zoomWidth / TILE_DIM) / LOG_2;
+            double hlevel = Math.log(zoomHeight/ TILE_DIM) / LOG_2;
+            double maxLevel = Math.max(wlevel, hlevel);
+
+//            System.out.println("clip: " + clip);
+//            System.out.println("zoomWidth: " + zoomWidth);
+//            System.out.println("zoomHeight: " + zoomHeight);
+//            System.out.println("level: " + maxLevel);
+
+            int visibleLeft = Math.max(0, clip.left);
+            int visibleRight = Math.min(bounds.width(), clip.right);
+            int visibleTop = Math.max(0, clip.top);
+            int visibleBottom = Math.min(bounds.height(), clip.bottom);
+            int level = (int)Math.ceil(maxLevel);
+            int levelTiles = 1 << level;
+            int levelDim = levelTiles * TILE_DIM;
+            Rect visible = new Rect(visibleLeft, visibleTop, visibleRight, visibleBottom);
+//            System.out.println("visible: " + visible);
+
+            int textureTileDim = textureDim / levelTiles;
+
+            paint.setColor(Color.BLACK);
+            canvas.drawRect(getBounds(), paint);
+
+            int sampleSize = 1;
+            while (textureTileDim / sampleSize > TILE_DIM)
+                sampleSize <<= 1;
+
+            for (int y = 0; y < levelTiles; y++) {
+                int top = textureTileDim * y;
+                int bottom = textureTileDim * (y + 1);
+                bottom = Math.min(bottom, bounds.bottom);
+                if (bottom < visibleTop)
+                    continue;
+                if (top > visibleBottom)
+                    continue;
+                for (int x = 0; x < levelTiles; x++) {
+                    int left = textureTileDim * x;
+                    int right = textureTileDim * (x + 1);
+                    right = Math.min(right, bounds.right);
+                    if (right < visibleLeft)
+                        continue;
+                    if (left > visibleRight)
+                        continue;
+
+                    Rect texRect = new Rect(left, top, right, bottom);
+
+                    // find, render/fetch
+//                    System.out.println("rendering: " + texRect + " for: " + bounds);
+                    String tileKey = ResponseCacheMiddleware.toKeyString(info.key + "," + level + "," + x + "," + y);
+                    BitmapInfo tile = ion.bitmapCache.get(tileKey);
+                    if (tile != null) {
+                        // render it
+                        if (tile.bitmaps != null) {
+//                            System.out.println("bitmap is: " + tile.bitmaps[0].getWidth() + "x" + tile.bitmaps[0].getHeight());
+                            canvas.drawBitmap(tile.bitmaps[0], null, texRect, paint);
+                        }
+                        continue;
+                    }
+
+                    if (ion.bitmapsPending.tag(tileKey) == null) {
+                        // fetch it
+                        LoadBitmapRegion region = new LoadBitmapRegion(ion, tileKey, info.mipmap, texRect, sampleSize);
+                    }
+                    ion.bitmapsPending.add(tileKey, tileCallback);
+                }
+            }
+
+
+//            paint.setColor(Color.RED);
+//            canvas.drawRect(getBounds(), paint);
+//            paint.reset();
+        }
         else {
             Drawable error = tryGetErrorResource();
             if (error != null) {
diff --git a/ion/src/com/koushikdutta/ion/LoadMipmap.java b/ion/src/com/koushikdutta/ion/LoadMipmap.java
index f4f95935..a3045f5e 100644
--- a/ion/src/com/koushikdutta/ion/LoadMipmap.java
+++ b/ion/src/com/koushikdutta/ion/LoadMipmap.java
@@ -1,5 +1,10 @@
 package com.koushikdutta.ion;
 
+import android.annotation.TargetApi;
+import android.graphics.BitmapRegionDecoder;
+import android.graphics.Point;
+import android.os.Build;
+
 import com.koushikdutta.async.future.FutureCallback;
 import com.koushikdutta.ion.bitmap.BitmapInfo;
 
@@ -8,13 +13,14 @@
 /**
  * Created by koush on 1/5/14.
  */
+@TargetApi(Build.VERSION_CODES.GINGERBREAD_MR1)
 public class LoadMipmap extends BitmapCallback implements FutureCallback<File> {
     public LoadMipmap(Ion ion, String key) {
         super(ion, key, true);
     }
 
     @Override
-    public void onCompleted(Exception e, File result) {
+    public void onCompleted(Exception e, final File file) {
         if (e != null) {
             report(e, null);
             return;
@@ -25,13 +31,20 @@ public void onCompleted(Exception e, File result) {
             return;
         }
 
-        ion.configure().getFileLoader().loadBitmap(ion, result.toURI().toString(), 256, 256)
-        .setCallback(new FutureCallback<BitmapInfo>() {
+        Ion.getBitmapLoadExecutorService().execute(new Runnable() {
             @Override
-            public void onCompleted(Exception e, BitmapInfo result) {
-                if (result != null)
-                    result.key = key;
-                report(e, result);
+            public void run() {
+                try {
+                    BitmapRegionDecoder decoder = BitmapRegionDecoder.newInstance(file.toString(), false);
+                    Point size = new Point(decoder.getWidth(), decoder.getHeight());
+                    BitmapInfo info = new BitmapInfo(null, size);
+                    info.mipmap = decoder;
+                    info.loadedFrom = Loader.LoaderEmitter.LOADED_FROM_NETWORK;
+                    info.key = key;
+                    report(null, info);
+                } catch (Exception e) {
+                    report(e, null);
+                }
             }
         });
     }
diff --git a/ion/src/com/koushikdutta/ion/bitmap/BitmapInfo.java b/ion/src/com/koushikdutta/ion/bitmap/BitmapInfo.java
index 484f66ec..47adce4f 100644
--- a/ion/src/com/koushikdutta/ion/bitmap/BitmapInfo.java
+++ b/ion/src/com/koushikdutta/ion/bitmap/BitmapInfo.java
@@ -1,8 +1,10 @@
 package com.koushikdutta.ion.bitmap;
 
 import android.graphics.Bitmap;
+import android.graphics.BitmapRegionDecoder;
 import android.graphics.Point;
 
+import java.io.File;
 import java.lang.ref.WeakReference;
 
 /**
@@ -22,6 +24,7 @@ public BitmapInfo(Bitmap[] bitmaps, Point originalSize) {
     final public Bitmap[] bitmaps;
     public int[] delays;
     public Exception exception;
+    public BitmapRegionDecoder mipmap;
 
     public int sizeOf() {
         if (bitmaps == null)
diff --git a/ion/src/com/koushikdutta/ion/bitmap/IonBitmapCache.java b/ion/src/com/koushikdutta/ion/bitmap/IonBitmapCache.java
index bd2359e0..9ec6e077 100644
--- a/ion/src/com/koushikdutta/ion/bitmap/IonBitmapCache.java
+++ b/ion/src/com/koushikdutta/ion/bitmap/IonBitmapCache.java
@@ -1,13 +1,17 @@
 package com.koushikdutta.ion.bitmap;
 
+import android.annotation.TargetApi;
 import android.app.ActivityManager;
 import android.content.Context;
 import android.content.res.AssetManager;
 import android.content.res.Resources;
 import android.graphics.Bitmap;
 import android.graphics.BitmapFactory;
+import android.graphics.BitmapRegionDecoder;
 import android.graphics.Matrix;
 import android.graphics.Point;
+import android.graphics.Rect;
+import android.os.Build;
 import android.os.Looper;
 import android.util.DisplayMetrics;
 import android.util.Log;
@@ -148,6 +152,13 @@ public Bitmap loadBitmap(byte[] bytes, int offset, int length, int minx, int min
         return Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(), bitmap.getHeight(), matrix, true);
     }
 
+    @TargetApi(Build.VERSION_CODES.GINGERBREAD_MR1)
+    public Bitmap loadRegion(BitmapRegionDecoder decoder, Rect sourceRect, int inSampleSize) {
+        BitmapFactory.Options options = new BitmapFactory.Options();
+        options.inSampleSize = inSampleSize;
+        return decoder.decodeRegion(sourceRect, options);
+    }
+
     public Bitmap loadBitmap(InputStream stream, int minx, int miny, Point outSize) {
         stream = new BufferedInputStream(stream, 64 * 1024);
         assert Thread.currentThread() != Looper.getMainLooper().getThread();
