diff --git a/ion/src/com/koushikdutta/ion/bitmap/BitmapInfo.java b/ion/src/com/koushikdutta/ion/bitmap/BitmapInfo.java
index e818916e..1a71e566 100644
--- a/ion/src/com/koushikdutta/ion/bitmap/BitmapInfo.java
+++ b/ion/src/com/koushikdutta/ion/bitmap/BitmapInfo.java
@@ -2,6 +2,8 @@
 
 import android.graphics.Bitmap;
 
+import java.lang.ref.WeakReference;
+
 /**
  * Created by koush on 6/12/13.
  */
@@ -13,6 +15,7 @@
     public Bitmap[] bitmaps;
     public int[] delays;
     public Exception exception;
+    public WeakReference<Bitmap[]> bitmapsRef;
 
     public int sizeOf() {
         if (bitmaps == null)
diff --git a/ion/src/com/koushikdutta/ion/bitmap/IonBitmapCache.java b/ion/src/com/koushikdutta/ion/bitmap/IonBitmapCache.java
index d5a57e76..aadace82 100644
--- a/ion/src/com/koushikdutta/ion/bitmap/IonBitmapCache.java
+++ b/ion/src/com/koushikdutta/ion/bitmap/IonBitmapCache.java
@@ -61,15 +61,33 @@ public void put(BitmapInfo info) {
     public BitmapInfo get(String key) {
         if (key == null)
             return null;
+
+        // see if this thing has an immediate cache hit
         BitmapInfo ret = cache.get(key);
         if (ret == null || ret.bitmaps != null)
             return ret;
 
-        // if this bitmap load previously errored out, see if it is time to retry
-        // the fetch. connectivity error, server failure, etc, shouldn't be
-        // cached indefinitely...
-        if (ret.loadTime + errorCacheDuration > System.currentTimeMillis())
-            return ret;
+        // see if the the bitmap got evicted and put into a weak ref
+        if (ret.bitmapsRef != null) {
+            Bitmap[] bitmaps = ret.bitmapsRef.get();
+            // see if we successfully repopulated from the weak ref
+            if (ret.bitmaps != null) {
+                cache.remove(key);
+                ret.bitmaps = bitmaps;
+                ret.bitmapsRef = null;
+                cache.put(key, ret);
+                System.out.println("===== SUCCESSFULLY GRABBED FROM WEAK REF CACHE! ====");
+                return ret;
+            }
+            // ok, fall through and toss this, it's useless.
+        }
+        else {
+            // if this bitmap load previously errored out, see if it is time to retry
+            // the fetch. connectivity error, server failure, etc, shouldn't be
+            // cached indefinitely...
+            if (ret.loadTime + errorCacheDuration > System.currentTimeMillis())
+                return ret;
+        }
         cache.remove(key);
         return null;
     }
diff --git a/ion/src/com/koushikdutta/ion/bitmap/LruBitmapCache.java b/ion/src/com/koushikdutta/ion/bitmap/LruBitmapCache.java
index 2fa31cf1..132b3419 100644
--- a/ion/src/com/koushikdutta/ion/bitmap/LruBitmapCache.java
+++ b/ion/src/com/koushikdutta/ion/bitmap/LruBitmapCache.java
@@ -1,5 +1,9 @@
 package com.koushikdutta.ion.bitmap;
 
+import android.graphics.Bitmap;
+
+import java.lang.ref.WeakReference;
+
 class LruBitmapCache extends LruCache<String, BitmapInfo> {
     public LruBitmapCache(int maxSize) {
         super(maxSize);
@@ -9,4 +13,25 @@ public LruBitmapCache(int maxSize) {
     protected int sizeOf(String key, BitmapInfo info) {
         return info.sizeOf();
     }
+
+    @Override
+    protected void entryRemoved(boolean evicted, String key, BitmapInfo oldValue, BitmapInfo newValue) {
+        super.entryRemoved(evicted, key, oldValue, newValue);
+
+        // on eviction, put the bitmaps into a weak ref
+        if (!evicted)
+            return;
+
+        // toss the oldValue into a weak ref, and play with that.
+        if (oldValue == null)
+            return;
+        if (oldValue.bitmaps == null)
+            return;
+
+        oldValue.bitmapsRef = new WeakReference<Bitmap[]>(oldValue.bitmaps);
+        oldValue.bitmaps = null;
+        put(key, oldValue);
+    }
+
+
 }
