diff --git a/ion-test/src/com/koushikdutta/ion/test/Issues.java b/ion-test/src/com/koushikdutta/ion/test/Issues.java
index cabbb66a..e5ba78a1 100644
--- a/ion-test/src/com/koushikdutta/ion/test/Issues.java
+++ b/ion-test/src/com/koushikdutta/ion/test/Issues.java
@@ -11,6 +11,12 @@
 import com.koushikdutta.async.http.server.HttpServerRequestCallback;
 import com.koushikdutta.ion.Ion;
 
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.TimeUnit;
+
 /**
  * Created by koush on 10/27/13.
  */
@@ -77,4 +83,19 @@ public void onRequest(AsyncHttpServerRequest request, AsyncHttpServerResponse re
             asyncServer.stop();
         }
     }
+
+    public void testIssue200() throws Exception {
+        Map<String, List<String>> params = new HashMap<String, List<String>>();
+        params.put("email", Arrays.asList("mail@mail.pl"));
+        params.put("password", Arrays.asList("pass"));
+
+        String val = Ion.with(getContext())
+        .load("https://koush.clockworkmod.com/test/echo")
+        .setLogging("Issue200", Log.VERBOSE)
+        .setBodyParameters(params)
+        .asString()
+        .get(2000, TimeUnit.MILLISECONDS);
+
+        System.out.println(val);
+    }
 }
diff --git a/ion/src/com/koushikdutta/ion/BitmapFetcher.java b/ion/src/com/koushikdutta/ion/BitmapFetcher.java
index 6dd443b4..c1612f2b 100644
--- a/ion/src/com/koushikdutta/ion/BitmapFetcher.java
+++ b/ion/src/com/koushikdutta/ion/BitmapFetcher.java
@@ -5,8 +5,8 @@
 import com.koushikdutta.async.future.Future;
 import com.koushikdutta.async.future.FutureCallback;
 import com.koushikdutta.async.http.AsyncHttpRequest;
-import com.koushikdutta.async.http.libcore.DiskLruCache;
 import com.koushikdutta.async.parser.ByteBufferListParser;
+import com.koushikdutta.async.util.FileCache;
 import com.koushikdutta.ion.bitmap.BitmapInfo;
 import com.koushikdutta.ion.bitmap.Transform;
 import com.koushikdutta.ion.loader.MediaFile;
@@ -107,11 +107,11 @@ public boolean loadRequest(AsyncHttpRequest request) {
     public void execute() {
         final Ion ion = builder.ion;
 
-        // bitmaps that were transformed are put into the DiskLruCache to prevent
+        // bitmaps that were transformed are put into the FileCache to prevent
         // subsequent retransformation. See if we can retrieve the bitmap from the disk cache.
         // See TransformBitmap for where the cache is populated.
-        DiskLruCache diskLruCache = ion.responseCache.getDiskLruCache();
-        if (!builder.noCache && hasTransforms && diskLruCache.containsKey(bitmapKey) && !deepZoom) {
+        FileCache fileCache = ion.responseCache.getFileCache();
+        if (!builder.noCache && hasTransforms && fileCache.exists(bitmapKey) && !deepZoom) {
             TransformBitmap.getBitmapSnapshot(ion, bitmapKey);
             return;
         }
@@ -137,9 +137,9 @@ public void run() {
             }
             else {
 //                System.out.println("downloading file for deepZoom");
-                File file = diskLruCache.getFile(downloadKey, 0);
+                File file = fileCache.getTempFile();
                 IonRequestBuilder.EmitterTransform<File> emitterTransform = builder.write(file);
-                LoadDeepZoom loadDeepZoom = new LoadDeepZoom(ion, downloadKey, animateGif, emitterTransform, diskLruCache) {
+                LoadDeepZoom loadDeepZoom = new LoadDeepZoom(ion, downloadKey, animateGif, emitterTransform, fileCache) {
                     @Override
                     public void onCompleted(Exception e, File file) {
                         super.onCompleted(e, file);
diff --git a/ion/src/com/koushikdutta/ion/DiskLruCacheStore.java b/ion/src/com/koushikdutta/ion/FileCacheStore.java
similarity index 60%
rename from ion/src/com/koushikdutta/ion/DiskLruCacheStore.java
rename to ion/src/com/koushikdutta/ion/FileCacheStore.java
index f508a7a7..9391f097 100644
--- a/ion/src/com/koushikdutta/ion/DiskLruCacheStore.java
+++ b/ion/src/com/koushikdutta/ion/FileCacheStore.java
@@ -8,28 +8,29 @@
 import com.koushikdutta.async.future.FutureCallback;
 import com.koushikdutta.async.future.SimpleFuture;
 import com.koushikdutta.async.http.ResponseCacheMiddleware;
-import com.koushikdutta.async.http.libcore.DiskLruCache;
 import com.koushikdutta.async.parser.AsyncParser;
 import com.koushikdutta.async.parser.DocumentParser;
 import com.koushikdutta.async.parser.StringParser;
+import com.koushikdutta.async.stream.FileDataSink;
 import com.koushikdutta.async.stream.InputStreamDataEmitter;
 import com.koushikdutta.async.stream.OutputStreamDataSink;
+import com.koushikdutta.async.util.FileCache;
 import com.koushikdutta.ion.gson.GsonParser;
 import com.koushikdutta.ion.gson.GsonSerializer;
 
 import org.w3c.dom.Document;
 
-import java.io.IOException;
+import java.io.File;
 import java.io.InputStream;
 import java.io.OutputStream;
 
 /**
  * Created by koush on 11/17/13.
  */
-public class DiskLruCacheStore {
+public class FileCacheStore {
     Ion ion;
-    DiskLruCache cache;
-    DiskLruCacheStore(Ion ion, DiskLruCache cache) {
+    FileCache cache;
+    FileCacheStore(Ion ion, FileCache cache) {
         this.ion = ion;
         this.cache = cache;
     }
@@ -39,56 +40,20 @@
         Ion.getIoExecutorService().execute(new Runnable() {
             @Override
             public void run() {
-                final DiskLruCache.Editor editor;
-                try {
-                    final String key = ResponseCacheMiddleware.toKeyString("ion-store:" + rawKey);
-                    editor = cache.edit(key);
-                }
-                catch (Exception e) {
-                    ret.setComplete(e);
-                    return;
-                }
-                final OutputStream out;
-                try {
-                    out = editor.newOutputStream(0);
-                    for (int i = 1; i < cache.size(); i++) {
-                        editor.newOutputStream(i).close();
-                    }
-                }
-                catch (Exception e) {
-                    try {
-                        editor.abort();
-                    }
-                    catch (Exception ex) {
-                    }
-                    ret.setComplete(e);
-                    return;
-                }
-
-                if (editor == null) {
-                    ret.setComplete(new Exception("unable to edit"));
-                    return;
-                }
-                parser.write(new OutputStreamDataSink(ion.getServer(), out), value, new CompletedCallback() {
+                final String key = FileCache.toKeyString("ion-store:", rawKey);
+                final File file = cache.getTempFile();
+                final FileDataSink sink = new FileDataSink(ion.getServer(), file);
+                parser.write(sink, value, new CompletedCallback() {
                     @Override
                     public void onCompleted(Exception ex) {
-                        if (ex == null) {
-                            try {
-                                out.close();
-                                editor.commit();
-                                ret.setComplete(value);
-                                return;
-                            }
-                            catch (Exception e) {
-                                ex = e;
-                            }
-                        }
-                        try {
-                            editor.abort();
+                        sink.close();
+                        if (ex != null) {
+                            file.delete();
+                            ret.setComplete(ex);
+                            return;
                         }
-                        catch (Exception e) {
-                        }
-                        ret.setComplete(ex);
+                        cache.commitTempFiles(key, file);
+                        ret.setComplete(value);
                     }
                 });
             }
@@ -137,24 +102,15 @@ public void onCompleted(Exception ex) {
             @Override
             public void run() {
                 try {
-                    final String key = ResponseCacheMiddleware.toKeyString("ion-store:" + rawKey);
-                    final DiskLruCache.Snapshot snapshot = cache.get(key);
-                    if (snapshot == null) {
+                    final String key = FileCache.toKeyString("ion-store:", rawKey);
+                    final File file = cache.getFile(key);
+                    if (!file.exists()) {
                         ret.setComplete((T)null);
                         return;
                     }
-                    InputStream inputStream = snapshot.getInputStream(0);
-                    InputStreamDataEmitter emitter = new InputStreamDataEmitter(ion.getServer(), inputStream);
-                    parser.parse(emitter).setCallback(new FutureCallback<T>() {
-                        @Override
-                        public void onCompleted(Exception e, T result) {
-                            snapshot.close();
-                            if (e != null)
-                                ret.setComplete(e);
-                            else
-                                ret.setComplete(result);
-                        }
-                    });
+                    ion.build(ion.getContext(), file)
+                    .as(parser)
+                    .setCallback(ret.getCompletionCallback());
                 }
                 catch (Exception e) {
                 }
diff --git a/ion/src/com/koushikdutta/ion/Ion.java b/ion/src/com/koushikdutta/ion/Ion.java
index 5317024c..070cc69e 100644
--- a/ion/src/com/koushikdutta/ion/Ion.java
+++ b/ion/src/com/koushikdutta/ion/Ion.java
@@ -22,13 +22,11 @@
 import com.koushikdutta.async.AsyncServer;
 import com.koushikdutta.async.future.Future;
 import com.koushikdutta.async.future.FutureCallback;
-import com.koushikdutta.async.future.SimpleFuture;
-import com.koushikdutta.async.future.TransformFuture;
 import com.koushikdutta.async.http.AsyncHttpClient;
 import com.koushikdutta.async.http.AsyncHttpRequest;
 import com.koushikdutta.async.http.ResponseCacheMiddleware;
-import com.koushikdutta.async.http.libcore.DiskLruCache;
 import com.koushikdutta.async.http.libcore.RawHeaders;
+import com.koushikdutta.async.util.FileCache;
 import com.koushikdutta.async.util.FileUtility;
 import com.koushikdutta.async.util.HashList;
 import com.koushikdutta.ion.bitmap.BitmapInfo;
@@ -119,7 +117,7 @@ public static Ion getInstance(Context context, String name) {
     AsyncHttpClient httpClient;
     CookieMiddleware cookieMiddleware;
     ResponseCacheMiddleware responseCache;
-    DiskLruCache storeCache;
+    FileCache storeCache;
     HttpLoader httpLoader;
     ContentLoader contentLoader;
     VideoLoader videoLoader;
@@ -157,11 +155,7 @@ private Ion(Context context, String name) {
             }
         }
 
-        try {
-            storeCache = DiskLruCache.open(new File(context.getFilesDir(), name), 1, 1, Long.MAX_VALUE);
-        }
-        catch (IOException e) {
-        }
+        storeCache = new FileCache(new File(context.getFilesDir(), name), Long.MAX_VALUE, false);
 
         // TODO: Support pre GB?
         if (Build.VERSION.SDK_INT >= 9)
@@ -379,16 +373,16 @@ private void addCookieMiddleware() {
      * Get or put an item from the cache
      * @return
      */
-    public DiskLruCacheStore cache() {
-        return new DiskLruCacheStore(this, responseCache.getDiskLruCache());
+    public FileCacheStore cache() {
+        return new FileCacheStore(this, responseCache.getFileCache());
     }
 
     /**
      * Get or put an item in the persistent store
      * @return
      */
-    public DiskLruCacheStore store() {
-        return new DiskLruCacheStore(this, responseCache.getDiskLruCache());
+    public FileCacheStore store() {
+        return new FileCacheStore(this, storeCache);
     }
 
     public String getName() {
diff --git a/ion/src/com/koushikdutta/ion/IonBitmapRequestBuilder.java b/ion/src/com/koushikdutta/ion/IonBitmapRequestBuilder.java
index 0cdce95f..245f62a3 100644
--- a/ion/src/com/koushikdutta/ion/IonBitmapRequestBuilder.java
+++ b/ion/src/com/koushikdutta/ion/IonBitmapRequestBuilder.java
@@ -11,7 +11,7 @@
 
 import com.koushikdutta.async.future.Future;
 import com.koushikdutta.async.future.SimpleFuture;
-import com.koushikdutta.async.http.ResponseCacheMiddleware;
+import com.koushikdutta.async.util.FileCache;
 import com.koushikdutta.ion.bitmap.BitmapInfo;
 import com.koushikdutta.ion.bitmap.Transform;
 import com.koushikdutta.ion.builder.BitmapFutureBuilder;
@@ -140,7 +140,7 @@ private String computeDownloadKey() {
             downloadKey += ":!animateGif";
         if (deepZoom)
             downloadKey += ":deepZoom";
-        return ResponseCacheMiddleware.toKeyString(downloadKey);
+        return FileCache.toKeyString(downloadKey);
     }
 
     @Override
@@ -162,7 +162,7 @@ public BitmapInfo asCachedBitmap() {
             for (Transform transform : transforms) {
                 bitmapKey += transform.key();
             }
-            bitmapKey = ResponseCacheMiddleware.toKeyString(bitmapKey);
+            bitmapKey = FileCache.toKeyString(bitmapKey);
         }
 
         return builder.ion.bitmapCache.get(bitmapKey);
@@ -186,7 +186,7 @@ BitmapFetcher executeCache() {
             for (Transform transform : transforms) {
                 bitmapKey += transform.key();
             }
-            bitmapKey = ResponseCacheMiddleware.toKeyString(bitmapKey);
+            bitmapKey = FileCache.toKeyString(bitmapKey);
         }
 
         // TODO: eliminate this allocation?
diff --git a/ion/src/com/koushikdutta/ion/IonDrawable.java b/ion/src/com/koushikdutta/ion/IonDrawable.java
index e77e7134..4dad54b5 100644
--- a/ion/src/com/koushikdutta/ion/IonDrawable.java
+++ b/ion/src/com/koushikdutta/ion/IonDrawable.java
@@ -16,7 +16,7 @@
 
 import com.koushikdutta.async.future.FutureCallback;
 import com.koushikdutta.async.future.SimpleFuture;
-import com.koushikdutta.async.http.ResponseCacheMiddleware;
+import com.koushikdutta.async.util.FileCache;
 import com.koushikdutta.ion.bitmap.BitmapInfo;
 
 import java.lang.ref.WeakReference;
@@ -435,7 +435,7 @@ public void draw(Canvas canvas) {
 
                     // find, render/fetch
 //                    System.out.println("rendering: " + texRect + " for: " + bounds);
-                    String tileKey = ResponseCacheMiddleware.toKeyString(info.key + "," + level + "," + x + "," + y);
+                    String tileKey = FileCache.toKeyString(info.key, ",", level, ",", x, ",", y);
                     BitmapInfo tile = ion.bitmapCache.get(tileKey);
                     if (tile != null && tile.bitmaps != null) {
                         // render it
@@ -464,7 +464,7 @@ public void draw(Canvas canvas) {
                     int parentY = y >> 1;
 
                     while (parentLevel >= 0) {
-                        tileKey = ResponseCacheMiddleware.toKeyString(info.key + "," + parentLevel + "," + parentX + "," + parentY);
+                        tileKey = FileCache.toKeyString(info.key, ",", parentLevel, ",", parentX, ",", parentY);
                         tile = ion.bitmapCache.get(tileKey);
                         if (tile != null && tile.bitmaps != null)
                             break;
diff --git a/ion/src/com/koushikdutta/ion/LoadDeepZoom.java b/ion/src/com/koushikdutta/ion/LoadDeepZoom.java
index c95ac236..4293d41e 100644
--- a/ion/src/com/koushikdutta/ion/LoadDeepZoom.java
+++ b/ion/src/com/koushikdutta/ion/LoadDeepZoom.java
@@ -10,8 +10,8 @@
 import android.text.TextUtils;
 
 import com.koushikdutta.async.future.FutureCallback;
-import com.koushikdutta.async.http.libcore.DiskLruCache;
-import com.koushikdutta.async.http.libcore.IoUtils;
+import com.koushikdutta.async.util.FileCache;
+import com.koushikdutta.async.util.StreamUtility;
 import com.koushikdutta.ion.bitmap.BitmapInfo;
 import com.koushikdutta.ion.gif.GifAction;
 import com.koushikdutta.ion.gif.GifDecoder;
@@ -24,14 +24,14 @@
  */
 @TargetApi(Build.VERSION_CODES.GINGERBREAD_MR1)
 public class LoadDeepZoom extends LoadBitmapEmitter implements FutureCallback<File> {
-    DiskLruCache diskLruCache;
-    public LoadDeepZoom(Ion ion, String urlKey, boolean animateGif, IonRequestBuilder.EmitterTransform<File> emitterTransform, DiskLruCache diskLruCache) {
+    FileCache fileCache;
+    public LoadDeepZoom(Ion ion, String urlKey, boolean animateGif, IonRequestBuilder.EmitterTransform<File> emitterTransform, FileCache fileCache) {
         super(ion, urlKey, true, animateGif, emitterTransform);
-        this.diskLruCache = diskLruCache;
+        this.fileCache = fileCache;
     }
 
     @Override
-    public void onCompleted(Exception e, final File file) {
+    public void onCompleted(Exception e, final File tempFile) {
         if (e != null) {
             report(e, null);
             return;
@@ -46,20 +46,15 @@ public void onCompleted(Exception e, final File file) {
             @Override
             public void run() {
                 FileInputStream fin = null;
-                DiskLruCache.Editor editor = null;
                 try {
-                    if (diskLruCache != null) {
-                        editor = diskLruCache.edit(key);
-                        editor.set(1, "");
-                        editor.commit(true);
-                    }
-
+                    fileCache.commitTempFiles(key, tempFile);
+                    File file = fileCache.getFile(key);
                     BitmapFactory.Options options = ion.getBitmapCache().prepareBitmapOptions(file, 0, 0);
                     if (options == null)
                         throw new Exception("BitmapFactory.Options failed to load");
                     final Point size = new Point(options.outWidth, options.outHeight);
                     if (animateGif && TextUtils.equals("image/gif", options.outMimeType)) {
-                        fin = new FileInputStream(file);
+                        fin = fileCache.get(key);
                         GifDecoder decoder = new GifDecoder(fin, new GifAction() {
                             @Override
                             public boolean parseOk(boolean parseStatus, int frameIndex) {
@@ -100,15 +95,9 @@ public boolean parseOk(boolean parseStatus, int frameIndex) {
                     report(null, info);
                 } catch (Exception e) {
                     report(e, null);
-                    try {
-                        if (editor != null)
-                            editor.abort();
-                    }
-                    catch (Exception ex) {
-                    }
                 }
                 finally {
-                    IoUtils.closeQuietly(fin);
+                    StreamUtility.closeQuietly(fin);
                 }
             }
         });
diff --git a/ion/src/com/koushikdutta/ion/TransformBitmap.java b/ion/src/com/koushikdutta/ion/TransformBitmap.java
index 8352964e..2f449f24 100644
--- a/ion/src/com/koushikdutta/ion/TransformBitmap.java
+++ b/ion/src/com/koushikdutta/ion/TransformBitmap.java
@@ -2,18 +2,14 @@
 
 import android.graphics.Bitmap;
 import android.graphics.Point;
-import android.util.Log;
 
 import com.koushikdutta.async.future.FutureCallback;
-import com.koushikdutta.async.http.ResponseCacheMiddleware;
-import com.koushikdutta.async.http.libcore.DiskLruCache;
+import com.koushikdutta.async.util.FileCache;
 import com.koushikdutta.ion.bitmap.BitmapInfo;
 import com.koushikdutta.ion.bitmap.Transform;
 
 import java.io.File;
-import java.io.FileInputStream;
-import java.io.InputStream;
-import java.io.OutputStream;
+import java.io.FileOutputStream;
 import java.util.ArrayList;
 
 class TransformBitmap extends BitmapCallback implements FutureCallback<BitmapInfo> {
@@ -33,7 +29,7 @@ public void run() {
                 }
 
                 try {
-                    File file = ion.responseCache.getDiskLruCache().getFile(transformKey, 0);
+                    File file = ion.responseCache.getFileCache().getFile(transformKey);
                     Bitmap bitmap = ion.getBitmapCache().loadBitmap(file, null);
                     if (bitmap == null)
                         throw new Exception("Bitmap failed to load");
@@ -48,7 +44,7 @@ public void run() {
                 catch (Exception e) {
                     callback.report(e, null);
                     try {
-                        ion.responseCache.getDiskLruCache().remove(transformKey);
+                        ion.responseCache.getFileCache().remove(transformKey);
                     } catch (Exception ex) {
                     }
                 }
@@ -116,27 +112,21 @@ public void run() {
                 // but don't persist gifs...
                 if (info.bitmaps.length > 1)
                     return;
+                FileCache cache = ion.responseCache.getFileCache();
+                if (cache == null)
+                    return;
+                File tempFile = cache.getTempFile();
                 try {
-                    DiskLruCache cache = ion.responseCache.getDiskLruCache();
-                    if (cache == null)
-                        return;
-                    DiskLruCache.Editor editor = cache.edit(key);
-                    if (editor == null)
-                        return;
-                    try {
-                        for (int i = 1; i < ResponseCacheMiddleware.ENTRY_COUNT; i++) {
-                            editor.set(i, key);
-                        }
-                        OutputStream out = editor.newOutputStream(0);
-                        Bitmap.CompressFormat format = info.bitmaps[0].hasAlpha() ? Bitmap.CompressFormat.PNG : Bitmap.CompressFormat.JPEG;
-                        info.bitmaps[0].compress(format, 100, out);
-                        out.close();
-                        editor.commit();
-                    } catch (Exception ex) {
-                        editor.abort();
-                    }
+                    FileOutputStream out = new FileOutputStream(tempFile);
+                    Bitmap.CompressFormat format = info.bitmaps[0].hasAlpha() ? Bitmap.CompressFormat.PNG : Bitmap.CompressFormat.JPEG;
+                    info.bitmaps[0].compress(format, 100, out);
+                    out.close();
+                    cache.commitTempFiles(key, tempFile);
                 }
-                catch (Exception e) {
+                catch (Exception ex) {
+                }
+                finally {
+                    tempFile.delete();
                 }
             }
         });
diff --git a/ion/src/com/koushikdutta/ion/bitmap/IonBitmapCache.java b/ion/src/com/koushikdutta/ion/bitmap/IonBitmapCache.java
index 68c11fd0..b9dfec29 100644
--- a/ion/src/com/koushikdutta/ion/bitmap/IonBitmapCache.java
+++ b/ion/src/com/koushikdutta/ion/bitmap/IonBitmapCache.java
@@ -17,13 +17,11 @@
 import android.util.Log;
 import android.view.WindowManager;
 
-import com.koushikdutta.async.http.libcore.IoUtils;
+import com.koushikdutta.async.util.StreamUtility;
 import com.koushikdutta.ion.Ion;
 
-import java.io.BufferedInputStream;
 import java.io.File;
 import java.io.FileInputStream;
-import java.io.InputStream;
 
 /**
  * Created by koush on 5/23/13.
@@ -184,7 +182,7 @@ public Bitmap loadBitmap(File file, BitmapFactory.Options o) {
         catch (Exception e) {
             rotation = 0;
         }
-        IoUtils.closeQuietly(fin);
+        StreamUtility.closeQuietly(fin);
 
         Bitmap bitmap = BitmapFactory.decodeFile(file.toString(), o);
         if (bitmap == null)
diff --git a/ion/src/com/koushikdutta/ion/bitmap/LruBitmapCache.java b/ion/src/com/koushikdutta/ion/bitmap/LruBitmapCache.java
index 8213e32c..4893da3e 100644
--- a/ion/src/com/koushikdutta/ion/bitmap/LruBitmapCache.java
+++ b/ion/src/com/koushikdutta/ion/bitmap/LruBitmapCache.java
@@ -1,5 +1,7 @@
 package com.koushikdutta.ion.bitmap;
 
+import com.koushikdutta.async.util.LruCache;
+
 class LruBitmapCache extends LruCache<String, BitmapInfo> {
     private SoftReferenceHashtable<String, BitmapInfo> soft = new SoftReferenceHashtable<String, BitmapInfo>();
 
@@ -8,7 +10,7 @@ public LruBitmapCache(int maxSize) {
     }
 
     @Override
-    protected int sizeOf(String key, BitmapInfo info) {
+    protected long sizeOf(String key, BitmapInfo info) {
         return info.sizeOf();
     }
 
diff --git a/ion/src/com/koushikdutta/ion/bitmap/LruCache.java b/ion/src/com/koushikdutta/ion/bitmap/LruCache.java
deleted file mode 100644
index 12bfec53..00000000
--- a/ion/src/com/koushikdutta/ion/bitmap/LruCache.java
+++ /dev/null
@@ -1,327 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.koushikdutta.ion.bitmap;
-
-import java.util.LinkedHashMap;
-import java.util.Map;
-
-/**
- * Static library version of {@link android.util.LruCache}. Used to write apps
- * that run on API levels prior to 12. When running on API level 12 or above,
- * this implementation is still used; it does not try to switch to the
- * framework's implementation. See the framework SDK documentation for a class
- * overview.
- */
-class LruCache<K, V> {
-    private final LinkedHashMap<K, V> map;
-
-    /** Size of this cache in units. Not necessarily the number of elements. */
-    private int size;
-    private int maxSize;
-
-    private int putCount;
-    private int createCount;
-    private int evictionCount;
-    private int hitCount;
-    private int missCount;
-
-    /**
-     * @param maxSize for caches that do not override {@link #sizeOf}, this is
-     *     the maximum number of entries in the cache. For all other caches,
-     *     this is the maximum sum of the sizes of the entries in this cache.
-     */
-    public LruCache(int maxSize) {
-        if (maxSize <= 0) {
-            throw new IllegalArgumentException("maxSize <= 0");
-        }
-        this.maxSize = maxSize;
-        this.map = new LinkedHashMap<K, V>(0, 0.75f, true);
-    }
-
-    /**
-     * Returns the value for {@code key} if it exists in the cache or can be
-     * created by {@code #create}. If a value was returned, it is moved to the
-     * head of the queue. This returns null if a value is not cached and cannot
-     * be created.
-     */
-    public final V get(K key) {
-        if (key == null) {
-            throw new NullPointerException("key == null");
-        }
-
-        V mapValue;
-        synchronized (this) {
-            mapValue = map.get(key);
-            if (mapValue != null) {
-                hitCount++;
-                return mapValue;
-            }
-            missCount++;
-        }
-
-        /*
-         * Attempt to create a value. This may take a long time, and the map
-         * may be different when create() returns. If a conflicting value was
-         * added to the map while create() was working, we leave that value in
-         * the map and release the created value.
-         */
-
-        V createdValue = create(key);
-        if (createdValue == null) {
-            return null;
-        }
-
-        synchronized (this) {
-            createCount++;
-            mapValue = map.put(key, createdValue);
-
-            if (mapValue != null) {
-                // There was a conflict so undo that last put
-                map.put(key, mapValue);
-            } else {
-                size += safeSizeOf(key, createdValue);
-            }
-        }
-
-        if (mapValue != null) {
-            entryRemoved(false, key, createdValue, mapValue);
-            return mapValue;
-        } else {
-            trimToSize(maxSize);
-            return createdValue;
-        }
-    }
-
-    /**
-     * Caches {@code value} for {@code key}. The value is moved to the head of
-     * the queue.
-     *
-     * @return the previous value mapped by {@code key}.
-     */
-    public final V put(K key, V value) {
-        if (key == null || value == null) {
-            throw new NullPointerException("key == null || value == null");
-        }
-
-        V previous;
-        synchronized (this) {
-            putCount++;
-            size += safeSizeOf(key, value);
-            previous = map.put(key, value);
-            if (previous != null) {
-                size -= safeSizeOf(key, previous);
-            }
-        }
-
-        if (previous != null) {
-            entryRemoved(false, key, previous, value);
-        }
-
-        trimToSize(maxSize);
-        return previous;
-    }
-
-    /**
-     * @param maxSize the maximum size of the cache before returning. May be -1
-     *     to evict even 0-sized elements.
-     */
-    private void trimToSize(int maxSize) {
-        while (true) {
-            K key;
-            V value;
-            synchronized (this) {
-                if (size < 0 || (map.isEmpty() && size != 0)) {
-                    throw new IllegalStateException(getClass().getName()
-                            + ".sizeOf() is reporting inconsistent results!");
-                }
-
-                if (size <= maxSize || map.isEmpty()) {
-                    break;
-                }
-
-                Map.Entry<K, V> toEvict = map.entrySet().iterator().next();
-                key = toEvict.getKey();
-                value = toEvict.getValue();
-                map.remove(key);
-                size -= safeSizeOf(key, value);
-                evictionCount++;
-            }
-
-            entryRemoved(true, key, value, null);
-        }
-    }
-
-    /**
-     * Removes the entry for {@code key} if it exists.
-     *
-     * @return the previous value mapped by {@code key}.
-     */
-    public final V remove(K key) {
-        if (key == null) {
-            throw new NullPointerException("key == null");
-        }
-
-        V previous;
-        synchronized (this) {
-            previous = map.remove(key);
-            if (previous != null) {
-                size -= safeSizeOf(key, previous);
-            }
-        }
-
-        if (previous != null) {
-            entryRemoved(false, key, previous, null);
-        }
-
-        return previous;
-    }
-
-    /**
-     * Called for entries that have been evicted or removed. This method is
-     * invoked when a value is evicted to make space, removed by a call to
-     * {@link #remove}, or replaced by a call to {@link #put}. The default
-     * implementation does nothing.
-     *
-     * <p>The method is called without synchronization: other threads may
-     * access the cache while this method is executing.
-     *
-     * @param evicted true if the entry is being removed to make space, false
-     *     if the removal was caused by a {@link #put} or {@link #remove}.
-     * @param newValue the new value for {@code key}, if it exists. If non-null,
-     *     this removal was caused by a {@link #put}. Otherwise it was caused by
-     *     an eviction or a {@link #remove}.
-     */
-    protected void entryRemoved(boolean evicted, K key, V oldValue, V newValue) {}
-
-    /**
-     * Called after a cache miss to compute a value for the corresponding key.
-     * Returns the computed value or null if no value can be computed. The
-     * default implementation returns null.
-     *
-     * <p>The method is called without synchronization: other threads may
-     * access the cache while this method is executing.
-     *
-     * <p>If a value for {@code key} exists in the cache when this method
-     * returns, the created value will be released with {@link #entryRemoved}
-     * and discarded. This can occur when multiple threads request the same key
-     * at the same time (causing multiple values to be created), or when one
-     * thread calls {@link #put} while another is creating a value for the same
-     * key.
-     */
-    protected V create(K key) {
-        return null;
-    }
-
-    private int safeSizeOf(K key, V value) {
-        int result = sizeOf(key, value);
-        if (result < 0) {
-            throw new IllegalStateException("Negative size: " + key + "=" + value);
-        }
-        return result;
-    }
-
-    /**
-     * Returns the size of the entry for {@code key} and {@code value} in
-     * user-defined units.  The default implementation returns 1 so that size
-     * is the number of entries and max size is the maximum number of entries.
-     *
-     * <p>An entry's size must not change while it is in the cache.
-     */
-    protected int sizeOf(K key, V value) {
-        return 1;
-    }
-
-    /**
-     * Clear the cache, calling {@link #entryRemoved} on each removed entry.
-     */
-    public final void evictAll() {
-        trimToSize(-1); // -1 will evict 0-sized elements
-    }
-
-    /**
-     * For caches that do not override {@link #sizeOf}, this returns the number
-     * of entries in the cache. For all other caches, this returns the sum of
-     * the sizes of the entries in this cache.
-     */
-    public synchronized final int size() {
-        return size;
-    }
-
-    public void setMaxSize(int maxSize) {
-        this.maxSize = maxSize;
-    }
-
-    /**
-     * For caches that do not override {@link #sizeOf}, this returns the maximum
-     * number of entries in the cache. For all other caches, this returns the
-     * maximum sum of the sizes of the entries in this cache.
-     */
-    public synchronized final int maxSize() {
-        return maxSize;
-    }
-
-    /**
-     * Returns the number of times {@link #get} returned a value.
-     */
-    public synchronized final int hitCount() {
-        return hitCount;
-    }
-
-    /**
-     * Returns the number of times {@link #get} returned null or required a new
-     * value to be created.
-     */
-    public synchronized final int missCount() {
-        return missCount;
-    }
-
-    /**
-     * Returns the number of times {@link #create(Object)} returned a value.
-     */
-    public synchronized final int createCount() {
-        return createCount;
-    }
-
-    /**
-     * Returns the number of times {@link #put} was called.
-     */
-    public synchronized final int putCount() {
-        return putCount;
-    }
-
-    /**
-     * Returns the number of values that have been evicted.
-     */
-    public synchronized final int evictionCount() {
-        return evictionCount;
-    }
-
-    /**
-     * Returns a copy of the current contents of the cache, ordered from least
-     * recently accessed to most recently accessed.
-     */
-    public synchronized final Map<K, V> snapshot() {
-        return new LinkedHashMap<K, V>(map);
-    }
-
-    @Override public synchronized final String toString() {
-        int accesses = hitCount + missCount;
-        int hitPercent = accesses != 0 ? (100 * hitCount / accesses) : 0;
-        return String.format("LruCache[maxSize=%d,hits=%d,misses=%d,hitRate=%d%%]",
-                maxSize, hitCount, missCount, hitPercent);
-    }
-}
diff --git a/ion/src/com/koushikdutta/ion/loader/FileLoader.java b/ion/src/com/koushikdutta/ion/loader/FileLoader.java
index 825b043a..5b6444da 100644
--- a/ion/src/com/koushikdutta/ion/loader/FileLoader.java
+++ b/ion/src/com/koushikdutta/ion/loader/FileLoader.java
@@ -5,7 +5,6 @@
 import android.graphics.BitmapFactory;
 import android.graphics.Point;
 import android.text.TextUtils;
-import android.util.Log;
 
 import com.koushikdutta.async.DataEmitter;
 import com.koushikdutta.async.FileDataEmitter;
@@ -13,17 +12,15 @@
 import com.koushikdutta.async.future.FutureCallback;
 import com.koushikdutta.async.future.SimpleFuture;
 import com.koushikdutta.async.http.AsyncHttpRequest;
-import com.koushikdutta.async.http.libcore.IoUtils;
+import com.koushikdutta.async.util.StreamUtility;
 import com.koushikdutta.ion.Ion;
 import com.koushikdutta.ion.Loader;
 import com.koushikdutta.ion.bitmap.BitmapInfo;
 import com.koushikdutta.ion.gif.GifAction;
 import com.koushikdutta.ion.gif.GifDecoder;
 
-import java.io.BufferedInputStream;
 import java.io.File;
 import java.io.FileInputStream;
-import java.io.IOException;
 import java.io.InputStream;
 import java.net.URI;
 
@@ -67,7 +64,7 @@ public boolean parseOk(boolean parseStatus, int frameIndex) {
                             }
                         });
                         decoder.run();
-                        IoUtils.closeQuietly(fin);
+                        StreamUtility.closeQuietly(fin);
                         if (decoder.getFrameCount() == 0)
                             throw new Exception("failed to load gif");
                         bitmaps = new Bitmap[decoder.getFrameCount()];
diff --git a/ion/src/com/koushikdutta/ion/loader/VideoLoader.java b/ion/src/com/koushikdutta/ion/loader/VideoLoader.java
index 068716fb..ae31cbb8 100644
--- a/ion/src/com/koushikdutta/ion/loader/VideoLoader.java
+++ b/ion/src/com/koushikdutta/ion/loader/VideoLoader.java
@@ -22,11 +22,6 @@
  * Created by koush on 11/6/13.
  */
 public class VideoLoader extends SimpleLoader {
-    private boolean useThumbnailUtils;
-    public void useThumbnailUtils(boolean useThumbnailUtils) {
-        this.useThumbnailUtils = useThumbnailUtils;
-    }
-
     @TargetApi(Build.VERSION_CODES.GINGERBREAD_MR1)
     public static Bitmap createVideoThumbnail(String filePath) throws Exception {
         MediaMetadataRetriever retriever = new MediaMetadataRetriever();
@@ -34,6 +29,12 @@ public static Bitmap createVideoThumbnail(String filePath) throws Exception {
         return retriever.getFrameAtTime();
     }
 
+    static boolean mustUseThumbnailUtils() {
+        // http://developer.samsung.com/forum/thread/mediametadataretriever-getframeattime-to-retrieve-video-frame-fails/77/202945
+        // https://codereview.chromium.org/107523005
+        return Build.MANUFACTURER.toLowerCase().contains("samsung");
+    }
+
     @Override
     public Future<BitmapInfo> loadBitmap(Context context, Ion ion, final String key, final String uri, int resizeWidth, int resizeHeight, boolean animateGif) {
         if (!uri.startsWith(ContentResolver.SCHEME_FILE))
@@ -54,7 +55,8 @@ public void run() {
                 }
                 try {
                     Bitmap bmp;
-                    if (useThumbnailUtils || Build.VERSION.SDK_INT < Build.VERSION_CODES.GINGERBREAD_MR1)
+
+                    if (mustUseThumbnailUtils() || Build.VERSION.SDK_INT < Build.VERSION_CODES.GINGERBREAD_MR1)
                         bmp = ThumbnailUtils.createVideoThumbnail(file.getAbsolutePath(), MediaStore.Video.Thumbnails.MINI_KIND);
                     else
                         bmp = createVideoThumbnail(file.getAbsolutePath());
