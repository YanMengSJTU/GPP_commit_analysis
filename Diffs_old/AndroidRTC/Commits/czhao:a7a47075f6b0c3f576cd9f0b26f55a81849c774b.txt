diff --git a/app/src/main/AndroidManifest.xml b/app/src/main/AndroidManifest.xml
index 066dbbc..0386633 100644
--- a/app/src/main/AndroidManifest.xml
+++ b/app/src/main/AndroidManifest.xml
@@ -31,7 +31,9 @@
 
         <activity
             android:name=".HomeActivity"
-            android:label="@string/app_name" >
+            android:label="@string/app_name"
+            android:screenOrientation="portrait"
+            >
 
             <intent-filter>
                 <action android:name="android.intent.action.MAIN" />
diff --git a/app/src/main/java/fr/pchab/androidrtc/RtcAudioActivity.java b/app/src/main/java/fr/pchab/androidrtc/RtcAudioActivity.java
index f341634..8f86848 100644
--- a/app/src/main/java/fr/pchab/androidrtc/RtcAudioActivity.java
+++ b/app/src/main/java/fr/pchab/androidrtc/RtcAudioActivity.java
@@ -8,6 +8,7 @@
 import android.nfc.NfcAdapter;
 import android.nfc.NfcEvent;
 import android.os.Bundle;
+import android.util.Log;
 import android.view.View;
 import android.view.Window;
 import android.view.WindowManager.LayoutParams;
@@ -18,6 +19,7 @@
 import org.webrtc.VideoRendererGui;
 
 import fr.pchab.webrtcclient.AppRTCAudioManager;
+import fr.pchab.webrtcclient.AppRTCUtils;
 import fr.pchab.webrtcclient.PeerConnectionParameters;
 import fr.pchab.webrtcclient.WebRtcClient;
 
@@ -42,6 +44,7 @@
     @Override
     public void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
+        Log.d("audio_activity", "onCreate");
         getWindow().addFlags(
                 LayoutParams.FLAG_KEEP_SCREEN_ON
                         | LayoutParams.FLAG_DISMISS_KEYGUARD
@@ -73,6 +76,7 @@ public void onClick(View view) {
                 //output the caller ID
                 Toast.makeText(RtcAudioActivity.this,"Session End "+ mSessionId, Toast.LENGTH_SHORT).show();
                 disconnect();
+                setResult(Activity.RESULT_OK);
                 finish();
             }
         });
@@ -90,19 +94,21 @@ public void onClick(View view) {
     }
 
     private void init() {
-        PeerConnectionParameters parameters = new PeerConnectionParameters(false, false, 0, 0, 30, 1, VIDEO_CODEC_VP9, false, 1, AUDIO_CODEC_OPUS, true);
+        Log.d("audio_activity","init");
+        PeerConnectionParameters parameters = new PeerConnectionParameters(false, false,
+                0, 0, 30, 1, VIDEO_CODEC_VP9, false,
+                32, AppRTCUtils.AUDIO_CODEC_ISAC, false, true);
         client = new WebRtcClient(this, mSocketAddress, parameters, VideoRendererGui.getEGLContext());
         client.start("android_test");
         //configure the audio manager
-        audioManager = AppRTCAudioManager.create(this, new Runnable() {
+        /*audioManager = AppRTCAudioManager.create(this, new Runnable() {
                     @Override
                     public void run() {
                         onAudioManageStatusChanged();
-
                     }
                 }
         );
-        audioManager.init();
+        audioManager.init();*/
     }
 
     @TargetApi(16)
@@ -120,6 +126,7 @@ public NdefMessage createNdefMessage(NfcEvent nfcEvent) {
     @Override
     public void onPause() {
         super.onPause();
+        Log.d("audio_activity","onPause");
         if(client != null) {
             client.onPause();
         }
@@ -134,15 +141,20 @@ public void onNewIntent(Intent intent) {
     @Override
     public void onResume() {
         super.onResume();
-
+        Log.d("audio_activity","onResume");
         if(client != null) {
             client.onResume();
         }
     }
 
     @Override
-    public void onDestroy() {
+    public void onBackPressed() {
         disconnect();
+        super.onBackPressed();
+    }
+
+    @Override
+    public void onDestroy() {
         super.onDestroy();
     }
 
@@ -160,15 +172,18 @@ public void run() {
     }
 
     private void disconnect(){
-        if (audioManager != null){
-            audioManager.close();
-            audioManager = null;
-        }
 
         if (client != null) {
             client.onDestroy();
             client = null;
         }
+
+        if (audioManager != null){
+            audioManager.close();
+            audioManager = null;
+        }
+
+        Log.d("audio_activity","disconnect");
     }
 
     public void answer(String callerId) throws JSONException {
diff --git a/app/src/main/java/fr/pchab/androidrtc/RtcVideoActivity.java b/app/src/main/java/fr/pchab/androidrtc/RtcVideoActivity.java
index d592cb6..8b25c99 100644
--- a/app/src/main/java/fr/pchab/androidrtc/RtcVideoActivity.java
+++ b/app/src/main/java/fr/pchab/androidrtc/RtcVideoActivity.java
@@ -133,7 +133,7 @@ private void init() {
         Point displaySize = new Point();
         getWindowManager().getDefaultDisplay().getSize(displaySize);
         PeerConnectionParameters params = new PeerConnectionParameters(
-                VIDEO_ENABLED, false, displaySize.x, displaySize.y, 30, 1, VIDEO_CODEC_VP9, true, 1, AUDIO_CODEC_OPUS, true);
+                VIDEO_ENABLED, false, displaySize.x, displaySize.y, 30, 1, VIDEO_CODEC_VP9, true, 1, AUDIO_CODEC_OPUS, false, true);
         client = new WebRtcClient(this, mSocketAddress, params, VideoRendererGui.getEGLContext());
     }
 
diff --git a/webrtc-client/src/main/java/fr/pchab/webrtcclient/AppRTCAudioManager.java b/webrtc-client/src/main/java/fr/pchab/webrtcclient/AppRTCAudioManager.java
index 526c262..a756f12 100644
--- a/webrtc-client/src/main/java/fr/pchab/webrtcclient/AppRTCAudioManager.java
+++ b/webrtc-client/src/main/java/fr/pchab/webrtcclient/AppRTCAudioManager.java
@@ -140,16 +140,18 @@ public void init() {
         // Register receiver for broadcast intents related to adding/removing a
         // wired headset (Intent.ACTION_HEADSET_PLUG).
         registerForWiredHeadsetIntentBroadcast();
+        Log.d("audio_activity", "register_ib");
 
         initialized = true;
     }
 
     public void close() {
-        Log.d(TAG, "close");
+        Log.d("audio_activity", "close");
         if (!initialized) {
             return;
         }
 
+        Log.d("audio_activity", "unregister_ib");
         unregisterForWiredHeadsetIntentBroadcast();
 
         // Restore previously stored audio states.
diff --git a/webrtc-client/src/main/java/fr/pchab/webrtcclient/AppRTCUtils.java b/webrtc-client/src/main/java/fr/pchab/webrtcclient/AppRTCUtils.java
index 9dabf15..002e7ec 100755
--- a/webrtc-client/src/main/java/fr/pchab/webrtcclient/AppRTCUtils.java
+++ b/webrtc-client/src/main/java/fr/pchab/webrtcclient/AppRTCUtils.java
@@ -30,13 +30,24 @@
 import android.os.Build;
 import android.util.Log;
 
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
 /**
  * AppRTCUtils provides helper functions for managing thread safety.
  */
 public final class AppRTCUtils {
 
-  private AppRTCUtils() {
-  }
+    private static final String VIDEO_CODEC_PARAM_START_BITRATE =
+            "x-google-start-bitrate";
+    private static final String AUDIO_CODEC_PARAM_BITRATE = "maxaveragebitrate";
+
+    private static final String TAG = "PCRTCClient";
+
+    public static final String AUDIO_CODEC_OPUS = "opus";
+    public static final String AUDIO_CODEC_ISAC = "ISAC";
+
+    private AppRTCUtils() {}
 
   /**
    * NonThreadSafe is a helper class used to help verify that methods of a
@@ -81,4 +92,140 @@ public static void logDeviceInfo(String tag) {
         + "Model: " + Build.MODEL + ", "
         + "Product: " + Build.PRODUCT);
   }
+
+    /**
+     * Modify the configuration
+     * @param codec
+     * @param isVideoCodec
+     * @param sdpDescription
+     * @param bitrateKbps
+     * @return
+     */
+    public static String setStartBitrate(String codec, boolean isVideoCodec,
+                                          String sdpDescription, int bitrateKbps) {
+        String[] lines = sdpDescription.split("\r\n");
+        int rtpmapLineIndex = -1;
+        boolean sdpFormatUpdated = false;
+        String codecRtpMap = null;
+        // Search for codec rtpmap in format
+        // a=rtpmap:<payload type> <encoding name>/<clock rate> [/<encoding parameters>]
+        String regex = "^a=rtpmap:(\\d+) " + codec + "(/\\d+)+[\r]?$";
+        Pattern codecPattern = Pattern.compile(regex);
+        for (int i = 0; i < lines.length; i++) {
+            Matcher codecMatcher = codecPattern.matcher(lines[i]);
+            if (codecMatcher.matches()) {
+                codecRtpMap = codecMatcher.group(1);
+                rtpmapLineIndex = i;
+                break;
+            }
+        }
+        if (codecRtpMap == null) {
+            Log.w(TAG, "No rtpmap for " + codec + " codec");
+            return sdpDescription;
+        }
+        Log.d(TAG, "Found " +  codec + " rtpmap " + codecRtpMap
+                + " at " + lines[rtpmapLineIndex]);
+
+        // Check if a=fmtp string already exist in remote SDP for this codec and
+        // update it with new bitrate parameter.
+        regex = "^a=fmtp:" + codecRtpMap + " \\w+=\\d+.*[\r]?$";
+        codecPattern = Pattern.compile(regex);
+        for (int i = 0; i < lines.length; i++) {
+            Matcher codecMatcher = codecPattern.matcher(lines[i]);
+            if (codecMatcher.matches()) {
+                Log.d(TAG, "Found " +  codec + " " + lines[i]);
+                if (isVideoCodec) {
+                    lines[i] += "; " + VIDEO_CODEC_PARAM_START_BITRATE
+                            + "=" + bitrateKbps;
+                } else {
+                    lines[i] += "; " + AUDIO_CODEC_PARAM_BITRATE
+                            + "=" + (bitrateKbps * 1000);
+                }
+                Log.d(TAG, "Update remote SDP line: " + lines[i]);
+                sdpFormatUpdated = true;
+                break;
+            }
+        }
+
+        StringBuilder newSdpDescription = new StringBuilder();
+        for (int i = 0; i < lines.length; i++) {
+            newSdpDescription.append(lines[i]).append("\r\n");
+            // Append new a=fmtp line if no such line exist for a codec.
+            if (!sdpFormatUpdated && i == rtpmapLineIndex) {
+                String bitrateSet;
+                if (isVideoCodec) {
+                    bitrateSet = "a=fmtp:" + codecRtpMap + " "
+                            + VIDEO_CODEC_PARAM_START_BITRATE + "=" + bitrateKbps;
+                } else {
+                    bitrateSet = "a=fmtp:" + codecRtpMap + " "
+                            + AUDIO_CODEC_PARAM_BITRATE + "=" + (bitrateKbps * 1000);
+                }
+                Log.d(TAG, "Add remote SDP line: " + bitrateSet);
+                newSdpDescription.append(bitrateSet).append("\r\n");
+            }
+
+        }
+        return newSdpDescription.toString();
+    }
+
+    public static String preferCodec(
+            String sdpDescription, String codec, boolean isAudio) {
+        String[] lines = sdpDescription.split("\r\n");
+        int mLineIndex = -1;
+        String codecRtpMap = null;
+        // a=rtpmap:<payload type> <encoding name>/<clock rate> [/<encoding parameters>]
+        String regex = "^a=rtpmap:(\\d+) " + codec + "(/\\d+)+[\r]?$";
+        Pattern codecPattern = Pattern.compile(regex);
+        String mediaDescription = "m=video ";
+        if (isAudio) {
+            mediaDescription = "m=audio ";
+        }
+        for (int i = 0; (i < lines.length)
+                && (mLineIndex == -1 || codecRtpMap == null); i++) {
+            if (lines[i].startsWith(mediaDescription)) {
+                mLineIndex = i;
+                continue;
+            }
+            Matcher codecMatcher = codecPattern.matcher(lines[i]);
+            if (codecMatcher.matches()) {
+                codecRtpMap = codecMatcher.group(1);
+                continue;
+            }
+        }
+        if (mLineIndex == -1) {
+            Log.w(TAG, "No " + mediaDescription + " line, so can't prefer " + codec);
+            return sdpDescription;
+        }
+        if (codecRtpMap == null) {
+            Log.w(TAG, "No rtpmap for " + codec);
+            return sdpDescription;
+        }
+        Log.d(TAG, "Found " +  codec + " rtpmap " + codecRtpMap + ", prefer at "
+                + lines[mLineIndex]);
+        String[] origMLineParts = lines[mLineIndex].split(" ");
+        if (origMLineParts.length > 3) {
+            StringBuilder newMLine = new StringBuilder();
+            int origPartIndex = 0;
+            // Format is: m=<media> <port> <proto> <fmt> ...
+            newMLine.append(origMLineParts[origPartIndex++]).append(" ");
+            newMLine.append(origMLineParts[origPartIndex++]).append(" ");
+            newMLine.append(origMLineParts[origPartIndex++]).append(" ");
+            newMLine.append(codecRtpMap);
+            for (; origPartIndex < origMLineParts.length; origPartIndex++) {
+                if (!origMLineParts[origPartIndex].equals(codecRtpMap)) {
+                    newMLine.append(" ").append(origMLineParts[origPartIndex]);
+                }
+            }
+            lines[mLineIndex] = newMLine.toString();
+            Log.d(TAG, "Change media description: " + lines[mLineIndex]);
+        } else {
+            Log.e(TAG, "Wrong SDP media description format: " + lines[mLineIndex]);
+        }
+        StringBuilder newSdpDescription = new StringBuilder();
+        for (String line : lines) {
+            newSdpDescription.append(line).append("\r\n");
+        }
+        return newSdpDescription.toString();
+    }
+
 }
diff --git a/webrtc-client/src/main/java/fr/pchab/webrtcclient/PeerConnectionParameters.java b/webrtc-client/src/main/java/fr/pchab/webrtcclient/PeerConnectionParameters.java
index 8171342..9d5e0ca 100644
--- a/webrtc-client/src/main/java/fr/pchab/webrtcclient/PeerConnectionParameters.java
+++ b/webrtc-client/src/main/java/fr/pchab/webrtcclient/PeerConnectionParameters.java
@@ -10,13 +10,30 @@
     public final String videoCodec;
     public final boolean videoCodecHwAcceleration;
     public final int audioStartBitrate;
+    public final boolean noAudioProcessing;
     public final String audioCodec;
     public final boolean cpuOveruseDetection;
+
+    /**
+     *
+     * @param videoCallEnabled whether enable video or not
+     * @param loopback
+     * @param videoWidth
+     * @param videoHeight
+     * @param videoFps
+     * @param videoStartBitrate
+     * @param videoCodec
+     * @param videoCodecHwAcceleration
+     * @param audioStartBitrate bit rate for audio transmission
+     * @param audioCodec codec used for audio
+     * @param noAudioProcessing true to disable audio processing
+     * @param cpuOveruseDetection set true to detect CPI overuse
+     */
     public PeerConnectionParameters(
             boolean videoCallEnabled, boolean loopback,
             int videoWidth, int videoHeight, int videoFps, int videoStartBitrate,
             String videoCodec, boolean videoCodecHwAcceleration,
-            int audioStartBitrate, String audioCodec,
+            int audioStartBitrate, String audioCodec, boolean noAudioProcessing,
             boolean cpuOveruseDetection) {
         this.videoCallEnabled = videoCallEnabled;
         this.loopback = loopback;
@@ -28,6 +45,7 @@ public PeerConnectionParameters(
         this.videoCodecHwAcceleration = videoCodecHwAcceleration;
         this.audioStartBitrate = audioStartBitrate;
         this.audioCodec = audioCodec;
+        this.noAudioProcessing = noAudioProcessing;
         this.cpuOveruseDetection = cpuOveruseDetection;
     }
 }
\ No newline at end of file
diff --git a/webrtc-client/src/main/java/fr/pchab/webrtcclient/WebRtcClient.java b/webrtc-client/src/main/java/fr/pchab/webrtcclient/WebRtcClient.java
index a021f0c..81624b5 100644
--- a/webrtc-client/src/main/java/fr/pchab/webrtcclient/WebRtcClient.java
+++ b/webrtc-client/src/main/java/fr/pchab/webrtcclient/WebRtcClient.java
@@ -28,6 +28,12 @@
     private RtcListener mListener;
     private Socket client;
 
+    private static final String AUDIO_CODEC_PARAM_BITRATE = "maxaveragebitrate";
+    private static final String AUDIO_ECHO_CANCELLATION_CONSTRAINT = "googEchoCancellation";
+    private static final String AUDIO_AUTO_GAIN_CONTROL_CONSTRAINT= "googAutoGainControl";
+    private static final String AUDIO_HIGH_PASS_FILTER_CONSTRAINT  = "googHighpassFilter";
+    private static final String AUDIO_NOISE_SUPPRESSION_CONSTRAINT = "googNoiseSuppression";
+
     public interface STATUS {
         int NONE = 0;
         int CONNECTING = 1;
@@ -64,13 +70,13 @@ public void execute(String peerId, JSONObject payload) throws JSONException {
 
     private class CreateAnswerCommand implements Command{
         public void execute(String peerId, JSONObject payload) throws JSONException {
-            Log.d(TAG,"CreateAnswerCommand");
+            Log.d(TAG, "CreateAnswerCommand");
             Peer peer = peers.get(peerId);
             SessionDescription sdp = new SessionDescription(
                     SessionDescription.Type.fromCanonicalForm(payload.getString("type")),
                     payload.getString("sdp")
             );
-            peer.pc.setRemoteDescription(peer, sdp);
+            peer.pc.setRemoteDescription(peer, overrideRemoteDescription(sdp));
             peer.pc.createAnswer(peer, pcConstraints);
         }
     }
@@ -83,8 +89,24 @@ public void execute(String peerId, JSONObject payload) throws JSONException {
                     SessionDescription.Type.fromCanonicalForm(payload.getString("type")),
                     payload.getString("sdp")
             );
-            peer.pc.setRemoteDescription(peer, sdp);
+            peer.pc.setRemoteDescription(peer, overrideRemoteDescription(sdp));
+        }
+    }
+
+    private SessionDescription overrideRemoteDescription(SessionDescription sdp){
+        String sdpDescription = sdp.description;
+
+        //support audio configuration only
+        if (pcParams.audioStartBitrate > 0){
+            sdpDescription = AppRTCUtils.setStartBitrate(AppRTCUtils.AUDIO_CODEC_OPUS, false, sdpDescription, pcParams.audioStartBitrate);
         }
+
+        if (pcParams.audioCodec.equals(AppRTCUtils.AUDIO_CODEC_ISAC)){
+            sdpDescription = AppRTCUtils.preferCodec(sdpDescription,AppRTCUtils.AUDIO_CODEC_ISAC, true);
+        }
+        return new SessionDescription(
+                sdp.type, sdpDescription);
+
     }
 
     private class AddIceCandidateCommand implements Command{
@@ -140,6 +162,9 @@ public void call(Object... args) {
                     if(!type.equals("init")) {
                         payload = data.getJSONObject("payload");
                     }
+
+                    Log.e("test","onMessage from:"+from+" type:" +type);
+
                     // if peer is unknown, try to add him
                     if(!peers.containsKey(from)) {
                         // if MAX_PEER is reach, ignore the call
@@ -173,10 +198,22 @@ public void call(Object... args) {
         private int endPoint;
 
         @Override
-        public void onCreateSuccess(final SessionDescription sdp) {
-            // TODO: modify sdp to use pcParams prefered codecs
+        public void onCreateSuccess(final SessionDescription origSdp) {
             try {
                 JSONObject payload = new JSONObject();
+
+                String sdpDescription = origSdp.description;
+
+                //modify sdp to use pcParams preferred codecs
+                /*if (preferIsac) {
+                    sdpDescription = preferCodec(sdpDescription, AUDIO_CODEC_ISAC, true);
+                }
+                if (videoCallEnabled && preferH264) {
+                    sdpDescription = preferCodec(sdpDescription, VIDEO_CODEC_H264, false);
+                }*/
+                final SessionDescription sdp = new SessionDescription(
+                        origSdp.type, sdpDescription);
+
                 payload.put("type", sdp.type.canonicalForm());
                 payload.put("sdp", sdp.description);
                 sendMessage(id, sdp.type.canonicalForm(), payload);
@@ -324,9 +361,14 @@ public void onDestroy() {
         if (videoSource != null) {
             videoSource.stop();
         }
-        factory.dispose();
-        client.disconnect();
+
+        if (factory != null) {
+            factory.dispose();
+            factory = null;
+        }
         client.close();
+        client.disconnect();
+        client = null;
     }
 
     private int findEndPoint() {
@@ -343,7 +385,7 @@ private int findEndPoint() {
      * @param name client name
      */
     public void start(String name){
-        setCamera();
+        configOutput();
         try {
             JSONObject message = new JSONObject();
             message.put("name", name);
@@ -353,7 +395,7 @@ public void start(String name){
         }
     }
 
-    private void setCamera(){
+    private void configOutput(){
         localMS = factory.createLocalMediaStream("ARDAMS");
         if(pcParams.videoCallEnabled){
             MediaConstraints videoConstraints = new MediaConstraints();
@@ -366,7 +408,21 @@ private void setCamera(){
             localMS.addTrack(factory.createVideoTrack("ARDAMSv0", videoSource));
         }
 
-        AudioSource audioSource = factory.createAudioSource(new MediaConstraints());
+        MediaConstraints audioConstraints = new MediaConstraints();
+
+        if (pcParams.noAudioProcessing) {
+            Log.d(TAG, "Disabling audio processing");
+            audioConstraints.mandatory.add(new MediaConstraints.KeyValuePair(
+                    AUDIO_ECHO_CANCELLATION_CONSTRAINT, "false"));
+            audioConstraints.mandatory.add(new MediaConstraints.KeyValuePair(
+                    AUDIO_AUTO_GAIN_CONTROL_CONSTRAINT, "false"));
+            audioConstraints.mandatory.add(new MediaConstraints.KeyValuePair(
+                    AUDIO_HIGH_PASS_FILTER_CONSTRAINT, "false"));
+            audioConstraints.mandatory.add(new MediaConstraints.KeyValuePair(
+                    AUDIO_NOISE_SUPPRESSION_CONSTRAINT , "false"));
+        }
+
+        AudioSource audioSource = factory.createAudioSource(audioConstraints);
         localMS.addTrack(factory.createAudioTrack("ARDAMSa0", audioSource));
 
         mListener.onLocalStream(localMS);
