diff --git a/pom.xml b/pom.xml
index a389b655c..271601784 100644
--- a/pom.xml
+++ b/pom.xml
@@ -49,7 +49,7 @@
 
     <!-- Dependencies -->
     <android.version>4.1.1.4</android.version>
-    <okhttp.version>3.10.0</okhttp.version>
+    <okhttp.version>3.11.0</okhttp.version>
     <animal.sniffer.version>1.14</animal.sniffer.version>
 
     <!-- Adapter Dependencies -->
diff --git a/retrofit-adapters/guava/README.md b/retrofit-adapters/guava/README.md
index b1449e80e..c2c3badfa 100644
--- a/retrofit-adapters/guava/README.md
+++ b/retrofit-adapters/guava/README.md
@@ -37,7 +37,7 @@ Download [the latest JAR][2] or grab via [Maven][3]:
 ```
 or [Gradle][3]:
 ```groovy
-compile 'com.squareup.retrofit2:adapter-guava:latest.version'
+implementation 'com.squareup.retrofit2:adapter-guava:latest.version'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/StringConverterFactory.java b/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/StringConverterFactory.java
index bb9ccf189..f56fcf63a 100644
--- a/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/StringConverterFactory.java
+++ b/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/StringConverterFactory.java
@@ -39,7 +39,7 @@
       Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     return new Converter<String, RequestBody>() {
       @Override public RequestBody convert(String value) throws IOException {
-        return RequestBody.create(MediaType.parse("text/plain"), value);
+        return RequestBody.create(MediaType.get("text/plain"), value);
       }
     };
   }
diff --git a/retrofit-adapters/java8/README.md b/retrofit-adapters/java8/README.md
index 83424c809..31f98f7fd 100644
--- a/retrofit-adapters/java8/README.md
+++ b/retrofit-adapters/java8/README.md
@@ -37,7 +37,7 @@ Download [the latest JAR][2] or grab via [Maven][3]:
 ```
 or [Gradle][3]:
 ```groovy
-compile 'com.squareup.retrofit2:adapter-java8:latest.version'
+implementation 'com.squareup.retrofit2:adapter-java8:latest.version'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/StringConverterFactory.java b/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/StringConverterFactory.java
index de4b63e61..81c6ec90b 100644
--- a/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/StringConverterFactory.java
+++ b/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/StringConverterFactory.java
@@ -39,7 +39,7 @@
       Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     return new Converter<String, RequestBody>() {
       @Override public RequestBody convert(String value) throws IOException {
-        return RequestBody.create(MediaType.parse("text/plain"), value);
+        return RequestBody.create(MediaType.get("text/plain"), value);
       }
     };
   }
diff --git a/retrofit-adapters/rxjava/README.md b/retrofit-adapters/rxjava/README.md
index 3352daf8f..9b0a95828 100644
--- a/retrofit-adapters/rxjava/README.md
+++ b/retrofit-adapters/rxjava/README.md
@@ -50,7 +50,7 @@ Download [the latest JAR][2] or grab via [Maven][3]:
 ```
 or [Gradle][3]:
 ```groovy
-compile 'com.squareup.retrofit2:adapter-rxjava:latest.version'
+implementation 'com.squareup.retrofit2:adapter-rxjava:latest.version'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/StringConverterFactory.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/StringConverterFactory.java
index c44038d02..49de8bf19 100644
--- a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/StringConverterFactory.java
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/StringConverterFactory.java
@@ -39,7 +39,7 @@
       Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     return new Converter<String, RequestBody>() {
       @Override public RequestBody convert(String value) throws IOException {
-        return RequestBody.create(MediaType.parse("text/plain"), value);
+        return RequestBody.create(MediaType.get("text/plain"), value);
       }
     };
   }
diff --git a/retrofit-adapters/rxjava2/README.md b/retrofit-adapters/rxjava2/README.md
index 0512f9fbb..74d14b4be 100644
--- a/retrofit-adapters/rxjava2/README.md
+++ b/retrofit-adapters/rxjava2/README.md
@@ -51,7 +51,7 @@ Download [the latest JAR][2] or grab via [Maven][3]:
 ```
 or [Gradle][3]:
 ```groovy
-compile 'com.squareup.retrofit2:adapter-rxjava2:latest.version'
+implementation 'com.squareup.retrofit2:adapter-rxjava2:latest.version'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallEnqueueObservable.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallEnqueueObservable.java
index 8c7dc4ebc..3c6fa094b 100644
--- a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallEnqueueObservable.java
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallEnqueueObservable.java
@@ -37,7 +37,9 @@
     Call<T> call = originalCall.clone();
     CallCallback<T> callback = new CallCallback<>(call, observer);
     observer.onSubscribe(callback);
-    call.enqueue(callback);
+    if (!callback.isDisposed()) {
+      call.enqueue(callback);
+    }
   }
 
   private static final class CallCallback<T> implements Disposable, Callback<T> {
diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallExecuteObservable.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallExecuteObservable.java
index b4963e075..71b9066e7 100644
--- a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallExecuteObservable.java
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallExecuteObservable.java
@@ -36,6 +36,9 @@
     Call<T> call = originalCall.clone();
     CallDisposable disposable = new CallDisposable(call);
     observer.onSubscribe(disposable);
+    if (disposable.isDisposed()) {
+      return;
+    }
 
     boolean terminated = false;
     try {
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CancelDisposeTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CancelDisposeTest.java
index d643e4eb1..8a9a6c375 100644
--- a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CancelDisposeTest.java
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CancelDisposeTest.java
@@ -59,6 +59,12 @@
     assertTrue(calls.get(0).isCanceled());
   }
 
+  @Test public void disposeBeforeEnqueueDoesNotEnqueue() {
+    service.go().test(true);
+    List<Call> calls = client.dispatcher().runningCalls();
+    assertEquals(0, calls.size());
+  }
+
   @Test public void cancelDoesNotDispose() {
     Disposable disposable = service.go().subscribe();
     List<Call> calls = client.dispatcher().runningCalls();
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CancelDisposeTestSync.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CancelDisposeTestSync.java
new file mode 100644
index 000000000..174536d13
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CancelDisposeTestSync.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Observable;
+import okhttp3.OkHttpClient;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+import static org.junit.Assert.assertEquals;
+
+public final class CancelDisposeTestSync {
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  interface Service {
+    @GET("/") Observable<String> go();
+  }
+
+  private final OkHttpClient client = new OkHttpClient();
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
+        .callFactory(client)
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void disposeBeforeExecuteDoesNotEnqueue() {
+    service.go().test(true);
+    assertEquals(0, server.getRequestCount());
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/StringConverterFactory.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/StringConverterFactory.java
index 5a6841840..c975258cb 100644
--- a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/StringConverterFactory.java
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/StringConverterFactory.java
@@ -39,7 +39,7 @@
       Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     return new Converter<String, RequestBody>() {
       @Override public RequestBody convert(String value) throws IOException {
-        return RequestBody.create(MediaType.parse("text/plain"), value);
+        return RequestBody.create(MediaType.get("text/plain"), value);
       }
     };
   }
diff --git a/retrofit-adapters/scala/README.md b/retrofit-adapters/scala/README.md
index 74aa0a7a1..24c427fed 100644
--- a/retrofit-adapters/scala/README.md
+++ b/retrofit-adapters/scala/README.md
@@ -37,7 +37,7 @@ Download [the latest JAR][2] or grab via [Maven][3]:
 ```
 or [Gradle][3]:
 ```groovy
-compile 'com.squareup.retrofit2:adapter-scala:latest.version'
+implementation 'com.squareup.retrofit2:adapter-scala:latest.version'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/retrofit-adapters/scala/src/test/java/retrofit2/adapter/scala/StringConverterFactory.java b/retrofit-adapters/scala/src/test/java/retrofit2/adapter/scala/StringConverterFactory.java
index d14596c40..a46c087d3 100644
--- a/retrofit-adapters/scala/src/test/java/retrofit2/adapter/scala/StringConverterFactory.java
+++ b/retrofit-adapters/scala/src/test/java/retrofit2/adapter/scala/StringConverterFactory.java
@@ -39,7 +39,7 @@
       Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     return new Converter<String, RequestBody>() {
       @Override public RequestBody convert(String value) throws IOException {
-        return RequestBody.create(MediaType.parse("text/plain"), value);
+        return RequestBody.create(MediaType.get("text/plain"), value);
       }
     };
   }
diff --git a/retrofit-converters/gson/README.md b/retrofit-converters/gson/README.md
index 980d1d1f0..814f49ab1 100644
--- a/retrofit-converters/gson/README.md
+++ b/retrofit-converters/gson/README.md
@@ -20,7 +20,7 @@ Download [the latest JAR][2] or grab via [Maven][3]:
 ```
 or [Gradle][3]:
 ```groovy
-compile 'com.squareup.retrofit2:converter-gson:latest.version'
+implementation 'com.squareup.retrofit2:converter-gson:latest.version'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonRequestBodyConverter.java b/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonRequestBodyConverter.java
index 2e30a4478..a47775748 100644
--- a/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonRequestBodyConverter.java
+++ b/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonRequestBodyConverter.java
@@ -28,7 +28,7 @@
 import retrofit2.Converter;
 
 final class GsonRequestBodyConverter<T> implements Converter<T, RequestBody> {
-  private static final MediaType MEDIA_TYPE = MediaType.parse("application/json; charset=UTF-8");
+  private static final MediaType MEDIA_TYPE = MediaType.get("application/json; charset=UTF-8");
   private static final Charset UTF_8 = Charset.forName("UTF-8");
 
   private final Gson gson;
diff --git a/retrofit-converters/guava/README.md b/retrofit-converters/guava/README.md
index 03eae96f5..158a71e59 100644
--- a/retrofit-converters/guava/README.md
+++ b/retrofit-converters/guava/README.md
@@ -18,7 +18,7 @@ Download [the latest JAR][1] or grab via [Maven][2]:
 ```
 or [Gradle][2]:
 ```groovy
-compile 'com.squareup.retrofit2:converter-guava:latest.version'
+implementation 'com.squareup.retrofit2:converter-guava:latest.version'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/retrofit-converters/jackson/README.md b/retrofit-converters/jackson/README.md
index 2335d2903..8436a0de5 100644
--- a/retrofit-converters/jackson/README.md
+++ b/retrofit-converters/jackson/README.md
@@ -20,7 +20,7 @@ Download [the latest JAR][2] or grab via [Maven][3]:
 ```
 or [Gradle][3]:
 ```groovy
-compile 'com.squareup.retrofit2:converter-jackson:latest.version'
+implementation 'com.squareup.retrofit2:converter-jackson:latest.version'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonRequestBodyConverter.java b/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonRequestBodyConverter.java
index bd20a0ae0..85408a479 100644
--- a/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonRequestBodyConverter.java
+++ b/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonRequestBodyConverter.java
@@ -22,7 +22,7 @@
 import retrofit2.Converter;
 
 final class JacksonRequestBodyConverter<T> implements Converter<T, RequestBody> {
-  private static final MediaType MEDIA_TYPE = MediaType.parse("application/json; charset=UTF-8");
+  private static final MediaType MEDIA_TYPE = MediaType.get("application/json; charset=UTF-8");
 
   private final ObjectWriter adapter;
 
diff --git a/retrofit-converters/java8/README.md b/retrofit-converters/java8/README.md
index 696ac23c6..6aa640209 100644
--- a/retrofit-converters/java8/README.md
+++ b/retrofit-converters/java8/README.md
@@ -18,7 +18,7 @@ Download [the latest JAR][1] or grab via [Maven][2]:
 ```
 or [Gradle][2]:
 ```groovy
-compile 'com.squareup.retrofit2:converter-java8:latest.version'
+implementation 'com.squareup.retrofit2:converter-java8:latest.version'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/retrofit-converters/jaxb/README.md b/retrofit-converters/jaxb/README.md
index 76f311eb4..63176ed49 100644
--- a/retrofit-converters/jaxb/README.md
+++ b/retrofit-converters/jaxb/README.md
@@ -21,7 +21,7 @@ Download [the latest JAR][2] or grab via [Maven][3]:
 ```
 or [Gradle][3]:
 ```groovy
-compile 'com.squareup.retrofit2:converter-jaxb:latest.version'
+implementation 'com.squareup.retrofit2:converter-jaxb:latest.version'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/retrofit-converters/jaxb/src/main/java/retrofit2/converter/jaxb/JaxbConverterFactory.java b/retrofit-converters/jaxb/src/main/java/retrofit2/converter/jaxb/JaxbConverterFactory.java
index f0c8116dc..8e140aff6 100644
--- a/retrofit-converters/jaxb/src/main/java/retrofit2/converter/jaxb/JaxbConverterFactory.java
+++ b/retrofit-converters/jaxb/src/main/java/retrofit2/converter/jaxb/JaxbConverterFactory.java
@@ -32,7 +32,7 @@
  * ignored.
  */
 public final class JaxbConverterFactory extends Converter.Factory {
-  static final MediaType XML = MediaType.parse("application/xml; charset=utf-8");
+  static final MediaType XML = MediaType.get("application/xml; charset=utf-8");
 
   /** Create an instance using a default {@link JAXBContext} instance for conversion. */
   public static JaxbConverterFactory create() {
diff --git a/retrofit-converters/moshi/README.md b/retrofit-converters/moshi/README.md
index c5668f9ab..343b22dc0 100644
--- a/retrofit-converters/moshi/README.md
+++ b/retrofit-converters/moshi/README.md
@@ -20,7 +20,7 @@ Download [the latest JAR][2] or grab via [Maven][3]:
 ```
 or [Gradle][3]:
 ```groovy
-compile 'com.squareup.retrofit2:converter-moshi:latest.version'
+implementation 'com.squareup.retrofit2:converter-moshi:latest.version'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiRequestBodyConverter.java b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiRequestBodyConverter.java
index edbcf243e..879d73fc4 100644
--- a/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiRequestBodyConverter.java
+++ b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiRequestBodyConverter.java
@@ -24,7 +24,7 @@
 import retrofit2.Converter;
 
 final class MoshiRequestBodyConverter<T> implements Converter<T, RequestBody> {
-  private static final MediaType MEDIA_TYPE = MediaType.parse("application/json; charset=UTF-8");
+  private static final MediaType MEDIA_TYPE = MediaType.get("application/json; charset=UTF-8");
 
   private final JsonAdapter<T> adapter;
 
diff --git a/retrofit-converters/protobuf/README.md b/retrofit-converters/protobuf/README.md
index 7575a3d6c..2569fe962 100644
--- a/retrofit-converters/protobuf/README.md
+++ b/retrofit-converters/protobuf/README.md
@@ -17,7 +17,7 @@ Download [the latest JAR][2] or grab via [Maven][3]:
 ```
 or [Gradle][3]:
 ```groovy
-compile 'com.squareup.retrofit2:converter-protobuf:latest.version'
+implementation 'com.squareup.retrofit2:converter-protobuf:latest.version'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoRequestBodyConverter.java b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoRequestBodyConverter.java
index 814dc326b..90905db40 100644
--- a/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoRequestBodyConverter.java
+++ b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoRequestBodyConverter.java
@@ -22,7 +22,7 @@
 import retrofit2.Converter;
 
 final class ProtoRequestBodyConverter<T extends MessageLite> implements Converter<T, RequestBody> {
-  private static final MediaType MEDIA_TYPE = MediaType.parse("application/x-protobuf");
+  private static final MediaType MEDIA_TYPE = MediaType.get("application/x-protobuf");
 
   @Override public RequestBody convert(T value) throws IOException {
     byte[] bytes = value.toByteArray();
diff --git a/retrofit-converters/scalars/README.md b/retrofit-converters/scalars/README.md
index 5231b6129..67f0fd15b 100644
--- a/retrofit-converters/scalars/README.md
+++ b/retrofit-converters/scalars/README.md
@@ -18,7 +18,7 @@ Download [the latest JAR][1] or grab via [Maven][2]:
 ```
 or [Gradle][2]:
 ```groovy
-compile 'com.squareup.retrofit2:converter-scalars:latest.version'
+implementation 'com.squareup.retrofit2:converter-scalars:latest.version'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarRequestBodyConverter.java b/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarRequestBodyConverter.java
index fd65200d4..fb2f4ec43 100644
--- a/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarRequestBodyConverter.java
+++ b/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarRequestBodyConverter.java
@@ -22,7 +22,7 @@
 
 final class ScalarRequestBodyConverter<T> implements Converter<T, RequestBody> {
   static final ScalarRequestBodyConverter<Object> INSTANCE = new ScalarRequestBodyConverter<>();
-  private static final MediaType MEDIA_TYPE = MediaType.parse("text/plain; charset=UTF-8");
+  private static final MediaType MEDIA_TYPE = MediaType.get("text/plain; charset=UTF-8");
 
   private ScalarRequestBodyConverter() {
   }
diff --git a/retrofit-converters/simplexml/README.md b/retrofit-converters/simplexml/README.md
index 37e6f8f50..1a7ca6bf6 100644
--- a/retrofit-converters/simplexml/README.md
+++ b/retrofit-converters/simplexml/README.md
@@ -36,7 +36,7 @@ Download [the latest JAR][2] or grab via [Maven][3]:
 ```
 or [Gradle][3]:
 ```groovy
-compile 'com.squareup.retrofit2:converter-simplexml:latest.version'
+implementation 'com.squareup.retrofit2:converter-simplexml:latest.version'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlRequestBodyConverter.java b/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlRequestBodyConverter.java
index cb1c9dcb7..645b4bb73 100644
--- a/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlRequestBodyConverter.java
+++ b/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlRequestBodyConverter.java
@@ -24,7 +24,7 @@
 import retrofit2.Converter;
 
 final class SimpleXmlRequestBodyConverter<T> implements Converter<T, RequestBody> {
-  private static final MediaType MEDIA_TYPE = MediaType.parse("application/xml; charset=UTF-8");
+  private static final MediaType MEDIA_TYPE = MediaType.get("application/xml; charset=UTF-8");
   private static final String CHARSET = "UTF-8";
 
   private final Serializer serializer;
diff --git a/retrofit-converters/wire/README.md b/retrofit-converters/wire/README.md
index 6289cc8a7..eec260fd4 100644
--- a/retrofit-converters/wire/README.md
+++ b/retrofit-converters/wire/README.md
@@ -17,7 +17,7 @@ Download [the latest JAR][2] or grab via [Maven][3]:
 ```
 or [Gradle][3]:
 ```groovy
-compile 'com.squareup.retrofit2:converter-wire:latest.version'
+implementation 'com.squareup.retrofit2:converter-wire:latest.version'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireRequestBodyConverter.java b/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireRequestBodyConverter.java
index d388a944c..fd6cc3291 100644
--- a/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireRequestBodyConverter.java
+++ b/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireRequestBodyConverter.java
@@ -24,7 +24,7 @@
 import retrofit2.Converter;
 
 final class WireRequestBodyConverter<T extends Message<T, ?>> implements Converter<T, RequestBody> {
-  private static final MediaType MEDIA_TYPE = MediaType.parse("application/x-protobuf");
+  private static final MediaType MEDIA_TYPE = MediaType.get("application/x-protobuf");
 
   private final ProtoAdapter<T> adapter;
 
diff --git a/retrofit-mock/README.md b/retrofit-mock/README.md
index 851e9e82d..d846650b4 100644
--- a/retrofit-mock/README.md
+++ b/retrofit-mock/README.md
@@ -16,7 +16,7 @@ Download [the latest JAR][1] or grab via [Maven][2]:
 ```
 or [Gradle][1]:
 ```groovy
-compile 'com.squareup.retrofit2:retrofit-mock:see.latest.version'
+implementation 'com.squareup.retrofit2:retrofit-mock:see.latest.version'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/retrofit/src/main/java/retrofit2/HttpServiceMethod.java b/retrofit/src/main/java/retrofit2/HttpServiceMethod.java
index 027f6cf6e..b6d13cedf 100644
--- a/retrofit/src/main/java/retrofit2/HttpServiceMethod.java
+++ b/retrofit/src/main/java/retrofit2/HttpServiceMethod.java
@@ -21,6 +21,8 @@
 import javax.annotation.Nullable;
 import okhttp3.ResponseBody;
 
+import static retrofit2.Utils.methodError;
+
 /** Adapts an invocation of an interface method into an HTTP call. */
 final class HttpServiceMethod<ResponseT, ReturnT> extends ServiceMethod<ReturnT> {
   private final RequestFactory requestFactory;
@@ -65,14 +67,14 @@
       callAdapter = createCallAdapter();
       responseType = callAdapter.responseType();
       if (responseType == Response.class || responseType == okhttp3.Response.class) {
-        throw methodError("'"
+        throw methodError(method, "'"
             + Utils.getRawType(responseType).getName()
             + "' is not a valid response body type. Did you mean ResponseBody?");
       }
       responseConverter = createResponseConverter();
 
       if (requestFactory.httpMethod.equals("HEAD") && !Void.class.equals(responseType)) {
-        throw methodError("HEAD method must use Void as response type.");
+        throw methodError(method, "HEAD method must use Void as response type.");
       }
 
       return new HttpServiceMethod<>(this);
@@ -80,19 +82,12 @@
 
     private CallAdapter<ResponseT, ReturnT> createCallAdapter() {
       Type returnType = method.getGenericReturnType();
-      if (Utils.hasUnresolvableType(returnType)) {
-        throw methodError(
-            "Method return type must not include a type variable or wildcard: %s", returnType);
-      }
-      if (returnType == void.class) {
-        throw methodError("Service methods cannot return void.");
-      }
       Annotation[] annotations = method.getAnnotations();
       try {
         //noinspection unchecked
         return (CallAdapter<ResponseT, ReturnT>) retrofit.callAdapter(returnType, annotations);
       } catch (RuntimeException e) { // Wide exception range because factories are user code.
-        throw methodError(e, "Unable to create call adapter for %s", returnType);
+        throw methodError(method, e, "Unable to create call adapter for %s", returnType);
       }
     }
 
@@ -101,21 +96,8 @@
       try {
         return retrofit.responseBodyConverter(responseType, annotations);
       } catch (RuntimeException e) { // Wide exception range because factories are user code.
-        throw methodError(e, "Unable to create converter for %s", responseType);
+        throw methodError(method, e, "Unable to create converter for %s", responseType);
       }
     }
-
-    private RuntimeException methodError(String message, Object... args) {
-      return methodError(null, message, args);
-    }
-
-    private RuntimeException methodError(Throwable cause, String message, Object... args) {
-      message = String.format(message, args);
-      return new IllegalArgumentException(message
-          + "\n    for method "
-          + method.getDeclaringClass().getSimpleName()
-          + "."
-          + method.getName(), cause);
-    }
   }
 }
diff --git a/retrofit/src/main/java/retrofit2/OkHttpCall.java b/retrofit/src/main/java/retrofit2/OkHttpCall.java
index d15e37fa3..3a4d0562d 100644
--- a/retrofit/src/main/java/retrofit2/OkHttpCall.java
+++ b/retrofit/src/main/java/retrofit2/OkHttpCall.java
@@ -218,7 +218,7 @@ private void callFailure(Throwable e) {
       return Response.success(null, rawResponse);
     }
 
-    ExceptionCatchingRequestBody catchingBody = new ExceptionCatchingRequestBody(rawBody);
+    ExceptionCatchingResponseBody catchingBody = new ExceptionCatchingResponseBody(rawBody);
     try {
       T body = responseConverter.convert(catchingBody);
       return Response.success(body, rawResponse);
@@ -273,11 +273,11 @@ public void cancel() {
     }
   }
 
-  static final class ExceptionCatchingRequestBody extends ResponseBody {
+  static final class ExceptionCatchingResponseBody extends ResponseBody {
     private final ResponseBody delegate;
     IOException thrownException;
 
-    ExceptionCatchingRequestBody(ResponseBody delegate) {
+    ExceptionCatchingResponseBody(ResponseBody delegate) {
       this.delegate = delegate;
     }
 
diff --git a/retrofit/src/main/java/retrofit2/Platform.java b/retrofit/src/main/java/retrofit2/Platform.java
index 3c3307b70..092c95f8f 100644
--- a/retrofit/src/main/java/retrofit2/Platform.java
+++ b/retrofit/src/main/java/retrofit2/Platform.java
@@ -88,6 +88,14 @@ boolean isDefaultMethod(Method method) {
   }
 
   static class Android extends Platform {
+    @IgnoreJRERequirement // Guarded by API check.
+    @Override boolean isDefaultMethod(Method method) {
+      if (Build.VERSION.SDK_INT < 24) {
+        return false;
+      }
+      return method.isDefault();
+    }
+
     @Override public Executor defaultCallbackExecutor() {
       return new MainThreadExecutor();
     }
diff --git a/retrofit/src/main/java/retrofit2/RequestBuilder.java b/retrofit/src/main/java/retrofit2/RequestBuilder.java
index f27db26ee..436240cc4 100644
--- a/retrofit/src/main/java/retrofit2/RequestBuilder.java
+++ b/retrofit/src/main/java/retrofit2/RequestBuilder.java
@@ -76,11 +76,11 @@ void setRelativeUrl(Object relativeUrl) {
 
   void addHeader(String name, String value) {
     if ("Content-Type".equalsIgnoreCase(name)) {
-      MediaType type = MediaType.parse(value);
-      if (type == null) {
-        throw new IllegalArgumentException("Malformed content type: " + value);
+      try {
+        contentType = MediaType.get(value);
+      } catch (IllegalArgumentException e) {
+        throw new IllegalArgumentException("Malformed content type: " + value, e);
       }
-      contentType = type;
     } else {
       requestBuilder.addHeader(name, value);
     }
diff --git a/retrofit/src/main/java/retrofit2/RequestFactory.java b/retrofit/src/main/java/retrofit2/RequestFactory.java
index de6268086..c6098b2a9 100644
--- a/retrofit/src/main/java/retrofit2/RequestFactory.java
+++ b/retrofit/src/main/java/retrofit2/RequestFactory.java
@@ -55,6 +55,9 @@
 import retrofit2.http.QueryName;
 import retrofit2.http.Url;
 
+import static retrofit2.Utils.methodError;
+import static retrofit2.Utils.parameterError;
+
 final class RequestFactory {
   static RequestFactory parseAnnotations(Retrofit retrofit, Method method) {
     return new Builder(retrofit, method).build();
@@ -149,16 +152,16 @@ RequestFactory build() {
       }
 
       if (httpMethod == null) {
-        throw methodError("HTTP method annotation is required (e.g., @GET, @POST, etc.).");
+        throw methodError(method, "HTTP method annotation is required (e.g., @GET, @POST, etc.).");
       }
 
       if (!hasBody) {
         if (isMultipart) {
-          throw methodError(
+          throw methodError(method,
               "Multipart can only be specified on HTTP methods with request body (e.g., @POST).");
         }
         if (isFormEncoded) {
-          throw methodError("FormUrlEncoded can only be specified on HTTP methods with "
+          throw methodError(method, "FormUrlEncoded can only be specified on HTTP methods with "
               + "request body (e.g., @POST).");
         }
       }
@@ -168,29 +171,29 @@ RequestFactory build() {
       for (int p = 0; p < parameterCount; p++) {
         Type parameterType = parameterTypes[p];
         if (Utils.hasUnresolvableType(parameterType)) {
-          throw parameterError(p, "Parameter type must not include a type variable or wildcard: %s",
-              parameterType);
+          throw parameterError(method, p,
+              "Parameter type must not include a type variable or wildcard: %s", parameterType);
         }
 
         Annotation[] parameterAnnotations = parameterAnnotationsArray[p];
         if (parameterAnnotations == null) {
-          throw parameterError(p, "No Retrofit annotation found.");
+          throw parameterError(method, p, "No Retrofit annotation found.");
         }
 
         parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);
       }
 
       if (relativeUrl == null && !gotUrl) {
-        throw methodError("Missing either @%s URL or @Url parameter.", httpMethod);
+        throw methodError(method, "Missing either @%s URL or @Url parameter.", httpMethod);
       }
       if (!isFormEncoded && !isMultipart && !hasBody && gotBody) {
-        throw methodError("Non-body HTTP method cannot contain @Body.");
+        throw methodError(method, "Non-body HTTP method cannot contain @Body.");
       }
       if (isFormEncoded && !gotField) {
-        throw methodError("Form-encoded method must contain at least one @Field.");
+        throw methodError(method, "Form-encoded method must contain at least one @Field.");
       }
       if (isMultipart && !gotPart) {
-        throw methodError("Multipart method must contain at least one @Part.");
+        throw methodError(method, "Multipart method must contain at least one @Part.");
       }
 
       return new RequestFactory(this);
@@ -217,17 +220,17 @@ private void parseMethodAnnotation(Annotation annotation) {
       } else if (annotation instanceof retrofit2.http.Headers) {
         String[] headersToParse = ((retrofit2.http.Headers) annotation).value();
         if (headersToParse.length == 0) {
-          throw methodError("@Headers annotation is empty.");
+          throw methodError(method, "@Headers annotation is empty.");
         }
         headers = parseHeaders(headersToParse);
       } else if (annotation instanceof Multipart) {
         if (isFormEncoded) {
-          throw methodError("Only one encoding annotation is allowed.");
+          throw methodError(method, "Only one encoding annotation is allowed.");
         }
         isMultipart = true;
       } else if (annotation instanceof FormUrlEncoded) {
         if (isMultipart) {
-          throw methodError("Only one encoding annotation is allowed.");
+          throw methodError(method, "Only one encoding annotation is allowed.");
         }
         isFormEncoded = true;
       }
@@ -235,7 +238,7 @@ private void parseMethodAnnotation(Annotation annotation) {
 
     private void parseHttpMethodAndPath(String httpMethod, String value, boolean hasBody) {
       if (this.httpMethod != null) {
-        throw methodError("Only one HTTP method is allowed. Found: %s and %s.",
+        throw methodError(method, "Only one HTTP method is allowed. Found: %s and %s.",
             this.httpMethod, httpMethod);
       }
       this.httpMethod = httpMethod;
@@ -252,7 +255,7 @@ private void parseHttpMethodAndPath(String httpMethod, String value, boolean has
         String queryParams = value.substring(question + 1);
         Matcher queryParamMatcher = PARAM_URL_REGEX.matcher(queryParams);
         if (queryParamMatcher.find()) {
-          throw methodError("URL query string \"%s\" must not have replace block. "
+          throw methodError(method, "URL query string \"%s\" must not have replace block. "
               + "For dynamic query parameters use @Query.", queryParams);
         }
       }
@@ -266,17 +269,17 @@ private Headers parseHeaders(String[] headers) {
       for (String header : headers) {
         int colon = header.indexOf(':');
         if (colon == -1 || colon == 0 || colon == header.length() - 1) {
-          throw methodError(
+          throw methodError(method,
               "@Headers value must be in the form \"Name: Value\". Found: \"%s\"", header);
         }
         String headerName = header.substring(0, colon);
         String headerValue = header.substring(colon + 1).trim();
         if ("Content-Type".equalsIgnoreCase(headerName)) {
-          MediaType type = MediaType.parse(headerValue);
-          if (type == null) {
-            throw methodError("Malformed content type: %s", headerValue);
+          try {
+            contentType = MediaType.get(headerValue);
+          } catch (IllegalArgumentException e) {
+            throw methodError(method, e, "Malformed content type: %s", headerValue);
           }
-          contentType = type;
         } else {
           builder.add(headerName, headerValue);
         }
@@ -296,14 +299,14 @@ private Headers parseHeaders(String[] headers) {
         }
 
         if (result != null) {
-          throw parameterError(p, "Multiple Retrofit annotations found, only one allowed.");
+          throw parameterError(method, p, "Multiple Retrofit annotations found, only one allowed.");
         }
 
         result = annotationAction;
       }
 
       if (result == null) {
-        throw parameterError(p, "No Retrofit annotation found.");
+        throw parameterError(method, p, "No Retrofit annotation found.");
       }
 
       return result;
@@ -313,16 +316,16 @@ private Headers parseHeaders(String[] headers) {
         int p, Type type, Annotation[] annotations, Annotation annotation) {
       if (annotation instanceof Url) {
         if (gotUrl) {
-          throw parameterError(p, "Multiple @Url method annotations found.");
+          throw parameterError(method, p, "Multiple @Url method annotations found.");
         }
         if (gotPath) {
-          throw parameterError(p, "@Path parameters may not be used with @Url.");
+          throw parameterError(method, p, "@Path parameters may not be used with @Url.");
         }
         if (gotQuery) {
-          throw parameterError(p, "A @Url parameter must not come after a @Query");
+          throw parameterError(method, p, "A @Url parameter must not come after a @Query");
         }
         if (relativeUrl != null) {
-          throw parameterError(p, "@Url cannot be used with @%s URL", httpMethod);
+          throw parameterError(method, p, "@Url cannot be used with @%s URL", httpMethod);
         }
 
         gotUrl = true;
@@ -333,19 +336,20 @@ private Headers parseHeaders(String[] headers) {
             || (type instanceof Class && "android.net.Uri".equals(((Class<?>) type).getName()))) {
           return new ParameterHandler.RelativeUrl();
         } else {
-          throw parameterError(p,
+          throw parameterError(method, p,
               "@Url must be okhttp3.HttpUrl, String, java.net.URI, or android.net.Uri type.");
         }
 
       } else if (annotation instanceof Path) {
         if (gotQuery) {
-          throw parameterError(p, "A @Path parameter must not come after a @Query.");
+          throw parameterError(method, p, "A @Path parameter must not come after a @Query.");
         }
         if (gotUrl) {
-          throw parameterError(p, "@Path parameters may not be used with @Url.");
+          throw parameterError(method, p, "@Path parameters may not be used with @Url.");
         }
         if (relativeUrl == null) {
-          throw parameterError(p, "@Path can only be used with relative url on @%s", httpMethod);
+          throw parameterError(method, p, "@Path can only be used with relative url on @%s",
+              httpMethod);
         }
         gotPath = true;
 
@@ -365,7 +369,7 @@ private Headers parseHeaders(String[] headers) {
         gotQuery = true;
         if (Iterable.class.isAssignableFrom(rawParameterType)) {
           if (!(type instanceof ParameterizedType)) {
-            throw parameterError(p, rawParameterType.getSimpleName()
+            throw parameterError(method, p, rawParameterType.getSimpleName()
                 + " must include generic type (e.g., "
                 + rawParameterType.getSimpleName()
                 + "<String>)");
@@ -394,7 +398,7 @@ private Headers parseHeaders(String[] headers) {
         gotQuery = true;
         if (Iterable.class.isAssignableFrom(rawParameterType)) {
           if (!(type instanceof ParameterizedType)) {
-            throw parameterError(p, rawParameterType.getSimpleName()
+            throw parameterError(method, p, rawParameterType.getSimpleName()
                 + " must include generic type (e.g., "
                 + rawParameterType.getSimpleName()
                 + "<String>)");
@@ -418,16 +422,17 @@ private Headers parseHeaders(String[] headers) {
       } else if (annotation instanceof QueryMap) {
         Class<?> rawParameterType = Utils.getRawType(type);
         if (!Map.class.isAssignableFrom(rawParameterType)) {
-          throw parameterError(p, "@QueryMap parameter type must be Map.");
+          throw parameterError(method, p, "@QueryMap parameter type must be Map.");
         }
         Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
         if (!(mapType instanceof ParameterizedType)) {
-          throw parameterError(p, "Map must include generic types (e.g., Map<String, String>)");
+          throw parameterError(method, p,
+              "Map must include generic types (e.g., Map<String, String>)");
         }
         ParameterizedType parameterizedType = (ParameterizedType) mapType;
         Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
         if (String.class != keyType) {
-          throw parameterError(p, "@QueryMap keys must be of type String: " + keyType);
+          throw parameterError(method, p, "@QueryMap keys must be of type String: " + keyType);
         }
         Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
         Converter<?, String> valueConverter =
@@ -442,7 +447,7 @@ private Headers parseHeaders(String[] headers) {
         Class<?> rawParameterType = Utils.getRawType(type);
         if (Iterable.class.isAssignableFrom(rawParameterType)) {
           if (!(type instanceof ParameterizedType)) {
-            throw parameterError(p, rawParameterType.getSimpleName()
+            throw parameterError(method, p, rawParameterType.getSimpleName()
                 + " must include generic type (e.g., "
                 + rawParameterType.getSimpleName()
                 + "<String>)");
@@ -466,16 +471,17 @@ private Headers parseHeaders(String[] headers) {
       } else if (annotation instanceof HeaderMap) {
         Class<?> rawParameterType = Utils.getRawType(type);
         if (!Map.class.isAssignableFrom(rawParameterType)) {
-          throw parameterError(p, "@HeaderMap parameter type must be Map.");
+          throw parameterError(method, p, "@HeaderMap parameter type must be Map.");
         }
         Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
         if (!(mapType instanceof ParameterizedType)) {
-          throw parameterError(p, "Map must include generic types (e.g., Map<String, String>)");
+          throw parameterError(method, p,
+              "Map must include generic types (e.g., Map<String, String>)");
         }
         ParameterizedType parameterizedType = (ParameterizedType) mapType;
         Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
         if (String.class != keyType) {
-          throw parameterError(p, "@HeaderMap keys must be of type String: " + keyType);
+          throw parameterError(method, p, "@HeaderMap keys must be of type String: " + keyType);
         }
         Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
         Converter<?, String> valueConverter =
@@ -485,7 +491,7 @@ private Headers parseHeaders(String[] headers) {
 
       } else if (annotation instanceof Field) {
         if (!isFormEncoded) {
-          throw parameterError(p, "@Field parameters can only be used with form encoding.");
+          throw parameterError(method, p, "@Field parameters can only be used with form encoding.");
         }
         Field field = (Field) annotation;
         String name = field.value();
@@ -496,7 +502,7 @@ private Headers parseHeaders(String[] headers) {
         Class<?> rawParameterType = Utils.getRawType(type);
         if (Iterable.class.isAssignableFrom(rawParameterType)) {
           if (!(type instanceof ParameterizedType)) {
-            throw parameterError(p, rawParameterType.getSimpleName()
+            throw parameterError(method, p, rawParameterType.getSimpleName()
                 + " must include generic type (e.g., "
                 + rawParameterType.getSimpleName()
                 + "<String>)");
@@ -519,21 +525,22 @@ private Headers parseHeaders(String[] headers) {
 
       } else if (annotation instanceof FieldMap) {
         if (!isFormEncoded) {
-          throw parameterError(p, "@FieldMap parameters can only be used with form encoding.");
+          throw parameterError(method, p,
+              "@FieldMap parameters can only be used with form encoding.");
         }
         Class<?> rawParameterType = Utils.getRawType(type);
         if (!Map.class.isAssignableFrom(rawParameterType)) {
-          throw parameterError(p, "@FieldMap parameter type must be Map.");
+          throw parameterError(method, p, "@FieldMap parameter type must be Map.");
         }
         Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
         if (!(mapType instanceof ParameterizedType)) {
-          throw parameterError(p,
+          throw parameterError(method, p,
               "Map must include generic types (e.g., Map<String, String>)");
         }
         ParameterizedType parameterizedType = (ParameterizedType) mapType;
         Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
         if (String.class != keyType) {
-          throw parameterError(p, "@FieldMap keys must be of type String: " + keyType);
+          throw parameterError(method, p, "@FieldMap keys must be of type String: " + keyType);
         }
         Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
         Converter<?, String> valueConverter =
@@ -544,7 +551,8 @@ private Headers parseHeaders(String[] headers) {
 
       } else if (annotation instanceof Part) {
         if (!isMultipart) {
-          throw parameterError(p, "@Part parameters can only be used with multipart encoding.");
+          throw parameterError(method, p,
+              "@Part parameters can only be used with multipart encoding.");
         }
         Part part = (Part) annotation;
         gotPart = true;
@@ -554,7 +562,7 @@ private Headers parseHeaders(String[] headers) {
         if (partName.isEmpty()) {
           if (Iterable.class.isAssignableFrom(rawParameterType)) {
             if (!(type instanceof ParameterizedType)) {
-              throw parameterError(p, rawParameterType.getSimpleName()
+              throw parameterError(method, p, rawParameterType.getSimpleName()
                   + " must include generic type (e.g., "
                   + rawParameterType.getSimpleName()
                   + "<String>)");
@@ -562,21 +570,21 @@ private Headers parseHeaders(String[] headers) {
             ParameterizedType parameterizedType = (ParameterizedType) type;
             Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
             if (!MultipartBody.Part.class.isAssignableFrom(Utils.getRawType(iterableType))) {
-              throw parameterError(p,
+              throw parameterError(method, p,
                   "@Part annotation must supply a name or use MultipartBody.Part parameter type.");
             }
             return ParameterHandler.RawPart.INSTANCE.iterable();
           } else if (rawParameterType.isArray()) {
             Class<?> arrayComponentType = rawParameterType.getComponentType();
             if (!MultipartBody.Part.class.isAssignableFrom(arrayComponentType)) {
-              throw parameterError(p,
+              throw parameterError(method, p,
                   "@Part annotation must supply a name or use MultipartBody.Part parameter type.");
             }
             return ParameterHandler.RawPart.INSTANCE.array();
           } else if (MultipartBody.Part.class.isAssignableFrom(rawParameterType)) {
             return ParameterHandler.RawPart.INSTANCE;
           } else {
-            throw parameterError(p,
+            throw parameterError(method, p,
                 "@Part annotation must supply a name or use MultipartBody.Part parameter type.");
           }
         } else {
@@ -586,7 +594,7 @@ private Headers parseHeaders(String[] headers) {
 
           if (Iterable.class.isAssignableFrom(rawParameterType)) {
             if (!(type instanceof ParameterizedType)) {
-              throw parameterError(p, rawParameterType.getSimpleName()
+              throw parameterError(method, p, rawParameterType.getSimpleName()
                   + " must include generic type (e.g., "
                   + rawParameterType.getSimpleName()
                   + "<String>)");
@@ -594,8 +602,9 @@ private Headers parseHeaders(String[] headers) {
             ParameterizedType parameterizedType = (ParameterizedType) type;
             Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
             if (MultipartBody.Part.class.isAssignableFrom(Utils.getRawType(iterableType))) {
-              throw parameterError(p, "@Part parameters using the MultipartBody.Part must not "
-                  + "include a part name in the annotation.");
+              throw parameterError(method, p,
+                  "@Part parameters using the MultipartBody.Part must not "
+                      + "include a part name in the annotation.");
             }
             Converter<?, RequestBody> converter =
                 retrofit.requestBodyConverter(iterableType, annotations, methodAnnotations);
@@ -603,15 +612,17 @@ private Headers parseHeaders(String[] headers) {
           } else if (rawParameterType.isArray()) {
             Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
             if (MultipartBody.Part.class.isAssignableFrom(arrayComponentType)) {
-              throw parameterError(p, "@Part parameters using the MultipartBody.Part must not "
-                  + "include a part name in the annotation.");
+              throw parameterError(method, p,
+                  "@Part parameters using the MultipartBody.Part must not "
+                      + "include a part name in the annotation.");
             }
             Converter<?, RequestBody> converter =
                 retrofit.requestBodyConverter(arrayComponentType, annotations, methodAnnotations);
             return new ParameterHandler.Part<>(headers, converter).array();
           } else if (MultipartBody.Part.class.isAssignableFrom(rawParameterType)) {
-            throw parameterError(p, "@Part parameters using the MultipartBody.Part must not "
-                + "include a part name in the annotation.");
+            throw parameterError(method, p,
+                "@Part parameters using the MultipartBody.Part must not "
+                    + "include a part name in the annotation.");
           } else {
             Converter<?, RequestBody> converter =
                 retrofit.requestBodyConverter(type, annotations, methodAnnotations);
@@ -621,27 +632,29 @@ private Headers parseHeaders(String[] headers) {
 
       } else if (annotation instanceof PartMap) {
         if (!isMultipart) {
-          throw parameterError(p, "@PartMap parameters can only be used with multipart encoding.");
+          throw parameterError(method, p,
+              "@PartMap parameters can only be used with multipart encoding.");
         }
         gotPart = true;
         Class<?> rawParameterType = Utils.getRawType(type);
         if (!Map.class.isAssignableFrom(rawParameterType)) {
-          throw parameterError(p, "@PartMap parameter type must be Map.");
+          throw parameterError(method, p, "@PartMap parameter type must be Map.");
         }
         Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
         if (!(mapType instanceof ParameterizedType)) {
-          throw parameterError(p, "Map must include generic types (e.g., Map<String, String>)");
+          throw parameterError(method, p,
+              "Map must include generic types (e.g., Map<String, String>)");
         }
         ParameterizedType parameterizedType = (ParameterizedType) mapType;
 
         Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
         if (String.class != keyType) {
-          throw parameterError(p, "@PartMap keys must be of type String: " + keyType);
+          throw parameterError(method, p, "@PartMap keys must be of type String: " + keyType);
         }
 
         Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
         if (MultipartBody.Part.class.isAssignableFrom(Utils.getRawType(valueType))) {
-          throw parameterError(p, "@PartMap values cannot be MultipartBody.Part. "
+          throw parameterError(method, p, "@PartMap values cannot be MultipartBody.Part. "
               + "Use @Part List<Part> or a different value type instead.");
         }
 
@@ -653,11 +666,11 @@ private Headers parseHeaders(String[] headers) {
 
       } else if (annotation instanceof Body) {
         if (isFormEncoded || isMultipart) {
-          throw parameterError(p,
+          throw parameterError(method, p,
               "@Body parameters cannot be used with form or multi-part encoding.");
         }
         if (gotBody) {
-          throw parameterError(p, "Multiple @Body method annotations found.");
+          throw parameterError(method, p, "Multiple @Body method annotations found.");
         }
 
         Converter<?, RequestBody> converter;
@@ -665,7 +678,7 @@ private Headers parseHeaders(String[] headers) {
           converter = retrofit.requestBodyConverter(type, annotations, methodAnnotations);
         } catch (RuntimeException e) {
           // Wide exception range because factories are user code.
-          throw parameterError(e, p, "Unable to create @Body converter for %s", type);
+          throw parameterError(method, e, p, "Unable to create @Body converter for %s", type);
         }
         gotBody = true;
         return new ParameterHandler.Body<>(converter);
@@ -676,37 +689,15 @@ private Headers parseHeaders(String[] headers) {
 
     private void validatePathName(int p, String name) {
       if (!PARAM_NAME_REGEX.matcher(name).matches()) {
-        throw parameterError(p, "@Path parameter name must match %s. Found: %s",
+        throw parameterError(method, p, "@Path parameter name must match %s. Found: %s",
             PARAM_URL_REGEX.pattern(), name);
       }
       // Verify URL replacement name is actually present in the URL path.
       if (!relativeUrlParamNames.contains(name)) {
-        throw parameterError(p, "URL \"%s\" does not contain \"{%s}\".", relativeUrl, name);
+        throw parameterError(method, p, "URL \"%s\" does not contain \"{%s}\".", relativeUrl, name);
       }
     }
 
-    private RuntimeException methodError(String message, Object... args) {
-      return methodError(null, message, args);
-    }
-
-    private RuntimeException methodError(Throwable cause, String message, Object... args) {
-      message = String.format(message, args);
-      return new IllegalArgumentException(message
-          + "\n    for method "
-          + method.getDeclaringClass().getSimpleName()
-          + "."
-          + method.getName(), cause);
-    }
-
-    private RuntimeException parameterError(
-        Throwable cause, int p, String message, Object... args) {
-      return methodError(cause, message + " (parameter #" + (p + 1) + ")", args);
-    }
-
-    private RuntimeException parameterError(int p, String message, Object... args) {
-      return methodError(message + " (parameter #" + (p + 1) + ")", args);
-    }
-
     /**
      * Gets the set of unique path parameters used in the given URI. If a parameter is used twice
      * in the URI, it will only show up once in the set.
diff --git a/retrofit/src/main/java/retrofit2/Retrofit.java b/retrofit/src/main/java/retrofit2/Retrofit.java
index 993690898..498d006eb 100644
--- a/retrofit/src/main/java/retrofit2/Retrofit.java
+++ b/retrofit/src/main/java/retrofit2/Retrofit.java
@@ -448,11 +448,7 @@ public Builder callFactory(okhttp3.Call.Factory factory) {
      */
     public Builder baseUrl(String baseUrl) {
       checkNotNull(baseUrl, "baseUrl == null");
-      HttpUrl httpUrl = HttpUrl.parse(baseUrl);
-      if (httpUrl == null) {
-        throw new IllegalArgumentException("Illegal URL: " + baseUrl);
-      }
-      return baseUrl(httpUrl);
+      return baseUrl(HttpUrl.get(baseUrl));
     }
 
     /**
diff --git a/retrofit/src/main/java/retrofit2/ServiceMethod.java b/retrofit/src/main/java/retrofit2/ServiceMethod.java
index 8434f9e85..2ae44628e 100644
--- a/retrofit/src/main/java/retrofit2/ServiceMethod.java
+++ b/retrofit/src/main/java/retrofit2/ServiceMethod.java
@@ -16,10 +16,22 @@
 package retrofit2;
 
 import java.lang.reflect.Method;
+import java.lang.reflect.Type;
 import javax.annotation.Nullable;
 
+import static retrofit2.Utils.methodError;
+
 abstract class ServiceMethod<T> {
   static <T> ServiceMethod<T> parseAnnotations(Retrofit retrofit, Method method) {
+    Type returnType = method.getGenericReturnType();
+    if (Utils.hasUnresolvableType(returnType)) {
+      throw methodError(method,
+          "Method return type must not include a type variable or wildcard: %s", returnType);
+    }
+    if (returnType == void.class) {
+      throw methodError(method, "Service methods cannot return void.");
+    }
+
     return new HttpServiceMethod.Builder<Object, T>(retrofit, method).build();
   }
 
diff --git a/retrofit/src/main/java/retrofit2/Utils.java b/retrofit/src/main/java/retrofit2/Utils.java
index 12544e357..85258222c 100644
--- a/retrofit/src/main/java/retrofit2/Utils.java
+++ b/retrofit/src/main/java/retrofit2/Utils.java
@@ -20,6 +20,7 @@
 import java.lang.reflect.Array;
 import java.lang.reflect.GenericArrayType;
 import java.lang.reflect.GenericDeclaration;
+import java.lang.reflect.Method;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import java.lang.reflect.TypeVariable;
@@ -37,6 +38,29 @@ private Utils() {
     // No instances.
   }
 
+  static RuntimeException methodError(Method method, String message, Object... args) {
+    return methodError(method, null, message, args);
+  }
+
+  static RuntimeException methodError(Method method, @Nullable Throwable cause, String message,
+      Object... args) {
+    message = String.format(message, args);
+    return new IllegalArgumentException(message
+        + "\n    for method "
+        + method.getDeclaringClass().getSimpleName()
+        + "."
+        + method.getName(), cause);
+  }
+
+  static RuntimeException parameterError(Method method,
+      Throwable cause, int p, String message, Object... args) {
+    return methodError(method, cause, message + " (parameter #" + (p + 1) + ")", args);
+  }
+
+  static RuntimeException parameterError(Method method, int p, String message, Object... args) {
+    return methodError(method, message + " (parameter #" + (p + 1) + ")", args);
+  }
+
   static Class<?> getRawType(Type type) {
     checkNotNull(type, "type == null");
 
diff --git a/retrofit/src/test/java/retrofit2/RequestFactoryTest.java b/retrofit/src/test/java/retrofit2/RequestFactoryTest.java
index db2c4c2e7..cfee28e19 100644
--- a/retrofit/src/test/java/retrofit2/RequestFactoryTest.java
+++ b/retrofit/src/test/java/retrofit2/RequestFactoryTest.java
@@ -65,7 +65,7 @@
 
 @SuppressWarnings({"UnusedParameters", "unused"}) // Parameters inspected reflectively.
 public final class RequestFactoryTest {
-  private static final MediaType TEXT_PLAIN = MediaType.parse("text/plain");
+  private static final MediaType TEXT_PLAIN = MediaType.get("text/plain");
 
   @Test public void customMethodNoBody() {
     class Example {
@@ -89,7 +89,7 @@
       }
     }
 
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    RequestBody body = RequestBody.create(TEXT_PLAIN, "hi");
     Request request = buildRequest(Example.class, body);
     assertThat(request.method()).isEqualTo("CUSTOM2");
     assertThat(request.url().toString()).isEqualTo("http://example.com/foo");
@@ -742,7 +742,7 @@
         return null;
       }
     }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    RequestBody body = RequestBody.create(TEXT_PLAIN, "hi");
     Request request = buildRequest(Example.class, body);
     assertThat(request.method()).isEqualTo("POST");
     assertThat(request.headers().size()).isZero();
@@ -757,7 +757,7 @@
         return null;
       }
     }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    RequestBody body = RequestBody.create(TEXT_PLAIN, "hi");
     Request request = buildRequest(Example.class, body);
     assertThat(request.method()).isEqualTo("PUT");
     assertThat(request.headers().size()).isZero();
@@ -772,7 +772,7 @@
         return null;
       }
     }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    RequestBody body = RequestBody.create(TEXT_PLAIN, "hi");
     Request request = buildRequest(Example.class, body);
     assertThat(request.method()).isEqualTo("PATCH");
     assertThat(request.headers().size()).isZero();
@@ -1322,10 +1322,10 @@
       }
     }
 
-    Request request = buildRequest(Example.class, HttpUrl.parse("http://example.com/foo/bar/"));
+    Request request = buildRequest(Example.class, HttpUrl.get("http://example.com/foo/bar/"));
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.url()).isEqualTo(HttpUrl.parse("http://example.com/foo/bar/"));
+    assertThat(request.url()).isEqualTo(HttpUrl.get("http://example.com/foo/bar/"));
     assertThat(request.body()).isNull();
   }
 
@@ -1470,7 +1470,7 @@
         return null;
       }
     }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    RequestBody body = RequestBody.create(TEXT_PLAIN, "hi");
     Request request = buildRequest(Example.class, "http://example.com/foo/bar", body);
     assertThat(request.method()).isEqualTo("POST");
     assertThat(request.headers().size()).isZero();
@@ -1561,7 +1561,7 @@
     }
 
     Request request = buildRequest(Example.class, "pong", RequestBody.create(
-        MediaType.parse("text/plain"), "kat"));
+        TEXT_PLAIN, "kat"));
     assertThat(request.method()).isEqualTo("POST");
     assertThat(request.headers().size()).isZero();
     assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
@@ -1886,7 +1886,7 @@
     }
 
     Request request = buildRequest(Example.class, "pong", RequestBody.create(
-        MediaType.parse("text/plain"), "kat"));
+        TEXT_PLAIN, "kat"));
     assertThat(request.method()).isEqualTo("POST");
     assertThat(request.headers().size()).isZero();
     assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
@@ -2484,7 +2484,7 @@
         return null;
       }
     }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    RequestBody body = RequestBody.create(TEXT_PLAIN, "hi");
     Request request = buildRequest(Example.class, body);
     assertThat(request.body().contentType().toString()).isEqualTo("text/not-plain");
   }
@@ -2497,13 +2497,14 @@
         return null;
       }
     }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    RequestBody body = RequestBody.create(TEXT_PLAIN, "hi");
     try {
       buildRequest(Example.class, body);
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage("Malformed content type: hello, world!\n"
           + "    for method Example.method");
+      assertThat(e.getCause()).isInstanceOf(IllegalArgumentException.class); // OkHttp's cause.
     }
   }
 
@@ -2526,7 +2527,7 @@
         return null;
       }
     }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "Plain");
+    RequestBody body = RequestBody.create(TEXT_PLAIN, "Plain");
     Request request = buildRequest(Example.class, "text/not-plain", body);
     assertThat(request.body().contentType().toString()).isEqualTo("text/not-plain");
   }
@@ -2538,12 +2539,13 @@
         return null;
       }
     }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    RequestBody body = RequestBody.create(TEXT_PLAIN, "hi");
     try {
       buildRequest(Example.class, "hello, world!", body);
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage("Malformed content type: hello, world!");
+      assertThat(e.getCause()).isInstanceOf(IllegalArgumentException.class); // OkHttp's cause.
     }
   }
 
diff --git a/retrofit/src/test/java/retrofit2/RetrofitTest.java b/retrofit/src/test/java/retrofit2/RetrofitTest.java
index 4a1b2b773..05e4cf928 100644
--- a/retrofit/src/test/java/retrofit2/RetrofitTest.java
+++ b/retrofit/src/test/java/retrofit2/RetrofitTest.java
@@ -566,7 +566,7 @@
 
     server.enqueue(new MockResponse().setBody("Hi"));
 
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "Hey");
+    RequestBody body = RequestBody.create(MediaType.get("text/plain"), "Hey");
     Response<ResponseBody> response = example.postRequestBody(body).execute();
     assertThat(response.body().string()).isEqualTo("Hi");
 
@@ -693,8 +693,7 @@
     try {
       new Retrofit.Builder().baseUrl("ftp://foo/bar");
       fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Illegal URL: ftp://foo/bar");
+    } catch (IllegalArgumentException ignored) {
     }
   }
 
@@ -705,7 +704,7 @@
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage("baseUrl must end in /: http://example.com/api");
     }
-    HttpUrl parsed = HttpUrl.parse("http://example.com/api");
+    HttpUrl parsed = HttpUrl.get("http://example.com/api");
     try {
       new Retrofit.Builder().baseUrl(parsed);
       fail();
@@ -719,11 +718,11 @@
         .baseUrl("http://example.com/")
         .build();
     HttpUrl baseUrl = retrofit.baseUrl();
-    assertThat(baseUrl).isEqualTo(HttpUrl.parse("http://example.com/"));
+    assertThat(baseUrl).isEqualTo(HttpUrl.get("http://example.com/"));
   }
 
   @Test public void baseHttpUrlPropagated() {
-    HttpUrl url = HttpUrl.parse("http://example.com/");
+    HttpUrl url = HttpUrl.get("http://example.com/");
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(url)
         .build();
diff --git a/retrofit/src/test/java/retrofit2/helpers/ToStringConverterFactory.java b/retrofit/src/test/java/retrofit2/helpers/ToStringConverterFactory.java
index 0a70e3ddb..bcafe282c 100644
--- a/retrofit/src/test/java/retrofit2/helpers/ToStringConverterFactory.java
+++ b/retrofit/src/test/java/retrofit2/helpers/ToStringConverterFactory.java
@@ -25,7 +25,7 @@
 import retrofit2.Retrofit;
 
 public class ToStringConverterFactory extends Converter.Factory {
-  static final MediaType MEDIA_TYPE = MediaType.parse("text/plain");
+  static final MediaType MEDIA_TYPE = MediaType.get("text/plain");
 
   @Override
   public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
diff --git a/samples/src/main/java/com/example/retrofit/Crawler.java b/samples/src/main/java/com/example/retrofit/Crawler.java
index 1e213e9a1..2fd7e350f 100644
--- a/samples/src/main/java/com/example/retrofit/Crawler.java
+++ b/samples/src/main/java/com/example/retrofit/Crawler.java
@@ -100,7 +100,7 @@ public static void main(String... args) throws Exception {
         .build();
 
     Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(HttpUrl.parse("https://example.com/"))
+        .baseUrl(HttpUrl.get("https://example.com/"))
         .addConverterFactory(PageAdapter.FACTORY)
         .client(okHttpClient)
         .build();
@@ -108,7 +108,7 @@ public static void main(String... args) throws Exception {
     PageService pageService = retrofit.create(PageService.class);
 
     Crawler crawler = new Crawler(pageService);
-    crawler.crawlPage(HttpUrl.parse(args[0]));
+    crawler.crawlPage(HttpUrl.get(args[0]));
   }
 
   interface PageService {
