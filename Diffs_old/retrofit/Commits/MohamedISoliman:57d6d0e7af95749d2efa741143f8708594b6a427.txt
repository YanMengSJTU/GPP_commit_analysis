diff --git a/README.md b/README.md
index cea3f3870..5b30970a6 100644
--- a/README.md
+++ b/README.md
@@ -27,22 +27,13 @@ Snapshots of the development version are available in [Sonatype's `snapshots` re
 Retrofit requires at minimum Java 7 or Android 2.3.
 
 
-ProGuard
---------
+R8 / ProGuard
+-------------
 
-If you are using ProGuard you need to add the following options:
-```
-# Retain generic type information for use by reflection by converters and adapters.
--keepattributes Signature
-# Retain service method parameters.
--keepclassmembernames,allowobfuscation interface * {
-    @retrofit2.http.* <methods>;
-}
-# Ignore annotation used for build tooling.
--dontwarn org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement
-```
+If you are using R8 or ProGuard add the options from
+[this file](https://github.com/square/retrofit/blob/master/retrofit/src/main/resources/META-INF/proguard/retrofit2.pro).
 
-You might also need rules for OkHttp and Okio which are dependencies.
+You might also need rules for OkHttp and Okio which are dependencies of this library.
 
 
 License
diff --git a/pom.xml b/pom.xml
index a389b655c..9bf69434c 100644
--- a/pom.xml
+++ b/pom.xml
@@ -46,10 +46,11 @@
 
     <!-- Compilation -->
     <java.version>1.7</java.version>
+    <kotlin.version>1.2.60</kotlin.version>
 
     <!-- Dependencies -->
     <android.version>4.1.1.4</android.version>
-    <okhttp.version>3.10.0</okhttp.version>
+    <okhttp.version>3.11.0</okhttp.version>
     <animal.sniffer.version>1.14</animal.sniffer.version>
 
     <!-- Adapter Dependencies -->
@@ -108,6 +109,11 @@
         <artifactId>android</artifactId>
         <version>${android.version}</version>
       </dependency>
+      <dependency>
+        <groupId>org.jetbrains.kotlin</groupId>
+        <artifactId>kotlin-stdlib</artifactId>
+        <version>${kotlin.version}</version>
+      </dependency>
       <dependency>
         <groupId>org.codehaus.mojo</groupId>
         <artifactId>animal-sniffer-annotations</artifactId>
diff --git a/retrofit-adapters/guava/README.md b/retrofit-adapters/guava/README.md
index b1449e80e..c2c3badfa 100644
--- a/retrofit-adapters/guava/README.md
+++ b/retrofit-adapters/guava/README.md
@@ -37,7 +37,7 @@ Download [the latest JAR][2] or grab via [Maven][3]:
 ```
 or [Gradle][3]:
 ```groovy
-compile 'com.squareup.retrofit2:adapter-guava:latest.version'
+implementation 'com.squareup.retrofit2:adapter-guava:latest.version'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/StringConverterFactory.java b/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/StringConverterFactory.java
index bb9ccf189..f56fcf63a 100644
--- a/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/StringConverterFactory.java
+++ b/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/StringConverterFactory.java
@@ -39,7 +39,7 @@
       Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     return new Converter<String, RequestBody>() {
       @Override public RequestBody convert(String value) throws IOException {
-        return RequestBody.create(MediaType.parse("text/plain"), value);
+        return RequestBody.create(MediaType.get("text/plain"), value);
       }
     };
   }
diff --git a/retrofit-adapters/java8/README.md b/retrofit-adapters/java8/README.md
index 83424c809..31f98f7fd 100644
--- a/retrofit-adapters/java8/README.md
+++ b/retrofit-adapters/java8/README.md
@@ -37,7 +37,7 @@ Download [the latest JAR][2] or grab via [Maven][3]:
 ```
 or [Gradle][3]:
 ```groovy
-compile 'com.squareup.retrofit2:adapter-java8:latest.version'
+implementation 'com.squareup.retrofit2:adapter-java8:latest.version'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/StringConverterFactory.java b/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/StringConverterFactory.java
index de4b63e61..81c6ec90b 100644
--- a/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/StringConverterFactory.java
+++ b/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/StringConverterFactory.java
@@ -39,7 +39,7 @@
       Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     return new Converter<String, RequestBody>() {
       @Override public RequestBody convert(String value) throws IOException {
-        return RequestBody.create(MediaType.parse("text/plain"), value);
+        return RequestBody.create(MediaType.get("text/plain"), value);
       }
     };
   }
diff --git a/retrofit-adapters/rxjava/README.md b/retrofit-adapters/rxjava/README.md
index 3352daf8f..9b0a95828 100644
--- a/retrofit-adapters/rxjava/README.md
+++ b/retrofit-adapters/rxjava/README.md
@@ -50,7 +50,7 @@ Download [the latest JAR][2] or grab via [Maven][3]:
 ```
 or [Gradle][3]:
 ```groovy
-compile 'com.squareup.retrofit2:adapter-rxjava:latest.version'
+implementation 'com.squareup.retrofit2:adapter-rxjava:latest.version'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/StringConverterFactory.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/StringConverterFactory.java
index c44038d02..49de8bf19 100644
--- a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/StringConverterFactory.java
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/StringConverterFactory.java
@@ -39,7 +39,7 @@
       Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     return new Converter<String, RequestBody>() {
       @Override public RequestBody convert(String value) throws IOException {
-        return RequestBody.create(MediaType.parse("text/plain"), value);
+        return RequestBody.create(MediaType.get("text/plain"), value);
       }
     };
   }
diff --git a/retrofit-adapters/rxjava2/README.md b/retrofit-adapters/rxjava2/README.md
index 0512f9fbb..74d14b4be 100644
--- a/retrofit-adapters/rxjava2/README.md
+++ b/retrofit-adapters/rxjava2/README.md
@@ -51,7 +51,7 @@ Download [the latest JAR][2] or grab via [Maven][3]:
 ```
 or [Gradle][3]:
 ```groovy
-compile 'com.squareup.retrofit2:adapter-rxjava2:latest.version'
+implementation 'com.squareup.retrofit2:adapter-rxjava2:latest.version'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallEnqueueObservable.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallEnqueueObservable.java
index 8c7dc4ebc..3c6fa094b 100644
--- a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallEnqueueObservable.java
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallEnqueueObservable.java
@@ -37,7 +37,9 @@
     Call<T> call = originalCall.clone();
     CallCallback<T> callback = new CallCallback<>(call, observer);
     observer.onSubscribe(callback);
-    call.enqueue(callback);
+    if (!callback.isDisposed()) {
+      call.enqueue(callback);
+    }
   }
 
   private static final class CallCallback<T> implements Disposable, Callback<T> {
diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallExecuteObservable.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallExecuteObservable.java
index b4963e075..71b9066e7 100644
--- a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallExecuteObservable.java
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallExecuteObservable.java
@@ -36,6 +36,9 @@
     Call<T> call = originalCall.clone();
     CallDisposable disposable = new CallDisposable(call);
     observer.onSubscribe(disposable);
+    if (disposable.isDisposed()) {
+      return;
+    }
 
     boolean terminated = false;
     try {
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CancelDisposeTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CancelDisposeTest.java
index d643e4eb1..8a9a6c375 100644
--- a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CancelDisposeTest.java
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CancelDisposeTest.java
@@ -59,6 +59,12 @@
     assertTrue(calls.get(0).isCanceled());
   }
 
+  @Test public void disposeBeforeEnqueueDoesNotEnqueue() {
+    service.go().test(true);
+    List<Call> calls = client.dispatcher().runningCalls();
+    assertEquals(0, calls.size());
+  }
+
   @Test public void cancelDoesNotDispose() {
     Disposable disposable = service.go().subscribe();
     List<Call> calls = client.dispatcher().runningCalls();
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CancelDisposeTestSync.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CancelDisposeTestSync.java
new file mode 100644
index 000000000..174536d13
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CancelDisposeTestSync.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Observable;
+import okhttp3.OkHttpClient;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+import static org.junit.Assert.assertEquals;
+
+public final class CancelDisposeTestSync {
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  interface Service {
+    @GET("/") Observable<String> go();
+  }
+
+  private final OkHttpClient client = new OkHttpClient();
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
+        .callFactory(client)
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void disposeBeforeExecuteDoesNotEnqueue() {
+    service.go().test(true);
+    assertEquals(0, server.getRequestCount());
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/StringConverterFactory.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/StringConverterFactory.java
index 5a6841840..c975258cb 100644
--- a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/StringConverterFactory.java
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/StringConverterFactory.java
@@ -39,7 +39,7 @@
       Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     return new Converter<String, RequestBody>() {
       @Override public RequestBody convert(String value) throws IOException {
-        return RequestBody.create(MediaType.parse("text/plain"), value);
+        return RequestBody.create(MediaType.get("text/plain"), value);
       }
     };
   }
diff --git a/retrofit-adapters/scala/README.md b/retrofit-adapters/scala/README.md
index 74aa0a7a1..24c427fed 100644
--- a/retrofit-adapters/scala/README.md
+++ b/retrofit-adapters/scala/README.md
@@ -37,7 +37,7 @@ Download [the latest JAR][2] or grab via [Maven][3]:
 ```
 or [Gradle][3]:
 ```groovy
-compile 'com.squareup.retrofit2:adapter-scala:latest.version'
+implementation 'com.squareup.retrofit2:adapter-scala:latest.version'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/retrofit-adapters/scala/src/test/java/retrofit2/adapter/scala/StringConverterFactory.java b/retrofit-adapters/scala/src/test/java/retrofit2/adapter/scala/StringConverterFactory.java
index d14596c40..a46c087d3 100644
--- a/retrofit-adapters/scala/src/test/java/retrofit2/adapter/scala/StringConverterFactory.java
+++ b/retrofit-adapters/scala/src/test/java/retrofit2/adapter/scala/StringConverterFactory.java
@@ -39,7 +39,7 @@
       Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     return new Converter<String, RequestBody>() {
       @Override public RequestBody convert(String value) throws IOException {
-        return RequestBody.create(MediaType.parse("text/plain"), value);
+        return RequestBody.create(MediaType.get("text/plain"), value);
       }
     };
   }
diff --git a/retrofit-converters/gson/README.md b/retrofit-converters/gson/README.md
index 980d1d1f0..814f49ab1 100644
--- a/retrofit-converters/gson/README.md
+++ b/retrofit-converters/gson/README.md
@@ -20,7 +20,7 @@ Download [the latest JAR][2] or grab via [Maven][3]:
 ```
 or [Gradle][3]:
 ```groovy
-compile 'com.squareup.retrofit2:converter-gson:latest.version'
+implementation 'com.squareup.retrofit2:converter-gson:latest.version'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonRequestBodyConverter.java b/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonRequestBodyConverter.java
index 2e30a4478..a47775748 100644
--- a/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonRequestBodyConverter.java
+++ b/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonRequestBodyConverter.java
@@ -28,7 +28,7 @@
 import retrofit2.Converter;
 
 final class GsonRequestBodyConverter<T> implements Converter<T, RequestBody> {
-  private static final MediaType MEDIA_TYPE = MediaType.parse("application/json; charset=UTF-8");
+  private static final MediaType MEDIA_TYPE = MediaType.get("application/json; charset=UTF-8");
   private static final Charset UTF_8 = Charset.forName("UTF-8");
 
   private final Gson gson;
diff --git a/retrofit-converters/guava/README.md b/retrofit-converters/guava/README.md
index 03eae96f5..158a71e59 100644
--- a/retrofit-converters/guava/README.md
+++ b/retrofit-converters/guava/README.md
@@ -18,7 +18,7 @@ Download [the latest JAR][1] or grab via [Maven][2]:
 ```
 or [Gradle][2]:
 ```groovy
-compile 'com.squareup.retrofit2:converter-guava:latest.version'
+implementation 'com.squareup.retrofit2:converter-guava:latest.version'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/retrofit-converters/jackson/README.md b/retrofit-converters/jackson/README.md
index 2335d2903..8436a0de5 100644
--- a/retrofit-converters/jackson/README.md
+++ b/retrofit-converters/jackson/README.md
@@ -20,7 +20,7 @@ Download [the latest JAR][2] or grab via [Maven][3]:
 ```
 or [Gradle][3]:
 ```groovy
-compile 'com.squareup.retrofit2:converter-jackson:latest.version'
+implementation 'com.squareup.retrofit2:converter-jackson:latest.version'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonRequestBodyConverter.java b/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonRequestBodyConverter.java
index bd20a0ae0..85408a479 100644
--- a/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonRequestBodyConverter.java
+++ b/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonRequestBodyConverter.java
@@ -22,7 +22,7 @@
 import retrofit2.Converter;
 
 final class JacksonRequestBodyConverter<T> implements Converter<T, RequestBody> {
-  private static final MediaType MEDIA_TYPE = MediaType.parse("application/json; charset=UTF-8");
+  private static final MediaType MEDIA_TYPE = MediaType.get("application/json; charset=UTF-8");
 
   private final ObjectWriter adapter;
 
diff --git a/retrofit-converters/java8/README.md b/retrofit-converters/java8/README.md
index 696ac23c6..6aa640209 100644
--- a/retrofit-converters/java8/README.md
+++ b/retrofit-converters/java8/README.md
@@ -18,7 +18,7 @@ Download [the latest JAR][1] or grab via [Maven][2]:
 ```
 or [Gradle][2]:
 ```groovy
-compile 'com.squareup.retrofit2:converter-java8:latest.version'
+implementation 'com.squareup.retrofit2:converter-java8:latest.version'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/retrofit-converters/jaxb/README.md b/retrofit-converters/jaxb/README.md
index 76f311eb4..63176ed49 100644
--- a/retrofit-converters/jaxb/README.md
+++ b/retrofit-converters/jaxb/README.md
@@ -21,7 +21,7 @@ Download [the latest JAR][2] or grab via [Maven][3]:
 ```
 or [Gradle][3]:
 ```groovy
-compile 'com.squareup.retrofit2:converter-jaxb:latest.version'
+implementation 'com.squareup.retrofit2:converter-jaxb:latest.version'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/retrofit-converters/jaxb/src/main/java/retrofit2/converter/jaxb/JaxbConverterFactory.java b/retrofit-converters/jaxb/src/main/java/retrofit2/converter/jaxb/JaxbConverterFactory.java
index f0c8116dc..8e140aff6 100644
--- a/retrofit-converters/jaxb/src/main/java/retrofit2/converter/jaxb/JaxbConverterFactory.java
+++ b/retrofit-converters/jaxb/src/main/java/retrofit2/converter/jaxb/JaxbConverterFactory.java
@@ -32,7 +32,7 @@
  * ignored.
  */
 public final class JaxbConverterFactory extends Converter.Factory {
-  static final MediaType XML = MediaType.parse("application/xml; charset=utf-8");
+  static final MediaType XML = MediaType.get("application/xml; charset=utf-8");
 
   /** Create an instance using a default {@link JAXBContext} instance for conversion. */
   public static JaxbConverterFactory create() {
diff --git a/retrofit-converters/moshi/README.md b/retrofit-converters/moshi/README.md
index c5668f9ab..343b22dc0 100644
--- a/retrofit-converters/moshi/README.md
+++ b/retrofit-converters/moshi/README.md
@@ -20,7 +20,7 @@ Download [the latest JAR][2] or grab via [Maven][3]:
 ```
 or [Gradle][3]:
 ```groovy
-compile 'com.squareup.retrofit2:converter-moshi:latest.version'
+implementation 'com.squareup.retrofit2:converter-moshi:latest.version'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiRequestBodyConverter.java b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiRequestBodyConverter.java
index edbcf243e..879d73fc4 100644
--- a/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiRequestBodyConverter.java
+++ b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiRequestBodyConverter.java
@@ -24,7 +24,7 @@
 import retrofit2.Converter;
 
 final class MoshiRequestBodyConverter<T> implements Converter<T, RequestBody> {
-  private static final MediaType MEDIA_TYPE = MediaType.parse("application/json; charset=UTF-8");
+  private static final MediaType MEDIA_TYPE = MediaType.get("application/json; charset=UTF-8");
 
   private final JsonAdapter<T> adapter;
 
diff --git a/retrofit-converters/protobuf/README.md b/retrofit-converters/protobuf/README.md
index 7575a3d6c..2569fe962 100644
--- a/retrofit-converters/protobuf/README.md
+++ b/retrofit-converters/protobuf/README.md
@@ -17,7 +17,7 @@ Download [the latest JAR][2] or grab via [Maven][3]:
 ```
 or [Gradle][3]:
 ```groovy
-compile 'com.squareup.retrofit2:converter-protobuf:latest.version'
+implementation 'com.squareup.retrofit2:converter-protobuf:latest.version'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoRequestBodyConverter.java b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoRequestBodyConverter.java
index 814dc326b..90905db40 100644
--- a/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoRequestBodyConverter.java
+++ b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoRequestBodyConverter.java
@@ -22,7 +22,7 @@
 import retrofit2.Converter;
 
 final class ProtoRequestBodyConverter<T extends MessageLite> implements Converter<T, RequestBody> {
-  private static final MediaType MEDIA_TYPE = MediaType.parse("application/x-protobuf");
+  private static final MediaType MEDIA_TYPE = MediaType.get("application/x-protobuf");
 
   @Override public RequestBody convert(T value) throws IOException {
     byte[] bytes = value.toByteArray();
diff --git a/retrofit-converters/scalars/README.md b/retrofit-converters/scalars/README.md
index 5231b6129..67f0fd15b 100644
--- a/retrofit-converters/scalars/README.md
+++ b/retrofit-converters/scalars/README.md
@@ -18,7 +18,7 @@ Download [the latest JAR][1] or grab via [Maven][2]:
 ```
 or [Gradle][2]:
 ```groovy
-compile 'com.squareup.retrofit2:converter-scalars:latest.version'
+implementation 'com.squareup.retrofit2:converter-scalars:latest.version'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarRequestBodyConverter.java b/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarRequestBodyConverter.java
index fd65200d4..fb2f4ec43 100644
--- a/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarRequestBodyConverter.java
+++ b/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarRequestBodyConverter.java
@@ -22,7 +22,7 @@
 
 final class ScalarRequestBodyConverter<T> implements Converter<T, RequestBody> {
   static final ScalarRequestBodyConverter<Object> INSTANCE = new ScalarRequestBodyConverter<>();
-  private static final MediaType MEDIA_TYPE = MediaType.parse("text/plain; charset=UTF-8");
+  private static final MediaType MEDIA_TYPE = MediaType.get("text/plain; charset=UTF-8");
 
   private ScalarRequestBodyConverter() {
   }
diff --git a/retrofit-converters/simplexml/README.md b/retrofit-converters/simplexml/README.md
index 37e6f8f50..1a7ca6bf6 100644
--- a/retrofit-converters/simplexml/README.md
+++ b/retrofit-converters/simplexml/README.md
@@ -36,7 +36,7 @@ Download [the latest JAR][2] or grab via [Maven][3]:
 ```
 or [Gradle][3]:
 ```groovy
-compile 'com.squareup.retrofit2:converter-simplexml:latest.version'
+implementation 'com.squareup.retrofit2:converter-simplexml:latest.version'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlRequestBodyConverter.java b/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlRequestBodyConverter.java
index cb1c9dcb7..645b4bb73 100644
--- a/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlRequestBodyConverter.java
+++ b/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlRequestBodyConverter.java
@@ -24,7 +24,7 @@
 import retrofit2.Converter;
 
 final class SimpleXmlRequestBodyConverter<T> implements Converter<T, RequestBody> {
-  private static final MediaType MEDIA_TYPE = MediaType.parse("application/xml; charset=UTF-8");
+  private static final MediaType MEDIA_TYPE = MediaType.get("application/xml; charset=UTF-8");
   private static final String CHARSET = "UTF-8";
 
   private final Serializer serializer;
diff --git a/retrofit-converters/wire/README.md b/retrofit-converters/wire/README.md
index 6289cc8a7..eec260fd4 100644
--- a/retrofit-converters/wire/README.md
+++ b/retrofit-converters/wire/README.md
@@ -17,7 +17,7 @@ Download [the latest JAR][2] or grab via [Maven][3]:
 ```
 or [Gradle][3]:
 ```groovy
-compile 'com.squareup.retrofit2:converter-wire:latest.version'
+implementation 'com.squareup.retrofit2:converter-wire:latest.version'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireRequestBodyConverter.java b/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireRequestBodyConverter.java
index d388a944c..fd6cc3291 100644
--- a/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireRequestBodyConverter.java
+++ b/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireRequestBodyConverter.java
@@ -24,7 +24,7 @@
 import retrofit2.Converter;
 
 final class WireRequestBodyConverter<T extends Message<T, ?>> implements Converter<T, RequestBody> {
-  private static final MediaType MEDIA_TYPE = MediaType.parse("application/x-protobuf");
+  private static final MediaType MEDIA_TYPE = MediaType.get("application/x-protobuf");
 
   private final ProtoAdapter<T> adapter;
 
diff --git a/retrofit-mock/README.md b/retrofit-mock/README.md
index 851e9e82d..d846650b4 100644
--- a/retrofit-mock/README.md
+++ b/retrofit-mock/README.md
@@ -16,7 +16,7 @@ Download [the latest JAR][1] or grab via [Maven][2]:
 ```
 or [Gradle][1]:
 ```groovy
-compile 'com.squareup.retrofit2:retrofit-mock:see.latest.version'
+implementation 'com.squareup.retrofit2:retrofit-mock:see.latest.version'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/retrofit/pom.xml b/retrofit/pom.xml
index e665b66e2..d103d715f 100644
--- a/retrofit/pom.xml
+++ b/retrofit/pom.xml
@@ -24,6 +24,11 @@
       <artifactId>android</artifactId>
       <optional>true</optional>
     </dependency>
+    <dependency>
+      <groupId>org.jetbrains.kotlin</groupId>
+      <artifactId>kotlin-stdlib</artifactId>
+      <optional>true</optional>
+    </dependency>
 
     <dependency>
       <groupId>org.codehaus.mojo</groupId>
diff --git a/retrofit/src/main/java/retrofit2/BuiltInConverters.java b/retrofit/src/main/java/retrofit2/BuiltInConverters.java
index 86228d5c3..f5e636214 100644
--- a/retrofit/src/main/java/retrofit2/BuiltInConverters.java
+++ b/retrofit/src/main/java/retrofit2/BuiltInConverters.java
@@ -18,11 +18,15 @@
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+import kotlin.Unit;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import retrofit2.http.Streaming;
 
 final class BuiltInConverters extends Converter.Factory {
+  /** Not volatile because we don't mind multiple threads discovering this. */
+  private boolean checkForKotlinUnit = true;
+
   @Override
   public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
       Retrofit retrofit) {
@@ -34,6 +38,15 @@
     if (type == Void.class) {
       return VoidResponseBodyConverter.INSTANCE;
     }
+    if (checkForKotlinUnit) {
+      try {
+        if (type == Unit.class) {
+          return UnitResponseBodyConverter.INSTANCE;
+        }
+      } catch (NoClassDefFoundError ignored) {
+        checkForKotlinUnit = false;
+      }
+    }
     return null;
   }
 
@@ -55,6 +68,15 @@
     }
   }
 
+  static final class UnitResponseBodyConverter implements Converter<ResponseBody, Unit> {
+    static final UnitResponseBodyConverter INSTANCE = new UnitResponseBodyConverter();
+
+    @Override public Unit convert(ResponseBody value) {
+      value.close();
+      return Unit.INSTANCE;
+    }
+  }
+
   static final class RequestBodyConverter implements Converter<RequestBody, RequestBody> {
     static final RequestBodyConverter INSTANCE = new RequestBodyConverter();
 
diff --git a/retrofit/src/main/java/retrofit2/HttpServiceMethod.java b/retrofit/src/main/java/retrofit2/HttpServiceMethod.java
new file mode 100644
index 000000000..b6d13cedf
--- /dev/null
+++ b/retrofit/src/main/java/retrofit2/HttpServiceMethod.java
@@ -0,0 +1,103 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Method;
+import java.lang.reflect.Type;
+import javax.annotation.Nullable;
+import okhttp3.ResponseBody;
+
+import static retrofit2.Utils.methodError;
+
+/** Adapts an invocation of an interface method into an HTTP call. */
+final class HttpServiceMethod<ResponseT, ReturnT> extends ServiceMethod<ReturnT> {
+  private final RequestFactory requestFactory;
+  private final okhttp3.Call.Factory callFactory;
+  private final CallAdapter<ResponseT, ReturnT> callAdapter;
+  private final Converter<ResponseBody, ResponseT> responseConverter;
+
+  HttpServiceMethod(Builder<ResponseT, ReturnT> builder) {
+    requestFactory = builder.requestFactory;
+    callFactory = builder.retrofit.callFactory();
+    callAdapter = builder.callAdapter;
+    responseConverter = builder.responseConverter;
+  }
+
+  @Override ReturnT invoke(@Nullable Object[] args) {
+    return callAdapter.adapt(
+        new OkHttpCall<>(requestFactory, args, callFactory, responseConverter));
+  }
+
+  /**
+   * Inspects the annotations on an interface method to construct a reusable service method. This
+   * requires potentially-expensive reflection so it is best to build each service method only once
+   * and reuse it. Builders cannot be reused.
+   */
+  static final class Builder<ResponseT, ReturnT> {
+    final Retrofit retrofit;
+    final Method method;
+
+    RequestFactory requestFactory;
+    Type responseType;
+    Converter<ResponseBody, ResponseT> responseConverter;
+    CallAdapter<ResponseT, ReturnT> callAdapter;
+
+    Builder(Retrofit retrofit, Method method) {
+      this.retrofit = retrofit;
+      this.method = method;
+    }
+
+    HttpServiceMethod<ResponseT, ReturnT> build() {
+      requestFactory = RequestFactory.parseAnnotations(retrofit, method);
+
+      callAdapter = createCallAdapter();
+      responseType = callAdapter.responseType();
+      if (responseType == Response.class || responseType == okhttp3.Response.class) {
+        throw methodError(method, "'"
+            + Utils.getRawType(responseType).getName()
+            + "' is not a valid response body type. Did you mean ResponseBody?");
+      }
+      responseConverter = createResponseConverter();
+
+      if (requestFactory.httpMethod.equals("HEAD") && !Void.class.equals(responseType)) {
+        throw methodError(method, "HEAD method must use Void as response type.");
+      }
+
+      return new HttpServiceMethod<>(this);
+    }
+
+    private CallAdapter<ResponseT, ReturnT> createCallAdapter() {
+      Type returnType = method.getGenericReturnType();
+      Annotation[] annotations = method.getAnnotations();
+      try {
+        //noinspection unchecked
+        return (CallAdapter<ResponseT, ReturnT>) retrofit.callAdapter(returnType, annotations);
+      } catch (RuntimeException e) { // Wide exception range because factories are user code.
+        throw methodError(method, e, "Unable to create call adapter for %s", returnType);
+      }
+    }
+
+    private Converter<ResponseBody, ResponseT> createResponseConverter() {
+      Annotation[] annotations = method.getAnnotations();
+      try {
+        return retrofit.responseBodyConverter(responseType, annotations);
+      } catch (RuntimeException e) { // Wide exception range because factories are user code.
+        throw methodError(method, e, "Unable to create converter for %s", responseType);
+      }
+    }
+  }
+}
diff --git a/retrofit/src/main/java/retrofit2/OkHttpCall.java b/retrofit/src/main/java/retrofit2/OkHttpCall.java
index 45a77afe7..3a4d0562d 100644
--- a/retrofit/src/main/java/retrofit2/OkHttpCall.java
+++ b/retrofit/src/main/java/retrofit2/OkHttpCall.java
@@ -30,8 +30,10 @@
 import static retrofit2.Utils.throwIfFatal;
 
 final class OkHttpCall<T> implements Call<T> {
-  private final ServiceMethod<T, ?> serviceMethod;
+  private final RequestFactory requestFactory;
   private final @Nullable Object[] args;
+  private final okhttp3.Call.Factory callFactory;
+  private final Converter<ResponseBody, T> responseConverter;
 
   private volatile boolean canceled;
 
@@ -42,14 +44,17 @@
   @GuardedBy("this")
   private boolean executed;
 
-  OkHttpCall(ServiceMethod<T, ?> serviceMethod, @Nullable Object[] args) {
-    this.serviceMethod = serviceMethod;
+  OkHttpCall(RequestFactory requestFactory, @Nullable Object[] args,
+      okhttp3.Call.Factory callFactory, Converter<ResponseBody, T> responseConverter) {
+    this.requestFactory = requestFactory;
     this.args = args;
+    this.callFactory = callFactory;
+    this.responseConverter = responseConverter;
   }
 
   @SuppressWarnings("CloneDoesntCallSuperClone") // We are a final type & this saves clearing state.
   @Override public OkHttpCall<T> clone() {
-    return new OkHttpCall<>(serviceMethod, args);
+    return new OkHttpCall<>(requestFactory, args, callFactory, responseConverter);
   }
 
   @Override public synchronized Request request() {
@@ -182,7 +187,7 @@ private void callFailure(Throwable e) {
   }
 
   private okhttp3.Call createRawCall() throws IOException {
-    okhttp3.Call call = serviceMethod.toCall(args);
+    okhttp3.Call call = callFactory.newCall(requestFactory.create(args));
     if (call == null) {
       throw new NullPointerException("Call.Factory returned null.");
     }
@@ -213,9 +218,9 @@ private void callFailure(Throwable e) {
       return Response.success(null, rawResponse);
     }
 
-    ExceptionCatchingRequestBody catchingBody = new ExceptionCatchingRequestBody(rawBody);
+    ExceptionCatchingResponseBody catchingBody = new ExceptionCatchingResponseBody(rawBody);
     try {
-      T body = serviceMethod.toResponse(catchingBody);
+      T body = responseConverter.convert(catchingBody);
       return Response.success(body, rawResponse);
     } catch (RuntimeException e) {
       // If the underlying source threw an exception, propagate that rather than indicating it was
@@ -268,11 +273,11 @@ public void cancel() {
     }
   }
 
-  static final class ExceptionCatchingRequestBody extends ResponseBody {
+  static final class ExceptionCatchingResponseBody extends ResponseBody {
     private final ResponseBody delegate;
     IOException thrownException;
 
-    ExceptionCatchingRequestBody(ResponseBody delegate) {
+    ExceptionCatchingResponseBody(ResponseBody delegate) {
       this.delegate = delegate;
     }
 
diff --git a/retrofit/src/main/java/retrofit2/Platform.java b/retrofit/src/main/java/retrofit2/Platform.java
index 3c3307b70..092c95f8f 100644
--- a/retrofit/src/main/java/retrofit2/Platform.java
+++ b/retrofit/src/main/java/retrofit2/Platform.java
@@ -88,6 +88,14 @@ boolean isDefaultMethod(Method method) {
   }
 
   static class Android extends Platform {
+    @IgnoreJRERequirement // Guarded by API check.
+    @Override boolean isDefaultMethod(Method method) {
+      if (Build.VERSION.SDK_INT < 24) {
+        return false;
+      }
+      return method.isDefault();
+    }
+
     @Override public Executor defaultCallbackExecutor() {
       return new MainThreadExecutor();
     }
diff --git a/retrofit/src/main/java/retrofit2/RequestBuilder.java b/retrofit/src/main/java/retrofit2/RequestBuilder.java
index f27db26ee..436240cc4 100644
--- a/retrofit/src/main/java/retrofit2/RequestBuilder.java
+++ b/retrofit/src/main/java/retrofit2/RequestBuilder.java
@@ -76,11 +76,11 @@ void setRelativeUrl(Object relativeUrl) {
 
   void addHeader(String name, String value) {
     if ("Content-Type".equalsIgnoreCase(name)) {
-      MediaType type = MediaType.parse(value);
-      if (type == null) {
-        throw new IllegalArgumentException("Malformed content type: " + value);
+      try {
+        contentType = MediaType.get(value);
+      } catch (IllegalArgumentException e) {
+        throw new IllegalArgumentException("Malformed content type: " + value, e);
       }
-      contentType = type;
     } else {
       requestBuilder.addHeader(name, value);
     }
diff --git a/retrofit/src/main/java/retrofit2/RequestFactory.java b/retrofit/src/main/java/retrofit2/RequestFactory.java
new file mode 100644
index 000000000..ee7cdba41
--- /dev/null
+++ b/retrofit/src/main/java/retrofit2/RequestFactory.java
@@ -0,0 +1,741 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Method;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.net.URI;
+import java.util.LinkedHashSet;
+import java.util.Map;
+import java.util.Set;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import javax.annotation.Nullable;
+import okhttp3.Headers;
+import okhttp3.HttpUrl;
+import okhttp3.MediaType;
+import okhttp3.MultipartBody;
+import okhttp3.RequestBody;
+import retrofit2.http.Body;
+import retrofit2.http.DELETE;
+import retrofit2.http.Field;
+import retrofit2.http.FieldMap;
+import retrofit2.http.FormUrlEncoded;
+import retrofit2.http.GET;
+import retrofit2.http.HEAD;
+import retrofit2.http.HTTP;
+import retrofit2.http.Header;
+import retrofit2.http.HeaderMap;
+import retrofit2.http.Multipart;
+import retrofit2.http.OPTIONS;
+import retrofit2.http.PATCH;
+import retrofit2.http.POST;
+import retrofit2.http.PUT;
+import retrofit2.http.Part;
+import retrofit2.http.PartMap;
+import retrofit2.http.Path;
+import retrofit2.http.Query;
+import retrofit2.http.QueryMap;
+import retrofit2.http.QueryName;
+import retrofit2.http.Url;
+
+import static retrofit2.Utils.methodError;
+import static retrofit2.Utils.parameterError;
+
+final class RequestFactory {
+  static RequestFactory parseAnnotations(Retrofit retrofit, Method method) {
+    return new Builder(retrofit, method).build();
+  }
+
+  private final HttpUrl baseUrl;
+  final String httpMethod;
+  private final String relativeUrl;
+  private final Headers headers;
+  private final MediaType contentType;
+  private final boolean hasBody;
+  private final boolean isFormEncoded;
+  private final boolean isMultipart;
+  private final ParameterHandler<?>[] parameterHandlers;
+
+  RequestFactory(Builder builder) {
+    baseUrl = builder.retrofit.baseUrl;
+    httpMethod = builder.httpMethod;
+    relativeUrl = builder.relativeUrl;
+    headers = builder.headers;
+    contentType = builder.contentType;
+    hasBody = builder.hasBody;
+    isFormEncoded = builder.isFormEncoded;
+    isMultipart = builder.isMultipart;
+    parameterHandlers = builder.parameterHandlers;
+  }
+
+  okhttp3.Request create(@Nullable Object[] args) throws IOException {
+    RequestBuilder requestBuilder = new RequestBuilder(httpMethod, baseUrl, relativeUrl, headers,
+        contentType, hasBody, isFormEncoded, isMultipart);
+
+    @SuppressWarnings("unchecked") // It is an error to invoke a method with the wrong arg types.
+    ParameterHandler<Object>[] handlers = (ParameterHandler<Object>[]) parameterHandlers;
+
+    int argumentCount = args != null ? args.length : 0;
+    if (argumentCount != handlers.length) {
+      throw new IllegalArgumentException("Argument count (" + argumentCount
+          + ") doesn't match expected count (" + handlers.length + ")");
+    }
+
+    for (int p = 0; p < argumentCount; p++) {
+      handlers[p].apply(requestBuilder, args[p]);
+    }
+
+    return requestBuilder.build();
+  }
+
+  /**
+   * Inspects the annotations on an interface method to construct a reusable service method. This
+   * requires potentially-expensive reflection so it is best to build each service method only once
+   * and reuse it. Builders cannot be reused.
+   */
+  static final class Builder {
+    // Upper and lower characters, digits, underscores, and hyphens, starting with a character.
+    private static final String PARAM = "[a-zA-Z][a-zA-Z0-9_-]*";
+    private static final Pattern PARAM_URL_REGEX = Pattern.compile("\\{(" + PARAM + ")\\}");
+    private static final Pattern PARAM_NAME_REGEX = Pattern.compile(PARAM);
+
+    final Retrofit retrofit;
+    final Method method;
+    final Annotation[] methodAnnotations;
+    final Annotation[][] parameterAnnotationsArray;
+    final Type[] parameterTypes;
+
+    boolean gotField;
+    boolean gotPart;
+    boolean gotBody;
+    boolean gotPath;
+    boolean gotQuery;
+    boolean gotQueryName;
+    boolean gotQueryMap;
+    boolean gotUrl;
+    String httpMethod;
+    boolean hasBody;
+    boolean isFormEncoded;
+    boolean isMultipart;
+    String relativeUrl;
+    Headers headers;
+    MediaType contentType;
+    Set<String> relativeUrlParamNames;
+    ParameterHandler<?>[] parameterHandlers;
+
+    Builder(Retrofit retrofit, Method method) {
+      this.retrofit = retrofit;
+      this.method = method;
+      this.methodAnnotations = method.getAnnotations();
+      this.parameterTypes = method.getGenericParameterTypes();
+      this.parameterAnnotationsArray = method.getParameterAnnotations();
+    }
+
+    RequestFactory build() {
+      for (Annotation annotation : methodAnnotations) {
+        parseMethodAnnotation(annotation);
+      }
+
+      if (httpMethod == null) {
+        throw methodError(method, "HTTP method annotation is required (e.g., @GET, @POST, etc.).");
+      }
+
+      if (!hasBody) {
+        if (isMultipart) {
+          throw methodError(method,
+              "Multipart can only be specified on HTTP methods with request body (e.g., @POST).");
+        }
+        if (isFormEncoded) {
+          throw methodError(method, "FormUrlEncoded can only be specified on HTTP methods with "
+              + "request body (e.g., @POST).");
+        }
+      }
+
+      int parameterCount = parameterAnnotationsArray.length;
+      parameterHandlers = new ParameterHandler<?>[parameterCount];
+      for (int p = 0; p < parameterCount; p++) {
+        Type parameterType = parameterTypes[p];
+        if (Utils.hasUnresolvableType(parameterType)) {
+          throw parameterError(method, p,
+              "Parameter type must not include a type variable or wildcard: %s", parameterType);
+        }
+
+        Annotation[] parameterAnnotations = parameterAnnotationsArray[p];
+        if (parameterAnnotations == null) {
+          throw parameterError(method, p, "No Retrofit annotation found.");
+        }
+
+        parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);
+      }
+
+      if (relativeUrl == null && !gotUrl) {
+        throw methodError(method, "Missing either @%s URL or @Url parameter.", httpMethod);
+      }
+      if (!isFormEncoded && !isMultipart && !hasBody && gotBody) {
+        throw methodError(method, "Non-body HTTP method cannot contain @Body.");
+      }
+      if (isFormEncoded && !gotField) {
+        throw methodError(method, "Form-encoded method must contain at least one @Field.");
+      }
+      if (isMultipart && !gotPart) {
+        throw methodError(method, "Multipart method must contain at least one @Part.");
+      }
+
+      return new RequestFactory(this);
+    }
+
+    private void parseMethodAnnotation(Annotation annotation) {
+      if (annotation instanceof DELETE) {
+        parseHttpMethodAndPath("DELETE", ((DELETE) annotation).value(), false);
+      } else if (annotation instanceof GET) {
+        parseHttpMethodAndPath("GET", ((GET) annotation).value(), false);
+      } else if (annotation instanceof HEAD) {
+        parseHttpMethodAndPath("HEAD", ((HEAD) annotation).value(), false);
+      } else if (annotation instanceof PATCH) {
+        parseHttpMethodAndPath("PATCH", ((PATCH) annotation).value(), true);
+      } else if (annotation instanceof POST) {
+        parseHttpMethodAndPath("POST", ((POST) annotation).value(), true);
+      } else if (annotation instanceof PUT) {
+        parseHttpMethodAndPath("PUT", ((PUT) annotation).value(), true);
+      } else if (annotation instanceof OPTIONS) {
+        parseHttpMethodAndPath("OPTIONS", ((OPTIONS) annotation).value(), false);
+      } else if (annotation instanceof HTTP) {
+        HTTP http = (HTTP) annotation;
+        parseHttpMethodAndPath(http.method(), http.path(), http.hasBody());
+      } else if (annotation instanceof retrofit2.http.Headers) {
+        String[] headersToParse = ((retrofit2.http.Headers) annotation).value();
+        if (headersToParse.length == 0) {
+          throw methodError(method, "@Headers annotation is empty.");
+        }
+        headers = parseHeaders(headersToParse);
+      } else if (annotation instanceof Multipart) {
+        if (isFormEncoded) {
+          throw methodError(method, "Only one encoding annotation is allowed.");
+        }
+        isMultipart = true;
+      } else if (annotation instanceof FormUrlEncoded) {
+        if (isMultipart) {
+          throw methodError(method, "Only one encoding annotation is allowed.");
+        }
+        isFormEncoded = true;
+      }
+    }
+
+    private void parseHttpMethodAndPath(String httpMethod, String value, boolean hasBody) {
+      if (this.httpMethod != null) {
+        throw methodError(method, "Only one HTTP method is allowed. Found: %s and %s.",
+            this.httpMethod, httpMethod);
+      }
+      this.httpMethod = httpMethod;
+      this.hasBody = hasBody;
+
+      if (value.isEmpty()) {
+        return;
+      }
+
+      // Get the relative URL path and existing query string, if present.
+      int question = value.indexOf('?');
+      if (question != -1 && question < value.length() - 1) {
+        // Ensure the query string does not have any named parameters.
+        String queryParams = value.substring(question + 1);
+        Matcher queryParamMatcher = PARAM_URL_REGEX.matcher(queryParams);
+        if (queryParamMatcher.find()) {
+          throw methodError(method, "URL query string \"%s\" must not have replace block. "
+              + "For dynamic query parameters use @Query.", queryParams);
+        }
+      }
+
+      this.relativeUrl = value;
+      this.relativeUrlParamNames = parsePathParameters(value);
+    }
+
+    private Headers parseHeaders(String[] headers) {
+      Headers.Builder builder = new Headers.Builder();
+      for (String header : headers) {
+        int colon = header.indexOf(':');
+        if (colon == -1 || colon == 0 || colon == header.length() - 1) {
+          throw methodError(method,
+              "@Headers value must be in the form \"Name: Value\". Found: \"%s\"", header);
+        }
+        String headerName = header.substring(0, colon);
+        String headerValue = header.substring(colon + 1).trim();
+        if ("Content-Type".equalsIgnoreCase(headerName)) {
+          try {
+            contentType = MediaType.get(headerValue);
+          } catch (IllegalArgumentException e) {
+            throw methodError(method, e, "Malformed content type: %s", headerValue);
+          }
+        } else {
+          builder.add(headerName, headerValue);
+        }
+      }
+      return builder.build();
+    }
+
+    private ParameterHandler<?> parseParameter(
+        int p, Type parameterType, Annotation[] annotations) {
+      ParameterHandler<?> result = null;
+      for (Annotation annotation : annotations) {
+        ParameterHandler<?> annotationAction = parseParameterAnnotation(
+            p, parameterType, annotations, annotation);
+
+        if (annotationAction == null) {
+          continue;
+        }
+
+        if (result != null) {
+          throw parameterError(method, p, "Multiple Retrofit annotations found, only one allowed.");
+        }
+
+        result = annotationAction;
+      }
+
+      if (result == null) {
+        throw parameterError(method, p, "No Retrofit annotation found.");
+      }
+
+      return result;
+    }
+
+    private ParameterHandler<?> parseParameterAnnotation(
+        int p, Type type, Annotation[] annotations, Annotation annotation) {
+      if (annotation instanceof Url) {
+        if (gotUrl) {
+          throw parameterError(method, p, "Multiple @Url method annotations found.");
+        }
+        if (gotPath) {
+          throw parameterError(method, p, "@Path parameters may not be used with @Url.");
+        }
+        if (gotQuery) {
+          throw parameterError(method, p, "A @Url parameter must not come after a @Query.");
+        }
+        if (gotQueryName) {
+          throw parameterError(method, p, "A @Url parameter must not come after a @QueryName.");
+        }
+        if (gotQueryMap) {
+          throw parameterError(method, p, "A @Url parameter must not come after a @QueryMap.");
+        }
+        if (relativeUrl != null) {
+          throw parameterError(method, p, "@Url cannot be used with @%s URL", httpMethod);
+        }
+
+        gotUrl = true;
+
+        if (type == HttpUrl.class
+            || type == String.class
+            || type == URI.class
+            || (type instanceof Class && "android.net.Uri".equals(((Class<?>) type).getName()))) {
+          return new ParameterHandler.RelativeUrl();
+        } else {
+          throw parameterError(method, p,
+              "@Url must be okhttp3.HttpUrl, String, java.net.URI, or android.net.Uri type.");
+        }
+
+      } else if (annotation instanceof Path) {
+        if (gotQuery) {
+          throw parameterError(method, p, "A @Path parameter must not come after a @Query.");
+        }
+        if (gotQueryName) {
+          throw parameterError(method, p, "A @Path parameter must not come after a @QueryName.");
+        }
+        if (gotQueryMap) {
+          throw parameterError(method, p, "A @Path parameter must not come after a @QueryMap.");
+        }
+        if (gotUrl) {
+          throw parameterError(method, p, "@Path parameters may not be used with @Url.");
+        }
+        if (relativeUrl == null) {
+          throw parameterError(method, p, "@Path can only be used with relative url on @%s",
+              httpMethod);
+        }
+        gotPath = true;
+
+        Path path = (Path) annotation;
+        String name = path.value();
+        validatePathName(p, name);
+
+        Converter<?, String> converter = retrofit.stringConverter(type, annotations);
+        return new ParameterHandler.Path<>(name, converter, path.encoded());
+
+      } else if (annotation instanceof Query) {
+        Query query = (Query) annotation;
+        String name = query.value();
+        boolean encoded = query.encoded();
+
+        Class<?> rawParameterType = Utils.getRawType(type);
+        gotQuery = true;
+        if (Iterable.class.isAssignableFrom(rawParameterType)) {
+          if (!(type instanceof ParameterizedType)) {
+            throw parameterError(method, p, rawParameterType.getSimpleName()
+                + " must include generic type (e.g., "
+                + rawParameterType.getSimpleName()
+                + "<String>)");
+          }
+          ParameterizedType parameterizedType = (ParameterizedType) type;
+          Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
+          Converter<?, String> converter =
+              retrofit.stringConverter(iterableType, annotations);
+          return new ParameterHandler.Query<>(name, converter, encoded).iterable();
+        } else if (rawParameterType.isArray()) {
+          Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
+          Converter<?, String> converter =
+              retrofit.stringConverter(arrayComponentType, annotations);
+          return new ParameterHandler.Query<>(name, converter, encoded).array();
+        } else {
+          Converter<?, String> converter =
+              retrofit.stringConverter(type, annotations);
+          return new ParameterHandler.Query<>(name, converter, encoded);
+        }
+
+      } else if (annotation instanceof QueryName) {
+        QueryName query = (QueryName) annotation;
+        boolean encoded = query.encoded();
+
+        Class<?> rawParameterType = Utils.getRawType(type);
+        gotQueryName = true;
+        if (Iterable.class.isAssignableFrom(rawParameterType)) {
+          if (!(type instanceof ParameterizedType)) {
+            throw parameterError(method, p, rawParameterType.getSimpleName()
+                + " must include generic type (e.g., "
+                + rawParameterType.getSimpleName()
+                + "<String>)");
+          }
+          ParameterizedType parameterizedType = (ParameterizedType) type;
+          Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
+          Converter<?, String> converter =
+              retrofit.stringConverter(iterableType, annotations);
+          return new ParameterHandler.QueryName<>(converter, encoded).iterable();
+        } else if (rawParameterType.isArray()) {
+          Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
+          Converter<?, String> converter =
+              retrofit.stringConverter(arrayComponentType, annotations);
+          return new ParameterHandler.QueryName<>(converter, encoded).array();
+        } else {
+          Converter<?, String> converter =
+              retrofit.stringConverter(type, annotations);
+          return new ParameterHandler.QueryName<>(converter, encoded);
+        }
+
+      } else if (annotation instanceof QueryMap) {
+        Class<?> rawParameterType = Utils.getRawType(type);
+        gotQueryMap = true;
+        if (!Map.class.isAssignableFrom(rawParameterType)) {
+          throw parameterError(method, p, "@QueryMap parameter type must be Map.");
+        }
+        Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
+        if (!(mapType instanceof ParameterizedType)) {
+          throw parameterError(method, p,
+              "Map must include generic types (e.g., Map<String, String>)");
+        }
+        ParameterizedType parameterizedType = (ParameterizedType) mapType;
+        Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
+        if (String.class != keyType) {
+          throw parameterError(method, p, "@QueryMap keys must be of type String: " + keyType);
+        }
+        Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
+        Converter<?, String> valueConverter =
+            retrofit.stringConverter(valueType, annotations);
+
+        return new ParameterHandler.QueryMap<>(valueConverter, ((QueryMap) annotation).encoded());
+
+      } else if (annotation instanceof Header) {
+        Header header = (Header) annotation;
+        String name = header.value();
+
+        Class<?> rawParameterType = Utils.getRawType(type);
+        if (Iterable.class.isAssignableFrom(rawParameterType)) {
+          if (!(type instanceof ParameterizedType)) {
+            throw parameterError(method, p, rawParameterType.getSimpleName()
+                + " must include generic type (e.g., "
+                + rawParameterType.getSimpleName()
+                + "<String>)");
+          }
+          ParameterizedType parameterizedType = (ParameterizedType) type;
+          Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
+          Converter<?, String> converter =
+              retrofit.stringConverter(iterableType, annotations);
+          return new ParameterHandler.Header<>(name, converter).iterable();
+        } else if (rawParameterType.isArray()) {
+          Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
+          Converter<?, String> converter =
+              retrofit.stringConverter(arrayComponentType, annotations);
+          return new ParameterHandler.Header<>(name, converter).array();
+        } else {
+          Converter<?, String> converter =
+              retrofit.stringConverter(type, annotations);
+          return new ParameterHandler.Header<>(name, converter);
+        }
+
+      } else if (annotation instanceof HeaderMap) {
+        Class<?> rawParameterType = Utils.getRawType(type);
+        if (!Map.class.isAssignableFrom(rawParameterType)) {
+          throw parameterError(method, p, "@HeaderMap parameter type must be Map.");
+        }
+        Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
+        if (!(mapType instanceof ParameterizedType)) {
+          throw parameterError(method, p,
+              "Map must include generic types (e.g., Map<String, String>)");
+        }
+        ParameterizedType parameterizedType = (ParameterizedType) mapType;
+        Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
+        if (String.class != keyType) {
+          throw parameterError(method, p, "@HeaderMap keys must be of type String: " + keyType);
+        }
+        Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
+        Converter<?, String> valueConverter =
+            retrofit.stringConverter(valueType, annotations);
+
+        return new ParameterHandler.HeaderMap<>(valueConverter);
+
+      } else if (annotation instanceof Field) {
+        if (!isFormEncoded) {
+          throw parameterError(method, p, "@Field parameters can only be used with form encoding.");
+        }
+        Field field = (Field) annotation;
+        String name = field.value();
+        boolean encoded = field.encoded();
+
+        gotField = true;
+
+        Class<?> rawParameterType = Utils.getRawType(type);
+        if (Iterable.class.isAssignableFrom(rawParameterType)) {
+          if (!(type instanceof ParameterizedType)) {
+            throw parameterError(method, p, rawParameterType.getSimpleName()
+                + " must include generic type (e.g., "
+                + rawParameterType.getSimpleName()
+                + "<String>)");
+          }
+          ParameterizedType parameterizedType = (ParameterizedType) type;
+          Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
+          Converter<?, String> converter =
+              retrofit.stringConverter(iterableType, annotations);
+          return new ParameterHandler.Field<>(name, converter, encoded).iterable();
+        } else if (rawParameterType.isArray()) {
+          Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
+          Converter<?, String> converter =
+              retrofit.stringConverter(arrayComponentType, annotations);
+          return new ParameterHandler.Field<>(name, converter, encoded).array();
+        } else {
+          Converter<?, String> converter =
+              retrofit.stringConverter(type, annotations);
+          return new ParameterHandler.Field<>(name, converter, encoded);
+        }
+
+      } else if (annotation instanceof FieldMap) {
+        if (!isFormEncoded) {
+          throw parameterError(method, p,
+              "@FieldMap parameters can only be used with form encoding.");
+        }
+        Class<?> rawParameterType = Utils.getRawType(type);
+        if (!Map.class.isAssignableFrom(rawParameterType)) {
+          throw parameterError(method, p, "@FieldMap parameter type must be Map.");
+        }
+        Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
+        if (!(mapType instanceof ParameterizedType)) {
+          throw parameterError(method, p,
+              "Map must include generic types (e.g., Map<String, String>)");
+        }
+        ParameterizedType parameterizedType = (ParameterizedType) mapType;
+        Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
+        if (String.class != keyType) {
+          throw parameterError(method, p, "@FieldMap keys must be of type String: " + keyType);
+        }
+        Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
+        Converter<?, String> valueConverter =
+            retrofit.stringConverter(valueType, annotations);
+
+        gotField = true;
+        return new ParameterHandler.FieldMap<>(valueConverter, ((FieldMap) annotation).encoded());
+
+      } else if (annotation instanceof Part) {
+        if (!isMultipart) {
+          throw parameterError(method, p,
+              "@Part parameters can only be used with multipart encoding.");
+        }
+        Part part = (Part) annotation;
+        gotPart = true;
+
+        String partName = part.value();
+        Class<?> rawParameterType = Utils.getRawType(type);
+        if (partName.isEmpty()) {
+          if (Iterable.class.isAssignableFrom(rawParameterType)) {
+            if (!(type instanceof ParameterizedType)) {
+              throw parameterError(method, p, rawParameterType.getSimpleName()
+                  + " must include generic type (e.g., "
+                  + rawParameterType.getSimpleName()
+                  + "<String>)");
+            }
+            ParameterizedType parameterizedType = (ParameterizedType) type;
+            Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
+            if (!MultipartBody.Part.class.isAssignableFrom(Utils.getRawType(iterableType))) {
+              throw parameterError(method, p,
+                  "@Part annotation must supply a name or use MultipartBody.Part parameter type.");
+            }
+            return ParameterHandler.RawPart.INSTANCE.iterable();
+          } else if (rawParameterType.isArray()) {
+            Class<?> arrayComponentType = rawParameterType.getComponentType();
+            if (!MultipartBody.Part.class.isAssignableFrom(arrayComponentType)) {
+              throw parameterError(method, p,
+                  "@Part annotation must supply a name or use MultipartBody.Part parameter type.");
+            }
+            return ParameterHandler.RawPart.INSTANCE.array();
+          } else if (MultipartBody.Part.class.isAssignableFrom(rawParameterType)) {
+            return ParameterHandler.RawPart.INSTANCE;
+          } else {
+            throw parameterError(method, p,
+                "@Part annotation must supply a name or use MultipartBody.Part parameter type.");
+          }
+        } else {
+          Headers headers =
+              Headers.of("Content-Disposition", "form-data; name=\"" + partName + "\"",
+                  "Content-Transfer-Encoding", part.encoding());
+
+          if (Iterable.class.isAssignableFrom(rawParameterType)) {
+            if (!(type instanceof ParameterizedType)) {
+              throw parameterError(method, p, rawParameterType.getSimpleName()
+                  + " must include generic type (e.g., "
+                  + rawParameterType.getSimpleName()
+                  + "<String>)");
+            }
+            ParameterizedType parameterizedType = (ParameterizedType) type;
+            Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
+            if (MultipartBody.Part.class.isAssignableFrom(Utils.getRawType(iterableType))) {
+              throw parameterError(method, p,
+                  "@Part parameters using the MultipartBody.Part must not "
+                      + "include a part name in the annotation.");
+            }
+            Converter<?, RequestBody> converter =
+                retrofit.requestBodyConverter(iterableType, annotations, methodAnnotations);
+            return new ParameterHandler.Part<>(headers, converter).iterable();
+          } else if (rawParameterType.isArray()) {
+            Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
+            if (MultipartBody.Part.class.isAssignableFrom(arrayComponentType)) {
+              throw parameterError(method, p,
+                  "@Part parameters using the MultipartBody.Part must not "
+                      + "include a part name in the annotation.");
+            }
+            Converter<?, RequestBody> converter =
+                retrofit.requestBodyConverter(arrayComponentType, annotations, methodAnnotations);
+            return new ParameterHandler.Part<>(headers, converter).array();
+          } else if (MultipartBody.Part.class.isAssignableFrom(rawParameterType)) {
+            throw parameterError(method, p,
+                "@Part parameters using the MultipartBody.Part must not "
+                    + "include a part name in the annotation.");
+          } else {
+            Converter<?, RequestBody> converter =
+                retrofit.requestBodyConverter(type, annotations, methodAnnotations);
+            return new ParameterHandler.Part<>(headers, converter);
+          }
+        }
+
+      } else if (annotation instanceof PartMap) {
+        if (!isMultipart) {
+          throw parameterError(method, p,
+              "@PartMap parameters can only be used with multipart encoding.");
+        }
+        gotPart = true;
+        Class<?> rawParameterType = Utils.getRawType(type);
+        if (!Map.class.isAssignableFrom(rawParameterType)) {
+          throw parameterError(method, p, "@PartMap parameter type must be Map.");
+        }
+        Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
+        if (!(mapType instanceof ParameterizedType)) {
+          throw parameterError(method, p,
+              "Map must include generic types (e.g., Map<String, String>)");
+        }
+        ParameterizedType parameterizedType = (ParameterizedType) mapType;
+
+        Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
+        if (String.class != keyType) {
+          throw parameterError(method, p, "@PartMap keys must be of type String: " + keyType);
+        }
+
+        Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
+        if (MultipartBody.Part.class.isAssignableFrom(Utils.getRawType(valueType))) {
+          throw parameterError(method, p, "@PartMap values cannot be MultipartBody.Part. "
+              + "Use @Part List<Part> or a different value type instead.");
+        }
+
+        Converter<?, RequestBody> valueConverter =
+            retrofit.requestBodyConverter(valueType, annotations, methodAnnotations);
+
+        PartMap partMap = (PartMap) annotation;
+        return new ParameterHandler.PartMap<>(valueConverter, partMap.encoding());
+
+      } else if (annotation instanceof Body) {
+        if (isFormEncoded || isMultipart) {
+          throw parameterError(method, p,
+              "@Body parameters cannot be used with form or multi-part encoding.");
+        }
+        if (gotBody) {
+          throw parameterError(method, p, "Multiple @Body method annotations found.");
+        }
+
+        Converter<?, RequestBody> converter;
+        try {
+          converter = retrofit.requestBodyConverter(type, annotations, methodAnnotations);
+        } catch (RuntimeException e) {
+          // Wide exception range because factories are user code.
+          throw parameterError(method, e, p, "Unable to create @Body converter for %s", type);
+        }
+        gotBody = true;
+        return new ParameterHandler.Body<>(converter);
+      }
+
+      return null; // Not a Retrofit annotation.
+    }
+
+    private void validatePathName(int p, String name) {
+      if (!PARAM_NAME_REGEX.matcher(name).matches()) {
+        throw parameterError(method, p, "@Path parameter name must match %s. Found: %s",
+            PARAM_URL_REGEX.pattern(), name);
+      }
+      // Verify URL replacement name is actually present in the URL path.
+      if (!relativeUrlParamNames.contains(name)) {
+        throw parameterError(method, p, "URL \"%s\" does not contain \"{%s}\".", relativeUrl, name);
+      }
+    }
+
+    /**
+     * Gets the set of unique path parameters used in the given URI. If a parameter is used twice
+     * in the URI, it will only show up once in the set.
+     */
+    static Set<String> parsePathParameters(String path) {
+      Matcher m = PARAM_URL_REGEX.matcher(path);
+      Set<String> patterns = new LinkedHashSet<>();
+      while (m.find()) {
+        patterns.add(m.group(1));
+      }
+      return patterns;
+    }
+
+    private static Class<?> boxIfPrimitive(Class<?> type) {
+      if (boolean.class == type) return Boolean.class;
+      if (byte.class == type) return Byte.class;
+      if (char.class == type) return Character.class;
+      if (double.class == type) return Double.class;
+      if (float.class == type) return Float.class;
+      if (int.class == type) return Integer.class;
+      if (long.class == type) return Long.class;
+      if (short.class == type) return Short.class;
+      return type;
+    }
+  }
+}
diff --git a/retrofit/src/main/java/retrofit2/Retrofit.java b/retrofit/src/main/java/retrofit2/Retrofit.java
index 2f1ee2524..498d006eb 100644
--- a/retrofit/src/main/java/retrofit2/Retrofit.java
+++ b/retrofit/src/main/java/retrofit2/Retrofit.java
@@ -58,7 +58,7 @@
  * @author Jake Wharton (jw@squareup.com)
  */
 public final class Retrofit {
-  private final Map<Method, ServiceMethod<?, ?>> serviceMethodCache = new ConcurrentHashMap<>();
+  private final Map<Method, ServiceMethod<?>> serviceMethodCache = new ConcurrentHashMap<>();
 
   final okhttp3.Call.Factory callFactory;
   final HttpUrl baseUrl;
@@ -143,10 +143,7 @@
             if (platform.isDefaultMethod(method)) {
               return platform.invokeDefaultMethod(method, service, proxy, args);
             }
-            ServiceMethod<Object, Object> serviceMethod =
-                (ServiceMethod<Object, Object>) loadServiceMethod(method);
-            OkHttpCall<Object> okHttpCall = new OkHttpCall<>(serviceMethod, args);
-            return serviceMethod.adapt(okHttpCall);
+            return loadServiceMethod(method).invoke(args);
           }
         });
   }
@@ -160,14 +157,14 @@ private void eagerlyValidateMethods(Class<?> service) {
     }
   }
 
-  ServiceMethod<?, ?> loadServiceMethod(Method method) {
-    ServiceMethod<?, ?> result = serviceMethodCache.get(method);
+  ServiceMethod<?> loadServiceMethod(Method method) {
+    ServiceMethod<?> result = serviceMethodCache.get(method);
     if (result != null) return result;
 
     synchronized (serviceMethodCache) {
       result = serviceMethodCache.get(method);
       if (result == null) {
-        result = new ServiceMethod.Builder<>(this, method).build();
+        result = ServiceMethod.parseAnnotations(this, method);
         serviceMethodCache.put(method, result);
       }
     }
@@ -451,11 +448,7 @@ public Builder callFactory(okhttp3.Call.Factory factory) {
      */
     public Builder baseUrl(String baseUrl) {
       checkNotNull(baseUrl, "baseUrl == null");
-      HttpUrl httpUrl = HttpUrl.parse(baseUrl);
-      if (httpUrl == null) {
-        throw new IllegalArgumentException("Illegal URL: " + baseUrl);
-      }
-      return baseUrl(httpUrl);
+      return baseUrl(HttpUrl.get(baseUrl));
     }
 
     /**
diff --git a/retrofit/src/main/java/retrofit2/ServiceMethod.java b/retrofit/src/main/java/retrofit2/ServiceMethod.java
index 9e718b604..2ae44628e 100644
--- a/retrofit/src/main/java/retrofit2/ServiceMethod.java
+++ b/retrofit/src/main/java/retrofit2/ServiceMethod.java
@@ -15,778 +15,25 @@
  */
 package retrofit2;
 
-import java.io.IOException;
-import java.lang.annotation.Annotation;
 import java.lang.reflect.Method;
-import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
-import java.net.URI;
-import java.util.LinkedHashSet;
-import java.util.Map;
-import java.util.Set;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
 import javax.annotation.Nullable;
-import okhttp3.Headers;
-import okhttp3.HttpUrl;
-import okhttp3.MediaType;
-import okhttp3.MultipartBody;
-import okhttp3.RequestBody;
-import okhttp3.ResponseBody;
-import retrofit2.http.Body;
-import retrofit2.http.DELETE;
-import retrofit2.http.Field;
-import retrofit2.http.FieldMap;
-import retrofit2.http.FormUrlEncoded;
-import retrofit2.http.GET;
-import retrofit2.http.HEAD;
-import retrofit2.http.HTTP;
-import retrofit2.http.Header;
-import retrofit2.http.HeaderMap;
-import retrofit2.http.Multipart;
-import retrofit2.http.OPTIONS;
-import retrofit2.http.PATCH;
-import retrofit2.http.POST;
-import retrofit2.http.PUT;
-import retrofit2.http.Part;
-import retrofit2.http.PartMap;
-import retrofit2.http.Path;
-import retrofit2.http.Query;
-import retrofit2.http.QueryMap;
-import retrofit2.http.QueryName;
-import retrofit2.http.Url;
 
-/** Adapts an invocation of an interface method into an HTTP call. */
-final class ServiceMethod<R, T> {
-  // Upper and lower characters, digits, underscores, and hyphens, starting with a character.
-  static final String PARAM = "[a-zA-Z][a-zA-Z0-9_-]*";
-  static final Pattern PARAM_URL_REGEX = Pattern.compile("\\{(" + PARAM + ")\\}");
-  static final Pattern PARAM_NAME_REGEX = Pattern.compile(PARAM);
+import static retrofit2.Utils.methodError;
 
-  private final okhttp3.Call.Factory callFactory;
-  private final CallAdapter<R, T> callAdapter;
-
-  private final HttpUrl baseUrl;
-  private final Converter<ResponseBody, R> responseConverter;
-  private final String httpMethod;
-  private final String relativeUrl;
-  private final Headers headers;
-  private final MediaType contentType;
-  private final boolean hasBody;
-  private final boolean isFormEncoded;
-  private final boolean isMultipart;
-  private final ParameterHandler<?>[] parameterHandlers;
-
-  ServiceMethod(Builder<R, T> builder) {
-    this.callFactory = builder.retrofit.callFactory();
-    this.callAdapter = builder.callAdapter;
-    this.baseUrl = builder.retrofit.baseUrl();
-    this.responseConverter = builder.responseConverter;
-    this.httpMethod = builder.httpMethod;
-    this.relativeUrl = builder.relativeUrl;
-    this.headers = builder.headers;
-    this.contentType = builder.contentType;
-    this.hasBody = builder.hasBody;
-    this.isFormEncoded = builder.isFormEncoded;
-    this.isMultipart = builder.isMultipart;
-    this.parameterHandlers = builder.parameterHandlers;
-  }
-
-  /** Builds an HTTP request from method arguments. */
-  okhttp3.Call toCall(@Nullable Object... args) throws IOException {
-    RequestBuilder requestBuilder = new RequestBuilder(httpMethod, baseUrl, relativeUrl, headers,
-        contentType, hasBody, isFormEncoded, isMultipart);
-
-    @SuppressWarnings("unchecked") // It is an error to invoke a method with the wrong arg types.
-    ParameterHandler<Object>[] handlers = (ParameterHandler<Object>[]) parameterHandlers;
-
-    int argumentCount = args != null ? args.length : 0;
-    if (argumentCount != handlers.length) {
-      throw new IllegalArgumentException("Argument count (" + argumentCount
-          + ") doesn't match expected count (" + handlers.length + ")");
+abstract class ServiceMethod<T> {
+  static <T> ServiceMethod<T> parseAnnotations(Retrofit retrofit, Method method) {
+    Type returnType = method.getGenericReturnType();
+    if (Utils.hasUnresolvableType(returnType)) {
+      throw methodError(method,
+          "Method return type must not include a type variable or wildcard: %s", returnType);
     }
-
-    for (int p = 0; p < argumentCount; p++) {
-      handlers[p].apply(requestBuilder, args[p]);
+    if (returnType == void.class) {
+      throw methodError(method, "Service methods cannot return void.");
     }
 
-    return callFactory.newCall(requestBuilder.build());
-  }
-
-  T adapt(Call<R> call) {
-    return callAdapter.adapt(call);
+    return new HttpServiceMethod.Builder<Object, T>(retrofit, method).build();
   }
 
-  /** Builds a method return value from an HTTP response body. */
-  R toResponse(ResponseBody body) throws IOException {
-    return responseConverter.convert(body);
-  }
-
-  /**
-   * Inspects the annotations on an interface method to construct a reusable service method. This
-   * requires potentially-expensive reflection so it is best to build each service method only once
-   * and reuse it. Builders cannot be reused.
-   */
-  static final class Builder<T, R> {
-    final Retrofit retrofit;
-    final Method method;
-    final Annotation[] methodAnnotations;
-    final Annotation[][] parameterAnnotationsArray;
-    final Type[] parameterTypes;
-
-    Type responseType;
-    boolean gotField;
-    boolean gotPart;
-    boolean gotBody;
-    boolean gotPath;
-    boolean gotQuery;
-    boolean gotUrl;
-    String httpMethod;
-    boolean hasBody;
-    boolean isFormEncoded;
-    boolean isMultipart;
-    String relativeUrl;
-    Headers headers;
-    MediaType contentType;
-    Set<String> relativeUrlParamNames;
-    ParameterHandler<?>[] parameterHandlers;
-    Converter<ResponseBody, T> responseConverter;
-    CallAdapter<T, R> callAdapter;
-
-    Builder(Retrofit retrofit, Method method) {
-      this.retrofit = retrofit;
-      this.method = method;
-      this.methodAnnotations = method.getAnnotations();
-      this.parameterTypes = method.getGenericParameterTypes();
-      this.parameterAnnotationsArray = method.getParameterAnnotations();
-    }
-
-    public ServiceMethod build() {
-      callAdapter = createCallAdapter();
-      responseType = callAdapter.responseType();
-      if (responseType == Response.class || responseType == okhttp3.Response.class) {
-        throw methodError("'"
-            + Utils.getRawType(responseType).getName()
-            + "' is not a valid response body type. Did you mean ResponseBody?");
-      }
-      responseConverter = createResponseConverter();
-
-      for (Annotation annotation : methodAnnotations) {
-        parseMethodAnnotation(annotation);
-      }
-
-      if (httpMethod == null) {
-        throw methodError("HTTP method annotation is required (e.g., @GET, @POST, etc.).");
-      }
-
-      if (!hasBody) {
-        if (isMultipart) {
-          throw methodError(
-              "Multipart can only be specified on HTTP methods with request body (e.g., @POST).");
-        }
-        if (isFormEncoded) {
-          throw methodError("FormUrlEncoded can only be specified on HTTP methods with "
-              + "request body (e.g., @POST).");
-        }
-      }
-
-      int parameterCount = parameterAnnotationsArray.length;
-      parameterHandlers = new ParameterHandler<?>[parameterCount];
-      for (int p = 0; p < parameterCount; p++) {
-        Type parameterType = parameterTypes[p];
-        if (Utils.hasUnresolvableType(parameterType)) {
-          throw parameterError(p, "Parameter type must not include a type variable or wildcard: %s",
-              parameterType);
-        }
-
-        Annotation[] parameterAnnotations = parameterAnnotationsArray[p];
-        if (parameterAnnotations == null) {
-          throw parameterError(p, "No Retrofit annotation found.");
-        }
-
-        parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);
-      }
-
-      if (relativeUrl == null && !gotUrl) {
-        throw methodError("Missing either @%s URL or @Url parameter.", httpMethod);
-      }
-      if (!isFormEncoded && !isMultipart && !hasBody && gotBody) {
-        throw methodError("Non-body HTTP method cannot contain @Body.");
-      }
-      if (isFormEncoded && !gotField) {
-        throw methodError("Form-encoded method must contain at least one @Field.");
-      }
-      if (isMultipart && !gotPart) {
-        throw methodError("Multipart method must contain at least one @Part.");
-      }
-
-      return new ServiceMethod<>(this);
-    }
-
-    private CallAdapter<T, R> createCallAdapter() {
-      Type returnType = method.getGenericReturnType();
-      if (Utils.hasUnresolvableType(returnType)) {
-        throw methodError(
-            "Method return type must not include a type variable or wildcard: %s", returnType);
-      }
-      if (returnType == void.class) {
-        throw methodError("Service methods cannot return void.");
-      }
-      Annotation[] annotations = method.getAnnotations();
-      try {
-        //noinspection unchecked
-        return (CallAdapter<T, R>) retrofit.callAdapter(returnType, annotations);
-      } catch (RuntimeException e) { // Wide exception range because factories are user code.
-        throw methodError(e, "Unable to create call adapter for %s", returnType);
-      }
-    }
-
-    private void parseMethodAnnotation(Annotation annotation) {
-      if (annotation instanceof DELETE) {
-        parseHttpMethodAndPath("DELETE", ((DELETE) annotation).value(), false);
-      } else if (annotation instanceof GET) {
-        parseHttpMethodAndPath("GET", ((GET) annotation).value(), false);
-      } else if (annotation instanceof HEAD) {
-        parseHttpMethodAndPath("HEAD", ((HEAD) annotation).value(), false);
-        if (!Void.class.equals(responseType)) {
-          throw methodError("HEAD method must use Void as response type.");
-        }
-      } else if (annotation instanceof PATCH) {
-        parseHttpMethodAndPath("PATCH", ((PATCH) annotation).value(), true);
-      } else if (annotation instanceof POST) {
-        parseHttpMethodAndPath("POST", ((POST) annotation).value(), true);
-      } else if (annotation instanceof PUT) {
-        parseHttpMethodAndPath("PUT", ((PUT) annotation).value(), true);
-      } else if (annotation instanceof OPTIONS) {
-        parseHttpMethodAndPath("OPTIONS", ((OPTIONS) annotation).value(), false);
-      } else if (annotation instanceof HTTP) {
-        HTTP http = (HTTP) annotation;
-        parseHttpMethodAndPath(http.method(), http.path(), http.hasBody());
-      } else if (annotation instanceof retrofit2.http.Headers) {
-        String[] headersToParse = ((retrofit2.http.Headers) annotation).value();
-        if (headersToParse.length == 0) {
-          throw methodError("@Headers annotation is empty.");
-        }
-        headers = parseHeaders(headersToParse);
-      } else if (annotation instanceof Multipart) {
-        if (isFormEncoded) {
-          throw methodError("Only one encoding annotation is allowed.");
-        }
-        isMultipart = true;
-      } else if (annotation instanceof FormUrlEncoded) {
-        if (isMultipart) {
-          throw methodError("Only one encoding annotation is allowed.");
-        }
-        isFormEncoded = true;
-      }
-    }
-
-    private void parseHttpMethodAndPath(String httpMethod, String value, boolean hasBody) {
-      if (this.httpMethod != null) {
-        throw methodError("Only one HTTP method is allowed. Found: %s and %s.",
-            this.httpMethod, httpMethod);
-      }
-      this.httpMethod = httpMethod;
-      this.hasBody = hasBody;
-
-      if (value.isEmpty()) {
-        return;
-      }
-
-      // Get the relative URL path and existing query string, if present.
-      int question = value.indexOf('?');
-      if (question != -1 && question < value.length() - 1) {
-        // Ensure the query string does not have any named parameters.
-        String queryParams = value.substring(question + 1);
-        Matcher queryParamMatcher = PARAM_URL_REGEX.matcher(queryParams);
-        if (queryParamMatcher.find()) {
-          throw methodError("URL query string \"%s\" must not have replace block. "
-              + "For dynamic query parameters use @Query.", queryParams);
-        }
-      }
-
-      this.relativeUrl = value;
-      this.relativeUrlParamNames = parsePathParameters(value);
-    }
-
-    private Headers parseHeaders(String[] headers) {
-      Headers.Builder builder = new Headers.Builder();
-      for (String header : headers) {
-        int colon = header.indexOf(':');
-        if (colon == -1 || colon == 0 || colon == header.length() - 1) {
-          throw methodError(
-              "@Headers value must be in the form \"Name: Value\". Found: \"%s\"", header);
-        }
-        String headerName = header.substring(0, colon);
-        String headerValue = header.substring(colon + 1).trim();
-        if ("Content-Type".equalsIgnoreCase(headerName)) {
-          MediaType type = MediaType.parse(headerValue);
-          if (type == null) {
-            throw methodError("Malformed content type: %s", headerValue);
-          }
-          contentType = type;
-        } else {
-          builder.add(headerName, headerValue);
-        }
-      }
-      return builder.build();
-    }
-
-    private ParameterHandler<?> parseParameter(
-        int p, Type parameterType, Annotation[] annotations) {
-      ParameterHandler<?> result = null;
-      for (Annotation annotation : annotations) {
-        ParameterHandler<?> annotationAction = parseParameterAnnotation(
-            p, parameterType, annotations, annotation);
-
-        if (annotationAction == null) {
-          continue;
-        }
-
-        if (result != null) {
-          throw parameterError(p, "Multiple Retrofit annotations found, only one allowed.");
-        }
-
-        result = annotationAction;
-      }
-
-      if (result == null) {
-        throw parameterError(p, "No Retrofit annotation found.");
-      }
-
-      return result;
-    }
-
-    private ParameterHandler<?> parseParameterAnnotation(
-        int p, Type type, Annotation[] annotations, Annotation annotation) {
-      if (annotation instanceof Url) {
-        if (gotUrl) {
-          throw parameterError(p, "Multiple @Url method annotations found.");
-        }
-        if (gotPath) {
-          throw parameterError(p, "@Path parameters may not be used with @Url.");
-        }
-        if (gotQuery) {
-          throw parameterError(p, "A @Url parameter must not come after a @Query");
-        }
-        if (relativeUrl != null) {
-          throw parameterError(p, "@Url cannot be used with @%s URL", httpMethod);
-        }
-
-        gotUrl = true;
-
-        if (type == HttpUrl.class
-            || type == String.class
-            || type == URI.class
-            || (type instanceof Class && "android.net.Uri".equals(((Class<?>) type).getName()))) {
-          return new ParameterHandler.RelativeUrl();
-        } else {
-          throw parameterError(p,
-              "@Url must be okhttp3.HttpUrl, String, java.net.URI, or android.net.Uri type.");
-        }
-
-      } else if (annotation instanceof Path) {
-        if (gotQuery) {
-          throw parameterError(p, "A @Path parameter must not come after a @Query.");
-        }
-        if (gotUrl) {
-          throw parameterError(p, "@Path parameters may not be used with @Url.");
-        }
-        if (relativeUrl == null) {
-          throw parameterError(p, "@Path can only be used with relative url on @%s", httpMethod);
-        }
-        gotPath = true;
-
-        Path path = (Path) annotation;
-        String name = path.value();
-        validatePathName(p, name);
-
-        Converter<?, String> converter = retrofit.stringConverter(type, annotations);
-        return new ParameterHandler.Path<>(name, converter, path.encoded());
-
-      } else if (annotation instanceof Query) {
-        Query query = (Query) annotation;
-        String name = query.value();
-        boolean encoded = query.encoded();
-
-        Class<?> rawParameterType = Utils.getRawType(type);
-        gotQuery = true;
-        if (Iterable.class.isAssignableFrom(rawParameterType)) {
-          if (!(type instanceof ParameterizedType)) {
-            throw parameterError(p, rawParameterType.getSimpleName()
-                + " must include generic type (e.g., "
-                + rawParameterType.getSimpleName()
-                + "<String>)");
-          }
-          ParameterizedType parameterizedType = (ParameterizedType) type;
-          Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
-          Converter<?, String> converter =
-              retrofit.stringConverter(iterableType, annotations);
-          return new ParameterHandler.Query<>(name, converter, encoded).iterable();
-        } else if (rawParameterType.isArray()) {
-          Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
-          Converter<?, String> converter =
-              retrofit.stringConverter(arrayComponentType, annotations);
-          return new ParameterHandler.Query<>(name, converter, encoded).array();
-        } else {
-          Converter<?, String> converter =
-              retrofit.stringConverter(type, annotations);
-          return new ParameterHandler.Query<>(name, converter, encoded);
-        }
-
-      } else if (annotation instanceof QueryName) {
-        QueryName query = (QueryName) annotation;
-        boolean encoded = query.encoded();
-
-        Class<?> rawParameterType = Utils.getRawType(type);
-        gotQuery = true;
-        if (Iterable.class.isAssignableFrom(rawParameterType)) {
-          if (!(type instanceof ParameterizedType)) {
-            throw parameterError(p, rawParameterType.getSimpleName()
-                + " must include generic type (e.g., "
-                + rawParameterType.getSimpleName()
-                + "<String>)");
-          }
-          ParameterizedType parameterizedType = (ParameterizedType) type;
-          Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
-          Converter<?, String> converter =
-              retrofit.stringConverter(iterableType, annotations);
-          return new ParameterHandler.QueryName<>(converter, encoded).iterable();
-        } else if (rawParameterType.isArray()) {
-          Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
-          Converter<?, String> converter =
-              retrofit.stringConverter(arrayComponentType, annotations);
-          return new ParameterHandler.QueryName<>(converter, encoded).array();
-        } else {
-          Converter<?, String> converter =
-              retrofit.stringConverter(type, annotations);
-          return new ParameterHandler.QueryName<>(converter, encoded);
-        }
-
-      } else if (annotation instanceof QueryMap) {
-        Class<?> rawParameterType = Utils.getRawType(type);
-        if (!Map.class.isAssignableFrom(rawParameterType)) {
-          throw parameterError(p, "@QueryMap parameter type must be Map.");
-        }
-        Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
-        if (!(mapType instanceof ParameterizedType)) {
-          throw parameterError(p, "Map must include generic types (e.g., Map<String, String>)");
-        }
-        ParameterizedType parameterizedType = (ParameterizedType) mapType;
-        Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
-        if (String.class != keyType) {
-          throw parameterError(p, "@QueryMap keys must be of type String: " + keyType);
-        }
-        Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
-        Converter<?, String> valueConverter =
-            retrofit.stringConverter(valueType, annotations);
-
-        return new ParameterHandler.QueryMap<>(valueConverter, ((QueryMap) annotation).encoded());
-
-      } else if (annotation instanceof Header) {
-        Header header = (Header) annotation;
-        String name = header.value();
-
-        Class<?> rawParameterType = Utils.getRawType(type);
-        if (Iterable.class.isAssignableFrom(rawParameterType)) {
-          if (!(type instanceof ParameterizedType)) {
-            throw parameterError(p, rawParameterType.getSimpleName()
-                + " must include generic type (e.g., "
-                + rawParameterType.getSimpleName()
-                + "<String>)");
-          }
-          ParameterizedType parameterizedType = (ParameterizedType) type;
-          Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
-          Converter<?, String> converter =
-              retrofit.stringConverter(iterableType, annotations);
-          return new ParameterHandler.Header<>(name, converter).iterable();
-        } else if (rawParameterType.isArray()) {
-          Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
-          Converter<?, String> converter =
-              retrofit.stringConverter(arrayComponentType, annotations);
-          return new ParameterHandler.Header<>(name, converter).array();
-        } else {
-          Converter<?, String> converter =
-              retrofit.stringConverter(type, annotations);
-          return new ParameterHandler.Header<>(name, converter);
-        }
-
-      } else if (annotation instanceof HeaderMap) {
-        Class<?> rawParameterType = Utils.getRawType(type);
-        if (!Map.class.isAssignableFrom(rawParameterType)) {
-          throw parameterError(p, "@HeaderMap parameter type must be Map.");
-        }
-        Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
-        if (!(mapType instanceof ParameterizedType)) {
-          throw parameterError(p, "Map must include generic types (e.g., Map<String, String>)");
-        }
-        ParameterizedType parameterizedType = (ParameterizedType) mapType;
-        Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
-        if (String.class != keyType) {
-          throw parameterError(p, "@HeaderMap keys must be of type String: " + keyType);
-        }
-        Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
-        Converter<?, String> valueConverter =
-            retrofit.stringConverter(valueType, annotations);
-
-        return new ParameterHandler.HeaderMap<>(valueConverter);
-
-      } else if (annotation instanceof Field) {
-        if (!isFormEncoded) {
-          throw parameterError(p, "@Field parameters can only be used with form encoding.");
-        }
-        Field field = (Field) annotation;
-        String name = field.value();
-        boolean encoded = field.encoded();
-
-        gotField = true;
-
-        Class<?> rawParameterType = Utils.getRawType(type);
-        if (Iterable.class.isAssignableFrom(rawParameterType)) {
-          if (!(type instanceof ParameterizedType)) {
-            throw parameterError(p, rawParameterType.getSimpleName()
-                + " must include generic type (e.g., "
-                + rawParameterType.getSimpleName()
-                + "<String>)");
-          }
-          ParameterizedType parameterizedType = (ParameterizedType) type;
-          Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
-          Converter<?, String> converter =
-              retrofit.stringConverter(iterableType, annotations);
-          return new ParameterHandler.Field<>(name, converter, encoded).iterable();
-        } else if (rawParameterType.isArray()) {
-          Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
-          Converter<?, String> converter =
-              retrofit.stringConverter(arrayComponentType, annotations);
-          return new ParameterHandler.Field<>(name, converter, encoded).array();
-        } else {
-          Converter<?, String> converter =
-              retrofit.stringConverter(type, annotations);
-          return new ParameterHandler.Field<>(name, converter, encoded);
-        }
-
-      } else if (annotation instanceof FieldMap) {
-        if (!isFormEncoded) {
-          throw parameterError(p, "@FieldMap parameters can only be used with form encoding.");
-        }
-        Class<?> rawParameterType = Utils.getRawType(type);
-        if (!Map.class.isAssignableFrom(rawParameterType)) {
-          throw parameterError(p, "@FieldMap parameter type must be Map.");
-        }
-        Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
-        if (!(mapType instanceof ParameterizedType)) {
-          throw parameterError(p,
-              "Map must include generic types (e.g., Map<String, String>)");
-        }
-        ParameterizedType parameterizedType = (ParameterizedType) mapType;
-        Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
-        if (String.class != keyType) {
-          throw parameterError(p, "@FieldMap keys must be of type String: " + keyType);
-        }
-        Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
-        Converter<?, String> valueConverter =
-            retrofit.stringConverter(valueType, annotations);
-
-        gotField = true;
-        return new ParameterHandler.FieldMap<>(valueConverter, ((FieldMap) annotation).encoded());
-
-      } else if (annotation instanceof Part) {
-        if (!isMultipart) {
-          throw parameterError(p, "@Part parameters can only be used with multipart encoding.");
-        }
-        Part part = (Part) annotation;
-        gotPart = true;
-
-        String partName = part.value();
-        Class<?> rawParameterType = Utils.getRawType(type);
-        if (partName.isEmpty()) {
-          if (Iterable.class.isAssignableFrom(rawParameterType)) {
-            if (!(type instanceof ParameterizedType)) {
-              throw parameterError(p, rawParameterType.getSimpleName()
-                  + " must include generic type (e.g., "
-                  + rawParameterType.getSimpleName()
-                  + "<String>)");
-            }
-            ParameterizedType parameterizedType = (ParameterizedType) type;
-            Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
-            if (!MultipartBody.Part.class.isAssignableFrom(Utils.getRawType(iterableType))) {
-              throw parameterError(p,
-                  "@Part annotation must supply a name or use MultipartBody.Part parameter type.");
-            }
-            return ParameterHandler.RawPart.INSTANCE.iterable();
-          } else if (rawParameterType.isArray()) {
-            Class<?> arrayComponentType = rawParameterType.getComponentType();
-            if (!MultipartBody.Part.class.isAssignableFrom(arrayComponentType)) {
-              throw parameterError(p,
-                  "@Part annotation must supply a name or use MultipartBody.Part parameter type.");
-            }
-            return ParameterHandler.RawPart.INSTANCE.array();
-          } else if (MultipartBody.Part.class.isAssignableFrom(rawParameterType)) {
-            return ParameterHandler.RawPart.INSTANCE;
-          } else {
-            throw parameterError(p,
-                "@Part annotation must supply a name or use MultipartBody.Part parameter type.");
-          }
-        } else {
-          Headers headers =
-              Headers.of("Content-Disposition", "form-data; name=\"" + partName + "\"",
-                  "Content-Transfer-Encoding", part.encoding());
-
-          if (Iterable.class.isAssignableFrom(rawParameterType)) {
-            if (!(type instanceof ParameterizedType)) {
-              throw parameterError(p, rawParameterType.getSimpleName()
-                  + " must include generic type (e.g., "
-                  + rawParameterType.getSimpleName()
-                  + "<String>)");
-            }
-            ParameterizedType parameterizedType = (ParameterizedType) type;
-            Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
-            if (MultipartBody.Part.class.isAssignableFrom(Utils.getRawType(iterableType))) {
-              throw parameterError(p, "@Part parameters using the MultipartBody.Part must not "
-                  + "include a part name in the annotation.");
-            }
-            Converter<?, RequestBody> converter =
-                retrofit.requestBodyConverter(iterableType, annotations, methodAnnotations);
-            return new ParameterHandler.Part<>(headers, converter).iterable();
-          } else if (rawParameterType.isArray()) {
-            Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
-            if (MultipartBody.Part.class.isAssignableFrom(arrayComponentType)) {
-              throw parameterError(p, "@Part parameters using the MultipartBody.Part must not "
-                  + "include a part name in the annotation.");
-            }
-            Converter<?, RequestBody> converter =
-                retrofit.requestBodyConverter(arrayComponentType, annotations, methodAnnotations);
-            return new ParameterHandler.Part<>(headers, converter).array();
-          } else if (MultipartBody.Part.class.isAssignableFrom(rawParameterType)) {
-            throw parameterError(p, "@Part parameters using the MultipartBody.Part must not "
-                + "include a part name in the annotation.");
-          } else {
-            Converter<?, RequestBody> converter =
-                retrofit.requestBodyConverter(type, annotations, methodAnnotations);
-            return new ParameterHandler.Part<>(headers, converter);
-          }
-        }
-
-      } else if (annotation instanceof PartMap) {
-        if (!isMultipart) {
-          throw parameterError(p, "@PartMap parameters can only be used with multipart encoding.");
-        }
-        gotPart = true;
-        Class<?> rawParameterType = Utils.getRawType(type);
-        if (!Map.class.isAssignableFrom(rawParameterType)) {
-          throw parameterError(p, "@PartMap parameter type must be Map.");
-        }
-        Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
-        if (!(mapType instanceof ParameterizedType)) {
-          throw parameterError(p, "Map must include generic types (e.g., Map<String, String>)");
-        }
-        ParameterizedType parameterizedType = (ParameterizedType) mapType;
-
-        Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
-        if (String.class != keyType) {
-          throw parameterError(p, "@PartMap keys must be of type String: " + keyType);
-        }
-
-        Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
-        if (MultipartBody.Part.class.isAssignableFrom(Utils.getRawType(valueType))) {
-          throw parameterError(p, "@PartMap values cannot be MultipartBody.Part. "
-              + "Use @Part List<Part> or a different value type instead.");
-        }
-
-        Converter<?, RequestBody> valueConverter =
-            retrofit.requestBodyConverter(valueType, annotations, methodAnnotations);
-
-        PartMap partMap = (PartMap) annotation;
-        return new ParameterHandler.PartMap<>(valueConverter, partMap.encoding());
-
-      } else if (annotation instanceof Body) {
-        if (isFormEncoded || isMultipart) {
-          throw parameterError(p,
-              "@Body parameters cannot be used with form or multi-part encoding.");
-        }
-        if (gotBody) {
-          throw parameterError(p, "Multiple @Body method annotations found.");
-        }
-
-        Converter<?, RequestBody> converter;
-        try {
-          converter = retrofit.requestBodyConverter(type, annotations, methodAnnotations);
-        } catch (RuntimeException e) {
-          // Wide exception range because factories are user code.
-          throw parameterError(e, p, "Unable to create @Body converter for %s", type);
-        }
-        gotBody = true;
-        return new ParameterHandler.Body<>(converter);
-      }
-
-      return null; // Not a Retrofit annotation.
-    }
-
-    private void validatePathName(int p, String name) {
-      if (!PARAM_NAME_REGEX.matcher(name).matches()) {
-        throw parameterError(p, "@Path parameter name must match %s. Found: %s",
-            PARAM_URL_REGEX.pattern(), name);
-      }
-      // Verify URL replacement name is actually present in the URL path.
-      if (!relativeUrlParamNames.contains(name)) {
-        throw parameterError(p, "URL \"%s\" does not contain \"{%s}\".", relativeUrl, name);
-      }
-    }
-
-    private Converter<ResponseBody, T> createResponseConverter() {
-      Annotation[] annotations = method.getAnnotations();
-      try {
-        return retrofit.responseBodyConverter(responseType, annotations);
-      } catch (RuntimeException e) { // Wide exception range because factories are user code.
-        throw methodError(e, "Unable to create converter for %s", responseType);
-      }
-    }
-
-    private RuntimeException methodError(String message, Object... args) {
-      return methodError(null, message, args);
-    }
-
-    private RuntimeException methodError(Throwable cause, String message, Object... args) {
-      message = String.format(message, args);
-      return new IllegalArgumentException(message
-          + "\n    for method "
-          + method.getDeclaringClass().getSimpleName()
-          + "."
-          + method.getName(), cause);
-    }
-
-    private RuntimeException parameterError(
-        Throwable cause, int p, String message, Object... args) {
-      return methodError(cause, message + " (parameter #" + (p + 1) + ")", args);
-    }
-
-    private RuntimeException parameterError(int p, String message, Object... args) {
-      return methodError(message + " (parameter #" + (p + 1) + ")", args);
-    }
-  }
-
-  /**
-   * Gets the set of unique path parameters used in the given URI. If a parameter is used twice
-   * in the URI, it will only show up once in the set.
-   */
-  static Set<String> parsePathParameters(String path) {
-    Matcher m = PARAM_URL_REGEX.matcher(path);
-    Set<String> patterns = new LinkedHashSet<>();
-    while (m.find()) {
-      patterns.add(m.group(1));
-    }
-    return patterns;
-  }
-
-  static Class<?> boxIfPrimitive(Class<?> type) {
-    if (boolean.class == type) return Boolean.class;
-    if (byte.class == type) return Byte.class;
-    if (char.class == type) return Character.class;
-    if (double.class == type) return Double.class;
-    if (float.class == type) return Float.class;
-    if (int.class == type) return Integer.class;
-    if (long.class == type) return Long.class;
-    if (short.class == type) return Short.class;
-    return type;
-  }
+  abstract T invoke(@Nullable Object[] args);
 }
diff --git a/retrofit/src/main/java/retrofit2/Utils.java b/retrofit/src/main/java/retrofit2/Utils.java
index 12544e357..85258222c 100644
--- a/retrofit/src/main/java/retrofit2/Utils.java
+++ b/retrofit/src/main/java/retrofit2/Utils.java
@@ -20,6 +20,7 @@
 import java.lang.reflect.Array;
 import java.lang.reflect.GenericArrayType;
 import java.lang.reflect.GenericDeclaration;
+import java.lang.reflect.Method;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import java.lang.reflect.TypeVariable;
@@ -37,6 +38,29 @@ private Utils() {
     // No instances.
   }
 
+  static RuntimeException methodError(Method method, String message, Object... args) {
+    return methodError(method, null, message, args);
+  }
+
+  static RuntimeException methodError(Method method, @Nullable Throwable cause, String message,
+      Object... args) {
+    message = String.format(message, args);
+    return new IllegalArgumentException(message
+        + "\n    for method "
+        + method.getDeclaringClass().getSimpleName()
+        + "."
+        + method.getName(), cause);
+  }
+
+  static RuntimeException parameterError(Method method,
+      Throwable cause, int p, String message, Object... args) {
+    return methodError(method, cause, message + " (parameter #" + (p + 1) + ")", args);
+  }
+
+  static RuntimeException parameterError(Method method, int p, String message, Object... args) {
+    return methodError(method, message + " (parameter #" + (p + 1) + ")", args);
+  }
+
   static Class<?> getRawType(Type type) {
     checkNotNull(type, "type == null");
 
diff --git a/retrofit/src/main/resources/META-INF/proguard/retrofit2.pro b/retrofit/src/main/resources/META-INF/proguard/retrofit2.pro
new file mode 100644
index 000000000..7a2556032
--- /dev/null
+++ b/retrofit/src/main/resources/META-INF/proguard/retrofit2.pro
@@ -0,0 +1,16 @@
+# Retain generic type information for use by reflection by converters and adapters.
+-keepattributes Signature
+
+# Retain service method parameters when optimizing.
+-keepclassmembers,allowshrinking,allowobfuscation interface * {
+    @retrofit2.http.* <methods>;
+}
+
+# Ignore annotation used for build tooling.
+-dontwarn org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement
+
+# Ignore JSR 305 annotations for embedding nullability information.
+-dontwarn javax.annotation.**
+
+# Guarded by a NoClassDefFoundError try/catch and only used when on the classpath.
+-dontwarn kotlin.Unit
diff --git a/retrofit/src/test/java/retrofit2/KotlinUnitTest.java b/retrofit/src/test/java/retrofit2/KotlinUnitTest.java
new file mode 100644
index 000000000..e73f223c7
--- /dev/null
+++ b/retrofit/src/test/java/retrofit2/KotlinUnitTest.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import java.io.IOException;
+import kotlin.Unit;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Ignore;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.http.GET;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class KotlinUnitTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  interface Service {
+    @GET("/")
+    Call<Unit> empty();
+  }
+
+  @Test public void unitOnClasspath() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    Response<Unit> response = example.empty().execute();
+    assertThat(response.isSuccessful()).isTrue();
+    assertThat(response.body()).isSameAs(Unit.INSTANCE);
+  }
+
+  @Ignore("This is implicitly tested by integration tests of the adapters and converters")
+  @Test public void unitMissingFromClasspath() {
+  }
+}
diff --git a/retrofit/src/test/java/retrofit2/RequestBuilderAndroidTest.java b/retrofit/src/test/java/retrofit2/RequestFactoryAndroidTest.java
similarity index 95%
rename from retrofit/src/test/java/retrofit2/RequestBuilderAndroidTest.java
rename to retrofit/src/test/java/retrofit2/RequestFactoryAndroidTest.java
index 63fa57b6c..37c470529 100644
--- a/retrofit/src/test/java/retrofit2/RequestBuilderAndroidTest.java
+++ b/retrofit/src/test/java/retrofit2/RequestFactoryAndroidTest.java
@@ -25,11 +25,11 @@
 import retrofit2.http.Url;
 
 import static org.assertj.core.api.Assertions.assertThat;
-import static retrofit2.RequestBuilderTest.buildRequest;
+import static retrofit2.RequestFactoryTest.buildRequest;
 
 @RunWith(RobolectricTestRunner.class)
 @SuppressWarnings({"UnusedParameters", "unused"}) // Parameters inspected reflectively.
-public final class RequestBuilderAndroidTest {
+public final class RequestFactoryAndroidTest {
   @Test public void getWithAndroidUriUrl() {
     class Example {
       @GET
diff --git a/retrofit/src/test/java/retrofit2/ServiceMethodTest.java b/retrofit/src/test/java/retrofit2/RequestFactoryBuilderTest.java
similarity index 90%
rename from retrofit/src/test/java/retrofit2/ServiceMethodTest.java
rename to retrofit/src/test/java/retrofit2/RequestFactoryBuilderTest.java
index c9c48f31e..f2bd3791d 100644
--- a/retrofit/src/test/java/retrofit2/ServiceMethodTest.java
+++ b/retrofit/src/test/java/retrofit2/RequestFactoryBuilderTest.java
@@ -20,7 +20,8 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-public final class ServiceMethodTest {
+// TODO this test is far too white box, migrate to black box.
+public final class RequestFactoryBuilderTest {
   @Test public void pathParameterParsing() throws Exception {
     expectParams("/");
     expectParams("/foo");
@@ -41,7 +42,7 @@
   }
 
   private static void expectParams(String path, String... expected) {
-    Set<String> calculated = ServiceMethod.parsePathParameters(path);
+    Set<String> calculated = RequestFactory.Builder.parsePathParameters(path);
     assertThat(calculated).containsExactly(expected);
   }
 }
diff --git a/retrofit/src/test/java/retrofit2/RequestBuilderTest.java b/retrofit/src/test/java/retrofit2/RequestFactoryTest.java
similarity index 96%
rename from retrofit/src/test/java/retrofit2/RequestBuilderTest.java
rename to retrofit/src/test/java/retrofit2/RequestFactoryTest.java
index 6b3634237..97d178677 100644
--- a/retrofit/src/test/java/retrofit2/RequestBuilderTest.java
+++ b/retrofit/src/test/java/retrofit2/RequestFactoryTest.java
@@ -25,7 +25,6 @@
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
-import java.util.concurrent.atomic.AtomicReference;
 import okhttp3.HttpUrl;
 import okhttp3.MediaType;
 import okhttp3.MultipartBody;
@@ -65,8 +64,8 @@
 import static org.junit.Assert.fail;
 
 @SuppressWarnings({"UnusedParameters", "unused"}) // Parameters inspected reflectively.
-public final class RequestBuilderTest {
-  private static final MediaType TEXT_PLAIN = MediaType.parse("text/plain");
+public final class RequestFactoryTest {
+  private static final MediaType TEXT_PLAIN = MediaType.get("text/plain");
 
   @Test public void customMethodNoBody() {
     class Example {
@@ -90,7 +89,7 @@
       }
     }
 
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    RequestBody body = RequestBody.create(TEXT_PLAIN, "hi");
     Request request = buildRequest(Example.class, body);
     assertThat(request.method()).isEqualTo("CUSTOM2");
     assertThat(request.url().toString()).isEqualTo("http://example.com/foo");
@@ -743,7 +742,7 @@
         return null;
       }
     }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    RequestBody body = RequestBody.create(TEXT_PLAIN, "hi");
     Request request = buildRequest(Example.class, body);
     assertThat(request.method()).isEqualTo("POST");
     assertThat(request.headers().size()).isZero();
@@ -758,7 +757,7 @@
         return null;
       }
     }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    RequestBody body = RequestBody.create(TEXT_PLAIN, "hi");
     Request request = buildRequest(Example.class, body);
     assertThat(request.method()).isEqualTo("PUT");
     assertThat(request.headers().size()).isZero();
@@ -773,7 +772,7 @@
         return null;
       }
     }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    RequestBody body = RequestBody.create(TEXT_PLAIN, "hi");
     Request request = buildRequest(Example.class, body);
     assertThat(request.method()).isEqualTo("PATCH");
     assertThat(request.headers().size()).isZero();
@@ -1006,6 +1005,40 @@
     }
   }
 
+  @Test public void getWithQueryNameThenPathThrows() {
+    class Example {
+      @GET("/foo/bar/{ping}/") //
+      Call<ResponseBody> method(@QueryName String kit, @Path("ping") String ping) {
+        throw new AssertionError();
+      }
+    }
+
+    try {
+      buildRequest(Example.class, "kat", "pong");
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("A @Path parameter must not come after a @QueryName. (parameter #2)\n"
+          + "    for method Example.method");
+    }
+  }
+
+  @Test public void getWithQueryMapThenPathThrows() {
+    class Example {
+      @GET("/foo/bar/{ping}/") //
+      Call<ResponseBody> method(@QueryMap Map<String, String> queries, @Path("ping") String ping) {
+        throw new AssertionError();
+      }
+    }
+
+    try {
+      buildRequest(Example.class, Collections.singletonMap("kit", "kat"), "pong");
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("A @Path parameter must not come after a @QueryMap. (parameter #2)\n"
+          + "    for method Example.method");
+    }
+  }
+
   @Test public void getWithPathAndQueryQuestionMarkParam() {
     class Example {
       @GET("/foo/bar/{ping}/") //
@@ -1323,10 +1356,10 @@
       }
     }
 
-    Request request = buildRequest(Example.class, HttpUrl.parse("http://example.com/foo/bar/"));
+    Request request = buildRequest(Example.class, HttpUrl.get("http://example.com/foo/bar/"));
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.url()).isEqualTo(HttpUrl.parse("http://example.com/foo/bar/"));
+    assertThat(request.url()).isEqualTo(HttpUrl.get("http://example.com/foo/bar/"));
     assertThat(request.body()).isNull();
   }
 
@@ -1445,7 +1478,41 @@
       buildRequest(Example.class, "hey", "foo/bar/");
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("A @Url parameter must not come after a @Query (parameter #2)\n"
+      assertThat(e).hasMessage("A @Url parameter must not come after a @Query. (parameter #2)\n"
+          + "    for method Example.method");
+    }
+  }
+
+  @Test public void getWithQueryNameThenUrlThrows() {
+    class Example {
+      @GET
+      Call<ResponseBody> method(@QueryName String name, @Url String url) {
+        throw new AssertionError();
+      }
+    }
+
+    try {
+      buildRequest(Example.class, Collections.singletonMap("kit", "kat"), "foo/bar/");
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("A @Url parameter must not come after a @QueryName. (parameter #2)\n"
+          + "    for method Example.method");
+    }
+  }
+
+  @Test public void getWithQueryMapThenUrlThrows() {
+    class Example {
+      @GET
+      Call<ResponseBody> method(@QueryMap Map<String, String> queries, @Url String url) {
+        throw new AssertionError();
+      }
+    }
+
+    try {
+      buildRequest(Example.class, Collections.singletonMap("kit", "kat"), "foo/bar/");
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("A @Url parameter must not come after a @QueryMap. (parameter #2)\n"
           + "    for method Example.method");
     }
   }
@@ -1471,7 +1538,7 @@
         return null;
       }
     }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    RequestBody body = RequestBody.create(TEXT_PLAIN, "hi");
     Request request = buildRequest(Example.class, "http://example.com/foo/bar", body);
     assertThat(request.method()).isEqualTo("POST");
     assertThat(request.headers().size()).isZero();
@@ -1562,7 +1629,7 @@
     }
 
     Request request = buildRequest(Example.class, "pong", RequestBody.create(
-        MediaType.parse("text/plain"), "kat"));
+        TEXT_PLAIN, "kat"));
     assertThat(request.method()).isEqualTo("POST");
     assertThat(request.headers().size()).isZero();
     assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
@@ -1887,7 +1954,7 @@
     }
 
     Request request = buildRequest(Example.class, "pong", RequestBody.create(
-        MediaType.parse("text/plain"), "kat"));
+        TEXT_PLAIN, "kat"));
     assertThat(request.method()).isEqualTo("POST");
     assertThat(request.headers().size()).isZero();
     assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
@@ -2485,7 +2552,7 @@
         return null;
       }
     }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    RequestBody body = RequestBody.create(TEXT_PLAIN, "hi");
     Request request = buildRequest(Example.class, body);
     assertThat(request.body().contentType().toString()).isEqualTo("text/not-plain");
   }
@@ -2498,13 +2565,14 @@
         return null;
       }
     }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    RequestBody body = RequestBody.create(TEXT_PLAIN, "hi");
     try {
       buildRequest(Example.class, body);
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage("Malformed content type: hello, world!\n"
           + "    for method Example.method");
+      assertThat(e.getCause()).isInstanceOf(IllegalArgumentException.class); // OkHttp's cause.
     }
   }
 
@@ -2527,7 +2595,7 @@
         return null;
       }
     }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "Plain");
+    RequestBody body = RequestBody.create(TEXT_PLAIN, "Plain");
     Request request = buildRequest(Example.class, "text/not-plain", body);
     assertThat(request.body().contentType().toString()).isEqualTo("text/not-plain");
   }
@@ -2539,12 +2607,13 @@
         return null;
       }
     }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    RequestBody body = RequestBody.create(TEXT_PLAIN, "hi");
     try {
       buildRequest(Example.class, "hello, world!", body);
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage("Malformed content type: hello, world!");
+      assertThat(e.getCause()).isInstanceOf(IllegalArgumentException.class); // OkHttp's cause.
     }
   }
 
@@ -2689,10 +2758,8 @@ private static void assertBody(RequestBody body, String expected) {
   }
 
   static <T> Request buildRequest(Class<T> cls, Retrofit.Builder builder, Object... args) {
-    final AtomicReference<Request> requestRef = new AtomicReference<>();
     okhttp3.Call.Factory callFactory = new okhttp3.Call.Factory() {
       @Override public okhttp3.Call newCall(Request request) {
-        requestRef.set(request);
         throw new UnsupportedOperationException("Not implemented");
       }
     };
@@ -2700,16 +2767,8 @@ private static void assertBody(RequestBody body, String expected) {
     Retrofit retrofit = builder.callFactory(callFactory).build();
 
     Method method = TestingUtils.onlyMethod(cls);
-    //noinspection unchecked
-    ServiceMethod<T, Call<T>> serviceMethod =
-        (ServiceMethod<T, Call<T>>) retrofit.loadServiceMethod(method);
-    Call<T> okHttpCall = new OkHttpCall<>(serviceMethod, args);
-    Call<T> call = serviceMethod.adapt(okHttpCall);
-    try {
-      call.execute();
-      throw new AssertionError();
-    } catch (UnsupportedOperationException ignored) {
-      return requestRef.get();
+    try {
+      return RequestFactory.parseAnnotations(retrofit, method).create(args);
     } catch (RuntimeException e) {
       throw e;
     } catch (Exception e) {
diff --git a/retrofit/src/test/java/retrofit2/RetrofitTest.java b/retrofit/src/test/java/retrofit2/RetrofitTest.java
index 4a1b2b773..05e4cf928 100644
--- a/retrofit/src/test/java/retrofit2/RetrofitTest.java
+++ b/retrofit/src/test/java/retrofit2/RetrofitTest.java
@@ -566,7 +566,7 @@
 
     server.enqueue(new MockResponse().setBody("Hi"));
 
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "Hey");
+    RequestBody body = RequestBody.create(MediaType.get("text/plain"), "Hey");
     Response<ResponseBody> response = example.postRequestBody(body).execute();
     assertThat(response.body().string()).isEqualTo("Hi");
 
@@ -693,8 +693,7 @@
     try {
       new Retrofit.Builder().baseUrl("ftp://foo/bar");
       fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Illegal URL: ftp://foo/bar");
+    } catch (IllegalArgumentException ignored) {
     }
   }
 
@@ -705,7 +704,7 @@
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage("baseUrl must end in /: http://example.com/api");
     }
-    HttpUrl parsed = HttpUrl.parse("http://example.com/api");
+    HttpUrl parsed = HttpUrl.get("http://example.com/api");
     try {
       new Retrofit.Builder().baseUrl(parsed);
       fail();
@@ -719,11 +718,11 @@
         .baseUrl("http://example.com/")
         .build();
     HttpUrl baseUrl = retrofit.baseUrl();
-    assertThat(baseUrl).isEqualTo(HttpUrl.parse("http://example.com/"));
+    assertThat(baseUrl).isEqualTo(HttpUrl.get("http://example.com/"));
   }
 
   @Test public void baseHttpUrlPropagated() {
-    HttpUrl url = HttpUrl.parse("http://example.com/");
+    HttpUrl url = HttpUrl.get("http://example.com/");
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(url)
         .build();
diff --git a/retrofit/src/test/java/retrofit2/helpers/ToStringConverterFactory.java b/retrofit/src/test/java/retrofit2/helpers/ToStringConverterFactory.java
index 0a70e3ddb..bcafe282c 100644
--- a/retrofit/src/test/java/retrofit2/helpers/ToStringConverterFactory.java
+++ b/retrofit/src/test/java/retrofit2/helpers/ToStringConverterFactory.java
@@ -25,7 +25,7 @@
 import retrofit2.Retrofit;
 
 public class ToStringConverterFactory extends Converter.Factory {
-  static final MediaType MEDIA_TYPE = MediaType.parse("text/plain");
+  static final MediaType MEDIA_TYPE = MediaType.get("text/plain");
 
   @Override
   public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
diff --git a/samples/src/main/java/com/example/retrofit/Crawler.java b/samples/src/main/java/com/example/retrofit/Crawler.java
index 1e213e9a1..2fd7e350f 100644
--- a/samples/src/main/java/com/example/retrofit/Crawler.java
+++ b/samples/src/main/java/com/example/retrofit/Crawler.java
@@ -100,7 +100,7 @@ public static void main(String... args) throws Exception {
         .build();
 
     Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(HttpUrl.parse("https://example.com/"))
+        .baseUrl(HttpUrl.get("https://example.com/"))
         .addConverterFactory(PageAdapter.FACTORY)
         .client(okHttpClient)
         .build();
@@ -108,7 +108,7 @@ public static void main(String... args) throws Exception {
     PageService pageService = retrofit.create(PageService.class);
 
     Crawler crawler = new Crawler(pageService);
-    crawler.crawlPage(HttpUrl.parse(args[0]));
+    crawler.crawlPage(HttpUrl.get(args[0]));
   }
 
   interface PageService {
diff --git a/website/index.html b/website/index.html
index 1b33a54b5..c34bd1687 100644
--- a/website/index.html
+++ b/website/index.html
@@ -173,19 +173,9 @@ <h4>Gradle</h4>
 </pre>
               <p>Retrofit requires at minimum Java 7 or Android 2.3.</p>
 
-              <h4>ProGuard</h4>
-              <p>If you are using ProGuard in your project add the following lines to your configuration:</p>
-              <pre class="prettyprint">
-# Retain generic type information for use by reflection by converters and adapters.
--keepattributes Signature
-# Retain service method parameters.
--keepclassmembernames,allowobfuscation interface * {
-    @retrofit2.http.* <methods>;
-}
-# Ignore annotation used for build tooling.
--dontwarn org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement
-</pre>
-            <p>Retrofit uses <a href="https://github.com/square/okio">Okio</a> under the hood, so you may want to look at its <a href="https://github.com/square/okio#proguard">ProGuard rules</a> as well.</p>
+              <h4>R8 / ProGuard</h4>
+              <p>If you are using R8 or ProGuard add the options from <a href="https://github.com/square/retrofit/blob/master/retrofit/src/main/resources/META-INF/proguard/retrofit2.pro">this file</a>.</p>
+              <p>You might also need rules for OkHttp and Okio which are dependencies of this library.</p>
             </section>
 
             <section id="contributing">
