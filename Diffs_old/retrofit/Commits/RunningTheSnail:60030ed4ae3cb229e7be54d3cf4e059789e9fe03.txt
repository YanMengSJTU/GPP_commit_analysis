diff --git a/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java b/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java
index 0c44243c6..d4f211afd 100644
--- a/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java
+++ b/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java
@@ -19,91 +19,107 @@
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
 import java.util.concurrent.Executor;
+
 import okhttp3.Request;
 
 final class ExecutorCallAdapterFactory extends CallAdapter.Factory {
-  final Executor callbackExecutor;
-
-  ExecutorCallAdapterFactory(Executor callbackExecutor) {
-    this.callbackExecutor = callbackExecutor;
-  }
-
-  @Override
-  public CallAdapter<Call<?>> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
-    if (getRawType(returnType) != Call.class) {
-      return null;
-    }
-    final Type responseType = Utils.getCallResponseType(returnType);
-    return new CallAdapter<Call<?>>() {
-      @Override public Type responseType() {
-        return responseType;
-      }
-
-      @Override public <R> Call<R> adapt(Call<R> call) {
-        return new ExecutorCallbackCall<>(callbackExecutor, call);
-      }
-    };
-  }
-
-  static final class ExecutorCallbackCall<T> implements Call<T> {
     final Executor callbackExecutor;
-    final Call<T> delegate;
 
-    ExecutorCallbackCall(Executor callbackExecutor, Call<T> delegate) {
-      this.callbackExecutor = callbackExecutor;
-      this.delegate = delegate;
+    ExecutorCallAdapterFactory(Executor callbackExecutor) {
+        this.callbackExecutor = callbackExecutor;
     }
 
-    @Override public void enqueue(final Callback<T> callback) {
-      if (callback == null) throw new NullPointerException("callback == null");
-
-      delegate.enqueue(new Callback<T>() {
-        @Override public void onResponse(Call<T> call, final Response<T> response) {
-          callbackExecutor.execute(new Runnable() {
-            @Override public void run() {
-              if (delegate.isCanceled()) {
-                // Emulate OkHttp's behavior of throwing/delivering an IOException on cancellation.
-                callback.onFailure(ExecutorCallbackCall.this, new IOException("Canceled"));
-              } else {
-                callback.onResponse(ExecutorCallbackCall.this, response);
-              }
-            }
-          });
+    @Override
+    public CallAdapter<Call<?>> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+        if (getRawType(returnType) != Call.class) {
+            return null;
         }
+        final Type responseType = Utils.getCallResponseType(returnType);
+        return new CallAdapter<Call<?>>() {
+            @Override
+            public Type responseType() {
+                return responseType;
+            }
 
-        @Override public void onFailure(Call<T> call, final Throwable t) {
-          callbackExecutor.execute(new Runnable() {
-            @Override public void run() {
-              callback.onFailure(ExecutorCallbackCall.this, t);
+            @Override
+            public <R> Call<R> adapt(Call<R> call) {
+                return new ExecutorCallbackCall<>(callbackExecutor, call);
             }
-          });
-        }
-      });
+        };
     }
 
-    @Override public boolean isExecuted() {
-      return delegate.isExecuted();
-    }
+    //静态代理 和装饰者模式类似
+    //作用 线程切换
+    static final class ExecutorCallbackCall<T> implements Call<T> {
+        final Executor callbackExecutor;
+        final Call<T> delegate;
 
-    @Override public Response<T> execute() throws IOException {
-      return delegate.execute();
-    }
+        ExecutorCallbackCall(Executor callbackExecutor, Call<T> delegate) {
+            this.callbackExecutor = callbackExecutor;
+            this.delegate = delegate;
+        }
 
-    @Override public void cancel() {
-      delegate.cancel();
-    }
+        @Override
+        public void enqueue(final Callback<T> callback) {
+            if (callback == null) throw new NullPointerException("callback == null");
+
+            delegate.enqueue(new Callback<T>() {
+                @Override
+                public void onResponse(Call<T> call, final Response<T> response) {
+                    callbackExecutor.execute(new Runnable() {
+                        @Override
+                        public void run() {
+                            if (delegate.isCanceled()) {
+                                // Emulate OkHttp's behavior of throwing/delivering an IOException on cancellation.
+                                callback.onFailure(ExecutorCallbackCall.this, new IOException("Canceled"));
+                            } else {
+                                callback.onResponse(ExecutorCallbackCall.this, response);
+                            }
+                        }
+                    });
+                }
+
+                @Override
+                public void onFailure(Call<T> call, final Throwable t) {
+                    callbackExecutor.execute(new Runnable() {
+                        @Override
+                        public void run() {
+                            callback.onFailure(ExecutorCallbackCall.this, t);
+                        }
+                    });
+                }
+            });
+        }
 
-    @Override public boolean isCanceled() {
-      return delegate.isCanceled();
-    }
+        @Override
+        public boolean isExecuted() {
+            return delegate.isExecuted();
+        }
 
-    @SuppressWarnings("CloneDoesntCallSuperClone") // Performing deep clone.
-    @Override public Call<T> clone() {
-      return new ExecutorCallbackCall<>(callbackExecutor, delegate.clone());
-    }
+        @Override
+        public Response<T> execute() throws IOException {
+            return delegate.execute();
+        }
+
+        @Override
+        public void cancel() {
+            delegate.cancel();
+        }
 
-    @Override public Request request() {
-      return delegate.request();
+        @Override
+        public boolean isCanceled() {
+            return delegate.isCanceled();
+        }
+
+        @SuppressWarnings("CloneDoesntCallSuperClone") // Performing deep clone.
+        @Override
+        public Call<T> clone() {
+            return new ExecutorCallbackCall<>(callbackExecutor, delegate.clone());
+        }
+
+        @Override
+        public Request request() {
+            return delegate.request();
+        }
     }
-  }
 }
diff --git a/retrofit/src/main/java/retrofit2/Platform.java b/retrofit/src/main/java/retrofit2/Platform.java
index 912312625..6a20410f6 100644
--- a/retrofit/src/main/java/retrofit2/Platform.java
+++ b/retrofit/src/main/java/retrofit2/Platform.java
@@ -27,130 +27,142 @@
 import java.util.concurrent.Executor;
 
 class Platform {
-  private static final Platform PLATFORM = findPlatform();
-
-  static Platform get() {
-    return PLATFORM;
-  }
-
-  private static Platform findPlatform() {
-    try {
-      Class.forName("android.os.Build");
-      if (Build.VERSION.SDK_INT != 0) {
-        return new Android();
-      }
-    } catch (ClassNotFoundException ignored) {
-    }
-    try {
-      Class.forName("java.util.Optional");
-      return new Java8();
-    } catch (ClassNotFoundException ignored) {
-    }
-    try {
-      Class.forName("org.robovm.apple.foundation.NSObject");
-      return new IOS();
-    } catch (ClassNotFoundException ignored) {
-    }
-    return new Platform();
-  }
+    private static final Platform PLATFORM = findPlatform();
 
-  Executor defaultCallbackExecutor() {
-    return null;
-  }
+    static Platform get() {
+        return PLATFORM;
+    }
 
-  CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) {
-    if (callbackExecutor != null) {
-      return new ExecutorCallAdapterFactory(callbackExecutor);
+    //通过反射获取当前是哪个平台
+    private static Platform findPlatform() {
+        try {
+            Class.forName("android.os.Build");
+            if (Build.VERSION.SDK_INT != 0) {
+                return new Android();
+            }
+        } catch (ClassNotFoundException ignored) {
+        }
+        try {
+            Class.forName("java.util.Optional");
+            return new Java8();
+        } catch (ClassNotFoundException ignored) {
+        }
+        try {
+            Class.forName("org.robovm.apple.foundation.NSObject");
+            return new IOS();
+        } catch (ClassNotFoundException ignored) {
+        }
+        return new Platform();
     }
-    return DefaultCallAdapterFactory.INSTANCE;
-  }
-
-  boolean isDefaultMethod(Method method) {
-    return false;
-  }
-
-  Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object, Object... args)
-      throws Throwable {
-    throw new UnsupportedOperationException();
-  }
-
-  @IgnoreJRERequirement // Only classloaded and used on Java 8.
-  static class Java8 extends Platform {
-    @Override boolean isDefaultMethod(Method method) {
-      return method.isDefault();
+
+    Executor defaultCallbackExecutor() {
+        return null;
     }
 
-    @Override Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object,
-        Object... args) throws Throwable {
-      // Because the service interface might not be public, we need to use a MethodHandle lookup
-      // that ignores the visibility of the declaringClass.
-      Constructor<Lookup> constructor = Lookup.class.getDeclaredConstructor(Class.class, int.class);
-      constructor.setAccessible(true);
-      return constructor.newInstance(declaringClass, -1 /* trusted */)
-          .unreflectSpecial(method, declaringClass)
-          .bindTo(object)
-          .invokeWithArguments(args);
+    CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) {
+        if (callbackExecutor != null) {
+            return new ExecutorCallAdapterFactory(callbackExecutor);
+        }
+        return DefaultCallAdapterFactory.INSTANCE;
     }
-  }
 
-  static class Android extends Platform {
-    @Override public Executor defaultCallbackExecutor() {
-      return new MainThreadExecutor();
+    boolean isDefaultMethod(Method method) {
+        return false;
     }
 
-    @Override CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) {
-      return new ExecutorCallAdapterFactory(callbackExecutor);
+    Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object, Object... args)
+            throws Throwable {
+        throw new UnsupportedOperationException();
     }
 
-    static class MainThreadExecutor implements Executor {
-      private final Handler handler = new Handler(Looper.getMainLooper());
+    @IgnoreJRERequirement // Only classloaded and used on Java 8.
+    static class Java8 extends Platform {
+        @Override
+        boolean isDefaultMethod(Method method) {
+            return method.isDefault();
+        }
 
-      @Override public void execute(Runnable r) {
-        handler.post(r);
-      }
+        @Override
+        Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object,
+                                   Object... args) throws Throwable {
+            // Because the service interface might not be public, we need to use a MethodHandle lookup
+            // that ignores the visibility of the declaringClass.
+            Constructor<Lookup> constructor = Lookup.class.getDeclaredConstructor(Class.class, int.class);
+            constructor.setAccessible(true);
+            return constructor.newInstance(declaringClass, -1 /* trusted */)
+                    .unreflectSpecial(method, declaringClass)
+                    .bindTo(object)
+                    .invokeWithArguments(args);
+        }
     }
-  }
 
-  static class IOS extends Platform {
-    @Override public Executor defaultCallbackExecutor() {
-      return new MainThreadExecutor();
-    }
+    //默认Android平台配置
+    static class Android extends Platform {
+
+        //CallbackExecutor 线程切换
+        @Override
+        public Executor defaultCallbackExecutor() {
+            return new MainThreadExecutor();
+        }
+
+        @Override
+        CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) {
+            return new ExecutorCallAdapterFactory(callbackExecutor);
+        }
+
+        static class MainThreadExecutor implements Executor {
+            private final Handler handler = new Handler(Looper.getMainLooper());
 
-    @Override CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) {
-      return new ExecutorCallAdapterFactory(callbackExecutor);
+            @Override
+            public void execute(Runnable r) {
+                handler.post(r);
+            }
+        }
     }
 
-    static class MainThreadExecutor implements Executor {
-      private static Object queue;
-      private static Method addOperation;
+    static class IOS extends Platform {
+        @Override
+        public Executor defaultCallbackExecutor() {
+            return new MainThreadExecutor();
+        }
 
-      static {
-        try {
-          // queue = NSOperationQueue.getMainQueue();
-          Class<?> operationQueue = Class.forName("org.robovm.apple.foundation.NSOperationQueue");
-          queue = operationQueue.getDeclaredMethod("getMainQueue").invoke(null);
-          addOperation = operationQueue.getDeclaredMethod("addOperation", Runnable.class);
-        } catch (Exception e) {
-          throw new AssertionError(e);
+        @Override
+        CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) {
+            return new ExecutorCallAdapterFactory(callbackExecutor);
         }
-      }
 
-      @Override public void execute(Runnable r) {
-        try {
-          // queue.addOperation(r);
-          addOperation.invoke(queue, r);
-        } catch (IllegalArgumentException | IllegalAccessException e) {
-          throw new AssertionError(e);
-        } catch (InvocationTargetException e) {
-          Throwable cause = e.getCause();
-          if (cause instanceof RuntimeException) {
-            throw (RuntimeException) cause;
-          } else if (cause instanceof Error) {
-            throw (Error) cause;
-          }
-          throw new RuntimeException(cause);
+        static class MainThreadExecutor implements Executor {
+            private static Object queue;
+            private static Method addOperation;
+
+            static {
+                try {
+                    // queue = NSOperationQueue.getMainQueue();
+                    Class<?> operationQueue = Class.forName("org.robovm.apple.foundation.NSOperationQueue");
+                    queue = operationQueue.getDeclaredMethod("getMainQueue").invoke(null);
+                    addOperation = operationQueue.getDeclaredMethod("addOperation", Runnable.class);
+                } catch (Exception e) {
+                    throw new AssertionError(e);
+                }
+            }
+
+            @Override
+            public void execute(Runnable r) {
+                try {
+                    // queue.addOperation(r);
+                    addOperation.invoke(queue, r);
+                } catch (IllegalArgumentException | IllegalAccessException e) {
+                    throw new AssertionError(e);
+                } catch (InvocationTargetException e) {
+                    Throwable cause = e.getCause();
+                    if (cause instanceof RuntimeException) {
+                        throw (RuntimeException) cause;
+                    } else if (cause instanceof Error) {
+                        throw (Error) cause;
+                    }
+                    throw new RuntimeException(cause);
+                }
+            }
         }
-      }
     }
-  }
 }
diff --git a/retrofit/src/main/java/retrofit2/Retrofit.java b/retrofit/src/main/java/retrofit2/Retrofit.java
index 2695c0223..f0e32eebc 100644
--- a/retrofit/src/main/java/retrofit2/Retrofit.java
+++ b/retrofit/src/main/java/retrofit2/Retrofit.java
@@ -58,7 +58,7 @@
  * @author Jake Wharton (jw@squareup.com)
  */
 public final class Retrofit {
-    //缓存service中的业务方法
+    //缓存service中的业务方法,所以一般Retrofit设置为单例
     private final Map<Method, ServiceMethod> serviceMethodCache = new LinkedHashMap<>();
     //发送请求采用的客户端,默认OkHttpClient
     private final okhttp3.Call.Factory callFactory;
@@ -76,6 +76,7 @@
              Executor callbackExecutor, boolean validateEagerly) {
         this.callFactory = callFactory;
         this.baseUrl = baseUrl;
+        //一旦生成Retrofit实例,解析器和适配器就不能修改了
         this.converterFactories = unmodifiableList(converterFactories); // Defensive copy at call site.
         this.adapterFactories = unmodifiableList(adapterFactories); // Defensive copy at call site.
         this.callbackExecutor = callbackExecutor;
@@ -136,14 +137,19 @@
         }
         //动态代理,类加载器,
         //代理模式:实际上都是持有原对象,在这个对象上操作的,添加了额外的操作
+        //Retrofit 并没有真正的持有原对象,只是想利用Method方法上面的注解
+        //静态代理和动态代理的区别  静态代理:当代理接口变化时，实现类和代理类都要变化，而动态代理不会,方法的调用都委托了InvocationHandler调用处理器
         return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[]{service},
                 new InvocationHandler() {
                     private final Platform platform = Platform.get();
 
+                    //spring中事务的管理貌似就是动态代理,可以根据Method 判断注解
                     @Override
                     public Object invoke(Object proxy, Method method, Object... args)
                             throws Throwable {
                         // If the method is a method from Object then defer to normal invocation.
+
+                        //判断调用的是不是Object继承下来的方法
                         if (method.getDeclaringClass() == Object.class) {
                             return method.invoke(this, args);
                         }
@@ -170,6 +176,7 @@ private void eagerlyValidateMethods(Class<?> service) {
     ServiceMethod loadServiceMethod(Method method) {
         ServiceMethod result;
         synchronized (serviceMethodCache) {
+            //Method作为KEY , class 对象是单例的，所以Method也是单例的 不可变对象
             result = serviceMethodCache.get(method);
             if (result == null) {
                 result = new ServiceMethod.Builder(this, method).build();
@@ -414,6 +421,7 @@ public Executor callbackExecutor() {
         }
 
         public Builder() {
+            //获取当前是什么平台
             this(Platform.get());
         }
 
diff --git a/retrofit/src/main/java/retrofit2/ServiceMethod.java b/retrofit/src/main/java/retrofit2/ServiceMethod.java
index 94dde7996..984b06e7e 100644
--- a/retrofit/src/main/java/retrofit2/ServiceMethod.java
+++ b/retrofit/src/main/java/retrofit2/ServiceMethod.java
@@ -33,6 +33,8 @@
 
 /**
  * Adapts an invocation of an interface method into an HTTP call.
+ * <p>
+ * 缓存api上的各种注解配置  例如:@GET 存储get  不用每次都重新解析
  */
 final class ServiceMethod<T> {
     // Upper and lower characters, digits, underscores, and hyphens, starting with a character.
@@ -52,6 +54,9 @@
     private final boolean hasBody;
     private final boolean isFormEncoded;
     private final boolean isMultipart;
+
+
+    //参数解析器  和参数个数 一一对应
     private final ParameterHandler<?>[] parameterHandlers;
 
     ServiceMethod(Builder<T> builder) {
@@ -149,12 +154,14 @@ public ServiceMethod build() {
             callAdapter = createCallAdapter();
             //返回类型
             responseType = callAdapter.responseType();
+
+            //不能直接返回Response,需要用Call<Response>包装
             if (responseType == Response.class || responseType == okhttp3.Response.class) {
                 throw methodError("'"
                         + Utils.getRawType(responseType).getName()
                         + "' is not a valid response body type. Did you mean ResponseBody?");
             }
-            //创建响应解析器
+            //获取响应解析器
             responseConverter = createResponseConverter();
 
             //解析方法上面的注解 get,post,delete eg..
@@ -178,7 +185,9 @@ public ServiceMethod build() {
             }
 
             int parameterCount = parameterAnnotationsArray.length;
-            //参数拼接
+            //生成方法参数上面的解析器
+
+            //负责解析api 上面的参数,为生成Request做准备
             parameterHandlers = new ParameterHandler<?>[parameterCount];
             for (int p = 0; p < parameterCount; p++) {
                 //注解类型
@@ -222,6 +231,7 @@ public ServiceMethod build() {
             if (returnType == void.class) {
                 throw methodError("Service methods cannot return void.");
             }
+            //获取方法上面的注解
             Annotation[] annotations = method.getAnnotations();
             try {
                 return retrofit.callAdapter(returnType, annotations);
