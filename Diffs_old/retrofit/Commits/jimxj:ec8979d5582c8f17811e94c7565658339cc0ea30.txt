diff --git a/.travis.yml b/.travis.yml
index e6a844e22..79fe36a95 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,7 +1,6 @@
 language: java
 
 jdk:
-  - oraclejdk7
   - oraclejdk8
 
 after_success:
diff --git a/pom.xml b/pom.xml
index 51f820329..23d8c82e3 100644
--- a/pom.xml
+++ b/pom.xml
@@ -51,9 +51,10 @@
     <android.version>4.1.1.4</android.version>
     <android.platform>16</android.platform>
     <okhttp.version>2.5.0-SNAPSHOT</okhttp.version>
+    <animal.sniffer.version>1.14</animal.sniffer.version>
 
     <!-- Adapter Dependencies -->
-    <rxjava.version>1.0.10</rxjava.version>
+    <rxjava.version>1.0.13</rxjava.version>
 
     <!-- Converter Dependencies -->
     <gson.version>2.3.1</gson.version>
@@ -101,6 +102,11 @@
         <artifactId>android</artifactId>
         <version>${android.version}</version>
       </dependency>
+      <dependency>
+        <groupId>org.codehaus.mojo</groupId>
+        <artifactId>animal-sniffer-annotations</artifactId>
+        <version>${animal.sniffer.version}</version>
+      </dependency>
       <dependency>
         <groupId>com.squareup.okhttp</groupId>
         <artifactId>okhttp</artifactId>
@@ -214,6 +220,27 @@
           </execution>
         </executions>
       </plugin>
+
+      <plugin>
+        <groupId>org.codehaus.mojo</groupId>
+        <artifactId>animal-sniffer-maven-plugin</artifactId>
+        <version>${animal.sniffer.version}</version>
+        <executions>
+          <execution>
+            <phase>test</phase>
+            <goals>
+              <goal>check</goal>
+            </goals>
+          </execution>
+        </executions>
+        <configuration>
+          <signature>
+            <groupId>org.codehaus.mojo.signature</groupId>
+            <artifactId>java16</artifactId>
+            <version>1.1</version>
+          </signature>
+        </configuration>
+      </plugin>
     </plugins>
   </build>
 </project>
diff --git a/retrofit-adapters/rxjava-mock/src/main/java/retrofit/mock/RxJavaBehaviorAdapter.java b/retrofit-adapters/rxjava-mock/src/main/java/retrofit/mock/RxJavaBehaviorAdapter.java
new file mode 100644
index 000000000..054c5556a
--- /dev/null
+++ b/retrofit-adapters/rxjava-mock/src/main/java/retrofit/mock/RxJavaBehaviorAdapter.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.mock;
+
+import rx.Observable;
+import rx.functions.Func1;
+
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+
+public final class RxJavaBehaviorAdapter implements NetworkBehavior.Adapter<Object> {
+  public static RxJavaBehaviorAdapter create() {
+    return new RxJavaBehaviorAdapter();
+  }
+
+  private RxJavaBehaviorAdapter() {
+  }
+
+  @Override public Object applyBehavior(NetworkBehavior behavior, Object value) {
+    if (value instanceof Observable) {
+      return applyObservableBehavior(behavior, (Observable<?>) value);
+    }
+    String name = value.getClass().getCanonicalName();
+    if ("rx.Single".equals(name)) {
+      // Apply behavior to the Single from a separate class. This defers classloading such that
+      // regular Observable operation can be leveraged without relying on this unstable RxJava API.
+      return SingleHelper.applySingleBehavior(behavior, value);
+    }
+    throw new IllegalStateException("Unsupported type " + name);
+  }
+
+  public Observable<?> applyObservableBehavior(final NetworkBehavior behavior,
+      final Observable<?> value) {
+    return Observable.timer(behavior.calculateDelay(MILLISECONDS), MILLISECONDS)
+        .flatMap(new Func1<Long, Observable<?>>() {
+          @Override public Observable<?> call(Long ignored) {
+            if (behavior.calculateIsFailure()) {
+              return Observable.error(behavior.failureException());
+            }
+            return value;
+          }
+        });
+  }
+}
diff --git a/retrofit-adapters/rxjava-mock/src/main/java/retrofit/mock/ObservableBehaviorAdapter.java b/retrofit-adapters/rxjava-mock/src/main/java/retrofit/mock/SingleHelper.java
similarity index 74%
rename from retrofit-adapters/rxjava-mock/src/main/java/retrofit/mock/ObservableBehaviorAdapter.java
rename to retrofit-adapters/rxjava-mock/src/main/java/retrofit/mock/SingleHelper.java
index 3fd67a6c8..d1c54214f 100644
--- a/retrofit-adapters/rxjava-mock/src/main/java/retrofit/mock/ObservableBehaviorAdapter.java
+++ b/retrofit-adapters/rxjava-mock/src/main/java/retrofit/mock/SingleHelper.java
@@ -16,27 +16,24 @@
 package retrofit.mock;
 
 import rx.Observable;
+import rx.Single;
 import rx.functions.Func1;
 
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 
-public final class ObservableBehaviorAdapter implements BehaviorAdapter<Observable<?>> {
-  public static ObservableBehaviorAdapter create() {
-    return new ObservableBehaviorAdapter();
-  }
-
-  private ObservableBehaviorAdapter() {
-  }
-
-  @Override public Observable<?> applyBehavior(final Behavior behavior, final Observable<?> value) {
+final class SingleHelper {
+  @SuppressWarnings("unchecked") // Caller must instanceof / getClass() verify 'value' is Single.
+  public static Object applySingleBehavior(final NetworkBehavior behavior, Object value) {
+    final Single<Object> single = (Single<Object>) value;
     return Observable.timer(behavior.calculateDelay(MILLISECONDS), MILLISECONDS)
         .flatMap(new Func1<Long, Observable<?>>() {
           @Override public Observable<?> call(Long ignored) {
             if (behavior.calculateIsFailure()) {
               return Observable.error(behavior.failureException());
             }
-            return value;
+            return single.toObservable();
           }
-        });
+        })
+        .toSingle();
   }
 }
diff --git a/retrofit-adapters/rxjava-mock/src/test/java/retrofit/mock/ObservableBehaviorAdapterTest.java b/retrofit-adapters/rxjava-mock/src/test/java/retrofit/mock/RxJavaBehaviorAdapterTest.java
similarity index 52%
rename from retrofit-adapters/rxjava-mock/src/test/java/retrofit/mock/ObservableBehaviorAdapterTest.java
rename to retrofit-adapters/rxjava-mock/src/test/java/retrofit/mock/RxJavaBehaviorAdapterTest.java
index 6b2528f66..d256b84f0 100644
--- a/retrofit-adapters/rxjava-mock/src/test/java/retrofit/mock/ObservableBehaviorAdapterTest.java
+++ b/retrofit-adapters/rxjava-mock/src/test/java/retrofit/mock/RxJavaBehaviorAdapterTest.java
@@ -23,6 +23,7 @@
 import org.junit.Before;
 import org.junit.Test;
 import rx.Observable;
+import rx.Single;
 import rx.Subscriber;
 
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
@@ -30,32 +31,99 @@
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.assertTrue;
 
-public final class ObservableBehaviorAdapterTest {
+public final class RxJavaBehaviorAdapterTest {
   interface DoWorkService {
-    Observable<String> response();
+    Observable<String> observableResponse();
+    Single<String> singleResponse();
   }
 
-  private final Behavior behavior = Behavior.create(new Random(2847));
+  private final NetworkBehavior behavior = NetworkBehavior.create(new Random(2847));
   private DoWorkService service;
 
   @Before public void setUp() {
     DoWorkService mockService = new DoWorkService() {
-      @Override public Observable<String> response() {
+      @Override public Observable<String> observableResponse() {
         return Observable.just("Hi!");
       }
+
+      @Override public Single<String> singleResponse() {
+        return Single.just("Hi!");
+      }
     };
 
-    BehaviorAdapter<?> adapter = ObservableBehaviorAdapter.create();
-    MockRetrofit mockRetrofit = new MockRetrofit(adapter, behavior);
+    NetworkBehavior.Adapter<?> adapter = RxJavaBehaviorAdapter.create();
+    MockRetrofit mockRetrofit = new MockRetrofit(behavior, adapter);
     service = mockRetrofit.create(DoWorkService.class, mockService);
   }
 
-  @Test public void failureAfterDelay() throws InterruptedException {
+  @Test public void observableFailureAfterDelay() throws InterruptedException {
+    behavior.setDelay(100, MILLISECONDS);
+    behavior.setVariancePercent(0);
+    behavior.setFailurePercent(100);
+
+    Observable<String> observable = service.observableResponse();
+
+    final long startNanos = System.nanoTime();
+    final AtomicLong tookMs = new AtomicLong();
+    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    observable.subscribe(new Subscriber<String>() {
+      @Override public void onNext(String s) {
+        throw new AssertionError();
+      }
+
+      @Override public void onError(Throwable throwable) {
+        tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
+        failureRef.set(throwable);
+        latch.countDown();
+      }
+
+      @Override public void onCompleted() {
+      }
+    });
+    assertTrue(latch.await(1, SECONDS));
+
+    assertThat(failureRef.get()).isSameAs(behavior.failureException());
+    assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
+  }
+
+  @Test public void observableSuccessAfterDelay() throws InterruptedException {
+    behavior.setDelay(100, MILLISECONDS);
+    behavior.setVariancePercent(0);
+    behavior.setFailurePercent(0);
+
+    Observable<String> observable = service.observableResponse();
+
+    final long startNanos = System.nanoTime();
+    final AtomicLong tookMs = new AtomicLong();
+    final AtomicReference<String> actual = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    observable.subscribe(new Subscriber<String>() {
+      @Override public void onNext(String value) {
+        tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
+        actual.set(value);
+        latch.countDown();
+      }
+
+      @Override public void onError(Throwable throwable) {
+        throw new AssertionError();
+      }
+
+      @Override public void onCompleted() {
+      }
+    });
+    assertTrue(latch.await(1, SECONDS));
+
+    assertThat(actual.get()).isEqualTo("Hi!");
+    assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
+  }
+
+  @Test public void singleFailureAfterDelay() throws InterruptedException {
     behavior.setDelay(100, MILLISECONDS);
     behavior.setVariancePercent(0);
     behavior.setFailurePercent(100);
 
-    Observable<String> observable = service.response();
+    Single<String> observable = service.singleResponse();
 
     final long startNanos = System.nanoTime();
     final AtomicLong tookMs = new AtomicLong();
@@ -81,12 +149,12 @@
     assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
   }
 
-  @Test public void successAfterDelay() throws InterruptedException {
+  @Test public void singleSuccessAfterDelay() throws InterruptedException {
     behavior.setDelay(100, MILLISECONDS);
     behavior.setVariancePercent(0);
     behavior.setFailurePercent(0);
 
-    Observable<String> observable = service.response();
+    Single<String> observable = service.singleResponse();
 
     final long startNanos = System.nanoTime();
     final AtomicLong tookMs = new AtomicLong();
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit/ObservableCallAdapterFactory.java b/retrofit-adapters/rxjava/src/main/java/retrofit/RxJavaCallAdapterFactory.java
similarity index 82%
rename from retrofit-adapters/rxjava/src/main/java/retrofit/ObservableCallAdapterFactory.java
rename to retrofit-adapters/rxjava/src/main/java/retrofit/RxJavaCallAdapterFactory.java
index b09d67070..b715e1dc0 100644
--- a/retrofit-adapters/rxjava/src/main/java/retrofit/ObservableCallAdapterFactory.java
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit/RxJavaCallAdapterFactory.java
@@ -26,33 +26,41 @@
 /**
  * TODO docs
  */
-public final class ObservableCallAdapterFactory implements CallAdapter.Factory {
+public final class RxJavaCallAdapterFactory implements CallAdapter.Factory {
   /**
    * TODO
    */
-  public static ObservableCallAdapterFactory create() {
-    return new ObservableCallAdapterFactory();
+  public static RxJavaCallAdapterFactory create() {
+    return new RxJavaCallAdapterFactory();
   }
 
-  private ObservableCallAdapterFactory() {
-  }
-
-  @Override public String toString() {
-    return getClass().getSimpleName();
+  private RxJavaCallAdapterFactory() {
   }
 
   @Override public CallAdapter<?> get(Type returnType) {
-    if (Utils.getRawType(returnType) != Observable.class) {
+    Class<?> rawType = Utils.getRawType(returnType);
+    boolean isSingle = "rx.Single".equals(rawType.getCanonicalName());
+    if (rawType != Observable.class && !isSingle) {
       return null;
     }
     if (!(returnType instanceof ParameterizedType)) {
-      throw new IllegalStateException("Observable return type must be parameterized"
-          + " as Observable<Foo> or Observable<? extends Foo>");
+      String name = isSingle ? "Single" : "Observable";
+      throw new IllegalStateException(name + " return type must be parameterized"
+          + " as " + name + "<Foo> or " + name + "<? extends Foo>");
+    }
+
+    CallAdapter<Object> callAdapter = getCallAdapter(returnType);
+    if (isSingle) {
+      // Add Single-converter wrapper from a separate class. This defers classloading such that
+      // regular Observable operation can be leveraged without relying on this unstable RxJava API.
+      callAdapter = SingleHelper.makeSingle(callAdapter);
     }
+    return callAdapter;
+  }
 
+  private CallAdapter<Object> getCallAdapter(Type returnType) {
     Type observableType = Utils.getSingleParameterUpperBound((ParameterizedType) returnType);
     Class<?> rawObservableType = Utils.getRawType(observableType);
-
     if (rawObservableType == Response.class) {
       if (!(observableType instanceof ParameterizedType)) {
         throw new IllegalStateException("Response must be parameterized"
@@ -71,7 +79,7 @@ private ObservableCallAdapterFactory() {
       return new ResultCallAdapter<>(responseType);
     }
 
-    return new SimpleCallAdapter(observableType);
+    return new SimpleCallAdapter<>(observableType);
   }
 
   static final class CallOnSubscribe<T> implements Observable.OnSubscribe<Response<T>> {
diff --git a/retrofit-mock/src/main/java/retrofit/mock/BehaviorAdapter.java b/retrofit-adapters/rxjava/src/main/java/retrofit/SingleHelper.java
similarity index 53%
rename from retrofit-mock/src/main/java/retrofit/mock/BehaviorAdapter.java
rename to retrofit-adapters/rxjava/src/main/java/retrofit/SingleHelper.java
index 5dde8b58f..01f91d7f7 100644
--- a/retrofit-mock/src/main/java/retrofit/mock/BehaviorAdapter.java
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit/SingleHelper.java
@@ -13,8 +13,23 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit.mock;
+package retrofit;
 
-public interface BehaviorAdapter<T> {
-  T applyBehavior(Behavior behavior, T value);
+import java.lang.reflect.Type;
+import rx.Observable;
+import rx.Single;
+
+final class SingleHelper {
+  static CallAdapter<Object> makeSingle(final CallAdapter<Object> callAdapter) {
+    return new CallAdapter<Object>() {
+      @Override public Type responseType() {
+        return callAdapter.responseType();
+      }
+
+      @Override public Single<?> adapt(Call<Object> call) {
+        Observable<?> observable = (Observable<?>) callAdapter.adapt(call);
+        return observable.toSingle();
+      }
+    };
+  }
 }
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit/ObservableCallAdapterFactoryTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit/RxJavaCallAdapterFactoryTest.java
similarity index 67%
rename from retrofit-adapters/rxjava/src/test/java/retrofit/ObservableCallAdapterFactoryTest.java
rename to retrofit-adapters/rxjava/src/test/java/retrofit/RxJavaCallAdapterFactoryTest.java
index 3be1a8a9e..726de5a3f 100644
--- a/retrofit-adapters/rxjava/src/test/java/retrofit/ObservableCallAdapterFactoryTest.java
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit/RxJavaCallAdapterFactoryTest.java
@@ -29,19 +29,24 @@
 import org.junit.Test;
 import retrofit.http.GET;
 import rx.Observable;
+import rx.Single;
 import rx.observables.BlockingObservable;
 
 import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.fail;
 
-public final class ObservableCallAdapterFactoryTest {
+public final class RxJavaCallAdapterFactoryTest {
   @Rule public final MockWebServer server = new MockWebServer();
 
   interface Service {
-    @GET("/") Observable<String> body();
-    @GET("/") Observable<Response<String>> response();
-    @GET("/") Observable<Result<String>> result();
+    @GET("/") Observable<String> observableBody();
+    @GET("/") Observable<Response<String>> observableResponse();
+    @GET("/") Observable<Result<String>> observableResult();
+    @GET("/") Single<String> singleBody();
+    @GET("/") Single<Response<String>> singleResponse();
+    @GET("/") Single<Result<String>> singleResult();
   }
 
   private Service service;
@@ -50,7 +55,7 @@
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
         .addConverterFactory(new StringConverterFactory())
-        .addCallAdapterFactory(ObservableCallAdapterFactory.create())
+        .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
         .build();
     service = retrofit.create(Service.class);
   }
@@ -58,14 +63,14 @@
   @Test public void bodySuccess200() {
     server.enqueue(new MockResponse().setBody("Hi"));
 
-    BlockingObservable<String> o = service.body().toBlocking();
+    BlockingObservable<String> o = service.observableBody().toBlocking();
     assertThat(o.first()).isEqualTo("Hi");
   }
 
   @Test public void bodySuccess404() {
     server.enqueue(new MockResponse().setResponseCode(404));
 
-    BlockingObservable<String> o = service.body().toBlocking();
+    BlockingObservable<String> o = service.observableBody().toBlocking();
     try {
       o.first();
       fail();
@@ -78,7 +83,7 @@
   @Test public void bodyFailure() {
     server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
 
-    BlockingObservable<String> o = service.body().toBlocking();
+    BlockingObservable<String> o = service.observableBody().toBlocking();
     try {
       o.first();
       fail();
@@ -90,7 +95,7 @@
   @Test public void responseSuccess200() {
     server.enqueue(new MockResponse().setBody("Hi"));
 
-    BlockingObservable<Response<String>> o = service.response().toBlocking();
+    BlockingObservable<Response<String>> o = service.observableResponse().toBlocking();
     Response<String> response = o.first();
     assertThat(response.isSuccess()).isTrue();
     assertThat(response.body()).isEqualTo("Hi");
@@ -99,7 +104,7 @@
   @Test public void responseSuccess404() throws IOException {
     server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
 
-    BlockingObservable<Response<String>> o = service.response().toBlocking();
+    BlockingObservable<Response<String>> o = service.observableResponse().toBlocking();
     Response<String> response = o.first();
     assertThat(response.isSuccess()).isFalse();
     assertThat(response.errorBody().string()).isEqualTo("Hi");
@@ -108,7 +113,7 @@
   @Test public void responseFailure() {
     server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
 
-    BlockingObservable<Response<String>> o = service.response().toBlocking();
+    BlockingObservable<Response<String>> o = service.observableResponse().toBlocking();
     try {
       o.first();
       fail();
@@ -120,7 +125,7 @@
   @Test public void resultSuccess200() {
     server.enqueue(new MockResponse().setBody("Hi"));
 
-    BlockingObservable<Result<String>> o = service.result().toBlocking();
+    BlockingObservable<Result<String>> o = service.observableResult().toBlocking();
     Result<String> result = o.first();
     assertThat(result.isError()).isFalse();
     Response<String> response = result.response();
@@ -131,7 +136,7 @@
   @Test public void resultSuccess404() throws IOException {
     server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
 
-    BlockingObservable<Result<String>> o = service.result().toBlocking();
+    BlockingObservable<Result<String>> o = service.observableResult().toBlocking();
     Result<String> result = o.first();
     assertThat(result.isError()).isFalse();
     Response<String> response = result.response();
@@ -142,14 +147,14 @@
   @Test public void resultFailure() {
     server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
 
-    BlockingObservable<Result<String>> o = service.result().toBlocking();
+    BlockingObservable<Result<String>> o = service.observableResult().toBlocking();
     Result<String> result = o.first();
     assertThat(result.isError()).isTrue();
     assertThat(result.error()).isInstanceOf(IOException.class);
   }
 
   @Test public void responseType() {
-    CallAdapter.Factory factory = ObservableCallAdapterFactory.create();
+    CallAdapter.Factory factory = RxJavaCallAdapterFactory.create();
     Type classType = new TypeToken<Observable<String>>() {}.getType();
     assertThat(factory.get(classType).responseType()).isEqualTo(String.class);
     Type wilcardType = new TypeToken<Observable<? extends String>>() {}.getType();
@@ -164,27 +169,41 @@
   }
 
   @Test public void nonObservableTypeReturnsNull() {
-    CallAdapter.Factory factory = ObservableCallAdapterFactory.create();
+    CallAdapter.Factory factory = RxJavaCallAdapterFactory.create();
     CallAdapter<?> adapter = factory.get(String.class);
     assertThat(adapter).isNull();
   }
 
   @Test public void rawTypeThrows() {
-    Type type = new TypeToken<Observable>() {}.getType();
-    CallAdapter.Factory factory = ObservableCallAdapterFactory.create();
+    CallAdapter.Factory factory = RxJavaCallAdapterFactory.create();
+    Type observableType = new TypeToken<Observable>() {}.getType();
     try {
-      factory.get(type);
+      factory.get(observableType);
       fail();
     } catch (IllegalStateException e) {
       assertThat(e).hasMessage("Observable return type must be parameterized as Observable<Foo> or Observable<? extends Foo>");
     }
+    Type singleType = new TypeToken<Single>() {}.getType();
+    try {
+      factory.get(singleType);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage("Single return type must be parameterized as Single<Foo> or Single<? extends Foo>");
+    }
   }
 
-  @Test public void rawResponseTypeThrows() {
-    Type type = new TypeToken<Observable<Response>>() {}.getType();
-    CallAdapter.Factory factory = ObservableCallAdapterFactory.create();
+  @Test public void rawObservableResponseTypeThrows() {
+    CallAdapter.Factory factory = RxJavaCallAdapterFactory.create();
+    Type observableType = new TypeToken<Observable<Response>>() {}.getType();
+    try {
+      factory.get(observableType);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage("Response must be parameterized as Response<Foo> or Response<? extends Foo>");
+    }
+    Type singleType = new TypeToken<Single<Response>>() {}.getType();
     try {
-      factory.get(type);
+      factory.get(singleType);
       fail();
     } catch (IllegalStateException e) {
       assertThat(e).hasMessage("Response must be parameterized as Response<Foo> or Response<? extends Foo>");
@@ -192,16 +211,30 @@
   }
 
   @Test public void rawResultTypeThrows() {
-    Type type = new TypeToken<Observable<Result>>() {}.getType();
-    CallAdapter.Factory factory = ObservableCallAdapterFactory.create();
+    CallAdapter.Factory factory = RxJavaCallAdapterFactory.create();
+    Type observableType = new TypeToken<Observable<Result>>() {}.getType();
+    try {
+      factory.get(observableType);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage("Result must be parameterized as Result<Foo> or Result<? extends Foo>");
+    }
+    Type singleType = new TypeToken<Single<Result>>() {}.getType();
     try {
-      factory.get(type);
+      factory.get(singleType);
       fail();
     } catch (IllegalStateException e) {
       assertThat(e).hasMessage("Result must be parameterized as Result<Foo> or Result<? extends Foo>");
     }
   }
 
+  @Test public void single() {
+    // TODO Better tests here. Why is there no toBlocking() on Single?
+    assertNotNull(service.singleBody());
+    assertNotNull(service.singleResponse());
+    assertNotNull(service.singleResult());
+  }
+
   static class StringConverterFactory implements Converter.Factory {
     @Override public Converter<?> get(Type type) {
       return new Converter<String>() {
diff --git a/retrofit-mock/src/main/java/retrofit/mock/BehaviorCall.java b/retrofit-mock/src/main/java/retrofit/mock/BehaviorCall.java
index 2e3bce2a1..6857cdc8b 100644
--- a/retrofit-mock/src/main/java/retrofit/mock/BehaviorCall.java
+++ b/retrofit-mock/src/main/java/retrofit/mock/BehaviorCall.java
@@ -29,7 +29,7 @@
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 
 final class BehaviorCall<T> implements Call<T> {
-  private final Behavior behavior;
+  private final NetworkBehavior behavior;
   private final ExecutorService backgroundExecutor;
   private final Executor callbackExecutor;
   private final Call<T> delegate;
@@ -38,8 +38,8 @@
   private volatile boolean canceled;
   private volatile boolean executed;
 
-  BehaviorCall(Behavior behavior, ExecutorService backgroundExecutor, Executor callbackExecutor,
-      Call<T> delegate) {
+  BehaviorCall(NetworkBehavior behavior, ExecutorService backgroundExecutor,
+      Executor callbackExecutor, Call<T> delegate) {
     if (callbackExecutor == null) {
       callbackExecutor = new Executor() {
         @Override public void execute(Runnable command) {
diff --git a/retrofit-mock/src/main/java/retrofit/mock/CallBehaviorAdapter.java b/retrofit-mock/src/main/java/retrofit/mock/CallBehaviorAdapter.java
index e580d1076..551f706f0 100644
--- a/retrofit-mock/src/main/java/retrofit/mock/CallBehaviorAdapter.java
+++ b/retrofit-mock/src/main/java/retrofit/mock/CallBehaviorAdapter.java
@@ -20,7 +20,7 @@
 import retrofit.Call;
 import retrofit.Retrofit;
 
-public final class CallBehaviorAdapter implements BehaviorAdapter<Call<?>> {
+public final class CallBehaviorAdapter implements NetworkBehavior.Adapter<Call<?>> {
   private final Executor callbackExecutor;
   private final ExecutorService backgroundExecutor;
 
@@ -34,7 +34,7 @@ public CallBehaviorAdapter(Retrofit retrofit, ExecutorService backgroundExecutor
     this.backgroundExecutor = backgroundExecutor;
   }
 
-  @Override public Call<?> applyBehavior(Behavior behavior, Call<?> value) {
+  @Override public Call<?> applyBehavior(NetworkBehavior behavior, Call<?> value) {
     return new BehaviorCall<>(behavior, backgroundExecutor, callbackExecutor, value);
   }
 }
diff --git a/retrofit-mock/src/main/java/retrofit/mock/MockRetrofit.java b/retrofit-mock/src/main/java/retrofit/mock/MockRetrofit.java
index dcd966c13..71aaaca6d 100644
--- a/retrofit-mock/src/main/java/retrofit/mock/MockRetrofit.java
+++ b/retrofit-mock/src/main/java/retrofit/mock/MockRetrofit.java
@@ -20,12 +20,12 @@
 import java.lang.reflect.Proxy;
 
 public final class MockRetrofit {
-  private final BehaviorAdapter<Object> adapter;
-  private final Behavior behavior;
+  private final NetworkBehavior behavior;
+  private final NetworkBehavior.Adapter<Object> adapter;
 
   @SuppressWarnings("unchecked") //
-  public MockRetrofit(BehaviorAdapter<?> adapter, Behavior behavior) {
-    this.adapter = (BehaviorAdapter<Object>) adapter;
+  public MockRetrofit(NetworkBehavior behavior, NetworkBehavior.Adapter<?> adapter) {
+    this.adapter = (NetworkBehavior.Adapter<Object>) adapter;
     this.behavior = behavior;
   }
 
@@ -39,7 +39,9 @@ public MockRetrofit(BehaviorAdapter<?> adapter, Behavior behavior) {
               return method.invoke(this, args);
             }
             method.setAccessible(true); // Just In Case™
-            return adapter.applyBehavior(behavior, method.invoke(instance, args));
+
+            Object value = method.invoke(instance, args);
+            return adapter.applyBehavior(behavior, value);
           }
         });
   }
diff --git a/retrofit-mock/src/main/java/retrofit/mock/Behavior.java b/retrofit-mock/src/main/java/retrofit/mock/NetworkBehavior.java
similarity index 67%
rename from retrofit-mock/src/main/java/retrofit/mock/Behavior.java
rename to retrofit-mock/src/main/java/retrofit/mock/NetworkBehavior.java
index 713561c5c..f3fdffb77 100644
--- a/retrofit-mock/src/main/java/retrofit/mock/Behavior.java
+++ b/retrofit-mock/src/main/java/retrofit/mock/NetworkBehavior.java
@@ -21,17 +21,47 @@
 
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 
-public final class Behavior {
+/**
+ * A simple emulation of the behavior of network calls.
+ * <p>
+ * This class models three properties of a network:
+ * <ul>
+ * <li>Delay – the time it takes before a response is received (successful or otherwise).</li>
+ * <li>Variance – the amount of fluctuation of the delay to be faster or slower.</li>
+ * <li>Failure - the percentage of operations which fail (such as {@link IOException}).</li>
+ * </ul>
+ * Behavior can be applied to a Retrofit interface with {@link MockRetrofit}. Behavior can also
+ * be applied elsewhere using {@link #calculateDelay(TimeUnit)} and {@link #calculateIsFailure()}.
+ * <p>
+ * By default, instances of this class will use a 2 second delay with 40% variance and failures
+ * will occur 3% of the time.
+ */
+public final class NetworkBehavior {
   private static final int DEFAULT_DELAY_MS = 2000; // Network calls will take 2 seconds.
   private static final int DEFAULT_VARIANCE_PERCENT = 40; // Network delay varies by ±40%.
   private static final int DEFAULT_FAILURE_PERCENT = 3; // 3% of network calls will fail.
 
-  public static Behavior create() {
-    return new Behavior(new Random());
+  /** Applies {@link NetworkBehavior} to instances of {@code T}. */
+  public interface Adapter<T> {
+    /**
+     * Apply {@code behavior} to {@code value} so that it exhibits the configured network behavior
+     * traits when interacted with.
+     */
+    T applyBehavior(NetworkBehavior behavior, T value);
+  }
+
+  /** Create an instance with default behavior. */
+  public static NetworkBehavior create() {
+    return new NetworkBehavior(new Random());
   }
 
-  public static Behavior create(Random random) {
-    return new Behavior(random);
+  /**
+   * Create an instance with default behavior which uses {@code random} to control variance and
+   * failure calculation.
+   */
+  public static NetworkBehavior create(Random random) {
+    if (random == null) throw new NullPointerException("random == null");
+    return new NetworkBehavior(random);
   }
 
   private final Random random;
@@ -39,9 +69,9 @@ public static Behavior create(Random random) {
   private volatile long delayMs = DEFAULT_DELAY_MS;
   private volatile int variancePercent = DEFAULT_VARIANCE_PERCENT;
   private volatile int failurePercent = DEFAULT_FAILURE_PERCENT;
-  private volatile IOException failureException = new IOException("Mock failure!");
+  private volatile Throwable failureException = new IOException("Mock failure!");
 
-  private Behavior(Random random) {
+  private NetworkBehavior(Random random) {
     this.random = random;
   }
 
@@ -85,15 +115,15 @@ public int failurePercent() {
   }
 
   /** Set the exception to be used when a failure is triggered. */
-  public void setFailureException(IOException exception) {
-    if (exception == null) {
-      throw new NullPointerException("exception == null");
+  public void setFailureException(Throwable t) {
+    if (t == null) {
+      throw new NullPointerException("t == null");
     }
-    this.failureException = exception;
+    this.failureException = t;
   }
 
   /** The exception to be used when a failure is triggered. */
-  public IOException failureException() {
+  public Throwable failureException() {
     return failureException;
   }
 
diff --git a/retrofit-mock/src/test/java/retrofit/MockRetrofitTest.java b/retrofit-mock/src/test/java/retrofit/MockRetrofitTest.java
index f1f2d8cdc..55e4549bb 100644
--- a/retrofit-mock/src/test/java/retrofit/MockRetrofitTest.java
+++ b/retrofit-mock/src/test/java/retrofit/MockRetrofitTest.java
@@ -25,11 +25,10 @@
 import java.util.concurrent.atomic.AtomicReference;
 import org.junit.Before;
 import org.junit.Test;
-import retrofit.mock.Behavior;
-import retrofit.mock.BehaviorAdapter;
 import retrofit.mock.CallBehaviorAdapter;
 import retrofit.mock.Calls;
 import retrofit.mock.MockRetrofit;
+import retrofit.mock.NetworkBehavior;
 
 import static java.util.concurrent.Executors.newSingleThreadExecutor;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
@@ -45,7 +44,7 @@
   }
 
   private final IOException mockFailure = new IOException("Timeout!");
-  private final Behavior behavior = Behavior.create(new Random(2847));
+  private final NetworkBehavior behavior = NetworkBehavior.create(new Random(2847));
   private DoWorkService service;
 
   @Before public void setUp() {
@@ -63,8 +62,9 @@
       }
     };
 
-    BehaviorAdapter<?> adapter = new CallBehaviorAdapter(retrofit, newSingleThreadExecutor());
-    MockRetrofit mockRetrofit = new MockRetrofit(adapter, behavior);
+    NetworkBehavior.Adapter<?> adapter =
+        new CallBehaviorAdapter(retrofit, newSingleThreadExecutor());
+    MockRetrofit mockRetrofit = new MockRetrofit(behavior, adapter);
     service = mockRetrofit.create(DoWorkService.class, mockService);
   }
 
diff --git a/retrofit-mock/src/test/java/retrofit/BehaviorTest.java b/retrofit-mock/src/test/java/retrofit/NetworkBehaviorTest.java
similarity index 95%
rename from retrofit-mock/src/test/java/retrofit/BehaviorTest.java
rename to retrofit-mock/src/test/java/retrofit/NetworkBehaviorTest.java
index 46b75be17..916e8cf5c 100644
--- a/retrofit-mock/src/test/java/retrofit/BehaviorTest.java
+++ b/retrofit-mock/src/test/java/retrofit/NetworkBehaviorTest.java
@@ -17,15 +17,15 @@
 
 import java.util.Random;
 import org.junit.Test;
-import retrofit.mock.Behavior;
+import retrofit.mock.NetworkBehavior;
 
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static java.util.concurrent.TimeUnit.SECONDS;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
-public final class BehaviorTest {
-  private final Behavior behavior = Behavior.create(new Random(2847));
+public final class NetworkBehaviorTest {
+  private final NetworkBehavior behavior = NetworkBehavior.create(new Random(2847));
 
   @Test public void delayMustBePositive() {
     try {
diff --git a/retrofit/pom.xml b/retrofit/pom.xml
index b4e355270..a6d9f5496 100644
--- a/retrofit/pom.xml
+++ b/retrofit/pom.xml
@@ -25,6 +25,12 @@
       <optional>true</optional>
     </dependency>
 
+    <dependency>
+      <groupId>org.codehaus.mojo</groupId>
+      <artifactId>animal-sniffer-annotations</artifactId>
+      <optional>true</optional>
+    </dependency>
+
     <dependency>
       <groupId>junit</groupId>
       <artifactId>junit</artifactId>
diff --git a/retrofit/src/main/java/retrofit/Converter.java b/retrofit/src/main/java/retrofit/Converter.java
index 5df86878a..6a82784a8 100644
--- a/retrofit/src/main/java/retrofit/Converter.java
+++ b/retrofit/src/main/java/retrofit/Converter.java
@@ -20,7 +20,11 @@
 import java.io.IOException;
 import java.lang.reflect.Type;
 
-/** Convert objects to and from their representation as HTTP bodies. */
+/**
+ * Convert objects to and from their representation as HTTP bodies. Register a converter with
+ * Retrofit using {@link Retrofit.Builder#addConverter(Type, Converter)} or {@link
+ * Retrofit.Builder#addConverterFactory(Factory)}.
+ */
 public interface Converter<T> {
   /** Convert an HTTP response body to a concrete object of the specified type. */
   T fromBody(ResponseBody body) throws IOException;
diff --git a/retrofit/src/main/java/retrofit/ExecutorCallAdapterFactory.java b/retrofit/src/main/java/retrofit/ExecutorCallAdapterFactory.java
index d9af81ca4..cbe6c27a7 100644
--- a/retrofit/src/main/java/retrofit/ExecutorCallAdapterFactory.java
+++ b/retrofit/src/main/java/retrofit/ExecutorCallAdapterFactory.java
@@ -26,10 +26,6 @@
     this.callbackExecutor = callbackExecutor;
   }
 
-  @Override public String toString() {
-    return "ExecutorCallAdapterFactory[" + callbackExecutor + ']';
-  }
-
   @Override public CallAdapter<?> get(Type returnType) {
     if (Utils.getRawType(returnType) != Call.class) {
       return null;
diff --git a/retrofit/src/main/java/retrofit/OkHttpCall.java b/retrofit/src/main/java/retrofit/OkHttpCall.java
index f9f64ba60..5e34cadcc 100644
--- a/retrofit/src/main/java/retrofit/OkHttpCall.java
+++ b/retrofit/src/main/java/retrofit/OkHttpCall.java
@@ -48,7 +48,7 @@
     return new OkHttpCall<>(client, requestFactory, responseConverter, args);
   }
 
-  public void enqueue(final Callback<T> callback) {
+  @Override public void enqueue(final Callback<T> callback) {
     synchronized (this) {
       if (executed) throw new IllegalStateException("Already executed");
       executed = true;
diff --git a/retrofit/src/main/java/retrofit/Platform.java b/retrofit/src/main/java/retrofit/Platform.java
index 845b61c47..b27dd9d6e 100644
--- a/retrofit/src/main/java/retrofit/Platform.java
+++ b/retrofit/src/main/java/retrofit/Platform.java
@@ -19,8 +19,11 @@
 import android.os.Handler;
 import android.os.Looper;
 import com.squareup.okhttp.OkHttpClient;
+import java.lang.invoke.MethodHandles;
+import java.lang.reflect.Method;
 import java.util.concurrent.Executor;
 import java.util.concurrent.TimeUnit;
+import org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement;
 
 class Platform {
   private static final Platform PLATFORM = findPlatform();
@@ -37,7 +40,11 @@ private static Platform findPlatform() {
       }
     } catch (ClassNotFoundException ignored) {
     }
-
+    try {
+      Class.forName("java.util.Optional");
+      return new Java8();
+    } catch (ClassNotFoundException ignored) {
+    }
     return new Platform();
   }
 
@@ -56,7 +63,31 @@ OkHttpClient defaultClient() {
     return client;
   }
 
-  /** Provides sane defaults for operation on Android. */
+  boolean isDefaultMethod(Method method) {
+    return false;
+  }
+
+  Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object, Object... args)
+      throws Throwable {
+    throw new UnsupportedOperationException();
+  }
+
+  @IgnoreJRERequirement // Only classloaded and used on Java 8.
+  static class Java8 extends Platform {
+    @Override boolean isDefaultMethod(Method method) {
+      return method.isDefault();
+    }
+
+    @Override Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object,
+        Object... args) throws Throwable {
+      return MethodHandles.lookup()
+          .in(declaringClass)
+          .unreflectSpecial(method, declaringClass)
+          .bindTo(object)
+          .invokeWithArguments(args);
+    }
+  }
+
   static class Android extends Platform {
     @Override CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) {
       if (callbackExecutor == null) {
@@ -71,10 +102,6 @@ OkHttpClient defaultClient() {
       @Override public void execute(Runnable r) {
         handler.post(r);
       }
-
-      @Override public String toString() {
-        return "MainThreadExecutor";
-      }
     }
   }
 }
diff --git a/retrofit/src/main/java/retrofit/RequestBuilder.java b/retrofit/src/main/java/retrofit/RequestBuilder.java
index 79ab64e76..60bde3630 100644
--- a/retrofit/src/main/java/retrofit/RequestBuilder.java
+++ b/retrofit/src/main/java/retrofit/RequestBuilder.java
@@ -38,7 +38,7 @@
   private HttpUrl.Builder urlBuilder;
 
   private final Request.Builder requestBuilder;
-  private MediaType mediaType;
+  private MediaType contentType;
 
   private final boolean hasBody;
   private MultipartBuilder multipartBuilder;
@@ -46,20 +46,17 @@
   private RequestBody body;
 
   RequestBuilder(String method, HttpUrl baseUrl, String relativeUrl, Headers headers,
-      MediaType mediaType, boolean hasBody, boolean isFormEncoded, boolean isMultipart) {
+      MediaType contentType, boolean hasBody, boolean isFormEncoded, boolean isMultipart) {
     this.method = method;
-
     this.baseUrl = baseUrl;
     this.relativeUrl = relativeUrl;
+    this.requestBuilder = new Request.Builder();
+    this.contentType = contentType;
+    this.hasBody = hasBody;
 
-    Request.Builder requestBuilder = new Request.Builder();
     if (headers != null) {
       requestBuilder.headers(headers);
     }
-    this.requestBuilder = requestBuilder;
-    this.mediaType = mediaType;
-
-    this.hasBody = hasBody;
 
     if (isFormEncoded) {
       // Will be set to 'body' in 'build'.
@@ -84,7 +81,7 @@ void addHeader(String name, Object value) {
       stringValue = value.toString();
     }
     if ("Content-Type".equalsIgnoreCase(name)) {
-      mediaType = MediaType.parse(stringValue);
+      contentType = MediaType.parse(stringValue);
     } else {
       requestBuilder.addHeader(name, stringValue);
     }
@@ -165,12 +162,12 @@ Request build() {
       }
     }
 
-    MediaType mediaType = this.mediaType;
-    if (mediaType != null) {
+    MediaType contentType = this.contentType;
+    if (contentType != null) {
       if (body != null) {
-        body = new MediaTypeOverridingRequestBody(body, mediaType);
+        body = new ContentTypeOverridingRequestBody(body, contentType);
       } else {
-        requestBuilder.addHeader("Content-Type", mediaType.toString());
+        requestBuilder.addHeader("Content-Type", contentType.toString());
       }
     }
 
@@ -180,17 +177,17 @@ Request build() {
         .build();
   }
 
-  private static class MediaTypeOverridingRequestBody extends RequestBody {
+  private static class ContentTypeOverridingRequestBody extends RequestBody {
     private final RequestBody delegate;
-    private final MediaType mediaType;
+    private final MediaType contentType;
 
-    MediaTypeOverridingRequestBody(RequestBody delegate, MediaType mediaType) {
+    ContentTypeOverridingRequestBody(RequestBody delegate, MediaType contentType) {
       this.delegate = delegate;
-      this.mediaType = mediaType;
+      this.contentType = contentType;
     }
 
     @Override public MediaType contentType() {
-      return mediaType;
+      return contentType;
     }
 
     @Override public long contentLength() throws IOException {
diff --git a/retrofit/src/main/java/retrofit/RequestFactory.java b/retrofit/src/main/java/retrofit/RequestFactory.java
index 63527aabe..0e1668198 100644
--- a/retrofit/src/main/java/retrofit/RequestFactory.java
+++ b/retrofit/src/main/java/retrofit/RequestFactory.java
@@ -24,20 +24,20 @@
   private final BaseUrl baseUrl;
   private final String relativeUrl;
   private final Headers headers;
-  private final MediaType mediaType;
+  private final MediaType contentType;
   private final boolean hasBody;
   private final boolean isFormEncoded;
   private final boolean isMultipart;
   private final RequestBuilderAction[] requestBuilderActions;
 
   RequestFactory(String method, BaseUrl baseUrl, String relativeUrl, Headers headers,
-      MediaType mediaType, boolean hasBody, boolean isFormEncoded, boolean isMultipart,
+      MediaType contentType, boolean hasBody, boolean isFormEncoded, boolean isMultipart,
       RequestBuilderAction[] requestBuilderActions) {
     this.method = method;
     this.baseUrl = baseUrl;
     this.relativeUrl = relativeUrl;
     this.headers = headers;
-    this.mediaType = mediaType;
+    this.contentType = contentType;
     this.hasBody = hasBody;
     this.isFormEncoded = isFormEncoded;
     this.isMultipart = isMultipart;
@@ -46,7 +46,7 @@
 
   Request create(Object... args) {
     RequestBuilder requestBuilder =
-        new RequestBuilder(method, baseUrl.url(), relativeUrl, headers, mediaType, hasBody,
+        new RequestBuilder(method, baseUrl.url(), relativeUrl, headers, contentType, hasBody,
             isFormEncoded, isMultipart);
 
     if (args != null) {
diff --git a/retrofit/src/main/java/retrofit/RequestFactoryParser.java b/retrofit/src/main/java/retrofit/RequestFactoryParser.java
index 01da14846..78ac91b24 100644
--- a/retrofit/src/main/java/retrofit/RequestFactoryParser.java
+++ b/retrofit/src/main/java/retrofit/RequestFactoryParser.java
@@ -71,7 +71,7 @@ static RequestFactory parse(Method method, BaseUrl baseUrl,
   private boolean isMultipart;
   private String relativeUrl;
   private com.squareup.okhttp.Headers headers;
-  private MediaType mediaType;
+  private MediaType contentType;
   private RequestBuilderAction[] requestBuilderActions;
 
   private Set<String> relativeUrlParamNames;
@@ -81,7 +81,7 @@ private RequestFactoryParser(Method method) {
   }
 
   private RequestFactory toRequestFactory(BaseUrl baseUrl) {
-    return new RequestFactory(httpMethod, baseUrl, relativeUrl, headers, mediaType, hasBody,
+    return new RequestFactory(httpMethod, baseUrl, relativeUrl, headers, contentType, hasBody,
         isFormEncoded, isMultipart, requestBuilderActions);
   }
 
@@ -186,7 +186,7 @@ private void parseHttpMethodAndPath(String httpMethod, String value, boolean has
       String headerName = header.substring(0, colon);
       String headerValue = header.substring(colon + 1).trim();
       if ("Content-Type".equalsIgnoreCase(headerName)) {
-        mediaType = MediaType.parse(headerValue);
+        contentType = MediaType.parse(headerValue);
       } else {
         builder.add(headerName, headerValue);
       }
diff --git a/retrofit/src/main/java/retrofit/Retrofit.java b/retrofit/src/main/java/retrofit/Retrofit.java
index 3f0561eac..a1b100952 100644
--- a/retrofit/src/main/java/retrofit/Retrofit.java
+++ b/retrofit/src/main/java/retrofit/Retrofit.java
@@ -22,6 +22,7 @@
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.Method;
 import java.lang.reflect.Proxy;
+import java.lang.reflect.Type;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.LinkedHashMap;
@@ -108,21 +109,25 @@ private Retrofit(OkHttpClient client, BaseUrl baseUrl, List<Converter.Factory> c
 
   /** Create an implementation of the API defined by the {@code service} interface. */
   @SuppressWarnings("unchecked") // Single-interface proxy creation guarded by parameter safety.
-  public <T> T create(Class<T> service) {
-    Utils.validateServiceClass(service);
+  public <T> T create(final Class<T> service) {
+    Utils.validateServiceInterface(service);
     return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service },
-        handler);
-  }
+        new InvocationHandler() {
+          private final Platform platform = Platform.get();
 
-  private final InvocationHandler handler = new InvocationHandler() {
-    @Override public Object invoke(Object proxy, Method method, Object... args) throws Throwable {
-      // If the method is a method from Object then defer to normal invocation.
-      if (method.getDeclaringClass() == Object.class) {
-        return method.invoke(this, args);
-      }
-      return loadMethodHandler(method).invoke(args);
-    }
-  };
+          @Override public Object invoke(Object proxy, Method method, Object... args)
+              throws Throwable {
+            // If the method is a method from Object then defer to normal invocation.
+            if (method.getDeclaringClass() == Object.class) {
+              return method.invoke(this, args);
+            }
+            if (platform.isDefaultMethod(method)) {
+              return platform.invokeDefaultMethod(method, service, proxy, args);
+            }
+            return loadMethodHandler(method).invoke(args);
+          }
+        });
+  }
 
   MethodHandler<?> loadMethodHandler(Method method) {
     MethodHandler<?> handler;
@@ -205,6 +210,21 @@ public Builder baseUrl(BaseUrl baseUrl) {
       return this;
     }
 
+    /** Add converter for serialization and deserialization of {@code type}. */
+    public <T> Builder addConverter(final Type type, final Converter<T> converter) {
+      checkNotNull(type, "type == null");
+      checkNotNull(converter, "converter == null");
+      converterFactories.add(new Converter.Factory() {
+        @Override public Converter<?> get(Type candidate) {
+          return candidate.equals(type) ? converter : null;
+        }
+        @Override public String toString() {
+          return "ConverterFactory(type=" + type + ",converter=" + converter + ")";
+        }
+      });
+      return this;
+    }
+
     /** Add converter factory for serialization and deserialization of objects. */
     public Builder addConverterFactory(Converter.Factory converterFactory) {
       converterFactories.add(checkNotNull(converterFactory, "converterFactory == null"));
diff --git a/retrofit/src/main/java/retrofit/Utils.java b/retrofit/src/main/java/retrofit/Utils.java
index ed35ee92c..620dacb3a 100644
--- a/retrofit/src/main/java/retrofit/Utils.java
+++ b/retrofit/src/main/java/retrofit/Utils.java
@@ -97,22 +97,22 @@ public static ResponseBody readBodyToBytesIfNecessary(final ResponseBody body)
     }
 
     BufferedSource source = body.source();
-    final Buffer buffer = new Buffer();
+    Buffer buffer = new Buffer();
     buffer.writeAll(source);
     source.close();
 
     return ResponseBody.create(body.contentType(), body.contentLength(), buffer);
   }
 
-  public static <T> void validateServiceClass(Class<T> service) {
+  public static <T> void validateServiceInterface(Class<T> service) {
     if (!service.isInterface()) {
-      throw new IllegalArgumentException("Only interface baseUrl definitions are supported.");
+      throw new IllegalArgumentException("API declarations must be interfaces.");
     }
     // Prevent API interfaces from extending other interfaces. This not only avoids a bug in
     // Android (http://b.android.com/58753) but it forces composition of API declarations which is
     // the recommended pattern.
     if (service.getInterfaces().length > 0) {
-      throw new IllegalArgumentException("Interface definitions must not extend other interfaces.");
+      throw new IllegalArgumentException("API interfaces must not extend other interfaces.");
     }
   }
 
diff --git a/retrofit/src/main/java/retrofit/http/Part.java b/retrofit/src/main/java/retrofit/http/Part.java
index 154af6086..0f5913777 100644
--- a/retrofit/src/main/java/retrofit/http/Part.java
+++ b/retrofit/src/main/java/retrofit/http/Part.java
@@ -18,7 +18,7 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
-import retrofit.Retrofit;
+import retrofit.Converter;
 
 import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
@@ -31,7 +31,7 @@
  * <li>If the type is {@link String} the value will also be used directly with a {@code text/plain}
  * content type.</li>
  * <li>Other object types will be converted to an appropriate representation by using
- * {@linkplain Retrofit#converterFactory() a converter}.</li>
+ * {@linkplain Converter a converter}.</li>
  * </ul>
  * <p>
  * Values may be {@code null} which will omit them from the request body.
diff --git a/retrofit/src/main/java/retrofit/http/PartMap.java b/retrofit/src/main/java/retrofit/http/PartMap.java
index 512f3545f..a8d788447 100644
--- a/retrofit/src/main/java/retrofit/http/PartMap.java
+++ b/retrofit/src/main/java/retrofit/http/PartMap.java
@@ -18,7 +18,7 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
-import retrofit.Retrofit;
+import retrofit.Converter;
 
 import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
@@ -31,7 +31,7 @@
  * <li>If the type is {@link String} the value will also be used directly with a {@code text/plain}
  * content type.</li>
  * <li>Other object types will be converted to an appropriate representation by using
- * {@linkplain Retrofit#converterFactory() a converter}.</li>
+ * {@linkplain Converter a converter}.</li>
  * </ul>
  * <p>
  * <pre>
diff --git a/retrofit/src/test/java/retrofit/RetrofitTest.java b/retrofit/src/test/java/retrofit/RetrofitTest.java
index 6934c6c05..4c8c740e3 100644
--- a/retrofit/src/test/java/retrofit/RetrofitTest.java
+++ b/retrofit/src/test/java/retrofit/RetrofitTest.java
@@ -11,6 +11,7 @@
 import java.io.IOException;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
+import java.math.BigInteger;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
@@ -38,6 +39,24 @@
 public final class RetrofitTest {
   @Rule public final MockWebServer server = new MockWebServer();
 
+  static final Converter<BigInteger> bigIntegerConverter = new Converter<BigInteger>() {
+    @Override public BigInteger fromBody(ResponseBody body) throws IOException {
+      return new BigInteger(body.string());
+    }
+    @Override public RequestBody toBody(BigInteger value) {
+      return RequestBody.create(MediaType.parse("text/plain"), value.toString());
+    }
+  };
+  static final Converter<CharSequence> charSequenceConverter = new Converter<CharSequence>() {
+    @Override public CharSequence fromBody(ResponseBody body) throws IOException {
+      return new StringBuilder().append(body.string());
+    }
+
+    @Override public RequestBody toBody(CharSequence value) {
+      return RequestBody.create(MediaType.parse("text/plain"), value.toString());
+    }
+  };
+
   interface CallMethod {
     @GET("/") Call<String> disallowed();
     @POST("/") Call<ResponseBody> disallowed(@Body String body);
@@ -62,6 +81,10 @@
   interface VoidService {
     @GET("/") void nope();
   }
+  interface CustomConverter {
+    @POST("/a") Call<BigInteger> call(@Body BigInteger bigInteger);
+    @POST("/b") Call<CharSequence> call(@Body CharSequence charSequence);
+  }
 
   @SuppressWarnings("EqualsBetweenInconvertibleTypes") // We are explicitly testing this behavior.
   @Test public void objectMethodsStillWork() {
@@ -83,7 +106,7 @@
       retrofit.create(Extending.class);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Interface definitions must not extend other interfaces.");
+      assertThat(e).hasMessage("API interfaces must not extend other interfaces.");
     }
   }
 
@@ -244,7 +267,7 @@
           + "    for method CallMethod.disallowed");
       assertThat(e.getCause()).hasMessage(
           "Could not locate converter for class java.lang.String. Tried:\n"
-              + " * retrofit.RetrofitTest$1\n"
+              + " * retrofit.RetrofitTest$3\n"
               + " * retrofit.OkHttpBodyConverterFactory");
     }
   }
@@ -456,6 +479,43 @@
     assertThat(retrofit.callAdapterFactories()).isNotEmpty();
   }
 
+  @Test public void addConverter() throws Exception {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverter(BigInteger.class, bigIntegerConverter)
+        .addConverter(CharSequence.class, charSequenceConverter)
+        .build();
+    CustomConverter api = retrofit.create(CustomConverter.class);
+
+    server.enqueue(new MockResponse().setBody("456"));
+    assertThat(api.call(new BigInteger("123")).execute().body())
+        .isEqualTo(new BigInteger("456"));
+    assertThat(server.takeRequest().getBody().readUtf8()).isEqualTo("123");
+
+    server.enqueue(new MockResponse().setBody("DEF"));
+    assertThat(api.call(new StringBuilder("ABC")).execute().body())
+        .matches("DEF");
+    assertThat(server.takeRequest().getBody().readUtf8()).isEqualTo("ABC");
+  }
+
+  @Test public void addConverterNullType() throws Exception {
+    try {
+      new Retrofit.Builder().addConverter(null, bigIntegerConverter);
+      fail();
+    } catch (NullPointerException expected) {
+      assertThat(expected).hasMessage("type == null");
+    }
+  }
+
+  @Test public void addConverterNullConverter() throws Exception {
+    try {
+      new Retrofit.Builder().addConverter(BigInteger.class, null);
+      fail();
+    } catch (NullPointerException expected) {
+      assertThat(expected).hasMessage("converter == null");
+    }
+  }
+
   @Test public void callAdapterFactoryPropagated() {
     CallAdapter.Factory factory = mock(CallAdapter.Factory.class);
     Retrofit retrofit = new Retrofit.Builder()
diff --git a/samples/src/main/java/com/example/retrofit/SimpleMockService.java b/samples/src/main/java/com/example/retrofit/SimpleMockService.java
index b05f00844..a591e2be7 100644
--- a/samples/src/main/java/com/example/retrofit/SimpleMockService.java
+++ b/samples/src/main/java/com/example/retrofit/SimpleMockService.java
@@ -14,10 +14,10 @@
 import java.util.concurrent.Executors;
 import retrofit.Call;
 import retrofit.Retrofit;
-import retrofit.mock.Behavior;
 import retrofit.mock.CallBehaviorAdapter;
 import retrofit.mock.Calls;
 import retrofit.mock.MockRetrofit;
+import retrofit.mock.NetworkBehavior;
 
 /**
  * An example of using {@link MockRetrofit} to create a mock service implementation with
@@ -73,14 +73,14 @@ public static void main(String... args) throws IOException {
         .build();
 
     // Create the Behavior object which manages the fake behavior and the background executor.
-    Behavior behavior = Behavior.create();
+    NetworkBehavior behavior = NetworkBehavior.create();
     ExecutorService bg = Executors.newSingleThreadExecutor(new ThreadFactoryBuilder()
         .setNameFormat("mock-retrofit-%d")
         .setDaemon(true)
         .build());
 
     // Create the mock implementation and use MockRetrofit to apply the behavior to it.
-    MockRetrofit mockRetrofit = new MockRetrofit(new CallBehaviorAdapter(retrofit, bg), behavior);
+    MockRetrofit mockRetrofit = new MockRetrofit(behavior, new CallBehaviorAdapter(retrofit, bg));
     MockGitHub mockGitHub = new MockGitHub();
     GitHub gitHub = mockRetrofit.create(GitHub.class, mockGitHub);
 
diff --git a/website/index.html b/website/index.html
index fbbda6a98..9225a7611 100644
--- a/website/index.html
+++ b/website/index.html
@@ -195,7 +195,7 @@ <h4>Content format Agnostic</h4>
 
 SoundCloudService service = retrofit.create(SoundCloudService.class);</pre>
             <h4>Custom Converters</h4>
-            <p>If you need to communicate with an API that uses a content-format that Retrofit does not support out of the box (e.g. YAML, txt, custom format) or you wish to use a different library to implement an existing format, you can easily create your own converter. Create a class that implements the <a href="https://github.com/square/retrofit/blob/master/retrofit/src/main/java/retrofit/converter/Converter.java"><code>Converter</code> interface</a> and pass in an instance when building your adapter.</p>
+            <p>If you need to communicate with an API that uses a content-format that Retrofit does not support out of the box (e.g. YAML, txt, custom format) or you wish to use a different library to implement an existing format, you can easily create your own converter. Create a class that implements the <a href="https://github.com/square/retrofit/blob/master/retrofit/src/main/java/retrofit/Converter.java"><code>Converter</code> interface</a> and pass in an instance when building your adapter.</p>
             <h4>Custom Error Handling</h4>
             <p>If you need custom error handling for requests, you may provide your own <code>ErrorHandler</code>. The following code shows how to throw a custom exception when a response returns a HTTP 401 status code</p>
             <pre class="prettyprint">
@@ -238,7 +238,7 @@ <h4>Gradle</h4>
             <pre class="prettyprint">
 compile 'com.squareup.retrofit:retrofit:<span class="version pln"><em>(insert latest version)</em></span>'
 </pre>
-            <p>Retrofit requires at minimum Java 6 or Android 2.3.</p>
+            <p>Retrofit requires at minimum Java 7 or Android 2.3.</p>
 
             <h4>Integration with OkHttp</h4>
             <p>Retrofit will automatically use OkHttp (version 2.0 or newer) when it is present.</p>
