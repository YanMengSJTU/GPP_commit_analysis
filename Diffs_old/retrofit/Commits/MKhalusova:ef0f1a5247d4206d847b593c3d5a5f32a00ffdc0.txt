diff --git a/retrofit/src/test/java/retrofit2/RequestBuilderTest.java b/retrofit/src/test/java/retrofit2/RequestBuilderTest.java
index 907316e2f..7d0592bb9 100644
--- a/retrofit/src/test/java/retrofit2/RequestBuilderTest.java
+++ b/retrofit/src/test/java/retrofit2/RequestBuilderTest.java
@@ -15,48 +15,20 @@
  */
 package retrofit2;
 
-import java.io.IOException;
-import java.lang.reflect.Method;
-import java.math.BigInteger;
-import java.net.URI;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.atomic.AtomicReference;
-import okhttp3.HttpUrl;
-import okhttp3.MediaType;
-import okhttp3.MultipartBody;
-import okhttp3.Request;
-import okhttp3.RequestBody;
-import okhttp3.ResponseBody;
+import okhttp3.*;
 import okio.Buffer;
 import org.junit.Ignore;
 import org.junit.Test;
 import retrofit2.helpers.ToStringConverterFactory;
-import retrofit2.http.Body;
-import retrofit2.http.DELETE;
-import retrofit2.http.Field;
-import retrofit2.http.FieldMap;
-import retrofit2.http.FormUrlEncoded;
-import retrofit2.http.GET;
-import retrofit2.http.HEAD;
-import retrofit2.http.HTTP;
-import retrofit2.http.Header;
+import retrofit2.http.*;
 import retrofit2.http.Headers;
-import retrofit2.http.Multipart;
-import retrofit2.http.OPTIONS;
-import retrofit2.http.PATCH;
-import retrofit2.http.POST;
-import retrofit2.http.PUT;
-import retrofit2.http.Part;
-import retrofit2.http.PartMap;
-import retrofit2.http.Path;
-import retrofit2.http.Query;
-import retrofit2.http.QueryMap;
-import retrofit2.http.Url;
+
+import java.io.IOException;
+import java.lang.reflect.Method;
+import java.math.BigInteger;
+import java.net.URI;
+import java.util.*;
+import java.util.concurrent.atomic.AtomicReference;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.assertNull;
@@ -110,7 +82,7 @@
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "Only one encoding annotation is allowed.\n    for method Example.method");
+              "Only one encoding annotation is allowed.\n    for method Example.method");
     }
   }
 
@@ -128,7 +100,7 @@
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "Only one encoding annotation is allowed.\n    for method Example.method");
+              "Only one encoding annotation is allowed.\n    for method Example.method");
     }
   }
 
@@ -145,8 +117,8 @@
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "@Path parameter name must match \\{([a-zA-Z][a-zA-Z0-9_-]*)\\}."
-              + " Found: hey! (parameter #1)\n    for method Example.method");
+              "@Path parameter name must match \\{([a-zA-Z][a-zA-Z0-9_-]*)\\}."
+                      + " Found: hey! (parameter #1)\n    for method Example.method");
     }
   }
 
@@ -162,8 +134,8 @@
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "URL query string \"bar={bar}\" must not have replace block."
-              + " For dynamic query parameters use @Query.\n    for method Example.method");
+              "URL query string \"bar={bar}\" must not have replace block."
+                      + " For dynamic query parameters use @Query.\n    for method Example.method");
     }
   }
 
@@ -179,7 +151,7 @@
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "Multiple Retrofit annotations found, only one allowed. (parameter #1)\n    for method Example.method");
+              "Multiple Retrofit annotations found, only one allowed. (parameter #1)\n    for method Example.method");
     }
   }
 
@@ -210,7 +182,7 @@
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "Only one HTTP method is allowed. Found: PATCH and POST.\n    for method Example.method");
+              "Only one HTTP method is allowed. Found: PATCH and POST.\n    for method Example.method");
     }
   }
 
@@ -225,7 +197,7 @@
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "HTTP method annotation is required (e.g., @GET, @POST, etc.).\n    for method Example.method");
+              "HTTP method annotation is required (e.g., @GET, @POST, etc.).\n    for method Example.method");
     }
   }
 
@@ -241,7 +213,7 @@
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "@Part parameters can only be used with multipart encoding. (parameter #1)\n    for method Example.method");
+              "@Part parameters can only be used with multipart encoding. (parameter #1)\n    for method Example.method");
     }
   }
 
@@ -257,7 +229,7 @@
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "@PartMap parameters can only be used with multipart encoding. (parameter #1)\n    for method Example.method");
+              "@PartMap parameters can only be used with multipart encoding. (parameter #1)\n    for method Example.method");
     }
   }
 
@@ -274,7 +246,7 @@
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "Multipart can only be specified on HTTP methods with request body (e.g., @POST).\n    for method Example.method");
+              "Multipart can only be specified on HTTP methods with request body (e.g., @POST).\n    for method Example.method");
     }
   }
 
@@ -291,7 +263,7 @@
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "Multipart method must contain at least one @Part.\n    for method Example.method");
+              "Multipart method must contain at least one @Part.\n    for method Example.method");
     }
   }
 
@@ -307,7 +279,7 @@
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "@Field parameters can only be used with form encoding. (parameter #1)\n    for method Example.method");
+              "@Field parameters can only be used with form encoding. (parameter #1)\n    for method Example.method");
     }
   }
 
@@ -323,7 +295,7 @@
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "@FieldMap parameters can only be used with form encoding. (parameter #1)\n    for method Example.method");
+              "@FieldMap parameters can only be used with form encoding. (parameter #1)\n    for method Example.method");
     }
   }
 
@@ -340,7 +312,7 @@
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "FormUrlEncoded can only be specified on HTTP methods with request body (e.g., @POST).\n    for method Example.method");
+              "FormUrlEncoded can only be specified on HTTP methods with request body (e.g., @POST).\n    for method Example.method");
     }
   }
 
@@ -389,7 +361,7 @@
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "@Headers value must be in the form \"Name: Value\". Found: \"Malformed\"\n    for method Example.method");
+              "@Headers value must be in the form \"Name: Value\". Found: \"Malformed\"\n    for method Example.method");
     }
   }
 
@@ -405,7 +377,7 @@
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "URL \"/{a}\" does not contain \"{b}\". (parameter #2)\n    for method Example.method");
+              "URL \"/{a}\" does not contain \"{b}\". (parameter #2)\n    for method Example.method");
     }
   }
 
@@ -421,7 +393,7 @@
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "No Retrofit annotation found. (parameter #1)\n    for method Example.method");
+              "No Retrofit annotation found. (parameter #1)\n    for method Example.method");
     }
   }
 
@@ -437,7 +409,7 @@
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "Non-body HTTP method cannot contain @Body.\n    for method Example.method");
+              "Non-body HTTP method cannot contain @Body.\n    for method Example.method");
     }
   }
 
@@ -453,7 +425,7 @@
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "@QueryMap parameter type must be Map. (parameter #1)\n    for method Example.method");
+              "@QueryMap parameter type must be Map. (parameter #1)\n    for method Example.method");
     }
   }
 
@@ -531,6 +503,119 @@
     }
   }
 
+  @Test public void getWithHeaderMap() {
+    class Example {
+      @GET("/search")
+      Call<ResponseBody> method(@HeaderMap Map<String, Object> headers) {
+        return null;
+      }
+    }
+
+    Map<String, Object> headers = new LinkedHashMap<>();
+    headers.put("Accept", "text/plain");
+    headers.put("Accept-Charset", "utf-8");
+
+    Request request = buildRequest(Example.class, headers);
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/search");
+    assertThat(request.body()).isNull();
+    assertThat(request.headers().size()).isEqualTo(2);
+    assertThat(request.header("Accept")).isEqualTo("text/plain");
+    assertThat(request.header("Accept-Charset")).isEqualTo("utf-8");
+  }
+
+  @Test public void headerMapMustBeAMap() {
+    class Example {
+      @GET("/")
+      Call<ResponseBody> method(@HeaderMap List<String> headers) {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+              "@HeaderMap parameter type must be Map. (parameter #1)\n    for method Example.method");
+    }
+  }
+
+  @Test public void headerMapSupportsSubclasses() {
+    class Foo extends HashMap<String, String> {
+    }
+
+    class Example {
+      @GET("/search")
+      Call<ResponseBody> method(@HeaderMap Foo headers) {
+        return null;
+      }
+    }
+
+    Foo headers = new Foo();
+    headers.put("Accept", "text/plain");
+
+    Request request = buildRequest(Example.class, headers);
+    assertThat(request.url().toString()).isEqualTo("http://example.com/search");
+    assertThat(request.headers().size()).isEqualTo(1);
+    assertThat(request.header("Accept")).isEqualTo("text/plain");
+  }
+
+  @Test public void headerMapRejectsNull() {
+    class Example {
+      @GET("/")
+      Call<ResponseBody> method(@HeaderMap Map<String, String> headers) {
+        return null;
+      }
+    }
+
+    try {
+      buildRequest(Example.class, (Map<String, String>) null);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Header map was null.");
+    }
+  }
+
+  @Test public void headerMapRejectsNullKeys() {
+    class Example {
+      @GET("/")
+      Call<ResponseBody> method(@HeaderMap Map<String, String> headers) {
+        return null;
+      }
+    }
+
+    Map<String, String> headers = new LinkedHashMap<>();
+    headers.put("Accept", "text/plain");
+    headers.put(null, "utf-8");
+
+    try {
+      buildRequest(Example.class, headers);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Header map contained null key.");
+    }
+  }
+
+  @Test public void headerMapRejectsNullValues() {
+    class Example {
+      @GET("/")
+      Call<ResponseBody> method(@HeaderMap Map<String, String> headers) {
+        return null;
+      }
+    }
+
+    Map<String, String> headers = new LinkedHashMap<>();
+    headers.put("Accept", "text/plain");
+    headers.put("Accept-Charset", null);
+
+    try {
+      buildRequest(Example.class, headers);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Header map contained null value for key 'Accept-Charset'.");
+    }
+  }
+
   @Test public void twoBodies() {
     class Example {
       @PUT("/") //
@@ -543,7 +628,7 @@
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "Multiple @Body method annotations found. (parameter #2)\n    for method Example.method");
+              "Multiple @Body method annotations found. (parameter #2)\n    for method Example.method");
     }
   }
 
@@ -560,7 +645,7 @@
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "@Body parameters cannot be used with form or multi-part encoding. (parameter #2)\n    for method Example.method");
+              "@Body parameters cannot be used with form or multi-part encoding. (parameter #2)\n    for method Example.method");
     }
   }
 
@@ -617,7 +702,7 @@
       buildRequest(Example.class);
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "HEAD method must use Void as response type.\n    for method Example.method");
+              "HEAD method must use Void as response type.\n    for method Example.method");
     }
   }
 
@@ -822,7 +907,7 @@
     class Example {
       @GET("/foo/bar/") //
       Call<ResponseBody> method(@Query("foo") String foo, @Query("ping") String ping,
-          @Query("kit") String kit) {
+                                @Query("kit") String kit) {
         return null;
       }
     }
@@ -862,7 +947,7 @@
     class Example {
       @GET("/foo/bar/{ping}/") //
       Call<ResponseBody> method(@Path("ping") String ping, @Query("kit") String kit,
-          @Query("riff") String riff) {
+                                @Query("riff") String riff) {
         return null;
       }
     }
@@ -887,7 +972,7 @@
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage("A @Path parameter must not come after a @Query. (parameter #2)\n"
-          + "    for method Example.method");
+              + "    for method Example.method");
     }
   }
 
@@ -1156,9 +1241,9 @@
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "@Url must be okhttp3.HttpUrl, String, java.net.URI, or android.net.Uri type."
-              + " (parameter #1)\n"
-              + "    for method Example.method");
+              "@Url must be okhttp3.HttpUrl, String, java.net.URI, or android.net.Uri type."
+                      + " (parameter #1)\n"
+                      + "    for method Example.method");
     }
   }
 
@@ -1175,7 +1260,7 @@
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage("@Url cannot be used with @GET URL (parameter #1)\n"
-          + "    for method Example.method");
+              + "    for method Example.method");
     }
   }
 
@@ -1192,7 +1277,7 @@
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage("Missing either @GET URL or @Url parameter.\n"
-          + "    for method Example.method");
+              + "    for method Example.method");
     }
   }
 
@@ -1209,7 +1294,7 @@
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage("@Path parameters may not be used with @Url. (parameter #2)\n"
-          + "    for method Example.method");
+              + "    for method Example.method");
     }
   }
 
@@ -1226,7 +1311,7 @@
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage("@Path can only be used with relative url on @GET (parameter #1)\n"
-          + "    for method Example.method");
+              + "    for method Example.method");
     }
   }
 
@@ -1243,7 +1328,7 @@
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage("A @Url parameter must not come after a @Query (parameter #2)\n"
-          + "    for method Example.method");
+              + "    for method Example.method");
     }
   }
 
@@ -1375,7 +1460,7 @@
     }
 
     Request request = buildRequest(Example.class, "pong", RequestBody.create(
-        MediaType.parse("text/plain"), "kat"));
+            MediaType.parse("text/plain"), "kat"));
     assertThat(request.method()).isEqualTo("POST");
     assertThat(request.headers().size()).isZero();
     assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
@@ -1386,14 +1471,14 @@
     String bodyString = buffer.readUtf8();
 
     assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"ping\"\r\n")
-        .contains("\r\npong\r\n--");
+            .contains("Content-Disposition: form-data;")
+            .contains("name=\"ping\"\r\n")
+            .contains("\r\npong\r\n--");
 
     assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"kit\"")
-        .contains("\r\nkat\r\n--");
+            .contains("Content-Disposition: form-data;")
+            .contains("name=\"kit\"")
+            .contains("\r\nkat\r\n--");
   }
 
   @Test public void multipartArray() throws IOException {
@@ -1406,7 +1491,7 @@
     }
 
     Request request =
-        buildRequest(Example.class, new Object[] { new String[] { "pong1", "pong2" } });
+            buildRequest(Example.class, new Object[] { new String[] { "pong1", "pong2" } });
     assertThat(request.method()).isEqualTo("POST");
     assertThat(request.headers().size()).isZero();
     assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
@@ -1417,14 +1502,14 @@
     String bodyString = buffer.readUtf8();
 
     assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"ping\"\r\n")
-        .contains("\r\npong1\r\n--");
+            .contains("Content-Disposition: form-data;")
+            .contains("name=\"ping\"\r\n")
+            .contains("\r\npong1\r\n--");
 
     assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"ping\"")
-        .contains("\r\npong2\r\n--");
+            .contains("Content-Disposition: form-data;")
+            .contains("name=\"ping\"")
+            .contains("\r\npong2\r\n--");
   }
 
   @Test public void multipartRequiresName() {
@@ -1441,8 +1526,46 @@
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "@Part annotation must supply a name or use MultipartBody.Part parameter type. (parameter #1)\n"
-              + "    for method Example.method");
+              "@Part annotation must supply a name or use MultipartBody.Part parameter type. (parameter #1)\n"
+                      + "    for method Example.method");
+    }
+  }
+
+  @Test public void multipartIterableRequiresName() {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method(@Part List<RequestBody> part) {
+        return null;
+      }
+    }
+
+    try {
+      buildRequest(Example.class, new Object[] { null });
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+              "@Part annotation must supply a name or use MultipartBody.Part parameter type. (parameter #1)\n"
+                      + "    for method Example.method");
+    }
+  }
+
+  @Test public void multipartArrayRequiresName() {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method(@Part RequestBody[] part) {
+        return null;
+      }
+    }
+
+    try {
+      buildRequest(Example.class, new Object[] { null });
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+              "@Part annotation must supply a name or use MultipartBody.Part parameter type. (parameter #1)\n"
+                      + "    for method Example.method");
     }
   }
 
@@ -1460,8 +1583,8 @@
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "@Part parameters using the MultipartBody.Part must not include a part name in the annotation. (parameter #1)\n"
-              + "    for method Example.method");
+              "@Part parameters using the MultipartBody.Part must not include a part name in the annotation. (parameter #1)\n"
+                      + "    for method Example.method");
     }
   }
 
@@ -1486,9 +1609,74 @@
     String bodyString = buffer.readUtf8();
 
     assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"kit\"\r\n")
-        .contains("\r\nkat\r\n--");
+            .contains("Content-Disposition: form-data;")
+            .contains("name=\"kit\"\r\n")
+            .contains("\r\nkat\r\n--");
+  }
+
+  @Test public void multipartOkHttpIterablePart() throws IOException {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method(@Part List<MultipartBody.Part> part) {
+        return null;
+      }
+    }
+
+    MultipartBody.Part part1 = MultipartBody.Part.createFormData("foo", "bar");
+    MultipartBody.Part part2 = MultipartBody.Part.createFormData("kit", "kat");
+    Request request = buildRequest(Example.class, Arrays.asList(part1, part2));
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+
+    RequestBody body = request.body();
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    String bodyString = buffer.readUtf8();
+
+    assertThat(bodyString)
+            .contains("Content-Disposition: form-data;")
+            .contains("name=\"foo\"\r\n")
+            .contains("\r\nbar\r\n--");
+
+    assertThat(bodyString)
+            .contains("Content-Disposition: form-data;")
+            .contains("name=\"kit\"\r\n")
+            .contains("\r\nkat\r\n--");
+  }
+
+  @Test public void multipartOkHttpArrayPart() throws IOException {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method(@Part MultipartBody.Part[] part) {
+        return null;
+      }
+    }
+
+    MultipartBody.Part part1 = MultipartBody.Part.createFormData("foo", "bar");
+    MultipartBody.Part part2 = MultipartBody.Part.createFormData("kit", "kat");
+    Request request =
+            buildRequest(Example.class, new Object[] { new MultipartBody.Part[] { part1, part2 } });
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+
+    RequestBody body = request.body();
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    String bodyString = buffer.readUtf8();
+
+    assertThat(bodyString)
+            .contains("Content-Disposition: form-data;")
+            .contains("name=\"foo\"\r\n")
+            .contains("\r\nbar\r\n--");
+
+    assertThat(bodyString)
+            .contains("Content-Disposition: form-data;")
+            .contains("name=\"kit\"\r\n")
+            .contains("\r\nkat\r\n--");
   }
 
   @Test public void multipartOkHttpPartWithFilename() throws IOException {
@@ -1501,7 +1689,7 @@
     }
 
     MultipartBody.Part part =
-        MultipartBody.Part.createFormData("kit", "kit.txt", RequestBody.create(null, "kat"));
+            MultipartBody.Part.createFormData("kit", "kit.txt", RequestBody.create(null, "kat"));
     Request request = buildRequest(Example.class, part);
     assertThat(request.method()).isEqualTo("POST");
     assertThat(request.headers().size()).isZero();
@@ -1513,9 +1701,9 @@
     String bodyString = buffer.readUtf8();
 
     assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"kit\"; filename=\"kit.txt\"\r\n")
-        .contains("\r\nkat\r\n--");
+            .contains("Content-Disposition: form-data;")
+            .contains("name=\"kit\"; filename=\"kit.txt\"\r\n")
+            .contains("\r\nkat\r\n--");
   }
 
   @Test public void multipartIterable() throws IOException {
@@ -1538,14 +1726,52 @@
     String bodyString = buffer.readUtf8();
 
     assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"ping\"\r\n")
-        .contains("\r\npong1\r\n--");
+            .contains("Content-Disposition: form-data;")
+            .contains("name=\"ping\"\r\n")
+            .contains("\r\npong1\r\n--");
 
     assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"ping\"")
-        .contains("\r\npong2\r\n--");
+            .contains("Content-Disposition: form-data;")
+            .contains("name=\"ping\"")
+            .contains("\r\npong2\r\n--");
+  }
+
+  @Test public void multipartIterableOkHttpPart() {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method(@Part("ping") List<MultipartBody.Part> part) {
+        return null;
+      }
+    }
+
+    try {
+      buildRequest(Example.class, new Object[] { null });
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+              "@Part parameters using the MultipartBody.Part must not include a part name in the annotation. (parameter #1)\n"
+                      + "    for method Example.method");
+    }
+  }
+
+  @Test public void multipartArrayOkHttpPart() {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method(@Part("ping") MultipartBody.Part[] part) {
+        return null;
+      }
+    }
+
+    try {
+      buildRequest(Example.class, new Object[] { null });
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+              "@Part parameters using the MultipartBody.Part must not include a part name in the annotation. (parameter #1)\n"
+                      + "    for method Example.method");
+    }
   }
 
   @Test public void multipartWithEncoding() throws IOException {
@@ -1553,13 +1779,13 @@
       @Multipart //
       @POST("/foo/bar/") //
       Call<ResponseBody> method(@Part(value = "ping", encoding = "8-bit") String ping,
-          @Part(value = "kit", encoding = "7-bit") RequestBody kit) {
+                                @Part(value = "kit", encoding = "7-bit") RequestBody kit) {
         return null;
       }
     }
 
     Request request = buildRequest(Example.class, "pong", RequestBody.create(
-        MediaType.parse("text/plain"), "kat"));
+            MediaType.parse("text/plain"), "kat"));
     assertThat(request.method()).isEqualTo("POST");
     assertThat(request.headers().size()).isZero();
     assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
@@ -1570,16 +1796,16 @@
     String bodyString = buffer.readUtf8();
 
     assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"ping\"\r\n")
-        .contains("Content-Transfer-Encoding: 8-bit")
-        .contains("\r\npong\r\n--");
+            .contains("Content-Disposition: form-data;")
+            .contains("name=\"ping\"\r\n")
+            .contains("Content-Transfer-Encoding: 8-bit")
+            .contains("\r\npong\r\n--");
 
     assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"kit\"")
-        .contains("Content-Transfer-Encoding: 7-bit")
-        .contains("\r\nkat\r\n--");
+            .contains("Content-Disposition: form-data;")
+            .contains("name=\"kit\"")
+            .contains("Content-Transfer-Encoding: 7-bit")
+            .contains("\r\nkat\r\n--");
   }
 
   @Test public void multipartPartMap() throws IOException {
@@ -1606,14 +1832,14 @@
     String bodyString = buffer.readUtf8();
 
     assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"ping\"\r\n")
-        .contains("\r\npong\r\n--");
+            .contains("Content-Disposition: form-data;")
+            .contains("name=\"ping\"\r\n")
+            .contains("\r\npong\r\n--");
 
     assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"kit\"")
-        .contains("\r\nkat\r\n--");
+            .contains("Content-Disposition: form-data;")
+            .contains("name=\"kit\"")
+            .contains("\r\nkat\r\n--");
   }
 
   @Test public void multipartPartMapWithEncoding() throws IOException {
@@ -1640,16 +1866,16 @@
     String bodyString = buffer.readUtf8();
 
     assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"ping\"\r\n")
-        .contains("Content-Transfer-Encoding: 8-bit")
-        .contains("\r\npong\r\n--");
+            .contains("Content-Disposition: form-data;")
+            .contains("name=\"ping\"\r\n")
+            .contains("Content-Transfer-Encoding: 8-bit")
+            .contains("\r\npong\r\n--");
 
     assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"kit\"")
-        .contains("Content-Transfer-Encoding: 8-bit")
-        .contains("\r\nkat\r\n--");
+            .contains("Content-Disposition: form-data;")
+            .contains("name=\"kit\"")
+            .contains("Content-Transfer-Encoding: 8-bit")
+            .contains("\r\nkat\r\n--");
   }
 
   @Test public void multipartPartMapRejectsNonStringKeys() {
@@ -1666,8 +1892,8 @@
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "@PartMap keys must be of type String: class java.lang.Object (parameter #1)\n"
-              + "    for method Example.method");
+              "@PartMap keys must be of type String: class java.lang.Object (parameter #1)\n"
+                      + "    for method Example.method");
     }
   }
 
@@ -1685,8 +1911,8 @@
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "@PartMap values cannot be MultipartBody.Part. Use @Part List<Part> or a different value type instead. (parameter #1)\n"
-              + "    for method Example.method");
+              "@PartMap values cannot be MultipartBody.Part. Use @Part List<Part> or a different value type instead. (parameter #1)\n"
+                      + "    for method Example.method");
     }
   }
 
@@ -1763,7 +1989,7 @@
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "@PartMap parameter type must be Map. (parameter #1)\n    for method Example.method");
+              "@PartMap parameter type must be Map. (parameter #1)\n    for method Example.method");
     }
   }
 
@@ -1786,8 +2012,8 @@
     Buffer buffer = new Buffer();
     request.body().writeTo(buffer);
     assertThat(buffer.readUtf8())
-        .contains("name=\"hello\"")
-        .contains("\r\n\r\nworld\r\n--");
+            .contains("name=\"hello\"")
+            .contains("\r\n\r\nworld\r\n--");
   }
 
   @Test public void multipartNullRemovesPart() throws IOException {
@@ -1809,9 +2035,9 @@
     String bodyString = buffer.readUtf8();
 
     assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"ping\"")
-        .contains("\r\npong\r\n--");
+            .contains("Content-Disposition: form-data;")
+            .contains("name=\"ping\"")
+            .contains("\r\npong\r\n--");
   }
 
   @Test public void multipartPartOptional() {
@@ -1859,7 +2085,7 @@
       @FormUrlEncoded //
       @POST("/foo") //
       Call<ResponseBody> method(@Field("foo") String foo, @Field("ping") String ping,
-          @Field("kit") String kit) {
+                                @Field("kit") String kit) {
         return null;
       }
     }
@@ -2015,7 +2241,7 @@
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "@FieldMap parameter type must be Map. (parameter #1)\n    for method Example.method");
+              "@FieldMap parameter type must be Map. (parameter #1)\n    for method Example.method");
     }
   }
 
@@ -2044,8 +2270,8 @@
     class Example {
       @GET("/foo/bar/")
       @Headers({
-          "ping: pong",
-          "kit: kat"
+              "ping: pong",
+              "kit: kat"
       })
       Call<ResponseBody> method() {
         return null;
@@ -2176,7 +2402,7 @@
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "Malformed URL. Base: http://example.com/, Relative: ftp://example.org");
+              "Malformed URL. Base: http://example.com/, Relative: ftp://example.org");
     }
   }
 
@@ -2192,7 +2418,7 @@
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "Malformed URL. Base: http://example.com/, Relative: ftp://example.org");
+              "Malformed URL. Base: http://example.com/, Relative: ftp://example.org");
     }
   }
 
@@ -2217,10 +2443,10 @@ static Request buildRequest(Class<?> cls, Object... args) {
     };
 
     Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addConverterFactory(new ToStringConverterFactory())
-        .callFactory(callFactory)
-        .build();
+            .baseUrl("http://example.com/")
+            .addConverterFactory(new ToStringConverterFactory())
+            .callFactory(callFactory)
+            .build();
 
     Method method = TestingUtils.onlyMethod(cls);
     ServiceMethod<?> serviceMethod = retrofit.loadServiceMethod(method);
@@ -2237,4 +2463,4 @@ static Request buildRequest(Class<?> cls, Object... args) {
       throw new AssertionError(e);
     }
   }
-}
+}
\ No newline at end of file
