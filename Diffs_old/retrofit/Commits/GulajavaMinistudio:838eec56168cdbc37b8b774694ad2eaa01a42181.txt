diff --git a/retrofit/src/main/java/retrofit2/HttpServiceMethod.java b/retrofit/src/main/java/retrofit2/HttpServiceMethod.java
index e79205ab2..94b8df94d 100644
--- a/retrofit/src/main/java/retrofit2/HttpServiceMethod.java
+++ b/retrofit/src/main/java/retrofit2/HttpServiceMethod.java
@@ -165,7 +165,13 @@
       //noinspection unchecked Checked by reflection inside RequestFactory.
       Continuation<Response<ResponseT>> continuation =
           (Continuation<Response<ResponseT>>) args[args.length - 1];
-      return KotlinExtensions.awaitResponse(call, continuation);
+
+      // See SuspendForBody for explanation about this try/catch.
+      try {
+        return KotlinExtensions.awaitResponse(call, continuation);
+      } catch (Exception e) {
+        return KotlinExtensions.yieldAndThrow(e, continuation);
+      }
     }
   }
 
diff --git a/retrofit/src/test/java/retrofit2/KotlinSuspendTest.kt b/retrofit/src/test/java/retrofit2/KotlinSuspendTest.kt
index e3c005e81..361b40a17 100644
--- a/retrofit/src/test/java/retrofit2/KotlinSuspendTest.kt
+++ b/retrofit/src/test/java/retrofit2/KotlinSuspendTest.kt
@@ -274,7 +274,7 @@ class KotlinSuspendTest {
     assertThat(body).isEqualTo("HiHiHiHiHi")
   }
 
-  @Test fun checkedExceptionsAreNotSynchronouslyThrown() = runBlocking {
+  @Test fun checkedExceptionsAreNotSynchronouslyThrownForBody() = runBlocking {
     val retrofit = Retrofit.Builder()
         .baseUrl("https://unresolved-host.com/")
         .addConverterFactory(ToStringConverterFactory())
@@ -295,4 +295,26 @@ class KotlinSuspendTest {
       }
     }
   }
+
+  @Test fun checkedExceptionsAreNotSynchronouslyThrownForResponse() = runBlocking {
+    val retrofit = Retrofit.Builder()
+        .baseUrl("https://unresolved-host.com/")
+        .addConverterFactory(ToStringConverterFactory())
+        .build()
+    val example = retrofit.create(Service::class.java)
+
+    server.shutdown()
+
+    // The problematic behavior of the UnknownHostException being synchronously thrown is
+    // probabilistic based on thread preemption. Running a thousand times will almost always
+    // trigger it, so we run an order of magnitude more to be safe.
+    repeat(10000) {
+      try {
+        example.response()
+        fail()
+      } catch (_: IOException) {
+        // We expect IOException, the bad behavior will wrap this in UndeclaredThrowableException.
+      }
+    }
+  }
 }
