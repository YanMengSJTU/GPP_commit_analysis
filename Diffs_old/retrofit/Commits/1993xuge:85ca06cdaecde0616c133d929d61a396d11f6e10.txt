diff --git a/retrofit/src/main/java/retrofit2/HttpServiceMethod.java b/retrofit/src/main/java/retrofit2/HttpServiceMethod.java
index d149df56a..251c33612 100644
--- a/retrofit/src/main/java/retrofit2/HttpServiceMethod.java
+++ b/retrofit/src/main/java/retrofit2/HttpServiceMethod.java
@@ -18,75 +18,96 @@
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Method;
 import java.lang.reflect.Type;
+
 import okhttp3.ResponseBody;
 
 import static retrofit2.Utils.methodError;
 
-/** Adapts an invocation of an interface method into an HTTP call. */
+/**
+ * Adapts an invocation of an interface method into an HTTP call.
+ */
 final class HttpServiceMethod<ResponseT, ReturnT> extends ServiceMethod<ReturnT> {
-  /**
-   * Inspects the annotations on an interface method to construct a reusable service method that
-   * speaks HTTP. This requires potentially-expensive reflection so it is best to build each service
-   * method only once and reuse it.
-   */
-  static <ResponseT, ReturnT> HttpServiceMethod<ResponseT, ReturnT> parseAnnotations(
-      Retrofit retrofit, Method method, RequestFactory requestFactory) {
-    CallAdapter<ResponseT, ReturnT> callAdapter = createCallAdapter(retrofit, method);
-    Type responseType = callAdapter.responseType();
-    if (responseType == Response.class || responseType == okhttp3.Response.class) {
-      throw methodError(method, "'"
-          + Utils.getRawType(responseType).getName()
-          + "' is not a valid response body type. Did you mean ResponseBody?");
-    }
-    if (requestFactory.httpMethod.equals("HEAD") && !Void.class.equals(responseType)) {
-      throw methodError(method, "HEAD method must use Void as response type.");
-    }
+    /**
+     * Inspects the annotations on an interface method to construct a reusable service method that
+     * speaks HTTP. This requires potentially-expensive reflection so it is best to build each service
+     * method only once and reuse it.
+     */
+    static <ResponseT, ReturnT> HttpServiceMethod<ResponseT, ReturnT> parseAnnotations(
+            Retrofit retrofit, Method method, RequestFactory requestFactory) {
+        // 1、根据接口方法的注解和返回类型 获取 callAdapter
+        CallAdapter<ResponseT, ReturnT> callAdapter = createCallAdapter(retrofit, method);
+
+        // 2、calladapter 的响应类型中的泛型，比如 Call<User> 中的 User
+        // 并对响应泛型的类型进行检查
+        Type responseType = callAdapter.responseType();
+        if (responseType == Response.class || responseType == okhttp3.Response.class) {
+            // 如果响应的类型是 Response.class 或 okhttp3.Response.class，则抛出异常
+            throw methodError(method, "'"
+                    + Utils.getRawType(responseType).getName()
+                    + "' is not a valid response body type. Did you mean ResponseBody?");
+        }
+        // 如果 该请求方法是 HEAD请求，那么 响应类型 必须是 Void，否则就会 抛出异常
+        if (requestFactory.httpMethod.equals("HEAD") && !Void.class.equals(responseType)) {
+            throw methodError(method, "HEAD method must use Void as response type.");
+        }
 
-    Converter<ResponseBody, ResponseT> responseConverter =
-        createResponseConverter(retrofit, method, responseType);
+        // 3、根据之前泛型中的类型以及接口方法的注解创建 ResponseConverter
+        Converter<ResponseBody, ResponseT> responseConverter =
+                createResponseConverter(retrofit, method, responseType);
 
-    okhttp3.Call.Factory callFactory = retrofit.callFactory;
-    return new HttpServiceMethod<>(requestFactory, callFactory, callAdapter, responseConverter);
-  }
+        // 4、获取 Retrofit中的 okhttp3.Call.Factory 对象
+        okhttp3.Call.Factory callFactory = retrofit.callFactory;
 
-  private static <ResponseT, ReturnT> CallAdapter<ResponseT, ReturnT> createCallAdapter(
-      Retrofit retrofit, Method method) {
-    Type returnType = method.getGenericReturnType();
-    Annotation[] annotations = method.getAnnotations();
-    try {
-      //noinspection unchecked
-      return (CallAdapter<ResponseT, ReturnT>) retrofit.callAdapter(returnType, annotations);
-    } catch (RuntimeException e) { // Wide exception range because factories are user code.
-      throw methodError(method, e, "Unable to create call adapter for %s", returnType);
+        //5、将 requestFactory、callFactory、callAdapter、responseConverter传入HttpServiceMethod，并创建对象
+        return new HttpServiceMethod<>(requestFactory, callFactory, callAdapter, responseConverter);
     }
-  }
 
-  private static <ResponseT> Converter<ResponseBody, ResponseT> createResponseConverter(
-      Retrofit retrofit, Method method, Type responseType) {
-    Annotation[] annotations = method.getAnnotations();
-    try {
-      return retrofit.responseBodyConverter(responseType, annotations);
-    } catch (RuntimeException e) { // Wide exception range because factories are user code.
-      throw methodError(method, e, "Unable to create converter for %s", responseType);
+    /**
+     * 根据接口方法的注解和返回类型创建 callAdapter
+     */
+    private static <ResponseT, ReturnT> CallAdapter<ResponseT, ReturnT> createCallAdapter(
+            Retrofit retrofit, Method method) {
+        // 方法 的 返回值类型
+        Type returnType = method.getGenericReturnType();
+        // 方法上 添加的注解
+        Annotation[] annotations = method.getAnnotations();
+        try {
+            //noinspection unchecked
+            // 通过 Retrofit对象的callAdapter方法 获取 合适的CallAdapter
+            return (CallAdapter<ResponseT, ReturnT>) retrofit.callAdapter(returnType, annotations);
+        } catch (RuntimeException e) { // Wide exception range because factories are user code.
+            throw methodError(method, e, "Unable to create call adapter for %s", returnType);
+        }
     }
-  }
 
-  private final RequestFactory requestFactory;
-  private final okhttp3.Call.Factory callFactory;
-  private final CallAdapter<ResponseT, ReturnT> callAdapter;
-  private final Converter<ResponseBody, ResponseT> responseConverter;
+    private static <ResponseT> Converter<ResponseBody, ResponseT> createResponseConverter(
+            Retrofit retrofit, Method method, Type responseType) {
+        Annotation[] annotations = method.getAnnotations();
+        try {
+            return retrofit.responseBodyConverter(responseType, annotations);
+        } catch (RuntimeException e) { // Wide exception range because factories are user code.
+            throw methodError(method, e, "Unable to create converter for %s", responseType);
+        }
+    }
+
+    private final RequestFactory requestFactory;
+    private final okhttp3.Call.Factory callFactory;
+    private final CallAdapter<ResponseT, ReturnT> callAdapter;
+    private final Converter<ResponseBody, ResponseT> responseConverter;
 
-  private HttpServiceMethod(RequestFactory requestFactory, okhttp3.Call.Factory callFactory,
-      CallAdapter<ResponseT, ReturnT> callAdapter,
-      Converter<ResponseBody, ResponseT> responseConverter) {
-    this.requestFactory = requestFactory;
-    this.callFactory = callFactory;
-    this.callAdapter = callAdapter;
-    this.responseConverter = responseConverter;
-  }
+    private HttpServiceMethod(RequestFactory requestFactory, okhttp3.Call.Factory callFactory,
+                              CallAdapter<ResponseT, ReturnT> callAdapter,
+                              Converter<ResponseBody, ResponseT> responseConverter) {
+        this.requestFactory = requestFactory;
+        this.callFactory = callFactory;
+        this.callAdapter = callAdapter;
+        this.responseConverter = responseConverter;
+    }
 
-  @Override ReturnT invoke(Object[] args) {
-    return callAdapter.adapt(
-        new OkHttpCall<>(requestFactory, args, callFactory, responseConverter));
-  }
+    @Override
+    ReturnT invoke(Object[] args) {
+        // 调用 请求接口中的方法，实际上 会使用 动态代理调用这个方法，创建Call对象，显然此处是OkHttpCall
+        return callAdapter.adapt(
+                new OkHttpCall<>(requestFactory, args, callFactory, responseConverter));
+    }
 }
diff --git a/retrofit/src/main/java/retrofit2/OkHttpCall.java b/retrofit/src/main/java/retrofit2/OkHttpCall.java
index e334219ea..4e7be2e1d 100644
--- a/retrofit/src/main/java/retrofit2/OkHttpCall.java
+++ b/retrofit/src/main/java/retrofit2/OkHttpCall.java
@@ -16,8 +16,10 @@
 package retrofit2;
 
 import java.io.IOException;
+
 import javax.annotation.Nullable;
 import javax.annotation.concurrent.GuardedBy;
+
 import okhttp3.MediaType;
 import okhttp3.Request;
 import okhttp3.ResponseBody;
@@ -29,287 +31,350 @@
 import static retrofit2.Utils.checkNotNull;
 import static retrofit2.Utils.throwIfFatal;
 
+/**
+ * OkHttpCall实现了 Call接口，并重写了 同步请求的execute方法和异步请求的 enqueue方法
+ */
 final class OkHttpCall<T> implements Call<T> {
-  private final RequestFactory requestFactory;
-  private final Object[] args;
-  private final okhttp3.Call.Factory callFactory;
-  private final Converter<ResponseBody, T> responseConverter;
-
-  private volatile boolean canceled;
-
-  @GuardedBy("this")
-  private @Nullable okhttp3.Call rawCall;
-  @GuardedBy("this") // Either a RuntimeException, non-fatal Error, or IOException.
-  private @Nullable Throwable creationFailure;
-  @GuardedBy("this")
-  private boolean executed;
-
-  OkHttpCall(RequestFactory requestFactory, Object[] args,
-      okhttp3.Call.Factory callFactory, Converter<ResponseBody, T> responseConverter) {
-    this.requestFactory = requestFactory;
-    this.args = args;
-    this.callFactory = callFactory;
-    this.responseConverter = responseConverter;
-  }
-
-  @SuppressWarnings("CloneDoesntCallSuperClone") // We are a final type & this saves clearing state.
-  @Override public OkHttpCall<T> clone() {
-    return new OkHttpCall<>(requestFactory, args, callFactory, responseConverter);
-  }
-
-  @Override public synchronized Request request() {
-    okhttp3.Call call = rawCall;
-    if (call != null) {
-      return call.request();
-    }
-    if (creationFailure != null) {
-      if (creationFailure instanceof IOException) {
-        throw new RuntimeException("Unable to create request.", creationFailure);
-      } else if (creationFailure instanceof RuntimeException) {
-        throw (RuntimeException) creationFailure;
-      } else {
-        throw (Error) creationFailure;
-      }
+    private final RequestFactory requestFactory;
+
+    /**
+     * 网络请求接口中的参数
+     */
+    private final Object[] args;
+
+    /**
+     * Okhttp中的Factory类的对象，通过这个对象的newCall方法，根据参数Request创建OkHttp实际的Call对象，来进行网络请求
+     */
+    private final okhttp3.Call.Factory callFactory;
+    private final Converter<ResponseBody, T> responseConverter;
+
+    private volatile boolean canceled;
+
+    @GuardedBy("this")
+    private @Nullable
+    okhttp3.Call rawCall;
+    @GuardedBy("this") // Either a RuntimeException, non-fatal Error, or IOException.
+    private @Nullable
+    Throwable creationFailure;
+    @GuardedBy("this")
+    private boolean executed;
+
+    OkHttpCall(RequestFactory requestFactory, Object[] args,
+               okhttp3.Call.Factory callFactory, Converter<ResponseBody, T> responseConverter) {
+        this.requestFactory = requestFactory;
+        this.args = args;
+        this.callFactory = callFactory;
+        this.responseConverter = responseConverter;
     }
-    try {
-      return (rawCall = createRawCall()).request();
-    } catch (RuntimeException | Error e) {
-      throwIfFatal(e); // Do not assign a fatal error to creationFailure.
-      creationFailure = e;
-      throw e;
-    } catch (IOException e) {
-      creationFailure = e;
-      throw new RuntimeException("Unable to create request.", e);
-    }
-  }
-
-  @Override public void enqueue(final Callback<T> callback) {
-    checkNotNull(callback, "callback == null");
 
-    okhttp3.Call call;
-    Throwable failure;
-
-    synchronized (this) {
-      if (executed) throw new IllegalStateException("Already executed.");
-      executed = true;
+    @SuppressWarnings("CloneDoesntCallSuperClone")
+    // We are a final type & this saves clearing state.
+    @Override
+    public OkHttpCall<T> clone() {
+        return new OkHttpCall<>(requestFactory, args, callFactory, responseConverter);
+    }
 
-      call = rawCall;
-      failure = creationFailure;
-      if (call == null && failure == null) {
+    @Override
+    public synchronized Request request() {
+        okhttp3.Call call = rawCall;
+        if (call != null) {
+            return call.request();
+        }
+        if (creationFailure != null) {
+            if (creationFailure instanceof IOException) {
+                throw new RuntimeException("Unable to create request.", creationFailure);
+            } else if (creationFailure instanceof RuntimeException) {
+                throw (RuntimeException) creationFailure;
+            } else {
+                throw (Error) creationFailure;
+            }
+        }
         try {
-          call = rawCall = createRawCall();
-        } catch (Throwable t) {
-          throwIfFatal(t);
-          failure = creationFailure = t;
+            return (rawCall = createRawCall()).request();
+        } catch (RuntimeException | Error e) {
+            throwIfFatal(e); // Do not assign a fatal error to creationFailure.
+            creationFailure = e;
+            throw e;
+        } catch (IOException e) {
+            creationFailure = e;
+            throw new RuntimeException("Unable to create request.", e);
         }
-      }
-    }
-
-    if (failure != null) {
-      callback.onFailure(this, failure);
-      return;
-    }
-
-    if (canceled) {
-      call.cancel();
     }
 
-    call.enqueue(new okhttp3.Callback() {
-      @Override public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse) {
-        Response<T> response;
-        try {
-          response = parseResponse(rawResponse);
-        } catch (Throwable e) {
-          throwIfFatal(e);
-          callFailure(e);
-          return;
+    /**
+     * 异步请求
+     */
+    @Override
+    public void enqueue(final Callback<T> callback) {
+        checkNotNull(callback, "callback == null");
+
+        okhttp3.Call call;
+        Throwable failure;
+
+        synchronized (this) {
+            // 检查 该 请求是否被执行过，如果执行过则抛出异常
+            if (executed) throw new IllegalStateException("Already executed.");
+            executed = true;
+
+            call = rawCall;
+            failure = creationFailure;
+            if (call == null && failure == null) {
+                try {
+                    // 创建 实际的OkHttp对象
+                    call = rawCall = createRawCall();
+                } catch (Throwable t) {
+                    throwIfFatal(t);
+                    failure = creationFailure = t;
+                }
+            }
         }
 
-        try {
-          callback.onResponse(OkHttpCall.this, response);
-        } catch (Throwable t) {
-          t.printStackTrace();
+        if (failure != null) {
+            callback.onFailure(this, failure);
+            return;
         }
-      }
 
-      @Override public void onFailure(okhttp3.Call call, IOException e) {
-        callFailure(e);
-      }
-
-      private void callFailure(Throwable e) {
-        try {
-          callback.onFailure(OkHttpCall.this, e);
-        } catch (Throwable t) {
-          t.printStackTrace();
+        if (canceled) {
+            call.cancel();
         }
-      }
-    });
-  }
-
-  @Override public synchronized boolean isExecuted() {
-    return executed;
-  }
-
-  @Override public Response<T> execute() throws IOException {
-    okhttp3.Call call;
-
-    synchronized (this) {
-      if (executed) throw new IllegalStateException("Already executed.");
-      executed = true;
-
-      if (creationFailure != null) {
-        if (creationFailure instanceof IOException) {
-          throw (IOException) creationFailure;
-        } else if (creationFailure instanceof RuntimeException) {
-          throw (RuntimeException) creationFailure;
-        } else {
-          throw (Error) creationFailure;
-        }
-      }
 
-      call = rawCall;
-      if (call == null) {
-        try {
-          call = rawCall = createRawCall();
-        } catch (IOException | RuntimeException | Error e) {
-          throwIfFatal(e); //  Do not assign a fatal error to creationFailure.
-          creationFailure = e;
-          throw e;
-        }
-      }
+        // 调用 OkHttp的Call对象 来执行 异步请求
+        call.enqueue(new okhttp3.Callback() {
+            @Override
+            public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse) {
+                // 响应成功
+                Response<T> response;
+                try {
+                    // 解析 响应
+                    response = parseResponse(rawResponse);
+                } catch (Throwable e) {
+                    throwIfFatal(e);
+                    callFailure(e);
+                    return;
+                }
+
+                try {
+                    // 回调响应成功
+                    callback.onResponse(OkHttpCall.this, response);
+                } catch (Throwable t) {
+                    t.printStackTrace();
+                }
+            }
+
+            @Override
+            public void onFailure(okhttp3.Call call, IOException e) {
+                // 回调 失败
+                callFailure(e);
+            }
+
+            private void callFailure(Throwable e) {
+                try {
+                    callback.onFailure(OkHttpCall.this, e);
+                } catch (Throwable t) {
+                    t.printStackTrace();
+                }
+            }
+        });
     }
 
-    if (canceled) {
-      call.cancel();
+    @Override
+    public synchronized boolean isExecuted() {
+        return executed;
     }
 
-    return parseResponse(call.execute());
-  }
+    @Override
+    public Response<T> execute() throws IOException {
+        okhttp3.Call call;
+
+        synchronized (this) {
+            // 检查 该 请求是否被执行过，如果执行过则抛出异常
+            if (executed) throw new IllegalStateException("Already executed.");
+            executed = true;
+
+            if (creationFailure != null) {
+                if (creationFailure instanceof IOException) {
+                    throw (IOException) creationFailure;
+                } else if (creationFailure instanceof RuntimeException) {
+                    throw (RuntimeException) creationFailure;
+                } else {
+                    throw (Error) creationFailure;
+                }
+            }
+
+            call = rawCall;
+            if (call == null) {
+                try {
+                    // 创建 实际的OkHttp对象
+                    call = rawCall = createRawCall();
+                } catch (IOException | RuntimeException | Error e) {
+                    throwIfFatal(e); //  Do not assign a fatal error to creationFailure.
+                    creationFailure = e;
+                    throw e;
+                }
+            }
+        }
 
-  private okhttp3.Call createRawCall() throws IOException {
-    okhttp3.Call call = callFactory.newCall(requestFactory.create(args));
-    if (call == null) {
-      throw new NullPointerException("Call.Factory returned null.");
-    }
-    return call;
-  }
-
-  Response<T> parseResponse(okhttp3.Response rawResponse) throws IOException {
-    ResponseBody rawBody = rawResponse.body();
-
-    // Remove the body's source (the only stateful object) so we can pass the response along.
-    rawResponse = rawResponse.newBuilder()
-        .body(new NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))
-        .build();
-
-    int code = rawResponse.code();
-    if (code < 200 || code >= 300) {
-      try {
-        // Buffer the entire body to avoid future I/O.
-        ResponseBody bufferedBody = Utils.buffer(rawBody);
-        return Response.error(bufferedBody, rawResponse);
-      } finally {
-        rawBody.close();
-      }
-    }
+        // 获取到对象锁，并创建了OkHttp的Call对象，然后进行是否被取消的判断
+        // 如果请求被取消了，那么调用OkHttp的Call对象 取消 网络请求
+        if (canceled) {
+            // 取消 请求
+            call.cancel();
+        }
 
-    if (code == 204 || code == 205) {
-      rawBody.close();
-      return Response.success(null, rawResponse);
+        // 调用 OkHttp的Call对象 的 execute方法执行 同步请求
+        // 然后解析 请求的结果
+        return parseResponse(call.execute());
     }
 
-    ExceptionCatchingResponseBody catchingBody = new ExceptionCatchingResponseBody(rawBody);
-    try {
-      T body = responseConverter.convert(catchingBody);
-      return Response.success(body, rawResponse);
-    } catch (RuntimeException e) {
-      // If the underlying source threw an exception, propagate that rather than indicating it was
-      // a runtime exception.
-      catchingBody.throwIfCaught();
-      throw e;
+    /**
+     * 创建实际的OkHttp对象
+     */
+    private okhttp3.Call createRawCall() throws IOException {
+        // 首先通过requestFactory创建实际的Request对象，然
+        // 后使用OkHttp中Factory类的newCall方法创建okhttp3.Call对象
+        okhttp3.Call call = callFactory.newCall(requestFactory.create(args));
+        if (call == null) {
+            throw new NullPointerException("Call.Factory returned null.");
+        }
+        return call;
     }
-  }
 
-  public void cancel() {
-    canceled = true;
+    /**
+     * 解析 Http响应，同步请求和异步请求结束后，都是通过该方法进行结果解析的
+     */
+    Response<T> parseResponse(okhttp3.Response rawResponse) throws IOException {
+        // 获取 OkHttp响应 Response对象中的 body
+        ResponseBody rawBody = rawResponse.body();
+
+        // Remove the body's source (the only stateful object) so we can pass the response along.
+        rawResponse = rawResponse.newBuilder()
+                .body(new NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))
+                .build();
+
+        // 获取 响应码，并检查响应码
+        // 不是成功的响应码，则返回错误。成功的响应码指的是 2XX的响应码
+        int code = rawResponse.code();
+        if (code < 200 || code >= 300) {
+            try {
+                // Buffer the entire body to avoid future I/O.
+                ResponseBody bufferedBody = Utils.buffer(rawBody);
+                // 返回失败的响应
+                return Response.error(bufferedBody, rawResponse);
+            } finally {
+                rawBody.close();
+            }
+        }
 
-    okhttp3.Call call;
-    synchronized (this) {
-      call = rawCall;
-    }
-    if (call != null) {
-      call.cancel();
-    }
-  }
+        // 如果返回的响应码是204或者205，返回没有 body 的成功 Response
+        if (code == 204 || code == 205) {
+            rawBody.close();
+            return Response.success(null, rawResponse);
+        }
 
-  @Override public boolean isCanceled() {
-    if (canceled) {
-      return true;
-    }
-    synchronized (this) {
-      return rawCall != null && rawCall.isCanceled();
+        ExceptionCatchingResponseBody catchingBody = new ExceptionCatchingResponseBody(rawBody);
+        try {
+            // 通过转换器 将 响应 转换成 需要的泛型对象，并返回成功的响应
+            T body = responseConverter.convert(catchingBody);
+            return Response.success(body, rawResponse);
+        } catch (RuntimeException e) {
+            // If the underlying source threw an exception, propagate that rather than indicating it was
+            // a runtime exception.
+            catchingBody.throwIfCaught();
+            throw e;
+        }
     }
-  }
 
-  static final class NoContentResponseBody extends ResponseBody {
-    private final @Nullable MediaType contentType;
-    private final long contentLength;
+    public void cancel() {
+        canceled = true;
 
-    NoContentResponseBody(@Nullable MediaType contentType, long contentLength) {
-      this.contentType = contentType;
-      this.contentLength = contentLength;
+        okhttp3.Call call;
+        synchronized (this) {
+            call = rawCall;
+        }
+        if (call != null) {
+            call.cancel();
+        }
     }
 
-    @Override public MediaType contentType() {
-      return contentType;
+    @Override
+    public boolean isCanceled() {
+        if (canceled) {
+            return true;
+        }
+        synchronized (this) {
+            return rawCall != null && rawCall.isCanceled();
+        }
     }
 
-    @Override public long contentLength() {
-      return contentLength;
-    }
+    static final class NoContentResponseBody extends ResponseBody {
+        private final @Nullable
+        MediaType contentType;
+        private final long contentLength;
 
-    @Override public BufferedSource source() {
-      throw new IllegalStateException("Cannot read raw response body of a converted body.");
-    }
-  }
+        NoContentResponseBody(@Nullable MediaType contentType, long contentLength) {
+            this.contentType = contentType;
+            this.contentLength = contentLength;
+        }
 
-  static final class ExceptionCatchingResponseBody extends ResponseBody {
-    private final ResponseBody delegate;
-    @Nullable IOException thrownException;
+        @Override
+        public MediaType contentType() {
+            return contentType;
+        }
 
-    ExceptionCatchingResponseBody(ResponseBody delegate) {
-      this.delegate = delegate;
-    }
+        @Override
+        public long contentLength() {
+            return contentLength;
+        }
 
-    @Override public MediaType contentType() {
-      return delegate.contentType();
+        @Override
+        public BufferedSource source() {
+            throw new IllegalStateException("Cannot read raw response body of a converted body.");
+        }
     }
 
-    @Override public long contentLength() {
-      return delegate.contentLength();
-    }
+    static final class ExceptionCatchingResponseBody extends ResponseBody {
+        private final ResponseBody delegate;
+        @Nullable
+        IOException thrownException;
 
-    @Override public BufferedSource source() {
-      return Okio.buffer(new ForwardingSource(delegate.source()) {
-        @Override public long read(Buffer sink, long byteCount) throws IOException {
-          try {
-            return super.read(sink, byteCount);
-          } catch (IOException e) {
-            thrownException = e;
-            throw e;
-          }
+        ExceptionCatchingResponseBody(ResponseBody delegate) {
+            this.delegate = delegate;
         }
-      });
-    }
 
-    @Override public void close() {
-      delegate.close();
-    }
+        @Override
+        public MediaType contentType() {
+            return delegate.contentType();
+        }
 
-    void throwIfCaught() throws IOException {
-      if (thrownException != null) {
-        throw thrownException;
-      }
+        @Override
+        public long contentLength() {
+            return delegate.contentLength();
+        }
+
+        @Override
+        public BufferedSource source() {
+            return Okio.buffer(new ForwardingSource(delegate.source()) {
+                @Override
+                public long read(Buffer sink, long byteCount) throws IOException {
+                    try {
+                        return super.read(sink, byteCount);
+                    } catch (IOException e) {
+                        thrownException = e;
+                        throw e;
+                    }
+                }
+            });
+        }
+
+        @Override
+        public void close() {
+            delegate.close();
+        }
+
+        void throwIfCaught() throws IOException {
+            if (thrownException != null) {
+                throw thrownException;
+            }
+        }
     }
-  }
 }
diff --git a/retrofit/src/main/java/retrofit2/Platform.java b/retrofit/src/main/java/retrofit2/Platform.java
index 52f7557bd..6baa7953e 100644
--- a/retrofit/src/main/java/retrofit2/Platform.java
+++ b/retrofit/src/main/java/retrofit2/Platform.java
@@ -18,6 +18,7 @@
 import android.os.Build;
 import android.os.Handler;
 import android.os.Looper;
+
 import java.lang.invoke.MethodHandles.Lookup;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Method;
@@ -25,7 +26,9 @@
 import java.util.Collections;
 import java.util.List;
 import java.util.concurrent.Executor;
+
 import javax.annotation.Nullable;
+
 import org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement;
 
 import static java.util.Arrays.asList;
@@ -34,146 +37,185 @@
 import static java.util.Collections.unmodifiableList;
 
 class Platform {
-  private static final Platform PLATFORM = findPlatform();
-
-  static Platform get() {
-    return PLATFORM;
-  }
-
-  private static Platform findPlatform() {
-    try {
-      Class.forName("android.os.Build");
-      if (Build.VERSION.SDK_INT != 0) {
-        return new Android();
-      }
-    } catch (ClassNotFoundException ignored) {
-    }
-    try {
-      Class.forName("java.util.Optional");
-      return new Java8();
-    } catch (ClassNotFoundException ignored) {
-    }
-    return new Platform();
-  }
+    /**
+     * 通过findPlatform创建Platform对象
+     */
+    private static final Platform PLATFORM = findPlatform();
 
-  @Nullable Executor defaultCallbackExecutor() {
-    return null;
-  }
-
-  List<? extends CallAdapter.Factory> defaultCallAdapterFactories(
-      @Nullable Executor callbackExecutor) {
-    if (callbackExecutor != null) {
-      return singletonList(new ExecutorCallAdapterFactory(callbackExecutor));
-    }
-    return singletonList(DefaultCallAdapterFactory.INSTANCE);
-  }
-
-  int defaultCallAdapterFactoriesSize() {
-    return 1;
-  }
-
-  List<? extends Converter.Factory> defaultConverterFactories() {
-    return emptyList();
-  }
-
-  int defaultConverterFactoriesSize() {
-    return 0;
-  }
-
-  boolean isDefaultMethod(Method method) {
-    return false;
-  }
-
-  @Nullable Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object,
-      @Nullable Object... args) throws Throwable {
-    throw new UnsupportedOperationException();
-  }
-
-  @IgnoreJRERequirement // Only classloaded and used on Java 8.
-  static class Java8 extends Platform {
-    @Override boolean isDefaultMethod(Method method) {
-      return method.isDefault();
+    static Platform get() {
+        // 直接将 静态变量 PLATFORM
+        return PLATFORM;
     }
 
-    @Override Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object,
-        @Nullable Object... args) throws Throwable {
-      // Because the service interface might not be public, we need to use a MethodHandle lookup
-      // that ignores the visibility of the declaringClass.
-      Constructor<Lookup> constructor = Lookup.class.getDeclaredConstructor(Class.class, int.class);
-      constructor.setAccessible(true);
-      return constructor.newInstance(declaringClass, -1 /* trusted */)
-          .unreflectSpecial(method, declaringClass)
-          .bindTo(object)
-          .invokeWithArguments(args);
-    }
+    /**
+     * 通过反射的方式判断当前的Platform是 Android 还是 Java8 ，如果都不是就会创建一个Platform对象
+     *
+     * @return
+     */
+    private static Platform findPlatform() {
+        try {
+            // 判断 是否是 Android平台
+            Class.forName("android.os.Build");
+            if (Build.VERSION.SDK_INT != 0) {
+                return new Android();
+            }
+        } catch (ClassNotFoundException ignored) {
+        }
+        try {
+            // 判断 是否是 Java8平台
+            Class.forName("java.util.Optional");
+            return new Java8();
+        } catch (ClassNotFoundException ignored) {
+        }
 
-    @Override List<? extends CallAdapter.Factory> defaultCallAdapterFactories(
-        @Nullable Executor callbackExecutor) {
-      List<CallAdapter.Factory> factories = new ArrayList<>(2);
-      factories.add(CompletableFutureCallAdapterFactory.INSTANCE);
-      if (callbackExecutor != null) {
-        factories.add(new ExecutorCallAdapterFactory(callbackExecutor));
-      } else {
-        factories.add(DefaultCallAdapterFactory.INSTANCE);
-      }
-      return unmodifiableList(factories);
+        // 创建一个 Platform 对象返回
+        return new Platform();
     }
 
-    @Override int defaultCallAdapterFactoriesSize() {
-      return 2;
+    @Nullable
+    Executor defaultCallbackExecutor() {
+        return null;
     }
 
-    @Override List<? extends Converter.Factory> defaultConverterFactories() {
-      return singletonList(OptionalConverterFactory.INSTANCE);
+    List<? extends CallAdapter.Factory> defaultCallAdapterFactories(
+            @Nullable Executor callbackExecutor) {
+        if (callbackExecutor != null) {
+            return singletonList(new ExecutorCallAdapterFactory(callbackExecutor));
+        }
+        return singletonList(DefaultCallAdapterFactory.INSTANCE);
     }
 
-    @Override int defaultConverterFactoriesSize() {
-      return 1;
+    int defaultCallAdapterFactoriesSize() {
+        return 1;
     }
-  }
 
-  static class Android extends Platform {
-    @IgnoreJRERequirement // Guarded by API check.
-    @Override boolean isDefaultMethod(Method method) {
-      if (Build.VERSION.SDK_INT < 24) {
-        return false;
-      }
-      return method.isDefault();
+    List<? extends Converter.Factory> defaultConverterFactories() {
+        return emptyList();
     }
 
-    @Override public Executor defaultCallbackExecutor() {
-      return new MainThreadExecutor();
+    int defaultConverterFactoriesSize() {
+        return 0;
     }
 
-    @Override List<? extends CallAdapter.Factory> defaultCallAdapterFactories(
-        @Nullable Executor callbackExecutor) {
-      if (callbackExecutor == null) throw new AssertionError();
-      ExecutorCallAdapterFactory executorFactory = new ExecutorCallAdapterFactory(callbackExecutor);
-      return Build.VERSION.SDK_INT >= 24
-        ? asList(CompletableFutureCallAdapterFactory.INSTANCE, executorFactory)
-        : singletonList(executorFactory);
-    }
-
-    @Override int defaultCallAdapterFactoriesSize() {
-      return Build.VERSION.SDK_INT >= 24 ? 2 : 1;
-    }
-
-    @Override List<? extends Converter.Factory> defaultConverterFactories() {
-      return Build.VERSION.SDK_INT >= 24
-          ? singletonList(OptionalConverterFactory.INSTANCE)
-          : Collections.<Converter.Factory>emptyList();
-    }
-
-    @Override int defaultConverterFactoriesSize() {
-      return Build.VERSION.SDK_INT >= 24 ? 1 : 0;
+    boolean isDefaultMethod(Method method) {
+        return false;
     }
 
-    static class MainThreadExecutor implements Executor {
-      private final Handler handler = new Handler(Looper.getMainLooper());
-
-      @Override public void execute(Runnable r) {
-        handler.post(r);
-      }
+    @Nullable
+    Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object,
+                               @Nullable Object... args) throws Throwable {
+        throw new UnsupportedOperationException();
+    }
+
+    @IgnoreJRERequirement // Only classloaded and used on Java 8.
+    static class Java8 extends Platform {
+
+        /**
+         * 判断被调用的method是否Java8的默认方法
+         */
+        @Override
+        boolean isDefaultMethod(Method method) {
+            return method.isDefault();
+        }
+
+        @Override
+        Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object,
+                                   @Nullable Object... args) throws Throwable {
+            // Because the service interface might not be public, we need to use a MethodHandle lookup
+            // that ignores the visibility of the declaringClass.
+            Constructor<Lookup> constructor = Lookup.class.getDeclaredConstructor(Class.class, int.class);
+            constructor.setAccessible(true);
+            return constructor.newInstance(declaringClass, -1 /* trusted */)
+                    .unreflectSpecial(method, declaringClass)
+                    .bindTo(object)
+                    .invokeWithArguments(args);
+        }
+
+        @Override
+        List<? extends CallAdapter.Factory> defaultCallAdapterFactories(
+                @Nullable Executor callbackExecutor) {
+            List<CallAdapter.Factory> factories = new ArrayList<>(2);
+            factories.add(CompletableFutureCallAdapterFactory.INSTANCE);
+            if (callbackExecutor != null) {
+                factories.add(new ExecutorCallAdapterFactory(callbackExecutor));
+            } else {
+                factories.add(DefaultCallAdapterFactory.INSTANCE);
+            }
+            return unmodifiableList(factories);
+        }
+
+        @Override
+        int defaultCallAdapterFactoriesSize() {
+            return 2;
+        }
+
+        @Override
+        List<? extends Converter.Factory> defaultConverterFactories() {
+            return singletonList(OptionalConverterFactory.INSTANCE);
+        }
+
+        @Override
+        int defaultConverterFactoriesSize() {
+            return 1;
+        }
+    }
+
+    static class Android extends Platform {
+        @IgnoreJRERequirement // Guarded by API check.
+        @Override
+        boolean isDefaultMethod(Method method) {
+            if (Build.VERSION.SDK_INT < 24) {
+                return false;
+            }
+            return method.isDefault();
+        }
+
+        /**
+         * Android平台的默认callbackExecutor，实际上就是抛到UI线程去执行回调
+         */
+        @Override
+        public Executor defaultCallbackExecutor() {
+            return new MainThreadExecutor();
+        }
+
+        /**
+         * Android平台的默认CallAdapterFactory
+         */
+        @Override
+        List<? extends CallAdapter.Factory> defaultCallAdapterFactories(
+                @Nullable Executor callbackExecutor) {
+            if (callbackExecutor == null) throw new AssertionError();
+
+            ExecutorCallAdapterFactory executorFactory = new ExecutorCallAdapterFactory(callbackExecutor);
+            return Build.VERSION.SDK_INT >= 24
+                    ? asList(CompletableFutureCallAdapterFactory.INSTANCE, executorFactory)
+                    : singletonList(executorFactory);
+        }
+
+        @Override
+        int defaultCallAdapterFactoriesSize() {
+            return Build.VERSION.SDK_INT >= 24 ? 2 : 1;
+        }
+
+        @Override
+        List<? extends Converter.Factory> defaultConverterFactories() {
+            return Build.VERSION.SDK_INT >= 24
+                    ? singletonList(OptionalConverterFactory.INSTANCE)
+                    : Collections.<Converter.Factory>emptyList();
+        }
+
+        @Override
+        int defaultConverterFactoriesSize() {
+            return Build.VERSION.SDK_INT >= 24 ? 1 : 0;
+        }
+
+        static class MainThreadExecutor implements Executor {
+            private final Handler handler = new Handler(Looper.getMainLooper());
+
+            @Override
+            public void execute(Runnable r) {
+                handler.post(r);
+            }
+        }
     }
-  }
 }
diff --git a/retrofit/src/main/java/retrofit2/RequestFactory.java b/retrofit/src/main/java/retrofit2/RequestFactory.java
index aaa00d462..760dc2972 100644
--- a/retrofit/src/main/java/retrofit2/RequestFactory.java
+++ b/retrofit/src/main/java/retrofit2/RequestFactory.java
@@ -28,7 +28,9 @@
 import java.util.Set;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
+
 import javax.annotation.Nullable;
+
 import okhttp3.Headers;
 import okhttp3.HttpUrl;
 import okhttp3.MediaType;
@@ -61,701 +63,746 @@
 import static retrofit2.Utils.parameterError;
 
 final class RequestFactory {
-  static RequestFactory parseAnnotations(Retrofit retrofit, Method method) {
-    return new Builder(retrofit, method).build();
-  }
-
-  private final Method method;
-  private final HttpUrl baseUrl;
-  final String httpMethod;
-  private final @Nullable String relativeUrl;
-  private final @Nullable Headers headers;
-  private final @Nullable MediaType contentType;
-  private final boolean hasBody;
-  private final boolean isFormEncoded;
-  private final boolean isMultipart;
-  private final ParameterHandler<?>[] parameterHandlers;
-
-  RequestFactory(Builder builder) {
-    method = builder.method;
-    baseUrl = builder.retrofit.baseUrl;
-    httpMethod = builder.httpMethod;
-    relativeUrl = builder.relativeUrl;
-    headers = builder.headers;
-    contentType = builder.contentType;
-    hasBody = builder.hasBody;
-    isFormEncoded = builder.isFormEncoded;
-    isMultipart = builder.isMultipart;
-    parameterHandlers = builder.parameterHandlers;
-  }
-
-  okhttp3.Request create(Object[] args) throws IOException {
-    @SuppressWarnings("unchecked") // It is an error to invoke a method with the wrong arg types.
-    ParameterHandler<Object>[] handlers = (ParameterHandler<Object>[]) parameterHandlers;
-
-    int argumentCount = args.length;
-    if (argumentCount != handlers.length) {
-      throw new IllegalArgumentException("Argument count (" + argumentCount
-          + ") doesn't match expected count (" + handlers.length + ")");
+
+    /**
+     * 通过 Builder模式 构建一个 RequestFactory对象
+     * 该 方法 只是 简单地将 Retrofit对象和Method对象传入 RequestFactory.Builder，然后构建出 RequestFactory对象
+     */
+    static RequestFactory parseAnnotations(Retrofit retrofit, Method method) {
+        return new Builder(retrofit, method).build();
     }
 
-    RequestBuilder requestBuilder = new RequestBuilder(httpMethod, baseUrl, relativeUrl,
-        headers, contentType, hasBody, isFormEncoded, isMultipart);
+    /**
+     * 方法对象
+     */
+    private final Method method;
 
-    List<Object> argumentList = new ArrayList<>(argumentCount);
-    for (int p = 0; p < argumentCount; p++) {
-      argumentList.add(args[p]);
-      handlers[p].apply(requestBuilder, args[p]);
-    }
+    /**
+     * 请求的baseUrl
+     */
+    private final HttpUrl baseUrl;
 
-    return requestBuilder.get()
-        .tag(Invocation.class, new Invocation(method, argumentList))
-        .build();
-  }
-
-  /**
-   * Inspects the annotations on an interface method to construct a reusable service method. This
-   * requires potentially-expensive reflection so it is best to build each service method only once
-   * and reuse it. Builders cannot be reused.
-   */
-  static final class Builder {
-    // Upper and lower characters, digits, underscores, and hyphens, starting with a character.
-    private static final String PARAM = "[a-zA-Z][a-zA-Z0-9_-]*";
-    private static final Pattern PARAM_URL_REGEX = Pattern.compile("\\{(" + PARAM + ")\\}");
-    private static final Pattern PARAM_NAME_REGEX = Pattern.compile(PARAM);
-
-    final Retrofit retrofit;
-    final Method method;
-    final Annotation[] methodAnnotations;
-    final Annotation[][] parameterAnnotationsArray;
-    final Type[] parameterTypes;
-
-    boolean gotField;
-    boolean gotPart;
-    boolean gotBody;
-    boolean gotPath;
-    boolean gotQuery;
-    boolean gotQueryName;
-    boolean gotQueryMap;
-    boolean gotUrl;
-    @Nullable String httpMethod;
-    boolean hasBody;
-    boolean isFormEncoded;
-    boolean isMultipart;
-    @Nullable String relativeUrl;
-    @Nullable Headers headers;
-    @Nullable MediaType contentType;
-    @Nullable Set<String> relativeUrlParamNames;
-    @Nullable ParameterHandler<?>[] parameterHandlers;
-
-    Builder(Retrofit retrofit, Method method) {
-      this.retrofit = retrofit;
-      this.method = method;
-      this.methodAnnotations = method.getAnnotations();
-      this.parameterTypes = method.getGenericParameterTypes();
-      this.parameterAnnotationsArray = method.getParameterAnnotations();
-    }
+    /**
+     * 网络请求方法，GET、POST等
+     */
+    final String httpMethod;
 
-    RequestFactory build() {
-      for (Annotation annotation : methodAnnotations) {
-        parseMethodAnnotation(annotation);
-      }
+    /**
+     * 请求的相对地址
+     */
+    @Nullable
+    private final String relativeUrl;
 
-      if (httpMethod == null) {
-        throw methodError(method, "HTTP method annotation is required (e.g., @GET, @POST, etc.).");
-      }
+    /**
+     * 请求头部信息
+     */
+    @Nullable
+    private final Headers headers;
 
-      if (!hasBody) {
-        if (isMultipart) {
-          throw methodError(method,
-              "Multipart can only be specified on HTTP methods with request body (e.g., @POST).");
-        }
-        if (isFormEncoded) {
-          throw methodError(method, "FormUrlEncoded can only be specified on HTTP methods with "
-              + "request body (e.g., @POST).");
-        }
-      }
-
-      int parameterCount = parameterAnnotationsArray.length;
-      parameterHandlers = new ParameterHandler<?>[parameterCount];
-      for (int p = 0; p < parameterCount; p++) {
-        parameterHandlers[p] = parseParameter(p, parameterTypes[p], parameterAnnotationsArray[p]);
-      }
-
-      if (relativeUrl == null && !gotUrl) {
-        throw methodError(method, "Missing either @%s URL or @Url parameter.", httpMethod);
-      }
-      if (!isFormEncoded && !isMultipart && !hasBody && gotBody) {
-        throw methodError(method, "Non-body HTTP method cannot contain @Body.");
-      }
-      if (isFormEncoded && !gotField) {
-        throw methodError(method, "Form-encoded method must contain at least one @Field.");
-      }
-      if (isMultipart && !gotPart) {
-        throw methodError(method, "Multipart method must contain at least one @Part.");
-      }
-
-      return new RequestFactory(this);
+    /**
+     * 数据类型
+     */
+    @Nullable
+    private final MediaType contentType;
+
+
+    private final boolean hasBody;
+    private final boolean isFormEncoded;
+    private final boolean isMultipart;
+    private final ParameterHandler<?>[] parameterHandlers;
+
+    RequestFactory(Builder builder) {
+        method = builder.method;
+        baseUrl = builder.retrofit.baseUrl;
+        httpMethod = builder.httpMethod;
+        relativeUrl = builder.relativeUrl;
+        headers = builder.headers;
+        contentType = builder.contentType;
+        hasBody = builder.hasBody;
+        isFormEncoded = builder.isFormEncoded;
+        isMultipart = builder.isMultipart;
+        parameterHandlers = builder.parameterHandlers;
     }
 
-    private void parseMethodAnnotation(Annotation annotation) {
-      if (annotation instanceof DELETE) {
-        parseHttpMethodAndPath("DELETE", ((DELETE) annotation).value(), false);
-      } else if (annotation instanceof GET) {
-        parseHttpMethodAndPath("GET", ((GET) annotation).value(), false);
-      } else if (annotation instanceof HEAD) {
-        parseHttpMethodAndPath("HEAD", ((HEAD) annotation).value(), false);
-      } else if (annotation instanceof PATCH) {
-        parseHttpMethodAndPath("PATCH", ((PATCH) annotation).value(), true);
-      } else if (annotation instanceof POST) {
-        parseHttpMethodAndPath("POST", ((POST) annotation).value(), true);
-      } else if (annotation instanceof PUT) {
-        parseHttpMethodAndPath("PUT", ((PUT) annotation).value(), true);
-      } else if (annotation instanceof OPTIONS) {
-        parseHttpMethodAndPath("OPTIONS", ((OPTIONS) annotation).value(), false);
-      } else if (annotation instanceof HTTP) {
-        HTTP http = (HTTP) annotation;
-        parseHttpMethodAndPath(http.method(), http.path(), http.hasBody());
-      } else if (annotation instanceof retrofit2.http.Headers) {
-        String[] headersToParse = ((retrofit2.http.Headers) annotation).value();
-        if (headersToParse.length == 0) {
-          throw methodError(method, "@Headers annotation is empty.");
-        }
-        headers = parseHeaders(headersToParse);
-      } else if (annotation instanceof Multipart) {
-        if (isFormEncoded) {
-          throw methodError(method, "Only one encoding annotation is allowed.");
-        }
-        isMultipart = true;
-      } else if (annotation instanceof FormUrlEncoded) {
-        if (isMultipart) {
-          throw methodError(method, "Only one encoding annotation is allowed.");
-        }
-        isFormEncoded = true;
-      }
-    }
+    /**
+     * 将参数信息封装成 OkHttp的请求对象 Request
+     * @param args - 请求参数
+     * @return - OkHttp请求，在执行实际的OkHttp请求时使用
+     * @throws IOException
+     */
+    okhttp3.Request create(Object[] args) throws IOException {
+        @SuppressWarnings("unchecked") // It is an error to invoke a method with the wrong arg types.
+                ParameterHandler<Object>[] handlers = (ParameterHandler<Object>[]) parameterHandlers;
 
-    private void parseHttpMethodAndPath(String httpMethod, String value, boolean hasBody) {
-      if (this.httpMethod != null) {
-        throw methodError(method, "Only one HTTP method is allowed. Found: %s and %s.",
-            this.httpMethod, httpMethod);
-      }
-      this.httpMethod = httpMethod;
-      this.hasBody = hasBody;
-
-      if (value.isEmpty()) {
-        return;
-      }
-
-      // Get the relative URL path and existing query string, if present.
-      int question = value.indexOf('?');
-      if (question != -1 && question < value.length() - 1) {
-        // Ensure the query string does not have any named parameters.
-        String queryParams = value.substring(question + 1);
-        Matcher queryParamMatcher = PARAM_URL_REGEX.matcher(queryParams);
-        if (queryParamMatcher.find()) {
-          throw methodError(method, "URL query string \"%s\" must not have replace block. "
-              + "For dynamic query parameters use @Query.", queryParams);
+        int argumentCount = args.length;
+        if (argumentCount != handlers.length) {
+            throw new IllegalArgumentException("Argument count (" + argumentCount
+                    + ") doesn't match expected count (" + handlers.length + ")");
         }
-      }
 
-      this.relativeUrl = value;
-      this.relativeUrlParamNames = parsePathParameters(value);
-    }
+        RequestBuilder requestBuilder = new RequestBuilder(httpMethod, baseUrl, relativeUrl,
+                headers, contentType, hasBody, isFormEncoded, isMultipart);
 
-    private Headers parseHeaders(String[] headers) {
-      Headers.Builder builder = new Headers.Builder();
-      for (String header : headers) {
-        int colon = header.indexOf(':');
-        if (colon == -1 || colon == 0 || colon == header.length() - 1) {
-          throw methodError(method,
-              "@Headers value must be in the form \"Name: Value\". Found: \"%s\"", header);
+        List<Object> argumentList = new ArrayList<>(argumentCount);
+        for (int p = 0; p < argumentCount; p++) {
+            argumentList.add(args[p]);
+            handlers[p].apply(requestBuilder, args[p]);
         }
-        String headerName = header.substring(0, colon);
-        String headerValue = header.substring(colon + 1).trim();
-        if ("Content-Type".equalsIgnoreCase(headerName)) {
-          try {
-            contentType = MediaType.get(headerValue);
-          } catch (IllegalArgumentException e) {
-            throw methodError(method, e, "Malformed content type: %s", headerValue);
-          }
-        } else {
-          builder.add(headerName, headerValue);
-        }
-      }
-      return builder.build();
-    }
 
-    private ParameterHandler<?> parseParameter(
-        int p, Type parameterType, @Nullable Annotation[] annotations) {
-      ParameterHandler<?> result = null;
-      if (annotations != null) {
-        for (Annotation annotation : annotations) {
-          ParameterHandler<?> annotationAction =
-              parseParameterAnnotation(p, parameterType, annotations, annotation);
+        return requestBuilder.get()
+                .tag(Invocation.class, new Invocation(method, argumentList))
+                .build();
+    }
 
-          if (annotationAction == null) {
-            continue;
-          }
+    /**
+     * Inspects the annotations on an interface method to construct a reusable service method. This
+     * requires potentially-expensive reflection so it is best to build each service method only once
+     * and reuse it. Builders cannot be reused.
+     */
+    static final class Builder {
+        // Upper and lower characters, digits, underscores, and hyphens, starting with a character.
+        private static final String PARAM = "[a-zA-Z][a-zA-Z0-9_-]*";
+        private static final Pattern PARAM_URL_REGEX = Pattern.compile("\\{(" + PARAM + ")\\}");
+        private static final Pattern PARAM_NAME_REGEX = Pattern.compile(PARAM);
+
+        final Retrofit retrofit;
+        final Method method;
+        final Annotation[] methodAnnotations;
+        final Annotation[][] parameterAnnotationsArray;
+        final Type[] parameterTypes;
+
+        boolean gotField;
+        boolean gotPart;
+        boolean gotBody;
+        boolean gotPath;
+        boolean gotQuery;
+        boolean gotQueryName;
+        boolean gotQueryMap;
+        boolean gotUrl;
+        @Nullable
+        String httpMethod;
+        boolean hasBody;
+        boolean isFormEncoded;
+        boolean isMultipart;
+        @Nullable
+        String relativeUrl;
+        @Nullable
+        Headers headers;
+        @Nullable
+        MediaType contentType;
+        @Nullable
+        Set<String> relativeUrlParamNames;
+        @Nullable
+        ParameterHandler<?>[] parameterHandlers;
+
+        Builder(Retrofit retrofit, Method method) {
+            this.retrofit = retrofit;
+            this.method = method;
+            this.methodAnnotations = method.getAnnotations();
+            this.parameterTypes = method.getGenericParameterTypes();
+            this.parameterAnnotationsArray = method.getParameterAnnotations();
+        }
+
+        RequestFactory build() {
+            for (Annotation annotation : methodAnnotations) {
+                parseMethodAnnotation(annotation);
+            }
 
-          if (result != null) {
-            throw parameterError(method, p,
-                "Multiple Retrofit annotations found, only one allowed.");
-          }
+            if (httpMethod == null) {
+                throw methodError(method, "HTTP method annotation is required (e.g., @GET, @POST, etc.).");
+            }
 
-          result = annotationAction;
-        }
-      }
+            if (!hasBody) {
+                if (isMultipart) {
+                    throw methodError(method,
+                            "Multipart can only be specified on HTTP methods with request body (e.g., @POST).");
+                }
+                if (isFormEncoded) {
+                    throw methodError(method, "FormUrlEncoded can only be specified on HTTP methods with "
+                            + "request body (e.g., @POST).");
+                }
+            }
 
-      if (result == null) {
-        throw parameterError(method, p, "No Retrofit annotation found.");
-      }
+            int parameterCount = parameterAnnotationsArray.length;
+            parameterHandlers = new ParameterHandler<?>[parameterCount];
+            for (int p = 0; p < parameterCount; p++) {
+                parameterHandlers[p] = parseParameter(p, parameterTypes[p], parameterAnnotationsArray[p]);
+            }
 
-      return result;
-    }
+            if (relativeUrl == null && !gotUrl) {
+                throw methodError(method, "Missing either @%s URL or @Url parameter.", httpMethod);
+            }
+            if (!isFormEncoded && !isMultipart && !hasBody && gotBody) {
+                throw methodError(method, "Non-body HTTP method cannot contain @Body.");
+            }
+            if (isFormEncoded && !gotField) {
+                throw methodError(method, "Form-encoded method must contain at least one @Field.");
+            }
+            if (isMultipart && !gotPart) {
+                throw methodError(method, "Multipart method must contain at least one @Part.");
+            }
 
-    @Nullable
-    private ParameterHandler<?> parseParameterAnnotation(
-        int p, Type type, Annotation[] annotations, Annotation annotation) {
-      if (annotation instanceof Url) {
-        validateResolvableType(p, type);
-        if (gotUrl) {
-          throw parameterError(method, p, "Multiple @Url method annotations found.");
-        }
-        if (gotPath) {
-          throw parameterError(method, p, "@Path parameters may not be used with @Url.");
-        }
-        if (gotQuery) {
-          throw parameterError(method, p, "A @Url parameter must not come after a @Query.");
-        }
-        if (gotQueryName) {
-          throw parameterError(method, p, "A @Url parameter must not come after a @QueryName.");
-        }
-        if (gotQueryMap) {
-          throw parameterError(method, p, "A @Url parameter must not come after a @QueryMap.");
-        }
-        if (relativeUrl != null) {
-          throw parameterError(method, p, "@Url cannot be used with @%s URL", httpMethod);
+            return new RequestFactory(this);
+        }
+
+        private void parseMethodAnnotation(Annotation annotation) {
+            if (annotation instanceof DELETE) {
+                parseHttpMethodAndPath("DELETE", ((DELETE) annotation).value(), false);
+            } else if (annotation instanceof GET) {
+                parseHttpMethodAndPath("GET", ((GET) annotation).value(), false);
+            } else if (annotation instanceof HEAD) {
+                parseHttpMethodAndPath("HEAD", ((HEAD) annotation).value(), false);
+            } else if (annotation instanceof PATCH) {
+                parseHttpMethodAndPath("PATCH", ((PATCH) annotation).value(), true);
+            } else if (annotation instanceof POST) {
+                parseHttpMethodAndPath("POST", ((POST) annotation).value(), true);
+            } else if (annotation instanceof PUT) {
+                parseHttpMethodAndPath("PUT", ((PUT) annotation).value(), true);
+            } else if (annotation instanceof OPTIONS) {
+                parseHttpMethodAndPath("OPTIONS", ((OPTIONS) annotation).value(), false);
+            } else if (annotation instanceof HTTP) {
+                HTTP http = (HTTP) annotation;
+                parseHttpMethodAndPath(http.method(), http.path(), http.hasBody());
+            } else if (annotation instanceof retrofit2.http.Headers) {
+                String[] headersToParse = ((retrofit2.http.Headers) annotation).value();
+                if (headersToParse.length == 0) {
+                    throw methodError(method, "@Headers annotation is empty.");
+                }
+                headers = parseHeaders(headersToParse);
+            } else if (annotation instanceof Multipart) {
+                if (isFormEncoded) {
+                    throw methodError(method, "Only one encoding annotation is allowed.");
+                }
+                isMultipart = true;
+            } else if (annotation instanceof FormUrlEncoded) {
+                if (isMultipart) {
+                    throw methodError(method, "Only one encoding annotation is allowed.");
+                }
+                isFormEncoded = true;
+            }
         }
 
-        gotUrl = true;
-
-        if (type == HttpUrl.class
-            || type == String.class
-            || type == URI.class
-            || (type instanceof Class && "android.net.Uri".equals(((Class<?>) type).getName()))) {
-          return new ParameterHandler.RelativeUrl();
-        } else {
-          throw parameterError(method, p,
-              "@Url must be okhttp3.HttpUrl, String, java.net.URI, or android.net.Uri type.");
-        }
+        private void parseHttpMethodAndPath(String httpMethod, String value, boolean hasBody) {
+            if (this.httpMethod != null) {
+                throw methodError(method, "Only one HTTP method is allowed. Found: %s and %s.",
+                        this.httpMethod, httpMethod);
+            }
+            this.httpMethod = httpMethod;
+            this.hasBody = hasBody;
 
-      } else if (annotation instanceof Path) {
-        validateResolvableType(p, type);
-        if (gotQuery) {
-          throw parameterError(method, p, "A @Path parameter must not come after a @Query.");
-        }
-        if (gotQueryName) {
-          throw parameterError(method, p, "A @Path parameter must not come after a @QueryName.");
-        }
-        if (gotQueryMap) {
-          throw parameterError(method, p, "A @Path parameter must not come after a @QueryMap.");
-        }
-        if (gotUrl) {
-          throw parameterError(method, p, "@Path parameters may not be used with @Url.");
-        }
-        if (relativeUrl == null) {
-          throw parameterError(method, p, "@Path can only be used with relative url on @%s",
-              httpMethod);
-        }
-        gotPath = true;
-
-        Path path = (Path) annotation;
-        String name = path.value();
-        validatePathName(p, name);
-
-        Converter<?, String> converter = retrofit.stringConverter(type, annotations);
-        return new ParameterHandler.Path<>(name, converter, path.encoded());
-
-      } else if (annotation instanceof Query) {
-        validateResolvableType(p, type);
-        Query query = (Query) annotation;
-        String name = query.value();
-        boolean encoded = query.encoded();
-
-        Class<?> rawParameterType = Utils.getRawType(type);
-        gotQuery = true;
-        if (Iterable.class.isAssignableFrom(rawParameterType)) {
-          if (!(type instanceof ParameterizedType)) {
-            throw parameterError(method, p, rawParameterType.getSimpleName()
-                + " must include generic type (e.g., "
-                + rawParameterType.getSimpleName()
-                + "<String>)");
-          }
-          ParameterizedType parameterizedType = (ParameterizedType) type;
-          Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
-          Converter<?, String> converter =
-              retrofit.stringConverter(iterableType, annotations);
-          return new ParameterHandler.Query<>(name, converter, encoded).iterable();
-        } else if (rawParameterType.isArray()) {
-          Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
-          Converter<?, String> converter =
-              retrofit.stringConverter(arrayComponentType, annotations);
-          return new ParameterHandler.Query<>(name, converter, encoded).array();
-        } else {
-          Converter<?, String> converter =
-              retrofit.stringConverter(type, annotations);
-          return new ParameterHandler.Query<>(name, converter, encoded);
-        }
+            if (value.isEmpty()) {
+                return;
+            }
 
-      } else if (annotation instanceof QueryName) {
-        validateResolvableType(p, type);
-        QueryName query = (QueryName) annotation;
-        boolean encoded = query.encoded();
-
-        Class<?> rawParameterType = Utils.getRawType(type);
-        gotQueryName = true;
-        if (Iterable.class.isAssignableFrom(rawParameterType)) {
-          if (!(type instanceof ParameterizedType)) {
-            throw parameterError(method, p, rawParameterType.getSimpleName()
-                + " must include generic type (e.g., "
-                + rawParameterType.getSimpleName()
-                + "<String>)");
-          }
-          ParameterizedType parameterizedType = (ParameterizedType) type;
-          Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
-          Converter<?, String> converter =
-              retrofit.stringConverter(iterableType, annotations);
-          return new ParameterHandler.QueryName<>(converter, encoded).iterable();
-        } else if (rawParameterType.isArray()) {
-          Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
-          Converter<?, String> converter =
-              retrofit.stringConverter(arrayComponentType, annotations);
-          return new ParameterHandler.QueryName<>(converter, encoded).array();
-        } else {
-          Converter<?, String> converter =
-              retrofit.stringConverter(type, annotations);
-          return new ParameterHandler.QueryName<>(converter, encoded);
-        }
+            // Get the relative URL path and existing query string, if present.
+            int question = value.indexOf('?');
+            if (question != -1 && question < value.length() - 1) {
+                // Ensure the query string does not have any named parameters.
+                String queryParams = value.substring(question + 1);
+                Matcher queryParamMatcher = PARAM_URL_REGEX.matcher(queryParams);
+                if (queryParamMatcher.find()) {
+                    throw methodError(method, "URL query string \"%s\" must not have replace block. "
+                            + "For dynamic query parameters use @Query.", queryParams);
+                }
+            }
 
-      } else if (annotation instanceof QueryMap) {
-        validateResolvableType(p, type);
-        Class<?> rawParameterType = Utils.getRawType(type);
-        gotQueryMap = true;
-        if (!Map.class.isAssignableFrom(rawParameterType)) {
-          throw parameterError(method, p, "@QueryMap parameter type must be Map.");
-        }
-        Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
-        if (!(mapType instanceof ParameterizedType)) {
-          throw parameterError(method, p,
-              "Map must include generic types (e.g., Map<String, String>)");
-        }
-        ParameterizedType parameterizedType = (ParameterizedType) mapType;
-        Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
-        if (String.class != keyType) {
-          throw parameterError(method, p, "@QueryMap keys must be of type String: " + keyType);
-        }
-        Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
-        Converter<?, String> valueConverter =
-            retrofit.stringConverter(valueType, annotations);
-
-        return new ParameterHandler.QueryMap<>(valueConverter, ((QueryMap) annotation).encoded());
-
-      } else if (annotation instanceof Header) {
-        validateResolvableType(p, type);
-        Header header = (Header) annotation;
-        String name = header.value();
-
-        Class<?> rawParameterType = Utils.getRawType(type);
-        if (Iterable.class.isAssignableFrom(rawParameterType)) {
-          if (!(type instanceof ParameterizedType)) {
-            throw parameterError(method, p, rawParameterType.getSimpleName()
-                + " must include generic type (e.g., "
-                + rawParameterType.getSimpleName()
-                + "<String>)");
-          }
-          ParameterizedType parameterizedType = (ParameterizedType) type;
-          Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
-          Converter<?, String> converter =
-              retrofit.stringConverter(iterableType, annotations);
-          return new ParameterHandler.Header<>(name, converter).iterable();
-        } else if (rawParameterType.isArray()) {
-          Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
-          Converter<?, String> converter =
-              retrofit.stringConverter(arrayComponentType, annotations);
-          return new ParameterHandler.Header<>(name, converter).array();
-        } else {
-          Converter<?, String> converter =
-              retrofit.stringConverter(type, annotations);
-          return new ParameterHandler.Header<>(name, converter);
+            this.relativeUrl = value;
+            this.relativeUrlParamNames = parsePathParameters(value);
+        }
+
+        private Headers parseHeaders(String[] headers) {
+            Headers.Builder builder = new Headers.Builder();
+            for (String header : headers) {
+                int colon = header.indexOf(':');
+                if (colon == -1 || colon == 0 || colon == header.length() - 1) {
+                    throw methodError(method,
+                            "@Headers value must be in the form \"Name: Value\". Found: \"%s\"", header);
+                }
+                String headerName = header.substring(0, colon);
+                String headerValue = header.substring(colon + 1).trim();
+                if ("Content-Type".equalsIgnoreCase(headerName)) {
+                    try {
+                        contentType = MediaType.get(headerValue);
+                    } catch (IllegalArgumentException e) {
+                        throw methodError(method, e, "Malformed content type: %s", headerValue);
+                    }
+                } else {
+                    builder.add(headerName, headerValue);
+                }
+            }
+            return builder.build();
         }
 
-      } else if (annotation instanceof HeaderMap) {
-        validateResolvableType(p, type);
-        Class<?> rawParameterType = Utils.getRawType(type);
-        if (!Map.class.isAssignableFrom(rawParameterType)) {
-          throw parameterError(method, p, "@HeaderMap parameter type must be Map.");
-        }
-        Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
-        if (!(mapType instanceof ParameterizedType)) {
-          throw parameterError(method, p,
-              "Map must include generic types (e.g., Map<String, String>)");
-        }
-        ParameterizedType parameterizedType = (ParameterizedType) mapType;
-        Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
-        if (String.class != keyType) {
-          throw parameterError(method, p, "@HeaderMap keys must be of type String: " + keyType);
-        }
-        Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
-        Converter<?, String> valueConverter =
-            retrofit.stringConverter(valueType, annotations);
+        private ParameterHandler<?> parseParameter(
+                int p, Type parameterType, @Nullable Annotation[] annotations) {
+            ParameterHandler<?> result = null;
+            if (annotations != null) {
+                for (Annotation annotation : annotations) {
+                    ParameterHandler<?> annotationAction =
+                            parseParameterAnnotation(p, parameterType, annotations, annotation);
 
-        return new ParameterHandler.HeaderMap<>(valueConverter);
+                    if (annotationAction == null) {
+                        continue;
+                    }
 
-      } else if (annotation instanceof Field) {
-        validateResolvableType(p, type);
-        if (!isFormEncoded) {
-          throw parameterError(method, p, "@Field parameters can only be used with form encoding.");
-        }
-        Field field = (Field) annotation;
-        String name = field.value();
-        boolean encoded = field.encoded();
-
-        gotField = true;
-
-        Class<?> rawParameterType = Utils.getRawType(type);
-        if (Iterable.class.isAssignableFrom(rawParameterType)) {
-          if (!(type instanceof ParameterizedType)) {
-            throw parameterError(method, p, rawParameterType.getSimpleName()
-                + " must include generic type (e.g., "
-                + rawParameterType.getSimpleName()
-                + "<String>)");
-          }
-          ParameterizedType parameterizedType = (ParameterizedType) type;
-          Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
-          Converter<?, String> converter =
-              retrofit.stringConverter(iterableType, annotations);
-          return new ParameterHandler.Field<>(name, converter, encoded).iterable();
-        } else if (rawParameterType.isArray()) {
-          Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
-          Converter<?, String> converter =
-              retrofit.stringConverter(arrayComponentType, annotations);
-          return new ParameterHandler.Field<>(name, converter, encoded).array();
-        } else {
-          Converter<?, String> converter =
-              retrofit.stringConverter(type, annotations);
-          return new ParameterHandler.Field<>(name, converter, encoded);
-        }
+                    if (result != null) {
+                        throw parameterError(method, p,
+                                "Multiple Retrofit annotations found, only one allowed.");
+                    }
 
-      } else if (annotation instanceof FieldMap) {
-        validateResolvableType(p, type);
-        if (!isFormEncoded) {
-          throw parameterError(method, p,
-              "@FieldMap parameters can only be used with form encoding.");
-        }
-        Class<?> rawParameterType = Utils.getRawType(type);
-        if (!Map.class.isAssignableFrom(rawParameterType)) {
-          throw parameterError(method, p, "@FieldMap parameter type must be Map.");
-        }
-        Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
-        if (!(mapType instanceof ParameterizedType)) {
-          throw parameterError(method, p,
-              "Map must include generic types (e.g., Map<String, String>)");
-        }
-        ParameterizedType parameterizedType = (ParameterizedType) mapType;
-        Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
-        if (String.class != keyType) {
-          throw parameterError(method, p, "@FieldMap keys must be of type String: " + keyType);
-        }
-        Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
-        Converter<?, String> valueConverter =
-            retrofit.stringConverter(valueType, annotations);
-
-        gotField = true;
-        return new ParameterHandler.FieldMap<>(valueConverter, ((FieldMap) annotation).encoded());
-
-      } else if (annotation instanceof Part) {
-        validateResolvableType(p, type);
-        if (!isMultipart) {
-          throw parameterError(method, p,
-              "@Part parameters can only be used with multipart encoding.");
-        }
-        Part part = (Part) annotation;
-        gotPart = true;
-
-        String partName = part.value();
-        Class<?> rawParameterType = Utils.getRawType(type);
-        if (partName.isEmpty()) {
-          if (Iterable.class.isAssignableFrom(rawParameterType)) {
-            if (!(type instanceof ParameterizedType)) {
-              throw parameterError(method, p, rawParameterType.getSimpleName()
-                  + " must include generic type (e.g., "
-                  + rawParameterType.getSimpleName()
-                  + "<String>)");
+                    result = annotationAction;
+                }
             }
-            ParameterizedType parameterizedType = (ParameterizedType) type;
-            Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
-            if (!MultipartBody.Part.class.isAssignableFrom(Utils.getRawType(iterableType))) {
-              throw parameterError(method, p,
-                  "@Part annotation must supply a name or use MultipartBody.Part parameter type.");
-            }
-            return ParameterHandler.RawPart.INSTANCE.iterable();
-          } else if (rawParameterType.isArray()) {
-            Class<?> arrayComponentType = rawParameterType.getComponentType();
-            if (!MultipartBody.Part.class.isAssignableFrom(arrayComponentType)) {
-              throw parameterError(method, p,
-                  "@Part annotation must supply a name or use MultipartBody.Part parameter type.");
-            }
-            return ParameterHandler.RawPart.INSTANCE.array();
-          } else if (MultipartBody.Part.class.isAssignableFrom(rawParameterType)) {
-            return ParameterHandler.RawPart.INSTANCE;
-          } else {
-            throw parameterError(method, p,
-                "@Part annotation must supply a name or use MultipartBody.Part parameter type.");
-          }
-        } else {
-          Headers headers =
-              Headers.of("Content-Disposition", "form-data; name=\"" + partName + "\"",
-                  "Content-Transfer-Encoding", part.encoding());
-
-          if (Iterable.class.isAssignableFrom(rawParameterType)) {
-            if (!(type instanceof ParameterizedType)) {
-              throw parameterError(method, p, rawParameterType.getSimpleName()
-                  + " must include generic type (e.g., "
-                  + rawParameterType.getSimpleName()
-                  + "<String>)");
-            }
-            ParameterizedType parameterizedType = (ParameterizedType) type;
-            Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
-            if (MultipartBody.Part.class.isAssignableFrom(Utils.getRawType(iterableType))) {
-              throw parameterError(method, p,
-                  "@Part parameters using the MultipartBody.Part must not "
-                      + "include a part name in the annotation.");
+
+            if (result == null) {
+                throw parameterError(method, p, "No Retrofit annotation found.");
             }
-            Converter<?, RequestBody> converter =
-                retrofit.requestBodyConverter(iterableType, annotations, methodAnnotations);
-            return new ParameterHandler.Part<>(headers, converter).iterable();
-          } else if (rawParameterType.isArray()) {
-            Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
-            if (MultipartBody.Part.class.isAssignableFrom(arrayComponentType)) {
-              throw parameterError(method, p,
-                  "@Part parameters using the MultipartBody.Part must not "
-                      + "include a part name in the annotation.");
+
+            return result;
+        }
+
+        @Nullable
+        private ParameterHandler<?> parseParameterAnnotation(
+                int p, Type type, Annotation[] annotations, Annotation annotation) {
+            if (annotation instanceof Url) {
+                validateResolvableType(p, type);
+                if (gotUrl) {
+                    throw parameterError(method, p, "Multiple @Url method annotations found.");
+                }
+                if (gotPath) {
+                    throw parameterError(method, p, "@Path parameters may not be used with @Url.");
+                }
+                if (gotQuery) {
+                    throw parameterError(method, p, "A @Url parameter must not come after a @Query.");
+                }
+                if (gotQueryName) {
+                    throw parameterError(method, p, "A @Url parameter must not come after a @QueryName.");
+                }
+                if (gotQueryMap) {
+                    throw parameterError(method, p, "A @Url parameter must not come after a @QueryMap.");
+                }
+                if (relativeUrl != null) {
+                    throw parameterError(method, p, "@Url cannot be used with @%s URL", httpMethod);
+                }
+
+                gotUrl = true;
+
+                if (type == HttpUrl.class
+                        || type == String.class
+                        || type == URI.class
+                        || (type instanceof Class && "android.net.Uri".equals(((Class<?>) type).getName()))) {
+                    return new ParameterHandler.RelativeUrl();
+                } else {
+                    throw parameterError(method, p,
+                            "@Url must be okhttp3.HttpUrl, String, java.net.URI, or android.net.Uri type.");
+                }
+
+            } else if (annotation instanceof Path) {
+                validateResolvableType(p, type);
+                if (gotQuery) {
+                    throw parameterError(method, p, "A @Path parameter must not come after a @Query.");
+                }
+                if (gotQueryName) {
+                    throw parameterError(method, p, "A @Path parameter must not come after a @QueryName.");
+                }
+                if (gotQueryMap) {
+                    throw parameterError(method, p, "A @Path parameter must not come after a @QueryMap.");
+                }
+                if (gotUrl) {
+                    throw parameterError(method, p, "@Path parameters may not be used with @Url.");
+                }
+                if (relativeUrl == null) {
+                    throw parameterError(method, p, "@Path can only be used with relative url on @%s",
+                            httpMethod);
+                }
+                gotPath = true;
+
+                Path path = (Path) annotation;
+                String name = path.value();
+                validatePathName(p, name);
+
+                Converter<?, String> converter = retrofit.stringConverter(type, annotations);
+                return new ParameterHandler.Path<>(name, converter, path.encoded());
+
+            } else if (annotation instanceof Query) {
+                validateResolvableType(p, type);
+                Query query = (Query) annotation;
+                String name = query.value();
+                boolean encoded = query.encoded();
+
+                Class<?> rawParameterType = Utils.getRawType(type);
+                gotQuery = true;
+                if (Iterable.class.isAssignableFrom(rawParameterType)) {
+                    if (!(type instanceof ParameterizedType)) {
+                        throw parameterError(method, p, rawParameterType.getSimpleName()
+                                + " must include generic type (e.g., "
+                                + rawParameterType.getSimpleName()
+                                + "<String>)");
+                    }
+                    ParameterizedType parameterizedType = (ParameterizedType) type;
+                    Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
+                    Converter<?, String> converter =
+                            retrofit.stringConverter(iterableType, annotations);
+                    return new ParameterHandler.Query<>(name, converter, encoded).iterable();
+                } else if (rawParameterType.isArray()) {
+                    Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
+                    Converter<?, String> converter =
+                            retrofit.stringConverter(arrayComponentType, annotations);
+                    return new ParameterHandler.Query<>(name, converter, encoded).array();
+                } else {
+                    Converter<?, String> converter =
+                            retrofit.stringConverter(type, annotations);
+                    return new ParameterHandler.Query<>(name, converter, encoded);
+                }
+
+            } else if (annotation instanceof QueryName) {
+                validateResolvableType(p, type);
+                QueryName query = (QueryName) annotation;
+                boolean encoded = query.encoded();
+
+                Class<?> rawParameterType = Utils.getRawType(type);
+                gotQueryName = true;
+                if (Iterable.class.isAssignableFrom(rawParameterType)) {
+                    if (!(type instanceof ParameterizedType)) {
+                        throw parameterError(method, p, rawParameterType.getSimpleName()
+                                + " must include generic type (e.g., "
+                                + rawParameterType.getSimpleName()
+                                + "<String>)");
+                    }
+                    ParameterizedType parameterizedType = (ParameterizedType) type;
+                    Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
+                    Converter<?, String> converter =
+                            retrofit.stringConverter(iterableType, annotations);
+                    return new ParameterHandler.QueryName<>(converter, encoded).iterable();
+                } else if (rawParameterType.isArray()) {
+                    Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
+                    Converter<?, String> converter =
+                            retrofit.stringConverter(arrayComponentType, annotations);
+                    return new ParameterHandler.QueryName<>(converter, encoded).array();
+                } else {
+                    Converter<?, String> converter =
+                            retrofit.stringConverter(type, annotations);
+                    return new ParameterHandler.QueryName<>(converter, encoded);
+                }
+
+            } else if (annotation instanceof QueryMap) {
+                validateResolvableType(p, type);
+                Class<?> rawParameterType = Utils.getRawType(type);
+                gotQueryMap = true;
+                if (!Map.class.isAssignableFrom(rawParameterType)) {
+                    throw parameterError(method, p, "@QueryMap parameter type must be Map.");
+                }
+                Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
+                if (!(mapType instanceof ParameterizedType)) {
+                    throw parameterError(method, p,
+                            "Map must include generic types (e.g., Map<String, String>)");
+                }
+                ParameterizedType parameterizedType = (ParameterizedType) mapType;
+                Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
+                if (String.class != keyType) {
+                    throw parameterError(method, p, "@QueryMap keys must be of type String: " + keyType);
+                }
+                Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
+                Converter<?, String> valueConverter =
+                        retrofit.stringConverter(valueType, annotations);
+
+                return new ParameterHandler.QueryMap<>(valueConverter, ((QueryMap) annotation).encoded());
+
+            } else if (annotation instanceof Header) {
+                validateResolvableType(p, type);
+                Header header = (Header) annotation;
+                String name = header.value();
+
+                Class<?> rawParameterType = Utils.getRawType(type);
+                if (Iterable.class.isAssignableFrom(rawParameterType)) {
+                    if (!(type instanceof ParameterizedType)) {
+                        throw parameterError(method, p, rawParameterType.getSimpleName()
+                                + " must include generic type (e.g., "
+                                + rawParameterType.getSimpleName()
+                                + "<String>)");
+                    }
+                    ParameterizedType parameterizedType = (ParameterizedType) type;
+                    Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
+                    Converter<?, String> converter =
+                            retrofit.stringConverter(iterableType, annotations);
+                    return new ParameterHandler.Header<>(name, converter).iterable();
+                } else if (rawParameterType.isArray()) {
+                    Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
+                    Converter<?, String> converter =
+                            retrofit.stringConverter(arrayComponentType, annotations);
+                    return new ParameterHandler.Header<>(name, converter).array();
+                } else {
+                    Converter<?, String> converter =
+                            retrofit.stringConverter(type, annotations);
+                    return new ParameterHandler.Header<>(name, converter);
+                }
+
+            } else if (annotation instanceof HeaderMap) {
+                validateResolvableType(p, type);
+                Class<?> rawParameterType = Utils.getRawType(type);
+                if (!Map.class.isAssignableFrom(rawParameterType)) {
+                    throw parameterError(method, p, "@HeaderMap parameter type must be Map.");
+                }
+                Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
+                if (!(mapType instanceof ParameterizedType)) {
+                    throw parameterError(method, p,
+                            "Map must include generic types (e.g., Map<String, String>)");
+                }
+                ParameterizedType parameterizedType = (ParameterizedType) mapType;
+                Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
+                if (String.class != keyType) {
+                    throw parameterError(method, p, "@HeaderMap keys must be of type String: " + keyType);
+                }
+                Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
+                Converter<?, String> valueConverter =
+                        retrofit.stringConverter(valueType, annotations);
+
+                return new ParameterHandler.HeaderMap<>(valueConverter);
+
+            } else if (annotation instanceof Field) {
+                validateResolvableType(p, type);
+                if (!isFormEncoded) {
+                    throw parameterError(method, p, "@Field parameters can only be used with form encoding.");
+                }
+                Field field = (Field) annotation;
+                String name = field.value();
+                boolean encoded = field.encoded();
+
+                gotField = true;
+
+                Class<?> rawParameterType = Utils.getRawType(type);
+                if (Iterable.class.isAssignableFrom(rawParameterType)) {
+                    if (!(type instanceof ParameterizedType)) {
+                        throw parameterError(method, p, rawParameterType.getSimpleName()
+                                + " must include generic type (e.g., "
+                                + rawParameterType.getSimpleName()
+                                + "<String>)");
+                    }
+                    ParameterizedType parameterizedType = (ParameterizedType) type;
+                    Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
+                    Converter<?, String> converter =
+                            retrofit.stringConverter(iterableType, annotations);
+                    return new ParameterHandler.Field<>(name, converter, encoded).iterable();
+                } else if (rawParameterType.isArray()) {
+                    Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
+                    Converter<?, String> converter =
+                            retrofit.stringConverter(arrayComponentType, annotations);
+                    return new ParameterHandler.Field<>(name, converter, encoded).array();
+                } else {
+                    Converter<?, String> converter =
+                            retrofit.stringConverter(type, annotations);
+                    return new ParameterHandler.Field<>(name, converter, encoded);
+                }
+
+            } else if (annotation instanceof FieldMap) {
+                validateResolvableType(p, type);
+                if (!isFormEncoded) {
+                    throw parameterError(method, p,
+                            "@FieldMap parameters can only be used with form encoding.");
+                }
+                Class<?> rawParameterType = Utils.getRawType(type);
+                if (!Map.class.isAssignableFrom(rawParameterType)) {
+                    throw parameterError(method, p, "@FieldMap parameter type must be Map.");
+                }
+                Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
+                if (!(mapType instanceof ParameterizedType)) {
+                    throw parameterError(method, p,
+                            "Map must include generic types (e.g., Map<String, String>)");
+                }
+                ParameterizedType parameterizedType = (ParameterizedType) mapType;
+                Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
+                if (String.class != keyType) {
+                    throw parameterError(method, p, "@FieldMap keys must be of type String: " + keyType);
+                }
+                Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
+                Converter<?, String> valueConverter =
+                        retrofit.stringConverter(valueType, annotations);
+
+                gotField = true;
+                return new ParameterHandler.FieldMap<>(valueConverter, ((FieldMap) annotation).encoded());
+
+            } else if (annotation instanceof Part) {
+                validateResolvableType(p, type);
+                if (!isMultipart) {
+                    throw parameterError(method, p,
+                            "@Part parameters can only be used with multipart encoding.");
+                }
+                Part part = (Part) annotation;
+                gotPart = true;
+
+                String partName = part.value();
+                Class<?> rawParameterType = Utils.getRawType(type);
+                if (partName.isEmpty()) {
+                    if (Iterable.class.isAssignableFrom(rawParameterType)) {
+                        if (!(type instanceof ParameterizedType)) {
+                            throw parameterError(method, p, rawParameterType.getSimpleName()
+                                    + " must include generic type (e.g., "
+                                    + rawParameterType.getSimpleName()
+                                    + "<String>)");
+                        }
+                        ParameterizedType parameterizedType = (ParameterizedType) type;
+                        Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
+                        if (!MultipartBody.Part.class.isAssignableFrom(Utils.getRawType(iterableType))) {
+                            throw parameterError(method, p,
+                                    "@Part annotation must supply a name or use MultipartBody.Part parameter type.");
+                        }
+                        return ParameterHandler.RawPart.INSTANCE.iterable();
+                    } else if (rawParameterType.isArray()) {
+                        Class<?> arrayComponentType = rawParameterType.getComponentType();
+                        if (!MultipartBody.Part.class.isAssignableFrom(arrayComponentType)) {
+                            throw parameterError(method, p,
+                                    "@Part annotation must supply a name or use MultipartBody.Part parameter type.");
+                        }
+                        return ParameterHandler.RawPart.INSTANCE.array();
+                    } else if (MultipartBody.Part.class.isAssignableFrom(rawParameterType)) {
+                        return ParameterHandler.RawPart.INSTANCE;
+                    } else {
+                        throw parameterError(method, p,
+                                "@Part annotation must supply a name or use MultipartBody.Part parameter type.");
+                    }
+                } else {
+                    Headers headers =
+                            Headers.of("Content-Disposition", "form-data; name=\"" + partName + "\"",
+                                    "Content-Transfer-Encoding", part.encoding());
+
+                    if (Iterable.class.isAssignableFrom(rawParameterType)) {
+                        if (!(type instanceof ParameterizedType)) {
+                            throw parameterError(method, p, rawParameterType.getSimpleName()
+                                    + " must include generic type (e.g., "
+                                    + rawParameterType.getSimpleName()
+                                    + "<String>)");
+                        }
+                        ParameterizedType parameterizedType = (ParameterizedType) type;
+                        Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
+                        if (MultipartBody.Part.class.isAssignableFrom(Utils.getRawType(iterableType))) {
+                            throw parameterError(method, p,
+                                    "@Part parameters using the MultipartBody.Part must not "
+                                            + "include a part name in the annotation.");
+                        }
+                        Converter<?, RequestBody> converter =
+                                retrofit.requestBodyConverter(iterableType, annotations, methodAnnotations);
+                        return new ParameterHandler.Part<>(headers, converter).iterable();
+                    } else if (rawParameterType.isArray()) {
+                        Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
+                        if (MultipartBody.Part.class.isAssignableFrom(arrayComponentType)) {
+                            throw parameterError(method, p,
+                                    "@Part parameters using the MultipartBody.Part must not "
+                                            + "include a part name in the annotation.");
+                        }
+                        Converter<?, RequestBody> converter =
+                                retrofit.requestBodyConverter(arrayComponentType, annotations, methodAnnotations);
+                        return new ParameterHandler.Part<>(headers, converter).array();
+                    } else if (MultipartBody.Part.class.isAssignableFrom(rawParameterType)) {
+                        throw parameterError(method, p,
+                                "@Part parameters using the MultipartBody.Part must not "
+                                        + "include a part name in the annotation.");
+                    } else {
+                        Converter<?, RequestBody> converter =
+                                retrofit.requestBodyConverter(type, annotations, methodAnnotations);
+                        return new ParameterHandler.Part<>(headers, converter);
+                    }
+                }
+
+            } else if (annotation instanceof PartMap) {
+                validateResolvableType(p, type);
+                if (!isMultipart) {
+                    throw parameterError(method, p,
+                            "@PartMap parameters can only be used with multipart encoding.");
+                }
+                gotPart = true;
+                Class<?> rawParameterType = Utils.getRawType(type);
+                if (!Map.class.isAssignableFrom(rawParameterType)) {
+                    throw parameterError(method, p, "@PartMap parameter type must be Map.");
+                }
+                Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
+                if (!(mapType instanceof ParameterizedType)) {
+                    throw parameterError(method, p,
+                            "Map must include generic types (e.g., Map<String, String>)");
+                }
+                ParameterizedType parameterizedType = (ParameterizedType) mapType;
+
+                Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
+                if (String.class != keyType) {
+                    throw parameterError(method, p, "@PartMap keys must be of type String: " + keyType);
+                }
+
+                Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
+                if (MultipartBody.Part.class.isAssignableFrom(Utils.getRawType(valueType))) {
+                    throw parameterError(method, p, "@PartMap values cannot be MultipartBody.Part. "
+                            + "Use @Part List<Part> or a different value type instead.");
+                }
+
+                Converter<?, RequestBody> valueConverter =
+                        retrofit.requestBodyConverter(valueType, annotations, methodAnnotations);
+
+                PartMap partMap = (PartMap) annotation;
+                return new ParameterHandler.PartMap<>(valueConverter, partMap.encoding());
+
+            } else if (annotation instanceof Body) {
+                validateResolvableType(p, type);
+                if (isFormEncoded || isMultipart) {
+                    throw parameterError(method, p,
+                            "@Body parameters cannot be used with form or multi-part encoding.");
+                }
+                if (gotBody) {
+                    throw parameterError(method, p, "Multiple @Body method annotations found.");
+                }
+
+                Converter<?, RequestBody> converter;
+                try {
+                    converter = retrofit.requestBodyConverter(type, annotations, methodAnnotations);
+                } catch (RuntimeException e) {
+                    // Wide exception range because factories are user code.
+                    throw parameterError(method, e, p, "Unable to create @Body converter for %s", type);
+                }
+                gotBody = true;
+                return new ParameterHandler.Body<>(converter);
             }
-            Converter<?, RequestBody> converter =
-                retrofit.requestBodyConverter(arrayComponentType, annotations, methodAnnotations);
-            return new ParameterHandler.Part<>(headers, converter).array();
-          } else if (MultipartBody.Part.class.isAssignableFrom(rawParameterType)) {
-            throw parameterError(method, p,
-                "@Part parameters using the MultipartBody.Part must not "
-                    + "include a part name in the annotation.");
-          } else {
-            Converter<?, RequestBody> converter =
-                retrofit.requestBodyConverter(type, annotations, methodAnnotations);
-            return new ParameterHandler.Part<>(headers, converter);
-          }
-        }
 
-      } else if (annotation instanceof PartMap) {
-        validateResolvableType(p, type);
-        if (!isMultipart) {
-          throw parameterError(method, p,
-              "@PartMap parameters can only be used with multipart encoding.");
-        }
-        gotPart = true;
-        Class<?> rawParameterType = Utils.getRawType(type);
-        if (!Map.class.isAssignableFrom(rawParameterType)) {
-          throw parameterError(method, p, "@PartMap parameter type must be Map.");
+            return null; // Not a Retrofit annotation.
         }
-        Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
-        if (!(mapType instanceof ParameterizedType)) {
-          throw parameterError(method, p,
-              "Map must include generic types (e.g., Map<String, String>)");
-        }
-        ParameterizedType parameterizedType = (ParameterizedType) mapType;
 
-        Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
-        if (String.class != keyType) {
-          throw parameterError(method, p, "@PartMap keys must be of type String: " + keyType);
+        private void validateResolvableType(int p, Type type) {
+            if (Utils.hasUnresolvableType(type)) {
+                throw parameterError(method, p,
+                        "Parameter type must not include a type variable or wildcard: %s", type);
+            }
         }
 
-        Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
-        if (MultipartBody.Part.class.isAssignableFrom(Utils.getRawType(valueType))) {
-          throw parameterError(method, p, "@PartMap values cannot be MultipartBody.Part. "
-              + "Use @Part List<Part> or a different value type instead.");
+        private void validatePathName(int p, String name) {
+            if (!PARAM_NAME_REGEX.matcher(name).matches()) {
+                throw parameterError(method, p, "@Path parameter name must match %s. Found: %s",
+                        PARAM_URL_REGEX.pattern(), name);
+            }
+            // Verify URL replacement name is actually present in the URL path.
+            if (!relativeUrlParamNames.contains(name)) {
+                throw parameterError(method, p, "URL \"%s\" does not contain \"{%s}\".", relativeUrl, name);
+            }
         }
 
-        Converter<?, RequestBody> valueConverter =
-            retrofit.requestBodyConverter(valueType, annotations, methodAnnotations);
-
-        PartMap partMap = (PartMap) annotation;
-        return new ParameterHandler.PartMap<>(valueConverter, partMap.encoding());
-
-      } else if (annotation instanceof Body) {
-        validateResolvableType(p, type);
-        if (isFormEncoded || isMultipart) {
-          throw parameterError(method, p,
-              "@Body parameters cannot be used with form or multi-part encoding.");
-        }
-        if (gotBody) {
-          throw parameterError(method, p, "Multiple @Body method annotations found.");
+        /**
+         * Gets the set of unique path parameters used in the given URI. If a parameter is used twice
+         * in the URI, it will only show up once in the set.
+         */
+        static Set<String> parsePathParameters(String path) {
+            Matcher m = PARAM_URL_REGEX.matcher(path);
+            Set<String> patterns = new LinkedHashSet<>();
+            while (m.find()) {
+                patterns.add(m.group(1));
+            }
+            return patterns;
         }
 
-        Converter<?, RequestBody> converter;
-        try {
-          converter = retrofit.requestBodyConverter(type, annotations, methodAnnotations);
-        } catch (RuntimeException e) {
-          // Wide exception range because factories are user code.
-          throw parameterError(method, e, p, "Unable to create @Body converter for %s", type);
+        private static Class<?> boxIfPrimitive(Class<?> type) {
+            if (boolean.class == type) return Boolean.class;
+            if (byte.class == type) return Byte.class;
+            if (char.class == type) return Character.class;
+            if (double.class == type) return Double.class;
+            if (float.class == type) return Float.class;
+            if (int.class == type) return Integer.class;
+            if (long.class == type) return Long.class;
+            if (short.class == type) return Short.class;
+            return type;
         }
-        gotBody = true;
-        return new ParameterHandler.Body<>(converter);
-      }
-
-      return null; // Not a Retrofit annotation.
-    }
-
-    private void validateResolvableType(int p, Type type) {
-      if (Utils.hasUnresolvableType(type)) {
-        throw parameterError(method, p,
-            "Parameter type must not include a type variable or wildcard: %s", type);
-      }
-    }
-
-    private void validatePathName(int p, String name) {
-      if (!PARAM_NAME_REGEX.matcher(name).matches()) {
-        throw parameterError(method, p, "@Path parameter name must match %s. Found: %s",
-            PARAM_URL_REGEX.pattern(), name);
-      }
-      // Verify URL replacement name is actually present in the URL path.
-      if (!relativeUrlParamNames.contains(name)) {
-        throw parameterError(method, p, "URL \"%s\" does not contain \"{%s}\".", relativeUrl, name);
-      }
-    }
-
-    /**
-     * Gets the set of unique path parameters used in the given URI. If a parameter is used twice
-     * in the URI, it will only show up once in the set.
-     */
-    static Set<String> parsePathParameters(String path) {
-      Matcher m = PARAM_URL_REGEX.matcher(path);
-      Set<String> patterns = new LinkedHashSet<>();
-      while (m.find()) {
-        patterns.add(m.group(1));
-      }
-      return patterns;
-    }
-
-    private static Class<?> boxIfPrimitive(Class<?> type) {
-      if (boolean.class == type) return Boolean.class;
-      if (byte.class == type) return Byte.class;
-      if (char.class == type) return Character.class;
-      if (double.class == type) return Double.class;
-      if (float.class == type) return Float.class;
-      if (int.class == type) return Integer.class;
-      if (long.class == type) return Long.class;
-      if (short.class == type) return Short.class;
-      return type;
     }
-  }
 }
diff --git a/retrofit/src/main/java/retrofit2/Retrofit.java b/retrofit/src/main/java/retrofit2/Retrofit.java
index 6ee695940..ff6463289 100644
--- a/retrofit/src/main/java/retrofit2/Retrofit.java
+++ b/retrofit/src/main/java/retrofit2/Retrofit.java
@@ -70,6 +70,8 @@
 
   /**
    * 它是请求网络的OkHttp的工厂，用于生产OkHttpClient的工厂
+   * 在OkHttp中，Http请求被抽象为OkHttp3.Call类，它表示一个已经准备好，可以随时执行的Http请求。
+   * 而OkHttpClient 正是用来创建创建Call对象的，通过 OkHttpClient的newCall(Request request)方法
    */
   final okhttp3.Call.Factory callFactory;
 
@@ -79,8 +81,9 @@
   final HttpUrl baseUrl;
 
   /**
-   * 数据转换器工厂集合。
-   * 数据转换器就是对请求网络之后的得到的Response进行转换，转换成能够使用的Java对象。
+   * Converter工厂集合。
+   *
+   * 数据转换器（Converter）：负责把服务器返回的数据（JSON、XML、PB、二进制、其他格式，由ResponseBody封装）转化为T类型的对象。
    * 数据转换器工厂 ： 是用来生产 数据转换器的。
    * <p>
    * 这个集合就是用来 存放 数据转换器工厂的集合
@@ -88,9 +91,12 @@
   final List<Converter.Factory> converterFactories;
 
   /**
-   * 网络请求适配器的工厂集合。
+   * CallAdapter的工厂集合。
    * <p>
-   * 网络请求适配器：就是将call对象转换成其他类型。
+   * CallAdapter：负责把Retrofit中的Call转换成另一种类型T，这个过程会发送Http请求，
+   * 获取到服务器返回的数据（通过OkHttp实现），并把数据转换成声明的T类型（通过Converter<F, T> 实现）
+   *
+   * 注意：把Retrofit中的Call与OkHttp中的Call区分开来，Retrofit中的Call表示的是对一个Retrofit方法的调用
    */
   final List<CallAdapter.Factory> callAdapterFactories;
 
@@ -164,10 +170,15 @@
    */
   @SuppressWarnings("unchecked") // Single-interface proxy creation guarded by parameter safety.
   public <T> T create(final Class<T> service) {
+    // 1、校验是否为接口，且不能继承其他接口
     Utils.validateServiceInterface(service);
+
+    // 2、是否需要提前解析接口方法
     if (validateEagerly) {
       eagerlyValidateMethods(service);
     }
+
+    // 3、动态代理模式，返回一个 Service接口的代理对象
     return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[]{service},
             new InvocationHandler() {
               private final Platform platform = Platform.get();
@@ -178,11 +189,15 @@ public Object invoke(Object proxy, Method method, @Nullable Object[] args)
                       throws Throwable {
                 // If the method is a method from Object then defer to normal invocation.
                 if (method.getDeclaringClass() == Object.class) {
+                  // 如果是Object的方法，那么直接调用，例如 equals，toString
                   return method.invoke(this, args);
                 }
                 if (platform.isDefaultMethod(method)) {
+                  // 如果是Java8中的默认方法，直接调用
                   return platform.invokeDefaultMethod(method, service, proxy, args);
                 }
+
+                // 将接口中的方法构造为 ServiceMethod
                 return loadServiceMethod(method).invoke(args != null ? args : emptyArgs);
               }
             });
@@ -198,13 +213,17 @@ private void eagerlyValidateMethods(Class<?> service) {
   }
 
   ServiceMethod<?> loadServiceMethod(Method method) {
+    // 从 serviceMethodCache中 获取，如果获取成功，则直接返回
     ServiceMethod<?> result = serviceMethodCache.get(method);
     if (result != null) return result;
 
     synchronized (serviceMethodCache) {
       result = serviceMethodCache.get(method);
       if (result == null) {
+        // 通过 ServiceMethod 的 parseAnnotations方法，解析定义的方法的注解信息，并生成ServiceMethod对象
         result = ServiceMethod.parseAnnotations(this, method);
+
+        // 将 生成的 ServiceMethod对象 保存在 serviceMethodCache中
         serviceMethodCache.put(method, result);
       }
     }
@@ -433,7 +452,8 @@ public Builder newBuilder() {
    */
   public static final class Builder {
     /**
-     * Platform：代表了Retrofit所适配的平台
+     * Platform：代表了Retrofit所适配的平台。
+     * Retrofit中支持 Android、java8 和 默认平台
      */
     private final Platform platform;
     private @Nullable
diff --git a/retrofit/src/main/java/retrofit2/ServiceMethod.java b/retrofit/src/main/java/retrofit2/ServiceMethod.java
index 8ddd42254..560a61fda 100644
--- a/retrofit/src/main/java/retrofit2/ServiceMethod.java
+++ b/retrofit/src/main/java/retrofit2/ServiceMethod.java
@@ -20,21 +20,36 @@
 
 import static retrofit2.Utils.methodError;
 
+/**
+ * 把对接口方法的调用转为一次 HTTP 调用。
+ * <p>
+ * 一个ServiceMethod对象 对应于 一个 API interface的一个方法
+ */
 abstract class ServiceMethod<T> {
-  static <T> ServiceMethod<T> parseAnnotations(Retrofit retrofit, Method method) {
-    RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method);
 
-    Type returnType = method.getGenericReturnType();
-    if (Utils.hasUnresolvableType(returnType)) {
-      throw methodError(method,
-          "Method return type must not include a type variable or wildcard: %s", returnType);
-    }
-    if (returnType == void.class) {
-      throw methodError(method, "Service methods cannot return void.");
-    }
+    /**
+     * 解析 Method上的注解，并返回一个ServiceMethod对象，实际上是ServiceMethod的子类HttpServiceMethod
+     */
+    static <T> ServiceMethod<T> parseAnnotations(Retrofit retrofit, Method method) {
 
-    return HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);
-  }
+        // 1、创建 一个 RequestFactory 对象
+        RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method);
+
+        // 2、获取 方法 的 返回值类型，并对返回值类型进行检查
+        Type returnType = method.getGenericReturnType();
+        if (Utils.hasUnresolvableType(returnType)) {
+            // 如果有 不合法的类型，那么 就抛出 方法异常
+            throw methodError(method,
+                    "Method return type must not include a type variable or wildcard: %s", returnType);
+        }
+        // 返回值的类型 不能是 void
+        if (returnType == void.class) {
+            throw methodError(method, "Service methods cannot return void.");
+        }
+
+        // 3、通过 HttpServiceMethod 继续解析
+        return HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);
+    }
 
-  abstract T invoke(Object[] args);
+    abstract T invoke(Object[] args);
 }
diff --git a/retrofit/src/main/java/retrofit2/Utils.java b/retrofit/src/main/java/retrofit2/Utils.java
index 85258222c..ea2e02694 100644
--- a/retrofit/src/main/java/retrofit2/Utils.java
+++ b/retrofit/src/main/java/retrofit2/Utils.java
@@ -323,6 +323,11 @@ static ResponseBody buffer(final ResponseBody body) throws IOException {
     return ResponseBody.create(body.contentType(), body.contentLength(), buffer);
   }
 
+  /**
+   * 检查 这个类型是否是一个 合法的接口类型
+   * 1）必须是接口
+   * 2）这个接口 还必须继承另外的接口
+   */
   static <T> void validateServiceInterface(Class<T> service) {
     if (!service.isInterface()) {
       throw new IllegalArgumentException("API declarations must be interfaces.");
