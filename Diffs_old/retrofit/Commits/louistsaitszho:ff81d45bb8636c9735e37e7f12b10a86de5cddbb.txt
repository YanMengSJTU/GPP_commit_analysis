diff --git a/retrofit/src/main/java/retrofit2/ParameterHandler.java b/retrofit/src/main/java/retrofit2/ParameterHandler.java
index 929413418..71606ce22 100644
--- a/retrofit/src/main/java/retrofit2/ParameterHandler.java
+++ b/retrofit/src/main/java/retrofit2/ParameterHandler.java
@@ -17,6 +17,7 @@
 
 import java.io.IOException;
 import java.lang.reflect.Array;
+import java.util.List;
 import java.util.Map;
 import javax.annotation.Nullable;
 import okhttp3.Headers;
@@ -136,12 +137,14 @@
     }
   }
 
-  static final class QueryMap<T> extends ParameterHandler<Map<String, T>> {
-    private final Converter<T, String> valueConverter;
+  static final class QueryMap<T, S> extends ParameterHandler<Map<String, T>> {
+    @Nullable private final Converter<T, String> valueConverter;
+    @Nullable private final Converter<S, String> listValueConverter;
     private final boolean encoded;
 
-    QueryMap(Converter<T, String> valueConverter, boolean encoded) {
+    QueryMap(@Nullable Converter<T, String> valueConverter, @Nullable Converter<S, String> listValueConverter, boolean encoded) {
       this.valueConverter = valueConverter;
+      this.listValueConverter = listValueConverter;
       this.encoded = encoded;
     }
 
@@ -162,18 +165,35 @@
               "Query map contained null value for key '" + entryKey + "'.");
         }
 
-        String convertedEntryValue = valueConverter.convert(entryValue);
-        if (convertedEntryValue == null) {
-          throw new IllegalArgumentException("Query map value '"
-              + entryValue
-              + "' converted to null by "
-              + valueConverter.getClass().getName()
-              + " for key '"
-              + entryKey
-              + "'.");
+        if (entryValue instanceof List && listValueConverter != null) {
+          List<S> entryValueList = (List<S>) entryValue;    //TODO there's got to be a safer way to do this
+          for (S item :entryValueList) {
+            String convertedEntryValue = listValueConverter.convert(item);
+            if (convertedEntryValue == null) {
+              throw new IllegalArgumentException("Query map in list value '"
+                      + item
+                      + "' converted to null by "
+                      + listValueConverter.getClass().getName()
+                      + " for key '"
+                      + entryKey
+                      + "'.");
+            }
+            builder.addQueryParam(entryKey, convertedEntryValue, encoded);
+          }
+        } else if (valueConverter != null) {
+          String convertedEntryValue = valueConverter.convert(entryValue);
+          if (convertedEntryValue == null) {
+            throw new IllegalArgumentException("Query map value '"
+                    + entryValue
+                    + "' converted to null by "
+                    + valueConverter.getClass().getName()
+                    + " for key '"
+                    + entryKey
+                    + "'.");
+          }
+
+          builder.addQueryParam(entryKey, convertedEntryValue, encoded);
         }
-
-        builder.addQueryParam(entryKey, convertedEntryValue, encoded);
       }
     }
   }
diff --git a/retrofit/src/main/java/retrofit2/RequestFactory.java b/retrofit/src/main/java/retrofit2/RequestFactory.java
index ee1ab0265..94e2ece5c 100644
--- a/retrofit/src/main/java/retrofit2/RequestFactory.java
+++ b/retrofit/src/main/java/retrofit2/RequestFactory.java
@@ -455,10 +455,22 @@ private Headers parseHeaders(String[] headers) {
           throw parameterError(method, p, "@QueryMap keys must be of type String: " + keyType);
         }
         Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
-        Converter<?, String> valueConverter =
-            retrofit.stringConverter(valueType, annotations);
+        Converter<?, String> valueConverter = null;
+        Converter<?, String> listValueConverter = null;
+        if (List.class == valueType) {
+          Type listType = Utils.getSupertype(valueType, Utils.getRawType(valueType), List.class);
+          if (!(listType instanceof ParameterizedType)) {
+            throw parameterError(method, p,
+                    "List must include generic types (e.g. Map<String, List<String>>");
+          }
+          ParameterizedType valueParameterizeType = (ParameterizedType) listType;
+          Type l2ValueType = Utils.getParameterUpperBound(0, valueParameterizeType);
+          listValueConverter = retrofit.stringConverter(l2ValueType, annotations);
+        } else {
+          valueConverter = retrofit.stringConverter(valueType, annotations);
+        }
 
-        return new ParameterHandler.QueryMap<>(valueConverter, ((QueryMap) annotation).encoded());
+        return new ParameterHandler.QueryMap<>(valueConverter, listValueConverter, ((QueryMap) annotation).encoded());
 
       } else if (annotation instanceof Header) {
         validateResolvableType(p, type);
