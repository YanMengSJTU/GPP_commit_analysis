diff --git a/.gitignore b/.gitignore
index 133735f7b..5632d833a 100644
--- a/.gitignore
+++ b/.gitignore
@@ -20,3 +20,6 @@ classes
 obj
 
 .DS_Store
+
+.gradle
+local.properties
diff --git a/README.md b/README.md
index 5c76cebaa..a73462500 100644
--- a/README.md
+++ b/README.md
@@ -1,37 +1,117 @@
-Retrofit
+RetrofitPlus
 ========
+A extension for retrofit2
 
-Type-safe HTTP client for Android and Java by Square, Inc.
+Feature
+--------
 
-For more information please see [the website][1].
+1、Rebase to lastest version of retrofit2(now is retrofit-2.0.0),support all feature of retrofit2.
 
+2、@HTTPS Annotation：config which service use https.
 
-Download
---------
+Example:
+```java
+@HTTPS
+@GET("/search/users")
+Call<GitResult> getUsersByName(@Query("q") String name);
+```
+
+3、Set certificate pinning for https of okhttp3.
+
+Example:
+* put certificate file into assets folder
+```java
+OkHttpClientUtil.getSSLClient(okClient, context, "xxx.pem");
+```
+* set certificate string  directly
+```java
+OkHttpClientUtil.getSSLClientByCertificateString(okClient,  certificateString);
+```
+4、Compatible with Retrofit 1.x,like: put callback into parameter and enqueue directly.
+
+Example:
+```java
+@HTTPS
+@GET("/search/users")
+void getUsersByName2(@Query("q") String name, Callback<GitResult> callback);
+```
+5、Add RetrofitPlusCallBack
+```java
+onCallStart();
+onCallFinish();
+onHttpSuccess(Call<T> call, Response<T> response);
+onHttpFailure(Call<T> call, Response<T> response);
+onNetFailure(Call<T> call, Throwable t);
+```
+
+中文：
+---------
+
+1、已经 rebase 到最新 retrofit2 代码(目前是最新的retrofit2.0.0)，支持原生 retrofit2 所有特性。
+
+2、增加@HTTPS Annotation，可以灵活配置哪些方法使用 https。
 
-Download [the latest JAR][2] or grab via Maven:
-```xml
-<dependency>
-  <groupId>com.squareup.retrofit2</groupId>
-  <artifactId>retrofit</artifactId>
-  <version>2.0.1</version>
-</dependency>
+例如:
+```java
+@HTTPS
+@GET("/search/users")
+Call<GitResult> getUsersByName(@Query("q") String name);
 ```
-or Gradle:
+
+3、为 okhttp3 的 https 设置certificate pinning。
+
+例如:
+* 将证书文件放入assets文件夹
+```java
+OkHttpClientUtil.getSSLClient(okClient, context, "xxx.pem");
+```
+* 直接设置证书字符串
+```java
+OkHttpClientUtil.getSSLClientByCertificateString(okClient,  certificateString);
+```
+
+4、兼容 Retrofit 1.x，可以把 callback 放到参数里，执行方法后直接发送异步请求，此时方法返回值必须void。
+
+ 例如：
+```java
+@GET("/search/users")
+void getUsersByName2(@Query("q") String name, Callback<GitResult> callback);
+```
+5、添加 RetrofitPlusCallBack 类，回调方法更完整清晰
+```java
+onCallStart();
+onCallFinish();
+onHttpSuccess(Call<T> call, Response<T> response);
+onHttpFailure(Call<T> call, Response<T> response);
+onNetFailure(Call<T> call, Throwable t);
+```
+Usage
+--------
+
 ```groovy
-compile 'com.squareup.retrofit2:retrofit:2.0.1'
+repositories {
+    maven {
+        url "https://jitpack.io"
+    }
+}
+dependencies {
+	compile 'com.github.MasonLiuChn:RetrofitPlus:2.0.0.5'
+}
 ```
+Demo：https://github.com/MasonLiuChn/RetrofitPlus/tree/master/retrofit-plus-demo
 
-Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
+Usage of retrofit2.0：https://realm.io/cn/news/droidcon-jake-wharton-simple-http-retrofit-2
 
-Retrofit requires at minimum Java 7 or Android 2.3.
+#Contact me:
 
+- Blog:http://blog.csdn.net/masonblog
 
+- Email:MasonLiuChn@gmail.com
 
 License
 =======
 
-    Copyright 2013 Square, Inc.
+    Copyright 2016 MasonLiu, Inc.
 
     Licensed under the Apache License, Version 2.0 (the "License");
     you may not use this file except in compliance with the License.
@@ -44,8 +124,3 @@ License
     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     See the License for the specific language governing permissions and
     limitations under the License.
-
-
- [1]: http://square.github.io/retrofit/
- [2]: https://search.maven.org/remote_content?g=com.squareup.retrofit&a=retrofit&v=LATEST
- [snap]: https://oss.sonatype.org/content/repositories/snapshots/
diff --git a/retrofit-plus-demo/.gitignore b/retrofit-plus-demo/.gitignore
new file mode 100644
index 000000000..796b96d1c
--- /dev/null
+++ b/retrofit-plus-demo/.gitignore
@@ -0,0 +1 @@
+/build
diff --git a/retrofit-plus-demo/build.gradle b/retrofit-plus-demo/build.gradle
new file mode 100644
index 000000000..d0b7bbd5d
--- /dev/null
+++ b/retrofit-plus-demo/build.gradle
@@ -0,0 +1,35 @@
+apply plugin: 'com.android.application'
+
+android {
+    compileSdkVersion 23
+    buildToolsVersion "23.0.2"
+
+    defaultConfig {
+        applicationId "net.masonliu.retrofit2plus.demo"
+        minSdkVersion 14
+        targetSdkVersion 23
+        versionCode 1
+        versionName "1.0"
+    }
+    buildTypes {
+        release {
+            minifyEnabled false
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
+        }
+    }
+}
+
+repositories {
+    maven { url "https://jitpack.io" }
+}
+
+dependencies {
+    compile fileTree(dir: 'libs', include: ['*.jar'])
+    testCompile 'junit:junit:4.12'
+    compile 'com.android.support:appcompat-v7:23.1.1'
+    compile project(':retrofit')
+    compile ('com.squareup.retrofit2:converter-gson:2.0.0') {
+        exclude module: 'retrofit'
+    }
+    //compile 'com.github.MasonLiuChn:RetrofitPlus:2.0.0.1'
+}
diff --git a/retrofit-plus-demo/proguard-rules.pro b/retrofit-plus-demo/proguard-rules.pro
new file mode 100644
index 000000000..e7118966c
--- /dev/null
+++ b/retrofit-plus-demo/proguard-rules.pro
@@ -0,0 +1,17 @@
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in /Users/liumeng/Documents/AndroidSDK/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the proguardFiles
+# directive in build.gradle.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
diff --git a/retrofit-plus-demo/src/androidTest/java/net/masonliu/retrofit2plus/demo/ApplicationTest.java b/retrofit-plus-demo/src/androidTest/java/net/masonliu/retrofit2plus/demo/ApplicationTest.java
new file mode 100644
index 000000000..d9b22f3c9
--- /dev/null
+++ b/retrofit-plus-demo/src/androidTest/java/net/masonliu/retrofit2plus/demo/ApplicationTest.java
@@ -0,0 +1,13 @@
+package net.masonliu.retrofit2plus.demo;
+
+import android.app.Application;
+import android.test.ApplicationTestCase;
+
+/**
+ * <a href="http://d.android.com/tools/testing/testing_android.html">Testing Fundamentals</a>
+ */
+public class ApplicationTest extends ApplicationTestCase<Application> {
+    public ApplicationTest() {
+        super(Application.class);
+    }
+}
\ No newline at end of file
diff --git a/retrofit-plus-demo/src/main/AndroidManifest.xml b/retrofit-plus-demo/src/main/AndroidManifest.xml
new file mode 100644
index 000000000..a7f1dcf9a
--- /dev/null
+++ b/retrofit-plus-demo/src/main/AndroidManifest.xml
@@ -0,0 +1,26 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="net.masonliu.retrofit2plus.demo">
+    <!-- 网络 -->
+    <uses-permission android:name="android.permission.INTERNET" />
+    <uses-permission android:name="android.permission.ACCESS_WIFI_STATE" />
+    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
+    <uses-permission android:name="android.permission.CHANGE_WIFI_STATE" />
+    <uses-permission android:name="android.permission.READ_PHONE_STATE" />
+
+    <application
+        android:allowBackup="true"
+        android:icon="@mipmap/ic_launcher"
+        android:label="@string/app_name"
+        android:supportsRtl="true"
+        android:theme="@style/AppTheme">
+        <activity android:name=".MainActivity">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+
+                <category android:name="android.intent.category.LAUNCHER" />
+            </intent-filter>
+        </activity>
+    </application>
+
+</manifest>
diff --git a/retrofit-plus-demo/src/main/assets/Baidu.pem b/retrofit-plus-demo/src/main/assets/Baidu.pem
new file mode 100644
index 000000000..8b53e0ff9
--- /dev/null
+++ b/retrofit-plus-demo/src/main/assets/Baidu.pem
@@ -0,0 +1,37 @@
+-----BEGIN CERTIFICATE-----
+MIIGaTCCBVGgAwIBAgIQN23AqZqLxKVCT8qo88qpAzANBgkqhkiG9w0BAQUFADCB
+vDELMAkGA1UEBhMCVVMxFzAVBgNVBAoTDlZlcmlTaWduLCBJbmMuMR8wHQYDVQQL
+ExZWZXJpU2lnbiBUcnVzdCBOZXR3b3JrMTswOQYDVQQLEzJUZXJtcyBvZiB1c2Ug
+YXQgaHR0cHM6Ly93d3cudmVyaXNpZ24uY29tL3JwYSAoYykxMDE2MDQGA1UEAxMt
+VmVyaVNpZ24gQ2xhc3MgMyBJbnRlcm5hdGlvbmFsIFNlcnZlciBDQSAtIEczMB4X
+DTE1MDQxNjAwMDAwMFoXDTE2MDQxNjIzNTk1OVowgaoxCzAJBgNVBAYTAkNOMRAw
+DgYDVQQIEwdiZWlqaW5nMRAwDgYDVQQHFAdiZWlqaW5nMTkwNwYDVQQKFDBCZWlK
+aW5nIEJhaWR1IE5ldGNvbSBTY2llbmNlIFRlY2hub2xvZ3kgQ28uLCBMdGQxJTAj
+BgNVBAsUHHNlcnZpY2Ugb3BlcmF0aW9uIGRlcGFydG1lbnQxFTATBgNVBAMUDHd3
+dy5iYWlkdS5jbjCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBANWCP46U
+yot79anMBfFoTg8n6Fj7Jsa2NpvJdZ+NT6D+ZZEp7BdWQkUtHup3Ohu/Nmuy0D9I
+sxCMV23hPMOf8Ha+xYmfP0ege81IMENnI7d2NkE4PRWD7rVWsL/OjUGNUm1Pbvz3
+1PY28M9SZZLfy9uAlGspZ/r5TQy7TtiMt/Ol4tBA3PjcOrlL5ik6KJf7iNKm0gDE
+rF37JUvuVQjFxRYb9R2O1L9Lvxff/5JmOJTCdTTff1Pt6mb/j/vlVyCCARFz7leN
+1GUCfcSAhr4Ow/j5PNVO6sdJoL4JbLqgLl/7oaS8cGMc581LI64qSfaTAgTd3x9r
+UEwvuHrdbXpXUCsCAwEAAaOCAnUwggJxMIIBGgYDVR0RBIIBETCCAQ2CCGJhaWR1
+LmNuggliYWlkdS5jb22CDGJhaWR1LmNvbS5jboILdy5iYWlkdS5jb22CDHd3LmJh
+aWR1LmNvbYIMd3d3LmJhaWR1LmNughB3d3cuYmFpZHUuY29tLmNughB3d3cuYmFp
+ZHUuY29tLmhrggx3d3cuYmFpZHUuaGuCEHd3dy5iYWlkdS5uZXQuYXWCEHd3dy5i
+YWlkdS5uZXQubXmCEHd3dy5iYWlkdS5uZXQucGiCEHd3dy5iYWlkdS5uZXQucGuC
+EHd3dy5iYWlkdS5uZXQudHeCEHd3dy5iYWlkdS5uZXQudm6CDnd3d3cuYmFpZHUu
+Y29tghF3d3d3LmJhaWR1LmNvbS5jbjAJBgNVHRMEAjAAMA4GA1UdDwEB/wQEAwIF
+oDAoBgNVHSUEITAfBggrBgEFBQcDAQYIKwYBBQUHAwIGCWCGSAGG+EIEATBlBgNV
+HSAEXjBcMFoGCmCGSAGG+EUBBzYwTDAjBggrBgEFBQcCARYXaHR0cHM6Ly9kLnN5
+bWNiLmNvbS9jcHMwJQYIKwYBBQUHAgIwGRoXaHR0cHM6Ly9kLnN5bWNiLmNvbS9y
+cGEwHwYDVR0jBBgwFoAU15t82CKgFffdrV/OKZtYw7xGALUwKwYDVR0fBCQwIjAg
+oB6gHIYaaHR0cDovL3NlLnN5bWNiLmNvbS9zZS5jcmwwVwYIKwYBBQUHAQEESzBJ
+MB8GCCsGAQUFBzABhhNodHRwOi8vc2Uuc3ltY2QuY29tMCYGCCsGAQUFBzAChhpo
+dHRwOi8vc2Uuc3ltY2IuY29tL3NlLmNydDANBgkqhkiG9w0BAQUFAAOCAQEAXm3C
+4yOWxuG5h7KXjMjFzo7qzRN8GrkeENzm82GTaxwo3Op7WJv64DdreE9SSa3EHnXW
+R72bvLU+f8Fq41Ptx24tBlv5tKtk1Z5/7hwIGJLRwh0i+OICKlW5tu71DhnJvZkD
+/dEwfc6PygFTMEu4rLM8RlMSy9JM0FIGQeKoA2YfVd5rV/Z3dNb2y1YOMg1VE2EZ
+23aKSXj1/dSd/KmSuoHI1dcOAnFXXRDJS37RejsOrq4sXiYhb7oOnErarVA9IpMs
+cnM7TvlhUztnyzMpD1ABWjt/kqL2Wyx+CKfr4/Zd54i89fD+6jSMyS3iZIhtgXxd
+CIhENC7RHoQqph7JJQ==
+-----END CERTIFICATE-----
\ No newline at end of file
diff --git a/retrofit-plus-demo/src/main/java/net/masonliu/retrofit2plus/demo/MainActivity.java b/retrofit-plus-demo/src/main/java/net/masonliu/retrofit2plus/demo/MainActivity.java
new file mode 100644
index 000000000..e93f0a63b
--- /dev/null
+++ b/retrofit-plus-demo/src/main/java/net/masonliu/retrofit2plus/demo/MainActivity.java
@@ -0,0 +1,101 @@
+package net.masonliu.retrofit2plus.demo;
+
+import android.os.Bundle;
+import android.support.v7.app.AppCompatActivity;
+import android.util.Log;
+
+import net.masonliu.retrofit2plus.demo.model.GitResult;
+
+import retrofit2.Call;
+import retrofit2.Response;
+import retrofit2.plus.RetrofitPlusCallBack;
+
+public class MainActivity extends AppCompatActivity {
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.activity_main);
+//        Call<GitResult> call = RestApi.getApiService().getUsersByName("Mason","ss");
+//        call.enqueue(new Callback<GitResult>() {
+//
+//            @Override
+//            public void onResponse(Call<GitResult> call, Response<GitResult> response) {
+//                GitResult gitResult = response.body();
+//                Log.e("retrofit_plus", "success:" + response.raw().request().url().toString() + "\n"
+//                        + gitResult.getTotalCount());
+//            }
+//
+//            @Override
+//            public void onFailure(Call<GitResult> call, Throwable t) {
+//                Log.e("retrofit_plus", "failure");
+//            }
+//
+//            @Override
+//            public void onStart() {
+//                Log.e("retrofit_plus", "start");
+//            }
+//
+//            @Override
+//            public void onFinish() {
+//                Log.e("retrofit_plus", "finish");
+//            }
+//
+//        });
+
+        RestApi.getApiService(this).getUsersByName2("Mason",new RetrofitPlusCallBack<GitResult>() {
+
+            @Override
+            public void onCallStart() {
+                Log.e("retrofit_plus", "start");
+            }
+
+            @Override
+            public void onCallFinish() {
+                Log.e("retrofit_plus", "finish");
+            }
+
+            @Override
+            public void onHttpSuccess(Call<GitResult> call, Response<GitResult> response) {
+                GitResult gitResult = response.body();
+                Log.e("retrofit_plus", "success:" + response.raw().request().url().toString() + "\n"
+                        + gitResult.getTotalCount());
+            }
+
+            @Override
+            public void onHttpFailure(Call<GitResult> call, Response<GitResult> response) {
+
+            }
+
+            @Override
+            public void onNetFailure(Call<GitResult> call, Throwable t) {
+
+            }
+
+        });
+
+//        RestApi.getApiService(this).testHttps(new Callback<HttpsResult>() {
+//            @Override
+//            public void onResponse(Call<HttpsResult> call, Response<HttpsResult> response) {
+//                HttpsResult gitResult = response.body();
+//                Log.e("retrofit_plus", "success:" + response.raw().request().url().toString() + "\n"
+//                        + gitResult.getCode());
+//            }
+//
+//            @Override
+//            public void onFailure(Call<HttpsResult> call, Throwable t) {
+//                Log.e("retrofit_plus", "failure:");
+//            }
+//
+//            @Override
+//            public void onCallStart() {
+//
+//            }
+//
+//            @Override
+//            public void onCallFinish() {
+//
+//            }
+//        });
+    }
+}
diff --git a/retrofit-plus-demo/src/main/java/net/masonliu/retrofit2plus/demo/RestApi.java b/retrofit-plus-demo/src/main/java/net/masonliu/retrofit2plus/demo/RestApi.java
new file mode 100644
index 000000000..3fcc64ecc
--- /dev/null
+++ b/retrofit-plus-demo/src/main/java/net/masonliu/retrofit2plus/demo/RestApi.java
@@ -0,0 +1,93 @@
+package net.masonliu.retrofit2plus.demo;
+
+import android.content.Context;
+
+import net.masonliu.retrofit2plus.demo.model.GitResult;
+import net.masonliu.retrofit2plus.demo.model.HttpsResult;
+
+import okhttp3.OkHttpClient;
+import retrofit2.Call;
+import retrofit2.Callback;
+import retrofit2.Retrofit;
+import retrofit2.converter.gson.GsonConverterFactory;
+import retrofit2.http.GET;
+import retrofit2.http.Headers;
+import retrofit2.http.Query;
+import retrofit2.plus.HTTPS;
+
+/**
+ * Created by liumeng on 1/18/16.
+ */
+public class RestApi {
+    private static String certificateString = "-----BEGIN CERTIFICATE-----\n" +
+            "MIIGaTCCBVGgAwIBAgIQN23AqZqLxKVCT8qo88qpAzANBgkqhkiG9w0BAQUFADCB\n" +
+            "vDELMAkGA1UEBhMCVVMxFzAVBgNVBAoTDlZlcmlTaWduLCBJbmMuMR8wHQYDVQQL\n" +
+            "ExZWZXJpU2lnbiBUcnVzdCBOZXR3b3JrMTswOQYDVQQLEzJUZXJtcyBvZiB1c2Ug\n" +
+            "YXQgaHR0cHM6Ly93d3cudmVyaXNpZ24uY29tL3JwYSAoYykxMDE2MDQGA1UEAxMt\n" +
+            "VmVyaVNpZ24gQ2xhc3MgMyBJbnRlcm5hdGlvbmFsIFNlcnZlciBDQSAtIEczMB4X\n" +
+            "DTE1MDQxNjAwMDAwMFoXDTE2MDQxNjIzNTk1OVowgaoxCzAJBgNVBAYTAkNOMRAw\n" +
+            "DgYDVQQIEwdiZWlqaW5nMRAwDgYDVQQHFAdiZWlqaW5nMTkwNwYDVQQKFDBCZWlK\n" +
+            "aW5nIEJhaWR1IE5ldGNvbSBTY2llbmNlIFRlY2hub2xvZ3kgQ28uLCBMdGQxJTAj\n" +
+            "BgNVBAsUHHNlcnZpY2Ugb3BlcmF0aW9uIGRlcGFydG1lbnQxFTATBgNVBAMUDHd3\n" +
+            "dy5iYWlkdS5jbjCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBANWCP46U\n" +
+            "yot79anMBfFoTg8n6Fj7Jsa2NpvJdZ+NT6D+ZZEp7BdWQkUtHup3Ohu/Nmuy0D9I\n" +
+            "sxCMV23hPMOf8Ha+xYmfP0ege81IMENnI7d2NkE4PRWD7rVWsL/OjUGNUm1Pbvz3\n" +
+            "1PY28M9SZZLfy9uAlGspZ/r5TQy7TtiMt/Ol4tBA3PjcOrlL5ik6KJf7iNKm0gDE\n" +
+            "rF37JUvuVQjFxRYb9R2O1L9Lvxff/5JmOJTCdTTff1Pt6mb/j/vlVyCCARFz7leN\n" +
+            "1GUCfcSAhr4Ow/j5PNVO6sdJoL4JbLqgLl/7oaS8cGMc581LI64qSfaTAgTd3x9r\n" +
+            "UEwvuHrdbXpXUCsCAwEAAaOCAnUwggJxMIIBGgYDVR0RBIIBETCCAQ2CCGJhaWR1\n" +
+            "LmNuggliYWlkdS5jb22CDGJhaWR1LmNvbS5jboILdy5iYWlkdS5jb22CDHd3LmJh\n" +
+            "aWR1LmNvbYIMd3d3LmJhaWR1LmNughB3d3cuYmFpZHUuY29tLmNughB3d3cuYmFp\n" +
+            "ZHUuY29tLmhrggx3d3cuYmFpZHUuaGuCEHd3dy5iYWlkdS5uZXQuYXWCEHd3dy5i\n" +
+            "YWlkdS5uZXQubXmCEHd3dy5iYWlkdS5uZXQucGiCEHd3dy5iYWlkdS5uZXQucGuC\n" +
+            "EHd3dy5iYWlkdS5uZXQudHeCEHd3dy5iYWlkdS5uZXQudm6CDnd3d3cuYmFpZHUu\n" +
+            "Y29tghF3d3d3LmJhaWR1LmNvbS5jbjAJBgNVHRMEAjAAMA4GA1UdDwEB/wQEAwIF\n" +
+            "oDAoBgNVHSUEITAfBggrBgEFBQcDAQYIKwYBBQUHAwIGCWCGSAGG+EIEATBlBgNV\n" +
+            "HSAEXjBcMFoGCmCGSAGG+EUBBzYwTDAjBggrBgEFBQcCARYXaHR0cHM6Ly9kLnN5\n" +
+            "bWNiLmNvbS9jcHMwJQYIKwYBBQUHAgIwGRoXaHR0cHM6Ly9kLnN5bWNiLmNvbS9y\n" +
+            "cGEwHwYDVR0jBBgwFoAU15t82CKgFffdrV/OKZtYw7xGALUwKwYDVR0fBCQwIjAg\n" +
+            "oB6gHIYaaHR0cDovL3NlLnN5bWNiLmNvbS9zZS5jcmwwVwYIKwYBBQUHAQEESzBJ\n" +
+            "MB8GCCsGAQUFBzABhhNodHRwOi8vc2Uuc3ltY2QuY29tMCYGCCsGAQUFBzAChhpo\n" +
+            "dHRwOi8vc2Uuc3ltY2IuY29tL3NlLmNydDANBgkqhkiG9w0BAQUFAAOCAQEAXm3C\n" +
+            "4yOWxuG5h7KXjMjFzo7qzRN8GrkeENzm82GTaxwo3Op7WJv64DdreE9SSa3EHnXW\n" +
+            "R72bvLU+f8Fq41Ptx24tBlv5tKtk1Z5/7hwIGJLRwh0i+OICKlW5tu71DhnJvZkD\n" +
+            "/dEwfc6PygFTMEu4rLM8RlMSy9JM0FIGQeKoA2YfVd5rV/Z3dNb2y1YOMg1VE2EZ\n" +
+            "23aKSXj1/dSd/KmSuoHI1dcOAnFXXRDJS37RejsOrq4sXiYhb7oOnErarVA9IpMs\n" +
+            "cnM7TvlhUztnyzMpD1ABWjt/kqL2Wyx+CKfr4/Zd54i89fD+6jSMyS3iZIhtgXxd\n" +
+            "CIhENC7RHoQqph7JJQ==\n" +
+            "-----END CERTIFICATE-----";
+    private static GitApiService gitApiService;
+    private static String baseUrl = "http://api.github.com";
+    public static GitApiService getApiService(Context context) {
+        if (gitApiService == null) {
+            OkHttpClient okClient = new OkHttpClient();
+            //okClient = OkHttpClientUtil.getSSLClient(okClient, context, "Baidu.pem");
+            //okClient = OkHttpClientUtil.getSSLClientByCertificateString(okClient,  certificateString);
+            Retrofit client = new Retrofit.Builder()
+                    .baseUrl(baseUrl)
+                    .client(okClient)
+                    .addConverterFactory(GsonConverterFactory.create())
+                    .build();
+            gitApiService = client.create(GitApiService.class);
+        }
+        return gitApiService;
+    }
+
+    public interface GitApiService {
+
+        @HTTPS
+        @Headers("User-Agent: Retrofit2.0Tutorial-App")
+        @GET("/search/users")
+        Call<GitResult> getUsersByName(@Query("q") String name);
+
+        @HTTPS
+        @Headers("User-Agent: Retrofit2.0Tutorial-App")
+        @GET("/search/users")
+        void getUsersByName2(@Query("q") String name, Callback<GitResult> callback);
+
+        @HTTPS
+        @GET("/settlement/bank/showBanks")
+        void testHttps(Callback<HttpsResult> callback);
+    }
+
+}
diff --git a/retrofit-plus-demo/src/main/java/net/masonliu/retrofit2plus/demo/model/GitResult.java b/retrofit-plus-demo/src/main/java/net/masonliu/retrofit2plus/demo/model/GitResult.java
new file mode 100644
index 000000000..2b1d62c9d
--- /dev/null
+++ b/retrofit-plus-demo/src/main/java/net/masonliu/retrofit2plus/demo/model/GitResult.java
@@ -0,0 +1,38 @@
+package net.masonliu.retrofit2plus.demo.model;
+
+import com.google.gson.annotations.SerializedName;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public class GitResult {
+
+    @SerializedName("total_count")
+    private int totalCount;
+    private boolean incompleteResults;
+    private List<Item> items = new ArrayList<Item>();
+
+    public int getTotalCount() {
+        return totalCount;
+    }
+
+    public void setTotalCount(int totalCount) {
+        this.totalCount = totalCount;
+    }
+
+    public boolean isIncompleteResults() {
+        return incompleteResults;
+    }
+
+    public void setIncompleteResults(boolean incompleteResults) {
+        this.incompleteResults = incompleteResults;
+    }
+
+    public List<Item> getItems() {
+        return items;
+    }
+
+    public void setItems(List<Item> items) {
+        this.items = items;
+    }
+}
\ No newline at end of file
diff --git a/retrofit-plus-demo/src/main/java/net/masonliu/retrofit2plus/demo/model/HttpsResult.java b/retrofit-plus-demo/src/main/java/net/masonliu/retrofit2plus/demo/model/HttpsResult.java
new file mode 100644
index 000000000..f2425c700
--- /dev/null
+++ b/retrofit-plus-demo/src/main/java/net/masonliu/retrofit2plus/demo/model/HttpsResult.java
@@ -0,0 +1,29 @@
+package net.masonliu.retrofit2plus.demo.model;
+
+import com.google.gson.annotations.SerializedName;
+
+/**
+ * Created by liumeng on 3/29/16.
+ */
+public class HttpsResult {
+    @SerializedName("code")
+    private int code;
+    @SerializedName("message")
+    private String message;
+
+    public int getCode() {
+        return code;
+    }
+
+    public void setCode(int code) {
+        this.code = code;
+    }
+
+    public String getMessage() {
+        return message;
+    }
+
+    public void setMessage(String message) {
+        this.message = message;
+    }
+}
diff --git a/retrofit-plus-demo/src/main/java/net/masonliu/retrofit2plus/demo/model/Item.java b/retrofit-plus-demo/src/main/java/net/masonliu/retrofit2plus/demo/model/Item.java
new file mode 100644
index 000000000..b8acc6160
--- /dev/null
+++ b/retrofit-plus-demo/src/main/java/net/masonliu/retrofit2plus/demo/model/Item.java
@@ -0,0 +1,275 @@
+package net.masonliu.retrofit2plus.demo.model;
+
+public class Item {
+
+    private String login;
+    private int id;
+    private String avatarUrl;
+    private String gravatarId;
+    private String url;
+    private String htmlUrl;
+    private String followersUrl;
+    private String followingUrl;
+    private String gistsUrl;
+    private String starredUrl;
+    private String subscriptionsUrl;
+    private String organizationsUrl;
+    private String reposUrl;
+    private String eventsUrl;
+    private String receivedEventsUrl;
+    private String type;
+    private boolean siteAdmin;
+    private float score;
+    /**
+     * @return The login
+     */
+    public String getLogin() {
+        return login;
+    }
+
+    /**
+     * @param login The login
+     */
+    public void setLogin(String login) {
+        this.login = login;
+    }
+
+    /**
+     * @return The id
+     */
+    public int getId() {
+        return id;
+    }
+
+    /**
+     * @param id The id
+     */
+    public void setId(int id) {
+        this.id = id;
+    }
+
+    /**
+     * @return The avatarUrl
+     */
+    public String getAvatarUrl() {
+        return avatarUrl;
+    }
+
+    /**
+     * @param avatarUrl The avatar_url
+     */
+    public void setAvatarUrl(String avatarUrl) {
+        this.avatarUrl = avatarUrl;
+    }
+
+    /**
+     * @return The gravatarId
+     */
+    public String getGravatarId() {
+        return gravatarId;
+    }
+
+    /**
+     * @param gravatarId The gravatar_id
+     */
+    public void setGravatarId(String gravatarId) {
+        this.gravatarId = gravatarId;
+    }
+
+    /**
+     * @return The url
+     */
+    public String getUrl() {
+        return url;
+    }
+
+    /**
+     * @param url The url
+     */
+    public void setUrl(String url) {
+        this.url = url;
+    }
+
+    /**
+     * @return The htmlUrl
+     */
+    public String getHtmlUrl() {
+        return htmlUrl;
+    }
+
+    /**
+     * @param htmlUrl The html_url
+     */
+    public void setHtmlUrl(String htmlUrl) {
+        this.htmlUrl = htmlUrl;
+    }
+
+    /**
+     * @return The followersUrl
+     */
+    public String getFollowersUrl() {
+        return followersUrl;
+    }
+
+    /**
+     * @param followersUrl The followers_url
+     */
+    public void setFollowersUrl(String followersUrl) {
+        this.followersUrl = followersUrl;
+    }
+
+    /**
+     * @return The followingUrl
+     */
+    public String getFollowingUrl() {
+        return followingUrl;
+    }
+
+    /**
+     * @param followingUrl The following_url
+     */
+    public void setFollowingUrl(String followingUrl) {
+        this.followingUrl = followingUrl;
+    }
+
+    /**
+     * @return The gistsUrl
+     */
+    public String getGistsUrl() {
+        return gistsUrl;
+    }
+
+    /**
+     * @param gistsUrl The gists_url
+     */
+    public void setGistsUrl(String gistsUrl) {
+        this.gistsUrl = gistsUrl;
+    }
+
+    /**
+     * @return The starredUrl
+     */
+    public String getStarredUrl() {
+        return starredUrl;
+    }
+
+    /**
+     * @param starredUrl The starred_url
+     */
+    public void setStarredUrl(String starredUrl) {
+        this.starredUrl = starredUrl;
+    }
+
+    /**
+     * @return The subscriptionsUrl
+     */
+    public String getSubscriptionsUrl() {
+        return subscriptionsUrl;
+    }
+
+    /**
+     * @param subscriptionsUrl The subscriptions_url
+     */
+    public void setSubscriptionsUrl(String subscriptionsUrl) {
+        this.subscriptionsUrl = subscriptionsUrl;
+    }
+
+    /**
+     * @return The organizationsUrl
+     */
+    public String getOrganizationsUrl() {
+        return organizationsUrl;
+    }
+
+    /**
+     * @param organizationsUrl The organizations_url
+     */
+    public void setOrganizationsUrl(String organizationsUrl) {
+        this.organizationsUrl = organizationsUrl;
+    }
+
+    /**
+     * @return The reposUrl
+     */
+    public String getReposUrl() {
+        return reposUrl;
+    }
+
+    /**
+     * @param reposUrl The repos_url
+     */
+    public void setReposUrl(String reposUrl) {
+        this.reposUrl = reposUrl;
+    }
+
+    /**
+     * @return The eventsUrl
+     */
+    public String getEventsUrl() {
+        return eventsUrl;
+    }
+
+    /**
+     * @param eventsUrl The events_url
+     */
+    public void setEventsUrl(String eventsUrl) {
+        this.eventsUrl = eventsUrl;
+    }
+
+    /**
+     * @return The receivedEventsUrl
+     */
+    public String getReceivedEventsUrl() {
+        return receivedEventsUrl;
+    }
+
+    /**
+     * @param receivedEventsUrl The received_events_url
+     */
+    public void setReceivedEventsUrl(String receivedEventsUrl) {
+        this.receivedEventsUrl = receivedEventsUrl;
+    }
+
+    /**
+     * @return The type
+     */
+    public String getType() {
+        return type;
+    }
+
+    /**
+     * @param type The type
+     */
+    public void setType(String type) {
+        this.type = type;
+    }
+
+    /**
+     * @return The siteAdmin
+     */
+    public boolean isSiteAdmin() {
+        return siteAdmin;
+    }
+
+    /**
+     * @param siteAdmin The site_admin
+     */
+    public void setSiteAdmin(boolean siteAdmin) {
+        this.siteAdmin = siteAdmin;
+    }
+
+    /**
+     * @return The score
+     */
+    public float getScore() {
+        return score;
+    }
+
+    /**
+     * @param score The score
+     */
+    public void setScore(float score) {
+        this.score = score;
+    }
+
+}
\ No newline at end of file
diff --git a/retrofit-plus-demo/src/main/res/layout/activity_main.xml b/retrofit-plus-demo/src/main/res/layout/activity_main.xml
new file mode 100644
index 000000000..f5e60fa88
--- /dev/null
+++ b/retrofit-plus-demo/src/main/res/layout/activity_main.xml
@@ -0,0 +1,12 @@
+<?xml version="1.0" encoding="utf-8"?>
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent"
+    android:layout_height="match_parent" android:paddingBottom="@dimen/activity_vertical_margin"
+    android:paddingLeft="@dimen/activity_horizontal_margin"
+    android:paddingRight="@dimen/activity_horizontal_margin"
+    android:paddingTop="@dimen/activity_vertical_margin"
+    tools:context="net.masonliu.retrofit2plus.demo.MainActivity">
+
+    <TextView android:layout_width="wrap_content" android:layout_height="wrap_content"
+        android:text="Hello World!" />
+</RelativeLayout>
diff --git a/retrofit-plus-demo/src/main/res/mipmap-hdpi/ic_launcher.png b/retrofit-plus-demo/src/main/res/mipmap-hdpi/ic_launcher.png
new file mode 100644
index 000000000..cde69bccc
Binary files /dev/null and b/retrofit-plus-demo/src/main/res/mipmap-hdpi/ic_launcher.png differ
diff --git a/retrofit-plus-demo/src/main/res/mipmap-mdpi/ic_launcher.png b/retrofit-plus-demo/src/main/res/mipmap-mdpi/ic_launcher.png
new file mode 100644
index 000000000..c133a0cbd
Binary files /dev/null and b/retrofit-plus-demo/src/main/res/mipmap-mdpi/ic_launcher.png differ
diff --git a/retrofit-plus-demo/src/main/res/mipmap-xhdpi/ic_launcher.png b/retrofit-plus-demo/src/main/res/mipmap-xhdpi/ic_launcher.png
new file mode 100644
index 000000000..bfa42f0e7
Binary files /dev/null and b/retrofit-plus-demo/src/main/res/mipmap-xhdpi/ic_launcher.png differ
diff --git a/retrofit-plus-demo/src/main/res/mipmap-xxhdpi/ic_launcher.png b/retrofit-plus-demo/src/main/res/mipmap-xxhdpi/ic_launcher.png
new file mode 100644
index 000000000..324e72cdd
Binary files /dev/null and b/retrofit-plus-demo/src/main/res/mipmap-xxhdpi/ic_launcher.png differ
diff --git a/retrofit-plus-demo/src/main/res/mipmap-xxxhdpi/ic_launcher.png b/retrofit-plus-demo/src/main/res/mipmap-xxxhdpi/ic_launcher.png
new file mode 100644
index 000000000..aee44e138
Binary files /dev/null and b/retrofit-plus-demo/src/main/res/mipmap-xxxhdpi/ic_launcher.png differ
diff --git a/retrofit-plus-demo/src/main/res/values-w820dp/dimens.xml b/retrofit-plus-demo/src/main/res/values-w820dp/dimens.xml
new file mode 100644
index 000000000..63fc81644
--- /dev/null
+++ b/retrofit-plus-demo/src/main/res/values-w820dp/dimens.xml
@@ -0,0 +1,6 @@
+<resources>
+    <!-- Example customization of dimensions originally defined in res/values/dimens.xml
+         (such as screen margins) for screens with more than 820dp of available width. This
+         would include 7" and 10" devices in landscape (~960dp and ~1280dp respectively). -->
+    <dimen name="activity_horizontal_margin">64dp</dimen>
+</resources>
diff --git a/retrofit-plus-demo/src/main/res/values/colors.xml b/retrofit-plus-demo/src/main/res/values/colors.xml
new file mode 100644
index 000000000..3ab3e9cbc
--- /dev/null
+++ b/retrofit-plus-demo/src/main/res/values/colors.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <color name="colorPrimary">#3F51B5</color>
+    <color name="colorPrimaryDark">#303F9F</color>
+    <color name="colorAccent">#FF4081</color>
+</resources>
diff --git a/retrofit-plus-demo/src/main/res/values/dimens.xml b/retrofit-plus-demo/src/main/res/values/dimens.xml
new file mode 100644
index 000000000..47c822467
--- /dev/null
+++ b/retrofit-plus-demo/src/main/res/values/dimens.xml
@@ -0,0 +1,5 @@
+<resources>
+    <!-- Default screen margins, per the Android Design guidelines. -->
+    <dimen name="activity_horizontal_margin">16dp</dimen>
+    <dimen name="activity_vertical_margin">16dp</dimen>
+</resources>
diff --git a/retrofit-plus-demo/src/main/res/values/strings.xml b/retrofit-plus-demo/src/main/res/values/strings.xml
new file mode 100644
index 000000000..de3b9bdf7
--- /dev/null
+++ b/retrofit-plus-demo/src/main/res/values/strings.xml
@@ -0,0 +1,3 @@
+<resources>
+    <string name="app_name">retrofit-plus-demo</string>
+</resources>
diff --git a/retrofit-plus-demo/src/main/res/values/styles.xml b/retrofit-plus-demo/src/main/res/values/styles.xml
new file mode 100644
index 000000000..5885930df
--- /dev/null
+++ b/retrofit-plus-demo/src/main/res/values/styles.xml
@@ -0,0 +1,11 @@
+<resources>
+
+    <!-- Base application theme. -->
+    <style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar">
+        <!-- Customize your theme here. -->
+        <item name="colorPrimary">@color/colorPrimary</item>
+        <item name="colorPrimaryDark">@color/colorPrimaryDark</item>
+        <item name="colorAccent">@color/colorAccent</item>
+    </style>
+
+</resources>
diff --git a/retrofit-plus-demo/src/test/java/net/masonliu/retrofit2plus/demo/ExampleUnitTest.java b/retrofit-plus-demo/src/test/java/net/masonliu/retrofit2plus/demo/ExampleUnitTest.java
new file mode 100644
index 000000000..59f201a09
--- /dev/null
+++ b/retrofit-plus-demo/src/test/java/net/masonliu/retrofit2plus/demo/ExampleUnitTest.java
@@ -0,0 +1,15 @@
+package net.masonliu.retrofit2plus.demo;
+
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
+/**
+ * To work on unit tests, switch the Test Artifact in the Build Variants view.
+ */
+public class ExampleUnitTest {
+    @Test
+    public void addition_isCorrect() throws Exception {
+        assertEquals(4, 2 + 2);
+    }
+}
\ No newline at end of file
diff --git a/retrofit/.gitignore b/retrofit/.gitignore
new file mode 100644
index 000000000..796b96d1c
--- /dev/null
+++ b/retrofit/.gitignore
@@ -0,0 +1 @@
+/build
diff --git a/retrofit/build.gradle b/retrofit/build.gradle
index 9e7a78a4a..1c1e2caa4 100644
--- a/retrofit/build.gradle
+++ b/retrofit/build.gradle
@@ -1,5 +1,3 @@
-
-
 apply plugin: 'com.android.library'
 
 android {
@@ -20,14 +18,9 @@ android {
     }
 }
 
-
-repositories {
-    maven { url 'https://oss.sonatype.org/content/repositories/snapshots/' }
-}
-
 dependencies {
     compile fileTree(dir: 'libs', include: ['*.jar'])
-    compile 'com.squareup.okhttp3:okhttp:3.0.0-SNAPSHOT'
+    compile 'com.squareup.okhttp3:okhttp:3.2.0'
     compile 'com.android.support:appcompat-v7:23.1.1'
     compile 'org.codehaus.mojo:animal-sniffer-annotations:1.14'
 }
\ No newline at end of file
diff --git a/retrofit/src/main/java/retrofit2/Callback.java b/retrofit/src/main/java/retrofit2/Callback.java
index 62c93a621..a83bffaf3 100644
--- a/retrofit/src/main/java/retrofit2/Callback.java
+++ b/retrofit/src/main/java/retrofit2/Callback.java
@@ -42,4 +42,8 @@
    * exception occurred creating the request or processing the response.
    */
   void onFailure(Call<T> call, Throwable t);
+
+  void onCallStart();
+
+  void onCallFinish();
 }
diff --git a/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java b/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java
index 95ecbf4b7..e1bcd0ffd 100644
--- a/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java
+++ b/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java
@@ -19,6 +19,7 @@
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
 import java.util.concurrent.Executor;
+
 import okhttp3.Request;
 
 final class ExecutorCallAdapterFactory extends CallAdapter.Factory {
@@ -57,6 +58,11 @@
     @Override public void enqueue(final Callback<T> callback) {
       if (callback == null) throw new NullPointerException("callback == null");
 
+      callbackExecutor.execute(new Runnable() {
+        @Override public void run() {
+          callback.onCallStart();
+        }
+      });
       delegate.enqueue(new Callback<T>() {
         @Override public void onResponse(final Call<T> call, final Response<T> response) {
           callbackExecutor.execute(new Runnable() {
@@ -67,6 +73,7 @@
               } else {
                 callback.onResponse(call, response);
               }
+              callback.onCallFinish();
             }
           });
         }
@@ -75,9 +82,20 @@
           callbackExecutor.execute(new Runnable() {
             @Override public void run() {
               callback.onFailure(call, t);
+              callback.onCallFinish();
             }
           });
         }
+
+        @Override
+        public void onCallStart() {
+
+        }
+
+        @Override
+        public void onCallFinish() {
+
+        }
       });
     }
 
diff --git a/retrofit/src/main/java/retrofit2/Platform.java b/retrofit/src/main/java/retrofit2/Platform.java
index e67159bff..444b80b18 100644
--- a/retrofit/src/main/java/retrofit2/Platform.java
+++ b/retrofit/src/main/java/retrofit2/Platform.java
@@ -18,12 +18,11 @@
 import android.os.Build;
 import android.os.Handler;
 import android.os.Looper;
-import java.lang.invoke.MethodHandles.Lookup;
-import java.lang.reflect.Constructor;
+
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.util.concurrent.Executor;
-import org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement;
+
 
 class Platform {
   private static final Platform PLATFORM = findPlatform();
@@ -40,16 +39,16 @@ private static Platform findPlatform() {
       }
     } catch (ClassNotFoundException ignored) {
     }
-    try {
-      Class.forName("java.util.Optional");
-      return new Java8();
-    } catch (ClassNotFoundException ignored) {
-    }
-    try {
-      Class.forName("org.robovm.apple.foundation.NSObject");
-      return new IOS();
-    } catch (ClassNotFoundException ignored) {
-    }
+//    try {
+//      Class.forName("java.util.Optional");
+//      return new Java8();
+//    } catch (ClassNotFoundException ignored) {
+//    }
+//    try {
+//      Class.forName("org.robovm.apple.foundation.NSObject");
+//      return new IOS();
+//    } catch (ClassNotFoundException ignored) {
+//    }
     return new Platform();
   }
 
@@ -73,24 +72,24 @@ Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object
     throw new UnsupportedOperationException();
   }
 
-  @IgnoreJRERequirement // Only classloaded and used on Java 8.
-  static class Java8 extends Platform {
-    @Override boolean isDefaultMethod(Method method) {
-      return method.isDefault();
-    }
-
-    @Override Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object,
-        Object... args) throws Throwable {
-      // Because the service interface might not be public, we need to use a MethodHandle lookup
-      // that ignores the visibility of the declaringClass.
-      Constructor<Lookup> constructor = Lookup.class.getDeclaredConstructor(Class.class, int.class);
-      constructor.setAccessible(true);
-      return constructor.newInstance(declaringClass, -1 /* trusted */)
-          .unreflectSpecial(method, declaringClass)
-          .bindTo(object)
-          .invokeWithArguments(args);
-    }
-  }
+//  @IgnoreJRERequirement // Only classloaded and used on Java 8.
+//  static class Java8 extends Platform {
+//    @Override boolean isDefaultMethod(Method method) {
+//      return method.isDefault();
+//    }
+//
+//    @Override Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object,
+//        Object... args) throws Throwable {
+//      // Because the service interface might not be public, we need to use a MethodHandle lookup
+//      // that ignores the visibility of the declaringClass.
+//      Constructor<Lookup> constructor = Lookup.class.getDeclaredConstructor(Class.class, int.class);
+//      constructor.setAccessible(true);
+//      return constructor.newInstance(declaringClass, -1 /* trusted */)
+//          .unreflectSpecial(method, declaringClass)
+//          .bindTo(object)
+//          .invokeWithArguments(args);
+//    }
+//  }
 
   static class Android extends Platform {
     @Override public Executor defaultCallbackExecutor() {
diff --git a/retrofit/src/main/java/retrofit2/Response.java b/retrofit/src/main/java/retrofit2/Response.java
index 939363b3d..cb0518f00 100644
--- a/retrofit/src/main/java/retrofit2/Response.java
+++ b/retrofit/src/main/java/retrofit2/Response.java
@@ -85,6 +85,7 @@
   private final okhttp3.Response rawResponse;
   private final T body;
   private final ResponseBody errorBody;
+  private String errorBodyString;
 
   private Response(okhttp3.Response rawResponse, T body, ResponseBody errorBody) {
     this.rawResponse = rawResponse;
@@ -92,6 +93,20 @@ private Response(okhttp3.Response rawResponse, T body, ResponseBody errorBody) {
     this.errorBody = errorBody;
   }
 
+  /** The error response body string. */
+  public String errorBodyString() {
+    if(errorBodyString != null){
+      return errorBodyString;
+    }
+    try{
+      errorBodyString = errorBody.string();
+    }catch (Exception e){
+      e.printStackTrace();
+      errorBodyString = "";
+    }
+    return errorBodyString;
+  }
+
   /** The raw response from the HTTP client. */
   public okhttp3.Response raw() {
     return rawResponse;
diff --git a/retrofit/src/main/java/retrofit2/Retrofit.java b/retrofit/src/main/java/retrofit2/Retrofit.java
index e612069de..3f7455e40 100644
--- a/retrofit/src/main/java/retrofit2/Retrofit.java
+++ b/retrofit/src/main/java/retrofit2/Retrofit.java
@@ -33,6 +33,7 @@
 import retrofit2.http.HTTP;
 import retrofit2.http.Header;
 import retrofit2.http.Url;
+import retrofit2.plus.RetrofitUtil;
 
 import static java.util.Collections.unmodifiableList;
 import static retrofit2.Utils.checkNotNull;
@@ -144,6 +145,11 @@
             }
             ServiceMethod serviceMethod = loadServiceMethod(method);
             OkHttpCall okHttpCall = new OkHttpCall<>(serviceMethod, args);
+            // 如果参数里有 callback 则 直接执行
+            if (RetrofitUtil.isDirectCall(method,args)) {
+              Call call = (Call)serviceMethod.callAdapter.adapt(okHttpCall);
+              call.enqueue((Callback) args[args.length - 1]);
+            }
             return serviceMethod.callAdapter.adapt(okHttpCall);
           }
         });
diff --git a/retrofit/src/main/java/retrofit2/ServiceMethod.java b/retrofit/src/main/java/retrofit2/ServiceMethod.java
index a05568859..ef816ea3f 100644
--- a/retrofit/src/main/java/retrofit2/ServiceMethod.java
+++ b/retrofit/src/main/java/retrofit2/ServiceMethod.java
@@ -53,6 +53,8 @@
 import retrofit2.http.Query;
 import retrofit2.http.QueryMap;
 import retrofit2.http.Url;
+import retrofit2.plus.HTTPS;
+import retrofit2.plus.RetrofitUtil;
 
 /** Adapts an invocation of an interface method into an HTTP call. */
 final class ServiceMethod<T> {
@@ -78,7 +80,7 @@
   ServiceMethod(Builder<T> builder) {
     this.callFactory = builder.retrofit.callFactory();
     this.callAdapter = builder.callAdapter;
-    this.baseUrl = builder.retrofit.baseUrl();
+    this.baseUrl = builder.baseUrl;
     this.responseConverter = builder.responseConverter;
     this.httpMethod = builder.httpMethod;
     this.relativeUrl = builder.relativeUrl;
@@ -98,13 +100,13 @@ Request toRequest(Object... args) throws IOException {
     @SuppressWarnings("unchecked") // It is an error to invoke a method with the wrong arg types.
     ParameterHandler<Object>[] handlers = (ParameterHandler<Object>[]) parameterHandlers;
 
-    int argumentCount = args != null ? args.length : 0;
-    if (argumentCount != handlers.length) {
-      throw new IllegalArgumentException("Argument count (" + argumentCount
-          + ") doesn't match expected count (" + handlers.length + ")");
-    }
+//    int argumentCount = args != null ? args.length : 0;
+//    if (argumentCount != handlers.length) {
+//      throw new IllegalArgumentException("Argument count (" + argumentCount
+//          + ") doesn't match expected count (" + handlers.length + ")");
+//    }
 
-    for (int p = 0; p < argumentCount; p++) {
+    for (int p = 0; p < handlers.length; p++) {
       handlers[p].apply(requestBuilder, args[p]);
     }
 
@@ -146,13 +148,15 @@ T toResponse(ResponseBody body) throws IOException {
     ParameterHandler<?>[] parameterHandlers;
     Converter<ResponseBody, T> responseConverter;
     CallAdapter<?> callAdapter;
+    HttpUrl baseUrl;
 
     public Builder(Retrofit retrofit, Method method) {
       this.retrofit = retrofit;
       this.method = method;
       this.methodAnnotations = method.getAnnotations();
       this.parameterTypes = method.getGenericParameterTypes();
-      this.parameterAnnotationsArray = method.getParameterAnnotations();
+      this.parameterAnnotationsArray = RetrofitUtil.getParameterAnnotationsWithCallbackArg(method);
+      this.baseUrl = retrofit.baseUrl();
     }
 
     public ServiceMethod build() {
@@ -218,13 +222,10 @@ public ServiceMethod build() {
     }
 
     private CallAdapter<?> createCallAdapter() {
-      Type returnType = method.getGenericReturnType();
+      Type returnType = RetrofitUtil.getReturnTypeIfWithCallbackArg(method);
       if (Utils.hasUnresolvableType(returnType)) {
         throw methodError(
-            "Method return type must not include a type variable or wildcard: %s", returnType);
-      }
-      if (returnType == void.class) {
-        throw methodError("Service methods cannot return void.");
+                "Method return type must not include a type variable or wildcard: %s", returnType);
       }
       Annotation[] annotations = method.getAnnotations();
       try {
@@ -271,6 +272,8 @@ private void parseMethodAnnotation(Annotation annotation) {
           throw methodError("Only one encoding annotation is allowed.");
         }
         isFormEncoded = true;
+      } else if (annotation instanceof HTTPS) {
+        baseUrl = RetrofitUtil.convertHttpsUrl(baseUrl);
       }
     }
 
diff --git a/retrofit/src/test/java/retrofit2/TestingUtils.java b/retrofit/src/main/java/retrofit2/plus/HTTPS.java
similarity index 62%
rename from retrofit/src/test/java/retrofit2/TestingUtils.java
rename to retrofit/src/main/java/retrofit2/plus/HTTPS.java
index 3847509ea..09774e619 100644
--- a/retrofit/src/test/java/retrofit2/TestingUtils.java
+++ b/retrofit/src/main/java/retrofit2/plus/HTTPS.java
@@ -13,16 +13,19 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.plus;
 
-import java.lang.reflect.Method;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/** Make a HTTPS request. */
+@Documented
+@Target(METHOD)
+@Retention(RUNTIME)
+public @interface HTTPS {
 
-public final class TestingUtils {
-  public static Method onlyMethod(Class c) {
-    Method[] declaredMethods = c.getDeclaredMethods();
-    if (declaredMethods.length == 1) {
-      return declaredMethods[0];
-    }
-    throw new IllegalArgumentException("More than one method declared.");
-  }
 }
diff --git a/retrofit/src/main/java/retrofit2/plus/OkHttpClientUtil.java b/retrofit/src/main/java/retrofit2/plus/OkHttpClientUtil.java
new file mode 100644
index 000000000..8272d3a15
--- /dev/null
+++ b/retrofit/src/main/java/retrofit2/plus/OkHttpClientUtil.java
@@ -0,0 +1,105 @@
+package retrofit2.plus;
+
+import android.content.Context;
+
+import java.io.ByteArrayInputStream;
+import java.io.InputStream;
+import java.security.KeyStore;
+import java.security.SecureRandom;
+import java.security.cert.Certificate;
+import java.security.cert.CertificateFactory;
+import java.util.Collection;
+import java.util.Iterator;
+
+import javax.net.ssl.KeyManagerFactory;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.TrustManagerFactory;
+
+import okhttp3.OkHttpClient;
+
+/**
+ * Created by liumeng on 1/18/16.
+ */
+public class OkHttpClientUtil {
+    private OkHttpClientUtil() {
+    }
+
+    public static OkHttpClient getSSLClient(OkHttpClient client, Context context, String assetsSSLFileName) {
+        InputStream inputStream = trustedCertificatesInputStream(context, assetsSSLFileName);
+        return getSSLClientByInputStream(client, inputStream);
+    }
+
+    public static OkHttpClient getSSLClientByCertificateString(OkHttpClient client, String certificate) {
+        InputStream inputStream = trustedCertificatesInputStreamByCertificateString(certificate);
+        return getSSLClientByInputStream(client, inputStream);
+    }
+
+    private static OkHttpClient getSSLClientByInputStream(OkHttpClient client, InputStream inputStream) {
+        if (inputStream != null) {
+            SSLContext sslContext = sslContextForTrustedCertificates(inputStream);
+            if (sslContext != null) {
+                client = client.newBuilder().sslSocketFactory(sslContext.getSocketFactory()).build();
+            }
+        }
+        return client;
+    }
+
+    private static InputStream trustedCertificatesInputStream(Context context, String assetsFileName) {
+        try {
+            return context.getAssets().open(assetsFileName);
+        } catch (Exception var3) {
+            return null;
+        }
+    }
+
+    private static InputStream trustedCertificatesInputStreamByCertificateString(String certificate) {
+        try {
+            return new ByteArrayInputStream(certificate.getBytes("UTF-8"));
+        } catch (Exception var3) {
+            return null;
+        }
+    }
+
+    private static SSLContext sslContextForTrustedCertificates(InputStream in) {
+        try {
+            CertificateFactory e = CertificateFactory.getInstance("X.509");
+            Collection certificates = e.generateCertificates(in);
+            if (certificates.isEmpty()) {
+                throw new IllegalArgumentException("expected non-empty set of trusted certificates");
+            } else {
+                char[] password = "password".toCharArray();
+                KeyStore keyStore = newEmptyKeyStore(password);
+                int index = 0;
+                Iterator keyManagerFactory = certificates.iterator();
+                while (keyManagerFactory.hasNext()) {
+                    Certificate trustManagerFactory = (Certificate) keyManagerFactory.next();
+                    String sslContext = Integer.toString(index++);
+                    keyStore.setCertificateEntry(sslContext, trustManagerFactory);
+                }
+
+                KeyManagerFactory var10 = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
+                var10.init(keyStore, password);
+                TrustManagerFactory var11 = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
+                var11.init(keyStore);
+                SSLContext var12 = SSLContext.getInstance("TLS");
+                var12.init(var10.getKeyManagers(), var11.getTrustManagers(), new SecureRandom());
+                return var12;
+            }
+        } catch (Exception var9) {
+            var9.printStackTrace();
+        }
+        return null;
+    }
+
+    private static KeyStore newEmptyKeyStore(char[] password) {
+        try {
+            KeyStore e = KeyStore.getInstance(KeyStore.getDefaultType());
+            Object in = null;
+            e.load((InputStream) in, password);
+            return e;
+        } catch (Exception var3) {
+            var3.printStackTrace();
+        }
+        return null;
+    }
+}
diff --git a/retrofit/src/main/java/retrofit2/plus/RetrofitPlusCallBack.java b/retrofit/src/main/java/retrofit2/plus/RetrofitPlusCallBack.java
new file mode 100644
index 000000000..5ded5a8d3
--- /dev/null
+++ b/retrofit/src/main/java/retrofit2/plus/RetrofitPlusCallBack.java
@@ -0,0 +1,32 @@
+package retrofit2.plus;
+
+import retrofit2.Call;
+import retrofit2.Callback;
+import retrofit2.Response;
+
+/**
+ * Created by liumeng on 3/21/16.
+ */
+public abstract class RetrofitPlusCallBack<T> implements Callback<T> {
+    @Deprecated
+    @Override
+    public void onResponse(Call<T> call, Response<T> response) {
+        if (response.code() >= 200 && response.code() < 300) {
+            onHttpSuccess(call, response);
+        } else {
+            onHttpFailure(call, response);
+        }
+    }
+
+    @Deprecated
+    @Override
+    public void onFailure(Call<T> call, Throwable t) {
+        onNetFailure(call, t);
+    }
+
+    public abstract void onHttpSuccess(Call<T> call, Response<T> response);
+
+    public abstract void onHttpFailure(Call<T> call, Response<T> response);
+
+    public abstract void onNetFailure(Call<T> call, Throwable t);
+}
diff --git a/retrofit/src/main/java/retrofit2/plus/RetrofitUtil.java b/retrofit/src/main/java/retrofit2/plus/RetrofitUtil.java
new file mode 100644
index 000000000..ec1aac50d
--- /dev/null
+++ b/retrofit/src/main/java/retrofit2/plus/RetrofitUtil.java
@@ -0,0 +1,92 @@
+package retrofit2.plus;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Method;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+
+import okhttp3.HttpUrl;
+import retrofit2.Call;
+import retrofit2.Callback;
+
+/**
+ * Created by liumeng on 1/18/16.
+ */
+public class RetrofitUtil {
+    public static HttpUrl convertHttpsUrl(HttpUrl httpUrl) {
+        if (!httpUrl.isHttps()) {
+            return httpUrl.newBuilder().scheme("https").port(443).build();
+        }
+        return httpUrl;
+    }
+
+    public static Annotation[][] getParameterAnnotationsWithCallbackArg(Method method) {
+        Annotation[][] raw = method.getParameterAnnotations();
+        //最后一个参数是 callback 的情况
+        if (raw.length > 0 && raw[raw.length - 1].length == 0) {
+            Annotation[][] now = new Annotation[raw.length - 1][];
+            for (int i = 0; i < now.length; i++) {
+                now[i] = new Annotation[raw[i].length];
+                for (int j = 0; j < now[i].length; j++) {
+                    now[i][j] = raw[i][j];
+                }
+            }
+            return now;
+        }
+        return raw;
+    }
+
+    public static boolean isDirectCall(Method method, Object[] args) {
+        Type returnType = method.getGenericReturnType();
+        if (returnType == void.class && args.length > 0 && args[args.length - 1] instanceof Callback) {
+            return true;
+        }
+        return false;
+    }
+
+    public static Type getReturnTypeIfWithCallbackArg(Method method) {
+        Type returnType = method.getGenericReturnType();
+        if (returnType == void.class) {
+            Type lastArgType = null;
+            Class<?> lastArgClass = null;
+            Type[] parameterTypes = method.getGenericParameterTypes();
+            if (parameterTypes.length > 0) {
+                Type typeToCheck = parameterTypes[parameterTypes.length - 1];
+                lastArgType = typeToCheck;
+                if (typeToCheck instanceof ParameterizedType) {
+                    typeToCheck = ((ParameterizedType) typeToCheck).getRawType();
+                }
+                if (typeToCheck instanceof Class) {
+                    lastArgClass = (Class<?>) typeToCheck;
+                }
+            }
+            boolean hasCallback = lastArgClass != null && Callback.class.isAssignableFrom(lastArgClass);
+            if(hasCallback){
+                final ParameterizedType lastArgTypeTmp = (ParameterizedType)Types.getSupertype(lastArgType, Types.getRawType(lastArgType), Callback.class);
+                returnType = new ParameterizedType() {
+                    @Override
+                    public Type[] getActualTypeArguments() {
+                        return lastArgTypeTmp.getActualTypeArguments();
+                    }
+
+                    @Override
+                    public Type getOwnerType() {
+                        return lastArgTypeTmp.getOwnerType();
+                    }
+
+                    @Override
+                    public Type getRawType() {
+                        return Call.class;
+                    }
+                };
+            }else {
+                String message = "If Service methods return void, the last parameter of method must be a Callback" + "\n    for method "
+                        + method.getDeclaringClass().getSimpleName()
+                        + "."
+                        + method.getName();
+                throw new IllegalArgumentException(message, null);
+            }
+        }
+        return returnType;
+    }
+}
diff --git a/retrofit/src/main/java/retrofit2/plus/Types.java b/retrofit/src/main/java/retrofit2/plus/Types.java
new file mode 100644
index 000000000..60e9a634e
--- /dev/null
+++ b/retrofit/src/main/java/retrofit2/plus/Types.java
@@ -0,0 +1,431 @@
+package retrofit2.plus;
+/*
+ * Copyright (C) 2008 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.lang.reflect.Array;
+import java.lang.reflect.GenericArrayType;
+import java.lang.reflect.GenericDeclaration;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.lang.reflect.TypeVariable;
+import java.lang.reflect.WildcardType;
+import java.util.Arrays;
+import java.util.NoSuchElementException;
+
+/**
+ * Static methods for working with types.
+ *
+ * @author Bob Lee
+ * @author Jesse Wilson
+ */
+public final class Types {
+    private static final Type[] EMPTY_TYPE_ARRAY = new Type[0];
+
+    private Types() {
+        // No instances.
+    }
+
+    public static Class<?> getRawType(Type type) {
+        if (type instanceof Class<?>) {
+            // Type is a normal class.
+            return (Class<?>) type;
+
+        } else if (type instanceof ParameterizedType) {
+            ParameterizedType parameterizedType = (ParameterizedType) type;
+
+            // I'm not exactly sure why getRawType() returns Type instead of Class. Neal isn't either but
+            // suspects some pathological case related to nested classes exists.
+            Type rawType = parameterizedType.getRawType();
+            if (!(rawType instanceof Class)) throw new IllegalArgumentException();
+            return (Class<?>) rawType;
+
+        } else if (type instanceof GenericArrayType) {
+            Type componentType = ((GenericArrayType) type).getGenericComponentType();
+            return Array.newInstance(getRawType(componentType), 0).getClass();
+
+        } else if (type instanceof TypeVariable) {
+            // We could use the variable's bounds, but that won't work if there are multiple. Having a raw
+            // type that's more general than necessary is okay.
+            return Object.class;
+
+        } else if (type instanceof WildcardType) {
+            return getRawType(((WildcardType) type).getUpperBounds()[0]);
+
+        } else {
+            String className = type == null ? "null" : type.getClass().getName();
+            throw new IllegalArgumentException("Expected a Class, ParameterizedType, or "
+                    + "GenericArrayType, but <" + type + "> is of type " + className);
+        }
+    }
+
+    /**
+     * Returns true if {@code a} and {@code b} are equal.
+     */
+    public static boolean equals(Type a, Type b) {
+        if (a == b) {
+            return true; // Also handles (a == null && b == null).
+
+        } else if (a instanceof Class) {
+            return a.equals(b); // Class already specifies equals().
+
+        } else if (a instanceof ParameterizedType) {
+            if (!(b instanceof ParameterizedType)) return false;
+            ParameterizedType pa = (ParameterizedType) a;
+            ParameterizedType pb = (ParameterizedType) b;
+            return equal(pa.getOwnerType(), pb.getOwnerType())
+                    && pa.getRawType().equals(pb.getRawType())
+                    && Arrays.equals(pa.getActualTypeArguments(), pb.getActualTypeArguments());
+
+        } else if (a instanceof GenericArrayType) {
+            if (!(b instanceof GenericArrayType)) return false;
+            GenericArrayType ga = (GenericArrayType) a;
+            GenericArrayType gb = (GenericArrayType) b;
+            return equals(ga.getGenericComponentType(), gb.getGenericComponentType());
+
+        } else if (a instanceof WildcardType) {
+            if (!(b instanceof WildcardType)) return false;
+            WildcardType wa = (WildcardType) a;
+            WildcardType wb = (WildcardType) b;
+            return Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds())
+                    && Arrays.equals(wa.getLowerBounds(), wb.getLowerBounds());
+
+        } else if (a instanceof TypeVariable) {
+            if (!(b instanceof TypeVariable)) return false;
+            TypeVariable<?> va = (TypeVariable<?>) a;
+            TypeVariable<?> vb = (TypeVariable<?>) b;
+            return va.getGenericDeclaration() == vb.getGenericDeclaration()
+                    && va.getName().equals(vb.getName());
+
+        } else {
+            return false; // This isn't a type we support!
+        }
+    }
+
+    /**
+     * Returns the generic supertype for {@code supertype}. For example, given a class {@code
+     * IntegerSet}, the result for when supertype is {@code Set.class} is {@code Set<Integer>} and the
+     * result when the supertype is {@code Collection.class} is {@code Collection<Integer>}.
+     */
+    static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResolve) {
+        if (toResolve == rawType) return context;
+
+        // We skip searching through interfaces if unknown is an interface.
+        if (toResolve.isInterface()) {
+            Class<?>[] interfaces = rawType.getInterfaces();
+            for (int i = 0, length = interfaces.length; i < length; i++) {
+                if (interfaces[i] == toResolve) {
+                    return rawType.getGenericInterfaces()[i];
+                } else if (toResolve.isAssignableFrom(interfaces[i])) {
+                    return getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], toResolve);
+                }
+            }
+        }
+
+        // Check our supertypes.
+        if (!rawType.isInterface()) {
+            while (rawType != Object.class) {
+                Class<?> rawSupertype = rawType.getSuperclass();
+                if (rawSupertype == toResolve) {
+                    return rawType.getGenericSuperclass();
+                } else if (toResolve.isAssignableFrom(rawSupertype)) {
+                    return getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, toResolve);
+                }
+                rawType = rawSupertype;
+            }
+        }
+
+        // We can't resolve this further.
+        return toResolve;
+    }
+
+    private static int indexOf(Object[] array, Object toFind) {
+        for (int i = 0; i < array.length; i++) {
+            if (toFind.equals(array[i])) return i;
+        }
+        throw new NoSuchElementException();
+    }
+
+    private static boolean equal(Object a, Object b) {
+        return a == b || (a != null && a.equals(b));
+    }
+
+    private static int hashCodeOrZero(Object o) {
+        return o != null ? o.hashCode() : 0;
+    }
+
+    public static String typeToString(Type type) {
+        return type instanceof Class ? ((Class<?>) type).getName() : type.toString();
+    }
+
+    /**
+     * Returns the generic form of {@code supertype}. For example, if this is {@code
+     * ArrayList<String>}, this returns {@code Iterable<String>} given the input {@code
+     * Iterable.class}.
+     *
+     * @param supertype a superclass of, or interface implemented by, this.
+     */
+    public static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) {
+        if (!supertype.isAssignableFrom(contextRawType)) throw new IllegalArgumentException();
+        return resolve(context, contextRawType,
+                getGenericSupertype(context, contextRawType, supertype));
+    }
+
+    public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {
+        // This implementation is made a little more complicated in an attempt to avoid object-creation.
+        while (true) {
+            if (toResolve instanceof TypeVariable) {
+                TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;
+                toResolve = resolveTypeVariable(context, contextRawType, typeVariable);
+                if (toResolve == typeVariable) {
+                    return toResolve;
+                }
+
+            } else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {
+                Class<?> original = (Class<?>) toResolve;
+                Type componentType = original.getComponentType();
+                Type newComponentType = resolve(context, contextRawType, componentType);
+                return componentType == newComponentType ? original : new GenericArrayTypeImpl(
+                        newComponentType);
+
+            } else if (toResolve instanceof GenericArrayType) {
+                GenericArrayType original = (GenericArrayType) toResolve;
+                Type componentType = original.getGenericComponentType();
+                Type newComponentType = resolve(context, contextRawType, componentType);
+                return componentType == newComponentType ? original : new GenericArrayTypeImpl(
+                        newComponentType);
+
+            } else if (toResolve instanceof ParameterizedType) {
+                ParameterizedType original = (ParameterizedType) toResolve;
+                Type ownerType = original.getOwnerType();
+                Type newOwnerType = resolve(context, contextRawType, ownerType);
+                boolean changed = newOwnerType != ownerType;
+
+                Type[] args = original.getActualTypeArguments();
+                for (int t = 0, length = args.length; t < length; t++) {
+                    Type resolvedTypeArgument = resolve(context, contextRawType, args[t]);
+                    if (resolvedTypeArgument != args[t]) {
+                        if (!changed) {
+                            args = args.clone();
+                            changed = true;
+                        }
+                        args[t] = resolvedTypeArgument;
+                    }
+                }
+
+                return changed
+                        ? new ParameterizedTypeImpl(newOwnerType, original.getRawType(), args)
+                        : original;
+
+            } else if (toResolve instanceof WildcardType) {
+                WildcardType original = (WildcardType) toResolve;
+                Type[] originalLowerBound = original.getLowerBounds();
+                Type[] originalUpperBound = original.getUpperBounds();
+
+                if (originalLowerBound.length == 1) {
+                    Type lowerBound = resolve(context, contextRawType, originalLowerBound[0]);
+                    if (lowerBound != originalLowerBound[0]) {
+                        return new WildcardTypeImpl(new Type[]{Object.class}, new Type[]{lowerBound});
+                    }
+                } else if (originalUpperBound.length == 1) {
+                    Type upperBound = resolve(context, contextRawType, originalUpperBound[0]);
+                    if (upperBound != originalUpperBound[0]) {
+                        return new WildcardTypeImpl(new Type[]{upperBound}, EMPTY_TYPE_ARRAY);
+                    }
+                }
+                return original;
+
+            } else {
+                return toResolve;
+            }
+        }
+    }
+
+    private static Type resolveTypeVariable(
+            Type context, Class<?> contextRawType, TypeVariable<?> unknown) {
+        Class<?> declaredByRaw = declaringClassOf(unknown);
+
+        // We can't reduce this further.
+        if (declaredByRaw == null) return unknown;
+
+        Type declaredBy = getGenericSupertype(context, contextRawType, declaredByRaw);
+        if (declaredBy instanceof ParameterizedType) {
+            int index = indexOf(declaredByRaw.getTypeParameters(), unknown);
+            return ((ParameterizedType) declaredBy).getActualTypeArguments()[index];
+        }
+
+        return unknown;
+    }
+
+    /**
+     * Returns the declaring class of {@code typeVariable}, or {@code null} if it was not declared by
+     * a class.
+     */
+    private static Class<?> declaringClassOf(TypeVariable<?> typeVariable) {
+        GenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();
+        return genericDeclaration instanceof Class ? (Class<?>) genericDeclaration : null;
+    }
+
+    private static void checkNotPrimitive(Type type) {
+        if (type instanceof Class<?> && ((Class<?>) type).isPrimitive()) {
+            throw new IllegalArgumentException();
+        }
+    }
+
+    private static final class ParameterizedTypeImpl implements ParameterizedType {
+        private final Type ownerType;
+        private final Type rawType;
+        private final Type[] typeArguments;
+
+        public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments) {
+            // Require an owner type if the raw type needs it.
+            if (rawType instanceof Class<?>
+                    && (ownerType == null) != (((Class<?>) rawType).getEnclosingClass() == null)) {
+                throw new IllegalArgumentException();
+            }
+
+            this.ownerType = ownerType;
+            this.rawType = rawType;
+            this.typeArguments = typeArguments.clone();
+
+            for (Type typeArgument : this.typeArguments) {
+                if (typeArgument == null) throw new NullPointerException();
+                checkNotPrimitive(typeArgument);
+            }
+        }
+
+        @Override
+        public Type[] getActualTypeArguments() {
+            return typeArguments.clone();
+        }
+
+        @Override
+        public Type getRawType() {
+            return rawType;
+        }
+
+        @Override
+        public Type getOwnerType() {
+            return ownerType;
+        }
+
+        @Override
+        public boolean equals(Object other) {
+            return other instanceof ParameterizedType && Types.equals(this, (ParameterizedType) other);
+        }
+
+        @Override
+        public int hashCode() {
+            return Arrays.hashCode(typeArguments) ^ rawType.hashCode() ^ hashCodeOrZero(ownerType);
+        }
+
+        @Override
+        public String toString() {
+            StringBuilder result = new StringBuilder(30 * (typeArguments.length + 1));
+            result.append(typeToString(rawType));
+            if (typeArguments.length == 0) return result.toString();
+            result.append("<").append(typeToString(typeArguments[0]));
+            for (int i = 1; i < typeArguments.length; i++) {
+                result.append(", ").append(typeToString(typeArguments[i]));
+            }
+            return result.append(">").toString();
+        }
+    }
+
+    private static final class GenericArrayTypeImpl implements GenericArrayType {
+        private final Type componentType;
+
+        public GenericArrayTypeImpl(Type componentType) {
+            this.componentType = componentType;
+        }
+
+        @Override
+        public Type getGenericComponentType() {
+            return componentType;
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            return o instanceof GenericArrayType
+                    && Types.equals(this, (GenericArrayType) o);
+        }
+
+        @Override
+        public int hashCode() {
+            return componentType.hashCode();
+        }
+
+        @Override
+        public String toString() {
+            return typeToString(componentType) + "[]";
+        }
+    }
+
+    /**
+     * The WildcardType interface supports multiple upper bounds and multiple
+     * lower bounds. We only support what the Java 6 language needs - at most one
+     * bound. If a lower bound is set, the upper bound must be Object.class.
+     */
+    private static final class WildcardTypeImpl implements WildcardType {
+        private final Type upperBound;
+        private final Type lowerBound;
+
+        public WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {
+            if (lowerBounds.length > 1) throw new IllegalArgumentException();
+            if (upperBounds.length != 1) throw new IllegalArgumentException();
+
+            if (lowerBounds.length == 1) {
+                if (lowerBounds[0] == null) throw new NullPointerException();
+                checkNotPrimitive(lowerBounds[0]);
+                if (upperBounds[0] != Object.class) throw new IllegalArgumentException();
+                this.lowerBound = lowerBounds[0];
+                this.upperBound = Object.class;
+            } else {
+                if (upperBounds[0] == null) throw new NullPointerException();
+                checkNotPrimitive(upperBounds[0]);
+                this.lowerBound = null;
+                this.upperBound = upperBounds[0];
+            }
+        }
+
+        @Override
+        public Type[] getUpperBounds() {
+            return new Type[]{upperBound};
+        }
+
+        @Override
+        public Type[] getLowerBounds() {
+            return lowerBound != null ? new Type[]{lowerBound} : EMPTY_TYPE_ARRAY;
+        }
+
+        @Override
+        public boolean equals(Object other) {
+            return other instanceof WildcardType && Types.equals(this, (WildcardType) other);
+        }
+
+        @Override
+        public int hashCode() {
+            // This equals Arrays.hashCode(getLowerBounds()) ^ Arrays.hashCode(getUpperBounds()).
+            return (lowerBound != null ? 31 + lowerBound.hashCode() : 1) ^ (31 + upperBound.hashCode());
+        }
+
+        @Override
+        public String toString() {
+            if (lowerBound != null) return "? super " + typeToString(lowerBound);
+            if (upperBound == Object.class) return "?";
+            return "? extends " + typeToString(upperBound);
+        }
+    }
+}
diff --git a/retrofit/src/test/java/retrofit2/CallTest.java b/retrofit/src/test/java/retrofit2/CallTest.java
deleted file mode 100644
index 5f5a68a9f..000000000
--- a/retrofit/src/test/java/retrofit2/CallTest.java
+++ /dev/null
@@ -1,947 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2;
-
-import java.io.IOException;
-import java.lang.annotation.Annotation;
-import java.lang.reflect.Type;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.atomic.AtomicReference;
-import okhttp3.Interceptor;
-import okhttp3.OkHttpClient;
-import okhttp3.RequestBody;
-import okhttp3.ResponseBody;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.mockwebserver.SocketPolicy;
-import okio.Buffer;
-import okio.BufferedSource;
-import okio.ForwardingSource;
-import okio.Okio;
-import org.junit.Rule;
-import org.junit.Test;
-import retrofit2.helpers.ToStringConverterFactory;
-import retrofit2.http.Body;
-import retrofit2.http.GET;
-import retrofit2.http.POST;
-import retrofit2.http.Path;
-import retrofit2.http.Streaming;
-
-import static java.util.concurrent.TimeUnit.SECONDS;
-import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-import static org.mockito.Mockito.spy;
-import static org.mockito.Mockito.verifyNoMoreInteractions;
-
-public final class CallTest {
-  @Rule public final MockWebServer server = new MockWebServer();
-
-  interface Service {
-    @GET("/") Call<String> getString();
-    @GET("/") Call<ResponseBody> getBody();
-    @GET("/") @Streaming Call<ResponseBody> getStreamingBody();
-    @POST("/") Call<String> postString(@Body String body);
-    @POST("/{a}") Call<String> postRequestBody(@Path("a") Object a);
-  }
-
-  @Test public void http200Sync() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    Response<String> response = example.getString().execute();
-    assertThat(response.isSuccessful()).isTrue();
-    assertThat(response.body()).isEqualTo("Hi");
-  }
-
-  @Test public void http200Async() throws InterruptedException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    final AtomicReference<Response<String>> responseRef = new AtomicReference<>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    example.getString().enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {
-        responseRef.set(response);
-        latch.countDown();
-      }
-
-      @Override public void onFailure(Call<String> call, Throwable t) {
-        t.printStackTrace();
-      }
-    });
-    assertTrue(latch.await(2, SECONDS));
-
-    Response<String> response = responseRef.get();
-    assertThat(response.isSuccessful()).isTrue();
-    assertThat(response.body()).isEqualTo("Hi");
-  }
-
-  @Test public void http404Sync() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
-
-    Response<String> response = example.getString().execute();
-    assertThat(response.isSuccessful()).isFalse();
-    assertThat(response.code()).isEqualTo(404);
-    assertThat(response.errorBody().string()).isEqualTo("Hi");
-  }
-
-  @Test public void http404Async() throws InterruptedException, IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
-
-    final AtomicReference<Response<String>> responseRef = new AtomicReference<>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    example.getString().enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {
-        responseRef.set(response);
-        latch.countDown();
-      }
-
-      @Override public void onFailure(Call<String> call, Throwable t) {
-        t.printStackTrace();
-      }
-    });
-    assertTrue(latch.await(2, SECONDS));
-
-    Response<String> response = responseRef.get();
-    assertThat(response.isSuccessful()).isFalse();
-    assertThat(response.code()).isEqualTo(404);
-    assertThat(response.errorBody().string()).isEqualTo("Hi");
-  }
-
-  @Test public void transportProblemSync() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AT_START));
-
-    Call<String> call = example.getString();
-    try {
-      call.execute();
-      fail();
-    } catch (IOException ignored) {
-    }
-  }
-
-  @Test public void transportProblemAsync() throws InterruptedException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AT_START));
-
-    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    example.getString().enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {
-        throw new AssertionError();
-      }
-
-      @Override public void onFailure(Call<String> call, Throwable t) {
-        failureRef.set(t);
-        latch.countDown();
-      }
-    });
-    assertTrue(latch.await(2, SECONDS));
-
-    Throwable failure = failureRef.get();
-    assertThat(failure).isInstanceOf(IOException.class);
-  }
-
-  @Test public void conversionProblemOutgoingSync() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory() {
-          @Override
-          public Converter<?, RequestBody> requestBodyConverter(Type type,
-              Annotation[] parameterAnnotations, Annotation[] methodAnnotations,
-              Retrofit retrofit) {
-            return new Converter<String, RequestBody>() {
-              @Override public RequestBody convert(String value) throws IOException {
-                throw new UnsupportedOperationException("I am broken!");
-              }
-            };
-          }
-        })
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    Call<String> call = example.postString("Hi");
-    try {
-      call.execute();
-      fail();
-    } catch (UnsupportedOperationException e) {
-      assertThat(e).hasMessage("I am broken!");
-    }
-  }
-
-  @Test public void conversionProblemOutgoingAsync() throws InterruptedException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory() {
-          @Override
-          public Converter<?, RequestBody> requestBodyConverter(Type type,
-              Annotation[] parameterAnnotations, Annotation[] methodAnnotations,
-              Retrofit retrofit) {
-            return new Converter<String, RequestBody>() {
-              @Override public RequestBody convert(String value) throws IOException {
-                throw new UnsupportedOperationException("I am broken!");
-              }
-            };
-          }
-        })
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    example.postString("Hi").enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {
-        throw new AssertionError();
-      }
-
-      @Override public void onFailure(Call<String> call, Throwable t) {
-        failureRef.set(t);
-        latch.countDown();
-      }
-    });
-    assertTrue(latch.await(2, SECONDS));
-
-    assertThat(failureRef.get()).isInstanceOf(UnsupportedOperationException.class)
-        .hasMessage("I am broken!");
-  }
-
-  @Test public void conversionProblemIncomingSync() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory() {
-          @Override
-          public Converter<ResponseBody, ?> responseBodyConverter(Type type,
-              Annotation[] annotations, Retrofit retrofit) {
-            return new Converter<ResponseBody, String>() {
-              @Override public String convert(ResponseBody value) throws IOException {
-                throw new UnsupportedOperationException("I am broken!");
-              }
-            };
-          }
-        })
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    Call<String> call = example.postString("Hi");
-    try {
-      call.execute();
-      fail();
-    } catch (UnsupportedOperationException e) {
-      assertThat(e).hasMessage("I am broken!");
-    }
-  }
-
-  @Test public void conversionProblemIncomingMaskedByConverterIsUnwrapped() throws IOException {
-    // MWS has no way to trigger IOExceptions during the response body so use an interceptor.
-    OkHttpClient client = new OkHttpClient.Builder() //
-        .addInterceptor(new Interceptor() {
-          @Override public okhttp3.Response intercept(Chain chain) throws IOException {
-            okhttp3.Response response = chain.proceed(chain.request());
-            ResponseBody body = response.body();
-            BufferedSource source = Okio.buffer(new ForwardingSource(body.source()) {
-              @Override public long read(Buffer sink, long byteCount) throws IOException {
-                throw new IOException("cause");
-              }
-            });
-            body = ResponseBody.create(body.contentType(), body.contentLength(), source);
-            return response.newBuilder().body(body).build();
-          }
-        }).build();
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .client(client)
-        .addConverterFactory(new ToStringConverterFactory() {
-          @Override
-          public Converter<ResponseBody, ?> responseBodyConverter(Type type,
-              Annotation[] annotations, Retrofit retrofit) {
-            return new Converter<ResponseBody, String>() {
-              @Override public String convert(ResponseBody value) throws IOException {
-                try {
-                  return value.string();
-                } catch (IOException e) {
-                  // Some serialization libraries mask transport problems in runtime exceptions. Bad!
-                  throw new RuntimeException("wrapper", e);
-                }
-              }
-            };
-          }
-        })
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    Call<String> call = example.getString();
-    try {
-      call.execute();
-      fail();
-    } catch (IOException e) {
-      assertThat(e).hasMessage("cause");
-    }
-  }
-
-  @Test public void conversionProblemIncomingAsync() throws InterruptedException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory() {
-          @Override
-          public Converter<ResponseBody, ?> responseBodyConverter(Type type,
-              Annotation[] annotations, Retrofit retrofit) {
-            return new Converter<ResponseBody, String>() {
-              @Override public String convert(ResponseBody value) throws IOException {
-                throw new UnsupportedOperationException("I am broken!");
-              }
-            };
-          }
-        })
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    example.postString("Hi").enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {
-        throw new AssertionError();
-      }
-
-      @Override public void onFailure(Call<String> call, Throwable t) {
-        failureRef.set(t);
-        latch.countDown();
-      }
-    });
-    assertTrue(latch.await(2, SECONDS));
-
-    assertThat(failureRef.get()).isInstanceOf(UnsupportedOperationException.class)
-        .hasMessage("I am broken!");
-  }
-
-  @Test public void http204SkipsConverter() throws IOException {
-    final Converter<ResponseBody, String> converter = spy(new Converter<ResponseBody, String>() {
-      @Override public String convert(ResponseBody value) throws IOException {
-        return value.string();
-      }
-    });
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory() {
-          @Override
-          public Converter<ResponseBody, ?> responseBodyConverter(Type type,
-              Annotation[] annotations, Retrofit retrofit) {
-            return converter;
-          }
-        })
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setStatus("HTTP/1.1 204 Nothin"));
-
-    Response<String> response = example.getString().execute();
-    assertThat(response.code()).isEqualTo(204);
-    assertThat(response.body()).isNull();
-    verifyNoMoreInteractions(converter);
-  }
-
-  @Test public void http205SkipsConverter() throws IOException {
-    final Converter<ResponseBody, String> converter = spy(new Converter<ResponseBody, String>() {
-      @Override public String convert(ResponseBody value) throws IOException {
-        return value.string();
-      }
-    });
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory() {
-          @Override
-          public Converter<ResponseBody, ?> responseBodyConverter(Type type,
-              Annotation[] annotations, Retrofit retrofit) {
-            return converter;
-          }
-        })
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setStatus("HTTP/1.1 205 Nothin"));
-
-    Response<String> response = example.getString().execute();
-    assertThat(response.code()).isEqualTo(205);
-    assertThat(response.body()).isNull();
-    verifyNoMoreInteractions(converter);
-  }
-
-  @Test public void executeCallOnce() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-    server.enqueue(new MockResponse());
-    Call<String> call = example.getString();
-    call.execute();
-    try {
-      call.execute();
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage("Already executed.");
-    }
-  }
-
-  @Test public void successfulRequestResponseWhenMimeTypeMissing() throws Exception {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setBody("Hi").removeHeader("Content-Type"));
-
-    Response<String> response = example.getString().execute();
-    assertThat(response.body()).isEqualTo("Hi");
-  }
-
-  @Test public void responseBody() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setBody("1234"));
-
-    Response<ResponseBody> response = example.getBody().execute();
-    assertThat(response.body().string()).isEqualTo("1234");
-  }
-
-  @Test public void responseBodyBuffers() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse()
-        .setBody("1234")
-        .setSocketPolicy(DISCONNECT_DURING_RESPONSE_BODY));
-
-    Call<ResponseBody> buffered = example.getBody();
-    // When buffering we will detect all socket problems before returning the Response.
-    try {
-      buffered.execute();
-      fail();
-    } catch (IOException e) {
-      assertThat(e).hasMessage("unexpected end of stream");
-    }
-  }
-
-  @Test public void responseBodyStreams() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse()
-        .setBody("1234")
-        .setSocketPolicy(DISCONNECT_DURING_RESPONSE_BODY));
-
-    Response<ResponseBody> response = example.getStreamingBody().execute();
-
-    ResponseBody streamedBody = response.body();
-    // When streaming we only detect socket problems as the ResponseBody is read.
-    try {
-      streamedBody.string();
-      fail();
-    } catch (IOException e) {
-      assertThat(e).hasMessage("unexpected end of stream");
-    }
-  }
-
-  @Test public void rawResponseContentTypeAndLengthButNoSource() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setBody("Hi").addHeader("Content-Type", "text/greeting"));
-
-    Response<String> response = example.getString().execute();
-    assertThat(response.body()).isEqualTo("Hi");
-    ResponseBody rawBody = response.raw().body();
-    assertThat(rawBody.contentLength()).isEqualTo(2);
-    assertThat(rawBody.contentType().toString()).isEqualTo("text/greeting");
-    try {
-      rawBody.source();
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage("Cannot read raw response body of a converted body.");
-    }
-  }
-
-  @Test public void emptyResponse() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setBody("").addHeader("Content-Type", "text/stringy"));
-
-    Response<String> response = example.getString().execute();
-    assertThat(response.body()).isEqualTo("");
-    ResponseBody rawBody = response.raw().body();
-    assertThat(rawBody.contentLength()).isEqualTo(0);
-    assertThat(rawBody.contentType().toString()).isEqualTo("text/stringy");
-  }
-
-  @Test public void reportsExecutedSync() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    Call<String> call = example.getString();
-    assertThat(call.isExecuted()).isFalse();
-
-    call.execute();
-    assertThat(call.isExecuted()).isTrue();
-  }
-
-  @Test public void reportsExecutedAsync() throws InterruptedException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    Call<String> call = example.getString();
-    assertThat(call.isExecuted()).isFalse();
-
-    call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {}
-      @Override public void onFailure(Call<String> call, Throwable t) {}
-    });
-    assertThat(call.isExecuted()).isTrue();
-  }
-
-  @Test public void cancelBeforeExecute() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service service = retrofit.create(Service.class);
-    Call<String> call = service.getString();
-
-    call.cancel();
-    assertThat(call.isCanceled()).isTrue();
-
-    try {
-      call.execute();
-      fail();
-    } catch (IOException e) {
-      assertThat(e).hasMessage("Canceled");
-    }
-  }
-
-  @Test public void cancelBeforeEnqueue() throws Exception {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service service = retrofit.create(Service.class);
-    Call<String> call = service.getString();
-
-    call.cancel();
-    assertThat(call.isCanceled()).isTrue();
-
-    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {
-        throw new AssertionError();
-      }
-
-      @Override public void onFailure(Call<String> call, Throwable t) {
-        failureRef.set(t);
-        latch.countDown();
-      }
-    });
-    latch.await();
-    assertThat(failureRef.get()).hasMessage("Canceled");
-  }
-
-  @Test public void cloningExecutedRequestDoesNotCopyState() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service service = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setBody("Hi"));
-    server.enqueue(new MockResponse().setBody("Hello"));
-
-    Call<String> call = service.getString();
-    assertThat(call.execute().body()).isEqualTo("Hi");
-
-    Call<String> cloned = call.clone();
-    assertThat(cloned.execute().body()).isEqualTo("Hello");
-  }
-
-  @Test public void cancelRequest() throws InterruptedException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service service = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.NO_RESPONSE));
-
-    Call<String> call = service.getString();
-
-    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {
-        throw new AssertionError();
-      }
-
-      @Override public void onFailure(Call<String> call, Throwable t) {
-        failureRef.set(t);
-        latch.countDown();
-      }
-    });
-
-    call.cancel();
-    assertThat(call.isCanceled()).isTrue();
-
-    assertTrue(latch.await(2, SECONDS));
-    assertThat(failureRef.get()).isInstanceOf(IOException.class).hasMessage("Canceled");
-  }
-
-  @Test public void requestBeforeExecuteCreates() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service service = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse());
-
-    final AtomicInteger writeCount = new AtomicInteger();
-    Object a = new Object() {
-      @Override public String toString() {
-        writeCount.incrementAndGet();
-        return "Hello";
-      }
-    };
-    Call<String> call = service.postRequestBody(a);
-
-    call.request();
-    assertThat(writeCount.get()).isEqualTo(1);
-
-    call.execute();
-    assertThat(writeCount.get()).isEqualTo(1);
-  }
-
-  @Test public void requestThrowingBeforeExecuteFailsExecute() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service service = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse());
-
-    final AtomicInteger writeCount = new AtomicInteger();
-    Object a = new Object() {
-      @Override public String toString() {
-        writeCount.incrementAndGet();
-        throw new RuntimeException("Broken!");
-      }
-    };
-    Call<String> call = service.postRequestBody(a);
-
-    try {
-      call.request();
-      fail();
-    } catch (RuntimeException e) {
-      assertThat(e).hasMessage("Broken!");
-    }
-    assertThat(writeCount.get()).isEqualTo(1);
-
-    try {
-      call.execute();
-      fail();
-    } catch (RuntimeException e) {
-      assertThat(e).hasMessage("Broken!");
-    }
-    assertThat(writeCount.get()).isEqualTo(1);
-  }
-
-  @Test public void requestAfterExecuteReturnsCachedValue() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service service = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse());
-
-    final AtomicInteger writeCount = new AtomicInteger();
-    Object a = new Object() {
-      @Override public String toString() {
-        writeCount.incrementAndGet();
-        return "Hello";
-      }
-    };
-    Call<String> call = service.postRequestBody(a);
-
-    call.execute();
-    assertThat(writeCount.get()).isEqualTo(1);
-
-    call.request();
-    assertThat(writeCount.get()).isEqualTo(1);
-  }
-
-  @Test public void requestAfterExecuteThrowingAlsoThrows() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service service = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse());
-
-    final AtomicInteger writeCount = new AtomicInteger();
-    Object a = new Object() {
-      @Override public String toString() {
-        writeCount.incrementAndGet();
-        throw new RuntimeException("Broken!");
-      }
-    };
-    Call<String> call = service.postRequestBody(a);
-
-    try {
-      call.execute();
-      fail();
-    } catch (RuntimeException e) {
-      assertThat(e).hasMessage("Broken!");
-    }
-    assertThat(writeCount.get()).isEqualTo(1);
-
-    try {
-      call.request();
-      fail();
-    } catch (RuntimeException e) {
-      assertThat(e).hasMessage("Broken!");
-    }
-    assertThat(writeCount.get()).isEqualTo(1);
-  }
-
-  @Test public void requestBeforeEnqueueCreates() throws IOException, InterruptedException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service service = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse());
-
-    final AtomicInteger writeCount = new AtomicInteger();
-    Object a = new Object() {
-      @Override public String toString() {
-        writeCount.incrementAndGet();
-        return "Hello";
-      }
-    };
-    Call<String> call = service.postRequestBody(a);
-
-    call.request();
-    assertThat(writeCount.get()).isEqualTo(1);
-
-    final CountDownLatch latch = new CountDownLatch(1);
-    call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {
-        assertThat(writeCount.get()).isEqualTo(1);
-        latch.countDown();
-      }
-
-      @Override public void onFailure(Call<String> call, Throwable t) {
-      }
-    });
-    assertTrue(latch.await(1, SECONDS));
-  }
-
-  @Test public void requestThrowingBeforeEnqueueFailsEnqueue()
-      throws IOException, InterruptedException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service service = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse());
-
-    final AtomicInteger writeCount = new AtomicInteger();
-    Object a = new Object() {
-      @Override public String toString() {
-        writeCount.incrementAndGet();
-        throw new RuntimeException("Broken!");
-      }
-    };
-    Call<String> call = service.postRequestBody(a);
-
-    try {
-      call.request();
-      fail();
-    } catch (RuntimeException e) {
-      assertThat(e).hasMessage("Broken!");
-    }
-    assertThat(writeCount.get()).isEqualTo(1);
-
-    final CountDownLatch latch = new CountDownLatch(1);
-    call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {
-      }
-
-      @Override public void onFailure(Call<String> call, Throwable t) {
-        assertThat(t).isExactlyInstanceOf(RuntimeException.class).hasMessage("Broken!");
-        assertThat(writeCount.get()).isEqualTo(1);
-        latch.countDown();
-      }
-    });
-    assertTrue(latch.await(1, SECONDS));
-  }
-
-  @Test public void requestAfterEnqueueReturnsCachedValue() throws IOException,
-      InterruptedException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service service = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse());
-
-    final AtomicInteger writeCount = new AtomicInteger();
-    Object a = new Object() {
-      @Override public String toString() {
-        writeCount.incrementAndGet();
-        return "Hello";
-      }
-    };
-    Call<String> call = service.postRequestBody(a);
-
-    final CountDownLatch latch = new CountDownLatch(1);
-    call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {
-        assertThat(writeCount.get()).isEqualTo(1);
-        latch.countDown();
-      }
-
-      @Override public void onFailure(Call<String> call, Throwable t) {
-      }
-    });
-    assertTrue(latch.await(1, SECONDS));
-
-    call.request();
-    assertThat(writeCount.get()).isEqualTo(1);
-  }
-
-  @Test public void requestAfterEnqueueFailingThrows() throws IOException,
-      InterruptedException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service service = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse());
-
-    final AtomicInteger writeCount = new AtomicInteger();
-    Object a = new Object() {
-      @Override public String toString() {
-        writeCount.incrementAndGet();
-        throw new RuntimeException("Broken!");
-      }
-    };
-    Call<String> call = service.postRequestBody(a);
-
-    final CountDownLatch latch = new CountDownLatch(1);
-    call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {
-      }
-
-      @Override public void onFailure(Call<String> call, Throwable t) {
-        assertThat(t).isExactlyInstanceOf(RuntimeException.class).hasMessage("Broken!");
-        assertThat(writeCount.get()).isEqualTo(1);
-        latch.countDown();
-      }
-    });
-    assertTrue(latch.await(1, SECONDS));
-
-    try {
-      call.request();
-      fail();
-    } catch (RuntimeException e) {
-      assertThat(e).hasMessage("Broken!");
-    }
-    assertThat(writeCount.get()).isEqualTo(1);
-  }
-}
diff --git a/retrofit/src/test/java/retrofit2/ExecutorCallAdapterFactoryTest.java b/retrofit/src/test/java/retrofit2/ExecutorCallAdapterFactoryTest.java
deleted file mode 100644
index ba45b5fe6..000000000
--- a/retrofit/src/test/java/retrofit2/ExecutorCallAdapterFactoryTest.java
+++ /dev/null
@@ -1,170 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2;
-
-import com.google.common.reflect.TypeToken;
-import java.io.IOException;
-import java.lang.annotation.Annotation;
-import java.lang.reflect.Type;
-import java.util.List;
-import java.util.concurrent.Executor;
-import okhttp3.Request;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.spy;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.verifyNoMoreInteractions;
-
-@SuppressWarnings("unchecked")
-public final class ExecutorCallAdapterFactoryTest {
-  private static final Annotation[] NO_ANNOTATIONS = new Annotation[0];
-
-  private final Retrofit retrofit = new Retrofit.Builder()
-      .baseUrl("http://localhost:1")
-      .build();
-  private final Callback<String> callback = mock(Callback.class);
-  private final Executor callbackExecutor = spy(new Executor() {
-    @Override public void execute(Runnable runnable) {
-      runnable.run();
-    }
-  });
-  private final CallAdapter.Factory factory = new ExecutorCallAdapterFactory(callbackExecutor);
-
-  @Test public void rawTypeThrows() {
-    try {
-      factory.get(Call.class, NO_ANNOTATIONS, retrofit);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Call return type must be parameterized as Call<Foo> or Call<? extends Foo>");
-    }
-  }
-
-  @Test public void responseType() {
-    Type classType = new TypeToken<Call<String>>() {}.getType();
-    assertThat(factory.get(classType, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-    Type wilcardType = new TypeToken<Call<? extends String>>() {}.getType();
-    assertThat(factory.get(wilcardType, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-    Type genericType = new TypeToken<Call<List<String>>>() {}.getType();
-    assertThat(factory.get(genericType, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(new TypeToken<List<String>>() {}.getType());
-  }
-
-  @Test public void adaptedCallExecute() throws IOException {
-    Type returnType = new TypeToken<Call<String>>() {}.getType();
-    CallAdapter<Call<?>> adapter =
-        (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
-    final Response<String> response = Response.success("Hi");
-    Call<String> call = (Call<String>) adapter.adapt(new EmptyCall() {
-      @Override public Response<String> execute() throws IOException {
-        return response;
-      }
-    });
-    assertThat(call.execute()).isSameAs(response);
-  }
-
-  @Test public void adaptedCallEnqueueUsesExecutorForSuccessCallback() {
-    Type returnType = new TypeToken<Call<String>>() {}.getType();
-    CallAdapter<Call<?>> adapter =
-        (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
-    final Response<String> response = Response.success("Hi");
-    EmptyCall originalCall = new EmptyCall() {
-      @Override public void enqueue(Callback<String> callback) {
-        callback.onResponse(this, response);
-      }
-    };
-    Call<String> call = (Call<String>) adapter.adapt(originalCall);
-    call.enqueue(callback);
-    verify(callbackExecutor).execute(any(Runnable.class));
-    verify(callback).onResponse(originalCall, response);
-  }
-
-  @Test public void adaptedCallEnqueueUsesExecutorForFailureCallback() {
-    Type returnType = new TypeToken<Call<String>>() {}.getType();
-    CallAdapter<Call<?>> adapter =
-        (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
-    final Throwable throwable = new IOException();
-    EmptyCall originalCall = new EmptyCall() {
-      @Override public void enqueue(Callback<String> callback) {
-        callback.onFailure(this, throwable);
-      }
-    };
-    Call<String> call = (Call<String>) adapter.adapt(originalCall);
-    call.enqueue(callback);
-    verify(callbackExecutor).execute(any(Runnable.class));
-    verifyNoMoreInteractions(callbackExecutor);
-    verify(callback).onFailure(originalCall, throwable);
-    verifyNoMoreInteractions(callback);
-  }
-
-  @Test public void adaptedCallCloneDeepCopy() {
-    Type returnType = new TypeToken<Call<String>>() {}.getType();
-    CallAdapter<Call<?>> adapter =
-        (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
-    Call<String> delegate = mock(Call.class);
-    Call<String> call = (Call<String>) adapter.adapt(delegate);
-    Call<String> cloned = call.clone();
-    assertThat(cloned).isNotSameAs(call);
-    verify(delegate).clone();
-    verifyNoMoreInteractions(delegate);
-  }
-
-  @Test public void adaptedCallCancel() {
-    Type returnType = new TypeToken<Call<String>>() {}.getType();
-    CallAdapter<Call<?>> adapter =
-        (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
-    Call<String> delegate = mock(Call.class);
-    Call<String> call = (Call<String>) adapter.adapt(delegate);
-    call.cancel();
-    verify(delegate).cancel();
-    verifyNoMoreInteractions(delegate);
-  }
-
-  static class EmptyCall implements Call<String> {
-    @Override public void enqueue(Callback<String> callback) {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override public boolean isExecuted() {
-      return false;
-    }
-
-    @Override public Response<String> execute() throws IOException {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override public void cancel() {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override public boolean isCanceled() {
-      return false;
-    }
-
-    @Override public Call<String> clone() {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override public Request request() {
-      throw new UnsupportedOperationException();
-    }
-  }
-}
diff --git a/retrofit/src/test/java/retrofit2/Java8DefaultMethodsTest.java b/retrofit/src/test/java/retrofit2/Java8DefaultMethodsTest.java
deleted file mode 100644
index 8333969c6..000000000
--- a/retrofit/src/test/java/retrofit2/Java8DefaultMethodsTest.java
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2;
-
-// TODO this test doesn't play nice in the IDE because it relies on Java 8 language features.
-public final class Java8DefaultMethodsTest {
-  //@Rule public final MockWebServer server = new MockWebServer();
-  //
-  //interface Example {
-  //  @GET("/") Call<String> user(@Query("name") String name);
-  //
-  //  default Call<String> user() {
-  //    return user("hey");
-  //  }
-  //}
-  //
-  //@Test public void test() throws IOException {
-  //  server.enqueue(new MockResponse().setBody("Hi"));
-  //  server.enqueue(new MockResponse().setBody("Hi"));
-  //
-  //  Retrofit retrofit = new Retrofit.Builder()
-  //      .baseUrl(server.url("/"))
-  //      .addConverterFactory(new ToStringConverterFactory())
-  //      .build();
-  //  Example example = retrofit.create(Example.class);
-  //
-  //  Response<String> response = example.user().execute();
-  //  assertThat(response.body()).isEqualTo("Hi");
-  //  Response<String> response = example.user("hi").execute();
-  //  assertThat(response.body()).isEqualTo("Hi");
-  //}
-}
diff --git a/retrofit/src/test/java/retrofit2/RequestBuilderAndroidTest.java b/retrofit/src/test/java/retrofit2/RequestBuilderAndroidTest.java
deleted file mode 100644
index 63fa57b6c..000000000
--- a/retrofit/src/test/java/retrofit2/RequestBuilderAndroidTest.java
+++ /dev/null
@@ -1,62 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2;
-
-import android.net.Uri;
-import okhttp3.Request;
-import okhttp3.ResponseBody;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import retrofit2.http.GET;
-import retrofit2.http.Url;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static retrofit2.RequestBuilderTest.buildRequest;
-
-@RunWith(RobolectricTestRunner.class)
-@SuppressWarnings({"UnusedParameters", "unused"}) // Parameters inspected reflectively.
-public final class RequestBuilderAndroidTest {
-  @Test public void getWithAndroidUriUrl() {
-    class Example {
-      @GET
-      Call<ResponseBody> method(@Url Uri url) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, Uri.parse("foo/bar/"));
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithAndroidUriUrlAbsolute() {
-    class Example {
-      @GET
-      Call<ResponseBody> method(@Url Uri url) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, Uri.parse("https://example2.com/foo/bar/"));
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("https://example2.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-}
diff --git a/retrofit/src/test/java/retrofit2/ResponseTest.java b/retrofit/src/test/java/retrofit2/ResponseTest.java
deleted file mode 100644
index 3d059b8ad..000000000
--- a/retrofit/src/test/java/retrofit2/ResponseTest.java
+++ /dev/null
@@ -1,181 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2;
-
-import okhttp3.Headers;
-import okhttp3.Protocol;
-import okhttp3.ResponseBody;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class ResponseTest {
-  private final okhttp3.Response successResponse = new okhttp3.Response.Builder() //
-      .code(200)
-      .message("OK")
-      .protocol(Protocol.HTTP_1_1)
-      .request(new okhttp3.Request.Builder().url("http://localhost").build())
-      .build();
-  private final okhttp3.Response errorResponse = new okhttp3.Response.Builder() //
-      .code(400)
-      .message("Broken!")
-      .protocol(Protocol.HTTP_1_1)
-      .request(new okhttp3.Request.Builder().url("http://localhost").build())
-      .build();
-
-  @Test public void success() {
-    Object body = new Object();
-    Response<Object> response = Response.success(body);
-    assertThat(response.raw()).isNotNull();
-    assertThat(response.code()).isEqualTo(200);
-    assertThat(response.message()).isEqualTo("OK");
-    assertThat(response.headers().size()).isZero();
-    assertThat(response.isSuccessful()).isTrue();
-    assertThat(response.body()).isSameAs(body);
-    assertThat(response.errorBody()).isNull();
-  }
-
-  @Test public void successNullAllowed() {
-    Response<Object> response = Response.success(null);
-    assertThat(response.isSuccessful()).isTrue();
-    assertThat(response.body()).isNull();
-  }
-
-  @Test public void successWithHeaders() {
-    Object body = new Object();
-    Headers headers = Headers.of("foo", "bar");
-    Response<Object> response = Response.success(body, headers);
-    assertThat(response.raw()).isNotNull();
-    assertThat(response.code()).isEqualTo(200);
-    assertThat(response.message()).isEqualTo("OK");
-    assertThat(response.headers().toMultimap()).isEqualTo(headers.toMultimap());
-    assertThat(response.isSuccessful()).isTrue();
-    assertThat(response.body()).isSameAs(body);
-    assertThat(response.errorBody()).isNull();
-  }
-
-  @Test public void successWithNullHeadersThrows() {
-    try {
-      Response.success("", (okhttp3.Headers) null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("headers == null");
-    }
-  }
-
-  @Test public void successWithRawResponse() {
-    Object body = new Object();
-    Response<Object> response = Response.success(body, successResponse);
-    assertThat(response.raw()).isSameAs(successResponse);
-    assertThat(response.code()).isEqualTo(200);
-    assertThat(response.message()).isEqualTo("OK");
-    assertThat(response.headers().size()).isZero();
-    assertThat(response.isSuccessful()).isTrue();
-    assertThat(response.body()).isSameAs(body);
-    assertThat(response.errorBody()).isNull();
-  }
-
-  @Test public void successWithNullRawResponseThrows() {
-    try {
-      Response.success("", (okhttp3.Response) null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("rawResponse == null");
-    }
-  }
-
-  @Test public void successWithErrorRawResponseThrows() {
-    try {
-      Response.success("", errorResponse);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("rawResponse must be successful response");
-    }
-  }
-
-  @Test public void error() {
-    ResponseBody errorBody = ResponseBody.create(null, "Broken!");
-    Response<?> response = Response.error(400, errorBody);
-    assertThat(response.raw()).isNotNull();
-    assertThat(response.code()).isEqualTo(400);
-    assertThat(response.message()).isNull();
-    assertThat(response.headers().size()).isZero();
-    assertThat(response.isSuccessful()).isFalse();
-    assertThat(response.body()).isNull();
-    assertThat(response.errorBody()).isSameAs(errorBody);
-  }
-
-  @Test public void nullErrorThrows() {
-    try {
-      Response.error(400, null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("body == null");
-    }
-  }
-
-  @Test public void errorWithSuccessCodeThrows() {
-    ResponseBody errorBody = ResponseBody.create(null, "Broken!");
-    try {
-      Response.error(200, errorBody);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("code < 400: 200");
-    }
-  }
-
-  @Test public void errorWithRawResponse() {
-    ResponseBody errorBody = ResponseBody.create(null, "Broken!");
-    Response<?> response = Response.error(errorBody, errorResponse);
-    assertThat(response.raw()).isSameAs(errorResponse);
-    assertThat(response.code()).isEqualTo(400);
-    assertThat(response.message()).isEqualTo("Broken!");
-    assertThat(response.headers().size()).isZero();
-    assertThat(response.isSuccessful()).isFalse();
-    assertThat(response.body()).isNull();
-    assertThat(response.errorBody()).isSameAs(errorBody);
-  }
-
-  @Test public void nullErrorWithRawResponseThrows() {
-    try {
-      Response.error(null, errorResponse);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("body == null");
-    }
-  }
-
-  @Test public void errorWithNullRawResponseThrows() {
-    ResponseBody errorBody = ResponseBody.create(null, "Broken!");
-    try {
-      Response.error(errorBody, null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("rawResponse == null");
-    }
-  }
-
-  @Test public void errorWithSuccessRawResponseThrows() {
-    ResponseBody errorBody = ResponseBody.create(null, "Broken!");
-    try {
-      Response.error(errorBody, successResponse);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("rawResponse should not be successful response");
-    }
-  }
-}
diff --git a/retrofit/src/test/java/retrofit2/RetrofitTest.java b/retrofit/src/test/java/retrofit2/RetrofitTest.java
deleted file mode 100644
index 9c17cab42..000000000
--- a/retrofit/src/test/java/retrofit2/RetrofitTest.java
+++ /dev/null
@@ -1,1302 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2;
-
-import java.io.IOException;
-import java.lang.annotation.Annotation;
-import java.lang.annotation.Retention;
-import java.lang.reflect.ParameterizedType;
-import java.lang.reflect.Type;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.Executor;
-import java.util.concurrent.Executors;
-import java.util.concurrent.Future;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.atomic.AtomicReference;
-import okhttp3.HttpUrl;
-import okhttp3.MediaType;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.RequestBody;
-import okhttp3.ResponseBody;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import org.junit.Rule;
-import org.junit.Test;
-import retrofit2.helpers.DelegatingCallAdapterFactory;
-import retrofit2.helpers.NonMatchingCallAdapterFactory;
-import retrofit2.helpers.NonMatchingConverterFactory;
-import retrofit2.helpers.ToStringConverterFactory;
-import retrofit2.http.Body;
-import retrofit2.http.GET;
-import retrofit2.http.POST;
-import retrofit2.http.Query;
-
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.doReturn;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.spy;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.verifyNoMoreInteractions;
-
-public final class RetrofitTest {
-  @Rule public final MockWebServer server = new MockWebServer();
-
-  interface CallMethod {
-    @GET("/") Call<String> disallowed();
-    @POST("/") Call<ResponseBody> disallowed(@Body String body);
-
-    @GET("/") Call<retrofit2.Response> badType1();
-    @GET("/") Call<okhttp3.Response> badType2();
-
-    @GET("/") Call<ResponseBody> getResponseBody();
-    @GET("/") Call<Void> getVoid();
-    @POST("/") Call<ResponseBody> postRequestBody(@Body RequestBody body);
-    @GET("/") Call<ResponseBody> queryString(@Query("foo") String foo);
-    @GET("/") Call<ResponseBody> queryObject(@Query("foo") Object foo);
-  }
-  interface FutureMethod {
-    @GET("/") Future<String> method();
-  }
-  interface Extending extends CallMethod {
-  }
-  interface StringService {
-    @GET("/") String get();
-  }
-  interface UnresolvableResponseType {
-    @GET("/") <T> Call<T> typeVariable();
-    @GET("/") <T extends ResponseBody> Call<T> typeVariableUpperBound();
-    @GET("/") <T> Call<List<Map<String, Set<T[]>>>> crazy();
-    @GET("/") Call<?> wildcard();
-    @GET("/") Call<? extends ResponseBody> wildcardUpperBound();
-  }
-  interface UnresolvableParameterType {
-    @POST("/") <T> Call<ResponseBody> typeVariable(@Body T body);
-    @POST("/") <T extends RequestBody> Call<ResponseBody> typeVariableUpperBound(@Body T body);
-    @POST("/") <T> Call<ResponseBody> crazy(@Body List<Map<String, Set<T[]>>> body);
-    @POST("/") Call<ResponseBody> wildcard(@Body List<?> body);
-    @POST("/") Call<ResponseBody> wildcardUpperBound(@Body List<? extends RequestBody> body);
-  }
-  interface VoidService {
-    @GET("/") void nope();
-  }
-  interface Annotated {
-    @GET("/") @Foo Call<String> method();
-    @POST("/") Call<ResponseBody> bodyParameter(@Foo @Body String param);
-    @GET("/") Call<ResponseBody> queryParameter(@Foo @Query("foo") Object foo);
-
-    @Retention(RUNTIME)
-    @interface Foo {}
-  }
-  interface MutableParameters {
-    @GET("/") Call<String> method(@Query("i") AtomicInteger value);
-  }
-
-  @SuppressWarnings("EqualsBetweenInconvertibleTypes") // We are explicitly testing this behavior.
-  @Test public void objectMethodsStillWork() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-    CallMethod example = retrofit.create(CallMethod.class);
-
-    assertThat(example.hashCode()).isNotZero();
-    assertThat(example.equals(this)).isFalse();
-    assertThat(example.toString()).isNotEmpty();
-  }
-
-  @Test public void interfaceWithExtendIsNotSupported() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-    try {
-      retrofit.create(Extending.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("API interfaces must not extend other interfaces.");
-    }
-  }
-
-  @Test public void responseTypeCannotBeRetrofitResponse() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-    CallMethod service = retrofit.create(CallMethod.class);
-    try {
-      service.badType1();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "'retrofit2.Response' is not a valid response body type. Did you mean ResponseBody?\n"
-              + "    for method CallMethod.badType1");
-    }
-  }
-
-  @Test public void responseTypeCannotBeOkHttpResponse() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-    CallMethod service = retrofit.create(CallMethod.class);
-    try {
-      service.badType2();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "'okhttp3.Response' is not a valid response body type. Did you mean ResponseBody?\n"
-              + "    for method CallMethod.badType2");
-    }
-  }
-
-  @Test public void voidReturnTypeNotAllowed() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-    VoidService service = retrofit.create(VoidService.class);
-
-    try {
-      service.nope();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessageStartingWith(
-          "Service methods cannot return void.\n    for method VoidService.nope");
-    }
-  }
-
-  @Test public void validateEagerlyDisabledByDefault() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-
-    // Should not throw exception about incorrect configuration of the VoidService
-    retrofit.create(VoidService.class);
-  }
-
-  @Test public void validateEagerlyDisabledByUser() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .validateEagerly(false)
-        .build();
-
-    // Should not throw exception about incorrect configuration of the VoidService
-    retrofit.create(VoidService.class);
-  }
-
-  @Test public void validateEagerlyFailsAtCreation() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .validateEagerly(true)
-        .build();
-
-    try {
-      retrofit.create(VoidService.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessageStartingWith(
-          "Service methods cannot return void.\n    for method VoidService.nope");
-    }
-  }
-
-  @Test public void callCallAdapterAddedByDefault() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-    CallMethod example = retrofit.create(CallMethod.class);
-    assertThat(example.getResponseBody()).isNotNull();
-  }
-
-  @Test public void callCallCustomAdapter() {
-    final AtomicBoolean factoryCalled = new AtomicBoolean();
-    final AtomicBoolean adapterCalled = new AtomicBoolean();
-    class MyCallAdapterFactory extends CallAdapter.Factory {
-      @Override public CallAdapter<?> get(final Type returnType, Annotation[] annotations,
-          Retrofit retrofit) {
-        factoryCalled.set(true);
-        if (getRawType(returnType) != Call.class) {
-          return null;
-        }
-        return new CallAdapter<Call<?>>() {
-          @Override public Type responseType() {
-            return getParameterUpperBound(0, (ParameterizedType) returnType);
-          }
-
-          @Override public <R> Call<R> adapt(Call<R> call) {
-            adapterCalled.set(true);
-            return call;
-          }
-        };
-      }
-    }
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addCallAdapterFactory(new MyCallAdapterFactory())
-        .build();
-    CallMethod example = retrofit.create(CallMethod.class);
-    assertThat(example.getResponseBody()).isNotNull();
-    assertThat(factoryCalled.get()).isTrue();
-    assertThat(adapterCalled.get()).isTrue();
-  }
-
-  @Test public void customCallAdapter() {
-    class GreetingCallAdapterFactory extends CallAdapter.Factory {
-      @Override public CallAdapter<String> get(Type returnType, Annotation[] annotations,
-          Retrofit retrofit) {
-        if (getRawType(returnType) != String.class) {
-          return null;
-        }
-        return new CallAdapter<String>() {
-          @Override public Type responseType() {
-            return String.class;
-          }
-
-          @Override public <R> String adapt(Call<R> call) {
-            return "Hi!";
-          }
-        };
-      }
-    }
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .addCallAdapterFactory(new GreetingCallAdapterFactory())
-        .build();
-    StringService example = retrofit.create(StringService.class);
-    assertThat(example.get()).isEqualTo("Hi!");
-  }
-
-  @Test public void methodAnnotationsPassedToCallAdapter() {
-    final AtomicReference<Annotation[]> annotationsRef = new AtomicReference<>();
-    class MyCallAdapterFactory extends CallAdapter.Factory {
-      @Override public CallAdapter<?> get(Type returnType, Annotation[] annotations,
-          Retrofit retrofit) {
-        annotationsRef.set(annotations);
-        return null;
-      }
-    }
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .addCallAdapterFactory(new MyCallAdapterFactory())
-        .build();
-    Annotated annotated = retrofit.create(Annotated.class);
-    annotated.method(); // Trigger internal setup.
-
-    Annotation[] annotations = annotationsRef.get();
-    assertThat(annotations).hasAtLeastOneElementOfType(Annotated.Foo.class);
-  }
-
-  @Test public void customCallAdapterMissingThrows() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-    FutureMethod example = retrofit.create(FutureMethod.class);
-    try {
-      example.method();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(""
-          + "Unable to create call adapter for java.util.concurrent.Future<java.lang.String>\n"
-          + "    for method FutureMethod.method");
-      assertThat(e.getCause()).hasMessage(""
-          + "Could not locate call adapter for java.util.concurrent.Future<java.lang.String>.\n"
-          + "  Tried:\n"
-          + "   * retrofit2.DefaultCallAdapterFactory");
-    }
-  }
-
-  @Test public void methodAnnotationsPassedToResponseBodyConverter() {
-    final AtomicReference<Annotation[]> annotationsRef = new AtomicReference<>();
-    class MyConverterFactory extends Converter.Factory {
-      @Override
-      public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-          Retrofit retrofit) {
-        annotationsRef.set(annotations);
-        return new ToStringConverterFactory().responseBodyConverter(type, annotations, retrofit);
-      }
-    }
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new MyConverterFactory())
-        .build();
-    Annotated annotated = retrofit.create(Annotated.class);
-    annotated.method(); // Trigger internal setup.
-
-    Annotation[] annotations = annotationsRef.get();
-    assertThat(annotations).hasAtLeastOneElementOfType(Annotated.Foo.class);
-  }
-
-  @Test public void methodAndParameterAnnotationsPassedToRequestBodyConverter() {
-    final AtomicReference<Annotation[]> parameterAnnotationsRef = new AtomicReference<>();
-    final AtomicReference<Annotation[]> methodAnnotationsRef = new AtomicReference<>();
-
-    class MyConverterFactory extends Converter.Factory {
-      @Override
-      public Converter<?, RequestBody> requestBodyConverter(Type type,
-          Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
-        parameterAnnotationsRef.set(parameterAnnotations);
-        methodAnnotationsRef.set(methodAnnotations);
-        return new ToStringConverterFactory().requestBodyConverter(type, parameterAnnotations,
-            methodAnnotations, retrofit);
-      }
-    }
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new MyConverterFactory())
-        .build();
-    Annotated annotated = retrofit.create(Annotated.class);
-    annotated.bodyParameter(null); // Trigger internal setup.
-
-    assertThat(parameterAnnotationsRef.get()).hasAtLeastOneElementOfType(Annotated.Foo.class);
-    assertThat(methodAnnotationsRef.get()).hasAtLeastOneElementOfType(POST.class);
-  }
-
-  @Test public void parameterAnnotationsPassedToStringConverter() {
-    final AtomicReference<Annotation[]> annotationsRef = new AtomicReference<>();
-    class MyConverterFactory extends Converter.Factory {
-      @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
-          Retrofit retrofit) {
-        annotationsRef.set(annotations);
-
-        return new Converter<Object, String>() {
-          @Override public String convert(Object value) throws IOException {
-            return String.valueOf(value);
-          }
-        };
-      }
-    }
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new MyConverterFactory())
-        .build();
-    Annotated annotated = retrofit.create(Annotated.class);
-    annotated.queryParameter(null); // Trigger internal setup.
-
-    Annotation[] annotations = annotationsRef.get();
-    assertThat(annotations).hasAtLeastOneElementOfType(Annotated.Foo.class);
-  }
-
-  @Test public void stringConverterNotCalledForString() {
-    class MyConverterFactory extends Converter.Factory {
-      @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
-          Retrofit retrofit) {
-        throw new AssertionError();
-      }
-    }
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new MyConverterFactory())
-        .build();
-    CallMethod service = retrofit.create(CallMethod.class);
-    Call<ResponseBody> call = service.queryString(null);
-    assertThat(call).isNotNull();
-    // We also implicitly assert the above factory was not called as it would have thrown.
-  }
-
-  @Test public void stringConverterReturningNullResultsInDefault() {
-    final AtomicBoolean factoryCalled = new AtomicBoolean();
-    class MyConverterFactory extends Converter.Factory {
-      @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
-          Retrofit retrofit) {
-        factoryCalled.set(true);
-        return null;
-      }
-    }
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new MyConverterFactory())
-        .build();
-    CallMethod service = retrofit.create(CallMethod.class);
-    Call<ResponseBody> call = service.queryObject(null);
-    assertThat(call).isNotNull();
-    assertThat(factoryCalled.get()).isTrue();
-  }
-
-  @Test public void missingConverterThrowsOnNonRequestBody() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-    CallMethod example = retrofit.create(CallMethod.class);
-    try {
-      example.disallowed("Hi!");
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(""
-          + "Unable to create @Body converter for class java.lang.String (parameter #1)\n"
-          + "    for method CallMethod.disallowed");
-      assertThat(e.getCause()).hasMessage(""
-          + "Could not locate RequestBody converter for class java.lang.String.\n"
-          + "  Tried:\n"
-          + "   * retrofit2.BuiltInConverters");
-    }
-  }
-
-  @Test public void missingConverterThrowsOnNonResponseBody() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-    CallMethod example = retrofit.create(CallMethod.class);
-
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    try {
-      example.disallowed();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(""
-          + "Unable to create converter for class java.lang.String\n"
-          + "    for method CallMethod.disallowed");
-      assertThat(e.getCause()).hasMessage(""
-          + "Could not locate ResponseBody converter for class java.lang.String.\n"
-          + "  Tried:\n"
-          + "   * retrofit2.BuiltInConverters");
-    }
-  }
-
-  @Test public void requestBodyOutgoingAllowed() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-    CallMethod example = retrofit.create(CallMethod.class);
-
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    Response<ResponseBody> response = example.getResponseBody().execute();
-    assertThat(response.body().string()).isEqualTo("Hi");
-  }
-
-  @Test public void voidOutgoingAllowed() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-    CallMethod example = retrofit.create(CallMethod.class);
-
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    Response<Void> response = example.getVoid().execute();
-    assertThat(response.body()).isNull();
-  }
-
-  @Test public void voidResponsesArePooled() throws Exception {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-    CallMethod example = retrofit.create(CallMethod.class);
-
-    server.enqueue(new MockResponse().setBody("abc"));
-    server.enqueue(new MockResponse().setBody("def"));
-
-    example.getVoid().execute();
-    example.getVoid().execute();
-
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-  }
-
-  @Test public void responseBodyIncomingAllowed() throws IOException, InterruptedException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-    CallMethod example = retrofit.create(CallMethod.class);
-
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "Hey");
-    Response<ResponseBody> response = example.postRequestBody(body).execute();
-    assertThat(response.body().string()).isEqualTo("Hi");
-
-    assertThat(server.takeRequest().getBody().readUtf8()).isEqualTo("Hey");
-  }
-
-  @Test public void unresolvableResponseTypeThrows() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    UnresolvableResponseType example = retrofit.create(UnresolvableResponseType.class);
-
-    try {
-      example.typeVariable();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
-          + "retrofit2.Call<T>\n    for method UnresolvableResponseType.typeVariable");
-    }
-    try {
-      example.typeVariableUpperBound();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
-          + "retrofit2.Call<T>\n    for method UnresolvableResponseType.typeVariableUpperBound");
-    }
-    try {
-      example.crazy();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
-          + "retrofit2.Call<java.util.List<java.util.Map<java.lang.String, java.util.Set<T[]>>>>\n"
-          + "    for method UnresolvableResponseType.crazy");
-    }
-    try {
-      example.wildcard();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
-          + "retrofit2.Call<?>\n    for method UnresolvableResponseType.wildcard");
-    }
-    try {
-      example.wildcardUpperBound();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
-          + "retrofit2.Call<? extends okhttp3.ResponseBody>\n"
-          + "    for method UnresolvableResponseType.wildcardUpperBound");
-    }
-  }
-
-  @Test public void unresolvableParameterTypeThrows() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    UnresolvableParameterType example = retrofit.create(UnresolvableParameterType.class);
-
-    try {
-      example.typeVariable(null);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Parameter type must not include a type variable or wildcard: "
-          + "T (parameter #1)\n    for method UnresolvableParameterType.typeVariable");
-    }
-    try {
-      example.typeVariableUpperBound(null);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Parameter type must not include a type variable or wildcard: "
-          + "T (parameter #1)\n    for method UnresolvableParameterType.typeVariableUpperBound");
-    }
-    try {
-      example.crazy(null);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Parameter type must not include a type variable or wildcard: "
-          + "java.util.List<java.util.Map<java.lang.String, java.util.Set<T[]>>> (parameter #1)\n"
-          + "    for method UnresolvableParameterType.crazy");
-    }
-    try {
-      example.wildcard(null);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Parameter type must not include a type variable or wildcard: "
-          + "java.util.List<?> (parameter #1)\n    for method UnresolvableParameterType.wildcard");
-    }
-    try {
-      example.wildcardUpperBound(null);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Parameter type must not include a type variable or wildcard: "
-          + "java.util.List<? extends okhttp3.RequestBody> (parameter #1)\n"
-          + "    for method UnresolvableParameterType.wildcardUpperBound");
-    }
-  }
-
-  @Test public void baseUrlRequired() {
-    try {
-      new Retrofit.Builder().build();
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage("Base URL required.");
-    }
-  }
-
-  @Test public void baseUrlNullThrows() {
-    try {
-      new Retrofit.Builder().baseUrl((String) null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("baseUrl == null");
-    }
-    try {
-      new Retrofit.Builder().baseUrl((HttpUrl) null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("baseUrl == null");
-    }
-  }
-
-  @Test public void baseUrlInvalidThrows() {
-    try {
-      new Retrofit.Builder().baseUrl("ftp://foo/bar");
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Illegal URL: ftp://foo/bar");
-    }
-  }
-
-  @Test public void baseUrlNoTrailingSlashThrows() {
-    try {
-      new Retrofit.Builder().baseUrl("http://example.com/api");
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("baseUrl must end in /: http://example.com/api");
-    }
-    HttpUrl parsed = HttpUrl.parse("http://example.com/api");
-    try {
-      new Retrofit.Builder().baseUrl(parsed);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("baseUrl must end in /: http://example.com/api");
-    }
-  }
-
-  @Test public void baseUrlStringPropagated() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .build();
-    HttpUrl baseUrl = retrofit.baseUrl();
-    assertThat(baseUrl).isEqualTo(HttpUrl.parse("http://example.com/"));
-  }
-
-  @Test public void baseHttpUrlPropagated() {
-    HttpUrl url = HttpUrl.parse("http://example.com/");
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(url)
-        .build();
-    assertThat(retrofit.baseUrl()).isSameAs(url);
-  }
-
-  @Test public void clientNullThrows() {
-    try {
-      new Retrofit.Builder().client(null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("client == null");
-    }
-  }
-
-  @Test public void callFactoryDefault() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com")
-        .build();
-    assertThat(retrofit.callFactory()).isNotNull();
-  }
-
-  @Test public void callFactoryPropagated() {
-    okhttp3.Call.Factory callFactory = mock(okhttp3.Call.Factory.class);
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .callFactory(callFactory)
-        .build();
-    assertThat(retrofit.callFactory()).isSameAs(callFactory);
-  }
-
-  @Test public void callFactoryClientPropagated() {
-    OkHttpClient client = new OkHttpClient();
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .client(client)
-        .build();
-    assertThat(retrofit.callFactory()).isSameAs(client);
-  }
-
-  @Test public void callFactoryUsed() throws IOException {
-    okhttp3.Call.Factory callFactory = spy(new okhttp3.Call.Factory() {
-      @Override public okhttp3.Call newCall(Request request) {
-        return new OkHttpClient().newCall(request);
-      }
-    });
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .callFactory(callFactory)
-        .build();
-
-    server.enqueue(new MockResponse());
-
-    CallMethod service = retrofit.create(CallMethod.class);
-    service.getResponseBody().execute();
-    verify(callFactory).newCall(any(Request.class));
-    verifyNoMoreInteractions(callFactory);
-  }
-
-  @Test public void callFactoryReturningNullThrows() throws IOException {
-    okhttp3.Call.Factory callFactory = new okhttp3.Call.Factory() {
-      @Override public okhttp3.Call newCall(Request request) {
-        return null;
-      }
-    };
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .callFactory(callFactory)
-        .build();
-
-    server.enqueue(new MockResponse());
-
-    CallMethod service = retrofit.create(CallMethod.class);
-    Call<ResponseBody> call = service.getResponseBody();
-    try {
-      call.execute();
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("Call.Factory returned null.");
-    }
-  }
-
-  @Test public void callFactoryThrowingPropagates() {
-    final RuntimeException cause = new RuntimeException("Broken!");
-    okhttp3.Call.Factory callFactory = new okhttp3.Call.Factory() {
-      @Override public okhttp3.Call newCall(Request request) {
-        throw cause;
-      }
-    };
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .callFactory(callFactory)
-        .build();
-
-    server.enqueue(new MockResponse());
-
-    CallMethod service = retrofit.create(CallMethod.class);
-    Call<ResponseBody> call = service.getResponseBody();
-    try {
-      call.execute();
-      fail();
-    } catch (Exception e) {
-      assertThat(e).isSameAs(cause);
-    }
-  }
-
-  @Test public void converterNullThrows() {
-    try {
-      new Retrofit.Builder().addConverterFactory(null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("factory == null");
-    }
-  }
-
-  @Test public void converterFactoryDefault() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .build();
-    List<Converter.Factory> converterFactories = retrofit.converterFactories();
-    assertThat(converterFactories).hasSize(1);
-    assertThat(converterFactories.get(0)).isInstanceOf(BuiltInConverters.class);
-  }
-
-  @Test public void requestConverterFactoryQueried() {
-    Type type = String.class;
-    Annotation[] parameterAnnotations = new Annotation[0];
-    Annotation[] methodAnnotations = new Annotation[1];
-
-    Converter<?, RequestBody> expectedAdapter = mock(Converter.class);
-    Converter.Factory factory = mock(Converter.Factory.class);
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addConverterFactory(factory)
-        .build();
-
-    doReturn(expectedAdapter).when(factory).requestBodyConverter(type, parameterAnnotations,
-        methodAnnotations, retrofit);
-
-    Converter<?, RequestBody> actualAdapter = retrofit.requestBodyConverter(type,
-        parameterAnnotations, methodAnnotations);
-    assertThat(actualAdapter).isSameAs(expectedAdapter);
-
-    verify(factory).requestBodyConverter(type, parameterAnnotations, methodAnnotations, retrofit);
-    verifyNoMoreInteractions(factory);
-  }
-
-  @Test public void requestConverterFactoryNoMatchThrows() {
-    Type type = String.class;
-    Annotation[] annotations = new Annotation[0];
-
-    NonMatchingConverterFactory nonMatchingFactory = new NonMatchingConverterFactory();
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addConverterFactory(nonMatchingFactory)
-        .build();
-
-    try {
-      retrofit.requestBodyConverter(type, annotations, annotations);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(""
-          + "Could not locate RequestBody converter for class java.lang.String.\n"
-          + "  Tried:\n"
-          + "   * retrofit2.BuiltInConverters\n"
-          + "   * retrofit2.helpers.NonMatchingConverterFactory");
-    }
-
-    assertThat(nonMatchingFactory.called).isTrue();
-  }
-
-  @Test public void requestConverterFactorySkippedNoMatchThrows() {
-    Type type = String.class;
-    Annotation[] annotations = new Annotation[0];
-
-    NonMatchingConverterFactory nonMatchingFactory1 = new NonMatchingConverterFactory();
-    NonMatchingConverterFactory nonMatchingFactory2 = new NonMatchingConverterFactory();
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addConverterFactory(nonMatchingFactory1)
-        .addConverterFactory(nonMatchingFactory2)
-        .build();
-
-    try {
-      retrofit.nextRequestBodyConverter(nonMatchingFactory1, type, annotations, annotations);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(""
-          + "Could not locate RequestBody converter for class java.lang.String.\n"
-          + "  Skipped:\n"
-          + "   * retrofit2.BuiltInConverters\n"
-          + "   * retrofit2.helpers.NonMatchingConverterFactory\n"
-          + "  Tried:\n"
-          + "   * retrofit2.helpers.NonMatchingConverterFactory");
-    }
-
-    assertThat(nonMatchingFactory1.called).isFalse();
-    assertThat(nonMatchingFactory2.called).isTrue();
-  }
-
-  @Test public void responseConverterFactoryQueried() {
-    Type type = String.class;
-    Annotation[] annotations = new Annotation[0];
-
-    Converter<ResponseBody, ?> expectedAdapter = mock(Converter.class);
-    Converter.Factory factory = mock(Converter.Factory.class);
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addConverterFactory(factory)
-        .build();
-
-    doReturn(expectedAdapter).when(factory).responseBodyConverter(type, annotations, retrofit);
-
-    Converter<ResponseBody, ?> actualAdapter = retrofit.responseBodyConverter(type, annotations);
-    assertThat(actualAdapter).isSameAs(expectedAdapter);
-
-    verify(factory).responseBodyConverter(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory);
-  }
-
-  @Test public void responseConverterFactoryNoMatchThrows() {
-    Type type = String.class;
-    Annotation[] annotations = new Annotation[0];
-
-    NonMatchingConverterFactory nonMatchingFactory = new NonMatchingConverterFactory();
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addConverterFactory(nonMatchingFactory)
-        .build();
-
-    try {
-      retrofit.responseBodyConverter(type, annotations);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(""
-          + "Could not locate ResponseBody converter for class java.lang.String.\n"
-          + "  Tried:\n"
-          + "   * retrofit2.BuiltInConverters\n"
-          + "   * retrofit2.helpers.NonMatchingConverterFactory");
-    }
-
-    assertThat(nonMatchingFactory.called).isTrue();
-  }
-
-  @Test public void responseConverterFactorySkippedNoMatchThrows() {
-    Type type = String.class;
-    Annotation[] annotations = new Annotation[0];
-
-    NonMatchingConverterFactory nonMatchingFactory1 = new NonMatchingConverterFactory();
-    NonMatchingConverterFactory nonMatchingFactory2 = new NonMatchingConverterFactory();
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addConverterFactory(nonMatchingFactory1)
-        .addConverterFactory(nonMatchingFactory2)
-        .build();
-
-    try {
-      retrofit.nextResponseBodyConverter(nonMatchingFactory1, type, annotations);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(""
-          + "Could not locate ResponseBody converter for class java.lang.String.\n"
-          + "  Skipped:\n"
-          + "   * retrofit2.BuiltInConverters\n"
-          + "   * retrofit2.helpers.NonMatchingConverterFactory\n"
-          + "  Tried:\n"
-          + "   * retrofit2.helpers.NonMatchingConverterFactory");
-    }
-
-    assertThat(nonMatchingFactory1.called).isFalse();
-    assertThat(nonMatchingFactory2.called).isTrue();
-  }
-
-  @Test public void stringConverterFactoryQueried() {
-    Type type = Object.class;
-    Annotation[] annotations = new Annotation[0];
-
-    Converter<?, String> expectedAdapter = mock(Converter.class);
-    Converter.Factory factory = mock(Converter.Factory.class);
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addConverterFactory(factory)
-        .build();
-
-    doReturn(expectedAdapter).when(factory).stringConverter(type, annotations, retrofit);
-
-    Converter<?, String> actualAdapter = retrofit.stringConverter(type, annotations);
-    assertThat(actualAdapter).isSameAs(expectedAdapter);
-
-    verify(factory).stringConverter(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory);
-  }
-
-  @Test public void converterFactoryPropagated() {
-    Converter.Factory factory = mock(Converter.Factory.class);
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addConverterFactory(factory)
-        .build();
-    assertThat(retrofit.converterFactories()).contains(factory);
-  }
-
-  @Test public void callAdapterFactoryNullThrows() {
-    try {
-      new Retrofit.Builder().addCallAdapterFactory(null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("factory == null");
-    }
-  }
-
-  @Test public void callAdapterFactoryDefault() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .build();
-    assertThat(retrofit.callAdapterFactories()).isNotEmpty();
-  }
-
-  @Test public void callAdapterFactoryPropagated() {
-    CallAdapter.Factory factory = mock(CallAdapter.Factory.class);
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addCallAdapterFactory(factory)
-        .build();
-    assertThat(retrofit.callAdapterFactories()).contains(factory);
-  }
-
-  @Test public void callAdapterFactoryQueried() {
-    Type type = String.class;
-    Annotation[] annotations = new Annotation[0];
-
-    CallAdapter<?> expectedAdapter = mock(CallAdapter.class);
-    CallAdapter.Factory factory = mock(CallAdapter.Factory.class);
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addCallAdapterFactory(factory)
-        .build();
-
-    doReturn(expectedAdapter).when(factory).get(type, annotations, retrofit);
-
-    CallAdapter<?> actualAdapter = retrofit.callAdapter(type, annotations);
-    assertThat(actualAdapter).isSameAs(expectedAdapter);
-
-    verify(factory).get(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory);
-  }
-
-  @Test public void callAdapterFactoryQueriedCanDelegate() {
-    Type type = String.class;
-    Annotation[] annotations = new Annotation[0];
-
-    CallAdapter<?> expectedAdapter = mock(CallAdapter.class);
-    CallAdapter.Factory factory2 = mock(CallAdapter.Factory.class);
-    CallAdapter.Factory factory1 = spy(new CallAdapter.Factory() {
-      @Override
-      public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
-        return retrofit.nextCallAdapter(this, returnType, annotations);
-      }
-    });
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addCallAdapterFactory(factory1)
-        .addCallAdapterFactory(factory2)
-        .build();
-
-    doReturn(expectedAdapter).when(factory2).get(type, annotations, retrofit);
-
-    CallAdapter<?> actualAdapter = retrofit.callAdapter(type, annotations);
-    assertThat(actualAdapter).isSameAs(expectedAdapter);
-
-    verify(factory1).get(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory1);
-    verify(factory2).get(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory2);
-  }
-
-  @Test public void callAdapterFactoryQueriedCanDelegateTwiceWithoutRecursion() {
-    Type type = String.class;
-    Annotation[] annotations = new Annotation[0];
-
-    CallAdapter<?> expectedAdapter = mock(CallAdapter.class);
-    CallAdapter.Factory factory3 = mock(CallAdapter.Factory.class);
-    CallAdapter.Factory factory2 = spy(new CallAdapter.Factory() {
-      @Override
-      public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
-        return retrofit.nextCallAdapter(this, returnType, annotations);
-      }
-    });
-    CallAdapter.Factory factory1 = spy(new CallAdapter.Factory() {
-      @Override
-      public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
-        return retrofit.nextCallAdapter(this, returnType, annotations);
-      }
-    });
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addCallAdapterFactory(factory1)
-        .addCallAdapterFactory(factory2)
-        .addCallAdapterFactory(factory3)
-        .build();
-
-    doReturn(expectedAdapter).when(factory3).get(type, annotations, retrofit);
-
-    CallAdapter<?> actualAdapter = retrofit.callAdapter(type, annotations);
-    assertThat(actualAdapter).isSameAs(expectedAdapter);
-
-    verify(factory1).get(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory1);
-    verify(factory2).get(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory2);
-    verify(factory3).get(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory3);
-  }
-
-  @Test public void callAdapterFactoryNoMatchThrows() {
-    Type type = String.class;
-    Annotation[] annotations = new Annotation[0];
-
-    NonMatchingCallAdapterFactory nonMatchingFactory = new NonMatchingCallAdapterFactory();
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addCallAdapterFactory(nonMatchingFactory)
-        .build();
-
-    try {
-      retrofit.callAdapter(type, annotations);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(""
-          + "Could not locate call adapter for class java.lang.String.\n"
-          + "  Tried:\n"
-          + "   * retrofit2.helpers.NonMatchingCallAdapterFactory\n"
-          + "   * retrofit2.DefaultCallAdapterFactory");
-    }
-
-    assertThat(nonMatchingFactory.called).isTrue();
-  }
-
-  @Test public void callAdapterFactoryDelegateNoMatchThrows() {
-    Type type = String.class;
-    Annotation[] annotations = new Annotation[0];
-
-    DelegatingCallAdapterFactory delegatingFactory1 = new DelegatingCallAdapterFactory();
-    DelegatingCallAdapterFactory delegatingFactory2 = new DelegatingCallAdapterFactory();
-    NonMatchingCallAdapterFactory nonMatchingFactory = new NonMatchingCallAdapterFactory();
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addCallAdapterFactory(delegatingFactory1)
-        .addCallAdapterFactory(delegatingFactory2)
-        .addCallAdapterFactory(nonMatchingFactory)
-        .build();
-
-    try {
-      retrofit.callAdapter(type, annotations);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(""
-          + "Could not locate call adapter for class java.lang.String.\n"
-          + "  Skipped:\n"
-          + "   * retrofit2.helpers.DelegatingCallAdapterFactory\n"
-          + "   * retrofit2.helpers.DelegatingCallAdapterFactory\n"
-          + "  Tried:\n"
-          + "   * retrofit2.helpers.NonMatchingCallAdapterFactory\n"
-          + "   * retrofit2.DefaultCallAdapterFactory");
-    }
-
-    assertThat(delegatingFactory1.called).isTrue();
-    assertThat(delegatingFactory2.called).isTrue();
-    assertThat(nonMatchingFactory.called).isTrue();
-  }
-
-  @Test public void callbackExecutorNullThrows() {
-    try {
-      new Retrofit.Builder().callbackExecutor(null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("executor == null");
-    }
-  }
-
-  @Test public void callbackExecutorPropagatesDefaultJvm() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .build();
-    assertThat(retrofit.callbackExecutor()).isNull();
-  }
-
-  @Test public void callbackExecutorPropagatesDefaultAndroid() {
-    final Executor executor = Executors.newSingleThreadExecutor();
-    Platform platform = new Platform() {
-      @Override Executor defaultCallbackExecutor() {
-        return executor;
-      }
-    };
-    Retrofit retrofit = new Retrofit.Builder(platform)
-        .baseUrl("http://example.com/")
-        .build();
-    assertThat(retrofit.callbackExecutor()).isSameAs(executor);
-  }
-
-  @Test public void callbackExecutorPropagated() {
-    Executor executor = mock(Executor.class);
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .callbackExecutor(executor)
-        .build();
-    assertThat(retrofit.callbackExecutor()).isSameAs(executor);
-  }
-
-  @Test public void callbackExecutorUsedForSuccess() throws InterruptedException {
-    Executor executor = spy(new Executor() {
-      @Override public void execute(Runnable command) {
-        command.run();
-      }
-    });
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .callbackExecutor(executor)
-        .build();
-    CallMethod service = retrofit.create(CallMethod.class);
-    Call<ResponseBody> call = service.getResponseBody();
-
-    server.enqueue(new MockResponse());
-
-    final CountDownLatch latch = new CountDownLatch(1);
-    call.enqueue(new Callback<ResponseBody>() {
-      @Override public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
-        latch.countDown();
-      }
-
-      @Override public void onFailure(Call<ResponseBody> call, Throwable t) {
-        t.printStackTrace();
-      }
-    });
-    assertTrue(latch.await(2, TimeUnit.SECONDS));
-
-    verify(executor).execute(any(Runnable.class));
-    verifyNoMoreInteractions(executor);
-  }
-
-  @Test public void callbackExecutorUsedForFailure() throws InterruptedException {
-    Executor executor = spy(new Executor() {
-      @Override public void execute(Runnable command) {
-        command.run();
-      }
-    });
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .callbackExecutor(executor)
-        .build();
-    CallMethod service = retrofit.create(CallMethod.class);
-    Call<ResponseBody> call = service.getResponseBody();
-
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AT_START));
-
-    final CountDownLatch latch = new CountDownLatch(1);
-    call.enqueue(new Callback<ResponseBody>() {
-      @Override public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
-        throw new AssertionError();
-      }
-
-      @Override public void onFailure(Call<ResponseBody> call, Throwable t) {
-        latch.countDown();
-      }
-    });
-    assertTrue(latch.await(2, TimeUnit.SECONDS));
-
-    verify(executor).execute(any(Runnable.class));
-    verifyNoMoreInteractions(executor);
-  }
-
-  /** Confirm that Retrofit encodes parameters when the call is executed, and not earlier. */
-  @Test public void argumentCapture() throws Exception {
-    AtomicInteger i = new AtomicInteger();
-
-    server.enqueue(new MockResponse().setBody("a"));
-    server.enqueue(new MockResponse().setBody("b"));
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    MutableParameters mutableParameters = retrofit.create(MutableParameters.class);
-
-    i.set(100);
-    Call<String> call1 = mutableParameters.method(i);
-
-    i.set(101);
-    Response<String> response1 = call1.execute();
-
-    i.set(102);
-    assertEquals("a", response1.body());
-    assertEquals("/?i=101", server.takeRequest().getPath());
-
-    i.set(200);
-    Call<String> call2 = call1.clone();
-
-    i.set(201);
-    Response<String> response2 = call2.execute();
-
-    i.set(202);
-    assertEquals("b", response2.body());
-
-    assertEquals("/?i=201", server.takeRequest().getPath());
-  }
-}
diff --git a/retrofit/src/test/java/retrofit2/ServiceMethodTest.java b/retrofit/src/test/java/retrofit2/ServiceMethodTest.java
deleted file mode 100644
index c9c48f31e..000000000
--- a/retrofit/src/test/java/retrofit2/ServiceMethodTest.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2;
-
-import java.util.Set;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
-public final class ServiceMethodTest {
-  @Test public void pathParameterParsing() throws Exception {
-    expectParams("/");
-    expectParams("/foo");
-    expectParams("/foo/bar");
-    expectParams("/foo/bar/{}");
-    expectParams("/foo/bar/{taco}", "taco");
-    expectParams("/foo/bar/{t}", "t");
-    expectParams("/foo/bar/{!!!}/"); // Invalid parameter.
-    expectParams("/foo/bar/{}/{taco}", "taco");
-    expectParams("/foo/bar/{taco}/or/{burrito}", "taco", "burrito");
-    expectParams("/foo/bar/{taco}/or/{taco}", "taco");
-    expectParams("/foo/bar/{taco-shell}", "taco-shell");
-    expectParams("/foo/bar/{taco_shell}", "taco_shell");
-    expectParams("/foo/bar/{sha256}", "sha256");
-    expectParams("/foo/bar/{TACO}", "TACO");
-    expectParams("/foo/bar/{taco}/{tAco}/{taCo}", "taco", "tAco", "taCo");
-    expectParams("/foo/bar/{1}"); // Invalid parameter, name cannot start with digit.
-  }
-
-  private static void expectParams(String path, String... expected) {
-    Set<String> calculated = ServiceMethod.parsePathParameters(path);
-    assertThat(calculated).containsExactly(expected);
-  }
-}
diff --git a/retrofit/src/test/java/retrofit2/helpers/DelegatingCallAdapterFactory.java b/retrofit/src/test/java/retrofit2/helpers/DelegatingCallAdapterFactory.java
deleted file mode 100644
index 918b0ea0f..000000000
--- a/retrofit/src/test/java/retrofit2/helpers/DelegatingCallAdapterFactory.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2.helpers;
-
-import java.lang.annotation.Annotation;
-import java.lang.reflect.Type;
-import retrofit2.CallAdapter;
-import retrofit2.Retrofit;
-
-public final class DelegatingCallAdapterFactory extends CallAdapter.Factory {
-  public boolean called;
-
-  @Override
-  public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
-    called = true;
-    return retrofit.nextCallAdapter(this, returnType, annotations);
-  }
-}
diff --git a/retrofit/src/test/java/retrofit2/helpers/NonMatchingCallAdapterFactory.java b/retrofit/src/test/java/retrofit2/helpers/NonMatchingCallAdapterFactory.java
deleted file mode 100644
index 2b4954813..000000000
--- a/retrofit/src/test/java/retrofit2/helpers/NonMatchingCallAdapterFactory.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2.helpers;
-
-import java.lang.annotation.Annotation;
-import java.lang.reflect.Type;
-import retrofit2.CallAdapter;
-import retrofit2.Retrofit;
-
-public final class NonMatchingCallAdapterFactory extends CallAdapter.Factory {
-  public boolean called;
-
-  @Override
-  public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
-    called = true;
-    return null;
-  }
-}
diff --git a/retrofit/src/test/java/retrofit2/helpers/NonMatchingConverterFactory.java b/retrofit/src/test/java/retrofit2/helpers/NonMatchingConverterFactory.java
deleted file mode 100644
index 343839944..000000000
--- a/retrofit/src/test/java/retrofit2/helpers/NonMatchingConverterFactory.java
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2.helpers;
-
-import java.lang.annotation.Annotation;
-import java.lang.reflect.Type;
-import okhttp3.RequestBody;
-import okhttp3.ResponseBody;
-import retrofit2.Converter;
-import retrofit2.Retrofit;
-
-public final class NonMatchingConverterFactory extends Converter.Factory {
-  public boolean called;
-
-  @Override
-  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
-    called = true;
-    return null;
-  }
-
-  @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
-      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
-    called = true;
-    return null;
-  }
-
-  @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
-    called = true;
-    return null;
-  }
-}
diff --git a/retrofit/src/test/java/retrofit2/helpers/ToStringConverterFactory.java b/retrofit/src/test/java/retrofit2/helpers/ToStringConverterFactory.java
deleted file mode 100644
index 0a70e3ddb..000000000
--- a/retrofit/src/test/java/retrofit2/helpers/ToStringConverterFactory.java
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2.helpers;
-
-import java.io.IOException;
-import java.lang.annotation.Annotation;
-import java.lang.reflect.Type;
-import okhttp3.MediaType;
-import okhttp3.RequestBody;
-import okhttp3.ResponseBody;
-import retrofit2.Converter;
-import retrofit2.Retrofit;
-
-public class ToStringConverterFactory extends Converter.Factory {
-  static final MediaType MEDIA_TYPE = MediaType.parse("text/plain");
-
-  @Override
-  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
-    if (String.class.equals(type)) {
-      return new Converter<ResponseBody, String>() {
-        @Override public String convert(ResponseBody value) throws IOException {
-          return value.string();
-        }
-      };
-    }
-    return null;
-  }
-
-  @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
-      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
-    if (String.class.equals(type)) {
-      return new Converter<String, RequestBody>() {
-        @Override public RequestBody convert(String value) throws IOException {
-          return RequestBody.create(MEDIA_TYPE, value);
-        }
-      };
-    }
-    return null;
-  }
-}
diff --git a/settings.gradle b/settings.gradle
index e7b4def49..97d34ecda 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -1 +1 @@
-include ':app'
+include ':retrofit-plus-demo',':retrofit'
