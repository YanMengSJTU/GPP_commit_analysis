diff --git a/build.gradle b/build.gradle
index f55a6f535..6a625a3e8 100644
--- a/build.gradle
+++ b/build.gradle
@@ -5,7 +5,7 @@ buildscript {
         jcenter()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:1.3.0'
+        classpath 'com.android.tools.build:gradle:2.3.2'
 
         // NOTE: Do not place your application dependencies here; they belong
         // in the individual module build.gradle files
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index f23df6e46..15291e236 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Wed Oct 21 11:34:03 PDT 2015
+#Mon Jul 10 17:22:20 CST 2017
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.8-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-3.3-all.zip
diff --git a/retrofit/build.gradle b/retrofit/build.gradle
index 291687335..5055576e8 100644
--- a/retrofit/build.gradle
+++ b/retrofit/build.gradle
@@ -23,4 +23,5 @@ dependencies {
     compile 'com.squareup.okhttp3:okhttp:3.8.1'
     compile 'com.android.support:appcompat-v7:23.1.1'
     compile 'org.codehaus.mojo:animal-sniffer-annotations:1.14'
+    compile group: 'com.google.code.findbugs', name: 'jsr305', version: '3.0.0'
 }
\ No newline at end of file
diff --git a/retrofit/src/main/java/retrofit2/Platform.java b/retrofit/src/main/java/retrofit2/Platform.java
index fb768ecdc..f87594e7e 100644
--- a/retrofit/src/main/java/retrofit2/Platform.java
+++ b/retrofit/src/main/java/retrofit2/Platform.java
@@ -18,8 +18,12 @@
 import android.os.Build;
 import android.os.Handler;
 import android.os.Looper;
+//import java.lang.invoke.MethodHandles.Lookup;
+import java.lang.reflect.Constructor;
 import java.lang.reflect.Method;
 import java.util.concurrent.Executor;
+import javax.annotation.Nullable;
+import org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement;
 
 class Platform {
   private static final Platform PLATFORM = findPlatform();
@@ -36,19 +40,19 @@ private static Platform findPlatform() {
       }
     } catch (ClassNotFoundException ignored) {
     }
-//    try {
-//      Class.forName("java.util.Optional");
-//      return new Java8();
-//    } catch (ClassNotFoundException ignored) {
-//    }
+    try {
+      Class.forName("java.util.Optional");
+      return new Java8();
+    } catch (ClassNotFoundException ignored) {
+    }
     return new Platform();
   }
 
-   Executor defaultCallbackExecutor() {
+  @Nullable Executor defaultCallbackExecutor() {
     return null;
   }
 
-  CallAdapter.Factory defaultCallAdapterFactory( Executor callbackExecutor) {
+  CallAdapter.Factory defaultCallAdapterFactory(@Nullable Executor callbackExecutor) {
     if (callbackExecutor != null) {
       return new ExecutorCallAdapterFactory(callbackExecutor);
     }
@@ -59,36 +63,36 @@ boolean isDefaultMethod(Method method) {
     return false;
   }
 
-  Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object,
-       Object... args) throws Throwable {
+  @Nullable Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object,
+                                       @Nullable Object... args) throws Throwable {
     throw new UnsupportedOperationException();
   }
 
-//  @IgnoreJRERequirement // Only classloaded and used on Java 8.
-//  static class Java8 extends Platform {
+  @IgnoreJRERequirement // Only classloaded and used on Java 8.
+  static class Java8 extends Platform {
 //    @Override boolean isDefaultMethod(Method method) {
 //      return method.isDefault();
 //    }
 //
 //    @Override Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object,
-//        @Nullable Object... args) throws Throwable {
+//                                         @Nullable Object... args) throws Throwable {
 //      // Because the service interface might not be public, we need to use a MethodHandle lookup
 //      // that ignores the visibility of the declaringClass.
 //      Constructor<Lookup> constructor = Lookup.class.getDeclaredConstructor(Class.class, int.class);
 //      constructor.setAccessible(true);
 //      return constructor.newInstance(declaringClass, -1 /* trusted */)
-//          .unreflectSpecial(method, declaringClass)
-//          .bindTo(object)
-//          .invokeWithArguments(args);
+//              .unreflectSpecial(method, declaringClass)
+//              .bindTo(object)
+//              .invokeWithArguments(args);
 //    }
-//  }
+  }
 
   static class Android extends Platform {
     @Override public Executor defaultCallbackExecutor() {
       return new MainThreadExecutor();
     }
 
-    @Override CallAdapter.Factory defaultCallAdapterFactory( Executor callbackExecutor) {
+    @Override CallAdapter.Factory defaultCallAdapterFactory(@Nullable Executor callbackExecutor) {
       if (callbackExecutor == null) throw new AssertionError();
       return new ExecutorCallAdapterFactory(callbackExecutor);
     }
