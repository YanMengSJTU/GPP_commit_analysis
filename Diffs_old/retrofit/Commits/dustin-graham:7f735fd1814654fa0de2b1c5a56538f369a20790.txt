diff --git a/pom.xml b/pom.xml
index 93eac365f..414cad2c4 100644
--- a/pom.xml
+++ b/pom.xml
@@ -51,7 +51,6 @@
     <android.version>4.1.1.4</android.version>
     <android.platform>16</android.platform>
     <gson.version>2.2.2</gson.version>
-    <httpmime.version>4.2.3</httpmime.version>
     <javax.inject.version>1</javax.inject.version>
 
     <!-- Test Dependencies -->
@@ -111,11 +110,6 @@
         <artifactId>gson</artifactId>
         <version>${gson.version}</version>
       </dependency>
-      <dependency>
-        <groupId>org.apache.httpcomponents</groupId>
-        <artifactId>httpmime</artifactId>
-        <version>${httpmime.version}</version>
-      </dependency>
 
       <dependency>
         <groupId>junit</groupId>
diff --git a/retrofit/pom.xml b/retrofit/pom.xml
index e61e1a31b..f2ecdc6c2 100644
--- a/retrofit/pom.xml
+++ b/retrofit/pom.xml
@@ -20,10 +20,6 @@
       <groupId>com.google.code.gson</groupId>
       <artifactId>gson</artifactId>
     </dependency>
-    <dependency>
-      <groupId>org.apache.httpcomponents</groupId>
-      <artifactId>httpmime</artifactId>
-    </dependency>
     <dependency>
       <groupId>com.google.android</groupId>
       <artifactId>android</artifactId>
diff --git a/retrofit/src/main/java/retrofit/http/MultipartTypedOutput.java b/retrofit/src/main/java/retrofit/http/MultipartTypedOutput.java
index b01b70efc..f85e0ea0c 100644
--- a/retrofit/src/main/java/retrofit/http/MultipartTypedOutput.java
+++ b/retrofit/src/main/java/retrofit/http/MultipartTypedOutput.java
@@ -3,64 +3,81 @@
 
 import java.io.IOException;
 import java.io.OutputStream;
-import org.apache.http.entity.mime.MIME;
-import org.apache.http.entity.mime.MultipartEntity;
-import org.apache.http.entity.mime.content.AbstractContentBody;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import java.util.UUID;
+import retrofit.http.mime.TypedFile;
 import retrofit.http.mime.TypedOutput;
 
 final class MultipartTypedOutput implements TypedOutput {
-  // TODO implement our own Multipart logic instead!
-  final MultipartEntity cheat = new MultipartEntity();
+  final Map<String, TypedOutput> parts = new LinkedHashMap<String, TypedOutput>();
+  private final String boundary;
+
+  MultipartTypedOutput() {
+    boundary = UUID.randomUUID().toString();
+  }
 
   void addPart(String name, TypedOutput body) {
-    cheat.addPart(name, new TypedOutputBody(body));
+    if (name == null) {
+      throw new NullPointerException("Part name must not be null.");
+    }
+    if (body == null) {
+      throw new NullPointerException("Part body must not be null.");
+    }
+    parts.put(name, body);
   }
 
   @Override public String mimeType() {
-    return cheat.getContentType().getValue();
+    return "multipart/form-data; boundary=" + boundary;
   }
 
   @Override public long length() {
-    return cheat.getContentLength();
+    return -1;
   }
 
   @Override public void writeTo(OutputStream out) throws IOException {
-    cheat.writeTo(out);
-  }
-
-  /** Adapts {@link org.apache.http.entity.mime.content.ContentBody} to {@link TypedOutput}. */
-  static class TypedOutputBody extends AbstractContentBody {
-    final TypedOutput typedBytes;
-
-    TypedOutputBody(TypedOutput typedBytes) {
-      super(typedBytes.mimeType());
-      this.typedBytes = typedBytes;
+    boolean first = true;
+    for (Map.Entry<String, TypedOutput> part : parts.entrySet()) {
+      writeBoundary(out, boundary, first, false);
+      writePart(out, part);
+      first = false;
     }
+    writeBoundary(out, boundary, false, true);
+  }
 
-    @Override public long getContentLength() {
-      return typedBytes.length();
+  private static void writeBoundary(OutputStream out, String boundary, boolean first, boolean last)
+      throws IOException {
+    StringBuilder sb = new StringBuilder();
+    if (!first) {
+      sb.append("\r\n");
     }
-
-    @Override public String getFilename() {
-      return null;
+    sb.append("--");
+    sb.append(boundary);
+    if (last) {
+      sb.append("--");
+    } else {
+      sb.append("\r\n");
     }
+    out.write(sb.toString().getBytes("UTF-8"));
+  }
 
-    @Override public String getCharset() {
-      return null;
-    }
+  private static void writePart(OutputStream out, Map.Entry<String, TypedOutput> part)
+      throws IOException {
+    String name = part.getKey();
+    TypedOutput value = part.getValue();
 
-    @Override public String getTransferEncoding() {
-      return MIME.ENC_BINARY;
+    StringBuilder headers = new StringBuilder();
+    headers.append("Content-Disposition: form-data; name=\"");
+    headers.append(name);
+    if (value instanceof TypedFile) {
+      headers.append("\"; filename=\"");
+      headers.append(((TypedFile) value).file().getName());
     }
+    headers.append("\"\r\nContent-Type: ");
+    headers.append(value.mimeType());
+    headers.append("\r\nContent-Transfer-Encoding: binary\r\n\r\n");
+    out.write(headers.toString().getBytes("UTF-8"));
 
-    @Override public void writeTo(OutputStream out) throws IOException {
-      // Note: We probably want to differentiate I/O errors that occur while reading a file from
-      // network errors. Network operations can be retried. File operations will probably continue
-      // to fail.
-      //
-      // In the case of photo uploads, we at least check that the file exists before we even try to
-      // upload it.
-      typedBytes.writeTo(out);
-    }
+    value.writeTo(out);
   }
 }
diff --git a/retrofit/src/main/java/retrofit/http/Platform.java b/retrofit/src/main/java/retrofit/http/Platform.java
index 28ad85613..da9bfc7fe 100644
--- a/retrofit/src/main/java/retrofit/http/Platform.java
+++ b/retrofit/src/main/java/retrofit/http/Platform.java
@@ -2,6 +2,7 @@
 
 import android.os.Build;
 import android.os.Process;
+import android.util.Log;
 import com.google.gson.Gson;
 import java.util.concurrent.Executor;
 import java.util.concurrent.Executors;
@@ -39,6 +40,7 @@ Converter defaultConverter() {
   abstract Client.Provider defaultClient();
   abstract Executor defaultHttpExecutor();
   abstract Executor defaultCallbackExecutor();
+  abstract RestAdapter.Log defaultLog();
 
   /** Provides sane defaults for operation on the JVM. */
   private static class Base extends Platform {
@@ -69,6 +71,14 @@ Converter defaultConverter() {
     @Override Executor defaultCallbackExecutor() {
       return new SynchronousExecutor();
     }
+
+    @Override RestAdapter.Log defaultLog() {
+      return new RestAdapter.Log() {
+        @Override public void log(String message) {
+          System.out.println(message);
+        }
+      };
+    }
   }
 
   /** Provides sane defaults for operation on Android. */
@@ -105,5 +115,13 @@ Converter defaultConverter() {
     @Override Executor defaultCallbackExecutor() {
       return new MainThreadExecutor();
     }
+
+    @Override RestAdapter.Log defaultLog() {
+      return new RestAdapter.Log() {
+        @Override public void log(String message) {
+          Log.d("Retrofit", message);
+        }
+      };
+    }
   }
 }
diff --git a/retrofit/src/main/java/retrofit/http/RestAdapter.java b/retrofit/src/main/java/retrofit/http/RestAdapter.java
index 4bff10d1e..e77f41219 100644
--- a/retrofit/src/main/java/retrofit/http/RestAdapter.java
+++ b/retrofit/src/main/java/retrofit/http/RestAdapter.java
@@ -1,6 +1,7 @@
 // Copyright 2012 Square, Inc.
 package retrofit.http;
 
+import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.InvocationTargetException;
@@ -11,8 +12,6 @@
 import java.util.Map;
 import java.util.concurrent.Executor;
 import java.util.concurrent.TimeUnit;
-import java.util.logging.Level;
-import java.util.logging.Logger;
 import retrofit.http.Profiler.RequestInformation;
 import retrofit.http.client.Client;
 import retrofit.http.client.Request;
@@ -30,10 +29,15 @@
  * @author Jake Wharton (jw@squareup.com)
  */
 public class RestAdapter {
-  private static final Logger LOGGER = Logger.getLogger(RestAdapter.class.getName());
   private static final int LOG_CHUNK_SIZE = 4000;
   static final String THREAD_PREFIX = "Retrofit-";
 
+  /** Simple logging abstraction for debug messages. */
+  public interface Log {
+    /** Log a debug message to the appropriate console. */
+    void log(String message);
+  }
+
   private final Server server;
   private final Client.Provider clientProvider;
   private final Executor httpExecutor;
@@ -41,9 +45,12 @@
   private final Headers headers;
   private final Converter converter;
   private final Profiler profiler;
+  private final Log log;
+  private volatile boolean debug;
 
   private RestAdapter(Server server, Client.Provider clientProvider, Executor httpExecutor,
-      Executor callbackExecutor, Headers headers, Converter converter, Profiler profiler) {
+      Executor callbackExecutor, Headers headers, Converter converter, Profiler profiler, Log log,
+      boolean debug) {
     this.server = server;
     this.clientProvider = clientProvider;
     this.httpExecutor = httpExecutor;
@@ -51,6 +58,13 @@ private RestAdapter(Server server, Client.Provider clientProvider, Executor http
     this.headers = headers;
     this.converter = converter;
     this.profiler = profiler;
+    this.log = log;
+    this.debug = debug;
+  }
+
+  /** Toggle debug logging on and off. */
+  public void setDebug(boolean debug) {
+    this.debug = debug;
   }
 
   /**
@@ -141,10 +155,11 @@ private RestAdapter(Server server, Client.Provider clientProvider, Executor http
     private Object invokeRequest(RestMethodInfo methodDetails, Object[] args) {
       methodDetails.init(); // Ensure all relevant method information has been loaded.
 
-      String url = server.getUrl();
+      String serverUrl = server.getUrl();
+      String url = serverUrl; // Keep some url in case RequestBuilder throws an exception.
       try {
         Request request = new RequestBuilder(converter) //
-            .setApiUrl(server.getUrl())
+            .setApiUrl(serverUrl)
             .setArgs(args)
             .setHeaders(headers.get())
             .setMethodInfo(methodDetails)
@@ -153,11 +168,11 @@ private Object invokeRequest(RestMethodInfo methodDetails, Object[] args) {
 
         if (!methodDetails.isSynchronous) {
           // If we are executing asynchronously then update the current thread with a useful name.
-          Thread.currentThread().setName(THREAD_PREFIX + url);
+          Thread.currentThread().setName(THREAD_PREFIX + url.substring(serverUrl.length()));
         }
 
-        if (LOGGER.isLoggable(Level.FINE)) {
-          logRequest(request);
+        if (debug) {
+          request = logAndReplaceRequest(request);
         }
 
         Object profilerObject = null;
@@ -171,14 +186,12 @@ private Object invokeRequest(RestMethodInfo methodDetails, Object[] args) {
 
         int statusCode = response.getStatus();
         if (profiler != null) {
-          RequestInformation requestInfo = getRequestInfo(server, methodDetails, request);
+          RequestInformation requestInfo = getRequestInfo(serverUrl, methodDetails, request);
           profiler.afterCall(requestInfo, elapsedTime, statusCode, profilerObject);
         }
 
-        TypedInput body = response.getBody();
-        if (LOGGER.isLoggable(Level.FINE)) {
-          // Replace the response since the logger needs to consume the entire input stream.
-          body = logResponse(url, response.getStatus(), body, elapsedTime);
+        if (debug) {
+          response = logAndReplaceResponse(url, response, elapsedTime);
         }
 
         Type type = methodDetails.type;
@@ -189,6 +202,7 @@ private Object invokeRequest(RestMethodInfo methodDetails, Object[] args) {
             }
             return new ResponseWrapper(response, response);
           }
+          TypedInput body = response.getBody();
           if (body == null) {
             return new ResponseWrapper(response, null);
           }
@@ -213,34 +227,77 @@ private Object invokeRequest(RestMethodInfo methodDetails, Object[] args) {
     }
   }
 
-  private static void logRequest(Request request) {
-    LOGGER.fine("---> HTTP " + request.getMethod() + " " + request.getUrl());
+  /** Log request headers and body. Consumes request body and returns identical replacement. */
+  private Request logAndReplaceRequest(Request request) throws IOException {
+    log.log(String.format("---> HTTP %s %s", request.getMethod(), request.getUrl()));
+
     for (Header header : request.getHeaders()) {
-      LOGGER.fine(header.getName() + ": " + header.getValue());
+      log.log(header.getName() + ": " + header.getValue());
     }
-    LOGGER.fine("---> END HTTP");
+
+    TypedOutput body = request.getBody();
+    int bodySize = 0;
+    if (body != null) {
+      if (!request.getHeaders().isEmpty()) {
+        log.log("");
+      }
+
+      ByteArrayOutputStream baos = new ByteArrayOutputStream();
+      body.writeTo(baos);
+      byte[] bodyBytes = baos.toByteArray();
+      bodySize = bodyBytes.length;
+      String bodyMime = body.mimeType();
+      String bodyString = new String(bodyBytes, Utils.parseCharset(bodyMime));
+      for (int i = 0; i < bodyString.length(); i += LOG_CHUNK_SIZE) {
+        int end = Math.min(bodyString.length(), i + LOG_CHUNK_SIZE);
+        log.log(bodyString.substring(i, end));
+      }
+
+      body = new TypedByteArray(bodyMime, bodyBytes);
+    }
+
+    log.log(String.format("---> END HTTP (%s-byte body)", bodySize));
+
+    // Since we consumed the original request, return a new, identical one from its bytes.
+    return new Request(request.getMethod(), request.getUrl(), request.getHeaders(), body);
   }
 
-  /** Log response data. Returns replacement {@link TypedInput}. */
-  private static TypedInput logResponse(String url, int statusCode, TypedInput body,
-      long elapsedTime) throws IOException {
-    LOGGER.fine("<--- HTTP " + statusCode + " " + url + " (" + elapsedTime + "ms)");
-
-    byte[] bodyBytes = Utils.streamToBytes(body.in());
-    String bodyCharset = Utils.parseCharset(body.mimeType());
-    String bodyString = new String(bodyBytes, bodyCharset);
-    for (int i = 0; i < bodyString.length(); i += LOG_CHUNK_SIZE) {
-      int end = Math.min(bodyString.length(), i + LOG_CHUNK_SIZE);
-      LOGGER.fine(bodyString.substring(i, end));
+  /** Log response headers and body. Consumes response body and returns identical replacement. */
+  private Response logAndReplaceResponse(String url, Response response, long elapsedTime)
+      throws IOException {
+    log.log(String.format("<--- HTTP %s %s (%sms)", response.getStatus(), url, elapsedTime));
+
+    for (Header header : response.getHeaders()) {
+      log.log(header.getName() + ": " + header.getValue());
+    }
+
+    TypedInput body = response.getBody();
+    int bodySize = 0;
+    if (body != null) {
+      if (!response.getHeaders().isEmpty()) {
+        log.log("");
+      }
+
+      byte[] bodyBytes = Utils.streamToBytes(body.in());
+      bodySize = bodyBytes.length;
+      String bodyMime = body.mimeType();
+      String bodyCharset = Utils.parseCharset(bodyMime);
+      String bodyString = new String(bodyBytes, bodyCharset);
+      for (int i = 0; i < bodyString.length(); i += LOG_CHUNK_SIZE) {
+        int end = Math.min(bodyString.length(), i + LOG_CHUNK_SIZE);
+        log.log(bodyString.substring(i, end));
+      }
+
+      body = new TypedByteArray(bodyMime, bodyBytes);
     }
 
-    LOGGER.fine("<--- END HTTP");
+    log.log(String.format("---> END HTTP (%s-byte body)", bodySize));
 
-    // Since we consumed the entire input stream, return a new, identical one from its bytes.
-    return new TypedByteArray(body.mimeType(), bodyBytes);
+    // Since we consumed the original response, return a new, identical one from its bytes.
+    return new Response(response.getStatus(), response.getReason(), response.getHeaders(), body);
   }
 
-  private static Profiler.RequestInformation getRequestInfo(Server server,
+  private static Profiler.RequestInformation getRequestInfo(String serverUrl,
       RestMethodInfo methodDetails, Request request) {
     long contentLength = 0;
     String contentType = null;
@@ -251,7 +308,7 @@ private static TypedInput logResponse(String url, int statusCode, TypedInput bod
       contentType = body.mimeType();
     }
 
-    return new Profiler.RequestInformation(methodDetails.restMethod.value(), server.getUrl(),
+    return new Profiler.RequestInformation(methodDetails.restMethod.value(), serverUrl,
         methodDetails.path, contentLength, contentType);
   }
 
@@ -279,6 +336,8 @@ private static TypedInput logResponse(String url, int statusCode, TypedInput bod
     private Headers headers;
     private Converter converter;
     private Profiler profiler;
+    private Log log;
+    private boolean debug;
 
     public Builder setServer(String endpoint) {
       if (endpoint == null) throw new NullPointerException("endpoint");
@@ -340,13 +399,24 @@ public Builder setProfiler(Profiler profiler) {
       return this;
     }
 
+    public Builder setLog(Log log) {
+      if (log == null) throw new NullPointerException("log");
+      this.log = log;
+      return this;
+    }
+
+    public Builder setDebug(boolean debug) {
+      this.debug = debug;
+      return this;
+    }
+
     public RestAdapter build() {
       if (server == null) {
         throw new IllegalArgumentException("Server may not be null.");
       }
       ensureSaneDefaults();
-      return new RestAdapter(server, clientProvider, httpExecutor, callbackExecutor,
-          headers, converter, profiler);
+      return new RestAdapter(server, clientProvider, httpExecutor, callbackExecutor, headers,
+          converter, profiler, log, debug);
     }
 
     private void ensureSaneDefaults() {
@@ -362,6 +432,9 @@ private void ensureSaneDefaults() {
       if (callbackExecutor == null) {
         callbackExecutor = Platform.get().defaultCallbackExecutor();
       }
+      if (log == null) {
+        log = Platform.get().defaultLog();
+      }
       if (headers == null) {
         headers = Headers.NONE;
       }
diff --git a/retrofit/src/main/java/retrofit/http/client/ApacheClient.java b/retrofit/src/main/java/retrofit/http/client/ApacheClient.java
index 01ffa7994..8c0dcc660 100644
--- a/retrofit/src/main/java/retrofit/http/client/ApacheClient.java
+++ b/retrofit/src/main/java/retrofit/http/client/ApacheClient.java
@@ -37,23 +37,14 @@ public ApacheClient(HttpClient client) {
   }
 
   @Override public Response execute(Request request) throws IOException {
-    // Create and prepare the Apache request object.
     HttpUriRequest apacheRequest = createRequest(request);
-    prepareRequest(apacheRequest);
-
-    // Obtain and prepare the Apache response object.
-    HttpResponse apacheResponse = client.execute(apacheRequest);
-    prepareResponse(apacheResponse);
-
+    HttpResponse apacheResponse = execute(client, apacheRequest);
     return parseResponse(apacheResponse);
   }
 
-  /** Callback for additional preparation of the request before execution. */
-  protected void prepareRequest(HttpUriRequest request) {
-  }
-
-  /** Callback for additional preparation of the response before parsing. */
-  protected void prepareResponse(HttpResponse response) {
+  /** Execute the specified {@code request} using the provided {@code client}. */
+  protected HttpResponse execute(HttpClient client, HttpUriRequest request) throws IOException {
+    return client.execute(request);
   }
 
   static HttpUriRequest createRequest(Request request) {
diff --git a/retrofit/src/test/java/retrofit/http/RequestBuilderTest.java b/retrofit/src/test/java/retrofit/http/RequestBuilderTest.java
index 7de05d4f1..44fc6d25f 100644
--- a/retrofit/src/test/java/retrofit/http/RequestBuilderTest.java
+++ b/retrofit/src/test/java/retrofit/http/RequestBuilderTest.java
@@ -8,10 +8,10 @@
 import java.net.URISyntaxException;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Iterator;
 import java.util.List;
+import java.util.Map;
 import java.util.Set;
-import org.apache.http.entity.mime.FormBodyPart;
-import org.apache.http.entity.mime.HttpMultipart;
 import org.junit.Test;
 import retrofit.http.client.Request;
 import retrofit.http.mime.TypedOutput;
@@ -20,7 +20,6 @@
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
-import static retrofit.http.MultipartTypedOutput.TypedOutputBody;
 import static retrofit.http.RestMethodInfo.NO_SINGLE_ENTITY;
 
 public class RequestBuilderTest {
@@ -76,7 +75,7 @@
     assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/pong/?kit=kat&riff=raff");
     assertThat(request.getBody()).isNull();
   }
-  
+
   @Test public void getWithPathAndQueryQuestionMarkParam() throws Exception {
     Request request = new Helper() //
         .setMethod("GET") //
@@ -90,7 +89,7 @@
     assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/pong%3F/?kit=kat%3F");
     assertThat(request.getBody()).isNull();
   }
-  
+
   @Test public void getWithPathAndQueryAmpersandParam() throws Exception {
     Request request = new Helper() //
         .setMethod("GET") //
@@ -104,7 +103,7 @@
     assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/pong%26/?kit=kat%26");
     assertThat(request.getBody()).isNull();
   }
-  
+
   @Test public void getWithPathAndQueryHashParam() throws Exception {
     Request request = new Helper() //
         .setMethod("GET") //
@@ -222,18 +221,18 @@
     assertThat(request.getHeaders()).isEmpty();
     assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
 
-    HttpMultipart body = TestingUtils.extractEntity(request.getBody());
-    assertThat(body.getBodyParts()).hasSize(2);
+    MultipartTypedOutput body = (MultipartTypedOutput) request.getBody();
+    assertThat(body.parts).hasSize(2);
+
+    Iterator<Map.Entry<String, TypedOutput>> iterator = body.parts.entrySet().iterator();
 
-    FormBodyPart part1 = (FormBodyPart) body.getBodyParts().get(0);
-    assertThat(part1.getName()).isEqualTo("ping");
-    TypedOutputBody body1 = (TypedOutputBody) part1.getBody();
-    assertTypedBytes(body1.typedBytes, "pong");
+    Map.Entry<String, TypedOutput> one = iterator.next();
+    assertThat(one.getKey()).isEqualTo("ping");
+    assertTypedBytes(one.getValue(), "pong");
 
-    FormBodyPart part2 = (FormBodyPart) body.getBodyParts().get(1);
-    assertThat(part2.getName()).isEqualTo("kit");
-    TypedOutputBody body2 = (TypedOutputBody) part2.getBody();
-    assertTypedBytes(body2.typedBytes, "kat");
+    Map.Entry<String, TypedOutput> two = iterator.next();
+    assertThat(two.getKey()).isEqualTo("kit");
+    assertTypedBytes(two.getValue(), "kat");
   }
 
   @Test public void simpleHeaders() throws Exception {
@@ -325,7 +324,8 @@ Helper addSingleEntityParam(Object value) {
       if (singleEntityArgumentIndex != NO_SINGLE_ENTITY) {
         throw new IllegalStateException("Single entity param already added.");
       }
-      singleEntityArgumentIndex = namedParams.size(); // Relying on the fact that this is already less one.
+      // Relying on the fact that this is already less one.
+      singleEntityArgumentIndex = namedParams.size();
       namedParams.add(null);
       args.add(value);
       return this;
@@ -377,7 +377,7 @@ Request build() throws NoSuchMethodException, URISyntaxException {
       methodInfo.isMultipart = isMultipart;
       methodInfo.loaded = true;
 
-      return new RequestBuilder(GSON)
+      return new RequestBuilder(GSON) //
           .setApiUrl(url)
           .setHeaders(headers)
           .setArgs(args.toArray(new Object[args.size()]))
diff --git a/retrofit/src/test/java/retrofit/http/TestingUtils.java b/retrofit/src/test/java/retrofit/http/TestingUtils.java
index d7e3e02ce..91940816b 100644
--- a/retrofit/src/test/java/retrofit/http/TestingUtils.java
+++ b/retrofit/src/test/java/retrofit/http/TestingUtils.java
@@ -1,11 +1,8 @@
 // Copyright 2013 Square, Inc.
 package retrofit.http;
 
-import java.lang.reflect.Field;
 import java.lang.reflect.Method;
 import java.util.Map;
-import org.apache.http.entity.mime.HttpMultipart;
-import org.apache.http.entity.mime.MultipartEntity;
 import retrofit.http.mime.TypedOutput;
 
 import static org.fest.assertions.api.Assertions.assertThat;
@@ -28,17 +25,6 @@ public static TypedOutput createMultipart(Map<String, TypedOutput> parts) {
     return typedOutput;
   }
 
-  public static HttpMultipart extractEntity(TypedOutput output)
-      throws NoSuchFieldException, IllegalAccessException {
-    if (!(output instanceof MultipartTypedOutput)) {
-      throw new IllegalArgumentException("TypedOutput was not a MultipartTypedOutput.");
-    }
-    MultipartEntity entity = ((MultipartTypedOutput) output).cheat;
-    Field httpMultipartField = MultipartEntity.class.getDeclaredField("multipart");
-    httpMultipartField.setAccessible(true);
-    return (HttpMultipart) httpMultipartField.get(entity);
-  }
-
   public static void assertMultipart(TypedOutput typedOutput) {
     assertThat(typedOutput).isInstanceOf(MultipartTypedOutput.class);
   }
diff --git a/retrofit/src/test/java/retrofit/http/client/UrlConnectionClientTest.java b/retrofit/src/test/java/retrofit/http/client/UrlConnectionClientTest.java
index 11f76b060..3b9df8cb7 100644
--- a/retrofit/src/test/java/retrofit/http/client/UrlConnectionClientTest.java
+++ b/retrofit/src/test/java/retrofit/http/client/UrlConnectionClientTest.java
@@ -66,9 +66,8 @@
 
     assertThat(connection.getRequestMethod()).isEqualTo("POST");
     assertThat(connection.getURL().toString()).isEqualTo(HOST + "/that/");
-    assertThat(connection.getRequestProperties()).hasSize(2);
+    assertThat(connection.getRequestProperties()).hasSize(1);
     assertThat(connection.getRequestProperty("Content-Type")).startsWith("multipart/form-data;");
-    assertThat(connection.getRequestProperty("Content-Length")).isNotNull();
     assertThat(connection.getOutputStream().toByteArray().length).isGreaterThan(0);
   }
 
