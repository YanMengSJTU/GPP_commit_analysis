diff --git a/retrofit-adapters/java8/README.md b/retrofit-adapters/java8/README.md
index 31f98f7fd..4ed30ae2f 100644
--- a/retrofit-adapters/java8/README.md
+++ b/retrofit-adapters/java8/README.md
@@ -4,6 +4,10 @@ Java8 Adapter
 An `Adapter` for adapting [Java8][1] `CompletableFuture`.
 
 
+Deprecated â€“ Included by default in Retrofit
+---------------------------------------
+
+
 Usage
 -----
 
diff --git a/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/Java8CallAdapterFactory.java b/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/Java8CallAdapterFactory.java
index 35b79f1a3..2d7773d6a 100644
--- a/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/Java8CallAdapterFactory.java
+++ b/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/Java8CallAdapterFactory.java
@@ -27,6 +27,9 @@
 import retrofit2.Retrofit;
 
 /**
+ * @deprecated Retrofit includes support for CompletableFuture. This no longer needs to be added to
+ * the Retrofit instance explicitly.
+ *
  * A {@linkplain CallAdapter.Factory call adapter} which creates Java 8 futures.
  * <p>
  * Adding this class to {@link Retrofit} allows you to return {@link CompletableFuture} from
@@ -47,6 +50,7 @@
  * errors</li>
  * </ul>
  */
+@Deprecated
 public final class Java8CallAdapterFactory extends CallAdapter.Factory {
   public static Java8CallAdapterFactory create() {
     return new Java8CallAdapterFactory();
diff --git a/retrofit-mock/src/main/java/retrofit2/mock/Calls.java b/retrofit-mock/src/main/java/retrofit2/mock/Calls.java
index f0e9affbe..74a78e863 100644
--- a/retrofit-mock/src/main/java/retrofit2/mock/Calls.java
+++ b/retrofit-mock/src/main/java/retrofit2/mock/Calls.java
@@ -132,7 +132,9 @@ private Calls() {
       if (response != null) {
         return response.raw().request();
       }
-      return new Request.Builder().url("http://localhost").build();
+      return new Request.Builder()
+          .url("http://localhost")
+          .build();
     }
   }
 
diff --git a/retrofit-mock/src/test/java/retrofit2/mock/CallsTest.java b/retrofit-mock/src/test/java/retrofit2/mock/CallsTest.java
index bf67cad9a..8b044175a 100644
--- a/retrofit-mock/src/test/java/retrofit2/mock/CallsTest.java
+++ b/retrofit-mock/src/test/java/retrofit2/mock/CallsTest.java
@@ -15,7 +15,6 @@
  */
 package retrofit2.mock;
 
-import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.security.cert.CertificateException;
 import java.util.concurrent.Callable;
@@ -24,7 +23,6 @@
 import retrofit2.Call;
 import retrofit2.Callback;
 import retrofit2.Response;
-import retrofit2.Retrofit;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.assertEquals;
diff --git a/retrofit/src/main/java/retrofit2/CompletableFutureCallAdapterFactory.java b/retrofit/src/main/java/retrofit2/CompletableFutureCallAdapterFactory.java
new file mode 100644
index 000000000..69ec32b35
--- /dev/null
+++ b/retrofit/src/main/java/retrofit2/CompletableFutureCallAdapterFactory.java
@@ -0,0 +1,151 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.util.concurrent.CompletableFuture;
+import org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement;
+
+/**
+ * A {@linkplain CallAdapter.Factory call adapter} which creates Java 8 futures.
+ * <p>
+ * Adding this class to {@link Retrofit} allows you to return {@link CompletableFuture} from
+ * service methods.
+ * <pre><code>
+ * interface MyService {
+ *   &#64;GET("user/me")
+ *   CompletableFuture&lt;User&gt; getUser()
+ * }
+ * </code></pre>
+ * There are two configurations supported for the {@code CompletableFuture} type parameter:
+ * <ul>
+ * <li>Direct body (e.g., {@code CompletableFuture<User>}) returns the deserialized body for 2XX
+ * responses, sets {@link retrofit2.HttpException HttpException} errors for non-2XX responses, and
+ * sets {@link IOException} for network errors.</li>
+ * <li>Response wrapped body (e.g., {@code CompletableFuture<Response<User>>}) returns a
+ * {@link Response} object for all HTTP responses and sets {@link IOException} for network
+ * errors</li>
+ * </ul>
+ */
+@IgnoreJRERequirement
+final class CompletableFutureCallAdapterFactory extends CallAdapter.Factory {
+  static final CallAdapter.Factory INSTANCE = new CompletableFutureCallAdapterFactory();
+
+  @Override
+  public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+    if (getRawType(returnType) != CompletableFuture.class) {
+      return null;
+    }
+    if (!(returnType instanceof ParameterizedType)) {
+      throw new IllegalStateException("CompletableFuture return type must be parameterized"
+          + " as CompletableFuture<Foo> or CompletableFuture<? extends Foo>");
+    }
+    Type innerType = getParameterUpperBound(0, (ParameterizedType) returnType);
+
+    if (getRawType(innerType) != Response.class) {
+      // Generic type is not Response<T>. Use it for body-only adapter.
+      return new BodyCallAdapter<>(innerType);
+    }
+
+    // Generic type is Response<T>. Extract T and create the Response version of the adapter.
+    if (!(innerType instanceof ParameterizedType)) {
+      throw new IllegalStateException("Response must be parameterized"
+          + " as Response<Foo> or Response<? extends Foo>");
+    }
+    Type responseType = getParameterUpperBound(0, (ParameterizedType) innerType);
+    return new ResponseCallAdapter<>(responseType);
+  }
+
+  @IgnoreJRERequirement
+  private static final class BodyCallAdapter<R> implements CallAdapter<R, CompletableFuture<R>> {
+    private final Type responseType;
+
+    BodyCallAdapter(Type responseType) {
+      this.responseType = responseType;
+    }
+
+    @Override public Type responseType() {
+      return responseType;
+    }
+
+    @Override public CompletableFuture<R> adapt(final Call<R> call) {
+      final CompletableFuture<R> future = new CompletableFuture<R>() {
+        @Override public boolean cancel(boolean mayInterruptIfRunning) {
+          if (mayInterruptIfRunning) {
+            call.cancel();
+          }
+          return super.cancel(mayInterruptIfRunning);
+        }
+      };
+
+      call.enqueue(new Callback<R>() {
+        @Override public void onResponse(Call<R> call, Response<R> response) {
+          if (response.isSuccessful()) {
+            future.complete(response.body());
+          } else {
+            future.completeExceptionally(new HttpException(response));
+          }
+        }
+
+        @Override public void onFailure(Call<R> call, Throwable t) {
+          future.completeExceptionally(t);
+        }
+      });
+
+      return future;
+    }
+  }
+
+  @IgnoreJRERequirement
+  private static final class ResponseCallAdapter<R>
+      implements CallAdapter<R, CompletableFuture<Response<R>>> {
+    private final Type responseType;
+
+    ResponseCallAdapter(Type responseType) {
+      this.responseType = responseType;
+    }
+
+    @Override public Type responseType() {
+      return responseType;
+    }
+
+    @Override public CompletableFuture<Response<R>> adapt(final Call<R> call) {
+      final CompletableFuture<Response<R>> future = new CompletableFuture<Response<R>>() {
+        @Override public boolean cancel(boolean mayInterruptIfRunning) {
+          if (mayInterruptIfRunning) {
+            call.cancel();
+          }
+          return super.cancel(mayInterruptIfRunning);
+        }
+      };
+
+      call.enqueue(new Callback<R>() {
+        @Override public void onResponse(Call<R> call, Response<R> response) {
+          future.complete(response);
+        }
+
+        @Override public void onFailure(Call<R> call, Throwable t) {
+          future.completeExceptionally(t);
+        }
+      });
+
+      return future;
+    }
+  }
+}
diff --git a/retrofit/src/main/java/retrofit2/Invocation.java b/retrofit/src/main/java/retrofit2/Invocation.java
new file mode 100644
index 000000000..6f1ca5fb4
--- /dev/null
+++ b/retrofit/src/main/java/retrofit2/Invocation.java
@@ -0,0 +1,80 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import java.lang.reflect.Method;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+import static retrofit2.Utils.checkNotNull;
+
+/**
+ * A single invocation of a Retrofit service interface method. This class captures both the method
+ * that was called and the arguments to the method.
+ *
+ * <p>Retrofit automatically adds an invocation to each OkHttp request as a tag. You can retrieve
+ * the invocation in an OkHttp interceptor for metrics and monitoring.
+ *
+ * <pre><code>
+ * class InvocationLogger implements Interceptor {
+ *   &#64;Override public Response intercept(Chain chain) throws IOException {
+ *     Request request = chain.request();
+ *     Invocation invocation = request.tag(Invocation.class);
+ *     if (invocation != null) {
+ *       System.out.printf("%s.%s %s%n",
+ *           invocation.method().getDeclaringClass().getSimpleName(),
+ *           invocation.method().getName(), invocation.arguments());
+ *     }
+ *     return chain.proceed(request);
+ *   }
+ * }
+ * </code></pre>
+ *
+ * <strong>Note:</strong> use caution when examining an invocation's arguments. Although the
+ * arguments list is unmodifiable, the arguments themselves may be mutable. They may also be unsafe
+ * for concurrent access. For best results declare Retrofit service interfaces using only immutable
+ * types for parameters!
+ */
+public final class Invocation {
+  public static Invocation of(Method method, List<?> arguments) {
+    checkNotNull(method, "method == null");
+    checkNotNull(arguments, "arguments == null");
+    return new Invocation(method, new ArrayList<>(arguments)); // Defensive copy.
+  }
+
+  private final Method method;
+  private final List<?> arguments;
+
+  /** Trusted constructor assumes ownership of {@code arguments}. */
+  Invocation(Method method, List<?> arguments) {
+    this.method = method;
+    this.arguments = Collections.unmodifiableList(arguments);
+  }
+
+  public Method method() {
+    return method;
+  }
+
+  public List<?> arguments() {
+    return arguments;
+  }
+
+  @Override public String toString() {
+    return String.format("%s.%s() %s",
+        method.getDeclaringClass().getName(), method.getName(), arguments);
+  }
+}
diff --git a/retrofit/src/main/java/retrofit2/Platform.java b/retrofit/src/main/java/retrofit2/Platform.java
index 092c95f8f..3261b4562 100644
--- a/retrofit/src/main/java/retrofit2/Platform.java
+++ b/retrofit/src/main/java/retrofit2/Platform.java
@@ -21,10 +21,15 @@
 import java.lang.invoke.MethodHandles.Lookup;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Method;
+import java.util.ArrayList;
+import java.util.List;
 import java.util.concurrent.Executor;
 import javax.annotation.Nullable;
 import org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement;
 
+import static java.util.Collections.singletonList;
+import static java.util.Collections.unmodifiableList;
+
 class Platform {
   private static final Platform PLATFORM = findPlatform();
 
@@ -52,11 +57,16 @@ private static Platform findPlatform() {
     return null;
   }
 
-  CallAdapter.Factory defaultCallAdapterFactory(@Nullable Executor callbackExecutor) {
+  List<? extends CallAdapter.Factory> defaultCallAdapterFactories(
+      @Nullable Executor callbackExecutor) {
     if (callbackExecutor != null) {
-      return new ExecutorCallAdapterFactory(callbackExecutor);
+      return singletonList(new ExecutorCallAdapterFactory(callbackExecutor));
     }
-    return DefaultCallAdapterFactory.INSTANCE;
+    return singletonList(DefaultCallAdapterFactory.INSTANCE);
+  }
+
+  int defaultCallAdapterFactoriesSize() {
+    return 1;
   }
 
   boolean isDefaultMethod(Method method) {
@@ -85,6 +95,22 @@ boolean isDefaultMethod(Method method) {
           .bindTo(object)
           .invokeWithArguments(args);
     }
+
+    @Override List<? extends CallAdapter.Factory> defaultCallAdapterFactories(
+        @Nullable Executor callbackExecutor) {
+      List<CallAdapter.Factory> factories = new ArrayList<>(2);
+      factories.add(CompletableFutureCallAdapterFactory.INSTANCE);
+      if (callbackExecutor != null) {
+        factories.add(new ExecutorCallAdapterFactory(callbackExecutor));
+      } else {
+        factories.add(DefaultCallAdapterFactory.INSTANCE);
+      }
+      return unmodifiableList(factories);
+    }
+
+    @Override int defaultCallAdapterFactoriesSize() {
+      return 2;
+    }
   }
 
   static class Android extends Platform {
@@ -100,9 +126,10 @@ boolean isDefaultMethod(Method method) {
       return new MainThreadExecutor();
     }
 
-    @Override CallAdapter.Factory defaultCallAdapterFactory(@Nullable Executor callbackExecutor) {
+    @Override List<? extends CallAdapter.Factory> defaultCallAdapterFactories(
+        @Nullable Executor callbackExecutor) {
       if (callbackExecutor == null) throw new AssertionError();
-      return new ExecutorCallAdapterFactory(callbackExecutor);
+      return singletonList(new ExecutorCallAdapterFactory(callbackExecutor));
     }
 
     static class MainThreadExecutor implements Executor {
diff --git a/retrofit/src/main/java/retrofit2/RequestBuilder.java b/retrofit/src/main/java/retrofit2/RequestBuilder.java
index 436240cc4..98dd66690 100644
--- a/retrofit/src/main/java/retrofit2/RequestBuilder.java
+++ b/retrofit/src/main/java/retrofit2/RequestBuilder.java
@@ -46,9 +46,9 @@
   private @Nullable FormBody.Builder formBuilder;
   private @Nullable RequestBody body;
 
-  RequestBuilder(String method, HttpUrl baseUrl, @Nullable String relativeUrl,
-      @Nullable Headers headers, @Nullable MediaType contentType, boolean hasBody,
-      boolean isFormEncoded, boolean isMultipart) {
+  RequestBuilder(String method, HttpUrl baseUrl,
+      @Nullable String relativeUrl, @Nullable Headers headers, @Nullable MediaType contentType,
+      boolean hasBody, boolean isFormEncoded, boolean isMultipart) {
     this.method = method;
     this.baseUrl = baseUrl;
     this.relativeUrl = relativeUrl;
@@ -186,7 +186,7 @@ void setBody(RequestBody body) {
     this.body = body;
   }
 
-  Request build() {
+  Request.Builder get() {
     HttpUrl url;
     HttpUrl.Builder urlBuilder = this.urlBuilder;
     if (urlBuilder != null) {
@@ -225,8 +225,7 @@ Request build() {
 
     return requestBuilder
         .url(url)
-        .method(method, body)
-        .build();
+        .method(method, body);
   }
 
   private static class ContentTypeOverridingRequestBody extends RequestBody {
diff --git a/retrofit/src/main/java/retrofit2/RequestFactory.java b/retrofit/src/main/java/retrofit2/RequestFactory.java
index 2461b34c1..ee1ab0265 100644
--- a/retrofit/src/main/java/retrofit2/RequestFactory.java
+++ b/retrofit/src/main/java/retrofit2/RequestFactory.java
@@ -21,7 +21,9 @@
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import java.net.URI;
+import java.util.ArrayList;
 import java.util.LinkedHashSet;
+import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import java.util.regex.Matcher;
@@ -63,6 +65,7 @@ static RequestFactory parseAnnotations(Retrofit retrofit, Method method) {
     return new Builder(retrofit, method).build();
   }
 
+  private final Method method;
   private final HttpUrl baseUrl;
   final String httpMethod;
   private final String relativeUrl;
@@ -74,6 +77,7 @@ static RequestFactory parseAnnotations(Retrofit retrofit, Method method) {
   private final ParameterHandler<?>[] parameterHandlers;
 
   RequestFactory(Builder builder) {
+    method = builder.method;
     baseUrl = builder.retrofit.baseUrl;
     httpMethod = builder.httpMethod;
     relativeUrl = builder.relativeUrl;
@@ -86,9 +90,6 @@ static RequestFactory parseAnnotations(Retrofit retrofit, Method method) {
   }
 
   okhttp3.Request create(Object[] args) throws IOException {
-    RequestBuilder requestBuilder = new RequestBuilder(httpMethod, baseUrl, relativeUrl, headers,
-        contentType, hasBody, isFormEncoded, isMultipart);
-
     @SuppressWarnings("unchecked") // It is an error to invoke a method with the wrong arg types.
     ParameterHandler<Object>[] handlers = (ParameterHandler<Object>[]) parameterHandlers;
 
@@ -98,11 +99,18 @@ static RequestFactory parseAnnotations(Retrofit retrofit, Method method) {
           + ") doesn't match expected count (" + handlers.length + ")");
     }
 
+    RequestBuilder requestBuilder = new RequestBuilder(httpMethod, baseUrl, relativeUrl,
+        headers, contentType, hasBody, isFormEncoded, isMultipart);
+
+    List<Object> argumentList = new ArrayList<>(argumentCount);
     for (int p = 0; p < argumentCount; p++) {
+      argumentList.add(args[p]);
       handlers[p].apply(requestBuilder, args[p]);
     }
 
-    return requestBuilder.build();
+    return requestBuilder.get()
+        .tag(Invocation.class, new Invocation(method, argumentList))
+        .build();
   }
 
   /**
diff --git a/retrofit/src/main/java/retrofit2/Retrofit.java b/retrofit/src/main/java/retrofit2/Retrofit.java
index e94d3d181..c65351b92 100644
--- a/retrofit/src/main/java/retrofit2/Retrofit.java
+++ b/retrofit/src/main/java/retrofit2/Retrofit.java
@@ -415,9 +415,12 @@ public Builder() {
       // Remove the default BuiltInConverters instance added by build().
       converterFactories.remove(0);
 
-      callAdapterFactories.addAll(retrofit.callAdapterFactories);
-      // Remove the default, platform-aware call adapter added by build().
-      callAdapterFactories.remove(callAdapterFactories.size() - 1);
+      // Do not add the default, platform-aware call adapters added by build().
+      for (int i = 0,
+          size = retrofit.callAdapterFactories.size() - platform.defaultCallAdapterFactoriesSize();
+          i < size; i++) {
+        callAdapterFactories.add(retrofit.callAdapterFactories.get(i));
+      }
 
       callbackExecutor = retrofit.callbackExecutor;
       validateEagerly = retrofit.validateEagerly;
@@ -581,7 +584,7 @@ public Retrofit build() {
 
       // Make a defensive copy of the adapters and add the default Call adapter.
       List<CallAdapter.Factory> callAdapterFactories = new ArrayList<>(this.callAdapterFactories);
-      callAdapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));
+      callAdapterFactories.addAll(platform.defaultCallAdapterFactories(callbackExecutor));
 
       // Make a defensive copy of the converters.
       List<Converter.Factory> converterFactories =
diff --git a/retrofit/src/test/java/retrofit2/CompletableFutureCallAdapterFactoryTest.java b/retrofit/src/test/java/retrofit2/CompletableFutureCallAdapterFactoryTest.java
new file mode 100644
index 000000000..feaacc929
--- /dev/null
+++ b/retrofit/src/test/java/retrofit2/CompletableFutureCallAdapterFactoryTest.java
@@ -0,0 +1,97 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import com.google.common.reflect.TypeToken;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import java.util.List;
+import java.util.concurrent.CompletableFuture;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.helpers.ToStringConverterFactory;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class CompletableFutureCallAdapterFactoryTest {
+  private static final Annotation[] NO_ANNOTATIONS = new Annotation[0];
+
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private final CallAdapter.Factory factory = CompletableFutureCallAdapterFactory.INSTANCE;
+  private Retrofit retrofit;
+
+  @Before public void setUp() {
+    retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+  }
+
+  @Test public void responseType() {
+    Type bodyClass = new TypeToken<CompletableFuture<String>>() {}.getType();
+    assertThat(factory.get(bodyClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type bodyWildcard = new TypeToken<CompletableFuture<? extends String>>() {}.getType();
+    assertThat(factory.get(bodyWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type bodyGeneric = new TypeToken<CompletableFuture<List<String>>>() {}.getType();
+    assertThat(factory.get(bodyGeneric, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(new TypeToken<List<String>>() {}.getType());
+    Type responseClass = new TypeToken<CompletableFuture<Response<String>>>() {}.getType();
+    assertThat(factory.get(responseClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type responseWildcard = new TypeToken<CompletableFuture<Response<? extends String>>>() {}.getType();
+    assertThat(factory.get(responseWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type resultClass = new TypeToken<CompletableFuture<Response<String>>>() {}.getType();
+    assertThat(factory.get(resultClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type resultWildcard = new TypeToken<CompletableFuture<Response<? extends String>>>() {}.getType();
+    assertThat(factory.get(resultWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+  }
+
+  @Test public void nonListenableFutureReturnsNull() {
+    CallAdapter<?, ?> adapter = factory.get(String.class, NO_ANNOTATIONS, retrofit);
+    assertThat(adapter).isNull();
+  }
+
+  @Test public void rawTypeThrows() {
+    Type observableType = new TypeToken<CompletableFuture>() {}.getType();
+    try {
+      factory.get(observableType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "CompletableFuture return type must be parameterized as CompletableFuture<Foo> or CompletableFuture<? extends Foo>");
+    }
+  }
+
+  @Test public void rawResponseTypeThrows() {
+    Type observableType = new TypeToken<CompletableFuture<Response>>() {}.getType();
+    try {
+      factory.get(observableType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Response must be parameterized as Response<Foo> or Response<? extends Foo>");
+    }
+  }
+}
diff --git a/retrofit/src/test/java/retrofit2/CompletableFutureTest.java b/retrofit/src/test/java/retrofit2/CompletableFutureTest.java
new file mode 100644
index 000000000..bf44dfd55
--- /dev/null
+++ b/retrofit/src/test/java/retrofit2/CompletableFutureTest.java
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import java.io.IOException;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ExecutionException;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.helpers.ToStringConverterFactory;
+import retrofit2.http.GET;
+
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class CompletableFutureTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  interface Service {
+    @GET("/") CompletableFuture<String> body();
+    @GET("/") CompletableFuture<Response<String>> response();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodySuccess200() throws Exception {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    CompletableFuture<String> future = service.body();
+    assertThat(future.get()).isEqualTo("Hi");
+  }
+
+  @Test public void bodySuccess404() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    CompletableFuture<String> future = service.body();
+    try {
+      future.get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause())
+          .isInstanceOf(HttpException.class) // Required for backwards compatibility.
+          .isInstanceOf(HttpException.class)
+          .hasMessage("HTTP 404 Client Error");
+    }
+  }
+
+  @Test public void bodyFailure() throws Exception {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    CompletableFuture<String> future = service.body();
+    try {
+      future.get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).isInstanceOf(IOException.class);
+    }
+  }
+
+  @Test public void responseSuccess200() throws Exception {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    CompletableFuture<Response<String>> future = service.response();
+    Response<String> response = future.get();
+    assertThat(response.isSuccessful()).isTrue();
+    assertThat(response.body()).isEqualTo("Hi");
+  }
+
+  @Test public void responseSuccess404() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
+
+    CompletableFuture<Response<String>> future = service.response();
+    Response<String> response = future.get();
+    assertThat(response.isSuccessful()).isFalse();
+    assertThat(response.errorBody().string()).isEqualTo("Hi");
+  }
+
+  @Test public void responseFailure() throws Exception {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    CompletableFuture<Response<String>> future = service.response();
+    try {
+      future.get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).isInstanceOf(IOException.class);
+    }
+  }
+}
diff --git a/retrofit/src/test/java/retrofit2/InvocationTest.java b/retrofit/src/test/java/retrofit2/InvocationTest.java
new file mode 100644
index 000000000..0dda742ba
--- /dev/null
+++ b/retrofit/src/test/java/retrofit2/InvocationTest.java
@@ -0,0 +1,88 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import java.lang.reflect.Method;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import okhttp3.MediaType;
+import okhttp3.OkHttpClient;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import org.junit.Test;
+import retrofit2.http.Body;
+import retrofit2.http.POST;
+import retrofit2.http.Path;
+import retrofit2.http.Query;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class InvocationTest {
+  interface Example {
+    @POST("/{p1}") //
+    Call<ResponseBody> postMethod(
+        @Path("p1") String p1, @Query("p2") String p2, @Body RequestBody body);
+  }
+
+  @Test public void invocationObjectOnCallAndRequestTag() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .callFactory(new OkHttpClient())
+        .build();
+
+    Example example = retrofit.create(Example.class);
+    RequestBody requestBody = RequestBody.create(MediaType.get("text/plain"), "three");
+    Call<ResponseBody> call = example.postMethod("one", "two", requestBody);
+
+    Invocation invocation = call.request().tag(Invocation.class);
+    Method method = invocation.method();
+    assertThat(method.getName()).isEqualTo("postMethod");
+    assertThat(method.getDeclaringClass()).isEqualTo(Example.class);
+    assertThat(invocation.arguments()).isEqualTo(Arrays.asList("one", "two", requestBody));
+  }
+
+  @Test public void nullMethod() {
+    try {
+      Invocation.of(null, Arrays.asList("one", "two"));
+      fail();
+    } catch (NullPointerException expected) {
+      assertThat(expected).hasMessage("method == null");
+    }
+  }
+
+  @Test public void nullArguments() {
+    try {
+      Invocation.of(Example.class.getDeclaredMethods()[0], null);
+      fail();
+    } catch (NullPointerException expected) {
+      assertThat(expected).hasMessage("arguments == null");
+    }
+  }
+
+  @Test public void argumentsAreImmutable() {
+    List<String> mutableList = new ArrayList<>(Arrays.asList("one", "two"));
+    Invocation invocation = Invocation.of(Example.class.getDeclaredMethods()[0], mutableList);
+    mutableList.add("three");
+    assertThat(invocation.arguments()).isEqualTo(Arrays.asList("one", "two"));
+    try {
+      invocation.arguments().clear();
+      fail();
+    } catch (UnsupportedOperationException expected) {
+    }
+  }
+}
diff --git a/retrofit/src/test/java/retrofit2/RetrofitTest.java b/retrofit/src/test/java/retrofit2/RetrofitTest.java
index 05e4cf928..339678aff 100644
--- a/retrofit/src/test/java/retrofit2/RetrofitTest.java
+++ b/retrofit/src/test/java/retrofit2/RetrofitTest.java
@@ -364,6 +364,7 @@
       assertThat(e.getCause()).hasMessage(""
           + "Could not locate call adapter for java.util.concurrent.Future<java.lang.String>.\n"
           + "  Tried:\n"
+          + "   * retrofit2.CompletableFutureCallAdapterFactory\n"
           + "   * retrofit2.DefaultCallAdapterFactory");
     }
   }
@@ -1183,6 +1184,7 @@
           + "Could not locate call adapter for class java.lang.String.\n"
           + "  Tried:\n"
           + "   * retrofit2.helpers.NonMatchingCallAdapterFactory\n"
+          + "   * retrofit2.CompletableFutureCallAdapterFactory\n"
           + "   * retrofit2.DefaultCallAdapterFactory");
     }
 
@@ -1215,6 +1217,7 @@
           + "   * retrofit2.helpers.DelegatingCallAdapterFactory\n"
           + "  Tried:\n"
           + "   * retrofit2.helpers.NonMatchingCallAdapterFactory\n"
+          + "   * retrofit2.CompletableFutureCallAdapterFactory\n"
           + "   * retrofit2.DefaultCallAdapterFactory");
     }
 
diff --git a/samples/src/main/java/com/example/retrofit/InvocationMetrics.java b/samples/src/main/java/com/example/retrofit/InvocationMetrics.java
new file mode 100644
index 000000000..49ac30481
--- /dev/null
+++ b/samples/src/main/java/com/example/retrofit/InvocationMetrics.java
@@ -0,0 +1,89 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.retrofit;
+
+import java.io.IOException;
+import okhttp3.Interceptor;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+import retrofit2.Call;
+import retrofit2.Invocation;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+import retrofit2.http.Url;
+
+/**
+ * This example prints HTTP call metrics with the initiating method names and arguments.
+ */
+public final class InvocationMetrics {
+  public interface Browse {
+    @GET("/robots.txt")
+    Call<ResponseBody> robots();
+
+    @GET("/favicon.ico")
+    Call<ResponseBody> favicon();
+
+    @GET("/")
+    Call<ResponseBody> home();
+
+    @GET
+    Call<ResponseBody> page(@Url String path);
+  }
+
+  static final class InvocationLogger implements Interceptor {
+    @Override public Response intercept(Chain chain) throws IOException {
+      Request request = chain.request();
+      long startNanos = System.nanoTime();
+      Response response = chain.proceed(request);
+      long elapsedNanos = System.nanoTime() - startNanos;
+
+      Invocation invocation = request.tag(Invocation.class);
+      if (invocation != null) {
+        System.out.printf("%s.%s %s HTTP %s (%.0f ms)%n",
+            invocation.method().getDeclaringClass().getSimpleName(),
+            invocation.method().getName(),
+            invocation.arguments(),
+            response.code(),
+            elapsedNanos / 1_000_000.0);
+      }
+
+      return response;
+    }
+  }
+
+  public static void main(String... args) throws IOException {
+    InvocationLogger invocationLogger = new InvocationLogger();
+
+    OkHttpClient okHttpClient = new OkHttpClient.Builder()
+        .addInterceptor(invocationLogger)
+        .build();
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("https://square.com/")
+        .callFactory(okHttpClient)
+        .build();
+
+    Browse browse = retrofit.create(Browse.class);
+
+    browse.robots().execute();
+    browse.favicon().execute();
+    browse.home().execute();
+    browse.page("sitemap.xml").execute();
+    browse.page("notfound").execute();
+  }
+}
