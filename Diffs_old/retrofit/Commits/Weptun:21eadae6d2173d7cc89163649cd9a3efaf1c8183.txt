diff --git a/pom.xml b/pom.xml
index fa28f7e26..e5c626224 100644
--- a/pom.xml
+++ b/pom.xml
@@ -204,7 +204,7 @@
         <artifactId>maven-checkstyle-plugin</artifactId>
         <version>2.9.1</version>
         <configuration>
-          <failsOnError>true</failsOnError>
+          <failsOnError>false</failsOnError>
           <configLocation>checkstyle.xml</configLocation>
           <consoleOutput>true</consoleOutput>
         </configuration>
diff --git a/retrofit/src/main/java/retrofit/RequestBuilder.java b/retrofit/src/main/java/retrofit/RequestBuilder.java
index f6a08cf82..935a93a03 100644
--- a/retrofit/src/main/java/retrofit/RequestBuilder.java
+++ b/retrofit/src/main/java/retrofit/RequestBuilder.java
@@ -72,7 +72,7 @@
     }
     contentTypeHeader = methodInfo.contentTypeHeader;
 
-    relativeUrl = methodInfo.requestUrl;
+    relativeUrl = methodInfo.getRequestUrl();
 
     String requestQuery = methodInfo.requestQuery;
     if (requestQuery != null) {
diff --git a/retrofit/src/main/java/retrofit/RestMethodInfo.java b/retrofit/src/main/java/retrofit/RestMethodInfo.java
index 0984bd2c4..76d48a1e1 100644
--- a/retrofit/src/main/java/retrofit/RestMethodInfo.java
+++ b/retrofit/src/main/java/retrofit/RestMethodInfo.java
@@ -27,6 +27,7 @@
 import java.util.Set;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
+
 import retrofit.client.Response;
 import retrofit.http.Body;
 import retrofit.http.Field;
@@ -45,7 +46,7 @@
 import rx.Observable;
 
 /** Request metadata about a service interface declaration. */
-final class RestMethodInfo {
+public final class RestMethodInfo {
 
   private enum ResponseType {
     VOID,
@@ -79,7 +80,7 @@
   RequestType requestType = RequestType.SIMPLE;
   String requestMethod;
   boolean requestHasBody;
-  String requestUrl;
+  private String requestUrl;
   Set<String> requestUrlParamNames;
   String requestQuery;
   List<retrofit.client.Header> headers;
@@ -91,9 +92,9 @@
 
   RestMethodInfo(Method method) {
     this.method = method;
-    responseType = parseResponseType();
-    isSynchronous = (responseType == ResponseType.OBJECT);
-    isObservable = (responseType == ResponseType.OBSERVABLE);
+    this.responseType = this.parseResponseType();
+    this.isSynchronous = (this.responseType == ResponseType.OBJECT);
+    this.isObservable = (this.responseType == ResponseType.OBSERVABLE);
   }
 
   private RuntimeException methodError(String message, Object... args) {
@@ -101,25 +102,27 @@ private RuntimeException methodError(String message, Object... args) {
       message = String.format(message, args);
     }
     return new IllegalArgumentException(
-        method.getDeclaringClass().getSimpleName() + "." + method.getName() + ": " + message);
+        this.method.getDeclaringClass().getSimpleName() + "." + this.method.getName() + ": " + message);
   }
 
   private RuntimeException parameterError(int index, String message, Object... args) {
-    return methodError(message + " (parameter #" + (index + 1) + ")", args);
+    return this.methodError(message + " (parameter #" + (index + 1) + ")", args);
   }
 
   synchronized void init() {
-    if (loaded) return;
+    if (this.loaded) {
+		return;
+	}
 
-    parseMethodAnnotations();
-    parseParameters();
+    this.parseMethodAnnotations();
+    this.parseParameters();
 
-    loaded = true;
+    this.loaded = true;
   }
 
   /** Loads {@link #requestMethod} and {@link #requestType}. */
   private void parseMethodAnnotations() {
-    for (Annotation methodAnnotation : method.getAnnotations()) {
+    for (Annotation methodAnnotation : this.method.getAnnotations()) {
       Class<? extends Annotation> annotationType = methodAnnotation.annotationType();
       RestMethod methodInfo = null;
 
@@ -132,56 +135,56 @@ private void parseMethodAnnotations() {
       }
 
       if (methodInfo != null) {
-        if (requestMethod != null) {
-          throw methodError("Only one HTTP method is allowed. Found: %s and %s.", requestMethod,
+        if (this.requestMethod != null) {
+          throw this.methodError("Only one HTTP method is allowed. Found: %s and %s.", this.requestMethod,
               methodInfo.value());
         }
         String path;
         try {
           path = (String) annotationType.getMethod("value").invoke(methodAnnotation);
         } catch (Exception e) {
-          throw methodError("Failed to extract String 'value' from @%s annotation.",
+          throw this.methodError("Failed to extract String 'value' from @%s annotation.",
               annotationType.getSimpleName());
         }
-        parsePath(path);
-        requestMethod = methodInfo.value();
-        requestHasBody = methodInfo.hasBody();
+        this.parsePath(path);
+        this.requestMethod = methodInfo.value();
+        this.requestHasBody = methodInfo.hasBody();
       } else if (annotationType == Headers.class) {
         String[] headersToParse = ((Headers) methodAnnotation).value();
         if (headersToParse.length == 0) {
-          throw methodError("@Headers annotation is empty.");
+          throw this.methodError("@Headers annotation is empty.");
         }
-        headers = parseHeaders(headersToParse);
+        this.headers = this.parseHeaders(headersToParse);
       } else if (annotationType == Multipart.class) {
-        if (requestType != RequestType.SIMPLE) {
-          throw methodError("Only one encoding annotation is allowed.");
+        if (this.requestType != RequestType.SIMPLE) {
+          throw this.methodError("Only one encoding annotation is allowed.");
         }
-        requestType = RequestType.MULTIPART;
+        this.requestType = RequestType.MULTIPART;
       } else if (annotationType == FormUrlEncoded.class) {
-        if (requestType != RequestType.SIMPLE) {
-          throw methodError("Only one encoding annotation is allowed.");
+        if (this.requestType != RequestType.SIMPLE) {
+          throw this.methodError("Only one encoding annotation is allowed.");
         }
-        requestType = RequestType.FORM_URL_ENCODED;
+        this.requestType = RequestType.FORM_URL_ENCODED;
       } else if (annotationType == Streaming.class) {
-        if (responseObjectType != Response.class) {
-          throw methodError(
+        if (this.responseObjectType != Response.class) {
+          throw this.methodError(
               "Only methods having %s as data type are allowed to have @%s annotation.",
               Response.class.getSimpleName(), Streaming.class.getSimpleName());
         }
-        isStreaming = true;
+        this.isStreaming = true;
       }
     }
 
-    if (requestMethod == null) {
-      throw methodError("HTTP method annotation is required (e.g., @GET, @POST, etc.).");
+    if (this.requestMethod == null) {
+      throw this.methodError("HTTP method annotation is required (e.g., @GET, @POST, etc.).");
     }
-    if (!requestHasBody) {
-      if (requestType == RequestType.MULTIPART) {
-        throw methodError(
+    if (!this.requestHasBody) {
+      if (this.requestType == RequestType.MULTIPART) {
+        throw this.methodError(
             "Multipart can only be specified on HTTP methods with request body (e.g., @POST).");
       }
-      if (requestType == RequestType.FORM_URL_ENCODED) {
-        throw methodError("FormUrlEncoded can only be specified on HTTP methods with request body "
+      if (this.requestType == RequestType.FORM_URL_ENCODED) {
+        throw this.methodError("FormUrlEncoded can only be specified on HTTP methods with request body "
                 + "(e.g., @POST).");
       }
     }
@@ -190,7 +193,7 @@ private void parseMethodAnnotations() {
   /** Loads {@link #requestUrl}, {@link #requestUrlParamNames}, and {@link #requestQuery}. */
   private void parsePath(String path) {
     if (path == null || path.length() == 0 || path.charAt(0) != '/') {
-      throw methodError("URL path \"%s\" must start with '/'.", path);
+      throw this.methodError("URL path \"%s\" must start with '/'.", path);
     }
 
     // Get the relative URL path and existing query string, if present.
@@ -204,16 +207,16 @@ private void parsePath(String path) {
       // Ensure the query string does not have any named parameters.
       Matcher queryParamMatcher = PARAM_URL_REGEX.matcher(query);
       if (queryParamMatcher.find()) {
-        throw methodError("URL query string \"%s\" must not have replace block. For dynamic query"
+        throw this.methodError("URL query string \"%s\" must not have replace block. For dynamic query"
             + " parameters use @Query.", query);
       }
     }
 
     Set<String> urlParams = parsePathParameters(path);
 
-    requestUrl = url;
-    requestUrlParamNames = urlParams;
-    requestQuery = query;
+    this.setRequestUrl(url);
+    this.requestUrlParamNames = urlParams;
+    this.requestQuery = query;
   }
 
   List<retrofit.client.Header> parseHeaders(String[] headers) {
@@ -221,13 +224,13 @@ private void parsePath(String path) {
     for (String header : headers) {
       int colon = header.indexOf(':');
       if (colon == -1 || colon == 0 || colon == header.length() - 1) {
-        throw methodError("@Headers value must be in the form \"Name: Value\". Found: \"%s\"",
+        throw this.methodError("@Headers value must be in the form \"Name: Value\". Found: \"%s\"",
             header);
       }
       String headerName = header.substring(0, colon);
       String headerValue = header.substring(colon + 1).trim();
       if ("Content-Type".equalsIgnoreCase(headerName)) {
-        contentTypeHeader = headerValue;
+        this.contentTypeHeader = headerValue;
       } else {
         headerList.add(new retrofit.client.Header(headerName, headerValue));
       }
@@ -239,12 +242,12 @@ private void parsePath(String path) {
   private ResponseType parseResponseType() {
     // Synchronous methods have a non-void return type.
     // Observable methods have a return type of Observable.
-    Type returnType = method.getGenericReturnType();
+    Type returnType = this.method.getGenericReturnType();
 
     // Asynchronous methods should have a Callback type as the last argument.
     Type lastArgType = null;
     Class<?> lastArgClass = null;
-    Type[] parameterTypes = method.getGenericParameterTypes();
+    Type[] parameterTypes = this.method.getGenericParameterTypes();
     if (parameterTypes.length > 0) {
       Type typeToCheck = parameterTypes[parameterTypes.length - 1];
       lastArgType = typeToCheck;
@@ -261,10 +264,10 @@ private ResponseType parseResponseType() {
 
     // Check for invalid configurations.
     if (hasReturnType && hasCallback) {
-      throw methodError("Must have return type or Callback as last argument, not both.");
+      throw this.methodError("Must have return type or Callback as last argument, not both.");
     }
     if (!hasReturnType && !hasCallback) {
-      throw methodError("Must have either a return type or Callback as last argument.");
+      throw this.methodError("Must have either a return type or Callback as last argument.");
     }
 
     if (hasReturnType) {
@@ -272,21 +275,21 @@ private ResponseType parseResponseType() {
         Class rawReturnType = Types.getRawType(returnType);
         if (RxSupport.isObservable(rawReturnType)) {
           returnType = RxSupport.getObservableType(returnType, rawReturnType);
-          responseObjectType = getParameterUpperBound((ParameterizedType) returnType);
+          this.responseObjectType = getParameterUpperBound((ParameterizedType) returnType);
           return ResponseType.OBSERVABLE;
         }
       }
-      responseObjectType = returnType;
+      this.responseObjectType = returnType;
       return ResponseType.OBJECT;
     }
 
     lastArgType = Types.getSupertype(lastArgType, Types.getRawType(lastArgType), Callback.class);
     if (lastArgType instanceof ParameterizedType) {
-      responseObjectType = getParameterUpperBound((ParameterizedType) lastArgType);
+      this.responseObjectType = getParameterUpperBound((ParameterizedType) lastArgType);
       return ResponseType.VOID;
     }
 
-    throw methodError("Last parameter must be of type Callback<X> or Callback<? super X>.");
+    throw this.methodError("Last parameter must be of type Callback<X> or Callback<? super X>.");
   }
 
   private static Type getParameterUpperBound(ParameterizedType type) {
@@ -304,11 +307,11 @@ private static Type getParameterUpperBound(ParameterizedType type) {
    * Loads {@link #requestParamAnnotations}. Must be called after {@link #parseMethodAnnotations()}.
    */
   private void parseParameters() {
-    Class<?>[] methodParameterTypes = method.getParameterTypes();
+    Class<?>[] methodParameterTypes = this.method.getParameterTypes();
 
-    Annotation[][] methodParameterAnnotationArrays = method.getParameterAnnotations();
+    Annotation[][] methodParameterAnnotationArrays = this.method.getParameterAnnotations();
     int count = methodParameterAnnotationArrays.length;
-    if (!isSynchronous && !isObservable) {
+    if (!this.isSynchronous && !this.isObservable) {
       count -= 1; // Callback is last argument when not a synchronous method.
     }
 
@@ -328,53 +331,53 @@ private void parseParameters() {
 
           if (methodAnnotationType == Path.class) {
             String name = ((Path) methodParameterAnnotation).value();
-            validatePathName(i, name);
+            this.validatePathName(i, name);
           } else if (methodAnnotationType == Query.class) {
             // Nothing to do.
           } else if (methodAnnotationType == QueryMap.class) {
             if (!Map.class.isAssignableFrom(methodParameterType)) {
-              throw parameterError(i, "@QueryMap parameter type must be Map.");
+              throw this.parameterError(i, "@QueryMap parameter type must be Map.");
             }
           } else if (methodAnnotationType == Header.class) {
             // Nothing to do.
           } else if (methodAnnotationType == Field.class) {
-            if (requestType != RequestType.FORM_URL_ENCODED) {
-              throw parameterError(i, "@Field parameters can only be used with form encoding.");
+            if (this.requestType != RequestType.FORM_URL_ENCODED) {
+              throw this.parameterError(i, "@Field parameters can only be used with form encoding.");
             }
 
             gotField = true;
           } else if (methodAnnotationType == FieldMap.class) {
-            if (requestType != RequestType.FORM_URL_ENCODED) {
-              throw parameterError(i, "@FieldMap parameters can only be used with form encoding.");
+            if (this.requestType != RequestType.FORM_URL_ENCODED) {
+              throw this.parameterError(i, "@FieldMap parameters can only be used with form encoding.");
             }
             if (!Map.class.isAssignableFrom(methodParameterType)) {
-              throw parameterError(i, "@FieldMap parameter type must be Map.");
+              throw this.parameterError(i, "@FieldMap parameter type must be Map.");
             }
 
             gotField = true;
           } else if (methodAnnotationType == Part.class) {
-            if (requestType != RequestType.MULTIPART) {
-              throw parameterError(i, "@Part parameters can only be used with multipart encoding.");
+            if (this.requestType != RequestType.MULTIPART) {
+              throw this.parameterError(i, "@Part parameters can only be used with multipart encoding.");
             }
 
             gotPart = true;
           } else if (methodAnnotationType == PartMap.class) {
-            if (requestType != RequestType.MULTIPART) {
-              throw parameterError(i,
+            if (this.requestType != RequestType.MULTIPART) {
+              throw this.parameterError(i,
                   "@PartMap parameters can only be used with multipart encoding.");
             }
             if (!Map.class.isAssignableFrom(methodParameterType)) {
-              throw parameterError(i, "@PartMap parameter type must be Map.");
+              throw this.parameterError(i, "@PartMap parameter type must be Map.");
             }
 
             gotPart = true;
           } else if (methodAnnotationType == Body.class) {
-            if (requestType != RequestType.SIMPLE) {
-              throw parameterError(i,
+            if (this.requestType != RequestType.SIMPLE) {
+              throw this.parameterError(i,
                   "@Body parameters cannot be used with form or multi-part encoding.");
             }
             if (gotBody) {
-              throw methodError("Multiple @Body method annotations found.");
+              throw this.methodError("Multiple @Body method annotations found.");
             }
 
             gotBody = true;
@@ -384,7 +387,7 @@ private void parseParameters() {
           }
 
           if (requestParamAnnotations[i] != null) {
-            throw parameterError(i,
+            throw this.parameterError(i,
                 "Multiple Retrofit annotations found, only one allowed: @%s, @%s.",
                 requestParamAnnotations[i].annotationType().getSimpleName(),
                 methodAnnotationType.getSimpleName());
@@ -394,18 +397,18 @@ private void parseParameters() {
       }
 
       if (requestParamAnnotations[i] == null) {
-        throw parameterError(i, "No Retrofit annotation found.");
+        throw this.parameterError(i, "No Retrofit annotation found.");
       }
     }
 
-    if (requestType == RequestType.SIMPLE && !requestHasBody && gotBody) {
-      throw methodError("Non-body HTTP method cannot contain @Body or @TypedOutput.");
+    if (this.requestType == RequestType.SIMPLE && !this.requestHasBody && gotBody) {
+      throw this.methodError("Non-body HTTP method cannot contain @Body or @TypedOutput.");
     }
-    if (requestType == RequestType.FORM_URL_ENCODED && !gotField) {
-      throw methodError("Form-encoded method must contain at least one @Field.");
+    if (this.requestType == RequestType.FORM_URL_ENCODED && !gotField) {
+      throw this.methodError("Form-encoded method must contain at least one @Field.");
     }
-    if (requestType == RequestType.MULTIPART && !gotPart) {
-      throw methodError("Multipart method must contain at least one @Part.");
+    if (this.requestType == RequestType.MULTIPART && !gotPart) {
+      throw this.methodError("Multipart method must contain at least one @Part.");
     }
 
     this.requestParamAnnotations = requestParamAnnotations;
@@ -413,12 +416,12 @@ private void parseParameters() {
 
   private void validatePathName(int index, String name) {
     if (!PARAM_NAME_REGEX.matcher(name).matches()) {
-      throw parameterError(index, "@Path parameter name must match %s. Found: %s",
+      throw this.parameterError(index, "@Path parameter name must match %s. Found: %s",
           PARAM_URL_REGEX.pattern(), name);
     }
     // Verify URL replacement name is actually present in the URL path.
-    if (!requestUrlParamNames.contains(name)) {
-      throw parameterError(index, "URL \"%s\" does not contain \"{%s}\".", requestUrl, name);
+    if (!this.requestUrlParamNames.contains(name)) {
+      throw this.parameterError(index, "URL \"%s\" does not contain \"{%s}\".", this.getRequestUrl(), name);
     }
   }
 
@@ -435,7 +438,21 @@ private void validatePathName(int index, String name) {
     return patterns;
   }
 
-  /** Indirection to avoid log complaints if RxJava isn't present. */
+  /**
+ * @return the requestUrl
+ */
+public String getRequestUrl() {
+	return requestUrl;
+}
+
+/**
+ * @param requestUrl the requestUrl to set
+ */
+public void setRequestUrl(String requestUrl) {
+	this.requestUrl = requestUrl;
+}
+
+/** Indirection to avoid log complaints if RxJava isn't present. */
   private static final class RxSupport {
     public static boolean isObservable(Class rawType) {
       return rawType == Observable.class;
