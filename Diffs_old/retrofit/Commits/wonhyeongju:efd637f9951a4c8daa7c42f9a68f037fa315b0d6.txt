diff --git a/retrofit-converters/moshi/src/test/java/retrofit2/converter/moshi/MoshiConverterFactoryTest.java b/retrofit-converters/moshi/src/test/java/retrofit2/converter/moshi/MoshiConverterFactoryTest.java
deleted file mode 100644
index 3b902d1d8..000000000
--- a/retrofit-converters/moshi/src/test/java/retrofit2/converter/moshi/MoshiConverterFactoryTest.java
+++ /dev/null
@@ -1,237 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2.converter.moshi;
-
-import com.squareup.moshi.FromJson;
-import com.squareup.moshi.JsonAdapter;
-import com.squareup.moshi.JsonQualifier;
-import com.squareup.moshi.JsonReader;
-import com.squareup.moshi.JsonWriter;
-import com.squareup.moshi.Moshi;
-import com.squareup.moshi.ToJson;
-import java.io.IOException;
-import java.lang.annotation.Annotation;
-import java.lang.annotation.Retention;
-import java.lang.reflect.Type;
-import java.nio.charset.Charset;
-import java.util.Set;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.mockwebserver.RecordedRequest;
-import okio.Buffer;
-import okio.ByteString;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import retrofit2.Call;
-import retrofit2.Response;
-import retrofit2.Retrofit;
-import retrofit2.http.Body;
-import retrofit2.http.POST;
-
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
-
-public final class MoshiConverterFactoryTest {
-  @Retention(RUNTIME)
-  @JsonQualifier
-  @interface Qualifier {}
-
-  @Retention(RUNTIME)
-  @interface NonQualifer {}
-
-  interface AnInterface {
-    String getName();
-  }
-
-  static class AnImplementation implements AnInterface {
-    private final String theName;
-
-    AnImplementation(String name) {
-      theName = name;
-    }
-
-    @Override public String getName() {
-      return theName;
-    }
-  }
-
-  static class Adapters {
-    @ToJson public void write(JsonWriter jsonWriter, AnInterface anInterface) throws IOException {
-      jsonWriter.beginObject();
-      jsonWriter.name("name").value(anInterface.getName());
-      jsonWriter.endObject();
-    }
-
-    @FromJson public AnInterface read(JsonReader jsonReader) throws IOException {
-      jsonReader.beginObject();
-
-      String name = null;
-      while (jsonReader.hasNext()) {
-        switch (jsonReader.nextName()) {
-          case "name":
-            name = jsonReader.nextString();
-            break;
-        }
-      }
-
-      jsonReader.endObject();
-      return new AnImplementation(name);
-    }
-
-    @ToJson public void write(JsonWriter writer, @Qualifier String value) throws IOException {
-      writer.value("qualified!");
-    }
-
-    @FromJson @Qualifier public String readQualified(JsonReader reader) throws IOException {
-      String string = reader.nextString();
-      if (string.equals("qualified!")) {
-        return "it worked!";
-      }
-      throw new AssertionError("Found: " + string);
-    }
-  }
-
-  interface Service {
-    @POST("/") Call<AnImplementation> anImplementation(@Body AnImplementation impl);
-    @POST("/") Call<AnInterface> anInterface(@Body AnInterface impl);
-
-    @POST("/") @Qualifier @NonQualifer //
-    Call<String> annotations(@Body @Qualifier @NonQualifer String body);
-  }
-
-  @Rule public final MockWebServer server = new MockWebServer();
-
-  private Service service;
-  private Service serviceLenient;
-
-  @Before public void setUp() {
-    Moshi moshi = new Moshi.Builder()
-        .add(new JsonAdapter.Factory() {
-          @Override public JsonAdapter<?> create(Type type, Set<? extends Annotation> annotations,
-              Moshi moshi) {
-            for (Annotation annotation : annotations) {
-              if (!annotation.annotationType().isAnnotationPresent(JsonQualifier.class)) {
-                throw new AssertionError("Non-@JsonQualifier annotation: " + annotation);
-              }
-            }
-            return null;
-          }
-        })
-        .add(new Adapters())
-        .build();
-    MoshiConverterFactory factory = MoshiConverterFactory.create(moshi);
-    MoshiConverterFactory factoryLenient = factory.asLenient();
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(factory)
-        .build();
-    Retrofit retrofitLenient = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(factoryLenient)
-        .build();
-    service = retrofit.create(Service.class);
-    serviceLenient = retrofitLenient.create(Service.class);
-  }
-
-  @Test public void anInterface() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse().setBody("{\"name\":\"value\"}"));
-
-    Call<AnInterface> call = service.anInterface(new AnImplementation("value"));
-    Response<AnInterface> response = call.execute();
-    AnInterface body = response.body();
-    assertThat(body.getName()).isEqualTo("value");
-
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getBody().readUtf8()).isEqualTo("{\"name\":\"value\"}");
-    assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
-  }
-
-  @Test public void anImplementation() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse().setBody("{\"theName\":\"value\"}"));
-
-    Call<AnImplementation> call = service.anImplementation(new AnImplementation("value"));
-    Response<AnImplementation> response = call.execute();
-    AnImplementation body = response.body();
-    assertThat(body.theName).isEqualTo("value");
-
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getBody().readUtf8()).isEqualTo("{\"theName\":\"value\"}");
-    assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
-  }
-
-  @Test public void annotations() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse().setBody("\"qualified!\""));
-
-    Call<String> call = service.annotations("value");
-    Response<String> response = call.execute();
-    assertThat(response.body()).isEqualTo("it worked!");
-
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getBody().readUtf8()).isEqualTo("\"qualified!\"");
-    assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
-  }
-
-  @Test public void asLenient() throws IOException, InterruptedException {
-    MockResponse malformedResponse = new MockResponse().setBody("{\"theName\":value}");
-    server.enqueue(malformedResponse);
-    server.enqueue(malformedResponse);
-
-    Call<AnImplementation> call = service.anImplementation(new AnImplementation("value"));
-    try {
-      call.execute();
-      fail();
-    } catch (IOException e) {
-      assertEquals(e.getMessage(),
-          "Use JsonReader.setLenient(true) to accept malformed JSON at path $.theName");
-    }
-
-    Call<AnImplementation> call2 = serviceLenient.anImplementation(new AnImplementation("value"));
-    Response<AnImplementation> response = call2.execute();
-    AnImplementation body = response.body();
-    assertThat(body.theName).isEqualTo("value");
-  }
-
-  @Test public void utf8BomSkipped() throws IOException {
-    Buffer responseBody = new Buffer()
-        .write(ByteString.decodeHex("EFBBBF"))
-        .writeUtf8("{\"theName\":\"value\"}");
-    MockResponse malformedResponse = new MockResponse().setBody(responseBody);
-    server.enqueue(malformedResponse);
-
-    Call<AnImplementation> call = service.anImplementation(new AnImplementation("value"));
-    Response<AnImplementation> response = call.execute();
-    AnImplementation body = response.body();
-    assertThat(body.theName).isEqualTo("value");
-  }
-
-  @Test public void nonUtf8BomIsNotSkipped() throws IOException {
-    Buffer responseBody = new Buffer()
-        .write(ByteString.decodeHex("FEFF"))
-        .writeString("{\"theName\":\"value\"}", Charset.forName("UTF-16"));
-    MockResponse malformedResponse = new MockResponse().setBody(responseBody);
-    server.enqueue(malformedResponse);
-
-    Call<AnImplementation> call = service.anImplementation(new AnImplementation("value"));
-    try {
-      call.execute();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-}
diff --git a/retrofit/pom.xml b/retrofit/pom.xml
index 3f4461836..d6109ac0f 100644
--- a/retrofit/pom.xml
+++ b/retrofit/pom.xml
@@ -32,35 +32,5 @@
       <optional>true</optional>
     </dependency>
 
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.assertj</groupId>
-      <artifactId>assertj-core</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.mockito</groupId>
-      <artifactId>mockito-core</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>com.google.guava</groupId>
-      <artifactId>guava</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>com.squareup.okhttp3</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.robolectric</groupId>
-      <artifactId>robolectric</artifactId>
-      <scope>test</scope>
-    </dependency>
   </dependencies>
 </project>
diff --git a/retrofit/src/test/java/retrofit2/CallAdapterTest.java b/retrofit/src/test/java/retrofit2/CallAdapterTest.java
deleted file mode 100644
index d1ed83480..000000000
--- a/retrofit/src/test/java/retrofit2/CallAdapterTest.java
+++ /dev/null
@@ -1,96 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2;
-
-import com.google.common.reflect.TypeToken;
-import java.lang.reflect.ParameterizedType;
-import java.lang.reflect.Type;
-import java.util.List;
-import java.util.Map;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-import static retrofit2.CallAdapter.Factory.getParameterUpperBound;
-import static retrofit2.CallAdapter.Factory.getRawType;
-
-public final class CallAdapterTest {
-  @Test public void parameterizedTypeInvalidIndex() {
-    ParameterizedType listOfString = (ParameterizedType) new TypeToken<List<String>>() {}.getType();
-    try {
-      getParameterUpperBound(-1, listOfString);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Index -1 not in range [0,1) for java.util.List<java.lang.String>");
-    }
-    try {
-      getParameterUpperBound(1, listOfString);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Index 1 not in range [0,1) for java.util.List<java.lang.String>");
-    }
-  }
-
-  @Test public void parameterizedTypes() {
-    ParameterizedType one = (ParameterizedType) new TypeToken<List<String>>() {}.getType();
-    assertThat(getParameterUpperBound(0, one)).isSameAs(String.class);
-
-    ParameterizedType two = (ParameterizedType) new TypeToken<Map<String, String>>() {}.getType();
-    assertThat(getParameterUpperBound(0, two)).isSameAs(String.class);
-    assertThat(getParameterUpperBound(1, two)).isSameAs(String.class);
-
-    ParameterizedType wild = (ParameterizedType) new TypeToken<List<? extends CharSequence>>() {
-    }.getType();
-    assertThat(getParameterUpperBound(0, wild)).isSameAs(CharSequence.class);
-  }
-
-  @Test public void rawTypeThrowsOnNull() {
-    try {
-      getRawType(null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("type == null");
-    }
-  }
-
-  @Test public void rawTypes() throws NoSuchMethodException {
-    assertThat(getRawType(String.class)).isSameAs(String.class);
-
-    Type listOfString = new TypeToken<List<String>>() {}.getType();
-    assertThat(getRawType(listOfString)).isSameAs(List.class);
-
-    Type stringArray = new TypeToken<String[]>() {}.getType();
-    assertThat(getRawType(stringArray)).isSameAs(String[].class);
-
-    Type wild = ((ParameterizedType) new TypeToken<List<? extends CharSequence>>() {
-    }.getType()).getActualTypeArguments()[0];
-    assertThat(getRawType(wild)).isSameAs(CharSequence.class);
-
-    Type wildParam = ((ParameterizedType) new TypeToken<List<? extends List<String>>>() {
-    }.getType()).getActualTypeArguments()[0];
-    assertThat(getRawType(wildParam)).isSameAs(List.class);
-
-    Type typeVar = A.class.getDeclaredMethod("method").getGenericReturnType();
-    assertThat(getRawType(typeVar)).isSameAs(Object.class);
-  }
-
-  @SuppressWarnings("unused") // Used reflectively.
-  static class A<T> {
-    T method() {
-      return null;
-    }
-  }
-}
diff --git a/retrofit/src/test/java/retrofit2/CallTest.java b/retrofit/src/test/java/retrofit2/CallTest.java
deleted file mode 100644
index 18dd035af..000000000
--- a/retrofit/src/test/java/retrofit2/CallTest.java
+++ /dev/null
@@ -1,947 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2;
-
-import java.io.IOException;
-import java.lang.annotation.Annotation;
-import java.lang.reflect.Type;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.atomic.AtomicReference;
-import okhttp3.Interceptor;
-import okhttp3.OkHttpClient;
-import okhttp3.RequestBody;
-import okhttp3.ResponseBody;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.mockwebserver.SocketPolicy;
-import okio.Buffer;
-import okio.BufferedSource;
-import okio.ForwardingSource;
-import okio.Okio;
-import org.junit.Rule;
-import org.junit.Test;
-import retrofit2.helpers.ToStringConverterFactory;
-import retrofit2.http.Body;
-import retrofit2.http.GET;
-import retrofit2.http.POST;
-import retrofit2.http.Path;
-import retrofit2.http.Streaming;
-
-import static java.util.concurrent.TimeUnit.SECONDS;
-import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-import static org.mockito.Mockito.spy;
-import static org.mockito.Mockito.verifyNoMoreInteractions;
-
-public final class CallTest {
-  @Rule public final MockWebServer server = new MockWebServer();
-
-  interface Service {
-    @GET("/") Call<String> getString();
-    @GET("/") Call<ResponseBody> getBody();
-    @GET("/") @Streaming Call<ResponseBody> getStreamingBody();
-    @POST("/") Call<String> postString(@Body String body);
-    @POST("/{a}") Call<String> postRequestBody(@Path("a") Object a);
-  }
-
-  @Test public void http200Sync() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    Response<String> response = example.getString().execute();
-    assertThat(response.isSuccessful()).isTrue();
-    assertThat(response.body()).isEqualTo("Hi");
-  }
-
-  @Test public void http200Async() throws InterruptedException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    final AtomicReference<Response<String>> responseRef = new AtomicReference<>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    example.getString().enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {
-        responseRef.set(response);
-        latch.countDown();
-      }
-
-      @Override public void onFailure(Call<String> call, Throwable t) {
-        t.printStackTrace();
-      }
-    });
-    assertTrue(latch.await(10, SECONDS));
-
-    Response<String> response = responseRef.get();
-    assertThat(response.isSuccessful()).isTrue();
-    assertThat(response.body()).isEqualTo("Hi");
-  }
-
-  @Test public void http404Sync() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
-
-    Response<String> response = example.getString().execute();
-    assertThat(response.isSuccessful()).isFalse();
-    assertThat(response.code()).isEqualTo(404);
-    assertThat(response.errorBody().string()).isEqualTo("Hi");
-  }
-
-  @Test public void http404Async() throws InterruptedException, IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
-
-    final AtomicReference<Response<String>> responseRef = new AtomicReference<>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    example.getString().enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {
-        responseRef.set(response);
-        latch.countDown();
-      }
-
-      @Override public void onFailure(Call<String> call, Throwable t) {
-        t.printStackTrace();
-      }
-    });
-    assertTrue(latch.await(10, SECONDS));
-
-    Response<String> response = responseRef.get();
-    assertThat(response.isSuccessful()).isFalse();
-    assertThat(response.code()).isEqualTo(404);
-    assertThat(response.errorBody().string()).isEqualTo("Hi");
-  }
-
-  @Test public void transportProblemSync() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AT_START));
-
-    Call<String> call = example.getString();
-    try {
-      call.execute();
-      fail();
-    } catch (IOException ignored) {
-    }
-  }
-
-  @Test public void transportProblemAsync() throws InterruptedException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AT_START));
-
-    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    example.getString().enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {
-        throw new AssertionError();
-      }
-
-      @Override public void onFailure(Call<String> call, Throwable t) {
-        failureRef.set(t);
-        latch.countDown();
-      }
-    });
-    assertTrue(latch.await(10, SECONDS));
-
-    Throwable failure = failureRef.get();
-    assertThat(failure).isInstanceOf(IOException.class);
-  }
-
-  @Test public void conversionProblemOutgoingSync() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory() {
-          @Override
-          public Converter<?, RequestBody> requestBodyConverter(Type type,
-              Annotation[] parameterAnnotations, Annotation[] methodAnnotations,
-              Retrofit retrofit) {
-            return new Converter<String, RequestBody>() {
-              @Override public RequestBody convert(String value) throws IOException {
-                throw new UnsupportedOperationException("I am broken!");
-              }
-            };
-          }
-        })
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    Call<String> call = example.postString("Hi");
-    try {
-      call.execute();
-      fail();
-    } catch (UnsupportedOperationException e) {
-      assertThat(e).hasMessage("I am broken!");
-    }
-  }
-
-  @Test public void conversionProblemOutgoingAsync() throws InterruptedException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory() {
-          @Override
-          public Converter<?, RequestBody> requestBodyConverter(Type type,
-              Annotation[] parameterAnnotations, Annotation[] methodAnnotations,
-              Retrofit retrofit) {
-            return new Converter<String, RequestBody>() {
-              @Override public RequestBody convert(String value) throws IOException {
-                throw new UnsupportedOperationException("I am broken!");
-              }
-            };
-          }
-        })
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    example.postString("Hi").enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {
-        throw new AssertionError();
-      }
-
-      @Override public void onFailure(Call<String> call, Throwable t) {
-        failureRef.set(t);
-        latch.countDown();
-      }
-    });
-    assertTrue(latch.await(10, SECONDS));
-
-    assertThat(failureRef.get()).isInstanceOf(UnsupportedOperationException.class)
-        .hasMessage("I am broken!");
-  }
-
-  @Test public void conversionProblemIncomingSync() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory() {
-          @Override
-          public Converter<ResponseBody, ?> responseBodyConverter(Type type,
-              Annotation[] annotations, Retrofit retrofit) {
-            return new Converter<ResponseBody, String>() {
-              @Override public String convert(ResponseBody value) throws IOException {
-                throw new UnsupportedOperationException("I am broken!");
-              }
-            };
-          }
-        })
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    Call<String> call = example.postString("Hi");
-    try {
-      call.execute();
-      fail();
-    } catch (UnsupportedOperationException e) {
-      assertThat(e).hasMessage("I am broken!");
-    }
-  }
-
-  @Test public void conversionProblemIncomingMaskedByConverterIsUnwrapped() throws IOException {
-    // MWS has no way to trigger IOExceptions during the response body so use an interceptor.
-    OkHttpClient client = new OkHttpClient.Builder() //
-        .addInterceptor(new Interceptor() {
-          @Override public okhttp3.Response intercept(Chain chain) throws IOException {
-            okhttp3.Response response = chain.proceed(chain.request());
-            ResponseBody body = response.body();
-            BufferedSource source = Okio.buffer(new ForwardingSource(body.source()) {
-              @Override public long read(Buffer sink, long byteCount) throws IOException {
-                throw new IOException("cause");
-              }
-            });
-            body = ResponseBody.create(body.contentType(), body.contentLength(), source);
-            return response.newBuilder().body(body).build();
-          }
-        }).build();
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .client(client)
-        .addConverterFactory(new ToStringConverterFactory() {
-          @Override
-          public Converter<ResponseBody, ?> responseBodyConverter(Type type,
-              Annotation[] annotations, Retrofit retrofit) {
-            return new Converter<ResponseBody, String>() {
-              @Override public String convert(ResponseBody value) throws IOException {
-                try {
-                  return value.string();
-                } catch (IOException e) {
-                  // Some serialization libraries mask transport problems in runtime exceptions. Bad!
-                  throw new RuntimeException("wrapper", e);
-                }
-              }
-            };
-          }
-        })
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    Call<String> call = example.getString();
-    try {
-      call.execute();
-      fail();
-    } catch (IOException e) {
-      assertThat(e).hasMessage("cause");
-    }
-  }
-
-  @Test public void conversionProblemIncomingAsync() throws InterruptedException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory() {
-          @Override
-          public Converter<ResponseBody, ?> responseBodyConverter(Type type,
-              Annotation[] annotations, Retrofit retrofit) {
-            return new Converter<ResponseBody, String>() {
-              @Override public String convert(ResponseBody value) throws IOException {
-                throw new UnsupportedOperationException("I am broken!");
-              }
-            };
-          }
-        })
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    example.postString("Hi").enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {
-        throw new AssertionError();
-      }
-
-      @Override public void onFailure(Call<String> call, Throwable t) {
-        failureRef.set(t);
-        latch.countDown();
-      }
-    });
-    assertTrue(latch.await(10, SECONDS));
-
-    assertThat(failureRef.get()).isInstanceOf(UnsupportedOperationException.class)
-        .hasMessage("I am broken!");
-  }
-
-  @Test public void http204SkipsConverter() throws IOException {
-    final Converter<ResponseBody, String> converter = spy(new Converter<ResponseBody, String>() {
-      @Override public String convert(ResponseBody value) throws IOException {
-        return value.string();
-      }
-    });
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory() {
-          @Override
-          public Converter<ResponseBody, ?> responseBodyConverter(Type type,
-              Annotation[] annotations, Retrofit retrofit) {
-            return converter;
-          }
-        })
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setStatus("HTTP/1.1 204 Nothin"));
-
-    Response<String> response = example.getString().execute();
-    assertThat(response.code()).isEqualTo(204);
-    assertThat(response.body()).isNull();
-    verifyNoMoreInteractions(converter);
-  }
-
-  @Test public void http205SkipsConverter() throws IOException {
-    final Converter<ResponseBody, String> converter = spy(new Converter<ResponseBody, String>() {
-      @Override public String convert(ResponseBody value) throws IOException {
-        return value.string();
-      }
-    });
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory() {
-          @Override
-          public Converter<ResponseBody, ?> responseBodyConverter(Type type,
-              Annotation[] annotations, Retrofit retrofit) {
-            return converter;
-          }
-        })
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setStatus("HTTP/1.1 205 Nothin"));
-
-    Response<String> response = example.getString().execute();
-    assertThat(response.code()).isEqualTo(205);
-    assertThat(response.body()).isNull();
-    verifyNoMoreInteractions(converter);
-  }
-
-  @Test public void executeCallOnce() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-    server.enqueue(new MockResponse());
-    Call<String> call = example.getString();
-    call.execute();
-    try {
-      call.execute();
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage("Already executed.");
-    }
-  }
-
-  @Test public void successfulRequestResponseWhenMimeTypeMissing() throws Exception {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setBody("Hi").removeHeader("Content-Type"));
-
-    Response<String> response = example.getString().execute();
-    assertThat(response.body()).isEqualTo("Hi");
-  }
-
-  @Test public void responseBody() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setBody("1234"));
-
-    Response<ResponseBody> response = example.getBody().execute();
-    assertThat(response.body().string()).isEqualTo("1234");
-  }
-
-  @Test public void responseBodyBuffers() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse()
-        .setBody("1234")
-        .setSocketPolicy(DISCONNECT_DURING_RESPONSE_BODY));
-
-    Call<ResponseBody> buffered = example.getBody();
-    // When buffering we will detect all socket problems before returning the Response.
-    try {
-      buffered.execute();
-      fail();
-    } catch (IOException e) {
-      assertThat(e).hasMessage("unexpected end of stream");
-    }
-  }
-
-  @Test public void responseBodyStreams() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse()
-        .setBody("1234")
-        .setSocketPolicy(DISCONNECT_DURING_RESPONSE_BODY));
-
-    Response<ResponseBody> response = example.getStreamingBody().execute();
-
-    ResponseBody streamedBody = response.body();
-    // When streaming we only detect socket problems as the ResponseBody is read.
-    try {
-      streamedBody.string();
-      fail();
-    } catch (IOException e) {
-      assertThat(e).hasMessage("unexpected end of stream");
-    }
-  }
-
-  @Test public void rawResponseContentTypeAndLengthButNoSource() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setBody("Hi").addHeader("Content-Type", "text/greeting"));
-
-    Response<String> response = example.getString().execute();
-    assertThat(response.body()).isEqualTo("Hi");
-    ResponseBody rawBody = response.raw().body();
-    assertThat(rawBody.contentLength()).isEqualTo(2);
-    assertThat(rawBody.contentType().toString()).isEqualTo("text/greeting");
-    try {
-      rawBody.source();
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage("Cannot read raw response body of a converted body.");
-    }
-  }
-
-  @Test public void emptyResponse() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setBody("").addHeader("Content-Type", "text/stringy"));
-
-    Response<String> response = example.getString().execute();
-    assertThat(response.body()).isEqualTo("");
-    ResponseBody rawBody = response.raw().body();
-    assertThat(rawBody.contentLength()).isEqualTo(0);
-    assertThat(rawBody.contentType().toString()).isEqualTo("text/stringy");
-  }
-
-  @Test public void reportsExecutedSync() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    Call<String> call = example.getString();
-    assertThat(call.isExecuted()).isFalse();
-
-    call.execute();
-    assertThat(call.isExecuted()).isTrue();
-  }
-
-  @Test public void reportsExecutedAsync() throws InterruptedException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    Call<String> call = example.getString();
-    assertThat(call.isExecuted()).isFalse();
-
-    call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {}
-      @Override public void onFailure(Call<String> call, Throwable t) {}
-    });
-    assertThat(call.isExecuted()).isTrue();
-  }
-
-  @Test public void cancelBeforeExecute() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service service = retrofit.create(Service.class);
-    Call<String> call = service.getString();
-
-    call.cancel();
-    assertThat(call.isCanceled()).isTrue();
-
-    try {
-      call.execute();
-      fail();
-    } catch (IOException e) {
-      assertThat(e).hasMessage("Canceled");
-    }
-  }
-
-  @Test public void cancelBeforeEnqueue() throws Exception {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service service = retrofit.create(Service.class);
-    Call<String> call = service.getString();
-
-    call.cancel();
-    assertThat(call.isCanceled()).isTrue();
-
-    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {
-        throw new AssertionError();
-      }
-
-      @Override public void onFailure(Call<String> call, Throwable t) {
-        failureRef.set(t);
-        latch.countDown();
-      }
-    });
-    assertTrue(latch.await(10, SECONDS));
-    assertThat(failureRef.get()).hasMessage("Canceled");
-  }
-
-  @Test public void cloningExecutedRequestDoesNotCopyState() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service service = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setBody("Hi"));
-    server.enqueue(new MockResponse().setBody("Hello"));
-
-    Call<String> call = service.getString();
-    assertThat(call.execute().body()).isEqualTo("Hi");
-
-    Call<String> cloned = call.clone();
-    assertThat(cloned.execute().body()).isEqualTo("Hello");
-  }
-
-  @Test public void cancelRequest() throws InterruptedException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service service = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.NO_RESPONSE));
-
-    Call<String> call = service.getString();
-
-    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {
-        throw new AssertionError();
-      }
-
-      @Override public void onFailure(Call<String> call, Throwable t) {
-        failureRef.set(t);
-        latch.countDown();
-      }
-    });
-
-    call.cancel();
-    assertThat(call.isCanceled()).isTrue();
-
-    assertTrue(latch.await(10, SECONDS));
-    assertThat(failureRef.get()).isInstanceOf(IOException.class).hasMessage("Canceled");
-  }
-
-  @Test public void requestBeforeExecuteCreates() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service service = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse());
-
-    final AtomicInteger writeCount = new AtomicInteger();
-    Object a = new Object() {
-      @Override public String toString() {
-        writeCount.incrementAndGet();
-        return "Hello";
-      }
-    };
-    Call<String> call = service.postRequestBody(a);
-
-    call.request();
-    assertThat(writeCount.get()).isEqualTo(1);
-
-    call.execute();
-    assertThat(writeCount.get()).isEqualTo(1);
-  }
-
-  @Test public void requestThrowingBeforeExecuteFailsExecute() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service service = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse());
-
-    final AtomicInteger writeCount = new AtomicInteger();
-    Object a = new Object() {
-      @Override public String toString() {
-        writeCount.incrementAndGet();
-        throw new RuntimeException("Broken!");
-      }
-    };
-    Call<String> call = service.postRequestBody(a);
-
-    try {
-      call.request();
-      fail();
-    } catch (RuntimeException e) {
-      assertThat(e).hasMessage("Broken!");
-    }
-    assertThat(writeCount.get()).isEqualTo(1);
-
-    try {
-      call.execute();
-      fail();
-    } catch (RuntimeException e) {
-      assertThat(e).hasMessage("Broken!");
-    }
-    assertThat(writeCount.get()).isEqualTo(1);
-  }
-
-  @Test public void requestAfterExecuteReturnsCachedValue() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service service = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse());
-
-    final AtomicInteger writeCount = new AtomicInteger();
-    Object a = new Object() {
-      @Override public String toString() {
-        writeCount.incrementAndGet();
-        return "Hello";
-      }
-    };
-    Call<String> call = service.postRequestBody(a);
-
-    call.execute();
-    assertThat(writeCount.get()).isEqualTo(1);
-
-    call.request();
-    assertThat(writeCount.get()).isEqualTo(1);
-  }
-
-  @Test public void requestAfterExecuteThrowingAlsoThrows() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service service = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse());
-
-    final AtomicInteger writeCount = new AtomicInteger();
-    Object a = new Object() {
-      @Override public String toString() {
-        writeCount.incrementAndGet();
-        throw new RuntimeException("Broken!");
-      }
-    };
-    Call<String> call = service.postRequestBody(a);
-
-    try {
-      call.execute();
-      fail();
-    } catch (RuntimeException e) {
-      assertThat(e).hasMessage("Broken!");
-    }
-    assertThat(writeCount.get()).isEqualTo(1);
-
-    try {
-      call.request();
-      fail();
-    } catch (RuntimeException e) {
-      assertThat(e).hasMessage("Broken!");
-    }
-    assertThat(writeCount.get()).isEqualTo(1);
-  }
-
-  @Test public void requestBeforeEnqueueCreates() throws IOException, InterruptedException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service service = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse());
-
-    final AtomicInteger writeCount = new AtomicInteger();
-    Object a = new Object() {
-      @Override public String toString() {
-        writeCount.incrementAndGet();
-        return "Hello";
-      }
-    };
-    Call<String> call = service.postRequestBody(a);
-
-    call.request();
-    assertThat(writeCount.get()).isEqualTo(1);
-
-    final CountDownLatch latch = new CountDownLatch(1);
-    call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {
-        assertThat(writeCount.get()).isEqualTo(1);
-        latch.countDown();
-      }
-
-      @Override public void onFailure(Call<String> call, Throwable t) {
-      }
-    });
-    assertTrue(latch.await(10, SECONDS));
-  }
-
-  @Test public void requestThrowingBeforeEnqueueFailsEnqueue()
-      throws IOException, InterruptedException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service service = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse());
-
-    final AtomicInteger writeCount = new AtomicInteger();
-    Object a = new Object() {
-      @Override public String toString() {
-        writeCount.incrementAndGet();
-        throw new RuntimeException("Broken!");
-      }
-    };
-    Call<String> call = service.postRequestBody(a);
-
-    try {
-      call.request();
-      fail();
-    } catch (RuntimeException e) {
-      assertThat(e).hasMessage("Broken!");
-    }
-    assertThat(writeCount.get()).isEqualTo(1);
-
-    final CountDownLatch latch = new CountDownLatch(1);
-    call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {
-      }
-
-      @Override public void onFailure(Call<String> call, Throwable t) {
-        assertThat(t).isExactlyInstanceOf(RuntimeException.class).hasMessage("Broken!");
-        assertThat(writeCount.get()).isEqualTo(1);
-        latch.countDown();
-      }
-    });
-    assertTrue(latch.await(10, SECONDS));
-  }
-
-  @Test public void requestAfterEnqueueReturnsCachedValue() throws IOException,
-      InterruptedException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service service = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse());
-
-    final AtomicInteger writeCount = new AtomicInteger();
-    Object a = new Object() {
-      @Override public String toString() {
-        writeCount.incrementAndGet();
-        return "Hello";
-      }
-    };
-    Call<String> call = service.postRequestBody(a);
-
-    final CountDownLatch latch = new CountDownLatch(1);
-    call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {
-        assertThat(writeCount.get()).isEqualTo(1);
-        latch.countDown();
-      }
-
-      @Override public void onFailure(Call<String> call, Throwable t) {
-      }
-    });
-    assertTrue(latch.await(10, SECONDS));
-
-    call.request();
-    assertThat(writeCount.get()).isEqualTo(1);
-  }
-
-  @Test public void requestAfterEnqueueFailingThrows() throws IOException,
-      InterruptedException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service service = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse());
-
-    final AtomicInteger writeCount = new AtomicInteger();
-    Object a = new Object() {
-      @Override public String toString() {
-        writeCount.incrementAndGet();
-        throw new RuntimeException("Broken!");
-      }
-    };
-    Call<String> call = service.postRequestBody(a);
-
-    final CountDownLatch latch = new CountDownLatch(1);
-    call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {
-      }
-
-      @Override public void onFailure(Call<String> call, Throwable t) {
-        assertThat(t).isExactlyInstanceOf(RuntimeException.class).hasMessage("Broken!");
-        assertThat(writeCount.get()).isEqualTo(1);
-        latch.countDown();
-      }
-    });
-    assertTrue(latch.await(10, SECONDS));
-
-    try {
-      call.request();
-      fail();
-    } catch (RuntimeException e) {
-      assertThat(e).hasMessage("Broken!");
-    }
-    assertThat(writeCount.get()).isEqualTo(1);
-  }
-}
diff --git a/retrofit/src/test/java/retrofit2/ExecutorCallAdapterFactoryTest.java b/retrofit/src/test/java/retrofit2/ExecutorCallAdapterFactoryTest.java
deleted file mode 100644
index 24b871052..000000000
--- a/retrofit/src/test/java/retrofit2/ExecutorCallAdapterFactoryTest.java
+++ /dev/null
@@ -1,170 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2;
-
-import com.google.common.reflect.TypeToken;
-import java.io.IOException;
-import java.lang.annotation.Annotation;
-import java.lang.reflect.Type;
-import java.util.List;
-import java.util.concurrent.Executor;
-import okhttp3.Request;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.spy;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.verifyNoMoreInteractions;
-
-@SuppressWarnings("unchecked")
-public final class ExecutorCallAdapterFactoryTest {
-  private static final Annotation[] NO_ANNOTATIONS = new Annotation[0];
-
-  private final Retrofit retrofit = new Retrofit.Builder()
-      .baseUrl("http://localhost:1")
-      .build();
-  private final Callback<String> callback = mock(Callback.class);
-  private final Executor callbackExecutor = spy(new Executor() {
-    @Override public void execute(Runnable runnable) {
-      runnable.run();
-    }
-  });
-  private final CallAdapter.Factory factory = new ExecutorCallAdapterFactory(callbackExecutor);
-
-  @Test public void rawTypeThrows() {
-    try {
-      factory.get(Call.class, NO_ANNOTATIONS, retrofit);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Call return type must be parameterized as Call<Foo> or Call<? extends Foo>");
-    }
-  }
-
-  @Test public void responseType() {
-    Type classType = new TypeToken<Call<String>>() {}.getType();
-    assertThat(factory.get(classType, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-    Type wilcardType = new TypeToken<Call<? extends String>>() {}.getType();
-    assertThat(factory.get(wilcardType, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-    Type genericType = new TypeToken<Call<List<String>>>() {}.getType();
-    assertThat(factory.get(genericType, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(new TypeToken<List<String>>() {}.getType());
-  }
-
-  @Test public void adaptedCallExecute() throws IOException {
-    Type returnType = new TypeToken<Call<String>>() {}.getType();
-    CallAdapter<Call<?>> adapter =
-        (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
-    final Response<String> response = Response.success("Hi");
-    Call<String> call = (Call<String>) adapter.adapt(new EmptyCall() {
-      @Override public Response<String> execute() throws IOException {
-        return response;
-      }
-    });
-    assertThat(call.execute()).isSameAs(response);
-  }
-
-  @Test public void adaptedCallEnqueueUsesExecutorForSuccessCallback() {
-    Type returnType = new TypeToken<Call<String>>() {}.getType();
-    CallAdapter<Call<?>> adapter =
-        (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
-    final Response<String> response = Response.success("Hi");
-    EmptyCall originalCall = new EmptyCall() {
-      @Override public void enqueue(Callback<String> callback) {
-        callback.onResponse(this, response);
-      }
-    };
-    Call<String> call = (Call<String>) adapter.adapt(originalCall);
-    call.enqueue(callback);
-    verify(callbackExecutor).execute(any(Runnable.class));
-    verify(callback).onResponse(call, response);
-  }
-
-  @Test public void adaptedCallEnqueueUsesExecutorForFailureCallback() {
-    Type returnType = new TypeToken<Call<String>>() {}.getType();
-    CallAdapter<Call<?>> adapter =
-        (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
-    final Throwable throwable = new IOException();
-    EmptyCall originalCall = new EmptyCall() {
-      @Override public void enqueue(Callback<String> callback) {
-        callback.onFailure(this, throwable);
-      }
-    };
-    Call<String> call = (Call<String>) adapter.adapt(originalCall);
-    call.enqueue(callback);
-    verify(callbackExecutor).execute(any(Runnable.class));
-    verifyNoMoreInteractions(callbackExecutor);
-    verify(callback).onFailure(call, throwable);
-    verifyNoMoreInteractions(callback);
-  }
-
-  @Test public void adaptedCallCloneDeepCopy() {
-    Type returnType = new TypeToken<Call<String>>() {}.getType();
-    CallAdapter<Call<?>> adapter =
-        (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
-    Call<String> delegate = mock(Call.class);
-    Call<String> call = (Call<String>) adapter.adapt(delegate);
-    Call<String> cloned = call.clone();
-    assertThat(cloned).isNotSameAs(call);
-    verify(delegate).clone();
-    verifyNoMoreInteractions(delegate);
-  }
-
-  @Test public void adaptedCallCancel() {
-    Type returnType = new TypeToken<Call<String>>() {}.getType();
-    CallAdapter<Call<?>> adapter =
-        (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
-    Call<String> delegate = mock(Call.class);
-    Call<String> call = (Call<String>) adapter.adapt(delegate);
-    call.cancel();
-    verify(delegate).cancel();
-    verifyNoMoreInteractions(delegate);
-  }
-
-  static class EmptyCall implements Call<String> {
-    @Override public void enqueue(Callback<String> callback) {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override public boolean isExecuted() {
-      return false;
-    }
-
-    @Override public Response<String> execute() throws IOException {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override public void cancel() {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override public boolean isCanceled() {
-      return false;
-    }
-
-    @Override public Call<String> clone() {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override public Request request() {
-      throw new UnsupportedOperationException();
-    }
-  }
-}
diff --git a/retrofit/src/test/java/retrofit2/Java8DefaultMethodsTest.java b/retrofit/src/test/java/retrofit2/Java8DefaultMethodsTest.java
deleted file mode 100644
index 8333969c6..000000000
--- a/retrofit/src/test/java/retrofit2/Java8DefaultMethodsTest.java
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2;
-
-// TODO this test doesn't play nice in the IDE because it relies on Java 8 language features.
-public final class Java8DefaultMethodsTest {
-  //@Rule public final MockWebServer server = new MockWebServer();
-  //
-  //interface Example {
-  //  @GET("/") Call<String> user(@Query("name") String name);
-  //
-  //  default Call<String> user() {
-  //    return user("hey");
-  //  }
-  //}
-  //
-  //@Test public void test() throws IOException {
-  //  server.enqueue(new MockResponse().setBody("Hi"));
-  //  server.enqueue(new MockResponse().setBody("Hi"));
-  //
-  //  Retrofit retrofit = new Retrofit.Builder()
-  //      .baseUrl(server.url("/"))
-  //      .addConverterFactory(new ToStringConverterFactory())
-  //      .build();
-  //  Example example = retrofit.create(Example.class);
-  //
-  //  Response<String> response = example.user().execute();
-  //  assertThat(response.body()).isEqualTo("Hi");
-  //  Response<String> response = example.user("hi").execute();
-  //  assertThat(response.body()).isEqualTo("Hi");
-  //}
-}
diff --git a/retrofit/src/test/java/retrofit2/RequestBuilderAndroidTest.java b/retrofit/src/test/java/retrofit2/RequestBuilderAndroidTest.java
deleted file mode 100644
index 63fa57b6c..000000000
--- a/retrofit/src/test/java/retrofit2/RequestBuilderAndroidTest.java
+++ /dev/null
@@ -1,62 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2;
-
-import android.net.Uri;
-import okhttp3.Request;
-import okhttp3.ResponseBody;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import retrofit2.http.GET;
-import retrofit2.http.Url;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static retrofit2.RequestBuilderTest.buildRequest;
-
-@RunWith(RobolectricTestRunner.class)
-@SuppressWarnings({"UnusedParameters", "unused"}) // Parameters inspected reflectively.
-public final class RequestBuilderAndroidTest {
-  @Test public void getWithAndroidUriUrl() {
-    class Example {
-      @GET
-      Call<ResponseBody> method(@Url Uri url) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, Uri.parse("foo/bar/"));
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithAndroidUriUrlAbsolute() {
-    class Example {
-      @GET
-      Call<ResponseBody> method(@Url Uri url) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, Uri.parse("https://example2.com/foo/bar/"));
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("https://example2.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-}
diff --git a/retrofit/src/test/java/retrofit2/RequestBuilderTest.java b/retrofit/src/test/java/retrofit2/RequestBuilderTest.java
deleted file mode 100644
index 59b69f432..000000000
--- a/retrofit/src/test/java/retrofit2/RequestBuilderTest.java
+++ /dev/null
@@ -1,2530 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2;
-
-import java.io.IOException;
-import java.lang.reflect.Method;
-import java.math.BigInteger;
-import java.net.URI;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.atomic.AtomicReference;
-import okhttp3.HttpUrl;
-import okhttp3.MediaType;
-import okhttp3.MultipartBody;
-import okhttp3.Request;
-import okhttp3.RequestBody;
-import okhttp3.ResponseBody;
-import okio.Buffer;
-import org.junit.Ignore;
-import org.junit.Test;
-import retrofit2.helpers.ToStringConverterFactory;
-import retrofit2.http.Body;
-import retrofit2.http.DELETE;
-import retrofit2.http.Field;
-import retrofit2.http.FieldMap;
-import retrofit2.http.FormUrlEncoded;
-import retrofit2.http.GET;
-import retrofit2.http.HEAD;
-import retrofit2.http.HTTP;
-import retrofit2.http.Header;
-import retrofit2.http.HeaderMap;
-import retrofit2.http.Headers;
-import retrofit2.http.Multipart;
-import retrofit2.http.OPTIONS;
-import retrofit2.http.PATCH;
-import retrofit2.http.POST;
-import retrofit2.http.PUT;
-import retrofit2.http.Part;
-import retrofit2.http.PartMap;
-import retrofit2.http.Path;
-import retrofit2.http.Query;
-import retrofit2.http.QueryMap;
-import retrofit2.http.Url;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.fail;
-
-@SuppressWarnings({"UnusedParameters", "unused"}) // Parameters inspected reflectively.
-public final class RequestBuilderTest {
-  private static final MediaType TEXT_PLAIN = MediaType.parse("text/plain");
-
-  @Test public void customMethodNoBody() {
-    class Example {
-      @HTTP(method = "CUSTOM1", path = "/foo")
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class);
-    assertThat(request.method()).isEqualTo("CUSTOM1");
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo");
-    assertThat(request.body()).isNull();
-  }
-
-  @Ignore("https://github.com/square/okhttp/issues/229")
-  @Test public void customMethodWithBody() {
-    class Example {
-      @HTTP(method = "CUSTOM2", path = "/foo", hasBody = true)
-      Call<ResponseBody> method(@Body RequestBody body) {
-        return null;
-      }
-    }
-
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
-    Request request = buildRequest(Example.class, body);
-    assertThat(request.method()).isEqualTo("CUSTOM2");
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo");
-    assertBody(request.body(), "hi");
-  }
-
-  @Test public void onlyOneEncodingIsAllowedMultipartFirst() {
-    class Example {
-      @Multipart //
-      @FormUrlEncoded //
-      @POST("/") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Only one encoding annotation is allowed.\n    for method Example.method");
-    }
-  }
-
-  @Test public void onlyOneEncodingIsAllowedFormEncodingFirst() {
-    class Example {
-      @FormUrlEncoded //
-      @Multipart //
-      @POST("/") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Only one encoding annotation is allowed.\n    for method Example.method");
-    }
-  }
-
-  @Test public void invalidPathParam() throws Exception {
-    class Example {
-      @GET("/") //
-      Call<ResponseBody> method(@Path("hey!") String thing) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@Path parameter name must match \\{([a-zA-Z][a-zA-Z0-9_-]*)\\}."
-              + " Found: hey! (parameter #1)\n    for method Example.method");
-    }
-  }
-
-  @Test public void pathParamNotAllowedInQuery() throws Exception {
-    class Example {
-      @GET("/foo?bar={bar}") //
-      Call<ResponseBody> method(@Path("bar") String thing) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "URL query string \"bar={bar}\" must not have replace block."
-              + " For dynamic query parameters use @Query.\n    for method Example.method");
-    }
-  }
-
-  @Test public void multipleParameterAnnotationsNotAllowed() throws Exception {
-    class Example {
-      @GET("/") //
-      Call<ResponseBody> method(@Body @Query("nope") String o) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Multiple Retrofit annotations found, only one allowed. (parameter #1)\n    for method Example.method");
-    }
-  }
-
-  @interface NonNull {}
-
-  @Test public void multipleParameterAnnotationsOnlyOneRetrofitAllowed() throws Exception {
-    class Example {
-      @GET("/") //
-      Call<ResponseBody> method(@Query("maybe") @NonNull Object o) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "yep");
-    assertThat(request.url().toString()).isEqualTo("http://example.com/?maybe=yep");
-  }
-
-  @Test public void twoMethodsFail() {
-    class Example {
-      @PATCH("/foo") //
-      @POST("/foo") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-        assertThat(e.getMessage())
-            .isIn("Only one HTTP method is allowed. Found: PATCH and POST.\n    for method Example.method",
-                  "Only one HTTP method is allowed. Found: POST and PATCH.\n    for method Example.method");
-    }
-  }
-
-  @Test public void lackingMethod() {
-    class Example {
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "HTTP method annotation is required (e.g., @GET, @POST, etc.).\n    for method Example.method");
-    }
-  }
-
-  @Test public void implicitMultipartForbidden() {
-    class Example {
-      @POST("/") //
-      Call<ResponseBody> method(@Part("a") int a) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@Part parameters can only be used with multipart encoding. (parameter #1)\n    for method Example.method");
-    }
-  }
-
-  @Test public void implicitMultipartWithPartMapForbidden() {
-    class Example {
-      @POST("/") //
-      Call<ResponseBody> method(@PartMap Map<String, String> params) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@PartMap parameters can only be used with multipart encoding. (parameter #1)\n    for method Example.method");
-    }
-  }
-
-  @Test public void multipartFailsOnNonBodyMethod() {
-    class Example {
-      @Multipart //
-      @GET("/") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Multipart can only be specified on HTTP methods with request body (e.g., @POST).\n    for method Example.method");
-    }
-  }
-
-  @Test public void multipartFailsWithNoParts() {
-    class Example {
-      @Multipart //
-      @POST("/") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Multipart method must contain at least one @Part.\n    for method Example.method");
-    }
-  }
-
-  @Test public void implicitFormEncodingByFieldForbidden() {
-    class Example {
-      @POST("/") //
-      Call<ResponseBody> method(@Field("a") int a) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@Field parameters can only be used with form encoding. (parameter #1)\n    for method Example.method");
-    }
-  }
-
-  @Test public void implicitFormEncodingByFieldMapForbidden() {
-    class Example {
-      @POST("/") //
-      Call<ResponseBody> method(@FieldMap Map<String, String> a) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@FieldMap parameters can only be used with form encoding. (parameter #1)\n    for method Example.method");
-    }
-  }
-
-  @Test public void formEncodingFailsOnNonBodyMethod() {
-    class Example {
-      @FormUrlEncoded //
-      @GET("/") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "FormUrlEncoded can only be specified on HTTP methods with request body (e.g., @POST).\n    for method Example.method");
-    }
-  }
-
-  @Test public void formEncodingFailsWithNoParts() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Form-encoded method must contain at least one @Field.\n    for method Example.method");
-    }
-  }
-
-  @Test public void headersFailWhenEmptyOnMethod() {
-    class Example {
-      @GET("/") //
-      @Headers({}) //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("@Headers annotation is empty.\n    for method Example.method");
-    }
-  }
-
-  @Test public void headersFailWhenMalformed() {
-    class Example {
-      @GET("/") //
-      @Headers("Malformed") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@Headers value must be in the form \"Name: Value\". Found: \"Malformed\"\n    for method Example.method");
-    }
-  }
-
-  @Test public void pathParamNonPathParamAndTypedBytes() {
-    class Example {
-      @PUT("/{a}") //
-      Call<ResponseBody> method(@Path("a") int a, @Path("b") int b, @Body int c) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "URL \"/{a}\" does not contain \"{b}\". (parameter #2)\n    for method Example.method");
-    }
-  }
-
-  @Test public void parameterWithoutAnnotation() {
-    class Example {
-      @GET("/") //
-      Call<ResponseBody> method(String a) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "No Retrofit annotation found. (parameter #1)\n    for method Example.method");
-    }
-  }
-
-  @Test public void nonBodyHttpMethodWithSingleEntity() {
-    class Example {
-      @GET("/") //
-      Call<ResponseBody> method(@Body String o) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Non-body HTTP method cannot contain @Body.\n    for method Example.method");
-    }
-  }
-
-  @Test public void queryMapMustBeAMap() {
-    class Example {
-      @GET("/") //
-      Call<ResponseBody> method(@QueryMap List<String> a) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@QueryMap parameter type must be Map. (parameter #1)\n    for method Example.method");
-    }
-  }
-
-  @Test public void queryMapSupportsSubclasses() {
-    class Foo extends HashMap<String, String> {
-    }
-
-    class Example {
-      @GET("/") //
-      Call<ResponseBody> method(@QueryMap Foo a) {
-        return null;
-      }
-    }
-
-    Foo foo = new Foo();
-    foo.put("hello", "world");
-
-    Request request = buildRequest(Example.class, foo);
-    assertThat(request.url().toString()).isEqualTo("http://example.com/?hello=world");
-  }
-
-  @Test public void queryMapRejectsNull() {
-    class Example {
-      @GET("/") //
-      Call<ResponseBody> method(@QueryMap Map<String, String> a) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Query map was null.");
-    }
-  }
-
-  @Test public void queryMapRejectsNullKeys() {
-    class Example {
-      @GET("/") //
-      Call<ResponseBody> method(@QueryMap Map<String, String> a) {
-        return null;
-      }
-    }
-
-    Map<String, String> queryParams = new LinkedHashMap<>();
-    queryParams.put("ping", "pong");
-    queryParams.put(null, "kat");
-
-    try {
-      buildRequest(Example.class, queryParams);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Query map contained null key.");
-    }
-  }
-
-  @Test public void queryMapRejectsNullValues() {
-    class Example {
-      @GET("/") //
-      Call<ResponseBody> method(@QueryMap Map<String, String> a) {
-        return null;
-      }
-    }
-
-    Map<String, String> queryParams = new LinkedHashMap<>();
-    queryParams.put("ping", "pong");
-    queryParams.put("kit", null);
-
-    try {
-      buildRequest(Example.class, queryParams);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Query map contained null value for key 'kit'.");
-    }
-  }
-
-  @Test public void getWithHeaderMap() {
-    class Example {
-      @GET("/search")
-      Call<ResponseBody> method(@HeaderMap Map<String, Object> headers) {
-        return null;
-      }
-    }
-
-    Map<String, Object> headers = new LinkedHashMap<>();
-    headers.put("Accept", "text/plain");
-    headers.put("Accept-Charset", "utf-8");
-
-    Request request = buildRequest(Example.class, headers);
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.url().toString()).isEqualTo("http://example.com/search");
-    assertThat(request.body()).isNull();
-    assertThat(request.headers().size()).isEqualTo(2);
-    assertThat(request.header("Accept")).isEqualTo("text/plain");
-    assertThat(request.header("Accept-Charset")).isEqualTo("utf-8");
-  }
-
-  @Test public void headerMapMustBeAMap() {
-    class Example {
-      @GET("/")
-      Call<ResponseBody> method(@HeaderMap List<String> headers) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@HeaderMap parameter type must be Map. (parameter #1)\n    for method Example.method");
-    }
-  }
-
-  @Test public void headerMapSupportsSubclasses() {
-    class Foo extends HashMap<String, String> {
-    }
-
-    class Example {
-      @GET("/search")
-      Call<ResponseBody> method(@HeaderMap Foo headers) {
-        return null;
-      }
-    }
-
-    Foo headers = new Foo();
-    headers.put("Accept", "text/plain");
-
-    Request request = buildRequest(Example.class, headers);
-    assertThat(request.url().toString()).isEqualTo("http://example.com/search");
-    assertThat(request.headers().size()).isEqualTo(1);
-    assertThat(request.header("Accept")).isEqualTo("text/plain");
-  }
-
-  @Test public void headerMapRejectsNull() {
-    class Example {
-      @GET("/")
-      Call<ResponseBody> method(@HeaderMap Map<String, String> headers) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, (Map<String, String>) null);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Header map was null.");
-    }
-  }
-
-  @Test public void headerMapRejectsNullKeys() {
-    class Example {
-      @GET("/")
-      Call<ResponseBody> method(@HeaderMap Map<String, String> headers) {
-        return null;
-      }
-    }
-
-    Map<String, String> headers = new LinkedHashMap<>();
-    headers.put("Accept", "text/plain");
-    headers.put(null, "utf-8");
-
-    try {
-      buildRequest(Example.class, headers);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Header map contained null key.");
-    }
-  }
-
-  @Test public void headerMapRejectsNullValues() {
-    class Example {
-      @GET("/")
-      Call<ResponseBody> method(@HeaderMap Map<String, String> headers) {
-        return null;
-      }
-    }
-
-    Map<String, String> headers = new LinkedHashMap<>();
-    headers.put("Accept", "text/plain");
-    headers.put("Accept-Charset", null);
-
-    try {
-      buildRequest(Example.class, headers);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Header map contained null value for key 'Accept-Charset'.");
-    }
-  }
-
-  @Test public void twoBodies() {
-    class Example {
-      @PUT("/") //
-      Call<ResponseBody> method(@Body String o1, @Body String o2) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Multiple @Body method annotations found. (parameter #2)\n    for method Example.method");
-    }
-  }
-
-  @Test public void bodyInNonBodyRequest() {
-    class Example {
-      @Multipart //
-      @PUT("/") //
-      Call<ResponseBody> method(@Part("one") String o1, @Body String o2) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@Body parameters cannot be used with form or multi-part encoding. (parameter #2)\n    for method Example.method");
-    }
-  }
-
-  @Test public void get() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class);
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void delete() {
-    class Example {
-      @DELETE("/foo/bar/") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class);
-    assertThat(request.method()).isEqualTo("DELETE");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertNull(request.body());
-  }
-
-  @Test public void head() {
-    class Example {
-      @HEAD("/foo/bar/") //
-      Call<Void> method() {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class);
-    assertThat(request.method()).isEqualTo("HEAD");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void headWithoutVoidThrows() {
-    class Example {
-      @HEAD("/foo/bar/") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "HEAD method must use Void as response type.\n    for method Example.method");
-    }
-  }
-
-  @Test public void post() {
-    class Example {
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Body RequestBody body) {
-        return null;
-      }
-    }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
-    Request request = buildRequest(Example.class, body);
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertBody(request.body(), "hi");
-  }
-
-  @Test public void put() {
-    class Example {
-      @PUT("/foo/bar/") //
-      Call<ResponseBody> method(@Body RequestBody body) {
-        return null;
-      }
-    }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
-    Request request = buildRequest(Example.class, body);
-    assertThat(request.method()).isEqualTo("PUT");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertBody(request.body(), "hi");
-  }
-
-  @Test public void patch() {
-    class Example {
-      @PATCH("/foo/bar/") //
-      Call<ResponseBody> method(@Body RequestBody body) {
-        return null;
-      }
-    }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
-    Request request = buildRequest(Example.class, body);
-    assertThat(request.method()).isEqualTo("PATCH");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertBody(request.body(), "hi");
-  }
-
-  @Test public void options() {
-    class Example {
-      @OPTIONS("/foo/bar/") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class);
-    assertThat(request.method()).isEqualTo("OPTIONS");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithPathParam() {
-    class Example {
-      @GET("/foo/bar/{ping}/") //
-      Call<ResponseBody> method(@Path("ping") String ping) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "po ng");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/po%20ng/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithUnusedAndInvalidNamedPathParam() {
-    class Example {
-      @GET("/foo/bar/{ping}/{kit,kat}/") //
-      Call<ResponseBody> method(@Path("ping") String ping) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "pong");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong/%7Bkit,kat%7D/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithEncodedPathParam() {
-    class Example {
-      @GET("/foo/bar/{ping}/") //
-      Call<ResponseBody> method(@Path(value = "ping", encoded = true) String ping) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "po%20ng");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/po%20ng/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithEncodedPathSegments() {
-    class Example {
-      @GET("/foo/bar/{ping}/") //
-      Call<ResponseBody> method(@Path(value = "ping", encoded = true) String ping) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "baz/pong/more");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/baz/pong/more/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithUnencodedPathSegmentsPreventsRequestSplitting() {
-    class Example {
-      @GET("/foo/bar/{ping}/") //
-      Call<ResponseBody> method(@Path(value = "ping", encoded = false) String ping) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "baz/\r\nheader: blue");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/baz%2F%0D%0Aheader:%20blue/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithEncodedPathStillPreventsRequestSplitting() {
-    class Example {
-      @GET("/foo/bar/{ping}/") //
-      Call<ResponseBody> method(@Path(value = "ping", encoded = true) String ping) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "baz/\r\npong");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/baz/pong/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void pathParamRequired() {
-    class Example {
-      @GET("/foo/bar/{ping}/") //
-      Call<ResponseBody> method(@Path("ping") String ping) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e.getMessage()).isEqualTo("Path parameter \"ping\" value must not be null.");
-    }
-  }
-
-  @Test public void getWithQueryParam() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method(@Query("ping") String ping) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "pong");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?ping=pong");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithEncodedQueryParam() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method(@Query(value = "pi%20ng", encoded = true) String ping) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "p%20o%20n%20g");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?pi%20ng=p%20o%20n%20g");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void queryParamOptionalOmitsQuery() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method(@Query("ping") String ping) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, new Object[] { null });
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-  }
-
-  @Test public void queryParamOptional() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method(@Query("foo") String foo, @Query("ping") String ping,
-          @Query("kit") String kit) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "bar", null, "kat");
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?foo=bar&kit=kat");
-  }
-
-  @Test public void getWithQueryUrlAndParam() {
-    class Example {
-      @GET("/foo/bar/?hi=mom") //
-      Call<ResponseBody> method(@Query("ping") String ping) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "pong");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?hi=mom&ping=pong");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithQuery() {
-    class Example {
-      @GET("/foo/bar/?hi=mom") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class);
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?hi=mom");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithPathAndQueryParam() {
-    class Example {
-      @GET("/foo/bar/{ping}/") //
-      Call<ResponseBody> method(@Path("ping") String ping, @Query("kit") String kit,
-          @Query("riff") String riff) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, "pong", "kat", "raff");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong/?kit=kat&riff=raff");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithQueryThenPathThrows() {
-    class Example {
-      @GET("/foo/bar/{ping}/") //
-      Call<ResponseBody> method(@Query("kit") String kit, @Path("ping") String ping) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, "kat", "pong");
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("A @Path parameter must not come after a @Query. (parameter #2)\n"
-          + "    for method Example.method");
-    }
-  }
-
-  @Test public void getWithPathAndQueryQuestionMarkParam() {
-    class Example {
-      @GET("/foo/bar/{ping}/") //
-      Call<ResponseBody> method(@Path("ping") String ping, @Query("kit") String kit) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, "pong?", "kat?");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong%3F/?kit=kat?");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithPathAndQueryAmpersandParam() {
-    class Example {
-      @GET("/foo/bar/{ping}/") //
-      Call<ResponseBody> method(@Path("ping") String ping, @Query("kit") String kit) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, "pong&", "kat&");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong&/?kit=kat%26");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithPathAndQueryHashParam() {
-    class Example {
-      @GET("/foo/bar/{ping}/") //
-      Call<ResponseBody> method(@Path("ping") String ping, @Query("kit") String kit) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, "pong#", "kat#");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong%23/?kit=kat%23");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithQueryParamList() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method(@Query("key") List<Object> keys) {
-        return null;
-      }
-    }
-
-    List<Object> values = Arrays.<Object>asList(1, 2, null, "three");
-    Request request = buildRequest(Example.class, values);
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?key=1&key=2&key=three");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithQueryParamArray() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method(@Query("key") Object[] keys) {
-        return null;
-      }
-    }
-
-    Object[] values = { 1, 2, null, "three" };
-    Request request = buildRequest(Example.class, new Object[] { values });
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?key=1&key=2&key=three");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithQueryParamPrimitiveArray() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method(@Query("key") int[] keys) {
-        return null;
-      }
-    }
-
-    int[] values = { 1, 2, 3 };
-    Request request = buildRequest(Example.class, new Object[] { values });
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?key=1&key=2&key=3");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithQueryParamMap() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method(@QueryMap Map<String, Object> query) {
-        return null;
-      }
-    }
-
-    Map<String, Object> params = new LinkedHashMap<>();
-    params.put("kit", "kat");
-    params.put("ping", "pong");
-
-    Request request = buildRequest(Example.class, params);
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?kit=kat&ping=pong");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithEncodedQueryParamMap() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method(@QueryMap(encoded = true) Map<String, Object> query) {
-        return null;
-      }
-    }
-
-    Map<String, Object> params = new LinkedHashMap<>();
-    params.put("kit", "k%20t");
-    params.put("pi%20ng", "p%20g");
-
-    Request request = buildRequest(Example.class, params);
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?kit=k%20t&pi%20ng=p%20g");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getAbsoluteUrl() {
-    class Example {
-      @GET("http://example2.com/foo/bar/")
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class);
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example2.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithStringUrl() {
-    class Example {
-      @GET
-      Call<ResponseBody> method(@Url String url) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, "foo/bar/");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithJavaUriUrl() {
-    class Example {
-      @GET
-      Call<ResponseBody> method(@Url URI url) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, URI.create("foo/bar/"));
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithStringUrlAbsolute() {
-    class Example {
-      @GET
-      Call<ResponseBody> method(@Url String url) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, "https://example2.com/foo/bar/");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("https://example2.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithJavaUriUrlAbsolute() {
-    class Example {
-      @GET
-      Call<ResponseBody> method(@Url URI url) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, URI.create("https://example2.com/foo/bar/"));
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("https://example2.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithUrlAbsoluteSameHost() {
-    class Example {
-      @GET
-      Call<ResponseBody> method(@Url String url) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, "http://example.com/foo/bar/");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithHttpUrl() {
-    class Example {
-      @GET
-      Call<ResponseBody> method(@Url HttpUrl url) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, HttpUrl.parse("http://example.com/foo/bar/"));
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url()).isEqualTo(HttpUrl.parse("http://example.com/foo/bar/"));
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithNullUrl() {
-    class Example {
-      @GET
-      Call<ResponseBody> method(@Url HttpUrl url) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, (HttpUrl) null);
-      fail();
-    } catch (NullPointerException expected) {
-      assertThat(expected).hasMessage("@Url parameter is null.");
-    }
-  }
-
-  @Test public void getWithNonStringUrlThrows() {
-    class Example {
-      @GET
-      Call<ResponseBody> method(@Url Object url) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, "foo/bar");
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@Url must be okhttp3.HttpUrl, String, java.net.URI, or android.net.Uri type."
-              + " (parameter #1)\n"
-              + "    for method Example.method");
-    }
-  }
-
-  @Test public void getUrlAndUrlParamThrows() {
-    class Example {
-      @GET("foo/bar")
-      Call<ResponseBody> method(@Url Object url) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, "foo/bar");
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("@Url cannot be used with @GET URL (parameter #1)\n"
-          + "    for method Example.method");
-    }
-  }
-
-  @Test public void getWithoutUrlThrows() {
-    class Example {
-      @GET
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Missing either @GET URL or @Url parameter.\n"
-          + "    for method Example.method");
-    }
-  }
-
-  @Test public void getWithUrlThenPathThrows() {
-    class Example {
-      @GET
-      Call<ResponseBody> method(@Url String url, @Path("hey") String hey) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, "foo/bar");
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("@Path parameters may not be used with @Url. (parameter #2)\n"
-          + "    for method Example.method");
-    }
-  }
-
-  @Test public void getWithPathThenUrlThrows() {
-    class Example {
-      @GET
-      Call<ResponseBody> method(@Path("hey") String hey, @Url Object url) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, "foo/bar");
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("@Path can only be used with relative url on @GET (parameter #1)\n"
-          + "    for method Example.method");
-    }
-  }
-
-  @Test public void getWithQueryThenUrlThrows() {
-    class Example {
-      @GET("foo/bar")
-      Call<ResponseBody> method(@Query("hey") String hey, @Url Object url) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, "hey", "foo/bar/");
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("A @Url parameter must not come after a @Query (parameter #2)\n"
-          + "    for method Example.method");
-    }
-  }
-
-  @Test public void getWithUrlThenQuery() {
-    class Example {
-      @GET
-      Call<ResponseBody> method(@Url String url, @Query("hey") String hey) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, "foo/bar/", "hey!");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?hey=hey!");
-  }
-
-  @Test public void postWithUrl() {
-    class Example {
-      @POST
-      Call<ResponseBody> method(@Url String url, @Body RequestBody body) {
-        return null;
-      }
-    }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
-    Request request = buildRequest(Example.class, "http://example.com/foo/bar", body);
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar");
-    assertBody(request.body(), "hi");
-  }
-
-  @Test public void normalPostWithPathParam() {
-    class Example {
-      @POST("/foo/bar/{ping}/") //
-      Call<ResponseBody> method(@Path("ping") String ping, @Body RequestBody body) {
-        return null;
-      }
-    }
-    RequestBody body = RequestBody.create(TEXT_PLAIN, "Hi!");
-    Request request = buildRequest(Example.class, "pong", body);
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong/");
-    assertBody(request.body(), "Hi!");
-  }
-
-  @Test public void emptyBody() {
-    class Example {
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class);
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertBody(request.body(), "");
-  }
-
-  @Ignore("https://github.com/square/okhttp/issues/229")
-  @Test public void customMethodEmptyBody() {
-    class Example {
-      @HTTP(method = "CUSTOM", path = "/foo/bar/", hasBody = true) //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class);
-    assertThat(request.method()).isEqualTo("CUSTOM");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertBody(request.body(), "");
-  }
-
-  @Test public void bodyResponseBody() {
-    class Example {
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Body RequestBody body) {
-        return null;
-      }
-    }
-    RequestBody body = RequestBody.create(TEXT_PLAIN, "hi");
-    Request request = buildRequest(Example.class, body);
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertBody(request.body(), "hi");
-  }
-
-  @Test public void bodyRequired() {
-    class Example {
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Body RequestBody body) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e.getMessage()).isEqualTo("Body parameter value must not be null.");
-    }
-  }
-
-  @Test public void bodyWithPathParams() {
-    class Example {
-      @POST("/foo/bar/{ping}/{kit}/") //
-      Call<ResponseBody> method(@Path("ping") String ping, @Body RequestBody body, @Path("kit") String kit) {
-        return null;
-      }
-    }
-    RequestBody body = RequestBody.create(TEXT_PLAIN, "Hi!");
-    Request request = buildRequest(Example.class, "pong", body, "kat");
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong/kat/");
-    assertBody(request.body(), "Hi!");
-  }
-
-  @Test public void simpleMultipart() throws IOException {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part("ping") String ping, @Part("kit") RequestBody kit) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, "pong", RequestBody.create(
-        MediaType.parse("text/plain"), "kat"));
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-
-    RequestBody body = request.body();
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    String bodyString = buffer.readUtf8();
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"ping\"\r\n")
-        .contains("\r\npong\r\n--");
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"kit\"")
-        .contains("\r\nkat\r\n--");
-  }
-
-  @Test public void multipartArray() throws IOException {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part("ping") String[] ping) {
-        return null;
-      }
-    }
-
-    Request request =
-        buildRequest(Example.class, new Object[] { new String[] { "pong1", "pong2" } });
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-
-    RequestBody body = request.body();
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    String bodyString = buffer.readUtf8();
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"ping\"\r\n")
-        .contains("\r\npong1\r\n--");
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"ping\"")
-        .contains("\r\npong2\r\n--");
-  }
-
-  @Test public void multipartRequiresName() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part RequestBody part) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@Part annotation must supply a name or use MultipartBody.Part parameter type. (parameter #1)\n"
-              + "    for method Example.method");
-    }
-  }
-
-  @Test public void multipartIterableRequiresName() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part List<RequestBody> part) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@Part annotation must supply a name or use MultipartBody.Part parameter type. (parameter #1)\n"
-              + "    for method Example.method");
-    }
-  }
-
-  @Test public void multipartArrayRequiresName() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part RequestBody[] part) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@Part annotation must supply a name or use MultipartBody.Part parameter type. (parameter #1)\n"
-              + "    for method Example.method");
-    }
-  }
-
-  @Test public void multipartOkHttpPartForbidsName() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part("name") MultipartBody.Part part) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@Part parameters using the MultipartBody.Part must not include a part name in the annotation. (parameter #1)\n"
-              + "    for method Example.method");
-    }
-  }
-
-  @Test public void multipartOkHttpPart() throws IOException {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part MultipartBody.Part part) {
-        return null;
-      }
-    }
-
-    MultipartBody.Part part = MultipartBody.Part.createFormData("kit", "kat");
-    Request request = buildRequest(Example.class, part);
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-
-    RequestBody body = request.body();
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    String bodyString = buffer.readUtf8();
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"kit\"\r\n")
-        .contains("\r\nkat\r\n--");
-  }
-
-  @Test public void multipartOkHttpIterablePart() throws IOException {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part List<MultipartBody.Part> part) {
-        return null;
-      }
-    }
-
-    MultipartBody.Part part1 = MultipartBody.Part.createFormData("foo", "bar");
-    MultipartBody.Part part2 = MultipartBody.Part.createFormData("kit", "kat");
-    Request request = buildRequest(Example.class, Arrays.asList(part1, part2));
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-
-    RequestBody body = request.body();
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    String bodyString = buffer.readUtf8();
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"foo\"\r\n")
-        .contains("\r\nbar\r\n--");
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"kit\"\r\n")
-        .contains("\r\nkat\r\n--");
-  }
-
-  @Test public void multipartOkHttpArrayPart() throws IOException {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part MultipartBody.Part[] part) {
-        return null;
-      }
-    }
-
-    MultipartBody.Part part1 = MultipartBody.Part.createFormData("foo", "bar");
-    MultipartBody.Part part2 = MultipartBody.Part.createFormData("kit", "kat");
-    Request request =
-        buildRequest(Example.class, new Object[] { new MultipartBody.Part[] { part1, part2 } });
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-
-    RequestBody body = request.body();
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    String bodyString = buffer.readUtf8();
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"foo\"\r\n")
-        .contains("\r\nbar\r\n--");
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"kit\"\r\n")
-        .contains("\r\nkat\r\n--");
-  }
-
-  @Test public void multipartOkHttpPartWithFilename() throws IOException {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part MultipartBody.Part part) {
-        return null;
-      }
-    }
-
-    MultipartBody.Part part =
-        MultipartBody.Part.createFormData("kit", "kit.txt", RequestBody.create(null, "kat"));
-    Request request = buildRequest(Example.class, part);
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-
-    RequestBody body = request.body();
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    String bodyString = buffer.readUtf8();
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"kit\"; filename=\"kit.txt\"\r\n")
-        .contains("\r\nkat\r\n--");
-  }
-
-  @Test public void multipartIterable() throws IOException {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part("ping") List<String> ping) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, Arrays.asList("pong1", "pong2"));
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-
-    RequestBody body = request.body();
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    String bodyString = buffer.readUtf8();
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"ping\"\r\n")
-        .contains("\r\npong1\r\n--");
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"ping\"")
-        .contains("\r\npong2\r\n--");
-  }
-
-  @Test public void multipartIterableOkHttpPart() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part("ping") List<MultipartBody.Part> part) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@Part parameters using the MultipartBody.Part must not include a part name in the annotation. (parameter #1)\n"
-              + "    for method Example.method");
-    }
-  }
-
-  @Test public void multipartArrayOkHttpPart() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part("ping") MultipartBody.Part[] part) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@Part parameters using the MultipartBody.Part must not include a part name in the annotation. (parameter #1)\n"
-              + "    for method Example.method");
-    }
-  }
-
-  @Test public void multipartWithEncoding() throws IOException {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part(value = "ping", encoding = "8-bit") String ping,
-          @Part(value = "kit", encoding = "7-bit") RequestBody kit) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, "pong", RequestBody.create(
-        MediaType.parse("text/plain"), "kat"));
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-
-    RequestBody body = request.body();
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    String bodyString = buffer.readUtf8();
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"ping\"\r\n")
-        .contains("Content-Transfer-Encoding: 8-bit")
-        .contains("\r\npong\r\n--");
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"kit\"")
-        .contains("Content-Transfer-Encoding: 7-bit")
-        .contains("\r\nkat\r\n--");
-  }
-
-  @Test public void multipartPartMap() throws IOException {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@PartMap Map<String, RequestBody> parts) {
-        return null;
-      }
-    }
-
-    Map<String, RequestBody> params = new LinkedHashMap<>();
-    params.put("ping", RequestBody.create(null, "pong"));
-    params.put("kit", RequestBody.create(null, "kat"));
-
-    Request request = buildRequest(Example.class, params);
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-
-    RequestBody body = request.body();
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    String bodyString = buffer.readUtf8();
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"ping\"\r\n")
-        .contains("\r\npong\r\n--");
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"kit\"")
-        .contains("\r\nkat\r\n--");
-  }
-
-  @Test public void multipartPartMapWithEncoding() throws IOException {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@PartMap(encoding = "8-bit") Map<String, RequestBody> parts) {
-        return null;
-      }
-    }
-
-    Map<String, RequestBody> params = new LinkedHashMap<>();
-    params.put("ping", RequestBody.create(null, "pong"));
-    params.put("kit", RequestBody.create(null, "kat"));
-
-    Request request = buildRequest(Example.class, params);
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-
-    RequestBody body = request.body();
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    String bodyString = buffer.readUtf8();
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"ping\"\r\n")
-        .contains("Content-Transfer-Encoding: 8-bit")
-        .contains("\r\npong\r\n--");
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"kit\"")
-        .contains("Content-Transfer-Encoding: 8-bit")
-        .contains("\r\nkat\r\n--");
-  }
-
-  @Test public void multipartPartMapRejectsNonStringKeys() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@PartMap Map<Object, RequestBody> parts) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@PartMap keys must be of type String: class java.lang.Object (parameter #1)\n"
-              + "    for method Example.method");
-    }
-  }
-
-  @Test public void multipartPartMapRejectsOkHttpPartValues() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@PartMap Map<String, MultipartBody.Part> parts) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@PartMap values cannot be MultipartBody.Part. Use @Part List<Part> or a different value type instead. (parameter #1)\n"
-              + "    for method Example.method");
-    }
-  }
-
-  @Test public void multipartPartMapRejectsNull() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@PartMap Map<String, RequestBody> parts) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Part map was null.");
-    }
-  }
-
-  @Test public void multipartPartMapRejectsNullKeys() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@PartMap Map<String, RequestBody> parts) {
-        return null;
-      }
-    }
-
-    Map<String, RequestBody> params = new LinkedHashMap<>();
-    params.put("ping", RequestBody.create(null, "pong"));
-    params.put(null, RequestBody.create(null, "kat"));
-
-    try {
-      buildRequest(Example.class, params);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Part map contained null key.");
-    }
-  }
-
-  @Test public void multipartPartMapRejectsNullValues() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@PartMap Map<String, RequestBody> parts) {
-        return null;
-      }
-    }
-
-    Map<String, RequestBody> params = new LinkedHashMap<>();
-    params.put("ping", RequestBody.create(null, "pong"));
-    params.put("kit", null);
-
-    try {
-      buildRequest(Example.class, params);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Part map contained null value for key 'kit'.");
-    }
-  }
-
-  @Test public void multipartPartMapMustBeMap() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@PartMap List<Object> parts) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, Collections.emptyList());
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@PartMap parameter type must be Map. (parameter #1)\n    for method Example.method");
-    }
-  }
-
-  @Test public void multipartPartMapSupportsSubclasses() throws IOException {
-    class Foo extends HashMap<String, String> {
-    }
-
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@PartMap Foo parts) {
-        return null;
-      }
-    }
-
-    Foo foo = new Foo();
-    foo.put("hello", "world");
-
-    Request request = buildRequest(Example.class, foo);
-    Buffer buffer = new Buffer();
-    request.body().writeTo(buffer);
-    assertThat(buffer.readUtf8())
-        .contains("name=\"hello\"")
-        .contains("\r\n\r\nworld\r\n--");
-  }
-
-  @Test public void multipartNullRemovesPart() throws IOException {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part("ping") String ping, @Part("fizz") String fizz) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "pong", null);
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-
-    RequestBody body = request.body();
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    String bodyString = buffer.readUtf8();
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"ping\"")
-        .contains("\r\npong\r\n--");
-  }
-
-  @Test public void multipartPartOptional() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part("ping") RequestBody ping) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e.getMessage()).isEqualTo("Multipart body must have at least one part.");
-    }
-  }
-
-  @Test public void simpleFormEncoded() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/foo") //
-      Call<ResponseBody> method(@Field("foo") String foo, @Field("ping") String ping) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "bar", "pong");
-    assertBody(request.body(), "foo=bar&ping=pong");
-  }
-
-  @Test public void formEncodedWithEncodedNameFieldParam() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/foo") //
-      Call<ResponseBody> method(@Field(value = "na%20me", encoded = true) String foo) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "ba%20r");
-    assertBody(request.body(), "na%20me=ba%20r");
-  }
-
-  @Test public void formEncodedFieldOptional() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/foo") //
-      Call<ResponseBody> method(@Field("foo") String foo, @Field("ping") String ping,
-          @Field("kit") String kit) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "bar", null, "kat");
-    assertBody(request.body(), "foo=bar&kit=kat");
-  }
-
-  @Test public void formEncodedFieldList() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/foo") //
-      Call<ResponseBody> method(@Field("foo") List<Object> fields, @Field("kit") String kit) {
-        return null;
-      }
-    }
-
-    List<Object> values = Arrays.<Object>asList("foo", "bar", null, 3);
-    Request request = buildRequest(Example.class, values, "kat");
-    assertBody(request.body(), "foo=foo&foo=bar&foo=3&kit=kat");
-  }
-
-  @Test public void formEncodedFieldArray() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/foo") //
-      Call<ResponseBody> method(@Field("foo") Object[] fields, @Field("kit") String kit) {
-        return null;
-      }
-    }
-
-    Object[] values = { 1, 2, null, "three" };
-    Request request = buildRequest(Example.class, values, "kat");
-    assertBody(request.body(), "foo=1&foo=2&foo=three&kit=kat");
-  }
-
-  @Test public void formEncodedFieldPrimitiveArray() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/foo") //
-      Call<ResponseBody> method(@Field("foo") int[] fields, @Field("kit") String kit) {
-        return null;
-      }
-    }
-
-    int[] values = { 1, 2, 3 };
-    Request request = buildRequest(Example.class, values, "kat");
-    assertBody(request.body(), "foo=1&foo=2&foo=3&kit=kat");
-  }
-
-  @Test public void formEncodedWithEncodedNameFieldParamMap() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/foo") //
-      Call<ResponseBody> method(@FieldMap(encoded = true) Map<String, Object> fieldMap) {
-        return null;
-      }
-    }
-
-    Map<String, Object> fieldMap = new LinkedHashMap<>();
-    fieldMap.put("k%20it", "k%20at");
-    fieldMap.put("pin%20g", "po%20ng");
-
-    Request request = buildRequest(Example.class, fieldMap);
-    assertBody(request.body(), "k%20it=k%20at&pin%20g=po%20ng");
-  }
-
-  @Test public void formEncodedFieldMap() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/foo") //
-      Call<ResponseBody> method(@FieldMap Map<String, Object> fieldMap) {
-        return null;
-      }
-    }
-
-    Map<String, Object> fieldMap = new LinkedHashMap<>();
-    fieldMap.put("kit", "kat");
-    fieldMap.put("ping", "pong");
-
-    Request request = buildRequest(Example.class, fieldMap);
-    assertBody(request.body(), "kit=kat&ping=pong");
-  }
-
-  @Test public void fieldMapRejectsNull() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/") //
-      Call<ResponseBody> method(@FieldMap Map<String, Object> a) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Field map was null.");
-    }
-  }
-
-  @Test public void fieldMapRejectsNullKeys() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/") //
-      Call<ResponseBody> method(@FieldMap Map<String, Object> a) {
-        return null;
-      }
-    }
-
-    Map<String, Object> fieldMap = new LinkedHashMap<>();
-    fieldMap.put("kit", "kat");
-    fieldMap.put(null, "pong");
-
-    try {
-      buildRequest(Example.class, fieldMap);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Field map contained null key.");
-    }
-  }
-
-  @Test public void fieldMapRejectsNullValues() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/") //
-      Call<ResponseBody> method(@FieldMap Map<String, Object> a) {
-        return null;
-      }
-    }
-
-    Map<String, Object> fieldMap = new LinkedHashMap<>();
-    fieldMap.put("kit", "kat");
-    fieldMap.put("foo", null);
-
-    try {
-      buildRequest(Example.class, fieldMap);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Field map contained null value for key 'foo'.");
-    }
-  }
-
-  @Test public void fieldMapMustBeAMap() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/") //
-      Call<ResponseBody> method(@FieldMap List<String> a) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@FieldMap parameter type must be Map. (parameter #1)\n    for method Example.method");
-    }
-  }
-
-  @Test public void fieldMapSupportsSubclasses() throws IOException {
-    class Foo extends HashMap<String, String> {
-    }
-
-    class Example {
-      @FormUrlEncoded //
-      @POST("/") //
-      Call<ResponseBody> method(@FieldMap Foo a) {
-        return null;
-      }
-    }
-
-    Foo foo = new Foo();
-    foo.put("hello", "world");
-
-    Request request = buildRequest(Example.class, foo);
-    Buffer buffer = new Buffer();
-    request.body().writeTo(buffer);
-    assertThat(buffer.readUtf8()).isEqualTo("hello=world");
-  }
-
-  @Test public void simpleHeaders() {
-    class Example {
-      @GET("/foo/bar/")
-      @Headers({
-          "ping: pong",
-          "kit: kat"
-      })
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class);
-    assertThat(request.method()).isEqualTo("GET");
-    okhttp3.Headers headers = request.headers();
-    assertThat(headers.size()).isEqualTo(2);
-    assertThat(headers.get("ping")).isEqualTo("pong");
-    assertThat(headers.get("kit")).isEqualTo("kat");
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void headerParamToString() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method(@Header("kit") BigInteger kit) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, new BigInteger("1234"));
-    assertThat(request.method()).isEqualTo("GET");
-    okhttp3.Headers headers = request.headers();
-    assertThat(headers.size()).isEqualTo(1);
-    assertThat(headers.get("kit")).isEqualTo("1234");
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void headerParam() {
-    class Example {
-      @GET("/foo/bar/") //
-      @Headers("ping: pong") //
-      Call<ResponseBody> method(@Header("kit") String kit) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "kat");
-    assertThat(request.method()).isEqualTo("GET");
-    okhttp3.Headers headers = request.headers();
-    assertThat(headers.size()).isEqualTo(2);
-    assertThat(headers.get("ping")).isEqualTo("pong");
-    assertThat(headers.get("kit")).isEqualTo("kat");
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void headerParamList() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method(@Header("foo") List<String> kit) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, Arrays.asList("bar", null, "baz"));
-    assertThat(request.method()).isEqualTo("GET");
-    okhttp3.Headers headers = request.headers();
-    assertThat(headers.size()).isEqualTo(2);
-    assertThat(headers.values("foo")).containsExactly("bar", "baz");
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void headerParamArray() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method(@Header("foo") String[] kit) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, (Object) new String[] { "bar", null, "baz" });
-    assertThat(request.method()).isEqualTo("GET");
-    okhttp3.Headers headers = request.headers();
-    assertThat(headers.size()).isEqualTo(2);
-    assertThat(headers.values("foo")).containsExactly("bar", "baz");
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void contentTypeAnnotationHeaderOverrides() {
-    class Example {
-      @POST("/") //
-      @Headers("Content-Type: text/not-plain") //
-      Call<ResponseBody> method(@Body RequestBody body) {
-        return null;
-      }
-    }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
-    Request request = buildRequest(Example.class, body);
-    assertThat(request.body().contentType().toString()).isEqualTo("text/not-plain");
-  }
-
-  @Test public void malformedContentTypeHeaderThrows() {
-    class Example {
-      @POST("/") //
-      @Headers("Content-Type: hello, world!") //
-      Call<ResponseBody> method(@Body RequestBody body) {
-        return null;
-      }
-    }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
-    try {
-      buildRequest(Example.class, body);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Malformed content type: hello, world!\n"
-          + "    for method Example.method");
-    }
-  }
-
-  @Test public void contentTypeAnnotationHeaderAddsHeaderWithNoBody() {
-    class Example {
-      @DELETE("/") //
-      @Headers("Content-Type: text/not-plain") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class);
-    assertThat(request.headers().get("Content-Type")).isEqualTo("text/not-plain");
-  }
-
-  @Test public void contentTypeParameterHeaderOverrides() {
-    class Example {
-      @POST("/") //
-      Call<ResponseBody> method(@Header("Content-Type") String contentType, @Body RequestBody body) {
-        return null;
-      }
-    }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "Plain");
-    Request request = buildRequest(Example.class, "text/not-plain", body);
-    assertThat(request.body().contentType().toString()).isEqualTo("text/not-plain");
-  }
-
-  @Test public void malformedContentTypeParameterThrows() {
-    class Example {
-      @POST("/") //
-      Call<ResponseBody> method(@Header("Content-Type") String contentType, @Body RequestBody body) {
-        return null;
-      }
-    }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
-    try {
-      buildRequest(Example.class, "hello, world!", body);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Malformed content type: hello, world!");
-    }
-  }
-
-  @Test public void malformedAnnotationRelativeUrlThrows() {
-    class Example {
-      @GET("ftp://example.org")
-      Call<ResponseBody> get() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Malformed URL. Base: http://example.com/, Relative: ftp://example.org");
-    }
-  }
-
-  @Test public void malformedParameterRelativeUrlThrows() {
-    class Example {
-      @GET
-      Call<ResponseBody> get(@Url String relativeUrl) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class, "ftp://example.org");
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Malformed URL. Base: http://example.com/, Relative: ftp://example.org");
-    }
-  }
-
-  private static void assertBody(RequestBody body, String expected) {
-    assertThat(body).isNotNull();
-    Buffer buffer = new Buffer();
-    try {
-      body.writeTo(buffer);
-      assertThat(buffer.readUtf8()).isEqualTo(expected);
-    } catch (IOException e) {
-      throw new RuntimeException(e);
-    }
-  }
-
-  static Request buildRequest(Class<?> cls, Object... args) {
-    final AtomicReference<Request> requestRef = new AtomicReference<>();
-    okhttp3.Call.Factory callFactory = new okhttp3.Call.Factory() {
-      @Override public okhttp3.Call newCall(Request request) {
-        requestRef.set(request);
-        throw new UnsupportedOperationException("Not implemented");
-      }
-    };
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addConverterFactory(new ToStringConverterFactory())
-        .callFactory(callFactory)
-        .build();
-
-    Method method = TestingUtils.onlyMethod(cls);
-    ServiceMethod<?> serviceMethod = retrofit.loadServiceMethod(method);
-    OkHttpCall<?> okHttpCall = new OkHttpCall<>(serviceMethod, args);
-    Call<?> call = (Call<?>) serviceMethod.callAdapter.adapt(okHttpCall);
-    try {
-      call.execute();
-      throw new AssertionError();
-    } catch (UnsupportedOperationException ignored) {
-      return requestRef.get();
-    } catch (RuntimeException e) {
-      throw e;
-    } catch (Exception e) {
-      throw new AssertionError(e);
-    }
-  }
-}
diff --git a/retrofit/src/test/java/retrofit2/ResponseTest.java b/retrofit/src/test/java/retrofit2/ResponseTest.java
deleted file mode 100644
index 3d059b8ad..000000000
--- a/retrofit/src/test/java/retrofit2/ResponseTest.java
+++ /dev/null
@@ -1,181 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2;
-
-import okhttp3.Headers;
-import okhttp3.Protocol;
-import okhttp3.ResponseBody;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class ResponseTest {
-  private final okhttp3.Response successResponse = new okhttp3.Response.Builder() //
-      .code(200)
-      .message("OK")
-      .protocol(Protocol.HTTP_1_1)
-      .request(new okhttp3.Request.Builder().url("http://localhost").build())
-      .build();
-  private final okhttp3.Response errorResponse = new okhttp3.Response.Builder() //
-      .code(400)
-      .message("Broken!")
-      .protocol(Protocol.HTTP_1_1)
-      .request(new okhttp3.Request.Builder().url("http://localhost").build())
-      .build();
-
-  @Test public void success() {
-    Object body = new Object();
-    Response<Object> response = Response.success(body);
-    assertThat(response.raw()).isNotNull();
-    assertThat(response.code()).isEqualTo(200);
-    assertThat(response.message()).isEqualTo("OK");
-    assertThat(response.headers().size()).isZero();
-    assertThat(response.isSuccessful()).isTrue();
-    assertThat(response.body()).isSameAs(body);
-    assertThat(response.errorBody()).isNull();
-  }
-
-  @Test public void successNullAllowed() {
-    Response<Object> response = Response.success(null);
-    assertThat(response.isSuccessful()).isTrue();
-    assertThat(response.body()).isNull();
-  }
-
-  @Test public void successWithHeaders() {
-    Object body = new Object();
-    Headers headers = Headers.of("foo", "bar");
-    Response<Object> response = Response.success(body, headers);
-    assertThat(response.raw()).isNotNull();
-    assertThat(response.code()).isEqualTo(200);
-    assertThat(response.message()).isEqualTo("OK");
-    assertThat(response.headers().toMultimap()).isEqualTo(headers.toMultimap());
-    assertThat(response.isSuccessful()).isTrue();
-    assertThat(response.body()).isSameAs(body);
-    assertThat(response.errorBody()).isNull();
-  }
-
-  @Test public void successWithNullHeadersThrows() {
-    try {
-      Response.success("", (okhttp3.Headers) null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("headers == null");
-    }
-  }
-
-  @Test public void successWithRawResponse() {
-    Object body = new Object();
-    Response<Object> response = Response.success(body, successResponse);
-    assertThat(response.raw()).isSameAs(successResponse);
-    assertThat(response.code()).isEqualTo(200);
-    assertThat(response.message()).isEqualTo("OK");
-    assertThat(response.headers().size()).isZero();
-    assertThat(response.isSuccessful()).isTrue();
-    assertThat(response.body()).isSameAs(body);
-    assertThat(response.errorBody()).isNull();
-  }
-
-  @Test public void successWithNullRawResponseThrows() {
-    try {
-      Response.success("", (okhttp3.Response) null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("rawResponse == null");
-    }
-  }
-
-  @Test public void successWithErrorRawResponseThrows() {
-    try {
-      Response.success("", errorResponse);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("rawResponse must be successful response");
-    }
-  }
-
-  @Test public void error() {
-    ResponseBody errorBody = ResponseBody.create(null, "Broken!");
-    Response<?> response = Response.error(400, errorBody);
-    assertThat(response.raw()).isNotNull();
-    assertThat(response.code()).isEqualTo(400);
-    assertThat(response.message()).isNull();
-    assertThat(response.headers().size()).isZero();
-    assertThat(response.isSuccessful()).isFalse();
-    assertThat(response.body()).isNull();
-    assertThat(response.errorBody()).isSameAs(errorBody);
-  }
-
-  @Test public void nullErrorThrows() {
-    try {
-      Response.error(400, null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("body == null");
-    }
-  }
-
-  @Test public void errorWithSuccessCodeThrows() {
-    ResponseBody errorBody = ResponseBody.create(null, "Broken!");
-    try {
-      Response.error(200, errorBody);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("code < 400: 200");
-    }
-  }
-
-  @Test public void errorWithRawResponse() {
-    ResponseBody errorBody = ResponseBody.create(null, "Broken!");
-    Response<?> response = Response.error(errorBody, errorResponse);
-    assertThat(response.raw()).isSameAs(errorResponse);
-    assertThat(response.code()).isEqualTo(400);
-    assertThat(response.message()).isEqualTo("Broken!");
-    assertThat(response.headers().size()).isZero();
-    assertThat(response.isSuccessful()).isFalse();
-    assertThat(response.body()).isNull();
-    assertThat(response.errorBody()).isSameAs(errorBody);
-  }
-
-  @Test public void nullErrorWithRawResponseThrows() {
-    try {
-      Response.error(null, errorResponse);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("body == null");
-    }
-  }
-
-  @Test public void errorWithNullRawResponseThrows() {
-    ResponseBody errorBody = ResponseBody.create(null, "Broken!");
-    try {
-      Response.error(errorBody, null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("rawResponse == null");
-    }
-  }
-
-  @Test public void errorWithSuccessRawResponseThrows() {
-    ResponseBody errorBody = ResponseBody.create(null, "Broken!");
-    try {
-      Response.error(errorBody, successResponse);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("rawResponse should not be successful response");
-    }
-  }
-}
diff --git a/retrofit/src/test/java/retrofit2/RetrofitTest.java b/retrofit/src/test/java/retrofit2/RetrofitTest.java
deleted file mode 100644
index 41036c987..000000000
--- a/retrofit/src/test/java/retrofit2/RetrofitTest.java
+++ /dev/null
@@ -1,1304 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2;
-
-import java.io.IOException;
-import java.lang.annotation.Annotation;
-import java.lang.annotation.Retention;
-import java.lang.reflect.ParameterizedType;
-import java.lang.reflect.Type;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.Executor;
-import java.util.concurrent.Executors;
-import java.util.concurrent.Future;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.atomic.AtomicReference;
-import okhttp3.HttpUrl;
-import okhttp3.MediaType;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.RequestBody;
-import okhttp3.ResponseBody;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import org.junit.Rule;
-import org.junit.Test;
-import retrofit2.helpers.DelegatingCallAdapterFactory;
-import retrofit2.helpers.NonMatchingCallAdapterFactory;
-import retrofit2.helpers.NonMatchingConverterFactory;
-import retrofit2.helpers.ToStringConverterFactory;
-import retrofit2.http.Body;
-import retrofit2.http.GET;
-import retrofit2.http.POST;
-import retrofit2.http.Query;
-
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.doReturn;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.spy;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.verifyNoMoreInteractions;
-
-public final class RetrofitTest {
-  @Rule public final MockWebServer server = new MockWebServer();
-
-  interface CallMethod {
-    @GET("/") Call<String> disallowed();
-    @POST("/") Call<ResponseBody> disallowed(@Body String body);
-
-    @GET("/") Call<retrofit2.Response> badType1();
-    @GET("/") Call<okhttp3.Response> badType2();
-
-    @GET("/") Call<ResponseBody> getResponseBody();
-    @GET("/") Call<Void> getVoid();
-    @POST("/") Call<ResponseBody> postRequestBody(@Body RequestBody body);
-    @GET("/") Call<ResponseBody> queryString(@Query("foo") String foo);
-    @GET("/") Call<ResponseBody> queryObject(@Query("foo") Object foo);
-  }
-  interface FutureMethod {
-    @GET("/") Future<String> method();
-  }
-  interface Extending extends CallMethod {
-  }
-  interface StringService {
-    @GET("/") String get();
-  }
-  interface UnresolvableResponseType {
-    @GET("/") <T> Call<T> typeVariable();
-    @GET("/") <T extends ResponseBody> Call<T> typeVariableUpperBound();
-    @GET("/") <T> Call<List<Map<String, Set<T[]>>>> crazy();
-    @GET("/") Call<?> wildcard();
-    @GET("/") Call<? extends ResponseBody> wildcardUpperBound();
-  }
-  interface UnresolvableParameterType {
-    @POST("/") <T> Call<ResponseBody> typeVariable(@Body T body);
-    @POST("/") <T extends RequestBody> Call<ResponseBody> typeVariableUpperBound(@Body T body);
-    @POST("/") <T> Call<ResponseBody> crazy(@Body List<Map<String, Set<T[]>>> body);
-    @POST("/") Call<ResponseBody> wildcard(@Body List<?> body);
-    @POST("/") Call<ResponseBody> wildcardUpperBound(@Body List<? extends RequestBody> body);
-  }
-  interface VoidService {
-    @GET("/") void nope();
-  }
-  interface Annotated {
-    @GET("/") @Foo Call<String> method();
-    @POST("/") Call<ResponseBody> bodyParameter(@Foo @Body String param);
-    @GET("/") Call<ResponseBody> queryParameter(@Foo @Query("foo") Object foo);
-
-    @Retention(RUNTIME)
-    @interface Foo {}
-  }
-  interface MutableParameters {
-    @GET("/") Call<String> method(@Query("i") AtomicInteger value);
-  }
-
-  @SuppressWarnings("EqualsBetweenInconvertibleTypes") // We are explicitly testing this behavior.
-  @Test public void objectMethodsStillWork() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-    CallMethod example = retrofit.create(CallMethod.class);
-
-    assertThat(example.hashCode()).isNotZero();
-    assertThat(example.equals(this)).isFalse();
-    assertThat(example.toString()).isNotEmpty();
-  }
-
-  @Test public void interfaceWithExtendIsNotSupported() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-    try {
-      retrofit.create(Extending.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("API interfaces must not extend other interfaces.");
-    }
-  }
-
-  @Test public void responseTypeCannotBeRetrofitResponse() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-    CallMethod service = retrofit.create(CallMethod.class);
-    try {
-      service.badType1();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "'retrofit2.Response' is not a valid response body type. Did you mean ResponseBody?\n"
-              + "    for method CallMethod.badType1");
-    }
-  }
-
-  @Test public void responseTypeCannotBeOkHttpResponse() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-    CallMethod service = retrofit.create(CallMethod.class);
-    try {
-      service.badType2();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "'okhttp3.Response' is not a valid response body type. Did you mean ResponseBody?\n"
-              + "    for method CallMethod.badType2");
-    }
-  }
-
-  @Test public void voidReturnTypeNotAllowed() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-    VoidService service = retrofit.create(VoidService.class);
-
-    try {
-      service.nope();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessageStartingWith(
-          "Service methods cannot return void.\n    for method VoidService.nope");
-    }
-  }
-
-  @Test public void validateEagerlyDisabledByDefault() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-
-    // Should not throw exception about incorrect configuration of the VoidService
-    retrofit.create(VoidService.class);
-  }
-
-  @Test public void validateEagerlyDisabledByUser() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .validateEagerly(false)
-        .build();
-
-    // Should not throw exception about incorrect configuration of the VoidService
-    retrofit.create(VoidService.class);
-  }
-
-  @Test public void validateEagerlyFailsAtCreation() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .validateEagerly(true)
-        .build();
-
-    try {
-      retrofit.create(VoidService.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessageStartingWith(
-          "Service methods cannot return void.\n    for method VoidService.nope");
-    }
-  }
-
-  @Test public void callCallAdapterAddedByDefault() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-    CallMethod example = retrofit.create(CallMethod.class);
-    assertThat(example.getResponseBody()).isNotNull();
-  }
-
-  @Test public void callCallCustomAdapter() {
-    final AtomicBoolean factoryCalled = new AtomicBoolean();
-    final AtomicBoolean adapterCalled = new AtomicBoolean();
-    class MyCallAdapterFactory extends CallAdapter.Factory {
-      @Override public CallAdapter<?> get(final Type returnType, Annotation[] annotations,
-          Retrofit retrofit) {
-        factoryCalled.set(true);
-        if (getRawType(returnType) != Call.class) {
-          return null;
-        }
-        return new CallAdapter<Call<?>>() {
-          @Override public Type responseType() {
-            return getParameterUpperBound(0, (ParameterizedType) returnType);
-          }
-
-          @Override public <R> Call<R> adapt(Call<R> call) {
-            adapterCalled.set(true);
-            return call;
-          }
-        };
-      }
-    }
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addCallAdapterFactory(new MyCallAdapterFactory())
-        .build();
-    CallMethod example = retrofit.create(CallMethod.class);
-    assertThat(example.getResponseBody()).isNotNull();
-    assertThat(factoryCalled.get()).isTrue();
-    assertThat(adapterCalled.get()).isTrue();
-  }
-
-  @Test public void customCallAdapter() {
-    class GreetingCallAdapterFactory extends CallAdapter.Factory {
-      @Override public CallAdapter<String> get(Type returnType, Annotation[] annotations,
-          Retrofit retrofit) {
-        if (getRawType(returnType) != String.class) {
-          return null;
-        }
-        return new CallAdapter<String>() {
-          @Override public Type responseType() {
-            return String.class;
-          }
-
-          @Override public <R> String adapt(Call<R> call) {
-            return "Hi!";
-          }
-        };
-      }
-    }
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .addCallAdapterFactory(new GreetingCallAdapterFactory())
-        .build();
-    StringService example = retrofit.create(StringService.class);
-    assertThat(example.get()).isEqualTo("Hi!");
-  }
-
-  @Test public void methodAnnotationsPassedToCallAdapter() {
-    final AtomicReference<Annotation[]> annotationsRef = new AtomicReference<>();
-    class MyCallAdapterFactory extends CallAdapter.Factory {
-      @Override public CallAdapter<?> get(Type returnType, Annotation[] annotations,
-          Retrofit retrofit) {
-        annotationsRef.set(annotations);
-        return null;
-      }
-    }
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .addCallAdapterFactory(new MyCallAdapterFactory())
-        .build();
-    Annotated annotated = retrofit.create(Annotated.class);
-    annotated.method(); // Trigger internal setup.
-
-    Annotation[] annotations = annotationsRef.get();
-    assertThat(annotations).hasAtLeastOneElementOfType(Annotated.Foo.class);
-  }
-
-  @Test public void customCallAdapterMissingThrows() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-    FutureMethod example = retrofit.create(FutureMethod.class);
-    try {
-      example.method();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(""
-          + "Unable to create call adapter for java.util.concurrent.Future<java.lang.String>\n"
-          + "    for method FutureMethod.method");
-      assertThat(e.getCause()).hasMessage(""
-          + "Could not locate call adapter for java.util.concurrent.Future<java.lang.String>.\n"
-          + "  Tried:\n"
-          + "   * retrofit2.DefaultCallAdapterFactory");
-    }
-  }
-
-  @Test public void methodAnnotationsPassedToResponseBodyConverter() {
-    final AtomicReference<Annotation[]> annotationsRef = new AtomicReference<>();
-    class MyConverterFactory extends Converter.Factory {
-      @Override
-      public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-          Retrofit retrofit) {
-        annotationsRef.set(annotations);
-        return new ToStringConverterFactory().responseBodyConverter(type, annotations, retrofit);
-      }
-    }
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new MyConverterFactory())
-        .build();
-    Annotated annotated = retrofit.create(Annotated.class);
-    annotated.method(); // Trigger internal setup.
-
-    Annotation[] annotations = annotationsRef.get();
-    assertThat(annotations).hasAtLeastOneElementOfType(Annotated.Foo.class);
-  }
-
-  @Test public void methodAndParameterAnnotationsPassedToRequestBodyConverter() {
-    final AtomicReference<Annotation[]> parameterAnnotationsRef = new AtomicReference<>();
-    final AtomicReference<Annotation[]> methodAnnotationsRef = new AtomicReference<>();
-
-    class MyConverterFactory extends Converter.Factory {
-      @Override
-      public Converter<?, RequestBody> requestBodyConverter(Type type,
-          Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
-        parameterAnnotationsRef.set(parameterAnnotations);
-        methodAnnotationsRef.set(methodAnnotations);
-        return new ToStringConverterFactory().requestBodyConverter(type, parameterAnnotations,
-            methodAnnotations, retrofit);
-      }
-    }
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new MyConverterFactory())
-        .build();
-    Annotated annotated = retrofit.create(Annotated.class);
-    annotated.bodyParameter(null); // Trigger internal setup.
-
-    assertThat(parameterAnnotationsRef.get()).hasAtLeastOneElementOfType(Annotated.Foo.class);
-    assertThat(methodAnnotationsRef.get()).hasAtLeastOneElementOfType(POST.class);
-  }
-
-  @Test public void parameterAnnotationsPassedToStringConverter() {
-    final AtomicReference<Annotation[]> annotationsRef = new AtomicReference<>();
-    class MyConverterFactory extends Converter.Factory {
-      @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
-          Retrofit retrofit) {
-        annotationsRef.set(annotations);
-
-        return new Converter<Object, String>() {
-          @Override public String convert(Object value) throws IOException {
-            return String.valueOf(value);
-          }
-        };
-      }
-    }
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new MyConverterFactory())
-        .build();
-    Annotated annotated = retrofit.create(Annotated.class);
-    annotated.queryParameter(null); // Trigger internal setup.
-
-    Annotation[] annotations = annotationsRef.get();
-    assertThat(annotations).hasAtLeastOneElementOfType(Annotated.Foo.class);
-  }
-
-  @Test public void stringConverterCalledForString() {
-    final AtomicBoolean factoryCalled = new AtomicBoolean();
-    class MyConverterFactory extends Converter.Factory {
-      @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
-          Retrofit retrofit) {
-        factoryCalled.set(true);
-        return null;
-      }
-    }
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new MyConverterFactory())
-        .build();
-    CallMethod service = retrofit.create(CallMethod.class);
-    Call<ResponseBody> call = service.queryString(null);
-    assertThat(call).isNotNull();
-    assertThat(factoryCalled.get()).isTrue();
-  }
-
-  @Test public void stringConverterReturningNullResultsInDefault() {
-    final AtomicBoolean factoryCalled = new AtomicBoolean();
-    class MyConverterFactory extends Converter.Factory {
-      @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
-          Retrofit retrofit) {
-        factoryCalled.set(true);
-        return null;
-      }
-    }
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new MyConverterFactory())
-        .build();
-    CallMethod service = retrofit.create(CallMethod.class);
-    Call<ResponseBody> call = service.queryObject(null);
-    assertThat(call).isNotNull();
-    assertThat(factoryCalled.get()).isTrue();
-  }
-
-  @Test public void missingConverterThrowsOnNonRequestBody() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-    CallMethod example = retrofit.create(CallMethod.class);
-    try {
-      example.disallowed("Hi!");
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(""
-          + "Unable to create @Body converter for class java.lang.String (parameter #1)\n"
-          + "    for method CallMethod.disallowed");
-      assertThat(e.getCause()).hasMessage(""
-          + "Could not locate RequestBody converter for class java.lang.String.\n"
-          + "  Tried:\n"
-          + "   * retrofit2.BuiltInConverters");
-    }
-  }
-
-  @Test public void missingConverterThrowsOnNonResponseBody() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-    CallMethod example = retrofit.create(CallMethod.class);
-
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    try {
-      example.disallowed();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(""
-          + "Unable to create converter for class java.lang.String\n"
-          + "    for method CallMethod.disallowed");
-      assertThat(e.getCause()).hasMessage(""
-          + "Could not locate ResponseBody converter for class java.lang.String.\n"
-          + "  Tried:\n"
-          + "   * retrofit2.BuiltInConverters");
-    }
-  }
-
-  @Test public void requestBodyOutgoingAllowed() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-    CallMethod example = retrofit.create(CallMethod.class);
-
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    Response<ResponseBody> response = example.getResponseBody().execute();
-    assertThat(response.body().string()).isEqualTo("Hi");
-  }
-
-  @Test public void voidOutgoingAllowed() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-    CallMethod example = retrofit.create(CallMethod.class);
-
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    Response<Void> response = example.getVoid().execute();
-    assertThat(response.body()).isNull();
-  }
-
-  @Test public void voidResponsesArePooled() throws Exception {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-    CallMethod example = retrofit.create(CallMethod.class);
-
-    server.enqueue(new MockResponse().setBody("abc"));
-    server.enqueue(new MockResponse().setBody("def"));
-
-    example.getVoid().execute();
-    example.getVoid().execute();
-
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-  }
-
-  @Test public void responseBodyIncomingAllowed() throws IOException, InterruptedException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-    CallMethod example = retrofit.create(CallMethod.class);
-
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "Hey");
-    Response<ResponseBody> response = example.postRequestBody(body).execute();
-    assertThat(response.body().string()).isEqualTo("Hi");
-
-    assertThat(server.takeRequest().getBody().readUtf8()).isEqualTo("Hey");
-  }
-
-  @Test public void unresolvableResponseTypeThrows() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    UnresolvableResponseType example = retrofit.create(UnresolvableResponseType.class);
-
-    try {
-      example.typeVariable();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
-          + "retrofit2.Call<T>\n    for method UnresolvableResponseType.typeVariable");
-    }
-    try {
-      example.typeVariableUpperBound();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
-          + "retrofit2.Call<T>\n    for method UnresolvableResponseType.typeVariableUpperBound");
-    }
-    try {
-      example.crazy();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
-          + "retrofit2.Call<java.util.List<java.util.Map<java.lang.String, java.util.Set<T[]>>>>\n"
-          + "    for method UnresolvableResponseType.crazy");
-    }
-    try {
-      example.wildcard();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
-          + "retrofit2.Call<?>\n    for method UnresolvableResponseType.wildcard");
-    }
-    try {
-      example.wildcardUpperBound();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
-          + "retrofit2.Call<? extends okhttp3.ResponseBody>\n"
-          + "    for method UnresolvableResponseType.wildcardUpperBound");
-    }
-  }
-
-  @Test public void unresolvableParameterTypeThrows() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    UnresolvableParameterType example = retrofit.create(UnresolvableParameterType.class);
-
-    try {
-      example.typeVariable(null);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Parameter type must not include a type variable or wildcard: "
-          + "T (parameter #1)\n    for method UnresolvableParameterType.typeVariable");
-    }
-    try {
-      example.typeVariableUpperBound(null);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Parameter type must not include a type variable or wildcard: "
-          + "T (parameter #1)\n    for method UnresolvableParameterType.typeVariableUpperBound");
-    }
-    try {
-      example.crazy(null);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Parameter type must not include a type variable or wildcard: "
-          + "java.util.List<java.util.Map<java.lang.String, java.util.Set<T[]>>> (parameter #1)\n"
-          + "    for method UnresolvableParameterType.crazy");
-    }
-    try {
-      example.wildcard(null);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Parameter type must not include a type variable or wildcard: "
-          + "java.util.List<?> (parameter #1)\n    for method UnresolvableParameterType.wildcard");
-    }
-    try {
-      example.wildcardUpperBound(null);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Parameter type must not include a type variable or wildcard: "
-          + "java.util.List<? extends okhttp3.RequestBody> (parameter #1)\n"
-          + "    for method UnresolvableParameterType.wildcardUpperBound");
-    }
-  }
-
-  @Test public void baseUrlRequired() {
-    try {
-      new Retrofit.Builder().build();
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage("Base URL required.");
-    }
-  }
-
-  @Test public void baseUrlNullThrows() {
-    try {
-      new Retrofit.Builder().baseUrl((String) null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("baseUrl == null");
-    }
-    try {
-      new Retrofit.Builder().baseUrl((HttpUrl) null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("baseUrl == null");
-    }
-  }
-
-  @Test public void baseUrlInvalidThrows() {
-    try {
-      new Retrofit.Builder().baseUrl("ftp://foo/bar");
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Illegal URL: ftp://foo/bar");
-    }
-  }
-
-  @Test public void baseUrlNoTrailingSlashThrows() {
-    try {
-      new Retrofit.Builder().baseUrl("http://example.com/api");
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("baseUrl must end in /: http://example.com/api");
-    }
-    HttpUrl parsed = HttpUrl.parse("http://example.com/api");
-    try {
-      new Retrofit.Builder().baseUrl(parsed);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("baseUrl must end in /: http://example.com/api");
-    }
-  }
-
-  @Test public void baseUrlStringPropagated() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .build();
-    HttpUrl baseUrl = retrofit.baseUrl();
-    assertThat(baseUrl).isEqualTo(HttpUrl.parse("http://example.com/"));
-  }
-
-  @Test public void baseHttpUrlPropagated() {
-    HttpUrl url = HttpUrl.parse("http://example.com/");
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(url)
-        .build();
-    assertThat(retrofit.baseUrl()).isSameAs(url);
-  }
-
-  @Test public void clientNullThrows() {
-    try {
-      new Retrofit.Builder().client(null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("client == null");
-    }
-  }
-
-  @Test public void callFactoryDefault() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com")
-        .build();
-    assertThat(retrofit.callFactory()).isNotNull();
-  }
-
-  @Test public void callFactoryPropagated() {
-    okhttp3.Call.Factory callFactory = mock(okhttp3.Call.Factory.class);
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .callFactory(callFactory)
-        .build();
-    assertThat(retrofit.callFactory()).isSameAs(callFactory);
-  }
-
-  @Test public void callFactoryClientPropagated() {
-    OkHttpClient client = new OkHttpClient();
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .client(client)
-        .build();
-    assertThat(retrofit.callFactory()).isSameAs(client);
-  }
-
-  @Test public void callFactoryUsed() throws IOException {
-    okhttp3.Call.Factory callFactory = spy(new okhttp3.Call.Factory() {
-      @Override public okhttp3.Call newCall(Request request) {
-        return new OkHttpClient().newCall(request);
-      }
-    });
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .callFactory(callFactory)
-        .build();
-
-    server.enqueue(new MockResponse());
-
-    CallMethod service = retrofit.create(CallMethod.class);
-    service.getResponseBody().execute();
-    verify(callFactory).newCall(any(Request.class));
-    verifyNoMoreInteractions(callFactory);
-  }
-
-  @Test public void callFactoryReturningNullThrows() throws IOException {
-    okhttp3.Call.Factory callFactory = new okhttp3.Call.Factory() {
-      @Override public okhttp3.Call newCall(Request request) {
-        return null;
-      }
-    };
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .callFactory(callFactory)
-        .build();
-
-    server.enqueue(new MockResponse());
-
-    CallMethod service = retrofit.create(CallMethod.class);
-    Call<ResponseBody> call = service.getResponseBody();
-    try {
-      call.execute();
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("Call.Factory returned null.");
-    }
-  }
-
-  @Test public void callFactoryThrowingPropagates() {
-    final RuntimeException cause = new RuntimeException("Broken!");
-    okhttp3.Call.Factory callFactory = new okhttp3.Call.Factory() {
-      @Override public okhttp3.Call newCall(Request request) {
-        throw cause;
-      }
-    };
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .callFactory(callFactory)
-        .build();
-
-    server.enqueue(new MockResponse());
-
-    CallMethod service = retrofit.create(CallMethod.class);
-    Call<ResponseBody> call = service.getResponseBody();
-    try {
-      call.execute();
-      fail();
-    } catch (Exception e) {
-      assertThat(e).isSameAs(cause);
-    }
-  }
-
-  @Test public void converterNullThrows() {
-    try {
-      new Retrofit.Builder().addConverterFactory(null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("factory == null");
-    }
-  }
-
-  @Test public void converterFactoryDefault() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .build();
-    List<Converter.Factory> converterFactories = retrofit.converterFactories();
-    assertThat(converterFactories).hasSize(1);
-    assertThat(converterFactories.get(0)).isInstanceOf(BuiltInConverters.class);
-  }
-
-  @Test public void requestConverterFactoryQueried() {
-    Type type = String.class;
-    Annotation[] parameterAnnotations = new Annotation[0];
-    Annotation[] methodAnnotations = new Annotation[1];
-
-    Converter<?, RequestBody> expectedAdapter = mock(Converter.class);
-    Converter.Factory factory = mock(Converter.Factory.class);
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addConverterFactory(factory)
-        .build();
-
-    doReturn(expectedAdapter).when(factory).requestBodyConverter(type, parameterAnnotations,
-        methodAnnotations, retrofit);
-
-    Converter<?, RequestBody> actualAdapter = retrofit.requestBodyConverter(type,
-        parameterAnnotations, methodAnnotations);
-    assertThat(actualAdapter).isSameAs(expectedAdapter);
-
-    verify(factory).requestBodyConverter(type, parameterAnnotations, methodAnnotations, retrofit);
-    verifyNoMoreInteractions(factory);
-  }
-
-  @Test public void requestConverterFactoryNoMatchThrows() {
-    Type type = String.class;
-    Annotation[] annotations = new Annotation[0];
-
-    NonMatchingConverterFactory nonMatchingFactory = new NonMatchingConverterFactory();
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addConverterFactory(nonMatchingFactory)
-        .build();
-
-    try {
-      retrofit.requestBodyConverter(type, annotations, annotations);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(""
-          + "Could not locate RequestBody converter for class java.lang.String.\n"
-          + "  Tried:\n"
-          + "   * retrofit2.BuiltInConverters\n"
-          + "   * retrofit2.helpers.NonMatchingConverterFactory");
-    }
-
-    assertThat(nonMatchingFactory.called).isTrue();
-  }
-
-  @Test public void requestConverterFactorySkippedNoMatchThrows() {
-    Type type = String.class;
-    Annotation[] annotations = new Annotation[0];
-
-    NonMatchingConverterFactory nonMatchingFactory1 = new NonMatchingConverterFactory();
-    NonMatchingConverterFactory nonMatchingFactory2 = new NonMatchingConverterFactory();
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addConverterFactory(nonMatchingFactory1)
-        .addConverterFactory(nonMatchingFactory2)
-        .build();
-
-    try {
-      retrofit.nextRequestBodyConverter(nonMatchingFactory1, type, annotations, annotations);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(""
-          + "Could not locate RequestBody converter for class java.lang.String.\n"
-          + "  Skipped:\n"
-          + "   * retrofit2.BuiltInConverters\n"
-          + "   * retrofit2.helpers.NonMatchingConverterFactory\n"
-          + "  Tried:\n"
-          + "   * retrofit2.helpers.NonMatchingConverterFactory");
-    }
-
-    assertThat(nonMatchingFactory1.called).isFalse();
-    assertThat(nonMatchingFactory2.called).isTrue();
-  }
-
-  @Test public void responseConverterFactoryQueried() {
-    Type type = String.class;
-    Annotation[] annotations = new Annotation[0];
-
-    Converter<ResponseBody, ?> expectedAdapter = mock(Converter.class);
-    Converter.Factory factory = mock(Converter.Factory.class);
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addConverterFactory(factory)
-        .build();
-
-    doReturn(expectedAdapter).when(factory).responseBodyConverter(type, annotations, retrofit);
-
-    Converter<ResponseBody, ?> actualAdapter = retrofit.responseBodyConverter(type, annotations);
-    assertThat(actualAdapter).isSameAs(expectedAdapter);
-
-    verify(factory).responseBodyConverter(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory);
-  }
-
-  @Test public void responseConverterFactoryNoMatchThrows() {
-    Type type = String.class;
-    Annotation[] annotations = new Annotation[0];
-
-    NonMatchingConverterFactory nonMatchingFactory = new NonMatchingConverterFactory();
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addConverterFactory(nonMatchingFactory)
-        .build();
-
-    try {
-      retrofit.responseBodyConverter(type, annotations);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(""
-          + "Could not locate ResponseBody converter for class java.lang.String.\n"
-          + "  Tried:\n"
-          + "   * retrofit2.BuiltInConverters\n"
-          + "   * retrofit2.helpers.NonMatchingConverterFactory");
-    }
-
-    assertThat(nonMatchingFactory.called).isTrue();
-  }
-
-  @Test public void responseConverterFactorySkippedNoMatchThrows() {
-    Type type = String.class;
-    Annotation[] annotations = new Annotation[0];
-
-    NonMatchingConverterFactory nonMatchingFactory1 = new NonMatchingConverterFactory();
-    NonMatchingConverterFactory nonMatchingFactory2 = new NonMatchingConverterFactory();
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addConverterFactory(nonMatchingFactory1)
-        .addConverterFactory(nonMatchingFactory2)
-        .build();
-
-    try {
-      retrofit.nextResponseBodyConverter(nonMatchingFactory1, type, annotations);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(""
-          + "Could not locate ResponseBody converter for class java.lang.String.\n"
-          + "  Skipped:\n"
-          + "   * retrofit2.BuiltInConverters\n"
-          + "   * retrofit2.helpers.NonMatchingConverterFactory\n"
-          + "  Tried:\n"
-          + "   * retrofit2.helpers.NonMatchingConverterFactory");
-    }
-
-    assertThat(nonMatchingFactory1.called).isFalse();
-    assertThat(nonMatchingFactory2.called).isTrue();
-  }
-
-  @Test public void stringConverterFactoryQueried() {
-    Type type = Object.class;
-    Annotation[] annotations = new Annotation[0];
-
-    Converter<?, String> expectedAdapter = mock(Converter.class);
-    Converter.Factory factory = mock(Converter.Factory.class);
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addConverterFactory(factory)
-        .build();
-
-    doReturn(expectedAdapter).when(factory).stringConverter(type, annotations, retrofit);
-
-    Converter<?, String> actualAdapter = retrofit.stringConverter(type, annotations);
-    assertThat(actualAdapter).isSameAs(expectedAdapter);
-
-    verify(factory).stringConverter(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory);
-  }
-
-  @Test public void converterFactoryPropagated() {
-    Converter.Factory factory = mock(Converter.Factory.class);
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addConverterFactory(factory)
-        .build();
-    assertThat(retrofit.converterFactories()).contains(factory);
-  }
-
-  @Test public void callAdapterFactoryNullThrows() {
-    try {
-      new Retrofit.Builder().addCallAdapterFactory(null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("factory == null");
-    }
-  }
-
-  @Test public void callAdapterFactoryDefault() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .build();
-    assertThat(retrofit.callAdapterFactories()).isNotEmpty();
-  }
-
-  @Test public void callAdapterFactoryPropagated() {
-    CallAdapter.Factory factory = mock(CallAdapter.Factory.class);
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addCallAdapterFactory(factory)
-        .build();
-    assertThat(retrofit.callAdapterFactories()).contains(factory);
-  }
-
-  @Test public void callAdapterFactoryQueried() {
-    Type type = String.class;
-    Annotation[] annotations = new Annotation[0];
-
-    CallAdapter<?> expectedAdapter = mock(CallAdapter.class);
-    CallAdapter.Factory factory = mock(CallAdapter.Factory.class);
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addCallAdapterFactory(factory)
-        .build();
-
-    doReturn(expectedAdapter).when(factory).get(type, annotations, retrofit);
-
-    CallAdapter<?> actualAdapter = retrofit.callAdapter(type, annotations);
-    assertThat(actualAdapter).isSameAs(expectedAdapter);
-
-    verify(factory).get(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory);
-  }
-
-  @Test public void callAdapterFactoryQueriedCanDelegate() {
-    Type type = String.class;
-    Annotation[] annotations = new Annotation[0];
-
-    CallAdapter<?> expectedAdapter = mock(CallAdapter.class);
-    CallAdapter.Factory factory2 = mock(CallAdapter.Factory.class);
-    CallAdapter.Factory factory1 = spy(new CallAdapter.Factory() {
-      @Override
-      public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
-        return retrofit.nextCallAdapter(this, returnType, annotations);
-      }
-    });
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addCallAdapterFactory(factory1)
-        .addCallAdapterFactory(factory2)
-        .build();
-
-    doReturn(expectedAdapter).when(factory2).get(type, annotations, retrofit);
-
-    CallAdapter<?> actualAdapter = retrofit.callAdapter(type, annotations);
-    assertThat(actualAdapter).isSameAs(expectedAdapter);
-
-    verify(factory1).get(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory1);
-    verify(factory2).get(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory2);
-  }
-
-  @Test public void callAdapterFactoryQueriedCanDelegateTwiceWithoutRecursion() {
-    Type type = String.class;
-    Annotation[] annotations = new Annotation[0];
-
-    CallAdapter<?> expectedAdapter = mock(CallAdapter.class);
-    CallAdapter.Factory factory3 = mock(CallAdapter.Factory.class);
-    CallAdapter.Factory factory2 = spy(new CallAdapter.Factory() {
-      @Override
-      public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
-        return retrofit.nextCallAdapter(this, returnType, annotations);
-      }
-    });
-    CallAdapter.Factory factory1 = spy(new CallAdapter.Factory() {
-      @Override
-      public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
-        return retrofit.nextCallAdapter(this, returnType, annotations);
-      }
-    });
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addCallAdapterFactory(factory1)
-        .addCallAdapterFactory(factory2)
-        .addCallAdapterFactory(factory3)
-        .build();
-
-    doReturn(expectedAdapter).when(factory3).get(type, annotations, retrofit);
-
-    CallAdapter<?> actualAdapter = retrofit.callAdapter(type, annotations);
-    assertThat(actualAdapter).isSameAs(expectedAdapter);
-
-    verify(factory1).get(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory1);
-    verify(factory2).get(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory2);
-    verify(factory3).get(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory3);
-  }
-
-  @Test public void callAdapterFactoryNoMatchThrows() {
-    Type type = String.class;
-    Annotation[] annotations = new Annotation[0];
-
-    NonMatchingCallAdapterFactory nonMatchingFactory = new NonMatchingCallAdapterFactory();
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addCallAdapterFactory(nonMatchingFactory)
-        .build();
-
-    try {
-      retrofit.callAdapter(type, annotations);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(""
-          + "Could not locate call adapter for class java.lang.String.\n"
-          + "  Tried:\n"
-          + "   * retrofit2.helpers.NonMatchingCallAdapterFactory\n"
-          + "   * retrofit2.DefaultCallAdapterFactory");
-    }
-
-    assertThat(nonMatchingFactory.called).isTrue();
-  }
-
-  @Test public void callAdapterFactoryDelegateNoMatchThrows() {
-    Type type = String.class;
-    Annotation[] annotations = new Annotation[0];
-
-    DelegatingCallAdapterFactory delegatingFactory1 = new DelegatingCallAdapterFactory();
-    DelegatingCallAdapterFactory delegatingFactory2 = new DelegatingCallAdapterFactory();
-    NonMatchingCallAdapterFactory nonMatchingFactory = new NonMatchingCallAdapterFactory();
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addCallAdapterFactory(delegatingFactory1)
-        .addCallAdapterFactory(delegatingFactory2)
-        .addCallAdapterFactory(nonMatchingFactory)
-        .build();
-
-    try {
-      retrofit.callAdapter(type, annotations);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(""
-          + "Could not locate call adapter for class java.lang.String.\n"
-          + "  Skipped:\n"
-          + "   * retrofit2.helpers.DelegatingCallAdapterFactory\n"
-          + "   * retrofit2.helpers.DelegatingCallAdapterFactory\n"
-          + "  Tried:\n"
-          + "   * retrofit2.helpers.NonMatchingCallAdapterFactory\n"
-          + "   * retrofit2.DefaultCallAdapterFactory");
-    }
-
-    assertThat(delegatingFactory1.called).isTrue();
-    assertThat(delegatingFactory2.called).isTrue();
-    assertThat(nonMatchingFactory.called).isTrue();
-  }
-
-  @Test public void callbackExecutorNullThrows() {
-    try {
-      new Retrofit.Builder().callbackExecutor(null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("executor == null");
-    }
-  }
-
-  @Test public void callbackExecutorPropagatesDefaultJvm() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .build();
-    assertThat(retrofit.callbackExecutor()).isNull();
-  }
-
-  @Test public void callbackExecutorPropagatesDefaultAndroid() {
-    final Executor executor = Executors.newSingleThreadExecutor();
-    Platform platform = new Platform() {
-      @Override Executor defaultCallbackExecutor() {
-        return executor;
-      }
-    };
-    Retrofit retrofit = new Retrofit.Builder(platform)
-        .baseUrl("http://example.com/")
-        .build();
-    assertThat(retrofit.callbackExecutor()).isSameAs(executor);
-  }
-
-  @Test public void callbackExecutorPropagated() {
-    Executor executor = mock(Executor.class);
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .callbackExecutor(executor)
-        .build();
-    assertThat(retrofit.callbackExecutor()).isSameAs(executor);
-  }
-
-  @Test public void callbackExecutorUsedForSuccess() throws InterruptedException {
-    Executor executor = spy(new Executor() {
-      @Override public void execute(Runnable command) {
-        command.run();
-      }
-    });
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .callbackExecutor(executor)
-        .build();
-    CallMethod service = retrofit.create(CallMethod.class);
-    Call<ResponseBody> call = service.getResponseBody();
-
-    server.enqueue(new MockResponse());
-
-    final CountDownLatch latch = new CountDownLatch(1);
-    call.enqueue(new Callback<ResponseBody>() {
-      @Override public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
-        latch.countDown();
-      }
-
-      @Override public void onFailure(Call<ResponseBody> call, Throwable t) {
-        t.printStackTrace();
-      }
-    });
-    assertTrue(latch.await(2, TimeUnit.SECONDS));
-
-    verify(executor).execute(any(Runnable.class));
-    verifyNoMoreInteractions(executor);
-  }
-
-  @Test public void callbackExecutorUsedForFailure() throws InterruptedException {
-    Executor executor = spy(new Executor() {
-      @Override public void execute(Runnable command) {
-        command.run();
-      }
-    });
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .callbackExecutor(executor)
-        .build();
-    CallMethod service = retrofit.create(CallMethod.class);
-    Call<ResponseBody> call = service.getResponseBody();
-
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AT_START));
-
-    final CountDownLatch latch = new CountDownLatch(1);
-    call.enqueue(new Callback<ResponseBody>() {
-      @Override public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
-        throw new AssertionError();
-      }
-
-      @Override public void onFailure(Call<ResponseBody> call, Throwable t) {
-        latch.countDown();
-      }
-    });
-    assertTrue(latch.await(2, TimeUnit.SECONDS));
-
-    verify(executor).execute(any(Runnable.class));
-    verifyNoMoreInteractions(executor);
-  }
-
-  /** Confirm that Retrofit encodes parameters when the call is executed, and not earlier. */
-  @Test public void argumentCapture() throws Exception {
-    AtomicInteger i = new AtomicInteger();
-
-    server.enqueue(new MockResponse().setBody("a"));
-    server.enqueue(new MockResponse().setBody("b"));
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    MutableParameters mutableParameters = retrofit.create(MutableParameters.class);
-
-    i.set(100);
-    Call<String> call1 = mutableParameters.method(i);
-
-    i.set(101);
-    Response<String> response1 = call1.execute();
-
-    i.set(102);
-    assertEquals("a", response1.body());
-    assertEquals("/?i=101", server.takeRequest().getPath());
-
-    i.set(200);
-    Call<String> call2 = call1.clone();
-
-    i.set(201);
-    Response<String> response2 = call2.execute();
-
-    i.set(202);
-    assertEquals("b", response2.body());
-
-    assertEquals("/?i=201", server.takeRequest().getPath());
-  }
-}
diff --git a/retrofit/src/test/java/retrofit2/ServiceMethodTest.java b/retrofit/src/test/java/retrofit2/ServiceMethodTest.java
deleted file mode 100644
index c9c48f31e..000000000
--- a/retrofit/src/test/java/retrofit2/ServiceMethodTest.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2;
-
-import java.util.Set;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
-public final class ServiceMethodTest {
-  @Test public void pathParameterParsing() throws Exception {
-    expectParams("/");
-    expectParams("/foo");
-    expectParams("/foo/bar");
-    expectParams("/foo/bar/{}");
-    expectParams("/foo/bar/{taco}", "taco");
-    expectParams("/foo/bar/{t}", "t");
-    expectParams("/foo/bar/{!!!}/"); // Invalid parameter.
-    expectParams("/foo/bar/{}/{taco}", "taco");
-    expectParams("/foo/bar/{taco}/or/{burrito}", "taco", "burrito");
-    expectParams("/foo/bar/{taco}/or/{taco}", "taco");
-    expectParams("/foo/bar/{taco-shell}", "taco-shell");
-    expectParams("/foo/bar/{taco_shell}", "taco_shell");
-    expectParams("/foo/bar/{sha256}", "sha256");
-    expectParams("/foo/bar/{TACO}", "TACO");
-    expectParams("/foo/bar/{taco}/{tAco}/{taCo}", "taco", "tAco", "taCo");
-    expectParams("/foo/bar/{1}"); // Invalid parameter, name cannot start with digit.
-  }
-
-  private static void expectParams(String path, String... expected) {
-    Set<String> calculated = ServiceMethod.parsePathParameters(path);
-    assertThat(calculated).containsExactly(expected);
-  }
-}
diff --git a/retrofit/src/test/java/retrofit2/TestingUtils.java b/retrofit/src/test/java/retrofit2/TestingUtils.java
deleted file mode 100644
index 3847509ea..000000000
--- a/retrofit/src/test/java/retrofit2/TestingUtils.java
+++ /dev/null
@@ -1,28 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2;
-
-import java.lang.reflect.Method;
-
-public final class TestingUtils {
-  public static Method onlyMethod(Class c) {
-    Method[] declaredMethods = c.getDeclaredMethods();
-    if (declaredMethods.length == 1) {
-      return declaredMethods[0];
-    }
-    throw new IllegalArgumentException("More than one method declared.");
-  }
-}
diff --git a/retrofit/src/test/java/retrofit2/helpers/DelegatingCallAdapterFactory.java b/retrofit/src/test/java/retrofit2/helpers/DelegatingCallAdapterFactory.java
deleted file mode 100644
index 918b0ea0f..000000000
--- a/retrofit/src/test/java/retrofit2/helpers/DelegatingCallAdapterFactory.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2.helpers;
-
-import java.lang.annotation.Annotation;
-import java.lang.reflect.Type;
-import retrofit2.CallAdapter;
-import retrofit2.Retrofit;
-
-public final class DelegatingCallAdapterFactory extends CallAdapter.Factory {
-  public boolean called;
-
-  @Override
-  public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
-    called = true;
-    return retrofit.nextCallAdapter(this, returnType, annotations);
-  }
-}
diff --git a/retrofit/src/test/java/retrofit2/helpers/NonMatchingCallAdapterFactory.java b/retrofit/src/test/java/retrofit2/helpers/NonMatchingCallAdapterFactory.java
deleted file mode 100644
index 2b4954813..000000000
--- a/retrofit/src/test/java/retrofit2/helpers/NonMatchingCallAdapterFactory.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2.helpers;
-
-import java.lang.annotation.Annotation;
-import java.lang.reflect.Type;
-import retrofit2.CallAdapter;
-import retrofit2.Retrofit;
-
-public final class NonMatchingCallAdapterFactory extends CallAdapter.Factory {
-  public boolean called;
-
-  @Override
-  public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
-    called = true;
-    return null;
-  }
-}
diff --git a/retrofit/src/test/java/retrofit2/helpers/NonMatchingConverterFactory.java b/retrofit/src/test/java/retrofit2/helpers/NonMatchingConverterFactory.java
deleted file mode 100644
index 343839944..000000000
--- a/retrofit/src/test/java/retrofit2/helpers/NonMatchingConverterFactory.java
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2.helpers;
-
-import java.lang.annotation.Annotation;
-import java.lang.reflect.Type;
-import okhttp3.RequestBody;
-import okhttp3.ResponseBody;
-import retrofit2.Converter;
-import retrofit2.Retrofit;
-
-public final class NonMatchingConverterFactory extends Converter.Factory {
-  public boolean called;
-
-  @Override
-  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
-    called = true;
-    return null;
-  }
-
-  @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
-      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
-    called = true;
-    return null;
-  }
-
-  @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
-    called = true;
-    return null;
-  }
-}
diff --git a/retrofit/src/test/java/retrofit2/helpers/ToStringConverterFactory.java b/retrofit/src/test/java/retrofit2/helpers/ToStringConverterFactory.java
deleted file mode 100644
index 0a70e3ddb..000000000
--- a/retrofit/src/test/java/retrofit2/helpers/ToStringConverterFactory.java
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2.helpers;
-
-import java.io.IOException;
-import java.lang.annotation.Annotation;
-import java.lang.reflect.Type;
-import okhttp3.MediaType;
-import okhttp3.RequestBody;
-import okhttp3.ResponseBody;
-import retrofit2.Converter;
-import retrofit2.Retrofit;
-
-public class ToStringConverterFactory extends Converter.Factory {
-  static final MediaType MEDIA_TYPE = MediaType.parse("text/plain");
-
-  @Override
-  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
-    if (String.class.equals(type)) {
-      return new Converter<ResponseBody, String>() {
-        @Override public String convert(ResponseBody value) throws IOException {
-          return value.string();
-        }
-      };
-    }
-    return null;
-  }
-
-  @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
-      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
-    if (String.class.equals(type)) {
-      return new Converter<String, RequestBody>() {
-        @Override public RequestBody convert(String value) throws IOException {
-          return RequestBody.create(MEDIA_TYPE, value);
-        }
-      };
-    }
-    return null;
-  }
-}
