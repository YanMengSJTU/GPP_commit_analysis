diff --git a/README.md b/README.md
index d53a1c35f..81607e1d0 100644
--- a/README.md
+++ b/README.md
@@ -16,19 +16,19 @@ example interface:
 public interface DummyServiceAsync {
   // Produces a url like "foo/bar?id=idValue".
   @GET("foo/bar")
-  void normalGet(@Named("id") String id, Callback<SimpleResponse> callback);
+  void normalGet(@Name("id") String id, Callback<MyJsonObj> callback);
 
   // Produces a url like "foo/idValue/bar?category=categoryValue".
   @GET("foo/{id}/bar")
-  void getWithPathParam(@Named("id") String id, @Named("category") String category, Callback<SimpleResponse> callback);
+  void getWithPathParam(@Name("id") String id, @Name("category") String category, Callback<MyJsonObj> callback);
 
   // Produces a url like "foo/bar/idValue" and body like "id=idValue&body=bodyValue".
   @POST("foo/bar/{id}")
-  void normalPost(@Named("id") String id, @Named("body") String body, Callback<SimpleResponse> callback);
+  void normalPost(@Name("id") String id, @Name("body") String body, Callback<MyJsonObj> callback);
 
   // Produces a url like "foo/bar/idValue" and body generated by MyJsonObj.
   @POST("foo/bar/{id}")
-  void singleEntityPost(@SingleEntity MyJsonObj card, @Named("id") String id, Callback<SimpleResponse> callback);
+  void singleEntityPost(@SingleEntity MyJsonObj card, @Name("id") String id, Callback<MyJsonObj> callback);
 }
 ```
 
@@ -44,7 +44,7 @@ For synchronous execution, omit the `Callback` parameter and specify the respons
 ```java
 public interface DummyServiceSync {
   @GET("foo/bar")
-  SimpleResponse normalGet(@Named("id") String id);
+  MyJsonObj normalGet(@Name("id") String id);
 }
 ```
 
diff --git a/pom.xml b/pom.xml
index 151fe8a13..414cad2c4 100644
--- a/pom.xml
+++ b/pom.xml
@@ -14,8 +14,9 @@
   See the License for the specific language governing permissions and
   limitations under the License.
 -->
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+<project xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
   <modelVersion>4.0.0</modelVersion>
 
   <parent>
@@ -43,20 +44,20 @@
     <project.reporting.sourceEncoding>UTF-8</project.reporting.sourceEncoding>
 
     <!-- Compilation -->
-    <android-maven.version>3.4.0</android-maven.version>
+    <android-maven.version>3.5.1</android-maven.version>
     <java.version>1.6</java.version>
 
     <!-- Dependencies -->
     <android.version>4.1.1.4</android.version>
     <android.platform>16</android.platform>
-    <gson.version>2.2.3-SNAPSHOT</gson.version>
-    <httpcomponents.version>4.0.1</httpcomponents.version>
+    <gson.version>2.2.2</gson.version>
     <javax.inject.version>1</javax.inject.version>
 
     <!-- Test Dependencies -->
     <junit.version>4.10</junit.version>
-    <fest.version>2.0M8</fest.version>
+    <fest.version>2.0M10</fest.version>
     <mockito.version>1.9.5</mockito.version>
+    <guava.version>14.0</guava.version>
   </properties>
 
   <scm>
@@ -109,21 +110,6 @@
         <artifactId>gson</artifactId>
         <version>${gson.version}</version>
       </dependency>
-      <dependency>
-        <groupId>javax.inject</groupId>
-        <artifactId>javax.inject</artifactId>
-        <version>${javax.inject.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>org.apache.httpcomponents</groupId>
-        <artifactId>httpmime</artifactId>
-        <version>${httpcomponents.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>org.apache.httpcomponents</groupId>
-        <artifactId>httpclient</artifactId>
-        <version>${httpcomponents.version}</version>
-      </dependency>
 
       <dependency>
         <groupId>junit</groupId>
@@ -140,68 +126,62 @@
         <artifactId>mockito-core</artifactId>
         <version>${mockito.version}</version>
       </dependency>
+      <dependency>
+        <groupId>com.google.guava</groupId>
+        <artifactId>guava</artifactId>
+        <version>${guava.version}</version>
+      </dependency>
     </dependencies>
   </dependencyManagement>
 
   <build>
     <pluginManagement>
       <plugins>
-        <plugin>
-          <groupId>com.jayway.maven.plugins.android.generation2</groupId>
-          <artifactId>android-maven-plugin</artifactId>
-          <version>${android-maven.version}</version>
-          <configuration>
-            <sdk>
-              <platform>${android.platform}</platform>
-            </sdk>
-          </configuration>
-        </plugin>
-
         <plugin>
           <groupId>org.sonatype.plugins</groupId>
           <artifactId>jarjar-maven-plugin</artifactId>
-          <version>1.5</version>
+          <version>1.7</version>
         </plugin>
 
         <plugin>
           <groupId>org.apache.maven.plugins</groupId>
           <artifactId>maven-compiler-plugin</artifactId>
-          <version>2.5</version>
+          <version>3.0</version>
           <configuration>
             <source>${java.version}</source>
             <target>${java.version}</target>
           </configuration>
         </plugin>
-
-        <plugin>
-          <groupId>org.apache.maven.plugins</groupId>
-          <artifactId>maven-checkstyle-plugin</artifactId>
-          <version>2.9.1</version>
-          <configuration>
-            <failsOnError>true</failsOnError>
-            <!-- Relative to module directory. -->
-            <configLocation>../checkstyle.xml</configLocation>
-            <consoleOutput>true</consoleOutput>
-          </configuration>
-          <executions>
-            <execution>
-              <phase>verify</phase>
-              <goals>
-                <goal>checkstyle</goal>
-              </goals>
-            </execution>
-          </executions>
-        </plugin>
       </plugins>
     </pluginManagement>
 
     <plugins>
       <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-release-plugin</artifactId>
         <configuration>
           <autoVersionSubmodules>true</autoVersionSubmodules>
         </configuration>
       </plugin>
+
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-checkstyle-plugin</artifactId>
+        <version>2.9.1</version>
+        <configuration>
+          <failsOnError>true</failsOnError>
+          <configLocation>checkstyle.xml</configLocation>
+          <consoleOutput>true</consoleOutput>
+        </configuration>
+        <executions>
+          <execution>
+            <phase>verify</phase>
+            <goals>
+              <goal>checkstyle</goal>
+            </goals>
+          </execution>
+        </executions>
+      </plugin>
     </plugins>
   </build>
 </project>
diff --git a/retrofit/pom.xml b/retrofit/pom.xml
index c7e5701e8..f2ecdc6c2 100644
--- a/retrofit/pom.xml
+++ b/retrofit/pom.xml
@@ -1,7 +1,8 @@
 <?xml version="1.0" encoding="UTF-8"?>
 
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+<project xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
   <modelVersion>4.0.0</modelVersion>
 
   <parent>
@@ -15,26 +16,14 @@
   <name>Retrofit</name>
 
   <dependencies>
-    <dependency>
-      <groupId>javax.inject</groupId>
-      <artifactId>javax.inject</artifactId>
-    </dependency>
     <dependency>
       <groupId>com.google.code.gson</groupId>
       <artifactId>gson</artifactId>
     </dependency>
-    <dependency>
-      <groupId>org.apache.httpcomponents</groupId>
-      <artifactId>httpclient</artifactId>
-    </dependency>
-    <dependency>
-      <groupId>org.apache.httpcomponents</groupId>
-      <artifactId>httpmime</artifactId>
-    </dependency>
     <dependency>
       <groupId>com.google.android</groupId>
       <artifactId>android</artifactId>
-      <scope>provided</scope>
+      <optional>true</optional>
     </dependency>
 
     <dependency>
@@ -52,14 +41,10 @@
       <artifactId>mockito-core</artifactId>
       <scope>test</scope>
     </dependency>
+    <dependency>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
+      <scope>test</scope>
+    </dependency>
   </dependencies>
-
-  <build>
-    <plugins>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-checkstyle-plugin</artifactId>
-      </plugin>
-    </plugins>
-  </build>
 </project>
diff --git a/retrofit/src/main/java/retrofit/http/Callback.java b/retrofit/src/main/java/retrofit/http/Callback.java
index 7b2a0ba10..28a556f22 100644
--- a/retrofit/src/main/java/retrofit/http/Callback.java
+++ b/retrofit/src/main/java/retrofit/http/Callback.java
@@ -1,6 +1,8 @@
 // Copyright 2012 Square, Inc.
 package retrofit.http;
 
+import retrofit.http.client.Response;
+
 /**
  * Communicates responses to server or offline requests. Contains a callback method for each
  * possible outcome. One and only one method will be invoked in response to a given request.
@@ -11,7 +13,7 @@
 public interface Callback<T> {
 
   /** Successful HTTP response. */
-  void success(T t);
+  void success(T t, Response response);
 
   /**
    * Unsuccessful HTTP response due to network failure, non-2XX status code, or unexpected
diff --git a/retrofit/src/main/java/retrofit/http/CallbackRunnable.java b/retrofit/src/main/java/retrofit/http/CallbackRunnable.java
index 626cdfe04..debfa2610 100644
--- a/retrofit/src/main/java/retrofit/http/CallbackRunnable.java
+++ b/retrofit/src/main/java/retrofit/http/CallbackRunnable.java
@@ -21,10 +21,10 @@
   @SuppressWarnings("unchecked")
   @Override public final void run() {
     try {
-      final Object response = obtainResponse();
+      final ResponseWrapper wrapper = obtainResponse();
       callbackExecutor.execute(new Runnable() {
         @Override public void run() {
-          callback.success((T) response);
+          callback.success((T) wrapper.responseBody, wrapper.response);
         }
       });
     } catch (final RetrofitError e) {
@@ -36,5 +36,5 @@
     }
   }
 
-  public abstract Object obtainResponse();
+  public abstract ResponseWrapper obtainResponse();
 }
diff --git a/retrofit/src/main/java/retrofit/http/ChangeableServer.java b/retrofit/src/main/java/retrofit/http/ChangeableServer.java
new file mode 100644
index 000000000..f247024fa
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/http/ChangeableServer.java
@@ -0,0 +1,40 @@
+package retrofit.http;
+
+/** A {@link Server} whose URL and name can be changed at runtime. */
+public class ChangeableServer extends Server {
+  private String url;
+  private String name;
+
+  /** Create a changeable server with the provided URL and default name. */
+  public ChangeableServer(String url) {
+    super(url);
+    this.url = url;
+    this.name = DEFAULT_NAME;
+  }
+
+  /** Create a changeable server with the provided URL and name. */
+  public ChangeableServer(String url, String name) {
+    super(url, name);
+    this.url = url;
+    this.name = name;
+  }
+
+  /** Update the URL returned by {@link #getUrl()}. */
+  public void update(String url) {
+    this.url = url;
+  }
+
+  /** Update the URL and name returned by {@link #getUrl()} and {@link #getName()}, respetively. */
+  public void update(String url, String name) {
+    this.url = url;
+    this.name = name;
+  }
+
+  @Override public String getUrl() {
+    return url;
+  }
+
+  @Override public String getName() {
+    return name;
+  }
+}
diff --git a/retrofit/src/main/java/retrofit/http/Converter.java b/retrofit/src/main/java/retrofit/http/Converter.java
index e103f0e18..0a829525a 100644
--- a/retrofit/src/main/java/retrofit/http/Converter.java
+++ b/retrofit/src/main/java/retrofit/http/Converter.java
@@ -2,7 +2,8 @@
 package retrofit.http;
 
 import java.lang.reflect.Type;
-import retrofit.io.TypedBytes;
+import retrofit.http.mime.TypedInput;
+import retrofit.http.mime.TypedOutput;
 
 /**
  * Arbiter for converting objects to and from their representation in HTTP.
@@ -16,10 +17,12 @@
    * @param body HTTP response body.
    * @param type Target object type.
    * @return Instance of {@code type} which will be cast by the caller.
-   * @throws ConversionException If conversion was unable to complete. This will trigger a call to
-   * {@link Callback#failure(RetrofitError)} or throw a {@link retrofit.http.RetrofitError}.
+   * @throws ConversionException if conversion was unable to complete. This will trigger a call to
+   * {@link Callback#failure(RetrofitError)} or throw a {@link retrofit.http.RetrofitError}. The
+   * exception message should report all necessary information about its cause as the response body
+   * will be set to {@code null}.
    */
-  Object fromBody(byte[] body, Type type) throws ConversionException;
+  Object fromBody(TypedInput body, Type type) throws ConversionException;
 
   /**
    * Convert and object to an appropriate representation for HTTP transport.
@@ -27,5 +30,5 @@
    * @param object Object instance to convert.
    * @return Representation of the specified object as bytes.
    */
-  TypedBytes toBody(Object object);
+  TypedOutput toBody(Object object);
 }
diff --git a/retrofit/src/main/java/retrofit/http/GsonConverter.java b/retrofit/src/main/java/retrofit/http/GsonConverter.java
index d5b82978c..fcec2b016 100644
--- a/retrofit/src/main/java/retrofit/http/GsonConverter.java
+++ b/retrofit/src/main/java/retrofit/http/GsonConverter.java
@@ -3,15 +3,13 @@
 
 import com.google.gson.Gson;
 import com.google.gson.JsonParseException;
-import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.io.OutputStream;
 import java.io.UnsupportedEncodingException;
 import java.lang.reflect.Type;
-import retrofit.io.TypedBytes;
-
-import static retrofit.http.RestAdapter.UTF_8;
+import retrofit.http.mime.TypedInput;
+import retrofit.http.mime.TypedOutput;
 
 /**
  * A {@link Converter} which uses GSON for serialization and deserialization of entities.
@@ -25,37 +23,50 @@ public GsonConverter(Gson gson) {
     this.gson = gson;
   }
 
-  @Override public Object fromBody(byte[] body, Type type) throws ConversionException {
+  @Override public Object fromBody(TypedInput body, Type type) throws ConversionException {
+    String charset = Utils.parseCharset(body.mimeType());
+    InputStreamReader isr = null;
     try {
-      InputStreamReader isr = new InputStreamReader(new ByteArrayInputStream(body), UTF_8);
+      isr = new InputStreamReader(body.in(), charset);
       return gson.fromJson(isr, type);
     } catch (IOException e) {
       throw new ConversionException(e);
     } catch (JsonParseException e) {
       throw new ConversionException(e);
+    } finally {
+      if (isr != null) {
+        try {
+          isr.close();
+        } catch (IOException ignored) {
+        }
+      }
     }
   }
 
-  @Override public TypedBytes toBody(Object object) {
+  @Override public TypedOutput toBody(Object object) {
     try {
-      return new JsonTypedBytes(gson.toJson(object).getBytes(UTF_8));
+      return new JsonTypedOutput(gson.toJson(object).getBytes("UTF-8"));
     } catch (UnsupportedEncodingException e) {
       throw new AssertionError(e);
     }
   }
 
-  static class JsonTypedBytes implements TypedBytes {
-    final byte[] jsonBytes;
+  static class JsonTypedOutput implements TypedOutput {
+    private final byte[] jsonBytes;
 
-    JsonTypedBytes(byte[] jsonBytes) {
+    JsonTypedOutput(byte[] jsonBytes) {
       this.jsonBytes = jsonBytes;
     }
 
+    @Override public String fileName() {
+      return null;
+    }
+
     @Override public String mimeType() {
       return "application/json; charset=UTF-8";
     }
 
-    @Override public int length() {
+    @Override public long length() {
       return jsonBytes.length;
     }
 
diff --git a/retrofit/src/main/java/retrofit/http/Headers.java b/retrofit/src/main/java/retrofit/http/Headers.java
new file mode 100644
index 000000000..2220d588c
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/http/Headers.java
@@ -0,0 +1,21 @@
+// Copyright 2013 Square, Inc.
+package retrofit.http;
+
+import java.util.Collections;
+import java.util.List;
+
+/** Manages headers for each request. */
+public interface Headers {
+  /**
+   * Get a list of headers for a request. This method will be called once for each request allowing
+   * you to change the list as the state of your application changes.
+   */
+  List<Header> get();
+
+  /** Empty header list. */
+  Headers NONE = new Headers() {
+    @Override public List<Header> get() {
+      return Collections.emptyList();
+    }
+  };
+}
diff --git a/retrofit/src/main/java/retrofit/http/MultipartTypedOutput.java b/retrofit/src/main/java/retrofit/http/MultipartTypedOutput.java
new file mode 100644
index 000000000..e1a32e508
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/http/MultipartTypedOutput.java
@@ -0,0 +1,112 @@
+// Copyright 2013 Square, Inc.
+package retrofit.http;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.UUID;
+import retrofit.http.mime.TypedOutput;
+
+final class MultipartTypedOutput implements TypedOutput {
+  final List<byte[]> parts = new ArrayList<byte[]>();
+  private final byte[] footer;
+  private final String boundary;
+  private long length;
+
+  MultipartTypedOutput() {
+    boundary = UUID.randomUUID().toString();
+    footer = buildBoundary(boundary, false, true);
+    length = footer.length;
+  }
+
+  void addPart(String name, TypedOutput body) {
+    if (name == null) {
+      throw new NullPointerException("Part name must not be null.");
+    }
+    if (body == null) {
+      throw new NullPointerException("Part body must not be null.");
+    }
+
+    byte[] part = buildPart(name, body, parts.isEmpty());
+    parts.add(part);
+    length += part.length;
+  }
+
+  @Override public String fileName() {
+    return null;
+  }
+
+  @Override public String mimeType() {
+    return "multipart/form-data; boundary=" + boundary;
+  }
+
+  @Override public long length() {
+    return length;
+  }
+
+  @Override public void writeTo(OutputStream out) throws IOException {
+    for (byte[] part : parts) {
+      out.write(part);
+    }
+    out.write(footer);
+  }
+
+  private byte[] buildPart(String name, TypedOutput body, boolean first) {
+    ByteArrayOutputStream out = null;
+    try {
+      out = new ByteArrayOutputStream();
+      out.write(buildBoundary(boundary, first, false));
+      out.write(buildHeader(name, body));
+      body.writeTo(out);
+      return out.toByteArray();
+    } catch (IOException ex) {
+      throw new RuntimeException("Unable to write multipart request.", ex);
+    } finally {
+      if (out != null) {
+        try {
+          out.close();
+        } catch (IOException ignored) {
+        }
+      }
+    }
+  }
+
+  private static byte[] buildBoundary(String boundary, boolean first, boolean last) {
+    try {
+      StringBuilder sb = new StringBuilder();
+      if (!first) {
+        sb.append("\r\n");
+      }
+      sb.append("--");
+      sb.append(boundary);
+      if (last) {
+        sb.append("--");
+      } else {
+        sb.append("\r\n");
+      }
+      return sb.toString().getBytes("UTF-8");
+    } catch (IOException ex) {
+      throw new RuntimeException("Unable to write multipart boundary", ex);
+    }
+  }
+
+  private byte[] buildHeader(String name, TypedOutput value) {
+    try {
+      StringBuilder headers = new StringBuilder();
+      headers.append("Content-Disposition: form-data; name=\"");
+      headers.append(name);
+      if (value.fileName() != null) {
+        headers.append("\"; filename=\"");
+        headers.append(value.fileName());
+      }
+      headers.append("\"\r\nContent-Type: ");
+      headers.append(value.mimeType());
+      headers.append("\r\nContent-Transfer-Encoding: binary\r\n\r\n");
+      return headers.toString().getBytes("UTF-8");
+    } catch (IOException ex) {
+      throw new RuntimeException("Unable to write multipart header", ex);
+    }
+  }
+}
diff --git a/retrofit/src/main/java/retrofit/http/Name.java b/retrofit/src/main/java/retrofit/http/Name.java
new file mode 100644
index 000000000..b872502cd
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/http/Name.java
@@ -0,0 +1,13 @@
+// Copyright 2013 Square, Inc.
+package retrofit.http;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.PARAMETER;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+@Retention(RUNTIME) @Target(PARAMETER)
+public @interface Name {
+  String value();
+}
diff --git a/retrofit/src/main/java/retrofit/http/Parameter.java b/retrofit/src/main/java/retrofit/http/Parameter.java
index af25aee53..7812e7591 100644
--- a/retrofit/src/main/java/retrofit/http/Parameter.java
+++ b/retrofit/src/main/java/retrofit/http/Parameter.java
@@ -5,7 +5,7 @@
 
 /**
  * Represents a named parameter and its value.
- * <p/>
+ * <p>
  * This is used in one of three places in a request:
  * <ul>
  * <li>Named replacement in the relative URL path.
diff --git a/retrofit/src/main/java/retrofit/http/Platform.java b/retrofit/src/main/java/retrofit/http/Platform.java
index f3b058070..1a8de06d2 100644
--- a/retrofit/src/main/java/retrofit/http/Platform.java
+++ b/retrofit/src/main/java/retrofit/http/Platform.java
@@ -1,19 +1,20 @@
 package retrofit.http;
 
+import android.os.Build;
 import android.os.Process;
+import android.util.Log;
 import com.google.gson.Gson;
 import java.util.concurrent.Executor;
 import java.util.concurrent.Executors;
 import java.util.concurrent.ThreadFactory;
-import java.util.concurrent.atomic.AtomicInteger;
-import javax.inject.Provider;
-import retrofit.android.AndroidApacheClient;
-import retrofit.android.MainThreadExecutor;
-import retrofit.http.client.ApacheClient;
+import retrofit.http.android.AndroidApacheClient;
+import retrofit.http.android.MainThreadExecutor;
 import retrofit.http.client.Client;
+import retrofit.http.client.UrlConnectionClient;
 
 import static android.os.Process.THREAD_PRIORITY_BACKGROUND;
-import static retrofit.http.RestAdapter.THREAD_PREFIX;
+import static java.lang.Thread.MIN_PRIORITY;
+import static retrofit.http.RestAdapter.IDLE_THREAD_NAME;
 import static retrofit.http.Utils.SynchronousExecutor;
 
 abstract class Platform {
@@ -35,15 +36,16 @@ private static Platform findPlatform() {
   Converter defaultConverter() {
     return new GsonConverter(new Gson());
   }
-  abstract Provider<Client> defaultClient();
+  abstract Client.Provider defaultClient();
   abstract Executor defaultHttpExecutor();
   abstract Executor defaultCallbackExecutor();
+  abstract RestAdapter.Log defaultLog();
 
   /** Provides sane defaults for operation on the JVM. */
   private static class Base extends Platform {
-    @Override Provider<Client> defaultClient() {
-      final Client client = new ApacheClient();
-      return new Provider<Client>() {
+    @Override Client.Provider defaultClient() {
+      final Client client = new UrlConnectionClient();
+      return new Client.Provider() {
         @Override public Client get() {
           return client;
         }
@@ -52,15 +54,13 @@ Converter defaultConverter() {
 
     @Override Executor defaultHttpExecutor() {
       return Executors.newCachedThreadPool(new ThreadFactory() {
-        private final AtomicInteger threadCounter = new AtomicInteger();
-
         @Override public Thread newThread(final Runnable r) {
           return new Thread(new Runnable() {
             @Override public void run() {
-              Thread.currentThread().setPriority(THREAD_PRIORITY_BACKGROUND);
+              Thread.currentThread().setPriority(MIN_PRIORITY);
               r.run();
             }
-          }, THREAD_PREFIX + threadCounter.getAndIncrement());
+          }, IDLE_THREAD_NAME);
         }
       });
     }
@@ -68,13 +68,26 @@ Converter defaultConverter() {
     @Override Executor defaultCallbackExecutor() {
       return new SynchronousExecutor();
     }
+
+    @Override RestAdapter.Log defaultLog() {
+      return new RestAdapter.Log() {
+        @Override public void log(String message) {
+          System.out.println(message);
+        }
+      };
+    }
   }
 
   /** Provides sane defaults for operation on Android. */
   private static class Android extends Platform {
-    @Override Provider<Client> defaultClient() {
-      final Client client = new AndroidApacheClient();
-      return new Provider<Client>() {
+    @Override Client.Provider defaultClient() {
+      final Client client;
+      if (Build.VERSION.SDK_INT < Build.VERSION_CODES.GINGERBREAD) {
+        client = new AndroidApacheClient();
+      } else {
+        client = new UrlConnectionClient();
+      }
+      return new Client.Provider() {
         @Override public Client get() {
           return client;
         }
@@ -83,15 +96,13 @@ Converter defaultConverter() {
 
     @Override Executor defaultHttpExecutor() {
       return Executors.newCachedThreadPool(new ThreadFactory() {
-        private final AtomicInteger threadCounter = new AtomicInteger();
-
         @Override public Thread newThread(final Runnable r) {
           return new Thread(new Runnable() {
             @Override public void run() {
               Process.setThreadPriority(THREAD_PRIORITY_BACKGROUND);
               r.run();
             }
-          }, THREAD_PREFIX + threadCounter.getAndIncrement());
+          }, IDLE_THREAD_NAME);
         }
       });
     }
@@ -99,5 +110,13 @@ Converter defaultConverter() {
     @Override Executor defaultCallbackExecutor() {
       return new MainThreadExecutor();
     }
+
+    @Override RestAdapter.Log defaultLog() {
+      return new RestAdapter.Log() {
+        @Override public void log(String message) {
+          Log.d("Retrofit", message);
+        }
+      };
+    }
   }
 }
diff --git a/retrofit/src/main/java/retrofit/http/Profiler.java b/retrofit/src/main/java/retrofit/http/Profiler.java
index 4ede94a78..f1737906c 100644
--- a/retrofit/src/main/java/retrofit/http/Profiler.java
+++ b/retrofit/src/main/java/retrofit/http/Profiler.java
@@ -11,7 +11,7 @@
   /**
    * Invoked before an HTTP method call. The object returned by this method will be
    * passed to {@link #afterCall} when the call returns.
-   *
+   * <p>
    * This method gives implementors the opportunity to include information that may
    * change during the server call in {@code afterCall} logic.
    */
diff --git a/retrofit/src/main/java/retrofit/http/RequestBuilder.java b/retrofit/src/main/java/retrofit/http/RequestBuilder.java
index 2d95f4c76..a7b849569 100644
--- a/retrofit/src/main/java/retrofit/http/RequestBuilder.java
+++ b/retrofit/src/main/java/retrofit/http/RequestBuilder.java
@@ -4,26 +4,23 @@
 import java.io.UnsupportedEncodingException;
 import java.net.URLEncoder;
 import java.util.ArrayList;
-import java.util.LinkedHashMap;
 import java.util.LinkedHashSet;
 import java.util.List;
-import java.util.Map;
 import java.util.Set;
 import retrofit.http.client.Request;
-import retrofit.io.StringTypedBytes;
-import retrofit.io.TypedBytes;
+import retrofit.http.mime.TypedOutput;
+import retrofit.http.mime.TypedString;
 
-import static retrofit.http.RestAdapter.UTF_8;
 import static retrofit.http.RestMethodInfo.NO_SINGLE_ENTITY;
 
 /**
  * Builds HTTP requests from Java method invocations.  Handles "path parameters" in the
  * {@code apiUrl} in the form of "path/to/url/{id}/action" where a parameter annotated with
- * {@code @Named("id")} is inserted into the url.  Note that this replacement can be recursive if:
+ * {@code @Name("id")} is inserted into the url.  Note that this replacement can be recursive if:
  * <ol>
  * <li>Multiple sets of brackets are nested ("path/to/{{key}a}.</li>
- * <li>The order of {@link javax.inject.Named @Named} values go from innermost to outermost.</li>
- * <li>The values replaced correspond to {@link javax.inject.Named @Named} parameters.</li>
+ * <li>The order of {@link Name @Name} values go from innermost to outermost.</li>
+ * <li>The values replaced correspond to {@link Name @Name} parameters.</li>
  * </ol>
  */
 final class RequestBuilder {
@@ -62,11 +59,6 @@ RequestBuilder setHeaders(List<Header> headers) {
   private List<Parameter> createParamList() {
     List<Parameter> params = new ArrayList<Parameter>();
 
-    // Add query parameter(s), if specified.
-    for (QueryParam annotation : methodInfo.pathQueryParams) {
-      params.add(new Parameter(annotation.name(), annotation.value(), String.class));
-    }
-
     // Add arguments as parameters.
     String[] pathNamedParams = methodInfo.namedParams;
     int singleEntityArgumentIndex = methodInfo.singleEntityArgumentIndex;
@@ -95,17 +87,12 @@ Request build() {
         }
       }
       if (found != null) {
-        String value;
-        try {
-          value = URLEncoder.encode(String.valueOf(found.getValue()), UTF_8);
-        } catch (UnsupportedEncodingException e) {
-          throw new AssertionError(e);
-        }
+        String value = getUrlEncodedValue(found);
         replacedPath = replacedPath.replace("{" + found.getName() + "}", value);
         paramList.remove(found);
       } else {
         throw new IllegalArgumentException(
-            "URL param " + pathParam + " has no matching method @Named param.");
+            "URL param " + pathParam + " has no matching method @Name param.");
       }
     }
 
@@ -113,7 +100,7 @@ Request build() {
       // We're passing a JSON object as the entity: paramList should only contain path param values.
       if (!paramList.isEmpty()) {
         throw new IllegalStateException(
-            "Found @Named param on single-entity request that was not used for path substitution.");
+            "Found @Name param on single-entity request that was not used for path substitution.");
       }
     }
 
@@ -124,39 +111,53 @@ Request build() {
     }
     url.append(replacedPath);
 
-    TypedBytes body = null;
-    Map<String, TypedBytes> bodyParams = new LinkedHashMap<String, TypedBytes>();
+    // Add query parameter(s), if specified.
+    for (QueryParam annotation : methodInfo.pathQueryParams) {
+      paramList.add(new Parameter(annotation.name(), annotation.value(), String.class));
+    }
+
+    TypedOutput body = null;
     if (!methodInfo.restMethod.hasBody()) {
       for (int i = 0, count = paramList.size(); i < count; i++) {
         url.append((i == 0) ? '?' : '&');
         Parameter nonPathParam = paramList.get(i);
-        url.append(nonPathParam.getName()).append("=").append(nonPathParam.getValue());
+        String value = getUrlEncodedValue(nonPathParam);
+        url.append(nonPathParam.getName()).append("=").append(value);
       }
     } else if (!paramList.isEmpty()) {
       if (methodInfo.isMultipart) {
+        MultipartTypedOutput multipartBody = new MultipartTypedOutput();
         for (Parameter parameter : paramList) {
           Object value = parameter.getValue();
-          TypedBytes typedBytes;
-          if (value instanceof TypedBytes) {
-            typedBytes = (TypedBytes) value;
+          TypedOutput typedOutput;
+          if (value instanceof TypedOutput) {
+            typedOutput = (TypedOutput) value;
           } else {
-            typedBytes = new StringTypedBytes(value.toString());
+            typedOutput = new TypedString(value.toString());
           }
-          bodyParams.put(parameter.getName(), typedBytes);
+          multipartBody.addPart(parameter.getName(), typedOutput);
         }
+        body = multipartBody;
       } else {
         body = converter.toBody(paramList);
       }
     } else if (methodInfo.singleEntityArgumentIndex != NO_SINGLE_ENTITY) {
       Object singleEntity = args[methodInfo.singleEntityArgumentIndex];
-      if (singleEntity instanceof TypedBytes) {
-        body = (TypedBytes) singleEntity;
+      if (singleEntity instanceof TypedOutput) {
+        body = (TypedOutput) singleEntity;
       } else {
         body = converter.toBody(singleEntity);
       }
     }
 
-    return new Request(methodInfo.restMethod.value(), url.toString(), headers,
-        methodInfo.isMultipart, body, bodyParams);
+    return new Request(methodInfo.restMethod.value(), url.toString(), headers, body);
+  }
+
+  private static String getUrlEncodedValue(Parameter found) {
+    try {
+      return URLEncoder.encode(String.valueOf(found.getValue()), "UTF-8");
+    } catch (UnsupportedEncodingException e) {
+      throw new AssertionError(e);
+    }
   }
 }
\ No newline at end of file
diff --git a/retrofit/src/main/java/retrofit/http/ResponseWrapper.java b/retrofit/src/main/java/retrofit/http/ResponseWrapper.java
new file mode 100644
index 000000000..4be0b7822
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/http/ResponseWrapper.java
@@ -0,0 +1,20 @@
+package retrofit.http;
+
+import retrofit.http.client.Response;
+
+/**
+ * A wrapper that holds the {@link Response} and {@link Converter} response to be used by the
+ * {@link CallbackRunnable} for success method calls on {@link Callback}.
+ *
+ * @author JJ Ford (jj.n.ford@gmail.com)
+ */
+final class ResponseWrapper {
+
+  final Response response;
+  final Object responseBody;
+
+  public ResponseWrapper(Response response, Object responseBody) {
+    this.response = response;
+    this.responseBody = responseBody;
+  }
+}
diff --git a/retrofit/src/main/java/retrofit/http/RestAdapter.java b/retrofit/src/main/java/retrofit/http/RestAdapter.java
index 1e06c7cf9..7c67c2d52 100644
--- a/retrofit/src/main/java/retrofit/http/RestAdapter.java
+++ b/retrofit/src/main/java/retrofit/http/RestAdapter.java
@@ -1,28 +1,24 @@
 // Copyright 2012 Square, Inc.
 package retrofit.http;
 
+import java.io.ByteArrayOutputStream;
 import java.io.IOException;
-import java.io.UnsupportedEncodingException;
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.lang.reflect.Proxy;
 import java.lang.reflect.Type;
-import java.util.Collections;
 import java.util.LinkedHashMap;
-import java.util.List;
 import java.util.Map;
 import java.util.concurrent.Executor;
 import java.util.concurrent.TimeUnit;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-import javax.inject.Provider;
-import org.apache.http.protocol.HTTP;
 import retrofit.http.Profiler.RequestInformation;
 import retrofit.http.client.Client;
 import retrofit.http.client.Request;
 import retrofit.http.client.Response;
-import retrofit.io.TypedBytes;
+import retrofit.http.mime.TypedByteArray;
+import retrofit.http.mime.TypedInput;
+import retrofit.http.mime.TypedOutput;
 
 import static retrofit.http.Utils.SynchronousExecutor;
 
@@ -33,38 +29,52 @@
  * @author Jake Wharton (jw@squareup.com)
  */
 public class RestAdapter {
-  private static final Logger LOGGER = Logger.getLogger(RestAdapter.class.getName());
   private static final int LOG_CHUNK_SIZE = 4000;
   static final String THREAD_PREFIX = "Retrofit-";
-  static final String UTF_8 = "UTF-8";
+  static final String IDLE_THREAD_NAME = THREAD_PREFIX + "Idle";
+
+  /** Simple logging abstraction for debug messages. */
+  public interface Log {
+    /** Log a debug message to the appropriate console. */
+    void log(String message);
+  }
 
   private final Server server;
-  private final Provider<Client> clientProvider;
+  private final Client.Provider clientProvider;
   private final Executor httpExecutor;
   private final Executor callbackExecutor;
-  private final Provider<List<Header>> headersProvider;
+  private final Headers headers;
   private final Converter converter;
   private final Profiler profiler;
+  private final Log log;
+  private volatile boolean debug;
 
-  private RestAdapter(Server server, Provider<Client> clientProvider, Executor httpExecutor,
-      Executor callbackExecutor, Provider<List<Header>> headersProvider, Converter converter,
-      Profiler profiler) {
+  private RestAdapter(Server server, Client.Provider clientProvider, Executor httpExecutor,
+      Executor callbackExecutor, Headers headers, Converter converter, Profiler profiler, Log log,
+      boolean debug) {
     this.server = server;
     this.clientProvider = clientProvider;
     this.httpExecutor = httpExecutor;
     this.callbackExecutor = callbackExecutor;
-    this.headersProvider = headersProvider;
+    this.headers = headers;
     this.converter = converter;
     this.profiler = profiler;
+    this.log = log;
+    this.debug = debug;
+  }
+
+  /** Toggle debug logging on and off. */
+  public void setDebug(boolean debug) {
+    this.debug = debug;
   }
 
   /**
    * Adapts a Java interface to a REST API.
-   * <p/>
+   * <p>
    * The relative path for a given method is obtained from an annotation on the method describing
-   * the request type. The names of URL parameters are retrieved from {@link javax.inject.Named}
+   * the request type. The names of URL parameters are retrieved from {@link Name}
    * annotations on the method parameters.
-   * <p/>
+   * <p>
    * HTTP requests happen in one of two ways:
    * <ul>
    * <li>On the provided HTTP {@link Executor} with callbacks marshaled to the callback
@@ -76,14 +86,14 @@ private RestAdapter(Server server, Provider<Client> clientProvider, Executor htt
    * response will be converted to the method's return type using the specified
    * {@link Converter}.</li>
    * </ul>
-   * <p/>
+   * <p>
    * For example:
    * <pre>
    *   public interface MyApi {
    *     &#64;POST("go") // Asynchronous execution.
-   *     void go(@Named("a") String a, @Named("b") int b, Callback&lt;? super MyResult> callback);
+   *     void go(@Name("a") String a, @Name("b") int b, Callback&lt;? super MyResult> callback);
    *     &#64;POST("go") // Synchronous execution.
-   *     MyResult go(@Named("a") String a, @Named("b") int b);
+   *     MyResult go(@Name("a") String a, @Name("b") int b);
    *   }
    * </pre>
    *
@@ -130,8 +140,8 @@ private RestAdapter(Server server, Provider<Client> clientProvider, Executor htt
       }
       Callback<?> callback = (Callback<?>) args[args.length - 1];
       httpExecutor.execute(new CallbackRunnable(callback, callbackExecutor) {
-        @Override public Object obtainResponse() {
-          return invokeRequest(methodDetails, args);
+        @Override public ResponseWrapper obtainResponse() {
+          return (ResponseWrapper) invokeRequest(methodDetails, args);
         }
       });
       return null; // Asynchronous methods should have return type of void.
@@ -146,20 +156,24 @@ private RestAdapter(Server server, Provider<Client> clientProvider, Executor htt
     private Object invokeRequest(RestMethodInfo methodDetails, Object[] args) {
       methodDetails.init(); // Ensure all relevant method information has been loaded.
 
-      String url = server.apiUrl();
+      String serverUrl = server.getUrl();
+      String url = serverUrl; // Keep some url in case RequestBuilder throws an exception.
       try {
         Request request = new RequestBuilder(converter) //
-            .setApiUrl(server.apiUrl())
+            .setApiUrl(serverUrl)
             .setArgs(args)
-            .setHeaders(headersProvider.get())
+            .setHeaders(headers.get())
             .setMethodInfo(methodDetails)
             .build();
         url = request.getUrl();
-        LOGGER.fine("Sending " + request.getMethod() + " to " + url);
 
         if (!methodDetails.isSynchronous) {
           // If we are executing asynchronously then update the current thread with a useful name.
-          Thread.currentThread().setName(THREAD_PREFIX + url);
+          Thread.currentThread().setName(THREAD_PREFIX + url.substring(serverUrl.length()));
+        }
+
+        if (debug) {
+          request = logAndReplaceRequest(request);
         }
 
         Object profilerObject = null;
@@ -173,37 +187,47 @@ private Object invokeRequest(RestMethodInfo methodDetails, Object[] args) {
 
         int statusCode = response.getStatus();
         if (profiler != null) {
-          RequestInformation requestInfo = getRequestInfo(server, methodDetails, request);
+          RequestInformation requestInfo = getRequestInfo(serverUrl, methodDetails, request);
           profiler.afterCall(requestInfo, elapsedTime, statusCode, profilerObject);
         }
 
-        byte[] body = response.getBody();
-        if (LOGGER.isLoggable(Level.FINE)) {
-          logResponseBody(url, body, statusCode, elapsedTime);
-        }
-
-        List<Header> headers = response.getHeaders();
-        for (Header header : headers) {
-          if (HTTP.CONTENT_TYPE.equalsIgnoreCase(header.getName()) //
-              && !UTF_8.equalsIgnoreCase(Utils.parseCharset(header.getValue()))) {
-            throw new IOException("Only UTF-8 charset supported.");
-          }
+        if (debug) {
+          response = logAndReplaceResponse(url, response, elapsedTime);
         }
 
         Type type = methodDetails.type;
+
         if (statusCode >= 200 && statusCode < 300) { // 2XX == successful request
+          // Caller requested the raw Response object directly.
           if (type.equals(Response.class)) {
-            return response;
+            // Read the entire stream and replace with one backed by a byte[]
+            response = Utils.readBodyToBytesIfNecessary(response);
+
+            if (methodDetails.isSynchronous) {
+              return response;
+            }
+            return new ResponseWrapper(response, response);
           }
+
+          TypedInput body = response.getBody();
           if (body == null) {
-            return null;
+            return new ResponseWrapper(response, null);
           }
           try {
-            return converter.fromBody(body, type);
+            Object convert = converter.fromBody(body, type);
+            if (methodDetails.isSynchronous) {
+              return convert;
+            }
+            return new ResponseWrapper(response, convert);
           } catch (ConversionException e) {
+            // The response body was partially read by the converter. Replace it with null.
+            response = Utils.replaceResponseBody(response, null);
+
             throw RetrofitError.conversionError(url, response, converter, type, e);
           }
         }
+
+        response = Utils.readBodyToBytesIfNecessary(response);
         throw RetrofitError.httpError(url, response, converter, type);
       } catch (RetrofitError e) {
         throw e; // Pass through our own errors.
@@ -211,45 +235,112 @@ private Object invokeRequest(RestMethodInfo methodDetails, Object[] args) {
         throw RetrofitError.networkError(url, e);
       } catch (Throwable t) {
         throw RetrofitError.unexpectedError(url, t);
+      } finally {
+        if (!methodDetails.isSynchronous) {
+          Thread.currentThread().setName(IDLE_THREAD_NAME);
+        }
+      }
+    }
+  }
+
+  /** Log request headers and body. Consumes request body and returns identical replacement. */
+  private Request logAndReplaceRequest(Request request) throws IOException {
+    log.log(String.format("---> HTTP %s %s", request.getMethod(), request.getUrl()));
+
+    for (Header header : request.getHeaders()) {
+      log.log(header.getName() + ": " + header.getValue());
+    }
+
+    TypedOutput body = request.getBody();
+    int bodySize = 0;
+    if (body != null) {
+      if (!request.getHeaders().isEmpty()) {
+        log.log("");
+      }
+
+      ByteArrayOutputStream baos = new ByteArrayOutputStream();
+      body.writeTo(baos);
+      byte[] bodyBytes = baos.toByteArray();
+      bodySize = bodyBytes.length;
+      String bodyMime = body.mimeType();
+      String bodyString = new String(bodyBytes, Utils.parseCharset(bodyMime));
+      for (int i = 0, len = bodyString.length(); i < len; i += LOG_CHUNK_SIZE) {
+        int end = Math.min(len, i + LOG_CHUNK_SIZE);
+        log.log(bodyString.substring(i, end));
       }
+
+      body = new TypedByteArray(bodyMime, bodyBytes);
     }
+
+    log.log(String.format("---> END HTTP (%s-byte body)", bodySize));
+
+    // Since we consumed the original request, return a new, identical one from its bytes.
+    return new Request(request.getMethod(), request.getUrl(), request.getHeaders(), body);
   }
 
-  private static void logResponseBody(String url, byte[] body, int statusCode, long elapsedTime)
-      throws UnsupportedEncodingException {
-    LOGGER.fine("---- HTTP " + statusCode + " from " + url + " (" + elapsedTime + "ms)");
-    String bodyString = new String(body, UTF_8);
-    for (int i = 0; i < body.length; i += LOG_CHUNK_SIZE) {
-      int end = Math.min(bodyString.length(), i + LOG_CHUNK_SIZE);
-      LOGGER.fine(bodyString.substring(i, end));
+  /** Log response headers and body. Consumes response body and returns identical replacement. */
+  private Response logAndReplaceResponse(String url, Response response, long elapsedTime)
+      throws IOException {
+    log.log(String.format("<--- HTTP %s %s (%sms)", response.getStatus(), url, elapsedTime));
+
+    for (Header header : response.getHeaders()) {
+      log.log(header.getName() + ": " + header.getValue());
     }
-    LOGGER.fine("---- END HTTP");
+
+    TypedInput body = response.getBody();
+    int bodySize = 0;
+    if (body != null) {
+      if (!response.getHeaders().isEmpty()) {
+        log.log("");
+      }
+
+      if (!(body instanceof TypedByteArray)) {
+        // Read the entire response body to we can log it and replace the original response
+        response = Utils.readBodyToBytesIfNecessary(response);
+        body = response.getBody();
+      }
+
+      byte[] bodyBytes = ((TypedByteArray) body).getBytes();
+      bodySize = bodyBytes.length;
+      String bodyMime = body.mimeType();
+      String bodyCharset = Utils.parseCharset(bodyMime);
+      String bodyString = new String(bodyBytes, bodyCharset);
+      for (int i = 0, len = bodyString.length(); i < len; i += LOG_CHUNK_SIZE) {
+        int end = Math.min(len, i + LOG_CHUNK_SIZE);
+        log.log(bodyString.substring(i, end));
+      }
+    }
+
+    log.log(String.format("<--- END HTTP (%s-byte body)", bodySize));
+
+    return response;
   }
 
-  private static Profiler.RequestInformation getRequestInfo(Server server,
+  private static Profiler.RequestInformation getRequestInfo(String serverUrl,
       RestMethodInfo methodDetails, Request request) {
     long contentLength = 0;
     String contentType = null;
 
-    TypedBytes body = request.getBody();
+    TypedOutput body = request.getBody();
     if (body != null) {
       contentLength = body.length();
       contentType = body.mimeType();
     }
 
-    return new Profiler.RequestInformation(methodDetails.restMethod.value(), server.apiUrl(),
+    return new Profiler.RequestInformation(methodDetails.restMethod.value(), serverUrl,
         methodDetails.path, contentLength, contentType);
   }
 
   /**
    * Build a new {@link RestAdapter}.
-   * <p/>
+   * <p>
    * Calling the following methods is required before calling {@link #build()}:
    * <ul>
    * <li>{@link #setServer(Server)}</li>
-   * <li>{@link #setClient(javax.inject.Provider)}</li>
+   * <li>{@link #setClient(Client.Provider)}</li>
    * <li>{@link #setConverter(Converter)}</li>
    * </ul>
+   * <p>
    * If you are using asynchronous execution (i.e., with {@link Callback Callbacks}) the following
    * is also required:
    * <ul>
@@ -258,12 +349,14 @@ private static void logResponseBody(String url, byte[] body, int statusCode, lon
    */
   public static class Builder {
     private Server server;
-    private Provider<Client> clientProvider;
+    private Client.Provider clientProvider;
     private Executor httpExecutor;
     private Executor callbackExecutor;
-    private Provider<List<Header>> headersProvider;
+    private Headers headers;
     private Converter converter;
     private Profiler profiler;
+    private Log log;
+    private boolean debug;
 
     public Builder setServer(String endpoint) {
       if (endpoint == null) throw new NullPointerException("endpoint");
@@ -278,14 +371,14 @@ public Builder setServer(Server server) {
 
     public Builder setClient(final Client client) {
       if (client == null) throw new NullPointerException("client");
-      return setClient(new Provider<Client>() {
+      return setClient(new Client.Provider() {
         @Override public Client get() {
           return client;
         }
       });
     }
 
-    public Builder setClient(Provider<Client> clientProvider) {
+    public Builder setClient(Client.Provider clientProvider) {
       if (clientProvider == null) throw new NullPointerException("clientProvider");
       this.clientProvider = clientProvider;
       return this;
@@ -307,17 +400,9 @@ public Builder setExecutors(Executor httpExecutor, Executor callbackExecutor) {
       return this;
     }
 
-    public Builder setHeaders(final List<Header> headers) {
-      return setHeaders(new Provider<List<Header>>() {
-        @Override public List<Header> get() {
-          return headers;
-        }
-      });
-    }
-
-    public Builder setHeaders(Provider<List<Header>> headersProvider) {
-      if (headersProvider == null) throw new NullPointerException("headersProvider");
-      this.headersProvider = headersProvider;
+    public Builder setHeaders(Headers headers) {
+      if (headers == null) throw new NullPointerException("headers");
+      this.headers = headers;
       return this;
     }
 
@@ -333,13 +418,24 @@ public Builder setProfiler(Profiler profiler) {
       return this;
     }
 
+    public Builder setLog(Log log) {
+      if (log == null) throw new NullPointerException("log");
+      this.log = log;
+      return this;
+    }
+
+    public Builder setDebug(boolean debug) {
+      this.debug = debug;
+      return this;
+    }
+
     public RestAdapter build() {
       if (server == null) {
         throw new IllegalArgumentException("Server may not be null.");
       }
       ensureSaneDefaults();
-      return new RestAdapter(server, clientProvider, httpExecutor, callbackExecutor,
-          headersProvider, converter, profiler);
+      return new RestAdapter(server, clientProvider, httpExecutor, callbackExecutor, headers,
+          converter, profiler, log, debug);
     }
 
     private void ensureSaneDefaults() {
@@ -355,13 +451,12 @@ private void ensureSaneDefaults() {
       if (callbackExecutor == null) {
         callbackExecutor = Platform.get().defaultCallbackExecutor();
       }
-      if (headersProvider == null) {
-        headersProvider = new Provider<List<Header>>() {
-          @Override public List<Header> get() {
-            return Collections.emptyList();
-          }
-        };
+      if (log == null) {
+        log = Platform.get().defaultLog();
+      }
+      if (headers == null) {
+        headers = Headers.NONE;
       }
     }
   }
-}
\ No newline at end of file
+}
diff --git a/retrofit/src/main/java/retrofit/http/RestMethodInfo.java b/retrofit/src/main/java/retrofit/http/RestMethodInfo.java
index 463c2b0df..e7ac42b56 100644
--- a/retrofit/src/main/java/retrofit/http/RestMethodInfo.java
+++ b/retrofit/src/main/java/retrofit/http/RestMethodInfo.java
@@ -10,8 +10,7 @@
 import java.util.Set;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
-import javax.inject.Named;
-import retrofit.io.TypedBytes;
+import retrofit.http.mime.TypedOutput;
 
 /** Cached details about an interface method. */
 final class RestMethodInfo {
@@ -104,6 +103,12 @@ private void parseMethodAnnotations() {
     }
     if (pathQueryParams == null) {
       pathQueryParams = new QueryParam[0];
+    } else {
+      for (QueryParam pathQueryParam : pathQueryParams) {
+        if (pathParams.contains(pathQueryParam.name())) {
+          throw new IllegalStateException("Query parameters cannot be present in URL.");
+        }
+      }
     }
   }
 
@@ -145,7 +150,7 @@ private boolean parseResponseType() {
       return true;
     }
 
-    lastArgType = Utils.getGenericSupertype(lastArgType, lastArgClass, Callback.class);
+    lastArgType = Types.getSupertype(lastArgType, Types.getRawType(lastArgType), Callback.class);
     if (lastArgType instanceof ParameterizedType) {
       Type[] types = ((ParameterizedType) lastArgType).getActualTypeArguments();
       for (int i = 0; i < types.length; i++) {
@@ -183,12 +188,12 @@ private void parseParameters() {
       }
       for (Annotation parameterAnnotation : parameterAnnotations) {
         Class<? extends Annotation> annotationType = parameterAnnotation.annotationType();
-        if (annotationType == Named.class) {
-          String name = ((Named) parameterAnnotation).value();
+        if (annotationType == Name.class) {
+          String name = ((Name) parameterAnnotation).value();
           namedParams[i] = name;
           boolean isPathParam = pathParams.contains(name);
-          if (parameterType == TypedBytes.class && (isPathParam || !restMethod.hasBody())) {
-            throw new IllegalStateException("TypedBytes cannot be used as URL parameter.");
+          if (parameterType == TypedOutput.class && (isPathParam || !restMethod.hasBody())) {
+            throw new IllegalStateException("TypedOutput cannot be used as URL parameter.");
           }
           if (!isPathParam && !isMultipart && restMethod.hasBody()) {
             throw new IllegalStateException(
@@ -220,7 +225,7 @@ private void parseParameters() {
     }
     if (!restMethod.hasBody() && (isMultipart || singleEntityArgumentIndex != NO_SINGLE_ENTITY)) {
       throw new IllegalStateException(
-          "Non-body HTTP method cannot contain @SingleEntity or @TypedBytes.");
+          "Non-body HTTP method cannot contain @SingleEntity or @TypedOutput.");
     }
     this.namedParams = namedParams;
   }
diff --git a/retrofit/src/main/java/retrofit/http/RetrofitError.java b/retrofit/src/main/java/retrofit/http/RetrofitError.java
index 10d8d572c..cd1476864 100644
--- a/retrofit/src/main/java/retrofit/http/RetrofitError.java
+++ b/retrofit/src/main/java/retrofit/http/RetrofitError.java
@@ -4,6 +4,7 @@
 import java.io.IOException;
 import java.lang.reflect.Type;
 import retrofit.http.client.Response;
+import retrofit.http.mime.TypedInput;
 
 public class RetrofitError extends RuntimeException {
   static RetrofitError networkError(String url, IOException exception) {
@@ -29,16 +30,15 @@ static RetrofitError unexpectedError(String url, Throwable exception) {
   private final Converter converter;
   private final Type successType;
   private final boolean networkError;
-  private final Throwable exception;
 
   private RetrofitError(String url, Response response, Converter converter, Type successType,
       boolean networkError, Throwable exception) {
+    super(exception);
     this.url = url;
     this.response = response;
     this.converter = converter;
     this.successType = successType;
     this.networkError = networkError;
-    this.exception = exception;
   }
 
   /** The request URL which produced the error. */
@@ -61,7 +61,7 @@ public boolean isNetworkError() {
    * the generic type of the supplied {@link Callback} parameter.
    */
   public Object getBody() {
-    byte[] body = response.getBody();
+    TypedInput body = response.getBody();
     if (body == null) {
       return null;
     }
@@ -74,7 +74,7 @@ public Object getBody() {
 
   /** HTTP response body converted to specified {@code type}. */
   public Object getBodyAs(Type type) {
-    byte[] body = response.getBody();
+    TypedInput body = response.getBody();
     if (body == null) {
       return null;
     }
@@ -84,9 +84,4 @@ public Object getBodyAs(Type type) {
       throw new RuntimeException(e);
     }
   }
-
-  /** The exception which caused this error, if any. */
-  public Throwable getException() {
-    return exception;
-  }
-}
\ No newline at end of file
+}
diff --git a/retrofit/src/main/java/retrofit/http/Server.java b/retrofit/src/main/java/retrofit/http/Server.java
index 1fe362a22..b1c63b820 100644
--- a/retrofit/src/main/java/retrofit/http/Server.java
+++ b/retrofit/src/main/java/retrofit/http/Server.java
@@ -2,33 +2,36 @@
 package retrofit.http;
 
 /**
- * Server information. Applications may extend this class and return different URLs over time.
- * Callers should always consult the Server instance for the latest values rather than caching URLs.
+ * Represents an API endpoint URL and associated name. Callers should always consult the instance
+ * for the latest values rather than caching the returned values.
  *
  * @author Bob Lee (bob@squareup.com)
+ * @see ChangeableServer
  */
 public class Server {
-  public static final String DEFAULT_TYPE = "default";
+  public static final String DEFAULT_NAME = "default";
 
   private final String apiUrl;
   private final String type;
 
+  /** Create a server with the provided URL and default name. */
   public Server(String apiUrl) {
-    this(apiUrl, DEFAULT_TYPE);
+    this(apiUrl, DEFAULT_NAME);
   }
 
+  /** Create a server with the provided URL and name. */
   public Server(String apiUrl, String type) {
     this.apiUrl = apiUrl;
     this.type = type;
   }
 
-  /** Gets the base API url. */
-  public String apiUrl() {
+  /** The base API URL. */
+  public String getUrl() {
     return apiUrl;
   }
 
-  /** Gets a human-readable server type for differentiating between multiple instances. */
-  public String type() {
+  /** A name for differentiating between multiple API URLs. */
+  public String getName() {
     return type;
   }
 }
diff --git a/retrofit/src/main/java/retrofit/http/SingleEntity.java b/retrofit/src/main/java/retrofit/http/SingleEntity.java
index 445ccb377..ff0be889b 100644
--- a/retrofit/src/main/java/retrofit/http/SingleEntity.java
+++ b/retrofit/src/main/java/retrofit/http/SingleEntity.java
@@ -1,16 +1,22 @@
 // Copyright 2011 Square, Inc.
 package retrofit.http;
 
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.PARAMETER;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
 /**
  * Use this annotation on a service method param when you want to directly control the request body
  * of a POST/PUT request (instead of sending in as request parameters or form-style request
- * body).  If the value of the parameter implements TypedBytes, the request body will be written
- * exactly as specified by the TypedBytes.writeTo object.  If it doesn't implement TypedBytes, the
+ * body).  If the value of the parameter implements TypedOutput, the request body will be written
+ * exactly as specified by the TypedOutput.writeTo object.  If it doesn't implement TypedOutput, the
  * object will be serialized into JSON and the result will be set directly as the request body.
  *
  * @author Eric Denman (edenman@squareup.com)
  */
-@java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)
-@java.lang.annotation.Target(java.lang.annotation.ElementType.PARAMETER)
+@Retention(RUNTIME)
+@Target(PARAMETER)
 public @interface SingleEntity {
 }
diff --git a/retrofit/src/main/java/retrofit/http/Types.java b/retrofit/src/main/java/retrofit/http/Types.java
new file mode 100644
index 000000000..3aadc9c22
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/http/Types.java
@@ -0,0 +1,415 @@
+/**
+ * Copyright (C) 2008 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package retrofit.http;
+
+import java.lang.reflect.Array;
+import java.lang.reflect.GenericArrayType;
+import java.lang.reflect.GenericDeclaration;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.lang.reflect.TypeVariable;
+import java.lang.reflect.WildcardType;
+import java.util.Arrays;
+import java.util.NoSuchElementException;
+
+/**
+ * Static methods for working with types.
+ *
+ * @author Bob Lee
+ * @author Jesse Wilson
+ */
+final class Types {
+  private static final Type[] EMPTY_TYPE_ARRAY = new Type[0];
+
+  private Types() {
+    // No instances.
+  }
+
+  public static Class<?> getRawType(Type type) {
+    if (type instanceof Class<?>) {
+      // Type is a normal class.
+      return (Class<?>) type;
+
+    } else if (type instanceof ParameterizedType) {
+      ParameterizedType parameterizedType = (ParameterizedType) type;
+
+      // I'm not exactly sure why getRawType() returns Type instead of Class. Neal isn't either but
+      // suspects some pathological case related to nested classes exists.
+      Type rawType = parameterizedType.getRawType();
+      if (!(rawType instanceof Class)) throw new IllegalArgumentException();
+      return (Class<?>) rawType;
+
+    } else if (type instanceof GenericArrayType) {
+      Type componentType = ((GenericArrayType) type).getGenericComponentType();
+      return Array.newInstance(getRawType(componentType), 0).getClass();
+
+    } else if (type instanceof TypeVariable) {
+      // We could use the variable's bounds, but that won't work if there are multiple. Having a raw
+      // type that's more general than necessary is okay.
+      return Object.class;
+
+    } else if (type instanceof WildcardType) {
+      return getRawType(((WildcardType) type).getUpperBounds()[0]);
+
+    } else {
+      String className = type == null ? "null" : type.getClass().getName();
+      throw new IllegalArgumentException("Expected a Class, ParameterizedType, or "
+          + "GenericArrayType, but <" + type + "> is of type " + className);
+    }
+  }
+
+  /** Returns true if {@code a} and {@code b} are equal. */
+  public static boolean equals(Type a, Type b) {
+    if (a == b) {
+      return true; // Also handles (a == null && b == null).
+
+    } else if (a instanceof Class) {
+      return a.equals(b); // Class already specifies equals().
+
+    } else if (a instanceof ParameterizedType) {
+      if (!(b instanceof ParameterizedType)) return false;
+      ParameterizedType pa = (ParameterizedType) a;
+      ParameterizedType pb = (ParameterizedType) b;
+      return equal(pa.getOwnerType(), pb.getOwnerType())
+          && pa.getRawType().equals(pb.getRawType())
+          && Arrays.equals(pa.getActualTypeArguments(), pb.getActualTypeArguments());
+
+    } else if (a instanceof GenericArrayType) {
+      if (!(b instanceof GenericArrayType)) return false;
+      GenericArrayType ga = (GenericArrayType) a;
+      GenericArrayType gb = (GenericArrayType) b;
+      return equals(ga.getGenericComponentType(), gb.getGenericComponentType());
+
+    } else if (a instanceof WildcardType) {
+      if (!(b instanceof WildcardType)) return false;
+      WildcardType wa = (WildcardType) a;
+      WildcardType wb = (WildcardType) b;
+      return Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds())
+          && Arrays.equals(wa.getLowerBounds(), wb.getLowerBounds());
+
+    } else if (a instanceof TypeVariable) {
+      if (!(b instanceof TypeVariable)) return false;
+      TypeVariable<?> va = (TypeVariable<?>) a;
+      TypeVariable<?> vb = (TypeVariable<?>) b;
+      return va.getGenericDeclaration() == vb.getGenericDeclaration()
+          && va.getName().equals(vb.getName());
+
+    } else {
+      return false; // This isn't a type we support!
+    }
+  }
+
+  /**
+   * Returns the generic supertype for {@code supertype}. For example, given a class {@code
+   * IntegerSet}, the result for when supertype is {@code Set.class} is {@code Set<Integer>} and the
+   * result when the supertype is {@code Collection.class} is {@code Collection<Integer>}.
+   */
+  static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResolve) {
+    if (toResolve == rawType) return context;
+
+    // We skip searching through interfaces if unknown is an interface.
+    if (toResolve.isInterface()) {
+      Class<?>[] interfaces = rawType.getInterfaces();
+      for (int i = 0, length = interfaces.length; i < length; i++) {
+        if (interfaces[i] == toResolve) {
+          return rawType.getGenericInterfaces()[i];
+        } else if (toResolve.isAssignableFrom(interfaces[i])) {
+          return getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], toResolve);
+        }
+      }
+    }
+
+    // Check our supertypes.
+    if (!rawType.isInterface()) {
+      while (rawType != Object.class) {
+        Class<?> rawSupertype = rawType.getSuperclass();
+        if (rawSupertype == toResolve) {
+          return rawType.getGenericSuperclass();
+        } else if (toResolve.isAssignableFrom(rawSupertype)) {
+          return getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, toResolve);
+        }
+        rawType = rawSupertype;
+      }
+    }
+
+    // We can't resolve this further.
+    return toResolve;
+  }
+
+  private static int indexOf(Object[] array, Object toFind) {
+    for (int i = 0; i < array.length; i++) {
+      if (toFind.equals(array[i])) return i;
+    }
+    throw new NoSuchElementException();
+  }
+
+  private static boolean equal(Object a, Object b) {
+    return a == b || (a != null && a.equals(b));
+  }
+
+  private static int hashCodeOrZero(Object o) {
+    return o != null ? o.hashCode() : 0;
+  }
+
+  public static String typeToString(Type type) {
+    return type instanceof Class ? ((Class<?>) type).getName() : type.toString();
+  }
+
+  /**
+   * Returns the generic form of {@code supertype}. For example, if this is {@code
+   * ArrayList<String>}, this returns {@code Iterable<String>} given the input {@code
+   * Iterable.class}.
+   *
+   * @param supertype a superclass of, or interface implemented by, this.
+   */
+  public static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) {
+    if (!supertype.isAssignableFrom(contextRawType)) throw new IllegalArgumentException();
+    return resolve(context, contextRawType,
+        getGenericSupertype(context, contextRawType, supertype));
+  }
+
+  public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {
+    // This implementation is made a little more complicated in an attempt to avoid object-creation.
+    while (true) {
+      if (toResolve instanceof TypeVariable) {
+        TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;
+        toResolve = resolveTypeVariable(context, contextRawType, typeVariable);
+        if (toResolve == typeVariable) {
+          return toResolve;
+        }
+
+      } else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {
+        Class<?> original = (Class<?>) toResolve;
+        Type componentType = original.getComponentType();
+        Type newComponentType = resolve(context, contextRawType, componentType);
+        return componentType == newComponentType ? original : new GenericArrayTypeImpl(
+            newComponentType);
+
+      } else if (toResolve instanceof GenericArrayType) {
+        GenericArrayType original = (GenericArrayType) toResolve;
+        Type componentType = original.getGenericComponentType();
+        Type newComponentType = resolve(context, contextRawType, componentType);
+        return componentType == newComponentType ? original : new GenericArrayTypeImpl(
+            newComponentType);
+
+      } else if (toResolve instanceof ParameterizedType) {
+        ParameterizedType original = (ParameterizedType) toResolve;
+        Type ownerType = original.getOwnerType();
+        Type newOwnerType = resolve(context, contextRawType, ownerType);
+        boolean changed = newOwnerType != ownerType;
+
+        Type[] args = original.getActualTypeArguments();
+        for (int t = 0, length = args.length; t < length; t++) {
+          Type resolvedTypeArgument = resolve(context, contextRawType, args[t]);
+          if (resolvedTypeArgument != args[t]) {
+            if (!changed) {
+              args = args.clone();
+              changed = true;
+            }
+            args[t] = resolvedTypeArgument;
+          }
+        }
+
+        return changed
+            ? new ParameterizedTypeImpl(newOwnerType, original.getRawType(), args)
+            : original;
+
+      } else if (toResolve instanceof WildcardType) {
+        WildcardType original = (WildcardType) toResolve;
+        Type[] originalLowerBound = original.getLowerBounds();
+        Type[] originalUpperBound = original.getUpperBounds();
+
+        if (originalLowerBound.length == 1) {
+          Type lowerBound = resolve(context, contextRawType, originalLowerBound[0]);
+          if (lowerBound != originalLowerBound[0]) {
+            return new WildcardTypeImpl(new Type[] { Object.class }, new Type[] { lowerBound });
+          }
+        } else if (originalUpperBound.length == 1) {
+          Type upperBound = resolve(context, contextRawType, originalUpperBound[0]);
+          if (upperBound != originalUpperBound[0]) {
+            return new WildcardTypeImpl(new Type[] { upperBound }, EMPTY_TYPE_ARRAY);
+          }
+        }
+        return original;
+
+      } else {
+        return toResolve;
+      }
+    }
+  }
+
+  private static Type resolveTypeVariable(
+      Type context, Class<?> contextRawType, TypeVariable<?> unknown) {
+    Class<?> declaredByRaw = declaringClassOf(unknown);
+
+    // We can't reduce this further.
+    if (declaredByRaw == null) return unknown;
+
+    Type declaredBy = getGenericSupertype(context, contextRawType, declaredByRaw);
+    if (declaredBy instanceof ParameterizedType) {
+      int index = indexOf(declaredByRaw.getTypeParameters(), unknown);
+      return ((ParameterizedType) declaredBy).getActualTypeArguments()[index];
+    }
+
+    return unknown;
+  }
+
+  /**
+   * Returns the declaring class of {@code typeVariable}, or {@code null} if it was not declared by
+   * a class.
+   */
+  private static Class<?> declaringClassOf(TypeVariable<?> typeVariable) {
+    GenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();
+    return genericDeclaration instanceof Class ? (Class<?>) genericDeclaration : null;
+  }
+
+  private static void checkNotPrimitive(Type type) {
+    if (type instanceof Class<?> && ((Class<?>) type).isPrimitive()) {
+      throw new IllegalArgumentException();
+    }
+  }
+
+  private static final class ParameterizedTypeImpl implements ParameterizedType {
+    private final Type ownerType;
+    private final Type rawType;
+    private final Type[] typeArguments;
+
+    public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments) {
+      // Require an owner type if the raw type needs it.
+      if (rawType instanceof Class<?>
+          && (ownerType == null) != (((Class<?>) rawType).getEnclosingClass() == null)) {
+        throw new IllegalArgumentException();
+      }
+
+      this.ownerType = ownerType;
+      this.rawType = rawType;
+      this.typeArguments = typeArguments.clone();
+
+      for (Type typeArgument : this.typeArguments) {
+        if (typeArgument == null) throw new NullPointerException();
+        checkNotPrimitive(typeArgument);
+      }
+    }
+
+    public Type[] getActualTypeArguments() {
+      return typeArguments.clone();
+    }
+
+    public Type getRawType() {
+      return rawType;
+    }
+
+    public Type getOwnerType() {
+      return ownerType;
+    }
+
+    @Override public boolean equals(Object other) {
+      return other instanceof ParameterizedType && Types.equals(this, (ParameterizedType) other);
+    }
+
+    @Override public int hashCode() {
+      return Arrays.hashCode(typeArguments) ^ rawType.hashCode() ^ hashCodeOrZero(ownerType);
+    }
+
+    @Override public String toString() {
+      StringBuilder result = new StringBuilder(30 * (typeArguments.length + 1));
+      result.append(typeToString(rawType));
+      if (typeArguments.length == 0) return result.toString();
+      result.append("<").append(typeToString(typeArguments[0]));
+      for (int i = 1; i < typeArguments.length; i++) {
+        result.append(", ").append(typeToString(typeArguments[i]));
+      }
+      return result.append(">").toString();
+    }
+  }
+
+  private static final class GenericArrayTypeImpl implements GenericArrayType {
+    private final Type componentType;
+
+    public GenericArrayTypeImpl(Type componentType) {
+      this.componentType = componentType;
+    }
+
+    public Type getGenericComponentType() {
+      return componentType;
+    }
+
+    @Override public boolean equals(Object o) {
+      return o instanceof GenericArrayType
+          && Types.equals(this, (GenericArrayType) o);
+    }
+
+    @Override public int hashCode() {
+      return componentType.hashCode();
+    }
+
+    @Override public String toString() {
+      return typeToString(componentType) + "[]";
+    }
+  }
+
+  /**
+   * The WildcardType interface supports multiple upper bounds and multiple
+   * lower bounds. We only support what the Java 6 language needs - at most one
+   * bound. If a lower bound is set, the upper bound must be Object.class.
+   */
+  private static final class WildcardTypeImpl implements WildcardType {
+    private final Type upperBound;
+    private final Type lowerBound;
+
+    public WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {
+      if (lowerBounds.length > 1) throw new IllegalArgumentException();
+      if (upperBounds.length != 1) throw new IllegalArgumentException();
+
+      if (lowerBounds.length == 1) {
+        if (lowerBounds[0] == null) throw new NullPointerException();
+        checkNotPrimitive(lowerBounds[0]);
+        if (upperBounds[0] != Object.class) throw new IllegalArgumentException();
+        this.lowerBound = lowerBounds[0];
+        this.upperBound = Object.class;
+      } else {
+        if (upperBounds[0] == null) throw new NullPointerException();
+        checkNotPrimitive(upperBounds[0]);
+        this.lowerBound = null;
+        this.upperBound = upperBounds[0];
+      }
+    }
+
+    public Type[] getUpperBounds() {
+      return new Type[] { upperBound };
+    }
+
+    public Type[] getLowerBounds() {
+      return lowerBound != null ? new Type[] { lowerBound } : EMPTY_TYPE_ARRAY;
+    }
+
+    @Override public boolean equals(Object other) {
+      return other instanceof WildcardType && Types.equals(this, (WildcardType) other);
+    }
+
+    @Override public int hashCode() {
+      // This equals Arrays.hashCode(getLowerBounds()) ^ Arrays.hashCode(getUpperBounds()).
+      return (lowerBound != null ? 31 + lowerBound.hashCode() : 1) ^ (31 + upperBound.hashCode());
+    }
+
+    @Override public String toString() {
+      if (lowerBound != null) return "? super " + typeToString(lowerBound);
+      if (upperBound == Object.class) return "?";
+      return "? extends " + typeToString(upperBound);
+    }
+  }
+}
diff --git a/retrofit/src/main/java/retrofit/http/Utils.java b/retrofit/src/main/java/retrofit/http/Utils.java
index 2c01ac816..12dddb5ec 100644
--- a/retrofit/src/main/java/retrofit/http/Utils.java
+++ b/retrofit/src/main/java/retrofit/http/Utils.java
@@ -1,63 +1,68 @@
 // Copyright 2012 Square, Inc.
+// Copyright 2007 The Guava Authors
 package retrofit.http;
 
-import java.lang.reflect.Type;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
 import java.util.concurrent.Executor;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
+import retrofit.http.client.Response;
+import retrofit.http.mime.TypedByteArray;
+import retrofit.http.mime.TypedInput;
 
 import static java.util.regex.Pattern.CASE_INSENSITIVE;
-import static retrofit.http.RestAdapter.UTF_8;
 
-final class Utils {
+public final class Utils {
   private static final Pattern CHARSET = Pattern.compile("\\Wcharset=([^\\s;]+)", CASE_INSENSITIVE);
+  private static final int BUFFER_SIZE = 0x1000;
 
   /**
-   * Returns the generic supertype for {@code supertype}. For example, given a class
-   * {@code IntegerSet}, the result for when supertype is {@code Set.class} is {@code Set<Integer>}
-   * and the result when the supertype is {@code Collection.class} is {@code Collection<Integer>}.
+   * Creates a {@code byte[]} from reading the entirety of an {@link InputStream}. May return an
+   * empty array but never {@code null}.
+   * <p>
+   * Copied from Guava's {@code ByteStreams} class.
    */
-  // Copied from Guice's {@code MoreTypes} class. Copyright 2006 Google, Inc.
-  static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResolve) {
-    if (toResolve == rawType) {
-      return context;
-    }
-
-    // we skip searching through interfaces if unknown is an interface
-    if (toResolve.isInterface()) {
-      Class<?>[] interfaces = rawType.getInterfaces();
-      for (int i = 0, length = interfaces.length; i < length; i++) {
-        if (interfaces[i] == toResolve) {
-          return rawType.getGenericInterfaces()[i];
-        } else if (toResolve.isAssignableFrom(interfaces[i])) {
-          return getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], toResolve);
-        }
+  static byte[] streamToBytes(InputStream stream) throws IOException {
+    ByteArrayOutputStream baos = new ByteArrayOutputStream();
+    if (stream != null) {
+      byte[] buf = new byte[BUFFER_SIZE];
+      int r;
+      while ((r = stream.read(buf)) != -1) {
+        baos.write(buf, 0, r);
       }
     }
+    return baos.toByteArray();
+  }
 
-    // check our supertypes
-    if (!rawType.isInterface()) {
-      while (rawType != Object.class) {
-        Class<?> rawSupertype = rawType.getSuperclass();
-        if (rawSupertype == toResolve) {
-          return rawType.getGenericSuperclass();
-        } else if (toResolve.isAssignableFrom(rawSupertype)) {
-          return getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, toResolve);
-        }
-        rawType = rawSupertype;
-      }
+  /**
+   * Conditionally replace a {@link Response} with an identical copy whose body is backed by a
+   * byte[] rather than an input stream.
+   */
+  static Response readBodyToBytesIfNecessary(Response response) throws IOException {
+    TypedInput body = response.getBody();
+    if (body == null || body instanceof TypedByteArray) {
+      return response;
     }
 
-    // we can't resolve this further
-    return toResolve;
+    String bodyMime = body.mimeType();
+    byte[] bodyBytes = Utils.streamToBytes(body.in());
+    body = new TypedByteArray(bodyMime, bodyBytes);
+
+    return replaceResponseBody(response, body);
+  }
+
+  static Response replaceResponseBody(Response response, TypedInput body) {
+    return new Response(response.getStatus(), response.getReason(), response.getHeaders(), body);
   }
 
-  static String parseCharset(String headerValue) {
-    Matcher match = CHARSET.matcher(headerValue);
+  public static String parseCharset(String mimeType) {
+    Matcher match = CHARSET.matcher(mimeType);
     if (match.find()) {
       return match.group(1).replaceAll("[\"\\\\]", "");
     }
-    return UTF_8;
+    return "UTF-8";
   }
 
   static class SynchronousExecutor implements Executor {
@@ -65,4 +70,8 @@ static String parseCharset(String headerValue) {
       runnable.run();
     }
   }
-}
\ No newline at end of file
+
+  private Utils() {
+    // No instances.
+  }
+}
diff --git a/retrofit/src/main/java/retrofit/android/AndroidApacheClient.java b/retrofit/src/main/java/retrofit/http/android/AndroidApacheClient.java
similarity index 95%
rename from retrofit/src/main/java/retrofit/android/AndroidApacheClient.java
rename to retrofit/src/main/java/retrofit/http/android/AndroidApacheClient.java
index 87efc317d..d19e4710a 100644
--- a/retrofit/src/main/java/retrofit/android/AndroidApacheClient.java
+++ b/retrofit/src/main/java/retrofit/http/android/AndroidApacheClient.java
@@ -1,5 +1,5 @@
 // Copyright 2013 Square, Inc.
-package retrofit.android;
+package retrofit.http.android;
 
 import android.net.http.AndroidHttpClient;
 import retrofit.http.client.ApacheClient;
diff --git a/retrofit/src/main/java/retrofit/android/MainThreadExecutor.java b/retrofit/src/main/java/retrofit/http/android/MainThreadExecutor.java
similarity index 92%
rename from retrofit/src/main/java/retrofit/android/MainThreadExecutor.java
rename to retrofit/src/main/java/retrofit/http/android/MainThreadExecutor.java
index 9d8c76dbe..85bc92c53 100644
--- a/retrofit/src/main/java/retrofit/android/MainThreadExecutor.java
+++ b/retrofit/src/main/java/retrofit/http/android/MainThreadExecutor.java
@@ -1,5 +1,5 @@
 // Copyright 2012 Square, Inc.
-package retrofit.android;
+package retrofit.http.android;
 
 import android.os.Handler;
 import android.os.Looper;
diff --git a/retrofit/src/main/java/retrofit/http/client/ApacheClient.java b/retrofit/src/main/java/retrofit/http/client/ApacheClient.java
index 1d8eaac4c..8c0dcc660 100644
--- a/retrofit/src/main/java/retrofit/http/client/ApacheClient.java
+++ b/retrofit/src/main/java/retrofit/http/client/ApacheClient.java
@@ -9,7 +9,6 @@
 import java.net.URI;
 import java.util.ArrayList;
 import java.util.List;
-import java.util.Map;
 import org.apache.http.HttpEntity;
 import org.apache.http.HttpResponse;
 import org.apache.http.StatusLine;
@@ -17,16 +16,12 @@
 import org.apache.http.client.methods.HttpEntityEnclosingRequestBase;
 import org.apache.http.client.methods.HttpUriRequest;
 import org.apache.http.entity.AbstractHttpEntity;
-import org.apache.http.entity.mime.MIME;
-import org.apache.http.entity.mime.MultipartEntity;
-import org.apache.http.entity.mime.content.AbstractContentBody;
 import org.apache.http.impl.client.DefaultHttpClient;
 import org.apache.http.message.BasicHeader;
 import org.apache.http.util.EntityUtils;
 import retrofit.http.Header;
-import retrofit.io.TypedBytes;
-
-import static org.apache.http.entity.mime.HttpMultipartMode.BROWSER_COMPATIBLE;
+import retrofit.http.mime.TypedByteArray;
+import retrofit.http.mime.TypedOutput;
 
 /** A {@link Client} which uses an implementation of Apache's {@link HttpClient}. */
 public class ApacheClient implements Client {
@@ -42,23 +37,14 @@ public ApacheClient(HttpClient client) {
   }
 
   @Override public Response execute(Request request) throws IOException {
-    // Create and prepare the Apache request object.
     HttpUriRequest apacheRequest = createRequest(request);
-    prepareRequest(apacheRequest);
-
-    // Obtain and prepare the Apache response object.
-    HttpResponse apacheResponse = client.execute(apacheRequest);
-    prepareResponse(apacheResponse);
-
+    HttpResponse apacheResponse = execute(client, apacheRequest);
     return parseResponse(apacheResponse);
   }
 
-  /** Callback for additional preparation of the request before execution. */
-  protected void prepareRequest(HttpUriRequest request) {
-  }
-
-  /** Callback for additional preparation of the response before parsing. */
-  protected void prepareResponse(HttpResponse response) {
+  /** Execute the specified {@code request} using the provided {@code client}. */
+  protected HttpResponse execute(HttpClient client, HttpUriRequest request) throws IOException {
+    return client.execute(request);
   }
 
   static HttpUriRequest createRequest(Request request) {
@@ -71,14 +57,21 @@ static Response parseResponse(HttpResponse response) throws IOException {
     String reason = statusLine.getReasonPhrase();
 
     List<Header> headers = new ArrayList<Header>();
+    String contentType = "application/octet-stream";
     for (org.apache.http.Header header : response.getAllHeaders()) {
-      headers.add(new Header(header.getName(), header.getValue()));
+      String name = header.getName();
+      String value = header.getValue();
+      if ("Content-Type".equalsIgnoreCase(name)) {
+        contentType = value;
+      }
+      headers.add(new Header(name, value));
     }
 
-    byte[] body = null;
+    TypedByteArray body = null;
     HttpEntity entity = response.getEntity();
     if (entity != null) {
-      body = EntityUtils.toByteArray(entity);
+      byte[] bytes = EntityUtils.toByteArray(entity);
+      body = new TypedByteArray(contentType, bytes);
     }
 
     return new Response(status, reason, headers, body);
@@ -98,21 +91,9 @@ static Response parseResponse(HttpResponse response) throws IOException {
       }
 
       // Add the content body, if any.
-      if (!request.isMultipart()) {
-        TypedBytes body = request.getBody();
-        if (body != null) {
-          setEntity(new TypedBytesEntity(body));
-        }
-      } else {
-        Map<String, TypedBytes> bodyParameters = request.getBodyParameters();
-        if (bodyParameters != null && !bodyParameters.isEmpty()) {
-          MultipartEntity entity = new MultipartEntity(BROWSER_COMPATIBLE);
-          for (Map.Entry<String, TypedBytes> entry : bodyParameters.entrySet()) {
-            String key = entry.getKey();
-            entity.addPart(key, new TypedBytesBody(entry.getValue(), key));
-          }
-          setEntity(entity);
-        }
+      TypedOutput body = request.getBody();
+      if (body != null) {
+        setEntity(new TypedOutputEntity(body));
       }
     }
 
@@ -121,49 +102,13 @@ static Response parseResponse(HttpResponse response) throws IOException {
     }
   }
 
-  /** Adapts ContentBody to TypedBytes. */
-  private static class TypedBytesBody extends AbstractContentBody {
-    private final TypedBytes typedBytes;
-
-    TypedBytesBody(TypedBytes typedBytes, String baseName) {
-      super(typedBytes.mimeType());
-      this.typedBytes = typedBytes;
-    }
-
-    @Override public long getContentLength() {
-      return typedBytes.length();
-    }
-
-    @Override public String getFilename() {
-      return null;
-    }
-
-    @Override public String getCharset() {
-      return null;
-    }
-
-    @Override public String getTransferEncoding() {
-      return MIME.ENC_BINARY;
-    }
-
-    @Override public void writeTo(OutputStream out) throws IOException {
-      // Note: We probably want to differentiate I/O errors that occur while reading a file from
-      // network errors. Network operations can be retried. File operations will probably continue
-      // to fail.
-      //
-      // In the case of photo uploads, we at least check that the file exists before we even try to
-      // upload it.
-      typedBytes.writeTo(out);
-    }
-  }
-
-  /** Container class for passing an entire {@link TypedBytes} as an HTTP request. */
-  static class TypedBytesEntity extends AbstractHttpEntity {
-    private final TypedBytes typedBytes;
+  /** Container class for passing an entire {@link TypedOutput} as an {@link HttpEntity}. */
+  static class TypedOutputEntity extends AbstractHttpEntity {
+    final TypedOutput typedOutput;
 
-    TypedBytesEntity(TypedBytes typedBytes) {
-      this.typedBytes = typedBytes;
-      setContentType(typedBytes.mimeType());
+    TypedOutputEntity(TypedOutput typedOutput) {
+      this.typedOutput = typedOutput;
+      setContentType(typedOutput.mimeType());
     }
 
     @Override public boolean isRepeatable() {
@@ -171,17 +116,17 @@ static Response parseResponse(HttpResponse response) throws IOException {
     }
 
     @Override public long getContentLength() {
-      return typedBytes.length();
+      return typedOutput.length();
     }
 
     @Override public InputStream getContent() throws IOException {
       ByteArrayOutputStream out = new ByteArrayOutputStream();
-      typedBytes.writeTo(out);
+      typedOutput.writeTo(out);
       return new ByteArrayInputStream(out.toByteArray());
     }
 
     @Override public void writeTo(OutputStream out) throws IOException {
-      typedBytes.writeTo(out);
+      typedOutput.writeTo(out);
     }
 
     @Override public boolean isStreaming() {
diff --git a/retrofit/src/main/java/retrofit/http/client/Client.java b/retrofit/src/main/java/retrofit/http/client/Client.java
index 271a174e8..e601a3edd 100644
--- a/retrofit/src/main/java/retrofit/http/client/Client.java
+++ b/retrofit/src/main/java/retrofit/http/client/Client.java
@@ -12,4 +12,13 @@
    * into a {@link Response} instance.
    */
   Response execute(Request request) throws IOException;
+
+  /**
+   * Deferred means of obtaining a {@link Client}. For asynchronous requests this will always be
+   * called on a background thread.
+   */
+  interface Provider {
+    /** Obtain an HTTP client. Called once for each request. */
+    Client get();
+  }
 }
diff --git a/retrofit/src/main/java/retrofit/http/client/Request.java b/retrofit/src/main/java/retrofit/http/client/Request.java
index a8d85a6ce..dc1dc02bb 100644
--- a/retrofit/src/main/java/retrofit/http/client/Request.java
+++ b/retrofit/src/main/java/retrofit/http/client/Request.java
@@ -1,22 +1,19 @@
 package retrofit.http.client;
 
+import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
-import java.util.Map;
 import retrofit.http.Header;
-import retrofit.io.TypedBytes;
+import retrofit.http.mime.TypedOutput;
 
 /** Encapsulates all of the information necessary to make an HTTP request. */
 public final class Request {
   private final String method;
   private final String url;
   private final List<Header> headers;
-  private final boolean isMultipart;
-  private final TypedBytes body;
-  private Map<String, TypedBytes> bodyParameters;
+  private final TypedOutput body;
 
-  public Request(String method, String url, List<Header> headers, boolean isMultipart,
-      TypedBytes body, Map<String, TypedBytes> bodyParameters) {
+  public Request(String method, String url, List<Header> headers, TypedOutput body) {
     if (method == null) {
       throw new NullPointerException("Method must not be null.");
     }
@@ -29,16 +26,10 @@ public Request(String method, String url, List<Header> headers, boolean isMultip
     if (headers == null) {
       this.headers = Collections.emptyList();
     } else {
-      this.headers = Collections.unmodifiableList(headers);
+      this.headers = Collections.unmodifiableList(new ArrayList<Header>(headers));
     }
 
-    this.isMultipart = isMultipart;
     this.body = body;
-
-    if (bodyParameters != null) {
-      bodyParameters = Collections.unmodifiableMap(bodyParameters);
-    }
-    this.bodyParameters = bodyParameters;
   }
 
   /** HTTP method verb. */
@@ -56,21 +47,8 @@ public String getUrl() {
     return headers;
   }
 
-  /** {@code true} if the request body is multipart. */
-  public boolean isMultipart() {
-    return isMultipart;
-  }
-
-  /**
-   * Returns the request body for non-multipart requests, or {@code null} if the request has no
-   * body.
-   */
-  public TypedBytes getBody() {
+  /** Returns the request body or {@code null}. */
+  public TypedOutput getBody() {
     return body;
   }
-
-  /** Unmodifiable map of additional body parameters for multipart requests. */
-  public Map<String, TypedBytes> getBodyParameters() {
-    return bodyParameters;
-  }
 }
diff --git a/retrofit/src/main/java/retrofit/http/client/Response.java b/retrofit/src/main/java/retrofit/http/client/Response.java
index 247dd1759..9498a9b44 100644
--- a/retrofit/src/main/java/retrofit/http/client/Response.java
+++ b/retrofit/src/main/java/retrofit/http/client/Response.java
@@ -5,15 +5,16 @@
 import java.util.Collections;
 import java.util.List;
 import retrofit.http.Header;
+import retrofit.http.mime.TypedInput;
 
 /** An HTTP response. */
 public final class Response {
   private final int status;
   private final String reason;
   private final List<Header> headers;
-  private final byte[] body;
+  private final TypedInput body;
 
-  public Response(int status, String reason, List<Header> headers, byte[] body) {
+  public Response(int status, String reason, List<Header> headers, TypedInput body) {
     if (status < 200) {
       throw new IllegalArgumentException("Invalid status code: " + status);
     }
@@ -46,7 +47,7 @@ public String getReason() {
   }
 
   /** Response body. May be {@code null}. */
-  public byte[] getBody() {
+  public TypedInput getBody() {
     return body;
   }
 }
diff --git a/retrofit/src/main/java/retrofit/http/client/Streams.java b/retrofit/src/main/java/retrofit/http/client/Streams.java
deleted file mode 100644
index f9a8abf84..000000000
--- a/retrofit/src/main/java/retrofit/http/client/Streams.java
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- * Copyright (C) 2007 The Guava Authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit.http.client;
-
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-
-/** Utility methods for working with streams. */
-class Streams {
-  private static final int BUFFER_SIZE = 0x1000;
-
-  /**
-   * Creates a {@code byte[]} from reading the entirety of an {@link InputStream}. May return an
-   * empty array but never {@code null}.
-   */
-  static byte[] readFully(InputStream stream) throws IOException {
-    ByteArrayOutputStream baos = new ByteArrayOutputStream();
-    if (stream != null) {
-      byte[] buf = new byte[BUFFER_SIZE];
-      int r;
-      while ((r = stream.read(buf)) != -1) {
-        baos.write(buf, 0, r);
-      }
-    }
-    return baos.toByteArray();
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/http/client/UrlConnectionClient.java b/retrofit/src/main/java/retrofit/http/client/UrlConnectionClient.java
new file mode 100644
index 000000000..43f679b8f
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/http/client/UrlConnectionClient.java
@@ -0,0 +1,93 @@
+// Copyright 2013 Square, Inc.
+package retrofit.http.client;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.HttpURLConnection;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import retrofit.http.Header;
+import retrofit.http.mime.TypedInput;
+import retrofit.http.mime.TypedOutput;
+
+public class UrlConnectionClient implements Client {
+  @Override public Response execute(Request request) throws IOException {
+    HttpURLConnection connection = openConnection(request);
+    prepareRequest(connection, request);
+    return readResponse(connection);
+  }
+
+  protected HttpURLConnection openConnection(Request request) throws IOException {
+    return (HttpURLConnection) new URL(request.getUrl()).openConnection();
+  }
+
+  void prepareRequest(HttpURLConnection connection, Request request) throws IOException {
+    connection.setRequestMethod(request.getMethod());
+    connection.setDoInput(true);
+
+    for (Header header : request.getHeaders()) {
+      connection.addRequestProperty(header.getName(), header.getValue());
+    }
+
+    TypedOutput body = request.getBody();
+    if (body != null) {
+      connection.setDoOutput(true);
+      connection.addRequestProperty("Content-Type", body.mimeType());
+      long length = body.length();
+      if (length != -1) {
+        connection.addRequestProperty("Content-Length", String.valueOf(length));
+      }
+      body.writeTo(connection.getOutputStream());
+    }
+  }
+
+  Response readResponse(HttpURLConnection connection) throws IOException {
+    int status = connection.getResponseCode();
+    String reason = connection.getResponseMessage();
+
+    List<Header> headers = new ArrayList<Header>();
+    for (Map.Entry<String, List<String>> field : connection.getHeaderFields().entrySet()) {
+      String name = field.getKey();
+      for (String value : field.getValue()) {
+        headers.add(new Header(name, value));
+      }
+    }
+
+    String mimeType = connection.getContentType();
+    int length = connection.getContentLength();
+    InputStream stream;
+    if (status >= 400) {
+      stream = connection.getErrorStream();
+    } else {
+      stream = connection.getInputStream();
+    }
+    TypedInput responseBody = new TypedInputStream(mimeType, length, stream);
+    return new Response(status, reason, headers, responseBody);
+  }
+
+  private static class TypedInputStream implements TypedInput {
+    private final String mimeType;
+    private final long length;
+    private final InputStream stream;
+
+    private TypedInputStream(String mimeType, long length, InputStream stream) {
+      this.mimeType = mimeType;
+      this.length = length;
+      this.stream = stream;
+    }
+
+    @Override public String mimeType() {
+      return mimeType;
+    }
+
+    @Override public long length() {
+      return length;
+    }
+
+    @Override public InputStream in() throws IOException {
+      return stream;
+    }
+  }
+}
diff --git a/retrofit/src/main/java/retrofit/http/mime/TypedByteArray.java b/retrofit/src/main/java/retrofit/http/mime/TypedByteArray.java
new file mode 100644
index 000000000..dddd23f52
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/http/mime/TypedByteArray.java
@@ -0,0 +1,76 @@
+// Copyright 2010 Square, Inc.
+package retrofit.http.mime;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.Arrays;
+
+/**
+ * Byte array and its mime type.
+ *
+ * @author Bob Lee (bob@squareup.com)
+ */
+public class TypedByteArray implements TypedInput, TypedOutput {
+  private final String mimeType;
+  private final byte[] bytes;
+
+  /**
+   * Constructs a new typed byte array.
+   *
+   * @throws NullPointerException if bytes or mimeType is null
+   */
+  public TypedByteArray(String mimeType, byte[] bytes) {
+    if (mimeType == null) {
+      throw new NullPointerException("mimeType");
+    }
+    if (bytes == null) {
+      throw new NullPointerException("bytes");
+    }
+    this.mimeType = mimeType;
+    this.bytes = bytes;
+  }
+
+  public byte[] getBytes() {
+    return bytes;
+  }
+
+  @Override public String fileName() {
+    return null;
+  }
+
+  @Override public String mimeType() {
+    return mimeType;
+  }
+
+  @Override public long length() {
+    return bytes.length;
+  }
+
+  @Override public void writeTo(OutputStream out) throws IOException {
+    out.write(bytes);
+  }
+
+  @Override public InputStream in() throws IOException {
+    return new ByteArrayInputStream(bytes);
+  }
+
+  @Override public boolean equals(Object o) {
+    if (this == o) return true;
+    if (o == null || getClass() != o.getClass()) return false;
+
+    TypedByteArray that = (TypedByteArray) o;
+
+    if (!Arrays.equals(bytes, that.bytes)) return false;
+    if (!mimeType.equals(that.mimeType)) return false;
+
+    return true;
+  }
+
+  @Override public int hashCode() {
+    int result = mimeType.hashCode();
+    result = 31 * result + Arrays.hashCode(bytes);
+    return result;
+  }
+}
diff --git a/retrofit/src/main/java/retrofit/io/TypedFile.java b/retrofit/src/main/java/retrofit/http/mime/TypedFile.java
similarity index 64%
rename from retrofit/src/main/java/retrofit/io/TypedFile.java
rename to retrofit/src/main/java/retrofit/http/mime/TypedFile.java
index 2e79b515a..2a26e64f3 100644
--- a/retrofit/src/main/java/retrofit/io/TypedFile.java
+++ b/retrofit/src/main/java/retrofit/http/mime/TypedFile.java
@@ -1,9 +1,10 @@
 // Copyright 2010 Square, Inc.
-package retrofit.io;
+package retrofit.http.mime;
 
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.IOException;
+import java.io.InputStream;
 import java.io.OutputStream;
 
 /**
@@ -11,7 +12,10 @@
  *
  * @author Bob Lee (bob@squareup.com)
  */
-public class TypedFile extends AbstractTypedBytes {
+public class TypedFile implements TypedInput, TypedOutput {
+  private static final int BUFFER_SIZE = 4096;
+
+  private final String mimeType;
   private final File file;
 
   /**
@@ -19,9 +23,14 @@
    *
    * @throws NullPointerException if file or mimeType is null
    */
-  public TypedFile(File file, String mimeType) {
-    super(mimeType);
-    if (file == null) throw new NullPointerException("file");
+  public TypedFile(String mimeType, File file) {
+    if (mimeType == null) {
+      throw new NullPointerException("mimeType");
+    }
+    if (file == null) {
+      throw new NullPointerException("file");
+    }
+    this.mimeType = mimeType;
     this.file = file;
   }
 
@@ -30,8 +39,24 @@ public File file() {
     return file;
   }
 
-  public void writeTo(OutputStream out) throws IOException {
-    byte[] buffer = new byte[4096];
+  @Override public String mimeType() {
+    return mimeType;
+  }
+
+  @Override public long length() {
+    return file.length();
+  }
+
+  @Override public String fileName() {
+    return file.getName();
+  }
+
+  @Override public InputStream in() throws IOException {
+    return new FileInputStream(file);
+  }
+
+  @Override public void writeTo(OutputStream out) throws IOException {
+    byte[] buffer = new byte[BUFFER_SIZE];
     FileInputStream in = new FileInputStream(file);
     try {
       int read;
@@ -74,8 +99,4 @@ public void moveTo(TypedFile destination) throws IOException {
   @Override public int hashCode() {
     return file.hashCode();
   }
-
-  @Override public int length() {
-    return (int) file.length();
-  }
 }
diff --git a/retrofit/src/main/java/retrofit/http/mime/TypedInput.java b/retrofit/src/main/java/retrofit/http/mime/TypedInput.java
new file mode 100644
index 000000000..3fbb22535
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/http/mime/TypedInput.java
@@ -0,0 +1,25 @@
+// Copyright 2013 Square, Inc.
+package retrofit.http.mime;
+
+import java.io.IOException;
+import java.io.InputStream;
+
+/**
+ * Binary data with an associated mime type.
+ *
+ * @author Jake Wharton (jw@squareup.com)
+ */
+public interface TypedInput {
+
+  /** Returns the mime type. */
+  String mimeType();
+
+  /** Length in bytes. Returns {@code -1} if length is unknown. */
+  long length();
+
+  /**
+   * Read bytes as stream. Unless otherwise specified, this method may only be called once. It is
+   * the responsibility of the caller to close the stream.
+   */
+  InputStream in() throws IOException;
+}
diff --git a/retrofit/src/main/java/retrofit/io/TypedBytes.java b/retrofit/src/main/java/retrofit/http/mime/TypedOutput.java
similarity index 61%
rename from retrofit/src/main/java/retrofit/io/TypedBytes.java
rename to retrofit/src/main/java/retrofit/http/mime/TypedOutput.java
index 2ffd9458e..3ad49c974 100644
--- a/retrofit/src/main/java/retrofit/io/TypedBytes.java
+++ b/retrofit/src/main/java/retrofit/http/mime/TypedOutput.java
@@ -1,5 +1,5 @@
-// Copyright 2010 Square, Inc.
-package retrofit.io;
+// Copyright 2013 Square, Inc.
+package retrofit.http.mime;
 
 import java.io.IOException;
 import java.io.OutputStream;
@@ -9,13 +9,17 @@
  *
  * @author Bob Lee (bob@squareup.com)
  */
-public interface TypedBytes {
+public interface TypedOutput {
+  /** Original filename.
+   *
+   * Used only for multipart requests, may be null. */
+  String fileName();
 
   /** Returns the mime type. */
   String mimeType();
 
   /** Length in bytes. */
-  int length();
+  long length();
 
   /** Writes these bytes to the given output stream. */
   void writeTo(OutputStream out) throws IOException;
diff --git a/retrofit/src/main/java/retrofit/http/mime/TypedString.java b/retrofit/src/main/java/retrofit/http/mime/TypedString.java
new file mode 100644
index 000000000..ab8792e76
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/http/mime/TypedString.java
@@ -0,0 +1,18 @@
+// Copyright 2013 Square, Inc.
+package retrofit.http.mime;
+
+import java.io.UnsupportedEncodingException;
+
+public class TypedString extends TypedByteArray {
+  public TypedString(String string) {
+    super("text/plain; charset=UTF-8", convertToBytes(string));
+  }
+
+  private static byte[] convertToBytes(String string) {
+    try {
+      return string.getBytes("UTF-8");
+    } catch (UnsupportedEncodingException e) {
+      throw new RuntimeException(e);
+    }
+  }
+}
diff --git a/retrofit/src/main/java/retrofit/io/AbstractTypedBytes.java b/retrofit/src/main/java/retrofit/io/AbstractTypedBytes.java
deleted file mode 100644
index 942245af6..000000000
--- a/retrofit/src/main/java/retrofit/io/AbstractTypedBytes.java
+++ /dev/null
@@ -1,28 +0,0 @@
-// Copyright 2010 Square, Inc.
-package retrofit.io;
-
-/**
- * Support for Typed values.
- *
- * @author Bob Lee (bob@squareup.com)
- */
-public abstract class AbstractTypedBytes implements TypedBytes {
-  private final String mimeType;
-
-  /**
-   * Stores the mime type.
-   *
-   * @throws NullPointerException if mimeType is null
-   */
-  public AbstractTypedBytes(String mimeType) {
-    if (mimeType == null) throw new NullPointerException("mimeType");
-    this.mimeType = mimeType;
-  }
-
-  public String mimeType() {
-    return mimeType;
-  }
-
-  /** Returns the length in bytes. */
-  public abstract int length();
-}
\ No newline at end of file
diff --git a/retrofit/src/main/java/retrofit/io/StringTypedBytes.java b/retrofit/src/main/java/retrofit/io/StringTypedBytes.java
deleted file mode 100644
index 255a65a16..000000000
--- a/retrofit/src/main/java/retrofit/io/StringTypedBytes.java
+++ /dev/null
@@ -1,27 +0,0 @@
-// Copyright 2013 Square, Inc.
-package retrofit.io;
-
-import java.io.IOException;
-import java.io.OutputStream;
-import java.io.UnsupportedEncodingException;
-
-public class StringTypedBytes extends AbstractTypedBytes {
-  private final byte[] bytes;
-
-  public StringTypedBytes(String string) {
-    super("text/plain; charset=UTF-8");
-    try {
-      bytes = string.getBytes("UTF-8");
-    } catch (UnsupportedEncodingException e) {
-      throw new AssertionError(e);
-    }
-  }
-
-  @Override public int length() {
-    return bytes.length;
-  }
-
-  @Override public void writeTo(OutputStream out) throws IOException {
-    out.write(bytes);
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/io/TypedByteArray.java b/retrofit/src/main/java/retrofit/io/TypedByteArray.java
deleted file mode 100644
index 356197059..000000000
--- a/retrofit/src/main/java/retrofit/io/TypedByteArray.java
+++ /dev/null
@@ -1,48 +0,0 @@
-// Copyright 2010 Square, Inc.
-package retrofit.io;
-
-import java.io.IOException;
-import java.io.OutputStream;
-import java.util.Arrays;
-
-/**
- * Byte array and its mime type.
- *
- * @author Bob Lee (bob@squareup.com)
- */
-public class TypedByteArray extends AbstractTypedBytes {
-  private final byte[] bytes;
-
-  /**
-   * Constructs a new typed byte array.
-   *
-   * @throws NullPointerException if bytes or mimeType is null
-   */
-  public TypedByteArray(byte[] bytes, String mimeType) {
-    super(mimeType);
-    if (bytes == null) throw new NullPointerException("bytes");
-    this.bytes = bytes;
-  }
-
-  public void writeTo(OutputStream out) throws IOException {
-    out.write(bytes);
-  }
-
-  @Override public int length() {
-    return bytes.length;
-  }
-
-  @Override public boolean equals(Object o) {
-    if (this == o) return true;
-
-    if (o instanceof TypedByteArray) {
-      TypedByteArray rhs = (TypedByteArray) o;
-      return Arrays.equals(bytes, rhs.bytes);
-    }
-    return false;
-  }
-
-  @Override public int hashCode() {
-    return Arrays.hashCode(bytes);
-  }
-}
\ No newline at end of file
diff --git a/retrofit/src/test/java/retrofit/http/CallbackRunnableTest.java b/retrofit/src/test/java/retrofit/http/CallbackRunnableTest.java
index bfc46c949..225fed34e 100644
--- a/retrofit/src/test/java/retrofit/http/CallbackRunnableTest.java
+++ b/retrofit/src/test/java/retrofit/http/CallbackRunnableTest.java
@@ -21,20 +21,20 @@
   @Before public void setUp() {
     callback = mock(Callback.class);
     callbackRunnable = spy(new CallbackRunnable<Object>(callback, executor) {
-      @Override public Object obtainResponse() {
+      @Override public ResponseWrapper obtainResponse() {
         return null; // Must be mocked.
       }
     });
   }
 
   @Test public void responsePassedToSuccess() {
-    Object response = new Object();
-    when(callbackRunnable.obtainResponse()).thenReturn(response);
+    ResponseWrapper wrapper = new ResponseWrapper(null, new Object());
+    when(callbackRunnable.obtainResponse()).thenReturn(wrapper);
 
     callbackRunnable.run();
 
     verify(executor).execute(any(Runnable.class));
-    verify(callback).success(same(response));
+    verify(callback).success(same(wrapper.responseBody), same(wrapper.response));
   }
 
   @Test public void errorPassedToFailure() {
diff --git a/retrofit/src/test/java/retrofit/http/RequestBuilderTest.java b/retrofit/src/test/java/retrofit/http/RequestBuilderTest.java
index f804f01ef..fcb1d30d2 100644
--- a/retrofit/src/test/java/retrofit/http/RequestBuilderTest.java
+++ b/retrofit/src/test/java/retrofit/http/RequestBuilderTest.java
@@ -8,12 +8,14 @@
 import java.net.URISyntaxException;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Iterator;
 import java.util.List;
+import java.util.Map;
 import java.util.Set;
 import org.junit.Test;
 import retrofit.http.client.Request;
-import retrofit.io.StringTypedBytes;
-import retrofit.io.TypedBytes;
+import retrofit.http.mime.TypedOutput;
+import retrofit.http.mime.TypedString;
 
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Mockito.mock;
@@ -31,7 +33,6 @@
     assertThat(request.getHeaders()).isEmpty();
     assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
     assertThat(request.getBody()).isNull();
-    assertThat(request.getBodyParameters()).isEmpty();
   }
 
   @Test public void getWithPathParam() throws Exception {
@@ -45,7 +46,6 @@
     assertThat(request.getHeaders()).isEmpty();
     assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/pong/");
     assertThat(request.getBody()).isNull();
-    assertThat(request.getBodyParameters()).isEmpty();
   }
 
   @Test public void getWithQueryParam() throws Exception {
@@ -59,7 +59,6 @@
     assertThat(request.getHeaders()).isEmpty();
     assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/?ping=pong");
     assertThat(request.getBody()).isNull();
-    assertThat(request.getBodyParameters()).isEmpty();
   }
 
   @Test public void getWithPathAndQueryParam() throws Exception {
@@ -75,7 +74,48 @@
     assertThat(request.getHeaders()).isEmpty();
     assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/pong/?kit=kat&riff=raff");
     assertThat(request.getBody()).isNull();
-    assertThat(request.getBodyParameters()).isEmpty();
+  }
+
+  @Test public void getWithPathAndQueryQuestionMarkParam() throws Exception {
+    Request request = new Helper() //
+        .setMethod("GET") //
+        .setUrl("http://example.com") //
+        .setPath("/foo/bar/{ping}/") //
+        .addNamedParam("ping", "pong?") //
+        .addNamedParam("kit", "kat?") //
+        .build();
+    assertThat(request.getMethod()).isEqualTo("GET");
+    assertThat(request.getHeaders()).isEmpty();
+    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/pong%3F/?kit=kat%3F");
+    assertThat(request.getBody()).isNull();
+  }
+
+  @Test public void getWithPathAndQueryAmpersandParam() throws Exception {
+    Request request = new Helper() //
+        .setMethod("GET") //
+        .setUrl("http://example.com") //
+        .setPath("/foo/bar/{ping}/") //
+        .addNamedParam("ping", "pong&") //
+        .addNamedParam("kit", "kat&") //
+        .build();
+    assertThat(request.getMethod()).isEqualTo("GET");
+    assertThat(request.getHeaders()).isEmpty();
+    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/pong%26/?kit=kat%26");
+    assertThat(request.getBody()).isNull();
+  }
+
+  @Test public void getWithPathAndQueryHashParam() throws Exception {
+    Request request = new Helper() //
+        .setMethod("GET") //
+        .setUrl("http://example.com") //
+        .setPath("/foo/bar/{ping}/") //
+        .addNamedParam("ping", "pong#") //
+        .addNamedParam("kit", "kat#") //
+        .build();
+    assertThat(request.getMethod()).isEqualTo("GET");
+    assertThat(request.getHeaders()).isEmpty();
+    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/pong%23/?kit=kat%23");
+    assertThat(request.getBody()).isNull();
   }
 
   @Test public void getWithPathAndQueryParamAsync() throws Exception {
@@ -91,7 +131,6 @@
     assertThat(request.getHeaders()).isEmpty();
     assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/pong/?kit=kat");
     assertThat(request.getBody()).isNull();
-    assertThat(request.getBodyParameters()).isEmpty();
   }
 
   @Test public void normalPost() throws Exception {
@@ -105,7 +144,6 @@
     assertThat(request.getHeaders()).isEmpty();
     assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
     assertThat(request.getBody()).isNull();
-    assertThat(request.getBodyParameters()).isEmpty();
   }
 
   @Test public void normalPostWithPathParam() throws Exception {
@@ -120,7 +158,6 @@
     assertThat(request.getHeaders()).isEmpty();
     assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/pong/");
     assertThat(request.getBody()).isNull();
-    assertThat(request.getBodyParameters()).isEmpty();
   }
 
   @Test public void singleEntity() throws Exception {
@@ -135,7 +172,6 @@
     assertThat(request.getHeaders()).isEmpty();
     assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
     assertTypedBytes(request.getBody(), "[\"quick\",\"brown\",\"fox\"]");
-    assertThat(request.getBodyParameters()).isEmpty();
   }
 
   @Test public void singleEntityWithPathParams() throws Exception {
@@ -152,7 +188,6 @@
     assertThat(request.getHeaders()).isEmpty();
     assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/pong/kat/");
     assertTypedBytes(request.getBody(), "[\"quick\",\"brown\",\"fox\"]");
-    assertThat(request.getBodyParameters()).isEmpty();
   }
 
   @Test public void singleEntityWithPathParamsAsync() throws Exception {
@@ -170,7 +205,6 @@
     assertThat(request.getHeaders()).isEmpty();
     assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/pong/kat/");
     assertTypedBytes(request.getBody(), "[\"quick\",\"brown\",\"fox\"]");
-    assertThat(request.getBodyParameters()).isEmpty();
   }
 
   @Test public void simpleMultipart() throws Exception {
@@ -180,16 +214,23 @@
         .setUrl("http://example.com") //
         .setPath("/foo/bar/") //
         .addNamedParam("ping", "pong") //
-        .addNamedParam("kit", new StringTypedBytes("kat")) //
+        .addNamedParam("kit", new TypedString("kat")) //
         .setMultipart() //
         .build();
     assertThat(request.getMethod()).isEqualTo("POST");
     assertThat(request.getHeaders()).isEmpty();
     assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.getBody()).isNull();
-    assertThat(request.getBodyParameters()).hasSize(2);
-    assertTypedBytes(request.getBodyParameters().get("ping"), "pong");
-    assertTypedBytes(request.getBodyParameters().get("kit"), "kat");
+
+    MultipartTypedOutput body = (MultipartTypedOutput) request.getBody();
+    assertThat(body.parts).hasSize(2);
+
+    Iterator<byte[]> iterator = body.parts.iterator();
+
+    String one = new String(iterator.next(), "UTF-8");
+    assertThat(one).contains("ping").contains("pong");
+
+    String two = new String(iterator.next(), "UTF-8");
+    assertThat(two).contains("kit").contains("kat");
   }
 
   @Test public void simpleHeaders() throws Exception {
@@ -205,7 +246,6 @@
         .containsExactly(new Header("ping", "pong"), new Header("kit", "kat"));
     assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
     assertThat(request.getBody()).isNull();
-    assertThat(request.getBodyParameters()).isEmpty();
   }
 
   @Test public void noDuplicateSlashes() throws Exception {
@@ -217,7 +257,7 @@
     assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
   }
 
-  private static void assertTypedBytes(TypedBytes bytes, String expected) throws IOException {
+  private static void assertTypedBytes(TypedOutput bytes, String expected) throws IOException {
     assertThat(bytes).isNotNull();
     ByteArrayOutputStream baos = new ByteArrayOutputStream();
     bytes.writeTo(baos);
@@ -282,7 +322,8 @@ Helper addSingleEntityParam(Object value) {
       if (singleEntityArgumentIndex != NO_SINGLE_ENTITY) {
         throw new IllegalStateException("Single entity param already added.");
       }
-      singleEntityArgumentIndex = namedParams.size(); // Relying on the fact that this is already less one.
+      // Relying on the fact that this is already less one.
+      singleEntityArgumentIndex = namedParams.size();
       namedParams.add(null);
       args.add(value);
       return this;
@@ -334,7 +375,7 @@ Request build() throws NoSuchMethodException, URISyntaxException {
       methodInfo.isMultipart = isMultipart;
       methodInfo.loaded = true;
 
-      return new RequestBuilder(GSON)
+      return new RequestBuilder(GSON) //
           .setApiUrl(url)
           .setHeaders(headers)
           .setArgs(args.toArray(new Object[args.size()]))
diff --git a/retrofit/src/test/java/retrofit/http/RestAdapterTest.java b/retrofit/src/test/java/retrofit/http/RestAdapterTest.java
index fc7003180..de15b6bd4 100644
--- a/retrofit/src/test/java/retrofit/http/RestAdapterTest.java
+++ b/retrofit/src/test/java/retrofit/http/RestAdapterTest.java
@@ -10,11 +10,13 @@
 import retrofit.http.client.Client;
 import retrofit.http.client.Request;
 import retrofit.http.client.Response;
+import retrofit.http.mime.TypedString;
 
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.fest.assertions.api.Assertions.fail;
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.anyString;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Matchers.same;
 import static org.mockito.Mockito.mock;
@@ -87,28 +89,29 @@
   }
 
   @Test public void asynchronousUsesExecutors() throws Exception {
+    Response response = new Response(200, "OK", NO_HEADERS, new TypedString("{}"));
     when(mockClient.execute(any(Request.class))) //
-        .thenReturn(new Response(200, "OK", NO_HEADERS, null));
+        .thenReturn(response);
     Callback<Object> callback = mock(Callback.class);
 
     example.something(callback);
 
     verify(mockRequestExecutor).execute(any(CallbackRunnable.class));
     verify(mockCallbackExecutor).execute(any(Runnable.class));
-    verify(callback).success(eq(null));
+    verify(callback).success(anyString(), same(response));
   }
 
   @Test public void malformedResponseThrowsConversionException() throws Exception {
     when(mockClient.execute(any(Request.class))) //
-        .thenReturn(new Response(200, "OK", NO_HEADERS, "{".getBytes("UTF-8")));
+        .thenReturn(new Response(200, "OK", NO_HEADERS, new TypedString("{")));
 
     try {
       example.something();
       fail("RetrofitError expected on malformed response body.");
     } catch (RetrofitError e) {
       assertThat(e.getResponse().getStatus()).isEqualTo(200);
-      assertThat(e.getException()).isInstanceOf(ConversionException.class);
-      assertThat(e.getResponse().getBody()).isEqualTo("{".getBytes("UTF-8"));
+      assertThat(e.getCause()).isInstanceOf(ConversionException.class);
+      assertThat(e.getResponse().getBody()).isNull();
     }
   }
 
@@ -132,7 +135,7 @@
       example.something();
       fail("RetrofitError expected when client throws exception.");
     } catch (RetrofitError e) {
-      assertThat(e.getException()).isSameAs(exception);
+      assertThat(e.getCause()).isSameAs(exception);
     }
   }
 
@@ -144,7 +147,7 @@
       example.something();
       fail("RetrofitError expected when unexpected exception thrown.");
     } catch (RetrofitError e) {
-      assertThat(e.getException()).isSameAs(exception);
+      assertThat(e.getCause()).isSameAs(exception);
     }
   }
 
@@ -165,6 +168,6 @@
 
     verify(mockRequestExecutor).execute(any(CallbackRunnable.class));
     verify(mockCallbackExecutor).execute(any(Runnable.class));
-    verify(callback).success(eq(response));
+    verify(callback).success(eq(response), same(response));
   }
 }
diff --git a/retrofit/src/test/java/retrofit/http/RestMethodInfoTest.java b/retrofit/src/test/java/retrofit/http/RestMethodInfoTest.java
index 0fa75c57c..80255d253 100644
--- a/retrofit/src/test/java/retrofit/http/RestMethodInfoTest.java
+++ b/retrofit/src/test/java/retrofit/http/RestMethodInfoTest.java
@@ -7,11 +7,10 @@
 import java.lang.reflect.Method;
 import java.lang.reflect.Type;
 import java.util.List;
+import java.util.Map;
 import java.util.Set;
-import javax.inject.Named;
-import org.junit.Ignore;
 import org.junit.Test;
-import retrofit.io.TypedBytes;
+import retrofit.http.mime.TypedOutput;
 
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
@@ -69,7 +68,7 @@ public void pathMustBePrefixedWithSlash() {
 
   @Test public void concreteCallbackTypesWithParams() {
     class Example {
-      @GET("/foo") void a(@Named("id") String id, ResponseCallback cb) {
+      @GET("/foo") void a(@Name("id") String id, ResponseCallback cb) {
       }
     }
 
@@ -93,7 +92,7 @@ public void pathMustBePrefixedWithSlash() {
 
   @Test public void genericCallbackTypesWithParams() {
     class Example {
-      @GET("/foo") void a(@Named("id") String id, Callback<Response> c) {
+      @GET("/foo") void a(@Name("id") String id, Callback<Response> c) {
       }
     }
 
@@ -129,17 +128,21 @@ public void pathMustBePrefixedWithSlash() {
     assertThat(methodInfo.type).isEqualTo(expected);
   }
 
-  @Ignore // TODO support this case!
-  @Test public void extendingGenericCallback() {
+  // RestMethodInfo reconstructs this type from MultimapCallback<String, Set<Long>>. It contains
+  // a little of everything: a parameterized type, a generic array, and a wildcard.
+  private static Map<? extends String, Set<Long>[]> extendingGenericCallbackType;
+
+  @Test public void extendingGenericCallback() throws Exception {
     class Example {
-      @GET("/foo") void a(ExtendingCallback<Response> callback) {
+      @GET("/foo") void a(MultimapCallback<String, Set<Long>> callback) {
       }
     }
 
     Method method = TestingUtils.getMethod(Example.class, "a");
     RestMethodInfo methodInfo = new RestMethodInfo(method);
     assertThat(methodInfo.isSynchronous).isFalse();
-    assertThat(methodInfo.type).isEqualTo(Response.class);
+    assertThat(methodInfo.type).isEqualTo(
+        RestMethodInfoTest.class.getDeclaredField("extendingGenericCallbackType").getGenericType());
   }
 
   @Test public void synchronousResponse() {
@@ -173,7 +176,7 @@ public void pathMustBePrefixedWithSlash() {
   @Test(expected = IllegalArgumentException.class)
   public void missingCallbackTypes() {
     class Example {
-      @GET("/foo") void a(@Named("id") String id) {
+      @GET("/foo") void a(@Name("id") String id) {
       }
     }
 
@@ -422,6 +425,21 @@ Response a() {
     assertThat(methodInfo.isMultipart).isFalse();
   }
 
+  @Test(expected = IllegalStateException.class)
+  public void noQueryParamsInUrl() {
+    class Example {
+      @GET("/foo/{bar}/")
+      @QueryParam(name = "bar", value = "baz")
+      Response a() {
+        return null;
+      }
+    }
+
+    Method method = TestingUtils.getMethod(Example.class, "a");
+    RestMethodInfo methodInfo = new RestMethodInfo(method);
+    methodInfo.init();
+  }
+
   @Test public void emptyParams() {
     class Example {
       @GET("/") Response a() {
@@ -440,7 +458,7 @@ Response a() {
 
   @Test public void singleParam() {
     class Example {
-      @GET("/") Response a(@Named("a") String a) {
+      @GET("/") Response a(@Name("a") String a) {
         return null;
       }
     }
@@ -456,7 +474,7 @@ Response a() {
 
   @Test public void multipleParams() {
     class Example {
-      @GET("/") Response a(@Named("a") String a, @Named("b") String b, @Named("c") String c) {
+      @GET("/") Response a(@Name("a") String a, @Name("b") String b, @Name("c") String c) {
         return null;
       }
     }
@@ -487,7 +505,7 @@ Response a() {
 
   @Test public void singleParamWithCallback() {
     class Example {
-      @GET("/") void a(@Named("a") String a, ResponseCallback cb) {
+      @GET("/") void a(@Name("a") String a, ResponseCallback cb) {
       }
     }
 
@@ -502,7 +520,7 @@ Response a() {
 
   @Test public void multipleParamsWithCallback() {
     class Example {
-      @GET("/") void a(@Named("a") String a, @Named("b") String b, ResponseCallback cb) {
+      @GET("/") void a(@Name("a") String a, @Name("b") String b, ResponseCallback cb) {
       }
     }
 
@@ -534,7 +552,7 @@ Response a() {
 
   @Test public void singleEntityTypedBytes() {
     class Example {
-      @PUT("/") Response a(@SingleEntity TypedBytes o) {
+      @PUT("/") Response a(@SingleEntity TypedOutput o) {
         return null;
       }
     }
@@ -580,7 +598,7 @@ public void twoSingleEntities() {
 
   @Test public void singleEntityWithNamed() {
     class Example {
-      @PUT("/{a}/{c}") Response a(@Named("a") int a, @SingleEntity int b, @Named("c") int c) {
+      @PUT("/{a}/{c}") Response a(@Name("a") int a, @SingleEntity int b, @Name("c") int c) {
         return null;
       }
     }
@@ -595,7 +613,7 @@ public void twoSingleEntities() {
 
   @Test public void singleEntityWithNamedAndCallback() {
     class Example {
-      @PUT("/{a}") void a(@Named("a") int a, @SingleEntity int b, ResponseCallback cb) {
+      @PUT("/{a}") void a(@Name("a") int a, @SingleEntity int b, ResponseCallback cb) {
       }
     }
 
@@ -611,7 +629,7 @@ public void twoSingleEntities() {
   @Test(expected = IllegalStateException.class)
   public void nonPathParamAndSingleEntity() {
     class Example {
-      @PUT("/") Response a(@Named("a") int a, @SingleEntity int b) {
+      @PUT("/") Response a(@Name("a") int a, @SingleEntity int b) {
         return null;
       }
     }
@@ -624,7 +642,7 @@ public void nonPathParamAndSingleEntity() {
   @Test(expected = IllegalStateException.class)
   public void typedBytesUrlParam() {
     class Example {
-      @GET("/{a}") Response a(@Named("a") TypedBytes m) {
+      @GET("/{a}") Response a(@Name("a") TypedOutput m) {
         return null;
       }
     }
@@ -637,7 +655,7 @@ public void typedBytesUrlParam() {
   @Test(expected = IllegalStateException.class)
   public void pathParamNonPathParamAndTypedBytes() {
     class Example {
-      @PUT("/{a}") Response a(@Named("a") int a, @Named("b") int b, @SingleEntity int c) {
+      @PUT("/{a}") Response a(@Name("a") int a, @Name("b") int b, @SingleEntity int c) {
         return null;
       }
     }
@@ -676,7 +694,7 @@ public void nonBodyHttpMethodWithSingleEntity() {
   @Test(expected = IllegalStateException.class)
   public void nonBodyHttpMethodWithTypedBytes() {
     class Example {
-      @GET("/") Response a(@Named("a") TypedBytes a) {
+      @GET("/") Response a(@Name("a") TypedOutput a) {
         return null;
       }
     }
@@ -689,7 +707,7 @@ public void nonBodyHttpMethodWithTypedBytes() {
   @Test public void simpleMultipart() {
     class Example {
       @Multipart @PUT("/")
-      Response a(@Named("a") TypedBytes a) {
+      Response a(@Name("a") TypedOutput a) {
         return null;
       }
     }
@@ -704,7 +722,7 @@ Response a(@Named("a") TypedBytes a) {
   @Test public void twoTypedBytesMultipart() {
     class Example {
       @Multipart @PUT("/")
-      Response a(@Named("a") TypedBytes a, @Named("b") TypedBytes b) {
+      Response a(@Name("a") TypedOutput a, @Name("b") TypedOutput b) {
         return null;
       }
     }
@@ -719,7 +737,7 @@ Response a(@Named("a") TypedBytes a, @Named("b") TypedBytes b) {
   @Test public void twoTypesMultipart() {
     class Example {
       @Multipart @PUT("/")
-      Response a(@Named("a") TypedBytes a, @Named("b") int b) {
+      Response a(@Name("a") TypedOutput a, @Name("b") int b) {
         return null;
       }
     }
@@ -734,7 +752,7 @@ Response a(@Named("a") TypedBytes a, @Named("b") int b) {
   @Test(expected = IllegalStateException.class)
   public void implicitMultipartForbidden() {
     class Example {
-      @POST("/") Response a(@Named("a") int a) {
+      @POST("/") Response a(@Name("a") int a) {
         return null;
       }
     }
@@ -763,6 +781,6 @@ public void multipartFailsOnNonBodyMethod() {
   private static interface ResponseCallback extends Callback<Response> {
   }
 
-  private static interface ExtendingCallback<T> extends Callback<T> {
+  private static interface MultimapCallback<K, V> extends Callback<Map<? extends K, V[]>> {
   }
 }
diff --git a/retrofit/src/test/java/retrofit/http/TestingUtils.java b/retrofit/src/test/java/retrofit/http/TestingUtils.java
index f24a69ca5..91940816b 100644
--- a/retrofit/src/test/java/retrofit/http/TestingUtils.java
+++ b/retrofit/src/test/java/retrofit/http/TestingUtils.java
@@ -2,8 +2,12 @@
 package retrofit.http;
 
 import java.lang.reflect.Method;
+import java.util.Map;
+import retrofit.http.mime.TypedOutput;
 
-public class TestingUtils {
+import static org.fest.assertions.api.Assertions.assertThat;
+
+public abstract class TestingUtils {
   public static Method getMethod(Class c, String name) {
     for (Method method : c.getDeclaredMethods()) {
       if (method.getName().equals(name)) {
@@ -12,4 +16,20 @@ public static Method getMethod(Class c, String name) {
     }
     throw new IllegalArgumentException("Unknown method '" + name + "' on " + c);
   }
+
+  public static TypedOutput createMultipart(Map<String, TypedOutput> parts) {
+    MultipartTypedOutput typedOutput = new MultipartTypedOutput();
+    for (Map.Entry<String, TypedOutput> part : parts.entrySet()) {
+      typedOutput.addPart(part.getKey(), part.getValue());
+    }
+    return typedOutput;
+  }
+
+  public static void assertMultipart(TypedOutput typedOutput) {
+    assertThat(typedOutput).isInstanceOf(MultipartTypedOutput.class);
+  }
+
+  public static void assertBytes(byte[] bytes, String expected) throws Exception {
+    assertThat(new String(bytes, "UTF-8")).isEqualTo(expected);
+  }
 }
diff --git a/retrofit/src/test/java/retrofit/http/UtilsTest.java b/retrofit/src/test/java/retrofit/http/UtilsTest.java
index a81347f37..5176f0230 100644
--- a/retrofit/src/test/java/retrofit/http/UtilsTest.java
+++ b/retrofit/src/test/java/retrofit/http/UtilsTest.java
@@ -4,21 +4,20 @@
 import org.junit.Test;
 
 import static org.fest.assertions.api.Assertions.assertThat;
-import static retrofit.http.RestAdapter.UTF_8;
 import static retrofit.http.Utils.parseCharset;
 
 public class UtilsTest {
   @Test public void charsetParsing() {
-    assertThat(parseCharset("text/plain;charset=utf-8")).isEqualToIgnoringCase(UTF_8);
-    assertThat(parseCharset("text/plain; charset=utf-8")).isEqualToIgnoringCase(UTF_8);
-    assertThat(parseCharset("text/plain;  charset=utf-8")).isEqualToIgnoringCase(UTF_8);
-    assertThat(parseCharset("text/plain; \tcharset=utf-8")).isEqualToIgnoringCase(UTF_8);
-    assertThat(parseCharset("text/plain; \r\n\tcharset=utf-8")).isEqualToIgnoringCase(UTF_8);
-    assertThat(parseCharset("text/plain; CHARSET=utf-8")).isEqualToIgnoringCase(UTF_8);
-    assertThat(parseCharset("text/plain; charset=UTF-8")).isEqualToIgnoringCase(UTF_8);
-    assertThat(parseCharset("text/plain; charset=\"\\u\\tf-\\8\"")).isEqualToIgnoringCase(UTF_8);
-    assertThat(parseCharset("text/plain; charset=\"utf-8\"")).isEqualToIgnoringCase(UTF_8);
-    assertThat(parseCharset("text/plain; charset=utf-8; other=thing")).isEqualToIgnoringCase(UTF_8);
-    assertThat(parseCharset("text/plain; notthecharset=utf-16;")).isEqualToIgnoringCase(UTF_8);
+    assertThat(parseCharset("text/plain;charset=utf-8")).isEqualToIgnoringCase("UTF-8");
+    assertThat(parseCharset("text/plain; charset=utf-8")).isEqualToIgnoringCase("UTF-8");
+    assertThat(parseCharset("text/plain;  charset=utf-8")).isEqualToIgnoringCase("UTF-8");
+    assertThat(parseCharset("text/plain; \tcharset=utf-8")).isEqualToIgnoringCase("UTF-8");
+    assertThat(parseCharset("text/plain; \r\n\tcharset=utf-8")).isEqualToIgnoringCase("UTF-8");
+    assertThat(parseCharset("text/plain; CHARSET=utf-8")).isEqualToIgnoringCase("UTF-8");
+    assertThat(parseCharset("text/plain; charset=UTF-8")).isEqualToIgnoringCase("UTF-8");
+    assertThat(parseCharset("text/plain; charset=\"\\u\\tf-\\8\"")).isEqualToIgnoringCase("UTF-8");
+    assertThat(parseCharset("text/plain; charset=\"utf-8\"")).isEqualToIgnoringCase("UTF-8");
+    assertThat(parseCharset("text/plain;charset=utf-8;other=thing")).isEqualToIgnoringCase("UTF-8");
+    assertThat(parseCharset("text/plain; notthecharset=utf-16;")).isEqualToIgnoringCase("UTF-8");
   }
 }
diff --git a/retrofit/src/test/java/retrofit/http/client/ApacheClientTest.java b/retrofit/src/test/java/retrofit/http/client/ApacheClientTest.java
index 513aca5e5..d2f745b98 100644
--- a/retrofit/src/test/java/retrofit/http/client/ApacheClientTest.java
+++ b/retrofit/src/test/java/retrofit/http/client/ApacheClientTest.java
@@ -1,6 +1,7 @@
 // Copyright 2013 Square, Inc.
 package retrofit.http.client;
 
+import com.google.common.io.ByteStreams;
 import java.util.ArrayList;
 import java.util.LinkedHashMap;
 import java.util.List;
@@ -11,22 +12,24 @@
 import org.apache.http.HttpVersion;
 import org.apache.http.StatusLine;
 import org.apache.http.client.methods.HttpUriRequest;
-import org.apache.http.entity.mime.MultipartEntity;
 import org.apache.http.message.BasicHttpResponse;
 import org.apache.http.message.BasicStatusLine;
 import org.junit.Test;
 import retrofit.http.Header;
-import retrofit.io.StringTypedBytes;
-import retrofit.io.TypedBytes;
+import retrofit.http.TestingUtils;
+import retrofit.http.mime.TypedOutput;
+import retrofit.http.mime.TypedString;
 
 import static org.fest.assertions.api.Assertions.assertThat;
-import static retrofit.http.client.ApacheClient.TypedBytesEntity;
+import static retrofit.http.TestingUtils.assertBytes;
+import static retrofit.http.TestingUtils.assertMultipart;
+import static retrofit.http.client.ApacheClient.TypedOutputEntity;
 
 public class ApacheClientTest {
   private static final String HOST = "http://example.com";
 
   @Test public void get() {
-    Request request = new Request("GET", HOST + "/foo/bar/?kit=kat", null, false, null, null);
+    Request request = new Request("GET", HOST + "/foo/bar/?kit=kat", null, null);
     HttpUriRequest apacheRequest = ApacheClient.createRequest(request);
 
     assertThat(apacheRequest.getMethod()).isEqualTo("GET");
@@ -40,8 +43,8 @@
   }
 
   @Test public void post() throws Exception {
-    TypedBytes body = new StringTypedBytes("hi");
-    Request request = new Request("POST", HOST + "/foo/bar/", null, false, body, null);
+    TypedString body = new TypedString("hi");
+    Request request = new Request("POST", HOST + "/foo/bar/", null, body);
     HttpUriRequest apacheRequest = ApacheClient.createRequest(request);
 
     assertThat(apacheRequest.getMethod()).isEqualTo("POST");
@@ -52,15 +55,16 @@
     HttpEntityEnclosingRequest entityRequest = (HttpEntityEnclosingRequest) apacheRequest;
     HttpEntity entity = entityRequest.getEntity();
     assertThat(entity).isNotNull();
-    assertBytes(Streams.readFully(entity.getContent()), "hi");
+    assertBytes(ByteStreams.toByteArray(entity.getContent()), "hi");
     assertThat(entity.getContentType().getValue()).isEqualTo("text/plain; charset=UTF-8");
   }
 
   @Test public void multipart() {
-    Map<String, TypedBytes> bodyParams = new LinkedHashMap<String, TypedBytes>();
-    bodyParams.put("foo", new StringTypedBytes("bar"));
-    bodyParams.put("ping", new StringTypedBytes("pong"));
-    Request request = new Request("POST", HOST + "/that/", null, true, null, bodyParams);
+    Map<String, TypedOutput> bodyParams = new LinkedHashMap<String, TypedOutput>();
+    bodyParams.put("foo", new TypedString("bar"));
+    bodyParams.put("ping", new TypedString("pong"));
+    TypedOutput body = TestingUtils.createMultipart(bodyParams);
+    Request request = new Request("POST", HOST + "/that/", null, body);
     HttpUriRequest apacheRequest = ApacheClient.createRequest(request);
 
     assertThat(apacheRequest.getMethod()).isEqualTo("POST");
@@ -69,8 +73,8 @@
 
     assertThat(apacheRequest).isInstanceOf(HttpEntityEnclosingRequest.class);
     HttpEntityEnclosingRequest entityRequest = (HttpEntityEnclosingRequest) apacheRequest;
-    HttpEntity entity = entityRequest.getEntity();
-    assertThat(entity).isInstanceOf(MultipartEntity.class);
+    TypedOutputEntity entity = (TypedOutputEntity) entityRequest.getEntity();
+    assertMultipart(entity.typedOutput);
     // TODO test more?
   }
 
@@ -78,7 +82,7 @@
     List<Header> headers = new ArrayList<Header>();
     headers.add(new Header("kit", "kat"));
     headers.add(new Header("foo", "bar"));
-    Request request = new Request("GET", HOST + "/this/", headers, false, null, null);
+    Request request = new Request("GET", HOST + "/this/", headers, null);
     HttpUriRequest apacheRequest = ApacheClient.createRequest(request);
 
     assertThat(apacheRequest.getAllHeaders()).hasSize(2);
@@ -93,16 +97,18 @@
   @Test public void response() throws Exception {
     StatusLine statusLine = new BasicStatusLine(HttpVersion.HTTP_1_1, 200, "OK");
     HttpResponse apacheResponse = new BasicHttpResponse(statusLine);
-    apacheResponse.setEntity(new TypedBytesEntity(new StringTypedBytes("hello")));
+    apacheResponse.setEntity(new TypedOutputEntity(new TypedString("hello")));
+    apacheResponse.addHeader("Content-Type", "text/plain");
     apacheResponse.addHeader("foo", "bar");
     apacheResponse.addHeader("kit", "kat");
     Response response = ApacheClient.parseResponse(apacheResponse);
 
     assertThat(response.getStatus()).isEqualTo(200);
     assertThat(response.getReason()).isEqualTo("OK");
-    assertThat(response.getHeaders()).hasSize(2) //
-        .containsExactly(new Header("foo", "bar"), new Header("kit", "kat"));
-    assertBytes(response.getBody(), "hello");
+    assertThat(response.getHeaders()).hasSize(3) //
+        .containsOnly(new Header("foo", "bar"), new Header("kit", "kat"),
+            new Header("Content-Type", "text/plain"));
+    assertBytes(ByteStreams.toByteArray(response.getBody().in()), "hello");
   }
 
   @Test public void emptyResponse() throws Exception {
@@ -118,8 +124,4 @@
         .containsExactly(new Header("foo", "bar"), new Header("kit", "kat"));
     assertThat(response.getBody()).isNull();
   }
-
-  private static void assertBytes(byte[] bytes, String expected) throws Exception {
-    assertThat(new String(bytes, "UTF-8")).isEqualTo(expected);
-  }
 }
diff --git a/retrofit/src/test/java/retrofit/http/client/DummyHttpUrlConnection.java b/retrofit/src/test/java/retrofit/http/client/DummyHttpUrlConnection.java
new file mode 100644
index 000000000..f2f94e263
--- /dev/null
+++ b/retrofit/src/test/java/retrofit/http/client/DummyHttpUrlConnection.java
@@ -0,0 +1,115 @@
+// Copyright 2013 Square, Inc.
+package retrofit.http.client;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.HttpURLConnection;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Provides POJO behavior for all of the APIs {@link retrofit.http.client.UrlConnectionClient}
+ * interacts with.
+ */
+public class DummyHttpUrlConnection extends HttpURLConnection {
+  private final Map<String, List<String>> responseHeaders =
+      new LinkedHashMap<String, List<String>>();
+  private final Map<String, List<String>> requestHeaders =
+      new LinkedHashMap<String, List<String>>();
+  private final ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
+  private int responseCode;
+  private String responseMessage;
+  private InputStream inputStream;
+  private InputStream errorStream;
+
+  protected DummyHttpUrlConnection(String url) throws MalformedURLException {
+    super(new URL(url));
+  }
+
+  public void setResponseCode(int responseCode) {
+    this.responseCode = responseCode;
+  }
+
+  @Override public int getResponseCode() throws IOException {
+    return responseCode;
+  }
+
+  public void setResponseMessage(String responseMessage) {
+    this.responseMessage = responseMessage;
+  }
+
+  @Override public String getResponseMessage() throws IOException {
+    return responseMessage;
+  }
+
+  @Override public ByteArrayOutputStream getOutputStream() throws IOException {
+    return outputStream;
+  }
+
+  public void setInputStream(InputStream inputStream) {
+    this.inputStream = inputStream;
+  }
+
+  @Override public InputStream getInputStream() throws IOException {
+    return inputStream;
+  }
+
+  public void setErrorStream(InputStream errorStream) {
+    this.errorStream = errorStream;
+  }
+
+  @Override public InputStream getErrorStream() {
+    return errorStream;
+  }
+
+  public void addResponseHeader(String name, String value) {
+    List<String> values = responseHeaders.get(name);
+    if (values == null) {
+      values = new ArrayList<String>();
+      responseHeaders.put(name, values);
+    }
+    values.add(value);
+  }
+
+  @Override public Map<String, List<String>> getHeaderFields() {
+    return responseHeaders;
+  }
+
+  @Override public void addRequestProperty(String name, String value) {
+    List<String> values = requestHeaders.get(name);
+    if (values == null) {
+      values = new ArrayList<String>();
+      requestHeaders.put(name, values);
+    }
+    values.add(value);
+  }
+
+  @Override public Map<String, List<String>> getRequestProperties() {
+    return requestHeaders;
+  }
+
+  @Override public String getRequestProperty(String name) {
+    List<String> values = requestHeaders.get(name);
+    if (values == null || values.isEmpty()) {
+      return null;
+    }
+    return values.get(0);
+  }
+
+  @Override public void disconnect() {
+    throw new AssertionError("Not implemented.");
+  }
+
+  @Override public boolean usingProxy() {
+    return false;
+  }
+
+  @Override public void connect() throws IOException {
+    throw new AssertionError("Not implemented.");
+  }
+}
diff --git a/retrofit/src/test/java/retrofit/http/client/UrlConnectionClientTest.java b/retrofit/src/test/java/retrofit/http/client/UrlConnectionClientTest.java
new file mode 100644
index 000000000..ce2be4250
--- /dev/null
+++ b/retrofit/src/test/java/retrofit/http/client/UrlConnectionClientTest.java
@@ -0,0 +1,152 @@
+// Copyright 2013 Square, Inc.
+package retrofit.http.client;
+
+import com.google.common.io.ByteStreams;
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.net.HttpURLConnection;
+import java.util.ArrayList;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import org.junit.Test;
+import retrofit.http.Header;
+import retrofit.http.TestingUtils;
+import retrofit.http.mime.TypedOutput;
+import retrofit.http.mime.TypedString;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static retrofit.http.TestingUtils.assertBytes;
+
+public class UrlConnectionClientTest {
+  private static final String HOST = "http://example.com";
+
+  private UrlConnectionClient client = new UrlConnectionClient() {
+    @Override protected HttpURLConnection openConnection(Request request) throws IOException {
+      return new DummyHttpUrlConnection(request.getUrl());
+    }
+  };
+
+  @Test public void get() throws Exception {
+    Request request = new Request("GET", HOST + "/foo/bar/?kit=kat", null, null);
+
+    HttpURLConnection connection = client.openConnection(request);
+    client.prepareRequest(connection, request);
+
+    assertThat(connection.getRequestMethod()).isEqualTo("GET");
+    assertThat(connection.getURL().toString()).isEqualTo(HOST + "/foo/bar/?kit=kat");
+    assertThat(connection.getHeaderFields()).isEmpty();
+  }
+
+  @Test public void post() throws Exception {
+    TypedString body = new TypedString("hi");
+    Request request = new Request("POST", HOST + "/foo/bar/", null, body);
+
+    DummyHttpUrlConnection connection = (DummyHttpUrlConnection) client.openConnection(request);
+    client.prepareRequest(connection, request);
+
+    assertThat(connection.getRequestMethod()).isEqualTo("POST");
+    assertThat(connection.getURL().toString()).isEqualTo(HOST + "/foo/bar/");
+    assertThat(connection.getRequestProperties()).hasSize(2);
+    assertThat(connection.getRequestProperty("Content-Type")) //
+        .isEqualTo("text/plain; charset=UTF-8");
+    assertThat(connection.getRequestProperty("Content-Length")).isEqualTo("2");
+    assertBytes(connection.getOutputStream().toByteArray(), "hi");
+  }
+
+  @Test public void multipart() throws Exception {
+    Map<String, TypedOutput> bodyParams = new LinkedHashMap<String, TypedOutput>();
+    bodyParams.put("foo", new TypedString("bar"));
+    bodyParams.put("ping", new TypedString("pong"));
+    TypedOutput body = TestingUtils.createMultipart(bodyParams);
+    Request request = new Request("POST", HOST + "/that/", null, body);
+
+    DummyHttpUrlConnection connection = (DummyHttpUrlConnection) client.openConnection(request);
+    client.prepareRequest(connection, request);
+
+    byte[] output = connection.getOutputStream().toByteArray();
+
+    assertThat(connection.getRequestMethod()).isEqualTo("POST");
+    assertThat(connection.getURL().toString()).isEqualTo(HOST + "/that/");
+    assertThat(connection.getRequestProperties()).hasSize(2);
+    assertThat(connection.getRequestProperty("Content-Type")).startsWith("multipart/form-data;");
+    assertThat(connection.getRequestProperty("Content-Length")).isEqualTo(String.valueOf(output.length));
+    assertThat(output.length).isGreaterThan(0);
+  }
+
+  @Test public void headers() throws Exception {
+    List<Header> headers = new ArrayList<Header>();
+    headers.add(new Header("kit", "kat"));
+    headers.add(new Header("foo", "bar"));
+    Request request = new Request("GET", HOST + "/this/", headers, null);
+
+    HttpURLConnection connection = client.openConnection(request);
+    client.prepareRequest(connection, request);
+
+    assertThat(connection.getRequestProperties()).hasSize(2);
+    assertThat(connection.getRequestProperty("kit")).isEqualTo("kat");
+    assertThat(connection.getRequestProperty("foo")).isEqualTo("bar");
+  }
+
+  @Test public void response() throws Exception {
+    DummyHttpUrlConnection connection = new DummyHttpUrlConnection(HOST);
+    connection.setResponseCode(200);
+    connection.setResponseMessage("OK");
+    connection.addResponseHeader("Content-Type", "text/plain");
+    connection.addResponseHeader("foo", "bar");
+    connection.addResponseHeader("kit", "kat");
+    connection.setInputStream(new ByteArrayInputStream("hello".getBytes("UTF-8")));
+    Response response = client.readResponse(connection);
+
+    assertThat(response.getStatus()).isEqualTo(200);
+    assertThat(response.getReason()).isEqualTo("OK");
+    assertThat(response.getHeaders()).hasSize(3) //
+        .containsOnly(new Header("foo", "bar"), new Header("kit", "kat"),
+            new Header("Content-Type", "text/plain"));
+    assertBytes(ByteStreams.toByteArray(response.getBody().in()), "hello");
+  }
+
+  @Test public void createdResponse() throws Exception {
+    DummyHttpUrlConnection connection = new DummyHttpUrlConnection(HOST);
+    connection.setResponseCode(201);
+    connection.setResponseMessage("OK");
+    connection.addResponseHeader("Content-Type", "text/plain");
+    connection.addResponseHeader("foo", "bar");
+    connection.addResponseHeader("kit", "kat");
+    connection.setInputStream(new ByteArrayInputStream("hello".getBytes("UTF-8")));
+    Response response = client.readResponse(connection);
+
+    assertThat(response.getStatus()).isEqualTo(201);
+    assertThat(response.getReason()).isEqualTo("OK");
+    assertThat(response.getHeaders()).hasSize(3) //
+        .containsOnly(new Header("foo", "bar"), new Header("kit", "kat"),
+            new Header("Content-Type", "text/plain"));
+    assertBytes(ByteStreams.toByteArray(response.getBody().in()), "hello");
+  }
+
+  @Test public void errorResponse() throws Exception {
+    DummyHttpUrlConnection connection = new DummyHttpUrlConnection(HOST);
+    connection.setResponseCode(401);
+    connection.setResponseMessage("Not Authorized");
+    connection.addResponseHeader("Content-Type", "text/plain");
+    connection.setInputStream(new ByteArrayInputStream("input".getBytes("UTF-8")));
+    connection.setErrorStream(new ByteArrayInputStream("error".getBytes("UTF-8")));
+    Response response = client.readResponse(connection);
+
+    assertBytes(ByteStreams.toByteArray(response.getBody().in()), "error");
+  }
+
+  @Test public void emptyResponse() throws Exception {
+    DummyHttpUrlConnection connection = new DummyHttpUrlConnection(HOST);
+    connection.setResponseCode(200);
+    connection.setResponseMessage("OK");
+    connection.addResponseHeader("foo", "bar");
+    connection.addResponseHeader("kit", "kat");
+    Response response = client.readResponse(connection);
+
+    assertThat(response.getStatus()).isEqualTo(200);
+    assertThat(response.getReason()).isEqualTo("OK");
+    assertThat(response.getHeaders()).hasSize(2) //
+        .containsExactly(new Header("foo", "bar"), new Header("kit", "kat"));
+  }
+}
diff --git a/retrofit/src/test/java/retrofit/io/TypedByteArrayTest.java b/retrofit/src/test/java/retrofit/http/mime/TypedByteArrayTest.java
similarity index 63%
rename from retrofit/src/test/java/retrofit/io/TypedByteArrayTest.java
rename to retrofit/src/test/java/retrofit/http/mime/TypedByteArrayTest.java
index 07f6d5944..ab095261d 100644
--- a/retrofit/src/test/java/retrofit/io/TypedByteArrayTest.java
+++ b/retrofit/src/test/java/retrofit/http/mime/TypedByteArrayTest.java
@@ -1,5 +1,5 @@
 // Copyright 2010 Square, Inc.
-package retrofit.io;
+package retrofit.http.mime;
 
 import org.junit.Test;
 
@@ -9,9 +9,9 @@
   private static final String GIF = "image/gif";
 
   @Test public void objectEquals() {
-    TypedByteArray a1 = new TypedByteArray(new byte[] { 10, 20 }, GIF);
-    TypedByteArray a2 = new TypedByteArray(new byte[] { 10, 20 }, GIF);
-    TypedByteArray b = new TypedByteArray(new byte[] { 8, 12 }, GIF);
+    TypedByteArray a1 = new TypedByteArray(GIF, new byte[] { 10, 20 });
+    TypedByteArray a2 = new TypedByteArray(GIF, new byte[] { 10, 20 });
+    TypedByteArray b = new TypedByteArray(GIF, new byte[] { 8, 12 });
 
     assertThat(a1).isEqualTo(a2);
     assertThat(a1.hashCode()).isEqualTo(a2.hashCode());
diff --git a/retrofit/src/test/java/retrofit/io/TypedFileTest.java b/retrofit/src/test/java/retrofit/http/mime/TypedFileTest.java
similarity index 79%
rename from retrofit/src/test/java/retrofit/io/TypedFileTest.java
rename to retrofit/src/test/java/retrofit/http/mime/TypedFileTest.java
index 1a280556a..cf0d9f66b 100644
--- a/retrofit/src/test/java/retrofit/io/TypedFileTest.java
+++ b/retrofit/src/test/java/retrofit/http/mime/TypedFileTest.java
@@ -1,5 +1,5 @@
 // Copyright 2010 Square, Inc.
-package retrofit.io;
+package retrofit.http.mime;
 
 import java.io.File;
 import java.io.FileOutputStream;
@@ -12,9 +12,9 @@
   private static final String PNG = "image/png";
 
   @Test public void objectEquals() {
-    TypedFile a1 = new TypedFile(new File("a.png"), PNG);
-    TypedFile a2 = new TypedFile(new File("a.png"), PNG);
-    TypedFile b = new TypedFile(new File("b.png"), PNG);
+    TypedFile a1 = new TypedFile(PNG, new File("a.png"));
+    TypedFile a2 = new TypedFile(PNG, new File("a.png"));
+    TypedFile b = new TypedFile(PNG, new File("b.png"));
 
     assertThat(a1).isNotEqualTo(b);
     assertThat(a1.hashCode()).isNotEqualTo(b.hashCode());
@@ -25,14 +25,14 @@
   @Test public void objectToString() {
     File file = new File("/path/to/file.png");
 
-    assertThat(new TypedFile(file, PNG).toString()) //
+    assertThat(new TypedFile(PNG, file).toString()) //
         .isEqualTo(file.getAbsolutePath() + " (image/png)");
   }
 
   @Test public void length() throws IOException {
     File tempFile = File.createTempFile("foo", ".tmp");
     try {
-      TypedFile typedFile = new TypedFile(tempFile, PNG);
+      TypedFile typedFile = new TypedFile(PNG, tempFile);
       assertThat(typedFile.length()).isZero();
 
       writeToFile(tempFile, new byte[] { 0, 1, 2, 3, 4 });
diff --git a/samples/github-client/pom.xml b/samples/github-client/pom.xml
new file mode 100644
index 000000000..9f75f6303
--- /dev/null
+++ b/samples/github-client/pom.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.retrofit</groupId>
+    <artifactId>samples</artifactId>
+    <version>1.0.0-SNAPSHOT</version>
+    <relativePath>../pom.xml</relativePath>
+  </parent>
+
+  <artifactId>sample-github-client</artifactId>
+  <name>Sample: GitHub Client</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup.retrofit</groupId>
+      <artifactId>retrofit</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+  </dependencies>
+</project>
diff --git a/samples/github-client/src/main/java/com/squareup/retrofit/sample/github/Client.java b/samples/github-client/src/main/java/com/squareup/retrofit/sample/github/Client.java
new file mode 100644
index 000000000..aa1fdd4e9
--- /dev/null
+++ b/samples/github-client/src/main/java/com/squareup/retrofit/sample/github/Client.java
@@ -0,0 +1,40 @@
+// Copyright 2012 Square, Inc.
+package com.squareup.retrofit.sample.github;
+
+import java.util.List;
+import retrofit.http.GET;
+import retrofit.http.Name;
+import retrofit.http.RestAdapter;
+
+public class Client {
+  private static final String API_URL = "https://api.github.com";
+
+  class Contributor {
+    String login;
+    int contributions;
+  }
+
+  interface GitHub {
+    @GET("/repos/{owner}/{repo}/contributors")
+    List<Contributor> contributors(
+        @Name("owner") String owner,
+        @Name("repo") String repo
+    );
+  }
+
+  public static void main(String... args) {
+    // Create a very simple REST adapter which points the GitHub API endpoint.
+    RestAdapter restAdapter = new RestAdapter.Builder()
+        .setServer(API_URL)
+        .build();
+
+    // Create an instance of our GitHub API interface.
+    GitHub github = restAdapter.create(GitHub.class);
+
+    // Fetch and print a list of the contributors to this library.
+    List<Contributor> contributors = github.contributors("square", "retrofit");
+    for (Contributor contributor : contributors) {
+      System.out.println(contributor.login + " (" + contributor.contributions + ")");
+    }
+  }
+}
diff --git a/samples/pom.xml b/samples/pom.xml
index 7e8e9fd9e..660a096d2 100644
--- a/samples/pom.xml
+++ b/samples/pom.xml
@@ -1,7 +1,8 @@
 <?xml version="1.0" encoding="UTF-8"?>
 
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+<project xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
   <modelVersion>4.0.0</modelVersion>
 
   <parent>
@@ -16,6 +17,6 @@
   <packaging>pom</packaging>
 
   <modules>
-    <module>twitter-client</module>
+    <module>github-client</module>
   </modules>
 </project>
diff --git a/samples/twitter-client/pom.xml b/samples/twitter-client/pom.xml
deleted file mode 100644
index 99c148264..000000000
--- a/samples/twitter-client/pom.xml
+++ /dev/null
@@ -1,38 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<!--
-  ~ Copyright 2012 Square, Inc.
-  -->
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.retrofit</groupId>
-    <artifactId>samples</artifactId>
-    <version>1.0.0-SNAPSHOT</version>
-    <relativePath>../pom.xml</relativePath>
-  </parent>
-
-  <artifactId>sample-twitter-client</artifactId>
-  <packaging>jar</packaging>
-  <name>Sample: Twitter Client</name>
-
-  <dependencies>
-    <dependency>
-      <groupId>com.squareup.retrofit</groupId>
-      <artifactId>retrofit</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-  </dependencies>
-
-  <build>
-    <plugins>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-checkstyle-plugin</artifactId>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/samples/twitter-client/src/main/java/com/squareup/retrofit/sample/twitter/Client.java b/samples/twitter-client/src/main/java/com/squareup/retrofit/sample/twitter/Client.java
deleted file mode 100644
index 52130007e..000000000
--- a/samples/twitter-client/src/main/java/com/squareup/retrofit/sample/twitter/Client.java
+++ /dev/null
@@ -1,36 +0,0 @@
-// Copyright 2012 Square, Inc.
-package com.squareup.retrofit.sample.twitter;
-
-import java.util.List;
-import javax.inject.Named;
-import retrofit.http.GET;
-import retrofit.http.RestAdapter;
-
-public class Client {
-  private static final String API_URL = "https://api.twitter.com/1/";
-
-  class Tweet {
-    String text;
-  }
-
-  interface Twitter {
-    @GET("/statuses/user_timeline.json")
-    List<Tweet> tweets(@Named("screen_name") String user);
-  }
-
-  public static void main(String... args) {
-    // Create a very simple REST adapter which points the Twitter API endpoint.
-    RestAdapter restAdapter = new RestAdapter.Builder()
-        .setServer(API_URL)
-        .build();
-
-    // Create an instance of our Twitter API interface.
-    Twitter twitter = restAdapter.create(Twitter.class);
-
-    // Fetch and print a list of the 20 most recent tweets for a user.
-    List<Tweet> tweets = twitter.tweets("horse_ebooks");
-    for (Tweet tweet : tweets) {
-      System.out.println(tweet.text);
-    }
-  }
-}
