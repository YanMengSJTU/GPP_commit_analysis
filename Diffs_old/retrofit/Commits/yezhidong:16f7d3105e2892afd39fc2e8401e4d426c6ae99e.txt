diff --git a/.buildscript/deploy_snapshot.sh b/.buildscript/deploy_snapshot.sh
index fd12a9838..8743f45b4 100755
--- a/.buildscript/deploy_snapshot.sh
+++ b/.buildscript/deploy_snapshot.sh
@@ -3,7 +3,7 @@
 # Deploy a jar, source jar, and javadoc jar to Sonatype's snapshot repo.
 #
 # Adapted from https://coderwall.com/p/9b_lfq and
-# http://benlimmer.com/2013/12/26/automatically-publish-javadoc-to-gh-pages-with-travis-ci/
+# https://benlimmer.com/2013/12/26/automatically-publish-javadoc-to-gh-pages-with-travis-ci/
 
 SLUG="square/retrofit"
 JDK="oraclejdk8"
diff --git a/CONTRIBUTING.md b/.github/CONTRIBUTING.md
similarity index 100%
rename from CONTRIBUTING.md
rename to .github/CONTRIBUTING.md
diff --git a/.github/ISSUE_TEMPLATE.md b/.github/ISSUE_TEMPLATE.md
new file mode 100644
index 000000000..85c3e77b7
--- /dev/null
+++ b/.github/ISSUE_TEMPLATE.md
@@ -0,0 +1,12 @@
+What kind of issue is this?
+
+ - [ ] Question. This issue tracker is not the place for questions. If you want to ask how to do
+       something, or to understand why something isn't working the way you expect it to, use Stack
+       Overflow. https://stackoverflow.com/questions/tagged/retrofit
+
+ - [ ] Bug report. If you’ve found a bug, spend the time to write a failing test. Bugs with tests
+       get fixed. Here’s an example: https://gist.github.com/swankjesse/6608b4713ad80988cdc9
+
+ - [ ] Feature Request. Start by telling us what problem you’re trying to solve. Often a solution
+       already exists! Don’t send pull requests to implement new features without first getting our
+       support. Sometimes we leave features out on purpose to keep the project small.
diff --git a/.gitignore b/.gitignore
index 133735f7b..846cab690 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,3 +1,4 @@
+# Eclipse
 .classpath
 .project
 .settings
@@ -13,10 +14,12 @@ target
 pom.xml.*
 release.properties
 
+# Idea
 .idea
 *.iml
 classes
 
 obj
 
+#MacOS
 .DS_Store
diff --git a/CHANGELOG.md b/CHANGELOG.md
index e2eb7feba..7b8d177c6 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,6 +1,244 @@
 Change Log
 ==========
 
+Version 2.4.0 *(2018-03-14)*
+----------------------------
+
+ * New: `Retrofit.Builder` exposes mutable lists of the added converter and call adapter factories.
+ * New: Call adapter added for Scala's `Future`.
+ * New: Converter for JAXB replaces the now-deprecated converter for Simple XML Framework.
+ * New: Add Java 9 automatic module names for each artifact corresponding to their root package.
+ * Fix: Do not swallow `Error`s from callbacks (usually `OutOfMemoryError`).
+ * Fix: Moshi and Gson converters now assert that the full response was consumed. This prevents
+   hiding bugs in faulty adapters which might not have consumed the full JSON input which would
+   then cause failures on the next request over that connection.
+ * Fix: Do not conflate OkHttp `Call` cancelation with RxJava unsubscription/disposal. Prior to
+   this change, canceling of a `Call` would prevent a cancelation exception from propagating down
+   the Rx stream.
+
+
+Version 2.3.0 *(2017-05-13)*
+----------------------------
+
+ *  **Retrofit now uses `@Nullable` to annotate all possibly-null values.** We've
+    added a compile-time dependency on the JSR 305 annotations. This is a
+    [provided][maven_provided] dependency and does not need to be included in
+    your build configuration, `.jar` file, or `.apk`. We use
+    `@ParametersAreNonnullByDefault` and all parameters and return types are
+    never null unless explicitly annotated `@Nullable`.
+
+    **Warning: this release is source-incompatible for Kotlin users.**
+    Nullability was previously ambiguous and lenient but now the compiler will
+    enforce strict null checks.
+
+ * New: Converters added for Java 8's and Guava's `Optional` which wrap a potentially-nullable
+   response body. These converters still rely on normal serialization library converters for parsing
+   the response bytes into an object.
+ * New: String converters that return `null` for an `@Query` or `@Field` parameter are now skipped.
+ * New: The mock module's `NetworkBehavior` now throws a custom subclass of `IOException` to more
+   clearly indicate the exception's source.
+ * RxJava 1.x converter updated to 1.3.0 which stabilizes the use of `Completable`.
+ * Fix: Add explicit handling for `OnCompleteFailedException`, `OnErrorFailedException`, and
+   `OnErrorNotImplementedException` for RxJava 1.x to ensure they're correct delivered to the
+   plugins/hooks for handling.
+ * Fix: `NoSuchElementException` thrown when unsubscribing from an RxJava 1.x `Single`.
+
+
+Version 2.2.0 *(2017-02-21)*
+----------------------------
+
+ * RxJava 2.x is now supported with a first-party 'adapter-rxjava2' artifact.
+ * New: `@QueryName` annotation allows creating a query parameter with no '=' separator or value.
+ * New: Support for messages generated by Protobuf 3.0 or newer when using the converter for Google's
+   protobuf.
+ * New: RxJava 1.x call adapter now correctly handles broken subscribers whose methods throw exceptions.
+ * New: Add `toString()` implementations for `Response` and `Result`.
+ * New: The Moshi converter factory now offers methods for enabling null serialization and lenient
+   parsing.
+ * New: Add `createAsync()` to RxJava 1.x call adapter factory which executes requests using
+   `Call.enqueue()` using the underlying HTTP client's asynchronous support.
+ * New: `NetworkBehavior` now allows setting an error percentage and returns HTTP errors when triggered.
+ * `HttpException` has been moved into the main artifact and should be used instead of the versions
+   embedded in each adapter (which have been deprecated).
+ * Promote the response body generic type on `CallAdapter` from the `adapt` method to the enclosing
+   class. This is a source-incompatible but binary-compatible change which is only relevant if you are
+   implementing your own `CallAdapter`s.
+ * Remove explicit handling of the now-defunct RoboVM platform.
+ * Fix: Close response on HTTP 204 and 205 to avoid resource leak.
+ * Fix: Reflect the canceled state of the HTTP client's `Call` in Retrofit's `Call`.
+ * Fix: Use supplied string converters for the `String` type on non-body parameters. This allows user
+   converters to handle cases such as when annotating string parameters instead of them always using
+   the raw string.
+ * Fix: Skip a UTF-8 BOM (if present) when using the converter for Moshi.
+
+
+Version 2.1.0 *(2016-06-15)*
+----------------------------
+
+ * New: `@HeaderMap` annotation and support for supplying an arbitrary number of headers to an endpoint.
+ * New: `@JsonAdapter` annotations on the `@Body` parameter and on the method will be propagated to Moshi
+   for creating the request and response adapters, respectively.
+ * Fix: Honor the `Content-Type` encoding of XML responses when deserializing response bodies.
+ * Fix: Remove the stacktrace from fake network exceptions created from retrofit-mock's `NetworkBehavior`.
+   They had the potential to be misleading and look like a library issue.
+ * Fix: Eagerly catch malformed `Content-Type` headers supplied via `@Header` or `@Headers`.
+
+
+Version 2.0.2 *(2016-04-14)*
+----------------------------
+
+ * New: `ProtoConverterFactory.createWithRegistry()` method accepts an extension registry to be used
+   when deserializing protos.
+ * Fix: Pass the correct `Call` instance to `Callback`'s `onResponse` and `onFailure` methods such
+   that calling `clone()` retains the correct threading behavior.
+ * Fix: Reduce the per-request allocation overhead for the RxJava call adapter.
+
+
+Version 2.0.1 *(2016-03-30)*
+----------------------------
+
+ * New: Support OkHttp's `HttpUrl` as a `@Url` parameter type.
+ * New: Support iterable and array `@Part` parameters using OkHttp's `MultipartBody.Part`.
+ * Fix: Honor backpressure in `Observable`s created from the RxJavaCallAdapterFactory.
+
+
+Version 2.0.0 *(2016-03-11)*
+----------------------------
+
+Retrofit 2 is a major release focused on extensibility. The API changes are numerous but solve
+shortcomings of the previous version and provide a path for future enhancement.
+
+Because the release includes breaking API changes, we're changing the project's package name from
+`retrofit` to `retrofit2`. This should make it possible for large applications and libraries to
+migrate incrementally. The Maven group ID is now `com.squareup.retrofit2`. For an explanation of
+this strategy, see Jake Wharton's post, [Java Interoperability Policy for Major Version
+Updates](http://jakewharton.com/java-interoperability-policy-for-major-version-updates/).
+
+ * **Service methods return `Call<T>`.** This allows them to be executed synchronously or
+   asynchronously using the same method definition. A `Call` instance represents a single
+   request/response pair so it can only be used once, but you can `clone()` it for re-use.
+   Invoking `cancel()` will cancel in-flight requests or prevent the request from even being
+   performed if it has not already.
+ 
+ * **Multiple converters for multiple serialization formats.** API calls returning different
+  formats (like JSON, protocol buffers, and plain text) no longer need to be separated into
+  separate service interfaces. Combine them together and add multiple converters. Converters are
+  chosen based on the response type you declare. Gson is no longer included by default, so you will
+  always need to add a converter for any serialization support. OkHttp's `RequestBody` and
+  `ResponseBody` types can always be used without adding one, however.
+   
+ * **Call adapters allow different execution mechanisms.** While `Call` is the built-in mechanism,
+   support for additional ones can be added similar to how different converters can be added.
+   RxJava's `Observable` support has moved into a separate artifact as a result, and support for
+   Java 8's `CompletableFuture` and Guava's `ListenableFuture` are also provided as additional
+   artifacts.
+   
+ * **Generic response type includes HTTP information and deserialized body.** You no longer have to
+   choose between the deserialized body and reading HTTP information. Every `Call` automatically
+   receives both via the `Response<T>` type and the RxJava, Guava, and Java 8 call adapters also
+   support it.
+   
+ * **@Url for hypermedia-like APIs.** When your API returns links for pagination, additional
+   resources, or updated content they can now be used with a service method whose first parameter
+   is annotated with `@Url`.
+
+Changes from beta 4:
+
+ * New: `RxJavaCallAdapterFactory` now supports service methods which return `Completable` which
+   ignores and discards response bodies, if any.
+ * New: `RxJavaCallAdapterFactory` supports supplying a default `Scheduler` which will be used
+   for `subscribeOn` on returned `Observable`, `Single`, and `Completable` instances.
+ * New: `MoshiConverterFactory` supports creating an instance which uses lenient parsing.
+ * New: `@Part` can omit the part name and use OkHttp's `MultipartBody.Part` type for supplying
+   parts. This lets you customize the headers, name, and filename and provide the part body in a
+   single argument.
+ * The `BaseUrl` interface and support for changeable base URLs was removed. This functionality
+   can be done using an OkHttp interceptor and a sample showcasing it was added.
+ * `Response.isSuccess()` was renamed to `Response.isSuccessful()` for parity with the name of
+   OkHttp's version of that method.
+ * Fix: Throw a more appropriate exception with a message when a resolved url (base URL + relative
+   URL) is malformed.
+ * Fix: `GsonConverterFactory` now honors settings on the `Gson` instance (like leniency).
+ * Fix: `ScalarsConverterFactory` now supports primitive scalar types in addition to boxed for
+   response body parsing.
+ * Fix: `Retrofit.callbackExecutor()` may now return an executor even when one was not explicitly
+   provided. This allows custom `CallAdapter.Factory` implementations to use it when triggering
+   callbacks to ensure they happen on the appropriate thread for the platform (e.g., Android).
+
+
+Version 2.0.0-beta4 *(2016-02-04)*
+----------------------------------
+
+ * New: `Call` instance is now passed to both `onResponse` and `onFailure` methods of `Callback`. This aids
+   in detecting when `onFailure` is called as a result of `Call.cancel()` by checking `Call.isCanceled()`.
+ * New: `Call.request()` returns (optionally creating) the `Request` object for the call. Note: If this is
+   called before `Call.execute()` or `Call.enqueue()` this will do relatively expensive work synchronously.
+   Doing so in performance-critical sections (like on the Android main thread) should be avoided.
+ * New: Support for the release version of OkHttp 3.0 and newer.
+ * New: `adapter-guava` module provides a `CallAdapter.Factory` for Guava's `ListenableFuture`.
+ * New: `adapter-java8` module provides a `CallAdapter.Factory` for Java 8's `CompleteableFuture`.
+ * New: `ScalarsConverterFactory` (from `converter-scalars` module) now supports parsing response bodies
+   into either `String`, the 8 primitive types, or the 8 boxed primitive types.
+ * New: Automatic support for sending callbacks to the iOS main thread when running via RoboVM.
+ * New: Method annotations are now passed to the factory for request body converters. This allows converters
+   to alter the structure of both request bodies and response bodies with a single method-level annotation.
+ * Each converter has been moved to its own package under `retrofit2.converter.<name>`. This prevents type
+   collisions when many converters are simultaneously in use.
+ * Fix: Exceptions thrown when unable to locate a `CallAdapter.Factory` for a method return type now
+   correctly list the `CallAdapter.Factory` instances checked.
+ * Fix: Ensure default methods on service interfaces can be invoked.
+ * Fix: Correctly resolve the generic parameter types of collection interfaces when subclasses of those
+   collections are used as method parameters.
+ * Fix: Do not encode `/` characters in `@Path` replacements when `encoded = true`.
+
+
+Version 2.0.0-beta3 *(2016-01-05)*
+----------------------------------
+
+ * New: All classes have been migrated to the `retrofit2.*` package name. The Maven groupId is now
+   `com.squareup.retrofit2`. This is in accordance with the
+   [Java Interoperability Policy for Major Version Updates](http://jakewharton.com/java-interoperability-policy-for-major-version-updates/).
+   With this change Retrofit 2.x can coexiest with Retrofit 1.x in the same project.
+ * New: Update to use the OkHttp 3 API and OkHttp 3.0.0-RC1 or newer is now required. Similar to the previous
+   point, OkHttp has a new package name (`okhttp3.*`) and Maven groupId (`com.squareup.okhttp3`) which allow
+   it to coexist with OkHttp 2.x in the same project.
+ * New: String converters allow for custom serialization of parameters that end up as strings (such as `@Path`,
+   `@Query`, `@Header`, etc.). `Converter.Factory` has a new `stringConverter` method which receives the
+   parameter type and annotations and can return a converter for that type. This allows providing custom
+   rendering of types like `Date`, `User`, etc. to a string before being used for its purpose. A default
+   converter will call `toString()` for any type which retains the mimics the previous behavior.
+ * New: OkHttp's `Call.Factory` type is now used as the HTTP client rather than using the `OkHttpClient` type
+   directly (`OkHttpClient` does implement `Call.Factory`). A `callFactory` method has been added to both
+   `Retrofit.Builder` and `Retrofit` to allow supplying alternate implementations of an HTTP client. The
+   `client(OkHttpClient)` method on `Retrofit.Builder` still exists as a convenience.
+ * New: `isExecuted()` method returns whether a `Call` has been synchronously or asynchronously executed.
+ * New: `isCanceled()` method returns whether a `Call` has been canceled. Use this in `onFailure` to determine
+   whether the callback was invoked from cancellation or actual transport failure.
+ * New: `converter-scalars` module provides a `Converter.Factory` for converting `String`, the 8 primitive
+   types, and the 8 boxed primitive types as `text/plain` bodies. Install this before your normal converter
+   to avoid passing these simple scalars through, for example, a JSON converter.
+ * New: `Converter.Factory` methods now receive a `Retrofit` instance which also now has methods for querying
+   the next converter for a given type. This allows implementations to delegate to others and provide
+   additional behavior without complete reimplementation.
+ * New: `@OPTIONS` annotation more easily allows for making OPTIONS requests.
+ * New: `@Part` annotation now supports `List` and array types.
+ * New: The `@Url` annotation now allows using `java.net.URI` or `android.net.Uri` (in addition to `String`)
+   as parameter types for providing relative or absolute endpoint URLs dynamically.
+ * New: The `retrofit-mock` module has been rewritten with a new `BehaviorDelegate` class for implementing
+   fake network behavior in a local mock implementation of your service endpoints. Documentation and more
+   tests are forthcoming, but the `SimpleMockService` demonstrates its use for now.
+ * Fix: Forbid Retrofit's `Response` type and OkHttp's `Response` type as the response body type given to
+   a `Call` (i.e., `Call<Response>`). OkHttp's `ResponseBody` type is the correct one to use when the raw
+   body contents are desired.
+ * Fix: The Gson converter now respects settings on the supplied `Gson` instance (such as `serializeNulls`).
+   This requires Gson 2.4 or newer.
+ * The Wire converter has been updated to the Wire 2.0 API.
+ * The change in 2.0.0-beta2 which provided the `Retrofit` instance to the `onResponse` callback of `Callback`
+   has been reverted. There are too many edge cases around providing the `Retrofit` object in order to allow
+   deserialization of the error body. To accommodate this use case, pass around the `Retrofit` response
+   manually or implement a custom `CallAdapter.Factory` does so automatically.
+
+
 Version 2.0.0-beta2 *(2015-09-28)*
 ----------------------------------
 
@@ -145,7 +383,7 @@ Version 1.5.0 *(2014-03-20)*
  * Fix: Support empty HTTP response status reason.
  * If an `ErrorHandler` is supplied it will be invoked for `Callback` and `Observable` methods.
  * HTTP `PATCH` method using `HttpUrlConnection` is no longer supported. Add the
-   [OkHttp](http://square.github.io/okhttp) jar to your project if you need this behavior.
+   [OkHttp](https://square.github.io/okhttp) jar to your project if you need this behavior.
  * Custom `Client` implementations should no longer set `Content-Type` or `Content-Length` headers
    based on the `TypedInput` body of the `Request`. These headers will now be added automatically
    as part of the standard `Request` header list.
@@ -198,7 +436,7 @@ Version 1.2.2 *(2013-09-12)*
 Version 1.2.1 *(2013-08-30)*
 ----------------------------
 
- * New: Converter for [Wire protocol buffers](http://github.com/square/wire)!
+ * New: Converter for [Wire protocol buffers](https://github.com/square/wire)!
 
 
 Version 1.2.0 *(2013-08-23)*
@@ -260,3 +498,6 @@ Version 1.0.0 *(2013-05-13)*
 ----------------------------
 
 Initial release.
+
+
+ [maven_provided]: https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html
diff --git a/README.md b/README.md
index 5bbcdc582..cea3f3870 100644
--- a/README.md
+++ b/README.md
@@ -12,14 +12,14 @@ Download
 Download [the latest JAR][2] or grab via Maven:
 ```xml
 <dependency>
-  <groupId>com.squareup.retrofit</groupId>
+  <groupId>com.squareup.retrofit2</groupId>
   <artifactId>retrofit</artifactId>
-  <version>2.0.0-beta2</version>
+  <version>2.4.0</version>
 </dependency>
 ```
 or Gradle:
 ```groovy
-compile 'com.squareup.retrofit:retrofit:2.0.0-beta2'
+implementation 'com.squareup.retrofit2:retrofit:2.4.0'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
@@ -27,6 +27,23 @@ Snapshots of the development version are available in [Sonatype's `snapshots` re
 Retrofit requires at minimum Java 7 or Android 2.3.
 
 
+ProGuard
+--------
+
+If you are using ProGuard you need to add the following options:
+```
+# Retain generic type information for use by reflection by converters and adapters.
+-keepattributes Signature
+# Retain service method parameters.
+-keepclassmembernames,allowobfuscation interface * {
+    @retrofit2.http.* <methods>;
+}
+# Ignore annotation used for build tooling.
+-dontwarn org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement
+```
+
+You might also need rules for OkHttp and Okio which are dependencies.
+
 
 License
 =======
@@ -46,6 +63,6 @@ License
     limitations under the License.
 
 
- [1]: http://square.github.io/retrofit/
- [2]: https://search.maven.org/remote_content?g=com.squareup.retrofit&a=retrofit&v=LATEST
+ [1]: https://square.github.io/retrofit/
+ [2]: https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=retrofit&v=LATEST
  [snap]: https://oss.sonatype.org/content/repositories/snapshots/
diff --git a/checkstyle.xml b/checkstyle.xml
index ceb1d5cdf..4721a2fdc 100644
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -1,10 +1,12 @@
 <?xml version="1.0"?>
 <!DOCTYPE module PUBLIC
-    "-//Puppy Crawl//DTD Check Configuration 1.2//EN"
-    "http://www.puppycrawl.com/dtds/configuration_1_2.dtd">
+    "-//Puppy Crawl//DTD Check Configuration 1.3//EN"
+    "http://www.puppycrawl.com/dtds/configuration_1_3.dtd">
 
 <module name="Checker">
-    <module name="NewlineAtEndOfFile"/>
+    <module name="NewlineAtEndOfFile">
+        <property name="lineSeparator" value="lf" />
+    </module>
     <module name="FileLength"/>
     <module name="FileTabCharacter"/>
 
@@ -100,7 +102,6 @@
         <!--module name="InnerAssignment"/-->
         <!--module name="MagicNumber"/-->
         <module name="MissingSwitchDefault"/>
-        <module name="RedundantThrows"/>
         <module name="SimplifyBooleanExpression"/>
         <module name="SimplifyBooleanReturn"/>
 
@@ -121,6 +122,7 @@
         <module name="UpperEll"/>
         <module name="Indentation">
           <property name="basicOffset" value="2"/>
+          <property name="caseIndent" value="2"/>
         </module>
     </module>
 </module>
diff --git a/pom.xml b/pom.xml
index 3d4ce896e..a389b655c 100644
--- a/pom.xml
+++ b/pom.xml
@@ -25,12 +25,12 @@
 
   <groupId>com.squareup.retrofit2</groupId>
   <artifactId>parent</artifactId>
-  <version>2.0.0-SNAPSHOT</version>
+  <version>2.4.1-SNAPSHOT</version>
   <packaging>pom</packaging>
 
   <name>Retrofit (Parent)</name>
   <description>Type-safe HTTP client for Android and Java by Square, Inc.</description>
-  <url>http://github.com/square/retrofit/</url>
+  <url>https://github.com/square/retrofit/</url>
 
   <modules>
     <module>retrofit</module>
@@ -49,30 +49,36 @@
 
     <!-- Dependencies -->
     <android.version>4.1.1.4</android.version>
-    <android.platform>16</android.platform>
-    <okhttp.version>2.5.0</okhttp.version>
+    <okhttp.version>3.10.0</okhttp.version>
     <animal.sniffer.version>1.14</animal.sniffer.version>
 
     <!-- Adapter Dependencies -->
-    <rxjava.version>1.0.14</rxjava.version>
+    <rxjava.version>1.3.0</rxjava.version>
+    <rxjava2.version>2.0.0</rxjava2.version>
+    <guava.version>19.0</guava.version>
+    <scala.version>2.12.4</scala.version>
 
     <!-- Converter Dependencies -->
-    <gson.version>2.4</gson.version>
-    <protobuf.version>2.5.0</protobuf.version>
-    <jackson.version>2.4.3</jackson.version>
-    <wire.version>2.0.0</wire.version>
+    <gson.version>2.8.2</gson.version>
+    <protobuf.version>3.0.0</protobuf.version>
+    <jackson.version>2.9.4</jackson.version>
+    <wire.version>2.2.0</wire.version>
     <simplexml.version>2.7.1</simplexml.version>
-    <moshi.version>1.0.0</moshi.version>
+    <moshi.version>1.5.0</moshi.version>
+    <jaxb.version>2.2.12</jaxb.version><!-- 2.3.0 breaks due to https://github.com/mojohaus/animal-sniffer/issues/29 -->
+
+    <!-- Sample Dependencies -->
+    <jsoup.version>1.7.3</jsoup.version>
 
     <!-- Test Dependencies -->
     <junit.version>4.12</junit.version>
     <assertj.version>1.7.0</assertj.version>
     <mockito.version>1.9.5</mockito.version>
-    <guava.version>18.0</guava.version>
+    <robolectric.version>3.0</robolectric.version>
   </properties>
 
   <scm>
-    <url>http://github.com/square/retrofit</url>
+    <url>https://github.com/square/retrofit</url>
     <connection>scm:git:git://github.com/square/retrofit.git</connection>
     <developerConnection>scm:git:ssh://git@github.com/square/retrofit.git</developerConnection>
     <tag>HEAD</tag>
@@ -80,19 +86,19 @@
 
   <issueManagement>
     <system>GitHub Issues</system>
-    <url>http://github.com/square/retrofit/issues</url>
+    <url>https://github.com/square/retrofit/issues</url>
   </issueManagement>
 
   <licenses>
     <license>
       <name>Apache 2.0</name>
-      <url>http://www.apache.org/licenses/LICENSE-2.0.txt</url>
+      <url>https://www.apache.org/licenses/LICENSE-2.0.txt</url>
     </license>
   </licenses>
 
   <organization>
     <name>Square, Inc.</name>
-    <url>http://squareup.com</url>
+    <url>https://squareup.com</url>
   </organization>
 
   <dependencyManagement>
@@ -108,7 +114,7 @@
         <version>${animal.sniffer.version}</version>
       </dependency>
       <dependency>
-        <groupId>com.squareup.okhttp</groupId>
+        <groupId>com.squareup.okhttp3</groupId>
         <artifactId>okhttp</artifactId>
         <version>${okhttp.version}</version>
       </dependency>
@@ -122,7 +128,11 @@
         <artifactId>rxjava</artifactId>
         <version>${rxjava.version}</version>
       </dependency>
-
+      <dependency>
+        <groupId>io.reactivex.rxjava2</groupId>
+        <artifactId>rxjava</artifactId>
+        <version>${rxjava2.version}</version>
+      </dependency>
       <dependency>
         <groupId>com.google.protobuf</groupId>
         <artifactId>protobuf-java</artifactId>
@@ -148,7 +158,21 @@
         <artifactId>moshi</artifactId>
         <version>${moshi.version}</version>
       </dependency>
-
+      <dependency>
+        <groupId>javax.xml.bind</groupId>
+        <artifactId>jaxb-api</artifactId>
+        <version>${jaxb.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>org.scala-lang</groupId>
+        <artifactId>scala-library</artifactId>
+        <version>${scala.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>com.google.code.findbugs</groupId>
+        <artifactId>jsr305</artifactId>
+        <version>3.0.2</version>
+      </dependency>
       <dependency>
         <groupId>junit</groupId>
         <artifactId>junit</artifactId>
@@ -170,10 +194,15 @@
         <version>${guava.version}</version>
       </dependency>
       <dependency>
-        <groupId>com.squareup.okhttp</groupId>
+        <groupId>com.squareup.okhttp3</groupId>
         <artifactId>mockwebserver</artifactId>
         <version>${okhttp.version}</version>
       </dependency>
+      <dependency>
+        <groupId>org.robolectric</groupId>
+        <artifactId>robolectric</artifactId>
+        <version>${robolectric.version}</version>
+      </dependency>
     </dependencies>
   </dependencyManagement>
 
@@ -183,11 +212,25 @@
         <plugin>
           <groupId>org.apache.maven.plugins</groupId>
           <artifactId>maven-compiler-plugin</artifactId>
-          <version>3.0</version>
+          <version>3.6.1</version>
           <configuration>
+            <compilerId>javac-with-errorprone</compilerId>
+            <forceJavacCompilerUse>true</forceJavacCompilerUse>
             <source>${java.version}</source>
             <target>${java.version}</target>
           </configuration>
+          <dependencies>
+            <dependency>
+              <groupId>org.codehaus.plexus</groupId>
+              <artifactId>plexus-compiler-javac-errorprone</artifactId>
+              <version>2.8.1</version>
+            </dependency>
+            <dependency>
+              <groupId>com.google.errorprone</groupId>
+              <artifactId>error_prone_core</artifactId>
+              <version>2.0.16</version>
+            </dependency>
+          </dependencies>
         </plugin>
       </plugins>
     </pluginManagement>
@@ -196,7 +239,14 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-release-plugin</artifactId>
-        <version>2.5</version>
+        <version>2.4.2</version>
+        <dependencies>
+          <dependency>
+            <groupId>org.apache.maven.scm</groupId>
+            <artifactId>maven-scm-provider-gitexe</artifactId>
+            <version>1.9</version>
+          </dependency>
+        </dependencies>
         <configuration>
           <autoVersionSubmodules>true</autoVersionSubmodules>
         </configuration>
@@ -205,7 +255,14 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-checkstyle-plugin</artifactId>
-        <version>2.15</version>
+        <version>2.17</version>
+        <dependencies>
+          <dependency>
+            <groupId>com.puppycrawl.tools</groupId>
+            <artifactId>checkstyle</artifactId>
+            <version>7.7</version>
+          </dependency>
+        </dependencies>
         <configuration>
           <failsOnError>true</failsOnError>
           <configLocation>checkstyle.xml</configLocation>
diff --git a/retrofit-adapters/README.md b/retrofit-adapters/README.md
index 2dd0b7d47..34e18813b 100644
--- a/retrofit-adapters/README.md
+++ b/retrofit-adapters/README.md
@@ -1,4 +1,14 @@
 Retrofit Adapters
 =================
 
-TODO
+Retrofit ships with a default adapter for executing `Call` instances. The child modules contained
+herein are additional adapters for other popular execution mechanisms.
+
+To use, supply an instance of your desired adapter when building your `Retrofit` instance.
+
+```java
+Retrofit retrofit = new Retrofit.Builder()
+    .baseUrl("https://api.example.com")
+    .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
+    .build();
+```
diff --git a/retrofit-adapters/guava/README.md b/retrofit-adapters/guava/README.md
new file mode 100644
index 000000000..b1449e80e
--- /dev/null
+++ b/retrofit-adapters/guava/README.md
@@ -0,0 +1,50 @@
+Guava Adapter
+==============
+
+An `Adapter` for adapting [Guava][1] `ListenableFuture`.
+
+
+Usage
+-----
+
+Add `GuavaCallAdapterFactory` as a `Call` adapter when building your `Retrofit` instance:
+```java
+Retrofit retrofit = new Retrofit.Builder()
+    .baseUrl("https://example.com/")
+    .addCallAdapterFactory(GuavaCallAdapterFactory.create())
+    .build();
+```
+
+Your service methods can now use `ListenableFuture` as their return type.
+```java
+interface MyService {
+  @GET("/user")
+  ListenableFuture<User> getUser();
+}
+```
+
+
+Download
+--------
+
+Download [the latest JAR][2] or grab via [Maven][3]:
+```xml
+<dependency>
+  <groupId>com.squareup.retrofit2</groupId>
+  <artifactId>adapter-guava</artifactId>
+  <version>latest.version</version>
+</dependency>
+```
+or [Gradle][3]:
+```groovy
+compile 'com.squareup.retrofit2:adapter-guava:latest.version'
+```
+
+Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
+
+
+
+ [1]: https://github.com/google/guava
+ [2]: https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=adapter-guava&v=LATEST
+ [3]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup.retrofit2%22%20a%3A%22adapter-guava%22
+ [snap]: https://oss.sonatype.org/content/repositories/snapshots/
diff --git a/retrofit-adapters/guava/pom.xml b/retrofit-adapters/guava/pom.xml
new file mode 100644
index 000000000..98f9f531b
--- /dev/null
+++ b/retrofit-adapters/guava/pom.xml
@@ -0,0 +1,64 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.retrofit2</groupId>
+    <artifactId>retrofit-adapters</artifactId>
+    <version>2.4.1-SNAPSHOT</version>
+    <relativePath>../pom.xml</relativePath>
+  </parent>
+
+  <artifactId>adapter-guava</artifactId>
+  <name>Adapter: Guava</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>retrofit</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.assertj</groupId>
+      <artifactId>assertj-core</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp3</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-jar-plugin</artifactId>
+        <configuration>
+          <archive>
+            <manifestEntries>
+              <Automatic-Module-Name>retrofit2.adapter.guava</Automatic-Module-Name>
+            </manifestEntries>
+          </archive>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
diff --git a/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/GuavaCallAdapterFactory.java b/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/GuavaCallAdapterFactory.java
new file mode 100644
index 000000000..64dd0f5ad
--- /dev/null
+++ b/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/GuavaCallAdapterFactory.java
@@ -0,0 +1,152 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.guava;
+
+import com.google.common.util.concurrent.AbstractFuture;
+import com.google.common.util.concurrent.ListenableFuture;
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import retrofit2.Call;
+import retrofit2.CallAdapter;
+import retrofit2.Callback;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+
+/**
+ * A {@linkplain CallAdapter.Factory call adapter} which creates Guava futures.
+ * <p>
+ * Adding this class to {@link Retrofit} allows you to return {@link ListenableFuture} from service
+ * methods.
+ * <pre><code>
+ * interface MyService {
+ *   &#64;GET("user/me")
+ *   ListenableFuture&lt;User&gt; getUser()
+ * }
+ * </code></pre>
+ * There are two configurations supported for the {@code ListenableFuture} type parameter:
+ * <ul>
+ * <li>Direct body (e.g., {@code ListenableFuture<User>}) returns the deserialized body for 2XX
+ * responses, sets {@link retrofit2.HttpException HttpException} errors for non-2XX responses, and
+ * sets {@link IOException} for network errors.</li>
+ * <li>Response wrapped body (e.g., {@code ListenableFuture<Response<User>>}) returns a
+ * {@link Response} object for all HTTP responses and sets {@link IOException} for network
+ * errors</li>
+ * </ul>
+ */
+public final class GuavaCallAdapterFactory extends CallAdapter.Factory {
+  public static GuavaCallAdapterFactory create() {
+    return new GuavaCallAdapterFactory();
+  }
+
+  private GuavaCallAdapterFactory() {
+  }
+
+  @Override
+  public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+    if (getRawType(returnType) != ListenableFuture.class) {
+      return null;
+    }
+    if (!(returnType instanceof ParameterizedType)) {
+      throw new IllegalStateException("ListenableFuture return type must be parameterized"
+          + " as ListenableFuture<Foo> or ListenableFuture<? extends Foo>");
+    }
+    Type innerType = getParameterUpperBound(0, (ParameterizedType) returnType);
+
+    if (getRawType(innerType) != Response.class) {
+      // Generic type is not Response<T>. Use it for body-only adapter.
+      return new BodyCallAdapter<>(innerType);
+    }
+
+    // Generic type is Response<T>. Extract T and create the Response version of the adapter.
+    if (!(innerType instanceof ParameterizedType)) {
+      throw new IllegalStateException("Response must be parameterized"
+          + " as Response<Foo> or Response<? extends Foo>");
+    }
+    Type responseType = getParameterUpperBound(0, (ParameterizedType) innerType);
+    return new ResponseCallAdapter<>(responseType);
+  }
+
+  private static final class BodyCallAdapter<R> implements CallAdapter<R, ListenableFuture<R>> {
+    private final Type responseType;
+
+    BodyCallAdapter(Type responseType) {
+      this.responseType = responseType;
+    }
+
+    @Override public Type responseType() {
+      return responseType;
+    }
+
+    @Override public ListenableFuture<R> adapt(final Call<R> call) {
+      return new AbstractFuture<R>() {
+        {
+          call.enqueue(new Callback<R>() {
+            @Override public void onResponse(Call<R> call, Response<R> response) {
+              if (response.isSuccessful()) {
+                set(response.body());
+              } else {
+                setException(new HttpException(response));
+              }
+            }
+
+            @Override public void onFailure(Call<R> call, Throwable t) {
+              setException(t);
+            }
+          });
+        }
+
+        @Override protected void interruptTask() {
+          call.cancel();
+        }
+      };
+    }
+  }
+
+  private static final class ResponseCallAdapter<R>
+      implements CallAdapter<R, ListenableFuture<Response<R>>> {
+    private final Type responseType;
+
+    ResponseCallAdapter(Type responseType) {
+      this.responseType = responseType;
+    }
+
+    @Override public Type responseType() {
+      return responseType;
+    }
+
+    @Override public ListenableFuture<Response<R>> adapt(final Call<R> call) {
+      return new AbstractFuture<Response<R>>() {
+        {
+          call.enqueue(new Callback<R>() {
+            @Override public void onResponse(Call<R> call, Response<R> response) {
+              set(response);
+            }
+
+            @Override public void onFailure(Call<R> call, Throwable t) {
+              setException(t);
+            }
+          });
+        }
+
+        @Override protected void interruptTask() {
+          call.cancel();
+        }
+      };
+    }
+  }
+}
diff --git a/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/HttpException.java b/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/HttpException.java
new file mode 100644
index 000000000..4eb780eaa
--- /dev/null
+++ b/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/HttpException.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.guava;
+
+import retrofit2.Response;
+
+/** @deprecated Use {@link retrofit2.HttpException}. */
+@Deprecated
+public final class HttpException extends retrofit2.HttpException {
+  public HttpException(Response<?> response) {
+    super(response);
+  }
+}
diff --git a/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/package-info.java b/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/package-info.java
new file mode 100644
index 000000000..7943d1191
--- /dev/null
+++ b/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/package-info.java
@@ -0,0 +1,4 @@
+@ParametersAreNonnullByDefault
+package retrofit2.adapter.guava;
+
+import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/GuavaCallAdapterFactoryTest.java b/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/GuavaCallAdapterFactoryTest.java
new file mode 100644
index 000000000..c8abdf1c2
--- /dev/null
+++ b/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/GuavaCallAdapterFactoryTest.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.guava;
+
+import com.google.common.reflect.TypeToken;
+import com.google.common.util.concurrent.ListenableFuture;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import java.util.List;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.CallAdapter;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class GuavaCallAdapterFactoryTest {
+  private static final Annotation[] NO_ANNOTATIONS = new Annotation[0];
+
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private final CallAdapter.Factory factory = GuavaCallAdapterFactory.create();
+  private Retrofit retrofit;
+
+  @Before public void setUp() {
+    retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(factory)
+        .build();
+  }
+
+  @Test public void responseType() {
+    Type bodyClass = new TypeToken<ListenableFuture<String>>() {}.getType();
+    assertThat(factory.get(bodyClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type bodyWildcard = new TypeToken<ListenableFuture<? extends String>>() {}.getType();
+    assertThat(factory.get(bodyWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type bodyGeneric = new TypeToken<ListenableFuture<List<String>>>() {}.getType();
+    assertThat(factory.get(bodyGeneric, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(new TypeToken<List<String>>() {}.getType());
+    Type responseClass = new TypeToken<ListenableFuture<Response<String>>>() {}.getType();
+    assertThat(factory.get(responseClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type responseWildcard = new TypeToken<ListenableFuture<Response<? extends String>>>() {}.getType();
+    assertThat(factory.get(responseWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type resultClass = new TypeToken<ListenableFuture<Response<String>>>() {}.getType();
+    assertThat(factory.get(resultClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type resultWildcard = new TypeToken<ListenableFuture<Response<? extends String>>>() {}.getType();
+    assertThat(factory.get(resultWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+  }
+
+  @Test public void nonListenableFutureReturnsNull() {
+    CallAdapter<?, ?> adapter = factory.get(String.class, NO_ANNOTATIONS, retrofit);
+    assertThat(adapter).isNull();
+  }
+
+  @Test public void rawTypeThrows() {
+    Type observableType = new TypeToken<ListenableFuture>() {}.getType();
+    try {
+      factory.get(observableType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "ListenableFuture return type must be parameterized as ListenableFuture<Foo> or ListenableFuture<? extends Foo>");
+    }
+  }
+
+  @Test public void rawResponseTypeThrows() {
+    Type observableType = new TypeToken<ListenableFuture<Response>>() {}.getType();
+    try {
+      factory.get(observableType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Response must be parameterized as Response<Foo> or Response<? extends Foo>");
+    }
+  }
+}
diff --git a/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/ListenableFutureTest.java b/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/ListenableFutureTest.java
new file mode 100644
index 000000000..f3ceeca62
--- /dev/null
+++ b/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/ListenableFutureTest.java
@@ -0,0 +1,116 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.guava;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import java.io.IOException;
+import java.util.concurrent.ExecutionException;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class ListenableFutureTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  interface Service {
+    @GET("/") ListenableFuture<String> body();
+    @GET("/") ListenableFuture<Response<String>> response();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(GuavaCallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodySuccess200() throws Exception {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    ListenableFuture<String> future = service.body();
+    assertThat(future.get()).isEqualTo("Hi");
+  }
+
+  @Test public void bodySuccess404() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    ListenableFuture<String> future = service.body();
+    try {
+      future.get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause())
+          .isInstanceOf(HttpException.class) // Required for backwards compatibility.
+          .isInstanceOf(retrofit2.HttpException.class)
+          .hasMessage("HTTP 404 Client Error");
+    }
+  }
+
+  @Test public void bodyFailure() throws Exception {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    ListenableFuture<String> future = service.body();
+    try {
+      future.get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).isInstanceOf(IOException.class);
+    }
+  }
+
+  @Test public void responseSuccess200() throws Exception {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    ListenableFuture<Response<String>> future = service.response();
+    Response<String> response = future.get();
+    assertThat(response.isSuccessful()).isTrue();
+    assertThat(response.body()).isEqualTo("Hi");
+  }
+
+  @Test public void responseSuccess404() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
+
+    ListenableFuture<Response<String>> future = service.response();
+    Response<String> response = future.get();
+    assertThat(response.isSuccessful()).isFalse();
+    assertThat(response.errorBody().string()).isEqualTo("Hi");
+  }
+
+  @Test public void responseFailure() throws Exception {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    ListenableFuture<Response<String>> future = service.response();
+    try {
+      future.get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).isInstanceOf(IOException.class);
+    }
+  }
+}
diff --git a/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/StringConverterFactory.java b/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/StringConverterFactory.java
new file mode 100644
index 000000000..bb9ccf189
--- /dev/null
+++ b/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/StringConverterFactory.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.guava;
+
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import okhttp3.MediaType;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
+
+final class StringConverterFactory extends Converter.Factory {
+  @Override
+  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
+    return new Converter<ResponseBody, String>() {
+      @Override public String convert(ResponseBody value) throws IOException {
+        return value.string();
+      }
+    };
+  }
+
+  @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
+      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+    return new Converter<String, RequestBody>() {
+      @Override public RequestBody convert(String value) throws IOException {
+        return RequestBody.create(MediaType.parse("text/plain"), value);
+      }
+    };
+  }
+}
diff --git a/retrofit-adapters/java8/README.md b/retrofit-adapters/java8/README.md
new file mode 100644
index 000000000..83424c809
--- /dev/null
+++ b/retrofit-adapters/java8/README.md
@@ -0,0 +1,50 @@
+Java8 Adapter
+==============
+
+An `Adapter` for adapting [Java8][1] `CompletableFuture`.
+
+
+Usage
+-----
+
+Add `Java8CallAdapterFactory` as a `Call` adapter when building your `Retrofit` instance:
+```java
+Retrofit retrofit = new Retrofit.Builder()
+    .baseUrl("https://example.com/")
+    .addCallAdapterFactory(Java8CallAdapterFactory.create())
+    .build();
+```
+
+Your service methods can now use `CompletableFuture` as their return type.
+```java
+interface MyService {
+  @GET("/user")
+  CompletableFuture<User> getUser();
+}
+```
+
+
+Download
+--------
+
+Download [the latest JAR][2] or grab via [Maven][3]:
+```xml
+<dependency>
+  <groupId>com.squareup.retrofit2</groupId>
+  <artifactId>adapter-java8</artifactId>
+  <version>latest.version</version>
+</dependency>
+```
+or [Gradle][3]:
+```groovy
+compile 'com.squareup.retrofit2:adapter-java8:latest.version'
+```
+
+Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
+
+
+
+ [1]: http://www.oracle.com/technetwork/java/javase/jdk-8-readme-2095712.html
+ [2]: https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=adapter-java8&v=LATEST
+ [3]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup.retrofit2%22%20a%3A%22adapter-java8%22
+ [snap]: https://oss.sonatype.org/content/repositories/snapshots/
diff --git a/retrofit-adapters/java8/pom.xml b/retrofit-adapters/java8/pom.xml
new file mode 100644
index 000000000..675e96839
--- /dev/null
+++ b/retrofit-adapters/java8/pom.xml
@@ -0,0 +1,81 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.retrofit2</groupId>
+    <artifactId>retrofit-adapters</artifactId>
+    <version>2.4.1-SNAPSHOT</version>
+    <relativePath>../pom.xml</relativePath>
+  </parent>
+
+  <artifactId>adapter-java8</artifactId>
+  <name>Adapter: Java 8</name>
+
+  <properties>
+    <java.version>1.8</java.version>
+  </properties>
+
+  <dependencies>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>retrofit</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.assertj</groupId>
+      <artifactId>assertj-core</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp3</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.codehaus.mojo</groupId>
+        <artifactId>animal-sniffer-maven-plugin</artifactId>
+        <version>${animal.sniffer.version}</version>
+        <configuration>
+          <signature>
+            <groupId>org.kaazing.mojo.signature</groupId>
+            <artifactId>java18</artifactId>
+            <version>1.0</version>
+          </signature>
+        </configuration>
+      </plugin>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-jar-plugin</artifactId>
+        <configuration>
+          <archive>
+            <manifestEntries>
+              <Automatic-Module-Name>retrofit2.adapter.java8</Automatic-Module-Name>
+            </manifestEntries>
+          </archive>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
diff --git a/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/HttpException.java b/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/HttpException.java
new file mode 100644
index 000000000..c2d29cbbb
--- /dev/null
+++ b/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/HttpException.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.java8;
+
+import retrofit2.Response;
+
+/** @deprecated Use {@link retrofit2.HttpException}. */
+@Deprecated
+public final class HttpException extends retrofit2.HttpException {
+  public HttpException(Response<?> response) {
+    super(response);
+  }
+}
diff --git a/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/Java8CallAdapterFactory.java b/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/Java8CallAdapterFactory.java
new file mode 100644
index 000000000..35b79f1a3
--- /dev/null
+++ b/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/Java8CallAdapterFactory.java
@@ -0,0 +1,157 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.java8;
+
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.util.concurrent.CompletableFuture;
+import retrofit2.Call;
+import retrofit2.CallAdapter;
+import retrofit2.Callback;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+
+/**
+ * A {@linkplain CallAdapter.Factory call adapter} which creates Java 8 futures.
+ * <p>
+ * Adding this class to {@link Retrofit} allows you to return {@link CompletableFuture} from
+ * service methods.
+ * <pre><code>
+ * interface MyService {
+ *   &#64;GET("user/me")
+ *   CompletableFuture&lt;User&gt; getUser()
+ * }
+ * </code></pre>
+ * There are two configurations supported for the {@code CompletableFuture} type parameter:
+ * <ul>
+ * <li>Direct body (e.g., {@code CompletableFuture<User>}) returns the deserialized body for 2XX
+ * responses, sets {@link retrofit2.HttpException HttpException} errors for non-2XX responses, and
+ * sets {@link IOException} for network errors.</li>
+ * <li>Response wrapped body (e.g., {@code CompletableFuture<Response<User>>}) returns a
+ * {@link Response} object for all HTTP responses and sets {@link IOException} for network
+ * errors</li>
+ * </ul>
+ */
+public final class Java8CallAdapterFactory extends CallAdapter.Factory {
+  public static Java8CallAdapterFactory create() {
+    return new Java8CallAdapterFactory();
+  }
+
+  private Java8CallAdapterFactory() {
+  }
+
+  @Override
+  public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+    if (getRawType(returnType) != CompletableFuture.class) {
+      return null;
+    }
+    if (!(returnType instanceof ParameterizedType)) {
+      throw new IllegalStateException("CompletableFuture return type must be parameterized"
+          + " as CompletableFuture<Foo> or CompletableFuture<? extends Foo>");
+    }
+    Type innerType = getParameterUpperBound(0, (ParameterizedType) returnType);
+
+    if (getRawType(innerType) != Response.class) {
+      // Generic type is not Response<T>. Use it for body-only adapter.
+      return new BodyCallAdapter<>(innerType);
+    }
+
+    // Generic type is Response<T>. Extract T and create the Response version of the adapter.
+    if (!(innerType instanceof ParameterizedType)) {
+      throw new IllegalStateException("Response must be parameterized"
+          + " as Response<Foo> or Response<? extends Foo>");
+    }
+    Type responseType = getParameterUpperBound(0, (ParameterizedType) innerType);
+    return new ResponseCallAdapter<>(responseType);
+  }
+
+  private static final class BodyCallAdapter<R> implements CallAdapter<R, CompletableFuture<R>> {
+    private final Type responseType;
+
+    BodyCallAdapter(Type responseType) {
+      this.responseType = responseType;
+    }
+
+    @Override public Type responseType() {
+      return responseType;
+    }
+
+    @Override public CompletableFuture<R> adapt(final Call<R> call) {
+      final CompletableFuture<R> future = new CompletableFuture<R>() {
+        @Override public boolean cancel(boolean mayInterruptIfRunning) {
+          if (mayInterruptIfRunning) {
+            call.cancel();
+          }
+          return super.cancel(mayInterruptIfRunning);
+        }
+      };
+
+      call.enqueue(new Callback<R>() {
+        @Override public void onResponse(Call<R> call, Response<R> response) {
+          if (response.isSuccessful()) {
+            future.complete(response.body());
+          } else {
+            future.completeExceptionally(new HttpException(response));
+          }
+        }
+
+        @Override public void onFailure(Call<R> call, Throwable t) {
+          future.completeExceptionally(t);
+        }
+      });
+
+      return future;
+    }
+  }
+
+  private static final class ResponseCallAdapter<R>
+      implements CallAdapter<R, CompletableFuture<Response<R>>> {
+    private final Type responseType;
+
+    ResponseCallAdapter(Type responseType) {
+      this.responseType = responseType;
+    }
+
+    @Override public Type responseType() {
+      return responseType;
+    }
+
+    @Override public CompletableFuture<Response<R>> adapt(final Call<R> call) {
+      final CompletableFuture<Response<R>> future = new CompletableFuture<Response<R>>() {
+        @Override public boolean cancel(boolean mayInterruptIfRunning) {
+          if (mayInterruptIfRunning) {
+            call.cancel();
+          }
+          return super.cancel(mayInterruptIfRunning);
+        }
+      };
+
+      call.enqueue(new Callback<R>() {
+        @Override public void onResponse(Call<R> call, Response<R> response) {
+          future.complete(response);
+        }
+
+        @Override public void onFailure(Call<R> call, Throwable t) {
+          future.completeExceptionally(t);
+        }
+      });
+
+      return future;
+    }
+  }
+}
diff --git a/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/package-info.java b/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/package-info.java
new file mode 100644
index 000000000..7e36b199e
--- /dev/null
+++ b/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/package-info.java
@@ -0,0 +1,4 @@
+@ParametersAreNonnullByDefault
+package retrofit2.adapter.java8;
+
+import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/CompletableFutureTest.java b/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/CompletableFutureTest.java
new file mode 100644
index 000000000..ee06a31eb
--- /dev/null
+++ b/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/CompletableFutureTest.java
@@ -0,0 +1,116 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.java8;
+
+import java.io.IOException;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ExecutionException;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class CompletableFutureTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  interface Service {
+    @GET("/") CompletableFuture<String> body();
+    @GET("/") CompletableFuture<Response<String>> response();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(Java8CallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodySuccess200() throws Exception {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    CompletableFuture<String> future = service.body();
+    assertThat(future.get()).isEqualTo("Hi");
+  }
+
+  @Test public void bodySuccess404() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    CompletableFuture<String> future = service.body();
+    try {
+      future.get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause())
+          .isInstanceOf(HttpException.class) // Required for backwards compatibility.
+          .isInstanceOf(retrofit2.HttpException.class)
+          .hasMessage("HTTP 404 Client Error");
+    }
+  }
+
+  @Test public void bodyFailure() throws Exception {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    CompletableFuture<String> future = service.body();
+    try {
+      future.get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).isInstanceOf(IOException.class);
+    }
+  }
+
+  @Test public void responseSuccess200() throws Exception {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    CompletableFuture<Response<String>> future = service.response();
+    Response<String> response = future.get();
+    assertThat(response.isSuccessful()).isTrue();
+    assertThat(response.body()).isEqualTo("Hi");
+  }
+
+  @Test public void responseSuccess404() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
+
+    CompletableFuture<Response<String>> future = service.response();
+    Response<String> response = future.get();
+    assertThat(response.isSuccessful()).isFalse();
+    assertThat(response.errorBody().string()).isEqualTo("Hi");
+  }
+
+  @Test public void responseFailure() throws Exception {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    CompletableFuture<Response<String>> future = service.response();
+    try {
+      future.get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).isInstanceOf(IOException.class);
+    }
+  }
+}
diff --git a/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/Java8CallAdapterFactoryTest.java b/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/Java8CallAdapterFactoryTest.java
new file mode 100644
index 000000000..283268881
--- /dev/null
+++ b/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/Java8CallAdapterFactoryTest.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.java8;
+
+import com.google.common.reflect.TypeToken;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import java.util.List;
+import java.util.concurrent.CompletableFuture;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.CallAdapter;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class Java8CallAdapterFactoryTest {
+  private static final Annotation[] NO_ANNOTATIONS = new Annotation[0];
+
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private final CallAdapter.Factory factory = Java8CallAdapterFactory.create();
+  private Retrofit retrofit;
+
+  @Before public void setUp() {
+    retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(factory)
+        .build();
+  }
+
+  @Test public void responseType() {
+    Type bodyClass = new TypeToken<CompletableFuture<String>>() {}.getType();
+    assertThat(factory.get(bodyClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type bodyWildcard = new TypeToken<CompletableFuture<? extends String>>() {}.getType();
+    assertThat(factory.get(bodyWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type bodyGeneric = new TypeToken<CompletableFuture<List<String>>>() {}.getType();
+    assertThat(factory.get(bodyGeneric, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(new TypeToken<List<String>>() {}.getType());
+    Type responseClass = new TypeToken<CompletableFuture<Response<String>>>() {}.getType();
+    assertThat(factory.get(responseClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type responseWildcard = new TypeToken<CompletableFuture<Response<? extends String>>>() {}.getType();
+    assertThat(factory.get(responseWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type resultClass = new TypeToken<CompletableFuture<Response<String>>>() {}.getType();
+    assertThat(factory.get(resultClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type resultWildcard = new TypeToken<CompletableFuture<Response<? extends String>>>() {}.getType();
+    assertThat(factory.get(resultWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+  }
+
+  @Test public void nonListenableFutureReturnsNull() {
+    CallAdapter<?, ?> adapter = factory.get(String.class, NO_ANNOTATIONS, retrofit);
+    assertThat(adapter).isNull();
+  }
+
+  @Test public void rawTypeThrows() {
+    Type observableType = new TypeToken<CompletableFuture>() {}.getType();
+    try {
+      factory.get(observableType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "CompletableFuture return type must be parameterized as CompletableFuture<Foo> or CompletableFuture<? extends Foo>");
+    }
+  }
+
+  @Test public void rawResponseTypeThrows() {
+    Type observableType = new TypeToken<CompletableFuture<Response>>() {}.getType();
+    try {
+      factory.get(observableType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Response must be parameterized as Response<Foo> or Response<? extends Foo>");
+    }
+  }
+}
diff --git a/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/StringConverterFactory.java b/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/StringConverterFactory.java
new file mode 100644
index 000000000..de4b63e61
--- /dev/null
+++ b/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/StringConverterFactory.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.java8;
+
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import okhttp3.MediaType;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
+
+final class StringConverterFactory extends Converter.Factory {
+  @Override
+  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
+    return new Converter<ResponseBody, String>() {
+      @Override public String convert(ResponseBody value) throws IOException {
+        return value.string();
+      }
+    };
+  }
+
+  @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
+      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+    return new Converter<String, RequestBody>() {
+      @Override public RequestBody convert(String value) throws IOException {
+        return RequestBody.create(MediaType.parse("text/plain"), value);
+      }
+    };
+  }
+}
diff --git a/retrofit-adapters/pom.xml b/retrofit-adapters/pom.xml
index 8a677d359..45ae63173 100644
--- a/retrofit-adapters/pom.xml
+++ b/retrofit-adapters/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>parent</artifactId>
-    <version>2.0.0-SNAPSHOT</version>
+    <version>2.4.1-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -15,6 +15,10 @@
   <packaging>pom</packaging>
 
   <modules>
+    <module>guava</module>
+    <module>java8</module>
     <module>rxjava</module>
+    <module>rxjava2</module>
+    <module>scala</module>
   </modules>
 </project>
diff --git a/retrofit-adapters/rxjava/README.md b/retrofit-adapters/rxjava/README.md
new file mode 100644
index 000000000..3352daf8f
--- /dev/null
+++ b/retrofit-adapters/rxjava/README.md
@@ -0,0 +1,63 @@
+RxJava Adapter
+==============
+
+An `Adapter` for adapting [RxJava 1.x][1] types.
+
+Available types:
+
+ * `Observable<T>`, `Observable<Response<T>>`, and `Observable<Result<T>>` where `T` is the body type.
+ * `Single<T>`, `Single<Response<T>>`, and `Single<Result<T>>`  where `T` is the body type.
+ * `Completable` where response bodies are discarded.
+
+
+Usage
+-----
+
+Add `RxJavaCallAdapterFactory` as a `Call` adapter when building your `Retrofit` instance:
+```java
+Retrofit retrofit = new Retrofit.Builder()
+    .baseUrl("https://example.com/")
+    .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
+    .build();
+```
+
+Your service methods can now use any of the above types as their return type.
+```java
+interface MyService {
+  @GET("/user")
+  Observable<User> getUser();
+}
+```
+
+By default all reactive types execute their requests synchronously. There are multiple ways to
+control the threading on which a request occurs:
+
+ * Call `subscribeOn` on the returned reactive type with a `Scheduler` of your choice.
+ * Use `createAsync()` when creating the factory which will use OkHttp's internal thread pool.
+ * Use `createWithScheduler(Scheduler)` to supply a default subscription `Scheduler`.
+
+
+Download
+--------
+
+Download [the latest JAR][2] or grab via [Maven][3]:
+```xml
+<dependency>
+  <groupId>com.squareup.retrofit2</groupId>
+  <artifactId>adapter-rxjava</artifactId>
+  <version>latest.version</version>
+</dependency>
+```
+or [Gradle][3]:
+```groovy
+compile 'com.squareup.retrofit2:adapter-rxjava:latest.version'
+```
+
+Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
+
+
+
+ [1]: https://github.com/ReactiveX/RxJava/tree/1.x
+ [2]: https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=adapter-rxjava&v=LATEST
+ [3]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup.retrofit2%22%20a%3A%22adapter-rxjava%22
+ [snap]: https://oss.sonatype.org/content/repositories/snapshots/
diff --git a/retrofit-adapters/rxjava/pom.xml b/retrofit-adapters/rxjava/pom.xml
index bb9e273e2..97d45857e 100644
--- a/retrofit-adapters/rxjava/pom.xml
+++ b/retrofit-adapters/rxjava/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-adapters</artifactId>
-    <version>2.0.0-SNAPSHOT</version>
+    <version>2.4.1-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -23,6 +23,11 @@
       <groupId>io.reactivex</groupId>
       <artifactId>rxjava</artifactId>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
@@ -40,9 +45,25 @@
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>com.squareup.okhttp3</groupId>
       <artifactId>mockwebserver</artifactId>
       <scope>test</scope>
     </dependency>
   </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-jar-plugin</artifactId>
+        <configuration>
+          <archive>
+            <manifestEntries>
+              <Automatic-Module-Name>retrofit2.adapter.rxjava</Automatic-Module-Name>
+            </manifestEntries>
+          </archive>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
 </project>
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/HttpException.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/HttpException.java
deleted file mode 100644
index d8d199766..000000000
--- a/retrofit-adapters/rxjava/src/main/java/retrofit2/HttpException.java
+++ /dev/null
@@ -1,32 +0,0 @@
-package retrofit2;
-
-/** Exception for an unexpected, non-2xx HTTP response. */
-public final class HttpException extends Exception {
-  private final int code;
-  private final String message;
-  private final transient Response<?> response;
-
-  public HttpException(Response<?> response) {
-    super("HTTP " + response.code() + " " + response.message());
-    this.code = response.code();
-    this.message = response.message();
-    this.response = response;
-  }
-
-  /** HTTP status code. */
-  public int code() {
-    return code;
-  }
-
-  /** HTTP status message. */
-  public String message() {
-    return message;
-  }
-
-  /**
-   * The full HTTP response. This may be null if the exception was serialized.
-   */
-  public Response<?> response() {
-    return response;
-  }
-}
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/RxJavaCallAdapterFactory.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/RxJavaCallAdapterFactory.java
deleted file mode 100644
index 0f2687cc3..000000000
--- a/retrofit-adapters/rxjava/src/main/java/retrofit2/RxJavaCallAdapterFactory.java
+++ /dev/null
@@ -1,190 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2;
-
-import java.lang.annotation.Annotation;
-import java.lang.reflect.ParameterizedType;
-import java.lang.reflect.Type;
-import rx.Observable;
-import rx.Subscriber;
-import rx.exceptions.Exceptions;
-import rx.functions.Action0;
-import rx.functions.Func1;
-import rx.subscriptions.Subscriptions;
-
-/**
- * TODO docs
- */
-public final class RxJavaCallAdapterFactory implements CallAdapter.Factory {
-  /**
-   * TODO
-   */
-  public static RxJavaCallAdapterFactory create() {
-    return new RxJavaCallAdapterFactory();
-  }
-
-  private RxJavaCallAdapterFactory() {
-  }
-
-  @Override
-  public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
-    Class<?> rawType = Utils.getRawType(returnType);
-    boolean isSingle = "rx.Single".equals(rawType.getCanonicalName());
-    if (rawType != Observable.class && !isSingle) {
-      return null;
-    }
-    if (!(returnType instanceof ParameterizedType)) {
-      String name = isSingle ? "Single" : "Observable";
-      throw new IllegalStateException(name + " return type must be parameterized"
-          + " as " + name + "<Foo> or " + name + "<? extends Foo>");
-    }
-
-    CallAdapter<Observable<?>> callAdapter = getCallAdapter(returnType);
-    if (isSingle) {
-      // Add Single-converter wrapper from a separate class. This defers classloading such that
-      // regular Observable operation can be leveraged without relying on this unstable RxJava API.
-      return SingleHelper.makeSingle(callAdapter);
-    }
-    return callAdapter;
-  }
-
-  private CallAdapter<Observable<?>> getCallAdapter(Type returnType) {
-    Type observableType = Utils.getParameterUpperBound(0, (ParameterizedType) returnType);
-    Class<?> rawObservableType = Utils.getRawType(observableType);
-    if (rawObservableType == Response.class) {
-      if (!(observableType instanceof ParameterizedType)) {
-        throw new IllegalStateException("Response must be parameterized"
-            + " as Response<Foo> or Response<? extends Foo>");
-      }
-      Type responseType = Utils.getParameterUpperBound(0, (ParameterizedType) observableType);
-      return new ResponseCallAdapter(responseType);
-    }
-
-    if (rawObservableType == Result.class) {
-      if (!(observableType instanceof ParameterizedType)) {
-        throw new IllegalStateException("Result must be parameterized"
-            + " as Result<Foo> or Result<? extends Foo>");
-      }
-      Type responseType = Utils.getParameterUpperBound(0, (ParameterizedType) observableType);
-      return new ResultCallAdapter(responseType);
-    }
-
-    return new SimpleCallAdapter(observableType);
-  }
-
-  static final class CallOnSubscribe<T> implements Observable.OnSubscribe<Response<T>> {
-    private final Call<T> originalCall;
-
-    CallOnSubscribe(Call<T> originalCall) {
-      this.originalCall = originalCall;
-    }
-
-    @Override public void call(final Subscriber<? super Response<T>> subscriber) {
-      // Since Call is a one-shot type, clone it for each new subscriber.
-      final Call<T> call = originalCall.clone();
-
-      // Attempt to cancel the call if it is still in-flight on unsubscription.
-      subscriber.add(Subscriptions.create(new Action0() {
-        @Override public void call() {
-          call.cancel();
-        }
-      }));
-
-      try {
-        Response<T> response = call.execute();
-        if (!subscriber.isUnsubscribed()) {
-          subscriber.onNext(response);
-        }
-      } catch (Throwable t) {
-        Exceptions.throwIfFatal(t);
-        if (!subscriber.isUnsubscribed()) {
-          subscriber.onError(t);
-        }
-        return;
-      }
-
-      if (!subscriber.isUnsubscribed()) {
-        subscriber.onCompleted();
-      }
-    }
-  }
-
-  static final class ResponseCallAdapter implements CallAdapter<Observable<?>> {
-    private final Type responseType;
-
-    ResponseCallAdapter(Type responseType) {
-      this.responseType = responseType;
-    }
-
-    @Override public Type responseType() {
-      return responseType;
-    }
-
-    @Override public <R> Observable<Response<R>> adapt(Call<R> call) {
-      return Observable.create(new CallOnSubscribe<>(call));
-    }
-  }
-
-  static final class SimpleCallAdapter implements CallAdapter<Observable<?>> {
-    private final Type responseType;
-
-    SimpleCallAdapter(Type responseType) {
-      this.responseType = responseType;
-    }
-
-    @Override public Type responseType() {
-      return responseType;
-    }
-
-    @Override public <R> Observable<R> adapt(Call<R> call) {
-      return Observable.create(new CallOnSubscribe<>(call)) //
-          .flatMap(new Func1<Response<R>, Observable<R>>() {
-            @Override public Observable<R> call(Response<R> response) {
-              if (response.isSuccess()) {
-                return Observable.just(response.body());
-              }
-              return Observable.error(new HttpException(response));
-            }
-          });
-    }
-  }
-
-  static final class ResultCallAdapter implements CallAdapter<Observable<?>> {
-    private final Type responseType;
-
-    ResultCallAdapter(Type responseType) {
-      this.responseType = responseType;
-    }
-
-    @Override public Type responseType() {
-      return responseType;
-    }
-
-    @Override public <R> Observable<Result<R>> adapt(Call<R> call) {
-      return Observable.create(new CallOnSubscribe<>(call)) //
-          .map(new Func1<Response<R>, Result<R>>() {
-            @Override public Result<R> call(Response<R> response) {
-              return Result.response(response);
-            }
-          })
-          .onErrorReturn(new Func1<Throwable, Result<R>>() {
-            @Override public Result<R> call(Throwable throwable) {
-              return Result.error(throwable);
-            }
-          });
-    }
-  }
-}
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/BodyOnSubscribe.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/BodyOnSubscribe.java
new file mode 100644
index 000000000..d91105734
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/BodyOnSubscribe.java
@@ -0,0 +1,88 @@
+/*
+ * Copyright (C) 2016 Jake Wharton
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import retrofit2.Response;
+import rx.Observable.OnSubscribe;
+import rx.Subscriber;
+import rx.exceptions.CompositeException;
+import rx.exceptions.Exceptions;
+import rx.exceptions.OnCompletedFailedException;
+import rx.exceptions.OnErrorFailedException;
+import rx.exceptions.OnErrorNotImplementedException;
+import rx.plugins.RxJavaPlugins;
+
+final class BodyOnSubscribe<T> implements OnSubscribe<T> {
+  private final OnSubscribe<Response<T>> upstream;
+
+  BodyOnSubscribe(OnSubscribe<Response<T>> upstream) {
+    this.upstream = upstream;
+  }
+
+  @Override public void call(Subscriber<? super T> subscriber) {
+    upstream.call(new BodySubscriber<T>(subscriber));
+  }
+
+  private static class BodySubscriber<R> extends Subscriber<Response<R>> {
+    private final Subscriber<? super R> subscriber;
+    /** Indicates whether a terminal event has been sent to {@link #subscriber}. */
+    private boolean subscriberTerminated;
+
+    BodySubscriber(Subscriber<? super R> subscriber) {
+      super(subscriber);
+      this.subscriber = subscriber;
+    }
+
+    @Override public void onNext(Response<R> response) {
+      if (response.isSuccessful()) {
+        subscriber.onNext(response.body());
+      } else {
+        subscriberTerminated = true;
+        Throwable t = new HttpException(response);
+        try {
+          subscriber.onError(t);
+        } catch (OnCompletedFailedException
+            | OnErrorFailedException
+            | OnErrorNotImplementedException e) {
+          RxJavaPlugins.getInstance().getErrorHandler().handleError(e);
+        } catch (Throwable inner) {
+          Exceptions.throwIfFatal(inner);
+          CompositeException composite = new CompositeException(t, inner);
+          RxJavaPlugins.getInstance().getErrorHandler().handleError(composite);
+        }
+      }
+    }
+
+    @Override public void onError(Throwable throwable) {
+      if (!subscriberTerminated) {
+        subscriber.onError(throwable);
+      } else {
+        // This should never happen! onNext handles and forwards errors automatically.
+        Throwable broken = new AssertionError(
+            "This should never happen! Report as a Retrofit bug with the full stacktrace.");
+        //noinspection UnnecessaryInitCause Two-arg AssertionError constructor is 1.7+ only.
+        broken.initCause(throwable);
+        RxJavaPlugins.getInstance().getErrorHandler().handleError(broken);
+      }
+    }
+
+    @Override public void onCompleted() {
+      if (!subscriberTerminated) {
+        subscriber.onCompleted();
+      }
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/CallArbiter.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/CallArbiter.java
new file mode 100644
index 000000000..430ec2c36
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/CallArbiter.java
@@ -0,0 +1,173 @@
+/*
+ * Copyright (C) 2016 Jake Wharton
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import java.util.concurrent.atomic.AtomicInteger;
+import retrofit2.Call;
+import retrofit2.Response;
+import rx.Producer;
+import rx.Subscriber;
+import rx.Subscription;
+import rx.exceptions.CompositeException;
+import rx.exceptions.Exceptions;
+import rx.exceptions.OnCompletedFailedException;
+import rx.exceptions.OnErrorFailedException;
+import rx.exceptions.OnErrorNotImplementedException;
+import rx.plugins.RxJavaPlugins;
+
+final class CallArbiter<T> extends AtomicInteger implements Subscription, Producer {
+  private static final int STATE_WAITING = 0;
+  private static final int STATE_REQUESTED = 1;
+  private static final int STATE_HAS_RESPONSE = 2;
+  private static final int STATE_TERMINATED = 3;
+
+  private final Call<T> call;
+  private final Subscriber<? super Response<T>> subscriber;
+
+  private volatile boolean unsubscribed;
+  private volatile Response<T> response;
+
+  CallArbiter(Call<T> call, Subscriber<? super Response<T>> subscriber) {
+    super(STATE_WAITING);
+
+    this.call = call;
+    this.subscriber = subscriber;
+  }
+
+  @Override public void unsubscribe() {
+    unsubscribed = true;
+    call.cancel();
+  }
+
+  @Override public boolean isUnsubscribed() {
+    return unsubscribed;
+  }
+
+  @Override public void request(long amount) {
+    if (amount == 0) {
+      return;
+    }
+    while (true) {
+      int state = get();
+      switch (state) {
+        case STATE_WAITING:
+          if (compareAndSet(STATE_WAITING, STATE_REQUESTED)) {
+            return;
+          }
+          break; // State transition failed. Try again.
+
+        case STATE_HAS_RESPONSE:
+          if (compareAndSet(STATE_HAS_RESPONSE, STATE_TERMINATED)) {
+            deliverResponse(response);
+            return;
+          }
+          break; // State transition failed. Try again.
+
+        case STATE_REQUESTED:
+        case STATE_TERMINATED:
+          return; // Nothing to do.
+
+        default:
+          throw new IllegalStateException("Unknown state: " + state);
+      }
+    }
+  }
+
+  void emitResponse(Response<T> response) {
+    while (true) {
+      int state = get();
+      switch (state) {
+        case STATE_WAITING:
+          this.response = response;
+          if (compareAndSet(STATE_WAITING, STATE_HAS_RESPONSE)) {
+            return;
+          }
+          break; // State transition failed. Try again.
+
+        case STATE_REQUESTED:
+          if (compareAndSet(STATE_REQUESTED, STATE_TERMINATED)) {
+            deliverResponse(response);
+            return;
+          }
+          break; // State transition failed. Try again.
+
+        case STATE_HAS_RESPONSE:
+        case STATE_TERMINATED:
+          throw new AssertionError();
+
+        default:
+          throw new IllegalStateException("Unknown state: " + state);
+      }
+    }
+  }
+
+  private void deliverResponse(Response<T> response) {
+    try {
+      if (!isUnsubscribed()) {
+        subscriber.onNext(response);
+      }
+    } catch (OnCompletedFailedException
+        | OnErrorFailedException
+        | OnErrorNotImplementedException e) {
+      RxJavaPlugins.getInstance().getErrorHandler().handleError(e);
+      return;
+    } catch (Throwable t) {
+      Exceptions.throwIfFatal(t);
+      try {
+        subscriber.onError(t);
+      } catch (OnCompletedFailedException
+          | OnErrorFailedException
+          | OnErrorNotImplementedException e) {
+        RxJavaPlugins.getInstance().getErrorHandler().handleError(e);
+      } catch (Throwable inner) {
+        Exceptions.throwIfFatal(inner);
+        CompositeException composite = new CompositeException(t, inner);
+        RxJavaPlugins.getInstance().getErrorHandler().handleError(composite);
+      }
+      return;
+    }
+    try {
+      if (!isUnsubscribed()) {
+        subscriber.onCompleted();
+      }
+    } catch (OnCompletedFailedException
+        | OnErrorFailedException
+        | OnErrorNotImplementedException e) {
+      RxJavaPlugins.getInstance().getErrorHandler().handleError(e);
+    } catch (Throwable t) {
+      Exceptions.throwIfFatal(t);
+      RxJavaPlugins.getInstance().getErrorHandler().handleError(t);
+    }
+  }
+
+  void emitError(Throwable t) {
+    set(STATE_TERMINATED);
+
+    if (!isUnsubscribed()) {
+      try {
+        subscriber.onError(t);
+      } catch (OnCompletedFailedException
+          | OnErrorFailedException
+          | OnErrorNotImplementedException e) {
+        RxJavaPlugins.getInstance().getErrorHandler().handleError(e);
+      } catch (Throwable inner) {
+        Exceptions.throwIfFatal(inner);
+        CompositeException composite = new CompositeException(t, inner);
+        RxJavaPlugins.getInstance().getErrorHandler().handleError(composite);
+      }
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/CallEnqueueOnSubscribe.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/CallEnqueueOnSubscribe.java
new file mode 100644
index 000000000..7dcf917c3
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/CallEnqueueOnSubscribe.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2016 Jake Wharton
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import retrofit2.Call;
+import retrofit2.Callback;
+import retrofit2.Response;
+import rx.Observable.OnSubscribe;
+import rx.Subscriber;
+import rx.exceptions.Exceptions;
+
+final class CallEnqueueOnSubscribe<T> implements OnSubscribe<Response<T>> {
+  private final Call<T> originalCall;
+
+  CallEnqueueOnSubscribe(Call<T> originalCall) {
+    this.originalCall = originalCall;
+  }
+
+  @Override public void call(Subscriber<? super Response<T>> subscriber) {
+    // Since Call is a one-shot type, clone it for each new subscriber.
+    Call<T> call = originalCall.clone();
+    final CallArbiter<T> arbiter = new CallArbiter<>(call, subscriber);
+    subscriber.add(arbiter);
+    subscriber.setProducer(arbiter);
+
+    call.enqueue(new Callback<T>() {
+      @Override public void onResponse(Call<T> call, Response<T> response) {
+        arbiter.emitResponse(response);
+      }
+
+      @Override public void onFailure(Call<T> call, Throwable t) {
+        Exceptions.throwIfFatal(t);
+        arbiter.emitError(t);
+      }
+    });
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/CallExecuteOnSubscribe.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/CallExecuteOnSubscribe.java
new file mode 100644
index 000000000..593770aa7
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/CallExecuteOnSubscribe.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2016 Jake Wharton
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import retrofit2.Call;
+import retrofit2.Response;
+import rx.Observable.OnSubscribe;
+import rx.Subscriber;
+import rx.exceptions.Exceptions;
+
+final class CallExecuteOnSubscribe<T> implements OnSubscribe<Response<T>> {
+  private final Call<T> originalCall;
+
+  CallExecuteOnSubscribe(Call<T> originalCall) {
+    this.originalCall = originalCall;
+  }
+
+  @Override public void call(Subscriber<? super Response<T>> subscriber) {
+    // Since Call is a one-shot type, clone it for each new subscriber.
+    Call<T> call = originalCall.clone();
+    CallArbiter<T> arbiter = new CallArbiter<>(call, subscriber);
+    subscriber.add(arbiter);
+    subscriber.setProducer(arbiter);
+
+    Response<T> response;
+    try {
+      response = call.execute();
+    } catch (Throwable t) {
+      Exceptions.throwIfFatal(t);
+      arbiter.emitError(t);
+      return;
+    }
+    arbiter.emitResponse(response);
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/HttpException.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/HttpException.java
new file mode 100644
index 000000000..c81ad938e
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/HttpException.java
@@ -0,0 +1,11 @@
+package retrofit2.adapter.rxjava;
+
+import retrofit2.Response;
+
+/** @deprecated Use {@link retrofit2.HttpException}. */
+@Deprecated
+public final class HttpException extends retrofit2.HttpException {
+  public HttpException(Response<?> response) {
+    super(response);
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/Result.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/Result.java
new file mode 100644
index 000000000..29af1ff44
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/Result.java
@@ -0,0 +1,75 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import java.io.IOException;
+import javax.annotation.Nullable;
+import retrofit2.Response;
+
+/** The result of executing an HTTP request. */
+public final class Result<T> {
+  @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
+  public static <T> Result<T> error(Throwable error) {
+    if (error == null) throw new NullPointerException("error == null");
+    return new Result<>(null, error);
+  }
+
+  @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
+  public static <T> Result<T> response(Response<T> response) {
+    if (response == null) throw new NullPointerException("response == null");
+    return new Result<>(response, null);
+  }
+
+  private final @Nullable Response<T> response;
+  private final @Nullable Throwable error;
+
+  private Result(@Nullable Response<T> response, @Nullable Throwable error) {
+    this.response = response;
+    this.error = error;
+  }
+
+  /**
+   * The response received from executing an HTTP request. Only present when {@link #isError()} is
+   * false, null otherwise.
+   */
+  public @Nullable Response<T> response() {
+    return response;
+  }
+
+  /**
+   * The error experienced while attempting to execute an HTTP request. Only present when {@link
+   * #isError()} is true, null otherwise.
+   * <p>
+   * If the error is an {@link IOException} then there was a problem with the transport to the
+   * remote server. Any other exception type indicates an unexpected failure and should be
+   * considered fatal (configuration error, programming error, etc.).
+   */
+  public @Nullable Throwable error() {
+    return error;
+  }
+
+  /** {@code true} if the request resulted in an error. See {@link #error()} for the cause. */
+  public boolean isError() {
+    return error != null;
+  }
+
+  @Override public String toString() {
+    if (error != null) {
+      return "Result{isError=true, error=\"" + error + "\"}";
+    }
+    return "Result{isError=false, response=" + response + '}';
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/ResultOnSubscribe.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/ResultOnSubscribe.java
new file mode 100644
index 000000000..4ac19c4fe
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/ResultOnSubscribe.java
@@ -0,0 +1,75 @@
+/*
+ * Copyright (C) 2016 Jake Wharton
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import retrofit2.Response;
+import rx.Observable.OnSubscribe;
+import rx.Subscriber;
+import rx.exceptions.CompositeException;
+import rx.exceptions.Exceptions;
+import rx.exceptions.OnCompletedFailedException;
+import rx.exceptions.OnErrorFailedException;
+import rx.exceptions.OnErrorNotImplementedException;
+import rx.plugins.RxJavaPlugins;
+
+final class ResultOnSubscribe<T> implements OnSubscribe<Result<T>> {
+  private final OnSubscribe<Response<T>> upstream;
+
+  ResultOnSubscribe(OnSubscribe<Response<T>> upstream) {
+    this.upstream = upstream;
+  }
+
+  @Override public void call(Subscriber<? super Result<T>> subscriber) {
+    upstream.call(new ResultSubscriber<T>(subscriber));
+  }
+
+  private static class ResultSubscriber<R> extends Subscriber<Response<R>> {
+    private final Subscriber<? super Result<R>> subscriber;
+
+    ResultSubscriber(Subscriber<? super Result<R>> subscriber) {
+      super(subscriber);
+      this.subscriber = subscriber;
+    }
+
+    @Override public void onNext(Response<R> response) {
+      subscriber.onNext(Result.response(response));
+    }
+
+    @Override public void onError(Throwable throwable) {
+      try {
+        subscriber.onNext(Result.<R>error(throwable));
+      } catch (Throwable t) {
+        try {
+          subscriber.onError(t);
+        } catch (OnCompletedFailedException
+            | OnErrorFailedException
+            | OnErrorNotImplementedException e) {
+          RxJavaPlugins.getInstance().getErrorHandler().handleError(e);
+        } catch (Throwable inner) {
+          Exceptions.throwIfFatal(inner);
+          CompositeException composite = new CompositeException(t, inner);
+          RxJavaPlugins.getInstance().getErrorHandler().handleError(composite);
+        }
+        return;
+      }
+      subscriber.onCompleted();
+    }
+
+    @Override public void onCompleted() {
+      subscriber.onCompleted();
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapter.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapter.java
new file mode 100644
index 000000000..cb75bdc2b
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapter.java
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 2016 Jake Wharton
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import java.lang.reflect.Type;
+import javax.annotation.Nullable;
+import retrofit2.Call;
+import retrofit2.CallAdapter;
+import retrofit2.Response;
+import rx.Observable;
+import rx.Observable.OnSubscribe;
+import rx.Scheduler;
+
+final class RxJavaCallAdapter<R> implements CallAdapter<R, Object> {
+  private final Type responseType;
+  private final @Nullable Scheduler scheduler;
+  private final boolean isAsync;
+  private final boolean isResult;
+  private final boolean isBody;
+  private final boolean isSingle;
+  private final boolean isCompletable;
+
+  RxJavaCallAdapter(Type responseType, @Nullable Scheduler scheduler, boolean isAsync,
+      boolean isResult, boolean isBody, boolean isSingle, boolean isCompletable) {
+    this.responseType = responseType;
+    this.scheduler = scheduler;
+    this.isAsync = isAsync;
+    this.isResult = isResult;
+    this.isBody = isBody;
+    this.isSingle = isSingle;
+    this.isCompletable = isCompletable;
+  }
+
+  @Override public Type responseType() {
+    return responseType;
+  }
+
+  @Override public Object adapt(Call<R> call) {
+    OnSubscribe<Response<R>> callFunc = isAsync
+        ? new CallEnqueueOnSubscribe<>(call)
+        : new CallExecuteOnSubscribe<>(call);
+
+    OnSubscribe<?> func;
+    if (isResult) {
+      func = new ResultOnSubscribe<>(callFunc);
+    } else if (isBody) {
+      func = new BodyOnSubscribe<>(callFunc);
+    } else {
+      func = callFunc;
+    }
+    Observable<?> observable = Observable.create(func);
+
+    if (scheduler != null) {
+      observable = observable.subscribeOn(scheduler);
+    }
+
+    if (isSingle) {
+      return observable.toSingle();
+    }
+    if (isCompletable) {
+      return observable.toCompletable();
+    }
+    return observable;
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactory.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactory.java
new file mode 100644
index 000000000..51804b76f
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactory.java
@@ -0,0 +1,140 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import javax.annotation.Nullable;
+import retrofit2.CallAdapter;
+import retrofit2.HttpException;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import rx.Completable;
+import rx.Observable;
+import rx.Scheduler;
+import rx.Single;
+
+/**
+ * A {@linkplain CallAdapter.Factory call adapter} which uses RxJava for creating observables.
+ * <p>
+ * Adding this class to {@link Retrofit} allows you to return an {@link Observable}, {@link Single},
+ * or {@link Completable} from service methods.
+ * <pre><code>
+ * interface MyService {
+ *   &#64;GET("user/me")
+ *   Observable&lt;User&gt; getUser()
+ * }
+ * </code></pre>
+ * There are three configurations supported for the {@code Observable} or {@code Single} type
+ * parameter:
+ * <ul>
+ * <li>Direct body (e.g., {@code Observable<User>}) calls {@code onNext} with the deserialized body
+ * for 2XX responses and calls {@code onError} with {@link HttpException} for non-2XX responses and
+ * {@link IOException} for network errors.</li>
+ * <li>Response wrapped body (e.g., {@code Observable<Response<User>>}) calls {@code onNext}
+ * with a {@link Response} object for all HTTP responses and calls {@code onError} with
+ * {@link IOException} for network errors</li>
+ * <li>Result wrapped body (e.g., {@code Observable<Result<User>>}) calls {@code onNext} with a
+ * {@link Result} object for all HTTP responses and errors.</li>
+ * </ul>
+ * <p>
+ * <em>Note:</em> Support for {@link Single} and {@link Completable} is experimental and subject
+ * to backwards-incompatible changes at any time since both of these types are not considered
+ * stable by RxJava.
+ */
+public final class RxJavaCallAdapterFactory extends CallAdapter.Factory {
+  /**
+   * Returns an instance which creates synchronous observables that do not operate on any scheduler
+   * by default.
+   */
+  public static RxJavaCallAdapterFactory create() {
+    return new RxJavaCallAdapterFactory(null, false);
+  }
+
+  /**
+   * Returns an instance which creates asynchronous observables. Applying
+   * {@link Observable#subscribeOn} has no effect on stream types created by this factory.
+   */
+  public static RxJavaCallAdapterFactory createAsync() {
+    return new RxJavaCallAdapterFactory(null, true);
+  }
+
+  /**
+   * Returns an instance which creates synchronous observables that
+   * {@linkplain Observable#subscribeOn(Scheduler) subscribe on} {@code scheduler} by default.
+   */
+  @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
+  public static RxJavaCallAdapterFactory createWithScheduler(Scheduler scheduler) {
+    if (scheduler == null) throw new NullPointerException("scheduler == null");
+    return new RxJavaCallAdapterFactory(scheduler, false);
+  }
+
+  private final @Nullable Scheduler scheduler;
+  private final boolean isAsync;
+
+  private RxJavaCallAdapterFactory(@Nullable Scheduler scheduler, boolean isAsync) {
+    this.scheduler = scheduler;
+    this.isAsync = isAsync;
+  }
+
+  @Override
+  public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+    Class<?> rawType = getRawType(returnType);
+    boolean isSingle = rawType == Single.class;
+    boolean isCompletable = rawType == Completable.class;
+    if (rawType != Observable.class && !isSingle && !isCompletable) {
+      return null;
+    }
+
+    if (isCompletable) {
+      return new RxJavaCallAdapter(Void.class, scheduler, isAsync, false, true, false, true);
+    }
+
+    boolean isResult = false;
+    boolean isBody = false;
+    Type responseType;
+    if (!(returnType instanceof ParameterizedType)) {
+      String name = isSingle ? "Single" : "Observable";
+      throw new IllegalStateException(name + " return type must be parameterized"
+          + " as " + name + "<Foo> or " + name + "<? extends Foo>");
+    }
+
+    Type observableType = getParameterUpperBound(0, (ParameterizedType) returnType);
+    Class<?> rawObservableType = getRawType(observableType);
+    if (rawObservableType == Response.class) {
+      if (!(observableType instanceof ParameterizedType)) {
+        throw new IllegalStateException("Response must be parameterized"
+            + " as Response<Foo> or Response<? extends Foo>");
+      }
+      responseType = getParameterUpperBound(0, (ParameterizedType) observableType);
+    } else if (rawObservableType == Result.class) {
+      if (!(observableType instanceof ParameterizedType)) {
+        throw new IllegalStateException("Result must be parameterized"
+            + " as Result<Foo> or Result<? extends Foo>");
+      }
+      responseType = getParameterUpperBound(0, (ParameterizedType) observableType);
+      isResult = true;
+    } else {
+      responseType = observableType;
+      isBody = true;
+    }
+
+    return new RxJavaCallAdapter(responseType, scheduler, isAsync, isResult, isBody, isSingle,
+        false);
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/package-info.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/package-info.java
new file mode 100644
index 000000000..255728495
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/package-info.java
@@ -0,0 +1,4 @@
+@ParametersAreNonnullByDefault
+package retrofit2.adapter.rxjava;
+
+import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/RxJavaCallAdapterFactoryTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/RxJavaCallAdapterFactoryTest.java
deleted file mode 100644
index 17d14dae7..000000000
--- a/retrofit-adapters/rxjava/src/test/java/retrofit2/RxJavaCallAdapterFactoryTest.java
+++ /dev/null
@@ -1,266 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2;
-
-import com.google.common.reflect.TypeToken;
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.ResponseBody;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import java.io.IOException;
-import java.lang.annotation.Annotation;
-import java.lang.reflect.Type;
-import java.util.List;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import retrofit2.http.GET;
-import rx.Observable;
-import rx.Single;
-import rx.observables.BlockingObservable;
-
-import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.fail;
-
-public final class RxJavaCallAdapterFactoryTest {
-  private static final Annotation[] NO_ANNOTATIONS = new Annotation[0];
-
-  @Rule public final MockWebServer server = new MockWebServer();
-
-  interface Service {
-    @GET("/") Observable<String> observableBody();
-    @GET("/") Observable<Response<String>> observableResponse();
-    @GET("/") Observable<Result<String>> observableResult();
-    @GET("/") Single<String> singleBody();
-    @GET("/") Single<Response<String>> singleResponse();
-    @GET("/") Single<Result<String>> singleResult();
-  }
-
-  private Retrofit retrofit;
-  private Service service;
-
-  @Before public void setUp() {
-    retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new StringConverterFactory())
-        .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
-        .build();
-    service = retrofit.create(Service.class);
-  }
-
-  @Test public void bodySuccess200() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    BlockingObservable<String> o = service.observableBody().toBlocking();
-    assertThat(o.first()).isEqualTo("Hi");
-  }
-
-  @Test public void bodySuccess404() {
-    server.enqueue(new MockResponse().setResponseCode(404));
-
-    BlockingObservable<String> o = service.observableBody().toBlocking();
-    try {
-      o.first();
-      fail();
-    } catch (RuntimeException e) {
-      Throwable cause = e.getCause();
-      assertThat(cause).isInstanceOf(HttpException.class).hasMessage("HTTP 404 OK");
-    }
-  }
-
-  @Test public void bodyFailure() {
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
-
-    BlockingObservable<String> o = service.observableBody().toBlocking();
-    try {
-      o.first();
-      fail();
-    } catch (RuntimeException e) {
-      assertThat(e.getCause()).isInstanceOf(IOException.class);
-    }
-  }
-
-  @Test public void responseSuccess200() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    BlockingObservable<Response<String>> o = service.observableResponse().toBlocking();
-    Response<String> response = o.first();
-    assertThat(response.isSuccess()).isTrue();
-    assertThat(response.body()).isEqualTo("Hi");
-  }
-
-  @Test public void responseSuccess404() throws IOException {
-    server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
-
-    BlockingObservable<Response<String>> o = service.observableResponse().toBlocking();
-    Response<String> response = o.first();
-    assertThat(response.isSuccess()).isFalse();
-    assertThat(response.errorBody().string()).isEqualTo("Hi");
-  }
-
-  @Test public void responseFailure() {
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
-
-    BlockingObservable<Response<String>> o = service.observableResponse().toBlocking();
-    try {
-      o.first();
-      fail();
-    } catch (RuntimeException t) {
-      assertThat(t.getCause()).isInstanceOf(IOException.class);
-    }
-  }
-
-  @Test public void resultSuccess200() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    BlockingObservable<Result<String>> o = service.observableResult().toBlocking();
-    Result<String> result = o.first();
-    assertThat(result.isError()).isFalse();
-    Response<String> response = result.response();
-    assertThat(response.isSuccess()).isTrue();
-    assertThat(response.body()).isEqualTo("Hi");
-  }
-
-  @Test public void resultSuccess404() throws IOException {
-    server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
-
-    BlockingObservable<Result<String>> o = service.observableResult().toBlocking();
-    Result<String> result = o.first();
-    assertThat(result.isError()).isFalse();
-    Response<String> response = result.response();
-    assertThat(response.isSuccess()).isFalse();
-    assertThat(response.errorBody().string()).isEqualTo("Hi");
-  }
-
-  @Test public void resultFailure() {
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
-
-    BlockingObservable<Result<String>> o = service.observableResult().toBlocking();
-    Result<String> result = o.first();
-    assertThat(result.isError()).isTrue();
-    assertThat(result.error()).isInstanceOf(IOException.class);
-  }
-
-  @Test public void responseType() {
-    CallAdapter.Factory factory = RxJavaCallAdapterFactory.create();
-    Type classType = new TypeToken<Observable<String>>() {}.getType();
-    assertThat(factory.get(classType, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-    Type wilcardType = new TypeToken<Observable<? extends String>>() {}.getType();
-    assertThat(factory.get(wilcardType, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-    Type genericType = new TypeToken<Observable<List<String>>>() {}.getType();
-    assertThat(factory.get(genericType, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(new TypeToken<List<String>>() {}.getType());
-    Type responseType = new TypeToken<Observable<Response<String>>>() {}.getType();
-    assertThat(factory.get(responseType, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-    Type resultType = new TypeToken<Observable<Response<String>>>() {}.getType();
-    assertThat(factory.get(resultType, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-  }
-
-  @Test public void nonObservableTypeReturnsNull() {
-    CallAdapter.Factory factory = RxJavaCallAdapterFactory.create();
-    CallAdapter<?> adapter = factory.get(String.class, NO_ANNOTATIONS, retrofit);
-    assertThat(adapter).isNull();
-  }
-
-  @Test public void rawTypeThrows() {
-    CallAdapter.Factory factory = RxJavaCallAdapterFactory.create();
-    Type observableType = new TypeToken<Observable>() {}.getType();
-    try {
-      factory.get(observableType, NO_ANNOTATIONS, retrofit);
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage("Observable return type must be parameterized as Observable<Foo> or Observable<? extends Foo>");
-    }
-    Type singleType = new TypeToken<Single>() {}.getType();
-    try {
-      factory.get(singleType, NO_ANNOTATIONS, retrofit);
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage("Single return type must be parameterized as Single<Foo> or Single<? extends Foo>");
-    }
-  }
-
-  @Test public void rawObservableResponseTypeThrows() {
-    CallAdapter.Factory factory = RxJavaCallAdapterFactory.create();
-    Type observableType = new TypeToken<Observable<Response>>() {}.getType();
-    try {
-      factory.get(observableType, NO_ANNOTATIONS, retrofit);
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage("Response must be parameterized as Response<Foo> or Response<? extends Foo>");
-    }
-    Type singleType = new TypeToken<Single<Response>>() {}.getType();
-    try {
-      factory.get(singleType, NO_ANNOTATIONS, retrofit);
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage("Response must be parameterized as Response<Foo> or Response<? extends Foo>");
-    }
-  }
-
-  @Test public void rawResultTypeThrows() {
-    CallAdapter.Factory factory = RxJavaCallAdapterFactory.create();
-    Type observableType = new TypeToken<Observable<Result>>() {}.getType();
-    try {
-      factory.get(observableType, NO_ANNOTATIONS, retrofit);
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage("Result must be parameterized as Result<Foo> or Result<? extends Foo>");
-    }
-    Type singleType = new TypeToken<Single<Result>>() {}.getType();
-    try {
-      factory.get(singleType, NO_ANNOTATIONS, retrofit);
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage("Result must be parameterized as Result<Foo> or Result<? extends Foo>");
-    }
-  }
-
-  @Test public void single() {
-    // TODO Better tests here. Why is there no toBlocking() on Single?
-    assertNotNull(service.singleBody());
-    assertNotNull(service.singleResponse());
-    assertNotNull(service.singleResult());
-  }
-
-  static class StringConverterFactory extends Converter.Factory {
-    @Override
-    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-        Retrofit retrofit) {
-      return new Converter<ResponseBody, String>() {
-        @Override public String convert(ResponseBody value) throws IOException {
-          return value.string();
-        }
-      };
-    }
-
-    @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
-        Annotation[] annotations, Retrofit retrofit) {
-      return new Converter<String, RequestBody>() {
-        @Override public RequestBody convert(String value) throws IOException {
-          return RequestBody.create(MediaType.parse("text/plain"), value);
-        }
-      };
-    }
-  }
-}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/AsyncTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/AsyncTest.java
new file mode 100644
index 000000000..30f04cc7c
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/AsyncTest.java
@@ -0,0 +1,181 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import java.io.IOException;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+import rx.Completable;
+import rx.exceptions.CompositeException;
+import rx.exceptions.Exceptions;
+import rx.exceptions.OnErrorFailedException;
+import rx.observers.AsyncCompletableSubscriber;
+import rx.observers.TestSubscriber;
+import rx.plugins.RxJavaErrorHandler;
+import rx.plugins.RxJavaPlugins;
+
+import static java.util.concurrent.TimeUnit.SECONDS;
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+public final class AsyncTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final TestRule pluginsReset = new RxJavaPluginsResetRule();
+
+  interface Service {
+    @GET("/") Completable completable();
+  }
+
+  private Service service;
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addCallAdapterFactory(RxJavaCallAdapterFactory.createAsync())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void success() throws InterruptedException {
+    TestSubscriber<Void> subscriber = new TestSubscriber<>();
+    service.completable().subscribe(subscriber);
+    assertFalse(subscriber.awaitValueCount(1, 1, SECONDS));
+
+    server.enqueue(new MockResponse());
+    subscriber.awaitTerminalEvent(1, SECONDS);
+    subscriber.assertCompleted();
+  }
+
+
+  @Test public void failure() throws InterruptedException {
+    TestSubscriber<Void> subscriber = new TestSubscriber<>();
+    service.completable().subscribe(subscriber);
+    assertFalse(subscriber.awaitValueCount(1, 1, SECONDS));
+
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+    subscriber.awaitTerminalEvent(1, SECONDS);
+    subscriber.assertError(IOException.class);
+  }
+
+  @Test public void throwingInOnCompleteDeliveredToPlugin() throws InterruptedException {
+    server.enqueue(new MockResponse());
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (!errorRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+        latch.countDown();
+      }
+    });
+
+    final TestSubscriber<Void> subscriber = new TestSubscriber<>();
+    final RuntimeException e = new RuntimeException();
+    service.completable().unsafeSubscribe(new AsyncCompletableSubscriber() {
+      @Override public void onCompleted() {
+        throw e;
+      }
+
+      @Override public void onError(Throwable t) {
+        subscriber.onError(t);
+      }
+    });
+
+    latch.await(1, SECONDS);
+    assertThat(errorRef.get()).isSameAs(e);
+  }
+
+  @Test public void bodyThrowingInOnErrorDeliveredToPlugin() throws InterruptedException {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (!pluginRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+        latch.countDown();
+      }
+    });
+
+    final TestSubscriber<Void> subscriber = new TestSubscriber<>();
+    final RuntimeException e = new RuntimeException();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    service.completable().unsafeSubscribe(new AsyncCompletableSubscriber() {
+      @Override public void onCompleted() {
+        subscriber.onCompleted();
+      }
+
+      @Override public void onError(Throwable t) {
+        errorRef.set(t);
+        throw e;
+      }
+    });
+
+    assertTrue(latch.await(1, SECONDS));
+    CompositeException composite = (CompositeException) pluginRef.get();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+
+  @Test public void bodyThrowingInOnSafeSubscriberErrorDeliveredToPlugin()
+      throws InterruptedException {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (throwable instanceof OnErrorFailedException) {
+          if (!pluginRef.compareAndSet(null, throwable)) {
+            throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+          }
+          latch.countDown();
+        }
+      }
+    });
+
+    final TestSubscriber<Void> subscriber = new TestSubscriber<>();
+    final RuntimeException e = new RuntimeException();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    service.completable().subscribe(new AsyncCompletableSubscriber() {
+      @Override public void onCompleted() {
+        subscriber.onCompleted();
+      }
+
+      @Override public void onError(Throwable t) {
+        errorRef.set(t);
+        throw e;
+      }
+    });
+
+    assertTrue(latch.await(1, SECONDS));
+    OnErrorFailedException failed = (OnErrorFailedException) pluginRef.get();
+    CompositeException composite = (CompositeException) failed.getCause();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CancelDisposeTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CancelDisposeTest.java
new file mode 100644
index 000000000..333bf97c1
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CancelDisposeTest.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import java.util.List;
+import okhttp3.Call;
+import okhttp3.OkHttpClient;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+import rx.Observable;
+import rx.Subscription;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+public final class CancelDisposeTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  interface Service {
+    @GET("/") Observable<String> go();
+  }
+
+  private final OkHttpClient client = new OkHttpClient();
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJavaCallAdapterFactory.createAsync())
+        .callFactory(client)
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void disposeCancelsCall() {
+    Subscription subscription = service.go().subscribe();
+    List<Call> calls = client.dispatcher().runningCalls();
+    assertEquals(1, calls.size());
+    subscription.unsubscribe();
+    assertTrue(calls.get(0).isCanceled());
+  }
+
+  @Test public void cancelDoesNotDispose() {
+    Subscription subscription = service.go().subscribe();
+    List<Call> calls = client.dispatcher().runningCalls();
+    assertEquals(1, calls.size());
+    calls.get(0).cancel();
+    assertFalse(subscription.isUnsubscribed());
+  }
+}
+
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableTest.java
new file mode 100644
index 000000000..3d84b39f2
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableTest.java
@@ -0,0 +1,74 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import java.io.IOException;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+import rx.Completable;
+
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+
+public final class CompletableTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final TestRule pluginsReset = new RxJavaPluginsResetRule();
+  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
+
+  interface Service {
+    @GET("/") Completable completable();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void completableSuccess200() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingSubscriber<Void> subscriber = subscriberRule.create();
+    service.completable().unsafeSubscribe(subscriber);
+    subscriber.assertCompleted();
+  }
+
+  @Test public void completableSuccess404() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    RecordingSubscriber<Void> subscriber = subscriberRule.create();
+    service.completable().unsafeSubscribe(subscriber);
+    // Required for backwards compatibility.
+    subscriber.assertError(HttpException.class, "HTTP 404 Client Error");
+  }
+
+  @Test public void completableFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    RecordingSubscriber<Void> subscriber = subscriberRule.create();
+    service.completable().unsafeSubscribe(subscriber);
+    subscriber.assertError(IOException.class);
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableThrowingSafeSubscriberTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableThrowingSafeSubscriberTest.java
new file mode 100644
index 000000000..9a0dec34a
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableThrowingSafeSubscriberTest.java
@@ -0,0 +1,129 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+import rx.Completable;
+import rx.CompletableSubscriber;
+import rx.Subscription;
+import rx.exceptions.CompositeException;
+import rx.exceptions.Exceptions;
+import rx.exceptions.OnCompletedFailedException;
+import rx.exceptions.OnErrorFailedException;
+import rx.plugins.RxJavaErrorHandler;
+import rx.plugins.RxJavaPlugins;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class CompletableThrowingSafeSubscriberTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final TestRule resetRule = new RxJavaPluginsResetRule();
+  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
+
+  interface Service {
+    @GET("/") Completable completable();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void throwingInOnCompleteDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (throwable instanceof OnCompletedFailedException) {
+          if (!pluginRef.compareAndSet(null, throwable)) {
+            throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+          }
+        }
+      }
+    });
+
+    RecordingSubscriber<Void> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.completable().subscribe(new ForwardingCompletableObserver(observer) {
+      @Override public void onCompleted() {
+        throw e;
+      }
+    });
+
+    assertThat(pluginRef.get().getCause()).isSameAs(e);
+  }
+
+  @Test public void bodyThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (throwable instanceof OnErrorFailedException) {
+          if (!pluginRef.compareAndSet(null, throwable)) {
+            throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+          }
+        }
+      }
+    });
+
+    RecordingSubscriber<Void> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    service.completable().subscribe(new ForwardingCompletableObserver(observer) {
+      @Override public void onError(Throwable throwable) {
+        errorRef.set(throwable);
+        throw e;
+      }
+    });
+
+    CompositeException composite = (CompositeException) pluginRef.get().getCause();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+
+  static abstract class ForwardingCompletableObserver implements CompletableSubscriber {
+    private final RecordingSubscriber<Void> delegate;
+
+    ForwardingCompletableObserver(RecordingSubscriber<Void> delegate) {
+      this.delegate = delegate;
+    }
+
+    @Override public void onSubscribe(Subscription d) {
+    }
+
+    @Override public void onCompleted() {
+      delegate.onCompleted();
+    }
+
+    @Override public void onError(Throwable throwable) {
+      delegate.onError(throwable);
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableThrowingTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableThrowingTest.java
new file mode 100644
index 000000000..be4263b8c
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableThrowingTest.java
@@ -0,0 +1,124 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.function.Consumer;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+import rx.Completable;
+import rx.CompletableSubscriber;
+import rx.Subscription;
+import rx.exceptions.CompositeException;
+import rx.exceptions.Exceptions;
+import rx.plugins.RxJavaErrorHandler;
+import rx.plugins.RxJavaPlugins;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class CompletableThrowingTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final TestRule resetRule = new RxJavaPluginsResetRule();
+  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
+
+  interface Service {
+    @GET("/") Completable completable();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void throwingInOnCompleteDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (!pluginRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+      }
+    });
+
+    RecordingSubscriber<Void> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.completable().unsafeSubscribe(new ForwardingCompletableObserver(observer) {
+      @Override public void onCompleted() {
+        throw e;
+      }
+    });
+
+    assertThat(pluginRef.get()).isSameAs(e);
+  }
+
+  @Test public void bodyThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (!pluginRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+      }
+    });
+
+    RecordingSubscriber<Void> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    service.completable().unsafeSubscribe(new ForwardingCompletableObserver(observer) {
+      @Override public void onError(Throwable throwable) {
+        errorRef.set(throwable);
+        throw e;
+      }
+    });
+
+    CompositeException composite = (CompositeException) pluginRef.get();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+
+  static abstract class ForwardingCompletableObserver implements CompletableSubscriber {
+    private final RecordingSubscriber<Void> delegate;
+
+    ForwardingCompletableObserver(RecordingSubscriber<Void> delegate) {
+      this.delegate = delegate;
+    }
+
+    @Override public void onSubscribe(Subscription d) {
+    }
+
+    @Override public void onCompleted() {
+      delegate.onCompleted();
+    }
+
+    @Override public void onError(Throwable throwable) {
+      delegate.onError(throwable);
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableWithSchedulerTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableWithSchedulerTest.java
new file mode 100644
index 000000000..02c4778b1
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableWithSchedulerTest.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+import rx.Completable;
+import rx.schedulers.TestScheduler;
+
+public final class CompletableWithSchedulerTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
+
+  interface Service {
+    @GET("/") Completable completable();
+  }
+
+  private final TestScheduler scheduler = new TestScheduler();
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addCallAdapterFactory(RxJavaCallAdapterFactory.createWithScheduler(scheduler))
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void completableUsesScheduler() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingSubscriber<String> subscriber = subscriberRule.create();
+    service.completable().unsafeSubscribe(subscriber);
+    subscriber.assertNoEvents();
+
+    scheduler.triggerActions();
+    subscriber.assertCompleted();
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ForwardingSubscriber.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ForwardingSubscriber.java
new file mode 100644
index 000000000..d32d6f6ae
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ForwardingSubscriber.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import rx.Subscriber;
+
+abstract class ForwardingSubscriber<T> extends Subscriber<T> {
+  private final Subscriber<T> delegate;
+
+  ForwardingSubscriber(Subscriber<T> delegate) {
+    this.delegate = delegate;
+  }
+
+  @Override public void onNext(T value) {
+    delegate.onNext(value);
+  }
+
+  @Override public void onCompleted() {
+    delegate.onCompleted();
+  }
+
+  @Override public void onError(Throwable throwable) {
+    delegate.onError(throwable);
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableTest.java
new file mode 100644
index 000000000..500c3c539
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableTest.java
@@ -0,0 +1,194 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import java.io.IOException;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+import rx.Observable;
+import rx.functions.Action1;
+
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class ObservableTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final TestRule pluginsReset = new RxJavaPluginsResetRule();
+  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
+
+  interface Service {
+    @GET("/") Observable<String> body();
+    @GET("/") Observable<Response<String>> response();
+    @GET("/") Observable<Result<String>> result();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodySuccess200() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingSubscriber<String> subscriber = subscriberRule.create();
+    service.body().unsafeSubscribe(subscriber);
+    subscriber.assertValue("Hi").assertCompleted();
+  }
+
+  @Test public void bodySuccess404() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    RecordingSubscriber<String> subscriber = subscriberRule.create();
+    service.body().unsafeSubscribe(subscriber);
+    // Required for backwards compatibility.
+    subscriber.assertError(HttpException.class, "HTTP 404 Client Error");
+  }
+
+  @Test public void bodyFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    RecordingSubscriber<String> subscriber = subscriberRule.create();
+    service.body().unsafeSubscribe(subscriber);
+    subscriber.assertError(IOException.class);
+  }
+
+  @Test public void bodyRespectsBackpressure() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingSubscriber<String> subscriber = subscriberRule.createWithInitialRequest(0);
+    service.body().unsafeSubscribe(subscriber);
+    assertThat(server.getRequestCount()).isEqualTo(1);
+    subscriber.assertNoEvents();
+
+    subscriber.requestMore(1);
+    subscriber.assertAnyValue().assertCompleted();
+
+    subscriber.requestMore(Long.MAX_VALUE); // Subsequent requests do not trigger HTTP requests.
+    assertThat(server.getRequestCount()).isEqualTo(1);
+  }
+
+  @Test public void responseSuccess200() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+    service.response().unsafeSubscribe(subscriber);
+    assertThat(subscriber.takeValue().body()).isEqualTo("Hi");
+    subscriber.assertCompleted();
+  }
+
+  @Test public void responseSuccess404() throws IOException {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+    service.response().unsafeSubscribe(subscriber);
+    assertThat(subscriber.takeValue().code()).isEqualTo(404);
+    subscriber.assertCompleted();
+  }
+
+  @Test public void responseFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+    service.response().unsafeSubscribe(subscriber);
+    subscriber.assertError(IOException.class);
+  }
+
+  @Test public void responseRespectsBackpressure() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.createWithInitialRequest(0);
+    service.response().unsafeSubscribe(subscriber);
+    assertThat(server.getRequestCount()).isEqualTo(1);
+    subscriber.assertNoEvents();
+
+    subscriber.requestMore(1);
+    subscriber.assertAnyValue().assertCompleted();
+
+    subscriber.requestMore(Long.MAX_VALUE); // Subsequent requests do not trigger HTTP requests.
+    assertThat(server.getRequestCount()).isEqualTo(1);
+  }
+
+  @Test public void responseUnsubscribedDoesNotCallCompleted() throws InterruptedException {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    final RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+    service.response()
+        .doOnNext(new Action1<Response<String>>() {
+          @Override
+          public void call(Response<String> response) {
+            subscriber.unsubscribe();
+          }
+        })
+        .subscribe(subscriber);
+
+    assertThat(subscriber.takeValue().body()).isEqualTo("Hi");
+  }
+
+  @Test public void resultSuccess200() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+    service.result().unsafeSubscribe(subscriber);
+    assertThat(subscriber.takeValue().response().body()).isEqualTo("Hi");
+    subscriber.assertCompleted();
+  }
+
+  @Test public void resultSuccess404() throws IOException {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+    service.result().unsafeSubscribe(subscriber);
+    assertThat(subscriber.takeValue().response().code()).isEqualTo(404);
+    subscriber.assertCompleted();
+  }
+
+  @Test public void resultFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+    service.result().unsafeSubscribe(subscriber);
+    assertThat(subscriber.takeValue().error()).isInstanceOf(IOException.class);
+    subscriber.assertCompleted();
+  }
+
+  @Test public void resultRespectsBackpressure() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.createWithInitialRequest(0);
+    service.result().unsafeSubscribe(subscriber);
+    assertThat(server.getRequestCount()).isEqualTo(1);
+    subscriber.assertNoEvents();
+
+    subscriber.requestMore(1);
+    subscriber.assertAnyValue().assertCompleted();
+
+    subscriber.requestMore(Long.MAX_VALUE); // Subsequent requests do not trigger HTTP requests.
+    assertThat(server.getRequestCount()).isEqualTo(1);
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableThrowingSafeSubscriberTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableThrowingSafeSubscriberTest.java
new file mode 100644
index 000000000..550d6cbc3
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableThrowingSafeSubscriberTest.java
@@ -0,0 +1,272 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+import rx.Observable;
+import rx.exceptions.CompositeException;
+import rx.exceptions.Exceptions;
+import rx.exceptions.OnCompletedFailedException;
+import rx.exceptions.OnErrorFailedException;
+import rx.plugins.RxJavaErrorHandler;
+import rx.plugins.RxJavaPlugins;
+
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class ObservableThrowingSafeSubscriberTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final TestRule resetRule = new RxJavaPluginsResetRule();
+  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
+
+  interface Service {
+    @GET("/") Observable<String> body();
+    @GET("/") Observable<Response<String>> response();
+    @GET("/") Observable<Result<String>> result();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodyThrowingInOnNextDeliveredToError() {
+    server.enqueue(new MockResponse());
+
+    RecordingSubscriber<String> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.body().subscribe(new ForwardingSubscriber<String>(observer) {
+      @Override public void onNext(String value) {
+        throw e;
+      }
+    });
+
+    observer.assertError(e);
+  }
+
+  @Test public void bodyThrowingInOnCompleteDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (throwable instanceof OnCompletedFailedException) {
+          if (!pluginRef.compareAndSet(null, throwable)) {
+            throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+          }
+        }
+      }
+    });
+
+    RecordingSubscriber<String> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.body().subscribe(new ForwardingSubscriber<String>(observer) {
+      @Override public void onCompleted() {
+        throw e;
+      }
+    });
+
+    observer.assertAnyValue();
+    assertThat(pluginRef.get().getCause()).isSameAs(e);
+  }
+
+  @Test public void bodyThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (throwable instanceof OnErrorFailedException) {
+          if (!pluginRef.compareAndSet(null, throwable)) {
+            throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+          }
+        }
+      }
+    });
+
+    RecordingSubscriber<String> observer = subscriberRule.create();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    final RuntimeException e = new RuntimeException();
+    service.body().subscribe(new ForwardingSubscriber<String>(observer) {
+      @Override public void onError(Throwable throwable) {
+        if (!errorRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+        throw e;
+      }
+    });
+
+    CompositeException composite = (CompositeException) pluginRef.get().getCause();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+
+  @Test public void responseThrowingInOnNextDeliveredToError() {
+    server.enqueue(new MockResponse());
+
+    RecordingSubscriber<Response<String>> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.response().subscribe(new ForwardingSubscriber<Response<String>>(observer) {
+      @Override public void onNext(Response<String> value) {
+        throw e;
+      }
+    });
+
+    observer.assertError(e);
+  }
+
+  @Test public void responseThrowingInOnCompleteDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (throwable instanceof OnCompletedFailedException) {
+          if (!pluginRef.compareAndSet(null, throwable)) {
+            throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+          }
+        }
+      }
+    });
+
+    RecordingSubscriber<Response<String>> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.response().subscribe(new ForwardingSubscriber<Response<String>>(observer) {
+      @Override public void onCompleted() {
+        throw e;
+      }
+    });
+
+    observer.assertAnyValue();
+    assertThat(pluginRef.get().getCause()).isSameAs(e);
+  }
+
+  @Test public void responseThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (throwable instanceof OnErrorFailedException) {
+          if (!pluginRef.compareAndSet(null, throwable)) {
+            throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+          }
+        }
+      }
+    });
+
+    RecordingSubscriber<Response<String>> observer = subscriberRule.create();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    final RuntimeException e = new RuntimeException();
+    service.response().subscribe(new ForwardingSubscriber<Response<String>>(observer) {
+      @Override public void onError(Throwable throwable) {
+        if (!errorRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+        throw e;
+      }
+    });
+
+    CompositeException composite = (CompositeException) pluginRef.get().getCause();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+
+  @Test public void resultThrowingInOnNextDeliveredToError() {
+    server.enqueue(new MockResponse());
+
+    RecordingSubscriber<Result<String>> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.result().subscribe(new ForwardingSubscriber<Result<String>>(observer) {
+      @Override public void onNext(Result<String> value) {
+        throw e;
+      }
+    });
+
+    observer.assertError(e);
+  }
+
+  @Test public void resultThrowingInOnCompletedDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (throwable instanceof OnCompletedFailedException) {
+          if (!pluginRef.compareAndSet(null, throwable)) {
+            throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+          }
+        }
+      }
+    });
+
+    RecordingSubscriber<Result<String>> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.result().subscribe(new ForwardingSubscriber<Result<String>>(observer) {
+      @Override public void onCompleted() {
+        throw e;
+      }
+    });
+
+    observer.assertAnyValue();
+    assertThat(pluginRef.get().getCause()).isSameAs(e);
+  }
+
+  @Test public void resultThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (throwable instanceof OnErrorFailedException) {
+          if (!pluginRef.compareAndSet(null, throwable)) {
+            throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+          }
+        }
+      }
+    });
+
+    RecordingSubscriber<Result<String>> observer = subscriberRule.create();
+    final RuntimeException first = new RuntimeException();
+    final RuntimeException second = new RuntimeException();
+    service.result().subscribe(new ForwardingSubscriber<Result<String>>(observer) {
+      @Override public void onNext(Result<String> value) {
+        // The only way to trigger onError for a result is if onNext throws.
+        throw first;
+      }
+
+      @Override public void onError(Throwable throwable) {
+        throw second;
+      }
+    });
+
+    CompositeException composite = (CompositeException) pluginRef.get().getCause();
+    assertThat(composite.getExceptions()).containsExactly(first, second);
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableThrowingTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableThrowingTest.java
new file mode 100644
index 000000000..59c8ae5ae
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableThrowingTest.java
@@ -0,0 +1,258 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+import rx.Observable;
+import rx.exceptions.CompositeException;
+import rx.exceptions.Exceptions;
+import rx.plugins.RxJavaErrorHandler;
+import rx.plugins.RxJavaPlugins;
+
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class ObservableThrowingTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final TestRule resetRule = new RxJavaPluginsResetRule();
+  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
+
+  interface Service {
+    @GET("/") Observable<String> body();
+    @GET("/") Observable<Response<String>> response();
+    @GET("/") Observable<Result<String>> result();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodyThrowingInOnNextDeliveredToError() {
+    server.enqueue(new MockResponse());
+
+    RecordingSubscriber<String> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.body().unsafeSubscribe(new ForwardingSubscriber<String>(observer) {
+      @Override public void onNext(String value) {
+        throw e;
+      }
+    });
+
+    observer.assertError(e);
+  }
+
+  @Test public void bodyThrowingInOnCompleteDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (!pluginRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+      }
+    });
+
+    RecordingSubscriber<String> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.body().unsafeSubscribe(new ForwardingSubscriber<String>(observer) {
+      @Override public void onCompleted() {
+        throw e;
+      }
+    });
+
+    observer.assertAnyValue();
+    assertThat(pluginRef.get()).isSameAs(e);
+  }
+
+  @Test public void bodyThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (!pluginRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+      }
+    });
+
+    RecordingSubscriber<String> observer = subscriberRule.create();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    final RuntimeException e = new RuntimeException();
+    service.body().unsafeSubscribe(new ForwardingSubscriber<String>(observer) {
+      @Override public void onError(Throwable throwable) {
+        if (!errorRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+        throw e;
+      }
+    });
+
+    CompositeException composite = (CompositeException) pluginRef.get();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+
+  @Test public void responseThrowingInOnNextDeliveredToError() {
+    server.enqueue(new MockResponse());
+
+    RecordingSubscriber<Response<String>> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.response().unsafeSubscribe(new ForwardingSubscriber<Response<String>>(observer) {
+      @Override public void onNext(Response<String> value) {
+        throw e;
+      }
+    });
+
+    observer.assertError(e);
+  }
+
+  @Test public void responseThrowingInOnCompleteDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (!pluginRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+      }
+    });
+
+    RecordingSubscriber<Response<String>> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.response().unsafeSubscribe(new ForwardingSubscriber<Response<String>>(observer) {
+      @Override public void onCompleted() {
+        throw e;
+      }
+    });
+
+    observer.assertAnyValue();
+    assertThat(pluginRef.get()).isSameAs(e);
+  }
+
+  @Test public void responseThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (!pluginRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+      }
+    });
+
+    RecordingSubscriber<Response<String>> observer = subscriberRule.create();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    final RuntimeException e = new RuntimeException();
+    service.response().unsafeSubscribe(new ForwardingSubscriber<Response<String>>(observer) {
+      @Override public void onError(Throwable throwable) {
+        if (!errorRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+        throw e;
+      }
+    });
+
+    CompositeException composite = (CompositeException) pluginRef.get();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+
+  @Test public void resultThrowingInOnNextDeliveredToError() {
+    server.enqueue(new MockResponse());
+
+    RecordingSubscriber<Result<String>> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.result().unsafeSubscribe(new ForwardingSubscriber<Result<String>>(observer) {
+      @Override public void onNext(Result<String> value) {
+        throw e;
+      }
+    });
+
+    observer.assertError(e);
+  }
+
+  @Test public void resultThrowingInOnCompletedDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (!pluginRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+      }
+    });
+
+    RecordingSubscriber<Result<String>> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.result().unsafeSubscribe(new ForwardingSubscriber<Result<String>>(observer) {
+      @Override public void onCompleted() {
+        throw e;
+      }
+    });
+
+    observer.assertAnyValue();
+    assertThat(pluginRef.get()).isSameAs(e);
+  }
+
+  @Test public void resultThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (!pluginRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+      }
+    });
+
+    RecordingSubscriber<Result<String>> observer = subscriberRule.create();
+    final RuntimeException first = new RuntimeException();
+    final RuntimeException second = new RuntimeException();
+    service.result().unsafeSubscribe(new ForwardingSubscriber<Result<String>>(observer) {
+      @Override public void onNext(Result<String> value) {
+        // The only way to trigger onError for a result is if onNext throws.
+        throw first;
+      }
+
+      @Override public void onError(Throwable throwable) {
+        throw second;
+      }
+    });
+
+    CompositeException composite = (CompositeException) pluginRef.get();
+    assertThat(composite.getExceptions()).containsExactly(first, second);
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableWithSchedulerTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableWithSchedulerTest.java
new file mode 100644
index 000000000..3cf00cd7a
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableWithSchedulerTest.java
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+import rx.Observable;
+import rx.schedulers.TestScheduler;
+
+public final class ObservableWithSchedulerTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
+
+  interface Service {
+    @GET("/") Observable<String> body();
+    @GET("/") Observable<Response<String>> response();
+    @GET("/") Observable<Result<String>> result();
+  }
+
+  private final TestScheduler scheduler = new TestScheduler();
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJavaCallAdapterFactory.createWithScheduler(scheduler))
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodyUsesScheduler() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingSubscriber<String> subscriber = subscriberRule.create();
+    service.body().unsafeSubscribe(subscriber);
+    subscriber.assertNoEvents();
+
+    scheduler.triggerActions();
+    subscriber.assertAnyValue().assertCompleted();
+  }
+
+  @Test public void responseUsesScheduler() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+    service.response().unsafeSubscribe(subscriber);
+    subscriber.assertNoEvents();
+
+    scheduler.triggerActions();
+    subscriber.assertAnyValue().assertCompleted();
+  }
+
+  @Test public void resultUsesScheduler() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+    service.result().unsafeSubscribe(subscriber);
+    subscriber.assertNoEvents();
+
+    scheduler.triggerActions();
+    subscriber.assertAnyValue().assertCompleted();
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/RecordingSubscriber.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/RecordingSubscriber.java
new file mode 100644
index 000000000..4919ddcd5
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/RecordingSubscriber.java
@@ -0,0 +1,146 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Deque;
+import java.util.List;
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+import rx.Notification;
+import rx.Subscriber;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+/** A test {@link Subscriber} and JUnit rule which guarantees all events are asserted. */
+final class RecordingSubscriber<T> extends Subscriber<T> {
+  private final long initialRequest;
+  private final Deque<Notification<T>> events = new ArrayDeque<>();
+
+  private RecordingSubscriber(long initialRequest) {
+    this.initialRequest = initialRequest;
+  }
+
+  @Override public void onStart() {
+    request(initialRequest);
+  }
+
+  @Override public void onNext(T value) {
+    events.add(Notification.createOnNext(value));
+  }
+
+  @Override public void onCompleted() {
+    events.add(Notification.<T>createOnCompleted());
+  }
+
+  @Override public void onError(Throwable e) {
+    events.add(Notification.<T>createOnError(e));
+  }
+
+  private Notification<T> takeNotification() {
+    Notification<T> notification = events.pollFirst();
+    if (notification == null) {
+      throw new AssertionError("No event found!");
+    }
+    return notification;
+  }
+
+  public T takeValue() {
+    Notification<T> notification = takeNotification();
+    assertThat(notification.isOnNext())
+        .overridingErrorMessage("Expected onNext event but was %s", notification)
+        .isTrue();
+    return notification.getValue();
+  }
+
+  public Throwable takeError() {
+    Notification<T> notification = takeNotification();
+    assertThat(notification.isOnError())
+        .overridingErrorMessage("Expected onError event but was %s", notification)
+        .isTrue();
+    return notification.getThrowable();
+  }
+
+  public RecordingSubscriber<T> assertAnyValue() {
+    takeValue();
+    return this;
+  }
+
+  public RecordingSubscriber<T> assertValue(T value) {
+    assertThat(takeValue()).isEqualTo(value);
+    return this;
+  }
+
+  public void assertCompleted() {
+    Notification<T> notification = takeNotification();
+    assertThat(notification.isOnCompleted())
+        .overridingErrorMessage("Expected onCompleted event but was %s", notification)
+        .isTrue();
+    assertNoEvents();
+  }
+
+  public void assertError(Throwable throwable) {
+    assertThat(takeError()).isEqualTo(throwable);
+  }
+
+  public void assertError(Class<? extends Throwable> errorClass) {
+    assertError(errorClass, null);
+  }
+
+  public void assertError(Class<? extends Throwable> errorClass, String message) {
+    Throwable throwable = takeError();
+    assertThat(throwable).isInstanceOf(errorClass);
+    if (message != null) {
+      assertThat(throwable).hasMessage(message);
+    }
+    assertNoEvents();
+  }
+
+  public void assertNoEvents() {
+    assertThat(events).as("Unconsumed events found!").isEmpty();
+  }
+
+  public void requestMore(long amount) {
+    request(amount);
+  }
+
+  public static final class Rule implements TestRule {
+    final List<RecordingSubscriber<?>> subscribers = new ArrayList<>();
+
+    public <T> RecordingSubscriber<T> create() {
+      return createWithInitialRequest(Long.MAX_VALUE);
+    }
+
+    public <T> RecordingSubscriber<T> createWithInitialRequest(long initialRequest) {
+      RecordingSubscriber<T> subscriber = new RecordingSubscriber<>(initialRequest);
+      subscribers.add(subscriber);
+      return subscriber;
+    }
+
+    @Override public Statement apply(final Statement base, Description description) {
+      return new Statement() {
+        @Override public void evaluate() throws Throwable {
+          base.evaluate();
+          for (RecordingSubscriber<?> subscriber : subscribers) {
+            subscriber.assertNoEvents();
+          }
+        }
+      };
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ResultTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ResultTest.java
new file mode 100644
index 000000000..7c62c14ad
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ResultTest.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import java.io.IOException;
+import org.junit.Test;
+import retrofit2.Response;
+import retrofit2.adapter.rxjava.Result;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class ResultTest {
+  @Test public void response() {
+    Response<String> response = Response.success("Hi");
+    Result<String> result = Result.response(response);
+    assertThat(result.isError()).isFalse();
+    assertThat(result.error()).isNull();
+    assertThat(result.response()).isSameAs(response);
+  }
+
+  @Test public void nullResponseThrows() {
+    try {
+      Result.response(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("response == null");
+    }
+  }
+
+  @Test public void error() {
+    Throwable error = new IOException();
+    Result<Object> result = Result.error(error);
+    assertThat(result.isError()).isTrue();
+    assertThat(result.error()).isSameAs(error);
+    assertThat(result.response()).isNull();
+  }
+
+  @Test public void nullErrorThrows() {
+    try {
+      Result.error(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("error == null");
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactoryTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactoryTest.java
new file mode 100644
index 000000000..674575f74
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactoryTest.java
@@ -0,0 +1,171 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import com.google.common.reflect.TypeToken;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import java.util.List;
+import org.junit.Before;
+import org.junit.Test;
+import retrofit2.CallAdapter;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import rx.Observable;
+import rx.Single;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class RxJavaCallAdapterFactoryTest {
+  private static final Annotation[] NO_ANNOTATIONS = new Annotation[0];
+
+  private final CallAdapter.Factory factory = RxJavaCallAdapterFactory.create();
+  private Retrofit retrofit;
+
+  @Before public void setUp() {
+    retrofit = new Retrofit.Builder()
+        .baseUrl("http://localhost:1")
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(factory)
+        .build();
+  }
+
+  @Test public void nullSchedulerThrows() {
+    try {
+      RxJavaCallAdapterFactory.createWithScheduler(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("scheduler == null");
+    }
+  }
+
+  @Test public void nonRxJavaTypeReturnsNull() {
+    CallAdapter<?, ?> adapter = factory.get(String.class, NO_ANNOTATIONS, retrofit);
+    assertThat(adapter).isNull();
+  }
+
+  @Test public void responseTypes() {
+    Type oBodyClass = new TypeToken<Observable<String>>() {}.getType();
+    assertThat(factory.get(oBodyClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type sBodyClass = new TypeToken<Single<String>>() {}.getType();
+    assertThat(factory.get(sBodyClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+
+    Type oBodyWildcard = new TypeToken<Observable<? extends String>>() {}.getType();
+    assertThat(factory.get(oBodyWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type sBodyWildcard = new TypeToken<Single<? extends String>>() {}.getType();
+    assertThat(factory.get(sBodyWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+
+    Type oBodyGeneric = new TypeToken<Observable<List<String>>>() {}.getType();
+    assertThat(factory.get(oBodyGeneric, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(new TypeToken<List<String>>() {}.getType());
+    Type sBodyGeneric = new TypeToken<Single<List<String>>>() {}.getType();
+    assertThat(factory.get(sBodyGeneric, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(new TypeToken<List<String>>() {}.getType());
+
+    Type oResponseClass = new TypeToken<Observable<Response<String>>>() {}.getType();
+    assertThat(factory.get(oResponseClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type sResponseClass = new TypeToken<Single<Response<String>>>() {}.getType();
+    assertThat(factory.get(sResponseClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+
+    Type oResponseWildcard = new TypeToken<Observable<Response<? extends String>>>() {}.getType();
+    assertThat(factory.get(oResponseWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type sResponseWildcard = new TypeToken<Single<Response<? extends String>>>() {}.getType();
+    assertThat(factory.get(sResponseWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+
+    Type oResultClass = new TypeToken<Observable<Result<String>>>() {}.getType();
+    assertThat(factory.get(oResultClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type sResultClass = new TypeToken<Single<Result<String>>>() {}.getType();
+    assertThat(factory.get(sResultClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+
+    Type oResultWildcard = new TypeToken<Observable<Result<? extends String>>>() {}.getType();
+    assertThat(factory.get(oResultWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type sResultWildcard = new TypeToken<Single<Result<? extends String>>>() {}.getType();
+    assertThat(factory.get(sResultWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+  }
+
+  @Test public void rawBodyTypeThrows() {
+    Type observableType = new TypeToken<Observable>() {}.getType();
+    try {
+      factory.get(observableType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Observable return type must be parameterized as Observable<Foo> or Observable<? extends Foo>");
+    }
+
+    Type singleType = new TypeToken<Single>() {}.getType();
+    try {
+      factory.get(singleType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Single return type must be parameterized as Single<Foo> or Single<? extends Foo>");
+    }
+  }
+
+  @Test public void rawResponseTypeThrows() {
+    Type observableType = new TypeToken<Observable<Response>>() {}.getType();
+    try {
+      factory.get(observableType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Response must be parameterized as Response<Foo> or Response<? extends Foo>");
+    }
+
+    Type singleType = new TypeToken<Single<Response>>() {}.getType();
+    try {
+      factory.get(singleType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Response must be parameterized as Response<Foo> or Response<? extends Foo>");
+    }
+  }
+
+  @Test public void rawResultTypeThrows() {
+    Type observableType = new TypeToken<Observable<Result>>() {}.getType();
+    try {
+      factory.get(observableType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Result must be parameterized as Result<Foo> or Result<? extends Foo>");
+    }
+
+    Type singleType = new TypeToken<Single<Result>>() {}.getType();
+    try {
+      factory.get(singleType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Result must be parameterized as Result<Foo> or Result<? extends Foo>");
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/RxJavaPluginsResetRule.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/RxJavaPluginsResetRule.java
new file mode 100644
index 000000000..dfe336f07
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/RxJavaPluginsResetRule.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+import rx.plugins.RxJavaPlugins;
+
+/** A JUnit @Rule which resets RxJava's plugins before and after each test. */
+final class RxJavaPluginsResetRule implements TestRule {
+  @Override public Statement apply(final Statement base, Description description) {
+    return new Statement() {
+      @Override public void evaluate() throws Throwable {
+        RxJavaPlugins.getInstance().reset();
+        try {
+          base.evaluate();
+        } finally {
+          RxJavaPlugins.getInstance().reset();
+        }
+      }
+    };
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleTest.java
new file mode 100644
index 000000000..babd05c73
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleTest.java
@@ -0,0 +1,174 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import java.io.IOException;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+import rx.Single;
+
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class SingleTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final TestRule pluginsReset = new RxJavaPluginsResetRule();
+  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
+
+  interface Service {
+    @GET("/") Single<String> body();
+    @GET("/") Single<Response<String>> response();
+    @GET("/") Single<Result<String>> result();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodySuccess200() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingSubscriber<String> subscriber = subscriberRule.create();
+    service.body().unsafeSubscribe(subscriber);
+    subscriber.assertValue("Hi").assertCompleted();
+  }
+
+  @Test public void bodySuccess404() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    RecordingSubscriber<String> subscriber = subscriberRule.create();
+    service.body().unsafeSubscribe(subscriber);
+    // Required for backwards compatibility.
+    subscriber.assertError(HttpException.class, "HTTP 404 Client Error");
+  }
+
+  @Test public void bodyFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    RecordingSubscriber<String> subscriber = subscriberRule.create();
+    service.body().unsafeSubscribe(subscriber);
+    subscriber.assertError(IOException.class);
+  }
+
+  @Test public void bodyThrowingInOnNextDeliveredToError() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingSubscriber<String> subscriber = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.body().unsafeSubscribe(new ForwardingSubscriber<String>(subscriber) {
+      @Override public void onNext(String value) {
+        throw e;
+      }
+    });
+
+    subscriber.assertError(e);
+  }
+
+  @Test public void responseSuccess200() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+    service.response().unsafeSubscribe(subscriber);
+    assertThat(subscriber.takeValue().body()).isEqualTo("Hi");
+    subscriber.assertCompleted();
+  }
+
+  @Test public void responseSuccess404() throws IOException {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+    service.response().unsafeSubscribe(subscriber);
+    assertThat(subscriber.takeValue().code()).isEqualTo(404);
+    subscriber.assertCompleted();
+  }
+
+  @Test public void responseFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+    service.response().unsafeSubscribe(subscriber);
+    subscriber.assertError(IOException.class);
+  }
+
+  @Test public void responseThrowingInOnNextDeliveredToError() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.response().unsafeSubscribe(new ForwardingSubscriber<Response<String>>(subscriber) {
+      @Override public void onNext(Response<String> value) {
+        throw e;
+      }
+    });
+
+    subscriber.assertError(e);
+  }
+
+  @Test public void resultSuccess200() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+    service.result().unsafeSubscribe(subscriber);
+    assertThat(subscriber.takeValue().response().body()).isEqualTo("Hi");
+    subscriber.assertCompleted();
+  }
+
+  @Test public void resultSuccess404() throws IOException {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+    service.result().unsafeSubscribe(subscriber);
+    assertThat(subscriber.takeValue().response().code()).isEqualTo(404);
+    subscriber.assertCompleted();
+  }
+
+  @Test public void resultFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+    service.result().unsafeSubscribe(subscriber);
+    assertThat(subscriber.takeValue().error()).isInstanceOf(IOException.class);
+    subscriber.assertCompleted();
+  }
+
+  @Test public void resultThrowingInOnNextDeliveredToError() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.result().unsafeSubscribe(new ForwardingSubscriber<Result<String>>(subscriber) {
+      @Override public void onNext(Result<String> value) {
+        throw e;
+      }
+    });
+
+    subscriber.assertError(e);
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleThrowingTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleThrowingTest.java
new file mode 100644
index 000000000..5266a4f44
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleThrowingTest.java
@@ -0,0 +1,234 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+import rx.Single;
+import rx.SingleSubscriber;
+import rx.Subscriber;
+import rx.exceptions.CompositeException;
+import rx.exceptions.Exceptions;
+import rx.plugins.RxJavaErrorHandler;
+import rx.plugins.RxJavaPlugins;
+
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class SingleThrowingTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final TestRule resetRule = new RxJavaPluginsResetRule();
+  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
+
+  interface Service {
+    @GET("/") Single<String> body();
+    @GET("/") Single<Response<String>> response();
+    @GET("/") Single<Result<String>> result();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodyThrowingInOnSuccessDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (!pluginRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+      }
+    });
+
+    RecordingSubscriber<String> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.body().subscribe(new ForwardingObserver<String>(observer) {
+      @Override public void onSuccess(String value) {
+        throw e;
+      }
+    });
+
+    assertThat(pluginRef.get()).isSameAs(e);
+  }
+
+  @Test public void bodyThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (!pluginRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+      }
+    });
+
+    RecordingSubscriber<String> observer = subscriberRule.create();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    final RuntimeException e = new RuntimeException();
+    service.body().subscribe(new ForwardingObserver<String>(observer) {
+      @Override public void onError(Throwable throwable) {
+        if (!errorRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+        throw e;
+      }
+    });
+
+    CompositeException composite = (CompositeException) pluginRef.get();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+
+  @Test public void responseThrowingInOnSuccessDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (!pluginRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+      }
+    });
+
+    RecordingSubscriber<Response<String>> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.response().subscribe(new ForwardingObserver<Response<String>>(observer) {
+      @Override public void onSuccess(Response<String> value) {
+        throw e;
+      }
+    });
+
+    assertThat(pluginRef.get()).isSameAs(e);
+  }
+
+  @Test public void responseThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (!pluginRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+      }
+    });
+
+    RecordingSubscriber<Response<String>> observer = subscriberRule.create();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    final RuntimeException e = new RuntimeException();
+    service.response().subscribe(new ForwardingObserver<Response<String>>(observer) {
+      @Override public void onError(Throwable throwable) {
+        if (!errorRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+        throw e;
+      }
+    });
+
+    CompositeException composite = (CompositeException) pluginRef.get();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+
+  @Test public void resultThrowingInOnSuccessDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (!pluginRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+      }
+    });
+
+    RecordingSubscriber<Result<String>> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.result().subscribe(new ForwardingObserver<Result<String>>(observer) {
+      @Override public void onSuccess(Result<String> value) {
+        throw e;
+      }
+    });
+
+    assertThat(pluginRef.get()).isSameAs(e);
+  }
+
+  @Ignore("Single's contract is onNext|onError so we have no way of triggering this case")
+  @Test public void resultThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (!pluginRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+      }
+    });
+
+    RecordingSubscriber<Result<String>> observer = subscriberRule.create();
+    final RuntimeException first = new RuntimeException();
+    final RuntimeException second = new RuntimeException();
+    service.result().subscribe(new ForwardingObserver<Result<String>>(observer) {
+      @Override public void onSuccess(Result<String> value) {
+        // The only way to trigger onError for Result is if onSuccess throws.
+        throw first;
+      }
+
+      @Override public void onError(Throwable throwable) {
+        throw second;
+      }
+    });
+
+    CompositeException composite = (CompositeException) pluginRef.get();
+    assertThat(composite.getExceptions()).containsExactly(first, second);
+  }
+
+  private static abstract class ForwardingObserver<T> extends SingleSubscriber<T> {
+    private final Subscriber<T> delegate;
+
+    ForwardingObserver(Subscriber<T> delegate) {
+      this.delegate = delegate;
+    }
+
+    @Override public void onSuccess(T value) {
+      delegate.onNext(value);
+      delegate.onCompleted();
+    }
+
+    @Override public void onError(Throwable throwable) {
+      delegate.onError(throwable);
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleWithSchedulerTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleWithSchedulerTest.java
new file mode 100644
index 000000000..5188c0ed9
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleWithSchedulerTest.java
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+import rx.Single;
+import rx.schedulers.TestScheduler;
+
+public final class SingleWithSchedulerTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
+
+  interface Service {
+    @GET("/") Single<String> body();
+    @GET("/") Single<Response<String>> response();
+    @GET("/") Single<Result<String>> result();
+  }
+
+  private final TestScheduler scheduler = new TestScheduler();
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJavaCallAdapterFactory.createWithScheduler(scheduler))
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodyUsesScheduler() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingSubscriber<String> subscriber = subscriberRule.create();
+    service.body().unsafeSubscribe(subscriber);
+    subscriber.assertNoEvents();
+
+    scheduler.triggerActions();
+    subscriber.assertAnyValue().assertCompleted();
+  }
+
+  @Test public void responseUsesScheduler() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+    service.response().unsafeSubscribe(subscriber);
+    subscriber.assertNoEvents();
+
+    scheduler.triggerActions();
+    subscriber.assertAnyValue().assertCompleted();
+  }
+
+  @Test public void resultUsesScheduler() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+    service.result().unsafeSubscribe(subscriber);
+    subscriber.assertNoEvents();
+
+    scheduler.triggerActions();
+    subscriber.assertAnyValue().assertCompleted();
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/StringConverterFactory.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/StringConverterFactory.java
new file mode 100644
index 000000000..c44038d02
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/StringConverterFactory.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import okhttp3.MediaType;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
+
+final class StringConverterFactory extends Converter.Factory {
+  @Override
+  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
+    return new Converter<ResponseBody, String>() {
+      @Override public String convert(ResponseBody value) throws IOException {
+        return value.string();
+      }
+    };
+  }
+
+  @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
+      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+    return new Converter<String, RequestBody>() {
+      @Override public RequestBody convert(String value) throws IOException {
+        return RequestBody.create(MediaType.parse("text/plain"), value);
+      }
+    };
+  }
+}
diff --git a/retrofit-adapters/rxjava2/README.md b/retrofit-adapters/rxjava2/README.md
new file mode 100644
index 000000000..0512f9fbb
--- /dev/null
+++ b/retrofit-adapters/rxjava2/README.md
@@ -0,0 +1,64 @@
+RxJava2 Adapter
+==============
+
+An `Adapter` for adapting [RxJava 2.x][1] types.
+
+Available types:
+
+ * `Observable<T>`, `Observable<Response<T>>`, and `Observable<Result<T>>` where `T` is the body type.
+ * `Flowable<T>`, `Flowable<Response<T>>` and `Flowable<Result<T>>` where `T` is the body type.
+ * `Single<T>`, `Single<Response<T>>`, and `Single<Result<T>>`  where `T` is the body type.
+ * `Maybe<T>`, `Maybe<Response<T>>`, and `Maybe<Result<T>>`  where `T` is the body type.
+ * `Completable` where response bodies are discarded.
+
+
+Usage
+-----
+
+Add `RxJava2CallAdapterFactory` as a `Call` adapter when building your `Retrofit` instance:
+```java
+Retrofit retrofit = new Retrofit.Builder()
+    .baseUrl("https://example.com/")
+    .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
+    .build();
+```
+
+Your service methods can now use any of the above types as their return type.
+```java
+interface MyService {
+  @GET("/user")
+  Observable<User> getUser();
+}
+```
+
+By default all reactive types execute their requests synchronously. There are multiple ways to
+control the threading on which a request occurs:
+
+ * Call `subscribeOn` on the returned reactive type with a `Scheduler` of your choice.
+ * Use `createAsync()` when creating the factory which will use OkHttp's internal thread pool.
+ * Use `createWithScheduler(Scheduler)` to supply a default subscription `Scheduler`.
+
+Download
+--------
+
+Download [the latest JAR][2] or grab via [Maven][3]:
+```xml
+<dependency>
+  <groupId>com.squareup.retrofit2</groupId>
+  <artifactId>adapter-rxjava2</artifactId>
+  <version>latest.version</version>
+</dependency>
+```
+or [Gradle][3]:
+```groovy
+compile 'com.squareup.retrofit2:adapter-rxjava2:latest.version'
+```
+
+Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
+
+
+
+ [1]: https://github.com/ReactiveX/RxJava/tree/2.x
+ [2]: https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=adapter-rxjava2&v=LATEST
+ [3]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup.retrofit2%22%20a%3A%22adapter-rxjava2%22
+ [snap]: https://oss.sonatype.org/content/repositories/snapshots/
diff --git a/retrofit-adapters/rxjava2/pom.xml b/retrofit-adapters/rxjava2/pom.xml
new file mode 100644
index 000000000..5f1953a9a
--- /dev/null
+++ b/retrofit-adapters/rxjava2/pom.xml
@@ -0,0 +1,69 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.retrofit2</groupId>
+    <artifactId>retrofit-adapters</artifactId>
+    <version>2.4.1-SNAPSHOT</version>
+    <relativePath>../pom.xml</relativePath>
+  </parent>
+
+  <artifactId>adapter-rxjava2</artifactId>
+  <name>Adapter: RxJava 2</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>retrofit</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>io.reactivex.rxjava2</groupId>
+      <artifactId>rxjava</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.assertj</groupId>
+      <artifactId>assertj-core</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp3</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-jar-plugin</artifactId>
+        <configuration>
+          <archive>
+            <manifestEntries>
+              <Automatic-Module-Name>retrofit2.adapter.rxjava2</Automatic-Module-Name>
+            </manifestEntries>
+          </archive>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/BodyObservable.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/BodyObservable.java
new file mode 100644
index 000000000..c3f475604
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/BodyObservable.java
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2016 Jake Wharton
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Observable;
+import io.reactivex.Observer;
+import io.reactivex.disposables.Disposable;
+import io.reactivex.exceptions.CompositeException;
+import io.reactivex.exceptions.Exceptions;
+import io.reactivex.plugins.RxJavaPlugins;
+import retrofit2.Response;
+
+final class BodyObservable<T> extends Observable<T> {
+  private final Observable<Response<T>> upstream;
+
+  BodyObservable(Observable<Response<T>> upstream) {
+    this.upstream = upstream;
+  }
+
+  @Override protected void subscribeActual(Observer<? super T> observer) {
+    upstream.subscribe(new BodyObserver<T>(observer));
+  }
+
+  private static class BodyObserver<R> implements Observer<Response<R>> {
+    private final Observer<? super R> observer;
+    private boolean terminated;
+
+    BodyObserver(Observer<? super R> observer) {
+      this.observer = observer;
+    }
+
+    @Override public void onSubscribe(Disposable disposable) {
+      observer.onSubscribe(disposable);
+    }
+
+    @Override public void onNext(Response<R> response) {
+      if (response.isSuccessful()) {
+        observer.onNext(response.body());
+      } else {
+        terminated = true;
+        Throwable t = new HttpException(response);
+        try {
+          observer.onError(t);
+        } catch (Throwable inner) {
+          Exceptions.throwIfFatal(inner);
+          RxJavaPlugins.onError(new CompositeException(t, inner));
+        }
+      }
+    }
+
+    @Override public void onComplete() {
+      if (!terminated) {
+        observer.onComplete();
+      }
+    }
+
+    @Override public void onError(Throwable throwable) {
+      if (!terminated) {
+        observer.onError(throwable);
+      } else {
+        // This should never happen! onNext handles and forwards errors automatically.
+        Throwable broken = new AssertionError(
+            "This should never happen! Report as a bug with the full stacktrace.");
+        //noinspection UnnecessaryInitCause Two-arg AssertionError constructor is 1.7+ only.
+        broken.initCause(throwable);
+        RxJavaPlugins.onError(broken);
+      }
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallEnqueueObservable.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallEnqueueObservable.java
new file mode 100644
index 000000000..8c7dc4ebc
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallEnqueueObservable.java
@@ -0,0 +1,98 @@
+/*
+ * Copyright (C) 2016 Jake Wharton
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Observable;
+import io.reactivex.Observer;
+import io.reactivex.disposables.Disposable;
+import io.reactivex.exceptions.CompositeException;
+import io.reactivex.exceptions.Exceptions;
+import io.reactivex.plugins.RxJavaPlugins;
+import retrofit2.Call;
+import retrofit2.Callback;
+import retrofit2.Response;
+
+final class CallEnqueueObservable<T> extends Observable<Response<T>> {
+  private final Call<T> originalCall;
+
+  CallEnqueueObservable(Call<T> originalCall) {
+    this.originalCall = originalCall;
+  }
+
+  @Override protected void subscribeActual(Observer<? super Response<T>> observer) {
+    // Since Call is a one-shot type, clone it for each new observer.
+    Call<T> call = originalCall.clone();
+    CallCallback<T> callback = new CallCallback<>(call, observer);
+    observer.onSubscribe(callback);
+    call.enqueue(callback);
+  }
+
+  private static final class CallCallback<T> implements Disposable, Callback<T> {
+    private final Call<?> call;
+    private final Observer<? super Response<T>> observer;
+    private volatile boolean disposed;
+    boolean terminated = false;
+
+    CallCallback(Call<?> call, Observer<? super Response<T>> observer) {
+      this.call = call;
+      this.observer = observer;
+    }
+
+    @Override public void onResponse(Call<T> call, Response<T> response) {
+      if (disposed) return;
+
+      try {
+        observer.onNext(response);
+
+        if (!disposed) {
+          terminated = true;
+          observer.onComplete();
+        }
+      } catch (Throwable t) {
+        if (terminated) {
+          RxJavaPlugins.onError(t);
+        } else if (!disposed) {
+          try {
+            observer.onError(t);
+          } catch (Throwable inner) {
+            Exceptions.throwIfFatal(inner);
+            RxJavaPlugins.onError(new CompositeException(t, inner));
+          }
+        }
+      }
+    }
+
+    @Override public void onFailure(Call<T> call, Throwable t) {
+      if (call.isCanceled()) return;
+
+      try {
+        observer.onError(t);
+      } catch (Throwable inner) {
+        Exceptions.throwIfFatal(inner);
+        RxJavaPlugins.onError(new CompositeException(t, inner));
+      }
+    }
+
+    @Override public void dispose() {
+      disposed = true;
+      call.cancel();
+    }
+
+    @Override public boolean isDisposed() {
+      return disposed;
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallExecuteObservable.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallExecuteObservable.java
new file mode 100644
index 000000000..b4963e075
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallExecuteObservable.java
@@ -0,0 +1,82 @@
+/*
+ * Copyright (C) 2016 Jake Wharton
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Observable;
+import io.reactivex.Observer;
+import io.reactivex.disposables.Disposable;
+import io.reactivex.exceptions.CompositeException;
+import io.reactivex.exceptions.Exceptions;
+import io.reactivex.plugins.RxJavaPlugins;
+import retrofit2.Call;
+import retrofit2.Response;
+
+final class CallExecuteObservable<T> extends Observable<Response<T>> {
+  private final Call<T> originalCall;
+
+  CallExecuteObservable(Call<T> originalCall) {
+    this.originalCall = originalCall;
+  }
+
+  @Override protected void subscribeActual(Observer<? super Response<T>> observer) {
+    // Since Call is a one-shot type, clone it for each new observer.
+    Call<T> call = originalCall.clone();
+    CallDisposable disposable = new CallDisposable(call);
+    observer.onSubscribe(disposable);
+
+    boolean terminated = false;
+    try {
+      Response<T> response = call.execute();
+      if (!disposable.isDisposed()) {
+        observer.onNext(response);
+      }
+      if (!disposable.isDisposed()) {
+        terminated = true;
+        observer.onComplete();
+      }
+    } catch (Throwable t) {
+      Exceptions.throwIfFatal(t);
+      if (terminated) {
+        RxJavaPlugins.onError(t);
+      } else if (!disposable.isDisposed()) {
+        try {
+          observer.onError(t);
+        } catch (Throwable inner) {
+          Exceptions.throwIfFatal(inner);
+          RxJavaPlugins.onError(new CompositeException(t, inner));
+        }
+      }
+    }
+  }
+
+  private static final class CallDisposable implements Disposable {
+    private final Call<?> call;
+    private volatile boolean disposed;
+
+    CallDisposable(Call<?> call) {
+      this.call = call;
+    }
+
+    @Override public void dispose() {
+      disposed = true;
+      call.cancel();
+    }
+
+    @Override public boolean isDisposed() {
+      return disposed;
+    }
+  }
+}
diff --git a/retrofit/src/main/java/retrofit2/DeferredRequest.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/HttpException.java
similarity index 61%
rename from retrofit/src/main/java/retrofit2/DeferredRequest.java
rename to retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/HttpException.java
index 37d83711d..6e282e583 100644
--- a/retrofit/src/main/java/retrofit2/DeferredRequest.java
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/HttpException.java
@@ -13,16 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.adapter.rxjava2;
 
-import com.squareup.okhttp.Request;
-import java.io.IOException;
+import retrofit2.Response;
 
-/**
- * An un-built HTTP request. This class defers any work necessary to create an HTTP request until
- * {@link #get()} is called.
- */
-public interface DeferredRequest {
-  /** Perform the work necessary to create and then return the {@link Request}. */
-  Request get() throws IOException;
+/** @deprecated Use {@link retrofit2.HttpException}. */
+@Deprecated
+public final class HttpException extends retrofit2.HttpException {
+  public HttpException(Response<?> response) {
+    super(response);
+  }
 }
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/Result.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/Result.java
similarity index 69%
rename from retrofit-adapters/rxjava/src/main/java/retrofit2/Result.java
rename to retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/Result.java
index 751b629da..e43d7204f 100644
--- a/retrofit-adapters/rxjava/src/main/java/retrofit2/Result.java
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/Result.java
@@ -13,26 +13,30 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.adapter.rxjava2;
 
 import java.io.IOException;
-
-import static retrofit2.Utils.checkNotNull;
+import javax.annotation.Nullable;
+import retrofit2.Response;
 
 /** The result of executing an HTTP request. */
 public final class Result<T> {
+  @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
   public static <T> Result<T> error(Throwable error) {
-    return new Result<>(null, checkNotNull(error, "error == null"));
+    if (error == null) throw new NullPointerException("error == null");
+    return new Result<>(null, error);
   }
 
+  @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
   public static <T> Result<T> response(Response<T> response) {
-    return new Result<>(checkNotNull(response, "response == null"), null);
+    if (response == null) throw new NullPointerException("response == null");
+    return new Result<>(response, null);
   }
 
-  private final Response<T> response;
-  private final Throwable error;
+  private final @Nullable Response<T> response;
+  private final @Nullable Throwable error;
 
-  Result(Response<T> response, Throwable error) {
+  private Result(@Nullable Response<T> response, @Nullable Throwable error) {
     this.response = response;
     this.error = error;
   }
@@ -41,7 +45,7 @@
    * The response received from executing an HTTP request. Only present when {@link #isError()} is
    * false, null otherwise.
    */
-  public Response<T> response() {
+  public @Nullable Response<T> response() {
     return response;
   }
 
@@ -53,7 +57,7 @@
    * remote server. Any other exception type indicates an unexpected failure and should be
    * considered fatal (configuration error, programming error, etc.).
    */
-  public Throwable error() {
+  public @Nullable Throwable error() {
     return error;
   }
 
diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/ResultObservable.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/ResultObservable.java
new file mode 100644
index 000000000..4fb08fbd0
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/ResultObservable.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2016 Jake Wharton
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Observable;
+import io.reactivex.Observer;
+import io.reactivex.disposables.Disposable;
+import io.reactivex.exceptions.CompositeException;
+import io.reactivex.exceptions.Exceptions;
+import io.reactivex.plugins.RxJavaPlugins;
+import retrofit2.Response;
+
+final class ResultObservable<T> extends Observable<Result<T>> {
+  private final Observable<Response<T>> upstream;
+
+  ResultObservable(Observable<Response<T>> upstream) {
+    this.upstream = upstream;
+  }
+
+  @Override protected void subscribeActual(Observer<? super Result<T>> observer) {
+    upstream.subscribe(new ResultObserver<T>(observer));
+  }
+
+  private static class ResultObserver<R> implements Observer<Response<R>> {
+    private final Observer<? super Result<R>> observer;
+
+    ResultObserver(Observer<? super Result<R>> observer) {
+      this.observer = observer;
+    }
+
+    @Override public void onSubscribe(Disposable disposable) {
+      observer.onSubscribe(disposable);
+    }
+
+    @Override public void onNext(Response<R> response) {
+      observer.onNext(Result.response(response));
+    }
+
+    @Override public void onError(Throwable throwable) {
+      try {
+        observer.onNext(Result.<R>error(throwable));
+      } catch (Throwable t) {
+        try {
+          observer.onError(t);
+        } catch (Throwable inner) {
+          Exceptions.throwIfFatal(inner);
+          RxJavaPlugins.onError(new CompositeException(t, inner));
+        }
+        return;
+      }
+      observer.onComplete();
+    }
+
+    @Override public void onComplete() {
+      observer.onComplete();
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapter.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapter.java
new file mode 100644
index 000000000..eccd30da3
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapter.java
@@ -0,0 +1,88 @@
+/*
+ * Copyright (C) 2016 Jake Wharton
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.BackpressureStrategy;
+import io.reactivex.Observable;
+import io.reactivex.Scheduler;
+import java.lang.reflect.Type;
+import javax.annotation.Nullable;
+import retrofit2.Call;
+import retrofit2.CallAdapter;
+import retrofit2.Response;
+
+final class RxJava2CallAdapter<R> implements CallAdapter<R, Object> {
+  private final Type responseType;
+  private final @Nullable Scheduler scheduler;
+  private final boolean isAsync;
+  private final boolean isResult;
+  private final boolean isBody;
+  private final boolean isFlowable;
+  private final boolean isSingle;
+  private final boolean isMaybe;
+  private final boolean isCompletable;
+
+  RxJava2CallAdapter(Type responseType, @Nullable Scheduler scheduler, boolean isAsync,
+      boolean isResult, boolean isBody, boolean isFlowable, boolean isSingle, boolean isMaybe,
+      boolean isCompletable) {
+    this.responseType = responseType;
+    this.scheduler = scheduler;
+    this.isAsync = isAsync;
+    this.isResult = isResult;
+    this.isBody = isBody;
+    this.isFlowable = isFlowable;
+    this.isSingle = isSingle;
+    this.isMaybe = isMaybe;
+    this.isCompletable = isCompletable;
+  }
+
+  @Override public Type responseType() {
+    return responseType;
+  }
+
+  @Override public Object adapt(Call<R> call) {
+    Observable<Response<R>> responseObservable = isAsync
+        ? new CallEnqueueObservable<>(call)
+        : new CallExecuteObservable<>(call);
+
+    Observable<?> observable;
+    if (isResult) {
+      observable = new ResultObservable<>(responseObservable);
+    } else if (isBody) {
+      observable = new BodyObservable<>(responseObservable);
+    } else {
+      observable = responseObservable;
+    }
+
+    if (scheduler != null) {
+      observable = observable.subscribeOn(scheduler);
+    }
+
+    if (isFlowable) {
+      return observable.toFlowable(BackpressureStrategy.LATEST);
+    }
+    if (isSingle) {
+      return observable.singleOrError();
+    }
+    if (isMaybe) {
+      return observable.singleElement();
+    }
+    if (isCompletable) {
+      return observable.ignoreElements();
+    }
+    return observable;
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactory.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactory.java
new file mode 100644
index 000000000..8af54c505
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactory.java
@@ -0,0 +1,145 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Completable;
+import io.reactivex.Flowable;
+import io.reactivex.Maybe;
+import io.reactivex.Observable;
+import io.reactivex.Scheduler;
+import io.reactivex.Single;
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import javax.annotation.Nullable;
+import retrofit2.CallAdapter;
+import retrofit2.HttpException;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+
+/**
+ * A {@linkplain CallAdapter.Factory call adapter} which uses RxJava 2 for creating observables.
+ * <p>
+ * Adding this class to {@link Retrofit} allows you to return an {@link Observable},
+ * {@link Flowable}, {@link Single}, {@link Completable} or {@link Maybe} from service methods.
+ * <pre><code>
+ * interface MyService {
+ *   &#64;GET("user/me")
+ *   Observable&lt;User&gt; getUser()
+ * }
+ * </code></pre>
+ * There are three configurations supported for the {@code Observable}, {@code Flowable},
+ * {@code Single}, {@link Completable} and {@code Maybe} type parameter:
+ * <ul>
+ * <li>Direct body (e.g., {@code Observable<User>}) calls {@code onNext} with the deserialized body
+ * for 2XX responses and calls {@code onError} with {@link HttpException} for non-2XX responses and
+ * {@link IOException} for network errors.</li>
+ * <li>Response wrapped body (e.g., {@code Observable<Response<User>>}) calls {@code onNext}
+ * with a {@link Response} object for all HTTP responses and calls {@code onError} with
+ * {@link IOException} for network errors</li>
+ * <li>Result wrapped body (e.g., {@code Observable<Result<User>>}) calls {@code onNext} with a
+ * {@link Result} object for all HTTP responses and errors.</li>
+ * </ul>
+ */
+public final class RxJava2CallAdapterFactory extends CallAdapter.Factory {
+  /**
+   * Returns an instance which creates synchronous observables that do not operate on any scheduler
+   * by default.
+   */
+  public static RxJava2CallAdapterFactory create() {
+    return new RxJava2CallAdapterFactory(null, false);
+  }
+
+  /**
+   * Returns an instance which creates asynchronous observables. Applying
+   * {@link Observable#subscribeOn} has no effect on stream types created by this factory.
+   */
+  public static RxJava2CallAdapterFactory createAsync() {
+    return new RxJava2CallAdapterFactory(null, true);
+  }
+
+  /**
+   * Returns an instance which creates synchronous observables that
+   * {@linkplain Observable#subscribeOn(Scheduler) subscribe on} {@code scheduler} by default.
+   */
+  @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
+  public static RxJava2CallAdapterFactory createWithScheduler(Scheduler scheduler) {
+    if (scheduler == null) throw new NullPointerException("scheduler == null");
+    return new RxJava2CallAdapterFactory(scheduler, false);
+  }
+
+  private final @Nullable Scheduler scheduler;
+  private final boolean isAsync;
+
+  private RxJava2CallAdapterFactory(@Nullable Scheduler scheduler, boolean isAsync) {
+    this.scheduler = scheduler;
+    this.isAsync = isAsync;
+  }
+
+  @Override
+  public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+    Class<?> rawType = getRawType(returnType);
+
+    if (rawType == Completable.class) {
+      // Completable is not parameterized (which is what the rest of this method deals with) so it
+      // can only be created with a single configuration.
+      return new RxJava2CallAdapter(Void.class, scheduler, isAsync, false, true, false, false,
+          false, true);
+    }
+
+    boolean isFlowable = rawType == Flowable.class;
+    boolean isSingle = rawType == Single.class;
+    boolean isMaybe = rawType == Maybe.class;
+    if (rawType != Observable.class && !isFlowable && !isSingle && !isMaybe) {
+      return null;
+    }
+
+    boolean isResult = false;
+    boolean isBody = false;
+    Type responseType;
+    if (!(returnType instanceof ParameterizedType)) {
+      String name = isFlowable ? "Flowable"
+          : isSingle ? "Single"
+          : isMaybe ? "Maybe" : "Observable";
+      throw new IllegalStateException(name + " return type must be parameterized"
+          + " as " + name + "<Foo> or " + name + "<? extends Foo>");
+    }
+
+    Type observableType = getParameterUpperBound(0, (ParameterizedType) returnType);
+    Class<?> rawObservableType = getRawType(observableType);
+    if (rawObservableType == Response.class) {
+      if (!(observableType instanceof ParameterizedType)) {
+        throw new IllegalStateException("Response must be parameterized"
+            + " as Response<Foo> or Response<? extends Foo>");
+      }
+      responseType = getParameterUpperBound(0, (ParameterizedType) observableType);
+    } else if (rawObservableType == Result.class) {
+      if (!(observableType instanceof ParameterizedType)) {
+        throw new IllegalStateException("Result must be parameterized"
+            + " as Result<Foo> or Result<? extends Foo>");
+      }
+      responseType = getParameterUpperBound(0, (ParameterizedType) observableType);
+      isResult = true;
+    } else {
+      responseType = observableType;
+      isBody = true;
+    }
+
+    return new RxJava2CallAdapter(responseType, scheduler, isAsync, isResult, isBody, isFlowable,
+        isSingle, isMaybe, false);
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/package-info.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/package-info.java
new file mode 100644
index 000000000..c5fc01992
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/package-info.java
@@ -0,0 +1,4 @@
+@ParametersAreNonnullByDefault
+package retrofit2.adapter.rxjava2;
+
+import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/AsyncTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/AsyncTest.java
new file mode 100644
index 000000000..d008a5e70
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/AsyncTest.java
@@ -0,0 +1,133 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Completable;
+import io.reactivex.exceptions.CompositeException;
+import io.reactivex.exceptions.Exceptions;
+import io.reactivex.functions.Consumer;
+import io.reactivex.observers.TestObserver;
+import io.reactivex.plugins.RxJavaPlugins;
+import java.io.IOException;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Retrofit;
+import retrofit2.adapter.rxjava2.CompletableThrowingTest.ForwardingCompletableObserver;
+import retrofit2.http.GET;
+
+import static java.util.concurrent.TimeUnit.SECONDS;
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertFalse;
+
+public final class AsyncTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  interface Service {
+    @GET("/") Completable completable();
+  }
+
+  private Service service;
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addCallAdapterFactory(RxJava2CallAdapterFactory.createAsync())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void success() throws InterruptedException {
+    TestObserver<Void> observer = new TestObserver<>();
+    service.completable().subscribe(observer);
+    assertFalse(observer.await(1, SECONDS));
+
+    server.enqueue(new MockResponse());
+    observer.awaitTerminalEvent(1, SECONDS);
+    observer.assertComplete();
+  }
+
+
+  @Test public void failure() throws InterruptedException {
+    TestObserver<Void> observer = new TestObserver<>();
+    service.completable().subscribe(observer);
+    assertFalse(observer.await(1, SECONDS));
+
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+    observer.awaitTerminalEvent(1, SECONDS);
+    observer.assertError(IOException.class);
+  }
+
+  @Test public void throwingInOnCompleteDeliveredToPlugin() throws InterruptedException {
+    server.enqueue(new MockResponse());
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!errorRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+        latch.countDown();
+      }
+    });
+
+    TestObserver<Void> observer = new TestObserver<>();
+    final RuntimeException e = new RuntimeException();
+    service.completable().subscribe(new ForwardingCompletableObserver(observer) {
+      @Override public void onComplete() {
+        throw e;
+      }
+    });
+
+    latch.await(1, SECONDS);
+    assertThat(errorRef.get()).isSameAs(e);
+  }
+
+  @Test public void bodyThrowingInOnErrorDeliveredToPlugin() throws InterruptedException {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!pluginRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+        latch.countDown();
+      }
+    });
+
+    TestObserver<Void> observer = new TestObserver<>();
+    final RuntimeException e = new RuntimeException();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    service.completable().subscribe(new ForwardingCompletableObserver(observer) {
+      @Override public void onError(Throwable throwable) {
+        errorRef.set(throwable);
+        throw e;
+      }
+    });
+
+    latch.await(1, SECONDS);
+    //noinspection ThrowableResultOfMethodCallIgnored
+    CompositeException composite = (CompositeException) pluginRef.get();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CancelDisposeTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CancelDisposeTest.java
new file mode 100644
index 000000000..d643e4eb1
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CancelDisposeTest.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Observable;
+import io.reactivex.disposables.Disposable;
+import java.util.List;
+import okhttp3.Call;
+import okhttp3.OkHttpClient;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+public final class CancelDisposeTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  interface Service {
+    @GET("/") Observable<String> go();
+  }
+
+  private final OkHttpClient client = new OkHttpClient();
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJava2CallAdapterFactory.createAsync())
+        .callFactory(client)
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void disposeCancelsCall() {
+    Disposable disposable = service.go().subscribe();
+    List<Call> calls = client.dispatcher().runningCalls();
+    assertEquals(1, calls.size());
+    disposable.dispose();
+    assertTrue(calls.get(0).isCanceled());
+  }
+
+  @Test public void cancelDoesNotDispose() {
+    Disposable disposable = service.go().subscribe();
+    List<Call> calls = client.dispatcher().runningCalls();
+    assertEquals(1, calls.size());
+    calls.get(0).cancel();
+    assertFalse(disposable.isDisposed());
+  }
+}
+
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CompletableTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CompletableTest.java
new file mode 100644
index 000000000..999cf31bd
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CompletableTest.java
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Completable;
+import java.io.IOException;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+
+public final class CompletableTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final RecordingCompletableObserver.Rule observerRule =
+      new RecordingCompletableObserver.Rule();
+
+  interface Service {
+    @GET("/") Completable completable();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void completableSuccess200() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingCompletableObserver observer = observerRule.create();
+    service.completable().subscribe(observer);
+    observer.assertComplete();
+  }
+
+  @Test public void completableSuccess404() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    RecordingCompletableObserver observer = observerRule.create();
+    service.completable().subscribe(observer);
+    // Required for backwards compatibility.
+    observer.assertError(HttpException.class, "HTTP 404 Client Error");
+  }
+
+  @Test public void completableFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    RecordingCompletableObserver observer = observerRule.create();
+    service.completable().subscribe(observer);
+    observer.assertError(IOException.class);
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CompletableThrowingTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CompletableThrowingTest.java
new file mode 100644
index 000000000..6c558b029
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CompletableThrowingTest.java
@@ -0,0 +1,126 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Completable;
+import io.reactivex.CompletableObserver;
+import io.reactivex.disposables.Disposable;
+import io.reactivex.exceptions.CompositeException;
+import io.reactivex.exceptions.Exceptions;
+import io.reactivex.functions.Consumer;
+import io.reactivex.plugins.RxJavaPlugins;
+import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class CompletableThrowingTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final TestRule resetRule = new RxJavaPluginsResetRule();
+  @Rule public final RecordingCompletableObserver.Rule observerRule =
+      new RecordingCompletableObserver.Rule();
+
+  interface Service {
+    @GET("/") Completable completable();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void throwingInOnCompleteDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!errorRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+      }
+    });
+
+    RecordingCompletableObserver observer = observerRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.completable().subscribe(new ForwardingCompletableObserver(observer) {
+      @Override public void onComplete() {
+        throw e;
+      }
+    });
+
+    assertThat(errorRef.get()).isSameAs(e);
+  }
+
+  @Test public void bodyThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!pluginRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+      }
+    });
+
+    RecordingCompletableObserver observer = observerRule.create();
+    final RuntimeException e = new RuntimeException();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    service.completable().subscribe(new ForwardingCompletableObserver(observer) {
+      @Override public void onError(Throwable throwable) {
+        errorRef.set(throwable);
+        throw e;
+      }
+    });
+
+    //noinspection ThrowableResultOfMethodCallIgnored
+    CompositeException composite = (CompositeException) pluginRef.get();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+
+  static abstract class ForwardingCompletableObserver implements CompletableObserver {
+    private final CompletableObserver delegate;
+
+    ForwardingCompletableObserver(CompletableObserver delegate) {
+      this.delegate = delegate;
+    }
+
+    @Override public void onSubscribe(Disposable disposable) {
+      delegate.onSubscribe(disposable);
+    }
+
+    @Override public void onComplete() {
+      delegate.onComplete();
+    }
+
+    @Override public void onError(Throwable throwable) {
+      delegate.onError(throwable);
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CompletableWithSchedulerTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CompletableWithSchedulerTest.java
new file mode 100644
index 000000000..b4a4bc9a2
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CompletableWithSchedulerTest.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Completable;
+import io.reactivex.schedulers.TestScheduler;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+public final class CompletableWithSchedulerTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final RecordingCompletableObserver.Rule observerRule =
+      new RecordingCompletableObserver.Rule();
+
+  interface Service {
+    @GET("/") Completable completable();
+  }
+
+  private final TestScheduler scheduler = new TestScheduler();
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addCallAdapterFactory(RxJava2CallAdapterFactory.createWithScheduler(scheduler))
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void completableUsesScheduler() {
+    server.enqueue(new MockResponse());
+
+    RecordingCompletableObserver observer = observerRule.create();
+    service.completable().subscribe(observer);
+    observer.assertNoEvents();
+
+    scheduler.triggerActions();
+    observer.assertComplete();
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/FlowableTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/FlowableTest.java
new file mode 100644
index 000000000..22efcee2b
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/FlowableTest.java
@@ -0,0 +1,187 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Flowable;
+import java.io.IOException;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class FlowableTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
+
+  interface Service {
+    @GET("/") Flowable<String> body();
+    @GET("/") Flowable<Response<String>> response();
+    @GET("/") Flowable<Result<String>> result();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodySuccess200() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingSubscriber<String> subscriber = subscriberRule.create();
+    service.body().subscribe(subscriber);
+    subscriber.assertValue("Hi").assertComplete();
+  }
+
+  @Test public void bodySuccess404() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    RecordingSubscriber<String> subscriber = subscriberRule.create();
+    service.body().subscribe(subscriber);
+    // Required for backwards compatibility.
+    subscriber.assertError(HttpException.class, "HTTP 404 Client Error");
+  }
+
+  @Test public void bodyFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    RecordingSubscriber<String> subscriber = subscriberRule.create();
+    service.body().subscribe(subscriber);
+    subscriber.assertError(IOException.class);
+  }
+
+  @Test public void bodyRespectsBackpressure() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingSubscriber<String> subscriber = subscriberRule.createWithInitialRequest(0);
+    Flowable<String> o = service.body();
+
+    o.subscribe(subscriber);
+    assertThat(server.getRequestCount()).isEqualTo(1);
+    subscriber.assertNoEvents();
+
+    subscriber.request(1);
+    subscriber.assertAnyValue().assertComplete();
+
+    subscriber.request(Long.MAX_VALUE); // Subsequent requests do not trigger HTTP or notifications.
+    assertThat(server.getRequestCount()).isEqualTo(1);
+  }
+
+  @Test public void responseSuccess200() {
+    server.enqueue(new MockResponse());
+
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+    service.response().subscribe(subscriber);
+    assertThat(subscriber.takeValue().isSuccessful()).isTrue();
+    subscriber.assertComplete();
+  }
+
+  @Test public void responseSuccess404() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+    service.response().subscribe(subscriber);
+    assertThat(subscriber.takeValue().isSuccessful()).isFalse();
+    subscriber.assertComplete();
+  }
+
+  @Test public void responseFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+    service.response().subscribe(subscriber);
+    subscriber.assertError(IOException.class);
+  }
+
+  @Test public void responseRespectsBackpressure() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.createWithInitialRequest(0);
+    Flowable<Response<String>> o = service.response();
+
+    o.subscribe(subscriber);
+    assertThat(server.getRequestCount()).isEqualTo(1);
+    subscriber.assertNoEvents();
+
+    subscriber.request(1);
+    subscriber.assertAnyValue().assertComplete();
+
+    subscriber.request(Long.MAX_VALUE); // Subsequent requests do not trigger HTTP or notifications.
+    assertThat(server.getRequestCount()).isEqualTo(1);
+  }
+
+  @Test public void resultSuccess200() {
+    server.enqueue(new MockResponse());
+
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+    service.result().subscribe(subscriber);
+    Result<String> result = subscriber.takeValue();
+    assertThat(result.isError()).isFalse();
+    assertThat(result.response().isSuccessful()).isTrue();
+    subscriber.assertComplete();
+  }
+
+  @Test public void resultSuccess404() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+    service.result().subscribe(subscriber);
+    Result<String> result = subscriber.takeValue();
+    assertThat(result.isError()).isFalse();
+    assertThat(result.response().isSuccessful()).isFalse();
+    subscriber.assertComplete();
+  }
+
+  @Test public void resultFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+    service.result().subscribe(subscriber);
+    Result<String> result = subscriber.takeValue();
+    assertThat(result.isError()).isTrue();
+    assertThat(result.error()).isInstanceOf(IOException.class);
+    subscriber.assertComplete();
+  }
+
+  @Test public void resultRespectsBackpressure() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.createWithInitialRequest(0);
+    Flowable<Result<String>> o = service.result();
+
+    o.subscribe(subscriber);
+    assertThat(server.getRequestCount()).isEqualTo(1);
+    subscriber.assertNoEvents();
+
+    subscriber.request(1);
+    subscriber.assertAnyValue().assertComplete();
+
+    subscriber.request(Long.MAX_VALUE); // Subsequent requests do not trigger HTTP or notifications.
+    assertThat(server.getRequestCount()).isEqualTo(1);
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/FlowableThrowingTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/FlowableThrowingTest.java
new file mode 100644
index 000000000..34afbbeef
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/FlowableThrowingTest.java
@@ -0,0 +1,288 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Flowable;
+import io.reactivex.exceptions.CompositeException;
+import io.reactivex.exceptions.Exceptions;
+import io.reactivex.functions.Consumer;
+import io.reactivex.plugins.RxJavaPlugins;
+import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import org.reactivestreams.Subscriber;
+import org.reactivestreams.Subscription;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class FlowableThrowingTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final TestRule resetRule = new RxJavaPluginsResetRule();
+  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
+
+  interface Service {
+    @GET("/") Flowable<String> body();
+    @GET("/") Flowable<Response<String>> response();
+    @GET("/") Flowable<Result<String>> result();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodyThrowingInOnNextDeliveredToError() {
+    server.enqueue(new MockResponse());
+
+    RecordingSubscriber<String> subscriber = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.body().safeSubscribe(new ForwardingSubscriber<String>(subscriber) {
+      @Override public void onNext(String value) {
+        throw e;
+      }
+    });
+
+    subscriber.assertError(e);
+  }
+
+  @Test public void bodyThrowingInOnCompleteDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingSubscriber<String> subscriber = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.body().subscribe(new ForwardingSubscriber<String>(subscriber) {
+      @Override public void onComplete() {
+        throw e;
+      }
+    });
+
+    subscriber.assertAnyValue();
+    assertThat(throwableRef.get()).isSameAs(e);
+
+  }
+
+  @Test public void bodyThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingSubscriber<String> subscriber = subscriberRule.create();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    final RuntimeException e = new RuntimeException();
+    service.body().subscribe(new ForwardingSubscriber<String>(subscriber) {
+      @Override public void onError(Throwable throwable) {
+        if (!errorRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+        throw e;
+      }
+    });
+
+    //noinspection ThrowableResultOfMethodCallIgnored
+    CompositeException composite = (CompositeException) throwableRef.get();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+
+  @Test public void responseThrowingInOnNextDeliveredToError() {
+    server.enqueue(new MockResponse());
+
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.response().safeSubscribe(new ForwardingSubscriber<Response<String>>(subscriber) {
+      @Override public void onNext(Response<String> value) {
+        throw e;
+      }
+    });
+
+    subscriber.assertError(e);
+  }
+
+  @Test public void responseThrowingInOnCompleteDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.response().subscribe(new ForwardingSubscriber<Response<String>>(subscriber) {
+      @Override public void onComplete() {
+        throw e;
+      }
+    });
+
+    subscriber.assertAnyValue();
+    assertThat(throwableRef.get()).isSameAs(e);
+  }
+
+  @Test public void responseThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    final RuntimeException e = new RuntimeException();
+    service.response().subscribe(new ForwardingSubscriber<Response<String>>(subscriber) {
+      @Override public void onError(Throwable throwable) {
+        if (!errorRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+        throw e;
+      }
+    });
+
+    //noinspection ThrowableResultOfMethodCallIgnored
+    CompositeException composite = (CompositeException) throwableRef.get();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+
+  @Test public void resultThrowingInOnNextDeliveredToError() {
+    server.enqueue(new MockResponse());
+
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.result().safeSubscribe(new ForwardingSubscriber<Result<String>>(subscriber) {
+      @Override public void onNext(Result<String> value) {
+        throw e;
+      }
+    });
+
+    subscriber.assertError(e);
+  }
+
+  @Test public void resultThrowingInOnCompletedDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.result().subscribe(new ForwardingSubscriber<Result<String>>(subscriber) {
+      @Override public void onComplete() {
+        throw e;
+      }
+    });
+
+    subscriber.assertAnyValue();
+    assertThat(throwableRef.get()).isSameAs(e);
+  }
+
+  @Test public void resultThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+    final RuntimeException first = new RuntimeException();
+    final RuntimeException second = new RuntimeException();
+    service.result().safeSubscribe(new ForwardingSubscriber<Result<String>>(subscriber) {
+      @Override public void onNext(Result<String> value) {
+        // The only way to trigger onError for a result is if onNext throws.
+        throw first;
+      }
+
+      @Override public void onError(Throwable throwable) {
+        throw second;
+      }
+    });
+
+    //noinspection ThrowableResultOfMethodCallIgnored
+    CompositeException composite = (CompositeException) throwableRef.get();
+    assertThat(composite.getExceptions()).containsExactly(first, second);
+  }
+
+  private static abstract class ForwardingSubscriber<T> implements Subscriber<T> {
+    private final Subscriber<T> delegate;
+
+    ForwardingSubscriber(Subscriber<T> delegate) {
+      this.delegate = delegate;
+    }
+
+    @Override public void onSubscribe(Subscription subscription) {
+      delegate.onSubscribe(subscription);
+    }
+
+    @Override public void onNext(T value) {
+      delegate.onNext(value);
+    }
+
+    @Override public void onError(Throwable throwable) {
+      delegate.onError(throwable);
+    }
+
+    @Override public void onComplete() {
+      delegate.onComplete();
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/FlowableWithSchedulerTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/FlowableWithSchedulerTest.java
new file mode 100644
index 000000000..946ff51f1
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/FlowableWithSchedulerTest.java
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Flowable;
+import io.reactivex.schedulers.TestScheduler;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+public final class FlowableWithSchedulerTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
+
+  interface Service {
+    @GET("/") Flowable<String> body();
+    @GET("/") Flowable<Response<String>> response();
+    @GET("/") Flowable<Result<String>> result();
+  }
+
+  private final TestScheduler scheduler = new TestScheduler();
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJava2CallAdapterFactory.createWithScheduler(scheduler))
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodyUsesScheduler() {
+    server.enqueue(new MockResponse());
+
+    RecordingSubscriber<Object> subscriber = subscriberRule.create();
+    service.body().subscribe(subscriber);
+    subscriber.assertNoEvents();
+
+    scheduler.triggerActions();
+    subscriber.assertAnyValue().assertComplete();
+  }
+
+  @Test public void responseUsesScheduler() {
+    server.enqueue(new MockResponse());
+
+    RecordingSubscriber<Object> subscriber = subscriberRule.create();
+    service.response().subscribe(subscriber);
+    subscriber.assertNoEvents();
+
+    scheduler.triggerActions();
+    subscriber.assertAnyValue().assertComplete();
+  }
+
+  @Test public void resultUsesScheduler() {
+    server.enqueue(new MockResponse());
+
+    RecordingSubscriber<Object> subscriber = subscriberRule.create();
+    service.result().subscribe(subscriber);
+    subscriber.assertNoEvents();
+
+    scheduler.triggerActions();
+    subscriber.assertAnyValue().assertComplete();
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/MaybeTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/MaybeTest.java
new file mode 100644
index 000000000..21f69c68a
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/MaybeTest.java
@@ -0,0 +1,133 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Maybe;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+import java.io.IOException;
+
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class MaybeTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final RecordingMaybeObserver.Rule observerRule = new RecordingMaybeObserver.Rule();
+
+  interface Service {
+    @GET("/") Maybe<String> body();
+    @GET("/") Maybe<Response<String>> response();
+    @GET("/") Maybe<Result<String>> result();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodySuccess200() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingMaybeObserver<String> observer = observerRule.create();
+    service.body().subscribe(observer);
+    observer.assertValue("Hi");
+  }
+
+  @Test public void bodySuccess404() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    RecordingMaybeObserver<String> observer = observerRule.create();
+    service.body().subscribe(observer);
+    // Required for backwards compatibility.
+    observer.assertError(HttpException.class, "HTTP 404 Client Error");
+  }
+
+  @Test public void bodyFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    RecordingMaybeObserver<String> observer = observerRule.create();
+    service.body().subscribe(observer);
+    observer.assertError(IOException.class);
+  }
+
+  @Test public void responseSuccess200() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingMaybeObserver<Response<String>> observer = observerRule.create();
+    service.response().subscribe(observer);
+    Response<String> response = observer.takeValue();
+    assertThat(response.isSuccessful()).isTrue();
+  }
+
+  @Test public void responseSuccess404() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    RecordingMaybeObserver<Response<String>> observer = observerRule.create();
+    service.response().subscribe(observer);
+    assertThat(observer.takeValue().isSuccessful()).isFalse();
+  }
+
+  @Test public void responseFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    RecordingMaybeObserver<Response<String>> observer = observerRule.create();
+    service.response().subscribe(observer);
+    observer.assertError(IOException.class);
+  }
+
+  @Test public void resultSuccess200() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingMaybeObserver<Result<String>> observer = observerRule.create();
+    service.result().subscribe(observer);
+    Result<String> result = observer.takeValue();
+    assertThat(result.isError()).isFalse();
+    assertThat(result.response().isSuccessful()).isTrue();
+  }
+
+  @Test public void resultSuccess404() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    RecordingMaybeObserver<Result<String>> observer = observerRule.create();
+    service.result().subscribe(observer);
+    Result<String> result = observer.takeValue();
+    assertThat(result.isError()).isFalse();
+    assertThat(result.response().isSuccessful()).isFalse();
+  }
+
+  @Test public void resultFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    RecordingMaybeObserver<Result<String>> observer = observerRule.create();
+    service.result().subscribe(observer);
+    Result<String> result = observer.takeValue();
+    assertThat(result.isError()).isTrue();
+    assertThat(result.error()).isInstanceOf(IOException.class);
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/MaybeThrowingTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/MaybeThrowingTest.java
new file mode 100644
index 000000000..d5f83e1bd
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/MaybeThrowingTest.java
@@ -0,0 +1,245 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Maybe;
+import io.reactivex.MaybeObserver;
+import io.reactivex.disposables.Disposable;
+import io.reactivex.exceptions.CompositeException;
+import io.reactivex.exceptions.Exceptions;
+import io.reactivex.functions.Consumer;
+import io.reactivex.plugins.RxJavaPlugins;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+import java.util.concurrent.atomic.AtomicReference;
+
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class MaybeThrowingTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final TestRule resetRule = new RxJavaPluginsResetRule();
+  @Rule public final RecordingMaybeObserver.Rule subscriberRule = new RecordingMaybeObserver.Rule();
+
+  interface Service {
+    @GET("/") Maybe<String> body();
+    @GET("/") Maybe<Response<String>> response();
+    @GET("/") Maybe<Result<String>> result();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodyThrowingInOnSuccessDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingMaybeObserver<String> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.body().subscribe(new ForwardingObserver<String>(observer) {
+      @Override public void onSuccess(String value) {
+        throw e;
+      }
+    });
+
+    assertThat(throwableRef.get()).isSameAs(e);
+  }
+
+  @Test public void bodyThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingMaybeObserver<String> observer = subscriberRule.create();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    final RuntimeException e = new RuntimeException();
+    service.body().subscribe(new ForwardingObserver<String>(observer) {
+      @Override public void onError(Throwable throwable) {
+        if (!errorRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+        throw e;
+      }
+    });
+
+    //noinspection ThrowableResultOfMethodCallIgnored
+    CompositeException composite = (CompositeException) throwableRef.get();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+
+  @Test public void responseThrowingInOnSuccessDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingMaybeObserver<Response<String>> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.response().subscribe(new ForwardingObserver<Response<String>>(observer) {
+      @Override public void onSuccess(Response<String> value) {
+        throw e;
+      }
+    });
+
+    assertThat(throwableRef.get()).isSameAs(e);
+  }
+
+  @Test public void responseThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingMaybeObserver<Response<String>> observer = subscriberRule.create();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    final RuntimeException e = new RuntimeException();
+    service.response().subscribe(new ForwardingObserver<Response<String>>(observer) {
+      @Override public void onError(Throwable throwable) {
+        if (!errorRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+        throw e;
+      }
+    });
+
+    //noinspection ThrowableResultOfMethodCallIgnored
+    CompositeException composite = (CompositeException) throwableRef.get();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+
+  @Test public void resultThrowingInOnSuccessDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingMaybeObserver<Result<String>> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.result().subscribe(new ForwardingObserver<Result<String>>(observer) {
+      @Override public void onSuccess(Result<String> value) {
+        throw e;
+      }
+    });
+
+    assertThat(throwableRef.get()).isSameAs(e);
+  }
+
+  @Ignore("Single's contract is onNext|onError so we have no way of triggering this case")
+  @Test public void resultThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingMaybeObserver<Result<String>> observer = subscriberRule.create();
+    final RuntimeException first = new RuntimeException();
+    final RuntimeException second = new RuntimeException();
+    service.result().subscribe(new ForwardingObserver<Result<String>>(observer) {
+      @Override public void onSuccess(Result<String> value) {
+        // The only way to trigger onError for Result is if onSuccess throws.
+        throw first;
+      }
+
+      @Override public void onError(Throwable throwable) {
+        throw second;
+      }
+    });
+
+    //noinspection ThrowableResultOfMethodCallIgnored
+    CompositeException composite = (CompositeException) throwableRef.get();
+    assertThat(composite.getExceptions()).containsExactly(first, second);
+  }
+
+  private static abstract class ForwardingObserver<T> implements MaybeObserver<T> {
+    private final MaybeObserver<T> delegate;
+
+    ForwardingObserver(MaybeObserver<T> delegate) {
+      this.delegate = delegate;
+    }
+
+    @Override public void onSubscribe(Disposable disposable) {
+      delegate.onSubscribe(disposable);
+    }
+
+    @Override public void onSuccess(T value) {
+      delegate.onSuccess(value);
+    }
+
+    @Override public void onError(Throwable throwable) {
+      delegate.onError(throwable);
+    }
+
+    @Override public void onComplete() {
+      delegate.onComplete();
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/MaybeWithSchedulerTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/MaybeWithSchedulerTest.java
new file mode 100644
index 000000000..53fe60d94
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/MaybeWithSchedulerTest.java
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Maybe;
+import io.reactivex.schedulers.TestScheduler;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+public final class MaybeWithSchedulerTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final RecordingMaybeObserver.Rule observerRule = new RecordingMaybeObserver.Rule();
+
+  interface Service {
+    @GET("/") Maybe<String> body();
+    @GET("/") Maybe<Response<String>> response();
+    @GET("/") Maybe<Result<String>> result();
+  }
+
+  private final TestScheduler scheduler = new TestScheduler();
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJava2CallAdapterFactory.createWithScheduler(scheduler))
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodyUsesScheduler() {
+    server.enqueue(new MockResponse());
+
+    RecordingMaybeObserver<Object> observer = observerRule.create();
+    service.body().subscribe(observer);
+    observer.assertNoEvents();
+
+    scheduler.triggerActions();
+    observer.assertAnyValue();
+  }
+
+  @Test public void responseUsesScheduler() {
+    server.enqueue(new MockResponse());
+
+    RecordingMaybeObserver<Object> observer = observerRule.create();
+    service.response().subscribe(observer);
+    observer.assertNoEvents();
+
+    scheduler.triggerActions();
+    observer.assertAnyValue();
+  }
+
+  @Test public void resultUsesScheduler() {
+    server.enqueue(new MockResponse());
+
+    RecordingMaybeObserver<Object> observer = observerRule.create();
+    service.result().subscribe(observer);
+    observer.assertNoEvents();
+
+    scheduler.triggerActions();
+    observer.assertAnyValue();
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ObservableTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ObservableTest.java
new file mode 100644
index 000000000..e421c1652
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ObservableTest.java
@@ -0,0 +1,136 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Observable;
+import java.io.IOException;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class ObservableTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final RecordingObserver.Rule observerRule = new RecordingObserver.Rule();
+
+  interface Service {
+    @GET("/") Observable<String> body();
+    @GET("/") Observable<Response<String>> response();
+    @GET("/") Observable<Result<String>> result();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodySuccess200() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingObserver<String> observer = observerRule.create();
+    service.body().subscribe(observer);
+    observer.assertValue("Hi").assertComplete();
+  }
+
+  @Test public void bodySuccess404() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    RecordingObserver<String> observer = observerRule.create();
+    service.body().subscribe(observer);
+    // Required for backwards compatibility.
+    observer.assertError(HttpException.class, "HTTP 404 Client Error");
+  }
+
+  @Test public void bodyFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    RecordingObserver<String> observer = observerRule.create();
+    service.body().subscribe(observer);
+    observer.assertError(IOException.class);
+  }
+
+  @Test public void responseSuccess200() {
+    server.enqueue(new MockResponse());
+
+    RecordingObserver<Response<String>> observer = observerRule.create();
+    service.response().subscribe(observer);
+    assertThat(observer.takeValue().isSuccessful()).isTrue();
+    observer.assertComplete();
+  }
+
+  @Test public void responseSuccess404() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    RecordingObserver<Response<String>> observer = observerRule.create();
+    service.response().subscribe(observer);
+    assertThat(observer.takeValue().isSuccessful()).isFalse();
+    observer.assertComplete();
+  }
+
+  @Test public void responseFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    RecordingObserver<Response<String>> observer = observerRule.create();
+    service.response().subscribe(observer);
+    observer.assertError(IOException.class);
+  }
+
+  @Test public void resultSuccess200() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingObserver<Result<String>> observer = observerRule.create();
+    service.result().subscribe(observer);
+    Result<String> result = observer.takeValue();
+    assertThat(result.isError()).isFalse();
+    assertThat(result.response().isSuccessful()).isTrue();
+    observer.assertComplete();
+  }
+
+  @Test public void resultSuccess404() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    RecordingObserver<Result<String>> observer = observerRule.create();
+    service.result().subscribe(observer);
+    Result<String> result = observer.takeValue();
+    assertThat(result.isError()).isFalse();
+    assertThat(result.response().isSuccessful()).isFalse();
+    observer.assertComplete();
+  }
+
+  @Test public void resultFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    RecordingObserver<Result<String>> observer = observerRule.create();
+    service.result().subscribe(observer);
+    Result<String> result = observer.takeValue();
+    assertThat(result.isError()).isTrue();
+    assertThat(result.error()).isInstanceOf(IOException.class);
+    observer.assertComplete();
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ObservableThrowingTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ObservableThrowingTest.java
new file mode 100644
index 000000000..05c1d4f8f
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ObservableThrowingTest.java
@@ -0,0 +1,288 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Observable;
+import io.reactivex.Observer;
+import io.reactivex.disposables.Disposable;
+import io.reactivex.exceptions.CompositeException;
+import io.reactivex.exceptions.Exceptions;
+import io.reactivex.functions.Consumer;
+import io.reactivex.plugins.RxJavaPlugins;
+import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class ObservableThrowingTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final TestRule resetRule = new RxJavaPluginsResetRule();
+  @Rule public final RecordingObserver.Rule subscriberRule = new RecordingObserver.Rule();
+
+  interface Service {
+    @GET("/") Observable<String> body();
+    @GET("/") Observable<Response<String>> response();
+    @GET("/") Observable<Result<String>> result();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodyThrowingInOnNextDeliveredToError() {
+    server.enqueue(new MockResponse());
+
+    RecordingObserver<String> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.body().subscribe(new ForwardingObserver<String>(observer) {
+      @Override public void onNext(String value) {
+        throw e;
+      }
+    });
+
+    observer.assertError(e);
+  }
+
+  @Test public void bodyThrowingInOnCompleteDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingObserver<String> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.body().subscribe(new ForwardingObserver<String>(observer) {
+      @Override public void onComplete() {
+        throw e;
+      }
+    });
+
+    observer.assertAnyValue();
+    assertThat(throwableRef.get()).isSameAs(e);
+
+  }
+
+  @Test public void bodyThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingObserver<String> observer = subscriberRule.create();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    final RuntimeException e = new RuntimeException();
+    service.body().subscribe(new ForwardingObserver<String>(observer) {
+      @Override public void onError(Throwable throwable) {
+        if (!errorRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+        throw e;
+      }
+    });
+
+    //noinspection ThrowableResultOfMethodCallIgnored
+    CompositeException composite = (CompositeException) throwableRef.get();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+
+  @Test public void responseThrowingInOnNextDeliveredToError() {
+    server.enqueue(new MockResponse());
+
+    RecordingObserver<Response<String>> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.response().subscribe(new ForwardingObserver<Response<String>>(observer) {
+      @Override public void onNext(Response<String> value) {
+        throw e;
+      }
+    });
+
+    observer.assertError(e);
+  }
+
+  @Test public void responseThrowingInOnCompleteDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingObserver<Response<String>> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.response().subscribe(new ForwardingObserver<Response<String>>(observer) {
+      @Override public void onComplete() {
+        throw e;
+      }
+    });
+
+    observer.assertAnyValue();
+    assertThat(throwableRef.get()).isSameAs(e);
+  }
+
+  @Test public void responseThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingObserver<Response<String>> observer = subscriberRule.create();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    final RuntimeException e = new RuntimeException();
+    service.response().subscribe(new ForwardingObserver<Response<String>>(observer) {
+      @Override public void onError(Throwable throwable) {
+        if (!errorRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+        throw e;
+      }
+    });
+
+    //noinspection ThrowableResultOfMethodCallIgnored
+    CompositeException composite = (CompositeException) throwableRef.get();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+
+  @Test public void resultThrowingInOnNextDeliveredToError() {
+    server.enqueue(new MockResponse());
+
+    RecordingObserver<Result<String>> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.result().subscribe(new ForwardingObserver<Result<String>>(observer) {
+      @Override public void onNext(Result<String> value) {
+        throw e;
+      }
+    });
+
+    observer.assertError(e);
+  }
+
+  @Test public void resultThrowingInOnCompletedDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingObserver<Result<String>> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.result().subscribe(new ForwardingObserver<Result<String>>(observer) {
+      @Override public void onComplete() {
+        throw e;
+      }
+    });
+
+    observer.assertAnyValue();
+    assertThat(throwableRef.get()).isSameAs(e);
+  }
+
+  @Test public void resultThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingObserver<Result<String>> observer = subscriberRule.create();
+    final RuntimeException first = new RuntimeException();
+    final RuntimeException second = new RuntimeException();
+    service.result().subscribe(new ForwardingObserver<Result<String>>(observer) {
+      @Override public void onNext(Result<String> value) {
+        // The only way to trigger onError for a result is if onNext throws.
+        throw first;
+      }
+
+      @Override public void onError(Throwable throwable) {
+        throw second;
+      }
+    });
+
+    //noinspection ThrowableResultOfMethodCallIgnored
+    CompositeException composite = (CompositeException) throwableRef.get();
+    assertThat(composite.getExceptions()).containsExactly(first, second);
+  }
+
+  private static abstract class ForwardingObserver<T> implements Observer<T> {
+    private final Observer<T> delegate;
+
+    ForwardingObserver(Observer<T> delegate) {
+      this.delegate = delegate;
+    }
+
+    @Override public void onSubscribe(Disposable disposable) {
+      delegate.onSubscribe(disposable);
+    }
+
+    @Override public void onNext(T value) {
+      delegate.onNext(value);
+    }
+
+    @Override public void onError(Throwable throwable) {
+      delegate.onError(throwable);
+    }
+
+    @Override public void onComplete() {
+      delegate.onComplete();
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ObservableWithSchedulerTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ObservableWithSchedulerTest.java
new file mode 100644
index 000000000..2379f2835
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ObservableWithSchedulerTest.java
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Observable;
+import io.reactivex.schedulers.TestScheduler;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+public final class ObservableWithSchedulerTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final RecordingObserver.Rule observerRule = new RecordingObserver.Rule();
+
+  interface Service {
+    @GET("/") Observable<String> body();
+    @GET("/") Observable<Response<String>> response();
+    @GET("/") Observable<Result<String>> result();
+  }
+
+  private final TestScheduler scheduler = new TestScheduler();
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJava2CallAdapterFactory.createWithScheduler(scheduler))
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodyUsesScheduler() {
+    server.enqueue(new MockResponse());
+
+    RecordingObserver<Object> observer = observerRule.create();
+    service.body().subscribe(observer);
+    observer.assertNoEvents();
+
+    scheduler.triggerActions();
+    observer.assertAnyValue().assertComplete();
+  }
+
+  @Test public void responseUsesScheduler() {
+    server.enqueue(new MockResponse());
+
+    RecordingObserver<Object> observer = observerRule.create();
+    service.response().subscribe(observer);
+    observer.assertNoEvents();
+
+    scheduler.triggerActions();
+    observer.assertAnyValue().assertComplete();
+  }
+
+  @Test public void resultUsesScheduler() {
+    server.enqueue(new MockResponse());
+
+    RecordingObserver<Object> observer = observerRule.create();
+    service.result().subscribe(observer);
+    observer.assertNoEvents();
+
+    scheduler.triggerActions();
+    observer.assertAnyValue().assertComplete();
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RecordingCompletableObserver.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RecordingCompletableObserver.java
new file mode 100644
index 000000000..de7c93055
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RecordingCompletableObserver.java
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.CompletableObserver;
+import io.reactivex.Notification;
+import io.reactivex.disposables.Disposable;
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Deque;
+import java.util.List;
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+/** A test {@link CompletableObserver} and JUnit rule which guarantees all events are asserted. */
+final class RecordingCompletableObserver implements CompletableObserver {
+  private final Deque<Notification<?>> events = new ArrayDeque<>();
+
+  private RecordingCompletableObserver() {
+  }
+
+  @Override public void onSubscribe(Disposable disposable) {
+  }
+
+  @Override public void onComplete() {
+    events.add(Notification.createOnComplete());
+  }
+
+  @Override public void onError(Throwable e) {
+    events.add(Notification.createOnError(e));
+  }
+
+  private Notification<?> takeNotification() {
+    Notification<?> notification = events.pollFirst();
+    if (notification == null) {
+      throw new AssertionError("No event found!");
+    }
+    return notification;
+  }
+
+  public Throwable takeError() {
+    Notification<?> notification = takeNotification();
+    assertThat(notification.isOnError())
+        .as("Expected onError event but was " + notification)
+        .isTrue();
+    return notification.getError();
+  }
+
+  public void assertComplete() {
+    Notification<?> notification = takeNotification();
+    assertThat(notification.isOnComplete())
+        .as("Expected onCompleted event but was " + notification)
+        .isTrue();
+    assertNoEvents();
+  }
+
+  public void assertError(Throwable throwable) {
+    assertThat(takeError()).isEqualTo(throwable);
+  }
+
+  public void assertError(Class<? extends Throwable> errorClass) {
+    assertError(errorClass, null);
+  }
+
+  public void assertError(Class<? extends Throwable> errorClass, String message) {
+    Throwable throwable = takeError();
+    assertThat(throwable).isInstanceOf(errorClass);
+    if (message != null) {
+      assertThat(throwable).hasMessage(message);
+    }
+    assertNoEvents();
+  }
+
+  public void assertNoEvents() {
+    assertThat(events).as("Unconsumed events found!").isEmpty();
+  }
+
+  public static final class Rule implements TestRule {
+    final List<RecordingCompletableObserver> subscribers = new ArrayList<>();
+
+    public <T> RecordingCompletableObserver create() {
+      RecordingCompletableObserver subscriber = new RecordingCompletableObserver();
+      subscribers.add(subscriber);
+      return subscriber;
+    }
+
+    @Override public Statement apply(final Statement base, Description description) {
+      return new Statement() {
+        @Override public void evaluate() throws Throwable {
+          base.evaluate();
+          for (RecordingCompletableObserver subscriber : subscribers) {
+            subscriber.assertNoEvents();
+          }
+        }
+      };
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RecordingMaybeObserver.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RecordingMaybeObserver.java
new file mode 100644
index 000000000..63d34499f
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RecordingMaybeObserver.java
@@ -0,0 +1,130 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.MaybeObserver;
+import io.reactivex.Notification;
+import io.reactivex.Observer;
+import io.reactivex.disposables.Disposable;
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Deque;
+import java.util.List;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+/** A test {@link Observer} and JUnit rule which guarantees all events are asserted. */
+final class RecordingMaybeObserver<T> implements MaybeObserver<T> {
+  private final Deque<Notification<T>> events = new ArrayDeque<>();
+
+  private RecordingMaybeObserver() {
+  }
+
+  @Override public void onSubscribe(Disposable disposable) {
+  }
+
+  @Override public void onSuccess(T value) {
+    events.add(Notification.createOnNext(value));
+  }
+
+  @Override public void onError(Throwable e) {
+    events.add(Notification.<T>createOnError(e));
+  }
+
+  @Override public void onComplete() {
+    events.add(Notification.<T>createOnComplete());
+  }
+
+  private Notification<T> takeNotification() {
+    Notification<T> notification = events.pollFirst();
+    if (notification == null) {
+      throw new AssertionError("No event found!");
+    }
+    return notification;
+  }
+
+  public T takeValue() {
+    Notification<T> notification = takeNotification();
+    assertThat(notification.isOnNext())
+        .as("Expected onNext event but was " + notification)
+        .isTrue();
+    return notification.getValue();
+  }
+
+  public Throwable takeError() {
+    Notification<T> notification = takeNotification();
+    assertThat(notification.isOnError())
+        .as("Expected onError event but was " + notification)
+        .isTrue();
+    return notification.getError();
+  }
+
+  public RecordingMaybeObserver<T> assertAnyValue() {
+    takeValue();
+    return this;
+  }
+
+  public RecordingMaybeObserver<T> assertValue(T value) {
+    assertThat(takeValue()).isEqualTo(value);
+    return this;
+  }
+
+  public void assertError(Throwable throwable) {
+    assertThat(takeError()).isEqualTo(throwable);
+  }
+
+  public void assertError(Class<? extends Throwable> errorClass) {
+    assertError(errorClass, null);
+  }
+
+  public void assertError(Class<? extends Throwable> errorClass, String message) {
+    Throwable throwable = takeError();
+    assertThat(throwable).isInstanceOf(errorClass);
+    if (message != null) {
+      assertThat(throwable).hasMessage(message);
+    }
+    assertNoEvents();
+  }
+
+  public void assertNoEvents() {
+    assertThat(events).as("Unconsumed events found!").isEmpty();
+  }
+
+  public static final class Rule implements TestRule {
+    final List<RecordingMaybeObserver<?>> subscribers = new ArrayList<>();
+
+    public <T> RecordingMaybeObserver<T> create() {
+      RecordingMaybeObserver<T> subscriber = new RecordingMaybeObserver<>();
+      subscribers.add(subscriber);
+      return subscriber;
+    }
+
+    @Override public Statement apply(final Statement base, Description description) {
+      return new Statement() {
+        @Override public void evaluate() throws Throwable {
+          base.evaluate();
+          for (RecordingMaybeObserver<?> subscriber : subscribers) {
+            subscriber.assertNoEvents();
+          }
+        }
+      };
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RecordingObserver.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RecordingObserver.java
new file mode 100644
index 000000000..033111ff4
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RecordingObserver.java
@@ -0,0 +1,136 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Notification;
+import io.reactivex.Observer;
+import io.reactivex.disposables.Disposable;
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Deque;
+import java.util.List;
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+/** A test {@link Observer} and JUnit rule which guarantees all events are asserted. */
+final class RecordingObserver<T> implements Observer<T> {
+  private final Deque<Notification<T>> events = new ArrayDeque<>();
+
+  private RecordingObserver() {
+  }
+
+  @Override public void onSubscribe(Disposable disposable) {
+  }
+
+  @Override public void onNext(T value) {
+    events.add(Notification.createOnNext(value));
+  }
+
+  @Override public void onComplete() {
+    events.add(Notification.<T>createOnComplete());
+  }
+
+  @Override public void onError(Throwable e) {
+    events.add(Notification.<T>createOnError(e));
+  }
+
+  private Notification<T> takeNotification() {
+    Notification<T> notification = events.pollFirst();
+    if (notification == null) {
+      throw new AssertionError("No event found!");
+    }
+    return notification;
+  }
+
+  public T takeValue() {
+    Notification<T> notification = takeNotification();
+    assertThat(notification.isOnNext())
+        .as("Expected onNext event but was " + notification)
+        .isTrue();
+    return notification.getValue();
+  }
+
+  public Throwable takeError() {
+    Notification<T> notification = takeNotification();
+    assertThat(notification.isOnError())
+        .as("Expected onError event but was " + notification)
+        .isTrue();
+    return notification.getError();
+  }
+
+  public RecordingObserver<T> assertAnyValue() {
+    takeValue();
+    return this;
+  }
+
+  public RecordingObserver<T> assertValue(T value) {
+    assertThat(takeValue()).isEqualTo(value);
+    return this;
+  }
+
+  public void assertComplete() {
+    Notification<T> notification = takeNotification();
+    assertThat(notification.isOnComplete())
+        .as("Expected onCompleted event but was " + notification)
+        .isTrue();
+    assertNoEvents();
+  }
+
+  public void assertError(Throwable throwable) {
+    assertThat(takeError()).isEqualTo(throwable);
+  }
+
+  public void assertError(Class<? extends Throwable> errorClass) {
+    assertError(errorClass, null);
+  }
+
+  public void assertError(Class<? extends Throwable> errorClass, String message) {
+    Throwable throwable = takeError();
+    assertThat(throwable).isInstanceOf(errorClass);
+    if (message != null) {
+      assertThat(throwable).hasMessage(message);
+    }
+    assertNoEvents();
+  }
+
+  public void assertNoEvents() {
+    assertThat(events).as("Unconsumed events found!").isEmpty();
+  }
+
+  public static final class Rule implements TestRule {
+    final List<RecordingObserver<?>> subscribers = new ArrayList<>();
+
+    public <T> RecordingObserver<T> create() {
+      RecordingObserver<T> subscriber = new RecordingObserver<>();
+      subscribers.add(subscriber);
+      return subscriber;
+    }
+
+    @Override public Statement apply(final Statement base, Description description) {
+      return new Statement() {
+        @Override public void evaluate() throws Throwable {
+          base.evaluate();
+          for (RecordingObserver<?> subscriber : subscribers) {
+            subscriber.assertNoEvents();
+          }
+        }
+      };
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RecordingSingleObserver.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RecordingSingleObserver.java
new file mode 100644
index 000000000..6c7b61f77
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RecordingSingleObserver.java
@@ -0,0 +1,125 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Notification;
+import io.reactivex.Observer;
+import io.reactivex.SingleObserver;
+import io.reactivex.disposables.Disposable;
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Deque;
+import java.util.List;
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+/** A test {@link Observer} and JUnit rule which guarantees all events are asserted. */
+final class RecordingSingleObserver<T> implements SingleObserver<T> {
+  private final Deque<Notification<T>> events = new ArrayDeque<>();
+
+  private RecordingSingleObserver() {
+  }
+
+  @Override public void onSubscribe(Disposable disposable) {
+  }
+
+  @Override public void onSuccess(T value) {
+    events.add(Notification.createOnNext(value));
+  }
+
+  @Override public void onError(Throwable e) {
+    events.add(Notification.<T>createOnError(e));
+  }
+
+  private Notification<T> takeNotification() {
+    Notification<T> notification = events.pollFirst();
+    if (notification == null) {
+      throw new AssertionError("No event found!");
+    }
+    return notification;
+  }
+
+  public T takeValue() {
+    Notification<T> notification = takeNotification();
+    assertThat(notification.isOnNext())
+        .as("Expected onNext event but was " + notification)
+        .isTrue();
+    return notification.getValue();
+  }
+
+  public Throwable takeError() {
+    Notification<T> notification = takeNotification();
+    assertThat(notification.isOnError())
+        .as("Expected onError event but was " + notification)
+        .isTrue();
+    return notification.getError();
+  }
+
+  public RecordingSingleObserver<T> assertAnyValue() {
+    takeValue();
+    return this;
+  }
+
+  public RecordingSingleObserver<T> assertValue(T value) {
+    assertThat(takeValue()).isEqualTo(value);
+    return this;
+  }
+
+  public void assertError(Throwable throwable) {
+    assertThat(takeError()).isEqualTo(throwable);
+  }
+
+  public void assertError(Class<? extends Throwable> errorClass) {
+    assertError(errorClass, null);
+  }
+
+  public void assertError(Class<? extends Throwable> errorClass, String message) {
+    Throwable throwable = takeError();
+    assertThat(throwable).isInstanceOf(errorClass);
+    if (message != null) {
+      assertThat(throwable).hasMessage(message);
+    }
+    assertNoEvents();
+  }
+
+  public void assertNoEvents() {
+    assertThat(events).as("Unconsumed events found!").isEmpty();
+  }
+
+  public static final class Rule implements TestRule {
+    final List<RecordingSingleObserver<?>> subscribers = new ArrayList<>();
+
+    public <T> RecordingSingleObserver<T> create() {
+      RecordingSingleObserver<T> subscriber = new RecordingSingleObserver<>();
+      subscribers.add(subscriber);
+      return subscriber;
+    }
+
+    @Override public Statement apply(final Statement base, Description description) {
+      return new Statement() {
+        @Override public void evaluate() throws Throwable {
+          base.evaluate();
+          for (RecordingSingleObserver<?> subscriber : subscribers) {
+            subscriber.assertNoEvents();
+          }
+        }
+      };
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RecordingSubscriber.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RecordingSubscriber.java
new file mode 100644
index 000000000..f81bfd97a
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RecordingSubscriber.java
@@ -0,0 +1,154 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Notification;
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Deque;
+import java.util.List;
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+import org.reactivestreams.Subscriber;
+import org.reactivestreams.Subscription;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+/** A test {@link Subscriber} and JUnit rule which guarantees all events are asserted. */
+final class RecordingSubscriber<T> implements Subscriber<T> {
+  private final long initialRequest;
+  private final Deque<Notification<T>> events = new ArrayDeque<>();
+
+  private Subscription subscription;
+
+  private RecordingSubscriber(long initialRequest) {
+    this.initialRequest = initialRequest;
+  }
+
+  @Override public void onSubscribe(Subscription subscription) {
+    this.subscription = subscription;
+
+    subscription.request(initialRequest);
+  }
+
+  @Override public void onNext(T value) {
+    events.add(Notification.createOnNext(value));
+  }
+
+  @Override public void onComplete() {
+    events.add(Notification.<T>createOnComplete());
+  }
+
+  @Override public void onError(Throwable e) {
+    events.add(Notification.<T>createOnError(e));
+  }
+
+  private Notification<T> takeNotification() {
+    Notification<T> notification = events.pollFirst();
+    if (notification == null) {
+      throw new AssertionError("No event found!");
+    }
+    return notification;
+  }
+
+  public T takeValue() {
+    Notification<T> notification = takeNotification();
+    assertThat(notification.isOnNext())
+        .as("Expected onNext event but was " + notification)
+        .isTrue();
+    return notification.getValue();
+  }
+
+  public Throwable takeError() {
+    Notification<T> notification = takeNotification();
+    assertThat(notification.isOnError())
+        .as("Expected onError event but was " + notification)
+        .isTrue();
+    return notification.getError();
+  }
+
+  public RecordingSubscriber<T> assertAnyValue() {
+    takeValue();
+    return this;
+  }
+
+  public RecordingSubscriber<T> assertValue(T value) {
+    assertThat(takeValue()).isEqualTo(value);
+    return this;
+  }
+
+  public void assertComplete() {
+    Notification<T> notification = takeNotification();
+    assertThat(notification.isOnComplete())
+        .as("Expected onCompleted event but was " + notification)
+        .isTrue();
+    assertNoEvents();
+  }
+
+  public void assertError(Throwable throwable) {
+    assertThat(takeError()).isEqualTo(throwable);
+  }
+
+  public void assertError(Class<? extends Throwable> errorClass) {
+    assertError(errorClass, null);
+  }
+
+  public void assertError(Class<? extends Throwable> errorClass, String message) {
+    Throwable throwable = takeError();
+    assertThat(throwable).isInstanceOf(errorClass);
+    if (message != null) {
+      assertThat(throwable).hasMessage(message);
+    }
+    assertNoEvents();
+  }
+
+  public void assertNoEvents() {
+    assertThat(events).as("Unconsumed events found!").isEmpty();
+  }
+
+  public void request(long amount) {
+    if (subscription == null) {
+      throw new IllegalStateException("onSubscribe has not been called yet. Did you subscribe()?");
+    }
+    subscription.request(amount);
+  }
+
+  public static final class Rule implements TestRule {
+    final List<RecordingSubscriber<?>> subscribers = new ArrayList<>();
+
+    public <T> RecordingSubscriber<T> create() {
+      return createWithInitialRequest(Long.MAX_VALUE);
+    }
+
+    public <T> RecordingSubscriber<T> createWithInitialRequest(long initialRequest) {
+      RecordingSubscriber<T> subscriber = new RecordingSubscriber<>(initialRequest);
+      subscribers.add(subscriber);
+      return subscriber;
+    }
+
+    @Override public Statement apply(final Statement base, Description description) {
+      return new Statement() {
+        @Override public void evaluate() throws Throwable {
+          base.evaluate();
+          for (RecordingSubscriber<?> subscriber : subscribers) {
+            subscriber.assertNoEvents();
+          }
+        }
+      };
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/ResultTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ResultTest.java
similarity index 96%
rename from retrofit-adapters/rxjava/src/test/java/retrofit2/ResultTest.java
rename to retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ResultTest.java
index 935a2b9f7..a26043296 100644
--- a/retrofit-adapters/rxjava/src/test/java/retrofit2/ResultTest.java
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ResultTest.java
@@ -13,10 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.adapter.rxjava2;
 
 import java.io.IOException;
 import org.junit.Test;
+import retrofit2.Response;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactoryTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactoryTest.java
new file mode 100644
index 000000000..dea046f63
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactoryTest.java
@@ -0,0 +1,274 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package retrofit2.adapter.rxjava2;
+
+import com.google.common.reflect.TypeToken;
+import io.reactivex.Completable;
+import io.reactivex.Flowable;
+import io.reactivex.Maybe;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import java.util.List;
+import org.junit.Before;
+import org.junit.Test;
+import retrofit2.CallAdapter;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import io.reactivex.Observable;
+import io.reactivex.Single;
+import io.reactivex.Flowable;
+import io.reactivex.Maybe;
+import io.reactivex.Completable;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public class RxJava2CallAdapterFactoryTest {
+  private static final Annotation[] NO_ANNOTATIONS = new Annotation[0];
+
+  private final CallAdapter.Factory factory = RxJava2CallAdapterFactory.create();
+  private Retrofit retrofit;
+
+  @Before public void setUp() {
+    retrofit = new Retrofit.Builder()
+        .baseUrl("http://localhost:1")
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(factory)
+        .build();
+  }
+
+  @Test public void nullSchedulerThrows() {
+    try {
+      RxJava2CallAdapterFactory.createWithScheduler(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("scheduler == null");
+    }
+  }
+
+  @Test public void nonRxJavaTypeReturnsNull() {
+    CallAdapter<?, ?> adapter = factory.get(String.class, NO_ANNOTATIONS, retrofit);
+    assertThat(adapter).isNull();
+  }
+
+  @Test public void responseTypes() {
+    Type oBodyClass = new TypeToken<Observable<String>>() {}.getType();
+    assertThat(factory.get(oBodyClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type sBodyClass = new TypeToken<Single<String>>() {}.getType();
+    assertThat(factory.get(sBodyClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type mBodyClass = new TypeToken<Maybe<String>>() {}.getType();
+    assertThat(factory.get(mBodyClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type fBodyClass = new TypeToken<Flowable<String>>() {}.getType();
+    assertThat(factory.get(fBodyClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+
+    Type oBodyWildcard = new TypeToken<Observable<? extends String>>() {}.getType();
+    assertThat(factory.get(oBodyWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type sBodyWildcard = new TypeToken<Single<? extends String>>() {}.getType();
+    assertThat(factory.get(sBodyWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type mBodyWildcard = new TypeToken<Maybe<? extends String>>() {}.getType();
+    assertThat(factory.get(mBodyWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type fBodyWildcard = new TypeToken<Flowable<? extends String>>() {}.getType();
+    assertThat(factory.get(fBodyWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+
+    Type oBodyGeneric = new TypeToken<Observable<List<String>>>() {}.getType();
+    assertThat(factory.get(oBodyGeneric, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(new TypeToken<List<String>>() {}.getType());
+    Type sBodyGeneric = new TypeToken<Single<List<String>>>() {}.getType();
+    assertThat(factory.get(sBodyGeneric, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(new TypeToken<List<String>>() {}.getType());
+    Type mBodyGeneric = new TypeToken<Maybe<List<String>>>() {}.getType();
+    assertThat(factory.get(mBodyGeneric, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(new TypeToken<List<String>>() {}.getType());
+    Type fBodyGeneric = new TypeToken<Flowable<List<String>>>() {}.getType();
+    assertThat(factory.get(fBodyGeneric, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(new TypeToken<List<String>>() {}.getType());
+
+    Type oResponseClass = new TypeToken<Observable<Response<String>>>() {}.getType();
+    assertThat(factory.get(oResponseClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type sResponseClass = new TypeToken<Single<Response<String>>>() {}.getType();
+    assertThat(factory.get(sResponseClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type mResponseClass = new TypeToken<Maybe<Response<String>>>() {}.getType();
+    assertThat(factory.get(mResponseClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type fResponseClass = new TypeToken<Flowable<Response<String>>>() {}.getType();
+    assertThat(factory.get(fResponseClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+
+    Type oResponseWildcard = new TypeToken<Observable<Response<? extends String>>>() {}.getType();
+    assertThat(factory.get(oResponseWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type sResponseWildcard = new TypeToken<Single<Response<? extends String>>>() {}.getType();
+    assertThat(factory.get(sResponseWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type mResponseWildcard = new TypeToken<Maybe<Response<? extends String>>>() {}.getType();
+    assertThat(factory.get(mResponseWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type fResponseWildcard = new TypeToken<Flowable<Response<? extends String>>>() {}.getType();
+    assertThat(factory.get(fResponseWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+
+    Type oResultClass = new TypeToken<Observable<Result<String>>>() {}.getType();
+    assertThat(factory.get(oResultClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type sResultClass = new TypeToken<Single<Result<String>>>() {}.getType();
+    assertThat(factory.get(sResultClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type mResultClass = new TypeToken<Maybe<Result<String>>>() {}.getType();
+    assertThat(factory.get(mResultClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type fResultClass = new TypeToken<Flowable<Result<String>>>() {}.getType();
+    assertThat(factory.get(fResultClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+
+    Type oResultWildcard = new TypeToken<Observable<Result<? extends String>>>() {}.getType();
+    assertThat(factory.get(oResultWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type sResultWildcard = new TypeToken<Single<Result<? extends String>>>() {}.getType();
+    assertThat(factory.get(sResultWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type mResultWildcard = new TypeToken<Maybe<Result<? extends String>>>() {}.getType();
+    assertThat(factory.get(mResultWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type fResultWildcard = new TypeToken<Flowable<Result<? extends String>>>() {}.getType();
+    assertThat(factory.get(fResultWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+  }
+
+  @Test public void rawBodyTypeThrows() {
+    Type observableType = new TypeToken<Observable>() {}.getType();
+    try {
+      factory.get(observableType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Observable return type must be parameterized as Observable<Foo> or Observable<? extends Foo>");
+    }
+
+    Type singleType = new TypeToken<Single>() {}.getType();
+    try {
+      factory.get(singleType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Single return type must be parameterized as Single<Foo> or Single<? extends Foo>");
+    }
+
+    Type maybeType = new TypeToken<Maybe>() {}.getType();
+    try {
+      factory.get(maybeType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Maybe return type must be parameterized as Maybe<Foo> or Maybe<? extends Foo>");
+    }
+
+    Type flowableType = new TypeToken<Flowable>() {}.getType();
+    try {
+      factory.get(flowableType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Flowable return type must be parameterized as Flowable<Foo> or Flowable<? extends Foo>");
+    }
+  }
+
+  @Test public void rawResponseTypeThrows() {
+    Type observableType = new TypeToken<Observable<Response>>() {}.getType();
+    try {
+      factory.get(observableType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Response must be parameterized as Response<Foo> or Response<? extends Foo>");
+    }
+
+    Type singleType = new TypeToken<Single<Response>>() {}.getType();
+    try {
+      factory.get(singleType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Response must be parameterized as Response<Foo> or Response<? extends Foo>");
+    }
+
+    Type maybeType = new TypeToken<Maybe<Response>>() {}.getType();
+    try {
+      factory.get(maybeType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Response must be parameterized as Response<Foo> or Response<? extends Foo>");
+    }
+
+    Type flowableType = new TypeToken<Flowable<Response>>() {}.getType();
+    try {
+      factory.get(flowableType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Response must be parameterized as Response<Foo> or Response<? extends Foo>");
+    }
+  }
+
+  @Test public void rawResultTypeThrows() {
+    Type observableType = new TypeToken<Observable<Result>>() {}.getType();
+    try {
+      factory.get(observableType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Result must be parameterized as Result<Foo> or Result<? extends Foo>");
+    }
+
+    Type singleType = new TypeToken<Single<Result>>() {}.getType();
+    try {
+      factory.get(singleType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Result must be parameterized as Result<Foo> or Result<? extends Foo>");
+    }
+
+    Type maybeType = new TypeToken<Maybe<Result>>() {}.getType();
+    try {
+      factory.get(maybeType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Result must be parameterized as Result<Foo> or Result<? extends Foo>");
+    }
+
+    Type flowableType = new TypeToken<Flowable<Result>>() {}.getType();
+    try {
+      factory.get(flowableType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Result must be parameterized as Result<Foo> or Result<? extends Foo>");
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RxJavaPluginsResetRule.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RxJavaPluginsResetRule.java
new file mode 100644
index 000000000..2e97cc6f4
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RxJavaPluginsResetRule.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.plugins.RxJavaPlugins;
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+
+final class RxJavaPluginsResetRule implements TestRule {
+  @Override public Statement apply(final Statement base, Description description) {
+    return new Statement() {
+      @Override public void evaluate() throws Throwable {
+        RxJavaPlugins.reset();
+        try {
+          base.evaluate();
+        } finally {
+          RxJavaPlugins.reset();
+        }
+      }
+    };
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/SingleTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/SingleTest.java
new file mode 100644
index 000000000..dba2dd62a
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/SingleTest.java
@@ -0,0 +1,132 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Single;
+import java.io.IOException;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class SingleTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final RecordingSingleObserver.Rule observerRule = new RecordingSingleObserver.Rule();
+
+  interface Service {
+    @GET("/") Single<String> body();
+    @GET("/") Single<Response<String>> response();
+    @GET("/") Single<Result<String>> result();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodySuccess200() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingSingleObserver<String> observer = observerRule.create();
+    service.body().subscribe(observer);
+    observer.assertValue("Hi");
+  }
+
+  @Test public void bodySuccess404() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    RecordingSingleObserver<String> observer = observerRule.create();
+    service.body().subscribe(observer);
+    // Required for backwards compatibility.
+    observer.assertError(HttpException.class, "HTTP 404 Client Error");
+  }
+
+  @Test public void bodyFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    RecordingSingleObserver<String> observer = observerRule.create();
+    service.body().subscribe(observer);
+    observer.assertError(IOException.class);
+  }
+
+  @Test public void responseSuccess200() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingSingleObserver<Response<String>> observer = observerRule.create();
+    service.response().subscribe(observer);
+    Response<String> response = observer.takeValue();
+    assertThat(response.isSuccessful()).isTrue();
+  }
+
+  @Test public void responseSuccess404() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    RecordingSingleObserver<Response<String>> observer = observerRule.create();
+    service.response().subscribe(observer);
+    assertThat(observer.takeValue().isSuccessful()).isFalse();
+  }
+
+  @Test public void responseFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    RecordingSingleObserver<Response<String>> observer = observerRule.create();
+    service.response().subscribe(observer);
+    observer.assertError(IOException.class);
+  }
+
+  @Test public void resultSuccess200() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingSingleObserver<Result<String>> observer = observerRule.create();
+    service.result().subscribe(observer);
+    Result<String> result = observer.takeValue();
+    assertThat(result.isError()).isFalse();
+    assertThat(result.response().isSuccessful()).isTrue();
+  }
+
+  @Test public void resultSuccess404() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    RecordingSingleObserver<Result<String>> observer = observerRule.create();
+    service.result().subscribe(observer);
+    Result<String> result = observer.takeValue();
+    assertThat(result.isError()).isFalse();
+    assertThat(result.response().isSuccessful()).isFalse();
+  }
+
+  @Test public void resultFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    RecordingSingleObserver<Result<String>> observer = observerRule.create();
+    service.result().subscribe(observer);
+    Result<String> result = observer.takeValue();
+    assertThat(result.isError()).isTrue();
+    assertThat(result.error()).isInstanceOf(IOException.class);
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/SingleThrowingTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/SingleThrowingTest.java
new file mode 100644
index 000000000..294722783
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/SingleThrowingTest.java
@@ -0,0 +1,240 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Single;
+import io.reactivex.SingleObserver;
+import io.reactivex.disposables.Disposable;
+import io.reactivex.exceptions.CompositeException;
+import io.reactivex.exceptions.Exceptions;
+import io.reactivex.functions.Consumer;
+import io.reactivex.plugins.RxJavaPlugins;
+import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class SingleThrowingTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final TestRule resetRule = new RxJavaPluginsResetRule();
+  @Rule public final RecordingSingleObserver.Rule subscriberRule = new RecordingSingleObserver.Rule();
+
+  interface Service {
+    @GET("/") Single<String> body();
+    @GET("/") Single<Response<String>> response();
+    @GET("/") Single<Result<String>> result();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodyThrowingInOnSuccessDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingSingleObserver<String> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.body().subscribe(new ForwardingObserver<String>(observer) {
+      @Override public void onSuccess(String value) {
+        throw e;
+      }
+    });
+
+    assertThat(throwableRef.get()).isSameAs(e);
+  }
+
+  @Test public void bodyThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingSingleObserver<String> observer = subscriberRule.create();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    final RuntimeException e = new RuntimeException();
+    service.body().subscribe(new ForwardingObserver<String>(observer) {
+      @Override public void onError(Throwable throwable) {
+        if (!errorRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+        throw e;
+      }
+    });
+
+    //noinspection ThrowableResultOfMethodCallIgnored
+    CompositeException composite = (CompositeException) throwableRef.get();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+
+  @Test public void responseThrowingInOnSuccessDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingSingleObserver<Response<String>> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.response().subscribe(new ForwardingObserver<Response<String>>(observer) {
+      @Override public void onSuccess(Response<String> value) {
+        throw e;
+      }
+    });
+
+    assertThat(throwableRef.get()).isSameAs(e);
+  }
+
+  @Test public void responseThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingSingleObserver<Response<String>> observer = subscriberRule.create();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    final RuntimeException e = new RuntimeException();
+    service.response().subscribe(new ForwardingObserver<Response<String>>(observer) {
+      @Override public void onError(Throwable throwable) {
+        if (!errorRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+        throw e;
+      }
+    });
+
+    //noinspection ThrowableResultOfMethodCallIgnored
+    CompositeException composite = (CompositeException) throwableRef.get();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+
+  @Test public void resultThrowingInOnSuccessDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingSingleObserver<Result<String>> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.result().subscribe(new ForwardingObserver<Result<String>>(observer) {
+      @Override public void onSuccess(Result<String> value) {
+        throw e;
+      }
+    });
+
+    assertThat(throwableRef.get()).isSameAs(e);
+  }
+
+  @Ignore("Single's contract is onNext|onError so we have no way of triggering this case")
+  @Test public void resultThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingSingleObserver<Result<String>> observer = subscriberRule.create();
+    final RuntimeException first = new RuntimeException();
+    final RuntimeException second = new RuntimeException();
+    service.result().subscribe(new ForwardingObserver<Result<String>>(observer) {
+      @Override public void onSuccess(Result<String> value) {
+        // The only way to trigger onError for Result is if onSuccess throws.
+        throw first;
+      }
+
+      @Override public void onError(Throwable throwable) {
+        throw second;
+      }
+    });
+
+    //noinspection ThrowableResultOfMethodCallIgnored
+    CompositeException composite = (CompositeException) throwableRef.get();
+    assertThat(composite.getExceptions()).containsExactly(first, second);
+  }
+
+  private static abstract class ForwardingObserver<T> implements SingleObserver<T> {
+    private final SingleObserver<T> delegate;
+
+    ForwardingObserver(SingleObserver<T> delegate) {
+      this.delegate = delegate;
+    }
+
+    @Override public void onSubscribe(Disposable disposable) {
+      delegate.onSubscribe(disposable);
+    }
+
+    @Override public void onSuccess(T value) {
+      delegate.onSuccess(value);
+    }
+
+    @Override public void onError(Throwable throwable) {
+      delegate.onError(throwable);
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/SingleWithSchedulerTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/SingleWithSchedulerTest.java
new file mode 100644
index 000000000..5198d7bf3
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/SingleWithSchedulerTest.java
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Single;
+import io.reactivex.schedulers.TestScheduler;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+public final class SingleWithSchedulerTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final RecordingSingleObserver.Rule observerRule = new RecordingSingleObserver.Rule();
+
+  interface Service {
+    @GET("/") Single<String> body();
+    @GET("/") Single<Response<String>> response();
+    @GET("/") Single<Result<String>> result();
+  }
+
+  private final TestScheduler scheduler = new TestScheduler();
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJava2CallAdapterFactory.createWithScheduler(scheduler))
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodyUsesScheduler() {
+    server.enqueue(new MockResponse());
+
+    RecordingSingleObserver<Object> observer = observerRule.create();
+    service.body().subscribe(observer);
+    observer.assertNoEvents();
+
+    scheduler.triggerActions();
+    observer.assertAnyValue();
+  }
+
+  @Test public void responseUsesScheduler() {
+    server.enqueue(new MockResponse());
+
+    RecordingSingleObserver<Object> observer = observerRule.create();
+    service.response().subscribe(observer);
+    observer.assertNoEvents();
+
+    scheduler.triggerActions();
+    observer.assertAnyValue();
+  }
+
+  @Test public void resultUsesScheduler() {
+    server.enqueue(new MockResponse());
+
+    RecordingSingleObserver<Object> observer = observerRule.create();
+    service.result().subscribe(observer);
+    observer.assertNoEvents();
+
+    scheduler.triggerActions();
+    observer.assertAnyValue();
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/StringConverterFactory.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/StringConverterFactory.java
new file mode 100644
index 000000000..5a6841840
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/StringConverterFactory.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import okhttp3.MediaType;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
+
+final class StringConverterFactory extends Converter.Factory {
+  @Override
+  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
+    return new Converter<ResponseBody, String>() {
+      @Override public String convert(ResponseBody value) throws IOException {
+        return value.string();
+      }
+    };
+  }
+
+  @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
+      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+    return new Converter<String, RequestBody>() {
+      @Override public RequestBody convert(String value) throws IOException {
+        return RequestBody.create(MediaType.parse("text/plain"), value);
+      }
+    };
+  }
+}
diff --git a/retrofit-adapters/scala/README.md b/retrofit-adapters/scala/README.md
new file mode 100644
index 000000000..74aa0a7a1
--- /dev/null
+++ b/retrofit-adapters/scala/README.md
@@ -0,0 +1,49 @@
+Scala Adapter
+=============
+
+An `Adapter` for adapting Scala `Future`.
+
+
+Usage
+-----
+
+Add `ScalaCallAdapterFactory` as a `Call` adapter when building your `Retrofit` instance:
+```java
+Retrofit retrofit = new Retrofit.Builder()
+    .baseUrl("https://example.com/")
+    .addCallAdapterFactory(ScalaCallAdapterFactory.create())
+    .build();
+```
+
+Your service methods can now use `Future` as their return type.
+```java
+interface MyService {
+  @GET("/user")
+  Future<User> getUser();
+}
+```
+
+
+Download
+--------
+
+Download [the latest JAR][2] or grab via [Maven][3]:
+```xml
+<dependency>
+  <groupId>com.squareup.retrofit2</groupId>
+  <artifactId>adapter-scala</artifactId>
+  <version>latest.version</version>
+</dependency>
+```
+or [Gradle][3]:
+```groovy
+compile 'com.squareup.retrofit2:adapter-scala:latest.version'
+```
+
+Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
+
+
+
+ [2]: https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=adapter-scala&v=LATEST
+ [3]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup.retrofit2%22%20a%3A%22adapter-scala%22
+ [snap]: https://oss.sonatype.org/content/repositories/snapshots/
diff --git a/retrofit-adapters/scala/pom.xml b/retrofit-adapters/scala/pom.xml
new file mode 100644
index 000000000..ecbd8adde
--- /dev/null
+++ b/retrofit-adapters/scala/pom.xml
@@ -0,0 +1,85 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.retrofit2</groupId>
+    <artifactId>retrofit-adapters</artifactId>
+    <version>2.4.1-SNAPSHOT</version>
+    <relativePath>../pom.xml</relativePath>
+  </parent>
+
+  <artifactId>adapter-scala</artifactId>
+  <name>Adapter: Scala</name>
+
+  <properties>
+    <java.version>1.8</java.version>
+  </properties>
+
+  <dependencies>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>retrofit</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>org.scala-lang</groupId>
+      <artifactId>scala-library</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.assertj</groupId>
+      <artifactId>assertj-core</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp3</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.codehaus.mojo</groupId>
+        <artifactId>animal-sniffer-maven-plugin</artifactId>
+        <version>${animal.sniffer.version}</version>
+        <configuration>
+          <signature>
+            <groupId>org.kaazing.mojo.signature</groupId>
+            <artifactId>java18</artifactId>
+            <version>1.0</version>
+          </signature>
+        </configuration>
+      </plugin>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-jar-plugin</artifactId>
+        <configuration>
+          <archive>
+            <manifestEntries>
+              <Automatic-Module-Name>retrofit2.adapter.scala</Automatic-Module-Name>
+            </manifestEntries>
+          </archive>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
diff --git a/retrofit-adapters/scala/src/main/java/retrofit2/adapter/scala/BodyCallAdapter.java b/retrofit-adapters/scala/src/main/java/retrofit2/adapter/scala/BodyCallAdapter.java
new file mode 100644
index 000000000..432068f86
--- /dev/null
+++ b/retrofit-adapters/scala/src/main/java/retrofit2/adapter/scala/BodyCallAdapter.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.scala;
+
+import java.lang.reflect.Type;
+import javax.annotation.Nonnull;
+import retrofit2.Call;
+import retrofit2.CallAdapter;
+import retrofit2.Callback;
+import retrofit2.HttpException;
+import retrofit2.Response;
+import scala.concurrent.Future;
+import scala.concurrent.Promise;
+
+final class BodyCallAdapter<T> implements CallAdapter<T, Future<T>> {
+  private final Type responseType;
+
+  BodyCallAdapter(Type responseType) {
+    this.responseType = responseType;
+  }
+
+  @Override public Type responseType() {
+    return responseType;
+  }
+
+  @Override public Future<T> adapt(@Nonnull Call<T> call) {
+    Promise<T> promise = Promise.apply();
+
+    call.enqueue(new Callback<T>() {
+      @Override public void onResponse(@Nonnull Call<T> call, @Nonnull Response<T> response) {
+        if (response.isSuccessful()) {
+          promise.success(response.body());
+        } else {
+          promise.failure(new HttpException(response));
+        }
+      }
+
+      @Override public void onFailure(@Nonnull Call<T> call, @Nonnull Throwable t) {
+        promise.failure(t);
+      }
+    });
+
+    return promise.future();
+  }
+}
diff --git a/retrofit-adapters/scala/src/main/java/retrofit2/adapter/scala/ResponseCallAdapter.java b/retrofit-adapters/scala/src/main/java/retrofit2/adapter/scala/ResponseCallAdapter.java
new file mode 100644
index 000000000..75d75f99d
--- /dev/null
+++ b/retrofit-adapters/scala/src/main/java/retrofit2/adapter/scala/ResponseCallAdapter.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.scala;
+
+import java.lang.reflect.Type;
+import javax.annotation.Nonnull;
+import retrofit2.Call;
+import retrofit2.CallAdapter;
+import retrofit2.Callback;
+import retrofit2.Response;
+import scala.concurrent.Future;
+import scala.concurrent.Promise;
+
+final class ResponseCallAdapter<T> implements CallAdapter<T, Future<Response<T>>> {
+  private final Type responseType;
+
+  ResponseCallAdapter(Type responseType) {
+    this.responseType = responseType;
+  }
+
+  @Override public Type responseType() {
+    return responseType;
+  }
+
+  @Override public Future<Response<T>> adapt(@Nonnull Call<T> call) {
+    Promise<Response<T>> promise = Promise.apply();
+
+    call.enqueue(new Callback<T>() {
+      @Override public void onResponse(@Nonnull Call<T> call, @Nonnull Response<T> response) {
+        promise.success(response);
+      }
+
+      @Override public void onFailure(@Nonnull Call<T> call, @Nonnull Throwable t) {
+        promise.failure(t);
+      }
+    });
+
+    return promise.future();
+  }
+}
diff --git a/retrofit-adapters/scala/src/main/java/retrofit2/adapter/scala/ScalaCallAdapterFactory.java b/retrofit-adapters/scala/src/main/java/retrofit2/adapter/scala/ScalaCallAdapterFactory.java
new file mode 100644
index 000000000..afe2e7fe7
--- /dev/null
+++ b/retrofit-adapters/scala/src/main/java/retrofit2/adapter/scala/ScalaCallAdapterFactory.java
@@ -0,0 +1,82 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.scala;
+
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import javax.annotation.Nonnull;
+import retrofit2.CallAdapter;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import scala.concurrent.Future;
+
+/**
+ * A {@linkplain CallAdapter.Factory call adapter} which creates Scala futures.
+ * <p>
+ * Adding this class to {@link Retrofit} allows you to return {@link Future} from
+ * service methods.
+ * <pre><code>
+ * interface MyService {
+ *   &#64;GET("user/me")
+ *   Future&lt;User&gt; getUser()
+ * }
+ * </code></pre>
+ * There are two configurations supported for the {@code Future} type parameter:
+ * <ul>
+ * <li>Direct body (e.g., {@code Future<User>}) returns the deserialized body for 2XX
+ * responses, sets {@link retrofit2.HttpException HttpException} errors for non-2XX responses, and
+ * sets {@link IOException} for network errors.</li>
+ * <li>Response wrapped body (e.g., {@code Future<Response<User>>}) returns a
+ * {@link Response} object for all HTTP responses and sets {@link IOException} for network
+ * errors</li>
+ * </ul>
+ */
+public final class ScalaCallAdapterFactory extends CallAdapter.Factory {
+  public static ScalaCallAdapterFactory create() {
+    return new ScalaCallAdapterFactory();
+  }
+
+  private ScalaCallAdapterFactory() {
+  }
+
+  @Override
+  public CallAdapter<?, ?> get(@Nonnull Type returnType, @Nonnull Annotation[] annotations,
+      @Nonnull Retrofit retrofit) {
+    if (getRawType(returnType) != Future.class) {
+      return null;
+    }
+    if (!(returnType instanceof ParameterizedType)) {
+      throw new IllegalStateException(
+          "Future return type must be parameterized as Future<Foo> or Future<? extends Foo>");
+    }
+    Type innerType = getParameterUpperBound(0, (ParameterizedType) returnType);
+
+    if (getRawType(innerType) != Response.class) {
+      // Generic type is not Response<T>. Use it for body-only adapter.
+      return new BodyCallAdapter<>(innerType);
+    }
+
+    if (!(innerType instanceof ParameterizedType)) {
+      throw new IllegalStateException(
+          "Response must be parameterized as Response<Foo> or Response<? extends Foo>");
+    }
+
+    Type responseType = getParameterUpperBound(0, (ParameterizedType) innerType);
+    return new ResponseCallAdapter<>(responseType);
+  }
+}
diff --git a/retrofit-adapters/scala/src/test/java/retrofit2/adapter/scala/FutureTest.java b/retrofit-adapters/scala/src/test/java/retrofit2/adapter/scala/FutureTest.java
new file mode 100644
index 000000000..58556ef0c
--- /dev/null
+++ b/retrofit-adapters/scala/src/test/java/retrofit2/adapter/scala/FutureTest.java
@@ -0,0 +1,120 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.scala;
+
+import java.io.IOException;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.HttpException;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+import scala.concurrent.Await;
+import scala.concurrent.Future;
+import scala.concurrent.duration.Duration;
+
+import static java.util.concurrent.TimeUnit.SECONDS;
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class FutureTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  interface Service {
+    @GET("/") Future<String> body();
+    @GET("/") Future<Response<String>> response();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(ScalaCallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodySuccess200() throws Exception {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    Future<String> future = service.body();
+    String result = Await.result(future, Duration.create(5, SECONDS));
+    assertThat(result).isEqualTo("Hi");
+  }
+
+  @Test public void bodySuccess404() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    Future<String> future = service.body();
+    try {
+      Await.result(future, Duration.create(5, SECONDS));
+      fail();
+    } catch (Exception e) {
+      assertThat(e)
+          .isInstanceOf(HttpException.class) // Required for backwards compatibility.
+          .isInstanceOf(retrofit2.HttpException.class)
+          .hasMessage("HTTP 404 Client Error");
+    }
+  }
+
+  @Test public void bodyFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    Future<String> future = service.body();
+    try {
+      Await.result(future, Duration.create(5, SECONDS));
+      fail();
+    } catch (Exception e) {
+      assertThat(e).isInstanceOf(IOException.class);
+    }
+  }
+
+  @Test public void responseSuccess200() throws Exception {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    Future<Response<String>> future = service.response();
+    Response<String> response = Await.result(future, Duration.create(5, SECONDS));
+    assertThat(response.isSuccessful()).isTrue();
+    assertThat(response.body()).isEqualTo("Hi");
+  }
+
+  @Test public void responseSuccess404() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
+
+    Future<Response<String>> future = service.response();
+    Response<String> response = Await.result(future, Duration.create(5, SECONDS));
+    assertThat(response.isSuccessful()).isFalse();
+    assertThat(response.errorBody().string()).isEqualTo("Hi");
+  }
+
+  @Test public void responseFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    Future<Response<String>> future = service.response();
+    try {
+      Await.result(future, Duration.create(5, SECONDS));
+      fail();
+    } catch (Exception e) {
+      assertThat(e).isInstanceOf(IOException.class);
+    }
+  }
+}
diff --git a/retrofit-adapters/scala/src/test/java/retrofit2/adapter/scala/ScalaCallAdapterFactoryTest.java b/retrofit-adapters/scala/src/test/java/retrofit2/adapter/scala/ScalaCallAdapterFactoryTest.java
new file mode 100644
index 000000000..06c8b30fd
--- /dev/null
+++ b/retrofit-adapters/scala/src/test/java/retrofit2/adapter/scala/ScalaCallAdapterFactoryTest.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.scala;
+
+import com.google.common.reflect.TypeToken;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import java.util.List;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.CallAdapter;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import scala.concurrent.Future;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class ScalaCallAdapterFactoryTest {
+  private static final Annotation[] NO_ANNOTATIONS = new Annotation[0];
+
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private final CallAdapter.Factory factory = ScalaCallAdapterFactory.create();
+  private Retrofit retrofit;
+
+  @Before public void setUp() {
+    retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(factory)
+        .build();
+  }
+
+  @Test public void responseType() {
+    Type bodyClass = new TypeToken<Future<String>>() {}.getType();
+    assertThat(factory.get(bodyClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type bodyWildcard = new TypeToken<Future<? extends String>>() {}.getType();
+    assertThat(factory.get(bodyWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type bodyGeneric = new TypeToken<Future<List<String>>>() {}.getType();
+    assertThat(factory.get(bodyGeneric, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(new TypeToken<List<String>>() {}.getType());
+    Type responseClass = new TypeToken<Future<Response<String>>>() {}.getType();
+    assertThat(factory.get(responseClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type responseWildcard = new TypeToken<Future<Response<? extends String>>>() {}.getType();
+    assertThat(factory.get(responseWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type resultClass = new TypeToken<Future<Response<String>>>() {}.getType();
+    assertThat(factory.get(resultClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type resultWildcard = new TypeToken<Future<Response<? extends String>>>() {}.getType();
+    assertThat(factory.get(resultWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+  }
+
+  @Test public void nonListenableFutureReturnsNull() {
+    CallAdapter<?, ?> adapter = factory.get(String.class, NO_ANNOTATIONS, retrofit);
+    assertThat(adapter).isNull();
+  }
+
+  @Test public void rawTypeThrows() {
+    Type observableType = new TypeToken<Future>() {}.getType();
+    try {
+      factory.get(observableType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Future return type must be parameterized as Future<Foo> or Future<? extends Foo>");
+    }
+  }
+
+  @Test public void rawResponseTypeThrows() {
+    Type observableType = new TypeToken<Future<Response>>() {}.getType();
+    try {
+      factory.get(observableType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Response must be parameterized as Response<Foo> or Response<? extends Foo>");
+    }
+  }
+}
diff --git a/retrofit-adapters/scala/src/test/java/retrofit2/adapter/scala/StringConverterFactory.java b/retrofit-adapters/scala/src/test/java/retrofit2/adapter/scala/StringConverterFactory.java
new file mode 100644
index 000000000..d14596c40
--- /dev/null
+++ b/retrofit-adapters/scala/src/test/java/retrofit2/adapter/scala/StringConverterFactory.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.scala;
+
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import okhttp3.MediaType;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
+
+final class StringConverterFactory extends Converter.Factory {
+  @Override
+  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
+    return new Converter<ResponseBody, String>() {
+      @Override public String convert(ResponseBody value) throws IOException {
+        return value.string();
+      }
+    };
+  }
+
+  @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
+      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+    return new Converter<String, RequestBody>() {
+      @Override public RequestBody convert(String value) throws IOException {
+        return RequestBody.create(MediaType.parse("text/plain"), value);
+      }
+    };
+  }
+}
diff --git a/retrofit-converters/README.md b/retrofit-converters/README.md
index 1e440adef..041f7a4b9 100644
--- a/retrofit-converters/README.md
+++ b/retrofit-converters/README.md
@@ -1,14 +1,15 @@
 Retrofit Converters
 ===================
 
-Retrofit ships with a default converter for JSON that uses Gson but the library is content-format
-agnostic. The child modules contained herein are additional converters for other popular formats.
+Retrofit ships with support for OkHttp's `RequestBody` and `ResponseBody` types but the library is
+content-format agnostic. The child modules contained herein are additional converters for other
+popular formats.
 
 To use, supply an instance of your desired converter when building your `Retrofit` instance.
 
 ```java
 Retrofit retrofit = new Retrofit.Builder()
     .baseUrl("https://api.example.com")
-    .converter(new ProtoConverter())
+    .addConverterFactory(GsonConverterFactory.create())
     .build();
 ```
diff --git a/retrofit-converters/gson/README.md b/retrofit-converters/gson/README.md
index 1568926f2..980d1d1f0 100644
--- a/retrofit-converters/gson/README.md
+++ b/retrofit-converters/gson/README.md
@@ -4,7 +4,30 @@ Gson Converter
 A `Converter` which uses [Gson][1] for serialization to and from JSON.
 
 A default `Gson` instance will be created or one can be configured and passed to the
-`GsonConverter` construction to further control the serialization.
+`GsonConverterFactory` to further control the serialization.
+
+
+Download
+--------
+
+Download [the latest JAR][2] or grab via [Maven][3]:
+```xml
+<dependency>
+  <groupId>com.squareup.retrofit2</groupId>
+  <artifactId>converter-gson</artifactId>
+  <version>latest.version</version>
+</dependency>
+```
+or [Gradle][3]:
+```groovy
+compile 'com.squareup.retrofit2:converter-gson:latest.version'
+```
+
+Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
+
 
 
  [1]: https://github.com/google/gson
+ [2]: https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=converter-gson&v=LATEST
+ [3]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup.retrofit2%22%20a%3A%22converter-gson%22
+ [snap]: https://oss.sonatype.org/content/repositories/snapshots/
diff --git a/retrofit-converters/gson/pom.xml b/retrofit-converters/gson/pom.xml
index 15b9a716f..099da1b51 100644
--- a/retrofit-converters/gson/pom.xml
+++ b/retrofit-converters/gson/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-converters</artifactId>
-    <version>2.0.0-SNAPSHOT</version>
+    <version>2.4.1-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -23,6 +23,11 @@
       <groupId>com.google.code.gson</groupId>
       <artifactId>gson</artifactId>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
@@ -30,7 +35,7 @@
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>com.squareup.okhttp3</groupId>
       <artifactId>mockwebserver</artifactId>
       <scope>test</scope>
     </dependency>
@@ -40,4 +45,20 @@
       <scope>test</scope>
     </dependency>
   </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-jar-plugin</artifactId>
+        <configuration>
+          <archive>
+            <manifestEntries>
+              <Automatic-Module-Name>retrofit2.converter.gson</Automatic-Module-Name>
+            </manifestEntries>
+          </archive>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
 </project>
diff --git a/retrofit-converters/gson/src/main/java/retrofit2/GsonConverterFactory.java b/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonConverterFactory.java
similarity index 86%
rename from retrofit-converters/gson/src/main/java/retrofit2/GsonConverterFactory.java
rename to retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonConverterFactory.java
index 5208314b9..468d576d7 100644
--- a/retrofit-converters/gson/src/main/java/retrofit2/GsonConverterFactory.java
+++ b/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonConverterFactory.java
@@ -13,15 +13,17 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.gson;
 
 import com.google.gson.Gson;
 import com.google.gson.TypeAdapter;
 import com.google.gson.reflect.TypeToken;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.ResponseBody;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
 
 /**
  * A {@linkplain Converter.Factory converter} which uses Gson for JSON.
@@ -44,14 +46,15 @@ public static GsonConverterFactory create() {
    * Create an instance using {@code gson} for conversion. Encoding to JSON and
    * decoding from JSON (when no charset is specified by a header) will use UTF-8.
    */
+  @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
   public static GsonConverterFactory create(Gson gson) {
+    if (gson == null) throw new NullPointerException("gson == null");
     return new GsonConverterFactory(gson);
   }
 
   private final Gson gson;
 
   private GsonConverterFactory(Gson gson) {
-    if (gson == null) throw new NullPointerException("gson == null");
     this.gson = gson;
   }
 
@@ -59,12 +62,12 @@ private GsonConverterFactory(Gson gson) {
   public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
       Retrofit retrofit) {
     TypeAdapter<?> adapter = gson.getAdapter(TypeToken.get(type));
-    return new GsonResponseBodyConverter<>(adapter);
+    return new GsonResponseBodyConverter<>(gson, adapter);
   }
 
   @Override
-  public Converter<?, RequestBody> requestBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
+  public Converter<?, RequestBody> requestBodyConverter(Type type,
+      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     TypeAdapter<?> adapter = gson.getAdapter(TypeToken.get(type));
     return new GsonRequestBodyConverter<>(gson, adapter);
   }
diff --git a/retrofit-converters/gson/src/main/java/retrofit2/GsonRequestBodyConverter.java b/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonRequestBodyConverter.java
similarity index 85%
rename from retrofit-converters/gson/src/main/java/retrofit2/GsonRequestBodyConverter.java
rename to retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonRequestBodyConverter.java
index 1d3d6e75a..2e30a4478 100644
--- a/retrofit-converters/gson/src/main/java/retrofit2/GsonRequestBodyConverter.java
+++ b/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonRequestBodyConverter.java
@@ -13,18 +13,19 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.gson;
 
 import com.google.gson.Gson;
 import com.google.gson.TypeAdapter;
 import com.google.gson.stream.JsonWriter;
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.RequestBody;
 import java.io.IOException;
 import java.io.OutputStreamWriter;
 import java.io.Writer;
 import java.nio.charset.Charset;
+import okhttp3.MediaType;
+import okhttp3.RequestBody;
 import okio.Buffer;
+import retrofit2.Converter;
 
 final class GsonRequestBodyConverter<T> implements Converter<T, RequestBody> {
   private static final MediaType MEDIA_TYPE = MediaType.parse("application/json; charset=UTF-8");
@@ -42,12 +43,8 @@
     Buffer buffer = new Buffer();
     Writer writer = new OutputStreamWriter(buffer.outputStream(), UTF_8);
     JsonWriter jsonWriter = gson.newJsonWriter(writer);
-    try {
-      adapter.write(jsonWriter, value);
-      jsonWriter.flush();
-    } catch (IOException e) {
-      throw new AssertionError(e); // Writing to Buffer does no I/O.
-    }
+    adapter.write(jsonWriter, value);
+    jsonWriter.close();
     return RequestBody.create(MEDIA_TYPE, buffer.readByteString());
   }
 }
diff --git a/retrofit-converters/gson/src/main/java/retrofit2/GsonResponseBodyConverter.java b/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonResponseBodyConverter.java
similarity index 59%
rename from retrofit-converters/gson/src/main/java/retrofit2/GsonResponseBodyConverter.java
rename to retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonResponseBodyConverter.java
index f12075d00..d751e7402 100644
--- a/retrofit-converters/gson/src/main/java/retrofit2/GsonResponseBodyConverter.java
+++ b/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonResponseBodyConverter.java
@@ -13,31 +13,36 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.gson;
 
+import com.google.gson.Gson;
+import com.google.gson.JsonIOException;
 import com.google.gson.TypeAdapter;
-import com.squareup.okhttp.ResponseBody;
+import com.google.gson.stream.JsonReader;
+import com.google.gson.stream.JsonToken;
 import java.io.IOException;
-import java.io.Reader;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
 
 final class GsonResponseBodyConverter<T> implements Converter<ResponseBody, T> {
+  private final Gson gson;
   private final TypeAdapter<T> adapter;
 
-  GsonResponseBodyConverter(TypeAdapter<T> adapter) {
+  GsonResponseBodyConverter(Gson gson, TypeAdapter<T> adapter) {
+    this.gson = gson;
     this.adapter = adapter;
   }
 
   @Override public T convert(ResponseBody value) throws IOException {
-    Reader reader = value.charStream();
+    JsonReader jsonReader = gson.newJsonReader(value.charStream());
     try {
-      return adapter.fromJson(reader);
-    } finally {
-      if (reader != null) {
-        try {
-          reader.close();
-        } catch (IOException ignored) {
-        }
+      T result = adapter.read(jsonReader);
+      if (jsonReader.peek() != JsonToken.END_DOCUMENT) {
+        throw new JsonIOException("JSON document was not fully consumed.");
       }
+      return result;
+    } finally {
+      value.close();
     }
   }
 }
diff --git a/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/package-info.java b/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/package-info.java
new file mode 100644
index 000000000..b8ad27810
--- /dev/null
+++ b/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/package-info.java
@@ -0,0 +1,4 @@
+@ParametersAreNonnullByDefault
+package retrofit2.converter.gson;
+
+import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-converters/gson/src/test/java/retrofit2/GsonConverterFactoryTest.java b/retrofit-converters/gson/src/test/java/retrofit2/converter/gson/GsonConverterFactoryTest.java
similarity index 72%
rename from retrofit-converters/gson/src/test/java/retrofit2/GsonConverterFactoryTest.java
rename to retrofit-converters/gson/src/test/java/retrofit2/converter/gson/GsonConverterFactoryTest.java
index 2ea8c3f49..6113988de 100644
--- a/retrofit-converters/gson/src/test/java/retrofit2/GsonConverterFactoryTest.java
+++ b/retrofit-converters/gson/src/test/java/retrofit2/converter/gson/GsonConverterFactoryTest.java
@@ -13,25 +13,31 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.gson;
 
 import com.google.gson.Gson;
 import com.google.gson.GsonBuilder;
+import com.google.gson.JsonIOException;
 import com.google.gson.TypeAdapter;
 import com.google.gson.stream.JsonReader;
 import com.google.gson.stream.JsonToken;
 import com.google.gson.stream.JsonWriter;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import com.squareup.okhttp.mockwebserver.RecordedRequest;
 import java.io.IOException;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+import retrofit2.Call;
+import retrofit2.Response;
+import retrofit2.Retrofit;
 import retrofit2.http.Body;
+import retrofit2.http.GET;
 import retrofit2.http.POST;
 
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
 
 public final class GsonConverterFactoryTest {
   interface AnInterface {
@@ -50,6 +56,27 @@
     }
   }
 
+  static final class Value {
+    static final TypeAdapter<Value> BROKEN_ADAPTER = new TypeAdapter<Value>() {
+      @Override public void write(JsonWriter out, Value value) {
+        throw new AssertionError();
+      }
+
+      @Override public Value read(JsonReader reader) throws IOException {
+        reader.beginObject();
+        reader.nextName();
+        String theName = reader.nextString();
+        return new Value(theName);
+      }
+    };
+
+    final String theName;
+
+    Value(String theName) {
+      this.theName = theName;
+    }
+  }
+
   static class AnInterfaceAdapter extends TypeAdapter<AnInterface> {
     @Override public void write(JsonWriter jsonWriter, AnInterface anInterface) throws IOException {
       jsonWriter.beginObject();
@@ -77,6 +104,7 @@
   interface Service {
     @POST("/") Call<AnImplementation> anImplementation(@Body AnImplementation impl);
     @POST("/") Call<AnInterface> anInterface(@Body AnInterface impl);
+    @GET("/") Call<Value> value();
   }
 
   @Rule public final MockWebServer server = new MockWebServer();
@@ -86,6 +114,8 @@
   @Before public void setUp() {
     Gson gson = new GsonBuilder()
         .registerTypeAdapter(AnInterface.class, new AnInterfaceAdapter())
+        .registerTypeAdapter(Value.class, Value.BROKEN_ADAPTER)
+        .setLenient()
         .create();
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
@@ -129,4 +159,24 @@
     assertThat(request.getBody().readUtf8()).isEqualTo("{}"); // Null value was not serialized.
     assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
   }
+
+  @Test public void deserializeUsesConfiguration() throws IOException, InterruptedException {
+    server.enqueue(new MockResponse().setBody("{/* a comment! */}"));
+
+    Response<AnImplementation> response =
+        service.anImplementation(new AnImplementation("value")).execute();
+    assertThat(response.body().getName()).isNull();
+  }
+
+  @Test public void requireFullResponseDocumentConsumption() throws Exception {
+    server.enqueue(new MockResponse().setBody("{\"theName\":\"value\"}"));
+
+    Call<Value> call = service.value();
+    try {
+      call.execute();
+      fail();
+    } catch (JsonIOException e) {
+      assertThat(e).hasMessage("JSON document was not fully consumed.");
+    }
+  }
 }
diff --git a/retrofit-converters/guava/README.md b/retrofit-converters/guava/README.md
new file mode 100644
index 000000000..03eae96f5
--- /dev/null
+++ b/retrofit-converters/guava/README.md
@@ -0,0 +1,30 @@
+Guava Converter
+===============
+
+A `Converter` which supports Guava's `Optional<T>` by delegating to other converters for `T`
+and then wrapping it into `Optional`.
+
+
+Download
+--------
+
+Download [the latest JAR][1] or grab via [Maven][2]:
+```xml
+<dependency>
+  <groupId>com.squareup.retrofit2</groupId>
+  <artifactId>converter-guava</artifactId>
+  <version>latest.version</version>
+</dependency>
+```
+or [Gradle][2]:
+```groovy
+compile 'com.squareup.retrofit2:converter-guava:latest.version'
+```
+
+Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
+
+
+
+ [1]: https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=converter-guava&v=LATEST
+ [2]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup.retrofit2%22%20a%3A%22converter-guava%22
+ [snap]: https://oss.sonatype.org/content/repositories/snapshots/
diff --git a/retrofit-converters/guava/pom.xml b/retrofit-converters/guava/pom.xml
new file mode 100644
index 000000000..16e0d3896
--- /dev/null
+++ b/retrofit-converters/guava/pom.xml
@@ -0,0 +1,64 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.retrofit2</groupId>
+    <artifactId>retrofit-converters</artifactId>
+    <version>2.4.1-SNAPSHOT</version>
+    <relativePath>../pom.xml</relativePath>
+  </parent>
+
+  <artifactId>converter-guava</artifactId>
+  <name>Converter: Guava</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>retrofit</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp3</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.assertj</groupId>
+      <artifactId>assertj-core</artifactId>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-jar-plugin</artifactId>
+        <configuration>
+          <archive>
+            <manifestEntries>
+              <Automatic-Module-Name>retrofit2.converter.guava</Automatic-Module-Name>
+            </manifestEntries>
+          </archive>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
diff --git a/retrofit-converters/guava/src/main/java/retrofit/converter/guava/GuavaOptionalConverterFactory.java b/retrofit-converters/guava/src/main/java/retrofit/converter/guava/GuavaOptionalConverterFactory.java
new file mode 100644
index 000000000..bfa033614
--- /dev/null
+++ b/retrofit-converters/guava/src/main/java/retrofit/converter/guava/GuavaOptionalConverterFactory.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.converter.guava;
+
+import com.google.common.base.Optional;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import javax.annotation.Nullable;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
+
+/**
+ * A {@linkplain Converter.Factory converter} for {@code Optional<T>} which delegates to another
+ * converter to deserialize {@code T} and then wraps it into {@link Optional}.
+ */
+public final class GuavaOptionalConverterFactory extends Converter.Factory {
+  public static GuavaOptionalConverterFactory create() {
+    return new GuavaOptionalConverterFactory();
+  }
+
+  private GuavaOptionalConverterFactory() {
+  }
+
+  @Nullable @Override
+  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
+    if (getRawType(type) != Optional.class) {
+      return null;
+    }
+
+    Type innerType = getParameterUpperBound(0, (ParameterizedType) type);
+    Converter<ResponseBody, Object> delegate =
+        retrofit.nextResponseBodyConverter(this, innerType, annotations);
+    return new OptionalConverter<>(delegate);
+  }
+}
diff --git a/retrofit-converters/guava/src/main/java/retrofit/converter/guava/OptionalConverter.java b/retrofit-converters/guava/src/main/java/retrofit/converter/guava/OptionalConverter.java
new file mode 100644
index 000000000..72f2184db
--- /dev/null
+++ b/retrofit-converters/guava/src/main/java/retrofit/converter/guava/OptionalConverter.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.converter.guava;
+
+import com.google.common.base.Optional;
+import java.io.IOException;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+
+final class OptionalConverter<T> implements Converter<ResponseBody, Optional<T>> {
+  private final Converter<ResponseBody, T> delegate;
+
+  OptionalConverter(Converter<ResponseBody, T> delegate) {
+    this.delegate = delegate;
+  }
+
+  @Override public Optional<T> convert(ResponseBody value) throws IOException {
+    return Optional.fromNullable(delegate.convert(value));
+  }
+}
diff --git a/retrofit-converters/guava/src/main/java/retrofit/converter/guava/package-info.java b/retrofit-converters/guava/src/main/java/retrofit/converter/guava/package-info.java
new file mode 100644
index 000000000..bd25d1fe4
--- /dev/null
+++ b/retrofit-converters/guava/src/main/java/retrofit/converter/guava/package-info.java
@@ -0,0 +1,4 @@
+@ParametersAreNonnullByDefault
+package retrofit.converter.guava;
+
+import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-converters/guava/src/test/java/retrofit/converter/guava/AlwaysNullConverterFactory.java b/retrofit-converters/guava/src/test/java/retrofit/converter/guava/AlwaysNullConverterFactory.java
new file mode 100644
index 000000000..923252301
--- /dev/null
+++ b/retrofit-converters/guava/src/test/java/retrofit/converter/guava/AlwaysNullConverterFactory.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.converter.guava;
+
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
+
+final class AlwaysNullConverterFactory extends Converter.Factory {
+  @Override
+  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
+    return new Converter<ResponseBody, Object>() {
+      @Override public Object convert(ResponseBody value) throws IOException {
+        return null;
+      }
+    };
+  }
+}
diff --git a/retrofit-converters/guava/src/test/java/retrofit/converter/guava/GuavaOptionalConverterFactoryTest.java b/retrofit-converters/guava/src/test/java/retrofit/converter/guava/GuavaOptionalConverterFactoryTest.java
new file mode 100644
index 000000000..27680150e
--- /dev/null
+++ b/retrofit-converters/guava/src/test/java/retrofit/converter/guava/GuavaOptionalConverterFactoryTest.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.converter.guava;
+
+import com.google.common.base.Optional;
+import java.io.IOException;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Call;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class GuavaOptionalConverterFactoryTest {
+  interface Service {
+    @GET("/") Call<Optional<Object>> optional();
+    @GET("/") Call<Object> object();
+  }
+
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(GuavaOptionalConverterFactory.create())
+        .addConverterFactory(new AlwaysNullConverterFactory())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void optional() throws IOException {
+    server.enqueue(new MockResponse());
+
+    Optional<Object> optional = service.optional().execute().body();
+    assertThat(optional).isNotNull();
+    assertThat(optional.isPresent()).isFalse();
+  }
+
+  @Test public void onlyMatchesOptional() throws IOException {
+    server.enqueue(new MockResponse());
+
+    Object body = service.object().execute().body();
+    assertThat(body).isNull();
+  }
+}
diff --git a/retrofit-converters/jackson/README.md b/retrofit-converters/jackson/README.md
index d07b0afa6..2335d2903 100644
--- a/retrofit-converters/jackson/README.md
+++ b/retrofit-converters/jackson/README.md
@@ -4,7 +4,30 @@ Jackson Converter
 A `Converter` which uses [Jackson][1] for serialization to and from JSON.
 
 A default `ObjectMapper` instance will be created or one can be configured and passed to the
-`JacksonConverter` construction to further control the serialization.
+`JacksonConverterFactory` construction to further control the serialization.
+
+
+Download
+--------
+
+Download [the latest JAR][2] or grab via [Maven][3]:
+```xml
+<dependency>
+  <groupId>com.squareup.retrofit2</groupId>
+  <artifactId>converter-jackson</artifactId>
+  <version>latest.version</version>
+</dependency>
+```
+or [Gradle][3]:
+```groovy
+compile 'com.squareup.retrofit2:converter-jackson:latest.version'
+```
+
+Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
+
 
 
  [1]: http://wiki.fasterxml.com/JacksonHome
+ [2]: https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=converter-jackson&v=LATEST
+ [3]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup.retrofit2%22%20a%3A%22converter-jackson%22
+ [snap]: https://oss.sonatype.org/content/repositories/snapshots/
diff --git a/retrofit-converters/jackson/pom.xml b/retrofit-converters/jackson/pom.xml
index cccbce5cf..332f5ed04 100644
--- a/retrofit-converters/jackson/pom.xml
+++ b/retrofit-converters/jackson/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-converters</artifactId>
-    <version>2.0.0-SNAPSHOT</version>
+    <version>2.4.1-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -23,6 +23,11 @@
       <groupId>com.fasterxml.jackson.core</groupId>
       <artifactId>jackson-databind</artifactId>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
@@ -30,7 +35,7 @@
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>com.squareup.okhttp3</groupId>
       <artifactId>mockwebserver</artifactId>
       <scope>test</scope>
     </dependency>
@@ -40,4 +45,20 @@
       <scope>test</scope>
     </dependency>
   </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-jar-plugin</artifactId>
+        <configuration>
+          <archive>
+            <manifestEntries>
+              <Automatic-Module-Name>retrofit2.converter.jackson</Automatic-Module-Name>
+            </manifestEntries>
+          </archive>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
 </project>
diff --git a/retrofit-converters/jackson/src/main/java/retrofit2/JacksonConverterFactory.java b/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonConverterFactory.java
similarity index 84%
rename from retrofit-converters/jackson/src/main/java/retrofit2/JacksonConverterFactory.java
rename to retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonConverterFactory.java
index 756790901..5e5106c45 100644
--- a/retrofit-converters/jackson/src/main/java/retrofit2/JacksonConverterFactory.java
+++ b/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonConverterFactory.java
@@ -13,16 +13,18 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.jackson;
 
 import com.fasterxml.jackson.databind.JavaType;
 import com.fasterxml.jackson.databind.ObjectMapper;
 import com.fasterxml.jackson.databind.ObjectReader;
 import com.fasterxml.jackson.databind.ObjectWriter;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.ResponseBody;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
 
 /**
  * A {@linkplain Converter.Factory converter} which uses Jackson.
@@ -39,14 +41,15 @@ public static JacksonConverterFactory create() {
   }
 
   /** Create an instance using {@code mapper} for conversion. */
+  @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
   public static JacksonConverterFactory create(ObjectMapper mapper) {
+    if (mapper == null) throw new NullPointerException("mapper == null");
     return new JacksonConverterFactory(mapper);
   }
 
   private final ObjectMapper mapper;
 
   private JacksonConverterFactory(ObjectMapper mapper) {
-    if (mapper == null) throw new NullPointerException("mapper == null");
     this.mapper = mapper;
   }
 
@@ -54,15 +57,15 @@ private JacksonConverterFactory(ObjectMapper mapper) {
   public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
       Retrofit retrofit) {
     JavaType javaType = mapper.getTypeFactory().constructType(type);
-    ObjectReader reader = mapper.reader(javaType);
+    ObjectReader reader = mapper.readerFor(javaType);
     return new JacksonResponseBodyConverter<>(reader);
   }
 
   @Override
-  public Converter<?, RequestBody> requestBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
+  public Converter<?, RequestBody> requestBodyConverter(Type type,
+      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     JavaType javaType = mapper.getTypeFactory().constructType(type);
-    ObjectWriter writer = mapper.writerWithType(javaType);
+    ObjectWriter writer = mapper.writerFor(javaType);
     return new JacksonRequestBodyConverter<>(writer);
   }
 }
diff --git a/retrofit-converters/jackson/src/main/java/retrofit2/JacksonRequestBodyConverter.java b/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonRequestBodyConverter.java
similarity index 90%
rename from retrofit-converters/jackson/src/main/java/retrofit2/JacksonRequestBodyConverter.java
rename to retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonRequestBodyConverter.java
index af46a60fd..bd20a0ae0 100644
--- a/retrofit-converters/jackson/src/main/java/retrofit2/JacksonRequestBodyConverter.java
+++ b/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonRequestBodyConverter.java
@@ -13,12 +13,13 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.jackson;
 
 import com.fasterxml.jackson.databind.ObjectWriter;
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.RequestBody;
 import java.io.IOException;
+import okhttp3.MediaType;
+import okhttp3.RequestBody;
+import retrofit2.Converter;
 
 final class JacksonRequestBodyConverter<T> implements Converter<T, RequestBody> {
   private static final MediaType MEDIA_TYPE = MediaType.parse("application/json; charset=UTF-8");
diff --git a/retrofit-converters/jackson/src/main/java/retrofit2/JacksonResponseBodyConverter.java b/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonResponseBodyConverter.java
similarity index 77%
rename from retrofit-converters/jackson/src/main/java/retrofit2/JacksonResponseBodyConverter.java
rename to retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonResponseBodyConverter.java
index b22b87406..f51fde7df 100644
--- a/retrofit-converters/jackson/src/main/java/retrofit2/JacksonResponseBodyConverter.java
+++ b/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonResponseBodyConverter.java
@@ -13,12 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.jackson;
 
 import com.fasterxml.jackson.databind.ObjectReader;
-import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
-import java.io.Reader;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
 
 final class JacksonResponseBodyConverter<T> implements Converter<ResponseBody, T> {
   private final ObjectReader adapter;
@@ -28,16 +28,10 @@
   }
 
   @Override public T convert(ResponseBody value) throws IOException {
-    Reader reader = value.charStream();
     try {
-      return adapter.readValue(reader);
+      return adapter.readValue(value.charStream());
     } finally {
-      if (reader != null) {
-        try {
-          reader.close();
-        } catch (IOException ignored) {
-        }
-      }
+      value.close();
     }
   }
 }
diff --git a/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/package-info.java b/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/package-info.java
new file mode 100644
index 000000000..f747a1d6d
--- /dev/null
+++ b/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/package-info.java
@@ -0,0 +1,4 @@
+@ParametersAreNonnullByDefault
+package retrofit2.converter.jackson;
+
+import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-converters/jackson/src/test/java/retrofit2/JacksonConverterFactoryTest.java b/retrofit-converters/jackson/src/test/java/retrofit2/converter/jackson/JacksonConverterFactoryTest.java
similarity index 94%
rename from retrofit-converters/jackson/src/test/java/retrofit2/JacksonConverterFactoryTest.java
rename to retrofit-converters/jackson/src/test/java/retrofit2/converter/jackson/JacksonConverterFactoryTest.java
index e28812e7b..19c18538e 100644
--- a/retrofit-converters/jackson/src/test/java/retrofit2/JacksonConverterFactoryTest.java
+++ b/retrofit-converters/jackson/src/test/java/retrofit2/converter/jackson/JacksonConverterFactoryTest.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.jackson;
 
 import com.fasterxml.jackson.annotation.JsonAutoDetect;
 import com.fasterxml.jackson.core.JsonGenerator;
@@ -26,13 +26,17 @@
 import com.fasterxml.jackson.databind.deser.std.StdDeserializer;
 import com.fasterxml.jackson.databind.module.SimpleModule;
 import com.fasterxml.jackson.databind.ser.std.StdSerializer;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import com.squareup.okhttp.mockwebserver.RecordedRequest;
 import java.io.IOException;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+import retrofit2.Call;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.converter.jackson.JacksonConverterFactory;
 import retrofit2.http.Body;
 import retrofit2.http.POST;
 
diff --git a/retrofit-converters/java8/README.md b/retrofit-converters/java8/README.md
new file mode 100644
index 000000000..696ac23c6
--- /dev/null
+++ b/retrofit-converters/java8/README.md
@@ -0,0 +1,30 @@
+Java 8 Converter
+================
+
+A `Converter` which supports Java 8's `Optional<T>` by delegating to other converters for `T`
+and then wrapping it into `Optional`.
+
+
+Download
+--------
+
+Download [the latest JAR][1] or grab via [Maven][2]:
+```xml
+<dependency>
+  <groupId>com.squareup.retrofit2</groupId>
+  <artifactId>converter-java8</artifactId>
+  <version>latest.version</version>
+</dependency>
+```
+or [Gradle][2]:
+```groovy
+compile 'com.squareup.retrofit2:converter-java8:latest.version'
+```
+
+Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
+
+
+
+ [1]: https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=converter-java8&v=LATEST
+ [2]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup.retrofit2%22%20a%3A%22converter-java8%22
+ [snap]: https://oss.sonatype.org/content/repositories/snapshots/
diff --git a/retrofit-converters/java8/pom.xml b/retrofit-converters/java8/pom.xml
new file mode 100644
index 000000000..4f9e094f9
--- /dev/null
+++ b/retrofit-converters/java8/pom.xml
@@ -0,0 +1,76 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.retrofit2</groupId>
+    <artifactId>retrofit-converters</artifactId>
+    <version>2.4.1-SNAPSHOT</version>
+    <relativePath>../pom.xml</relativePath>
+  </parent>
+
+  <artifactId>converter-java8</artifactId>
+  <name>Converter: Java 8</name>
+
+  <properties>
+    <java.version>1.8</java.version>
+  </properties>
+
+  <dependencies>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>retrofit</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp3</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.assertj</groupId>
+      <artifactId>assertj-core</artifactId>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.codehaus.mojo</groupId>
+        <artifactId>animal-sniffer-maven-plugin</artifactId>
+        <version>${animal.sniffer.version}</version>
+        <configuration>
+          <signature>
+            <groupId>org.kaazing.mojo.signature</groupId>
+            <artifactId>java18</artifactId>
+            <version>1.0</version>
+          </signature>
+        </configuration>
+      </plugin>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-jar-plugin</artifactId>
+        <configuration>
+          <archive>
+            <manifestEntries>
+              <Automatic-Module-Name>retrofit2.converter.java8</Automatic-Module-Name>
+            </manifestEntries>
+          </archive>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
diff --git a/retrofit-converters/java8/src/main/java/retrofit/converter/java8/Java8OptionalConverterFactory.java b/retrofit-converters/java8/src/main/java/retrofit/converter/java8/Java8OptionalConverterFactory.java
new file mode 100644
index 000000000..7b55ca965
--- /dev/null
+++ b/retrofit-converters/java8/src/main/java/retrofit/converter/java8/Java8OptionalConverterFactory.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.converter.java8;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.util.Optional;
+import javax.annotation.Nullable;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
+
+/**
+ * A {@linkplain Converter.Factory converter} for {@code Optional<T>} which delegates to another
+ * converter to deserialize {@code T} and then wraps it into {@link Optional}.
+ */
+public final class Java8OptionalConverterFactory extends Converter.Factory {
+  public static Java8OptionalConverterFactory create() {
+    return new Java8OptionalConverterFactory();
+  }
+
+  private Java8OptionalConverterFactory() {
+  }
+
+  @Nullable @Override
+  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
+    if (getRawType(type) != Optional.class) {
+      return null;
+    }
+
+    Type innerType = getParameterUpperBound(0, (ParameterizedType) type);
+    Converter<ResponseBody, Object> delegate =
+        retrofit.nextResponseBodyConverter(this, innerType, annotations);
+    return new OptionalConverter<>(delegate);
+  }
+}
diff --git a/retrofit-converters/java8/src/main/java/retrofit/converter/java8/OptionalConverter.java b/retrofit-converters/java8/src/main/java/retrofit/converter/java8/OptionalConverter.java
new file mode 100644
index 000000000..438443256
--- /dev/null
+++ b/retrofit-converters/java8/src/main/java/retrofit/converter/java8/OptionalConverter.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.converter.java8;
+
+import java.io.IOException;
+import java.util.Optional;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+
+final class OptionalConverter<T> implements Converter<ResponseBody, Optional<T>> {
+  private final Converter<ResponseBody, T> delegate;
+
+  OptionalConverter(Converter<ResponseBody, T> delegate) {
+    this.delegate = delegate;
+  }
+
+  @Override public Optional<T> convert(ResponseBody value) throws IOException {
+    return Optional.ofNullable(delegate.convert(value));
+  }
+}
diff --git a/retrofit-converters/java8/src/main/java/retrofit/converter/java8/package-info.java b/retrofit-converters/java8/src/main/java/retrofit/converter/java8/package-info.java
new file mode 100644
index 000000000..e883be032
--- /dev/null
+++ b/retrofit-converters/java8/src/main/java/retrofit/converter/java8/package-info.java
@@ -0,0 +1,4 @@
+@ParametersAreNonnullByDefault
+package retrofit.converter.java8;
+
+import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-converters/java8/src/test/java/retrofit/converter/java8/AlwaysNullConverterFactory.java b/retrofit-converters/java8/src/test/java/retrofit/converter/java8/AlwaysNullConverterFactory.java
new file mode 100644
index 000000000..006b90624
--- /dev/null
+++ b/retrofit-converters/java8/src/test/java/retrofit/converter/java8/AlwaysNullConverterFactory.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.converter.java8;
+
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
+
+final class AlwaysNullConverterFactory extends Converter.Factory {
+  @Override
+  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
+    return new Converter<ResponseBody, Object>() {
+      @Override public Object convert(ResponseBody value) throws IOException {
+        return null;
+      }
+    };
+  }
+}
diff --git a/retrofit-converters/java8/src/test/java/retrofit/converter/java8/Java8OptionalConverterFactoryTest.java b/retrofit-converters/java8/src/test/java/retrofit/converter/java8/Java8OptionalConverterFactoryTest.java
new file mode 100644
index 000000000..73027907b
--- /dev/null
+++ b/retrofit-converters/java8/src/test/java/retrofit/converter/java8/Java8OptionalConverterFactoryTest.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.converter.java8;
+
+import java.io.IOException;
+import java.util.Optional;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Call;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class Java8OptionalConverterFactoryTest {
+  interface Service {
+    @GET("/") Call<Optional<Object>> optional();
+    @GET("/") Call<Object> object();
+  }
+
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(Java8OptionalConverterFactory.create())
+        .addConverterFactory(new AlwaysNullConverterFactory())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void optional() throws IOException {
+    server.enqueue(new MockResponse());
+
+    Optional<Object> optional = service.optional().execute().body();
+    assertThat(optional).isNotNull();
+    assertThat(optional.isPresent()).isFalse();
+  }
+
+  @Test public void onlyMatchesOptional() throws IOException {
+    server.enqueue(new MockResponse());
+
+    Object body = service.object().execute().body();
+    assertThat(body).isNull();
+  }
+}
diff --git a/retrofit-converters/jaxb/README.md b/retrofit-converters/jaxb/README.md
new file mode 100644
index 000000000..e35949857
--- /dev/null
+++ b/retrofit-converters/jaxb/README.md
@@ -0,0 +1,33 @@
+JAXB Converter
+==============
+
+A `Converter` which uses [JAXB][1] for serialization to and from XML.
+
+A default `JAXBContext` instance will be created or one can be configured and passed
+to `JaxbConverterFactory.create()` to further control the serialization.
+
+
+Download
+--------
+
+Download [the latest JAR][2] or grab via [Maven][3]:
+```xml
+<dependency>
+  <groupId>com.squareup.retrofit2</groupId>
+  <artifactId>converter-jaxb</artifactId>
+  <version>latest.version</version>
+</dependency>
+```
+or [Gradle][3]:
+```groovy
+compile 'com.squareup.retrofit2:converter-jaxb:latest.version'
+```
+
+Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
+
+
+
+ [1]: https://github.com/javaee/jaxb-v2
+ [2]: https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=converter-jaxb&v=LATEST
+ [3]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup.retrofit2%22%20a%3A%22converter-jaxb%22
+ [snap]: https://oss.sonatype.org/content/repositories/snapshots/
diff --git a/retrofit-converters/jaxb/pom.xml b/retrofit-converters/jaxb/pom.xml
new file mode 100644
index 000000000..ff2deee9e
--- /dev/null
+++ b/retrofit-converters/jaxb/pom.xml
@@ -0,0 +1,64 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.retrofit2</groupId>
+    <artifactId>retrofit-converters</artifactId>
+    <version>2.4.1-SNAPSHOT</version>
+    <relativePath>../pom.xml</relativePath>
+  </parent>
+
+  <artifactId>converter-jaxb</artifactId>
+  <name>Converter: JAXB</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>retrofit</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>javax.xml.bind</groupId>
+      <artifactId>jaxb-api</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp3</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.assertj</groupId>
+      <artifactId>assertj-core</artifactId>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-jar-plugin</artifactId>
+        <configuration>
+          <archive>
+            <manifestEntries>
+              <Automatic-Module-Name>retrofit2.converter.jaxb</Automatic-Module-Name>
+            </manifestEntries>
+          </archive>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
diff --git a/retrofit-converters/jaxb/src/main/java/retrofit2/converter/jaxb/JaxbConverterFactory.java b/retrofit-converters/jaxb/src/main/java/retrofit2/converter/jaxb/JaxbConverterFactory.java
new file mode 100644
index 000000000..f0c8116dc
--- /dev/null
+++ b/retrofit-converters/jaxb/src/main/java/retrofit2/converter/jaxb/JaxbConverterFactory.java
@@ -0,0 +1,79 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.converter.jaxb;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import javax.annotation.Nullable;
+import javax.xml.bind.JAXBContext;
+import javax.xml.bind.JAXBException;
+import javax.xml.bind.annotation.XmlRootElement;
+import okhttp3.MediaType;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
+
+/**
+ * A {@linkplain Converter.Factory converter} which uses JAXB for XML. All validation events are
+ * ignored.
+ */
+public final class JaxbConverterFactory extends Converter.Factory {
+  static final MediaType XML = MediaType.parse("application/xml; charset=utf-8");
+
+  /** Create an instance using a default {@link JAXBContext} instance for conversion. */
+  public static JaxbConverterFactory create() {
+    return new JaxbConverterFactory(null);
+  }
+
+  /** Create an instance using {@code context} for conversion. */
+  @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
+  public static JaxbConverterFactory create(JAXBContext context) {
+    if (context == null) throw new NullPointerException("context == null");
+    return new JaxbConverterFactory(context);
+  }
+
+  /** If null, a new JAXB context will be created for each type to be converted. */
+  private final @Nullable JAXBContext context;
+
+  private JaxbConverterFactory(@Nullable JAXBContext context) {
+    this.context = context;
+  }
+
+  @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
+      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+    if (type instanceof Class && ((Class<?>) type).isAnnotationPresent(XmlRootElement.class)) {
+      return new JaxbRequestConverter<>(contextForType((Class<?>) type), (Class<?>) type);
+    }
+    return null;
+  }
+
+  @Override public Converter<ResponseBody, ?> responseBodyConverter(
+      Type type, Annotation[] annotations, Retrofit retrofit) {
+    if (type instanceof Class && ((Class<?>) type).isAnnotationPresent(XmlRootElement.class)) {
+      return new JaxbResponseConverter<>(contextForType((Class<?>) type), (Class<?>) type);
+    }
+    return null;
+  }
+
+  private JAXBContext contextForType(Class<?> type) {
+    try {
+      return context != null ? context : JAXBContext.newInstance(type);
+    } catch (JAXBException e) {
+      throw new IllegalArgumentException(e);
+    }
+  }
+}
diff --git a/retrofit-converters/jaxb/src/main/java/retrofit2/converter/jaxb/JaxbRequestConverter.java b/retrofit-converters/jaxb/src/main/java/retrofit2/converter/jaxb/JaxbRequestConverter.java
new file mode 100644
index 000000000..7030c7a90
--- /dev/null
+++ b/retrofit-converters/jaxb/src/main/java/retrofit2/converter/jaxb/JaxbRequestConverter.java
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.converter.jaxb;
+
+import java.io.IOException;
+import javax.xml.bind.JAXBContext;
+import javax.xml.bind.JAXBException;
+import javax.xml.bind.Marshaller;
+import javax.xml.stream.XMLOutputFactory;
+import javax.xml.stream.XMLStreamException;
+import javax.xml.stream.XMLStreamWriter;
+import okhttp3.RequestBody;
+import okio.Buffer;
+import retrofit2.Converter;
+
+final class JaxbRequestConverter<T> implements Converter<T, RequestBody> {
+  final XMLOutputFactory xmlOutputFactory = XMLOutputFactory.newInstance();
+  final JAXBContext context;
+  final Class<T> type;
+
+  JaxbRequestConverter(JAXBContext context, Class<T> type) {
+    this.context = context;
+    this.type = type;
+  }
+
+  @Override public RequestBody convert(final T value) throws IOException {
+    Buffer buffer = new Buffer();
+    try {
+      Marshaller marshaller = context.createMarshaller();
+
+      XMLStreamWriter xmlWriter = xmlOutputFactory.createXMLStreamWriter(
+          buffer.outputStream(), JaxbConverterFactory.XML.charset().name());
+      marshaller.marshal(value, xmlWriter);
+    } catch (JAXBException | XMLStreamException e) {
+      throw new RuntimeException(e);
+    }
+    return RequestBody.create(JaxbConverterFactory.XML, buffer.readByteString());
+  }
+}
diff --git a/retrofit-converters/jaxb/src/main/java/retrofit2/converter/jaxb/JaxbResponseConverter.java b/retrofit-converters/jaxb/src/main/java/retrofit2/converter/jaxb/JaxbResponseConverter.java
new file mode 100644
index 000000000..1b0666b52
--- /dev/null
+++ b/retrofit-converters/jaxb/src/main/java/retrofit2/converter/jaxb/JaxbResponseConverter.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.converter.jaxb;
+
+import java.io.IOException;
+import javax.xml.bind.JAXBContext;
+import javax.xml.bind.JAXBException;
+import javax.xml.bind.Unmarshaller;
+import javax.xml.stream.XMLInputFactory;
+import javax.xml.stream.XMLStreamException;
+import javax.xml.stream.XMLStreamReader;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+
+final class JaxbResponseConverter<T> implements Converter<ResponseBody, T> {
+  final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
+  final JAXBContext context;
+  final Class<T> type;
+
+  JaxbResponseConverter(JAXBContext context, Class<T> type) {
+    this.context = context;
+    this.type = type;
+  }
+
+  @Override public T convert(ResponseBody value) throws IOException {
+    try {
+      Unmarshaller unmarshaller = context.createUnmarshaller();
+      XMLStreamReader streamReader = xmlInputFactory.createXMLStreamReader(value.charStream());
+      return unmarshaller.unmarshal(streamReader, type).getValue();
+    } catch (JAXBException | XMLStreamException e) {
+      throw new RuntimeException(e);
+    }
+  }
+}
diff --git a/retrofit-converters/jaxb/src/main/java/retrofit2/converter/jaxb/package-info.java b/retrofit-converters/jaxb/src/main/java/retrofit2/converter/jaxb/package-info.java
new file mode 100644
index 000000000..7aebe7e7b
--- /dev/null
+++ b/retrofit-converters/jaxb/src/main/java/retrofit2/converter/jaxb/package-info.java
@@ -0,0 +1,4 @@
+@ParametersAreNonnullByDefault
+package retrofit2.converter.jaxb;
+
+import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-converters/jaxb/src/test/java/retrofit2/converter/jaxb/Contact.java b/retrofit-converters/jaxb/src/test/java/retrofit2/converter/jaxb/Contact.java
new file mode 100644
index 000000000..78e523456
--- /dev/null
+++ b/retrofit-converters/jaxb/src/test/java/retrofit2/converter/jaxb/Contact.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.converter.jaxb;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import javax.xml.bind.annotation.XmlElement;
+import javax.xml.bind.annotation.XmlRootElement;
+
+@XmlRootElement(name = "contact")
+final class Contact {
+  @XmlElement(required = true)
+  public final String name;
+
+  @XmlElement(name = "phone_number")
+  public final List<PhoneNumber> phone_numbers;
+
+  @SuppressWarnings("unused") // Used by JAXB.
+  private Contact() {
+    this("", new ArrayList<PhoneNumber>());
+  }
+
+  public Contact(String name, List<PhoneNumber> phoneNumbers) {
+    this.name = name;
+    this.phone_numbers = phoneNumbers;
+  }
+
+  @Override public boolean equals(Object o) {
+    return o instanceof Contact
+        && ((Contact) o).name.equals(name)
+        && ((Contact) o).phone_numbers.equals(phone_numbers);
+  }
+
+  @Override public int hashCode() {
+    return Arrays.asList(name, phone_numbers).hashCode();
+  }
+}
diff --git a/retrofit-converters/jaxb/src/test/java/retrofit2/converter/jaxb/JaxbConverterFactoryTest.java b/retrofit-converters/jaxb/src/test/java/retrofit2/converter/jaxb/JaxbConverterFactoryTest.java
new file mode 100644
index 000000000..1067f8af5
--- /dev/null
+++ b/retrofit-converters/jaxb/src/test/java/retrofit2/converter/jaxb/JaxbConverterFactoryTest.java
@@ -0,0 +1,149 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.converter.jaxb;
+
+import java.util.Collections;
+import javax.xml.bind.JAXBContext;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Call;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.Body;
+import retrofit2.http.GET;
+import retrofit2.http.POST;
+
+import static junit.framework.TestCase.fail;
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class JaxbConverterFactoryTest {
+  static final Contact SAMPLE_CONTACT = new Contact("Jenny",
+      Collections.singletonList(new PhoneNumber("867-5309", Type.MOBILE)));
+
+  static final String SAMPLE_CONTACT_XML = ""
+      + "<?xml version=\"1.0\" ?>"
+      + "<contact>"
+      + "<name>Jenny</name>"
+      + "<phone_number type=\"MOBILE\">"
+      + "<number>867-5309</number>"
+      + "</phone_number>"
+      + "</contact>";
+
+  interface Service {
+    @POST("/") Call<Void> postXml(@Body Contact contact);
+    @GET("/") Call<Contact> getXml();
+  }
+
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private Service service;
+
+  @Before public void setUp() {
+    JaxbConverterFactory factory = JaxbConverterFactory.create();
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(factory)
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void xmlRequestBody() throws Exception {
+    server.enqueue(new MockResponse());
+
+    Call<Void> call = service.postXml(SAMPLE_CONTACT);
+    call.execute();
+
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getHeader("Content-Type")).isEqualTo("application/xml; charset=utf-8");
+    assertThat(request.getBody().readUtf8()).isEqualTo(SAMPLE_CONTACT_XML);
+  }
+
+  @Test public void xmlResponseBody() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody(SAMPLE_CONTACT_XML));
+
+    Call<Contact> call = service.getXml();
+    Response<Contact> response = call.execute();
+    assertThat(response.body()).isEqualTo(SAMPLE_CONTACT);
+  }
+
+  @Test public void characterEncoding() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody(""
+            + "<?xml version=\"1.0\" ?>"
+            + "<contact>"
+            + "<name>Бронтозавр \uD83E\uDD95 ティラノサウルス・レックス &#129430;</name>"
+            + "</contact>"));
+
+    Call<Contact> call = service.getXml();
+    Response<Contact> response = call.execute();
+    assertThat(response.body().name)
+        .isEqualTo("Бронтозавр \uD83E\uDD95 ティラノサウルス・レックス \uD83E\uDD96");
+  }
+
+  @Test public void userSuppliedJaxbContext() throws Exception {
+    JAXBContext context = JAXBContext.newInstance(Contact.class);
+    JaxbConverterFactory factory = JaxbConverterFactory.create(context);
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(factory)
+        .build();
+    service = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse());
+
+    Call<Void> call = service.postXml(SAMPLE_CONTACT);
+    call.execute();
+
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getHeader("Content-Type")).isEqualTo("application/xml; charset=utf-8");
+    assertThat(request.getBody().readUtf8()).isEqualTo(SAMPLE_CONTACT_XML);
+  }
+
+  @Test public void malformedXml() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("This is not XML"));
+
+    Call<Contact> call = service.getXml();
+    try {
+      call.execute();
+      fail();
+    } catch (RuntimeException expected) {
+      assertThat(expected).hasMessageContaining("ParseError");
+    }
+  }
+
+  @Test public void unrecognizedField() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody(""
+            + "<?xml version=\"1.0\" ?>"
+            + "<contact>"
+            + "<name>Jenny</name>"
+            + "<age>21</age>"
+            + "<phone_number type=\"FAX\">"
+            + "<number>867-5309</number>"
+            + "</phone_number>"
+            + "</contact>"));
+
+    Call<Contact> call = service.getXml();
+    Response<Contact> response = call.execute();
+    assertThat(response.body().name).isEqualTo("Jenny");
+  }
+}
diff --git a/retrofit-converters/jaxb/src/test/java/retrofit2/converter/jaxb/PhoneNumber.java b/retrofit-converters/jaxb/src/test/java/retrofit2/converter/jaxb/PhoneNumber.java
new file mode 100644
index 000000000..927f0e8f1
--- /dev/null
+++ b/retrofit-converters/jaxb/src/test/java/retrofit2/converter/jaxb/PhoneNumber.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.converter.jaxb;
+
+import java.util.Arrays;
+import javax.annotation.Nullable;
+import javax.xml.bind.annotation.XmlAttribute;
+import javax.xml.bind.annotation.XmlElement;
+
+final class PhoneNumber {
+  @XmlElement(required = true)
+  public final String number;
+
+  @XmlAttribute
+  public final Type type;
+
+  @SuppressWarnings("unused") // Used by JAXB.
+  private PhoneNumber() {
+    this("", Type.OTHER);
+  }
+
+  PhoneNumber(String number, @Nullable Type type) {
+    this.number = number;
+    this.type = type;
+  }
+
+  @Override public boolean equals(Object o) {
+    return o instanceof PhoneNumber
+        && ((PhoneNumber) o).number.equals(number)
+        && ((PhoneNumber) o).type.equals(type);
+  }
+
+  @Override public int hashCode() {
+    return Arrays.asList(number, type).hashCode();
+  }
+}
diff --git a/retrofit-converters/jaxb/src/test/java/retrofit2/converter/jaxb/Type.java b/retrofit-converters/jaxb/src/test/java/retrofit2/converter/jaxb/Type.java
new file mode 100644
index 000000000..e8b93d2e6
--- /dev/null
+++ b/retrofit-converters/jaxb/src/test/java/retrofit2/converter/jaxb/Type.java
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.converter.jaxb;
+
+enum Type {
+  OTHER, MOBILE
+}
diff --git a/retrofit-converters/moshi/README.md b/retrofit-converters/moshi/README.md
index 9968ccd38..c5668f9ab 100644
--- a/retrofit-converters/moshi/README.md
+++ b/retrofit-converters/moshi/README.md
@@ -7,4 +7,27 @@ A default `Moshi` instance will be created or one can be configured and passed t
 `MoshiConverterFactory.create()` to further control the serialization.
 
 
+Download
+--------
+
+Download [the latest JAR][2] or grab via [Maven][3]:
+```xml
+<dependency>
+  <groupId>com.squareup.retrofit2</groupId>
+  <artifactId>converter-moshi</artifactId>
+  <version>latest.version</version>
+</dependency>
+```
+or [Gradle][3]:
+```groovy
+compile 'com.squareup.retrofit2:converter-moshi:latest.version'
+```
+
+Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
+
+
+
  [1]: https://github.com/square/moshi
+ [2]: https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=converter-moshi&v=LATEST
+ [3]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup.retrofit2%22%20a%3A%22converter-moshi%22
+ [snap]: https://oss.sonatype.org/content/repositories/snapshots/
diff --git a/retrofit-converters/moshi/pom.xml b/retrofit-converters/moshi/pom.xml
index 2ce692676..884422a43 100644
--- a/retrofit-converters/moshi/pom.xml
+++ b/retrofit-converters/moshi/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-converters</artifactId>
-    <version>2.0.0-SNAPSHOT</version>
+    <version>2.4.1-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -23,6 +23,11 @@
       <groupId>com.squareup.moshi</groupId>
       <artifactId>moshi</artifactId>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
@@ -30,7 +35,7 @@
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>com.squareup.okhttp3</groupId>
       <artifactId>mockwebserver</artifactId>
       <scope>test</scope>
     </dependency>
@@ -40,4 +45,20 @@
       <scope>test</scope>
     </dependency>
   </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-jar-plugin</artifactId>
+        <configuration>
+          <archive>
+            <manifestEntries>
+              <Automatic-Module-Name>retrofit2.converter.moshi</Automatic-Module-Name>
+            </manifestEntries>
+          </archive>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
 </project>
diff --git a/retrofit-converters/moshi/src/main/java/retrofit2/MoshiConverterFactory.java b/retrofit-converters/moshi/src/main/java/retrofit2/MoshiConverterFactory.java
deleted file mode 100644
index 2f04ab12f..000000000
--- a/retrofit-converters/moshi/src/main/java/retrofit2/MoshiConverterFactory.java
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2;
-
-import com.squareup.moshi.JsonAdapter;
-import com.squareup.moshi.Moshi;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.ResponseBody;
-import java.lang.annotation.Annotation;
-import java.lang.reflect.Type;
-
-/**
- * A {@linkplain Converter.Factory converter} which uses Moshi for JSON.
- * <p>
- * Because Moshi is so flexible in the types it supports, this converter assumes that it can handle
- * all types. If you are mixing JSON serialization with something else (such as protocol buffers),
- * you must {@linkplain Retrofit.Builder#addConverterFactory(Converter.Factory) add this instance}
- * last to allow the other converters a chance to see their types.
- */
-public final class MoshiConverterFactory extends Converter.Factory {
-  /** Create an instance using a default {@link Moshi} instance for conversion. */
-  public static MoshiConverterFactory create() {
-    return create(new Moshi.Builder().build());
-  }
-
-  /** Create an instance using {@code moshi} for conversion. */
-  public static MoshiConverterFactory create(Moshi moshi) {
-    return new MoshiConverterFactory(moshi);
-  }
-
-  private final Moshi moshi;
-
-  private MoshiConverterFactory(Moshi moshi) {
-    if (moshi == null) throw new NullPointerException("moshi == null");
-    this.moshi = moshi;
-  }
-
-  @Override
-  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
-    JsonAdapter<?> adapter = moshi.adapter(type);
-    return new MoshiResponseBodyConverter<>(adapter);
-  }
-
-  @Override
-  public Converter<?, RequestBody> requestBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
-    JsonAdapter<?> adapter = moshi.adapter(type);
-    return new MoshiRequestBodyConverter<>(adapter);
-  }
-}
diff --git a/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiConverterFactory.java b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiConverterFactory.java
new file mode 100644
index 000000000..b7c016190
--- /dev/null
+++ b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiConverterFactory.java
@@ -0,0 +1,129 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.converter.moshi;
+
+import com.squareup.moshi.JsonAdapter;
+import com.squareup.moshi.JsonQualifier;
+import com.squareup.moshi.Moshi;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import java.util.Collections;
+import java.util.LinkedHashSet;
+import java.util.Set;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
+
+import static java.util.Collections.unmodifiableSet;
+
+/**
+ * A {@linkplain Converter.Factory converter} which uses Moshi for JSON.
+ * <p>
+ * Because Moshi is so flexible in the types it supports, this converter assumes that it can handle
+ * all types. If you are mixing JSON serialization with something else (such as protocol buffers),
+ * you must {@linkplain Retrofit.Builder#addConverterFactory(Converter.Factory) add this instance}
+ * last to allow the other converters a chance to see their types.
+ * <p>
+ * Any {@link JsonQualifier @JsonQualifier}-annotated annotations on the parameter will be used
+ * when looking up a request body converter and those on the method will be used when looking up a
+ * response body converter.
+ */
+public final class MoshiConverterFactory extends Converter.Factory {
+  /** Create an instance using a default {@link Moshi} instance for conversion. */
+  public static MoshiConverterFactory create() {
+    return create(new Moshi.Builder().build());
+  }
+
+  /** Create an instance using {@code moshi} for conversion. */
+  @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
+  public static MoshiConverterFactory create(Moshi moshi) {
+    if (moshi == null) throw new NullPointerException("moshi == null");
+    return new MoshiConverterFactory(moshi, false, false, false);
+  }
+
+  private final Moshi moshi;
+  private final boolean lenient;
+  private final boolean failOnUnknown;
+  private final boolean serializeNulls;
+
+  private MoshiConverterFactory(Moshi moshi, boolean lenient, boolean failOnUnknown,
+      boolean serializeNulls) {
+    this.moshi = moshi;
+    this.lenient = lenient;
+    this.failOnUnknown = failOnUnknown;
+    this.serializeNulls = serializeNulls;
+  }
+
+  /** Return a new factory which uses {@linkplain JsonAdapter#lenient() lenient} adapters. */
+  public MoshiConverterFactory asLenient() {
+    return new MoshiConverterFactory(moshi, true, failOnUnknown, serializeNulls);
+  }
+
+  /**
+   * Return a new factory which uses {@link JsonAdapter#failOnUnknown()} adapters.
+   */
+  public MoshiConverterFactory failOnUnknown() {
+    return new MoshiConverterFactory(moshi, lenient, true, serializeNulls);
+  }
+
+  /** Return a new factory which includes null values into the serialized JSON. */
+  public MoshiConverterFactory withNullSerialization() {
+    return new MoshiConverterFactory(moshi, lenient, failOnUnknown, true);
+  }
+
+  @Override
+  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
+    JsonAdapter<?> adapter = moshi.adapter(type, jsonAnnotations(annotations));
+    if (lenient) {
+      adapter = adapter.lenient();
+    }
+    if (failOnUnknown) {
+      adapter = adapter.failOnUnknown();
+    }
+    if (serializeNulls) {
+      adapter = adapter.serializeNulls();
+    }
+    return new MoshiResponseBodyConverter<>(adapter);
+  }
+
+  @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
+      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+    JsonAdapter<?> adapter = moshi.adapter(type, jsonAnnotations(parameterAnnotations));
+    if (lenient) {
+      adapter = adapter.lenient();
+    }
+    if (failOnUnknown) {
+      adapter = adapter.failOnUnknown();
+    }
+    if (serializeNulls) {
+      adapter = adapter.serializeNulls();
+    }
+    return new MoshiRequestBodyConverter<>(adapter);
+  }
+
+  private static Set<? extends Annotation> jsonAnnotations(Annotation[] annotations) {
+    Set<Annotation> result = null;
+    for (Annotation annotation : annotations) {
+      if (annotation.annotationType().isAnnotationPresent(JsonQualifier.class)) {
+        if (result == null) result = new LinkedHashSet<>();
+        result.add(annotation);
+      }
+    }
+    return result != null ? unmodifiableSet(result) : Collections.<Annotation>emptySet();
+  }
+}
diff --git a/retrofit-converters/moshi/src/main/java/retrofit2/MoshiRequestBodyConverter.java b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiRequestBodyConverter.java
similarity index 82%
rename from retrofit-converters/moshi/src/main/java/retrofit2/MoshiRequestBodyConverter.java
rename to retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiRequestBodyConverter.java
index fae968f69..edbcf243e 100644
--- a/retrofit-converters/moshi/src/main/java/retrofit2/MoshiRequestBodyConverter.java
+++ b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiRequestBodyConverter.java
@@ -13,13 +13,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.moshi;
 
 import com.squareup.moshi.JsonAdapter;
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.RequestBody;
+import com.squareup.moshi.JsonWriter;
 import java.io.IOException;
+import okhttp3.MediaType;
+import okhttp3.RequestBody;
 import okio.Buffer;
+import retrofit2.Converter;
 
 final class MoshiRequestBodyConverter<T> implements Converter<T, RequestBody> {
   private static final MediaType MEDIA_TYPE = MediaType.parse("application/json; charset=UTF-8");
@@ -32,11 +34,8 @@
 
   @Override public RequestBody convert(T value) throws IOException {
     Buffer buffer = new Buffer();
-    try {
-      adapter.toJson(buffer, value);
-    } catch (IOException e) {
-      throw new AssertionError(e); // Writing to Buffer does no I/O.
-    }
+    JsonWriter writer = JsonWriter.of(buffer);
+    adapter.toJson(writer, value);
     return RequestBody.create(MEDIA_TYPE, buffer.readByteString());
   }
 }
diff --git a/retrofit-converters/moshi/src/main/java/retrofit2/MoshiResponseBodyConverter.java b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiResponseBodyConverter.java
similarity index 56%
rename from retrofit-converters/moshi/src/main/java/retrofit2/MoshiResponseBodyConverter.java
rename to retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiResponseBodyConverter.java
index 3aa83f0b9..a19a66ccd 100644
--- a/retrofit-converters/moshi/src/main/java/retrofit2/MoshiResponseBodyConverter.java
+++ b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiResponseBodyConverter.java
@@ -13,14 +13,20 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.moshi;
 
 import com.squareup.moshi.JsonAdapter;
-import com.squareup.okhttp.ResponseBody;
+import com.squareup.moshi.JsonDataException;
+import com.squareup.moshi.JsonReader;
 import java.io.IOException;
+import okhttp3.ResponseBody;
 import okio.BufferedSource;
+import okio.ByteString;
+import retrofit2.Converter;
 
 final class MoshiResponseBodyConverter<T> implements Converter<ResponseBody, T> {
+  private static final ByteString UTF8_BOM = ByteString.decodeHex("EFBBBF");
+
   private final JsonAdapter<T> adapter;
 
   MoshiResponseBodyConverter(JsonAdapter<T> adapter) {
@@ -30,14 +36,19 @@
   @Override public T convert(ResponseBody value) throws IOException {
     BufferedSource source = value.source();
     try {
-      return adapter.fromJson(source);
-    } finally {
-      if (source != null) {
-        try {
-          source.close();
-        } catch (IOException ignored) {
-        }
+      // Moshi has no document-level API so the responsibility of BOM skipping falls to whatever
+      // is delegating to it. Since it's a UTF-8-only library as well we only honor the UTF-8 BOM.
+      if (source.rangeEquals(0, UTF8_BOM)) {
+        source.skip(UTF8_BOM.size());
       }
+      JsonReader reader = JsonReader.of(source);
+      T result = adapter.fromJson(reader);
+      if (reader.peek() != JsonReader.Token.END_DOCUMENT) {
+        throw new JsonDataException("JSON document was not fully consumed.");
+      }
+      return result;
+    } finally {
+      value.close();
     }
   }
 }
diff --git a/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/package-info.java b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/package-info.java
new file mode 100644
index 000000000..2d5a38a51
--- /dev/null
+++ b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/package-info.java
@@ -0,0 +1,4 @@
+@ParametersAreNonnullByDefault
+package retrofit2.converter.moshi;
+
+import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-converters/moshi/src/test/java/retrofit2/MoshiConverterFactoryTest.java b/retrofit-converters/moshi/src/test/java/retrofit2/MoshiConverterFactoryTest.java
deleted file mode 100644
index 6984e4834..000000000
--- a/retrofit-converters/moshi/src/test/java/retrofit2/MoshiConverterFactoryTest.java
+++ /dev/null
@@ -1,121 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2;
-
-import com.squareup.moshi.FromJson;
-import com.squareup.moshi.JsonReader;
-import com.squareup.moshi.JsonWriter;
-import com.squareup.moshi.Moshi;
-import com.squareup.moshi.ToJson;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import com.squareup.okhttp.mockwebserver.RecordedRequest;
-import java.io.IOException;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import retrofit2.http.Body;
-import retrofit2.http.POST;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
-public final class MoshiConverterFactoryTest {
-  interface AnInterface {
-    String getName();
-  }
-
-  static class AnImplementation implements AnInterface {
-    private final String theName;
-
-    AnImplementation(String name) {
-      theName = name;
-    }
-
-    @Override public String getName() {
-      return theName;
-    }
-  }
-
-  static class AnInterfaceAdapter {
-    @ToJson public void write(JsonWriter jsonWriter, AnInterface anInterface) throws IOException {
-      jsonWriter.beginObject();
-      jsonWriter.name("name").value(anInterface.getName());
-      jsonWriter.endObject();
-    }
-
-    @FromJson public AnInterface read(JsonReader jsonReader) throws IOException {
-      jsonReader.beginObject();
-
-      String name = null;
-      while (jsonReader.hasNext()) {
-        switch (jsonReader.nextName()) {
-          case "name":
-            name = jsonReader.nextString();
-            break;
-        }
-      }
-
-      jsonReader.endObject();
-      return new AnImplementation(name);
-    }
-  }
-
-  interface Service {
-    @POST("/") Call<AnImplementation> anImplementation(@Body AnImplementation impl);
-    @POST("/") Call<AnInterface> anInterface(@Body AnInterface impl);
-  }
-
-  @Rule public final MockWebServer server = new MockWebServer();
-
-  private Service service;
-
-  @Before public void setUp() {
-    Moshi moshi = new Moshi.Builder()
-        .add(new AnInterfaceAdapter())
-        .build();
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(MoshiConverterFactory.create(moshi))
-        .build();
-    service = retrofit.create(Service.class);
-  }
-
-  @Test public void anInterface() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse().setBody("{\"name\":\"value\"}"));
-
-    Call<AnInterface> call = service.anInterface(new AnImplementation("value"));
-    Response<AnInterface> response = call.execute();
-    AnInterface body = response.body();
-    assertThat(body.getName()).isEqualTo("value");
-
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getBody().readUtf8()).isEqualTo("{\"name\":\"value\"}");
-    assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
-  }
-
-  @Test public void anImplementation() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse().setBody("{\"theName\":\"value\"}"));
-
-    Call<AnImplementation> call = service.anImplementation(new AnImplementation("value"));
-    Response<AnImplementation> response = call.execute();
-    AnImplementation body = response.body();
-    assertThat(body.theName).isEqualTo("value");
-
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getBody().readUtf8()).isEqualTo("{\"theName\":\"value\"}");
-    assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
-  }
-}
diff --git a/retrofit-converters/moshi/src/test/java/retrofit2/converter/moshi/MoshiConverterFactoryTest.java b/retrofit-converters/moshi/src/test/java/retrofit2/converter/moshi/MoshiConverterFactoryTest.java
new file mode 100644
index 000000000..0a015ff49
--- /dev/null
+++ b/retrofit-converters/moshi/src/test/java/retrofit2/converter/moshi/MoshiConverterFactoryTest.java
@@ -0,0 +1,301 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.converter.moshi;
+
+import com.squareup.moshi.FromJson;
+import com.squareup.moshi.JsonAdapter;
+import com.squareup.moshi.JsonDataException;
+import com.squareup.moshi.JsonQualifier;
+import com.squareup.moshi.JsonReader;
+import com.squareup.moshi.JsonWriter;
+import com.squareup.moshi.Moshi;
+import com.squareup.moshi.ToJson;
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.annotation.Retention;
+import java.lang.reflect.Type;
+import java.nio.charset.Charset;
+import java.util.Set;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
+import okio.Buffer;
+import okio.ByteString;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Call;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.Body;
+import retrofit2.http.GET;
+import retrofit2.http.POST;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+public final class MoshiConverterFactoryTest {
+  @Retention(RUNTIME)
+  @JsonQualifier
+  @interface Qualifier {}
+
+  @Retention(RUNTIME)
+  @interface NonQualifer {}
+
+  interface AnInterface {
+    String getName();
+  }
+
+  static class AnImplementation implements AnInterface {
+    private final String theName;
+
+    AnImplementation(String name) {
+      theName = name;
+    }
+
+    @Override public String getName() {
+      return theName;
+    }
+  }
+
+  static final class Value {
+    final String theName;
+
+    Value(String theName) {
+      this.theName = theName;
+    }
+  }
+
+  static class Adapters {
+    @ToJson public void write(JsonWriter jsonWriter, AnInterface anInterface) throws IOException {
+      jsonWriter.beginObject();
+      jsonWriter.name("name").value(anInterface.getName());
+      jsonWriter.endObject();
+    }
+
+    @FromJson public AnInterface read(JsonReader jsonReader) throws IOException {
+      jsonReader.beginObject();
+
+      String name = null;
+      while (jsonReader.hasNext()) {
+        switch (jsonReader.nextName()) {
+          case "name":
+            name = jsonReader.nextString();
+            break;
+        }
+      }
+
+      jsonReader.endObject();
+      return new AnImplementation(name);
+    }
+
+    @ToJson public void write(JsonWriter writer, @Qualifier String value) throws IOException {
+      writer.value("qualified!");
+    }
+
+    @FromJson @Qualifier public String readQualified(JsonReader reader) throws IOException {
+      String string = reader.nextString();
+      if (string.equals("qualified!")) {
+        return "it worked!";
+      }
+      throw new AssertionError("Found: " + string);
+    }
+
+    @FromJson public Value readWithoutEndingObject(JsonReader reader) throws IOException {
+      reader.beginObject();
+      reader.nextName();
+      String theName = reader.nextString();
+      return new Value(theName);
+    }
+  }
+
+  interface Service {
+    @POST("/") Call<AnImplementation> anImplementation(@Body AnImplementation impl);
+    @POST("/") Call<AnInterface> anInterface(@Body AnInterface impl);
+    @GET("/") Call<Value> value();
+
+    @POST("/") @Qualifier @NonQualifer //
+    Call<String> annotations(@Body @Qualifier @NonQualifer String body);
+  }
+
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private Service service;
+  private Service serviceLenient;
+  private Service serviceNulls;
+  private Service serviceFailOnUnknown;
+
+  @Before public void setUp() {
+    Moshi moshi = new Moshi.Builder()
+        .add(new JsonAdapter.Factory() {
+          @Override public JsonAdapter<?> create(Type type, Set<? extends Annotation> annotations,
+              Moshi moshi) {
+            for (Annotation annotation : annotations) {
+              if (!annotation.annotationType().isAnnotationPresent(JsonQualifier.class)) {
+                throw new AssertionError("Non-@JsonQualifier annotation: " + annotation);
+              }
+            }
+            return null;
+          }
+        })
+        .add(new Adapters())
+        .build();
+    MoshiConverterFactory factory = MoshiConverterFactory.create(moshi);
+    MoshiConverterFactory factoryLenient = factory.asLenient();
+    MoshiConverterFactory factoryNulls = factory.withNullSerialization();
+    MoshiConverterFactory factoryFailOnUnknown = factory.failOnUnknown();
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(factory)
+        .build();
+    Retrofit retrofitLenient = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(factoryLenient)
+        .build();
+    Retrofit retrofitNulls = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(factoryNulls)
+        .build();
+    Retrofit retrofitFailOnUnknown = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(factoryFailOnUnknown)
+        .build();
+    service = retrofit.create(Service.class);
+    serviceLenient = retrofitLenient.create(Service.class);
+    serviceNulls = retrofitNulls.create(Service.class);
+    serviceFailOnUnknown = retrofitFailOnUnknown.create(Service.class);
+  }
+
+  @Test public void anInterface() throws IOException, InterruptedException {
+    server.enqueue(new MockResponse().setBody("{\"name\":\"value\"}"));
+
+    Call<AnInterface> call = service.anInterface(new AnImplementation("value"));
+    Response<AnInterface> response = call.execute();
+    AnInterface body = response.body();
+    assertThat(body.getName()).isEqualTo("value");
+
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getBody().readUtf8()).isEqualTo("{\"name\":\"value\"}");
+    assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
+  }
+
+  @Test public void anImplementation() throws IOException, InterruptedException {
+    server.enqueue(new MockResponse().setBody("{\"theName\":\"value\"}"));
+
+    Call<AnImplementation> call = service.anImplementation(new AnImplementation("value"));
+    Response<AnImplementation> response = call.execute();
+    AnImplementation body = response.body();
+    assertThat(body.theName).isEqualTo("value");
+
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getBody().readUtf8()).isEqualTo("{\"theName\":\"value\"}");
+    assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
+  }
+
+  @Test public void annotations() throws IOException, InterruptedException {
+    server.enqueue(new MockResponse().setBody("\"qualified!\""));
+
+    Call<String> call = service.annotations("value");
+    Response<String> response = call.execute();
+    assertThat(response.body()).isEqualTo("it worked!");
+
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getBody().readUtf8()).isEqualTo("\"qualified!\"");
+    assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
+  }
+
+  @Test public void asLenient() throws IOException, InterruptedException {
+    MockResponse malformedResponse = new MockResponse().setBody("{\"theName\":value}");
+    server.enqueue(malformedResponse);
+    server.enqueue(malformedResponse);
+
+    Call<AnImplementation> call = service.anImplementation(new AnImplementation("value"));
+    try {
+      call.execute();
+      fail();
+    } catch (IOException e) {
+      assertEquals(e.getMessage(),
+          "Use JsonReader.setLenient(true) to accept malformed JSON at path $.theName");
+    }
+
+    Call<AnImplementation> call2 = serviceLenient.anImplementation(new AnImplementation("value"));
+    Response<AnImplementation> response = call2.execute();
+    AnImplementation body = response.body();
+    assertThat(body.theName).isEqualTo("value");
+  }
+
+  @Test public void withNulls() throws IOException, InterruptedException {
+    server.enqueue(new MockResponse().setBody("{}"));
+
+    Call<AnImplementation> call = serviceNulls.anImplementation(new AnImplementation(null));
+    call.execute();
+    assertEquals("{\"theName\":null}", server.takeRequest().getBody().readUtf8());
+  }
+
+  @Test public void failOnUnknown() throws IOException, InterruptedException {
+    server.enqueue(new MockResponse().setBody("{\"taco\":\"delicious\"}"));
+
+    Call<AnImplementation> call = serviceFailOnUnknown.anImplementation(new AnImplementation(null));
+    try {
+      call.execute();
+      fail();
+    } catch (JsonDataException e) {
+      assertThat(e).hasMessage("Cannot skip unexpected STRING at $.taco");
+    }
+  }
+
+  @Test public void utf8BomSkipped() throws IOException {
+    Buffer responseBody = new Buffer()
+        .write(ByteString.decodeHex("EFBBBF"))
+        .writeUtf8("{\"theName\":\"value\"}");
+    MockResponse malformedResponse = new MockResponse().setBody(responseBody);
+    server.enqueue(malformedResponse);
+
+    Call<AnImplementation> call = service.anImplementation(new AnImplementation("value"));
+    Response<AnImplementation> response = call.execute();
+    AnImplementation body = response.body();
+    assertThat(body.theName).isEqualTo("value");
+  }
+
+  @Test public void nonUtf8BomIsNotSkipped() throws IOException {
+    Buffer responseBody = new Buffer()
+        .write(ByteString.decodeHex("FEFF"))
+        .writeString("{\"theName\":\"value\"}", Charset.forName("UTF-16"));
+    MockResponse malformedResponse = new MockResponse().setBody(responseBody);
+    server.enqueue(malformedResponse);
+
+    Call<AnImplementation> call = service.anImplementation(new AnImplementation("value"));
+    try {
+      call.execute();
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  @Test public void requireFullResponseDocumentConsumption() throws Exception {
+    server.enqueue(new MockResponse().setBody("{\"theName\":\"value\"}"));
+
+    Call<Value> call = service.value();
+    try {
+      call.execute();
+      fail();
+    } catch (JsonDataException e) {
+      assertThat(e).hasMessage("JSON document was not fully consumed.");
+    }
+  }
+}
diff --git a/retrofit-converters/pom.xml b/retrofit-converters/pom.xml
index 64adb3892..0aebd3275 100644
--- a/retrofit-converters/pom.xml
+++ b/retrofit-converters/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>parent</artifactId>
-    <version>2.0.0-SNAPSHOT</version>
+    <version>2.4.1-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -16,11 +16,14 @@
 
   <modules>
     <module>gson</module>
+    <module>guava</module>
     <module>protobuf</module>
     <module>jackson</module>
+    <module>java8</module>
     <module>wire</module>
     <module>simplexml</module>
     <module>scalars</module>
     <module>moshi</module>
+    <module>jaxb</module>
   </modules>
 </project>
diff --git a/retrofit-converters/protobuf/README.md b/retrofit-converters/protobuf/README.md
index ca4334147..7575a3d6c 100644
--- a/retrofit-converters/protobuf/README.md
+++ b/retrofit-converters/protobuf/README.md
@@ -4,4 +4,27 @@ Google Protocol Buffer Converter
 A `Converter` which uses [Protocol Buffer][1] binary serialization.
 
 
+Download
+--------
+
+Download [the latest JAR][2] or grab via [Maven][3]:
+```xml
+<dependency>
+  <groupId>com.squareup.retrofit2</groupId>
+  <artifactId>converter-protobuf</artifactId>
+  <version>latest.version</version>
+</dependency>
+```
+or [Gradle][3]:
+```groovy
+compile 'com.squareup.retrofit2:converter-protobuf:latest.version'
+```
+
+Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
+
+
+
  [1]: https://developers.google.com/protocol-buffers/
+ [2]: https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=converter-protobuf&v=LATEST
+ [3]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup.retrofit2%22%20a%3A%22converter-protobuf%22
+ [snap]: https://oss.sonatype.org/content/repositories/snapshots/
diff --git a/retrofit-converters/protobuf/pom.xml b/retrofit-converters/protobuf/pom.xml
index 5d2c876b7..8d61abf6a 100644
--- a/retrofit-converters/protobuf/pom.xml
+++ b/retrofit-converters/protobuf/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-converters</artifactId>
-    <version>2.0.0-SNAPSHOT</version>
+    <version>2.4.1-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -23,6 +23,11 @@
       <groupId>com.google.protobuf</groupId>
       <artifactId>protobuf-java</artifactId>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
@@ -30,7 +35,7 @@
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>com.squareup.okhttp3</groupId>
       <artifactId>mockwebserver</artifactId>
       <scope>test</scope>
     </dependency>
@@ -40,4 +45,20 @@
       <scope>test</scope>
     </dependency>
   </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-jar-plugin</artifactId>
+        <configuration>
+          <archive>
+            <manifestEntries>
+              <Automatic-Module-Name>retrofit2.converter.protobuf</Automatic-Module-Name>
+            </manifestEntries>
+          </archive>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
 </project>
diff --git a/retrofit-converters/protobuf/src/main/java/retrofit2/ProtoConverterFactory.java b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoConverterFactory.java
similarity index 51%
rename from retrofit-converters/protobuf/src/main/java/retrofit2/ProtoConverterFactory.java
rename to retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoConverterFactory.java
index 1a5e2bad1..6fb529429 100644
--- a/retrofit-converters/protobuf/src/main/java/retrofit2/ProtoConverterFactory.java
+++ b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoConverterFactory.java
@@ -13,15 +13,21 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.protobuf;
 
+import com.google.protobuf.ExtensionRegistryLite;
 import com.google.protobuf.MessageLite;
 import com.google.protobuf.Parser;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.ResponseBody;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Field;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
 import java.lang.reflect.Type;
+import javax.annotation.Nullable;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
 
 /**
  * A {@linkplain Converter.Factory converter} which uses Protocol Buffers.
@@ -31,7 +37,18 @@
  */
 public final class ProtoConverterFactory extends Converter.Factory {
   public static ProtoConverterFactory create() {
-    return new ProtoConverterFactory();
+    return new ProtoConverterFactory(null);
+  }
+
+  /** Create an instance which uses {@code registry} when deserializing. */
+  public static ProtoConverterFactory createWithRegistry(@Nullable ExtensionRegistryLite registry) {
+    return new ProtoConverterFactory(registry);
+  }
+
+  private final @Nullable ExtensionRegistryLite registry;
+
+  private ProtoConverterFactory(@Nullable ExtensionRegistryLite registry) {
+    this.registry = registry;
   }
 
   @Override
@@ -47,19 +64,29 @@ public static ProtoConverterFactory create() {
 
     Parser<MessageLite> parser;
     try {
-      Field field = c.getDeclaredField("PARSER");
+      Method method = c.getDeclaredMethod("parser");
       //noinspection unchecked
-      parser = (Parser<MessageLite>) field.get(null);
-    } catch (NoSuchFieldException | IllegalAccessException e) {
-      throw new IllegalArgumentException(
-          "Found a protobuf message but " + c.getName() + " had no PARSER field.");
+      parser = (Parser<MessageLite>) method.invoke(null);
+    } catch (InvocationTargetException e) {
+      throw new RuntimeException(e.getCause());
+    } catch (NoSuchMethodException | IllegalAccessException ignored) {
+      // If the method is missing, fall back to original static field for pre-3.0 support.
+      try {
+        Field field = c.getDeclaredField("PARSER");
+        //noinspection unchecked
+        parser = (Parser<MessageLite>) field.get(null);
+      } catch (NoSuchFieldException | IllegalAccessException e) {
+        throw new IllegalArgumentException("Found a protobuf message but "
+            + c.getName()
+            + " had no parser() method or PARSER field.");
+      }
     }
-    return new ProtoResponseBodyConverter<>(parser);
+    return new ProtoResponseBodyConverter<>(parser, registry);
   }
 
   @Override
-  public Converter<?, RequestBody> requestBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
+  public Converter<?, RequestBody> requestBodyConverter(Type type,
+      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     if (!(type instanceof Class<?>)) {
       return null;
     }
diff --git a/retrofit-converters/protobuf/src/main/java/retrofit2/ProtoRequestBodyConverter.java b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoRequestBodyConverter.java
similarity index 89%
rename from retrofit-converters/protobuf/src/main/java/retrofit2/ProtoRequestBodyConverter.java
rename to retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoRequestBodyConverter.java
index 4dc0c42cb..814dc326b 100644
--- a/retrofit-converters/protobuf/src/main/java/retrofit2/ProtoRequestBodyConverter.java
+++ b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoRequestBodyConverter.java
@@ -13,12 +13,13 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.protobuf;
 
 import com.google.protobuf.MessageLite;
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.RequestBody;
 import java.io.IOException;
+import okhttp3.MediaType;
+import okhttp3.RequestBody;
+import retrofit2.Converter;
 
 final class ProtoRequestBodyConverter<T extends MessageLite> implements Converter<T, RequestBody> {
   private static final MediaType MEDIA_TYPE = MediaType.parse("application/x-protobuf");
diff --git a/retrofit-converters/protobuf/src/main/java/retrofit2/ProtoResponseBodyConverter.java b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoResponseBodyConverter.java
similarity index 72%
rename from retrofit-converters/protobuf/src/main/java/retrofit2/ProtoResponseBodyConverter.java
rename to retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoResponseBodyConverter.java
index 3e37f1f63..fc840dc64 100644
--- a/retrofit-converters/protobuf/src/main/java/retrofit2/ProtoResponseBodyConverter.java
+++ b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoResponseBodyConverter.java
@@ -13,36 +13,34 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.protobuf;
 
+import com.google.protobuf.ExtensionRegistryLite;
 import com.google.protobuf.InvalidProtocolBufferException;
 import com.google.protobuf.MessageLite;
 import com.google.protobuf.Parser;
-import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
-import java.io.InputStream;
+import javax.annotation.Nullable;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
 
 final class ProtoResponseBodyConverter<T extends MessageLite>
     implements Converter<ResponseBody, T> {
   private final Parser<T> parser;
+  private final @Nullable ExtensionRegistryLite registry;
 
-  ProtoResponseBodyConverter(Parser<T> parser) {
+  ProtoResponseBodyConverter(Parser<T> parser, @Nullable ExtensionRegistryLite registry) {
     this.parser = parser;
+    this.registry = registry;
   }
 
   @Override public T convert(ResponseBody value) throws IOException {
-    InputStream is = value.byteStream();
     try {
-      return parser.parseFrom(is);
+      return parser.parseFrom(value.byteStream(), registry);
     } catch (InvalidProtocolBufferException e) {
       throw new RuntimeException(e); // Despite extending IOException, this is data mismatch.
     } finally {
-      if (is != null) {
-        try {
-          is.close();
-        } catch (IOException ignored) {
-        }
-      }
+      value.close();
     }
   }
 }
diff --git a/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/package-info.java b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/package-info.java
new file mode 100644
index 000000000..c976ca568
--- /dev/null
+++ b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/package-info.java
@@ -0,0 +1,4 @@
+@ParametersAreNonnullByDefault
+package retrofit2.converter.protobuf;
+
+import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-converters/protobuf/src/test/java/retrofit2/PhoneProtos.java b/retrofit-converters/protobuf/src/test/java/retrofit2/PhoneProtos.java
deleted file mode 100644
index e75ba0979..000000000
--- a/retrofit-converters/protobuf/src/test/java/retrofit2/PhoneProtos.java
+++ /dev/null
@@ -1,523 +0,0 @@
-// Generated by the protocol buffer compiler.  DO NOT EDIT!
-// source: protos/phone.proto
-
-package retrofit2;
-
-import com.google.protobuf.AbstractMessage;
-
-public final class PhoneProtos {
-  private PhoneProtos() {}
-  public static void registerAllExtensions(
-      com.google.protobuf.ExtensionRegistry registry) {
-  }
-  public interface PhoneOrBuilder
-      extends com.google.protobuf.MessageOrBuilder {
-
-    // optional string number = 1;
-    /**
-     * <code>optional string number = 1;</code>
-     */
-    boolean hasNumber();
-    /**
-     * <code>optional string number = 1;</code>
-     */
-    java.lang.String getNumber();
-    /**
-     * <code>optional string number = 1;</code>
-     */
-    com.google.protobuf.ByteString
-        getNumberBytes();
-  }
-  /**
-   * Protobuf type {@code retrofit2.Phone}
-   */
-  public static final class Phone extends
-      com.google.protobuf.GeneratedMessage
-      implements PhoneOrBuilder {
-    // Use Phone.newBuilder() to construct.
-    private Phone(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
-      super(builder);
-      this.unknownFields = builder.getUnknownFields();
-    }
-    private Phone(boolean noInit) { this.unknownFields = com.google.protobuf.UnknownFieldSet.getDefaultInstance(); }
-
-    private static final Phone defaultInstance;
-    public static Phone getDefaultInstance() {
-      return defaultInstance;
-    }
-
-    public Phone getDefaultInstanceForType() {
-      return defaultInstance;
-    }
-
-    private final com.google.protobuf.UnknownFieldSet unknownFields;
-    @java.lang.Override
-    public final com.google.protobuf.UnknownFieldSet
-        getUnknownFields() {
-      return this.unknownFields;
-    }
-    private Phone(
-        com.google.protobuf.CodedInputStream input,
-        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
-        throws com.google.protobuf.InvalidProtocolBufferException {
-      initFields();
-      int mutable_bitField0_ = 0;
-      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
-          com.google.protobuf.UnknownFieldSet.newBuilder();
-      try {
-        boolean done = false;
-        while (!done) {
-          int tag = input.readTag();
-          switch (tag) {
-            case 0:
-              done = true;
-              break;
-            default: {
-              if (!parseUnknownField(input, unknownFields,
-                                     extensionRegistry, tag)) {
-                done = true;
-              }
-              break;
-            }
-            case 10: {
-              bitField0_ |= 0x00000001;
-              number_ = input.readBytes();
-              break;
-            }
-          }
-        }
-      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
-        throw e.setUnfinishedMessage(this);
-      } catch (java.io.IOException e) {
-        throw new com.google.protobuf.InvalidProtocolBufferException(
-            e.getMessage()).setUnfinishedMessage(this);
-      } finally {
-        this.unknownFields = unknownFields.build();
-        makeExtensionsImmutable();
-      }
-    }
-    public static final com.google.protobuf.Descriptors.Descriptor
-        getDescriptor() {
-      return PhoneProtos.internal_static_retrofit_Phone_descriptor;
-    }
-
-    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
-        internalGetFieldAccessorTable() {
-      return PhoneProtos.internal_static_retrofit_Phone_fieldAccessorTable
-          .ensureFieldAccessorsInitialized(
-              PhoneProtos.Phone.class, PhoneProtos.Phone.Builder.class);
-    }
-
-    public static com.google.protobuf.Parser<Phone> PARSER =
-        new com.google.protobuf.AbstractParser<Phone>() {
-      public Phone parsePartialFrom(
-          com.google.protobuf.CodedInputStream input,
-          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
-          throws com.google.protobuf.InvalidProtocolBufferException {
-        return new Phone(input, extensionRegistry);
-      }
-    };
-
-    @java.lang.Override
-    public com.google.protobuf.Parser<Phone> getParserForType() {
-      return PARSER;
-    }
-
-    private int bitField0_;
-    // optional string number = 1;
-    public static final int NUMBER_FIELD_NUMBER = 1;
-    private java.lang.Object number_;
-    /**
-     * <code>optional string number = 1;</code>
-     */
-    public boolean hasNumber() {
-      return ((bitField0_ & 0x00000001) == 0x00000001);
-    }
-    /**
-     * <code>optional string number = 1;</code>
-     */
-    public java.lang.String getNumber() {
-      java.lang.Object ref = number_;
-      if (ref instanceof java.lang.String) {
-        return (java.lang.String) ref;
-      } else {
-        com.google.protobuf.ByteString bs =
-            (com.google.protobuf.ByteString) ref;
-        java.lang.String s = bs.toStringUtf8();
-        if (bs.isValidUtf8()) {
-          number_ = s;
-        }
-        return s;
-      }
-    }
-    /**
-     * <code>optional string number = 1;</code>
-     */
-    public com.google.protobuf.ByteString
-        getNumberBytes() {
-      java.lang.Object ref = number_;
-      if (ref instanceof java.lang.String) {
-        com.google.protobuf.ByteString b =
-            com.google.protobuf.ByteString.copyFromUtf8(
-                (java.lang.String) ref);
-        number_ = b;
-        return b;
-      } else {
-        return (com.google.protobuf.ByteString) ref;
-      }
-    }
-
-    private void initFields() {
-      number_ = "";
-    }
-    private byte memoizedIsInitialized = -1;
-    public final boolean isInitialized() {
-      byte isInitialized = memoizedIsInitialized;
-      if (isInitialized != -1) return isInitialized == 1;
-
-      memoizedIsInitialized = 1;
-      return true;
-    }
-
-    public void writeTo(com.google.protobuf.CodedOutputStream output)
-                        throws java.io.IOException {
-      getSerializedSize();
-      if (((bitField0_ & 0x00000001) == 0x00000001)) {
-        output.writeBytes(1, getNumberBytes());
-      }
-      getUnknownFields().writeTo(output);
-    }
-
-    private int memoizedSerializedSize = -1;
-    public int getSerializedSize() {
-      int size = memoizedSerializedSize;
-      if (size != -1) return size;
-
-      size = 0;
-      if (((bitField0_ & 0x00000001) == 0x00000001)) {
-        size += com.google.protobuf.CodedOutputStream
-          .computeBytesSize(1, getNumberBytes());
-      }
-      size += getUnknownFields().getSerializedSize();
-      memoizedSerializedSize = size;
-      return size;
-    }
-
-    private static final long serialVersionUID = 0L;
-    @java.lang.Override
-    protected java.lang.Object writeReplace()
-        throws java.io.ObjectStreamException {
-      return super.writeReplace();
-    }
-
-    public static PhoneProtos.Phone parseFrom(
-        com.google.protobuf.ByteString data)
-        throws com.google.protobuf.InvalidProtocolBufferException {
-      return PARSER.parseFrom(data);
-    }
-    public static PhoneProtos.Phone parseFrom(
-        com.google.protobuf.ByteString data,
-        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
-        throws com.google.protobuf.InvalidProtocolBufferException {
-      return PARSER.parseFrom(data, extensionRegistry);
-    }
-    public static PhoneProtos.Phone parseFrom(byte[] data)
-        throws com.google.protobuf.InvalidProtocolBufferException {
-      return PARSER.parseFrom(data);
-    }
-    public static PhoneProtos.Phone parseFrom(
-        byte[] data,
-        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
-        throws com.google.protobuf.InvalidProtocolBufferException {
-      return PARSER.parseFrom(data, extensionRegistry);
-    }
-    public static PhoneProtos.Phone parseFrom(java.io.InputStream input)
-        throws java.io.IOException {
-      return PARSER.parseFrom(input);
-    }
-    public static PhoneProtos.Phone parseFrom(
-        java.io.InputStream input,
-        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
-        throws java.io.IOException {
-      return PARSER.parseFrom(input, extensionRegistry);
-    }
-    public static PhoneProtos.Phone parseDelimitedFrom(java.io.InputStream input)
-        throws java.io.IOException {
-      return PARSER.parseDelimitedFrom(input);
-    }
-    public static PhoneProtos.Phone parseDelimitedFrom(
-        java.io.InputStream input,
-        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
-        throws java.io.IOException {
-      return PARSER.parseDelimitedFrom(input, extensionRegistry);
-    }
-    public static PhoneProtos.Phone parseFrom(
-        com.google.protobuf.CodedInputStream input)
-        throws java.io.IOException {
-      return PARSER.parseFrom(input);
-    }
-    public static PhoneProtos.Phone parseFrom(
-        com.google.protobuf.CodedInputStream input,
-        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
-        throws java.io.IOException {
-      return PARSER.parseFrom(input, extensionRegistry);
-    }
-
-    public static Builder newBuilder() { return Builder.create(); }
-    public Builder newBuilderForType() { return newBuilder(); }
-    public static Builder newBuilder(PhoneProtos.Phone prototype) {
-      return newBuilder().mergeFrom(prototype);
-    }
-    public Builder toBuilder() { return newBuilder(this); }
-
-    @java.lang.Override
-    protected Builder newBuilderForType(
-        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
-      Builder builder = new Builder(parent);
-      return builder;
-    }
-    /**
-     * Protobuf type {@code retrofit2.Phone}
-     */
-    public static final class Builder extends
-        com.google.protobuf.GeneratedMessage.Builder<Builder>
-       implements PhoneProtos.PhoneOrBuilder {
-      public static final com.google.protobuf.Descriptors.Descriptor
-          getDescriptor() {
-        return PhoneProtos.internal_static_retrofit_Phone_descriptor;
-      }
-
-      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
-          internalGetFieldAccessorTable() {
-        return PhoneProtos.internal_static_retrofit_Phone_fieldAccessorTable
-            .ensureFieldAccessorsInitialized(
-                PhoneProtos.Phone.class, PhoneProtos.Phone.Builder.class);
-      }
-
-      // Construct using retrofit2.PhoneProtos.Phone.newBuilder()
-      private Builder() {
-        maybeForceBuilderInitialization();
-      }
-
-      private Builder(
-          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
-        super(parent);
-        maybeForceBuilderInitialization();
-      }
-      private void maybeForceBuilderInitialization() {
-        if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {
-        }
-      }
-      private static Builder create() {
-        return new Builder();
-      }
-
-      public Builder clear() {
-        super.clear();
-        number_ = "";
-        bitField0_ = (bitField0_ & ~0x00000001);
-        return this;
-      }
-
-      public Builder clone() {
-        return create().mergeFrom(buildPartial());
-      }
-
-      public com.google.protobuf.Descriptors.Descriptor
-          getDescriptorForType() {
-        return PhoneProtos.internal_static_retrofit_Phone_descriptor;
-      }
-
-      public PhoneProtos.Phone getDefaultInstanceForType() {
-        return PhoneProtos.Phone.getDefaultInstance();
-      }
-
-      public PhoneProtos.Phone build() {
-        PhoneProtos.Phone result = buildPartial();
-        if (!result.isInitialized()) {
-          throw AbstractMessage.Builder.newUninitializedMessageException(result);
-        }
-        return result;
-      }
-
-      public PhoneProtos.Phone buildPartial() {
-        PhoneProtos.Phone result = new PhoneProtos.Phone(this);
-        int from_bitField0_ = bitField0_;
-        int to_bitField0_ = 0;
-        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
-          to_bitField0_ |= 0x00000001;
-        }
-        result.number_ = number_;
-        result.bitField0_ = to_bitField0_;
-        onBuilt();
-        return result;
-      }
-
-      public Builder mergeFrom(com.google.protobuf.Message other) {
-        if (other instanceof PhoneProtos.Phone) {
-          return mergeFrom((PhoneProtos.Phone)other);
-        } else {
-          super.mergeFrom(other);
-          return this;
-        }
-      }
-
-      public Builder mergeFrom(PhoneProtos.Phone other) {
-        if (other == PhoneProtos.Phone.getDefaultInstance()) return this;
-        if (other.hasNumber()) {
-          bitField0_ |= 0x00000001;
-          number_ = other.number_;
-          onChanged();
-        }
-        this.mergeUnknownFields(other.getUnknownFields());
-        return this;
-      }
-
-      public final boolean isInitialized() {
-        return true;
-      }
-
-      public Builder mergeFrom(
-          com.google.protobuf.CodedInputStream input,
-          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
-          throws java.io.IOException {
-        PhoneProtos.Phone parsedMessage = null;
-        try {
-          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
-        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
-          parsedMessage = (PhoneProtos.Phone) e.getUnfinishedMessage();
-          throw e;
-        } finally {
-          if (parsedMessage != null) {
-            mergeFrom(parsedMessage);
-          }
-        }
-        return this;
-      }
-      private int bitField0_;
-
-      // optional string number = 1;
-      private java.lang.Object number_ = "";
-      /**
-       * <code>optional string number = 1;</code>
-       */
-      public boolean hasNumber() {
-        return ((bitField0_ & 0x00000001) == 0x00000001);
-      }
-      /**
-       * <code>optional string number = 1;</code>
-       */
-      public java.lang.String getNumber() {
-        java.lang.Object ref = number_;
-        if (!(ref instanceof java.lang.String)) {
-          java.lang.String s = ((com.google.protobuf.ByteString) ref)
-              .toStringUtf8();
-          number_ = s;
-          return s;
-        } else {
-          return (java.lang.String) ref;
-        }
-      }
-      /**
-       * <code>optional string number = 1;</code>
-       */
-      public com.google.protobuf.ByteString
-          getNumberBytes() {
-        java.lang.Object ref = number_;
-        if (ref instanceof String) {
-          com.google.protobuf.ByteString b =
-              com.google.protobuf.ByteString.copyFromUtf8(
-                  (java.lang.String) ref);
-          number_ = b;
-          return b;
-        } else {
-          return (com.google.protobuf.ByteString) ref;
-        }
-      }
-      /**
-       * <code>optional string number = 1;</code>
-       */
-      public Builder setNumber(
-          java.lang.String value) {
-        if (value == null) {
-    throw new NullPointerException();
-  }
-  bitField0_ |= 0x00000001;
-        number_ = value;
-        onChanged();
-        return this;
-      }
-      /**
-       * <code>optional string number = 1;</code>
-       */
-      public Builder clearNumber() {
-        bitField0_ = (bitField0_ & ~0x00000001);
-        number_ = getDefaultInstance().getNumber();
-        onChanged();
-        return this;
-      }
-      /**
-       * <code>optional string number = 1;</code>
-       */
-      public Builder setNumberBytes(
-          com.google.protobuf.ByteString value) {
-        if (value == null) {
-    throw new NullPointerException();
-  }
-  bitField0_ |= 0x00000001;
-        number_ = value;
-        onChanged();
-        return this;
-      }
-
-      // @@protoc_insertion_point(builder_scope:retrofit2.Phone)
-    }
-
-    static {
-      defaultInstance = new Phone(true);
-      defaultInstance.initFields();
-    }
-
-    // @@protoc_insertion_point(class_scope:retrofit2.Phone)
-  }
-
-  private static com.google.protobuf.Descriptors.Descriptor
-    internal_static_retrofit_Phone_descriptor;
-  private static
-    com.google.protobuf.GeneratedMessage.FieldAccessorTable
-      internal_static_retrofit_Phone_fieldAccessorTable;
-
-  public static com.google.protobuf.Descriptors.FileDescriptor
-      getDescriptor() {
-    return descriptor;
-  }
-  private static com.google.protobuf.Descriptors.FileDescriptor
-      descriptor;
-  static {
-    java.lang.String[] descriptorData = {
-      "\n\022protos/phone.proto\022\010retrofit\"\027\n\005Phone\022" +
-      "\016\n\006number\030\001 \001(\tB!\n\022retrofit.converterB\013P" +
-      "honeProtos"
-    };
-    com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner assigner =
-      new com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner() {
-        public com.google.protobuf.ExtensionRegistry assignDescriptors(
-            com.google.protobuf.Descriptors.FileDescriptor root) {
-          descriptor = root;
-          internal_static_retrofit_Phone_descriptor =
-            getDescriptor().getMessageTypes().get(0);
-          internal_static_retrofit_Phone_fieldAccessorTable = new
-            com.google.protobuf.GeneratedMessage.FieldAccessorTable(
-              internal_static_retrofit_Phone_descriptor,
-              new java.lang.String[] { "Number", });
-          return null;
-        }
-      };
-    com.google.protobuf.Descriptors.FileDescriptor
-      .internalBuildGeneratedFileFrom(descriptorData,
-        new com.google.protobuf.Descriptors.FileDescriptor[] {
-        }, assigner);
-  }
-
-  // @@protoc_insertion_point(outer_class_scope)
-}
diff --git a/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/FallbackParserFinderTest.java b/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/FallbackParserFinderTest.java
new file mode 100644
index 000000000..b37ab55bc
--- /dev/null
+++ b/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/FallbackParserFinderTest.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.converter.protobuf;
+
+import com.google.protobuf.MessageLite;
+import com.google.protobuf.Parser;
+import java.lang.annotation.Annotation;
+import okhttp3.ResponseBody;
+import org.junit.Test;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
+import retrofit2.converter.protobuf.PhoneProtos.Phone;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class FallbackParserFinderTest {
+  @Test public void converterFactoryFallsBackToParserField() {
+    Retrofit retrofit = new Retrofit.Builder().baseUrl("http://localhost/").build();
+    ProtoConverterFactory factory = ProtoConverterFactory.create();
+    Converter<ResponseBody, ?> converter =
+        factory.responseBodyConverter(FakePhone.class, new Annotation[0], retrofit);
+    assertThat(converter).isNotNull();
+  }
+
+  @SuppressWarnings("unused") // Used reflectively.
+  public static abstract class FakePhone implements MessageLite {
+    public static final Parser<Phone> PARSER = Phone.parser();
+  }
+}
diff --git a/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/PhoneProtos.java b/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/PhoneProtos.java
new file mode 100644
index 000000000..3ad1bb0f6
--- /dev/null
+++ b/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/PhoneProtos.java
@@ -0,0 +1,656 @@
+// Generated by the protocol buffer compiler.  DO NOT EDIT!
+// source: protos/phone.proto
+
+package retrofit2.converter.protobuf;
+
+public final class PhoneProtos {
+  private PhoneProtos() {}
+  public static void registerAllExtensions(
+      com.google.protobuf.ExtensionRegistryLite registry) {
+    registry.add(retrofit2.converter.protobuf.PhoneProtos.voicemail);
+  }
+
+  public static void registerAllExtensions(
+      com.google.protobuf.ExtensionRegistry registry) {
+    registerAllExtensions(
+        (com.google.protobuf.ExtensionRegistryLite) registry);
+  }
+  public interface PhoneOrBuilder extends
+      // @@protoc_insertion_point(interface_extends:retrofit2.converter.protobuf.Phone)
+      com.google.protobuf.GeneratedMessage.
+          ExtendableMessageOrBuilder<Phone> {
+
+    /**
+     * <code>optional string number = 1;</code>
+     */
+    boolean hasNumber();
+    /**
+     * <code>optional string number = 1;</code>
+     */
+    java.lang.String getNumber();
+    /**
+     * <code>optional string number = 1;</code>
+     */
+    com.google.protobuf.ByteString
+        getNumberBytes();
+  }
+  /**
+   * Protobuf type {@code retrofit2.converter.protobuf.Phone}
+   */
+  public  static final class Phone extends
+      com.google.protobuf.GeneratedMessage.ExtendableMessage<
+        Phone> implements
+      // @@protoc_insertion_point(message_implements:retrofit2.converter.protobuf.Phone)
+      PhoneOrBuilder {
+    // Use Phone.newBuilder() to construct.
+    private Phone(com.google.protobuf.GeneratedMessage.ExtendableBuilder<retrofit2.converter.protobuf.PhoneProtos.Phone, ?> builder) {
+      super(builder);
+    }
+    private Phone() {
+      number_ = "";
+    }
+
+    @java.lang.Override
+    public final com.google.protobuf.UnknownFieldSet
+    getUnknownFields() {
+      return this.unknownFields;
+    }
+    private Phone(
+        com.google.protobuf.CodedInputStream input,
+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+        throws com.google.protobuf.InvalidProtocolBufferException {
+      this();
+      int mutable_bitField0_ = 0;
+      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
+          com.google.protobuf.UnknownFieldSet.newBuilder();
+      try {
+        boolean done = false;
+        while (!done) {
+          int tag = input.readTag();
+          switch (tag) {
+            case 0:
+              done = true;
+              break;
+            default: {
+              if (!parseUnknownField(input, unknownFields,
+                                     extensionRegistry, tag)) {
+                done = true;
+              }
+              break;
+            }
+            case 10: {
+              com.google.protobuf.ByteString bs = input.readBytes();
+              bitField0_ |= 0x00000001;
+              number_ = bs;
+              break;
+            }
+          }
+        }
+      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+        throw e.setUnfinishedMessage(this);
+      } catch (java.io.IOException e) {
+        throw new com.google.protobuf.InvalidProtocolBufferException(
+            e).setUnfinishedMessage(this);
+      } finally {
+        this.unknownFields = unknownFields.build();
+        makeExtensionsImmutable();
+      }
+    }
+    public static final com.google.protobuf.Descriptors.Descriptor
+        getDescriptor() {
+      return retrofit2.converter.protobuf.PhoneProtos.internal_static_retrofit2_converter_protobuf_Phone_descriptor;
+    }
+
+    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
+        internalGetFieldAccessorTable() {
+      return retrofit2.converter.protobuf.PhoneProtos.internal_static_retrofit2_converter_protobuf_Phone_fieldAccessorTable
+          .ensureFieldAccessorsInitialized(
+              retrofit2.converter.protobuf.PhoneProtos.Phone.class, retrofit2.converter.protobuf.PhoneProtos.Phone.Builder.class);
+    }
+
+    private int bitField0_;
+    public static final int NUMBER_FIELD_NUMBER = 1;
+    private volatile java.lang.Object number_;
+    /**
+     * <code>optional string number = 1;</code>
+     */
+    public boolean hasNumber() {
+      return ((bitField0_ & 0x00000001) == 0x00000001);
+    }
+    /**
+     * <code>optional string number = 1;</code>
+     */
+    public java.lang.String getNumber() {
+      java.lang.Object ref = number_;
+      if (ref instanceof java.lang.String) {
+        return (java.lang.String) ref;
+      } else {
+        com.google.protobuf.ByteString bs = 
+            (com.google.protobuf.ByteString) ref;
+        java.lang.String s = bs.toStringUtf8();
+        if (bs.isValidUtf8()) {
+          number_ = s;
+        }
+        return s;
+      }
+    }
+    /**
+     * <code>optional string number = 1;</code>
+     */
+    public com.google.protobuf.ByteString
+        getNumberBytes() {
+      java.lang.Object ref = number_;
+      if (ref instanceof java.lang.String) {
+        com.google.protobuf.ByteString b = 
+            com.google.protobuf.ByteString.copyFromUtf8(
+                (java.lang.String) ref);
+        number_ = b;
+        return b;
+      } else {
+        return (com.google.protobuf.ByteString) ref;
+      }
+    }
+
+    private byte memoizedIsInitialized = -1;
+    public final boolean isInitialized() {
+      byte isInitialized = memoizedIsInitialized;
+      if (isInitialized == 1) return true;
+      if (isInitialized == 0) return false;
+
+      if (!extensionsAreInitialized()) {
+        memoizedIsInitialized = 0;
+        return false;
+      }
+      memoizedIsInitialized = 1;
+      return true;
+    }
+
+    public void writeTo(com.google.protobuf.CodedOutputStream output)
+                        throws java.io.IOException {
+      com.google.protobuf.GeneratedMessage
+        .ExtendableMessage<retrofit2.converter.protobuf.PhoneProtos.Phone>.ExtensionWriter
+          extensionWriter = newExtensionWriter();
+      if (((bitField0_ & 0x00000001) == 0x00000001)) {
+        com.google.protobuf.GeneratedMessage.writeString(output, 1, number_);
+      }
+      extensionWriter.writeUntil(3, output);
+      unknownFields.writeTo(output);
+    }
+
+    public int getSerializedSize() {
+      int size = memoizedSize;
+      if (size != -1) return size;
+
+      size = 0;
+      if (((bitField0_ & 0x00000001) == 0x00000001)) {
+        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, number_);
+      }
+      size += extensionsSerializedSize();
+      size += unknownFields.getSerializedSize();
+      memoizedSize = size;
+      return size;
+    }
+
+    private static final long serialVersionUID = 0L;
+    @java.lang.Override
+    public boolean equals(final java.lang.Object obj) {
+      if (obj == this) {
+       return true;
+      }
+      if (!(obj instanceof retrofit2.converter.protobuf.PhoneProtos.Phone)) {
+        return super.equals(obj);
+      }
+      retrofit2.converter.protobuf.PhoneProtos.Phone other = (retrofit2.converter.protobuf.PhoneProtos.Phone) obj;
+
+      boolean result = true;
+      result = result && (hasNumber() == other.hasNumber());
+      if (hasNumber()) {
+        result = result && getNumber()
+            .equals(other.getNumber());
+      }
+      result = result && unknownFields.equals(other.unknownFields);
+      result = result &&
+          getExtensionFields().equals(other.getExtensionFields());
+      return result;
+    }
+
+    @java.lang.Override
+    public int hashCode() {
+      if (memoizedHashCode != 0) {
+        return memoizedHashCode;
+      }
+      int hash = 41;
+      hash = (19 * hash) + getDescriptorForType().hashCode();
+      if (hasNumber()) {
+        hash = (37 * hash) + NUMBER_FIELD_NUMBER;
+        hash = (53 * hash) + getNumber().hashCode();
+      }
+      hash = hashFields(hash, getExtensionFields());
+      hash = (29 * hash) + unknownFields.hashCode();
+      memoizedHashCode = hash;
+      return hash;
+    }
+
+    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(
+        com.google.protobuf.ByteString data)
+        throws com.google.protobuf.InvalidProtocolBufferException {
+      return PARSER.parseFrom(data);
+    }
+    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(
+        com.google.protobuf.ByteString data,
+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+        throws com.google.protobuf.InvalidProtocolBufferException {
+      return PARSER.parseFrom(data, extensionRegistry);
+    }
+    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(byte[] data)
+        throws com.google.protobuf.InvalidProtocolBufferException {
+      return PARSER.parseFrom(data);
+    }
+    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(
+        byte[] data,
+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+        throws com.google.protobuf.InvalidProtocolBufferException {
+      return PARSER.parseFrom(data, extensionRegistry);
+    }
+    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(java.io.InputStream input)
+        throws java.io.IOException {
+      return com.google.protobuf.GeneratedMessage
+          .parseWithIOException(PARSER, input);
+    }
+    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(
+        java.io.InputStream input,
+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+        throws java.io.IOException {
+      return com.google.protobuf.GeneratedMessage
+          .parseWithIOException(PARSER, input, extensionRegistry);
+    }
+    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseDelimitedFrom(java.io.InputStream input)
+        throws java.io.IOException {
+      return com.google.protobuf.GeneratedMessage
+          .parseDelimitedWithIOException(PARSER, input);
+    }
+    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseDelimitedFrom(
+        java.io.InputStream input,
+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+        throws java.io.IOException {
+      return com.google.protobuf.GeneratedMessage
+          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
+    }
+    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(
+        com.google.protobuf.CodedInputStream input)
+        throws java.io.IOException {
+      return com.google.protobuf.GeneratedMessage
+          .parseWithIOException(PARSER, input);
+    }
+    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(
+        com.google.protobuf.CodedInputStream input,
+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+        throws java.io.IOException {
+      return com.google.protobuf.GeneratedMessage
+          .parseWithIOException(PARSER, input, extensionRegistry);
+    }
+
+    public Builder newBuilderForType() { return newBuilder(); }
+    public static Builder newBuilder() {
+      return DEFAULT_INSTANCE.toBuilder();
+    }
+    public static Builder newBuilder(retrofit2.converter.protobuf.PhoneProtos.Phone prototype) {
+      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
+    }
+    public Builder toBuilder() {
+      return this == DEFAULT_INSTANCE
+          ? new Builder() : new Builder().mergeFrom(this);
+    }
+
+    @java.lang.Override
+    protected Builder newBuilderForType(
+        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
+      Builder builder = new Builder(parent);
+      return builder;
+    }
+    /**
+     * Protobuf type {@code retrofit2.converter.protobuf.Phone}
+     */
+    public static final class Builder extends
+        com.google.protobuf.GeneratedMessage.ExtendableBuilder<
+          retrofit2.converter.protobuf.PhoneProtos.Phone, Builder> implements
+        // @@protoc_insertion_point(builder_implements:retrofit2.converter.protobuf.Phone)
+        retrofit2.converter.protobuf.PhoneProtos.PhoneOrBuilder {
+      public static final com.google.protobuf.Descriptors.Descriptor
+          getDescriptor() {
+        return retrofit2.converter.protobuf.PhoneProtos.internal_static_retrofit2_converter_protobuf_Phone_descriptor;
+      }
+
+      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
+          internalGetFieldAccessorTable() {
+        return retrofit2.converter.protobuf.PhoneProtos.internal_static_retrofit2_converter_protobuf_Phone_fieldAccessorTable
+            .ensureFieldAccessorsInitialized(
+                retrofit2.converter.protobuf.PhoneProtos.Phone.class, retrofit2.converter.protobuf.PhoneProtos.Phone.Builder.class);
+      }
+
+      // Construct using retrofit2.converter.protobuf.PhoneProtos.Phone.newBuilder()
+      private Builder() {
+        maybeForceBuilderInitialization();
+      }
+
+      private Builder(
+          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
+        super(parent);
+        maybeForceBuilderInitialization();
+      }
+      private void maybeForceBuilderInitialization() {
+        if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {
+        }
+      }
+      public Builder clear() {
+        super.clear();
+        number_ = "";
+        bitField0_ = (bitField0_ & ~0x00000001);
+        return this;
+      }
+
+      public com.google.protobuf.Descriptors.Descriptor
+          getDescriptorForType() {
+        return retrofit2.converter.protobuf.PhoneProtos.internal_static_retrofit2_converter_protobuf_Phone_descriptor;
+      }
+
+      public retrofit2.converter.protobuf.PhoneProtos.Phone getDefaultInstanceForType() {
+        return retrofit2.converter.protobuf.PhoneProtos.Phone.getDefaultInstance();
+      }
+
+      public retrofit2.converter.protobuf.PhoneProtos.Phone build() {
+        retrofit2.converter.protobuf.PhoneProtos.Phone result = buildPartial();
+        if (!result.isInitialized()) {
+          throw newUninitializedMessageException(result);
+        }
+        return result;
+      }
+
+      public retrofit2.converter.protobuf.PhoneProtos.Phone buildPartial() {
+        retrofit2.converter.protobuf.PhoneProtos.Phone result = new retrofit2.converter.protobuf.PhoneProtos.Phone(this);
+        int from_bitField0_ = bitField0_;
+        int to_bitField0_ = 0;
+        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
+          to_bitField0_ |= 0x00000001;
+        }
+        result.number_ = number_;
+        result.bitField0_ = to_bitField0_;
+        onBuilt();
+        return result;
+      }
+
+      public Builder clone() {
+        return (Builder) super.clone();
+      }
+      public Builder setField(
+          com.google.protobuf.Descriptors.FieldDescriptor field,
+          Object value) {
+        return (Builder) super.setField(field, value);
+      }
+      public Builder clearField(
+          com.google.protobuf.Descriptors.FieldDescriptor field) {
+        return (Builder) super.clearField(field);
+      }
+      public Builder clearOneof(
+          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
+        return (Builder) super.clearOneof(oneof);
+      }
+      public Builder setRepeatedField(
+          com.google.protobuf.Descriptors.FieldDescriptor field,
+          int index, Object value) {
+        return (Builder) super.setRepeatedField(field, index, value);
+      }
+      public Builder addRepeatedField(
+          com.google.protobuf.Descriptors.FieldDescriptor field,
+          Object value) {
+        return (Builder) super.addRepeatedField(field, value);
+      }
+      public <Type> Builder setExtension(
+          com.google.protobuf.GeneratedMessage.GeneratedExtension<
+              retrofit2.converter.protobuf.PhoneProtos.Phone, Type> extension,
+          Type value) {
+        return (Builder) super.setExtension(extension, value);
+      }
+      public <Type> Builder setExtension(
+          com.google.protobuf.GeneratedMessage.GeneratedExtension<
+              retrofit2.converter.protobuf.PhoneProtos.Phone, java.util.List<Type>> extension,
+          int index, Type value) {
+        return (Builder) super.setExtension(extension, index, value);
+      }
+      public <Type> Builder addExtension(
+          com.google.protobuf.GeneratedMessage.GeneratedExtension<
+              retrofit2.converter.protobuf.PhoneProtos.Phone, java.util.List<Type>> extension,
+          Type value) {
+        return (Builder) super.addExtension(extension, value);
+      }
+      public <Type> Builder clearExtension(
+          com.google.protobuf.GeneratedMessage.GeneratedExtension<
+              retrofit2.converter.protobuf.PhoneProtos.Phone, ?> extension) {
+        return (Builder) super.clearExtension(extension);
+      }
+      public Builder mergeFrom(com.google.protobuf.Message other) {
+        if (other instanceof retrofit2.converter.protobuf.PhoneProtos.Phone) {
+          return mergeFrom((retrofit2.converter.protobuf.PhoneProtos.Phone)other);
+        } else {
+          super.mergeFrom(other);
+          return this;
+        }
+      }
+
+      public Builder mergeFrom(retrofit2.converter.protobuf.PhoneProtos.Phone other) {
+        if (other == retrofit2.converter.protobuf.PhoneProtos.Phone.getDefaultInstance()) return this;
+        if (other.hasNumber()) {
+          bitField0_ |= 0x00000001;
+          number_ = other.number_;
+          onChanged();
+        }
+        this.mergeExtensionFields(other);
+        this.mergeUnknownFields(other.unknownFields);
+        onChanged();
+        return this;
+      }
+
+      public final boolean isInitialized() {
+        if (!extensionsAreInitialized()) {
+          return false;
+        }
+        return true;
+      }
+
+      public Builder mergeFrom(
+          com.google.protobuf.CodedInputStream input,
+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+          throws java.io.IOException {
+        retrofit2.converter.protobuf.PhoneProtos.Phone parsedMessage = null;
+        try {
+          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
+        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+          parsedMessage = (retrofit2.converter.protobuf.PhoneProtos.Phone) e.getUnfinishedMessage();
+          throw e.unwrapIOException();
+        } finally {
+          if (parsedMessage != null) {
+            mergeFrom(parsedMessage);
+          }
+        }
+        return this;
+      }
+      private int bitField0_;
+
+      private java.lang.Object number_ = "";
+      /**
+       * <code>optional string number = 1;</code>
+       */
+      public boolean hasNumber() {
+        return ((bitField0_ & 0x00000001) == 0x00000001);
+      }
+      /**
+       * <code>optional string number = 1;</code>
+       */
+      public java.lang.String getNumber() {
+        java.lang.Object ref = number_;
+        if (!(ref instanceof java.lang.String)) {
+          com.google.protobuf.ByteString bs =
+              (com.google.protobuf.ByteString) ref;
+          java.lang.String s = bs.toStringUtf8();
+          if (bs.isValidUtf8()) {
+            number_ = s;
+          }
+          return s;
+        } else {
+          return (java.lang.String) ref;
+        }
+      }
+      /**
+       * <code>optional string number = 1;</code>
+       */
+      public com.google.protobuf.ByteString
+          getNumberBytes() {
+        java.lang.Object ref = number_;
+        if (ref instanceof String) {
+          com.google.protobuf.ByteString b = 
+              com.google.protobuf.ByteString.copyFromUtf8(
+                  (java.lang.String) ref);
+          number_ = b;
+          return b;
+        } else {
+          return (com.google.protobuf.ByteString) ref;
+        }
+      }
+      /**
+       * <code>optional string number = 1;</code>
+       */
+      public Builder setNumber(
+          java.lang.String value) {
+        if (value == null) {
+    throw new NullPointerException();
+  }
+  bitField0_ |= 0x00000001;
+        number_ = value;
+        onChanged();
+        return this;
+      }
+      /**
+       * <code>optional string number = 1;</code>
+       */
+      public Builder clearNumber() {
+        bitField0_ = (bitField0_ & ~0x00000001);
+        number_ = getDefaultInstance().getNumber();
+        onChanged();
+        return this;
+      }
+      /**
+       * <code>optional string number = 1;</code>
+       */
+      public Builder setNumberBytes(
+          com.google.protobuf.ByteString value) {
+        if (value == null) {
+    throw new NullPointerException();
+  }
+  bitField0_ |= 0x00000001;
+        number_ = value;
+        onChanged();
+        return this;
+      }
+      public final Builder setUnknownFields(
+          final com.google.protobuf.UnknownFieldSet unknownFields) {
+        return super.setUnknownFields(unknownFields);
+      }
+
+      public final Builder mergeUnknownFields(
+          final com.google.protobuf.UnknownFieldSet unknownFields) {
+        return super.mergeUnknownFields(unknownFields);
+      }
+
+
+      // @@protoc_insertion_point(builder_scope:retrofit2.converter.protobuf.Phone)
+    }
+
+    // @@protoc_insertion_point(class_scope:retrofit2.converter.protobuf.Phone)
+    private static final retrofit2.converter.protobuf.PhoneProtos.Phone DEFAULT_INSTANCE;
+    static {
+      DEFAULT_INSTANCE = new retrofit2.converter.protobuf.PhoneProtos.Phone();
+    }
+
+    public static retrofit2.converter.protobuf.PhoneProtos.Phone getDefaultInstance() {
+      return DEFAULT_INSTANCE;
+    }
+
+    @java.lang.Deprecated public static final com.google.protobuf.Parser<Phone>
+        PARSER = new com.google.protobuf.AbstractParser<Phone>() {
+      public Phone parsePartialFrom(
+          com.google.protobuf.CodedInputStream input,
+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+          throws com.google.protobuf.InvalidProtocolBufferException {
+          return new Phone(input, extensionRegistry);
+      }
+    };
+
+    public static com.google.protobuf.Parser<Phone> parser() {
+      return PARSER;
+    }
+
+    @java.lang.Override
+    public com.google.protobuf.Parser<Phone> getParserForType() {
+      return PARSER;
+    }
+
+    public retrofit2.converter.protobuf.PhoneProtos.Phone getDefaultInstanceForType() {
+      return DEFAULT_INSTANCE;
+    }
+
+  }
+
+  public static final int VOICEMAIL_FIELD_NUMBER = 2;
+  /**
+   * <code>extend .retrofit2.converter.protobuf.Phone { ... }</code>
+   */
+  public static final
+    com.google.protobuf.GeneratedMessage.GeneratedExtension<
+      retrofit2.converter.protobuf.PhoneProtos.Phone,
+      java.lang.Boolean> voicemail = com.google.protobuf.GeneratedMessage
+          .newFileScopedGeneratedExtension(
+        java.lang.Boolean.class,
+        null);
+  private static final com.google.protobuf.Descriptors.Descriptor
+    internal_static_retrofit2_converter_protobuf_Phone_descriptor;
+  private static final 
+    com.google.protobuf.GeneratedMessage.FieldAccessorTable
+      internal_static_retrofit2_converter_protobuf_Phone_fieldAccessorTable;
+
+  public static com.google.protobuf.Descriptors.FileDescriptor
+      getDescriptor() {
+    return descriptor;
+  }
+  private static  com.google.protobuf.Descriptors.FileDescriptor
+      descriptor;
+  static {
+    java.lang.String[] descriptorData = {
+      "\n\022protos/phone.proto\022\034retrofit2.converte" +
+      "r.protobuf\"\035\n\005Phone\022\016\n\006number\030\001 \001(\t*\004\010\002\020" +
+      "\003:6\n\tvoicemail\022#.retrofit2.converter.pro" +
+      "tobuf.Phone\030\002 \001(\010B+\n\034retrofit2.converter" +
+      ".protobufB\013PhoneProtos"
+    };
+    com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner assigner =
+        new com.google.protobuf.Descriptors.FileDescriptor.    InternalDescriptorAssigner() {
+          public com.google.protobuf.ExtensionRegistry assignDescriptors(
+              com.google.protobuf.Descriptors.FileDescriptor root) {
+            descriptor = root;
+            return null;
+          }
+        };
+    com.google.protobuf.Descriptors.FileDescriptor
+      .internalBuildGeneratedFileFrom(descriptorData,
+        new com.google.protobuf.Descriptors.FileDescriptor[] {
+        }, assigner);
+    internal_static_retrofit2_converter_protobuf_Phone_descriptor =
+      getDescriptor().getMessageTypes().get(0);
+    internal_static_retrofit2_converter_protobuf_Phone_fieldAccessorTable = new
+      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
+        internal_static_retrofit2_converter_protobuf_Phone_descriptor,
+        new java.lang.String[] { "Number", });
+    voicemail.internalInit(descriptor.getExtensions().get(0));
+  }
+
+  // @@protoc_insertion_point(outer_class_scope)
+}
diff --git a/retrofit-converters/protobuf/src/test/java/retrofit2/ProtoConverterFactoryTest.java b/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/ProtoConverterFactoryTest.java
similarity index 63%
rename from retrofit-converters/protobuf/src/test/java/retrofit2/ProtoConverterFactoryTest.java
rename to retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/ProtoConverterFactoryTest.java
index 421899b20..5a585b21f 100644
--- a/retrofit-converters/protobuf/src/test/java/retrofit2/ProtoConverterFactoryTest.java
+++ b/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/ProtoConverterFactoryTest.java
@@ -13,26 +13,30 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.protobuf;
 
+import com.google.protobuf.ExtensionRegistry;
 import com.google.protobuf.InvalidProtocolBufferException;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import com.squareup.okhttp.mockwebserver.RecordedRequest;
 import java.io.IOException;
 import java.util.List;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
 import okio.Buffer;
 import okio.ByteString;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+import retrofit2.Call;
+import retrofit2.Response;
+import retrofit2.Retrofit;
 import retrofit2.http.Body;
 import retrofit2.http.GET;
 import retrofit2.http.POST;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
-import static retrofit2.PhoneProtos.Phone;
+import static retrofit2.converter.protobuf.PhoneProtos.Phone;
 
 public final class ProtoConverterFactoryTest {
   interface Service {
@@ -41,10 +45,14 @@
     @GET("/") Call<String> wrongClass();
     @GET("/") Call<List<String>> wrongType();
   }
+  interface ServiceWithRegistry {
+    @GET("/") Call<Phone> get();
+  }
 
   @Rule public final MockWebServer server = new MockWebServer();
 
   private Service service;
+  private ServiceWithRegistry serviceWithRegistry;
 
   @Before public void setUp() {
     Retrofit retrofit = new Retrofit.Builder()
@@ -52,6 +60,14 @@
         .addConverterFactory(ProtoConverterFactory.create())
         .build();
     service = retrofit.create(Service.class);
+
+    ExtensionRegistry registry = ExtensionRegistry.newInstance();
+    PhoneProtos.registerAllExtensions(registry);
+    Retrofit retrofitWithRegistry = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(ProtoConverterFactory.createWithRegistry(registry))
+        .build();
+    serviceWithRegistry = retrofitWithRegistry.create(ServiceWithRegistry.class);
   }
 
   @Test public void serializeAndDeserialize() throws IOException, InterruptedException {
@@ -77,6 +93,17 @@
     assertThat(body.hasNumber()).isFalse();
   }
 
+  @Test public void deserializeUsesRegistry() throws IOException {
+    ByteString encoded = ByteString.decodeBase64("Cg4oNTE5KSA4NjctNTMwORAB");
+    server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));
+
+    Call<Phone> call = serviceWithRegistry.get();
+    Response<Phone> response = call.execute();
+    Phone body = response.body();
+    assertThat(body.getNumber()).isEqualTo("(519) 867-5309");
+    assertThat(body.getExtension(PhoneProtos.voicemail)).isEqualTo(true);
+  }
+
   @Test public void deserializeWrongClass() throws IOException {
     ByteString encoded = ByteString.decodeBase64("Cg4oNTE5KSA4NjctNTMwOQ==");
     server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));
@@ -85,12 +112,14 @@
       service.wrongClass();
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Unable to create converter for class java.lang.String\n"
+      assertThat(e).hasMessage(""
+          + "Unable to create converter for class java.lang.String\n"
           + "    for method Service.wrongClass");
-      assertThat(e.getCause()).hasMessage(
-          "Could not locate ResponseBody converter for class java.lang.String. Tried:\n"
-              + " * retrofit2.BuiltInConverters\n"
-              + " * retrofit2.ProtoConverterFactory");
+      assertThat(e.getCause()).hasMessage(""
+          + "Could not locate ResponseBody converter for class java.lang.String.\n"
+          + "  Tried:\n"
+          + "   * retrofit2.BuiltInConverters\n"
+          + "   * retrofit2.converter.protobuf.ProtoConverterFactory");
     }
   }
 
@@ -102,12 +131,14 @@
       service.wrongType();
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Unable to create converter for java.util.List<java.lang.String>\n"
+      assertThat(e).hasMessage(""
+          + "Unable to create converter for java.util.List<java.lang.String>\n"
           + "    for method Service.wrongType");
-      assertThat(e.getCause()).hasMessage(
-          "Could not locate ResponseBody converter for java.util.List<java.lang.String>. Tried:\n"
-              + " * retrofit2.BuiltInConverters\n"
-              + " * retrofit2.ProtoConverterFactory");
+      assertThat(e.getCause()).hasMessage(""
+          + "Could not locate ResponseBody converter for java.util.List<java.lang.String>.\n"
+          + "  Tried:\n"
+          + "   * retrofit2.BuiltInConverters\n"
+          + "   * retrofit2.converter.protobuf.ProtoConverterFactory");
     }
   }
 
diff --git a/retrofit-converters/protobuf/src/test/protos/phone.proto b/retrofit-converters/protobuf/src/test/protos/phone.proto
index 00fb8e133..02e4b9268 100644
--- a/retrofit-converters/protobuf/src/test/protos/phone.proto
+++ b/retrofit-converters/protobuf/src/test/protos/phone.proto
@@ -1,8 +1,14 @@
-package retrofit2;
+package retrofit2.converter.protobuf;
 
-option java_package = "retrofit2";
+option java_package = "retrofit2.converter.protobuf";
 option java_outer_classname = "PhoneProtos";
 
 message Phone {
   optional string number = 1;
+
+  extensions 2;
+}
+
+extend Phone {
+  optional bool voicemail = 2;
 }
diff --git a/retrofit-converters/scalars/README.md b/retrofit-converters/scalars/README.md
index e3edef925..5231b6129 100644
--- a/retrofit-converters/scalars/README.md
+++ b/retrofit-converters/scalars/README.md
@@ -3,3 +3,28 @@ Java Scalars Converter
 
 A `Converter` which supports converting strings and both primitives and their boxed types to
 `text/plain` bodies.
+
+
+Download
+--------
+
+Download [the latest JAR][1] or grab via [Maven][2]:
+```xml
+<dependency>
+  <groupId>com.squareup.retrofit2</groupId>
+  <artifactId>converter-scalars</artifactId>
+  <version>latest.version</version>
+</dependency>
+```
+or [Gradle][2]:
+```groovy
+compile 'com.squareup.retrofit2:converter-scalars:latest.version'
+```
+
+Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
+
+
+
+ [1]: https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=converter-scalars&v=LATEST
+ [2]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup.retrofit2%22%20a%3A%22converter-scalars%22
+ [snap]: https://oss.sonatype.org/content/repositories/snapshots/
diff --git a/retrofit-converters/scalars/pom.xml b/retrofit-converters/scalars/pom.xml
index f7fefc015..7a019e69d 100644
--- a/retrofit-converters/scalars/pom.xml
+++ b/retrofit-converters/scalars/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-converters</artifactId>
-    <version>2.0.0-SNAPSHOT</version>
+    <version>2.4.1-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -19,6 +19,11 @@
       <artifactId>retrofit</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
@@ -26,7 +31,7 @@
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>com.squareup.okhttp3</groupId>
       <artifactId>mockwebserver</artifactId>
       <scope>test</scope>
     </dependency>
@@ -36,4 +41,20 @@
       <scope>test</scope>
     </dependency>
   </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-jar-plugin</artifactId>
+        <configuration>
+          <archive>
+            <manifestEntries>
+              <Automatic-Module-Name>retrofit2.converter.scalars</Automatic-Module-Name>
+            </manifestEntries>
+          </archive>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
 </project>
diff --git a/retrofit-converters/scalars/src/main/java/retrofit2/ScalarsConverterFactory.java b/retrofit-converters/scalars/src/main/java/retrofit2/ScalarsConverterFactory.java
deleted file mode 100644
index 24f7e201b..000000000
--- a/retrofit-converters/scalars/src/main/java/retrofit2/ScalarsConverterFactory.java
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2;
-
-import com.squareup.okhttp.RequestBody;
-import java.lang.annotation.Annotation;
-import java.lang.reflect.Type;
-
-/**
- * A {@linkplain Converter.Factory converter} for strings and both primitives and their boxed types
- * to {@code text/plain} bodies.
- */
-public final class ScalarsConverterFactory extends Converter.Factory {
-  public static ScalarsConverterFactory create() {
-    return new ScalarsConverterFactory();
-  }
-
-  private ScalarsConverterFactory() {
-  }
-
-  @Override
-  public Converter<?, RequestBody> requestBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
-    if (type == String.class
-        || type == boolean.class
-        || type == Boolean.class
-        || type == byte.class
-        || type == Byte.class
-        || type == char.class
-        || type == Character.class
-        || type == double.class
-        || type == Double.class
-        || type == float.class
-        || type == Float.class
-        || type == int.class
-        || type == Integer.class
-        || type == long.class
-        || type == Long.class
-        || type == short.class
-        || type == Short.class) {
-      return ScalarRequestBodyConverter.INSTANCE;
-    }
-    return null;
-  }
-}
diff --git a/retrofit-converters/scalars/src/main/java/retrofit2/ScalarRequestBodyConverter.java b/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarRequestBodyConverter.java
similarity index 90%
rename from retrofit-converters/scalars/src/main/java/retrofit2/ScalarRequestBodyConverter.java
rename to retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarRequestBodyConverter.java
index 133e5fd54..fd65200d4 100644
--- a/retrofit-converters/scalars/src/main/java/retrofit2/ScalarRequestBodyConverter.java
+++ b/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarRequestBodyConverter.java
@@ -13,11 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.scalars;
 
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.RequestBody;
 import java.io.IOException;
+import okhttp3.MediaType;
+import okhttp3.RequestBody;
+import retrofit2.Converter;
 
 final class ScalarRequestBodyConverter<T> implements Converter<T, RequestBody> {
   static final ScalarRequestBodyConverter<Object> INSTANCE = new ScalarRequestBodyConverter<>();
diff --git a/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarResponseBodyConverters.java b/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarResponseBodyConverters.java
new file mode 100644
index 000000000..a91d87c82
--- /dev/null
+++ b/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarResponseBodyConverters.java
@@ -0,0 +1,102 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.converter.scalars;
+
+import java.io.IOException;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+
+final class ScalarResponseBodyConverters {
+  private ScalarResponseBodyConverters() {
+  }
+
+  static final class StringResponseBodyConverter implements Converter<ResponseBody, String> {
+    static final StringResponseBodyConverter INSTANCE = new StringResponseBodyConverter();
+
+    @Override public String convert(ResponseBody value) throws IOException {
+      return value.string();
+    }
+  }
+
+  static final class BooleanResponseBodyConverter implements Converter<ResponseBody, Boolean> {
+    static final BooleanResponseBodyConverter INSTANCE = new BooleanResponseBodyConverter();
+
+    @Override public Boolean convert(ResponseBody value) throws IOException {
+      return Boolean.valueOf(value.string());
+    }
+  }
+
+  static final class ByteResponseBodyConverter implements Converter<ResponseBody, Byte> {
+    static final ByteResponseBodyConverter INSTANCE = new ByteResponseBodyConverter();
+
+    @Override public Byte convert(ResponseBody value) throws IOException {
+      return Byte.valueOf(value.string());
+    }
+  }
+
+  static final class CharacterResponseBodyConverter implements Converter<ResponseBody, Character> {
+    static final CharacterResponseBodyConverter INSTANCE = new CharacterResponseBodyConverter();
+
+    @Override public Character convert(ResponseBody value) throws IOException {
+      String body = value.string();
+      if (body.length() != 1) {
+        throw new IOException(
+            "Expected body of length 1 for Character conversion but was " + body.length());
+      }
+      return body.charAt(0);
+    }
+  }
+
+  static final class DoubleResponseBodyConverter implements Converter<ResponseBody, Double> {
+    static final DoubleResponseBodyConverter INSTANCE = new DoubleResponseBodyConverter();
+
+    @Override public Double convert(ResponseBody value) throws IOException {
+      return Double.valueOf(value.string());
+    }
+  }
+
+  static final class FloatResponseBodyConverter implements Converter<ResponseBody, Float> {
+    static final FloatResponseBodyConverter INSTANCE = new FloatResponseBodyConverter();
+
+    @Override public Float convert(ResponseBody value) throws IOException {
+      return Float.valueOf(value.string());
+    }
+  }
+
+  static final class IntegerResponseBodyConverter implements Converter<ResponseBody, Integer> {
+    static final IntegerResponseBodyConverter INSTANCE = new IntegerResponseBodyConverter();
+
+    @Override public Integer convert(ResponseBody value) throws IOException {
+      return Integer.valueOf(value.string());
+    }
+  }
+
+  static final class LongResponseBodyConverter implements Converter<ResponseBody, Long> {
+    static final LongResponseBodyConverter INSTANCE = new LongResponseBodyConverter();
+
+    @Override public Long convert(ResponseBody value) throws IOException {
+      return Long.valueOf(value.string());
+    }
+  }
+
+  static final class ShortResponseBodyConverter implements Converter<ResponseBody, Short> {
+    static final ShortResponseBodyConverter INSTANCE = new ShortResponseBodyConverter();
+
+    @Override public Short convert(ResponseBody value) throws IOException {
+      return Short.valueOf(value.string());
+    }
+  }
+}
diff --git a/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarsConverterFactory.java b/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarsConverterFactory.java
new file mode 100644
index 000000000..5bf838fe9
--- /dev/null
+++ b/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarsConverterFactory.java
@@ -0,0 +1,102 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.converter.scalars;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
+import retrofit2.converter.scalars.ScalarResponseBodyConverters.BooleanResponseBodyConverter;
+import retrofit2.converter.scalars.ScalarResponseBodyConverters.ByteResponseBodyConverter;
+import retrofit2.converter.scalars.ScalarResponseBodyConverters.CharacterResponseBodyConverter;
+import retrofit2.converter.scalars.ScalarResponseBodyConverters.DoubleResponseBodyConverter;
+import retrofit2.converter.scalars.ScalarResponseBodyConverters.FloatResponseBodyConverter;
+import retrofit2.converter.scalars.ScalarResponseBodyConverters.IntegerResponseBodyConverter;
+import retrofit2.converter.scalars.ScalarResponseBodyConverters.LongResponseBodyConverter;
+import retrofit2.converter.scalars.ScalarResponseBodyConverters.ShortResponseBodyConverter;
+import retrofit2.converter.scalars.ScalarResponseBodyConverters.StringResponseBodyConverter;
+
+/**
+ * A {@linkplain Converter.Factory converter} for strings and both primitives and their boxed types
+ * to {@code text/plain} bodies.
+ */
+public final class ScalarsConverterFactory extends Converter.Factory {
+  public static ScalarsConverterFactory create() {
+    return new ScalarsConverterFactory();
+  }
+
+  private ScalarsConverterFactory() {
+  }
+
+  @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
+      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+    if (type == String.class
+        || type == boolean.class
+        || type == Boolean.class
+        || type == byte.class
+        || type == Byte.class
+        || type == char.class
+        || type == Character.class
+        || type == double.class
+        || type == Double.class
+        || type == float.class
+        || type == Float.class
+        || type == int.class
+        || type == Integer.class
+        || type == long.class
+        || type == Long.class
+        || type == short.class
+        || type == Short.class) {
+      return ScalarRequestBodyConverter.INSTANCE;
+    }
+    return null;
+  }
+
+  @Override
+  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
+    if (type == String.class) {
+      return StringResponseBodyConverter.INSTANCE;
+    }
+    if (type == Boolean.class || type == boolean.class) {
+      return BooleanResponseBodyConverter.INSTANCE;
+    }
+    if (type == Byte.class || type == byte.class) {
+      return ByteResponseBodyConverter.INSTANCE;
+    }
+    if (type == Character.class || type == char.class) {
+      return CharacterResponseBodyConverter.INSTANCE;
+    }
+    if (type == Double.class || type == double.class) {
+      return DoubleResponseBodyConverter.INSTANCE;
+    }
+    if (type == Float.class || type == float.class) {
+      return FloatResponseBodyConverter.INSTANCE;
+    }
+    if (type == Integer.class || type == int.class) {
+      return IntegerResponseBodyConverter.INSTANCE;
+    }
+    if (type == Long.class || type == long.class) {
+      return LongResponseBodyConverter.INSTANCE;
+    }
+    if (type == Short.class || type == short.class) {
+      return ShortResponseBodyConverter.INSTANCE;
+    }
+    return null;
+  }
+}
diff --git a/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/package-info.java b/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/package-info.java
new file mode 100644
index 000000000..0ea2f7740
--- /dev/null
+++ b/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/package-info.java
@@ -0,0 +1,4 @@
+@ParametersAreNonnullByDefault
+package retrofit2.converter.scalars;
+
+import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-converters/scalars/src/test/java/retrofit2/ScalarsConverterFactoryTest.java b/retrofit-converters/scalars/src/test/java/retrofit2/converter/scalars/ScalarsConverterFactoryTest.java
similarity index 66%
rename from retrofit-converters/scalars/src/test/java/retrofit2/ScalarsConverterFactoryTest.java
rename to retrofit-converters/scalars/src/test/java/retrofit2/converter/scalars/ScalarsConverterFactoryTest.java
index 31880a9d2..cc19d4fbc 100644
--- a/retrofit-converters/scalars/src/test/java/retrofit2/ScalarsConverterFactoryTest.java
+++ b/retrofit-converters/scalars/src/test/java/retrofit2/converter/scalars/ScalarsConverterFactoryTest.java
@@ -13,17 +13,22 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.scalars;
 
-import com.squareup.okhttp.ResponseBody;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import com.squareup.okhttp.mockwebserver.RecordedRequest;
 import java.io.IOException;
+import okhttp3.ResponseBody;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+import retrofit2.Call;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.converter.scalars.ScalarsConverterFactory;
 import retrofit2.http.Body;
+import retrofit2.http.GET;
 import retrofit2.http.POST;
 
 import static org.assertj.core.api.Assertions.assertThat;
@@ -50,6 +55,18 @@
       @POST("/") Call<ResponseBody> longObject(@Body Long body);
       @POST("/") Call<ResponseBody> shortPrimitive(@Body short body);
       @POST("/") Call<ResponseBody> shortObject(@Body Short body);
+
+      @GET("/") Call<Object> object();
+
+      @GET("/") Call<String> stringObject();
+      @GET("/") Call<Boolean> booleanObject();
+      @GET("/") Call<Byte> byteObject();
+      @GET("/") Call<Character> charObject();
+      @GET("/") Call<Double> doubleObject();
+      @GET("/") Call<Float> floatObject();
+      @GET("/") Call<Integer> integerObject();
+      @GET("/") Call<Long> longObject();
+      @GET("/") Call<Short> shortObject();
   }
 
   @Rule public final MockWebServer server = new MockWebServer();
@@ -64,22 +81,23 @@
     service = retrofit.create(Service.class);
   }
 
-  @Test public void unsupportedTypesNotMatched() {
+  @Test public void unsupportedRequestTypesNotMatched() {
     try {
       service.object(null);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Unable to create @Body converter for class java.lang.Object (parameter #1)\n"
-              + "    for method Service.object");
-      assertThat(e.getCause()).hasMessage(
-          "Could not locate RequestBody converter for class java.lang.Object. Tried:\n"
-              + " * retrofit2.BuiltInConverters\n"
-              + " * retrofit2.ScalarsConverterFactory");
+      assertThat(e).hasMessage(""
+          + "Unable to create @Body converter for class java.lang.Object (parameter #1)\n"
+          + "    for method Service.object");
+      assertThat(e.getCause()).hasMessage(""
+          + "Could not locate RequestBody converter for class java.lang.Object.\n"
+          + "  Tried:\n"
+          + "   * retrofit2.BuiltInConverters\n"
+          + "   * retrofit2.converter.scalars.ScalarsConverterFactory");
     }
   }
 
-  @Test public void supportedTypes() throws IOException, InterruptedException {
+  @Test public void supportedRequestTypes() throws IOException, InterruptedException {
     RecordedRequest request;
 
     server.enqueue(new MockResponse());
@@ -201,4 +219,72 @@
     assertThat(request.getHeader("Content-Length")).isEqualTo("2");
     assertThat(request.getBody().readUtf8()).isEqualTo("11");
   }
+
+  @Test public void unsupportedResponseTypesNotMatched() {
+    try {
+      service.object();
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(""
+          + "Unable to create converter for class java.lang.Object\n"
+          + "    for method Service.object");
+      assertThat(e.getCause()).hasMessage(""
+          + "Could not locate ResponseBody converter for class java.lang.Object.\n"
+          + "  Tried:\n"
+          + "   * retrofit2.BuiltInConverters\n"
+          + "   * retrofit2.converter.scalars.ScalarsConverterFactory");
+    }
+  }
+
+  @Test public void supportedResponseTypes() throws IOException, InterruptedException {
+    server.enqueue(new MockResponse().setBody("test"));
+    Response<String> stringResponse = service.stringObject().execute();
+    assertThat(stringResponse.body()).isEqualTo("test");
+
+    server.enqueue(new MockResponse().setBody("true"));
+    Response<Boolean> booleanResponse = service.booleanObject().execute();
+    assertThat(booleanResponse.body()).isTrue();
+
+    server.enqueue(new MockResponse().setBody("5"));
+    Response<Byte> byteResponse = service.byteObject().execute();
+    assertThat(byteResponse.body()).isEqualTo((byte) 5);
+
+    server.enqueue(new MockResponse().setBody("b"));
+    Response<Character> characterResponse = service.charObject().execute();
+    assertThat(characterResponse.body()).isEqualTo('b');
+
+    server.enqueue(new MockResponse().setBody(""));
+    try {
+      service.charObject().execute();
+    } catch (IOException e) {
+      assertThat(e).hasMessage("Expected body of length 1 for Character conversion but was 0");
+    }
+
+    server.enqueue(new MockResponse().setBody("bb"));
+    try {
+      service.charObject().execute();
+    } catch (IOException e) {
+      assertThat(e).hasMessage("Expected body of length 1 for Character conversion but was 2");
+    }
+
+    server.enqueue(new MockResponse().setBody("13.13"));
+    Response<Double> doubleResponse = service.doubleObject().execute();
+    assertThat(doubleResponse.body()).isEqualTo(13.13);
+
+    server.enqueue(new MockResponse().setBody("13.13"));
+    Response<Float> floatResponse = service.floatObject().execute();
+    assertThat(floatResponse.body()).isEqualTo(13.13f);
+
+    server.enqueue(new MockResponse().setBody("13"));
+    Response<Integer> integerResponse = service.integerObject().execute();
+    assertThat(integerResponse.body()).isEqualTo(13);
+
+    server.enqueue(new MockResponse().setBody("1347"));
+    Response<Long> longResponse = service.longObject().execute();
+    assertThat(longResponse.body()).isEqualTo(1347L);
+
+    server.enqueue(new MockResponse().setBody("134"));
+    Response<Short> shortResponse = service.shortObject().execute();
+    assertThat(shortResponse.body()).isEqualTo((short) 134);
+  }
 }
diff --git a/retrofit-converters/scalars/src/test/java/retrofit2/converter/scalars/ScalarsConverterPrimitivesFactoryTest.java b/retrofit-converters/scalars/src/test/java/retrofit2/converter/scalars/ScalarsConverterPrimitivesFactoryTest.java
new file mode 100644
index 000000000..8145bde2d
--- /dev/null
+++ b/retrofit-converters/scalars/src/test/java/retrofit2/converter/scalars/ScalarsConverterPrimitivesFactoryTest.java
@@ -0,0 +1,130 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.converter.scalars;
+
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Call;
+import retrofit2.CallAdapter;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class ScalarsConverterPrimitivesFactoryTest {
+  interface Service {
+    @GET("/") boolean booleanPrimitive();
+    @GET("/") byte bytePrimitive();
+    @GET("/") char charPrimitive();
+    @GET("/") double doublePrimitive();
+    @GET("/") float floatPrimitive();
+    @GET("/") int integerPrimitive();
+    @GET("/") long longPrimitive();
+    @GET("/") short shortPrimitive();
+  }
+
+  static class DirectCallIOException extends RuntimeException {
+    DirectCallIOException(String message, IOException e) {
+      super(message, e);
+    }
+  }
+
+  static class DirectCallAdapterFactory extends CallAdapter.Factory {
+    @Override
+    public CallAdapter<?, ?> get(final Type returnType, Annotation[] annotations, Retrofit retrofit) {
+      return new CallAdapter<Object, Object>() {
+        @Override public Type responseType() {
+          return returnType;
+        }
+
+        @Override public Object adapt(Call call) {
+          try {
+            return call.execute().body();
+          } catch (IOException e) {
+            throw new DirectCallIOException(e.getMessage(), e);
+          }
+        }
+      };
+    }
+  }
+
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(ScalarsConverterFactory.create())
+        .addCallAdapterFactory(new DirectCallAdapterFactory())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void supportedResponseTypes() throws IOException, InterruptedException {
+    server.enqueue(new MockResponse().setBody("true"));
+    boolean booleanResponse = service.booleanPrimitive();
+    assertThat(booleanResponse).isTrue();
+
+    server.enqueue(new MockResponse().setBody("5"));
+    byte byteResponse = service.bytePrimitive();
+    assertThat(byteResponse).isEqualTo((byte) 5);
+
+    server.enqueue(new MockResponse().setBody("b"));
+    char characterResponse = service.charPrimitive();
+    assertThat(characterResponse).isEqualTo('b');
+
+    server.enqueue(new MockResponse().setBody(""));
+    try {
+      service.charPrimitive();
+    } catch (DirectCallIOException e) {
+      assertThat(e).hasMessage("Expected body of length 1 for Character conversion but was 0");
+    }
+
+    server.enqueue(new MockResponse().setBody("bb"));
+    try {
+      service.charPrimitive();
+    } catch (DirectCallIOException e) {
+      assertThat(e).hasMessage("Expected body of length 1 for Character conversion but was 2");
+    }
+
+    server.enqueue(new MockResponse().setBody("13.13"));
+    double doubleResponse = service.doublePrimitive();
+    assertThat(doubleResponse).isEqualTo(13.13);
+
+    server.enqueue(new MockResponse().setBody("13.13"));
+    float floatResponse = service.floatPrimitive();
+    assertThat(floatResponse).isEqualTo(13.13f);
+
+    server.enqueue(new MockResponse().setBody("13"));
+    int integerResponse = service.integerPrimitive();
+    assertThat(integerResponse).isEqualTo(13);
+
+    server.enqueue(new MockResponse().setBody("1347"));
+    long longResponse = service.longPrimitive();
+    assertThat(longResponse).isEqualTo(1347L);
+
+    server.enqueue(new MockResponse().setBody("134"));
+    short shortResponse = service.shortPrimitive();
+    assertThat(shortResponse).isEqualTo((short) 134);
+  }
+}
diff --git a/retrofit-converters/simplexml/README.md b/retrofit-converters/simplexml/README.md
index 8d5b8e369..37e6f8f50 100644
--- a/retrofit-converters/simplexml/README.md
+++ b/retrofit-converters/simplexml/README.md
@@ -1,6 +1,14 @@
 Simple XML Converter
 ====================
 
+Deprecated – Please switch to the JAXB Converter
+------------------------------------------------
+
+The Simple XML project is no longer maintained. We recommend switching to the
+[JAXB converter](https://github.com/square/retrofit/tree/master/retrofit-converters/jaxb).
+
+-----
+
 A `Converter` which uses [Simple][1] for XML serialization.
 
 A default `Serializer` instance will be created or one can be configured and passed to the
@@ -15,5 +23,27 @@ a Maven or Gradle dependency, exclude the following transitive dependencies: `st
 `stax:stax`, and `xpp3:xpp3`.
 
 
+Download
+--------
+
+Download [the latest JAR][2] or grab via [Maven][3]:
+```xml
+<dependency>
+  <groupId>com.squareup.retrofit2</groupId>
+  <artifactId>converter-simplexml</artifactId>
+  <version>latest.version</version>
+</dependency>
+```
+or [Gradle][3]:
+```groovy
+compile 'com.squareup.retrofit2:converter-simplexml:latest.version'
+```
+
+Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
+
+
 
  [1]: http://simple.sourceforge.net/
+ [2]: https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=converter-simplexml&v=LATEST
+ [3]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup.retrofit2%22%20a%3A%22converter-simplexml%22
+ [snap]: https://oss.sonatype.org/content/repositories/snapshots/
diff --git a/retrofit-converters/simplexml/pom.xml b/retrofit-converters/simplexml/pom.xml
index ed3714d3b..109208e2e 100644
--- a/retrofit-converters/simplexml/pom.xml
+++ b/retrofit-converters/simplexml/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-converters</artifactId>
-    <version>2.0.0-SNAPSHOT</version>
+    <version>2.4.1-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -23,6 +23,11 @@
       <groupId>org.simpleframework</groupId>
       <artifactId>simple-xml</artifactId>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
@@ -30,7 +35,7 @@
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>com.squareup.okhttp3</groupId>
       <artifactId>mockwebserver</artifactId>
       <scope>test</scope>
     </dependency>
@@ -40,4 +45,20 @@
       <scope>test</scope>
     </dependency>
   </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-jar-plugin</artifactId>
+        <configuration>
+          <archive>
+            <manifestEntries>
+              <Automatic-Module-Name>retrofit2.converter.simplexml</Automatic-Module-Name>
+            </manifestEntries>
+          </archive>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
 </project>
diff --git a/retrofit-converters/simplexml/src/main/java/retrofit2/SimpleXmlConverterFactory.java b/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlConverterFactory.java
similarity index 87%
rename from retrofit-converters/simplexml/src/main/java/retrofit2/SimpleXmlConverterFactory.java
rename to retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlConverterFactory.java
index eac944102..793806d1d 100644
--- a/retrofit-converters/simplexml/src/main/java/retrofit2/SimpleXmlConverterFactory.java
+++ b/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlConverterFactory.java
@@ -13,21 +13,26 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.simplexml;
 
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.ResponseBody;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
 import org.simpleframework.xml.Serializer;
 import org.simpleframework.xml.core.Persister;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
 
 /**
  * A {@linkplain Converter.Factory converter} which uses Simple Framework for XML.
  * <p>
  * This converter only applies for class types. Parameterized types (e.g., {@code List<Foo>}) are
  * not handled.
+ *
+ * @deprecated we recommend switching to the JAXB converter.
  */
+@Deprecated
 public final class SimpleXmlConverterFactory extends Converter.Factory {
   /** Create an instance using a default {@link Persister} instance for conversion. */
   public static SimpleXmlConverterFactory create() {
@@ -45,7 +50,9 @@ public static SimpleXmlConverterFactory createNonStrict() {
   }
 
   /** Create an instance using {@code serializer} for non-strict conversion. */
+  @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
   public static SimpleXmlConverterFactory createNonStrict(Serializer serializer) {
+    if (serializer == null) throw new NullPointerException("serializer == null");
     return new SimpleXmlConverterFactory(serializer, false);
   }
 
@@ -53,7 +60,6 @@ public static SimpleXmlConverterFactory createNonStrict(Serializer serializer) {
   private final boolean strict;
 
   private SimpleXmlConverterFactory(Serializer serializer, boolean strict) {
-    if (serializer == null) throw new NullPointerException("serializer == null");
     this.serializer = serializer;
     this.strict = strict;
   }
@@ -73,8 +79,8 @@ public boolean isStrict() {
   }
 
   @Override
-  public Converter<?, RequestBody> requestBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
+  public Converter<?, RequestBody> requestBodyConverter(Type type,
+      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     if (!(type instanceof Class)) {
       return null;
     }
diff --git a/retrofit-converters/simplexml/src/main/java/retrofit2/SimpleXmlRequestBodyConverter.java b/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlRequestBodyConverter.java
similarity index 92%
rename from retrofit-converters/simplexml/src/main/java/retrofit2/SimpleXmlRequestBodyConverter.java
rename to retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlRequestBodyConverter.java
index 997379170..06aeee1e6 100644
--- a/retrofit-converters/simplexml/src/main/java/retrofit2/SimpleXmlRequestBodyConverter.java
+++ b/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlRequestBodyConverter.java
@@ -13,14 +13,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.simplexml;
 
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.RequestBody;
 import java.io.IOException;
 import java.io.OutputStreamWriter;
+import okhttp3.MediaType;
+import okhttp3.RequestBody;
 import okio.Buffer;
 import org.simpleframework.xml.Serializer;
+import retrofit2.Converter;
 
 final class SimpleXmlRequestBodyConverter<T> implements Converter<T, RequestBody> {
   private static final MediaType MEDIA_TYPE = MediaType.parse("application/xml; charset=UTF-8");
diff --git a/retrofit-converters/simplexml/src/main/java/retrofit2/SimpleXmlResponseBodyConverter.java b/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlResponseBodyConverter.java
similarity index 84%
rename from retrofit-converters/simplexml/src/main/java/retrofit2/SimpleXmlResponseBodyConverter.java
rename to retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlResponseBodyConverter.java
index 5303a0c5d..01759f449 100644
--- a/retrofit-converters/simplexml/src/main/java/retrofit2/SimpleXmlResponseBodyConverter.java
+++ b/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlResponseBodyConverter.java
@@ -13,12 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.simplexml;
 
-import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
-import java.io.InputStream;
+import okhttp3.ResponseBody;
 import org.simpleframework.xml.Serializer;
+import retrofit2.Converter;
 
 final class SimpleXmlResponseBodyConverter<T> implements Converter<ResponseBody, T> {
   private final Class<T> cls;
@@ -32,9 +32,8 @@
   }
 
   @Override public T convert(ResponseBody value) throws IOException {
-    InputStream is = value.byteStream();
     try {
-      T read = serializer.read(cls, is, strict);
+      T read = serializer.read(cls, value.charStream(), strict);
       if (read == null) {
         throw new IllegalStateException("Could not deserialize body as " + cls);
       }
@@ -44,10 +43,7 @@
     } catch (Exception e) {
       throw new RuntimeException(e);
     } finally {
-      try {
-        is.close();
-      } catch (IOException ignored) {
-      }
+      value.close();
     }
   }
 }
diff --git a/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/package-info.java b/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/package-info.java
new file mode 100644
index 000000000..69507b872
--- /dev/null
+++ b/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/package-info.java
@@ -0,0 +1,4 @@
+@ParametersAreNonnullByDefault
+package retrofit2.converter.simplexml;
+
+import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-converters/simplexml/src/test/java/retrofit2/MyObject.java b/retrofit-converters/simplexml/src/test/java/retrofit2/converter/simplexml/MyObject.java
similarity index 97%
rename from retrofit-converters/simplexml/src/test/java/retrofit2/MyObject.java
rename to retrofit-converters/simplexml/src/test/java/retrofit2/converter/simplexml/MyObject.java
index 3730b9544..18d2e146f 100644
--- a/retrofit-converters/simplexml/src/test/java/retrofit2/MyObject.java
+++ b/retrofit-converters/simplexml/src/test/java/retrofit2/converter/simplexml/MyObject.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.simplexml;
 
 import org.simpleframework.xml.Default;
 import org.simpleframework.xml.DefaultType;
diff --git a/retrofit-converters/simplexml/src/test/java/retrofit2/SimpleXmlConverterFactoryTest.java b/retrofit-converters/simplexml/src/test/java/retrofit2/converter/simplexml/SimpleXmlConverterFactoryTest.java
similarity index 75%
rename from retrofit-converters/simplexml/src/test/java/retrofit2/SimpleXmlConverterFactoryTest.java
rename to retrofit-converters/simplexml/src/test/java/retrofit2/converter/simplexml/SimpleXmlConverterFactoryTest.java
index e6da9e2d9..7ad58b22d 100644
--- a/retrofit-converters/simplexml/src/test/java/retrofit2/SimpleXmlConverterFactoryTest.java
+++ b/retrofit-converters/simplexml/src/test/java/retrofit2/converter/simplexml/SimpleXmlConverterFactoryTest.java
@@ -13,12 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.simplexml;
 
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import com.squareup.okhttp.mockwebserver.RecordedRequest;
 import java.io.IOException;
+import java.nio.charset.Charset;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
+import okio.Buffer;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
@@ -27,6 +29,9 @@
 import org.simpleframework.xml.stream.Format;
 import org.simpleframework.xml.stream.HyphenStyle;
 import org.simpleframework.xml.stream.Verbosity;
+import retrofit2.Call;
+import retrofit2.Response;
+import retrofit2.Retrofit;
 import retrofit2.http.Body;
 import retrofit2.http.GET;
 import retrofit2.http.POST;
@@ -66,11 +71,25 @@
     assertThat(body.getCount()).isEqualTo(10);
 
     RecordedRequest request = server.takeRequest();
-    assertThat(request.getBody().readUtf8()).isEqualTo(
-        "<my-object><message>hello world</message><count>10</count></my-object>");
+    assertThat(request.getBody().readUtf8()).isIn(
+        "<my-object><message>hello world</message><count>10</count></my-object>",
+        "<my-object><count>10</count><message>hello world</message></my-object>");
     assertThat(request.getHeader("Content-Type")).isEqualTo("application/xml; charset=UTF-8");
   }
 
+  @Test public void honorsCharacterEncoding() throws IOException {
+    Buffer buffer = new Buffer().writeString(
+        "<my-object><message>你好，世界</message><count>10</count></my-object>",
+        Charset.forName("GBK"));
+    server.enqueue(
+        new MockResponse().setBody(buffer).addHeader("Content-Type", "text/xml;charset=GBK"));
+
+    Call<MyObject> call = service.get();
+    Response<MyObject> response = call.execute();
+    MyObject body = response.body();
+    assertThat(body.getMessage()).isEqualTo("你好，世界");
+  }
+
   @Test public void deserializeWrongValue() throws IOException {
     server.enqueue(new MockResponse().setBody("<myObject><foo/><bar/></myObject>"));
 
@@ -80,7 +99,7 @@
       fail();
     } catch (RuntimeException e) {
       assertThat(e.getCause()).isInstanceOf(ElementException.class)
-          .hasMessageStartingWith("Element 'foo' does not have a match in class retrofit2.MyObject");
+          .hasMessageStartingWith("Element 'foo' does not have a match in class retrofit2.converter.simplexml.MyObject");
     }
   }
 
diff --git a/retrofit-converters/wire/README.md b/retrofit-converters/wire/README.md
index 9c82b143e..6289cc8a7 100644
--- a/retrofit-converters/wire/README.md
+++ b/retrofit-converters/wire/README.md
@@ -4,4 +4,27 @@ Wire Converter
 A `Converter` which uses [Wire][1] for protocol buffer-compatible serialization.
 
 
+Download
+--------
+
+Download [the latest JAR][2] or grab via [Maven][3]:
+```xml
+<dependency>
+  <groupId>com.squareup.retrofit2</groupId>
+  <artifactId>converter-wire</artifactId>
+  <version>latest.version</version>
+</dependency>
+```
+or [Gradle][3]:
+```groovy
+compile 'com.squareup.retrofit2:converter-wire:latest.version'
+```
+
+Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
+
+
+
  [1]: https://github.com/square/wire
+ [2]: https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=converter-wire&v=LATEST
+ [3]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup.retrofit2%22%20a%3A%22converter-wire%22
+ [snap]: https://oss.sonatype.org/content/repositories/snapshots/
diff --git a/retrofit-converters/wire/pom.xml b/retrofit-converters/wire/pom.xml
index 8357bc0de..333e91813 100644
--- a/retrofit-converters/wire/pom.xml
+++ b/retrofit-converters/wire/pom.xml
@@ -10,7 +10,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-converters</artifactId>
-    <version>2.0.0-SNAPSHOT</version>
+    <version>2.4.1-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -34,6 +34,11 @@
         </exclusion>
       </exclusions>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
@@ -41,7 +46,7 @@
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>com.squareup.okhttp3</groupId>
       <artifactId>mockwebserver</artifactId>
       <scope>test</scope>
     </dependency>
@@ -51,4 +56,20 @@
       <scope>test</scope>
     </dependency>
   </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-jar-plugin</artifactId>
+        <configuration>
+          <archive>
+            <manifestEntries>
+              <Automatic-Module-Name>retrofit2.converter.wire</Automatic-Module-Name>
+            </manifestEntries>
+          </archive>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
 </project>
diff --git a/retrofit-converters/wire/src/main/java/retrofit2/WireConverterFactory.java b/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireConverterFactory.java
similarity index 89%
rename from retrofit-converters/wire/src/main/java/retrofit2/WireConverterFactory.java
rename to retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireConverterFactory.java
index b084c6e7b..fbaaeac4a 100644
--- a/retrofit-converters/wire/src/main/java/retrofit2/WireConverterFactory.java
+++ b/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireConverterFactory.java
@@ -13,14 +13,16 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.wire;
 
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.ResponseBody;
 import com.squareup.wire.Message;
 import com.squareup.wire.ProtoAdapter;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
 
 /**
  * A {@linkplain Converter.Factory converter} that uses Wire for protocol buffers.
@@ -51,8 +53,8 @@ private WireConverterFactory() {
   }
 
   @Override
-  public Converter<?, RequestBody> requestBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
+  public Converter<?, RequestBody> requestBodyConverter(Type type,
+      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     if (!(type instanceof Class<?>)) {
       return null;
     }
diff --git a/retrofit-converters/wire/src/main/java/retrofit2/WireRequestBodyConverter.java b/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireRequestBodyConverter.java
similarity index 91%
rename from retrofit-converters/wire/src/main/java/retrofit2/WireRequestBodyConverter.java
rename to retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireRequestBodyConverter.java
index 193be4dbb..d388a944c 100644
--- a/retrofit-converters/wire/src/main/java/retrofit2/WireRequestBodyConverter.java
+++ b/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireRequestBodyConverter.java
@@ -13,14 +13,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.wire;
 
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.RequestBody;
 import com.squareup.wire.Message;
 import com.squareup.wire.ProtoAdapter;
 import java.io.IOException;
+import okhttp3.MediaType;
+import okhttp3.RequestBody;
 import okio.Buffer;
+import retrofit2.Converter;
 
 final class WireRequestBodyConverter<T extends Message<T, ?>> implements Converter<T, RequestBody> {
   private static final MediaType MEDIA_TYPE = MediaType.parse("application/x-protobuf");
diff --git a/retrofit-converters/wire/src/main/java/retrofit2/WireResponseBodyConverter.java b/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireResponseBodyConverter.java
similarity index 76%
rename from retrofit-converters/wire/src/main/java/retrofit2/WireResponseBodyConverter.java
rename to retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireResponseBodyConverter.java
index 974df6357..5ab321381 100644
--- a/retrofit-converters/wire/src/main/java/retrofit2/WireResponseBodyConverter.java
+++ b/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireResponseBodyConverter.java
@@ -13,13 +13,13 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.wire;
 
-import com.squareup.okhttp.ResponseBody;
 import com.squareup.wire.Message;
 import com.squareup.wire.ProtoAdapter;
 import java.io.IOException;
-import okio.BufferedSource;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
 
 final class WireResponseBodyConverter<T extends Message<T, ?>>
     implements Converter<ResponseBody, T> {
@@ -30,17 +30,10 @@
   }
 
   @Override public T convert(ResponseBody value) throws IOException {
-    BufferedSource source = null;
     try {
-      source = value.source();
-      return adapter.decode(source);
+      return adapter.decode(value.source());
     } finally {
-      if (source != null) {
-        try {
-          source.close();
-        } catch (IOException ignored) {
-        }
-      }
+      value.close();
     }
   }
 }
diff --git a/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/package-info.java b/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/package-info.java
new file mode 100644
index 000000000..483b65c81
--- /dev/null
+++ b/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/package-info.java
@@ -0,0 +1,4 @@
+@ParametersAreNonnullByDefault
+package retrofit2.converter.wire;
+
+import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-converters/wire/src/test/java/retrofit2/Phone.java b/retrofit-converters/wire/src/test/java/retrofit2/converter/wire/Phone.java
similarity index 83%
rename from retrofit-converters/wire/src/test/java/retrofit2/Phone.java
rename to retrofit-converters/wire/src/test/java/retrofit2/converter/wire/Phone.java
index 078a4c80a..c085094bb 100644
--- a/retrofit-converters/wire/src/test/java/retrofit2/Phone.java
+++ b/retrofit-converters/wire/src/test/java/retrofit2/converter/wire/Phone.java
@@ -1,12 +1,14 @@
 // Code generated by Wire protocol buffer compiler, do not edit.
-// Source file: test.proto at 2:1
-package retrofit2;
+// Source file: phone.proto at 6:1
+package retrofit2.converter.wire;
 
 import com.squareup.wire.FieldEncoding;
 import com.squareup.wire.Message;
 import com.squareup.wire.ProtoAdapter;
 import com.squareup.wire.ProtoReader;
 import com.squareup.wire.ProtoWriter;
+import com.squareup.wire.WireField;
+import com.squareup.wire.internal.Internal;
 import java.io.IOException;
 import java.lang.Object;
 import java.lang.Override;
@@ -15,49 +17,16 @@
 import okio.ByteString;
 
 public final class Phone extends Message<Phone, Phone.Builder> {
-  public static final ProtoAdapter<Phone> ADAPTER = new ProtoAdapter<Phone>(FieldEncoding.LENGTH_DELIMITED, Phone.class) {
-    @Override
-    public int encodedSize(Phone value) {
-      return (value.number != null ? ProtoAdapter.STRING.encodedSizeWithTag(1, value.number) : 0)
-          + value.unknownFields().size();
-    }
-
-    @Override
-    public void encode(ProtoWriter writer, Phone value) throws IOException {
-      if (value.number != null) ProtoAdapter.STRING.encodeWithTag(writer, 1, value.number);
-      writer.writeBytes(value.unknownFields());
-    }
-
-    @Override
-    public Phone decode(ProtoReader reader) throws IOException {
-      Builder builder = new Builder();
-      long token = reader.beginMessage();
-      for (int tag; (tag = reader.nextTag()) != -1;) {
-        switch (tag) {
-          case 1: builder.number(ProtoAdapter.STRING.decode(reader)); break;
-          default: {
-            FieldEncoding fieldEncoding = reader.peekFieldEncoding();
-            Object value = fieldEncoding.rawProtoAdapter().decode(reader);
-            builder.addUnknownField(tag, fieldEncoding, value);
-          }
-        }
-      }
-      reader.endMessage(token);
-      return builder.build();
-    }
-
-    @Override
-    public Phone redact(Phone value) {
-      Builder builder = value.newBuilder();
-      builder.clearUnknownFields();
-      return builder.build();
-    }
-  };
+  public static final ProtoAdapter<Phone> ADAPTER = new ProtoAdapter_Phone();
 
   private static final long serialVersionUID = 0L;
 
   public static final String DEFAULT_NUMBER = "";
 
+  @WireField(
+      tag = 1,
+      adapter = "com.squareup.wire.ProtoAdapter#STRING"
+  )
   public final String number;
 
   public Phone(String number) {
@@ -65,7 +34,7 @@ public Phone(String number) {
   }
 
   public Phone(String number, ByteString unknownFields) {
-    super(unknownFields);
+    super(ADAPTER, unknownFields);
     this.number = number;
   }
 
@@ -82,8 +51,8 @@ public boolean equals(Object other) {
     if (other == this) return true;
     if (!(other instanceof Phone)) return false;
     Phone o = (Phone) other;
-    return equals(unknownFields(), o.unknownFields())
-        && equals(number, o.number);
+    return Internal.equals(unknownFields(), o.unknownFields())
+        && Internal.equals(number, o.number);
   }
 
   @Override
@@ -104,7 +73,7 @@ public String toString() {
     return builder.replace(0, 2, "Phone{").append('}').toString();
   }
 
-  public static final class Builder extends com.squareup.wire.Message.Builder<Phone, Builder> {
+  public static final class Builder extends Message.Builder<Phone, Builder> {
     public String number;
 
     public Builder() {
@@ -120,4 +89,47 @@ public Phone build() {
       return new Phone(number, buildUnknownFields());
     }
   }
+
+  private static final class ProtoAdapter_Phone extends ProtoAdapter<Phone> {
+    ProtoAdapter_Phone() {
+      super(FieldEncoding.LENGTH_DELIMITED, Phone.class);
+    }
+
+    @Override
+    public int encodedSize(Phone value) {
+      return (value.number != null ? ProtoAdapter.STRING.encodedSizeWithTag(1, value.number) : 0)
+          + value.unknownFields().size();
+    }
+
+    @Override
+    public void encode(ProtoWriter writer, Phone value) throws IOException {
+      if (value.number != null) ProtoAdapter.STRING.encodeWithTag(writer, 1, value.number);
+      writer.writeBytes(value.unknownFields());
+    }
+
+    @Override
+    public Phone decode(ProtoReader reader) throws IOException {
+      Builder builder = new Builder();
+      long token = reader.beginMessage();
+      for (int tag; (tag = reader.nextTag()) != -1;) {
+        switch (tag) {
+          case 1: builder.number(ProtoAdapter.STRING.decode(reader)); break;
+          default: {
+            FieldEncoding fieldEncoding = reader.peekFieldEncoding();
+            Object value = fieldEncoding.rawProtoAdapter().decode(reader);
+            builder.addUnknownField(tag, fieldEncoding, value);
+          }
+        }
+      }
+      reader.endMessage(token);
+      return builder.build();
+    }
+
+    @Override
+    public Phone redact(Phone value) {
+      Builder builder = value.newBuilder();
+      builder.clearUnknownFields();
+      return builder.build();
+    }
+  }
 }
diff --git a/retrofit-converters/wire/src/test/java/retrofit2/WireConverterFactoryTest.java b/retrofit-converters/wire/src/test/java/retrofit2/converter/wire/WireConverterFactoryTest.java
similarity index 77%
rename from retrofit-converters/wire/src/test/java/retrofit2/WireConverterFactoryTest.java
rename to retrofit-converters/wire/src/test/java/retrofit2/converter/wire/WireConverterFactoryTest.java
index a1da24435..e972d5287 100644
--- a/retrofit-converters/wire/src/test/java/retrofit2/WireConverterFactoryTest.java
+++ b/retrofit-converters/wire/src/test/java/retrofit2/converter/wire/WireConverterFactoryTest.java
@@ -13,19 +13,22 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.wire;
 
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import com.squareup.okhttp.mockwebserver.RecordedRequest;
 import java.io.EOFException;
 import java.io.IOException;
 import java.util.List;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
 import okio.Buffer;
 import okio.ByteString;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+import retrofit2.Call;
+import retrofit2.Response;
+import retrofit2.Retrofit;
 import retrofit2.http.Body;
 import retrofit2.http.GET;
 import retrofit2.http.POST;
@@ -84,12 +87,14 @@
       service.wrongClass();
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Unable to create converter for class java.lang.String\n"
+      assertThat(e).hasMessage(""
+          + "Unable to create converter for class java.lang.String\n"
           + "    for method Service.wrongClass");
-      assertThat(e.getCause()).hasMessage(
-          "Could not locate ResponseBody converter for class java.lang.String. Tried:\n"
-              + " * retrofit2.BuiltInConverters\n"
-              + " * retrofit2.WireConverterFactory");
+      assertThat(e.getCause()).hasMessage(""
+          + "Could not locate ResponseBody converter for class java.lang.String.\n"
+          + "  Tried:\n"
+          + "   * retrofit2.BuiltInConverters\n"
+          + "   * retrofit2.converter.wire.WireConverterFactory");
     }
   }
 
@@ -101,12 +106,14 @@
       service.wrongType();
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Unable to create converter for java.util.List<java.lang.String>\n"
+      assertThat(e).hasMessage(""
+          + "Unable to create converter for java.util.List<java.lang.String>\n"
           + "    for method Service.wrongType");
-      assertThat(e.getCause()).hasMessage(
-          "Could not locate ResponseBody converter for java.util.List<java.lang.String>. Tried:\n"
-              + " * retrofit2.BuiltInConverters\n"
-              + " * retrofit2.WireConverterFactory");
+      assertThat(e.getCause()).hasMessage(""
+          + "Could not locate ResponseBody converter for java.util.List<java.lang.String>.\n"
+          + "  Tried:\n"
+          + "   * retrofit2.BuiltInConverters\n"
+          + "   * retrofit2.converter.wire.WireConverterFactory");
     }
   }
 
diff --git a/retrofit-mock/README.md b/retrofit-mock/README.md
new file mode 100644
index 000000000..851e9e82d
--- /dev/null
+++ b/retrofit-mock/README.md
@@ -0,0 +1,26 @@
+Mock Web Server
+==============
+
+A mock web server for mocking HTTP responses from a server, and simulating network behaviour.
+
+Download
+--------
+
+Download [the latest JAR][1] or grab via [Maven][2]:
+```xml
+<dependency>
+  <groupId>com.squareup.retrofit2</groupId>
+  <artifactId>retrofit-mock</artifactId>
+  <version>see.latest.version</version>
+</dependency>
+```
+or [Gradle][1]:
+```groovy
+compile 'com.squareup.retrofit2:retrofit-mock:see.latest.version'
+```
+
+Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
+
+ [1]: https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=retrofit-mock&v=LATEST
+ [2]: http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22retrofit-mock%22
+ [snap]: https://oss.sonatype.org/content/repositories/snapshots/
diff --git a/retrofit-mock/pom.xml b/retrofit-mock/pom.xml
index 9a5e881a1..5f978b16b 100644
--- a/retrofit-mock/pom.xml
+++ b/retrofit-mock/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>parent</artifactId>
-    <version>2.0.0-SNAPSHOT</version>
+    <version>2.4.1-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -19,6 +19,11 @@
       <artifactId>retrofit</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
@@ -36,4 +41,20 @@
       <scope>test</scope>
     </dependency>
   </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-jar-plugin</artifactId>
+        <configuration>
+          <archive>
+            <manifestEntries>
+              <Automatic-Module-Name>retrofit2.mock</Automatic-Module-Name>
+            </manifestEntries>
+          </archive>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
 </project>
diff --git a/retrofit-mock/src/main/java/retrofit2/mock/BehaviorCall.java b/retrofit-mock/src/main/java/retrofit2/mock/BehaviorCall.java
index ddc9b35d1..e7c48cf22 100644
--- a/retrofit-mock/src/main/java/retrofit2/mock/BehaviorCall.java
+++ b/retrofit-mock/src/main/java/retrofit2/mock/BehaviorCall.java
@@ -20,6 +20,8 @@
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Future;
 import java.util.concurrent.atomic.AtomicReference;
+import javax.annotation.concurrent.GuardedBy;
+import okhttp3.Request;
 import retrofit2.Call;
 import retrofit2.Callback;
 import retrofit2.Response;
@@ -33,7 +35,8 @@
 
   private volatile Future<?> task;
   volatile boolean canceled;
-  private volatile boolean executed;
+  @GuardedBy("this")
+  private boolean executed;
 
   BehaviorCall(NetworkBehavior behavior, ExecutorService backgroundExecutor, Call<T> delegate) {
     this.behavior = behavior;
@@ -46,7 +49,14 @@
     return new BehaviorCall<>(behavior, backgroundExecutor, delegate.clone());
   }
 
+  @Override public Request request() {
+    return delegate.request();
+  }
+
+  @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
   @Override public void enqueue(final Callback<T> callback) {
+    if (callback == null) throw new NullPointerException("callback == null");
+
     synchronized (this) {
       if (executed) throw new IllegalStateException("Already executed");
       executed = true;
@@ -58,7 +68,7 @@ boolean delaySleep() {
           try {
             Thread.sleep(sleepMs);
           } catch (InterruptedException e) {
-            callback.onFailure(new IOException("canceled"));
+            callback.onFailure(BehaviorCall.this, new IOException("canceled"));
             return false;
           }
         }
@@ -67,22 +77,27 @@ boolean delaySleep() {
 
       @Override public void run() {
         if (canceled) {
-          callback.onFailure(new IOException("canceled"));
+          callback.onFailure(BehaviorCall.this, new IOException("canceled"));
         } else if (behavior.calculateIsFailure()) {
           if (delaySleep()) {
-            callback.onFailure(behavior.failureException());
+            callback.onFailure(BehaviorCall.this, behavior.failureException());
+          }
+        } else if (behavior.calculateIsError()) {
+          if (delaySleep()) {
+            //noinspection unchecked An error response has no body.
+            callback.onResponse(BehaviorCall.this, (Response<T>) behavior.createErrorResponse());
           }
         } else {
           delegate.enqueue(new Callback<T>() {
-            @Override public void onResponse(final Response<T> response) {
+            @Override public void onResponse(Call<T> call, Response<T> response) {
               if (delaySleep()) {
-                callback.onResponse(response);
+                callback.onResponse(call, response);
               }
             }
 
-            @Override public void onFailure(final Throwable t) {
+            @Override public void onFailure(Call<T> call, Throwable t) {
               if (delaySleep()) {
-                callback.onFailure(t);
+                callback.onFailure(call, t);
               }
             }
           });
@@ -100,12 +115,12 @@ boolean delaySleep() {
     final AtomicReference<Throwable> failureRef = new AtomicReference<>();
     final CountDownLatch latch = new CountDownLatch(1);
     enqueue(new Callback<T>() {
-      @Override public void onResponse(Response<T> response) {
+      @Override public void onResponse(Call<T> call, Response<T> response) {
         responseRef.set(response);
         latch.countDown();
       }
 
-      @Override public void onFailure(Throwable t) {
+      @Override public void onFailure(Call<T> call, Throwable t) {
         failureRef.set(t);
         latch.countDown();
       }
diff --git a/retrofit-mock/src/main/java/retrofit2/mock/BehaviorDelegate.java b/retrofit-mock/src/main/java/retrofit2/mock/BehaviorDelegate.java
index 7c9361f65..b525696fb 100644
--- a/retrofit-mock/src/main/java/retrofit2/mock/BehaviorDelegate.java
+++ b/retrofit-mock/src/main/java/retrofit2/mock/BehaviorDelegate.java
@@ -21,6 +21,7 @@
 import java.lang.reflect.Proxy;
 import java.lang.reflect.Type;
 import java.util.concurrent.ExecutorService;
+import javax.annotation.Nullable;
 import retrofit2.Call;
 import retrofit2.CallAdapter;
 import retrofit2.Retrofit;
@@ -46,20 +47,21 @@
     this.service = service;
   }
 
-  public T returningResponse(Object response) {
+  public T returningResponse(@Nullable Object response) {
     return returning(Calls.response(response));
   }
 
   @SuppressWarnings("unchecked") // Single-interface proxy creation guarded by parameter safety.
-  public T returning(Call<?> call) {
-    final Call<?> behaviorCall = new BehaviorCall<>(behavior, executor, call);
+  public <R> T returning(Call<R> call) {
+    final Call<R> behaviorCall = new BehaviorCall<>(behavior, executor, call);
     return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class[] { service },
         new InvocationHandler() {
           @Override
-          public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
+          public T invoke(Object proxy, Method method, Object[] args) throws Throwable {
             Type returnType = method.getGenericReturnType();
             Annotation[] methodAnnotations = method.getAnnotations();
-            CallAdapter<?> callAdapter = retrofit.callAdapter(returnType, methodAnnotations);
+            CallAdapter<R, T> callAdapter =
+                (CallAdapter<R, T>) retrofit.callAdapter(returnType, methodAnnotations);
             return callAdapter.adapt(behaviorCall);
           }
         });
diff --git a/retrofit-mock/src/main/java/retrofit2/mock/Calls.java b/retrofit-mock/src/main/java/retrofit2/mock/Calls.java
index d89fd512a..42947a95f 100644
--- a/retrofit-mock/src/main/java/retrofit2/mock/Calls.java
+++ b/retrofit-mock/src/main/java/retrofit2/mock/Calls.java
@@ -16,73 +16,157 @@
 package retrofit2.mock;
 
 import java.io.IOException;
+import java.util.concurrent.Callable;
+import java.util.concurrent.atomic.AtomicBoolean;
+import javax.annotation.Nullable;
+import okhttp3.Request;
 import retrofit2.Call;
 import retrofit2.Callback;
 import retrofit2.Response;
 
 /** Factory methods for creating {@link Call} instances which immediately respond or fail. */
 public final class Calls {
-  public static <T> Call<T> response(T successValue) {
-    return response(Response.success(successValue));
+  /**
+   * Invokes {@code callable} once for the returned {@link Call} and once for each instance that is
+   * obtained from {@linkplain Call#clone() cloning} the returned {@link Call}.
+   */
+  public static <T> Call<T> defer(Callable<Call<T>> callable) {
+    return new DeferredCall<>(callable);
   }
 
-  public static <T> Call<T> response(final Response<T> response) {
-    return new Call<T>() {
-      @Override public Response<T> execute() throws IOException {
-        return response;
-      }
+  public static <T> Call<T> response(@Nullable T successValue) {
+    return new FakeCall<>(Response.success(successValue), null);
+  }
 
-      @Override public void enqueue(Callback<T> callback) {
-        callback.onResponse(response);
-      }
+  public static <T> Call<T> response(Response<T> response) {
+    return new FakeCall<>(response, null);
+  }
+
+  public static <T> Call<T> failure(IOException failure) {
+    return new FakeCall<>(null, failure);
+  }
+
+  private Calls() {
+    throw new AssertionError("No instances.");
+  }
+
+  static final class FakeCall<T> implements Call<T> {
+    private final Response<T> response;
+    private final IOException error;
+    private final AtomicBoolean canceled = new AtomicBoolean();
+    private final AtomicBoolean executed = new AtomicBoolean();
 
-      @Override public boolean isExecuted() {
-        return false;
+    FakeCall(@Nullable Response<T> response, @Nullable IOException error) {
+      if ((response == null) == (error == null)) {
+        throw new AssertionError("Only one of response or error can be set.");
       }
+      this.response = response;
+      this.error = error;
+    }
 
-      @Override public void cancel() {
+    @Override public Response<T> execute() throws IOException {
+      if (!executed.compareAndSet(false, true)) {
+        throw new IllegalStateException("Already executed");
       }
+      if (canceled.get()) {
+        throw new IOException("canceled");
+      }
+      if (response != null) {
+        return response;
+      }
+      throw error;
+    }
 
-      @Override public boolean isCanceled() {
-        return false;
+    @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
+    @Override public void enqueue(Callback<T> callback) {
+      if (callback == null) {
+        throw new NullPointerException("callback == null");
+      }
+      if (!executed.compareAndSet(false, true)) {
+        throw new IllegalStateException("Already executed");
       }
+      if (canceled.get()) {
+        callback.onFailure(this, new IOException("canceled"));
+      } else if (response != null) {
+        callback.onResponse(this, response);
+      } else {
+        callback.onFailure(this, error);
+      }
+    }
+
+    @Override public boolean isExecuted() {
+      return executed.get();
+    }
+
+    @Override public void cancel() {
+      canceled.set(true);
+    }
+
+    @Override public boolean isCanceled() {
+      return canceled.get();
+    }
 
-      @SuppressWarnings("CloneDoesntCallSuperClone") // Immutable object.
-      @Override public Call<T> clone() {
-        return this;
+    @Override public Call<T> clone() {
+      return new FakeCall<>(response, error);
+    }
+
+    @Override public Request request() {
+      if (response != null) {
+        return response.raw().request();
       }
-    };
+      return new Request.Builder().url("http://localhost").build();
+    }
   }
 
-  public static <T> Call<T> failure(final IOException failure) {
-    return new Call<T>() {
-      @Override public Response<T> execute() throws IOException {
-        throw failure;
-      }
+  static final class DeferredCall<T> implements Call<T> {
+    private final Callable<Call<T>> callable;
+    private Call<T> delegate;
 
-      @Override public void enqueue(Callback<T> callback) {
-        callback.onFailure(failure);
-      }
+    DeferredCall(Callable<Call<T>> callable) {
+      this.callable = callable;
+    }
 
-      @Override public boolean isExecuted() {
-        return false;
+    private synchronized Call<T> getDelegate() {
+      Call<T> delegate = this.delegate;
+      if (delegate == null) {
+        try {
+          delegate = callable.call();
+        } catch (IOException e) {
+          delegate = failure(e);
+        } catch (Exception e) {
+          throw new IllegalStateException("Callable threw unrecoverable exception", e);
+        }
+        this.delegate = delegate;
       }
+      return delegate;
+    }
 
-      @Override public void cancel() {
-      }
+    @Override public Response<T> execute() throws IOException {
+      return getDelegate().execute();
+    }
 
-      @Override public boolean isCanceled() {
-        return false;
-      }
+    @Override public void enqueue(Callback<T> callback) {
+      getDelegate().enqueue(callback);
+    }
 
-      @SuppressWarnings("CloneDoesntCallSuperClone") // Immutable object.
-      @Override public Call<T> clone() {
-        return this;
-      }
-    };
-  }
+    @Override public boolean isExecuted() {
+      return getDelegate().isExecuted();
+    }
 
-  private Calls() {
-    throw new AssertionError("No instances.");
+    @Override public void cancel() {
+      getDelegate().cancel();
+    }
+
+    @Override public boolean isCanceled() {
+      return getDelegate().isCanceled();
+    }
+
+    @Override public Call<T> clone() {
+      return new DeferredCall<>(callable);
+    }
+
+    @Override public Request request() {
+      return getDelegate().request();
+    }
   }
 }
diff --git a/retrofit-mock/src/main/java/retrofit2/mock/MockRetrofit.java b/retrofit-mock/src/main/java/retrofit2/mock/MockRetrofit.java
index 3c75b47a2..40185baaa 100644
--- a/retrofit-mock/src/main/java/retrofit2/mock/MockRetrofit.java
+++ b/retrofit-mock/src/main/java/retrofit2/mock/MockRetrofit.java
@@ -53,17 +53,20 @@ public Executor backgroundExecutor() {
     private NetworkBehavior behavior;
     private ExecutorService executor;
 
+    @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
     public Builder(Retrofit retrofit) {
       if (retrofit == null) throw new NullPointerException("retrofit == null");
       this.retrofit = retrofit;
     }
 
+    @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
     public Builder networkBehavior(NetworkBehavior behavior) {
       if (behavior == null) throw new NullPointerException("behavior == null");
       this.behavior = behavior;
       return this;
     }
 
+    @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
     public Builder backgroundExecutor(ExecutorService executor) {
       if (executor == null) throw new NullPointerException("executor == null");
       this.executor = executor;
diff --git a/retrofit-mock/src/main/java/retrofit2/mock/MockRetrofitIOException.java b/retrofit-mock/src/main/java/retrofit2/mock/MockRetrofitIOException.java
new file mode 100644
index 000000000..d4cdfc2c0
--- /dev/null
+++ b/retrofit-mock/src/main/java/retrofit2/mock/MockRetrofitIOException.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.mock;
+
+import java.io.IOException;
+
+final class MockRetrofitIOException extends IOException {
+  MockRetrofitIOException() {
+    super("Failure triggered by MockRetrofit's NetworkBehavior");
+  }
+}
diff --git a/retrofit-mock/src/main/java/retrofit2/mock/NetworkBehavior.java b/retrofit-mock/src/main/java/retrofit2/mock/NetworkBehavior.java
index d182862cb..263808dd4 100644
--- a/retrofit-mock/src/main/java/retrofit2/mock/NetworkBehavior.java
+++ b/retrofit-mock/src/main/java/retrofit2/mock/NetworkBehavior.java
@@ -17,7 +17,10 @@
 
 import java.io.IOException;
 import java.util.Random;
+import java.util.concurrent.Callable;
 import java.util.concurrent.TimeUnit;
+import okhttp3.ResponseBody;
+import retrofit2.Response;
 
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 
@@ -33,22 +36,14 @@
  * Behavior can be applied to a Retrofit interface with {@link MockRetrofit}. Behavior can also
  * be applied elsewhere using {@link #calculateDelay(TimeUnit)} and {@link #calculateIsFailure()}.
  * <p>
- * By default, instances of this class will use a 2 second delay with 40% variance and failures
- * will occur 3% of the time.
+ * By default, instances of this class will use a 2 second delay with 40% variance. Failures
+ * will occur 3% of the time. HTTP errors will occur 0% of the time.
  */
 public final class NetworkBehavior {
   private static final int DEFAULT_DELAY_MS = 2000; // Network calls will take 2 seconds.
   private static final int DEFAULT_VARIANCE_PERCENT = 40; // Network delay varies by ±40%.
   private static final int DEFAULT_FAILURE_PERCENT = 3; // 3% of network calls will fail.
-
-  /** Applies {@link NetworkBehavior} to instances of {@code T}. */
-  public interface Adapter<T> {
-    /**
-     * Apply {@code behavior} to {@code value} so that it exhibits the configured network behavior
-     * traits when interacted with.
-     */
-    T applyBehavior(NetworkBehavior behavior, T value);
-  }
+  private static final int DEFAULT_ERROR_PERCENT = 0; // 0% of network calls will return errors.
 
   /** Create an instance with default behavior. */
   public static NetworkBehavior create() {
@@ -59,6 +54,7 @@ public static NetworkBehavior create() {
    * Create an instance with default behavior which uses {@code random} to control variance and
    * failure calculation.
    */
+  @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
   public static NetworkBehavior create(Random random) {
     if (random == null) throw new NullPointerException("random == null");
     return new NetworkBehavior(random);
@@ -69,10 +65,19 @@ public static NetworkBehavior create(Random random) {
   private volatile long delayMs = DEFAULT_DELAY_MS;
   private volatile int variancePercent = DEFAULT_VARIANCE_PERCENT;
   private volatile int failurePercent = DEFAULT_FAILURE_PERCENT;
-  private volatile Throwable failureException = new IOException("Mock failure!");
+  private volatile Throwable failureException;
+  private volatile int errorPercent = DEFAULT_ERROR_PERCENT;
+  private volatile Callable<Response<?>> errorFactory = new Callable<Response<?>>() {
+    @Override public Response<?> call() {
+      return Response.error(500, ResponseBody.create(null, new byte[0]));
+    }
+  };
 
   private NetworkBehavior(Random random) {
     this.random = random;
+
+    failureException = new MockRetrofitIOException();
+    failureException.setStackTrace(new StackTraceElement[0]);
   }
 
   /** Set the network round trip delay. */
@@ -90,9 +95,7 @@ public long delay(TimeUnit unit) {
 
   /** Set the plus-or-minus variance percentage of the network round trip delay. */
   public void setVariancePercent(int variancePercent) {
-    if (variancePercent < 0 || variancePercent > 100) {
-      throw new IllegalArgumentException("Variance percentage must be between 0 and 100.");
-    }
+    checkPercentageValidity(variancePercent, "Variance percentage must be between 0 and 100.");
     this.variancePercent = variancePercent;
   }
 
@@ -103,9 +106,7 @@ public int variancePercent() {
 
   /** Set the percentage of calls to {@link #calculateIsFailure()} that return {@code true}. */
   public void setFailurePercent(int failurePercent) {
-    if (failurePercent < 0 || failurePercent > 100) {
-      throw new IllegalArgumentException("Failure percentage must be between 0 and 100.");
-    }
+    checkPercentageValidity(failurePercent, "Failure percentage must be between 0 and 100.");
     this.failurePercent = failurePercent;
   }
 
@@ -114,12 +115,18 @@ public int failurePercent() {
     return failurePercent;
   }
 
-  /** Set the exception to be used when a failure is triggered. */
-  public void setFailureException(Throwable t) {
-    if (t == null) {
-      throw new NullPointerException("t == null");
+  /**
+   * Set the exception to be used when a failure is triggered.
+   * <p>
+   * It is a best practice to remove the stack trace from {@code exception} since it can
+   * misleadingly point to code unrelated to this class.
+   */
+  @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
+  public void setFailureException(Throwable exception) {
+    if (exception == null) {
+      throw new NullPointerException("exception == null");
     }
-    this.failureException = t;
+    this.failureException = exception;
   }
 
   /** The exception to be used when a failure is triggered. */
@@ -127,13 +134,60 @@ public Throwable failureException() {
     return failureException;
   }
 
+  /** The percentage of calls to {@link #calculateIsError()} that return {@code true}. */
+  public int errorPercent() {
+    return errorPercent;
+  }
+
+  /** Set the percentage of calls to {@link #calculateIsError()} that return {@code true}. */
+  public void setErrorPercent(int errorPercent) {
+    checkPercentageValidity(errorPercent, "Error percentage must be between 0 and 100.");
+    this.errorPercent = errorPercent;
+  }
+
+  /**
+   * Set the error response factory to be used when an error is triggered. This factory may only
+   * return responses for which {@link Response#isSuccessful()} returns false.
+   */
+  @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
+  public void setErrorFactory(Callable<Response<?>> errorFactory) {
+    if (errorFactory == null) {
+      throw new NullPointerException("errorFactory == null");
+    }
+    this.errorFactory = errorFactory;
+  }
+
+  /** The HTTP error to be used when an error is triggered. */
+  public Response<?> createErrorResponse() {
+    Response<?> call;
+    try {
+      call = errorFactory.call();
+    } catch (Exception e) {
+      throw new IllegalStateException("Error factory threw an exception.", e);
+    }
+    if (call == null) {
+      throw new IllegalStateException("Error factory returned null.");
+    }
+    if (call.isSuccessful()) {
+      throw new IllegalStateException("Error factory returned successful response.");
+    }
+    return call;
+  }
+
   /**
    * Randomly determine whether this call should result in a network failure in accordance with
    * configured behavior. When true, {@link #failureException()} should be thrown.
    */
   public boolean calculateIsFailure() {
-    int randomValue = random.nextInt(100);
-    return randomValue < failurePercent;
+    return random.nextInt(100) < failurePercent;
+  }
+
+  /**
+   * Randomly determine whether this call should result in an HTTP error in accordance with
+   * configured behavior. When true, {@link #createErrorResponse()} should be returned.
+   */
+  public boolean calculateIsError() {
+    return random.nextInt(100) < errorPercent;
   }
 
   /**
@@ -149,4 +203,10 @@ public long calculateDelay(TimeUnit unit) {
     long callDelayMs = (long) (delayMs * delayPercent);
     return MILLISECONDS.convert(callDelayMs, unit);
   }
+
+  private static void checkPercentageValidity(int percentage, String message) {
+    if (percentage < 0 || percentage > 100) {
+      throw new IllegalArgumentException(message);
+    }
+  }
 }
diff --git a/retrofit-mock/src/main/java/retrofit2/mock/package-info.java b/retrofit-mock/src/main/java/retrofit2/mock/package-info.java
new file mode 100644
index 000000000..cb99df00c
--- /dev/null
+++ b/retrofit-mock/src/main/java/retrofit2/mock/package-info.java
@@ -0,0 +1,4 @@
+@ParametersAreNonnullByDefault
+package retrofit2.mock;
+
+import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-mock/src/test/java/retrofit2/mock/BehaviorDelegateTest.java b/retrofit-mock/src/test/java/retrofit2/mock/BehaviorDelegateTest.java
index 40d38f156..7199da059 100644
--- a/retrofit-mock/src/test/java/retrofit2/mock/BehaviorDelegateTest.java
+++ b/retrofit-mock/src/test/java/retrofit2/mock/BehaviorDelegateTest.java
@@ -97,11 +97,11 @@
     final AtomicReference<Throwable> failureRef = new AtomicReference<>();
     final CountDownLatch latch = new CountDownLatch(1);
     call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Response<String> response) {
+      @Override public void onResponse(Call<String> call, Response<String> response) {
         throw new AssertionError();
       }
 
-      @Override public void onFailure(Throwable t) {
+      @Override public void onFailure(Call<String> call, Throwable t) {
         tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
         failureRef.set(t);
         latch.countDown();
@@ -140,13 +140,13 @@
     final AtomicReference<String> actual = new AtomicReference<>();
     final CountDownLatch latch = new CountDownLatch(1);
     call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Response<String> response) {
+      @Override public void onResponse(Call<String> call, Response<String> response) {
         tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
         actual.set(response.body());
         latch.countDown();
       }
 
-      @Override public void onFailure(Throwable t) {
+      @Override public void onFailure(Call<String> call, Throwable t) {
         throw new AssertionError();
       }
     });
@@ -186,11 +186,11 @@
     final CountDownLatch latch = new CountDownLatch(1);
     final long startNanos = System.nanoTime();
     call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Response<String> response) {
+      @Override public void onResponse(Call<String> call, Response<String> response) {
         throw new AssertionError();
       }
 
-      @Override public void onFailure(Throwable t) {
+      @Override public void onFailure(Call<String> call, Throwable t) {
         tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
         failureRef.set(t);
         latch.countDown();
@@ -237,11 +237,11 @@
     final AtomicReference<Throwable> failureRef = new AtomicReference<>();
     final CountDownLatch latch = new CountDownLatch(1);
     call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Response<String> response) {
+      @Override public void onResponse(Call<String> call, Response<String> response) {
         latch.countDown();
       }
 
-      @Override public void onFailure(Throwable t) {
+      @Override public void onFailure(Call<String> call, Throwable t) {
         failureRef.set(t);
         latch.countDown();
       }
@@ -282,11 +282,11 @@
     final AtomicReference<Throwable> failureRef = new AtomicReference<>();
     final CountDownLatch latch = new CountDownLatch(1);
     call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Response<String> response) {
+      @Override public void onResponse(Call<String> call, Response<String> response) {
         latch.countDown();
       }
 
-      @Override public void onFailure(Throwable t) {
+      @Override public void onFailure(Call<String> call, Throwable t) {
         failureRef.set(t);
         latch.countDown();
       }
diff --git a/retrofit-mock/src/test/java/retrofit2/mock/CallsTest.java b/retrofit-mock/src/test/java/retrofit2/mock/CallsTest.java
new file mode 100644
index 000000000..f32f4c4ee
--- /dev/null
+++ b/retrofit-mock/src/test/java/retrofit2/mock/CallsTest.java
@@ -0,0 +1,263 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.mock;
+
+import java.io.IOException;
+import java.util.concurrent.Callable;
+import java.util.concurrent.atomic.AtomicReference;
+import org.junit.Test;
+import retrofit2.Call;
+import retrofit2.Callback;
+import retrofit2.Response;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class CallsTest {
+  @Test public void bodyExecute() throws IOException {
+    Call<String> taco = Calls.response("Taco");
+    assertEquals("Taco", taco.execute().body());
+  }
+
+  @Test public void bodyEnqueue() throws IOException {
+    Call<String> taco = Calls.response("Taco");
+    final AtomicReference<Response<String>> responseRef = new AtomicReference<>();
+    taco.enqueue(new Callback<String>() {
+      @Override public void onResponse(Call<String> call, Response<String> response) {
+        responseRef.set(response);
+      }
+
+      @Override public void onFailure(Call<String> call, Throwable t) {
+        fail();
+      }
+    });
+    assertThat(responseRef.get().body()).isEqualTo("Taco");
+  }
+
+  @Test public void responseExecute() throws IOException {
+    Response<String> response = Response.success("Taco");
+    Call<String> taco = Calls.response(response);
+    assertFalse(taco.isExecuted());
+    assertSame(response, taco.execute());
+    assertTrue(taco.isExecuted());
+    try {
+      taco.execute();
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage("Already executed");
+    }
+  }
+
+  @Test public void responseEnqueue() {
+    Response<String> response = Response.success("Taco");
+    Call<String> taco = Calls.response(response);
+    assertFalse(taco.isExecuted());
+
+    final AtomicReference<Response<String>> responseRef = new AtomicReference<>();
+    taco.enqueue(new Callback<String>() {
+      @Override public void onResponse(Call<String> call, Response<String> response) {
+        responseRef.set(response);
+      }
+
+      @Override public void onFailure(Call<String> call, Throwable t) {
+        fail();
+      }
+    });
+    assertSame(response, responseRef.get());
+    assertTrue(taco.isExecuted());
+
+    try {
+      taco.enqueue(new Callback<String>() {
+        @Override public void onResponse(Call<String> call, Response<String> response) {
+          fail();
+        }
+
+        @Override public void onFailure(Call<String> call, Throwable t) {
+          fail();
+        }
+      });
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage("Already executed");
+    }
+  }
+
+  @Test public void enqueueNullThrows() {
+    Call<String> taco = Calls.response("Taco");
+    try {
+      taco.enqueue(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("callback == null");
+    }
+  }
+
+  @Test public void responseCancelExecute() {
+    Call<String> taco = Calls.response(Response.success("Taco"));
+    assertFalse(taco.isCanceled());
+    taco.cancel();
+    assertTrue(taco.isCanceled());
+
+    try {
+      taco.execute();
+      fail();
+    } catch (IOException e) {
+      assertThat(e).hasMessage("canceled");
+    }
+  }
+
+  @Test public void responseCancelEnqueue() throws IOException {
+    Call<String> taco = Calls.response(Response.success("Taco"));
+    assertFalse(taco.isCanceled());
+    taco.cancel();
+    assertTrue(taco.isCanceled());
+
+    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+    taco.enqueue(new Callback<String>() {
+      @Override public void onResponse(Call<String> call, Response<String> response) {
+        fail();
+      }
+
+      @Override public void onFailure(Call<String> call, Throwable t) {
+        failureRef.set(t);
+      }
+    });
+    assertThat(failureRef.get()).isInstanceOf(IOException.class).hasMessage("canceled");
+  }
+
+  @Test public void failureExecute() {
+    IOException failure = new IOException("Hey");
+    Call<Object> taco = Calls.failure(failure);
+    assertFalse(taco.isExecuted());
+    try {
+      taco.execute();
+      fail();
+    } catch (IOException e) {
+      assertSame(failure, e);
+    }
+    assertTrue(taco.isExecuted());
+  }
+
+  @Test public void failureEnqueue() {
+    IOException failure = new IOException("Hey");
+    Call<Object> taco = Calls.failure(failure);
+    assertFalse(taco.isExecuted());
+
+    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+    taco.enqueue(new Callback<Object>() {
+      @Override public void onResponse(Call<Object> call, Response<Object> response) {
+        fail();
+      }
+
+      @Override public void onFailure(Call<Object> call, Throwable t) {
+        failureRef.set(t);
+      }
+    });
+    assertSame(failure, failureRef.get());
+    assertTrue(taco.isExecuted());
+  }
+
+  @Test public void cloneHasOwnState() throws IOException {
+    Call<String> taco = Calls.response("Taco");
+    assertEquals("Taco", taco.execute().body());
+    Call<String> anotherTaco = taco.clone();
+    assertFalse(anotherTaco.isExecuted());
+    assertEquals("Taco", anotherTaco.execute().body());
+    assertTrue(anotherTaco.isExecuted());
+  }
+
+  @Test public void deferredReturnExecute() throws IOException {
+    Call<Integer> counts = Calls.defer(new Callable<Call<Integer>>() {
+      private int count = 0;
+
+      @Override public Call<Integer> call() throws Exception {
+        return Calls.response(++count);
+      }
+    });
+    Call<Integer> a = counts.clone();
+    Call<Integer> b = counts.clone();
+
+    assertEquals(1, b.execute().body().intValue());
+    assertEquals(2, a.execute().body().intValue());
+  }
+
+  @Test public void deferredReturnEnqueue() {
+    Call<Integer> counts = Calls.defer(new Callable<Call<Integer>>() {
+      private int count = 0;
+
+      @Override public Call<Integer> call() throws Exception {
+        return Calls.response(++count);
+      }
+    });
+    Call<Integer> a = counts.clone();
+    Call<Integer> b = counts.clone();
+
+    final AtomicReference<Response<Integer>> responseRef = new AtomicReference<>();
+    Callback<Integer> callback = new Callback<Integer>() {
+      @Override public void onResponse(Call<Integer> call, Response<Integer> response) {
+        responseRef.set(response);
+      }
+
+      @Override public void onFailure(Call<Integer> call, Throwable t) {
+        fail();
+      }
+    };
+    b.enqueue(callback);
+    assertEquals(1, responseRef.get().body().intValue());
+
+    a.enqueue(callback);
+    assertEquals(2, responseRef.get().body().intValue());
+  }
+
+  @Test public void deferredThrowExecute() throws IOException {
+    final IOException failure = new IOException("Hey");
+    Call<Object> failing = Calls.defer(new Callable<Call<Object>>() {
+      @Override public Call<Object> call() throws Exception {
+        throw failure;
+      }
+    });
+    try {
+      failing.execute();
+      fail();
+    } catch (IOException e) {
+      assertSame(failure, e);
+    }
+  }
+
+  @Test public void deferredThrowEnqueue() {
+    final IOException failure = new IOException("Hey");
+    Call<Object> failing = Calls.defer(new Callable<Call<Object>>() {
+      @Override public Call<Object> call() throws Exception {
+        throw failure;
+      }
+    });
+    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+    failing.enqueue(new Callback<Object>() {
+      @Override public void onResponse(Call<Object> call, Response<Object> response) {
+        fail();
+      }
+
+      @Override public void onFailure(Call<Object> call, Throwable t) {
+        failureRef.set(t);
+      }
+    });
+    assertSame(failure, failureRef.get());
+  }
+}
diff --git a/retrofit-mock/src/test/java/retrofit2/mock/NetworkBehaviorTest.java b/retrofit-mock/src/test/java/retrofit2/mock/NetworkBehaviorTest.java
index 7ccccc0df..73de57911 100644
--- a/retrofit-mock/src/test/java/retrofit2/mock/NetworkBehaviorTest.java
+++ b/retrofit-mock/src/test/java/retrofit2/mock/NetworkBehaviorTest.java
@@ -15,17 +15,29 @@
  */
 package retrofit2.mock;
 
+import java.io.IOException;
 import java.util.Random;
+import java.util.concurrent.Callable;
+import okhttp3.ResponseBody;
 import org.junit.Test;
+import retrofit2.Response;
 
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static java.util.concurrent.TimeUnit.SECONDS;
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 
 public final class NetworkBehaviorTest {
   private final NetworkBehavior behavior = NetworkBehavior.create(new Random(2847));
 
+  @Test public void defaultThrowable() {
+    Throwable t = behavior.failureException();
+    assertThat(t).isInstanceOf(IOException.class)
+        .isExactlyInstanceOf(MockRetrofitIOException.class);
+    assertThat(t.getStackTrace()).isEmpty();
+  }
+
   @Test public void delayMustBePositive() {
     try {
       behavior.setDelay(-1, SECONDS);
@@ -65,6 +77,97 @@
     }
   }
 
+  @Test public void failureExceptionIsNotNull() {
+    try {
+      behavior.setFailureException(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("exception == null");
+    }
+  }
+
+  @Test public void errorRestrictsRange() {
+    try {
+      behavior.setErrorPercent(-13);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Error percentage must be between 0 and 100.");
+    }
+    try {
+      behavior.setErrorPercent(174);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Error percentage must be between 0 and 100.");
+    }
+  }
+
+  @Test public void errorFactoryIsNotNull() {
+    try {
+      behavior.setErrorFactory(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("errorFactory == null");
+    }
+  }
+
+  @Test public void errorFactoryCannotReturnNull() {
+    behavior.setErrorFactory(new Callable<Response<?>>() {
+      @Override public Response<?> call() throws Exception {
+        return null;
+      }
+    });
+    try {
+      behavior.createErrorResponse();
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage("Error factory returned null.");
+    }
+  }
+
+  @Test public void errorFactoryCannotThrow() {
+    final RuntimeException broken = new RuntimeException("Broken");
+    behavior.setErrorFactory(new Callable<Response<?>>() {
+      @Override public Response<?> call() throws Exception {
+        throw broken;
+      }
+    });
+    try {
+      behavior.createErrorResponse();
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage("Error factory threw an exception.");
+      assertThat(e.getCause()).isSameAs(broken);
+    }
+  }
+
+  @Test public void errorFactoryCannotReturnSuccess() {
+    behavior.setErrorFactory(new Callable<Response<?>>() {
+      @Override public Response<?> call() throws Exception {
+        return Response.success("Taco");
+      }
+    });
+    try {
+      behavior.createErrorResponse();
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage("Error factory returned successful response.");
+    }
+  }
+
+  @Test public void errorFactoryCalledEachTime() {
+    behavior.setErrorFactory(new Callable<Response<?>>() {
+      private int code = 500;
+
+      @Override public Response<?> call() throws Exception {
+        return Response.error(code++, ResponseBody.create(null, new byte[0]));
+      }
+    });
+
+    assertEquals(500, behavior.createErrorResponse().code());
+    assertEquals(501, behavior.createErrorResponse().code());
+    assertEquals(502, behavior.createErrorResponse().code());
+  }
+
   @Test public void failurePercentageIsAccurate() {
     behavior.setFailurePercent(0);
     for (int i = 0; i < 10000; i++) {
@@ -81,6 +184,22 @@
     assertThat(failures).isEqualTo(2964); // ~3% of 100k
   }
 
+  @Test public void errorPercentageIsAccurate() {
+    behavior.setErrorPercent(0);
+    for (int i = 0; i < 10000; i++) {
+      assertThat(behavior.calculateIsError()).isFalse();
+    }
+
+    behavior.setErrorPercent(3);
+    int errors = 0;
+    for (int i = 0; i < 100000; i++) {
+      if (behavior.calculateIsError()) {
+        errors += 1;
+      }
+    }
+    assertThat(errors).isEqualTo(2964); // ~3% of 100k
+  }
+
   @Test public void delayVarianceIsAccurate() {
     behavior.setDelay(2, SECONDS);
 
diff --git a/retrofit/pom.xml b/retrofit/pom.xml
index 2aab54992..e665b66e2 100644
--- a/retrofit/pom.xml
+++ b/retrofit/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>parent</artifactId>
-    <version>2.0.0-SNAPSHOT</version>
+    <version>2.4.1-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -15,7 +15,7 @@
 
   <dependencies>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>com.squareup.okhttp3</groupId>
       <artifactId>okhttp</artifactId>
     </dependency>
 
@@ -30,6 +30,11 @@
       <artifactId>animal-sniffer-annotations</artifactId>
       <optional>true</optional>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
@@ -52,9 +57,30 @@
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>com.squareup.okhttp3</groupId>
       <artifactId>mockwebserver</artifactId>
       <scope>test</scope>
     </dependency>
+    <dependency>
+      <groupId>org.robolectric</groupId>
+      <artifactId>robolectric</artifactId>
+      <scope>test</scope>
+    </dependency>
   </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-jar-plugin</artifactId>
+        <configuration>
+          <archive>
+            <manifestEntries>
+              <Automatic-Module-Name>retrofit2</Automatic-Module-Name>
+            </manifestEntries>
+          </archive>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
 </project>
diff --git a/retrofit/src/main/java/retrofit2/BaseUrl.java b/retrofit/src/main/java/retrofit2/BaseUrl.java
deleted file mode 100644
index 2c7fda391..000000000
--- a/retrofit/src/main/java/retrofit2/BaseUrl.java
+++ /dev/null
@@ -1,14 +0,0 @@
-package retrofit2;
-
-import com.squareup.okhttp.HttpUrl;
-
-/** The base URL of the remote service. */
-public interface BaseUrl {
-  /**
-   * The base URL.
-   * <p>
-   * Consumers will call this method every time they need to create a request allowing values
-   * to change over time.
-   */
-  HttpUrl url();
-}
diff --git a/retrofit/src/main/java/retrofit2/BuiltInConverters.java b/retrofit/src/main/java/retrofit2/BuiltInConverters.java
index 52ff5f0ba..86228d5c3 100644
--- a/retrofit/src/main/java/retrofit2/BuiltInConverters.java
+++ b/retrofit/src/main/java/retrofit2/BuiltInConverters.java
@@ -15,11 +15,11 @@
  */
 package retrofit2;
 
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
 import retrofit2.http.Streaming;
 
 final class BuiltInConverters extends Converter.Factory {
@@ -27,10 +27,9 @@
   public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
       Retrofit retrofit) {
     if (type == ResponseBody.class) {
-      if (Utils.isAnnotationPresent(annotations, Streaming.class)) {
-        return StreamingResponseBodyConverter.INSTANCE;
-      }
-      return BufferingResponseBodyConverter.INSTANCE;
+      return Utils.isAnnotationPresent(annotations, Streaming.class)
+          ? StreamingResponseBodyConverter.INSTANCE
+          : BufferingResponseBodyConverter.INSTANCE;
     }
     if (type == Void.class) {
       return VoidResponseBodyConverter.INSTANCE;
@@ -39,33 +38,18 @@
   }
 
   @Override
-  public Converter<?, RequestBody> requestBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
+  public Converter<?, RequestBody> requestBodyConverter(Type type,
+      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     if (RequestBody.class.isAssignableFrom(Utils.getRawType(type))) {
       return RequestBodyConverter.INSTANCE;
     }
     return null;
   }
 
-  @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations) {
-    if (type == String.class) {
-      return StringConverter.INSTANCE;
-    }
-    return null;
-  }
-
-  static final class StringConverter implements Converter<String, String> {
-    static final StringConverter INSTANCE = new StringConverter();
-
-    @Override public String convert(String value) throws IOException {
-      return value;
-    }
-  }
-
   static final class VoidResponseBodyConverter implements Converter<ResponseBody, Void> {
     static final VoidResponseBodyConverter INSTANCE = new VoidResponseBodyConverter();
 
-    @Override public Void convert(ResponseBody value) throws IOException {
+    @Override public Void convert(ResponseBody value) {
       value.close();
       return null;
     }
@@ -74,7 +58,7 @@
   static final class RequestBodyConverter implements Converter<RequestBody, RequestBody> {
     static final RequestBodyConverter INSTANCE = new RequestBodyConverter();
 
-    @Override public RequestBody convert(RequestBody value) throws IOException {
+    @Override public RequestBody convert(RequestBody value) {
       return value;
     }
   }
@@ -83,7 +67,7 @@
       implements Converter<ResponseBody, ResponseBody> {
     static final StreamingResponseBodyConverter INSTANCE = new StreamingResponseBodyConverter();
 
-    @Override public ResponseBody convert(ResponseBody value) throws IOException {
+    @Override public ResponseBody convert(ResponseBody value) {
       return value;
     }
   }
@@ -95,9 +79,9 @@
     @Override public ResponseBody convert(ResponseBody value) throws IOException {
       try {
         // Buffer the entire body to avoid future I/O.
-        return Utils.readBodyToBytesIfNecessary(value);
+        return Utils.buffer(value);
       } finally {
-        Utils.closeQuietly(value);
+        value.close();
       }
     }
   }
diff --git a/retrofit/src/main/java/retrofit2/Call.java b/retrofit/src/main/java/retrofit2/Call.java
index ca57759fd..171d9e0c4 100644
--- a/retrofit/src/main/java/retrofit2/Call.java
+++ b/retrofit/src/main/java/retrofit2/Call.java
@@ -15,8 +15,8 @@
  */
 package retrofit2;
 
-import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
+import okhttp3.Request;
 
 /**
  * An invocation of a Retrofit method that sends a request to a webserver and returns a response.
@@ -68,12 +68,6 @@
    */
   Call<T> clone();
 
-  /** Creates {@link Call} instances. */
-  interface Factory {
-    /**
-     * Returns a {@link Call} which will send {@code request} when executed or enqueue and use
-     * {@code converter} to parse the response. May not return null.
-     */
-    <T> Call<T> create(DeferredRequest request, Converter<ResponseBody, T> converter);
-  }
+  /** The original HTTP request. */
+  Request request();
 }
diff --git a/retrofit/src/main/java/retrofit2/CallAdapter.java b/retrofit/src/main/java/retrofit2/CallAdapter.java
index 7c289f5f4..97d34585d 100644
--- a/retrofit/src/main/java/retrofit2/CallAdapter.java
+++ b/retrofit/src/main/java/retrofit2/CallAdapter.java
@@ -16,14 +16,17 @@
 package retrofit2;
 
 import java.lang.annotation.Annotation;
+import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
+import javax.annotation.Nullable;
 
 /**
- * Adapts a {@link Call} into the type of {@code T}. Instances are created by {@linkplain Factory a
- * factory} which is {@linkplain Retrofit.Builder#addCallAdapterFactory(Factory) installed} into
- * the {@link Retrofit} instance.
+ * Adapts a {@link Call} with response type {@code R} into the type of {@code T}. Instances are
+ * created by {@linkplain Factory a factory} which is
+ * {@linkplain Retrofit.Builder#addCallAdapterFactory(Factory) installed} into the {@link Retrofit}
+ * instance.
  */
-public interface CallAdapter<T> {
+public interface CallAdapter<R, T> {
   /**
    * Returns the value type that this adapter uses when converting the HTTP response body to a Java
    * object. For example, the response type for {@code Call<Repo>} is {@code Repo}. This type
@@ -39,29 +42,46 @@
    * <p>
    * For example, given an instance for a hypothetical utility, {@code Async}, this instance would
    * return a new {@code Async<R>} which invoked {@code call} when run.
-   * <pre>{@code
+   * <pre><code>
    * &#64;Override
-   * public <R> Async<R> adapt(final Call<R> call) {
-   *   return Async.create(new Callable<Response<R>>() {
+   * public &lt;R&gt; Async&lt;R&gt; adapt(final Call&lt;R&gt; call) {
+   *   return Async.create(new Callable&lt;Response&lt;R&gt;&gt;() {
    *     &#64;Override
-   *     public Response<R> call() throws Exception {
+   *     public Response&lt;R&gt; call() throws Exception {
    *       return call.execute();
    *     }
    *   });
    * }
-   * }</pre>
+   * </code></pre>
    */
-  <R> T adapt(Call<R> call);
+  T adapt(Call<R> call);
 
   /**
    * Creates {@link CallAdapter} instances based on the return type of {@linkplain
    * Retrofit#create(Class) the service interface} methods.
    */
-  interface Factory {
+  abstract class Factory {
     /**
      * Returns a call adapter for interface methods that return {@code returnType}, or null if it
      * cannot be handled by this factory.
      */
-    CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit);
+    public abstract @Nullable CallAdapter<?, ?> get(Type returnType, Annotation[] annotations,
+        Retrofit retrofit);
+
+    /**
+     * Extract the upper bound of the generic parameter at {@code index} from {@code type}. For
+     * example, index 1 of {@code Map<String, ? extends Runnable>} returns {@code Runnable}.
+     */
+    protected static Type getParameterUpperBound(int index, ParameterizedType type) {
+      return Utils.getParameterUpperBound(index, type);
+    }
+
+    /**
+     * Extract the raw class type from {@code type}. For example, the type representing
+     * {@code List<? extends Runnable>} returns {@code List.class}.
+     */
+    protected static Class<?> getRawType(Type type) {
+      return Utils.getRawType(type);
+    }
   }
 }
diff --git a/retrofit/src/main/java/retrofit2/Callback.java b/retrofit/src/main/java/retrofit2/Callback.java
index 251f9a389..62c93a621 100644
--- a/retrofit/src/main/java/retrofit2/Callback.java
+++ b/retrofit/src/main/java/retrofit2/Callback.java
@@ -33,13 +33,13 @@
    * Invoked for a received HTTP response.
    * <p>
    * Note: An HTTP response may still indicate an application-level failure such as a 404 or 500.
-   * Call {@link Response#isSuccess()} to determine if the response indicates success.
+   * Call {@link Response#isSuccessful()} to determine if the response indicates success.
    */
-  void onResponse(Response<T> response);
+  void onResponse(Call<T> call, Response<T> response);
 
   /**
    * Invoked when a network exception occurred talking to the server or when an unexpected
    * exception occurred creating the request or processing the response.
    */
-  void onFailure(Throwable t);
+  void onFailure(Call<T> call, Throwable t);
 }
diff --git a/retrofit/src/main/java/retrofit2/Converter.java b/retrofit/src/main/java/retrofit2/Converter.java
index e20673d99..37a64f8d1 100644
--- a/retrofit/src/main/java/retrofit2/Converter.java
+++ b/retrofit/src/main/java/retrofit2/Converter.java
@@ -15,15 +15,18 @@
  */
 package retrofit2;
 
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
 import java.lang.annotation.Annotation;
+import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
+import javax.annotation.Nullable;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
 import retrofit2.http.Body;
 import retrofit2.http.Field;
 import retrofit2.http.FieldMap;
 import retrofit2.http.Header;
+import retrofit2.http.HeaderMap;
 import retrofit2.http.Part;
 import retrofit2.http.PartMap;
 import retrofit2.http.Path;
@@ -46,8 +49,8 @@
      * response types such as {@code SimpleResponse} from a {@code Call<SimpleResponse>}
      * declaration.
      */
-    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-        Retrofit retrofit) {
+    public @Nullable Converter<ResponseBody, ?> responseBodyConverter(Type type,
+        Annotation[] annotations, Retrofit retrofit) {
       return null;
     }
 
@@ -57,8 +60,8 @@
      * specified by {@link Body @Body}, {@link Part @Part}, and {@link PartMap @PartMap}
      * values.
      */
-    public Converter<?, RequestBody> requestBodyConverter(Type type, Annotation[] annotations,
-        Retrofit retrofit) {
+    public @Nullable Converter<?, RequestBody> requestBodyConverter(Type type,
+        Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
       return null;
     }
 
@@ -66,11 +69,28 @@
      * Returns a {@link Converter} for converting {@code type} to a {@link String}, or null if
      * {@code type} cannot be handled by this factory. This is used to create converters for types
      * specified by {@link Field @Field}, {@link FieldMap @FieldMap} values,
-     * {@link Header @Header}, {@link Path @Path}, {@link Query @Query}, and
-     * {@link QueryMap @QueryMap} values.
+     * {@link Header @Header}, {@link HeaderMap @HeaderMap}, {@link Path @Path},
+     * {@link Query @Query}, and {@link QueryMap @QueryMap} values.
      */
-    public Converter<?, String> stringConverter(Type type, Annotation[] annotations) {
+    public @Nullable Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+        Retrofit retrofit) {
       return null;
     }
+
+    /**
+     * Extract the upper bound of the generic parameter at {@code index} from {@code type}. For
+     * example, index 1 of {@code Map<String, ? extends Runnable>} returns {@code Runnable}.
+     */
+    protected static Type getParameterUpperBound(int index, ParameterizedType type) {
+      return Utils.getParameterUpperBound(index, type);
+    }
+
+    /**
+     * Extract the raw class type from {@code type}. For example, the type representing
+     * {@code List<? extends Runnable>} returns {@code List.class}.
+     */
+    protected static Class<?> getRawType(Type type) {
+      return Utils.getRawType(type);
+    }
   }
 }
diff --git a/retrofit/src/main/java/retrofit2/DefaultCallAdapter.java b/retrofit/src/main/java/retrofit2/DefaultCallAdapter.java
deleted file mode 100644
index 96408ac61..000000000
--- a/retrofit/src/main/java/retrofit2/DefaultCallAdapter.java
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2;
-
-import java.lang.annotation.Annotation;
-import java.lang.reflect.Type;
-
-/**
- * A call adapter that uses the same thread for both I/O and application-level callbacks. For
- * synchronous calls this is the application thread making the request; for asynchronous calls this
- * is a thread provided by OkHttp's dispatcher.
- */
-final class DefaultCallAdapter implements CallAdapter<Call<?>> {
-  static final Factory FACTORY = new Factory() {
-    @Override
-    public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
-      if (Utils.getRawType(returnType) != Call.class) {
-        return null;
-      }
-      Type responseType = Utils.getCallResponseType(returnType);
-      return new DefaultCallAdapter(responseType);
-    }
-  };
-
-  private final Type responseType;
-
-  DefaultCallAdapter(Type responseType) {
-    this.responseType = responseType;
-  }
-
-  @Override public Type responseType() {
-    return responseType;
-  }
-
-  @Override public <R> Call<R> adapt(Call<R> call) {
-    return call;
-  }
-}
diff --git a/retrofit/src/main/java/retrofit2/DefaultCallAdapterFactory.java b/retrofit/src/main/java/retrofit2/DefaultCallAdapterFactory.java
new file mode 100644
index 000000000..c0f114cf3
--- /dev/null
+++ b/retrofit/src/main/java/retrofit2/DefaultCallAdapterFactory.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+
+/**
+ * Creates call adapters for that uses the same thread for both I/O and application-level
+ * callbacks. For synchronous calls this is the application thread making the request; for
+ * asynchronous calls this is a thread provided by OkHttp's dispatcher.
+ */
+final class DefaultCallAdapterFactory extends CallAdapter.Factory {
+  static final CallAdapter.Factory INSTANCE = new DefaultCallAdapterFactory();
+
+  @Override
+  public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+    if (getRawType(returnType) != Call.class) {
+      return null;
+    }
+
+    final Type responseType = Utils.getCallResponseType(returnType);
+    return new CallAdapter<Object, Call<?>>() {
+      @Override public Type responseType() {
+        return responseType;
+      }
+
+      @Override public Call<Object> adapt(Call<Object> call) {
+        return call;
+      }
+    };
+  }
+}
diff --git a/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java b/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java
index ccdf9843f..f819c7863 100644
--- a/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java
+++ b/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java
@@ -19,8 +19,11 @@
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
 import java.util.concurrent.Executor;
+import okhttp3.Request;
 
-final class ExecutorCallAdapterFactory implements CallAdapter.Factory {
+import static retrofit2.Utils.checkNotNull;
+
+final class ExecutorCallAdapterFactory extends CallAdapter.Factory {
   final Executor callbackExecutor;
 
   ExecutorCallAdapterFactory(Executor callbackExecutor) {
@@ -28,17 +31,17 @@
   }
 
   @Override
-  public CallAdapter<Call<?>> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
-    if (Utils.getRawType(returnType) != Call.class) {
+  public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+    if (getRawType(returnType) != Call.class) {
       return null;
     }
     final Type responseType = Utils.getCallResponseType(returnType);
-    return new CallAdapter<Call<?>>() {
+    return new CallAdapter<Object, Call<?>>() {
       @Override public Type responseType() {
         return responseType;
       }
 
-      @Override public <R> Call<R> adapt(Call<R> call) {
+      @Override public Call<Object> adapt(Call<Object> call) {
         return new ExecutorCallbackCall<>(callbackExecutor, call);
       }
     };
@@ -54,24 +57,26 @@
     }
 
     @Override public void enqueue(final Callback<T> callback) {
+      checkNotNull(callback, "callback == null");
+
       delegate.enqueue(new Callback<T>() {
-        @Override public void onResponse(final Response<T> response) {
+        @Override public void onResponse(Call<T> call, final Response<T> response) {
           callbackExecutor.execute(new Runnable() {
             @Override public void run() {
               if (delegate.isCanceled()) {
-                // Emulate OkHttp's behavior of throwing/delivering an IOException on cancelation
-                callback.onFailure(new IOException("Canceled"));
+                // Emulate OkHttp's behavior of throwing/delivering an IOException on cancellation.
+                callback.onFailure(ExecutorCallbackCall.this, new IOException("Canceled"));
               } else {
-                callback.onResponse(response);
+                callback.onResponse(ExecutorCallbackCall.this, response);
               }
             }
           });
         }
 
-        @Override public void onFailure(final Throwable t) {
+        @Override public void onFailure(Call<T> call, final Throwable t) {
           callbackExecutor.execute(new Runnable() {
             @Override public void run() {
-              callback.onFailure(t);
+              callback.onFailure(ExecutorCallbackCall.this, t);
             }
           });
         }
@@ -98,5 +103,9 @@
     @Override public Call<T> clone() {
       return new ExecutorCallbackCall<>(callbackExecutor, delegate.clone());
     }
+
+    @Override public Request request() {
+      return delegate.request();
+    }
   }
 }
diff --git a/retrofit/src/main/java/retrofit2/HttpException.java b/retrofit/src/main/java/retrofit2/HttpException.java
new file mode 100644
index 000000000..c01f97dfe
--- /dev/null
+++ b/retrofit/src/main/java/retrofit2/HttpException.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import static retrofit2.Utils.checkNotNull;
+
+/** Exception for an unexpected, non-2xx HTTP response. */
+public class HttpException extends RuntimeException {
+  private static String getMessage(Response<?> response) {
+    checkNotNull(response, "response == null");
+    return "HTTP " + response.code() + " " + response.message();
+  }
+
+  private final int code;
+  private final String message;
+  private final transient Response<?> response;
+
+  public HttpException(Response<?> response) {
+    super(getMessage(response));
+    this.code = response.code();
+    this.message = response.message();
+    this.response = response;
+  }
+
+  /** HTTP status code. */
+  public int code() {
+    return code;
+  }
+
+  /** HTTP status message. */
+  public String message() {
+    return message;
+  }
+
+  /**
+   * The full HTTP response. This may be null if the exception was serialized.
+   */
+  public Response<?> response() {
+    return response;
+  }
+}
diff --git a/retrofit/src/main/java/retrofit2/MethodHandler.java b/retrofit/src/main/java/retrofit2/MethodHandler.java
deleted file mode 100644
index 7b97cf82f..000000000
--- a/retrofit/src/main/java/retrofit2/MethodHandler.java
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2;
-
-import com.squareup.okhttp.ResponseBody;
-import java.lang.annotation.Annotation;
-import java.lang.reflect.Method;
-import java.lang.reflect.Type;
-
-final class MethodHandler {
-  static MethodHandler create(Retrofit retrofit, Method method) {
-    CallAdapter<?> callAdapter = createCallAdapter(method, retrofit);
-    Type responseType = callAdapter.responseType();
-    Converter<ResponseBody, ?> responseConverter =
-        createResponseConverter(method, retrofit, responseType);
-    RequestFactory requestFactory = RequestFactoryParser.parse(method, responseType, retrofit);
-    return new MethodHandler(retrofit.callFactory(), requestFactory, callAdapter,
-        responseConverter);
-  }
-
-  private static CallAdapter<?> createCallAdapter(Method method, Retrofit retrofit) {
-    Type returnType = method.getGenericReturnType();
-    if (Utils.hasUnresolvableType(returnType)) {
-      throw Utils.methodError(method,
-          "Method return type must not include a type variable or wildcard: %s", returnType);
-    }
-    if (returnType == void.class) {
-      throw Utils.methodError(method, "Service methods cannot return void.");
-    }
-    Annotation[] annotations = method.getAnnotations();
-    try {
-      return retrofit.callAdapter(returnType, annotations);
-    } catch (RuntimeException e) { // Wide exception range because factories are user code.
-      throw Utils.methodError(e, method, "Unable to create call adapter for %s", returnType);
-    }
-  }
-
-  private static Converter<ResponseBody, ?> createResponseConverter(Method method,
-      Retrofit retrofit, Type responseType) {
-    Annotation[] annotations = method.getAnnotations();
-    try {
-      return retrofit.responseBodyConverter(responseType, annotations);
-    } catch (RuntimeException e) { // Wide exception range because factories are user code.
-      throw Utils.methodError(e, method, "Unable to create converter for %s", responseType);
-    }
-  }
-
-  private final Call.Factory callFactory;
-  private final RequestFactory requestFactory;
-  private final CallAdapter<?> callAdapter;
-  private final Converter<ResponseBody, ?> responseConverter;
-
-  private MethodHandler(Call.Factory callFactory, RequestFactory requestFactory,
-      CallAdapter<?> callAdapter, Converter<ResponseBody, ?> responseConverter) {
-    this.callFactory = callFactory;
-    this.requestFactory = requestFactory;
-    this.callAdapter = callAdapter;
-    this.responseConverter = responseConverter;
-  }
-
-  Object invoke(Object... args) {
-    DeferredRequest request = requestFactory.defer(args);
-    Call<?> call = callFactory.create(request, responseConverter);
-    if (call == null) {
-      throw new NullPointerException("Call.Factory returned null.");
-    }
-    return callAdapter.adapt(call);
-  }
-}
diff --git a/retrofit/src/main/java/retrofit2/OkHttpCall.java b/retrofit/src/main/java/retrofit2/OkHttpCall.java
index 92f1bab39..90e82d7b5 100644
--- a/retrofit/src/main/java/retrofit2/OkHttpCall.java
+++ b/retrofit/src/main/java/retrofit2/OkHttpCall.java
@@ -15,87 +15,127 @@
  */
 package retrofit2;
 
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
+import javax.annotation.Nullable;
+import javax.annotation.concurrent.GuardedBy;
+import okhttp3.MediaType;
+import okhttp3.Request;
+import okhttp3.ResponseBody;
 import okio.Buffer;
 import okio.BufferedSource;
 import okio.ForwardingSource;
 import okio.Okio;
 
-import static retrofit2.Utils.closeQuietly;
+import static retrofit2.Utils.checkNotNull;
+import static retrofit2.Utils.throwIfFatal;
 
 final class OkHttpCall<T> implements Call<T> {
-  private final OkHttpClient client;
-  private final DeferredRequest request;
-  private final Converter<ResponseBody, T> responseConverter;
+  private final ServiceMethod<T, ?> serviceMethod;
+  private final @Nullable Object[] args;
 
-  private volatile com.squareup.okhttp.Call rawCall;
-  private boolean executed; // Guarded by this.
   private volatile boolean canceled;
 
-  OkHttpCall(OkHttpClient client, DeferredRequest request,
-      Converter<ResponseBody, T> responseConverter) {
-    this.client = client;
-    this.request = request;
-    this.responseConverter = responseConverter;
+  @GuardedBy("this")
+  private @Nullable okhttp3.Call rawCall;
+  @GuardedBy("this") // Either a RuntimeException, non-fatal Error, or IOException.
+  private @Nullable Throwable creationFailure;
+  @GuardedBy("this")
+  private boolean executed;
+
+  OkHttpCall(ServiceMethod<T, ?> serviceMethod, @Nullable Object[] args) {
+    this.serviceMethod = serviceMethod;
+    this.args = args;
   }
 
   @SuppressWarnings("CloneDoesntCallSuperClone") // We are a final type & this saves clearing state.
   @Override public OkHttpCall<T> clone() {
-    return new OkHttpCall<>(client, request, responseConverter);
+    return new OkHttpCall<>(serviceMethod, args);
+  }
+
+  @Override public synchronized Request request() {
+    okhttp3.Call call = rawCall;
+    if (call != null) {
+      return call.request();
+    }
+    if (creationFailure != null) {
+      if (creationFailure instanceof IOException) {
+        throw new RuntimeException("Unable to create request.", creationFailure);
+      } else if (creationFailure instanceof RuntimeException) {
+        throw (RuntimeException) creationFailure;
+      } else {
+        throw (Error) creationFailure;
+      }
+    }
+    try {
+      return (rawCall = createRawCall()).request();
+    } catch (RuntimeException | Error e) {
+      throwIfFatal(e); // Do not assign a fatal error to creationFailure.
+      creationFailure = e;
+      throw e;
+    } catch (IOException e) {
+      creationFailure = e;
+      throw new RuntimeException("Unable to create request.", e);
+    }
   }
 
   @Override public void enqueue(final Callback<T> callback) {
+    checkNotNull(callback, "callback == null");
+
+    okhttp3.Call call;
+    Throwable failure;
+
     synchronized (this) {
       if (executed) throw new IllegalStateException("Already executed.");
       executed = true;
+
+      call = rawCall;
+      failure = creationFailure;
+      if (call == null && failure == null) {
+        try {
+          call = rawCall = createRawCall();
+        } catch (Throwable t) {
+          throwIfFatal(t);
+          failure = creationFailure = t;
+        }
+      }
     }
 
-    com.squareup.okhttp.Call rawCall;
-    try {
-      rawCall = createRawCall();
-    } catch (Throwable t) {
-      callback.onFailure(t);
+    if (failure != null) {
+      callback.onFailure(this, failure);
       return;
     }
+
     if (canceled) {
-      rawCall.cancel();
+      call.cancel();
     }
-    this.rawCall = rawCall;
 
-    rawCall.enqueue(new com.squareup.okhttp.Callback() {
-      private void callFailure(Throwable e) {
+    call.enqueue(new okhttp3.Callback() {
+      @Override public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse) {
+        Response<T> response;
         try {
-          callback.onFailure(e);
-        } catch (Throwable t) {
-          t.printStackTrace();
+          response = parseResponse(rawResponse);
+        } catch (Throwable e) {
+          callFailure(e);
+          return;
         }
-      }
 
-      private void callSuccess(Response<T> response) {
         try {
-          callback.onResponse(response);
+          callback.onResponse(OkHttpCall.this, response);
         } catch (Throwable t) {
           t.printStackTrace();
         }
       }
 
-      @Override public void onFailure(Request request, IOException e) {
+      @Override public void onFailure(okhttp3.Call call, IOException e) {
         callFailure(e);
       }
 
-      @Override public void onResponse(com.squareup.okhttp.Response rawResponse) {
-        Response<T> response;
+      private void callFailure(Throwable e) {
         try {
-          response = parseResponse(rawResponse);
-        } catch (Throwable e) {
-          callFailure(e);
-          return;
+          callback.onFailure(OkHttpCall.this, e);
+        } catch (Throwable t) {
+          t.printStackTrace();
         }
-        callSuccess(response);
       }
     });
   }
@@ -105,25 +145,50 @@ private void callSuccess(Response<T> response) {
   }
 
   @Override public Response<T> execute() throws IOException {
+    okhttp3.Call call;
+
     synchronized (this) {
       if (executed) throw new IllegalStateException("Already executed.");
       executed = true;
+
+      if (creationFailure != null) {
+        if (creationFailure instanceof IOException) {
+          throw (IOException) creationFailure;
+        } else if (creationFailure instanceof RuntimeException) {
+          throw (RuntimeException) creationFailure;
+        } else {
+          throw (Error) creationFailure;
+        }
+      }
+
+      call = rawCall;
+      if (call == null) {
+        try {
+          call = rawCall = createRawCall();
+        } catch (IOException | RuntimeException | Error e) {
+          throwIfFatal(e); //  Do not assign a fatal error to creationFailure.
+          creationFailure = e;
+          throw e;
+        }
+      }
     }
 
-    com.squareup.okhttp.Call rawCall = createRawCall();
     if (canceled) {
-      rawCall.cancel();
+      call.cancel();
     }
-    this.rawCall = rawCall;
 
-    return parseResponse(rawCall.execute());
+    return parseResponse(call.execute());
   }
 
-  private com.squareup.okhttp.Call createRawCall() throws IOException {
-    return client.newCall(request.get());
+  private okhttp3.Call createRawCall() throws IOException {
+    okhttp3.Call call = serviceMethod.toCall(args);
+    if (call == null) {
+      throw new NullPointerException("Call.Factory returned null.");
+    }
+    return call;
   }
 
-  Response<T> parseResponse(com.squareup.okhttp.Response rawResponse) throws IOException {
+  Response<T> parseResponse(okhttp3.Response rawResponse) throws IOException {
     ResponseBody rawBody = rawResponse.body();
 
     // Remove the body's source (the only stateful object) so we can pass the response along.
@@ -135,20 +200,21 @@ private void callSuccess(Response<T> response) {
     if (code < 200 || code >= 300) {
       try {
         // Buffer the entire body to avoid future I/O.
-        ResponseBody bufferedBody = Utils.readBodyToBytesIfNecessary(rawBody);
+        ResponseBody bufferedBody = Utils.buffer(rawBody);
         return Response.error(bufferedBody, rawResponse);
       } finally {
-        closeQuietly(rawBody);
+        rawBody.close();
       }
     }
 
     if (code == 204 || code == 205) {
+      rawBody.close();
       return Response.success(null, rawResponse);
     }
 
     ExceptionCatchingRequestBody catchingBody = new ExceptionCatchingRequestBody(rawBody);
     try {
-      T body = responseConverter.convert(catchingBody);
+      T body = serviceMethod.toResponse(catchingBody);
       return Response.success(body, rawResponse);
     } catch (RuntimeException e) {
       // If the underlying source threw an exception, propagate that rather than indicating it was
@@ -160,14 +226,23 @@ private void callSuccess(Response<T> response) {
 
   public void cancel() {
     canceled = true;
-    com.squareup.okhttp.Call rawCall = this.rawCall;
-    if (rawCall != null) {
-      rawCall.cancel();
+
+    okhttp3.Call call;
+    synchronized (this) {
+      call = rawCall;
+    }
+    if (call != null) {
+      call.cancel();
     }
   }
 
   @Override public boolean isCanceled() {
-    return canceled;
+    if (canceled) {
+      return true;
+    }
+    synchronized (this) {
+      return rawCall != null && rawCall.isCanceled();
+    }
   }
 
   static final class NoContentResponseBody extends ResponseBody {
@@ -183,11 +258,11 @@ public void cancel() {
       return contentType;
     }
 
-    @Override public long contentLength() throws IOException {
+    @Override public long contentLength() {
       return contentLength;
     }
 
-    @Override public BufferedSource source() throws IOException {
+    @Override public BufferedSource source() {
       throw new IllegalStateException("Cannot read raw response body of a converted body.");
     }
   }
@@ -204,24 +279,12 @@ public void cancel() {
       return delegate.contentType();
     }
 
-    @Override public long contentLength() throws IOException {
-      try {
-        return delegate.contentLength();
-      } catch (IOException e) {
-        thrownException = e;
-        throw e;
-      }
+    @Override public long contentLength() {
+      return delegate.contentLength();
     }
 
-    @Override public BufferedSource source() throws IOException {
-      BufferedSource delegateSource;
-      try {
-        delegateSource = delegate.source();
-      } catch (IOException e) {
-        thrownException = e;
-        throw e;
-      }
-      return Okio.buffer(new ForwardingSource(delegateSource) {
+    @Override public BufferedSource source() {
+      return Okio.buffer(new ForwardingSource(delegate.source()) {
         @Override public long read(Buffer sink, long byteCount) throws IOException {
           try {
             return super.read(sink, byteCount);
@@ -233,7 +296,7 @@ public void cancel() {
       });
     }
 
-    @Override public void close() throws IOException {
+    @Override public void close() {
       delegate.close();
     }
 
diff --git a/retrofit/src/main/java/retrofit2/ParameterHandler.java b/retrofit/src/main/java/retrofit2/ParameterHandler.java
new file mode 100644
index 000000000..929413418
--- /dev/null
+++ b/retrofit/src/main/java/retrofit2/ParameterHandler.java
@@ -0,0 +1,362 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import java.io.IOException;
+import java.lang.reflect.Array;
+import java.util.Map;
+import javax.annotation.Nullable;
+import okhttp3.Headers;
+import okhttp3.MultipartBody;
+import okhttp3.RequestBody;
+
+import static retrofit2.Utils.checkNotNull;
+
+abstract class ParameterHandler<T> {
+  abstract void apply(RequestBuilder builder, @Nullable T value) throws IOException;
+
+  final ParameterHandler<Iterable<T>> iterable() {
+    return new ParameterHandler<Iterable<T>>() {
+      @Override void apply(RequestBuilder builder, @Nullable Iterable<T> values)
+          throws IOException {
+        if (values == null) return; // Skip null values.
+
+        for (T value : values) {
+          ParameterHandler.this.apply(builder, value);
+        }
+      }
+    };
+  }
+
+  final ParameterHandler<Object> array() {
+    return new ParameterHandler<Object>() {
+      @Override void apply(RequestBuilder builder, @Nullable Object values) throws IOException {
+        if (values == null) return; // Skip null values.
+
+        for (int i = 0, size = Array.getLength(values); i < size; i++) {
+          //noinspection unchecked
+          ParameterHandler.this.apply(builder, (T) Array.get(values, i));
+        }
+      }
+    };
+  }
+
+  static final class RelativeUrl extends ParameterHandler<Object> {
+    @Override void apply(RequestBuilder builder, @Nullable Object value) {
+      checkNotNull(value, "@Url parameter is null.");
+      builder.setRelativeUrl(value);
+    }
+  }
+
+  static final class Header<T> extends ParameterHandler<T> {
+    private final String name;
+    private final Converter<T, String> valueConverter;
+
+    Header(String name, Converter<T, String> valueConverter) {
+      this.name = checkNotNull(name, "name == null");
+      this.valueConverter = valueConverter;
+    }
+
+    @Override void apply(RequestBuilder builder, @Nullable T value) throws IOException {
+      if (value == null) return; // Skip null values.
+
+      String headerValue = valueConverter.convert(value);
+      if (headerValue == null) return; // Skip converted but null values.
+
+      builder.addHeader(name, headerValue);
+    }
+  }
+
+  static final class Path<T> extends ParameterHandler<T> {
+    private final String name;
+    private final Converter<T, String> valueConverter;
+    private final boolean encoded;
+
+    Path(String name, Converter<T, String> valueConverter, boolean encoded) {
+      this.name = checkNotNull(name, "name == null");
+      this.valueConverter = valueConverter;
+      this.encoded = encoded;
+    }
+
+    @Override void apply(RequestBuilder builder, @Nullable T value) throws IOException {
+      if (value == null) {
+        throw new IllegalArgumentException(
+            "Path parameter \"" + name + "\" value must not be null.");
+      }
+      builder.addPathParam(name, valueConverter.convert(value), encoded);
+    }
+  }
+
+  static final class Query<T> extends ParameterHandler<T> {
+    private final String name;
+    private final Converter<T, String> valueConverter;
+    private final boolean encoded;
+
+    Query(String name, Converter<T, String> valueConverter, boolean encoded) {
+      this.name = checkNotNull(name, "name == null");
+      this.valueConverter = valueConverter;
+      this.encoded = encoded;
+    }
+
+    @Override void apply(RequestBuilder builder, @Nullable T value) throws IOException {
+      if (value == null) return; // Skip null values.
+
+      String queryValue = valueConverter.convert(value);
+      if (queryValue == null) return; // Skip converted but null values
+
+      builder.addQueryParam(name, queryValue, encoded);
+    }
+  }
+
+  static final class QueryName<T> extends ParameterHandler<T> {
+    private final Converter<T, String> nameConverter;
+    private final boolean encoded;
+
+    QueryName(Converter<T, String> nameConverter, boolean encoded) {
+      this.nameConverter = nameConverter;
+      this.encoded = encoded;
+    }
+
+    @Override void apply(RequestBuilder builder, @Nullable T value) throws IOException {
+      if (value == null) return; // Skip null values.
+      builder.addQueryParam(nameConverter.convert(value), null, encoded);
+    }
+  }
+
+  static final class QueryMap<T> extends ParameterHandler<Map<String, T>> {
+    private final Converter<T, String> valueConverter;
+    private final boolean encoded;
+
+    QueryMap(Converter<T, String> valueConverter, boolean encoded) {
+      this.valueConverter = valueConverter;
+      this.encoded = encoded;
+    }
+
+    @Override void apply(RequestBuilder builder, @Nullable Map<String, T> value)
+        throws IOException {
+      if (value == null) {
+        throw new IllegalArgumentException("Query map was null.");
+      }
+
+      for (Map.Entry<String, T> entry : value.entrySet()) {
+        String entryKey = entry.getKey();
+        if (entryKey == null) {
+          throw new IllegalArgumentException("Query map contained null key.");
+        }
+        T entryValue = entry.getValue();
+        if (entryValue == null) {
+          throw new IllegalArgumentException(
+              "Query map contained null value for key '" + entryKey + "'.");
+        }
+
+        String convertedEntryValue = valueConverter.convert(entryValue);
+        if (convertedEntryValue == null) {
+          throw new IllegalArgumentException("Query map value '"
+              + entryValue
+              + "' converted to null by "
+              + valueConverter.getClass().getName()
+              + " for key '"
+              + entryKey
+              + "'.");
+        }
+
+        builder.addQueryParam(entryKey, convertedEntryValue, encoded);
+      }
+    }
+  }
+
+  static final class HeaderMap<T> extends ParameterHandler<Map<String, T>> {
+    private final Converter<T, String> valueConverter;
+
+    HeaderMap(Converter<T, String> valueConverter) {
+      this.valueConverter = valueConverter;
+    }
+
+    @Override void apply(RequestBuilder builder, @Nullable Map<String, T> value)
+        throws IOException {
+      if (value == null) {
+        throw new IllegalArgumentException("Header map was null.");
+      }
+
+      for (Map.Entry<String, T> entry : value.entrySet()) {
+        String headerName = entry.getKey();
+        if (headerName == null) {
+          throw new IllegalArgumentException("Header map contained null key.");
+        }
+        T headerValue = entry.getValue();
+        if (headerValue == null) {
+          throw new IllegalArgumentException(
+              "Header map contained null value for key '" + headerName + "'.");
+        }
+        builder.addHeader(headerName, valueConverter.convert(headerValue));
+      }
+    }
+  }
+
+  static final class Field<T> extends ParameterHandler<T> {
+    private final String name;
+    private final Converter<T, String> valueConverter;
+    private final boolean encoded;
+
+    Field(String name, Converter<T, String> valueConverter, boolean encoded) {
+      this.name = checkNotNull(name, "name == null");
+      this.valueConverter = valueConverter;
+      this.encoded = encoded;
+    }
+
+    @Override void apply(RequestBuilder builder, @Nullable T value) throws IOException {
+      if (value == null) return; // Skip null values.
+
+      String fieldValue = valueConverter.convert(value);
+      if (fieldValue == null) return; // Skip null converted values
+
+      builder.addFormField(name, fieldValue, encoded);
+    }
+  }
+
+  static final class FieldMap<T> extends ParameterHandler<Map<String, T>> {
+    private final Converter<T, String> valueConverter;
+    private final boolean encoded;
+
+    FieldMap(Converter<T, String> valueConverter, boolean encoded) {
+      this.valueConverter = valueConverter;
+      this.encoded = encoded;
+    }
+
+    @Override void apply(RequestBuilder builder, @Nullable Map<String, T> value)
+        throws IOException {
+      if (value == null) {
+        throw new IllegalArgumentException("Field map was null.");
+      }
+
+      for (Map.Entry<String, T> entry : value.entrySet()) {
+        String entryKey = entry.getKey();
+        if (entryKey == null) {
+          throw new IllegalArgumentException("Field map contained null key.");
+        }
+        T entryValue = entry.getValue();
+        if (entryValue == null) {
+          throw new IllegalArgumentException(
+              "Field map contained null value for key '" + entryKey + "'.");
+        }
+
+        String fieldEntry = valueConverter.convert(entryValue);
+        if (fieldEntry == null) {
+          throw new IllegalArgumentException("Field map value '"
+              + entryValue
+              + "' converted to null by "
+              + valueConverter.getClass().getName()
+              + " for key '"
+              + entryKey
+              + "'.");
+        }
+
+        builder.addFormField(entryKey, fieldEntry, encoded);
+      }
+    }
+  }
+
+  static final class Part<T> extends ParameterHandler<T> {
+    private final Headers headers;
+    private final Converter<T, RequestBody> converter;
+
+    Part(Headers headers, Converter<T, RequestBody> converter) {
+      this.headers = headers;
+      this.converter = converter;
+    }
+
+    @Override void apply(RequestBuilder builder, @Nullable T value) {
+      if (value == null) return; // Skip null values.
+
+      RequestBody body;
+      try {
+        body = converter.convert(value);
+      } catch (IOException e) {
+        throw new RuntimeException("Unable to convert " + value + " to RequestBody", e);
+      }
+      builder.addPart(headers, body);
+    }
+  }
+
+  static final class RawPart extends ParameterHandler<MultipartBody.Part> {
+    static final RawPart INSTANCE = new RawPart();
+
+    private RawPart() {
+    }
+
+    @Override void apply(RequestBuilder builder, @Nullable MultipartBody.Part value) {
+      if (value != null) { // Skip null values.
+        builder.addPart(value);
+      }
+    }
+  }
+
+  static final class PartMap<T> extends ParameterHandler<Map<String, T>> {
+    private final Converter<T, RequestBody> valueConverter;
+    private final String transferEncoding;
+
+    PartMap(Converter<T, RequestBody> valueConverter, String transferEncoding) {
+      this.valueConverter = valueConverter;
+      this.transferEncoding = transferEncoding;
+    }
+
+    @Override void apply(RequestBuilder builder, @Nullable Map<String, T> value)
+        throws IOException {
+      if (value == null) {
+        throw new IllegalArgumentException("Part map was null.");
+      }
+
+      for (Map.Entry<String, T> entry : value.entrySet()) {
+        String entryKey = entry.getKey();
+        if (entryKey == null) {
+          throw new IllegalArgumentException("Part map contained null key.");
+        }
+        T entryValue = entry.getValue();
+        if (entryValue == null) {
+          throw new IllegalArgumentException(
+              "Part map contained null value for key '" + entryKey + "'.");
+        }
+
+        Headers headers = Headers.of(
+            "Content-Disposition", "form-data; name=\"" + entryKey + "\"",
+            "Content-Transfer-Encoding", transferEncoding);
+
+        builder.addPart(headers, valueConverter.convert(entryValue));
+      }
+    }
+  }
+
+  static final class Body<T> extends ParameterHandler<T> {
+    private final Converter<T, RequestBody> converter;
+
+    Body(Converter<T, RequestBody> converter) {
+      this.converter = converter;
+    }
+
+    @Override void apply(RequestBuilder builder, @Nullable T value) {
+      if (value == null) {
+        throw new IllegalArgumentException("Body parameter value must not be null.");
+      }
+      RequestBody body;
+      try {
+        body = converter.convert(value);
+      } catch (IOException e) {
+        throw new RuntimeException("Unable to convert " + value + " to RequestBody", e);
+      }
+      builder.setBody(body);
+    }
+  }
+}
diff --git a/retrofit/src/main/java/retrofit2/Platform.java b/retrofit/src/main/java/retrofit2/Platform.java
index 327d79208..3c3307b70 100644
--- a/retrofit/src/main/java/retrofit2/Platform.java
+++ b/retrofit/src/main/java/retrofit2/Platform.java
@@ -18,9 +18,11 @@
 import android.os.Build;
 import android.os.Handler;
 import android.os.Looper;
-import java.lang.invoke.MethodHandles;
+import java.lang.invoke.MethodHandles.Lookup;
+import java.lang.reflect.Constructor;
 import java.lang.reflect.Method;
 import java.util.concurrent.Executor;
+import javax.annotation.Nullable;
 import org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement;
 
 class Platform {
@@ -46,19 +48,23 @@ private static Platform findPlatform() {
     return new Platform();
   }
 
-  CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) {
+  @Nullable Executor defaultCallbackExecutor() {
+    return null;
+  }
+
+  CallAdapter.Factory defaultCallAdapterFactory(@Nullable Executor callbackExecutor) {
     if (callbackExecutor != null) {
       return new ExecutorCallAdapterFactory(callbackExecutor);
     }
-    return DefaultCallAdapter.FACTORY;
+    return DefaultCallAdapterFactory.INSTANCE;
   }
 
   boolean isDefaultMethod(Method method) {
     return false;
   }
 
-  Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object, Object... args)
-      throws Throwable {
+  @Nullable Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object,
+      @Nullable Object... args) throws Throwable {
     throw new UnsupportedOperationException();
   }
 
@@ -69,9 +75,12 @@ Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object
     }
 
     @Override Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object,
-        Object... args) throws Throwable {
-      return MethodHandles.lookup()
-          .in(declaringClass)
+        @Nullable Object... args) throws Throwable {
+      // Because the service interface might not be public, we need to use a MethodHandle lookup
+      // that ignores the visibility of the declaringClass.
+      Constructor<Lookup> constructor = Lookup.class.getDeclaredConstructor(Class.class, int.class);
+      constructor.setAccessible(true);
+      return constructor.newInstance(declaringClass, -1 /* trusted */)
           .unreflectSpecial(method, declaringClass)
           .bindTo(object)
           .invokeWithArguments(args);
@@ -79,10 +88,12 @@ Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object
   }
 
   static class Android extends Platform {
-    @Override CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) {
-      if (callbackExecutor == null) {
-        callbackExecutor = new MainThreadExecutor();
-      }
+    @Override public Executor defaultCallbackExecutor() {
+      return new MainThreadExecutor();
+    }
+
+    @Override CallAdapter.Factory defaultCallAdapterFactory(@Nullable Executor callbackExecutor) {
+      if (callbackExecutor == null) throw new AssertionError();
       return new ExecutorCallAdapterFactory(callbackExecutor);
     }
 
diff --git a/retrofit/src/main/java/retrofit2/RequestAction.java b/retrofit/src/main/java/retrofit2/RequestAction.java
deleted file mode 100644
index bc97cea3c..000000000
--- a/retrofit/src/main/java/retrofit2/RequestAction.java
+++ /dev/null
@@ -1,252 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2;
-
-import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.RequestBody;
-import java.io.IOException;
-import java.lang.reflect.Array;
-import java.util.Map;
-
-import static retrofit2.Utils.checkNotNull;
-
-abstract class RequestAction<T> {
-  abstract void perform(RequestBuilder builder, T value) throws IOException;
-
-  final RequestAction<Iterable<T>> iterable() {
-    return new RequestAction<Iterable<T>>() {
-      @Override void perform(RequestBuilder builder, Iterable<T> values) throws IOException {
-        if (values == null) return; // Skip null values.
-
-        for (T value : values) {
-          RequestAction.this.perform(builder, value);
-        }
-      }
-    };
-  }
-
-  final RequestAction<Object> array() {
-    return new RequestAction<Object>() {
-      @Override void perform(RequestBuilder builder, Object values) throws IOException {
-        if (values == null) return; // Skip null values.
-
-        for (int i = 0, size = Array.getLength(values); i < size; i++) {
-          //noinspection unchecked
-          RequestAction.this.perform(builder, (T) Array.get(values, i));
-        }
-      }
-    };
-  }
-
-  static final class Url extends RequestAction<String> {
-    @Override void perform(RequestBuilder builder, String value) {
-      builder.setRelativeUrl(value);
-    }
-  }
-
-  static final class Header<T> extends RequestAction<T> {
-    private final String name;
-    private final Converter<T, String> valueConverter;
-
-    Header(String name, Converter<T, String> valueConverter) {
-      this.name = checkNotNull(name, "name == null");
-      this.valueConverter = valueConverter;
-    }
-
-    @Override void perform(RequestBuilder builder, T value) throws IOException {
-      if (value == null) return; // Skip null values.
-      builder.addHeader(name, valueConverter.convert(value));
-    }
-  }
-
-  static final class Path<T> extends RequestAction<T> {
-    private final String name;
-    private final Converter<T, String> valueConverter;
-    private final boolean encoded;
-
-    Path(String name, Converter<T, String> valueConverter, boolean encoded) {
-      this.name = checkNotNull(name, "name == null");
-      this.valueConverter = valueConverter;
-      this.encoded = encoded;
-    }
-
-    @Override void perform(RequestBuilder builder, T value) throws IOException {
-      if (value == null) {
-        throw new IllegalArgumentException(
-            "Path parameter \"" + name + "\" value must not be null.");
-      }
-      builder.addPathParam(name, valueConverter.convert(value), encoded);
-    }
-  }
-
-  static final class Query<T> extends RequestAction<T> {
-    private final String name;
-    private final Converter<T, String> valueConverter;
-    private final boolean encoded;
-
-    Query(String name, Converter<T, String> valueConverter, boolean encoded) {
-      this.name = checkNotNull(name, "name == null");
-      this.valueConverter = valueConverter;
-      this.encoded = encoded;
-    }
-
-    @Override void perform(RequestBuilder builder, T value) throws IOException {
-      if (value == null) return; // Skip null values.
-      builder.addQueryParam(name, valueConverter.convert(value), encoded);
-    }
-  }
-
-  static final class QueryMap<T> extends RequestAction<Map<String, T>> {
-    private final Converter<T, String> valueConverter;
-    private final boolean encoded;
-
-    QueryMap(Converter<T, String> valueConverter, boolean encoded) {
-      this.valueConverter = valueConverter;
-      this.encoded = encoded;
-    }
-
-    @Override void perform(RequestBuilder builder, Map<String, T> value) throws IOException {
-      if (value == null) return; // Skip null values.
-
-      for (Map.Entry<String, T> entry : value.entrySet()) {
-        String entryKey = entry.getKey();
-        if (entryKey == null) {
-          throw new IllegalArgumentException("Query map contained null key.");
-        }
-        T entryValue = entry.getValue();
-        if (entryValue != null) { // Skip null values.
-          builder.addQueryParam(entryKey, valueConverter.convert(entryValue), encoded);
-        }
-      }
-    }
-  }
-
-  static final class Field<T> extends RequestAction<T> {
-    private final String name;
-    private final Converter<T, String> valueConverter;
-    private final boolean encoded;
-
-    Field(String name, Converter<T, String> valueConverter, boolean encoded) {
-      this.name = checkNotNull(name, "name == null");
-      this.valueConverter = valueConverter;
-      this.encoded = encoded;
-    }
-
-    @Override void perform(RequestBuilder builder, T value) throws IOException {
-      if (value == null) return; // Skip null values.
-      builder.addFormField(name, valueConverter.convert(value), encoded);
-    }
-  }
-
-  static final class FieldMap<T> extends RequestAction<Map<String, T>> {
-    private final Converter<T, String> valueConverter;
-    private final boolean encoded;
-
-    FieldMap(Converter<T, String> valueConverter, boolean encoded) {
-      this.valueConverter = valueConverter;
-      this.encoded = encoded;
-    }
-
-    @Override void perform(RequestBuilder builder, Map<String, T> value) throws IOException {
-      if (value == null) return; // Skip null values.
-
-      for (Map.Entry<String, T> entry : value.entrySet()) {
-        String entryKey = entry.getKey();
-        if (entryKey == null) {
-          throw new IllegalArgumentException("Field map contained null key.");
-        }
-        T entryValue = entry.getValue();
-        if (entryValue != null) { // Skip null values.
-          builder.addFormField(entryKey, valueConverter.convert(entryValue), encoded);
-        }
-      }
-    }
-  }
-
-  static final class Part<T> extends RequestAction<T> {
-    private final Headers headers;
-    private final Converter<T, RequestBody> converter;
-
-    Part(Headers headers, Converter<T, RequestBody> converter) {
-      this.headers = headers;
-      this.converter = converter;
-    }
-
-    @Override void perform(RequestBuilder builder, T value) {
-      if (value == null) return; // Skip null values.
-
-      RequestBody body;
-      try {
-        body = converter.convert(value);
-      } catch (IOException e) {
-        throw new RuntimeException("Unable to convert " + value + " to RequestBody", e);
-      }
-      builder.addPart(headers, body);
-    }
-  }
-
-  static final class PartMap<T> extends RequestAction<Map<String, T>> {
-    private final Converter<T, RequestBody> valueConverter;
-    private final String transferEncoding;
-
-    PartMap(Converter<T, RequestBody> valueConverter, String transferEncoding) {
-      this.valueConverter = valueConverter;
-      this.transferEncoding = transferEncoding;
-    }
-
-    @Override void perform(RequestBuilder builder, Map<String, T> value) throws IOException {
-      if (value == null) return; // Skip null values.
-
-      for (Map.Entry<String, T> entry : value.entrySet()) {
-        String entryKey = entry.getKey();
-        if (entryKey == null) {
-          throw new IllegalArgumentException("Part map contained null key.");
-        }
-        T entryValue = entry.getValue();
-        if (entryValue == null) {
-          continue; // Skip null values.
-        }
-
-        Headers headers = Headers.of(
-            "Content-Disposition", "form-data; name=\"" + entryKey + "\"",
-            "Content-Transfer-Encoding", transferEncoding);
-
-        builder.addPart(headers, valueConverter.convert(entryValue));
-      }
-    }
-  }
-
-  static final class Body<T> extends RequestAction<T> {
-    private final Converter<T, RequestBody> converter;
-
-    Body(Converter<T, RequestBody> converter) {
-      this.converter = converter;
-    }
-
-    @Override void perform(RequestBuilder builder, T value) {
-      if (value == null) {
-        throw new IllegalArgumentException("Body parameter value must not be null.");
-      }
-      RequestBody body;
-      try {
-        body = converter.convert(value);
-      } catch (IOException e) {
-        throw new RuntimeException("Unable to convert " + value + " to RequestBody", e);
-      }
-      builder.setBody(body);
-    }
-  }
-}
diff --git a/retrofit/src/main/java/retrofit2/RequestBuilder.java b/retrofit/src/main/java/retrofit2/RequestBuilder.java
index e04ead680..f27db26ee 100644
--- a/retrofit/src/main/java/retrofit2/RequestBuilder.java
+++ b/retrofit/src/main/java/retrofit2/RequestBuilder.java
@@ -15,38 +15,40 @@
  */
 package retrofit2;
 
-import com.squareup.okhttp.FormEncodingBuilder;
-import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.HttpUrl;
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.MultipartBuilder;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.RequestBody;
 import java.io.IOException;
+import javax.annotation.Nullable;
+import okhttp3.FormBody;
+import okhttp3.Headers;
+import okhttp3.HttpUrl;
+import okhttp3.MediaType;
+import okhttp3.MultipartBody;
+import okhttp3.Request;
+import okhttp3.RequestBody;
 import okio.Buffer;
 import okio.BufferedSink;
 
 final class RequestBuilder {
   private static final char[] HEX_DIGITS =
       { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
-  private static final String PATH_SEGMENT_ENCODE_SET = " \"<>^`{}|/\\?#";
+  private static final String PATH_SEGMENT_ALWAYS_ENCODE_SET = " \"<>^`{}|\\?#";
 
   private final String method;
 
   private final HttpUrl baseUrl;
-  private String relativeUrl;
-  private HttpUrl.Builder urlBuilder;
+  private @Nullable String relativeUrl;
+  private @Nullable HttpUrl.Builder urlBuilder;
 
   private final Request.Builder requestBuilder;
-  private MediaType contentType;
+  private @Nullable MediaType contentType;
 
   private final boolean hasBody;
-  private MultipartBuilder multipartBuilder;
-  private FormEncodingBuilder formEncodingBuilder;
-  private RequestBody body;
+  private @Nullable MultipartBody.Builder multipartBuilder;
+  private @Nullable FormBody.Builder formBuilder;
+  private @Nullable RequestBody body;
 
-  RequestBuilder(String method, HttpUrl baseUrl, String relativeUrl, Headers headers,
-      MediaType contentType, boolean hasBody, boolean isFormEncoded, boolean isMultipart) {
+  RequestBuilder(String method, HttpUrl baseUrl, @Nullable String relativeUrl,
+      @Nullable Headers headers, @Nullable MediaType contentType, boolean hasBody,
+      boolean isFormEncoded, boolean isMultipart) {
     this.method = method;
     this.baseUrl = baseUrl;
     this.relativeUrl = relativeUrl;
@@ -60,21 +62,25 @@
 
     if (isFormEncoded) {
       // Will be set to 'body' in 'build'.
-      formEncodingBuilder = new FormEncodingBuilder();
+      formBuilder = new FormBody.Builder();
     } else if (isMultipart) {
       // Will be set to 'body' in 'build'.
-      multipartBuilder = new MultipartBuilder();
-      multipartBuilder.type(MultipartBuilder.FORM);
+      multipartBuilder = new MultipartBody.Builder();
+      multipartBuilder.setType(MultipartBody.FORM);
     }
   }
 
-  void setRelativeUrl(String relativeUrl) {
-    this.relativeUrl = relativeUrl;
+  void setRelativeUrl(Object relativeUrl) {
+    this.relativeUrl = relativeUrl.toString();
   }
 
   void addHeader(String name, String value) {
     if ("Content-Type".equalsIgnoreCase(name)) {
-      contentType = MediaType.parse(value);
+      MediaType type = MediaType.parse(value);
+      if (type == null) {
+        throw new IllegalArgumentException("Malformed content type: " + value);
+      }
+      contentType = type;
     } else {
       requestBuilder.addHeader(name, value);
     }
@@ -85,20 +91,20 @@ void addPathParam(String name, String value, boolean encoded) {
       // The relative URL is cleared when the first query parameter is set.
       throw new AssertionError();
     }
-    relativeUrl = relativeUrl.replace("{" + name + "}", canonicalize(value, encoded));
+    relativeUrl = relativeUrl.replace("{" + name + "}", canonicalizeForPath(value, encoded));
   }
 
-  private static String canonicalize(String input, boolean alreadyEncoded) {
+  private static String canonicalizeForPath(String input, boolean alreadyEncoded) {
     int codePoint;
     for (int i = 0, limit = input.length(); i < limit; i += Character.charCount(codePoint)) {
       codePoint = input.codePointAt(i);
       if (codePoint < 0x20 || codePoint >= 0x7f
-          || PATH_SEGMENT_ENCODE_SET.indexOf(codePoint) != -1
-          || (codePoint == '%' && !alreadyEncoded)) {
+          || PATH_SEGMENT_ALWAYS_ENCODE_SET.indexOf(codePoint) != -1
+          || (!alreadyEncoded && (codePoint == '/' || codePoint == '%'))) {
         // Slow path: the character at i requires encoding!
         Buffer out = new Buffer();
         out.writeUtf8(input, 0, i);
-        canonicalize(out, input, i, limit, alreadyEncoded);
+        canonicalizeForPath(out, input, i, limit, alreadyEncoded);
         return out.readUtf8();
       }
     }
@@ -107,7 +113,7 @@ private static String canonicalize(String input, boolean alreadyEncoded) {
     return input;
   }
 
-  private static void canonicalize(Buffer out, String input, int pos, int limit,
+  private static void canonicalizeForPath(Buffer out, String input, int pos, int limit,
       boolean alreadyEncoded) {
     Buffer utf8Buffer = null; // Lazily allocated.
     int codePoint;
@@ -116,10 +122,9 @@ private static void canonicalize(Buffer out, String input, int pos, int limit,
       if (alreadyEncoded
           && (codePoint == '\t' || codePoint == '\n' || codePoint == '\f' || codePoint == '\r')) {
         // Skip this character.
-      } else if (codePoint < 0x20
-          || codePoint >= 0x7f
-          || PATH_SEGMENT_ENCODE_SET.indexOf(codePoint) != -1
-          || (codePoint == '%' && !alreadyEncoded)) {
+      } else if (codePoint < 0x20 || codePoint >= 0x7f
+          || PATH_SEGMENT_ALWAYS_ENCODE_SET.indexOf(codePoint) != -1
+          || (!alreadyEncoded && (codePoint == '/' || codePoint == '%'))) {
         // Percent encode this character.
         if (utf8Buffer == null) {
           utf8Buffer = new Buffer();
@@ -138,32 +143,45 @@ private static void canonicalize(Buffer out, String input, int pos, int limit,
     }
   }
 
-  void addQueryParam(String name, String value, boolean encoded) {
+  void addQueryParam(String name, @Nullable String value, boolean encoded) {
     if (relativeUrl != null) {
       // Do a one-time combination of the built relative URL and the base URL.
-      urlBuilder = baseUrl.resolve(relativeUrl).newBuilder();
+      urlBuilder = baseUrl.newBuilder(relativeUrl);
+      if (urlBuilder == null) {
+        throw new IllegalArgumentException(
+            "Malformed URL. Base: " + baseUrl + ", Relative: " + relativeUrl);
+      }
       relativeUrl = null;
     }
 
     if (encoded) {
+      //noinspection ConstantConditions Checked to be non-null by above 'if' block.
       urlBuilder.addEncodedQueryParameter(name, value);
     } else {
+      //noinspection ConstantConditions Checked to be non-null by above 'if' block.
       urlBuilder.addQueryParameter(name, value);
     }
   }
 
+  @SuppressWarnings("ConstantConditions") // Only called when isFormEncoded was true.
   void addFormField(String name, String value, boolean encoded) {
     if (encoded) {
-      formEncodingBuilder.addEncoded(name, value);
+      formBuilder.addEncoded(name, value);
     } else {
-      formEncodingBuilder.add(name, value);
+      formBuilder.add(name, value);
     }
   }
 
+  @SuppressWarnings("ConstantConditions") // Only called when isMultipart was true.
   void addPart(Headers headers, RequestBody body) {
     multipartBuilder.addPart(headers, body);
   }
 
+  @SuppressWarnings("ConstantConditions") // Only called when isMultipart was true.
+  void addPart(MultipartBody.Part part) {
+    multipartBuilder.addPart(part);
+  }
+
   void setBody(RequestBody body) {
     this.body = body;
   }
@@ -175,14 +193,19 @@ Request build() {
       url = urlBuilder.build();
     } else {
       // No query parameters triggered builder creation, just combine the relative URL and base URL.
+      //noinspection ConstantConditions Non-null if urlBuilder is null.
       url = baseUrl.resolve(relativeUrl);
+      if (url == null) {
+        throw new IllegalArgumentException(
+            "Malformed URL. Base: " + baseUrl + ", Relative: " + relativeUrl);
+      }
     }
 
     RequestBody body = this.body;
     if (body == null) {
       // Try to pull from one of the builders.
-      if (formEncodingBuilder != null) {
-        body = formEncodingBuilder.build();
+      if (formBuilder != null) {
+        body = formBuilder.build();
       } else if (multipartBuilder != null) {
         body = multipartBuilder.build();
       } else if (hasBody) {
diff --git a/retrofit/src/main/java/retrofit2/RequestFactory.java b/retrofit/src/main/java/retrofit2/RequestFactory.java
deleted file mode 100644
index 23063def4..000000000
--- a/retrofit/src/main/java/retrofit2/RequestFactory.java
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2;
-
-import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.Request;
-import java.io.IOException;
-
-final class RequestFactory {
-  private final String method;
-  private final BaseUrl baseUrl;
-  private final String relativeUrl;
-  private final Headers headers;
-  private final MediaType contentType;
-  private final boolean hasBody;
-  private final boolean isFormEncoded;
-  private final boolean isMultipart;
-  private final RequestAction[] requestActions;
-
-  RequestFactory(String method, BaseUrl baseUrl, String relativeUrl, Headers headers,
-      MediaType contentType, boolean hasBody, boolean isFormEncoded, boolean isMultipart,
-      RequestAction[] requestActions) {
-    this.method = method;
-    this.baseUrl = baseUrl;
-    this.relativeUrl = relativeUrl;
-    this.headers = headers;
-    this.contentType = contentType;
-    this.hasBody = hasBody;
-    this.isFormEncoded = isFormEncoded;
-    this.isMultipart = isMultipart;
-    this.requestActions = requestActions;
-  }
-
-  DeferredRequest defer(final Object... args) {
-    return new DeferredRequest() {
-      @Override public Request get() throws IOException {
-        return create(args);
-      }
-    };
-  }
-
-  Request create(Object... args) throws IOException {
-    RequestBuilder requestBuilder =
-        new RequestBuilder(method, baseUrl.url(), relativeUrl, headers, contentType, hasBody,
-            isFormEncoded, isMultipart);
-
-    if (args != null) {
-      RequestAction[] actions = requestActions;
-      if (actions.length != args.length) {
-        throw new IllegalArgumentException("Argument count ("
-            + args.length
-            + ") doesn't match action count ("
-            + actions.length
-            + ")");
-      }
-      for (int i = 0, count = args.length; i < count; i++) {
-        actions[i].perform(requestBuilder, args[i]);
-      }
-    }
-
-    return requestBuilder.build();
-  }
-}
diff --git a/retrofit/src/main/java/retrofit2/RequestFactoryParser.java b/retrofit/src/main/java/retrofit2/RequestFactoryParser.java
deleted file mode 100644
index db9089a3f..000000000
--- a/retrofit/src/main/java/retrofit2/RequestFactoryParser.java
+++ /dev/null
@@ -1,545 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2;
-
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.RequestBody;
-import java.lang.annotation.Annotation;
-import java.lang.reflect.Method;
-import java.lang.reflect.ParameterizedType;
-import java.lang.reflect.Type;
-import java.util.LinkedHashSet;
-import java.util.Map;
-import java.util.Set;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-import retrofit2.http.Body;
-import retrofit2.http.DELETE;
-import retrofit2.http.Field;
-import retrofit2.http.FieldMap;
-import retrofit2.http.FormUrlEncoded;
-import retrofit2.http.GET;
-import retrofit2.http.HEAD;
-import retrofit2.http.HTTP;
-import retrofit2.http.Header;
-import retrofit2.http.Headers;
-import retrofit2.http.Multipart;
-import retrofit2.http.OPTIONS;
-import retrofit2.http.PATCH;
-import retrofit2.http.POST;
-import retrofit2.http.PUT;
-import retrofit2.http.Part;
-import retrofit2.http.PartMap;
-import retrofit2.http.Path;
-import retrofit2.http.Query;
-import retrofit2.http.QueryMap;
-import retrofit2.http.Url;
-
-import static retrofit2.Utils.methodError;
-
-final class RequestFactoryParser {
-  // Upper and lower characters, digits, underscores, and hyphens, starting with a character.
-  private static final String PARAM = "[a-zA-Z][a-zA-Z0-9_-]*";
-  private static final Pattern PARAM_NAME_REGEX = Pattern.compile(PARAM);
-  private static final Pattern PARAM_URL_REGEX = Pattern.compile("\\{(" + PARAM + ")\\}");
-
-  static RequestFactory parse(Method method, Type responseType, Retrofit retrofit) {
-    RequestFactoryParser parser = new RequestFactoryParser(method);
-    parser.parseMethodAnnotations(responseType);
-    parser.parseParameters(retrofit);
-    return parser.toRequestFactory(retrofit.baseUrl());
-  }
-
-  private final Method method;
-
-  private String httpMethod;
-  private boolean hasBody;
-  private boolean isFormEncoded;
-  private boolean isMultipart;
-  private String relativeUrl;
-  private com.squareup.okhttp.Headers headers;
-  private MediaType contentType;
-  private RequestAction[] requestActions;
-
-  private Set<String> relativeUrlParamNames;
-
-  private RequestFactoryParser(Method method) {
-    this.method = method;
-  }
-
-  private RequestFactory toRequestFactory(BaseUrl baseUrl) {
-    return new RequestFactory(httpMethod, baseUrl, relativeUrl, headers, contentType, hasBody,
-        isFormEncoded, isMultipart, requestActions);
-  }
-
-  private RuntimeException parameterError(Throwable cause, int index, String message,
-      Object... args) {
-    return methodError(cause, method, message + " (parameter #" + (index + 1) + ")", args);
-  }
-
-  private RuntimeException parameterError(int index, String message, Object... args) {
-    return methodError(method, message + " (parameter #" + (index + 1) + ")", args);
-  }
-
-  private void parseMethodAnnotations(Type responseType) {
-    for (Annotation annotation : method.getAnnotations()) {
-      if (annotation instanceof DELETE) {
-        parseHttpMethodAndPath("DELETE", ((DELETE) annotation).value(), false);
-      } else if (annotation instanceof GET) {
-        parseHttpMethodAndPath("GET", ((GET) annotation).value(), false);
-      } else if (annotation instanceof HEAD) {
-        parseHttpMethodAndPath("HEAD", ((HEAD) annotation).value(), false);
-        if (!Void.class.equals(responseType)) {
-          throw methodError(method, "HEAD method must use Void as response type.");
-        }
-      } else if (annotation instanceof PATCH) {
-        parseHttpMethodAndPath("PATCH", ((PATCH) annotation).value(), true);
-      } else if (annotation instanceof POST) {
-        parseHttpMethodAndPath("POST", ((POST) annotation).value(), true);
-      } else if (annotation instanceof PUT) {
-        parseHttpMethodAndPath("PUT", ((PUT) annotation).value(), true);
-      } else if (annotation instanceof OPTIONS) {
-        parseHttpMethodAndPath("OPTIONS", ((OPTIONS) annotation).value(), false);
-      } else if (annotation instanceof HTTP) {
-        HTTP http = (HTTP) annotation;
-        parseHttpMethodAndPath(http.method(), http.path(), http.hasBody());
-      } else if (annotation instanceof Headers) {
-        String[] headersToParse = ((Headers) annotation).value();
-        if (headersToParse.length == 0) {
-          throw methodError(method, "@Headers annotation is empty.");
-        }
-        headers = parseHeaders(headersToParse);
-      } else if (annotation instanceof Multipart) {
-        if (isFormEncoded) {
-          throw methodError(method, "Only one encoding annotation is allowed.");
-        }
-        isMultipart = true;
-      } else if (annotation instanceof FormUrlEncoded) {
-        if (isMultipart) {
-          throw methodError(method, "Only one encoding annotation is allowed.");
-        }
-        isFormEncoded = true;
-      }
-    }
-
-    if (httpMethod == null) {
-      throw methodError(method, "HTTP method annotation is required (e.g., @GET, @POST, etc.).");
-    }
-    if (!hasBody) {
-      if (isMultipart) {
-        throw methodError(method,
-            "Multipart can only be specified on HTTP methods with request body (e.g., @POST).");
-      }
-      if (isFormEncoded) {
-        throw methodError(method,
-            "FormUrlEncoded can only be specified on HTTP methods with request body "
-                + "(e.g., @POST).");
-      }
-    }
-  }
-
-  private void parseHttpMethodAndPath(String httpMethod, String value, boolean hasBody) {
-    if (this.httpMethod != null) {
-      throw methodError(method, "Only one HTTP method is allowed. Found: %s and %s.",
-          this.httpMethod, httpMethod);
-    }
-    this.httpMethod = httpMethod;
-    this.hasBody = hasBody;
-
-    if (value.isEmpty()) {
-      return;
-    }
-
-    // Get the relative URL path and existing query string, if present.
-    int question = value.indexOf('?');
-    if (question != -1 && question < value.length() - 1) {
-      // Ensure the query string does not have any named parameters.
-      String queryParams = value.substring(question + 1);
-      Matcher queryParamMatcher = PARAM_URL_REGEX.matcher(queryParams);
-      if (queryParamMatcher.find()) {
-        throw methodError(method, "URL query string \"%s\" must not have replace block. "
-            + "For dynamic query parameters use @Query.", queryParams);
-      }
-    }
-
-    this.relativeUrl = value;
-    this.relativeUrlParamNames = parsePathParameters(value);
-  }
-
-  private com.squareup.okhttp.Headers parseHeaders(String[] headers) {
-    com.squareup.okhttp.Headers.Builder builder = new com.squareup.okhttp.Headers.Builder();
-    for (String header : headers) {
-      int colon = header.indexOf(':');
-      if (colon == -1 || colon == 0 || colon == header.length() - 1) {
-        throw methodError(method,
-            "@Headers value must be in the form \"Name: Value\". Found: \"%s\"", header);
-      }
-      String headerName = header.substring(0, colon);
-      String headerValue = header.substring(colon + 1).trim();
-      if ("Content-Type".equalsIgnoreCase(headerName)) {
-        contentType = MediaType.parse(headerValue);
-      } else {
-        builder.add(headerName, headerValue);
-      }
-    }
-    return builder.build();
-  }
-
-  private void parseParameters(Retrofit retrofit) {
-    Type[] methodParameterTypes = method.getGenericParameterTypes();
-    Annotation[][] methodParameterAnnotationArrays = method.getParameterAnnotations();
-
-    boolean gotField = false;
-    boolean gotPart = false;
-    boolean gotBody = false;
-    boolean gotPath = false;
-    boolean gotQuery = false;
-    boolean gotUrl = false;
-
-    int count = methodParameterAnnotationArrays.length;
-    RequestAction[] requestActions = new RequestAction[count];
-    for (int i = 0; i < count; i++) {
-      Type methodParameterType = methodParameterTypes[i];
-      if (Utils.hasUnresolvableType(methodParameterType)) {
-        throw parameterError(i, "Parameter type must not include a type variable or wildcard: %s",
-            methodParameterType);
-      }
-
-      Annotation[] methodParameterAnnotations = methodParameterAnnotationArrays[i];
-      if (methodParameterAnnotations != null) {
-        for (Annotation methodParameterAnnotation : methodParameterAnnotations) {
-          RequestAction action = null;
-          if (methodParameterAnnotation instanceof Url) {
-            if (gotUrl) {
-              throw parameterError(i, "Multiple @Url method annotations found.");
-            }
-            if (gotPath) {
-              throw parameterError(i, "@Path parameters may not be used with @Url.");
-            }
-            if (gotQuery) {
-              throw parameterError(i, "A @Url parameter must not come after a @Query");
-            }
-            if (methodParameterType != String.class) {
-              throw parameterError(i, "@Url must be String type.");
-            }
-            if (relativeUrl != null) {
-              throw parameterError(i, "@Url cannot be used with @%s URL", httpMethod);
-            }
-            gotUrl = true;
-            action = new RequestAction.Url();
-
-          } else if (methodParameterAnnotation instanceof Path) {
-            if (gotQuery) {
-              throw parameterError(i, "A @Path parameter must not come after a @Query.");
-            }
-            if (gotUrl) {
-              throw parameterError(i, "@Path parameters may not be used with @Url.");
-            }
-            if (relativeUrl == null) {
-              throw parameterError(i, "@Path can only be used with relative url on @%s",
-                  httpMethod);
-            }
-            gotPath = true;
-
-            Path path = (Path) methodParameterAnnotation;
-            String name = path.value();
-            validatePathName(i, name);
-
-            Converter<?, String> valueConverter =
-                retrofit.stringConverter(methodParameterType, methodParameterAnnotations);
-            action = new RequestAction.Path<>(name, valueConverter, path.encoded());
-
-          } else if (methodParameterAnnotation instanceof Query) {
-            Query query = (Query) methodParameterAnnotation;
-            String name = query.value();
-            boolean encoded = query.encoded();
-
-            Class<?> rawParameterType = Utils.getRawType(methodParameterType);
-            if (Iterable.class.isAssignableFrom(rawParameterType)) {
-              if (!(methodParameterType instanceof ParameterizedType)) {
-                throw parameterError(i, rawParameterType.getSimpleName()
-                    + " must include generic type (e.g., "
-                    + rawParameterType.getSimpleName()
-                    + "<String>)");
-              }
-              ParameterizedType parameterizedType = (ParameterizedType) methodParameterType;
-              Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
-              Converter<?, String> valueConverter =
-                  retrofit.stringConverter(iterableType, methodParameterAnnotations);
-              action = new RequestAction.Query<>(name, valueConverter, encoded).iterable();
-            } else if (rawParameterType.isArray()) {
-              Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
-              Converter<?, String> valueConverter =
-                  retrofit.stringConverter(arrayComponentType, methodParameterAnnotations);
-              action = new RequestAction.Query<>(name, valueConverter, encoded).array();
-            } else {
-              Converter<?, String> valueConverter =
-                  retrofit.stringConverter(methodParameterType, methodParameterAnnotations);
-              action = new RequestAction.Query<>(name, valueConverter, encoded);
-            }
-
-            gotQuery = true;
-
-          } else if (methodParameterAnnotation instanceof QueryMap) {
-            if (!Map.class.isAssignableFrom(Utils.getRawType(methodParameterType))) {
-              throw parameterError(i, "@QueryMap parameter type must be Map.");
-            }
-            if (!(methodParameterType instanceof ParameterizedType)) {
-              throw parameterError(i, "Map must include generic types (e.g., Map<String, String>)");
-            }
-            ParameterizedType parameterizedType = (ParameterizedType) methodParameterType;
-            Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
-            if (String.class != keyType) {
-              throw parameterError(i, "@QueryMap keys must be of type String: " + keyType);
-            }
-            Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
-            Converter<?, String> valueConverter =
-                retrofit.stringConverter(valueType, methodParameterAnnotations);
-
-            QueryMap queryMap = (QueryMap) methodParameterAnnotation;
-            action = new RequestAction.QueryMap<>(valueConverter, queryMap.encoded());
-
-          } else if (methodParameterAnnotation instanceof Header) {
-            Header header = (Header) methodParameterAnnotation;
-            String name = header.value();
-
-            Class<?> rawParameterType = Utils.getRawType(methodParameterType);
-            if (Iterable.class.isAssignableFrom(rawParameterType)) {
-              if (!(methodParameterType instanceof ParameterizedType)) {
-                throw parameterError(i, rawParameterType.getSimpleName()
-                    + " must include generic type (e.g., "
-                    + rawParameterType.getSimpleName()
-                    + "<String>)");
-              }
-              ParameterizedType parameterizedType = (ParameterizedType) methodParameterType;
-              Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
-              Converter<?, String> valueConverter =
-                  retrofit.stringConverter(iterableType, methodParameterAnnotations);
-              action = new RequestAction.Header<>(name, valueConverter).iterable();
-            } else if (rawParameterType.isArray()) {
-              Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
-              Converter<?, String> valueConverter =
-                  retrofit.stringConverter(arrayComponentType, methodParameterAnnotations);
-              action = new RequestAction.Header<>(name, valueConverter).array();
-            } else {
-              Converter<?, String> valueConverter =
-                  retrofit.stringConverter(methodParameterType, methodParameterAnnotations);
-              action = new RequestAction.Header<>(name, valueConverter);
-            }
-
-          } else if (methodParameterAnnotation instanceof Field) {
-            if (!isFormEncoded) {
-              throw parameterError(i, "@Field parameters can only be used with form encoding.");
-            }
-            Field field = (Field) methodParameterAnnotation;
-            String name = field.value();
-            boolean encoded = field.encoded();
-
-            Class<?> rawParameterType = Utils.getRawType(methodParameterType);
-            if (Iterable.class.isAssignableFrom(rawParameterType)) {
-              if (!(methodParameterType instanceof ParameterizedType)) {
-                throw parameterError(i, rawParameterType.getSimpleName()
-                    + " must include generic type (e.g., "
-                    + rawParameterType.getSimpleName()
-                    + "<String>)");
-              }
-              ParameterizedType parameterizedType = (ParameterizedType) methodParameterType;
-              Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
-              Converter<?, String> valueConverter =
-                  retrofit.stringConverter(iterableType, methodParameterAnnotations);
-              action = new RequestAction.Field<>(name, valueConverter, encoded).iterable();
-            } else if (rawParameterType.isArray()) {
-              Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
-              Converter<?, String> valueConverter =
-                  retrofit.stringConverter(arrayComponentType, methodParameterAnnotations);
-              action = new RequestAction.Field<>(name, valueConverter, encoded).array();
-            } else {
-              Converter<?, String> valueConverter =
-                  retrofit.stringConverter(methodParameterType, methodParameterAnnotations);
-              action = new RequestAction.Field<>(name, valueConverter, encoded);
-            }
-
-            gotField = true;
-
-          } else if (methodParameterAnnotation instanceof FieldMap) {
-            if (!isFormEncoded) {
-              throw parameterError(i, "@FieldMap parameters can only be used with form encoding.");
-            }
-            if (!Map.class.isAssignableFrom(Utils.getRawType(methodParameterType))) {
-              throw parameterError(i, "@FieldMap parameter type must be Map.");
-            }
-            if (!(methodParameterType instanceof ParameterizedType)) {
-              throw parameterError(i, "Map must include generic types (e.g., Map<String, String>)");
-            }
-            ParameterizedType parameterizedType = (ParameterizedType) methodParameterType;
-            Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
-            if (String.class != keyType) {
-              throw parameterError(i, "@FieldMap keys must be of type String: " + keyType);
-            }
-            Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
-            Converter<?, String> valueConverter =
-                retrofit.stringConverter(valueType, methodParameterAnnotations);
-
-            FieldMap fieldMap = (FieldMap) methodParameterAnnotation;
-            action = new RequestAction.FieldMap<>(valueConverter, fieldMap.encoded());
-            gotField = true;
-
-          } else if (methodParameterAnnotation instanceof Part) {
-            if (!isMultipart) {
-              throw parameterError(i, "@Part parameters can only be used with multipart encoding.");
-            }
-            Part part = (Part) methodParameterAnnotation;
-            com.squareup.okhttp.Headers headers = com.squareup.okhttp.Headers.of(
-                "Content-Disposition", "form-data; name=\"" + part.value() + "\"",
-                "Content-Transfer-Encoding", part.encoding());
-
-            Class<?> rawParameterType = Utils.getRawType(methodParameterType);
-            if (Iterable.class.isAssignableFrom(rawParameterType)) {
-              if (!(methodParameterType instanceof ParameterizedType)) {
-                throw parameterError(i, rawParameterType.getSimpleName()
-                    + " must include generic type (e.g., "
-                    + rawParameterType.getSimpleName()
-                    + "<String>)");
-              }
-              ParameterizedType parameterizedType = (ParameterizedType) methodParameterType;
-              Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
-              Converter<?, RequestBody> valueConverter =
-                  retrofit.requestBodyConverter(iterableType, methodParameterAnnotations);
-              action = new RequestAction.Part<>(headers, valueConverter).iterable();
-            } else if (rawParameterType.isArray()) {
-              Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
-              Converter<?, RequestBody> valueConverter =
-                  retrofit.requestBodyConverter(arrayComponentType, methodParameterAnnotations);
-              action = new RequestAction.Part<>(headers, valueConverter).array();
-            } else {
-              Converter<?, RequestBody> valueConverter =
-                  retrofit.requestBodyConverter(methodParameterType, methodParameterAnnotations);
-              action = new RequestAction.Part<>(headers, valueConverter);
-            }
-
-            gotPart = true;
-
-          } else if (methodParameterAnnotation instanceof PartMap) {
-            if (!isMultipart) {
-              throw parameterError(i,
-                  "@PartMap parameters can only be used with multipart encoding.");
-            }
-            if (!Map.class.isAssignableFrom(Utils.getRawType(methodParameterType))) {
-              throw parameterError(i, "@PartMap parameter type must be Map.");
-            }
-            if (!(methodParameterType instanceof ParameterizedType)) {
-              throw parameterError(i, "Map must include generic types (e.g., Map<String, String>)");
-            }
-            ParameterizedType parameterizedType = (ParameterizedType) methodParameterType;
-            Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
-            if (String.class != keyType) {
-              throw parameterError(i, "@PartMap keys must be of type String: " + keyType);
-            }
-            Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
-            Converter<?, RequestBody> valueConverter =
-                retrofit.requestBodyConverter(valueType, methodParameterAnnotations);
-
-            PartMap partMap = (PartMap) methodParameterAnnotation;
-            action = new RequestAction.PartMap<>(valueConverter, partMap.encoding());
-            gotPart = true;
-
-          } else if (methodParameterAnnotation instanceof Body) {
-            if (isFormEncoded || isMultipart) {
-              throw parameterError(i,
-                  "@Body parameters cannot be used with form or multi-part encoding.");
-            }
-            if (gotBody) {
-              throw parameterError(i, "Multiple @Body method annotations found.");
-            }
-
-            Converter<?, RequestBody> converter;
-            try {
-              converter =
-                  retrofit.requestBodyConverter(methodParameterType, methodParameterAnnotations);
-            } catch (RuntimeException e) { // Wide exception range because factories are user code.
-              throw parameterError(e, i, "Unable to create @Body converter for %s",
-                  methodParameterType);
-            }
-            action = new RequestAction.Body<>(converter);
-            gotBody = true;
-          }
-
-          if (action != null) {
-            if (requestActions[i] != null) {
-              throw parameterError(i, "Multiple Retrofit annotations found, only one allowed.");
-            }
-            requestActions[i] = action;
-          }
-        }
-      }
-
-      if (requestActions[i] == null) {
-        throw parameterError(i, "No Retrofit annotation found.");
-      }
-    }
-
-    if (relativeUrl == null && !gotUrl) {
-      throw methodError(method, "Missing either @%s URL or @Url parameter.", httpMethod);
-    }
-    if (!isFormEncoded && !isMultipart && !hasBody && gotBody) {
-      throw methodError(method, "Non-body HTTP method cannot contain @Body.");
-    }
-    if (isFormEncoded && !gotField) {
-      throw methodError(method, "Form-encoded method must contain at least one @Field.");
-    }
-    if (isMultipart && !gotPart) {
-      throw methodError(method, "Multipart method must contain at least one @Part.");
-    }
-
-    this.requestActions = requestActions;
-  }
-
-  private void validatePathName(int index, String name) {
-    if (!PARAM_NAME_REGEX.matcher(name).matches()) {
-      throw parameterError(index, "@Path parameter name must match %s. Found: %s",
-          PARAM_URL_REGEX.pattern(), name);
-    }
-    // Verify URL replacement name is actually present in the URL path.
-    if (!relativeUrlParamNames.contains(name)) {
-      throw parameterError(index, "URL \"%s\" does not contain \"{%s}\".", relativeUrl, name);
-    }
-  }
-
-  /**
-   * Gets the set of unique path parameters used in the given URI. If a parameter is used twice
-   * in the URI, it will only show up once in the set.
-   */
-  static Set<String> parsePathParameters(String path) {
-    Matcher m = PARAM_URL_REGEX.matcher(path);
-    Set<String> patterns = new LinkedHashSet<>();
-    while (m.find()) {
-      patterns.add(m.group(1));
-    }
-    return patterns;
-  }
-
-  private static Class<?> boxIfPrimitive(Class<?> type) {
-    if (boolean.class == type) return Boolean.class;
-    if (byte.class == type) return Byte.class;
-    if (char.class == type) return Character.class;
-    if (double.class == type) return Double.class;
-    if (float.class == type) return Float.class;
-    if (int.class == type) return Integer.class;
-    if (long.class == type) return Long.class;
-    if (short.class == type) return Short.class;
-    return type;
-  }
-}
diff --git a/retrofit/src/main/java/retrofit2/Response.java b/retrofit/src/main/java/retrofit2/Response.java
index 276a57b78..0f23bd4da 100644
--- a/retrofit/src/main/java/retrofit2/Response.java
+++ b/retrofit/src/main/java/retrofit2/Response.java
@@ -15,19 +15,38 @@
  */
 package retrofit2;
 
-import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.Protocol;
-import com.squareup.okhttp.ResponseBody;
+import javax.annotation.Nullable;
+import okhttp3.Headers;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.ResponseBody;
+
+import static retrofit2.Utils.checkNotNull;
 
 /** An HTTP response. */
 public final class Response<T> {
   /** Create a synthetic successful response with {@code body} as the deserialized body. */
-  public static <T> Response<T> success(T body) {
-    return success(body, new com.squareup.okhttp.Response.Builder() //
+  public static <T> Response<T> success(@Nullable T body) {
+    return success(body, new okhttp3.Response.Builder() //
         .code(200)
         .message("OK")
         .protocol(Protocol.HTTP_1_1)
-        .request(new com.squareup.okhttp.Request.Builder().url("http://localhost").build())
+        .request(new Request.Builder().url("http://localhost/").build())
+        .build());
+  }
+
+  /**
+   * Create a synthetic successful response using {@code headers} with {@code body} as the
+   * deserialized body.
+   */
+  public static <T> Response<T> success(@Nullable T body, Headers headers) {
+    checkNotNull(headers, "headers == null");
+    return success(body, new okhttp3.Response.Builder() //
+        .code(200)
+        .message("OK")
+        .protocol(Protocol.HTTP_1_1)
+        .headers(headers)
+        .request(new Request.Builder().url("http://localhost/").build())
         .build());
   }
 
@@ -35,8 +54,8 @@
    * Create a successful response from {@code rawResponse} with {@code body} as the deserialized
    * body.
    */
-  public static <T> Response<T> success(T body, com.squareup.okhttp.Response rawResponse) {
-    if (rawResponse == null) throw new NullPointerException("rawResponse == null");
+  public static <T> Response<T> success(@Nullable T body, okhttp3.Response rawResponse) {
+    checkNotNull(rawResponse, "rawResponse == null");
     if (!rawResponse.isSuccessful()) {
       throw new IllegalArgumentException("rawResponse must be successful response");
     }
@@ -49,35 +68,37 @@
    */
   public static <T> Response<T> error(int code, ResponseBody body) {
     if (code < 400) throw new IllegalArgumentException("code < 400: " + code);
-    return error(body, new com.squareup.okhttp.Response.Builder() //
+    return error(body, new okhttp3.Response.Builder() //
         .code(code)
+        .message("Response.error()")
         .protocol(Protocol.HTTP_1_1)
-        .request(new com.squareup.okhttp.Request.Builder().url("http://localhost").build())
+        .request(new Request.Builder().url("http://localhost/").build())
         .build());
   }
 
   /** Create an error response from {@code rawResponse} with {@code body} as the error body. */
-  public static <T> Response<T> error(ResponseBody body, com.squareup.okhttp.Response rawResponse) {
-    if (body == null) throw new NullPointerException("body == null");
-    if (rawResponse == null) throw new NullPointerException("rawResponse == null");
+  public static <T> Response<T> error(ResponseBody body, okhttp3.Response rawResponse) {
+    checkNotNull(body, "body == null");
+    checkNotNull(rawResponse, "rawResponse == null");
     if (rawResponse.isSuccessful()) {
       throw new IllegalArgumentException("rawResponse should not be successful response");
     }
     return new Response<>(rawResponse, null, body);
   }
 
-  private final com.squareup.okhttp.Response rawResponse;
-  private final T body;
-  private final ResponseBody errorBody;
+  private final okhttp3.Response rawResponse;
+  private final @Nullable T body;
+  private final @Nullable ResponseBody errorBody;
 
-  private Response(com.squareup.okhttp.Response rawResponse, T body, ResponseBody errorBody) {
+  private Response(okhttp3.Response rawResponse, @Nullable T body,
+      @Nullable ResponseBody errorBody) {
     this.rawResponse = rawResponse;
     this.body = body;
     this.errorBody = errorBody;
   }
 
   /** The raw response from the HTTP client. */
-  public com.squareup.okhttp.Response raw() {
+  public okhttp3.Response raw() {
     return rawResponse;
   }
 
@@ -96,18 +117,22 @@ public Headers headers() {
     return rawResponse.headers();
   }
 
-  /** {@code true} if {@link #code()} is in the range [200..300). */
-  public boolean isSuccess() {
+  /** Returns true if {@link #code()} is in the range [200..300). */
+  public boolean isSuccessful() {
     return rawResponse.isSuccessful();
   }
 
-  /** The deserialized response body of a {@linkplain #isSuccess() successful} response. */
-  public T body() {
+  /** The deserialized response body of a {@linkplain #isSuccessful() successful} response. */
+  public @Nullable T body() {
     return body;
   }
 
-  /** The raw response body of an {@linkplain #isSuccess() unsuccessful} response. */
-  public ResponseBody errorBody() {
+  /** The raw response body of an {@linkplain #isSuccessful() unsuccessful} response. */
+  public @Nullable ResponseBody errorBody() {
     return errorBody;
   }
+
+  @Override public String toString() {
+    return rawResponse.toString();
+  }
 }
diff --git a/retrofit/src/main/java/retrofit2/Retrofit.java b/retrofit/src/main/java/retrofit2/Retrofit.java
index 04245106a..2f1ee2524 100644
--- a/retrofit/src/main/java/retrofit2/Retrofit.java
+++ b/retrofit/src/main/java/retrofit2/Retrofit.java
@@ -15,26 +15,27 @@
  */
 package retrofit2;
 
-import com.squareup.okhttp.HttpUrl;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.ResponseBody;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.Method;
 import java.lang.reflect.Proxy;
 import java.lang.reflect.Type;
 import java.util.ArrayList;
-import java.util.Collections;
-import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.Executor;
+import javax.annotation.Nullable;
+import okhttp3.HttpUrl;
+import okhttp3.OkHttpClient;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
 import retrofit2.http.GET;
 import retrofit2.http.HTTP;
 import retrofit2.http.Header;
 import retrofit2.http.Url;
 
+import static java.util.Collections.unmodifiableList;
 import static retrofit2.Utils.checkNotNull;
 
 /**
@@ -43,36 +44,36 @@
  * the builder} and pass your interface to {@link #create} to generate an implementation.
  * <p>
  * For example,
- * <pre>{@code
+ * <pre><code>
  * Retrofit retrofit = new Retrofit.Builder()
- *     .baseUrl("http://api.example.com")
+ *     .baseUrl("https://api.example.com/")
  *     .addConverterFactory(GsonConverterFactory.create())
  *     .build();
  *
  * MyApi api = retrofit.create(MyApi.class);
- * Response<User> user = api.getUser().execute();
- * }</pre>
+ * Response&lt;User&gt; user = api.getUser().execute();
+ * </code></pre>
  *
  * @author Bob Lee (bob@squareup.com)
  * @author Jake Wharton (jw@squareup.com)
  */
 public final class Retrofit {
-  private final Map<Method, MethodHandler> methodHandlerCache = new LinkedHashMap<>();
-
-  private final Call.Factory callFactory;
-  private final BaseUrl baseUrl;
-  private final List<Converter.Factory> converterFactories;
-  private final List<CallAdapter.Factory> adapterFactories;
-  private final Executor callbackExecutor;
-  private final boolean validateEagerly;
-
-  Retrofit(Call.Factory callFactory, BaseUrl baseUrl, List<Converter.Factory> converterFactories,
-      List<CallAdapter.Factory> adapterFactories, Executor callbackExecutor,
-      boolean validateEagerly) {
+  private final Map<Method, ServiceMethod<?, ?>> serviceMethodCache = new ConcurrentHashMap<>();
+
+  final okhttp3.Call.Factory callFactory;
+  final HttpUrl baseUrl;
+  final List<Converter.Factory> converterFactories;
+  final List<CallAdapter.Factory> callAdapterFactories;
+  final @Nullable Executor callbackExecutor;
+  final boolean validateEagerly;
+
+  Retrofit(okhttp3.Call.Factory callFactory, HttpUrl baseUrl,
+      List<Converter.Factory> converterFactories, List<CallAdapter.Factory> callAdapterFactories,
+      @Nullable Executor callbackExecutor, boolean validateEagerly) {
     this.callFactory = callFactory;
     this.baseUrl = baseUrl;
-    this.converterFactories = converterFactories;
-    this.adapterFactories = adapterFactories;
+    this.converterFactories = converterFactories; // Copy+unmodifiable at call site.
+    this.callAdapterFactories = callAdapterFactories; // Copy+unmodifiable at call site.
     this.callbackExecutor = callbackExecutor;
     this.validateEagerly = validateEagerly;
   }
@@ -102,7 +103,7 @@
    * <ul>
    * <li>{@link retrofit2.http.FormUrlEncoded @FormUrlEncoded} - Form-encoded data with key-value
    * pairs specified by the {@link retrofit2.http.Field @Field} parameter annotation.
-   * <li>{@link retrofit2.http.Multipart @Multipart} - RFC 2388-compliant multi-part data with
+   * <li>{@link retrofit2.http.Multipart @Multipart} - RFC 2388-compliant multipart data with
    * parts specified by the {@link retrofit2.http.Part @Part} parameter annotation.
    * </ul>
    * <p>
@@ -133,7 +134,7 @@
         new InvocationHandler() {
           private final Platform platform = Platform.get();
 
-          @Override public Object invoke(Object proxy, Method method, Object... args)
+          @Override public Object invoke(Object proxy, Method method, @Nullable Object[] args)
               throws Throwable {
             // If the method is a method from Object then defer to normal invocation.
             if (method.getDeclaringClass() == Object.class) {
@@ -142,7 +143,10 @@
             if (platform.isDefaultMethod(method)) {
               return platform.invokeDefaultMethod(method, service, proxy, args);
             }
-            return loadMethodHandler(method).invoke(args);
+            ServiceMethod<Object, Object> serviceMethod =
+                (ServiceMethod<Object, Object>) loadServiceMethod(method);
+            OkHttpCall<Object> okHttpCall = new OkHttpCall<>(serviceMethod, args);
+            return serviceMethod.adapt(okHttpCall);
           }
         });
   }
@@ -151,34 +155,44 @@ private void eagerlyValidateMethods(Class<?> service) {
     Platform platform = Platform.get();
     for (Method method : service.getDeclaredMethods()) {
       if (!platform.isDefaultMethod(method)) {
-        loadMethodHandler(method);
+        loadServiceMethod(method);
       }
     }
   }
 
-  MethodHandler loadMethodHandler(Method method) {
-    MethodHandler handler;
-    synchronized (methodHandlerCache) {
-      handler = methodHandlerCache.get(method);
-      if (handler == null) {
-        handler = MethodHandler.create(this, method);
-        methodHandlerCache.put(method, handler);
+  ServiceMethod<?, ?> loadServiceMethod(Method method) {
+    ServiceMethod<?, ?> result = serviceMethodCache.get(method);
+    if (result != null) return result;
+
+    synchronized (serviceMethodCache) {
+      result = serviceMethodCache.get(method);
+      if (result == null) {
+        result = new ServiceMethod.Builder<>(this, method).build();
+        serviceMethodCache.put(method, result);
       }
     }
-    return handler;
+    return result;
   }
 
-  /** The factory used to create {@link Call} instances. */
-  public Call.Factory callFactory() {
+  /**
+   * The factory used to create {@linkplain okhttp3.Call OkHttp calls} for sending a HTTP requests.
+   * Typically an instance of {@link OkHttpClient}.
+   */
+  public okhttp3.Call.Factory callFactory() {
     return callFactory;
   }
 
-  public BaseUrl baseUrl() {
+  /** The API base URL. */
+  public HttpUrl baseUrl() {
     return baseUrl;
   }
 
+  /**
+   * Returns a list of the factories tried when creating a
+   * {@linkplain #callAdapter(Type, Annotation[])} call adapter}.
+   */
   public List<CallAdapter.Factory> callAdapterFactories() {
-    return Collections.unmodifiableList(adapterFactories);
+    return callAdapterFactories;
   }
 
   /**
@@ -187,7 +201,7 @@ public BaseUrl baseUrl() {
    *
    * @throws IllegalArgumentException if no call adapter available for {@code type}.
    */
-  public CallAdapter<?> callAdapter(Type returnType, Annotation[] annotations) {
+  public CallAdapter<?, ?> callAdapter(Type returnType, Annotation[] annotations) {
     return nextCallAdapter(null, returnType, annotations);
   }
 
@@ -197,14 +211,14 @@ public BaseUrl baseUrl() {
    *
    * @throws IllegalArgumentException if no call adapter available for {@code type}.
    */
-  public CallAdapter<?> nextCallAdapter(CallAdapter.Factory skipPast, Type returnType,
+  public CallAdapter<?, ?> nextCallAdapter(@Nullable CallAdapter.Factory skipPast, Type returnType,
       Annotation[] annotations) {
     checkNotNull(returnType, "returnType == null");
     checkNotNull(annotations, "annotations == null");
 
-    int start = adapterFactories.indexOf(skipPast) + 1;
-    for (int i = start, count = adapterFactories.size(); i < count; i++) {
-      CallAdapter<?> adapter = adapterFactories.get(i).get(returnType, annotations, this);
+    int start = callAdapterFactories.indexOf(skipPast) + 1;
+    for (int i = start, count = callAdapterFactories.size(); i < count; i++) {
+      CallAdapter<?, ?> adapter = callAdapterFactories.get(i).get(returnType, annotations, this);
       if (adapter != null) {
         return adapter;
       }
@@ -212,24 +226,29 @@ public BaseUrl baseUrl() {
 
     StringBuilder builder = new StringBuilder("Could not locate call adapter for ")
         .append(returnType)
-        .append(". Tried:");
-    for (int i = start, count = adapterFactories.size(); i < count; i++) {
-      builder.append("\n * ").append(adapterFactories.get(i).getClass().getName());
-    }
+        .append(".\n");
     if (skipPast != null) {
-      builder.append("\nSkipped:");
+      builder.append("  Skipped:");
       for (int i = 0; i < start; i++) {
-        builder.append("\n * ").append(adapterFactories.get(i).getClass().getName());
+        builder.append("\n   * ").append(callAdapterFactories.get(i).getClass().getName());
       }
+      builder.append('\n');
+    }
+    builder.append("  Tried:");
+    for (int i = start, count = callAdapterFactories.size(); i < count; i++) {
+      builder.append("\n   * ").append(callAdapterFactories.get(i).getClass().getName());
     }
     throw new IllegalArgumentException(builder.toString());
   }
 
   /**
-   * TODO
+   * Returns an unmodifiable list of the factories tried when creating a
+   * {@linkplain #requestBodyConverter(Type, Annotation[], Annotation[]) request body converter}, a
+   * {@linkplain #responseBodyConverter(Type, Annotation[]) response body converter}, or a
+   * {@linkplain #stringConverter(Type, Annotation[]) string converter}.
    */
   public List<Converter.Factory> converterFactories() {
-    return Collections.unmodifiableList(converterFactories);
+    return converterFactories;
   }
 
   /**
@@ -238,8 +257,9 @@ public BaseUrl baseUrl() {
    *
    * @throws IllegalArgumentException if no converter available for {@code type}.
    */
-  public <T> Converter<T, RequestBody> requestBodyConverter(Type type, Annotation[] annotations) {
-    return nextRequestBodyConverter(null, type, annotations);
+  public <T> Converter<T, RequestBody> requestBodyConverter(Type type,
+      Annotation[] parameterAnnotations, Annotation[] methodAnnotations) {
+    return nextRequestBodyConverter(null, type, parameterAnnotations, methodAnnotations);
   }
 
   /**
@@ -248,15 +268,18 @@ public BaseUrl baseUrl() {
    *
    * @throws IllegalArgumentException if no converter available for {@code type}.
    */
-  public <T> Converter<T, RequestBody> nextRequestBodyConverter(Converter.Factory skipPast,
-      Type type, Annotation[] annotations) {
+  public <T> Converter<T, RequestBody> nextRequestBodyConverter(
+      @Nullable Converter.Factory skipPast, Type type, Annotation[] parameterAnnotations,
+      Annotation[] methodAnnotations) {
     checkNotNull(type, "type == null");
-    checkNotNull(annotations, "annotations == null");
+    checkNotNull(parameterAnnotations, "parameterAnnotations == null");
+    checkNotNull(methodAnnotations, "methodAnnotations == null");
 
     int start = converterFactories.indexOf(skipPast) + 1;
     for (int i = start, count = converterFactories.size(); i < count; i++) {
+      Converter.Factory factory = converterFactories.get(i);
       Converter<?, RequestBody> converter =
-          converterFactories.get(i).requestBodyConverter(type, annotations, this);
+          factory.requestBodyConverter(type, parameterAnnotations, methodAnnotations, this);
       if (converter != null) {
         //noinspection unchecked
         return (Converter<T, RequestBody>) converter;
@@ -265,15 +288,17 @@ public BaseUrl baseUrl() {
 
     StringBuilder builder = new StringBuilder("Could not locate RequestBody converter for ")
         .append(type)
-        .append(". Tried:");
-    for (int i = start, count = converterFactories.size(); i < count; i++) {
-      builder.append("\n * ").append(converterFactories.get(i).getClass().getName());
-    }
+        .append(".\n");
     if (skipPast != null) {
-      builder.append("\nSkipped:");
+      builder.append("  Skipped:");
       for (int i = 0; i < start; i++) {
-        builder.append("\n * ").append(adapterFactories.get(i).getClass().getName());
+        builder.append("\n   * ").append(converterFactories.get(i).getClass().getName());
       }
+      builder.append('\n');
+    }
+    builder.append("  Tried:");
+    for (int i = start, count = converterFactories.size(); i < count; i++) {
+      builder.append("\n   * ").append(converterFactories.get(i).getClass().getName());
     }
     throw new IllegalArgumentException(builder.toString());
   }
@@ -294,8 +319,8 @@ public BaseUrl baseUrl() {
    *
    * @throws IllegalArgumentException if no converter available for {@code type}.
    */
-  public <T> Converter<ResponseBody, T> nextResponseBodyConverter(Converter.Factory skipPast,
-      Type type, Annotation[] annotations) {
+  public <T> Converter<ResponseBody, T> nextResponseBodyConverter(
+      @Nullable Converter.Factory skipPast, Type type, Annotation[] annotations) {
     checkNotNull(type, "type == null");
     checkNotNull(annotations, "annotations == null");
 
@@ -311,15 +336,17 @@ public BaseUrl baseUrl() {
 
     StringBuilder builder = new StringBuilder("Could not locate ResponseBody converter for ")
         .append(type)
-        .append(". Tried:");
-    for (int i = start, count = converterFactories.size(); i < count; i++) {
-      builder.append("\n * ").append(converterFactories.get(i).getClass().getName());
-    }
+        .append(".\n");
     if (skipPast != null) {
-      builder.append("\nSkipped:");
+      builder.append("  Skipped:");
       for (int i = 0; i < start; i++) {
-        builder.append("\n * ").append(adapterFactories.get(i).getClass().getName());
+        builder.append("\n   * ").append(converterFactories.get(i).getClass().getName());
       }
+      builder.append('\n');
+    }
+    builder.append("  Tried:");
+    for (int i = start, count = converterFactories.size(); i < count; i++) {
+      builder.append("\n   * ").append(converterFactories.get(i).getClass().getName());
     }
     throw new IllegalArgumentException(builder.toString());
   }
@@ -334,7 +361,7 @@ public BaseUrl baseUrl() {
 
     for (int i = 0, count = converterFactories.size(); i < count; i++) {
       Converter<?, String> converter =
-          converterFactories.get(i).stringConverter(type, annotations);
+          converterFactories.get(i).stringConverter(type, annotations, this);
       if (converter != null) {
         //noinspection unchecked
         return (Converter<T, String>) converter;
@@ -346,11 +373,18 @@ public BaseUrl baseUrl() {
     return (Converter<T, String>) BuiltInConverters.ToStringConverter.INSTANCE;
   }
 
-  /** The executor used for {@link Callback} methods on a {@link Call}. */
-  public Executor callbackExecutor() {
+  /**
+   * The executor used for {@link Callback} methods on a {@link Call}. This may be {@code null},
+   * in which case callbacks should be made synchronously on the background thread.
+   */
+  public @Nullable Executor callbackExecutor() {
     return callbackExecutor;
   }
 
+  public Builder newBuilder() {
+    return new Builder(this);
+  }
+
   /**
    * Build a new {@link Retrofit}.
    * <p>
@@ -358,31 +392,46 @@ public Executor callbackExecutor() {
    * are optional.
    */
   public static final class Builder {
-    private Call.Factory callFactory;
-    private BaseUrl baseUrl;
-    private List<Converter.Factory> converterFactories = new ArrayList<>();
-    private List<CallAdapter.Factory> adapterFactories = new ArrayList<>();
-    private Executor callbackExecutor;
+    private final Platform platform;
+    private @Nullable okhttp3.Call.Factory callFactory;
+    private HttpUrl baseUrl;
+    private final List<Converter.Factory> converterFactories = new ArrayList<>();
+    private final List<CallAdapter.Factory> callAdapterFactories = new ArrayList<>();
+    private @Nullable Executor callbackExecutor;
     private boolean validateEagerly;
 
+    Builder(Platform platform) {
+      this.platform = platform;
+    }
+
     public Builder() {
-      // Add the built-in converter factory first. This prevents overriding its behavior but also
-      // ensures correct behavior when using converters that consume all types.
-      converterFactories.add(new BuiltInConverters());
+      this(Platform.get());
+    }
+
+    Builder(Retrofit retrofit) {
+      platform = Platform.get();
+      callFactory = retrofit.callFactory;
+      baseUrl = retrofit.baseUrl;
+
+      converterFactories.addAll(retrofit.converterFactories);
+      // Remove the default BuiltInConverters instance added by build().
+      converterFactories.remove(0);
+
+      callAdapterFactories.addAll(retrofit.callAdapterFactories);
+      // Remove the default, platform-aware call adapter added by build().
+      callAdapterFactories.remove(callAdapterFactories.size() - 1);
+
+      callbackExecutor = retrofit.callbackExecutor;
+      validateEagerly = retrofit.validateEagerly;
     }
 
     /**
      * The HTTP client used for requests.
      * <p>
-     * This is a convenience method for calling {@link #callFactory} with an instance that uses
-     * {@code client} for execution.
-     * <p>
-     * Note: This method <b>does not</b> make a defensive copy of {@code client}. Changes to its
-     * settings will affect subsequent requests. Pass in a {@linkplain OkHttpClient#clone() cloned}
-     * instance to prevent this if desired.
+     * This is a convenience method for calling {@link #callFactory}.
      */
     public Builder client(OkHttpClient client) {
-      return callFactory(new OkHttpCallFactory(checkNotNull(client, "client == null")));
+      return callFactory(checkNotNull(client, "client == null"));
     }
 
     /**
@@ -390,13 +439,13 @@ public Builder client(OkHttpClient client) {
      * <p>
      * Note: Calling {@link #client} automatically sets this value.
      */
-    public Builder callFactory(Call.Factory factory) {
+    public Builder callFactory(okhttp3.Call.Factory factory) {
       this.callFactory = checkNotNull(factory, "factory == null");
       return this;
     }
 
     /**
-     * Set a fixed API base URL.
+     * Set the API base URL.
      *
      * @see #baseUrl(HttpUrl)
      */
@@ -410,7 +459,7 @@ public Builder baseUrl(String baseUrl) {
     }
 
     /**
-     * Set a fixed API base URL.
+     * Set the API base URL.
      * <p>
      * The specified endpoint values (such as with {@link GET @GET}) are resolved against this
      * value using {@link HttpUrl#resolve(String)}. The behavior of this matches that of an
@@ -459,26 +508,13 @@ public Builder baseUrl(String baseUrl) {
      * Endpoint: //github.com/square/retrofit/<br>
      * Result: http://github.com/square/retrofit/ (note the scheme stays 'http')
      */
-    public Builder baseUrl(final HttpUrl baseUrl) {
+    public Builder baseUrl(HttpUrl baseUrl) {
       checkNotNull(baseUrl, "baseUrl == null");
       List<String> pathSegments = baseUrl.pathSegments();
       if (!"".equals(pathSegments.get(pathSegments.size() - 1))) {
         throw new IllegalArgumentException("baseUrl must end in /: " + baseUrl);
       }
-      return baseUrl(new BaseUrl() {
-        @Override public HttpUrl url() {
-          return baseUrl;
-        }
-      });
-    }
-
-    /**
-     * Set an API base URL which can change over time.
-     *
-     * @see #baseUrl(HttpUrl)
-     */
-    public Builder baseUrl(BaseUrl baseUrl) {
-      this.baseUrl = checkNotNull(baseUrl, "baseUrl == null");
+      this.baseUrl = baseUrl;
       return this;
     }
 
@@ -493,7 +529,7 @@ public Builder addConverterFactory(Converter.Factory factory) {
      * Call}.
      */
     public Builder addCallAdapterFactory(CallAdapter.Factory factory) {
-      adapterFactories.add(checkNotNull(factory, "factory == null"));
+      callAdapterFactories.add(checkNotNull(factory, "factory == null"));
       return this;
     }
 
@@ -509,6 +545,16 @@ public Builder callbackExecutor(Executor executor) {
       return this;
     }
 
+    /** Returns a modifiable list of call adapter factories. */
+    public List<CallAdapter.Factory> callAdapterFactories() {
+      return this.callAdapterFactories;
+    }
+
+    /** Returns a modifiable list of converter factories. */
+    public List<Converter.Factory> converterFactories() {
+      return this.converterFactories;
+    }
+
     /**
      * When calling {@link #create} on the resulting {@link Retrofit} instance, eagerly validate
      * the configuration of all methods in the supplied interface.
@@ -529,20 +575,31 @@ public Retrofit build() {
         throw new IllegalStateException("Base URL required.");
       }
 
-      Call.Factory callFactory = this.callFactory;
+      okhttp3.Call.Factory callFactory = this.callFactory;
       if (callFactory == null) {
-        callFactory = new OkHttpCallFactory(new OkHttpClient());
+        callFactory = new OkHttpClient();
+      }
+
+      Executor callbackExecutor = this.callbackExecutor;
+      if (callbackExecutor == null) {
+        callbackExecutor = platform.defaultCallbackExecutor();
       }
 
       // Make a defensive copy of the adapters and add the default Call adapter.
-      List<CallAdapter.Factory> adapterFactories = new ArrayList<>(this.adapterFactories);
-      adapterFactories.add(Platform.get().defaultCallAdapterFactory(callbackExecutor));
+      List<CallAdapter.Factory> callAdapterFactories = new ArrayList<>(this.callAdapterFactories);
+      callAdapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));
 
       // Make a defensive copy of the converters.
-      List<Converter.Factory> converterFactories = new ArrayList<>(this.converterFactories);
+      List<Converter.Factory> converterFactories =
+          new ArrayList<>(1 + this.converterFactories.size());
+
+      // Add the built-in converter factory first. This prevents overriding its behavior but also
+      // ensures correct behavior when using converters that consume all types.
+      converterFactories.add(new BuiltInConverters());
+      converterFactories.addAll(this.converterFactories);
 
-      return new Retrofit(callFactory, baseUrl, converterFactories, adapterFactories,
-          callbackExecutor, validateEagerly);
+      return new Retrofit(callFactory, baseUrl, unmodifiableList(converterFactories),
+          unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly);
     }
   }
 }
diff --git a/retrofit/src/main/java/retrofit2/ServiceMethod.java b/retrofit/src/main/java/retrofit2/ServiceMethod.java
new file mode 100644
index 000000000..9e718b604
--- /dev/null
+++ b/retrofit/src/main/java/retrofit2/ServiceMethod.java
@@ -0,0 +1,792 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Method;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.net.URI;
+import java.util.LinkedHashSet;
+import java.util.Map;
+import java.util.Set;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import javax.annotation.Nullable;
+import okhttp3.Headers;
+import okhttp3.HttpUrl;
+import okhttp3.MediaType;
+import okhttp3.MultipartBody;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import retrofit2.http.Body;
+import retrofit2.http.DELETE;
+import retrofit2.http.Field;
+import retrofit2.http.FieldMap;
+import retrofit2.http.FormUrlEncoded;
+import retrofit2.http.GET;
+import retrofit2.http.HEAD;
+import retrofit2.http.HTTP;
+import retrofit2.http.Header;
+import retrofit2.http.HeaderMap;
+import retrofit2.http.Multipart;
+import retrofit2.http.OPTIONS;
+import retrofit2.http.PATCH;
+import retrofit2.http.POST;
+import retrofit2.http.PUT;
+import retrofit2.http.Part;
+import retrofit2.http.PartMap;
+import retrofit2.http.Path;
+import retrofit2.http.Query;
+import retrofit2.http.QueryMap;
+import retrofit2.http.QueryName;
+import retrofit2.http.Url;
+
+/** Adapts an invocation of an interface method into an HTTP call. */
+final class ServiceMethod<R, T> {
+  // Upper and lower characters, digits, underscores, and hyphens, starting with a character.
+  static final String PARAM = "[a-zA-Z][a-zA-Z0-9_-]*";
+  static final Pattern PARAM_URL_REGEX = Pattern.compile("\\{(" + PARAM + ")\\}");
+  static final Pattern PARAM_NAME_REGEX = Pattern.compile(PARAM);
+
+  private final okhttp3.Call.Factory callFactory;
+  private final CallAdapter<R, T> callAdapter;
+
+  private final HttpUrl baseUrl;
+  private final Converter<ResponseBody, R> responseConverter;
+  private final String httpMethod;
+  private final String relativeUrl;
+  private final Headers headers;
+  private final MediaType contentType;
+  private final boolean hasBody;
+  private final boolean isFormEncoded;
+  private final boolean isMultipart;
+  private final ParameterHandler<?>[] parameterHandlers;
+
+  ServiceMethod(Builder<R, T> builder) {
+    this.callFactory = builder.retrofit.callFactory();
+    this.callAdapter = builder.callAdapter;
+    this.baseUrl = builder.retrofit.baseUrl();
+    this.responseConverter = builder.responseConverter;
+    this.httpMethod = builder.httpMethod;
+    this.relativeUrl = builder.relativeUrl;
+    this.headers = builder.headers;
+    this.contentType = builder.contentType;
+    this.hasBody = builder.hasBody;
+    this.isFormEncoded = builder.isFormEncoded;
+    this.isMultipart = builder.isMultipart;
+    this.parameterHandlers = builder.parameterHandlers;
+  }
+
+  /** Builds an HTTP request from method arguments. */
+  okhttp3.Call toCall(@Nullable Object... args) throws IOException {
+    RequestBuilder requestBuilder = new RequestBuilder(httpMethod, baseUrl, relativeUrl, headers,
+        contentType, hasBody, isFormEncoded, isMultipart);
+
+    @SuppressWarnings("unchecked") // It is an error to invoke a method with the wrong arg types.
+    ParameterHandler<Object>[] handlers = (ParameterHandler<Object>[]) parameterHandlers;
+
+    int argumentCount = args != null ? args.length : 0;
+    if (argumentCount != handlers.length) {
+      throw new IllegalArgumentException("Argument count (" + argumentCount
+          + ") doesn't match expected count (" + handlers.length + ")");
+    }
+
+    for (int p = 0; p < argumentCount; p++) {
+      handlers[p].apply(requestBuilder, args[p]);
+    }
+
+    return callFactory.newCall(requestBuilder.build());
+  }
+
+  T adapt(Call<R> call) {
+    return callAdapter.adapt(call);
+  }
+
+  /** Builds a method return value from an HTTP response body. */
+  R toResponse(ResponseBody body) throws IOException {
+    return responseConverter.convert(body);
+  }
+
+  /**
+   * Inspects the annotations on an interface method to construct a reusable service method. This
+   * requires potentially-expensive reflection so it is best to build each service method only once
+   * and reuse it. Builders cannot be reused.
+   */
+  static final class Builder<T, R> {
+    final Retrofit retrofit;
+    final Method method;
+    final Annotation[] methodAnnotations;
+    final Annotation[][] parameterAnnotationsArray;
+    final Type[] parameterTypes;
+
+    Type responseType;
+    boolean gotField;
+    boolean gotPart;
+    boolean gotBody;
+    boolean gotPath;
+    boolean gotQuery;
+    boolean gotUrl;
+    String httpMethod;
+    boolean hasBody;
+    boolean isFormEncoded;
+    boolean isMultipart;
+    String relativeUrl;
+    Headers headers;
+    MediaType contentType;
+    Set<String> relativeUrlParamNames;
+    ParameterHandler<?>[] parameterHandlers;
+    Converter<ResponseBody, T> responseConverter;
+    CallAdapter<T, R> callAdapter;
+
+    Builder(Retrofit retrofit, Method method) {
+      this.retrofit = retrofit;
+      this.method = method;
+      this.methodAnnotations = method.getAnnotations();
+      this.parameterTypes = method.getGenericParameterTypes();
+      this.parameterAnnotationsArray = method.getParameterAnnotations();
+    }
+
+    public ServiceMethod build() {
+      callAdapter = createCallAdapter();
+      responseType = callAdapter.responseType();
+      if (responseType == Response.class || responseType == okhttp3.Response.class) {
+        throw methodError("'"
+            + Utils.getRawType(responseType).getName()
+            + "' is not a valid response body type. Did you mean ResponseBody?");
+      }
+      responseConverter = createResponseConverter();
+
+      for (Annotation annotation : methodAnnotations) {
+        parseMethodAnnotation(annotation);
+      }
+
+      if (httpMethod == null) {
+        throw methodError("HTTP method annotation is required (e.g., @GET, @POST, etc.).");
+      }
+
+      if (!hasBody) {
+        if (isMultipart) {
+          throw methodError(
+              "Multipart can only be specified on HTTP methods with request body (e.g., @POST).");
+        }
+        if (isFormEncoded) {
+          throw methodError("FormUrlEncoded can only be specified on HTTP methods with "
+              + "request body (e.g., @POST).");
+        }
+      }
+
+      int parameterCount = parameterAnnotationsArray.length;
+      parameterHandlers = new ParameterHandler<?>[parameterCount];
+      for (int p = 0; p < parameterCount; p++) {
+        Type parameterType = parameterTypes[p];
+        if (Utils.hasUnresolvableType(parameterType)) {
+          throw parameterError(p, "Parameter type must not include a type variable or wildcard: %s",
+              parameterType);
+        }
+
+        Annotation[] parameterAnnotations = parameterAnnotationsArray[p];
+        if (parameterAnnotations == null) {
+          throw parameterError(p, "No Retrofit annotation found.");
+        }
+
+        parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);
+      }
+
+      if (relativeUrl == null && !gotUrl) {
+        throw methodError("Missing either @%s URL or @Url parameter.", httpMethod);
+      }
+      if (!isFormEncoded && !isMultipart && !hasBody && gotBody) {
+        throw methodError("Non-body HTTP method cannot contain @Body.");
+      }
+      if (isFormEncoded && !gotField) {
+        throw methodError("Form-encoded method must contain at least one @Field.");
+      }
+      if (isMultipart && !gotPart) {
+        throw methodError("Multipart method must contain at least one @Part.");
+      }
+
+      return new ServiceMethod<>(this);
+    }
+
+    private CallAdapter<T, R> createCallAdapter() {
+      Type returnType = method.getGenericReturnType();
+      if (Utils.hasUnresolvableType(returnType)) {
+        throw methodError(
+            "Method return type must not include a type variable or wildcard: %s", returnType);
+      }
+      if (returnType == void.class) {
+        throw methodError("Service methods cannot return void.");
+      }
+      Annotation[] annotations = method.getAnnotations();
+      try {
+        //noinspection unchecked
+        return (CallAdapter<T, R>) retrofit.callAdapter(returnType, annotations);
+      } catch (RuntimeException e) { // Wide exception range because factories are user code.
+        throw methodError(e, "Unable to create call adapter for %s", returnType);
+      }
+    }
+
+    private void parseMethodAnnotation(Annotation annotation) {
+      if (annotation instanceof DELETE) {
+        parseHttpMethodAndPath("DELETE", ((DELETE) annotation).value(), false);
+      } else if (annotation instanceof GET) {
+        parseHttpMethodAndPath("GET", ((GET) annotation).value(), false);
+      } else if (annotation instanceof HEAD) {
+        parseHttpMethodAndPath("HEAD", ((HEAD) annotation).value(), false);
+        if (!Void.class.equals(responseType)) {
+          throw methodError("HEAD method must use Void as response type.");
+        }
+      } else if (annotation instanceof PATCH) {
+        parseHttpMethodAndPath("PATCH", ((PATCH) annotation).value(), true);
+      } else if (annotation instanceof POST) {
+        parseHttpMethodAndPath("POST", ((POST) annotation).value(), true);
+      } else if (annotation instanceof PUT) {
+        parseHttpMethodAndPath("PUT", ((PUT) annotation).value(), true);
+      } else if (annotation instanceof OPTIONS) {
+        parseHttpMethodAndPath("OPTIONS", ((OPTIONS) annotation).value(), false);
+      } else if (annotation instanceof HTTP) {
+        HTTP http = (HTTP) annotation;
+        parseHttpMethodAndPath(http.method(), http.path(), http.hasBody());
+      } else if (annotation instanceof retrofit2.http.Headers) {
+        String[] headersToParse = ((retrofit2.http.Headers) annotation).value();
+        if (headersToParse.length == 0) {
+          throw methodError("@Headers annotation is empty.");
+        }
+        headers = parseHeaders(headersToParse);
+      } else if (annotation instanceof Multipart) {
+        if (isFormEncoded) {
+          throw methodError("Only one encoding annotation is allowed.");
+        }
+        isMultipart = true;
+      } else if (annotation instanceof FormUrlEncoded) {
+        if (isMultipart) {
+          throw methodError("Only one encoding annotation is allowed.");
+        }
+        isFormEncoded = true;
+      }
+    }
+
+    private void parseHttpMethodAndPath(String httpMethod, String value, boolean hasBody) {
+      if (this.httpMethod != null) {
+        throw methodError("Only one HTTP method is allowed. Found: %s and %s.",
+            this.httpMethod, httpMethod);
+      }
+      this.httpMethod = httpMethod;
+      this.hasBody = hasBody;
+
+      if (value.isEmpty()) {
+        return;
+      }
+
+      // Get the relative URL path and existing query string, if present.
+      int question = value.indexOf('?');
+      if (question != -1 && question < value.length() - 1) {
+        // Ensure the query string does not have any named parameters.
+        String queryParams = value.substring(question + 1);
+        Matcher queryParamMatcher = PARAM_URL_REGEX.matcher(queryParams);
+        if (queryParamMatcher.find()) {
+          throw methodError("URL query string \"%s\" must not have replace block. "
+              + "For dynamic query parameters use @Query.", queryParams);
+        }
+      }
+
+      this.relativeUrl = value;
+      this.relativeUrlParamNames = parsePathParameters(value);
+    }
+
+    private Headers parseHeaders(String[] headers) {
+      Headers.Builder builder = new Headers.Builder();
+      for (String header : headers) {
+        int colon = header.indexOf(':');
+        if (colon == -1 || colon == 0 || colon == header.length() - 1) {
+          throw methodError(
+              "@Headers value must be in the form \"Name: Value\". Found: \"%s\"", header);
+        }
+        String headerName = header.substring(0, colon);
+        String headerValue = header.substring(colon + 1).trim();
+        if ("Content-Type".equalsIgnoreCase(headerName)) {
+          MediaType type = MediaType.parse(headerValue);
+          if (type == null) {
+            throw methodError("Malformed content type: %s", headerValue);
+          }
+          contentType = type;
+        } else {
+          builder.add(headerName, headerValue);
+        }
+      }
+      return builder.build();
+    }
+
+    private ParameterHandler<?> parseParameter(
+        int p, Type parameterType, Annotation[] annotations) {
+      ParameterHandler<?> result = null;
+      for (Annotation annotation : annotations) {
+        ParameterHandler<?> annotationAction = parseParameterAnnotation(
+            p, parameterType, annotations, annotation);
+
+        if (annotationAction == null) {
+          continue;
+        }
+
+        if (result != null) {
+          throw parameterError(p, "Multiple Retrofit annotations found, only one allowed.");
+        }
+
+        result = annotationAction;
+      }
+
+      if (result == null) {
+        throw parameterError(p, "No Retrofit annotation found.");
+      }
+
+      return result;
+    }
+
+    private ParameterHandler<?> parseParameterAnnotation(
+        int p, Type type, Annotation[] annotations, Annotation annotation) {
+      if (annotation instanceof Url) {
+        if (gotUrl) {
+          throw parameterError(p, "Multiple @Url method annotations found.");
+        }
+        if (gotPath) {
+          throw parameterError(p, "@Path parameters may not be used with @Url.");
+        }
+        if (gotQuery) {
+          throw parameterError(p, "A @Url parameter must not come after a @Query");
+        }
+        if (relativeUrl != null) {
+          throw parameterError(p, "@Url cannot be used with @%s URL", httpMethod);
+        }
+
+        gotUrl = true;
+
+        if (type == HttpUrl.class
+            || type == String.class
+            || type == URI.class
+            || (type instanceof Class && "android.net.Uri".equals(((Class<?>) type).getName()))) {
+          return new ParameterHandler.RelativeUrl();
+        } else {
+          throw parameterError(p,
+              "@Url must be okhttp3.HttpUrl, String, java.net.URI, or android.net.Uri type.");
+        }
+
+      } else if (annotation instanceof Path) {
+        if (gotQuery) {
+          throw parameterError(p, "A @Path parameter must not come after a @Query.");
+        }
+        if (gotUrl) {
+          throw parameterError(p, "@Path parameters may not be used with @Url.");
+        }
+        if (relativeUrl == null) {
+          throw parameterError(p, "@Path can only be used with relative url on @%s", httpMethod);
+        }
+        gotPath = true;
+
+        Path path = (Path) annotation;
+        String name = path.value();
+        validatePathName(p, name);
+
+        Converter<?, String> converter = retrofit.stringConverter(type, annotations);
+        return new ParameterHandler.Path<>(name, converter, path.encoded());
+
+      } else if (annotation instanceof Query) {
+        Query query = (Query) annotation;
+        String name = query.value();
+        boolean encoded = query.encoded();
+
+        Class<?> rawParameterType = Utils.getRawType(type);
+        gotQuery = true;
+        if (Iterable.class.isAssignableFrom(rawParameterType)) {
+          if (!(type instanceof ParameterizedType)) {
+            throw parameterError(p, rawParameterType.getSimpleName()
+                + " must include generic type (e.g., "
+                + rawParameterType.getSimpleName()
+                + "<String>)");
+          }
+          ParameterizedType parameterizedType = (ParameterizedType) type;
+          Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
+          Converter<?, String> converter =
+              retrofit.stringConverter(iterableType, annotations);
+          return new ParameterHandler.Query<>(name, converter, encoded).iterable();
+        } else if (rawParameterType.isArray()) {
+          Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
+          Converter<?, String> converter =
+              retrofit.stringConverter(arrayComponentType, annotations);
+          return new ParameterHandler.Query<>(name, converter, encoded).array();
+        } else {
+          Converter<?, String> converter =
+              retrofit.stringConverter(type, annotations);
+          return new ParameterHandler.Query<>(name, converter, encoded);
+        }
+
+      } else if (annotation instanceof QueryName) {
+        QueryName query = (QueryName) annotation;
+        boolean encoded = query.encoded();
+
+        Class<?> rawParameterType = Utils.getRawType(type);
+        gotQuery = true;
+        if (Iterable.class.isAssignableFrom(rawParameterType)) {
+          if (!(type instanceof ParameterizedType)) {
+            throw parameterError(p, rawParameterType.getSimpleName()
+                + " must include generic type (e.g., "
+                + rawParameterType.getSimpleName()
+                + "<String>)");
+          }
+          ParameterizedType parameterizedType = (ParameterizedType) type;
+          Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
+          Converter<?, String> converter =
+              retrofit.stringConverter(iterableType, annotations);
+          return new ParameterHandler.QueryName<>(converter, encoded).iterable();
+        } else if (rawParameterType.isArray()) {
+          Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
+          Converter<?, String> converter =
+              retrofit.stringConverter(arrayComponentType, annotations);
+          return new ParameterHandler.QueryName<>(converter, encoded).array();
+        } else {
+          Converter<?, String> converter =
+              retrofit.stringConverter(type, annotations);
+          return new ParameterHandler.QueryName<>(converter, encoded);
+        }
+
+      } else if (annotation instanceof QueryMap) {
+        Class<?> rawParameterType = Utils.getRawType(type);
+        if (!Map.class.isAssignableFrom(rawParameterType)) {
+          throw parameterError(p, "@QueryMap parameter type must be Map.");
+        }
+        Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
+        if (!(mapType instanceof ParameterizedType)) {
+          throw parameterError(p, "Map must include generic types (e.g., Map<String, String>)");
+        }
+        ParameterizedType parameterizedType = (ParameterizedType) mapType;
+        Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
+        if (String.class != keyType) {
+          throw parameterError(p, "@QueryMap keys must be of type String: " + keyType);
+        }
+        Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
+        Converter<?, String> valueConverter =
+            retrofit.stringConverter(valueType, annotations);
+
+        return new ParameterHandler.QueryMap<>(valueConverter, ((QueryMap) annotation).encoded());
+
+      } else if (annotation instanceof Header) {
+        Header header = (Header) annotation;
+        String name = header.value();
+
+        Class<?> rawParameterType = Utils.getRawType(type);
+        if (Iterable.class.isAssignableFrom(rawParameterType)) {
+          if (!(type instanceof ParameterizedType)) {
+            throw parameterError(p, rawParameterType.getSimpleName()
+                + " must include generic type (e.g., "
+                + rawParameterType.getSimpleName()
+                + "<String>)");
+          }
+          ParameterizedType parameterizedType = (ParameterizedType) type;
+          Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
+          Converter<?, String> converter =
+              retrofit.stringConverter(iterableType, annotations);
+          return new ParameterHandler.Header<>(name, converter).iterable();
+        } else if (rawParameterType.isArray()) {
+          Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
+          Converter<?, String> converter =
+              retrofit.stringConverter(arrayComponentType, annotations);
+          return new ParameterHandler.Header<>(name, converter).array();
+        } else {
+          Converter<?, String> converter =
+              retrofit.stringConverter(type, annotations);
+          return new ParameterHandler.Header<>(name, converter);
+        }
+
+      } else if (annotation instanceof HeaderMap) {
+        Class<?> rawParameterType = Utils.getRawType(type);
+        if (!Map.class.isAssignableFrom(rawParameterType)) {
+          throw parameterError(p, "@HeaderMap parameter type must be Map.");
+        }
+        Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
+        if (!(mapType instanceof ParameterizedType)) {
+          throw parameterError(p, "Map must include generic types (e.g., Map<String, String>)");
+        }
+        ParameterizedType parameterizedType = (ParameterizedType) mapType;
+        Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
+        if (String.class != keyType) {
+          throw parameterError(p, "@HeaderMap keys must be of type String: " + keyType);
+        }
+        Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
+        Converter<?, String> valueConverter =
+            retrofit.stringConverter(valueType, annotations);
+
+        return new ParameterHandler.HeaderMap<>(valueConverter);
+
+      } else if (annotation instanceof Field) {
+        if (!isFormEncoded) {
+          throw parameterError(p, "@Field parameters can only be used with form encoding.");
+        }
+        Field field = (Field) annotation;
+        String name = field.value();
+        boolean encoded = field.encoded();
+
+        gotField = true;
+
+        Class<?> rawParameterType = Utils.getRawType(type);
+        if (Iterable.class.isAssignableFrom(rawParameterType)) {
+          if (!(type instanceof ParameterizedType)) {
+            throw parameterError(p, rawParameterType.getSimpleName()
+                + " must include generic type (e.g., "
+                + rawParameterType.getSimpleName()
+                + "<String>)");
+          }
+          ParameterizedType parameterizedType = (ParameterizedType) type;
+          Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
+          Converter<?, String> converter =
+              retrofit.stringConverter(iterableType, annotations);
+          return new ParameterHandler.Field<>(name, converter, encoded).iterable();
+        } else if (rawParameterType.isArray()) {
+          Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
+          Converter<?, String> converter =
+              retrofit.stringConverter(arrayComponentType, annotations);
+          return new ParameterHandler.Field<>(name, converter, encoded).array();
+        } else {
+          Converter<?, String> converter =
+              retrofit.stringConverter(type, annotations);
+          return new ParameterHandler.Field<>(name, converter, encoded);
+        }
+
+      } else if (annotation instanceof FieldMap) {
+        if (!isFormEncoded) {
+          throw parameterError(p, "@FieldMap parameters can only be used with form encoding.");
+        }
+        Class<?> rawParameterType = Utils.getRawType(type);
+        if (!Map.class.isAssignableFrom(rawParameterType)) {
+          throw parameterError(p, "@FieldMap parameter type must be Map.");
+        }
+        Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
+        if (!(mapType instanceof ParameterizedType)) {
+          throw parameterError(p,
+              "Map must include generic types (e.g., Map<String, String>)");
+        }
+        ParameterizedType parameterizedType = (ParameterizedType) mapType;
+        Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
+        if (String.class != keyType) {
+          throw parameterError(p, "@FieldMap keys must be of type String: " + keyType);
+        }
+        Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
+        Converter<?, String> valueConverter =
+            retrofit.stringConverter(valueType, annotations);
+
+        gotField = true;
+        return new ParameterHandler.FieldMap<>(valueConverter, ((FieldMap) annotation).encoded());
+
+      } else if (annotation instanceof Part) {
+        if (!isMultipart) {
+          throw parameterError(p, "@Part parameters can only be used with multipart encoding.");
+        }
+        Part part = (Part) annotation;
+        gotPart = true;
+
+        String partName = part.value();
+        Class<?> rawParameterType = Utils.getRawType(type);
+        if (partName.isEmpty()) {
+          if (Iterable.class.isAssignableFrom(rawParameterType)) {
+            if (!(type instanceof ParameterizedType)) {
+              throw parameterError(p, rawParameterType.getSimpleName()
+                  + " must include generic type (e.g., "
+                  + rawParameterType.getSimpleName()
+                  + "<String>)");
+            }
+            ParameterizedType parameterizedType = (ParameterizedType) type;
+            Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
+            if (!MultipartBody.Part.class.isAssignableFrom(Utils.getRawType(iterableType))) {
+              throw parameterError(p,
+                  "@Part annotation must supply a name or use MultipartBody.Part parameter type.");
+            }
+            return ParameterHandler.RawPart.INSTANCE.iterable();
+          } else if (rawParameterType.isArray()) {
+            Class<?> arrayComponentType = rawParameterType.getComponentType();
+            if (!MultipartBody.Part.class.isAssignableFrom(arrayComponentType)) {
+              throw parameterError(p,
+                  "@Part annotation must supply a name or use MultipartBody.Part parameter type.");
+            }
+            return ParameterHandler.RawPart.INSTANCE.array();
+          } else if (MultipartBody.Part.class.isAssignableFrom(rawParameterType)) {
+            return ParameterHandler.RawPart.INSTANCE;
+          } else {
+            throw parameterError(p,
+                "@Part annotation must supply a name or use MultipartBody.Part parameter type.");
+          }
+        } else {
+          Headers headers =
+              Headers.of("Content-Disposition", "form-data; name=\"" + partName + "\"",
+                  "Content-Transfer-Encoding", part.encoding());
+
+          if (Iterable.class.isAssignableFrom(rawParameterType)) {
+            if (!(type instanceof ParameterizedType)) {
+              throw parameterError(p, rawParameterType.getSimpleName()
+                  + " must include generic type (e.g., "
+                  + rawParameterType.getSimpleName()
+                  + "<String>)");
+            }
+            ParameterizedType parameterizedType = (ParameterizedType) type;
+            Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
+            if (MultipartBody.Part.class.isAssignableFrom(Utils.getRawType(iterableType))) {
+              throw parameterError(p, "@Part parameters using the MultipartBody.Part must not "
+                  + "include a part name in the annotation.");
+            }
+            Converter<?, RequestBody> converter =
+                retrofit.requestBodyConverter(iterableType, annotations, methodAnnotations);
+            return new ParameterHandler.Part<>(headers, converter).iterable();
+          } else if (rawParameterType.isArray()) {
+            Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
+            if (MultipartBody.Part.class.isAssignableFrom(arrayComponentType)) {
+              throw parameterError(p, "@Part parameters using the MultipartBody.Part must not "
+                  + "include a part name in the annotation.");
+            }
+            Converter<?, RequestBody> converter =
+                retrofit.requestBodyConverter(arrayComponentType, annotations, methodAnnotations);
+            return new ParameterHandler.Part<>(headers, converter).array();
+          } else if (MultipartBody.Part.class.isAssignableFrom(rawParameterType)) {
+            throw parameterError(p, "@Part parameters using the MultipartBody.Part must not "
+                + "include a part name in the annotation.");
+          } else {
+            Converter<?, RequestBody> converter =
+                retrofit.requestBodyConverter(type, annotations, methodAnnotations);
+            return new ParameterHandler.Part<>(headers, converter);
+          }
+        }
+
+      } else if (annotation instanceof PartMap) {
+        if (!isMultipart) {
+          throw parameterError(p, "@PartMap parameters can only be used with multipart encoding.");
+        }
+        gotPart = true;
+        Class<?> rawParameterType = Utils.getRawType(type);
+        if (!Map.class.isAssignableFrom(rawParameterType)) {
+          throw parameterError(p, "@PartMap parameter type must be Map.");
+        }
+        Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
+        if (!(mapType instanceof ParameterizedType)) {
+          throw parameterError(p, "Map must include generic types (e.g., Map<String, String>)");
+        }
+        ParameterizedType parameterizedType = (ParameterizedType) mapType;
+
+        Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
+        if (String.class != keyType) {
+          throw parameterError(p, "@PartMap keys must be of type String: " + keyType);
+        }
+
+        Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
+        if (MultipartBody.Part.class.isAssignableFrom(Utils.getRawType(valueType))) {
+          throw parameterError(p, "@PartMap values cannot be MultipartBody.Part. "
+              + "Use @Part List<Part> or a different value type instead.");
+        }
+
+        Converter<?, RequestBody> valueConverter =
+            retrofit.requestBodyConverter(valueType, annotations, methodAnnotations);
+
+        PartMap partMap = (PartMap) annotation;
+        return new ParameterHandler.PartMap<>(valueConverter, partMap.encoding());
+
+      } else if (annotation instanceof Body) {
+        if (isFormEncoded || isMultipart) {
+          throw parameterError(p,
+              "@Body parameters cannot be used with form or multi-part encoding.");
+        }
+        if (gotBody) {
+          throw parameterError(p, "Multiple @Body method annotations found.");
+        }
+
+        Converter<?, RequestBody> converter;
+        try {
+          converter = retrofit.requestBodyConverter(type, annotations, methodAnnotations);
+        } catch (RuntimeException e) {
+          // Wide exception range because factories are user code.
+          throw parameterError(e, p, "Unable to create @Body converter for %s", type);
+        }
+        gotBody = true;
+        return new ParameterHandler.Body<>(converter);
+      }
+
+      return null; // Not a Retrofit annotation.
+    }
+
+    private void validatePathName(int p, String name) {
+      if (!PARAM_NAME_REGEX.matcher(name).matches()) {
+        throw parameterError(p, "@Path parameter name must match %s. Found: %s",
+            PARAM_URL_REGEX.pattern(), name);
+      }
+      // Verify URL replacement name is actually present in the URL path.
+      if (!relativeUrlParamNames.contains(name)) {
+        throw parameterError(p, "URL \"%s\" does not contain \"{%s}\".", relativeUrl, name);
+      }
+    }
+
+    private Converter<ResponseBody, T> createResponseConverter() {
+      Annotation[] annotations = method.getAnnotations();
+      try {
+        return retrofit.responseBodyConverter(responseType, annotations);
+      } catch (RuntimeException e) { // Wide exception range because factories are user code.
+        throw methodError(e, "Unable to create converter for %s", responseType);
+      }
+    }
+
+    private RuntimeException methodError(String message, Object... args) {
+      return methodError(null, message, args);
+    }
+
+    private RuntimeException methodError(Throwable cause, String message, Object... args) {
+      message = String.format(message, args);
+      return new IllegalArgumentException(message
+          + "\n    for method "
+          + method.getDeclaringClass().getSimpleName()
+          + "."
+          + method.getName(), cause);
+    }
+
+    private RuntimeException parameterError(
+        Throwable cause, int p, String message, Object... args) {
+      return methodError(cause, message + " (parameter #" + (p + 1) + ")", args);
+    }
+
+    private RuntimeException parameterError(int p, String message, Object... args) {
+      return methodError(message + " (parameter #" + (p + 1) + ")", args);
+    }
+  }
+
+  /**
+   * Gets the set of unique path parameters used in the given URI. If a parameter is used twice
+   * in the URI, it will only show up once in the set.
+   */
+  static Set<String> parsePathParameters(String path) {
+    Matcher m = PARAM_URL_REGEX.matcher(path);
+    Set<String> patterns = new LinkedHashSet<>();
+    while (m.find()) {
+      patterns.add(m.group(1));
+    }
+    return patterns;
+  }
+
+  static Class<?> boxIfPrimitive(Class<?> type) {
+    if (boolean.class == type) return Boolean.class;
+    if (byte.class == type) return Byte.class;
+    if (char.class == type) return Character.class;
+    if (double.class == type) return Double.class;
+    if (float.class == type) return Float.class;
+    if (int.class == type) return Integer.class;
+    if (long.class == type) return Long.class;
+    if (short.class == type) return Short.class;
+    return type;
+  }
+}
diff --git a/retrofit/src/main/java/retrofit2/Utils.java b/retrofit/src/main/java/retrofit2/Utils.java
index 8eef16d1a..12544e357 100644
--- a/retrofit/src/main/java/retrofit2/Utils.java
+++ b/retrofit/src/main/java/retrofit2/Utils.java
@@ -1,12 +1,11 @@
 /*
- * Copyright (C) 2012 Square, Inc.
- * Copyright (C) 2007 The Guava Authors
+ * Copyright (C) 2008 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -16,37 +15,271 @@
  */
 package retrofit2;
 
-import com.squareup.okhttp.Response;
-import com.squareup.okhttp.ResponseBody;
-import java.io.Closeable;
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Array;
 import java.lang.reflect.GenericArrayType;
-import java.lang.reflect.Method;
+import java.lang.reflect.GenericDeclaration;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import java.lang.reflect.TypeVariable;
 import java.lang.reflect.WildcardType;
 import java.util.Arrays;
+import java.util.NoSuchElementException;
+import javax.annotation.Nullable;
+import okhttp3.ResponseBody;
 import okio.Buffer;
-import okio.BufferedSource;
-import okio.Source;
 
 final class Utils {
-  static <T> T checkNotNull(T object, String message) {
-    if (object == null) {
-      throw new NullPointerException(message);
+  static final Type[] EMPTY_TYPE_ARRAY = new Type[0];
+
+  private Utils() {
+    // No instances.
+  }
+
+  static Class<?> getRawType(Type type) {
+    checkNotNull(type, "type == null");
+
+    if (type instanceof Class<?>) {
+      // Type is a normal class.
+      return (Class<?>) type;
     }
-    return object;
+    if (type instanceof ParameterizedType) {
+      ParameterizedType parameterizedType = (ParameterizedType) type;
+
+      // I'm not exactly sure why getRawType() returns Type instead of Class. Neal isn't either but
+      // suspects some pathological case related to nested classes exists.
+      Type rawType = parameterizedType.getRawType();
+      if (!(rawType instanceof Class)) throw new IllegalArgumentException();
+      return (Class<?>) rawType;
+    }
+    if (type instanceof GenericArrayType) {
+      Type componentType = ((GenericArrayType) type).getGenericComponentType();
+      return Array.newInstance(getRawType(componentType), 0).getClass();
+    }
+    if (type instanceof TypeVariable) {
+      // We could use the variable's bounds, but that won't work if there are multiple. Having a raw
+      // type that's more general than necessary is okay.
+      return Object.class;
+    }
+    if (type instanceof WildcardType) {
+      return getRawType(((WildcardType) type).getUpperBounds()[0]);
+    }
+
+    throw new IllegalArgumentException("Expected a Class, ParameterizedType, or "
+          + "GenericArrayType, but <" + type + "> is of type " + type.getClass().getName());
+  }
+
+  /** Returns true if {@code a} and {@code b} are equal. */
+  static boolean equals(Type a, Type b) {
+    if (a == b) {
+      return true; // Also handles (a == null && b == null).
+
+    } else if (a instanceof Class) {
+      return a.equals(b); // Class already specifies equals().
+
+    } else if (a instanceof ParameterizedType) {
+      if (!(b instanceof ParameterizedType)) return false;
+      ParameterizedType pa = (ParameterizedType) a;
+      ParameterizedType pb = (ParameterizedType) b;
+      Object ownerA = pa.getOwnerType();
+      Object ownerB = pb.getOwnerType();
+      return (ownerA == ownerB || (ownerA != null && ownerA.equals(ownerB)))
+          && pa.getRawType().equals(pb.getRawType())
+          && Arrays.equals(pa.getActualTypeArguments(), pb.getActualTypeArguments());
+
+    } else if (a instanceof GenericArrayType) {
+      if (!(b instanceof GenericArrayType)) return false;
+      GenericArrayType ga = (GenericArrayType) a;
+      GenericArrayType gb = (GenericArrayType) b;
+      return equals(ga.getGenericComponentType(), gb.getGenericComponentType());
+
+    } else if (a instanceof WildcardType) {
+      if (!(b instanceof WildcardType)) return false;
+      WildcardType wa = (WildcardType) a;
+      WildcardType wb = (WildcardType) b;
+      return Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds())
+          && Arrays.equals(wa.getLowerBounds(), wb.getLowerBounds());
+
+    } else if (a instanceof TypeVariable) {
+      if (!(b instanceof TypeVariable)) return false;
+      TypeVariable<?> va = (TypeVariable<?>) a;
+      TypeVariable<?> vb = (TypeVariable<?>) b;
+      return va.getGenericDeclaration() == vb.getGenericDeclaration()
+          && va.getName().equals(vb.getName());
+
+    } else {
+      return false; // This isn't a type we support!
+    }
+  }
+
+  /**
+   * Returns the generic supertype for {@code supertype}. For example, given a class {@code
+   * IntegerSet}, the result for when supertype is {@code Set.class} is {@code Set<Integer>} and the
+   * result when the supertype is {@code Collection.class} is {@code Collection<Integer>}.
+   */
+  static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResolve) {
+    if (toResolve == rawType) return context;
+
+    // We skip searching through interfaces if unknown is an interface.
+    if (toResolve.isInterface()) {
+      Class<?>[] interfaces = rawType.getInterfaces();
+      for (int i = 0, length = interfaces.length; i < length; i++) {
+        if (interfaces[i] == toResolve) {
+          return rawType.getGenericInterfaces()[i];
+        } else if (toResolve.isAssignableFrom(interfaces[i])) {
+          return getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], toResolve);
+        }
+      }
+    }
+
+    // Check our supertypes.
+    if (!rawType.isInterface()) {
+      while (rawType != Object.class) {
+        Class<?> rawSupertype = rawType.getSuperclass();
+        if (rawSupertype == toResolve) {
+          return rawType.getGenericSuperclass();
+        } else if (toResolve.isAssignableFrom(rawSupertype)) {
+          return getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, toResolve);
+        }
+        rawType = rawSupertype;
+      }
+    }
+
+    // We can't resolve this further.
+    return toResolve;
   }
 
-  static void closeQuietly(Closeable closeable) {
-    if (closeable == null) return;
-    try {
-      closeable.close();
-    } catch (IOException ignored) {
+  private static int indexOf(Object[] array, Object toFind) {
+    for (int i = 0; i < array.length; i++) {
+      if (toFind.equals(array[i])) return i;
     }
+    throw new NoSuchElementException();
+  }
+
+  static String typeToString(Type type) {
+    return type instanceof Class ? ((Class<?>) type).getName() : type.toString();
+  }
+
+  /**
+   * Returns the generic form of {@code supertype}. For example, if this is {@code
+   * ArrayList<String>}, this returns {@code Iterable<String>} given the input {@code
+   * Iterable.class}.
+   *
+   * @param supertype a superclass of, or interface implemented by, this.
+   */
+  static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) {
+    if (!supertype.isAssignableFrom(contextRawType)) throw new IllegalArgumentException();
+    return resolve(context, contextRawType,
+        getGenericSupertype(context, contextRawType, supertype));
+  }
+
+  static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {
+    // This implementation is made a little more complicated in an attempt to avoid object-creation.
+    while (true) {
+      if (toResolve instanceof TypeVariable) {
+        TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;
+        toResolve = resolveTypeVariable(context, contextRawType, typeVariable);
+        if (toResolve == typeVariable) {
+          return toResolve;
+        }
+
+      } else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {
+        Class<?> original = (Class<?>) toResolve;
+        Type componentType = original.getComponentType();
+        Type newComponentType = resolve(context, contextRawType, componentType);
+        return componentType == newComponentType ? original : new GenericArrayTypeImpl(
+            newComponentType);
+
+      } else if (toResolve instanceof GenericArrayType) {
+        GenericArrayType original = (GenericArrayType) toResolve;
+        Type componentType = original.getGenericComponentType();
+        Type newComponentType = resolve(context, contextRawType, componentType);
+        return componentType == newComponentType ? original : new GenericArrayTypeImpl(
+            newComponentType);
+
+      } else if (toResolve instanceof ParameterizedType) {
+        ParameterizedType original = (ParameterizedType) toResolve;
+        Type ownerType = original.getOwnerType();
+        Type newOwnerType = resolve(context, contextRawType, ownerType);
+        boolean changed = newOwnerType != ownerType;
+
+        Type[] args = original.getActualTypeArguments();
+        for (int t = 0, length = args.length; t < length; t++) {
+          Type resolvedTypeArgument = resolve(context, contextRawType, args[t]);
+          if (resolvedTypeArgument != args[t]) {
+            if (!changed) {
+              args = args.clone();
+              changed = true;
+            }
+            args[t] = resolvedTypeArgument;
+          }
+        }
+
+        return changed
+            ? new ParameterizedTypeImpl(newOwnerType, original.getRawType(), args)
+            : original;
+
+      } else if (toResolve instanceof WildcardType) {
+        WildcardType original = (WildcardType) toResolve;
+        Type[] originalLowerBound = original.getLowerBounds();
+        Type[] originalUpperBound = original.getUpperBounds();
+
+        if (originalLowerBound.length == 1) {
+          Type lowerBound = resolve(context, contextRawType, originalLowerBound[0]);
+          if (lowerBound != originalLowerBound[0]) {
+            return new WildcardTypeImpl(new Type[] { Object.class }, new Type[] { lowerBound });
+          }
+        } else if (originalUpperBound.length == 1) {
+          Type upperBound = resolve(context, contextRawType, originalUpperBound[0]);
+          if (upperBound != originalUpperBound[0]) {
+            return new WildcardTypeImpl(new Type[] { upperBound }, EMPTY_TYPE_ARRAY);
+          }
+        }
+        return original;
+
+      } else {
+        return toResolve;
+      }
+    }
+  }
+
+  private static Type resolveTypeVariable(
+      Type context, Class<?> contextRawType, TypeVariable<?> unknown) {
+    Class<?> declaredByRaw = declaringClassOf(unknown);
+
+    // We can't reduce this further.
+    if (declaredByRaw == null) return unknown;
+
+    Type declaredBy = getGenericSupertype(context, contextRawType, declaredByRaw);
+    if (declaredBy instanceof ParameterizedType) {
+      int index = indexOf(declaredByRaw.getTypeParameters(), unknown);
+      return ((ParameterizedType) declaredBy).getActualTypeArguments()[index];
+    }
+
+    return unknown;
+  }
+
+  /**
+   * Returns the declaring class of {@code typeVariable}, or {@code null} if it was not declared by
+   * a class.
+   */
+  private static Class<?> declaringClassOf(TypeVariable<?> typeVariable) {
+    GenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();
+    return genericDeclaration instanceof Class ? (Class<?>) genericDeclaration : null;
+  }
+
+  static void checkNotPrimitive(Type type) {
+    if (type instanceof Class<?> && ((Class<?>) type).isPrimitive()) {
+      throw new IllegalArgumentException();
+    }
+  }
+
+  static <T> T checkNotNull(@Nullable T object, String message) {
+    if (object == null) {
+      throw new NullPointerException(message);
+    }
+    return object;
   }
 
   /** Returns true if {@code annotations} contains an instance of {@code cls}. */
@@ -60,20 +293,9 @@ static boolean isAnnotationPresent(Annotation[] annotations,
     return false;
   }
 
-  /**
-   * Replace a {@link Response} with an identical copy whose body is backed by a
-   * {@link Buffer} rather than a {@link Source}.
-   */
-  static ResponseBody readBodyToBytesIfNecessary(final ResponseBody body) throws IOException {
-    if (body == null) {
-      return null;
-    }
-
-    BufferedSource source = body.source();
+  static ResponseBody buffer(final ResponseBody body) throws IOException {
     Buffer buffer = new Buffer();
-    buffer.writeAll(source);
-    source.close();
-
+    body.source().readAll(buffer);
     return ResponseBody.create(body.contentType(), body.contentLength(), buffer);
   }
 
@@ -91,9 +313,9 @@ static ResponseBody readBodyToBytesIfNecessary(final ResponseBody body) throws I
 
   static Type getParameterUpperBound(int index, ParameterizedType type) {
     Type[] types = type.getActualTypeArguments();
-    if (types.length <= index) {
+    if (index < 0 || index >= types.length) {
       throw new IllegalArgumentException(
-          "Expected at least " + index + " type argument(s) but got: " + Arrays.toString(types));
+          "Index " + index + " not in range [0," + types.length + ") for " + type);
     }
     Type paramType = types[index];
     if (paramType instanceof WildcardType) {
@@ -102,7 +324,7 @@ static Type getParameterUpperBound(int index, ParameterizedType type) {
     return paramType;
   }
 
-  static boolean hasUnresolvableType(Type type) {
+  static boolean hasUnresolvableType(@Nullable Type type) {
     if (type instanceof Class<?>) {
       return false;
     }
@@ -129,71 +351,155 @@ static boolean hasUnresolvableType(Type type) {
         + "GenericArrayType, but <" + type + "> is of type " + className);
   }
 
-  // This method is copyright 2008 Google Inc. and is taken from Gson under the Apache 2.0 license.
-  static Class<?> getRawType(Type type) {
-    if (type instanceof Class<?>) {
-      // Type is a normal class.
-      return (Class<?>) type;
+  static Type getCallResponseType(Type returnType) {
+    if (!(returnType instanceof ParameterizedType)) {
+      throw new IllegalArgumentException(
+          "Call return type must be parameterized as Call<Foo> or Call<? extends Foo>");
+    }
+    return getParameterUpperBound(0, (ParameterizedType) returnType);
+  }
 
-    } else if (type instanceof ParameterizedType) {
-      ParameterizedType parameterizedType = (ParameterizedType) type;
+  private static final class ParameterizedTypeImpl implements ParameterizedType {
+    private final Type ownerType;
+    private final Type rawType;
+    private final Type[] typeArguments;
 
-      // I'm not exactly sure why getRawType() returns Type instead of Class. Neal isn't either but
-      // suspects some pathological case related to nested classes exists.
-      Type rawType = parameterizedType.getRawType();
-      if (!(rawType instanceof Class)) throw new IllegalArgumentException();
-      return (Class<?>) rawType;
+    ParameterizedTypeImpl(@Nullable Type ownerType, Type rawType, Type... typeArguments) {
+      // Require an owner type if the raw type needs it.
+      if (rawType instanceof Class<?>
+          && (ownerType == null) != (((Class<?>) rawType).getEnclosingClass() == null)) {
+        throw new IllegalArgumentException();
+      }
 
-    } else if (type instanceof GenericArrayType) {
-      Type componentType = ((GenericArrayType) type).getGenericComponentType();
-      return Array.newInstance(getRawType(componentType), 0).getClass();
+      for (Type typeArgument : typeArguments) {
+        checkNotNull(typeArgument, "typeArgument == null");
+        checkNotPrimitive(typeArgument);
+      }
 
-    } else if (type instanceof TypeVariable) {
-      // We could use the variable's bounds, but that won't work if there are multiple. Having a raw
-      // type that's more general than necessary is okay.
-      return Object.class;
+      this.ownerType = ownerType;
+      this.rawType = rawType;
+      this.typeArguments = typeArguments.clone();
+    }
 
-    } else if (type instanceof WildcardType) {
-      return getRawType(((WildcardType) type).getUpperBounds()[0]);
+    @Override public Type[] getActualTypeArguments() {
+      return typeArguments.clone();
+    }
 
-    } else {
-      String className = type == null ? "null" : type.getClass().getName();
-      throw new IllegalArgumentException("Expected a Class, ParameterizedType, or "
-          + "GenericArrayType, but <" + type + "> is of type " + className);
+    @Override public Type getRawType() {
+      return rawType;
     }
-  }
 
-  static RuntimeException methodError(Method method, String message, Object... args) {
-    return methodError(null, method, message, args);
+    @Override public Type getOwnerType() {
+      return ownerType;
+    }
+
+    @Override public boolean equals(Object other) {
+      return other instanceof ParameterizedType && Utils.equals(this, (ParameterizedType) other);
+    }
+
+    @Override public int hashCode() {
+      return Arrays.hashCode(typeArguments)
+          ^ rawType.hashCode()
+          ^ (ownerType != null ? ownerType.hashCode() : 0);
+    }
+
+    @Override public String toString() {
+      if (typeArguments.length == 0) return typeToString(rawType);
+      StringBuilder result = new StringBuilder(30 * (typeArguments.length + 1));
+      result.append(typeToString(rawType));
+      result.append("<").append(typeToString(typeArguments[0]));
+      for (int i = 1; i < typeArguments.length; i++) {
+        result.append(", ").append(typeToString(typeArguments[i]));
+      }
+      return result.append(">").toString();
+    }
   }
 
-  static RuntimeException methodError(Throwable cause, Method method, String message,
-      Object... args) {
-    message = String.format(message, args);
-    return new IllegalArgumentException(message
-        + "\n    for method "
-        + method.getDeclaringClass().getSimpleName()
-        + "."
-        + method.getName(), cause);
+  private static final class GenericArrayTypeImpl implements GenericArrayType {
+    private final Type componentType;
+
+    GenericArrayTypeImpl(Type componentType) {
+      this.componentType = componentType;
+    }
+
+    @Override public Type getGenericComponentType() {
+      return componentType;
+    }
+
+    @Override public boolean equals(Object o) {
+      return o instanceof GenericArrayType
+          && Utils.equals(this, (GenericArrayType) o);
+    }
+
+    @Override public int hashCode() {
+      return componentType.hashCode();
+    }
+
+    @Override public String toString() {
+      return typeToString(componentType) + "[]";
+    }
   }
 
-  static Type getCallResponseType(Type returnType) {
-    if (!(returnType instanceof ParameterizedType)) {
-      throw new IllegalArgumentException(
-          "Call return type must be parameterized as Call<Foo> or Call<? extends Foo>");
+  /**
+   * The WildcardType interface supports multiple upper bounds and multiple
+   * lower bounds. We only support what the Java 6 language needs - at most one
+   * bound. If a lower bound is set, the upper bound must be Object.class.
+   */
+  private static final class WildcardTypeImpl implements WildcardType {
+    private final Type upperBound;
+    private final Type lowerBound;
+
+    WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {
+      if (lowerBounds.length > 1) throw new IllegalArgumentException();
+      if (upperBounds.length != 1) throw new IllegalArgumentException();
+
+      if (lowerBounds.length == 1) {
+        if (lowerBounds[0] == null) throw new NullPointerException();
+        checkNotPrimitive(lowerBounds[0]);
+        if (upperBounds[0] != Object.class) throw new IllegalArgumentException();
+        this.lowerBound = lowerBounds[0];
+        this.upperBound = Object.class;
+      } else {
+        if (upperBounds[0] == null) throw new NullPointerException();
+        checkNotPrimitive(upperBounds[0]);
+        this.lowerBound = null;
+        this.upperBound = upperBounds[0];
+      }
     }
-    final Type responseType = getParameterUpperBound(0, (ParameterizedType) returnType);
 
-    // Ensure the Call response type is not Response, we automatically deliver the Response object.
-    if (getRawType(responseType) == retrofit2.Response.class) {
-      throw new IllegalArgumentException(
-          "Call<T> cannot use Response as its generic parameter. "
-              + "Specify the response body type only (e.g., Call<TweetResponse>).");
+    @Override public Type[] getUpperBounds() {
+      return new Type[] { upperBound };
+    }
+
+    @Override public Type[] getLowerBounds() {
+      return lowerBound != null ? new Type[] { lowerBound } : EMPTY_TYPE_ARRAY;
+    }
+
+    @Override public boolean equals(Object other) {
+      return other instanceof WildcardType && Utils.equals(this, (WildcardType) other);
+    }
+
+    @Override public int hashCode() {
+      // This equals Arrays.hashCode(getLowerBounds()) ^ Arrays.hashCode(getUpperBounds()).
+      return (lowerBound != null ? 31 + lowerBound.hashCode() : 1) ^ (31 + upperBound.hashCode());
+    }
+
+    @Override public String toString() {
+      if (lowerBound != null) return "? super " + typeToString(lowerBound);
+      if (upperBound == Object.class) return "?";
+      return "? extends " + typeToString(upperBound);
     }
-    return responseType;
   }
 
-  private Utils() {
-    // No instances.
+  // https://github.com/ReactiveX/RxJava/blob/6a44e5d0543a48f1c378dc833a155f3f71333bc2/
+  // src/main/java/io/reactivex/exceptions/Exceptions.java#L66
+  static void throwIfFatal(Throwable t) {
+    if (t instanceof VirtualMachineError) {
+      throw (VirtualMachineError) t;
+    } else if (t instanceof ThreadDeath) {
+      throw (ThreadDeath) t;
+    } else if (t instanceof LinkageError) {
+      throw (LinkageError) t;
+    }
   }
 }
diff --git a/retrofit/src/main/java/retrofit2/http/Body.java b/retrofit/src/main/java/retrofit2/http/Body.java
index 673a0a528..98d1d8684 100644
--- a/retrofit/src/main/java/retrofit2/http/Body.java
+++ b/retrofit/src/main/java/retrofit2/http/Body.java
@@ -32,8 +32,6 @@
  * request body.
  * <p>
  * Body parameters may not be {@code null}.
- *
- * @author Eric Denman (edenman@squareup.com)
  */
 @Documented
 @Target(PARAMETER)
diff --git a/retrofit/src/main/java/retrofit2/http/DELETE.java b/retrofit/src/main/java/retrofit2/http/DELETE.java
index c4a7143f0..4a2b3e519 100644
--- a/retrofit/src/main/java/retrofit2/http/DELETE.java
+++ b/retrofit/src/main/java/retrofit2/http/DELETE.java
@@ -15,10 +15,10 @@
  */
 package retrofit2.http;
 
-import com.squareup.okhttp.HttpUrl;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+import okhttp3.HttpUrl;
 
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
diff --git a/retrofit/src/main/java/retrofit2/http/Field.java b/retrofit/src/main/java/retrofit2/http/Field.java
index 9c6d354c8..06e369bc7 100644
--- a/retrofit/src/main/java/retrofit2/http/Field.java
+++ b/retrofit/src/main/java/retrofit2/http/Field.java
@@ -15,9 +15,12 @@
  */
 package retrofit2.http;
 
+import java.lang.annotation.Annotation;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+import java.lang.reflect.Type;
+import retrofit2.Retrofit;
 
 import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
@@ -25,27 +28,29 @@
 /**
  * Named pair for a form-encoded request.
  * <p>
- * Values are converted to strings using {@link String#valueOf(Object)} and then form URL encoded.
+ * Values are converted to strings using {@link Retrofit#stringConverter(Type, Annotation[])}
+ * (or {@link Object#toString()}, if no matching string converter is installed)
+ * and then form URL encoded.
  * {@code null} values are ignored. Passing a {@link java.util.List List} or array will result in a
  * field pair for each non-{@code null} item.
  * <p>
  * Simple Example:
- * <pre>{@code
+ * <pre><code>
  * &#64;FormUrlEncoded
  * &#64;POST("/")
- * Call&lt;ResponseBody> example(
+ * Call&lt;ResponseBody&gt; example(
  *     &#64;Field("name") String name,
  *     &#64;Field("occupation") String occupation);
- * }</pre>
+ * </code></pre>
  * Calling with {@code foo.example("Bob Smith", "President")} yields a request body of
  * {@code name=Bob+Smith&occupation=President}.
  * <p>
  * Array/Varargs Example:
- * <pre>{@code
+ * <pre><code>
  * &#64;FormUrlEncoded
  * &#64;POST("/list")
- * Call&lt;ResponseBody> example(@Field("name") String... names);
- * }</pre>
+ * Call&lt;ResponseBody&gt; example(@Field("name") String... names);
+ * </code></pre>
  * Calling with {@code foo.example("Bob Smith", "Jane Doe")} yields a request body of
  * {@code name=Bob+Smith&name=Jane+Doe}.
  *
diff --git a/retrofit/src/main/java/retrofit2/http/FieldMap.java b/retrofit/src/main/java/retrofit2/http/FieldMap.java
index fa2b272c3..a7eb1ee86 100644
--- a/retrofit/src/main/java/retrofit2/http/FieldMap.java
+++ b/retrofit/src/main/java/retrofit2/http/FieldMap.java
@@ -25,16 +25,16 @@
 /**
  * Named key/value pairs for a form-encoded request.
  * <p>
- * Field values may be {@code null} which will omit them from the request body.
- * <p>
  * Simple Example:
- * <pre>{@code
+ * <pre><code>
  * &#64;FormUrlEncoded
  * &#64;POST("/things")
- * Call&lt;ResponseBody> things(@FieldMap Map&lt;String, String&gt; fields);
- * }</pre>
+ * Call&lt;ResponseBody&gt; things(@FieldMap Map&lt;String, String&gt; fields);
+ * </code></pre>
  * Calling with {@code foo.things(ImmutableMap.of("foo", "bar", "kit", "kat")} yields a request
  * body of {@code foo=bar&kit=kat}.
+ * <p>
+ * A {@code null} value for the map, as a key, or as a value is not allowed.
  *
  * @see FormUrlEncoded
  * @see Field
diff --git a/retrofit/src/main/java/retrofit2/http/GET.java b/retrofit/src/main/java/retrofit2/http/GET.java
index 7c487a51d..deca1820d 100644
--- a/retrofit/src/main/java/retrofit2/http/GET.java
+++ b/retrofit/src/main/java/retrofit2/http/GET.java
@@ -15,10 +15,10 @@
  */
 package retrofit2.http;
 
-import com.squareup.okhttp.HttpUrl;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+import okhttp3.HttpUrl;
 
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
diff --git a/retrofit/src/main/java/retrofit2/http/HEAD.java b/retrofit/src/main/java/retrofit2/http/HEAD.java
index 0d7477542..077787d4f 100644
--- a/retrofit/src/main/java/retrofit2/http/HEAD.java
+++ b/retrofit/src/main/java/retrofit2/http/HEAD.java
@@ -15,10 +15,10 @@
  */
 package retrofit2.http;
 
-import com.squareup.okhttp.HttpUrl;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+import okhttp3.HttpUrl;
 
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
diff --git a/retrofit/src/main/java/retrofit2/http/HTTP.java b/retrofit/src/main/java/retrofit2/http/HTTP.java
index 1704fd780..101eecf3b 100644
--- a/retrofit/src/main/java/retrofit2/http/HTTP.java
+++ b/retrofit/src/main/java/retrofit2/http/HTTP.java
@@ -15,29 +15,29 @@
  */
 package retrofit2.http;
 
-import com.squareup.okhttp.HttpUrl;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+import okhttp3.HttpUrl;
 
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 /**
  * Use a custom HTTP verb for a request.
- * <pre>{@code
+ * <pre><code>
  * interface Service {
  *   &#064;HTTP(method = "CUSTOM", path = "custom/endpoint/")
- *   Call<ResponseBody> customEndpoint();
+ *   Call&lt;ResponseBody&gt; customEndpoint();
  * }
- * }</pre>
+ * </code></pre>
  * This annotation can also used for sending {@code DELETE} with a request body:
- * <pre>{@code
+ * <pre><code>
  * interface Service {
  *   &#064;HTTP(method = "DELETE", path = "remove/", hasBody = true)
- *   Call<ResponseBody> deleteObject(@Body RequestBody object);
+ *   Call&lt;ResponseBody&gt; deleteObject(@Body RequestBody object);
  * }
- * }</pre>
+ * </code></pre>
  */
 @Documented
 @Target(METHOD)
diff --git a/retrofit/src/main/java/retrofit2/http/Header.java b/retrofit/src/main/java/retrofit2/http/Header.java
index b51aaf5a2..b8f7a70ea 100644
--- a/retrofit/src/main/java/retrofit2/http/Header.java
+++ b/retrofit/src/main/java/retrofit2/http/Header.java
@@ -24,19 +24,18 @@
 
 /**
  * Replaces the header with the value of its target.
- * <p>
- * <pre>{@code
+ * <pre><code>
  * &#64;GET("/")
- * Call&lt;ResponseBody> foo(@Header("Accept-Language") String lang);
- * }</pre>
- * <p>
+ * Call&lt;ResponseBody&gt; foo(@Header("Accept-Language") String lang);
+ * </code></pre>
  * Header parameters may be {@code null} which will omit them from the request. Passing a
  * {@link java.util.List List} or array will result in a header for each non-{@code null} item.
  * <p>
  * <strong>Note:</strong> Headers do not overwrite each other. All headers with the same name will
  * be included in the request.
  *
- * @author Adrian Cole (adrianc@netflix.com)
+ * @see Headers
+ * @see HeaderMap
  */
 @Documented
 @Retention(RUNTIME)
diff --git a/retrofit/src/main/java/retrofit2/http/HeaderMap.java b/retrofit/src/main/java/retrofit2/http/HeaderMap.java
new file mode 100644
index 000000000..248abc15e
--- /dev/null
+++ b/retrofit/src/main/java/retrofit2/http/HeaderMap.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.http;
+
+import static java.lang.annotation.ElementType.PARAMETER;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import java.lang.annotation.Annotation;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+import java.lang.reflect.Type;
+import java.util.Map;
+import retrofit2.Retrofit;
+
+/**
+ * Adds headers specified in the {@link Map}.
+ * <p>
+ * Values are converted to strings using {@link Retrofit#stringConverter(Type, Annotation[])}
+ * (or {@link Object#toString()}, if no matching string converter is installed).
+ * <p>
+ * Simple Example:
+ * <pre>
+ * &#64;GET("/search")
+ * void list(@HeaderMap Map&lt;String, String&gt; headers);
+ *
+ * ...
+ *
+ * // The following call yields /search with headers
+ * // Accept: text/plain and Accept-Charset: utf-8
+ * foo.list(ImmutableMap.of("Accept", "text/plain", "Accept-Charset", "utf-8"));
+ * </pre>
+ *
+ * @see Header
+ * @see Headers
+ */
+@Documented
+@Target(PARAMETER)
+@Retention(RUNTIME)
+public @interface HeaderMap {
+
+}
diff --git a/retrofit/src/main/java/retrofit2/http/Headers.java b/retrofit/src/main/java/retrofit2/http/Headers.java
index abc16409f..b360f3ec3 100644
--- a/retrofit/src/main/java/retrofit2/http/Headers.java
+++ b/retrofit/src/main/java/retrofit2/http/Headers.java
@@ -24,8 +24,7 @@
 
 /**
  * Adds headers literally supplied in the {@code value}.
- * <p>
- * <pre>{@code
+ * <pre><code>
  * &#64;Headers("Cache-Control: max-age=640000")
  * &#64;GET("/")
  * ...
@@ -36,12 +35,12 @@
  * })
  * &#64;GET("/")
  * ...
- * }</pre>
- * <p>
+ * </code></pre>
  * <strong>Note:</strong> Headers do not overwrite each other. All headers with the same name will
  * be included in the request.
  *
- * @author Adrian Cole (adrianc@netflix.com)
+ * @see Header
+ * @see HeaderMap
  */
 @Documented
 @Target(METHOD)
diff --git a/retrofit/src/main/java/retrofit2/http/OPTIONS.java b/retrofit/src/main/java/retrofit2/http/OPTIONS.java
index 578cc68ec..17dc085e3 100644
--- a/retrofit/src/main/java/retrofit2/http/OPTIONS.java
+++ b/retrofit/src/main/java/retrofit2/http/OPTIONS.java
@@ -18,6 +18,7 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+import okhttp3.HttpUrl;
 
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
diff --git a/retrofit/src/main/java/retrofit2/http/PATCH.java b/retrofit/src/main/java/retrofit2/http/PATCH.java
index 4a79069b8..035276982 100644
--- a/retrofit/src/main/java/retrofit2/http/PATCH.java
+++ b/retrofit/src/main/java/retrofit2/http/PATCH.java
@@ -15,10 +15,10 @@
  */
 package retrofit2.http;
 
-import com.squareup.okhttp.HttpUrl;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+import okhttp3.HttpUrl;
 
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
diff --git a/retrofit/src/main/java/retrofit2/http/POST.java b/retrofit/src/main/java/retrofit2/http/POST.java
index b2ca5374b..34352cd34 100644
--- a/retrofit/src/main/java/retrofit2/http/POST.java
+++ b/retrofit/src/main/java/retrofit2/http/POST.java
@@ -15,10 +15,10 @@
  */
 package retrofit2.http;
 
-import com.squareup.okhttp.HttpUrl;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+import okhttp3.HttpUrl;
 
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
diff --git a/retrofit/src/main/java/retrofit2/http/PUT.java b/retrofit/src/main/java/retrofit2/http/PUT.java
index 204fc4eb0..0d4437f86 100644
--- a/retrofit/src/main/java/retrofit2/http/PUT.java
+++ b/retrofit/src/main/java/retrofit2/http/PUT.java
@@ -15,10 +15,10 @@
  */
 package retrofit2.http;
 
-import com.squareup.okhttp.HttpUrl;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+import okhttp3.HttpUrl;
 
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
diff --git a/retrofit/src/main/java/retrofit2/http/Part.java b/retrofit/src/main/java/retrofit2/http/Part.java
index 301daac16..f320c088f 100644
--- a/retrofit/src/main/java/retrofit2/http/Part.java
+++ b/retrofit/src/main/java/retrofit2/http/Part.java
@@ -26,23 +26,27 @@
 /**
  * Denotes a single part of a multi-part request.
  * <p>
- * The parameter type on which this annotation exists will be processed in one of two ways:
+ * The parameter type on which this annotation exists will be processed in one of three ways:
  * <ul>
- * <li>If the type is {@link com.squareup.okhttp.RequestBody RequestBody} the value will be used
- * directly with its content type.</li>
+ * <li>If the type is {@link okhttp3.MultipartBody.Part} the contents will be used directly. Omit
+ * the name from the annotation (i.e., {@code @Part MultipartBody.Part part}).</li>
+ * <li>If the type is {@link okhttp3.RequestBody RequestBody} the value will be used
+ * directly with its content type. Supply the part name in the annotation (e.g.,
+ * {@code @Part("foo") RequestBody foo}).</li>
  * <li>Other object types will be converted to an appropriate representation by using
- * {@linkplain Converter a converter}.</li>
+ * {@linkplain Converter a converter}. Supply the part name in the annotation (e.g.,
+ * {@code @Part("foo") Image photo}).</li>
  * </ul>
  * <p>
  * Values may be {@code null} which will omit them from the request body.
  * <p>
- * <pre>{@code
+ * <pre><code>
  * &#64;Multipart
  * &#64;POST("/")
- * Call&lt;ResponseBody> example(
+ * Call&lt;ResponseBody&gt; example(
  *     &#64;Part("description") String description,
  *     &#64;Part(value = "image", encoding = "8-bit") RequestBody image);
- * }</pre>
+ * </code></pre>
  * <p>
  * Part parameters may not be {@code null}.
  */
@@ -50,7 +54,11 @@
 @Target(PARAMETER)
 @Retention(RUNTIME)
 public @interface Part {
-  String value();
+  /**
+   * The name of the part. Required for all parameter types except
+   * {@link okhttp3.MultipartBody.Part}.
+   */
+  String value() default "";
   /** The {@code Content-Transfer-Encoding} of this part. */
   String encoding() default "binary";
 }
diff --git a/retrofit/src/main/java/retrofit2/http/PartMap.java b/retrofit/src/main/java/retrofit2/http/PartMap.java
index 3be4ef98d..79eae2147 100644
--- a/retrofit/src/main/java/retrofit2/http/PartMap.java
+++ b/retrofit/src/main/java/retrofit2/http/PartMap.java
@@ -28,19 +28,21 @@
  * <p>
  * Values of the map on which this annotation exists will be processed in one of two ways:
  * <ul>
- * <li>If the type is {@link com.squareup.okhttp.RequestBody RequestBody} the value will be used
+ * <li>If the type is {@link okhttp3.RequestBody RequestBody} the value will be used
  * directly with its content type.</li>
  * <li>Other object types will be converted to an appropriate representation by using
  * {@linkplain Converter a converter}.</li>
  * </ul>
  * <p>
- * <pre>{@code
+ * <pre><code>
  * &#64;Multipart
  * &#64;POST("/upload")
- * Call&lt;ResponseBody> upload(
+ * Call&lt;ResponseBody&gt; upload(
  *     &#64;Part("file") RequestBody file,
  *     &#64;PartMap Map&lt;String, RequestBody&gt; params);
- * }</pre>
+ * </code></pre>
+ * <p>
+ * A {@code null} value for the map, as a key, or as a value is not allowed.
  *
  * @see Multipart
  * @see Part
diff --git a/retrofit/src/main/java/retrofit2/http/Path.java b/retrofit/src/main/java/retrofit2/http/Path.java
index feaf34b27..52af62511 100644
--- a/retrofit/src/main/java/retrofit2/http/Path.java
+++ b/retrofit/src/main/java/retrofit2/http/Path.java
@@ -15,32 +15,36 @@
  */
 package retrofit2.http;
 
+import java.lang.annotation.Annotation;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+import java.lang.reflect.Type;
+import retrofit2.Retrofit;
 
 import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 /**
- * Named replacement in a URL path segment. Values are converted to string using
- * {@link String#valueOf(Object)} and URL encoded.
+ * Named replacement in a URL path segment. Values are converted to strings using
+ * {@link Retrofit#stringConverter(Type, Annotation[])} (or {@link Object#toString()},
+ * if no matching string converter is installed) and then URL encoded.
  * <p>
  * Simple example:
- * <pre>{@code
+ * <pre><code>
  * &#64;GET("/image/{id}")
- * Call&lt;ResponseBody> example(@Path("id") int id);
- * }</pre>
+ * Call&lt;ResponseBody&gt; example(@Path("id") int id);
+ * </code></pre>
  * Calling with {@code foo.example(1)} yields {@code /image/1}.
  * <p>
  * Values are URL encoded by default. Disable with {@code encoded=true}.
- * <pre>{@code
+ * <pre><code>
  * &#64;GET("/user/{name}")
- * Call&lt;ResponseBody> encoded(@Path("name") String name);
+ * Call&lt;ResponseBody&gt; encoded(@Path("name") String name);
  *
  * &#64;GET("/user/{name}")
- * Call&lt;ResponseBody> notEncoded(@Path(value="name", encoded=true) String name);
- * }</pre>
+ * Call&lt;ResponseBody&gt; notEncoded(@Path(value="name", encoded=true) String name);
+ * </code></pre>
  * Calling {@code foo.encoded("John+Doe")} yields {@code /user/John%2BDoe} whereas
  * {@code foo.notEncoded("John+Doe")} yields {@code /user/John+Doe}.
  * <p>
diff --git a/retrofit/src/main/java/retrofit2/http/Query.java b/retrofit/src/main/java/retrofit2/http/Query.java
index 29205bebc..17c36c154 100644
--- a/retrofit/src/main/java/retrofit2/http/Query.java
+++ b/retrofit/src/main/java/retrofit2/http/Query.java
@@ -15,9 +15,12 @@
  */
 package retrofit2.http;
 
+import java.lang.annotation.Annotation;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+import java.lang.reflect.Type;
+import retrofit2.Retrofit;
 
 import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
@@ -25,41 +28,44 @@
 /**
  * Query parameter appended to the URL.
  * <p>
- * Values are converted to strings using {@link String#valueOf(Object)} and then URL encoded.
+ * Values are converted to strings using {@link Retrofit#stringConverter(Type, Annotation[])}
+ * (or {@link Object#toString()}, if no matching string converter is installed)
+ * and then URL encoded.
  * {@code null} values are ignored. Passing a {@link java.util.List List} or array will result in a
  * query parameter for each non-{@code null} item.
  * <p>
  * Simple Example:
- * <pre>{@code
- * &#64;GET("/list")
- * Call&lt;ResponseBody> list(@Query("page") int page);
- * }</pre>
- * Calling with {@code foo.list(1)} yields {@code /list?page=1}.
+ * <pre><code>
+ * &#64;GET("/friends")
+ * Call&lt;ResponseBody&gt; friends(@Query("page") int page);
+ * </code></pre>
+ * Calling with {@code foo.friends(1)} yields {@code /friends?page=1}.
  * <p>
  * Example with {@code null}:
- * <pre>{@code
- * &#64;GET("/list")
- * Call&lt;ResponseBody> list(@Query("category") String category);
- * }</pre>
- * Calling with {@code foo.list(null)} yields {@code /list}.
+ * <pre><code>
+ * &#64;GET("/friends")
+ * Call&lt;ResponseBody&gt; friends(@Query("group") String group);
+ * </code></pre>
+ * Calling with {@code foo.friends(null)} yields {@code /friends}.
  * <p>
  * Array/Varargs Example:
- * <pre>{@code
- * &#64;GET("/list")
- * Call&lt;ResponseBody> list(@Query("category") String... categories);
- * }</pre>
- * Calling with {@code foo.list("bar", "baz")} yields
- * {@code /list?category=bar&category=baz}.
+ * <pre><code>
+ * &#64;GET("/friends")
+ * Call&lt;ResponseBody&gt; friends(@Query("group") String... groups);
+ * </code></pre>
+ * Calling with {@code foo.friends("coworker", "bowling")} yields
+ * {@code /friends?group=coworker&group=bowling}.
  * <p>
  * Parameter names and values are URL encoded by default. Specify {@link #encoded() encoded=true}
  * to change this behavior.
- * <pre>{@code
- * &#64;GET("/search")
- * Call&lt;ResponseBody> list(@Query(value="foo", encoded=true) String foo);
- * }</pre>
- * Calling with {@code foo.list("foo+bar"))} yields {@code /search?foo=foo+bar}.
+ * <pre><code>
+ * &#64;GET("/friends")
+ * Call&lt;ResponseBody&gt; friends(@Query(value="group", encoded=true) String group);
+ * </code></pre>
+ * Calling with {@code foo.friends("foo+bar"))} yields {@code /friends?group=foo+bar}.
  *
  * @see QueryMap
+ * @see QueryName
  */
 @Documented
 @Target(PARAMETER)
diff --git a/retrofit/src/main/java/retrofit2/http/QueryMap.java b/retrofit/src/main/java/retrofit2/http/QueryMap.java
index 60cff1cb3..a9d7a30ea 100644
--- a/retrofit/src/main/java/retrofit2/http/QueryMap.java
+++ b/retrofit/src/main/java/retrofit2/http/QueryMap.java
@@ -15,9 +15,12 @@
  */
 package retrofit2.http;
 
+import java.lang.annotation.Annotation;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+import java.lang.reflect.Type;
+import retrofit2.Retrofit;
 
 import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
@@ -25,28 +28,30 @@
 /**
  * Query parameter keys and values appended to the URL.
  * <p>
- * Both keys and values are converted to strings using {@link String#valueOf(Object)}. Values are
- * URL encoded and {@code null} will not include the query parameter in the URL. {@code null} keys
- * are not allowed.
+ * Values are converted to strings using {@link Retrofit#stringConverter(Type, Annotation[])}
+ * (or {@link Object#toString()}, if no matching string converter is installed).
  * <p>
  * Simple Example:
- * <pre>{@code
- * &#64;GET("/search")
- * Call&lt;ResponseBody> list(@QueryMap Map&lt;String, String&gt; filters);
- * }</pre>
- * Calling with {@code foo.list(ImmutableMap.of("foo", "bar", "kit", "kat"))} yields
- * {@code /search?foo=bar&kit=kat}.
+ * <pre><code>
+ * &#64;GET("/friends")
+ * Call&lt;ResponseBody&gt; friends(@QueryMap Map&lt;String, String&gt; filters);
+ * </code></pre>
+ * Calling with {@code foo.friends(ImmutableMap.of("group", "coworker", "age", "42"))} yields
+ * {@code /friends?group=coworker&age=42}.
  * <p>
  * Map keys and values representing parameter values are URL encoded by default. Specify
  * {@link #encoded() encoded=true} to change this behavior.
- * <pre>{@code
- * &#64;GET("/search")
- * Call&lt;ResponseBody> list(@QueryMap(encoded=true) Map&lt;String, String&gt; filters);
- * }</pre>
- * Calling with {@code foo.list(ImmutableMap.of("foo", "foo+foo"))} yields
- * {@code /search?foo=foo%2Bbar}.
+ * <pre><code>
+ * &#64;GET("/friends")
+ * Call&lt;ResponseBody&gt; friends(@QueryMap(encoded=true) Map&lt;String, String&gt; filters);
+ * </code></pre>
+ * Calling with {@code foo.list(ImmutableMap.of("group", "coworker+bowling"))} yields
+ * {@code /friends?group=coworker+bowling}.
+ * <p>
+ * A {@code null} value for the map, as a key, or as a value is not allowed.
  *
  * @see Query
+ * @see QueryName
  */
 @Documented
 @Target(PARAMETER)
diff --git a/retrofit/src/main/java/retrofit2/http/QueryName.java b/retrofit/src/main/java/retrofit2/http/QueryName.java
new file mode 100644
index 000000000..5d6f0e948
--- /dev/null
+++ b/retrofit/src/main/java/retrofit2/http/QueryName.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.http;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.PARAMETER;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Query parameter appended to the URL that has no value.
+ * <p>
+ * Passing a {@link java.util.List List} or array will result in a query parameter for each
+ * non-{@code null} item.
+ * <p>
+ * Simple Example:
+ * <pre><code>
+ * &#64;GET("/friends")
+ * Call&lt;ResponseBody&gt; friends(@QueryName String filter);
+ * </code></pre>
+ * Calling with {@code foo.friends("contains(Bob)")} yields {@code /friends?contains(Bob)}.
+ * <p>
+ * Array/Varargs Example:
+ * <pre><code>
+ * &#64;GET("/friends")
+ * Call&lt;ResponseBody&gt; friends(@QueryName String... filters);
+ * </code></pre>
+ * Calling with {@code foo.friends("contains(Bob)", "age(42)")} yields
+ * {@code /friends?contains(Bob)&age(42)}.
+ * <p>
+ * Parameter names are URL encoded by default. Specify {@link #encoded() encoded=true} to change
+ * this behavior.
+ * <pre><code>
+ * &#64;GET("/friends")
+ * Call&lt;ResponseBody&gt; friends(@QueryName(encoded=true) String filter);
+ * </code></pre>
+ * Calling with {@code foo.friends("name+age"))} yields {@code /friends?name+age}.
+ *
+ * @see Query
+ * @see QueryMap
+ */
+@Documented
+@Target(PARAMETER)
+@Retention(RUNTIME)
+public @interface QueryName {
+  /**
+   * Specifies whether the parameter is already URL encoded.
+   */
+  boolean encoded() default false;
+}
diff --git a/retrofit/src/main/java/retrofit2/http/Streaming.java b/retrofit/src/main/java/retrofit2/http/Streaming.java
index 57bd0fa3e..4a87591df 100644
--- a/retrofit/src/main/java/retrofit2/http/Streaming.java
+++ b/retrofit/src/main/java/retrofit2/http/Streaming.java
@@ -23,8 +23,8 @@
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 /**
- * Treat the response body on methods returning {@link com.squareup.okhttp.Response Response} as is,
- * i.e. without converting {@link com.squareup.okhttp.Response#body() body()} to {@code byte[]}.
+ * Treat the response body on methods returning {@link okhttp3.Response Response} as is,
+ * i.e. without converting {@link okhttp3.Response#body() body()} to {@code byte[]}.
  */
 @Documented
 @Target(METHOD)
diff --git a/retrofit/src/main/java/retrofit2/http/Url.java b/retrofit/src/main/java/retrofit2/http/Url.java
index f614a46d4..31187ca3d 100644
--- a/retrofit/src/main/java/retrofit2/http/Url.java
+++ b/retrofit/src/main/java/retrofit2/http/Url.java
@@ -15,10 +15,10 @@
  */
 package retrofit2.http;
 
-import com.squareup.okhttp.HttpUrl;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+import okhttp3.HttpUrl;
 import retrofit2.Retrofit;
 
 import static java.lang.annotation.ElementType.PARAMETER;
@@ -26,10 +26,10 @@
 
 /**
  * URL resolved against the {@linkplain Retrofit#baseUrl() base URL}.
- * <pre>{@code
+ * <pre><code>
  * &#64;GET
- * Call&lt;ResponseBody> list(@Url String url);
- * }</pre>
+ * Call&lt;ResponseBody&gt; list(@Url String url);
+ * </code></pre>
  * <p>
  * See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
  * the value will be resolved against a base URL to create the full endpoint URL.
diff --git a/retrofit/src/main/java/retrofit2/package-info.java b/retrofit/src/main/java/retrofit2/package-info.java
index 44f5b357a..135079424 100644
--- a/retrofit/src/main/java/retrofit2/package-info.java
+++ b/retrofit/src/main/java/retrofit2/package-info.java
@@ -9,4 +9,7 @@
  * }
  * </pre>
  */
+@ParametersAreNonnullByDefault
 package retrofit2;
+
+import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit/src/test/java/retrofit2/CallAdapterTest.java b/retrofit/src/test/java/retrofit2/CallAdapterTest.java
new file mode 100644
index 000000000..d1ed83480
--- /dev/null
+++ b/retrofit/src/test/java/retrofit2/CallAdapterTest.java
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import com.google.common.reflect.TypeToken;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.util.List;
+import java.util.Map;
+import org.junit.Test;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+import static retrofit2.CallAdapter.Factory.getParameterUpperBound;
+import static retrofit2.CallAdapter.Factory.getRawType;
+
+public final class CallAdapterTest {
+  @Test public void parameterizedTypeInvalidIndex() {
+    ParameterizedType listOfString = (ParameterizedType) new TypeToken<List<String>>() {}.getType();
+    try {
+      getParameterUpperBound(-1, listOfString);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Index -1 not in range [0,1) for java.util.List<java.lang.String>");
+    }
+    try {
+      getParameterUpperBound(1, listOfString);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Index 1 not in range [0,1) for java.util.List<java.lang.String>");
+    }
+  }
+
+  @Test public void parameterizedTypes() {
+    ParameterizedType one = (ParameterizedType) new TypeToken<List<String>>() {}.getType();
+    assertThat(getParameterUpperBound(0, one)).isSameAs(String.class);
+
+    ParameterizedType two = (ParameterizedType) new TypeToken<Map<String, String>>() {}.getType();
+    assertThat(getParameterUpperBound(0, two)).isSameAs(String.class);
+    assertThat(getParameterUpperBound(1, two)).isSameAs(String.class);
+
+    ParameterizedType wild = (ParameterizedType) new TypeToken<List<? extends CharSequence>>() {
+    }.getType();
+    assertThat(getParameterUpperBound(0, wild)).isSameAs(CharSequence.class);
+  }
+
+  @Test public void rawTypeThrowsOnNull() {
+    try {
+      getRawType(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("type == null");
+    }
+  }
+
+  @Test public void rawTypes() throws NoSuchMethodException {
+    assertThat(getRawType(String.class)).isSameAs(String.class);
+
+    Type listOfString = new TypeToken<List<String>>() {}.getType();
+    assertThat(getRawType(listOfString)).isSameAs(List.class);
+
+    Type stringArray = new TypeToken<String[]>() {}.getType();
+    assertThat(getRawType(stringArray)).isSameAs(String[].class);
+
+    Type wild = ((ParameterizedType) new TypeToken<List<? extends CharSequence>>() {
+    }.getType()).getActualTypeArguments()[0];
+    assertThat(getRawType(wild)).isSameAs(CharSequence.class);
+
+    Type wildParam = ((ParameterizedType) new TypeToken<List<? extends List<String>>>() {
+    }.getType()).getActualTypeArguments()[0];
+    assertThat(getRawType(wildParam)).isSameAs(List.class);
+
+    Type typeVar = A.class.getDeclaredMethod("method").getGenericReturnType();
+    assertThat(getRawType(typeVar)).isSameAs(Object.class);
+  }
+
+  @SuppressWarnings("unused") // Used reflectively.
+  static class A<T> {
+    T method() {
+      return null;
+    }
+  }
+}
diff --git a/retrofit/src/test/java/retrofit2/CallTest.java b/retrofit/src/test/java/retrofit2/CallTest.java
index c25b45375..aa9b882d8 100644
--- a/retrofit/src/test/java/retrofit2/CallTest.java
+++ b/retrofit/src/test/java/retrofit2/CallTest.java
@@ -15,31 +15,35 @@
  */
 package retrofit2;
 
-import com.squareup.okhttp.Interceptor;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.ResponseBody;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import com.squareup.okhttp.mockwebserver.SocketPolicy;
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
 import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.Interceptor;
+import okhttp3.OkHttpClient;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.SocketPolicy;
 import okio.Buffer;
 import okio.BufferedSource;
 import okio.ForwardingSource;
 import okio.Okio;
 import org.junit.Rule;
 import org.junit.Test;
+import retrofit2.helpers.ToStringConverterFactory;
 import retrofit2.http.Body;
 import retrofit2.http.GET;
 import retrofit2.http.POST;
+import retrofit2.http.Path;
 import retrofit2.http.Streaming;
 
-import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY;
 import static java.util.concurrent.TimeUnit.SECONDS;
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
@@ -54,6 +58,7 @@
     @GET("/") Call<ResponseBody> getBody();
     @GET("/") @Streaming Call<ResponseBody> getStreamingBody();
     @POST("/") Call<String> postString(@Body String body);
+    @POST("/{a}") Call<String> postRequestBody(@Path("a") Object a);
   }
 
   @Test public void http200Sync() throws IOException {
@@ -66,7 +71,7 @@
     server.enqueue(new MockResponse().setBody("Hi"));
 
     Response<String> response = example.getString().execute();
-    assertThat(response.isSuccess()).isTrue();
+    assertThat(response.isSuccessful()).isTrue();
     assertThat(response.body()).isEqualTo("Hi");
   }
 
@@ -82,19 +87,19 @@
     final AtomicReference<Response<String>> responseRef = new AtomicReference<>();
     final CountDownLatch latch = new CountDownLatch(1);
     example.getString().enqueue(new Callback<String>() {
-      @Override public void onResponse(Response<String> response) {
+      @Override public void onResponse(Call<String> call, Response<String> response) {
         responseRef.set(response);
         latch.countDown();
       }
 
-      @Override public void onFailure(Throwable t) {
+      @Override public void onFailure(Call<String> call, Throwable t) {
         t.printStackTrace();
       }
     });
-    assertTrue(latch.await(2, SECONDS));
+    assertTrue(latch.await(10, SECONDS));
 
     Response<String> response = responseRef.get();
-    assertThat(response.isSuccess()).isTrue();
+    assertThat(response.isSuccessful()).isTrue();
     assertThat(response.body()).isEqualTo("Hi");
   }
 
@@ -108,7 +113,7 @@
     server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
 
     Response<String> response = example.getString().execute();
-    assertThat(response.isSuccess()).isFalse();
+    assertThat(response.isSuccessful()).isFalse();
     assertThat(response.code()).isEqualTo(404);
     assertThat(response.errorBody().string()).isEqualTo("Hi");
   }
@@ -125,19 +130,19 @@
     final AtomicReference<Response<String>> responseRef = new AtomicReference<>();
     final CountDownLatch latch = new CountDownLatch(1);
     example.getString().enqueue(new Callback<String>() {
-      @Override public void onResponse(Response<String> response) {
+      @Override public void onResponse(Call<String> call, Response<String> response) {
         responseRef.set(response);
         latch.countDown();
       }
 
-      @Override public void onFailure(Throwable t) {
+      @Override public void onFailure(Call<String> call, Throwable t) {
         t.printStackTrace();
       }
     });
-    assertTrue(latch.await(2, SECONDS));
+    assertTrue(latch.await(10, SECONDS));
 
     Response<String> response = responseRef.get();
-    assertThat(response.isSuccess()).isFalse();
+    assertThat(response.isSuccessful()).isFalse();
     assertThat(response.code()).isEqualTo(404);
     assertThat(response.errorBody().string()).isEqualTo("Hi");
   }
@@ -171,16 +176,16 @@
     final AtomicReference<Throwable> failureRef = new AtomicReference<>();
     final CountDownLatch latch = new CountDownLatch(1);
     example.getString().enqueue(new Callback<String>() {
-      @Override public void onResponse(Response<String> response) {
+      @Override public void onResponse(Call<String> call, Response<String> response) {
         throw new AssertionError();
       }
 
-      @Override public void onFailure(Throwable t) {
+      @Override public void onFailure(Call<String> call, Throwable t) {
         failureRef.set(t);
         latch.countDown();
       }
     });
-    assertTrue(latch.await(2, SECONDS));
+    assertTrue(latch.await(10, SECONDS));
 
     Throwable failure = failureRef.get();
     assertThat(failure).isInstanceOf(IOException.class);
@@ -191,7 +196,8 @@
         .baseUrl(server.url("/"))
         .addConverterFactory(new ToStringConverterFactory() {
           @Override
-          public Converter<?, RequestBody> requestBodyConverter(Type type, Annotation[] annotations,
+          public Converter<?, RequestBody> requestBodyConverter(Type type,
+              Annotation[] parameterAnnotations, Annotation[] methodAnnotations,
               Retrofit retrofit) {
             return new Converter<String, RequestBody>() {
               @Override public RequestBody convert(String value) throws IOException {
@@ -217,7 +223,8 @@
         .baseUrl(server.url("/"))
         .addConverterFactory(new ToStringConverterFactory() {
           @Override
-          public Converter<?, RequestBody> requestBodyConverter(Type type, Annotation[] annotations,
+          public Converter<?, RequestBody> requestBodyConverter(Type type,
+              Annotation[] parameterAnnotations, Annotation[] methodAnnotations,
               Retrofit retrofit) {
             return new Converter<String, RequestBody>() {
               @Override public RequestBody convert(String value) throws IOException {
@@ -232,16 +239,16 @@
     final AtomicReference<Throwable> failureRef = new AtomicReference<>();
     final CountDownLatch latch = new CountDownLatch(1);
     example.postString("Hi").enqueue(new Callback<String>() {
-      @Override public void onResponse(Response<String> response) {
+      @Override public void onResponse(Call<String> call, Response<String> response) {
         throw new AssertionError();
       }
 
-      @Override public void onFailure(Throwable t) {
+      @Override public void onFailure(Call<String> call, Throwable t) {
         failureRef.set(t);
         latch.countDown();
       }
     });
-    assertTrue(latch.await(2, SECONDS));
+    assertTrue(latch.await(10, SECONDS));
 
     assertThat(failureRef.get()).isInstanceOf(UnsupportedOperationException.class)
         .hasMessage("I am broken!");
@@ -277,20 +284,20 @@
 
   @Test public void conversionProblemIncomingMaskedByConverterIsUnwrapped() throws IOException {
     // MWS has no way to trigger IOExceptions during the response body so use an interceptor.
-    OkHttpClient client = new OkHttpClient();
-    client.interceptors().add(new Interceptor() {
-      @Override public com.squareup.okhttp.Response intercept(Chain chain) throws IOException {
-        com.squareup.okhttp.Response response = chain.proceed(chain.request());
-        ResponseBody body = response.body();
-        BufferedSource source = Okio.buffer(new ForwardingSource(body.source()) {
-          @Override public long read(Buffer sink, long byteCount) throws IOException {
-            throw new IOException("cause");
+    OkHttpClient client = new OkHttpClient.Builder() //
+        .addInterceptor(new Interceptor() {
+          @Override public okhttp3.Response intercept(Chain chain) throws IOException {
+            okhttp3.Response response = chain.proceed(chain.request());
+            ResponseBody body = response.body();
+            BufferedSource source = Okio.buffer(new ForwardingSource(body.source()) {
+              @Override public long read(Buffer sink, long byteCount) throws IOException {
+                throw new IOException("cause");
+              }
+            });
+            body = ResponseBody.create(body.contentType(), body.contentLength(), source);
+            return response.newBuilder().body(body).build();
           }
-        });
-        body = ResponseBody.create(body.contentType(), body.contentLength(), source);
-        return response.newBuilder().body(body).build();
-      }
-    });
+        }).build();
 
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
@@ -347,16 +354,16 @@
     final AtomicReference<Throwable> failureRef = new AtomicReference<>();
     final CountDownLatch latch = new CountDownLatch(1);
     example.postString("Hi").enqueue(new Callback<String>() {
-      @Override public void onResponse(Response<String> response) {
+      @Override public void onResponse(Call<String> call, Response<String> response) {
         throw new AssertionError();
       }
 
-      @Override public void onFailure(Throwable t) {
+      @Override public void onFailure(Call<String> call, Throwable t) {
         failureRef.set(t);
         latch.countDown();
       }
     });
-    assertTrue(latch.await(2, SECONDS));
+    assertTrue(latch.await(10, SECONDS));
 
     assertThat(failureRef.get()).isInstanceOf(UnsupportedOperationException.class)
         .hasMessage("I am broken!");
@@ -568,8 +575,8 @@
     assertThat(call.isExecuted()).isFalse();
 
     call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Response<String> response) {}
-      @Override public void onFailure(Throwable t) {}
+      @Override public void onResponse(Call<String> call, Response<String> response) {}
+      @Override public void onFailure(Call<String> call, Throwable t) {}
     });
     assertThat(call.isExecuted()).isTrue();
   }
@@ -607,16 +614,16 @@
     final AtomicReference<Throwable> failureRef = new AtomicReference<>();
     final CountDownLatch latch = new CountDownLatch(1);
     call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Response<String> response) {
+      @Override public void onResponse(Call<String> call, Response<String> response) {
         throw new AssertionError();
       }
 
-      @Override public void onFailure(Throwable t) {
+      @Override public void onFailure(Call<String> call, Throwable t) {
         failureRef.set(t);
         latch.countDown();
       }
     });
-    latch.await();
+    assertTrue(latch.await(10, SECONDS));
     assertThat(failureRef.get()).hasMessage("Canceled");
   }
 
@@ -651,11 +658,11 @@
     final AtomicReference<Throwable> failureRef = new AtomicReference<>();
     final CountDownLatch latch = new CountDownLatch(1);
     call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Response<String> response) {
+      @Override public void onResponse(Call<String> call, Response<String> response) {
         throw new AssertionError();
       }
 
-      @Override public void onFailure(Throwable t) {
+      @Override public void onFailure(Call<String> call, Throwable t) {
         failureRef.set(t);
         latch.countDown();
       }
@@ -664,7 +671,578 @@
     call.cancel();
     assertThat(call.isCanceled()).isTrue();
 
-    assertTrue(latch.await(2, SECONDS));
+    assertTrue(latch.await(10, SECONDS));
+    assertThat(failureRef.get()).isInstanceOf(IOException.class).hasMessage("Canceled");
+  }
+
+  @Test public void cancelOkHttpRequest() throws InterruptedException {
+    OkHttpClient client = new OkHttpClient();
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .client(client)
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service service = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.NO_RESPONSE));
+
+    Call<String> call = service.getString();
+
+    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    call.enqueue(new Callback<String>() {
+      @Override public void onResponse(Call<String> call, Response<String> response) {
+        throw new AssertionError();
+      }
+
+      @Override public void onFailure(Call<String> call, Throwable t) {
+        failureRef.set(t);
+        latch.countDown();
+      }
+    });
+
+    // Cancel the underlying HTTP Call. Should be reflected accurately back in the Retrofit Call.
+    client.dispatcher().cancelAll();
+    assertThat(call.isCanceled()).isTrue();
+
+    assertTrue(latch.await(10, SECONDS));
     assertThat(failureRef.get()).isInstanceOf(IOException.class).hasMessage("Canceled");
   }
+
+  @Test public void requestBeforeExecuteCreates() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service service = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse());
+
+    final AtomicInteger writeCount = new AtomicInteger();
+    Object a = new Object() {
+      @Override public String toString() {
+        writeCount.incrementAndGet();
+        return "Hello";
+      }
+    };
+    Call<String> call = service.postRequestBody(a);
+
+    call.request();
+    assertThat(writeCount.get()).isEqualTo(1);
+
+    call.execute();
+    assertThat(writeCount.get()).isEqualTo(1);
+  }
+
+  @Test public void requestThrowingBeforeExecuteFailsExecute() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service service = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse());
+
+    final AtomicInteger writeCount = new AtomicInteger();
+    Object a = new Object() {
+      @Override public String toString() {
+        writeCount.incrementAndGet();
+        throw new RuntimeException("Broken!");
+      }
+    };
+    Call<String> call = service.postRequestBody(a);
+
+    try {
+      call.request();
+      fail();
+    } catch (RuntimeException e) {
+      assertThat(e).hasMessage("Broken!");
+    }
+    assertThat(writeCount.get()).isEqualTo(1);
+
+    try {
+      call.execute();
+      fail();
+    } catch (RuntimeException e) {
+      assertThat(e).hasMessage("Broken!");
+    }
+    assertThat(writeCount.get()).isEqualTo(1);
+  }
+
+  @Test public void requestThrowingNonFatalErrorBeforeExecuteFailsExecute() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service service = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse());
+
+    final AtomicInteger writeCount = new AtomicInteger();
+    Object a = new Object() {
+      @Override public String toString() {
+        writeCount.incrementAndGet();
+        throw new Error("Broken!");
+      }
+    };
+    Call<String> call = service.postRequestBody(a);
+
+    try {
+      call.request();
+      fail();
+    } catch (Error e) {
+      assertThat(e).hasMessage("Broken!");
+    }
+    assertThat(writeCount.get()).isEqualTo(1);
+
+    try {
+      call.execute();
+      fail();
+    } catch (Error e) {
+      assertThat(e).hasMessage("Broken!");
+    }
+    assertThat(writeCount.get()).isEqualTo(1);
+  }
+
+  @Test public void requestAfterExecuteReturnsCachedValue() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service service = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse());
+
+    final AtomicInteger writeCount = new AtomicInteger();
+    Object a = new Object() {
+      @Override public String toString() {
+        writeCount.incrementAndGet();
+        return "Hello";
+      }
+    };
+    Call<String> call = service.postRequestBody(a);
+
+    call.execute();
+    assertThat(writeCount.get()).isEqualTo(1);
+
+    call.request();
+    assertThat(writeCount.get()).isEqualTo(1);
+  }
+
+  @Test public void requestAfterExecuteThrowingAlsoThrows() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service service = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse());
+
+    final AtomicInteger writeCount = new AtomicInteger();
+    Object a = new Object() {
+      @Override public String toString() {
+        writeCount.incrementAndGet();
+        throw new RuntimeException("Broken!");
+      }
+    };
+    Call<String> call = service.postRequestBody(a);
+
+    try {
+      call.execute();
+      fail();
+    } catch (RuntimeException e) {
+      assertThat(e).hasMessage("Broken!");
+    }
+    assertThat(writeCount.get()).isEqualTo(1);
+
+    try {
+      call.request();
+      fail();
+    } catch (RuntimeException e) {
+      assertThat(e).hasMessage("Broken!");
+    }
+    assertThat(writeCount.get()).isEqualTo(1);
+  }
+
+  @Test public void requestAfterExecuteThrowingAlsoThrowsForNonFatalErrors() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service service = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse());
+
+    final AtomicInteger writeCount = new AtomicInteger();
+    Object a = new Object() {
+      @Override public String toString() {
+        writeCount.incrementAndGet();
+        throw new Error("Broken!");
+      }
+    };
+    Call<String> call = service.postRequestBody(a);
+
+    try {
+      call.execute();
+      fail();
+    } catch (Error e) {
+      assertThat(e).hasMessage("Broken!");
+    }
+    assertThat(writeCount.get()).isEqualTo(1);
+
+    try {
+      call.request();
+      fail();
+    } catch (Error e) {
+      assertThat(e).hasMessage("Broken!");
+    }
+    assertThat(writeCount.get()).isEqualTo(1);
+  }
+
+  @Test public void requestBeforeEnqueueCreates() throws IOException, InterruptedException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service service = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse());
+
+    final AtomicInteger writeCount = new AtomicInteger();
+    Object a = new Object() {
+      @Override public String toString() {
+        writeCount.incrementAndGet();
+        return "Hello";
+      }
+    };
+    Call<String> call = service.postRequestBody(a);
+
+    call.request();
+    assertThat(writeCount.get()).isEqualTo(1);
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    call.enqueue(new Callback<String>() {
+      @Override public void onResponse(Call<String> call, Response<String> response) {
+        assertThat(writeCount.get()).isEqualTo(1);
+        latch.countDown();
+      }
+
+      @Override public void onFailure(Call<String> call, Throwable t) {
+      }
+    });
+    assertTrue(latch.await(10, SECONDS));
+  }
+
+  @Test public void requestThrowingBeforeEnqueueFailsEnqueue()
+      throws IOException, InterruptedException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service service = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse());
+
+    final AtomicInteger writeCount = new AtomicInteger();
+    Object a = new Object() {
+      @Override public String toString() {
+        writeCount.incrementAndGet();
+        throw new RuntimeException("Broken!");
+      }
+    };
+    Call<String> call = service.postRequestBody(a);
+
+    try {
+      call.request();
+      fail();
+    } catch (RuntimeException e) {
+      assertThat(e).hasMessage("Broken!");
+    }
+    assertThat(writeCount.get()).isEqualTo(1);
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    call.enqueue(new Callback<String>() {
+      @Override public void onResponse(Call<String> call, Response<String> response) {
+      }
+
+      @Override public void onFailure(Call<String> call, Throwable t) {
+        assertThat(t).isExactlyInstanceOf(RuntimeException.class).hasMessage("Broken!");
+        assertThat(writeCount.get()).isEqualTo(1);
+        latch.countDown();
+      }
+    });
+    assertTrue(latch.await(10, SECONDS));
+  }
+
+  @Test public void requestThrowingNonFatalErrorBeforeEnqueueFailsEnqueue()
+      throws IOException, InterruptedException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service service = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse());
+
+    final AtomicInteger writeCount = new AtomicInteger();
+    Object a = new Object() {
+      @Override public String toString() {
+        writeCount.incrementAndGet();
+        throw new Error("Broken!");
+      }
+    };
+    Call<String> call = service.postRequestBody(a);
+
+    try {
+      call.request();
+      fail();
+    } catch (Error e) {
+      assertThat(e).hasMessage("Broken!");
+    }
+    assertThat(writeCount.get()).isEqualTo(1);
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    call.enqueue(new Callback<String>() {
+      @Override public void onResponse(Call<String> call, Response<String> response) {
+      }
+
+      @Override public void onFailure(Call<String> call, Throwable t) {
+        assertThat(t).isExactlyInstanceOf(Error.class).hasMessage("Broken!");
+        assertThat(writeCount.get()).isEqualTo(1);
+        latch.countDown();
+      }
+    });
+    assertTrue(latch.await(10, SECONDS));
+  }
+
+  @Test public void requestAfterEnqueueReturnsCachedValue() throws IOException,
+      InterruptedException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service service = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse());
+
+    final AtomicInteger writeCount = new AtomicInteger();
+    Object a = new Object() {
+      @Override public String toString() {
+        writeCount.incrementAndGet();
+        return "Hello";
+      }
+    };
+    Call<String> call = service.postRequestBody(a);
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    call.enqueue(new Callback<String>() {
+      @Override public void onResponse(Call<String> call, Response<String> response) {
+        assertThat(writeCount.get()).isEqualTo(1);
+        latch.countDown();
+      }
+
+      @Override public void onFailure(Call<String> call, Throwable t) {
+      }
+    });
+    assertTrue(latch.await(10, SECONDS));
+
+    call.request();
+    assertThat(writeCount.get()).isEqualTo(1);
+  }
+
+  @Test public void requestAfterEnqueueFailingThrows() throws IOException,
+      InterruptedException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service service = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse());
+
+    final AtomicInteger writeCount = new AtomicInteger();
+    Object a = new Object() {
+      @Override public String toString() {
+        writeCount.incrementAndGet();
+        throw new RuntimeException("Broken!");
+      }
+    };
+    Call<String> call = service.postRequestBody(a);
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    call.enqueue(new Callback<String>() {
+      @Override public void onResponse(Call<String> call, Response<String> response) {
+      }
+
+      @Override public void onFailure(Call<String> call, Throwable t) {
+        assertThat(t).isExactlyInstanceOf(RuntimeException.class).hasMessage("Broken!");
+        assertThat(writeCount.get()).isEqualTo(1);
+        latch.countDown();
+      }
+    });
+    assertTrue(latch.await(10, SECONDS));
+
+    try {
+      call.request();
+      fail();
+    } catch (RuntimeException e) {
+      assertThat(e).hasMessage("Broken!");
+    }
+    assertThat(writeCount.get()).isEqualTo(1);
+  }
+
+  @Test public void requestAfterEnqueueFailingThrowsForNonFatalErrors() throws IOException,
+      InterruptedException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service service = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse());
+
+    final AtomicInteger writeCount = new AtomicInteger();
+    Object a = new Object() {
+      @Override public String toString() {
+        writeCount.incrementAndGet();
+        throw new Error("Broken!");
+      }
+    };
+    Call<String> call = service.postRequestBody(a);
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    call.enqueue(new Callback<String>() {
+      @Override public void onResponse(Call<String> call, Response<String> response) {
+      }
+
+      @Override public void onFailure(Call<String> call, Throwable t) {
+        assertThat(t).isExactlyInstanceOf(Error.class).hasMessage("Broken!");
+        assertThat(writeCount.get()).isEqualTo(1);
+        latch.countDown();
+      }
+    });
+    assertTrue(latch.await(10, SECONDS));
+
+    try {
+      call.request();
+      fail();
+    } catch (Error e) {
+      assertThat(e).hasMessage("Broken!");
+    }
+    assertThat(writeCount.get()).isEqualTo(1);
+  }
+
+  @Test public void fatalErrorsAreNotCaughtRequest() throws Exception {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service service = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse());
+
+    final AtomicInteger writeCount = new AtomicInteger();
+    Object a = new Object() {
+      @Override public String toString() {
+        writeCount.incrementAndGet();
+        throw new OutOfMemoryError("Broken!");
+      }
+    };
+    Call<String> call = service.postRequestBody(a);
+
+    try {
+      call.request();
+      fail();
+    } catch (OutOfMemoryError e) {
+      assertThat(e).hasMessage("Broken!");
+    }
+    assertThat(writeCount.get()).isEqualTo(1);
+
+    try {
+      call.request();
+      fail();
+    } catch (OutOfMemoryError e) {
+      assertThat(e).hasMessage("Broken!");
+    }
+    assertThat(writeCount.get()).isEqualTo(2);
+  }
+
+  @Test public void fatalErrorsAreNotCaughtEnqueue() throws Exception {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service service = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse());
+
+    final AtomicInteger writeCount = new AtomicInteger();
+    Object a = new Object() {
+      @Override public String toString() {
+        writeCount.incrementAndGet();
+        throw new OutOfMemoryError("Broken!");
+      }
+    };
+    Call<String> call = service.postRequestBody(a);
+
+    try {
+      final AtomicBoolean callsFailureSynchronously = new AtomicBoolean();
+      call.enqueue(new Callback<String>() {
+        @Override public void onResponse(Call<String> call, Response<String> response) {
+        }
+
+        @Override public void onFailure(Call<String> call, Throwable t) {
+          callsFailureSynchronously.set(true); // Will not be called for fatal errors.
+        }
+      });
+      assertThat(callsFailureSynchronously.get()).isFalse();
+      fail();
+    } catch (OutOfMemoryError e) {
+      assertThat(e).hasMessage("Broken!");
+    }
+    assertThat(writeCount.get()).isEqualTo(1);
+
+    try {
+      call.request();
+      fail();
+    } catch (OutOfMemoryError e) {
+      assertThat(e).hasMessage("Broken!");
+    }
+    assertThat(writeCount.get()).isEqualTo(2);
+  }
+
+  @Test public void fatalErrorsAreNotCaughtExecute() throws Exception {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service service = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse());
+
+    final AtomicInteger writeCount = new AtomicInteger();
+    Object a = new Object() {
+      @Override public String toString() {
+        writeCount.incrementAndGet();
+        throw new OutOfMemoryError("Broken!");
+      }
+    };
+    Call<String> call = service.postRequestBody(a);
+
+    try {
+      call.execute();
+      fail();
+    } catch (OutOfMemoryError e) {
+      assertThat(e).hasMessage("Broken!");
+    }
+    assertThat(writeCount.get()).isEqualTo(1);
+
+    try {
+      call.request();
+      fail();
+    } catch (OutOfMemoryError e) {
+      assertThat(e).hasMessage("Broken!");
+    }
+    assertThat(writeCount.get()).isEqualTo(2);
+  }
 }
diff --git a/retrofit/src/test/java/retrofit2/ExecutorCallAdapterFactoryTest.java b/retrofit/src/test/java/retrofit2/ExecutorCallAdapterFactoryTest.java
index a838193ea..6f1480d23 100644
--- a/retrofit/src/test/java/retrofit2/ExecutorCallAdapterFactoryTest.java
+++ b/retrofit/src/test/java/retrofit2/ExecutorCallAdapterFactoryTest.java
@@ -21,6 +21,7 @@
 import java.lang.reflect.Type;
 import java.util.List;
 import java.util.concurrent.Executor;
+import okhttp3.Request;
 import org.junit.Test;
 
 import static org.assertj.core.api.Assertions.assertThat;
@@ -55,17 +56,6 @@
     }
   }
 
-  @Test public void responseThrows() {
-    Type returnType = new TypeToken<Call<Response<String>>>() {}.getType();
-    try {
-      factory.get(returnType, NO_ANNOTATIONS, retrofit);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Call<T> cannot use Response as its generic parameter. "
-          + "Specify the response body type only (e.g., Call<TweetResponse>).");
-    }
-  }
-
   @Test public void responseType() {
     Type classType = new TypeToken<Call<String>>() {}.getType();
     assertThat(factory.get(classType, NO_ANNOTATIONS, retrofit).responseType())
@@ -80,10 +70,10 @@
 
   @Test public void adaptedCallExecute() throws IOException {
     Type returnType = new TypeToken<Call<String>>() {}.getType();
-    CallAdapter<Call<?>> adapter =
-        (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
+    CallAdapter<String, Call<String>> adapter =
+        (CallAdapter<String, Call<String>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
     final Response<String> response = Response.success("Hi");
-    Call<String> call = (Call<String>) adapter.adapt(new EmptyCall() {
+    Call<String> call = adapter.adapt(new EmptyCall() {
       @Override public Response<String> execute() throws IOException {
         return response;
       }
@@ -93,42 +83,44 @@
 
   @Test public void adaptedCallEnqueueUsesExecutorForSuccessCallback() {
     Type returnType = new TypeToken<Call<String>>() {}.getType();
-    CallAdapter<Call<?>> adapter =
-        (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
+    CallAdapter<String, Call<String>> adapter =
+        (CallAdapter<String, Call<String>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
     final Response<String> response = Response.success("Hi");
-    Call<String> call = (Call<String>) adapter.adapt(new EmptyCall() {
+    EmptyCall originalCall = new EmptyCall() {
       @Override public void enqueue(Callback<String> callback) {
-        callback.onResponse(response);
+        callback.onResponse(this, response);
       }
-    });
+    };
+    Call<String> call = adapter.adapt(originalCall);
     call.enqueue(callback);
     verify(callbackExecutor).execute(any(Runnable.class));
-    verify(callback).onResponse(response);
+    verify(callback).onResponse(call, response);
   }
 
   @Test public void adaptedCallEnqueueUsesExecutorForFailureCallback() {
     Type returnType = new TypeToken<Call<String>>() {}.getType();
-    CallAdapter<Call<?>> adapter =
-        (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
+    CallAdapter<String, Call<String>> adapter =
+        (CallAdapter<String, Call<String>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
     final Throwable throwable = new IOException();
-    Call<String> call = (Call<String>) adapter.adapt(new EmptyCall() {
+    EmptyCall originalCall = new EmptyCall() {
       @Override public void enqueue(Callback<String> callback) {
-        callback.onFailure(throwable);
+        callback.onFailure(this, throwable);
       }
-    });
+    };
+    Call<String> call = adapter.adapt(originalCall);
     call.enqueue(callback);
     verify(callbackExecutor).execute(any(Runnable.class));
     verifyNoMoreInteractions(callbackExecutor);
-    verify(callback).onFailure(throwable);
+    verify(callback).onFailure(call, throwable);
     verifyNoMoreInteractions(callback);
   }
 
   @Test public void adaptedCallCloneDeepCopy() {
     Type returnType = new TypeToken<Call<String>>() {}.getType();
-    CallAdapter<Call<?>> adapter =
-        (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
+    CallAdapter<String, Call<String>> adapter =
+        (CallAdapter<String, Call<String>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
     Call<String> delegate = mock(Call.class);
-    Call<String> call = (Call<String>) adapter.adapt(delegate);
+    Call<String> call = adapter.adapt(delegate);
     Call<String> cloned = call.clone();
     assertThat(cloned).isNotSameAs(call);
     verify(delegate).clone();
@@ -137,10 +129,10 @@
 
   @Test public void adaptedCallCancel() {
     Type returnType = new TypeToken<Call<String>>() {}.getType();
-    CallAdapter<Call<?>> adapter =
-        (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
+    CallAdapter<String, Call<String>> adapter =
+        (CallAdapter<String, Call<String>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
     Call<String> delegate = mock(Call.class);
-    Call<String> call = (Call<String>) adapter.adapt(delegate);
+    Call<String> call = adapter.adapt(delegate);
     call.cancel();
     verify(delegate).cancel();
     verifyNoMoreInteractions(delegate);
@@ -170,5 +162,9 @@
     @Override public Call<String> clone() {
       throw new UnsupportedOperationException();
     }
+
+    @Override public Request request() {
+      throw new UnsupportedOperationException();
+    }
   }
 }
diff --git a/retrofit/src/test/java/retrofit2/HttpExceptionTest.java b/retrofit/src/test/java/retrofit2/HttpExceptionTest.java
new file mode 100644
index 000000000..37fa3722c
--- /dev/null
+++ b/retrofit/src/test/java/retrofit2/HttpExceptionTest.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import org.junit.Test;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class HttpExceptionTest {
+  @Test public void response() {
+    Response<String> response = Response.success("Hi");
+    HttpException exception = new HttpException(response);
+    assertThat(exception.code()).isEqualTo(200);
+    assertThat(exception.message()).isEqualTo("OK");
+    assertThat(exception.response()).isSameAs(response);
+  }
+
+  @Test public void nullResponseThrows() {
+    try {
+      new HttpException(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("response == null");
+    }
+  }
+}
diff --git a/retrofit/src/test/java/retrofit2/Java8DefaultMethodsTest.java b/retrofit/src/test/java/retrofit2/Java8DefaultMethodsTest.java
new file mode 100644
index 000000000..8333969c6
--- /dev/null
+++ b/retrofit/src/test/java/retrofit2/Java8DefaultMethodsTest.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+// TODO this test doesn't play nice in the IDE because it relies on Java 8 language features.
+public final class Java8DefaultMethodsTest {
+  //@Rule public final MockWebServer server = new MockWebServer();
+  //
+  //interface Example {
+  //  @GET("/") Call<String> user(@Query("name") String name);
+  //
+  //  default Call<String> user() {
+  //    return user("hey");
+  //  }
+  //}
+  //
+  //@Test public void test() throws IOException {
+  //  server.enqueue(new MockResponse().setBody("Hi"));
+  //  server.enqueue(new MockResponse().setBody("Hi"));
+  //
+  //  Retrofit retrofit = new Retrofit.Builder()
+  //      .baseUrl(server.url("/"))
+  //      .addConverterFactory(new ToStringConverterFactory())
+  //      .build();
+  //  Example example = retrofit.create(Example.class);
+  //
+  //  Response<String> response = example.user().execute();
+  //  assertThat(response.body()).isEqualTo("Hi");
+  //  Response<String> response = example.user("hi").execute();
+  //  assertThat(response.body()).isEqualTo("Hi");
+  //}
+}
diff --git a/retrofit/src/test/java/retrofit2/RequestBuilderAndroidTest.java b/retrofit/src/test/java/retrofit2/RequestBuilderAndroidTest.java
new file mode 100644
index 000000000..63fa57b6c
--- /dev/null
+++ b/retrofit/src/test/java/retrofit2/RequestBuilderAndroidTest.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import android.net.Uri;
+import okhttp3.Request;
+import okhttp3.ResponseBody;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import retrofit2.http.GET;
+import retrofit2.http.Url;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static retrofit2.RequestBuilderTest.buildRequest;
+
+@RunWith(RobolectricTestRunner.class)
+@SuppressWarnings({"UnusedParameters", "unused"}) // Parameters inspected reflectively.
+public final class RequestBuilderAndroidTest {
+  @Test public void getWithAndroidUriUrl() {
+    class Example {
+      @GET
+      Call<ResponseBody> method(@Url Uri url) {
+        return null;
+      }
+    }
+
+    Request request = buildRequest(Example.class, Uri.parse("foo/bar/"));
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithAndroidUriUrlAbsolute() {
+    class Example {
+      @GET
+      Call<ResponseBody> method(@Url Uri url) {
+        return null;
+      }
+    }
+
+    Request request = buildRequest(Example.class, Uri.parse("https://example2.com/foo/bar/"));
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("https://example2.com/foo/bar/");
+    assertThat(request.body()).isNull();
+  }
+}
diff --git a/retrofit/src/test/java/retrofit2/RequestBuilderTest.java b/retrofit/src/test/java/retrofit2/RequestBuilderTest.java
index 4e2f5968d..9d12f6654 100644
--- a/retrofit/src/test/java/retrofit2/RequestBuilderTest.java
+++ b/retrofit/src/test/java/retrofit2/RequestBuilderTest.java
@@ -1,25 +1,42 @@
-// Copyright 2013 Square, Inc.
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package retrofit2;
 
-import com.squareup.okhttp.Interceptor;
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.Response;
-import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
 import java.lang.reflect.Method;
 import java.math.BigInteger;
+import java.net.URI;
 import java.util.Arrays;
 import java.util.Collections;
+import java.util.HashMap;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.HttpUrl;
+import okhttp3.MediaType;
+import okhttp3.MultipartBody;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
 import okio.Buffer;
 import org.junit.Ignore;
 import org.junit.Test;
+import retrofit2.helpers.NullObjectConverterFactory;
+import retrofit2.helpers.ToStringConverterFactory;
 import retrofit2.http.Body;
 import retrofit2.http.DELETE;
 import retrofit2.http.Field;
@@ -29,6 +46,7 @@
 import retrofit2.http.HEAD;
 import retrofit2.http.HTTP;
 import retrofit2.http.Header;
+import retrofit2.http.HeaderMap;
 import retrofit2.http.Headers;
 import retrofit2.http.Multipart;
 import retrofit2.http.OPTIONS;
@@ -40,6 +58,7 @@
 import retrofit2.http.Path;
 import retrofit2.http.Query;
 import retrofit2.http.QueryMap;
+import retrofit2.http.QueryName;
 import retrofit2.http.Url;
 
 import static org.assertj.core.api.Assertions.assertThat;
@@ -60,11 +79,10 @@
 
     Request request = buildRequest(Example.class);
     assertThat(request.method()).isEqualTo("CUSTOM1");
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo");
     assertThat(request.body()).isNull();
   }
 
-  @Ignore("https://github.com/square/okhttp/issues/229")
   @Test public void customMethodWithBody() {
     class Example {
       @HTTP(method = "CUSTOM2", path = "/foo", hasBody = true)
@@ -76,7 +94,7 @@
     RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
     Request request = buildRequest(Example.class, body);
     assertThat(request.method()).isEqualTo("CUSTOM2");
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo");
     assertBody(request.body(), "hi");
   }
 
@@ -177,7 +195,7 @@
       }
     }
     Request request = buildRequest(Example.class, "yep");
-    assertThat(request.urlString()).isEqualTo("http://example.com/?maybe=yep");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/?maybe=yep");
   }
 
   @Test public void twoMethodsFail() {
@@ -193,8 +211,9 @@
       buildRequest(Example.class);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Only one HTTP method is allowed. Found: PATCH and POST.\n    for method Example.method");
+        assertThat(e.getMessage())
+            .isIn("Only one HTTP method is allowed. Found: PATCH and POST.\n    for method Example.method",
+                  "Only one HTTP method is allowed. Found: POST and PATCH.\n    for method Example.method");
     }
   }
 
@@ -441,6 +460,40 @@
     }
   }
 
+  @Test public void queryMapSupportsSubclasses() {
+    class Foo extends HashMap<String, String> {
+    }
+
+    class Example {
+      @GET("/") //
+      Call<ResponseBody> method(@QueryMap Foo a) {
+        return null;
+      }
+    }
+
+    Foo foo = new Foo();
+    foo.put("hello", "world");
+
+    Request request = buildRequest(Example.class, foo);
+    assertThat(request.url().toString()).isEqualTo("http://example.com/?hello=world");
+  }
+
+  @Test public void queryMapRejectsNull() {
+    class Example {
+      @GET("/") //
+      Call<ResponseBody> method(@QueryMap Map<String, String> a) {
+        return null;
+      }
+    }
+
+    try {
+      buildRequest(Example.class, new Object[] { null });
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Query map was null.");
+    }
+  }
+
   @Test public void queryMapRejectsNullKeys() {
     class Example {
       @GET("/") //
@@ -461,6 +514,139 @@
     }
   }
 
+  @Test public void queryMapRejectsNullValues() {
+    class Example {
+      @GET("/") //
+      Call<ResponseBody> method(@QueryMap Map<String, String> a) {
+        return null;
+      }
+    }
+
+    Map<String, String> queryParams = new LinkedHashMap<>();
+    queryParams.put("ping", "pong");
+    queryParams.put("kit", null);
+
+    try {
+      buildRequest(Example.class, queryParams);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Query map contained null value for key 'kit'.");
+    }
+  }
+
+  @Test public void getWithHeaderMap() {
+    class Example {
+      @GET("/search")
+      Call<ResponseBody> method(@HeaderMap Map<String, Object> headers) {
+        return null;
+      }
+    }
+
+    Map<String, Object> headers = new LinkedHashMap<>();
+    headers.put("Accept", "text/plain");
+    headers.put("Accept-Charset", "utf-8");
+
+    Request request = buildRequest(Example.class, headers);
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/search");
+    assertThat(request.body()).isNull();
+    assertThat(request.headers().size()).isEqualTo(2);
+    assertThat(request.header("Accept")).isEqualTo("text/plain");
+    assertThat(request.header("Accept-Charset")).isEqualTo("utf-8");
+  }
+
+  @Test public void headerMapMustBeAMap() {
+    class Example {
+      @GET("/")
+      Call<ResponseBody> method(@HeaderMap List<String> headers) {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "@HeaderMap parameter type must be Map. (parameter #1)\n    for method Example.method");
+    }
+  }
+
+  @Test public void headerMapSupportsSubclasses() {
+    class Foo extends HashMap<String, String> {
+    }
+
+    class Example {
+      @GET("/search")
+      Call<ResponseBody> method(@HeaderMap Foo headers) {
+        return null;
+      }
+    }
+
+    Foo headers = new Foo();
+    headers.put("Accept", "text/plain");
+
+    Request request = buildRequest(Example.class, headers);
+    assertThat(request.url().toString()).isEqualTo("http://example.com/search");
+    assertThat(request.headers().size()).isEqualTo(1);
+    assertThat(request.header("Accept")).isEqualTo("text/plain");
+  }
+
+  @Test public void headerMapRejectsNull() {
+    class Example {
+      @GET("/")
+      Call<ResponseBody> method(@HeaderMap Map<String, String> headers) {
+        return null;
+      }
+    }
+
+    try {
+      buildRequest(Example.class, (Map<String, String>) null);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Header map was null.");
+    }
+  }
+
+  @Test public void headerMapRejectsNullKeys() {
+    class Example {
+      @GET("/")
+      Call<ResponseBody> method(@HeaderMap Map<String, String> headers) {
+        return null;
+      }
+    }
+
+    Map<String, String> headers = new LinkedHashMap<>();
+    headers.put("Accept", "text/plain");
+    headers.put(null, "utf-8");
+
+    try {
+      buildRequest(Example.class, headers);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Header map contained null key.");
+    }
+  }
+
+  @Test public void headerMapRejectsNullValues() {
+    class Example {
+      @GET("/")
+      Call<ResponseBody> method(@HeaderMap Map<String, String> headers) {
+        return null;
+      }
+    }
+
+    Map<String, String> headers = new LinkedHashMap<>();
+    headers.put("Accept", "text/plain");
+    headers.put("Accept-Charset", null);
+
+    try {
+      buildRequest(Example.class, headers);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Header map contained null value for key 'Accept-Charset'.");
+    }
+  }
+
   @Test public void twoBodies() {
     class Example {
       @PUT("/") //
@@ -504,7 +690,7 @@
     Request request = buildRequest(Example.class);
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
     assertThat(request.body()).isNull();
   }
 
@@ -518,7 +704,7 @@
     Request request = buildRequest(Example.class);
     assertThat(request.method()).isEqualTo("DELETE");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
     assertNull(request.body());
   }
 
@@ -532,7 +718,7 @@
     Request request = buildRequest(Example.class);
     assertThat(request.method()).isEqualTo("HEAD");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
     assertThat(request.body()).isNull();
   }
 
@@ -562,7 +748,7 @@
     Request request = buildRequest(Example.class, body);
     assertThat(request.method()).isEqualTo("POST");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
     assertBody(request.body(), "hi");
   }
 
@@ -577,7 +763,7 @@
     Request request = buildRequest(Example.class, body);
     assertThat(request.method()).isEqualTo("PUT");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
     assertBody(request.body(), "hi");
   }
 
@@ -592,7 +778,7 @@
     Request request = buildRequest(Example.class, body);
     assertThat(request.method()).isEqualTo("PATCH");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
     assertBody(request.body(), "hi");
   }
 
@@ -606,7 +792,7 @@
     Request request = buildRequest(Example.class);
     assertThat(request.method()).isEqualTo("OPTIONS");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
     assertThat(request.body()).isNull();
   }
 
@@ -620,7 +806,7 @@
     Request request = buildRequest(Example.class, "po ng");
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/po%20ng/");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/po%20ng/");
     assertThat(request.body()).isNull();
   }
 
@@ -634,7 +820,7 @@
     Request request = buildRequest(Example.class, "pong");
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/pong/%7Bkit,kat%7D/");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong/%7Bkit,kat%7D/");
     assertThat(request.body()).isNull();
   }
 
@@ -648,7 +834,49 @@
     Request request = buildRequest(Example.class, "po%20ng");
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/po%20ng/");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/po%20ng/");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithEncodedPathSegments() {
+    class Example {
+      @GET("/foo/bar/{ping}/") //
+      Call<ResponseBody> method(@Path(value = "ping", encoded = true) String ping) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, "baz/pong/more");
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/baz/pong/more/");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithUnencodedPathSegmentsPreventsRequestSplitting() {
+    class Example {
+      @GET("/foo/bar/{ping}/") //
+      Call<ResponseBody> method(@Path(value = "ping", encoded = false) String ping) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, "baz/\r\nheader: blue");
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/baz%2F%0D%0Aheader:%20blue/");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithEncodedPathStillPreventsRequestSplitting() {
+    class Example {
+      @GET("/foo/bar/{ping}/") //
+      Call<ResponseBody> method(@Path(value = "ping", encoded = true) String ping) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, "baz/\r\npong");
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/baz/pong/");
     assertThat(request.body()).isNull();
   }
 
@@ -677,7 +905,7 @@
     Request request = buildRequest(Example.class, "pong");
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?ping=pong");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?ping=pong");
     assertThat(request.body()).isNull();
   }
 
@@ -691,7 +919,7 @@
     Request request = buildRequest(Example.class, "p%20o%20n%20g");
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?pi%20ng=p%20o%20n%20g");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?pi%20ng=p%20o%20n%20g");
     assertThat(request.body()).isNull();
   }
 
@@ -703,7 +931,7 @@
       }
     }
     Request request = buildRequest(Example.class, new Object[] { null });
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
   }
 
   @Test public void queryParamOptional() {
@@ -715,7 +943,7 @@
       }
     }
     Request request = buildRequest(Example.class, "bar", null, "kat");
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?foo=bar&kit=kat");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?foo=bar&kit=kat");
   }
 
   @Test public void getWithQueryUrlAndParam() {
@@ -728,7 +956,7 @@
     Request request = buildRequest(Example.class, "pong");
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?hi=mom&ping=pong");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?hi=mom&ping=pong");
     assertThat(request.body()).isNull();
   }
 
@@ -742,7 +970,7 @@
     Request request = buildRequest(Example.class);
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?hi=mom");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?hi=mom");
     assertThat(request.body()).isNull();
   }
 
@@ -758,7 +986,7 @@
     Request request = buildRequest(Example.class, "pong", "kat", "raff");
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/pong/?kit=kat&riff=raff");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong/?kit=kat&riff=raff");
     assertThat(request.body()).isNull();
   }
 
@@ -790,7 +1018,8 @@
     Request request = buildRequest(Example.class, "pong?", "kat?");
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/pong%3F/?kit=kat?");
+    assertThat(request.url().toString())
+        .isEqualTo("http://example.com/foo/bar/pong%3F/?kit=kat%3F");
     assertThat(request.body()).isNull();
   }
 
@@ -805,7 +1034,7 @@
     Request request = buildRequest(Example.class, "pong&", "kat&");
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/pong&/?kit=kat%26");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong&/?kit=kat%26");
     assertThat(request.body()).isNull();
   }
 
@@ -820,7 +1049,7 @@
     Request request = buildRequest(Example.class, "pong#", "kat#");
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/pong%23/?kit=kat%23");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong%23/?kit=kat%23");
     assertThat(request.body()).isNull();
   }
 
@@ -832,11 +1061,11 @@
       }
     }
 
-    List<Object> values = Arrays.<Object>asList(1, 2, null, "three");
+    List<Object> values = Arrays.<Object>asList(1, 2, null, "three", "1");
     Request request = buildRequest(Example.class, values);
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?key=1&key=2&key=three");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?key=1&key=2&key=three&key=1");
     assertThat(request.body()).isNull();
   }
 
@@ -848,11 +1077,11 @@
       }
     }
 
-    Object[] values = { 1, 2, null, "three" };
+    Object[] values = { 1, 2, null, "three", "1" };
     Request request = buildRequest(Example.class, new Object[] { values });
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?key=1&key=2&key=three");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?key=1&key=2&key=three&key=1");
     assertThat(request.body()).isNull();
   }
 
@@ -864,11 +1093,98 @@
       }
     }
 
-    int[] values = { 1, 2, 3 };
+    int[] values = { 1, 2, 3, 1 };
+    Request request = buildRequest(Example.class, new Object[] { values });
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?key=1&key=2&key=3&key=1");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithQueryNameParam() {
+    class Example {
+      @GET("/foo/bar/") //
+      Call<ResponseBody> method(@QueryName String ping) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, "pong");
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?pong");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithEncodedQueryNameParam() {
+    class Example {
+      @GET("/foo/bar/") //
+      Call<ResponseBody> method(@QueryName(encoded = true) String ping) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, "p%20o%20n%20g");
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?p%20o%20n%20g");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void queryNameParamOptionalOmitsQuery() {
+    class Example {
+      @GET("/foo/bar/") //
+      Call<ResponseBody> method(@QueryName String ping) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, new Object[] { null });
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+  }
+
+  @Test public void getWithQueryNameParamList() {
+    class Example {
+      @GET("/foo/bar/") //
+      Call<ResponseBody> method(@QueryName List<Object> keys) {
+        return null;
+      }
+    }
+
+    List<Object> values = Arrays.<Object>asList(1, 2, null, "three", "1");
+    Request request = buildRequest(Example.class, values);
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?1&2&three&1");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithQueryNameParamArray() {
+    class Example {
+      @GET("/foo/bar/") //
+      Call<ResponseBody> method(@QueryName Object[] keys) {
+        return null;
+      }
+    }
+
+    Object[] values = { 1, 2, null, "three", "1" };
+    Request request = buildRequest(Example.class, new Object[] { values });
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?1&2&three&1");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithQueryNameParamPrimitiveArray() {
+    class Example {
+      @GET("/foo/bar/") //
+      Call<ResponseBody> method(@QueryName int[] keys) {
+        return null;
+      }
+    }
+
+    int[] values = { 1, 2, 3, 1 };
     Request request = buildRequest(Example.class, new Object[] { values });
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?key=1&key=2&key=3");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?1&2&3&1");
     assertThat(request.body()).isNull();
   }
 
@@ -882,13 +1198,12 @@
 
     Map<String, Object> params = new LinkedHashMap<>();
     params.put("kit", "kat");
-    params.put("foo", null);
     params.put("ping", "pong");
 
     Request request = buildRequest(Example.class, params);
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?kit=kat&ping=pong");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?kit=kat&ping=pong");
     assertThat(request.body()).isNull();
   }
 
@@ -902,17 +1217,31 @@
 
     Map<String, Object> params = new LinkedHashMap<>();
     params.put("kit", "k%20t");
-    params.put("foo", null);
     params.put("pi%20ng", "p%20g");
 
     Request request = buildRequest(Example.class, params);
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?kit=k%20t&pi%20ng=p%20g");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?kit=k%20t&pi%20ng=p%20g");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getAbsoluteUrl() {
+    class Example {
+      @GET("http://example2.com/foo/bar/")
+      Call<ResponseBody> method() {
+        return null;
+      }
+    }
+
+    Request request = buildRequest(Example.class);
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example2.com/foo/bar/");
     assertThat(request.body()).isNull();
   }
 
-  @Test public void getWithUrl() {
+  @Test public void getWithStringUrl() {
     class Example {
       @GET
       Call<ResponseBody> method(@Url String url) {
@@ -923,26 +1252,26 @@
     Request request = buildRequest(Example.class, "foo/bar/");
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
     assertThat(request.body()).isNull();
   }
 
-  @Test public void getAbsoluteUrl() {
+  @Test public void getWithJavaUriUrl() {
     class Example {
-      @GET("http://example2.com/foo/bar/")
-      Call<ResponseBody> method() {
+      @GET
+      Call<ResponseBody> method(@Url URI url) {
         return null;
       }
     }
 
-    Request request = buildRequest(Example.class);
+    Request request = buildRequest(Example.class, URI.create("foo/bar/"));
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example2.com/foo/bar/");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
     assertThat(request.body()).isNull();
   }
 
-  @Test public void getWithUrlAbsolute() {
+  @Test public void getWithStringUrlAbsolute() {
     class Example {
       @GET
       Call<ResponseBody> method(@Url String url) {
@@ -953,7 +1282,22 @@
     Request request = buildRequest(Example.class, "https://example2.com/foo/bar/");
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("https://example2.com/foo/bar/");
+    assertThat(request.url().toString()).isEqualTo("https://example2.com/foo/bar/");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithJavaUriUrlAbsolute() {
+    class Example {
+      @GET
+      Call<ResponseBody> method(@Url URI url) {
+        return null;
+      }
+    }
+
+    Request request = buildRequest(Example.class, URI.create("https://example2.com/foo/bar/"));
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("https://example2.com/foo/bar/");
     assertThat(request.body()).isNull();
   }
 
@@ -968,40 +1312,73 @@
     Request request = buildRequest(Example.class, "http://example.com/foo/bar/");
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
     assertThat(request.body()).isNull();
   }
 
-  @Test public void getWithNonStringUrlThrows() {
+  @Test public void getWithHttpUrl() {
     class Example {
       @GET
-      Call<ResponseBody> method(@Url Object url) {
+      Call<ResponseBody> method(@Url HttpUrl url) {
         return null;
       }
     }
 
-    try {
-      buildRequest(Example.class, "foo/bar");
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("@Url must be String type. (parameter #1)\n"
-          + "    for method Example.method");
-    }
+    Request request = buildRequest(Example.class, HttpUrl.parse("http://example.com/foo/bar/"));
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url()).isEqualTo(HttpUrl.parse("http://example.com/foo/bar/"));
+    assertThat(request.body()).isNull();
   }
 
-  @Test public void getUrlAndUrlParamThrows() {
+  @Test public void getWithNullUrl() {
     class Example {
-      @GET("foo/bar")
-      Call<ResponseBody> method(@Url Object url) {
+      @GET
+      Call<ResponseBody> method(@Url HttpUrl url) {
         return null;
       }
     }
 
     try {
-      buildRequest(Example.class, "foo/bar");
+      buildRequest(Example.class, (HttpUrl) null);
+      fail();
+    } catch (NullPointerException expected) {
+      assertThat(expected).hasMessage("@Url parameter is null.");
+    }
+  }
+
+  @Test public void getWithNonStringUrlThrows() {
+    class Example {
+      @GET
+      Call<ResponseBody> method(@Url Object url) {
+        return null;
+      }
+    }
+
+    try {
+      buildRequest(Example.class, "foo/bar");
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("@Url must be String type. (parameter #1)\n"
+      assertThat(e).hasMessage(
+          "@Url must be okhttp3.HttpUrl, String, java.net.URI, or android.net.Uri type."
+              + " (parameter #1)\n"
+              + "    for method Example.method");
+    }
+  }
+
+  @Test public void getUrlAndUrlParamThrows() {
+    class Example {
+      @GET("foo/bar")
+      Call<ResponseBody> method(@Url Object url) {
+        return null;
+      }
+    }
+
+    try {
+      buildRequest(Example.class, "foo/bar");
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("@Url cannot be used with @GET URL (parameter #1)\n"
           + "    for method Example.method");
     }
   }
@@ -1085,7 +1462,7 @@
     Request request = buildRequest(Example.class, "foo/bar/", "hey!");
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?hey=hey!");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?hey=hey%21");
   }
 
   @Test public void postWithUrl() {
@@ -1099,7 +1476,7 @@
     Request request = buildRequest(Example.class, "http://example.com/foo/bar", body);
     assertThat(request.method()).isEqualTo("POST");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar");
     assertBody(request.body(), "hi");
   }
 
@@ -1114,7 +1491,7 @@
     Request request = buildRequest(Example.class, "pong", body);
     assertThat(request.method()).isEqualTo("POST");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/pong/");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong/");
     assertBody(request.body(), "Hi!");
   }
 
@@ -1128,11 +1505,10 @@
     Request request = buildRequest(Example.class);
     assertThat(request.method()).isEqualTo("POST");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
     assertBody(request.body(), "");
   }
 
-  @Ignore("https://github.com/square/okhttp/issues/229")
   @Test public void customMethodEmptyBody() {
     class Example {
       @HTTP(method = "CUSTOM", path = "/foo/bar/", hasBody = true) //
@@ -1143,25 +1519,10 @@
     Request request = buildRequest(Example.class);
     assertThat(request.method()).isEqualTo("CUSTOM");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
     assertBody(request.body(), "");
   }
 
-  @Test public void bodyResponseBody() {
-    class Example {
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Body RequestBody body) {
-        return null;
-      }
-    }
-    RequestBody body = RequestBody.create(TEXT_PLAIN, "hi");
-    Request request = buildRequest(Example.class, body);
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
-    assertBody(request.body(), "hi");
-  }
-
   @Test public void bodyRequired() {
     class Example {
       @POST("/foo/bar/") //
@@ -1188,7 +1549,7 @@
     Request request = buildRequest(Example.class, "pong", body, "kat");
     assertThat(request.method()).isEqualTo("POST");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/pong/kat/");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong/kat/");
     assertBody(request.body(), "Hi!");
   }
 
@@ -1205,7 +1566,7 @@
         MediaType.parse("text/plain"), "kat"));
     assertThat(request.method()).isEqualTo("POST");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
 
     RequestBody body = request.body();
     Buffer buffer = new Buffer();
@@ -1236,7 +1597,7 @@
         buildRequest(Example.class, new Object[] { new String[] { "pong1", "pong2" } });
     assertThat(request.method()).isEqualTo("POST");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
 
     RequestBody body = request.body();
     Buffer buffer = new Buffer();
@@ -1254,6 +1615,200 @@
         .contains("\r\npong2\r\n--");
   }
 
+  @Test public void multipartRequiresName() {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method(@Part RequestBody part) {
+        return null;
+      }
+    }
+
+    try {
+      buildRequest(Example.class, new Object[] { null });
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "@Part annotation must supply a name or use MultipartBody.Part parameter type. (parameter #1)\n"
+              + "    for method Example.method");
+    }
+  }
+
+  @Test public void multipartIterableRequiresName() {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method(@Part List<RequestBody> part) {
+        return null;
+      }
+    }
+
+    try {
+      buildRequest(Example.class, new Object[] { null });
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "@Part annotation must supply a name or use MultipartBody.Part parameter type. (parameter #1)\n"
+              + "    for method Example.method");
+    }
+  }
+
+  @Test public void multipartArrayRequiresName() {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method(@Part RequestBody[] part) {
+        return null;
+      }
+    }
+
+    try {
+      buildRequest(Example.class, new Object[] { null });
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "@Part annotation must supply a name or use MultipartBody.Part parameter type. (parameter #1)\n"
+              + "    for method Example.method");
+    }
+  }
+
+  @Test public void multipartOkHttpPartForbidsName() {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method(@Part("name") MultipartBody.Part part) {
+        return null;
+      }
+    }
+
+    try {
+      buildRequest(Example.class, new Object[] { null });
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "@Part parameters using the MultipartBody.Part must not include a part name in the annotation. (parameter #1)\n"
+              + "    for method Example.method");
+    }
+  }
+
+  @Test public void multipartOkHttpPart() throws IOException {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method(@Part MultipartBody.Part part) {
+        return null;
+      }
+    }
+
+    MultipartBody.Part part = MultipartBody.Part.createFormData("kit", "kat");
+    Request request = buildRequest(Example.class, part);
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+
+    RequestBody body = request.body();
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    String bodyString = buffer.readUtf8();
+
+    assertThat(bodyString)
+        .contains("Content-Disposition: form-data;")
+        .contains("name=\"kit\"\r\n")
+        .contains("\r\nkat\r\n--");
+  }
+
+  @Test public void multipartOkHttpIterablePart() throws IOException {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method(@Part List<MultipartBody.Part> part) {
+        return null;
+      }
+    }
+
+    MultipartBody.Part part1 = MultipartBody.Part.createFormData("foo", "bar");
+    MultipartBody.Part part2 = MultipartBody.Part.createFormData("kit", "kat");
+    Request request = buildRequest(Example.class, Arrays.asList(part1, part2));
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+
+    RequestBody body = request.body();
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    String bodyString = buffer.readUtf8();
+
+    assertThat(bodyString)
+        .contains("Content-Disposition: form-data;")
+        .contains("name=\"foo\"\r\n")
+        .contains("\r\nbar\r\n--");
+
+    assertThat(bodyString)
+        .contains("Content-Disposition: form-data;")
+        .contains("name=\"kit\"\r\n")
+        .contains("\r\nkat\r\n--");
+  }
+
+  @Test public void multipartOkHttpArrayPart() throws IOException {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method(@Part MultipartBody.Part[] part) {
+        return null;
+      }
+    }
+
+    MultipartBody.Part part1 = MultipartBody.Part.createFormData("foo", "bar");
+    MultipartBody.Part part2 = MultipartBody.Part.createFormData("kit", "kat");
+    Request request =
+        buildRequest(Example.class, new Object[] { new MultipartBody.Part[] { part1, part2 } });
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+
+    RequestBody body = request.body();
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    String bodyString = buffer.readUtf8();
+
+    assertThat(bodyString)
+        .contains("Content-Disposition: form-data;")
+        .contains("name=\"foo\"\r\n")
+        .contains("\r\nbar\r\n--");
+
+    assertThat(bodyString)
+        .contains("Content-Disposition: form-data;")
+        .contains("name=\"kit\"\r\n")
+        .contains("\r\nkat\r\n--");
+  }
+
+  @Test public void multipartOkHttpPartWithFilename() throws IOException {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method(@Part MultipartBody.Part part) {
+        return null;
+      }
+    }
+
+    MultipartBody.Part part =
+        MultipartBody.Part.createFormData("kit", "kit.txt", RequestBody.create(null, "kat"));
+    Request request = buildRequest(Example.class, part);
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+
+    RequestBody body = request.body();
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    String bodyString = buffer.readUtf8();
+
+    assertThat(bodyString)
+        .contains("Content-Disposition: form-data;")
+        .contains("name=\"kit\"; filename=\"kit.txt\"\r\n")
+        .contains("\r\nkat\r\n--");
+  }
+
   @Test public void multipartIterable() throws IOException {
     class Example {
       @Multipart //
@@ -1266,7 +1821,7 @@
     Request request = buildRequest(Example.class, Arrays.asList("pong1", "pong2"));
     assertThat(request.method()).isEqualTo("POST");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
 
     RequestBody body = request.body();
     Buffer buffer = new Buffer();
@@ -1284,6 +1839,44 @@
         .contains("\r\npong2\r\n--");
   }
 
+  @Test public void multipartIterableOkHttpPart() {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method(@Part("ping") List<MultipartBody.Part> part) {
+        return null;
+      }
+    }
+
+    try {
+      buildRequest(Example.class, new Object[] { null });
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "@Part parameters using the MultipartBody.Part must not include a part name in the annotation. (parameter #1)\n"
+              + "    for method Example.method");
+    }
+  }
+
+  @Test public void multipartArrayOkHttpPart() {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method(@Part("ping") MultipartBody.Part[] part) {
+        return null;
+      }
+    }
+
+    try {
+      buildRequest(Example.class, new Object[] { null });
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "@Part parameters using the MultipartBody.Part must not include a part name in the annotation. (parameter #1)\n"
+              + "    for method Example.method");
+    }
+  }
+
   @Test public void multipartWithEncoding() throws IOException {
     class Example {
       @Multipart //
@@ -1298,7 +1891,7 @@
         MediaType.parse("text/plain"), "kat"));
     assertThat(request.method()).isEqualTo("POST");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
 
     RequestBody body = request.body();
     Buffer buffer = new Buffer();
@@ -1329,13 +1922,12 @@
 
     Map<String, RequestBody> params = new LinkedHashMap<>();
     params.put("ping", RequestBody.create(null, "pong"));
-    params.put("foo", null); // Should be skipped.
     params.put("kit", RequestBody.create(null, "kat"));
 
     Request request = buildRequest(Example.class, params);
     assertThat(request.method()).isEqualTo("POST");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
 
     RequestBody body = request.body();
     Buffer buffer = new Buffer();
@@ -1351,8 +1943,6 @@
         .contains("Content-Disposition: form-data;")
         .contains("name=\"kit\"")
         .contains("\r\nkat\r\n--");
-
-    assertThat(bodyString).doesNotContain("name=\"foo\"\r\n");
   }
 
   @Test public void multipartPartMapWithEncoding() throws IOException {
@@ -1366,13 +1956,12 @@
 
     Map<String, RequestBody> params = new LinkedHashMap<>();
     params.put("ping", RequestBody.create(null, "pong"));
-    params.put("foo", null); // Should be skipped.
     params.put("kit", RequestBody.create(null, "kat"));
 
     Request request = buildRequest(Example.class, params);
     assertThat(request.method()).isEqualTo("POST");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
 
     RequestBody body = request.body();
     Buffer buffer = new Buffer();
@@ -1390,8 +1979,61 @@
         .contains("name=\"kit\"")
         .contains("Content-Transfer-Encoding: 8-bit")
         .contains("\r\nkat\r\n--");
+  }
+
+  @Test public void multipartPartMapRejectsNonStringKeys() {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method(@PartMap Map<Object, RequestBody> parts) {
+        return null;
+      }
+    }
 
-    assertThat(bodyString).doesNotContain("name=\"foo\"\r\n");
+    try {
+      buildRequest(Example.class, new Object[] { null });
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "@PartMap keys must be of type String: class java.lang.Object (parameter #1)\n"
+              + "    for method Example.method");
+    }
+  }
+
+  @Test public void multipartPartMapRejectsOkHttpPartValues() {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method(@PartMap Map<String, MultipartBody.Part> parts) {
+        return null;
+      }
+    }
+
+    try {
+      buildRequest(Example.class, new Object[] { null });
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "@PartMap values cannot be MultipartBody.Part. Use @Part List<Part> or a different value type instead. (parameter #1)\n"
+              + "    for method Example.method");
+    }
+  }
+
+  @Test public void multipartPartMapRejectsNull() {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method(@PartMap Map<String, RequestBody> parts) {
+        return null;
+      }
+    }
+
+    try {
+      buildRequest(Example.class, new Object[] { null });
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Part map was null.");
+    }
   }
 
   @Test public void multipartPartMapRejectsNullKeys() {
@@ -1415,6 +2057,27 @@
     }
   }
 
+  @Test public void multipartPartMapRejectsNullValues() {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method(@PartMap Map<String, RequestBody> parts) {
+        return null;
+      }
+    }
+
+    Map<String, RequestBody> params = new LinkedHashMap<>();
+    params.put("ping", RequestBody.create(null, "pong"));
+    params.put("kit", null);
+
+    try {
+      buildRequest(Example.class, params);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Part map contained null value for key 'kit'.");
+    }
+  }
+
   @Test public void multipartPartMapMustBeMap() {
     class Example {
       @Multipart //
@@ -1433,6 +2096,29 @@
     }
   }
 
+  @Test public void multipartPartMapSupportsSubclasses() throws IOException {
+    class Foo extends HashMap<String, String> {
+    }
+
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method(@PartMap Foo parts) {
+        return null;
+      }
+    }
+
+    Foo foo = new Foo();
+    foo.put("hello", "world");
+
+    Request request = buildRequest(Example.class, foo);
+    Buffer buffer = new Buffer();
+    request.body().writeTo(buffer);
+    assertThat(buffer.readUtf8())
+        .contains("name=\"hello\"")
+        .contains("\r\n\r\nworld\r\n--");
+  }
+
   @Test public void multipartNullRemovesPart() throws IOException {
     class Example {
       @Multipart //
@@ -1444,7 +2130,7 @@
     Request request = buildRequest(Example.class, "pong", null);
     assertThat(request.method()).isEqualTo("POST");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
 
     RequestBody body = request.body();
     Buffer buffer = new Buffer();
@@ -1580,13 +2266,29 @@
 
     Map<String, Object> fieldMap = new LinkedHashMap<>();
     fieldMap.put("kit", "kat");
-    fieldMap.put("foo", null);
     fieldMap.put("ping", "pong");
 
     Request request = buildRequest(Example.class, fieldMap);
     assertBody(request.body(), "kit=kat&ping=pong");
   }
 
+  @Test public void fieldMapRejectsNull() {
+    class Example {
+      @FormUrlEncoded //
+      @POST("/") //
+      Call<ResponseBody> method(@FieldMap Map<String, Object> a) {
+        return null;
+      }
+    }
+
+    try {
+      buildRequest(Example.class, new Object[] { null });
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Field map was null.");
+    }
+  }
+
   @Test public void fieldMapRejectsNullKeys() {
     class Example {
       @FormUrlEncoded //
@@ -1598,7 +2300,6 @@
 
     Map<String, Object> fieldMap = new LinkedHashMap<>();
     fieldMap.put("kit", "kat");
-    fieldMap.put("foo", null);
     fieldMap.put(null, "pong");
 
     try {
@@ -1609,6 +2310,27 @@
     }
   }
 
+  @Test public void fieldMapRejectsNullValues() {
+    class Example {
+      @FormUrlEncoded //
+      @POST("/") //
+      Call<ResponseBody> method(@FieldMap Map<String, Object> a) {
+        return null;
+      }
+    }
+
+    Map<String, Object> fieldMap = new LinkedHashMap<>();
+    fieldMap.put("kit", "kat");
+    fieldMap.put("foo", null);
+
+    try {
+      buildRequest(Example.class, fieldMap);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Field map contained null value for key 'foo'.");
+    }
+  }
+
   @Test public void fieldMapMustBeAMap() {
     class Example {
       @FormUrlEncoded //
@@ -1626,6 +2348,27 @@
     }
   }
 
+  @Test public void fieldMapSupportsSubclasses() throws IOException {
+    class Foo extends HashMap<String, String> {
+    }
+
+    class Example {
+      @FormUrlEncoded //
+      @POST("/") //
+      Call<ResponseBody> method(@FieldMap Foo a) {
+        return null;
+      }
+    }
+
+    Foo foo = new Foo();
+    foo.put("hello", "world");
+
+    Request request = buildRequest(Example.class, foo);
+    Buffer buffer = new Buffer();
+    request.body().writeTo(buffer);
+    assertThat(buffer.readUtf8()).isEqualTo("hello=world");
+  }
+
   @Test public void simpleHeaders() {
     class Example {
       @GET("/foo/bar/")
@@ -1639,11 +2382,11 @@
     }
     Request request = buildRequest(Example.class);
     assertThat(request.method()).isEqualTo("GET");
-    com.squareup.okhttp.Headers headers = request.headers();
+    okhttp3.Headers headers = request.headers();
     assertThat(headers.size()).isEqualTo(2);
     assertThat(headers.get("ping")).isEqualTo("pong");
     assertThat(headers.get("kit")).isEqualTo("kat");
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
     assertThat(request.body()).isNull();
   }
 
@@ -1656,10 +2399,10 @@
     }
     Request request = buildRequest(Example.class, new BigInteger("1234"));
     assertThat(request.method()).isEqualTo("GET");
-    com.squareup.okhttp.Headers headers = request.headers();
+    okhttp3.Headers headers = request.headers();
     assertThat(headers.size()).isEqualTo(1);
     assertThat(headers.get("kit")).isEqualTo("1234");
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
     assertThat(request.body()).isNull();
   }
 
@@ -1673,11 +2416,11 @@
     }
     Request request = buildRequest(Example.class, "kat");
     assertThat(request.method()).isEqualTo("GET");
-    com.squareup.okhttp.Headers headers = request.headers();
+    okhttp3.Headers headers = request.headers();
     assertThat(headers.size()).isEqualTo(2);
     assertThat(headers.get("ping")).isEqualTo("pong");
     assertThat(headers.get("kit")).isEqualTo("kat");
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
     assertThat(request.body()).isNull();
   }
 
@@ -1690,10 +2433,10 @@
     }
     Request request = buildRequest(Example.class, Arrays.asList("bar", null, "baz"));
     assertThat(request.method()).isEqualTo("GET");
-    com.squareup.okhttp.Headers headers = request.headers();
+    okhttp3.Headers headers = request.headers();
     assertThat(headers.size()).isEqualTo(2);
     assertThat(headers.values("foo")).containsExactly("bar", "baz");
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
     assertThat(request.body()).isNull();
   }
 
@@ -1706,10 +2449,10 @@
     }
     Request request = buildRequest(Example.class, (Object) new String[] { "bar", null, "baz" });
     assertThat(request.method()).isEqualTo("GET");
-    com.squareup.okhttp.Headers headers = request.headers();
+    okhttp3.Headers headers = request.headers();
     assertThat(headers.size()).isEqualTo(2);
     assertThat(headers.values("foo")).containsExactly("bar", "baz");
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
     assertThat(request.body()).isNull();
   }
 
@@ -1726,6 +2469,24 @@
     assertThat(request.body().contentType().toString()).isEqualTo("text/not-plain");
   }
 
+  @Test public void malformedContentTypeHeaderThrows() {
+    class Example {
+      @POST("/") //
+      @Headers("Content-Type: hello, world!") //
+      Call<ResponseBody> method(@Body RequestBody body) {
+        return null;
+      }
+    }
+    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    try {
+      buildRequest(Example.class, body);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Malformed content type: hello, world!\n"
+          + "    for method Example.method");
+    }
+  }
+
   @Test public void contentTypeAnnotationHeaderAddsHeaderWithNoBody() {
     class Example {
       @DELETE("/") //
@@ -1750,6 +2511,151 @@
     assertThat(request.body().contentType().toString()).isEqualTo("text/not-plain");
   }
 
+  @Test public void malformedContentTypeParameterThrows() {
+    class Example {
+      @POST("/") //
+      Call<ResponseBody> method(@Header("Content-Type") String contentType, @Body RequestBody body) {
+        return null;
+      }
+    }
+    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    try {
+      buildRequest(Example.class, "hello, world!", body);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Malformed content type: hello, world!");
+    }
+  }
+
+  @Test public void malformedAnnotationRelativeUrlThrows() {
+    class Example {
+      @GET("ftp://example.org")
+      Call<ResponseBody> get() {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "Malformed URL. Base: http://example.com/, Relative: ftp://example.org");
+    }
+  }
+
+  @Test public void malformedParameterRelativeUrlThrows() {
+    class Example {
+      @GET
+      Call<ResponseBody> get(@Url String relativeUrl) {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class, "ftp://example.org");
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "Malformed URL. Base: http://example.com/, Relative: ftp://example.org");
+    }
+  }
+
+  @Test public void multipartPartsShouldBeInOrder() throws IOException {
+    class Example {
+      @Multipart
+      @POST("/foo")
+      Call<ResponseBody> get(@Part("first") String data, @Part("second") String dataTwo, @Part("third") String dataThree) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, "firstParam", "secondParam", "thirdParam");
+    MultipartBody body = (MultipartBody) request.body();
+
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    String readBody = buffer.readUtf8();
+
+    assertThat(readBody.indexOf("firstParam")).isLessThan(readBody.indexOf("secondParam"));
+    assertThat(readBody.indexOf("secondParam")).isLessThan(readBody.indexOf("thirdParam"));
+  }
+
+  @Test public void queryParamsSkippedIfConvertedToNull() throws Exception {
+    class Example {
+      @GET("/query") Call<ResponseBody> queryPath(@Query("a") Object a) {
+        return null;
+      }
+    }
+
+    Retrofit.Builder retrofitBuilder = new Retrofit.Builder()
+        .baseUrl("http://example.com")
+        .addConverterFactory(new NullObjectConverterFactory());
+
+    Request request = buildRequest(Example.class, retrofitBuilder, "Ignored");
+
+    assertThat(request.url().toString()).doesNotContain("Ignored");
+  }
+
+  @Test public void queryParamMapsConvertedToNullShouldError() throws Exception {
+    class Example {
+      @GET("/query") Call<ResponseBody> queryPath(@QueryMap Map<String, String> a) {
+        return null;
+      }
+    }
+
+    Retrofit.Builder retrofitBuilder = new Retrofit.Builder()
+        .baseUrl("http://example.com")
+        .addConverterFactory(new NullObjectConverterFactory());
+
+    Map<String, String> queryMap = Collections.singletonMap("kit", "kat");
+
+    try {
+      buildRequest(Example.class, retrofitBuilder, queryMap);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessageContaining(
+          "Query map value 'kat' converted to null by retrofit2.helpers.NullObjectConverterFactory$1 for key 'kit'.");
+    }
+  }
+
+  @Test public void fieldParamsSkippedIfConvertedToNull() throws Exception {
+    class Example {
+      @FormUrlEncoded
+      @POST("/query") Call<ResponseBody> queryPath(@Field("a") Object a) {
+        return null;
+      }
+    }
+
+    Retrofit.Builder retrofitBuilder = new Retrofit.Builder()
+        .baseUrl("http://example.com")
+        .addConverterFactory(new NullObjectConverterFactory());
+
+    Request request = buildRequest(Example.class, retrofitBuilder, "Ignored");
+
+    assertThat(request.url().toString()).doesNotContain("Ignored");
+  }
+
+  @Test public void fieldParamMapsConvertedToNullShouldError() throws Exception {
+    class Example {
+      @FormUrlEncoded
+      @POST("/query") Call<ResponseBody> queryPath(@FieldMap Map<String, String> a) {
+        return null;
+      }
+    }
+
+    Retrofit.Builder retrofitBuilder = new Retrofit.Builder()
+        .baseUrl("http://example.com")
+        .addConverterFactory(new NullObjectConverterFactory());
+
+    Map<String, String> queryMap = Collections.singletonMap("kit", "kat");
+
+    try {
+      buildRequest(Example.class, retrofitBuilder, queryMap);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessageContaining(
+          "Field map value 'kat' converted to null by retrofit2.helpers.NullObjectConverterFactory$1 for key 'kit'.");
+    }
+  }
+
   private static void assertBody(RequestBody body, String expected) {
     assertThat(body).isNotNull();
     Buffer buffer = new Buffer();
@@ -1761,28 +2667,25 @@ private static void assertBody(RequestBody body, String expected) {
     }
   }
 
-  private Request buildRequest(Class<?> cls, Object... args) {
-    OkHttpClient client = new OkHttpClient();
-
+  static <T> Request buildRequest(Class<T> cls, Retrofit.Builder builder, Object... args) {
     final AtomicReference<Request> requestRef = new AtomicReference<>();
-    client.interceptors().add(new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        requestRef.set(chain.request());
+    okhttp3.Call.Factory callFactory = new okhttp3.Call.Factory() {
+      @Override public okhttp3.Call newCall(Request request) {
+        requestRef.set(request);
         throw new UnsupportedOperationException("Not implemented");
       }
-    });
+    };
 
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addConverterFactory(new ToStringConverterFactory())
-        .client(client)
-        .build();
+    Retrofit retrofit = builder.callFactory(callFactory).build();
 
     Method method = TestingUtils.onlyMethod(cls);
-    MethodHandler handler = retrofit.loadMethodHandler(method);
-    Call<?> invoke = (Call<?>) handler.invoke(args);
+    //noinspection unchecked
+    ServiceMethod<T, Call<T>> serviceMethod =
+        (ServiceMethod<T, Call<T>>) retrofit.loadServiceMethod(method);
+    Call<T> okHttpCall = new OkHttpCall<>(serviceMethod, args);
+    Call<T> call = serviceMethod.adapt(okHttpCall);
     try {
-      invoke.execute();
+      call.execute();
       throw new AssertionError();
     } catch (UnsupportedOperationException ignored) {
       return requestRef.get();
@@ -1792,4 +2695,12 @@ private Request buildRequest(Class<?> cls, Object... args) {
       throw new AssertionError(e);
     }
   }
+
+  static <T> Request buildRequest(Class<T> cls, Object... args) {
+    Retrofit.Builder retrofitBuilder = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .addConverterFactory(new ToStringConverterFactory());
+
+    return buildRequest(cls, retrofitBuilder, args);
+  }
 }
diff --git a/retrofit/src/test/java/retrofit2/ResponseTest.java b/retrofit/src/test/java/retrofit2/ResponseTest.java
index 0c48cf9a8..357e7ab65 100644
--- a/retrofit/src/test/java/retrofit2/ResponseTest.java
+++ b/retrofit/src/test/java/retrofit2/ResponseTest.java
@@ -15,28 +15,27 @@
  */
 package retrofit2;
 
-import com.squareup.okhttp.Protocol;
-import com.squareup.okhttp.ResponseBody;
+import okhttp3.Headers;
+import okhttp3.Protocol;
+import okhttp3.ResponseBody;
 import org.junit.Test;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
 public final class ResponseTest {
-  private final com.squareup.okhttp.Response successResponse =
-      new com.squareup.okhttp.Response.Builder() //
-          .code(200)
-          .message("OK")
-          .protocol(Protocol.HTTP_1_1)
-          .request(new com.squareup.okhttp.Request.Builder().url("http://localhost").build())
-          .build();
-  private final com.squareup.okhttp.Response errorResponse =
-      new com.squareup.okhttp.Response.Builder() //
-          .code(400)
-          .message("Broken!")
-          .protocol(Protocol.HTTP_1_1)
-          .request(new com.squareup.okhttp.Request.Builder().url("http://localhost").build())
-          .build();
+  private final okhttp3.Response successResponse = new okhttp3.Response.Builder() //
+      .code(200)
+      .message("OK")
+      .protocol(Protocol.HTTP_1_1)
+      .request(new okhttp3.Request.Builder().url("http://localhost").build())
+      .build();
+  private final okhttp3.Response errorResponse = new okhttp3.Response.Builder() //
+      .code(400)
+      .message("Broken!")
+      .protocol(Protocol.HTTP_1_1)
+      .request(new okhttp3.Request.Builder().url("http://localhost").build())
+      .build();
 
   @Test public void success() {
     Object body = new Object();
@@ -45,17 +44,39 @@
     assertThat(response.code()).isEqualTo(200);
     assertThat(response.message()).isEqualTo("OK");
     assertThat(response.headers().size()).isZero();
-    assertThat(response.isSuccess()).isTrue();
+    assertThat(response.isSuccessful()).isTrue();
     assertThat(response.body()).isSameAs(body);
     assertThat(response.errorBody()).isNull();
   }
 
   @Test public void successNullAllowed() {
     Response<Object> response = Response.success(null);
-    assertThat(response.isSuccess()).isTrue();
+    assertThat(response.isSuccessful()).isTrue();
     assertThat(response.body()).isNull();
   }
 
+  @Test public void successWithHeaders() {
+    Object body = new Object();
+    Headers headers = Headers.of("foo", "bar");
+    Response<Object> response = Response.success(body, headers);
+    assertThat(response.raw()).isNotNull();
+    assertThat(response.code()).isEqualTo(200);
+    assertThat(response.message()).isEqualTo("OK");
+    assertThat(response.headers().toMultimap()).isEqualTo(headers.toMultimap());
+    assertThat(response.isSuccessful()).isTrue();
+    assertThat(response.body()).isSameAs(body);
+    assertThat(response.errorBody()).isNull();
+  }
+
+  @Test public void successWithNullHeadersThrows() {
+    try {
+      Response.success("", (okhttp3.Headers) null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("headers == null");
+    }
+  }
+
   @Test public void successWithRawResponse() {
     Object body = new Object();
     Response<Object> response = Response.success(body, successResponse);
@@ -63,14 +84,14 @@
     assertThat(response.code()).isEqualTo(200);
     assertThat(response.message()).isEqualTo("OK");
     assertThat(response.headers().size()).isZero();
-    assertThat(response.isSuccess()).isTrue();
+    assertThat(response.isSuccessful()).isTrue();
     assertThat(response.body()).isSameAs(body);
     assertThat(response.errorBody()).isNull();
   }
 
   @Test public void successWithNullRawResponseThrows() {
     try {
-      Response.success("", null);
+      Response.success("", (okhttp3.Response) null);
       fail();
     } catch (NullPointerException e) {
       assertThat(e).hasMessage("rawResponse == null");
@@ -91,9 +112,9 @@
     Response<?> response = Response.error(400, errorBody);
     assertThat(response.raw()).isNotNull();
     assertThat(response.code()).isEqualTo(400);
-    assertThat(response.message()).isNull();
+    assertThat(response.message()).isEqualTo("Response.error()");
     assertThat(response.headers().size()).isZero();
-    assertThat(response.isSuccess()).isFalse();
+    assertThat(response.isSuccessful()).isFalse();
     assertThat(response.body()).isNull();
     assertThat(response.errorBody()).isSameAs(errorBody);
   }
@@ -124,7 +145,7 @@
     assertThat(response.code()).isEqualTo(400);
     assertThat(response.message()).isEqualTo("Broken!");
     assertThat(response.headers().size()).isZero();
-    assertThat(response.isSuccess()).isFalse();
+    assertThat(response.isSuccessful()).isFalse();
     assertThat(response.body()).isNull();
     assertThat(response.errorBody()).isSameAs(errorBody);
   }
diff --git a/retrofit/src/test/java/retrofit2/RetrofitTest.java b/retrofit/src/test/java/retrofit2/RetrofitTest.java
index 290a593c0..4b9cd8adb 100644
--- a/retrofit/src/test/java/retrofit2/RetrofitTest.java
+++ b/retrofit/src/test/java/retrofit2/RetrofitTest.java
@@ -1,13 +1,20 @@
-// Copyright 2013 Square, Inc.
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package retrofit2;
 
-import com.squareup.okhttp.HttpUrl;
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.ResponseBody;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.annotation.Retention;
@@ -18,20 +25,36 @@
 import java.util.Set;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.Executor;
+import java.util.concurrent.Executors;
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.HttpUrl;
+import okhttp3.MediaType;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
 import org.junit.Rule;
 import org.junit.Test;
+import retrofit2.helpers.DelegatingCallAdapterFactory;
+import retrofit2.helpers.NonMatchingCallAdapterFactory;
+import retrofit2.helpers.NonMatchingConverterFactory;
+import retrofit2.helpers.ToStringConverterFactory;
 import retrofit2.http.Body;
 import retrofit2.http.GET;
 import retrofit2.http.POST;
 import retrofit2.http.Query;
 
-import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 import static org.mockito.Matchers.any;
@@ -40,6 +63,7 @@
 import static org.mockito.Mockito.spy;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.verifyZeroInteractions;
 
 public final class RetrofitTest {
   @Rule public final MockWebServer server = new MockWebServer();
@@ -47,6 +71,10 @@
   interface CallMethod {
     @GET("/") Call<String> disallowed();
     @POST("/") Call<ResponseBody> disallowed(@Body String body);
+
+    @GET("/") Call<retrofit2.Response> badType1();
+    @GET("/") Call<okhttp3.Response> badType2();
+
     @GET("/") Call<ResponseBody> getResponseBody();
     @GET("/") Call<Void> getVoid();
     @POST("/") Call<ResponseBody> postRequestBody(@Body RequestBody body);
@@ -86,6 +114,9 @@
     @Retention(RUNTIME)
     @interface Foo {}
   }
+  interface MutableParameters {
+    @GET("/") Call<String> method(@Query("i") AtomicInteger value);
+  }
 
   @SuppressWarnings("EqualsBetweenInconvertibleTypes") // We are explicitly testing this behavior.
   @Test public void objectMethodsStillWork() {
@@ -111,6 +142,74 @@
     }
   }
 
+  @Test public void cloneSharesStatefulInstances() {
+    CallAdapter.Factory callAdapter = mock(CallAdapter.Factory.class);
+    Converter.Factory converter = mock(Converter.Factory.class);
+    HttpUrl baseUrl = server.url("/");
+    Executor executor = mock(Executor.class);
+    okhttp3.Call.Factory callFactory = mock(okhttp3.Call.Factory.class);
+
+    Retrofit one = new Retrofit.Builder()
+        .addCallAdapterFactory(callAdapter)
+        .addConverterFactory(converter)
+        .baseUrl(baseUrl)
+        .callbackExecutor(executor)
+        .callFactory(callFactory)
+        .build();
+
+    CallAdapter.Factory callAdapter2 = mock(CallAdapter.Factory.class);
+    Converter.Factory converter2 = mock(Converter.Factory.class);
+    Retrofit two = one.newBuilder()
+        .addCallAdapterFactory(callAdapter2)
+        .addConverterFactory(converter2)
+        .build();
+    assertEquals(one.callAdapterFactories().size() + 1, two.callAdapterFactories().size());
+    assertThat(two.callAdapterFactories()).contains(callAdapter, callAdapter2);
+    assertEquals(one.converterFactories().size() + 1, two.converterFactories().size());
+    assertThat(two.converterFactories()).contains(converter, converter2);
+    assertSame(baseUrl, two.baseUrl());
+    assertSame(executor, two.callbackExecutor());
+    assertSame(callFactory, two.callFactory());
+  }
+
+  @Test public void builtInConvertersAbsentInCloneBuilder() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .build();
+
+    assertEquals(0, retrofit.newBuilder().converterFactories().size());
+  }
+
+  @Test public void responseTypeCannotBeRetrofitResponse() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .build();
+    CallMethod service = retrofit.create(CallMethod.class);
+    try {
+      service.badType1();
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "'retrofit2.Response' is not a valid response body type. Did you mean ResponseBody?\n"
+              + "    for method CallMethod.badType1");
+    }
+  }
+
+  @Test public void responseTypeCannotBeOkHttpResponse() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .build();
+    CallMethod service = retrofit.create(CallMethod.class);
+    try {
+      service.badType2();
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "'okhttp3.Response' is not a valid response body type. Did you mean ResponseBody?\n"
+              + "    for method CallMethod.badType2");
+    }
+  }
+
   @Test public void voidReturnTypeNotAllowed() {
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
@@ -171,19 +270,19 @@
   @Test public void callCallCustomAdapter() {
     final AtomicBoolean factoryCalled = new AtomicBoolean();
     final AtomicBoolean adapterCalled = new AtomicBoolean();
-    class MyCallAdapterFactory implements CallAdapter.Factory {
-      @Override public CallAdapter<?> get(final Type returnType, Annotation[] annotations,
+    class MyCallAdapterFactory extends CallAdapter.Factory {
+      @Override public CallAdapter<?, ?> get(final Type returnType, Annotation[] annotations,
           Retrofit retrofit) {
         factoryCalled.set(true);
-        if (Utils.getRawType(returnType) != Call.class) {
+        if (getRawType(returnType) != Call.class) {
           return null;
         }
-        return new CallAdapter<Call<?>>() {
+        return new CallAdapter<Object, Call<?>>() {
           @Override public Type responseType() {
-            return Utils.getParameterUpperBound(0, (ParameterizedType) returnType);
+            return getParameterUpperBound(0, (ParameterizedType) returnType);
           }
 
-          @Override public <R> Call<R> adapt(Call<R> call) {
+          @Override public Call<Object> adapt(Call<Object> call) {
             adapterCalled.set(true);
             return call;
           }
@@ -202,18 +301,18 @@
   }
 
   @Test public void customCallAdapter() {
-    class GreetingCallAdapterFactory implements CallAdapter.Factory {
-      @Override public CallAdapter<String> get(Type returnType, Annotation[] annotations,
+    class GreetingCallAdapterFactory extends CallAdapter.Factory {
+      @Override public CallAdapter<Object, String> get(Type returnType, Annotation[] annotations,
           Retrofit retrofit) {
-        if (Utils.getRawType(returnType) != String.class) {
+        if (getRawType(returnType) != String.class) {
           return null;
         }
-        return new CallAdapter<String>() {
+        return new CallAdapter<Object, String>() {
           @Override public Type responseType() {
             return String.class;
           }
 
-          @Override public <R> String adapt(Call<R> call) {
+          @Override public String adapt(Call<Object> call) {
             return "Hi!";
           }
         };
@@ -231,8 +330,8 @@
 
   @Test public void methodAnnotationsPassedToCallAdapter() {
     final AtomicReference<Annotation[]> annotationsRef = new AtomicReference<>();
-    class MyCallAdapterFactory implements CallAdapter.Factory {
-      @Override public CallAdapter<?> get(Type returnType, Annotation[] annotations,
+    class MyCallAdapterFactory extends CallAdapter.Factory {
+      @Override public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations,
           Retrofit retrofit) {
         annotationsRef.set(annotations);
         return null;
@@ -259,12 +358,13 @@
       example.method();
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Unable to create call adapter for java.util.concurrent.Future<java.lang.String>\n"
-              + "    for method FutureMethod.method");
-      assertThat(e.getCause()).hasMessage(
-          "Could not locate call adapter for java.util.concurrent.Future<java.lang.String>. Tried:\n"
-              + " * retrofit2.DefaultCallAdapter$1");
+      assertThat(e).hasMessage(""
+          + "Unable to create call adapter for java.util.concurrent.Future<java.lang.String>\n"
+          + "    for method FutureMethod.method");
+      assertThat(e.getCause()).hasMessage(""
+          + "Could not locate call adapter for java.util.concurrent.Future<java.lang.String>.\n"
+          + "  Tried:\n"
+          + "   * retrofit2.DefaultCallAdapterFactory");
     }
   }
 
@@ -289,14 +389,18 @@
     assertThat(annotations).hasAtLeastOneElementOfType(Annotated.Foo.class);
   }
 
-  @Test public void parameterAnnotationsPassedToRequestBodyConverter() {
-    final AtomicReference<Annotation[]> annotationsRef = new AtomicReference<>();
+  @Test public void methodAndParameterAnnotationsPassedToRequestBodyConverter() {
+    final AtomicReference<Annotation[]> parameterAnnotationsRef = new AtomicReference<>();
+    final AtomicReference<Annotation[]> methodAnnotationsRef = new AtomicReference<>();
+
     class MyConverterFactory extends Converter.Factory {
       @Override
-      public Converter<?, RequestBody> requestBodyConverter(Type type, Annotation[] annotations,
-          Retrofit retrofit) {
-        annotationsRef.set(annotations);
-        return new ToStringConverterFactory().requestBodyConverter(type, annotations, retrofit);
+      public Converter<?, RequestBody> requestBodyConverter(Type type,
+          Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+        parameterAnnotationsRef.set(parameterAnnotations);
+        methodAnnotationsRef.set(methodAnnotations);
+        return new ToStringConverterFactory().requestBodyConverter(type, parameterAnnotations,
+            methodAnnotations, retrofit);
       }
     }
     Retrofit retrofit = new Retrofit.Builder()
@@ -306,14 +410,15 @@
     Annotated annotated = retrofit.create(Annotated.class);
     annotated.bodyParameter(null); // Trigger internal setup.
 
-    Annotation[] annotations = annotationsRef.get();
-    assertThat(annotations).hasAtLeastOneElementOfType(Annotated.Foo.class);
+    assertThat(parameterAnnotationsRef.get()).hasAtLeastOneElementOfType(Annotated.Foo.class);
+    assertThat(methodAnnotationsRef.get()).hasAtLeastOneElementOfType(POST.class);
   }
 
   @Test public void parameterAnnotationsPassedToStringConverter() {
     final AtomicReference<Annotation[]> annotationsRef = new AtomicReference<>();
     class MyConverterFactory extends Converter.Factory {
-      @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations) {
+      @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+          Retrofit retrofit) {
         annotationsRef.set(annotations);
 
         return new Converter<Object, String>() {
@@ -334,10 +439,13 @@
     assertThat(annotations).hasAtLeastOneElementOfType(Annotated.Foo.class);
   }
 
-  @Test public void stringConverterNotCalledForString() {
+  @Test public void stringConverterCalledForString() {
+    final AtomicBoolean factoryCalled = new AtomicBoolean();
     class MyConverterFactory extends Converter.Factory {
-      @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations) {
-        throw new AssertionError();
+      @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+          Retrofit retrofit) {
+        factoryCalled.set(true);
+        return null;
       }
     }
     Retrofit retrofit = new Retrofit.Builder()
@@ -347,13 +455,14 @@
     CallMethod service = retrofit.create(CallMethod.class);
     Call<ResponseBody> call = service.queryString(null);
     assertThat(call).isNotNull();
-    // We also implicitly assert the above factory was not called as it would have thrown.
+    assertThat(factoryCalled.get()).isTrue();
   }
 
   @Test public void stringConverterReturningNullResultsInDefault() {
     final AtomicBoolean factoryCalled = new AtomicBoolean();
     class MyConverterFactory extends Converter.Factory {
-      @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations) {
+      @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+          Retrofit retrofit) {
         factoryCalled.set(true);
         return null;
       }
@@ -377,12 +486,13 @@
       example.disallowed("Hi!");
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Unable to create @Body converter for class java.lang.String (parameter #1)\n"
-              + "    for method CallMethod.disallowed");
-      assertThat(e.getCause()).hasMessage(
-          "Could not locate RequestBody converter for class java.lang.String. Tried:\n"
-              + " * retrofit2.BuiltInConverters");
+      assertThat(e).hasMessage(""
+          + "Unable to create @Body converter for class java.lang.String (parameter #1)\n"
+          + "    for method CallMethod.disallowed");
+      assertThat(e.getCause()).hasMessage(""
+          + "Could not locate RequestBody converter for class java.lang.String.\n"
+          + "  Tried:\n"
+          + "   * retrofit2.BuiltInConverters");
     }
   }
 
@@ -398,31 +508,13 @@
       example.disallowed();
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Unable to create converter for class java.lang.String\n"
-          + "    for method CallMethod.disallowed");
-      assertThat(e.getCause()).hasMessage(
-          "Could not locate ResponseBody converter for class java.lang.String. Tried:\n"
-              + " * retrofit2.BuiltInConverters");
-    }
-  }
-
-  @Test public void converterReturningNullThrows() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new Converter.Factory() {})
-        .build();
-    CallMethod service = retrofit.create(CallMethod.class);
-
-    try {
-      service.disallowed();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Unable to create converter for class java.lang.String\n"
+      assertThat(e).hasMessage(""
+          + "Unable to create converter for class java.lang.String\n"
           + "    for method CallMethod.disallowed");
-      assertThat(e.getCause()).hasMessage(
-          "Could not locate ResponseBody converter for class java.lang.String. Tried:\n"
-              + " * retrofit2.BuiltInConverters\n"
-              + " * retrofit2.RetrofitTest$1");
+      assertThat(e.getCause()).hasMessage(""
+          + "Could not locate ResponseBody converter for class java.lang.String.\n"
+          + "  Tried:\n"
+          + "   * retrofit2.BuiltInConverters");
     }
   }
 
@@ -450,6 +542,22 @@
     assertThat(response.body()).isNull();
   }
 
+  @Test public void voidResponsesArePooled() throws Exception {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .build();
+    CallMethod example = retrofit.create(CallMethod.class);
+
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.enqueue(new MockResponse().setBody("def"));
+
+    example.getVoid().execute();
+    example.getVoid().execute();
+
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
+  }
+
   @Test public void responseBodyIncomingAllowed() throws IOException, InterruptedException {
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
@@ -506,7 +614,7 @@
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
-          + "retrofit2.Call<? extends com.squareup.okhttp.ResponseBody>\n"
+          + "retrofit2.Call<? extends okhttp3.ResponseBody>\n"
           + "    for method UnresolvableResponseType.wildcardUpperBound");
     }
   }
@@ -552,7 +660,7 @@
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage("Parameter type must not include a type variable or wildcard: "
-          + "java.util.List<? extends com.squareup.okhttp.RequestBody> (parameter #1)\n"
+          + "java.util.List<? extends okhttp3.RequestBody> (parameter #1)\n"
           + "    for method UnresolvableParameterType.wildcardUpperBound");
     }
   }
@@ -579,12 +687,6 @@
     } catch (NullPointerException e) {
       assertThat(e).hasMessage("baseUrl == null");
     }
-    try {
-      new Retrofit.Builder().baseUrl((BaseUrl) null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("baseUrl == null");
-    }
   }
 
   @Test public void baseUrlInvalidThrows() {
@@ -616,9 +718,8 @@
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl("http://example.com/")
         .build();
-    BaseUrl baseUrl = retrofit.baseUrl();
-    assertThat(baseUrl).isNotNull();
-    assertThat(baseUrl.url().toString()).isEqualTo("http://example.com/");
+    HttpUrl baseUrl = retrofit.baseUrl();
+    assertThat(baseUrl).isEqualTo(HttpUrl.parse("http://example.com/"));
   }
 
   @Test public void baseHttpUrlPropagated() {
@@ -626,17 +727,7 @@
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(url)
         .build();
-    BaseUrl baseUrl = retrofit.baseUrl();
-    assertThat(baseUrl).isNotNull();
-    assertThat(baseUrl.url()).isSameAs(url);
-  }
-
-  @Test public void baseUrlPropagated() {
-    BaseUrl baseUrl = mock(BaseUrl.class);
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(baseUrl)
-        .build();
-    assertThat(retrofit.baseUrl()).isSameAs(baseUrl);
+    assertThat(retrofit.baseUrl()).isSameAs(url);
   }
 
   @Test public void clientNullThrows() {
@@ -656,7 +747,7 @@
   }
 
   @Test public void callFactoryPropagated() {
-    Call.Factory callFactory = mock(Call.Factory.class);
+    okhttp3.Call.Factory callFactory = mock(okhttp3.Call.Factory.class);
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl("http://example.com/")
         .callFactory(callFactory)
@@ -670,35 +761,31 @@
         .baseUrl("http://example.com/")
         .client(client)
         .build();
-    OkHttpCallFactory factory = (OkHttpCallFactory) retrofit.callFactory();
-    assertThat(factory.client).isSameAs(client);
+    assertThat(retrofit.callFactory()).isSameAs(client);
   }
 
-  @Test public void callFactoryUsed() {
-    final Retrofit blackbox = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .build();
-    Call.Factory callFactory = spy(new Call.Factory() {
-      @Override
-      public <T> Call<T> create(DeferredRequest request, Converter<ResponseBody, T> converter) {
-        // Wrap the default Call.Factory without directly relying on its implementation.
-        return blackbox.callFactory().create(request, converter);
+  @Test public void callFactoryUsed() throws IOException {
+    okhttp3.Call.Factory callFactory = spy(new okhttp3.Call.Factory() {
+      @Override public okhttp3.Call newCall(Request request) {
+        return new OkHttpClient().newCall(request);
       }
     });
     Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
+        .baseUrl(server.url("/"))
         .callFactory(callFactory)
         .build();
+
+    server.enqueue(new MockResponse());
+
     CallMethod service = retrofit.create(CallMethod.class);
-    service.getResponseBody();
-    verify(callFactory).create(any(DeferredRequest.class), any(Converter.class));
+    service.getResponseBody().execute();
+    verify(callFactory).newCall(any(Request.class));
     verifyNoMoreInteractions(callFactory);
   }
 
-  @Test public void callFactoryReturningNullThrows() {
-    Call.Factory callFactory = new Call.Factory() {
-      @Override
-      public <T> Call<T> create(DeferredRequest request, Converter<ResponseBody, T> converter) {
+  @Test public void callFactoryReturningNullThrows() throws IOException {
+    okhttp3.Call.Factory callFactory = new okhttp3.Call.Factory() {
+      @Override public okhttp3.Call newCall(Request request) {
         return null;
       }
     };
@@ -706,9 +793,13 @@
         .baseUrl("http://example.com/")
         .callFactory(callFactory)
         .build();
+
+    server.enqueue(new MockResponse());
+
     CallMethod service = retrofit.create(CallMethod.class);
+    Call<ResponseBody> call = service.getResponseBody();
     try {
-      service.getResponseBody();
+      call.execute();
       fail();
     } catch (NullPointerException e) {
       assertThat(e).hasMessage("Call.Factory returned null.");
@@ -717,9 +808,8 @@
 
   @Test public void callFactoryThrowingPropagates() {
     final RuntimeException cause = new RuntimeException("Broken!");
-    Call.Factory callFactory = new Call.Factory() {
-      @Override
-      public <T> Call<T> create(DeferredRequest request, Converter<ResponseBody, T> converter) {
+    okhttp3.Call.Factory callFactory = new okhttp3.Call.Factory() {
+      @Override public okhttp3.Call newCall(Request request) {
         throw cause;
       }
     };
@@ -727,9 +817,13 @@
         .baseUrl("http://example.com/")
         .callFactory(callFactory)
         .build();
+
+    server.enqueue(new MockResponse());
+
     CallMethod service = retrofit.create(CallMethod.class);
+    Call<ResponseBody> call = service.getResponseBody();
     try {
-      service.getResponseBody();
+      call.execute();
       fail();
     } catch (Exception e) {
       assertThat(e).isSameAs(cause);
@@ -754,9 +848,27 @@
     assertThat(converterFactories.get(0)).isInstanceOf(BuiltInConverters.class);
   }
 
+  @Test public void builtInConvertersFirstInClone() {
+    Converter<ResponseBody, Void> converter = mock(Converter.class);
+    Converter.Factory factory = mock(Converter.Factory.class);
+    Annotation[] annotations = new Annotation[0];
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .addConverterFactory(factory)
+        .build();
+
+    doReturn(converter).when(factory).responseBodyConverter(Void.class, annotations, retrofit);
+
+    retrofit.newBuilder().build().responseBodyConverter(Void.class, annotations);
+
+    verifyZeroInteractions(factory);
+  }
+
   @Test public void requestConverterFactoryQueried() {
     Type type = String.class;
-    Annotation[] annotations = new Annotation[0];
+    Annotation[] parameterAnnotations = new Annotation[0];
+    Annotation[] methodAnnotations = new Annotation[1];
 
     Converter<?, RequestBody> expectedAdapter = mock(Converter.class);
     Converter.Factory factory = mock(Converter.Factory.class);
@@ -766,12 +878,14 @@
         .addConverterFactory(factory)
         .build();
 
-    doReturn(expectedAdapter).when(factory).requestBodyConverter(type, annotations, retrofit);
+    doReturn(expectedAdapter).when(factory).requestBodyConverter(type, parameterAnnotations,
+        methodAnnotations, retrofit);
 
-    Converter<?, RequestBody> actualAdapter = retrofit.requestBodyConverter(type, annotations);
+    Converter<?, RequestBody> actualAdapter = retrofit.requestBodyConverter(type,
+        parameterAnnotations, methodAnnotations);
     assertThat(actualAdapter).isSameAs(expectedAdapter);
 
-    verify(factory).requestBodyConverter(type, annotations, retrofit);
+    verify(factory).requestBodyConverter(type, parameterAnnotations, methodAnnotations, retrofit);
     verifyNoMoreInteractions(factory);
   }
 
@@ -779,28 +893,55 @@
     Type type = String.class;
     Annotation[] annotations = new Annotation[0];
 
-    Converter.Factory factory1 = spy(new Converter.Factory() {
-      @Override
-      public Converter<?, RequestBody> requestBodyConverter(Type returnType,
-          Annotation[] annotations, Retrofit retrofit) {
-        return null;
-      }
-    });
+    NonMatchingConverterFactory nonMatchingFactory = new NonMatchingConverterFactory();
 
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl("http://example.com/")
-        .addConverterFactory(factory1)
+        .addConverterFactory(nonMatchingFactory)
         .build();
 
     try {
-      retrofit.requestBodyConverter(type, annotations);
+      retrofit.requestBodyConverter(type, annotations, annotations);
+      fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessageStartingWith(
-          "Could not locate RequestBody converter for class java.lang.String. Tried:");
+      assertThat(e).hasMessage(""
+          + "Could not locate RequestBody converter for class java.lang.String.\n"
+          + "  Tried:\n"
+          + "   * retrofit2.BuiltInConverters\n"
+          + "   * retrofit2.helpers.NonMatchingConverterFactory");
     }
 
-    verify(factory1).requestBodyConverter(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory1);
+    assertThat(nonMatchingFactory.called).isTrue();
+  }
+
+  @Test public void requestConverterFactorySkippedNoMatchThrows() {
+    Type type = String.class;
+    Annotation[] annotations = new Annotation[0];
+
+    NonMatchingConverterFactory nonMatchingFactory1 = new NonMatchingConverterFactory();
+    NonMatchingConverterFactory nonMatchingFactory2 = new NonMatchingConverterFactory();
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .addConverterFactory(nonMatchingFactory1)
+        .addConverterFactory(nonMatchingFactory2)
+        .build();
+
+    try {
+      retrofit.nextRequestBodyConverter(nonMatchingFactory1, type, annotations, annotations);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(""
+          + "Could not locate RequestBody converter for class java.lang.String.\n"
+          + "  Skipped:\n"
+          + "   * retrofit2.BuiltInConverters\n"
+          + "   * retrofit2.helpers.NonMatchingConverterFactory\n"
+          + "  Tried:\n"
+          + "   * retrofit2.helpers.NonMatchingConverterFactory");
+    }
+
+    assertThat(nonMatchingFactory1.called).isFalse();
+    assertThat(nonMatchingFactory2.called).isTrue();
   }
 
   @Test public void responseConverterFactoryQueried() {
@@ -828,28 +969,55 @@
     Type type = String.class;
     Annotation[] annotations = new Annotation[0];
 
-    Converter.Factory factory1 = spy(new Converter.Factory() {
-      @Override
-      public Converter<ResponseBody, ?> responseBodyConverter(Type returnType,
-          Annotation[] annotations, Retrofit retrofit) {
-        return null;
-      }
-    });
+    NonMatchingConverterFactory nonMatchingFactory = new NonMatchingConverterFactory();
 
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl("http://example.com/")
-        .addConverterFactory(factory1)
+        .addConverterFactory(nonMatchingFactory)
         .build();
 
     try {
       retrofit.responseBodyConverter(type, annotations);
+      fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessageStartingWith(
-          "Could not locate ResponseBody converter for class java.lang.String. Tried:");
+      assertThat(e).hasMessage(""
+          + "Could not locate ResponseBody converter for class java.lang.String.\n"
+          + "  Tried:\n"
+          + "   * retrofit2.BuiltInConverters\n"
+          + "   * retrofit2.helpers.NonMatchingConverterFactory");
     }
 
-    verify(factory1).responseBodyConverter(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory1);
+    assertThat(nonMatchingFactory.called).isTrue();
+  }
+
+  @Test public void responseConverterFactorySkippedNoMatchThrows() {
+    Type type = String.class;
+    Annotation[] annotations = new Annotation[0];
+
+    NonMatchingConverterFactory nonMatchingFactory1 = new NonMatchingConverterFactory();
+    NonMatchingConverterFactory nonMatchingFactory2 = new NonMatchingConverterFactory();
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .addConverterFactory(nonMatchingFactory1)
+        .addConverterFactory(nonMatchingFactory2)
+        .build();
+
+    try {
+      retrofit.nextResponseBodyConverter(nonMatchingFactory1, type, annotations);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(""
+          + "Could not locate ResponseBody converter for class java.lang.String.\n"
+          + "  Skipped:\n"
+          + "   * retrofit2.BuiltInConverters\n"
+          + "   * retrofit2.helpers.NonMatchingConverterFactory\n"
+          + "  Tried:\n"
+          + "   * retrofit2.helpers.NonMatchingConverterFactory");
+    }
+
+    assertThat(nonMatchingFactory1.called).isFalse();
+    assertThat(nonMatchingFactory2.called).isTrue();
   }
 
   @Test public void stringConverterFactoryQueried() {
@@ -864,12 +1032,12 @@
         .addConverterFactory(factory)
         .build();
 
-    doReturn(expectedAdapter).when(factory).stringConverter(type, annotations);
+    doReturn(expectedAdapter).when(factory).stringConverter(type, annotations, retrofit);
 
     Converter<?, String> actualAdapter = retrofit.stringConverter(type, annotations);
     assertThat(actualAdapter).isSameAs(expectedAdapter);
 
-    verify(factory).stringConverter(type, annotations);
+    verify(factory).stringConverter(type, annotations, retrofit);
     verifyNoMoreInteractions(factory);
   }
 
@@ -911,7 +1079,7 @@
     Type type = String.class;
     Annotation[] annotations = new Annotation[0];
 
-    CallAdapter<?> expectedAdapter = mock(CallAdapter.class);
+    CallAdapter<?, ?> expectedAdapter = mock(CallAdapter.class);
     CallAdapter.Factory factory = mock(CallAdapter.Factory.class);
 
     Retrofit retrofit = new Retrofit.Builder()
@@ -921,7 +1089,7 @@
 
     doReturn(expectedAdapter).when(factory).get(type, annotations, retrofit);
 
-    CallAdapter<?> actualAdapter = retrofit.callAdapter(type, annotations);
+    CallAdapter<?, ?> actualAdapter = retrofit.callAdapter(type, annotations);
     assertThat(actualAdapter).isSameAs(expectedAdapter);
 
     verify(factory).get(type, annotations, retrofit);
@@ -932,11 +1100,11 @@
     Type type = String.class;
     Annotation[] annotations = new Annotation[0];
 
-    CallAdapter<?> expectedAdapter = mock(CallAdapter.class);
+    CallAdapter<?, ?> expectedAdapter = mock(CallAdapter.class);
     CallAdapter.Factory factory2 = mock(CallAdapter.Factory.class);
     CallAdapter.Factory factory1 = spy(new CallAdapter.Factory() {
       @Override
-      public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+      public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
         return retrofit.nextCallAdapter(this, returnType, annotations);
       }
     });
@@ -949,7 +1117,7 @@
 
     doReturn(expectedAdapter).when(factory2).get(type, annotations, retrofit);
 
-    CallAdapter<?> actualAdapter = retrofit.callAdapter(type, annotations);
+    CallAdapter<?, ?> actualAdapter = retrofit.callAdapter(type, annotations);
     assertThat(actualAdapter).isSameAs(expectedAdapter);
 
     verify(factory1).get(type, annotations, retrofit);
@@ -962,17 +1130,17 @@
     Type type = String.class;
     Annotation[] annotations = new Annotation[0];
 
-    CallAdapter<?> expectedAdapter = mock(CallAdapter.class);
+    CallAdapter<?, ?> expectedAdapter = mock(CallAdapter.class);
     CallAdapter.Factory factory3 = mock(CallAdapter.Factory.class);
     CallAdapter.Factory factory2 = spy(new CallAdapter.Factory() {
       @Override
-      public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+      public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
         return retrofit.nextCallAdapter(this, returnType, annotations);
       }
     });
     CallAdapter.Factory factory1 = spy(new CallAdapter.Factory() {
       @Override
-      public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+      public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
         return retrofit.nextCallAdapter(this, returnType, annotations);
       }
     });
@@ -986,7 +1154,7 @@
 
     doReturn(expectedAdapter).when(factory3).get(type, annotations, retrofit);
 
-    CallAdapter<?> actualAdapter = retrofit.callAdapter(type, annotations);
+    CallAdapter<?, ?> actualAdapter = retrofit.callAdapter(type, annotations);
     assertThat(actualAdapter).isSameAs(expectedAdapter);
 
     verify(factory1).get(type, annotations, retrofit);
@@ -1001,52 +1169,67 @@
     Type type = String.class;
     Annotation[] annotations = new Annotation[0];
 
-    CallAdapter.Factory factory = mock(CallAdapter.Factory.class);
+    NonMatchingCallAdapterFactory nonMatchingFactory = new NonMatchingCallAdapterFactory();
 
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl("http://example.com/")
-        .addCallAdapterFactory(factory)
+        .addCallAdapterFactory(nonMatchingFactory)
         .build();
 
-    doReturn(null).when(factory).get(type, annotations, retrofit);
-
     try {
       retrofit.callAdapter(type, annotations);
+      fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessageStartingWith(
-          "Could not locate call adapter for class java.lang.String. Tried:");
+      assertThat(e).hasMessage(""
+          + "Could not locate call adapter for class java.lang.String.\n"
+          + "  Tried:\n"
+          + "   * retrofit2.helpers.NonMatchingCallAdapterFactory\n"
+          + "   * retrofit2.DefaultCallAdapterFactory");
     }
 
-    verify(factory).get(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory);
+    assertThat(nonMatchingFactory.called).isTrue();
   }
 
   @Test public void callAdapterFactoryDelegateNoMatchThrows() {
     Type type = String.class;
     Annotation[] annotations = new Annotation[0];
 
-    CallAdapter.Factory factory1 = spy(new CallAdapter.Factory() {
-      @Override
-      public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
-        return retrofit.nextCallAdapter(this, returnType, annotations);
-      }
-    });
+    DelegatingCallAdapterFactory delegatingFactory1 = new DelegatingCallAdapterFactory();
+    DelegatingCallAdapterFactory delegatingFactory2 = new DelegatingCallAdapterFactory();
+    NonMatchingCallAdapterFactory nonMatchingFactory = new NonMatchingCallAdapterFactory();
 
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl("http://example.com/")
-        .addCallAdapterFactory(factory1)
+        .addCallAdapterFactory(delegatingFactory1)
+        .addCallAdapterFactory(delegatingFactory2)
+        .addCallAdapterFactory(nonMatchingFactory)
         .build();
 
     try {
       retrofit.callAdapter(type, annotations);
+      fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessageContaining("Skipped:")
-          .hasMessageStartingWith(
-              "Could not locate call adapter for class java.lang.String. Tried:");
+      assertThat(e).hasMessage(""
+          + "Could not locate call adapter for class java.lang.String.\n"
+          + "  Skipped:\n"
+          + "   * retrofit2.helpers.DelegatingCallAdapterFactory\n"
+          + "   * retrofit2.helpers.DelegatingCallAdapterFactory\n"
+          + "  Tried:\n"
+          + "   * retrofit2.helpers.NonMatchingCallAdapterFactory\n"
+          + "   * retrofit2.DefaultCallAdapterFactory");
     }
 
-    verify(factory1).get(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory1);
+    assertThat(delegatingFactory1.called).isTrue();
+    assertThat(delegatingFactory2.called).isTrue();
+    assertThat(nonMatchingFactory.called).isTrue();
+  }
+
+  @Test public void platformAwareAdapterAbsentInCloneBuilder() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .build();
+
+    assertEquals(0, retrofit.newBuilder().callAdapterFactories().size());
   }
 
   @Test public void callbackExecutorNullThrows() {
@@ -1058,13 +1241,26 @@
     }
   }
 
-  @Test public void callbackExecutorNoDefault() {
+  @Test public void callbackExecutorPropagatesDefaultJvm() {
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl("http://example.com/")
         .build();
     assertThat(retrofit.callbackExecutor()).isNull();
   }
 
+  @Test public void callbackExecutorPropagatesDefaultAndroid() {
+    final Executor executor = Executors.newSingleThreadExecutor();
+    Platform platform = new Platform() {
+      @Override Executor defaultCallbackExecutor() {
+        return executor;
+      }
+    };
+    Retrofit retrofit = new Retrofit.Builder(platform)
+        .baseUrl("http://example.com/")
+        .build();
+    assertThat(retrofit.callbackExecutor()).isSameAs(executor);
+  }
+
   @Test public void callbackExecutorPropagated() {
     Executor executor = mock(Executor.class);
     Retrofit retrofit = new Retrofit.Builder()
@@ -1091,11 +1287,11 @@
 
     final CountDownLatch latch = new CountDownLatch(1);
     call.enqueue(new Callback<ResponseBody>() {
-      @Override public void onResponse(Response<ResponseBody> response) {
+      @Override public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
         latch.countDown();
       }
 
-      @Override public void onFailure(Throwable t) {
+      @Override public void onFailure(Call<ResponseBody> call, Throwable t) {
         t.printStackTrace();
       }
     });
@@ -1122,11 +1318,11 @@
 
     final CountDownLatch latch = new CountDownLatch(1);
     call.enqueue(new Callback<ResponseBody>() {
-      @Override public void onResponse(Response<ResponseBody> response) {
+      @Override public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
         throw new AssertionError();
       }
 
-      @Override public void onFailure(Throwable t) {
+      @Override public void onFailure(Call<ResponseBody> call, Throwable t) {
         latch.countDown();
       }
     });
@@ -1135,4 +1331,39 @@
     verify(executor).execute(any(Runnable.class));
     verifyNoMoreInteractions(executor);
   }
+
+  /** Confirm that Retrofit encodes parameters when the call is executed, and not earlier. */
+  @Test public void argumentCapture() throws Exception {
+    AtomicInteger i = new AtomicInteger();
+
+    server.enqueue(new MockResponse().setBody("a"));
+    server.enqueue(new MockResponse().setBody("b"));
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    MutableParameters mutableParameters = retrofit.create(MutableParameters.class);
+
+    i.set(100);
+    Call<String> call1 = mutableParameters.method(i);
+
+    i.set(101);
+    Response<String> response1 = call1.execute();
+
+    i.set(102);
+    assertEquals("a", response1.body());
+    assertEquals("/?i=101", server.takeRequest().getPath());
+
+    i.set(200);
+    Call<String> call2 = call1.clone();
+
+    i.set(201);
+    Response<String> response2 = call2.execute();
+
+    i.set(202);
+    assertEquals("b", response2.body());
+
+    assertEquals("/?i=201", server.takeRequest().getPath());
+  }
 }
diff --git a/retrofit/src/test/java/retrofit2/RequestFactoryParserTest.java b/retrofit/src/test/java/retrofit2/ServiceMethodTest.java
similarity index 61%
rename from retrofit/src/test/java/retrofit2/RequestFactoryParserTest.java
rename to retrofit/src/test/java/retrofit2/ServiceMethodTest.java
index 502368545..c9c48f31e 100644
--- a/retrofit/src/test/java/retrofit2/RequestFactoryParserTest.java
+++ b/retrofit/src/test/java/retrofit2/ServiceMethodTest.java
@@ -1,4 +1,18 @@
-// Copyright 2013 Square, Inc.
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package retrofit2;
 
 import java.util.Set;
@@ -6,7 +20,7 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-public final class RequestFactoryParserTest {
+public final class ServiceMethodTest {
   @Test public void pathParameterParsing() throws Exception {
     expectParams("/");
     expectParams("/foo");
@@ -27,7 +41,7 @@
   }
 
   private static void expectParams(String path, String... expected) {
-    Set<String> calculated = RequestFactoryParser.parsePathParameters(path);
+    Set<String> calculated = ServiceMethod.parsePathParameters(path);
     assertThat(calculated).containsExactly(expected);
   }
 }
diff --git a/retrofit/src/test/java/retrofit2/TestingUtils.java b/retrofit/src/test/java/retrofit2/TestingUtils.java
index 7bbf68e0a..3847509ea 100644
--- a/retrofit/src/test/java/retrofit2/TestingUtils.java
+++ b/retrofit/src/test/java/retrofit2/TestingUtils.java
@@ -1,4 +1,18 @@
-// Copyright 2013 Square, Inc.
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package retrofit2;
 
 import java.lang.reflect.Method;
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/SingleHelper.java b/retrofit/src/test/java/retrofit2/helpers/DelegatingCallAdapterFactory.java
similarity index 53%
rename from retrofit-adapters/rxjava/src/main/java/retrofit2/SingleHelper.java
rename to retrofit/src/test/java/retrofit2/helpers/DelegatingCallAdapterFactory.java
index b4c2808d3..6ce48efe2 100644
--- a/retrofit-adapters/rxjava/src/main/java/retrofit2/SingleHelper.java
+++ b/retrofit/src/test/java/retrofit2/helpers/DelegatingCallAdapterFactory.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Square, Inc.
+ * Copyright (C) 2016 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,23 +13,19 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.helpers;
 
+import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
-import rx.Observable;
-import rx.Single;
+import retrofit2.CallAdapter;
+import retrofit2.Retrofit;
 
-final class SingleHelper {
-  static CallAdapter<Single<?>> makeSingle(final CallAdapter<Observable<?>> callAdapter) {
-    return new CallAdapter<Single<?>>() {
-      @Override public Type responseType() {
-        return callAdapter.responseType();
-      }
+public final class DelegatingCallAdapterFactory extends CallAdapter.Factory {
+  public boolean called;
 
-      @Override public <R> Single<?> adapt(Call<R> call) {
-        Observable<?> observable = callAdapter.adapt(call);
-        return observable.toSingle();
-      }
-    };
+  @Override
+  public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+    called = true;
+    return retrofit.nextCallAdapter(this, returnType, annotations);
   }
 }
diff --git a/retrofit/src/main/java/retrofit2/OkHttpCallFactory.java b/retrofit/src/test/java/retrofit2/helpers/NonMatchingCallAdapterFactory.java
similarity index 56%
rename from retrofit/src/main/java/retrofit2/OkHttpCallFactory.java
rename to retrofit/src/test/java/retrofit2/helpers/NonMatchingCallAdapterFactory.java
index 7c9e666bd..3f44ddff8 100644
--- a/retrofit/src/main/java/retrofit2/OkHttpCallFactory.java
+++ b/retrofit/src/test/java/retrofit2/helpers/NonMatchingCallAdapterFactory.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Square, Inc.
+ * Copyright (C) 2016 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,20 +13,19 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.helpers;
 
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.ResponseBody;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import retrofit2.CallAdapter;
+import retrofit2.Retrofit;
 
-final class OkHttpCallFactory implements Call.Factory {
-  final OkHttpClient client;
-
-  OkHttpCallFactory(OkHttpClient client) {
-    this.client = client;
-  }
+public final class NonMatchingCallAdapterFactory extends CallAdapter.Factory {
+  public boolean called;
 
   @Override
-  public <T> Call<T> create(DeferredRequest request, Converter<ResponseBody, T> converter) {
-    return new OkHttpCall<>(client, request, converter);
+  public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+    called = true;
+    return null;
   }
 }
diff --git a/retrofit/src/test/java/retrofit2/helpers/NonMatchingConverterFactory.java b/retrofit/src/test/java/retrofit2/helpers/NonMatchingConverterFactory.java
new file mode 100644
index 000000000..343839944
--- /dev/null
+++ b/retrofit/src/test/java/retrofit2/helpers/NonMatchingConverterFactory.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.helpers;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
+
+public final class NonMatchingConverterFactory extends Converter.Factory {
+  public boolean called;
+
+  @Override
+  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
+    called = true;
+    return null;
+  }
+
+  @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
+      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+    called = true;
+    return null;
+  }
+
+  @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
+    called = true;
+    return null;
+  }
+}
diff --git a/retrofit/src/test/java/retrofit2/helpers/NullObjectConverterFactory.java b/retrofit/src/test/java/retrofit2/helpers/NullObjectConverterFactory.java
new file mode 100644
index 000000000..d34988d1f
--- /dev/null
+++ b/retrofit/src/test/java/retrofit2/helpers/NullObjectConverterFactory.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.helpers;
+
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
+
+/** Always converts to null. */
+public final class NullObjectConverterFactory extends Converter.Factory {
+  @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
+    return new Converter<Object, String>() {
+      @Override public String convert(Object value) throws IOException {
+        return null;
+      }
+    };
+  }
+}
diff --git a/retrofit/src/test/java/retrofit2/ToStringConverterFactory.java b/retrofit/src/test/java/retrofit2/helpers/ToStringConverterFactory.java
similarity index 82%
rename from retrofit/src/test/java/retrofit2/ToStringConverterFactory.java
rename to retrofit/src/test/java/retrofit2/helpers/ToStringConverterFactory.java
index d441a5caf..0a70e3ddb 100644
--- a/retrofit/src/test/java/retrofit2/ToStringConverterFactory.java
+++ b/retrofit/src/test/java/retrofit2/helpers/ToStringConverterFactory.java
@@ -13,16 +13,18 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.helpers;
 
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+import okhttp3.MediaType;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
 
-class ToStringConverterFactory extends Converter.Factory {
+public class ToStringConverterFactory extends Converter.Factory {
   static final MediaType MEDIA_TYPE = MediaType.parse("text/plain");
 
   @Override
@@ -39,7 +41,7 @@
   }
 
   @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
-      Annotation[] annotations, Retrofit retrofit) {
+      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     if (String.class.equals(type)) {
       return new Converter<String, RequestBody>() {
         @Override public RequestBody convert(String value) throws IOException {
diff --git a/samples/pom.xml b/samples/pom.xml
index ed051d0c6..10ce5624b 100644
--- a/samples/pom.xml
+++ b/samples/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>parent</artifactId>
-    <version>2.0.0-SNAPSHOT</version>
+    <version>2.4.1-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -24,19 +24,39 @@
       <artifactId>retrofit-mock</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>converter-moshi</artifactId>
+      <version>${project.version}</version>
+    </dependency>
     <dependency>
       <groupId>${project.groupId}</groupId>
       <artifactId>converter-gson</artifactId>
       <version>${project.version}</version>
     </dependency>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>converter-simplexml</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>adapter-rxjava</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp3</groupId>
       <artifactId>mockwebserver</artifactId>
     </dependency>
     <dependency>
       <groupId>com.google.guava</groupId>
       <artifactId>guava</artifactId>
     </dependency>
+    <dependency>
+      <groupId>org.jsoup</groupId>
+      <artifactId>jsoup</artifactId>
+      <version>${jsoup.version}</version>
+    </dependency>
   </dependencies>
 
   <build>
diff --git a/samples/src/main/java/com/example/retrofit/AnnotatedConverters.java b/samples/src/main/java/com/example/retrofit/AnnotatedConverters.java
new file mode 100644
index 000000000..0664d3482
--- /dev/null
+++ b/samples/src/main/java/com/example/retrofit/AnnotatedConverters.java
@@ -0,0 +1,155 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.retrofit;
+
+import com.google.gson.GsonBuilder;
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.annotation.Retention;
+import java.lang.reflect.Type;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.simpleframework.xml.Attribute;
+import org.simpleframework.xml.Default;
+import org.simpleframework.xml.DefaultType;
+import retrofit2.Call;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
+import retrofit2.converter.gson.GsonConverterFactory;
+import retrofit2.converter.moshi.MoshiConverterFactory;
+import retrofit2.converter.simplexml.SimpleXmlConverterFactory;
+import retrofit2.http.GET;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+final class AnnotatedConverters {
+  public static final class AnnotatedConverterFactory extends Converter.Factory {
+    private final Map<Class<? extends Annotation>, Converter.Factory> factories;
+
+    public static final class Builder {
+      private final Map<Class<? extends Annotation>, Converter.Factory> factories =
+          new LinkedHashMap<>();
+
+      public Builder add(Class<? extends Annotation> cls, Converter.Factory factory) {
+        if (cls == null) {
+          throw new NullPointerException("cls == null");
+        }
+        if (factory == null) {
+          throw new NullPointerException("factory == null");
+        }
+        factories.put(cls, factory);
+        return this;
+      }
+
+      public AnnotatedConverterFactory build() {
+        return new AnnotatedConverterFactory(factories);
+      }
+    }
+
+    AnnotatedConverterFactory(Map<Class<? extends Annotation>, Converter.Factory> factories) {
+      this.factories = new LinkedHashMap<>(factories);
+    }
+
+    @Override
+    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+        Retrofit retrofit) {
+      for (Annotation annotation : annotations) {
+        Converter.Factory factory = factories.get(annotation.annotationType());
+        if (factory != null) {
+          return factory.responseBodyConverter(type, annotations, retrofit);
+        }
+      }
+      return null;
+    }
+
+    @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
+        Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+      for (Annotation annotation : parameterAnnotations) {
+        Converter.Factory factory = factories.get(annotation.annotationType());
+        if (factory != null) {
+          return factory.requestBodyConverter(type, parameterAnnotations, methodAnnotations,
+              retrofit);
+        }
+      }
+      return null;
+    }
+  }
+
+  @Retention(RUNTIME) public @interface Moshi {
+  }
+
+  @Retention(RUNTIME) public @interface Gson {
+  }
+
+  @Retention(RUNTIME) public @interface SimpleXml {
+  }
+
+  @Default(value = DefaultType.FIELD) static final class Library {
+    @Attribute String name;
+  }
+
+  interface Service {
+    @GET("/") @Moshi Call<Library> exampleMoshi();
+
+    @GET("/") @Gson Call<Library> exampleGson();
+
+    @GET("/") @SimpleXml Call<Library> exampleSimpleXml();
+
+    @GET("/") Call<Library> exampleDefault();
+  }
+
+  public static void main(String... args) throws IOException {
+    MockWebServer server = new MockWebServer();
+    server.start();
+    server.enqueue(new MockResponse().setBody("{\"name\": \"Moshi\"}"));
+    server.enqueue(new MockResponse().setBody("{\"name\": \"Gson\"}"));
+    server.enqueue(new MockResponse().setBody("<user name=\"SimpleXML\"/>"));
+    server.enqueue(new MockResponse().setBody("{\"name\": \"Gson\"}"));
+
+    com.squareup.moshi.Moshi moshi = new com.squareup.moshi.Moshi.Builder().build();
+    com.google.gson.Gson gson = new GsonBuilder().create();
+    MoshiConverterFactory moshiConverterFactory = MoshiConverterFactory.create(moshi);
+    GsonConverterFactory gsonConverterFactory = GsonConverterFactory.create(gson);
+    SimpleXmlConverterFactory simpleXmlConverterFactory = SimpleXmlConverterFactory.create();
+    Retrofit retrofit = new Retrofit.Builder().baseUrl(server.url("/"))
+        .addConverterFactory(
+            new AnnotatedConverterFactory.Builder().add(Moshi.class, moshiConverterFactory)
+                .add(Gson.class, gsonConverterFactory)
+                .add(SimpleXml.class, simpleXmlConverterFactory)
+                .build())
+        .addConverterFactory(gsonConverterFactory)
+        .build();
+    Service service = retrofit.create(Service.class);
+
+    Library library1 = service.exampleMoshi().execute().body();
+    System.out.println("Library 1: " + library1.name);
+
+    Library library2 = service.exampleGson().execute().body();
+    System.out.println("Library 2: " + library2.name);
+
+    Library library3 = service.exampleSimpleXml().execute().body();
+    System.out.println("Library 3: " + library3.name);
+
+    Library library4 = service.exampleDefault().execute().body();
+    System.out.println("Library 4: " + library4.name);
+
+    server.shutdown();
+  }
+}
diff --git a/samples/src/main/java/com/example/retrofit/ChunkingConverter.java b/samples/src/main/java/com/example/retrofit/ChunkingConverter.java
index b8cc32893..790675975 100644
--- a/samples/src/main/java/com/example/retrofit/ChunkingConverter.java
+++ b/samples/src/main/java/com/example/retrofit/ChunkingConverter.java
@@ -15,21 +15,21 @@
  */
 package com.example.retrofit;
 
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.ResponseBody;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import com.squareup.okhttp.mockwebserver.RecordedRequest;
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 import java.lang.reflect.Type;
+import okhttp3.MediaType;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
 import okio.BufferedSink;
 import retrofit2.Call;
 import retrofit2.Converter;
-import retrofit2.GsonConverterFactory;
+import retrofit2.converter.gson.GsonConverterFactory;
 import retrofit2.Retrofit;
 import retrofit2.http.Body;
 import retrofit2.http.POST;
@@ -49,11 +49,11 @@
    */
   static class ChunkingConverterFactory extends Converter.Factory {
     @Override
-    public Converter<?, RequestBody> requestBodyConverter(Type type, Annotation[] annotations,
-        Retrofit retrofit) {
+    public Converter<?, RequestBody> requestBodyConverter(Type type,
+        Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
       boolean isBody = false;
       boolean isChunked = false;
-      for (Annotation annotation : annotations) {
+      for (Annotation annotation : parameterAnnotations) {
         isBody |= annotation instanceof Body;
         isChunked |= annotation instanceof Chunked;
       }
@@ -63,7 +63,7 @@
 
       // Look up the real converter to delegate to.
       final Converter<Object, RequestBody> delegate =
-          retrofit.nextRequestBodyConverter(this, type, annotations);
+          retrofit.nextRequestBodyConverter(this, type, parameterAnnotations, methodAnnotations);
       // Wrap it in a Converter which removes the content length from the delegate's body.
       return new Converter<Object, RequestBody>() {
         @Override public RequestBody convert(Object value) throws IOException {
diff --git a/samples/src/main/java/com/example/retrofit/Crawler.java b/samples/src/main/java/com/example/retrofit/Crawler.java
new file mode 100644
index 000000000..1e213e9a1
--- /dev/null
+++ b/samples/src/main/java/com/example/retrofit/Crawler.java
@@ -0,0 +1,146 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.retrofit;
+
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.Executors;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+import okhttp3.ConnectionPool;
+import okhttp3.Dispatcher;
+import okhttp3.HttpUrl;
+import okhttp3.OkHttpClient;
+import okhttp3.ResponseBody;
+import org.jsoup.Jsoup;
+import org.jsoup.nodes.Document;
+import org.jsoup.nodes.Element;
+import retrofit2.Call;
+import retrofit2.Callback;
+import retrofit2.Converter;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+import retrofit2.http.Url;
+
+/** A simple web crawler that uses a Retrofit service to turn URLs into webpages. */
+public final class Crawler {
+  private final Set<HttpUrl> fetchedUrls = Collections.synchronizedSet(
+      new LinkedHashSet<HttpUrl>());
+  private final ConcurrentHashMap<String, AtomicInteger> hostnames = new ConcurrentHashMap<>();
+  private final PageService pageService;
+
+  public Crawler(PageService pageService) {
+    this.pageService = pageService;
+  }
+
+  public void crawlPage(HttpUrl url) {
+    // Skip hosts that we've visited many times.
+    AtomicInteger hostnameCount = new AtomicInteger();
+    AtomicInteger previous = hostnames.putIfAbsent(url.host(), hostnameCount);
+    if (previous != null) hostnameCount = previous;
+    if (hostnameCount.incrementAndGet() > 100) return;
+
+    // Asynchronously visit URL.
+    pageService.get(url).enqueue(new Callback<Page>() {
+      @Override public void onResponse(Call<Page> call, Response<Page> response) {
+        if (!response.isSuccessful()) {
+          System.out.println(call.request().url() + ": failed: " + response.code());
+          return;
+        }
+
+        // Print this page's URL and title.
+        Page page = response.body();
+        HttpUrl base = response.raw().request().url();
+        System.out.println(base + ": " + page.title);
+
+        // Enqueue its links for visiting.
+        for (String link : page.links) {
+          HttpUrl linkUrl = base.resolve(link);
+          if (linkUrl != null && fetchedUrls.add(linkUrl)) {
+            crawlPage(linkUrl);
+          }
+        }
+      }
+
+      @Override public void onFailure(Call<Page> call, Throwable t) {
+        System.out.println(call.request().url() + ": failed: " + t);
+      }
+    });
+  }
+
+  public static void main(String... args) throws Exception {
+    Dispatcher dispatcher = new Dispatcher(Executors.newFixedThreadPool(20));
+    dispatcher.setMaxRequests(20);
+    dispatcher.setMaxRequestsPerHost(1);
+
+    OkHttpClient okHttpClient = new OkHttpClient.Builder()
+        .dispatcher(dispatcher)
+        .connectionPool(new ConnectionPool(100, 30, TimeUnit.SECONDS))
+        .build();
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(HttpUrl.parse("https://example.com/"))
+        .addConverterFactory(PageAdapter.FACTORY)
+        .client(okHttpClient)
+        .build();
+
+    PageService pageService = retrofit.create(PageService.class);
+
+    Crawler crawler = new Crawler(pageService);
+    crawler.crawlPage(HttpUrl.parse(args[0]));
+  }
+
+  interface PageService {
+    @GET Call<Page> get(@Url HttpUrl url);
+  }
+
+  static class Page {
+    final String title;
+    final List<String> links;
+
+    Page(String title, List<String> links) {
+      this.title = title;
+      this.links = links;
+    }
+  }
+
+  static final class PageAdapter implements Converter<ResponseBody, Page> {
+    static final Converter.Factory FACTORY = new Converter.Factory() {
+      @Override public Converter<ResponseBody, ?> responseBodyConverter(
+          Type type, Annotation[] annotations, Retrofit retrofit) {
+        if (type == Page.class) return new PageAdapter();
+        return null;
+      }
+    };
+
+    @Override public Page convert(ResponseBody responseBody) throws IOException {
+      Document document = Jsoup.parse(responseBody.string());
+      List<String> links = new ArrayList<>();
+      for (Element element : document.select("a[href]")) {
+        links.add(element.attr("href"));
+      }
+      return new Page(document.title(), Collections.unmodifiableList(links));
+    }
+  }
+}
diff --git a/samples/src/main/java/com/example/retrofit/CustomCallAdapter.java b/samples/src/main/java/com/example/retrofit/CustomCallAdapter.java
deleted file mode 100644
index cce467ee1..000000000
--- a/samples/src/main/java/com/example/retrofit/CustomCallAdapter.java
+++ /dev/null
@@ -1,118 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.example.retrofit;
-
-import com.google.common.reflect.TypeToken;
-import com.google.common.util.concurrent.AbstractFuture;
-import com.google.common.util.concurrent.ListenableFuture;
-import java.io.IOException;
-import java.lang.annotation.Annotation;
-import java.lang.reflect.ParameterizedType;
-import java.lang.reflect.Type;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.Executors;
-import retrofit2.Call;
-import retrofit2.CallAdapter;
-import retrofit2.Callback;
-import retrofit2.GsonConverterFactory;
-import retrofit2.Response;
-import retrofit2.Retrofit;
-import retrofit2.http.GET;
-
-/**
- * A sample showing a custom {@link CallAdapter} which adapts Guava's {@link ListenableFuture} as
- * a service method return type.
- */
-public final class CustomCallAdapter {
-  public static class ListenableFutureCallAdapterFactory implements CallAdapter.Factory {
-    @Override public CallAdapter<ListenableFuture<?>> get(Type returnType, Annotation[] annotations,
-        Retrofit retrofit) {
-      TypeToken<?> token = TypeToken.of(returnType);
-      if (token.getRawType() != ListenableFuture.class) {
-        return null;
-      }
-      if (!(returnType instanceof ParameterizedType)) {
-        throw new IllegalStateException(
-            "ListenableFuture must have generic type (e.g., ListenableFuture<ResponseBody>)");
-      }
-      final Type responseType = ((ParameterizedType) returnType).getActualTypeArguments()[0];
-      return new CallAdapter<ListenableFuture<?>>() {
-        @Override public Type responseType() {
-          return responseType;
-        }
-
-        @Override public <R> ListenableFuture<R> adapt(Call<R> call) {
-          CallFuture<R> future = new CallFuture<>(call);
-          call.enqueue(future);
-          return future;
-        }
-      };
-    }
-
-    private static final class CallFuture<T> extends AbstractFuture<T> implements Callback<T> {
-      private final Call<T> call;
-
-      private CallFuture(Call<T> call) {
-        this.call = call;
-      }
-
-      @Override protected void interruptTask() {
-        call.cancel();
-      }
-
-      @Override public void onResponse(Response<T> response) {
-        if (response.isSuccess()) {
-          set(response.body());
-        } else {
-          setException(new IOException()); // TODO something more useful.
-        }
-      }
-
-      @Override public void onFailure(Throwable t) {
-        setException(t);
-      }
-    }
-  }
-
-  interface HttpBinService {
-    @GET("/ip")
-    ListenableFuture<Ip> getIp();
-  }
-
-  static class Ip {
-    String origin;
-  }
-
-  public static void main(String... args) {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://httpbin.org")
-        .addCallAdapterFactory(new ListenableFutureCallAdapterFactory())
-        .addConverterFactory(GsonConverterFactory.create())
-        .build();
-
-    HttpBinService service = retrofit.create(HttpBinService.class);
-    final ListenableFuture<Ip> ip = service.getIp();
-    ip.addListener(new Runnable() {
-      @Override public void run() {
-        try {
-          System.out.println("IP: " + ip.get().origin);
-        } catch (InterruptedException | ExecutionException e) {
-          e.printStackTrace();
-        }
-      }
-    }, Executors.newSingleThreadExecutor());
-  }
-}
diff --git a/samples/src/main/java/com/example/retrofit/DeserializeErrorBody.java b/samples/src/main/java/com/example/retrofit/DeserializeErrorBody.java
index 163120e94..4fc6c8669 100644
--- a/samples/src/main/java/com/example/retrofit/DeserializeErrorBody.java
+++ b/samples/src/main/java/com/example/retrofit/DeserializeErrorBody.java
@@ -15,14 +15,14 @@
  */
 package com.example.retrofit;
 
-import com.squareup.okhttp.ResponseBody;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
 import java.io.IOException;
 import java.lang.annotation.Annotation;
+import okhttp3.ResponseBody;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
 import retrofit2.Call;
 import retrofit2.Converter;
-import retrofit2.GsonConverterFactory;
+import retrofit2.converter.gson.GsonConverterFactory;
 import retrofit2.Response;
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
diff --git a/samples/src/main/java/com/example/retrofit/DynamicBaseUrl.java b/samples/src/main/java/com/example/retrofit/DynamicBaseUrl.java
new file mode 100644
index 000000000..bbe28ae57
--- /dev/null
+++ b/samples/src/main/java/com/example/retrofit/DynamicBaseUrl.java
@@ -0,0 +1,86 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.retrofit;
+
+import java.io.IOException;
+import okhttp3.HttpUrl;
+import okhttp3.Interceptor;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.ResponseBody;
+import retrofit2.Call;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+/**
+ * This example uses an OkHttp interceptor to change the target hostname dynamically at runtime.
+ * Typically this would be used to implement client-side load balancing or to use the webserver
+ * that's nearest geographically.
+ */
+public final class DynamicBaseUrl {
+  public interface Pop {
+    @GET("robots.txt")
+    Call<ResponseBody> robots();
+  }
+
+  static final class HostSelectionInterceptor implements Interceptor {
+    private volatile String host;
+
+    public void setHost(String host) {
+      this.host = host;
+    }
+
+    @Override public okhttp3.Response intercept(Chain chain) throws IOException {
+      Request request = chain.request();
+      String host = this.host;
+      if (host != null) {
+        HttpUrl newUrl = request.url().newBuilder()
+            .host(host)
+            .build();
+        request = request.newBuilder()
+            .url(newUrl)
+            .build();
+      }
+      return chain.proceed(request);
+    }
+  }
+
+  public static void main(String... args) throws IOException {
+    HostSelectionInterceptor hostSelectionInterceptor = new HostSelectionInterceptor();
+
+    OkHttpClient okHttpClient = new OkHttpClient.Builder()
+        .addInterceptor(hostSelectionInterceptor)
+        .build();
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://www.github.com/")
+        .callFactory(okHttpClient)
+        .build();
+
+    Pop pop = retrofit.create(Pop.class);
+
+    Response<ResponseBody> response1 = pop.robots().execute();
+    System.out.println("Response from: " + response1.raw().request().url());
+    System.out.println(response1.body().string());
+
+    hostSelectionInterceptor.setHost("www.pepsi.com");
+
+    Response<ResponseBody> response2 = pop.robots().execute();
+    System.out.println("Response from: " + response2.raw().request().url());
+    System.out.println(response2.body().string());
+  }
+}
diff --git a/samples/src/main/java/com/example/retrofit/ErrorHandlingCallAdapter.java b/samples/src/main/java/com/example/retrofit/ErrorHandlingAdapter.java
similarity index 70%
rename from samples/src/main/java/com/example/retrofit/ErrorHandlingCallAdapter.java
rename to samples/src/main/java/com/example/retrofit/ErrorHandlingAdapter.java
index 2326319b7..fd05c044d 100644
--- a/samples/src/main/java/com/example/retrofit/ErrorHandlingCallAdapter.java
+++ b/samples/src/main/java/com/example/retrofit/ErrorHandlingAdapter.java
@@ -15,15 +15,15 @@
  */
 package com.example.retrofit;
 
-import com.google.common.reflect.TypeToken;
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
+import java.util.concurrent.Executor;
 import retrofit2.Call;
 import retrofit2.CallAdapter;
 import retrofit2.Callback;
-import retrofit2.GsonConverterFactory;
+import retrofit2.converter.gson.GsonConverterFactory;
 import retrofit2.Response;
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
@@ -32,7 +32,7 @@
  * A sample showing a custom {@link CallAdapter} which adapts the built-in {@link Call} to a custom
  * version whose callback has more granular methods.
  */
-public final class ErrorHandlingCallAdapter {
+public final class ErrorHandlingAdapter {
   /** A callback which offers granular callbacks for various conditions. */
   interface MyCallback<T> {
     /** Called for [200, 300) responses. */
@@ -58,36 +58,48 @@
     // TODO MyResponse<T> execute() throws MyHttpException;
   }
 
-  public static class ErrorHandlingCallAdapterFactory implements CallAdapter.Factory {
-    @Override public CallAdapter<MyCall<?>> get(Type returnType, Annotation[] annotations,
+  public static class ErrorHandlingCallAdapterFactory extends CallAdapter.Factory {
+    @Override public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations,
         Retrofit retrofit) {
-      TypeToken<?> token = TypeToken.of(returnType);
-      if (token.getRawType() != MyCall.class) {
+      if (getRawType(returnType) != MyCall.class) {
         return null;
       }
       if (!(returnType instanceof ParameterizedType)) {
         throw new IllegalStateException(
             "MyCall must have generic type (e.g., MyCall<ResponseBody>)");
       }
-      final Type responseType = ((ParameterizedType) returnType).getActualTypeArguments()[0];
-      return new CallAdapter<MyCall<?>>() {
-        @Override public Type responseType() {
-          return responseType;
-        }
+      Type responseType = getParameterUpperBound(0, (ParameterizedType) returnType);
+      Executor callbackExecutor = retrofit.callbackExecutor();
+      return new ErrorHandlingCallAdapter<>(responseType, callbackExecutor);
+    }
 
-        @Override public <R> MyCall<R> adapt(Call<R> call) {
-          return new MyCallAdapter<>(call);
-        }
-      };
+    private static final class ErrorHandlingCallAdapter<R> implements CallAdapter<R, MyCall<R>> {
+      private final Type responseType;
+      private final Executor callbackExecutor;
+
+      ErrorHandlingCallAdapter(Type responseType, Executor callbackExecutor) {
+        this.responseType = responseType;
+        this.callbackExecutor = callbackExecutor;
+      }
+
+      @Override public Type responseType() {
+        return responseType;
+      }
+
+      @Override public MyCall<R> adapt(Call<R> call) {
+        return new MyCallAdapter<>(call, callbackExecutor);
+      }
     }
   }
 
   /** Adapts a {@link Call} to {@link MyCall}. */
   static class MyCallAdapter<T> implements MyCall<T> {
     private final Call<T> call;
+    private final Executor callbackExecutor;
 
-    MyCallAdapter(Call<T> call) {
+    MyCallAdapter(Call<T> call, Executor callbackExecutor) {
       this.call = call;
+      this.callbackExecutor = callbackExecutor;
     }
 
     @Override public void cancel() {
@@ -96,7 +108,10 @@
 
     @Override public void enqueue(final MyCallback<T> callback) {
       call.enqueue(new Callback<T>() {
-        @Override public void onResponse(Response<T> response) {
+        @Override public void onResponse(Call<T> call, Response<T> response) {
+          // TODO if 'callbackExecutor' is not null, the 'callback' methods should be executed
+          // on that executor by submitting a Runnable. This is left as an exercise for the reader.
+
           int code = response.code();
           if (code >= 200 && code < 300) {
             callback.success(response);
@@ -111,7 +126,10 @@
           }
         }
 
-        @Override public void onFailure(Throwable t) {
+        @Override public void onFailure(Call<T> call, Throwable t) {
+          // TODO if 'callbackExecutor' is not null, the 'callback' methods should be executed
+          // on that executor by submitting a Runnable. This is left as an exercise for the reader.
+
           if (t instanceof IOException) {
             callback.networkError((IOException) t);
           } else {
@@ -122,7 +140,7 @@
     }
 
     @Override public MyCall<T> clone() {
-      return new MyCallAdapter<>(call.clone());
+      return new MyCallAdapter<>(call.clone(), callbackExecutor);
     }
   }
 
@@ -162,7 +180,7 @@ public static void main(String... args) {
       }
 
       @Override public void networkError(IOException e) {
-        System.err.println("NETOWRK ERROR " + e.getMessage());
+        System.err.println("NETWORK ERROR " + e.getMessage());
       }
 
       @Override public void unexpectedError(Throwable t) {
diff --git a/samples/src/main/java/com/example/retrofit/JsonAndXmlConverters.java b/samples/src/main/java/com/example/retrofit/JsonAndXmlConverters.java
new file mode 100644
index 000000000..2163f3dec
--- /dev/null
+++ b/samples/src/main/java/com/example/retrofit/JsonAndXmlConverters.java
@@ -0,0 +1,128 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.retrofit;
+
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.annotation.Retention;
+import java.lang.reflect.Type;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.simpleframework.xml.Attribute;
+import org.simpleframework.xml.Default;
+import org.simpleframework.xml.DefaultType;
+import retrofit2.Call;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
+import retrofit2.converter.gson.GsonConverterFactory;
+import retrofit2.converter.simplexml.SimpleXmlConverterFactory;
+import retrofit2.http.GET;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Both the Gson converter and the Simple Framework converter accept all types. Because of this,
+ * you cannot use both in a single service by default. In order to work around this, we can create
+ * an @Json and @Xml annotation to declare which serialization format each endpoint should use and
+ * then write our own Converter.Factory which delegates to either the Gson or Simple Framework
+ * converter.
+ */
+public final class JsonAndXmlConverters {
+  @Retention(RUNTIME)
+  @interface Json {
+  }
+
+  @Retention(RUNTIME)
+  @interface Xml {
+  }
+
+  static class QualifiedTypeConverterFactory extends Converter.Factory {
+    private final Converter.Factory jsonFactory;
+    private final Converter.Factory xmlFactory;
+
+    QualifiedTypeConverterFactory(Converter.Factory jsonFactory, Converter.Factory xmlFactory) {
+      this.jsonFactory = jsonFactory;
+      this.xmlFactory = xmlFactory;
+    }
+
+    @Override
+    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+        Retrofit retrofit) {
+      for (Annotation annotation : annotations) {
+        if (annotation instanceof Json) {
+          return jsonFactory.responseBodyConverter(type, annotations, retrofit);
+        }
+        if (annotation instanceof Xml) {
+          return xmlFactory.responseBodyConverter(type, annotations, retrofit);
+        }
+      }
+      return null;
+    }
+
+    @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
+        Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+      for (Annotation annotation : parameterAnnotations) {
+        if (annotation instanceof Json) {
+          return jsonFactory.requestBodyConverter(type, parameterAnnotations, methodAnnotations,
+              retrofit);
+        }
+        if (annotation instanceof Xml) {
+          return xmlFactory.requestBodyConverter(type, parameterAnnotations, methodAnnotations,
+              retrofit);
+        }
+      }
+      return null;
+    }
+  }
+
+  @Default(value = DefaultType.FIELD)
+  static class User {
+    @Attribute
+    public String name;
+  }
+
+  interface Service {
+    @GET("/") @Json
+    Call<User> exampleJson();
+    @GET("/") @Xml
+    Call<User> exampleXml();
+  }
+
+  public static void main(String... args) throws IOException {
+    MockWebServer server = new MockWebServer();
+    server.start();
+    server.enqueue(new MockResponse().setBody("{\"name\": \"Jason\"}"));
+    server.enqueue(new MockResponse().setBody("<user name=\"Eximel\"/>"));
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new QualifiedTypeConverterFactory(
+            GsonConverterFactory.create(),
+            SimpleXmlConverterFactory.create()))
+        .build();
+    Service service = retrofit.create(Service.class);
+
+    User user1 = service.exampleJson().execute().body();
+    System.out.println("User 1: " + user1.name);
+
+    User user2 = service.exampleXml().execute().body();
+    System.out.println("User 2: " + user2.name);
+
+    server.shutdown();
+  }
+}
diff --git a/samples/src/main/java/com/example/retrofit/JsonQueryParameters.java b/samples/src/main/java/com/example/retrofit/JsonQueryParameters.java
new file mode 100644
index 000000000..724c75fb2
--- /dev/null
+++ b/samples/src/main/java/com/example/retrofit/JsonQueryParameters.java
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.retrofit;
+
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.annotation.Retention;
+import java.lang.reflect.Type;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
+import okio.Buffer;
+import retrofit2.Call;
+import retrofit2.Converter;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.converter.gson.GsonConverterFactory;
+import retrofit2.http.GET;
+import retrofit2.http.Query;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+public final class JsonQueryParameters {
+  @Retention(RUNTIME)
+  @interface Json {
+  }
+
+  static class JsonStringConverterFactory extends Converter.Factory {
+    private final Converter.Factory delegateFactory;
+
+    JsonStringConverterFactory(Converter.Factory delegateFactory) {
+      this.delegateFactory = delegateFactory;
+    }
+
+    @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+        Retrofit retrofit) {
+      for (Annotation annotation : annotations) {
+        if (annotation instanceof Json) {
+          // NOTE: If you also have a JSON converter factory installed in addition to this factory,
+          // you can call retrofit.requestBodyConverter(type, annotations) instead of having a
+          // reference to it explicitly as a field.
+          Converter<?, RequestBody> delegate =
+              delegateFactory.requestBodyConverter(type, annotations, new Annotation[0], retrofit);
+          return new DelegateToStringConverter<>(delegate);
+        }
+      }
+      return null;
+    }
+
+    static class DelegateToStringConverter<T> implements Converter<T, String> {
+      private final Converter<T, RequestBody> delegate;
+
+      DelegateToStringConverter(Converter<T, RequestBody> delegate) {
+        this.delegate = delegate;
+      }
+
+      @Override public String convert(T value) throws IOException {
+        Buffer buffer = new Buffer();
+        delegate.convert(value).writeTo(buffer);
+        return buffer.readUtf8();
+      }
+    }
+  }
+
+  static class Filter {
+    final String userId;
+
+    Filter(String userId) {
+      this.userId = userId;
+    }
+  }
+
+  interface Service {
+    @GET("/filter")
+    Call<ResponseBody> example(@Json @Query("value") Filter value);
+  }
+
+  public static void main(String... args) throws IOException, InterruptedException {
+    MockWebServer server = new MockWebServer();
+    server.start();
+    server.enqueue(new MockResponse());
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new JsonStringConverterFactory(GsonConverterFactory.create()))
+        .build();
+    Service service = retrofit.create(Service.class);
+
+    Call<ResponseBody> call = service.example(new Filter("123"));
+    Response<ResponseBody> response = call.execute();
+    // TODO handle user response...
+
+    // Print the request path that the server saw to show the JSON query param:
+    RecordedRequest recordedRequest = server.takeRequest();
+    System.out.println(recordedRequest.getPath());
+
+    server.shutdown();
+  }
+}
diff --git a/samples/src/main/java/com/example/retrofit/RxJavaObserveOnMainThread.java b/samples/src/main/java/com/example/retrofit/RxJavaObserveOnMainThread.java
new file mode 100644
index 000000000..6c4fec40d
--- /dev/null
+++ b/samples/src/main/java/com/example/retrofit/RxJavaObserveOnMainThread.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.retrofit;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import retrofit2.Call;
+import retrofit2.CallAdapter;
+import retrofit2.Retrofit;
+import retrofit2.adapter.rxjava.RxJavaCallAdapterFactory;
+import rx.Observable;
+import rx.Scheduler;
+import rx.schedulers.Schedulers;
+
+import static rx.schedulers.Schedulers.io;
+
+public final class RxJavaObserveOnMainThread {
+  public static void main(String... args) {
+    Scheduler observeOn = Schedulers.computation(); // Or use mainThread() for Android.
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com")
+        .addCallAdapterFactory(new ObserveOnMainCallAdapterFactory(observeOn))
+        .addCallAdapterFactory(RxJavaCallAdapterFactory.createWithScheduler(io()))
+        .build();
+
+    // Services created with this instance that use Observable will execute on the 'io' scheduler
+    // and notify their observer on the 'computation' scheduler.
+  }
+
+  static final class ObserveOnMainCallAdapterFactory extends CallAdapter.Factory {
+    final Scheduler scheduler;
+
+    ObserveOnMainCallAdapterFactory(Scheduler scheduler) {
+      this.scheduler = scheduler;
+    }
+
+    @Override
+    public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+      if (getRawType(returnType) != Observable.class) {
+        return null; // Ignore non-Observable types.
+      }
+
+      // Look up the next call adapter which would otherwise be used if this one was not present.
+      //noinspection unchecked returnType checked above to be Observable.
+      final CallAdapter<Object, Observable<?>> delegate =
+          (CallAdapter<Object, Observable<?>>) retrofit.nextCallAdapter(this, returnType,
+              annotations);
+
+      return new CallAdapter<Object, Object>() {
+        @Override public Object adapt(Call<Object> call) {
+          // Delegate to get the normal Observable...
+          Observable<?> o = delegate.adapt(call);
+          // ...and change it to send notifications to the observer on the specified scheduler.
+          return o.observeOn(scheduler);
+        }
+
+        @Override public Type responseType() {
+          return delegate.responseType();
+        }
+      };
+    }
+  }
+}
diff --git a/samples/src/main/java/com/example/retrofit/SimpleMockService.java b/samples/src/main/java/com/example/retrofit/SimpleMockService.java
index 347c911af..7c8a98e37 100644
--- a/samples/src/main/java/com/example/retrofit/SimpleMockService.java
+++ b/samples/src/main/java/com/example/retrofit/SimpleMockService.java
@@ -26,7 +26,7 @@
     private final BehaviorDelegate<GitHub> delegate;
     private final Map<String, Map<String, List<Contributor>>> ownerRepoContributors;
 
-    public MockGitHub(BehaviorDelegate<GitHub> delegate) {
+    MockGitHub(BehaviorDelegate<GitHub> delegate) {
       this.delegate = delegate;
       ownerRepoContributors = new LinkedHashMap<>();
 
@@ -50,7 +50,7 @@ public MockGitHub(BehaviorDelegate<GitHub> delegate) {
       return delegate.returningResponse(response).contributors(owner, repo);
     }
 
-    public void addContributor(String owner, String repo, String name, int contributions) {
+    void addContributor(String owner, String repo, String name, int contributions) {
       Map<String, List<Contributor>> repoContributors = ownerRepoContributors.get(owner);
       if (repoContributors == null) {
         repoContributors = new LinkedHashMap<>();
diff --git a/samples/src/main/java/com/example/retrofit/SimpleService.java b/samples/src/main/java/com/example/retrofit/SimpleService.java
index 135eb818c..ef5a3060e 100644
--- a/samples/src/main/java/com/example/retrofit/SimpleService.java
+++ b/samples/src/main/java/com/example/retrofit/SimpleService.java
@@ -18,7 +18,7 @@
 import java.io.IOException;
 import java.util.List;
 import retrofit2.Call;
-import retrofit2.GsonConverterFactory;
+import retrofit2.converter.gson.GsonConverterFactory;
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
 import retrofit2.http.Path;
diff --git a/website/index.html b/website/index.html
index a7933983c..1b33a54b5 100644
--- a/website/index.html
+++ b/website/index.html
@@ -22,8 +22,8 @@ <h1>Retrofit</h1>
             <menu>
               <ul>
                 <li><a href="#download" class="menu download">Download <span class="version-tag">Latest</span></a></li>
-                <li><a href="http://github.com/square/retrofit" data-title="View GitHub Project" class="menu github"><img src="static/icon-github.png" alt="GitHub"/></a></li>
-                <li><a href="http://square.github.io/" data-title="Square Open Source Portal" class="menu square"><img src="static/icon-square.png" alt="Square"/></a></li>
+                <li><a href="https://github.com/square/retrofit" data-title="View GitHub Project" class="menu github"><img src="static/icon-github.png" alt="GitHub"/></a></li>
+                <li><a href="https://square.github.io/" data-title="Square Open Source Portal" class="menu square"><img src="static/icon-square.png" alt="Square"/></a></li>
               </ul>
             </menu>
           </div>
@@ -47,12 +47,12 @@ <h2>A type-safe <strong>HTTP client</strong> for Android and Java<!-- and Samsun
               <h3>Introduction</h3>
               <p>Retrofit turns your HTTP API into a Java interface.</p>
               <pre class="prettyprint">public interface GitHubService {
-  @GET("/users/{user}/repos")
+  @GET("users/{user}/repos")
   Call&lt;List&lt;Repo>> listRepos(@Path("user") String user);
 }</pre>
               <p>The <code>Retrofit</code> class generates an implementation of the <code>GitHubService</code> interface.</p>
               <pre class="prettyprint">Retrofit retrofit = new Retrofit.Builder()
-    .baseUrl("https://api.github.com")
+    .baseUrl("https://api.github.com/")
     .build();
 
 GitHubService service = retrofit.create(GitHubService.class);</pre>
@@ -64,7 +64,6 @@ <h3>Introduction</h3>
                 <li>Object conversion to request body (e.g., JSON, protocol buffers)</li>
                 <li>Multipart request body and file upload</li>
               </ul>
-              <p><em>Note:</em> This site is still in the process of being expanded for the new 2.0 APIs.</p>
             </section>
 
             <section id="api-declaration">
@@ -73,24 +72,24 @@ <h3>API Declaration</h3>
 
               <h4>Request Method</h4>
               <p>Every method must have an HTTP annotation that provides the request method and relative URL. There are five built-in annotations: <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>, and <code>HEAD</code>. The relative URL of the resource is specified in the annotation.</p>
-              <pre class="prettyprint">@GET("/users/list")</pre>
+              <pre class="prettyprint">@GET("users/list")</pre>
               <p>You can also specify query parameters in the URL.</p>
-              <pre class="prettyprint">@GET("/users/list?sort=desc")</pre>
+              <pre class="prettyprint">@GET("users/list?sort=desc")</pre>
 
               <h4>URL Manipulation</h4>
               <p>A request URL can be updated dynamically using replacement blocks and parameters on the method. A replacement block is an alphanumeric string surrounded by <code>{</code> and <code>}</code>. A corresponding parameter must be annotated with <code>@Path</code> using the same string.</p>
-              <pre class="prettyprint">@GET("/group/{id}/users")
+              <pre class="prettyprint">@GET("group/{id}/users")
 Call&lt;List&lt;User>> groupList(@Path("id") int groupId);</pre>
               <p>Query parameters can also be added.</p>
-              <pre class="prettyprint">@GET("/group/{id}/users")
+              <pre class="prettyprint">@GET("group/{id}/users")
 Call&lt;List&lt;User>> groupList(@Path("id") int groupId, @Query("sort") String sort);</pre>
               <p>For complex query parameter combinations a <code>Map</code> can be used.</p>
-              <pre class="prettyprint">@GET("/group/{id}/users")
+              <pre class="prettyprint">@GET("group/{id}/users")
 Call&lt;List&lt;User>> groupList(@Path("id") int groupId, @QueryMap Map&lt;String, String&gt; options);</pre>
 
               <h4>Request Body</h4>
               <p>An object can be specified for use as an HTTP request body with the <code>@Body</code> annotation.</p>
-              <pre class="prettyprint">@POST("/users/new")
+              <pre class="prettyprint">@POST("users/new")
 Call&lt;User> createUser(@Body User user);</pre>
               <p>The object will also be converted using a converter specified on the <code>Retrofit</code> instance. If no converter is added, only <code>RequestBody</code> can be used.</p>
 
@@ -98,29 +97,32 @@ <h4>Form Encoded and Multipart</h4>
               <p>Methods can also be declared to send form-encoded and multipart data.</p>
               <p>Form-encoded data is sent when <code>@FormUrlEncoded</code> is present on the method. Each key-value pair is annotated with <code>@Field</code> containing the name and the object providing the value.</p>
               <pre class="prettyprint">@FormUrlEncoded
-@POST("/user/edit")
+@POST("user/edit")
 Call&lt;User> updateUser(@Field("first_name") String first, @Field("last_name") String last);</pre>
               <p>Multipart requests are used when <code>@Multipart</code> is present on the method. Parts are declared using the <code>@Part</code> annotation.</p>
               <pre class="prettyprint">@Multipart
-@PUT("/user/photo")
+@PUT("user/photo")
 Call&lt;User> updateUser(@Part("photo") RequestBody photo, @Part("description") RequestBody description);</pre>
               <p>Multipart parts use one of <code>Retrofit</code>'s converters or they can implement <code>RequestBody</code> to handle their own serialization.</p>
 
               <h4>Header Manipulation</h4>
               <p>You can set static headers for a method using the <code>@Headers</code> annotation.</p>
               <pre class="prettyprint">@Headers("Cache-Control: max-age=640000")
-@GET("/widget/list")
+@GET("widget/list")
 Call&lt;List&lt;Widget>> widgetList();</pre>
               <pre class="prettyprint">@Headers({
     "Accept: application/vnd.github.v3.full+json",
     "User-Agent: Retrofit-Sample-App"
 })
-@GET("/users/{username}")
+@GET("users/{username}")
 Call&lt;User> getUser(@Path("username") String username);</pre>
               <p>Note that headers do not overwrite each other. All headers with the same name will be included in the request.</p>
               <p>A request Header can be updated dynamically using the <code>@Header</code> annotation. A corresponding parameter must be provided to the <code>@Header</code>. If the value is null, the header will be omitted. Otherwise, <code>toString</code> will be called on the value, and the result used.</p>
-              <pre class="prettyprint">@GET("/user")
+              <pre class="prettyprint">@GET("user")
 Call&lt;User> getUser(@Header("Authorization") String authorization)</pre>
+              <p>Similar to query parameters, for complex header combinations, a <code>Map</code> can be used.
+			  <pre class="prettyprint">@GET("user")
+Call&lt;User> getUser(@HeaderMap Map&lt;String, String&gt; headers)</pre>
               <p>Headers that need to be added to every request can be specified using an <a href="https://github.com/square/okhttp/wiki/Interceptors">OkHttp interceptor</a>.
 
               <h4>Synchronous vs. Asynchronous</h4>
@@ -136,12 +138,13 @@ <h4>Converters</h4>
               <p>By default, Retrofit can only deserialize HTTP bodies into OkHttp's <code>ResponseBody</code> type and it can only accept its <code>RequestBody</code> type for <code>@Body</code>.</p>
               <p>Converters can be added to support other types. Six sibling modules adapt popular serialization libraries for your convenience.</p>
               <ul>
-                <li><a href="https://github.com/google/gson">Gson</a>: <code>com.squareup.retrofit:converter-gson</code></li>
-                <li><a href="http://wiki.fasterxml.com/JacksonHome">Jackson</a>: <code>com.squareup.retrofit:converter-jackson</code></li>
-                <li><a href="https://github.com/square/moshi/">Moshi</a>: <code>com.squareup.retrofit:converter-moshi</code></li>
-                <li><a href="https://developers.google.com/protocol-buffers/">Protobuf</a>: <code>com.squareup.retrofit:converter-protobuf</code></li>
-                <li><a href="https://github.com/square/wire">Wire</a>: <code>com.squareup.retrofit:converter-wire</code></li>
-                <li><a href="http://simple.sourceforge.net/">Simple XML</a>: <code>com.squareup.retrofit:converter-simplexml</code></li>
+                <li><a href="https://github.com/google/gson">Gson</a>: <code>com.squareup.retrofit2:converter-gson</code></li>
+                <li><a href="http://wiki.fasterxml.com/JacksonHome">Jackson</a>: <code>com.squareup.retrofit2:converter-jackson</code></li>
+                <li><a href="https://github.com/square/moshi/">Moshi</a>: <code>com.squareup.retrofit2:converter-moshi</code></li>
+                <li><a href="https://developers.google.com/protocol-buffers/">Protobuf</a>: <code>com.squareup.retrofit2:converter-protobuf</code></li>
+                <li><a href="https://github.com/square/wire">Wire</a>: <code>com.squareup.retrofit2:converter-wire</code></li>
+                <li><a href="http://simple.sourceforge.net/">Simple XML</a>: <code>com.squareup.retrofit2:converter-simplexml</code></li>
+                <li>Scalars (primitives, boxed, and String): <code>com.squareup.retrofit2:converter-scalars</code></li>
               </ul>
               <p>Here's an example of using the <code>GsonConverterFactory</code> class to generate an implementation of the <code>GitHubService</code> interface which uses Gson for its deserialization.</p>
               <pre class="prettyprint">Retrofit retrofit = new Retrofit.Builder()
@@ -151,13 +154,13 @@ <h4>Converters</h4>
 
 GitHubService service = retrofit.create(GitHubService.class);</pre>
               <h4>Custom Converters</h4>
-              <p>If you need to communicate with an API that uses a content-format that Retrofit does not support out of the box (e.g. YAML, txt, custom format) or you wish to use a different library to implement an existing format, you can easily create your own converter. Create a class that extends the <a href="https://github.com/square/retrofit/blob/master/retrofit/src/main/java/retrofit/Converter.java"><code>Converter.Factory</code> class</a> and pass in an instance when building your adapter.</p>
+              <p>If you need to communicate with an API that uses a content-format that Retrofit does not support out of the box (e.g. YAML, txt, custom format) or you wish to use a different library to implement an existing format, you can easily create your own converter. Create a class that extends the <a href="https://github.com/square/retrofit/blob/master/retrofit/src/main/java/retrofit2/Converter.java"><code>Converter.Factory</code> class</a> and pass in an instance when building your adapter.</p>
             </section>
 
             <section id="download">
               <h3>Download</h3>
               <p><a href="https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=retrofit&v=LATEST" class="dl version-href">&darr; <span class="version-tag">Latest</span> JAR</a></p>
-              <p>The source code to the Retrofit, its samples, and this website is <a href="http://github.com/square/retrofit">available on GitHub</a>.</p>
+              <p>The source code to the Retrofit, its samples, and this website is <a href="https://github.com/square/retrofit">available on GitHub</a>.</p>
               <h4>Maven</h4>
               <pre class="prettyprint">&lt;dependency>
   &lt;groupId>com.squareup.retrofit2&lt;/groupId>
@@ -166,25 +169,30 @@ <h4>Maven</h4>
 &lt;/dependency></pre>
               <h4>Gradle</h4>
               <pre class="prettyprint">
-compile 'com.squareup.retrofit2:retrofit:<span class="version pln"><em>(insert latest version)</em></span>'
+implementation 'com.squareup.retrofit2:retrofit:<span class="version pln"><em>(insert latest version)</em></span>'
 </pre>
               <p>Retrofit requires at minimum Java 7 or Android 2.3.</p>
 
               <h4>ProGuard</h4>
-              <p>If you are using Proguard in your project add the following lines to your configuration:</p>
+              <p>If you are using ProGuard in your project add the following lines to your configuration:</p>
               <pre class="prettyprint">
--dontwarn retrofit2.**
--keep class retrofit2.** { *; }
+# Retain generic type information for use by reflection by converters and adapters.
 -keepattributes Signature
--keepattributes Exceptions
+# Retain service method parameters.
+-keepclassmembernames,allowobfuscation interface * {
+    @retrofit2.http.* <methods>;
+}
+# Ignore annotation used for build tooling.
+-dontwarn org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement
 </pre>
+            <p>Retrofit uses <a href="https://github.com/square/okio">Okio</a> under the hood, so you may want to look at its <a href="https://github.com/square/okio#proguard">ProGuard rules</a> as well.</p>
             </section>
 
             <section id="contributing">
               <h3>Contributing</h3>
               <p>If you would like to contribute code you can do so through GitHub by forking the repository and sending a pull request.</p>
               <p>When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Please also make sure your code compiles by running <code>mvn clean verify</code>.</p>
-              <p>Before your code can be accepted into the project you must also sign the <a href="http://squ.re/sign-the-cla">Individual Contributor License Agreement (CLA)</a>.</p>
+              <p>Before your code can be accepted into the project you must also sign the <a href="https://squ.re/sign-the-cla">Individual Contributor License Agreement (CLA)</a>.</p>
             </section>
 
             <section id="license">
@@ -216,7 +224,7 @@ <h3>License</h3>
               </ul>
               <ul class="nav nav-pills nav-stacked secondary">
                 <li><a href="2.x/retrofit/">Javadoc</a></li>
-                <li><a href="http://stackoverflow.com/questions/tagged/retrofit?sort=active">StackOverflow</a></li>
+                <li><a href="https://stackoverflow.com/questions/tagged/retrofit?sort=active">StackOverflow</a></li>
               </ul>
             </div>
           </div>
diff --git a/website/static/jquery-maven-artifact.min.js b/website/static/jquery-maven-artifact.min.js
index 08a0304fe..0cb624ff6 100644
--- a/website/static/jquery-maven-artifact.min.js
+++ b/website/static/jquery-maven-artifact.min.js
@@ -5,4 +5,4 @@
  * Author: Jake Wharton
  * License: Apache 2.0
  */
-(function($){function downloadUrl(groupId,artifactId,version,type){var groupPath=groupId.replace(/\./g,"/");return"http://repo1.maven.org/maven2/"+groupPath+"/"+artifactId+"/"+version+"/"+artifactId+"-"+version+type}$.fn.artifactVersion=function(groupId,artifactId,callback){if(typeof groupId!=="string"||typeof artifactId!=="string"){console.log("Error: groupId and artifactId are required.");return}if(typeof callback==="undefined"){console.log("Error: callback function required.");return}var url='http://search.maven.org/solrsearch/select/?q=g:"'+groupId+'"+AND+a:"'+artifactId+'"&wt=json&json.wrf=?';$.getJSON(url,function(response){var versions=response.response.docs;if(versions.length==0){return}var version=versions[0].latestVersion;var versionUrl=downloadUrl(groupId,artifactId,version,".jar");callback(version,versionUrl)})};$.fn.artifactVersions=function(groupId,artifactId,callback){if(typeof groupId!=="string"||typeof artifactId!=="string"){console.log("Error: groupId and artifactId are required.");return}if(typeof callback==="undefined"){console.log("Error: callback function required.");return}var url='http://search.maven.org/solrsearch/select/?q=g:"'+groupId+'"+AND+a:"'+artifactId+'"&wt=json&rows=10&core=gav&json.wrf=?';$.getJSON(url,function(response){var versions=response.response.docs;if(versions.length==0){return}versions.sort(function(o1,o2){return o1.v>o2.v?-1:1});var newVersions=[];for(var i=0;i<versions.length;i++){var version=versions[i].v;newVersions.push({name:version,url:downloadUrl(groupId,artifactId,version,".jar")})}callback(newVersions)})}})(jQuery);
\ No newline at end of file
+(function($){function downloadUrl(groupId,artifactId,version,type){var groupPath=groupId.replace(/\./g,"/");return"https://repo1.maven.org/maven2/"+groupPath+"/"+artifactId+"/"+version+"/"+artifactId+"-"+version+type}$.fn.artifactVersion=function(groupId,artifactId,callback){if(typeof groupId!=="string"||typeof artifactId!=="string"){console.log("Error: groupId and artifactId are required.");return}if(typeof callback==="undefined"){console.log("Error: callback function required.");return}var url='https://search.maven.org/solrsearch/select/?q=g:"'+groupId+'"+AND+a:"'+artifactId+'"&wt=json&json.wrf=?';$.getJSON(url,function(response){var versions=response.response.docs;if(versions.length==0){return}var version=versions[0].latestVersion;var versionUrl=downloadUrl(groupId,artifactId,version,".jar");callback(version,versionUrl)})};$.fn.artifactVersions=function(groupId,artifactId,callback){if(typeof groupId!=="string"||typeof artifactId!=="string"){console.log("Error: groupId and artifactId are required.");return}if(typeof callback==="undefined"){console.log("Error: callback function required.");return}var url='https://search.maven.org/solrsearch/select/?q=g:"'+groupId+'"+AND+a:"'+artifactId+'"&wt=json&rows=10&core=gav&json.wrf=?';$.getJSON(url,function(response){var versions=response.response.docs;if(versions.length==0){return}versions.sort(function(o1,o2){return o1.v>o2.v?-1:1});var newVersions=[];for(var i=0;i<versions.length;i++){var version=versions[i].v;newVersions.push({name:version,url:downloadUrl(groupId,artifactId,version,".jar")})}callback(newVersions)})}})(jQuery);
