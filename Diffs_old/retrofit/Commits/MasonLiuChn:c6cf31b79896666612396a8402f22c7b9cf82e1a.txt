diff --git a/.gitignore b/.gitignore
index 5632d833a..694a3ae67 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,3 +1,4 @@
+# Eclipse
 .classpath
 .project
 .settings
@@ -13,12 +14,14 @@ target
 pom.xml.*
 release.properties
 
+# Idea
 .idea
 *.iml
 classes
 
 obj
 
+#MacOS
 .DS_Store
 
 .gradle
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 98435f4bd..79750dded 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,6 +1,83 @@
 Change Log
 ==========
 
+Version 2.3.0 *(2017-05-13)*
+----------------------------
+
+ *  **Retrofit now uses `@Nullable` to annotate all possibly-null values.** We've
+    added a compile-time dependency on the JSR 305 annotations. This is a
+    [provided][maven_provided] dependency and does not need to be included in
+    your build configuration, `.jar` file, or `.apk`. We use
+    `@ParametersAreNonnullByDefault` and all parameters and return types are
+    never null unless explicitly annotated `@Nullable`.
+
+    **Warning: this release is source-incompatible for Kotlin users.**
+    Nullability was previously ambiguous and lenient but now the compiler will
+    enforce strict null checks.
+
+ * New: Converters added for Java 8's and Guava's `Optional` which wrap a potentially-nullable
+   response body. These converters still rely on normal serialization library converters for parsing
+   the response bytes into an object.
+ * New: String converters that return `null` for an `@Query` or `@Field` parameter are now skipped.
+ * New: The mock module's `NetworkBehavior` now throws a custom subclass of `IOException` to more
+   clearly indicate the exception's source.
+ * RxJava 1.x converter updated to 1.3.0 which stabilizes the use of `Completable`.
+ * Fix: Add explicit handling for `OnCompleteFailedException`, `OnErrorFailedException`, and
+   `OnErrorNotImplementedException` for RxJava 1.x to ensure they're correct delivered to the
+   plugins/hooks for handling.
+ * Fix: `NoSuchElementException` thrown when unsubscribing from an RxJava 1.x `Single`.
+
+
+Version 2.2.0 *(2017-02-21)*
+----------------------------
+
+ * RxJava 2.x is now supported with a first-party 'adapter-rxjava2' artifact.
+ * New: `@QueryName` annotation allows creating a query parameter with no '=' separator or value.
+ * New: Support for messages generated by Protobuf 3.0 or newer when using the converter for Google's
+   protobuf.
+ * New: RxJava 1.x call adapter now correctly handles broken subscribers whose methods throw exceptions.
+ * New: Add `toString()` implementations for `Response` and `Result`.
+ * New: The Moshi converter factory now offers methods for enabling null serialization and lenient
+   parsing.
+ * New: Add `createAsync()` to RxJava 1.x call adapter factory which executes requests using
+   `Call.enqueue()` using the underlying HTTP client's asynchronous support.
+ * New: `NetworkBehavior` now allows setting an error percentage and returns HTTP errors when triggered.
+ * `HttpException` has been moved into the main artifact and should be used instead of the versions
+   embedded in each adapter (which have been deprecated).
+ * Promote the response body generic type on `CallAdapter` from the `adapt` method to the enclosing
+   class. This is a source-incompatible but binary-compatible change which is only relevant if you are
+   implementing your own `CallAdapter`s.
+ * Remove explicit handling of the now-defunct RoboVM platform.
+ * Fix: Close response on HTTP 204 and 205 to avoid resource leak.
+ * Fix: Reflect the canceled state of the HTTP client's `Call` in Retrofit's `Call`.
+ * Fix: Use supplied string converters for the `String` type on non-body parameters. This allows user
+   converters to handle cases such as when annotating string parameters instead of them always using
+   the raw string.
+ * Fix: Skip a UTF-8 BOM (if present) when using the converter for Moshi.
+
+
+Version 2.1.0 *(2016-06-15)*
+----------------------------
+
+ * New: `@HeaderMap` annotation and support for supplying an arbitrary number of headers to an endpoint.
+ * New: `@JsonAdapter` annotations on the `@Body` parameter and on the method will be propagated to Moshi
+   for creating the request and response adapters, respectively.
+ * Fix: Honor the `Content-Type` encoding of XML responses when deserializing response bodies.
+ * Fix: Remove the stacktrace from fake network exceptions created from retrofit-mock's `NetworkBehavior`.
+   They had the potential to be misleading and look like a library issue.
+ * Fix: Eagerly catch malformed `Content-Type` headers supplied via `@Header` or `@Headers`.
+
+
+Version 2.0.2 *(2016-04-14)*
+----------------------------
+
+ * New: `ProtoConverterFactory.createWithRegistry()` method accepts an extension registry to be used
+   when deserializing protos.
+ * Fix: Pass the correct `Call` instance to `Callback`'s `onResponse` and `onFailure` methods such
+   that calling `clone()` retains the correct threading behavior.
+ * Fix: Reduce the per-request allocation overhead for the RxJava call adapter.
+
+
 Version 2.0.1 *(2016-03-30)*
 ----------------------------
 
@@ -405,3 +482,6 @@ Version 1.0.0 *(2013-05-13)*
 ----------------------------
 
 Initial release.
+
+
+ [maven_provided]: https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html
diff --git a/README.md b/README.md
index 0113f440b..8597709be 100644
--- a/README.md
+++ b/README.md
@@ -5,7 +5,7 @@ A extension for retrofit2
 Feature
 --------
 
-1、Rebase to lastest version of retrofit2(now is retrofit-2.0.1),support all feature of retrofit2.
+1、Rebase to lastest version of retrofit2(now is retrofit-2.3.0),support all feature of retrofit2.
 
 2、@HTTPS Annotation：config which service use https.
 
@@ -100,7 +100,7 @@ repositories {
     }
 }
 dependencies {
-	compile 'com.github.MasonLiuChn:RetrofitPlus:2.0.1.0'
+	compile 'com.github.MasonLiuChn:RetrofitPlus:2.3.0.0'
 	compile('com.squareup.retrofit2:converter-gson:2.0.0') {
         	//exclude module: 'retrofit' 如果不写 group 则生成 pom 不会 add exclusion
         	exclude group: 'com.squareup.retrofit2', module: 'retrofit'
@@ -115,7 +115,19 @@ Usage of retrofit2.0：https://realm.io/cn/news/droidcon-jake-wharton-simple-htt
 
 - Blog:http://blog.csdn.net/masonblog
 
+<<<<<<< HEAD
 - Email:MasonLiuChn@gmail.com
+=======
+ProGuard
+--------
+
+If you are using ProGuard you might need to add the following options:
+```
+-dontwarn okio.**
+-dontwarn javax.annotation.**
+```
+
+>>>>>>> upstream/master
 
 License
 =======
@@ -133,3 +145,11 @@ License
     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     See the License for the specific language governing permissions and
     limitations under the License.
+<<<<<<< HEAD
+=======
+
+
+ [1]: http://square.github.io/retrofit/
+ [2]: https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=retrofit&v=LATEST
+ [snap]: https://oss.sonatype.org/content/repositories/snapshots/
+>>>>>>> upstream/master
diff --git a/checkstyle.xml b/checkstyle.xml
index a729c26a7..4721a2fdc 100644
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -1,7 +1,7 @@
 <?xml version="1.0"?>
 <!DOCTYPE module PUBLIC
-    "-//Puppy Crawl//DTD Check Configuration 1.2//EN"
-    "http://www.puppycrawl.com/dtds/configuration_1_2.dtd">
+    "-//Puppy Crawl//DTD Check Configuration 1.3//EN"
+    "http://www.puppycrawl.com/dtds/configuration_1_3.dtd">
 
 <module name="Checker">
     <module name="NewlineAtEndOfFile">
@@ -102,7 +102,6 @@
         <!--module name="InnerAssignment"/-->
         <!--module name="MagicNumber"/-->
         <module name="MissingSwitchDefault"/>
-        <module name="RedundantThrows"/>
         <module name="SimplifyBooleanExpression"/>
         <module name="SimplifyBooleanReturn"/>
 
@@ -123,6 +122,7 @@
         <module name="UpperEll"/>
         <module name="Indentation">
           <property name="basicOffset" value="2"/>
+          <property name="caseIndent" value="2"/>
         </module>
     </module>
 </module>
diff --git a/pom.xml b/pom.xml
index 8055ebe8c..2989d3d4e 100644
--- a/pom.xml
+++ b/pom.xml
@@ -25,7 +25,7 @@
 
   <groupId>com.squareup.retrofit2</groupId>
   <artifactId>parent</artifactId>
-  <version>2.0.1</version>
+  <version>2.4.0-SNAPSHOT</version>
   <packaging>pom</packaging>
 
   <name>Retrofit (Parent)</name>
@@ -49,19 +49,21 @@
 
     <!-- Dependencies -->
     <android.version>4.1.1.4</android.version>
-    <okhttp.version>3.2.0</okhttp.version>
+    <okhttp.version>3.8.0</okhttp.version>
     <animal.sniffer.version>1.14</animal.sniffer.version>
 
     <!-- Adapter Dependencies -->
-    <rxjava.version>1.1.1</rxjava.version>
+    <rxjava.version>1.3.0</rxjava.version>
+    <rxjava2.version>2.0.0</rxjava2.version>
+    <guava.version>19.0</guava.version>
 
     <!-- Converter Dependencies -->
-    <gson.version>2.6.1</gson.version>
-    <protobuf.version>2.6.1</protobuf.version>
+    <gson.version>2.7</gson.version>
+    <protobuf.version>3.0.0</protobuf.version>
     <jackson.version>2.7.2</jackson.version>
-    <wire.version>2.1.1</wire.version>
+    <wire.version>2.2.0</wire.version>
     <simplexml.version>2.7.1</simplexml.version>
-    <moshi.version>1.1.0</moshi.version>
+    <moshi.version>1.4.0</moshi.version>
 
     <!-- Sample Dependencies -->
     <jsoup.version>1.7.3</jsoup.version>
@@ -70,7 +72,6 @@
     <junit.version>4.12</junit.version>
     <assertj.version>1.7.0</assertj.version>
     <mockito.version>1.9.5</mockito.version>
-    <guava.version>19.0</guava.version>
     <robolectric.version>3.0</robolectric.version>
   </properties>
 
@@ -78,7 +79,7 @@
     <url>http://github.com/square/retrofit</url>
     <connection>scm:git:git://github.com/square/retrofit.git</connection>
     <developerConnection>scm:git:ssh://git@github.com/square/retrofit.git</developerConnection>
-    <tag>parent-2.0.1</tag>
+    <tag>HEAD</tag>
   </scm>
 
   <issueManagement>
@@ -125,7 +126,11 @@
         <artifactId>rxjava</artifactId>
         <version>${rxjava.version}</version>
       </dependency>
-
+      <dependency>
+        <groupId>io.reactivex.rxjava2</groupId>
+        <artifactId>rxjava</artifactId>
+        <version>${rxjava2.version}</version>
+      </dependency>
       <dependency>
         <groupId>com.google.protobuf</groupId>
         <artifactId>protobuf-java</artifactId>
@@ -151,7 +156,11 @@
         <artifactId>moshi</artifactId>
         <version>${moshi.version}</version>
       </dependency>
-
+      <dependency>
+        <groupId>com.google.code.findbugs</groupId>
+        <artifactId>jsr305</artifactId>
+        <version>3.0.2</version>
+      </dependency>
       <dependency>
         <groupId>junit</groupId>
         <artifactId>junit</artifactId>
@@ -191,11 +200,25 @@
         <plugin>
           <groupId>org.apache.maven.plugins</groupId>
           <artifactId>maven-compiler-plugin</artifactId>
-          <version>3.0</version>
+          <version>3.6.1</version>
           <configuration>
+            <compilerId>javac-with-errorprone</compilerId>
+            <forceJavacCompilerUse>true</forceJavacCompilerUse>
             <source>${java.version}</source>
             <target>${java.version}</target>
           </configuration>
+          <dependencies>
+            <dependency>
+              <groupId>org.codehaus.plexus</groupId>
+              <artifactId>plexus-compiler-javac-errorprone</artifactId>
+              <version>2.8.1</version>
+            </dependency>
+            <dependency>
+              <groupId>com.google.errorprone</groupId>
+              <artifactId>error_prone_core</artifactId>
+              <version>2.0.16</version>
+            </dependency>
+          </dependencies>
         </plugin>
       </plugins>
     </pluginManagement>
@@ -213,7 +236,14 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-checkstyle-plugin</artifactId>
-        <version>2.15</version>
+        <version>2.17</version>
+        <dependencies>
+          <dependency>
+            <groupId>com.puppycrawl.tools</groupId>
+            <artifactId>checkstyle</artifactId>
+            <version>7.7</version>
+          </dependency>
+        </dependencies>
         <configuration>
           <failsOnError>true</failsOnError>
           <configLocation>checkstyle.xml</configLocation>
diff --git a/retrofit-adapters/README.md b/retrofit-adapters/README.md
index 7ef38b3ff..34e18813b 100644
--- a/retrofit-adapters/README.md
+++ b/retrofit-adapters/README.md
@@ -4,7 +4,7 @@ Retrofit Adapters
 Retrofit ships with a default adapter for executing `Call` instances. The child modules contained
 herein are additional adapters for other popular execution mechanisms.
 
-To use, supply an instance of your desired converter when building your `Retrofit` instance.
+To use, supply an instance of your desired adapter when building your `Retrofit` instance.
 
 ```java
 Retrofit retrofit = new Retrofit.Builder()
diff --git a/retrofit-adapters/guava/README.md b/retrofit-adapters/guava/README.md
new file mode 100644
index 000000000..b1449e80e
--- /dev/null
+++ b/retrofit-adapters/guava/README.md
@@ -0,0 +1,50 @@
+Guava Adapter
+==============
+
+An `Adapter` for adapting [Guava][1] `ListenableFuture`.
+
+
+Usage
+-----
+
+Add `GuavaCallAdapterFactory` as a `Call` adapter when building your `Retrofit` instance:
+```java
+Retrofit retrofit = new Retrofit.Builder()
+    .baseUrl("https://example.com/")
+    .addCallAdapterFactory(GuavaCallAdapterFactory.create())
+    .build();
+```
+
+Your service methods can now use `ListenableFuture` as their return type.
+```java
+interface MyService {
+  @GET("/user")
+  ListenableFuture<User> getUser();
+}
+```
+
+
+Download
+--------
+
+Download [the latest JAR][2] or grab via [Maven][3]:
+```xml
+<dependency>
+  <groupId>com.squareup.retrofit2</groupId>
+  <artifactId>adapter-guava</artifactId>
+  <version>latest.version</version>
+</dependency>
+```
+or [Gradle][3]:
+```groovy
+compile 'com.squareup.retrofit2:adapter-guava:latest.version'
+```
+
+Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
+
+
+
+ [1]: https://github.com/google/guava
+ [2]: https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=adapter-guava&v=LATEST
+ [3]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup.retrofit2%22%20a%3A%22adapter-guava%22
+ [snap]: https://oss.sonatype.org/content/repositories/snapshots/
diff --git a/retrofit-adapters/guava/pom.xml b/retrofit-adapters/guava/pom.xml
index fc56847d7..b5dbb1f5f 100644
--- a/retrofit-adapters/guava/pom.xml
+++ b/retrofit-adapters/guava/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-adapters</artifactId>
-    <version>2.0.1</version>
+    <version>2.4.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -23,6 +23,11 @@
       <groupId>com.google.guava</groupId>
       <artifactId>guava</artifactId>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
diff --git a/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/GuavaCallAdapterFactory.java b/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/GuavaCallAdapterFactory.java
index 301c91254..64dd0f5ad 100644
--- a/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/GuavaCallAdapterFactory.java
+++ b/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/GuavaCallAdapterFactory.java
@@ -17,6 +17,7 @@
 
 import com.google.common.util.concurrent.AbstractFuture;
 import com.google.common.util.concurrent.ListenableFuture;
+import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
@@ -26,6 +27,27 @@
 import retrofit2.Response;
 import retrofit2.Retrofit;
 
+/**
+ * A {@linkplain CallAdapter.Factory call adapter} which creates Guava futures.
+ * <p>
+ * Adding this class to {@link Retrofit} allows you to return {@link ListenableFuture} from service
+ * methods.
+ * <pre><code>
+ * interface MyService {
+ *   &#64;GET("user/me")
+ *   ListenableFuture&lt;User&gt; getUser()
+ * }
+ * </code></pre>
+ * There are two configurations supported for the {@code ListenableFuture} type parameter:
+ * <ul>
+ * <li>Direct body (e.g., {@code ListenableFuture<User>}) returns the deserialized body for 2XX
+ * responses, sets {@link retrofit2.HttpException HttpException} errors for non-2XX responses, and
+ * sets {@link IOException} for network errors.</li>
+ * <li>Response wrapped body (e.g., {@code ListenableFuture<Response<User>>}) returns a
+ * {@link Response} object for all HTTP responses and sets {@link IOException} for network
+ * errors</li>
+ * </ul>
+ */
 public final class GuavaCallAdapterFactory extends CallAdapter.Factory {
   public static GuavaCallAdapterFactory create() {
     return new GuavaCallAdapterFactory();
@@ -35,7 +57,7 @@ private GuavaCallAdapterFactory() {
   }
 
   @Override
-  public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+  public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
     if (getRawType(returnType) != ListenableFuture.class) {
       return null;
     }
@@ -47,7 +69,7 @@ private GuavaCallAdapterFactory() {
 
     if (getRawType(innerType) != Response.class) {
       // Generic type is not Response<T>. Use it for body-only adapter.
-      return new BodyCallAdapter(innerType);
+      return new BodyCallAdapter<>(innerType);
     }
 
     // Generic type is Response<T>. Extract T and create the Response version of the adapter.
@@ -56,10 +78,10 @@ private GuavaCallAdapterFactory() {
           + " as Response<Foo> or Response<? extends Foo>");
     }
     Type responseType = getParameterUpperBound(0, (ParameterizedType) innerType);
-    return new ResponseCallAdapter(responseType);
+    return new ResponseCallAdapter<>(responseType);
   }
 
-  private static class BodyCallAdapter implements CallAdapter<ListenableFuture<?>> {
+  private static final class BodyCallAdapter<R> implements CallAdapter<R, ListenableFuture<R>> {
     private final Type responseType;
 
     BodyCallAdapter(Type responseType) {
@@ -70,7 +92,7 @@ private GuavaCallAdapterFactory() {
       return responseType;
     }
 
-    @Override public <R> ListenableFuture<R> adapt(final Call<R> call) {
+    @Override public ListenableFuture<R> adapt(final Call<R> call) {
       return new AbstractFuture<R>() {
         {
           call.enqueue(new Callback<R>() {
@@ -95,7 +117,8 @@ private GuavaCallAdapterFactory() {
     }
   }
 
-  private static class ResponseCallAdapter implements CallAdapter<ListenableFuture<?>> {
+  private static final class ResponseCallAdapter<R>
+      implements CallAdapter<R, ListenableFuture<Response<R>>> {
     private final Type responseType;
 
     ResponseCallAdapter(Type responseType) {
@@ -106,7 +129,7 @@ private GuavaCallAdapterFactory() {
       return responseType;
     }
 
-    @Override public <R> ListenableFuture<Response<R>> adapt(final Call<R> call) {
+    @Override public ListenableFuture<Response<R>> adapt(final Call<R> call) {
       return new AbstractFuture<Response<R>>() {
         {
           call.enqueue(new Callback<R>() {
diff --git a/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/HttpException.java b/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/HttpException.java
index f18a81955..4eb780eaa 100644
--- a/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/HttpException.java
+++ b/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/HttpException.java
@@ -17,33 +17,10 @@
 
 import retrofit2.Response;
 
-/** Exception for an unexpected, non-2xx HTTP response. */
-public final class HttpException extends Exception {
-  private final int code;
-  private final String message;
-  private final transient Response<?> response;
-
+/** @deprecated Use {@link retrofit2.HttpException}. */
+@Deprecated
+public final class HttpException extends retrofit2.HttpException {
   public HttpException(Response<?> response) {
-    super("HTTP " + response.code() + " " + response.message());
-    this.code = response.code();
-    this.message = response.message();
-    this.response = response;
-  }
-
-  /** HTTP status code. */
-  public int code() {
-    return code;
-  }
-
-  /** HTTP status message. */
-  public String message() {
-    return message;
-  }
-
-  /**
-   * The full HTTP response. This may be null if the exception was serialized.
-   */
-  public Response<?> response() {
-    return response;
+    super(response);
   }
 }
diff --git a/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/package-info.java b/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/package-info.java
new file mode 100644
index 000000000..7943d1191
--- /dev/null
+++ b/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/package-info.java
@@ -0,0 +1,4 @@
+@ParametersAreNonnullByDefault
+package retrofit2.adapter.guava;
+
+import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/GuavaCallAdapterFactoryTest.java b/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/GuavaCallAdapterFactoryTest.java
index 62d449eb9..c8abdf1c2 100644
--- a/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/GuavaCallAdapterFactoryTest.java
+++ b/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/GuavaCallAdapterFactoryTest.java
@@ -72,7 +72,7 @@
   }
 
   @Test public void nonListenableFutureReturnsNull() {
-    CallAdapter<?> adapter = factory.get(String.class, NO_ANNOTATIONS, retrofit);
+    CallAdapter<?, ?> adapter = factory.get(String.class, NO_ANNOTATIONS, retrofit);
     assertThat(adapter).isNull();
   }
 
diff --git a/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/ListenableFutureTest.java b/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/ListenableFutureTest.java
index fb3ccb3da..f3ceeca62 100644
--- a/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/ListenableFutureTest.java
+++ b/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/ListenableFutureTest.java
@@ -65,7 +65,9 @@
       future.get();
       fail();
     } catch (ExecutionException e) {
-      assertThat(e.getCause()).isInstanceOf(HttpException.class)
+      assertThat(e.getCause())
+          .isInstanceOf(HttpException.class) // Required for backwards compatibility.
+          .isInstanceOf(retrofit2.HttpException.class)
           .hasMessage("HTTP 404 Client Error");
     }
   }
diff --git a/retrofit-adapters/java8/README.md b/retrofit-adapters/java8/README.md
new file mode 100644
index 000000000..83424c809
--- /dev/null
+++ b/retrofit-adapters/java8/README.md
@@ -0,0 +1,50 @@
+Java8 Adapter
+==============
+
+An `Adapter` for adapting [Java8][1] `CompletableFuture`.
+
+
+Usage
+-----
+
+Add `Java8CallAdapterFactory` as a `Call` adapter when building your `Retrofit` instance:
+```java
+Retrofit retrofit = new Retrofit.Builder()
+    .baseUrl("https://example.com/")
+    .addCallAdapterFactory(Java8CallAdapterFactory.create())
+    .build();
+```
+
+Your service methods can now use `CompletableFuture` as their return type.
+```java
+interface MyService {
+  @GET("/user")
+  CompletableFuture<User> getUser();
+}
+```
+
+
+Download
+--------
+
+Download [the latest JAR][2] or grab via [Maven][3]:
+```xml
+<dependency>
+  <groupId>com.squareup.retrofit2</groupId>
+  <artifactId>adapter-java8</artifactId>
+  <version>latest.version</version>
+</dependency>
+```
+or [Gradle][3]:
+```groovy
+compile 'com.squareup.retrofit2:adapter-java8:latest.version'
+```
+
+Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
+
+
+
+ [1]: http://www.oracle.com/technetwork/java/javase/jdk-8-readme-2095712.html
+ [2]: https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=adapter-java8&v=LATEST
+ [3]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup.retrofit2%22%20a%3A%22adapter-java8%22
+ [snap]: https://oss.sonatype.org/content/repositories/snapshots/
diff --git a/retrofit-adapters/java8/pom.xml b/retrofit-adapters/java8/pom.xml
index 9ff281818..4bcdd6727 100644
--- a/retrofit-adapters/java8/pom.xml
+++ b/retrofit-adapters/java8/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-adapters</artifactId>
-    <version>2.0.1</version>
+    <version>2.4.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -23,6 +23,11 @@
       <artifactId>retrofit</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
diff --git a/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/HttpException.java b/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/HttpException.java
index 022fa9848..c2d29cbbb 100644
--- a/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/HttpException.java
+++ b/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/HttpException.java
@@ -17,33 +17,10 @@
 
 import retrofit2.Response;
 
-/** Exception for an unexpected, non-2xx HTTP response. */
-public final class HttpException extends Exception {
-  private final int code;
-  private final String message;
-  private final transient Response<?> response;
-
+/** @deprecated Use {@link retrofit2.HttpException}. */
+@Deprecated
+public final class HttpException extends retrofit2.HttpException {
   public HttpException(Response<?> response) {
-    super("HTTP " + response.code() + " " + response.message());
-    this.code = response.code();
-    this.message = response.message();
-    this.response = response;
-  }
-
-  /** HTTP status code. */
-  public int code() {
-    return code;
-  }
-
-  /** HTTP status message. */
-  public String message() {
-    return message;
-  }
-
-  /**
-   * The full HTTP response. This may be null if the exception was serialized.
-   */
-  public Response<?> response() {
-    return response;
+    super(response);
   }
 }
diff --git a/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/Java8CallAdapterFactory.java b/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/Java8CallAdapterFactory.java
index d8a87c73c..35b79f1a3 100644
--- a/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/Java8CallAdapterFactory.java
+++ b/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/Java8CallAdapterFactory.java
@@ -15,6 +15,7 @@
  */
 package retrofit2.adapter.java8;
 
+import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
@@ -25,6 +26,27 @@
 import retrofit2.Response;
 import retrofit2.Retrofit;
 
+/**
+ * A {@linkplain CallAdapter.Factory call adapter} which creates Java 8 futures.
+ * <p>
+ * Adding this class to {@link Retrofit} allows you to return {@link CompletableFuture} from
+ * service methods.
+ * <pre><code>
+ * interface MyService {
+ *   &#64;GET("user/me")
+ *   CompletableFuture&lt;User&gt; getUser()
+ * }
+ * </code></pre>
+ * There are two configurations supported for the {@code CompletableFuture} type parameter:
+ * <ul>
+ * <li>Direct body (e.g., {@code CompletableFuture<User>}) returns the deserialized body for 2XX
+ * responses, sets {@link retrofit2.HttpException HttpException} errors for non-2XX responses, and
+ * sets {@link IOException} for network errors.</li>
+ * <li>Response wrapped body (e.g., {@code CompletableFuture<Response<User>>}) returns a
+ * {@link Response} object for all HTTP responses and sets {@link IOException} for network
+ * errors</li>
+ * </ul>
+ */
 public final class Java8CallAdapterFactory extends CallAdapter.Factory {
   public static Java8CallAdapterFactory create() {
     return new Java8CallAdapterFactory();
@@ -34,7 +56,7 @@ private Java8CallAdapterFactory() {
   }
 
   @Override
-  public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+  public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
     if (getRawType(returnType) != CompletableFuture.class) {
       return null;
     }
@@ -46,7 +68,7 @@ private Java8CallAdapterFactory() {
 
     if (getRawType(innerType) != Response.class) {
       // Generic type is not Response<T>. Use it for body-only adapter.
-      return new BodyCallAdapter(innerType);
+      return new BodyCallAdapter<>(innerType);
     }
 
     // Generic type is Response<T>. Extract T and create the Response version of the adapter.
@@ -55,10 +77,10 @@ private Java8CallAdapterFactory() {
           + " as Response<Foo> or Response<? extends Foo>");
     }
     Type responseType = getParameterUpperBound(0, (ParameterizedType) innerType);
-    return new ResponseCallAdapter(responseType);
+    return new ResponseCallAdapter<>(responseType);
   }
 
-  private static class BodyCallAdapter implements CallAdapter<CompletableFuture<?>> {
+  private static final class BodyCallAdapter<R> implements CallAdapter<R, CompletableFuture<R>> {
     private final Type responseType;
 
     BodyCallAdapter(Type responseType) {
@@ -69,7 +91,7 @@ private Java8CallAdapterFactory() {
       return responseType;
     }
 
-    @Override public <R> CompletableFuture<R> adapt(final Call<R> call) {
+    @Override public CompletableFuture<R> adapt(final Call<R> call) {
       final CompletableFuture<R> future = new CompletableFuture<R>() {
         @Override public boolean cancel(boolean mayInterruptIfRunning) {
           if (mayInterruptIfRunning) {
@@ -97,7 +119,8 @@ private Java8CallAdapterFactory() {
     }
   }
 
-  private static class ResponseCallAdapter implements CallAdapter<CompletableFuture<?>> {
+  private static final class ResponseCallAdapter<R>
+      implements CallAdapter<R, CompletableFuture<Response<R>>> {
     private final Type responseType;
 
     ResponseCallAdapter(Type responseType) {
@@ -108,7 +131,7 @@ private Java8CallAdapterFactory() {
       return responseType;
     }
 
-    @Override public <R> CompletableFuture<Response<R>> adapt(final Call<R> call) {
+    @Override public CompletableFuture<Response<R>> adapt(final Call<R> call) {
       final CompletableFuture<Response<R>> future = new CompletableFuture<Response<R>>() {
         @Override public boolean cancel(boolean mayInterruptIfRunning) {
           if (mayInterruptIfRunning) {
diff --git a/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/package-info.java b/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/package-info.java
new file mode 100644
index 000000000..7e36b199e
--- /dev/null
+++ b/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/package-info.java
@@ -0,0 +1,4 @@
+@ParametersAreNonnullByDefault
+package retrofit2.adapter.java8;
+
+import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/CompletableFutureTest.java b/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/CompletableFutureTest.java
index d4a00a1dc..ee06a31eb 100644
--- a/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/CompletableFutureTest.java
+++ b/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/CompletableFutureTest.java
@@ -65,7 +65,9 @@
       future.get();
       fail();
     } catch (ExecutionException e) {
-      assertThat(e.getCause()).isInstanceOf(HttpException.class)
+      assertThat(e.getCause())
+          .isInstanceOf(HttpException.class) // Required for backwards compatibility.
+          .isInstanceOf(retrofit2.HttpException.class)
           .hasMessage("HTTP 404 Client Error");
     }
   }
diff --git a/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/Java8CallAdapterFactoryTest.java b/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/Java8CallAdapterFactoryTest.java
index 89d2b9537..283268881 100644
--- a/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/Java8CallAdapterFactoryTest.java
+++ b/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/Java8CallAdapterFactoryTest.java
@@ -72,7 +72,7 @@
   }
 
   @Test public void nonListenableFutureReturnsNull() {
-    CallAdapter<?> adapter = factory.get(String.class, NO_ANNOTATIONS, retrofit);
+    CallAdapter<?, ?> adapter = factory.get(String.class, NO_ANNOTATIONS, retrofit);
     assertThat(adapter).isNull();
   }
 
diff --git a/retrofit-adapters/pom.xml b/retrofit-adapters/pom.xml
index 44f6f4f13..9c55ab105 100644
--- a/retrofit-adapters/pom.xml
+++ b/retrofit-adapters/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>parent</artifactId>
-    <version>2.0.1</version>
+    <version>2.4.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -18,5 +18,6 @@
     <module>guava</module>
     <module>java8</module>
     <module>rxjava</module>
+    <module>rxjava2</module>
   </modules>
 </project>
diff --git a/retrofit-adapters/rxjava/README.md b/retrofit-adapters/rxjava/README.md
new file mode 100644
index 000000000..3352daf8f
--- /dev/null
+++ b/retrofit-adapters/rxjava/README.md
@@ -0,0 +1,63 @@
+RxJava Adapter
+==============
+
+An `Adapter` for adapting [RxJava 1.x][1] types.
+
+Available types:
+
+ * `Observable<T>`, `Observable<Response<T>>`, and `Observable<Result<T>>` where `T` is the body type.
+ * `Single<T>`, `Single<Response<T>>`, and `Single<Result<T>>`  where `T` is the body type.
+ * `Completable` where response bodies are discarded.
+
+
+Usage
+-----
+
+Add `RxJavaCallAdapterFactory` as a `Call` adapter when building your `Retrofit` instance:
+```java
+Retrofit retrofit = new Retrofit.Builder()
+    .baseUrl("https://example.com/")
+    .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
+    .build();
+```
+
+Your service methods can now use any of the above types as their return type.
+```java
+interface MyService {
+  @GET("/user")
+  Observable<User> getUser();
+}
+```
+
+By default all reactive types execute their requests synchronously. There are multiple ways to
+control the threading on which a request occurs:
+
+ * Call `subscribeOn` on the returned reactive type with a `Scheduler` of your choice.
+ * Use `createAsync()` when creating the factory which will use OkHttp's internal thread pool.
+ * Use `createWithScheduler(Scheduler)` to supply a default subscription `Scheduler`.
+
+
+Download
+--------
+
+Download [the latest JAR][2] or grab via [Maven][3]:
+```xml
+<dependency>
+  <groupId>com.squareup.retrofit2</groupId>
+  <artifactId>adapter-rxjava</artifactId>
+  <version>latest.version</version>
+</dependency>
+```
+or [Gradle][3]:
+```groovy
+compile 'com.squareup.retrofit2:adapter-rxjava:latest.version'
+```
+
+Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
+
+
+
+ [1]: https://github.com/ReactiveX/RxJava/tree/1.x
+ [2]: https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=adapter-rxjava&v=LATEST
+ [3]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup.retrofit2%22%20a%3A%22adapter-rxjava%22
+ [snap]: https://oss.sonatype.org/content/repositories/snapshots/
diff --git a/retrofit-adapters/rxjava/pom.xml b/retrofit-adapters/rxjava/pom.xml
index b3b7fa373..4f010a453 100644
--- a/retrofit-adapters/rxjava/pom.xml
+++ b/retrofit-adapters/rxjava/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-adapters</artifactId>
-    <version>2.0.1</version>
+    <version>2.4.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -23,6 +23,11 @@
       <groupId>io.reactivex</groupId>
       <artifactId>rxjava</artifactId>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/BodyOnSubscribe.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/BodyOnSubscribe.java
new file mode 100644
index 000000000..d91105734
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/BodyOnSubscribe.java
@@ -0,0 +1,88 @@
+/*
+ * Copyright (C) 2016 Jake Wharton
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import retrofit2.Response;
+import rx.Observable.OnSubscribe;
+import rx.Subscriber;
+import rx.exceptions.CompositeException;
+import rx.exceptions.Exceptions;
+import rx.exceptions.OnCompletedFailedException;
+import rx.exceptions.OnErrorFailedException;
+import rx.exceptions.OnErrorNotImplementedException;
+import rx.plugins.RxJavaPlugins;
+
+final class BodyOnSubscribe<T> implements OnSubscribe<T> {
+  private final OnSubscribe<Response<T>> upstream;
+
+  BodyOnSubscribe(OnSubscribe<Response<T>> upstream) {
+    this.upstream = upstream;
+  }
+
+  @Override public void call(Subscriber<? super T> subscriber) {
+    upstream.call(new BodySubscriber<T>(subscriber));
+  }
+
+  private static class BodySubscriber<R> extends Subscriber<Response<R>> {
+    private final Subscriber<? super R> subscriber;
+    /** Indicates whether a terminal event has been sent to {@link #subscriber}. */
+    private boolean subscriberTerminated;
+
+    BodySubscriber(Subscriber<? super R> subscriber) {
+      super(subscriber);
+      this.subscriber = subscriber;
+    }
+
+    @Override public void onNext(Response<R> response) {
+      if (response.isSuccessful()) {
+        subscriber.onNext(response.body());
+      } else {
+        subscriberTerminated = true;
+        Throwable t = new HttpException(response);
+        try {
+          subscriber.onError(t);
+        } catch (OnCompletedFailedException
+            | OnErrorFailedException
+            | OnErrorNotImplementedException e) {
+          RxJavaPlugins.getInstance().getErrorHandler().handleError(e);
+        } catch (Throwable inner) {
+          Exceptions.throwIfFatal(inner);
+          CompositeException composite = new CompositeException(t, inner);
+          RxJavaPlugins.getInstance().getErrorHandler().handleError(composite);
+        }
+      }
+    }
+
+    @Override public void onError(Throwable throwable) {
+      if (!subscriberTerminated) {
+        subscriber.onError(throwable);
+      } else {
+        // This should never happen! onNext handles and forwards errors automatically.
+        Throwable broken = new AssertionError(
+            "This should never happen! Report as a Retrofit bug with the full stacktrace.");
+        //noinspection UnnecessaryInitCause Two-arg AssertionError constructor is 1.7+ only.
+        broken.initCause(throwable);
+        RxJavaPlugins.getInstance().getErrorHandler().handleError(broken);
+      }
+    }
+
+    @Override public void onCompleted() {
+      if (!subscriberTerminated) {
+        subscriber.onCompleted();
+      }
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/CallArbiter.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/CallArbiter.java
new file mode 100644
index 000000000..4162ecfab
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/CallArbiter.java
@@ -0,0 +1,171 @@
+/*
+ * Copyright (C) 2016 Jake Wharton
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import java.util.concurrent.atomic.AtomicInteger;
+import retrofit2.Call;
+import retrofit2.Response;
+import rx.Producer;
+import rx.Subscriber;
+import rx.Subscription;
+import rx.exceptions.CompositeException;
+import rx.exceptions.Exceptions;
+import rx.exceptions.OnCompletedFailedException;
+import rx.exceptions.OnErrorFailedException;
+import rx.exceptions.OnErrorNotImplementedException;
+import rx.plugins.RxJavaPlugins;
+
+final class CallArbiter<T> extends AtomicInteger implements Subscription, Producer {
+  private static final int STATE_WAITING = 0;
+  private static final int STATE_REQUESTED = 1;
+  private static final int STATE_HAS_RESPONSE = 2;
+  private static final int STATE_TERMINATED = 3;
+
+  private final Call<T> call;
+  private final Subscriber<? super Response<T>> subscriber;
+
+  private volatile Response<T> response;
+
+  CallArbiter(Call<T> call, Subscriber<? super Response<T>> subscriber) {
+    super(STATE_WAITING);
+
+    this.call = call;
+    this.subscriber = subscriber;
+  }
+
+  @Override public void unsubscribe() {
+    call.cancel();
+  }
+
+  @Override public boolean isUnsubscribed() {
+    return call.isCanceled();
+  }
+
+  @Override public void request(long amount) {
+    if (amount == 0) {
+      return;
+    }
+    while (true) {
+      int state = get();
+      switch (state) {
+        case STATE_WAITING:
+          if (compareAndSet(STATE_WAITING, STATE_REQUESTED)) {
+            return;
+          }
+          break; // State transition failed. Try again.
+
+        case STATE_HAS_RESPONSE:
+          if (compareAndSet(STATE_HAS_RESPONSE, STATE_TERMINATED)) {
+            deliverResponse(response);
+            return;
+          }
+          break; // State transition failed. Try again.
+
+        case STATE_REQUESTED:
+        case STATE_TERMINATED:
+          return; // Nothing to do.
+
+        default:
+          throw new IllegalStateException("Unknown state: " + state);
+      }
+    }
+  }
+
+  void emitResponse(Response<T> response) {
+    while (true) {
+      int state = get();
+      switch (state) {
+        case STATE_WAITING:
+          this.response = response;
+          if (compareAndSet(STATE_WAITING, STATE_HAS_RESPONSE)) {
+            return;
+          }
+          break; // State transition failed. Try again.
+
+        case STATE_REQUESTED:
+          if (compareAndSet(STATE_REQUESTED, STATE_TERMINATED)) {
+            deliverResponse(response);
+            return;
+          }
+          break; // State transition failed. Try again.
+
+        case STATE_HAS_RESPONSE:
+        case STATE_TERMINATED:
+          throw new AssertionError();
+
+        default:
+          throw new IllegalStateException("Unknown state: " + state);
+      }
+    }
+  }
+
+  private void deliverResponse(Response<T> response) {
+    try {
+      if (!isUnsubscribed()) {
+        subscriber.onNext(response);
+      }
+    } catch (OnCompletedFailedException
+        | OnErrorFailedException
+        | OnErrorNotImplementedException e) {
+      RxJavaPlugins.getInstance().getErrorHandler().handleError(e);
+      return;
+    } catch (Throwable t) {
+      Exceptions.throwIfFatal(t);
+      try {
+        subscriber.onError(t);
+      } catch (OnCompletedFailedException
+          | OnErrorFailedException
+          | OnErrorNotImplementedException e) {
+        RxJavaPlugins.getInstance().getErrorHandler().handleError(e);
+      } catch (Throwable inner) {
+        Exceptions.throwIfFatal(inner);
+        CompositeException composite = new CompositeException(t, inner);
+        RxJavaPlugins.getInstance().getErrorHandler().handleError(composite);
+      }
+      return;
+    }
+    try {
+      if (!isUnsubscribed()) {
+        subscriber.onCompleted();
+      }
+    } catch (OnCompletedFailedException
+        | OnErrorFailedException
+        | OnErrorNotImplementedException e) {
+      RxJavaPlugins.getInstance().getErrorHandler().handleError(e);
+    } catch (Throwable t) {
+      Exceptions.throwIfFatal(t);
+      RxJavaPlugins.getInstance().getErrorHandler().handleError(t);
+    }
+  }
+
+  void emitError(Throwable t) {
+    set(STATE_TERMINATED);
+
+    if (!isUnsubscribed()) {
+      try {
+        subscriber.onError(t);
+      } catch (OnCompletedFailedException
+          | OnErrorFailedException
+          | OnErrorNotImplementedException e) {
+        RxJavaPlugins.getInstance().getErrorHandler().handleError(e);
+      } catch (Throwable inner) {
+        Exceptions.throwIfFatal(inner);
+        CompositeException composite = new CompositeException(t, inner);
+        RxJavaPlugins.getInstance().getErrorHandler().handleError(composite);
+      }
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/CallEnqueueOnSubscribe.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/CallEnqueueOnSubscribe.java
new file mode 100644
index 000000000..7dcf917c3
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/CallEnqueueOnSubscribe.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2016 Jake Wharton
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import retrofit2.Call;
+import retrofit2.Callback;
+import retrofit2.Response;
+import rx.Observable.OnSubscribe;
+import rx.Subscriber;
+import rx.exceptions.Exceptions;
+
+final class CallEnqueueOnSubscribe<T> implements OnSubscribe<Response<T>> {
+  private final Call<T> originalCall;
+
+  CallEnqueueOnSubscribe(Call<T> originalCall) {
+    this.originalCall = originalCall;
+  }
+
+  @Override public void call(Subscriber<? super Response<T>> subscriber) {
+    // Since Call is a one-shot type, clone it for each new subscriber.
+    Call<T> call = originalCall.clone();
+    final CallArbiter<T> arbiter = new CallArbiter<>(call, subscriber);
+    subscriber.add(arbiter);
+    subscriber.setProducer(arbiter);
+
+    call.enqueue(new Callback<T>() {
+      @Override public void onResponse(Call<T> call, Response<T> response) {
+        arbiter.emitResponse(response);
+      }
+
+      @Override public void onFailure(Call<T> call, Throwable t) {
+        Exceptions.throwIfFatal(t);
+        arbiter.emitError(t);
+      }
+    });
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/CallExecuteOnSubscribe.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/CallExecuteOnSubscribe.java
new file mode 100644
index 000000000..593770aa7
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/CallExecuteOnSubscribe.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2016 Jake Wharton
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import retrofit2.Call;
+import retrofit2.Response;
+import rx.Observable.OnSubscribe;
+import rx.Subscriber;
+import rx.exceptions.Exceptions;
+
+final class CallExecuteOnSubscribe<T> implements OnSubscribe<Response<T>> {
+  private final Call<T> originalCall;
+
+  CallExecuteOnSubscribe(Call<T> originalCall) {
+    this.originalCall = originalCall;
+  }
+
+  @Override public void call(Subscriber<? super Response<T>> subscriber) {
+    // Since Call is a one-shot type, clone it for each new subscriber.
+    Call<T> call = originalCall.clone();
+    CallArbiter<T> arbiter = new CallArbiter<>(call, subscriber);
+    subscriber.add(arbiter);
+    subscriber.setProducer(arbiter);
+
+    Response<T> response;
+    try {
+      response = call.execute();
+    } catch (Throwable t) {
+      Exceptions.throwIfFatal(t);
+      arbiter.emitError(t);
+      return;
+    }
+    arbiter.emitResponse(response);
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/CompletableHelper.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/CompletableHelper.java
deleted file mode 100644
index 78b668905..000000000
--- a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/CompletableHelper.java
+++ /dev/null
@@ -1,92 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2.adapter.rxjava;
-
-import java.lang.reflect.Type;
-import retrofit2.Call;
-import retrofit2.CallAdapter;
-import retrofit2.Response;
-import rx.Completable;
-import rx.Completable.CompletableOnSubscribe;
-import rx.Completable.CompletableSubscriber;
-import rx.Scheduler;
-import rx.Subscription;
-import rx.exceptions.Exceptions;
-import rx.functions.Action0;
-import rx.subscriptions.Subscriptions;
-
-final class CompletableHelper {
-  static CallAdapter<Completable> createCallAdapter(Scheduler scheduler) {
-    return new CompletableCallAdapter(scheduler);
-  }
-
-  private static final class CompletableCallOnSubscribe implements CompletableOnSubscribe {
-    private final Call originalCall;
-
-    CompletableCallOnSubscribe(Call originalCall) {
-      this.originalCall = originalCall;
-    }
-
-    @Override public void call(CompletableSubscriber subscriber) {
-      // Since Call is a one-shot type, clone it for each new subscriber.
-      final Call call = originalCall.clone();
-
-      // Attempt to cancel the call if it is still in-flight on unsubscription.
-      Subscription subscription = Subscriptions.create(new Action0() {
-        @Override public void call() {
-          call.cancel();
-        }
-      });
-      subscriber.onSubscribe(subscription);
-
-      try {
-        Response response = call.execute();
-        if (!subscription.isUnsubscribed()) {
-          if (response.isSuccessful()) {
-            subscriber.onCompleted();
-          } else {
-            subscriber.onError(new HttpException(response));
-          }
-        }
-      } catch (Throwable t) {
-        Exceptions.throwIfFatal(t);
-        if (!subscription.isUnsubscribed()) {
-          subscriber.onError(t);
-        }
-      }
-    }
-  }
-
-  static class CompletableCallAdapter implements CallAdapter<Completable> {
-    private final Scheduler scheduler;
-
-    CompletableCallAdapter(Scheduler scheduler) {
-      this.scheduler = scheduler;
-    }
-
-    @Override public Type responseType() {
-      return Void.class;
-    }
-
-    @Override public Completable adapt(Call call) {
-      Completable completable = Completable.create(new CompletableCallOnSubscribe(call));
-      if (scheduler != null) {
-        return completable.subscribeOn(scheduler);
-      }
-      return completable;
-    }
-  }
-}
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/HttpException.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/HttpException.java
index 7b5377ea5..c81ad938e 100644
--- a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/HttpException.java
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/HttpException.java
@@ -2,33 +2,10 @@
 
 import retrofit2.Response;
 
-/** Exception for an unexpected, non-2xx HTTP response. */
-public final class HttpException extends Exception {
-  private final int code;
-  private final String message;
-  private final transient Response<?> response;
-
+/** @deprecated Use {@link retrofit2.HttpException}. */
+@Deprecated
+public final class HttpException extends retrofit2.HttpException {
   public HttpException(Response<?> response) {
-    super("HTTP " + response.code() + " " + response.message());
-    this.code = response.code();
-    this.message = response.message();
-    this.response = response;
-  }
-
-  /** HTTP status code. */
-  public int code() {
-    return code;
-  }
-
-  /** HTTP status message. */
-  public String message() {
-    return message;
-  }
-
-  /**
-   * The full HTTP response. This may be null if the exception was serialized.
-   */
-  public Response<?> response() {
-    return response;
+    super(response);
   }
 }
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/OperatorMapResponseToBodyOrError.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/OperatorMapResponseToBodyOrError.java
deleted file mode 100644
index 321f463f9..000000000
--- a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/OperatorMapResponseToBodyOrError.java
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2.adapter.rxjava;
-
-import retrofit2.Response;
-import rx.Observable;
-import rx.Observable.Operator;
-import rx.Subscriber;
-import rx.functions.Func1;
-
-/**
- * A version of {@link Observable#map(Func1)} which lets us trigger {@code onError} without having
- * to use {@link Observable#flatMap(Func1)} which breaks producer requests from propagating.
- */
-final class OperatorMapResponseToBodyOrError<T> implements Operator<T, Response<T>> {
-  private static final OperatorMapResponseToBodyOrError<Object> INSTANCE =
-      new OperatorMapResponseToBodyOrError<>();
-
-  @SuppressWarnings("unchecked") // Safe because of erasure.
-  static <R> OperatorMapResponseToBodyOrError<R> instance() {
-    return (OperatorMapResponseToBodyOrError<R>) INSTANCE;
-  }
-
-  @Override public Subscriber<? super Response<T>> call(final Subscriber<? super T> child) {
-    return new Subscriber<Response<T>>(child) {
-      @Override public void onNext(Response<T> response) {
-        if (response.isSuccessful()) {
-          child.onNext(response.body());
-        } else {
-          child.onError(new HttpException(response));
-        }
-      }
-
-      @Override public void onCompleted() {
-        child.onCompleted();
-      }
-
-      @Override public void onError(Throwable e) {
-        child.onError(e);
-      }
-    };
-  }
-}
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/Result.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/Result.java
index 8d68e9e7f..29af1ff44 100644
--- a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/Result.java
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/Result.java
@@ -16,24 +16,27 @@
 package retrofit2.adapter.rxjava;
 
 import java.io.IOException;
+import javax.annotation.Nullable;
 import retrofit2.Response;
 
 /** The result of executing an HTTP request. */
 public final class Result<T> {
+  @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
   public static <T> Result<T> error(Throwable error) {
     if (error == null) throw new NullPointerException("error == null");
     return new Result<>(null, error);
   }
 
+  @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
   public static <T> Result<T> response(Response<T> response) {
     if (response == null) throw new NullPointerException("response == null");
     return new Result<>(response, null);
   }
 
-  private final Response<T> response;
-  private final Throwable error;
+  private final @Nullable Response<T> response;
+  private final @Nullable Throwable error;
 
-  private Result(Response<T> response, Throwable error) {
+  private Result(@Nullable Response<T> response, @Nullable Throwable error) {
     this.response = response;
     this.error = error;
   }
@@ -42,7 +45,7 @@ private Result(Response<T> response, Throwable error) {
    * The response received from executing an HTTP request. Only present when {@link #isError()} is
    * false, null otherwise.
    */
-  public Response<T> response() {
+  public @Nullable Response<T> response() {
     return response;
   }
 
@@ -54,7 +57,7 @@ private Result(Response<T> response, Throwable error) {
    * remote server. Any other exception type indicates an unexpected failure and should be
    * considered fatal (configuration error, programming error, etc.).
    */
-  public Throwable error() {
+  public @Nullable Throwable error() {
     return error;
   }
 
@@ -62,4 +65,11 @@ public Throwable error() {
   public boolean isError() {
     return error != null;
   }
+
+  @Override public String toString() {
+    if (error != null) {
+      return "Result{isError=true, error=\"" + error + "\"}";
+    }
+    return "Result{isError=false, response=" + response + '}';
+  }
 }
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/ResultOnSubscribe.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/ResultOnSubscribe.java
new file mode 100644
index 000000000..4ac19c4fe
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/ResultOnSubscribe.java
@@ -0,0 +1,75 @@
+/*
+ * Copyright (C) 2016 Jake Wharton
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import retrofit2.Response;
+import rx.Observable.OnSubscribe;
+import rx.Subscriber;
+import rx.exceptions.CompositeException;
+import rx.exceptions.Exceptions;
+import rx.exceptions.OnCompletedFailedException;
+import rx.exceptions.OnErrorFailedException;
+import rx.exceptions.OnErrorNotImplementedException;
+import rx.plugins.RxJavaPlugins;
+
+final class ResultOnSubscribe<T> implements OnSubscribe<Result<T>> {
+  private final OnSubscribe<Response<T>> upstream;
+
+  ResultOnSubscribe(OnSubscribe<Response<T>> upstream) {
+    this.upstream = upstream;
+  }
+
+  @Override public void call(Subscriber<? super Result<T>> subscriber) {
+    upstream.call(new ResultSubscriber<T>(subscriber));
+  }
+
+  private static class ResultSubscriber<R> extends Subscriber<Response<R>> {
+    private final Subscriber<? super Result<R>> subscriber;
+
+    ResultSubscriber(Subscriber<? super Result<R>> subscriber) {
+      super(subscriber);
+      this.subscriber = subscriber;
+    }
+
+    @Override public void onNext(Response<R> response) {
+      subscriber.onNext(Result.response(response));
+    }
+
+    @Override public void onError(Throwable throwable) {
+      try {
+        subscriber.onNext(Result.<R>error(throwable));
+      } catch (Throwable t) {
+        try {
+          subscriber.onError(t);
+        } catch (OnCompletedFailedException
+            | OnErrorFailedException
+            | OnErrorNotImplementedException e) {
+          RxJavaPlugins.getInstance().getErrorHandler().handleError(e);
+        } catch (Throwable inner) {
+          Exceptions.throwIfFatal(inner);
+          CompositeException composite = new CompositeException(t, inner);
+          RxJavaPlugins.getInstance().getErrorHandler().handleError(composite);
+        }
+        return;
+      }
+      subscriber.onCompleted();
+    }
+
+    @Override public void onCompleted() {
+      subscriber.onCompleted();
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapter.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapter.java
new file mode 100644
index 000000000..cb75bdc2b
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapter.java
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 2016 Jake Wharton
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import java.lang.reflect.Type;
+import javax.annotation.Nullable;
+import retrofit2.Call;
+import retrofit2.CallAdapter;
+import retrofit2.Response;
+import rx.Observable;
+import rx.Observable.OnSubscribe;
+import rx.Scheduler;
+
+final class RxJavaCallAdapter<R> implements CallAdapter<R, Object> {
+  private final Type responseType;
+  private final @Nullable Scheduler scheduler;
+  private final boolean isAsync;
+  private final boolean isResult;
+  private final boolean isBody;
+  private final boolean isSingle;
+  private final boolean isCompletable;
+
+  RxJavaCallAdapter(Type responseType, @Nullable Scheduler scheduler, boolean isAsync,
+      boolean isResult, boolean isBody, boolean isSingle, boolean isCompletable) {
+    this.responseType = responseType;
+    this.scheduler = scheduler;
+    this.isAsync = isAsync;
+    this.isResult = isResult;
+    this.isBody = isBody;
+    this.isSingle = isSingle;
+    this.isCompletable = isCompletable;
+  }
+
+  @Override public Type responseType() {
+    return responseType;
+  }
+
+  @Override public Object adapt(Call<R> call) {
+    OnSubscribe<Response<R>> callFunc = isAsync
+        ? new CallEnqueueOnSubscribe<>(call)
+        : new CallExecuteOnSubscribe<>(call);
+
+    OnSubscribe<?> func;
+    if (isResult) {
+      func = new ResultOnSubscribe<>(callFunc);
+    } else if (isBody) {
+      func = new BodyOnSubscribe<>(callFunc);
+    } else {
+      func = callFunc;
+    }
+    Observable<?> observable = Observable.create(func);
+
+    if (scheduler != null) {
+      observable = observable.subscribeOn(scheduler);
+    }
+
+    if (isSingle) {
+      return observable.toSingle();
+    }
+    if (isCompletable) {
+      return observable.toCompletable();
+    }
+    return observable;
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactory.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactory.java
index 43a2105e2..51804b76f 100644
--- a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactory.java
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactory.java
@@ -15,34 +15,47 @@
  */
 package retrofit2.adapter.rxjava;
 
+import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
-import java.util.concurrent.atomic.AtomicBoolean;
-import retrofit2.Call;
+import javax.annotation.Nullable;
 import retrofit2.CallAdapter;
+import retrofit2.HttpException;
 import retrofit2.Response;
 import retrofit2.Retrofit;
+import rx.Completable;
 import rx.Observable;
-import rx.Producer;
 import rx.Scheduler;
-import rx.Subscriber;
-import rx.exceptions.Exceptions;
-import rx.functions.Action0;
-import rx.functions.Func1;
-import rx.subscriptions.Subscriptions;
+import rx.Single;
 
 /**
  * A {@linkplain CallAdapter.Factory call adapter} which uses RxJava for creating observables.
  * <p>
- * Adding this class to {@link Retrofit} allows you to return {@link Observable} from service
- * methods.
- * <pre>{@code
+ * Adding this class to {@link Retrofit} allows you to return an {@link Observable}, {@link Single},
+ * or {@link Completable} from service methods.
+ * <pre><code>
  * interface MyService {
  *   &#64;GET("user/me")
- *   Observable<User> getUser()
+ *   Observable&lt;User&gt; getUser()
  * }
- * }</pre>
+ * </code></pre>
+ * There are three configurations supported for the {@code Observable} or {@code Single} type
+ * parameter:
+ * <ul>
+ * <li>Direct body (e.g., {@code Observable<User>}) calls {@code onNext} with the deserialized body
+ * for 2XX responses and calls {@code onError} with {@link HttpException} for non-2XX responses and
+ * {@link IOException} for network errors.</li>
+ * <li>Response wrapped body (e.g., {@code Observable<Response<User>>}) calls {@code onNext}
+ * with a {@link Response} object for all HTTP responses and calls {@code onError} with
+ * {@link IOException} for network errors</li>
+ * <li>Result wrapped body (e.g., {@code Observable<Result<User>>}) calls {@code onNext} with a
+ * {@link Result} object for all HTTP responses and errors.</li>
+ * </ul>
+ * <p>
+ * <em>Note:</em> Support for {@link Single} and {@link Completable} is experimental and subject
+ * to backwards-incompatible changes at any time since both of these types are not considered
+ * stable by RxJava.
  */
 public final class RxJavaCallAdapterFactory extends CallAdapter.Factory {
   /**
@@ -50,57 +63,57 @@
    * by default.
    */
   public static RxJavaCallAdapterFactory create() {
-    return new RxJavaCallAdapterFactory(null);
+    return new RxJavaCallAdapterFactory(null, false);
+  }
+
+  /**
+   * Returns an instance which creates asynchronous observables. Applying
+   * {@link Observable#subscribeOn} has no effect on stream types created by this factory.
+   */
+  public static RxJavaCallAdapterFactory createAsync() {
+    return new RxJavaCallAdapterFactory(null, true);
   }
 
   /**
    * Returns an instance which creates synchronous observables that
    * {@linkplain Observable#subscribeOn(Scheduler) subscribe on} {@code scheduler} by default.
    */
+  @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
   public static RxJavaCallAdapterFactory createWithScheduler(Scheduler scheduler) {
     if (scheduler == null) throw new NullPointerException("scheduler == null");
-    return new RxJavaCallAdapterFactory(scheduler);
+    return new RxJavaCallAdapterFactory(scheduler, false);
   }
 
-  private final Scheduler scheduler;
+  private final @Nullable Scheduler scheduler;
+  private final boolean isAsync;
 
-  private RxJavaCallAdapterFactory(Scheduler scheduler) {
+  private RxJavaCallAdapterFactory(@Nullable Scheduler scheduler, boolean isAsync) {
     this.scheduler = scheduler;
+    this.isAsync = isAsync;
   }
 
   @Override
-  public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+  public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
     Class<?> rawType = getRawType(returnType);
-    String canonicalName = rawType.getCanonicalName();
-    boolean isSingle = "rx.Single".equals(canonicalName);
-    boolean isCompletable = "rx.Completable".equals(canonicalName);
+    boolean isSingle = rawType == Single.class;
+    boolean isCompletable = rawType == Completable.class;
     if (rawType != Observable.class && !isSingle && !isCompletable) {
       return null;
     }
-    if (!isCompletable && !(returnType instanceof ParameterizedType)) {
-      String name = isSingle ? "Single" : "Observable";
-      throw new IllegalStateException(name + " return type must be parameterized"
-          + " as " + name + "<Foo> or " + name + "<? extends Foo>");
-    }
 
     if (isCompletable) {
-      // Add Completable-converter wrapper from a separate class. This defers classloading such that
-      // regular Observable operation can be leveraged without relying on this unstable RxJava API.
-      // Note that this has to be done separately since Completable doesn't have a parametrized
-      // type.
-      return CompletableHelper.createCallAdapter(scheduler);
+      return new RxJavaCallAdapter(Void.class, scheduler, isAsync, false, true, false, true);
     }
 
-    CallAdapter<Observable<?>> callAdapter = getCallAdapter(returnType, scheduler);
-    if (isSingle) {
-      // Add Single-converter wrapper from a separate class. This defers classloading such that
-      // regular Observable operation can be leveraged without relying on this unstable RxJava API.
-      return SingleHelper.makeSingle(callAdapter);
+    boolean isResult = false;
+    boolean isBody = false;
+    Type responseType;
+    if (!(returnType instanceof ParameterizedType)) {
+      String name = isSingle ? "Single" : "Observable";
+      throw new IllegalStateException(name + " return type must be parameterized"
+          + " as " + name + "<Foo> or " + name + "<? extends Foo>");
     }
-    return callAdapter;
-  }
 
-  private CallAdapter<Observable<?>> getCallAdapter(Type returnType, Scheduler scheduler) {
     Type observableType = getParameterUpperBound(0, (ParameterizedType) returnType);
     Class<?> rawObservableType = getRawType(observableType);
     if (rawObservableType == Response.class) {
@@ -108,150 +121,20 @@ private RxJavaCallAdapterFactory(Scheduler scheduler) {
         throw new IllegalStateException("Response must be parameterized"
             + " as Response<Foo> or Response<? extends Foo>");
       }
-      Type responseType = getParameterUpperBound(0, (ParameterizedType) observableType);
-      return new ResponseCallAdapter(responseType, scheduler);
-    }
-
-    if (rawObservableType == Result.class) {
+      responseType = getParameterUpperBound(0, (ParameterizedType) observableType);
+    } else if (rawObservableType == Result.class) {
       if (!(observableType instanceof ParameterizedType)) {
         throw new IllegalStateException("Result must be parameterized"
             + " as Result<Foo> or Result<? extends Foo>");
       }
-      Type responseType = getParameterUpperBound(0, (ParameterizedType) observableType);
-      return new ResultCallAdapter(responseType, scheduler);
+      responseType = getParameterUpperBound(0, (ParameterizedType) observableType);
+      isResult = true;
+    } else {
+      responseType = observableType;
+      isBody = true;
     }
 
-    return new SimpleCallAdapter(observableType, scheduler);
-  }
-
-  static final class CallOnSubscribe<T> implements Observable.OnSubscribe<Response<T>> {
-    private final Call<T> originalCall;
-
-    CallOnSubscribe(Call<T> originalCall) {
-      this.originalCall = originalCall;
-    }
-
-    @Override public void call(final Subscriber<? super Response<T>> subscriber) {
-      // Since Call is a one-shot type, clone it for each new subscriber.
-      Call<T> call = originalCall.clone();
-
-      // Wrap the call in a helper which handles both unsubscription and backpressure.
-      RequestArbiter<T> requestArbiter = new RequestArbiter<>(call, subscriber);
-      subscriber.add(Subscriptions.create(requestArbiter));
-      subscriber.setProducer(requestArbiter);
-    }
-  }
-
-  static final class RequestArbiter<T> extends AtomicBoolean implements Action0, Producer {
-    private final Call<T> call;
-    private final Subscriber<? super Response<T>> subscriber;
-
-    RequestArbiter(Call<T> call, Subscriber<? super Response<T>> subscriber) {
-      this.call = call;
-      this.subscriber = subscriber;
-    }
-
-    @Override public void request(long n) {
-      if (n < 0) throw new IllegalArgumentException("n < 0: " + n);
-      if (n == 0) return; // Nothing to do when requesting 0.
-      if (!compareAndSet(false, true)) return; // Request was already triggered.
-
-      try {
-        Response<T> response = call.execute();
-        if (!subscriber.isUnsubscribed()) {
-          subscriber.onNext(response);
-        }
-      } catch (Throwable t) {
-        Exceptions.throwIfFatal(t);
-        if (!subscriber.isUnsubscribed()) {
-          subscriber.onError(t);
-        }
-        return;
-      }
-
-      if (!subscriber.isUnsubscribed()) {
-        subscriber.onCompleted();
-      }
-    }
-
-    @Override public void call() {
-      call.cancel();
-    }
-  }
-
-  static final class ResponseCallAdapter implements CallAdapter<Observable<?>> {
-    private final Type responseType;
-    private final Scheduler scheduler;
-
-    ResponseCallAdapter(Type responseType, Scheduler scheduler) {
-      this.responseType = responseType;
-      this.scheduler = scheduler;
-    }
-
-    @Override public Type responseType() {
-      return responseType;
-    }
-
-    @Override public <R> Observable<Response<R>> adapt(Call<R> call) {
-      Observable<Response<R>> observable = Observable.create(new CallOnSubscribe<>(call));
-      if (scheduler != null) {
-        return observable.subscribeOn(scheduler);
-      }
-      return observable;
-    }
-  }
-
-  static final class SimpleCallAdapter implements CallAdapter<Observable<?>> {
-    private final Type responseType;
-    private final Scheduler scheduler;
-
-    SimpleCallAdapter(Type responseType, Scheduler scheduler) {
-      this.responseType = responseType;
-      this.scheduler = scheduler;
-    }
-
-    @Override public Type responseType() {
-      return responseType;
-    }
-
-    @Override public <R> Observable<R> adapt(Call<R> call) {
-      Observable<R> observable = Observable.create(new CallOnSubscribe<>(call)) //
-          .lift(OperatorMapResponseToBodyOrError.<R>instance());
-      if (scheduler != null) {
-        return observable.subscribeOn(scheduler);
-      }
-      return observable;
-    }
-  }
-
-  static final class ResultCallAdapter implements CallAdapter<Observable<?>> {
-    private final Type responseType;
-    private final Scheduler scheduler;
-
-    ResultCallAdapter(Type responseType, Scheduler scheduler) {
-      this.responseType = responseType;
-      this.scheduler = scheduler;
-    }
-
-    @Override public Type responseType() {
-      return responseType;
-    }
-
-    @Override public <R> Observable<Result<R>> adapt(Call<R> call) {
-      Observable<Result<R>> observable = Observable.create(new CallOnSubscribe<>(call)) //
-          .map(new Func1<Response<R>, Result<R>>() {
-            @Override public Result<R> call(Response<R> response) {
-              return Result.response(response);
-            }
-          }).onErrorReturn(new Func1<Throwable, Result<R>>() {
-            @Override public Result<R> call(Throwable throwable) {
-              return Result.error(throwable);
-            }
-          });
-      if (scheduler != null) {
-        return observable.subscribeOn(scheduler);
-      }
-      return observable;
-    }
+    return new RxJavaCallAdapter(responseType, scheduler, isAsync, isResult, isBody, isSingle,
+        false);
   }
 }
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/package-info.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/package-info.java
new file mode 100644
index 000000000..255728495
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/package-info.java
@@ -0,0 +1,4 @@
+@ParametersAreNonnullByDefault
+package retrofit2.adapter.rxjava;
+
+import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/AsyncTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/AsyncTest.java
new file mode 100644
index 000000000..30f04cc7c
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/AsyncTest.java
@@ -0,0 +1,181 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import java.io.IOException;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+import rx.Completable;
+import rx.exceptions.CompositeException;
+import rx.exceptions.Exceptions;
+import rx.exceptions.OnErrorFailedException;
+import rx.observers.AsyncCompletableSubscriber;
+import rx.observers.TestSubscriber;
+import rx.plugins.RxJavaErrorHandler;
+import rx.plugins.RxJavaPlugins;
+
+import static java.util.concurrent.TimeUnit.SECONDS;
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+public final class AsyncTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final TestRule pluginsReset = new RxJavaPluginsResetRule();
+
+  interface Service {
+    @GET("/") Completable completable();
+  }
+
+  private Service service;
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addCallAdapterFactory(RxJavaCallAdapterFactory.createAsync())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void success() throws InterruptedException {
+    TestSubscriber<Void> subscriber = new TestSubscriber<>();
+    service.completable().subscribe(subscriber);
+    assertFalse(subscriber.awaitValueCount(1, 1, SECONDS));
+
+    server.enqueue(new MockResponse());
+    subscriber.awaitTerminalEvent(1, SECONDS);
+    subscriber.assertCompleted();
+  }
+
+
+  @Test public void failure() throws InterruptedException {
+    TestSubscriber<Void> subscriber = new TestSubscriber<>();
+    service.completable().subscribe(subscriber);
+    assertFalse(subscriber.awaitValueCount(1, 1, SECONDS));
+
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+    subscriber.awaitTerminalEvent(1, SECONDS);
+    subscriber.assertError(IOException.class);
+  }
+
+  @Test public void throwingInOnCompleteDeliveredToPlugin() throws InterruptedException {
+    server.enqueue(new MockResponse());
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (!errorRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+        latch.countDown();
+      }
+    });
+
+    final TestSubscriber<Void> subscriber = new TestSubscriber<>();
+    final RuntimeException e = new RuntimeException();
+    service.completable().unsafeSubscribe(new AsyncCompletableSubscriber() {
+      @Override public void onCompleted() {
+        throw e;
+      }
+
+      @Override public void onError(Throwable t) {
+        subscriber.onError(t);
+      }
+    });
+
+    latch.await(1, SECONDS);
+    assertThat(errorRef.get()).isSameAs(e);
+  }
+
+  @Test public void bodyThrowingInOnErrorDeliveredToPlugin() throws InterruptedException {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (!pluginRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+        latch.countDown();
+      }
+    });
+
+    final TestSubscriber<Void> subscriber = new TestSubscriber<>();
+    final RuntimeException e = new RuntimeException();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    service.completable().unsafeSubscribe(new AsyncCompletableSubscriber() {
+      @Override public void onCompleted() {
+        subscriber.onCompleted();
+      }
+
+      @Override public void onError(Throwable t) {
+        errorRef.set(t);
+        throw e;
+      }
+    });
+
+    assertTrue(latch.await(1, SECONDS));
+    CompositeException composite = (CompositeException) pluginRef.get();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+
+  @Test public void bodyThrowingInOnSafeSubscriberErrorDeliveredToPlugin()
+      throws InterruptedException {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (throwable instanceof OnErrorFailedException) {
+          if (!pluginRef.compareAndSet(null, throwable)) {
+            throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+          }
+          latch.countDown();
+        }
+      }
+    });
+
+    final TestSubscriber<Void> subscriber = new TestSubscriber<>();
+    final RuntimeException e = new RuntimeException();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    service.completable().subscribe(new AsyncCompletableSubscriber() {
+      @Override public void onCompleted() {
+        subscriber.onCompleted();
+      }
+
+      @Override public void onError(Throwable t) {
+        errorRef.set(t);
+        throw e;
+      }
+    });
+
+    assertTrue(latch.await(1, SECONDS));
+    OnErrorFailedException failed = (OnErrorFailedException) pluginRef.get();
+    CompositeException composite = (CompositeException) failed.getCause();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableTest.java
index 0cdd11155..3d84b39f2 100644
--- a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableTest.java
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableTest.java
@@ -21,16 +21,17 @@
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+import org.junit.rules.TestRule;
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
 import rx.Completable;
 
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
 
 public final class CompletableTest {
   @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final TestRule pluginsReset = new RxJavaPluginsResetRule();
+  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
 
   interface Service {
     @GET("/") Completable completable();
@@ -48,29 +49,26 @@
 
   @Test public void completableSuccess200() {
     server.enqueue(new MockResponse().setBody("Hi"));
-    service.completable().await();
+
+    RecordingSubscriber<Void> subscriber = subscriberRule.create();
+    service.completable().unsafeSubscribe(subscriber);
+    subscriber.assertCompleted();
   }
 
   @Test public void completableSuccess404() {
     server.enqueue(new MockResponse().setResponseCode(404));
 
-    try {
-      service.completable().await();
-      fail();
-    } catch (RuntimeException e) {
-      Throwable cause = e.getCause();
-      assertThat(cause).isInstanceOf(HttpException.class).hasMessage("HTTP 404 Client Error");
-    }
+    RecordingSubscriber<Void> subscriber = subscriberRule.create();
+    service.completable().unsafeSubscribe(subscriber);
+    // Required for backwards compatibility.
+    subscriber.assertError(HttpException.class, "HTTP 404 Client Error");
   }
 
   @Test public void completableFailure() {
     server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
 
-    try {
-      service.completable().await();
-      fail();
-    } catch (RuntimeException e) {
-      assertThat(e.getCause()).isInstanceOf(IOException.class);
-    }
+    RecordingSubscriber<Void> subscriber = subscriberRule.create();
+    service.completable().unsafeSubscribe(subscriber);
+    subscriber.assertError(IOException.class);
   }
 }
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableThrowingSafeSubscriberTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableThrowingSafeSubscriberTest.java
new file mode 100644
index 000000000..9a0dec34a
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableThrowingSafeSubscriberTest.java
@@ -0,0 +1,129 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+import rx.Completable;
+import rx.CompletableSubscriber;
+import rx.Subscription;
+import rx.exceptions.CompositeException;
+import rx.exceptions.Exceptions;
+import rx.exceptions.OnCompletedFailedException;
+import rx.exceptions.OnErrorFailedException;
+import rx.plugins.RxJavaErrorHandler;
+import rx.plugins.RxJavaPlugins;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class CompletableThrowingSafeSubscriberTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final TestRule resetRule = new RxJavaPluginsResetRule();
+  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
+
+  interface Service {
+    @GET("/") Completable completable();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void throwingInOnCompleteDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (throwable instanceof OnCompletedFailedException) {
+          if (!pluginRef.compareAndSet(null, throwable)) {
+            throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+          }
+        }
+      }
+    });
+
+    RecordingSubscriber<Void> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.completable().subscribe(new ForwardingCompletableObserver(observer) {
+      @Override public void onCompleted() {
+        throw e;
+      }
+    });
+
+    assertThat(pluginRef.get().getCause()).isSameAs(e);
+  }
+
+  @Test public void bodyThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (throwable instanceof OnErrorFailedException) {
+          if (!pluginRef.compareAndSet(null, throwable)) {
+            throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+          }
+        }
+      }
+    });
+
+    RecordingSubscriber<Void> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    service.completable().subscribe(new ForwardingCompletableObserver(observer) {
+      @Override public void onError(Throwable throwable) {
+        errorRef.set(throwable);
+        throw e;
+      }
+    });
+
+    CompositeException composite = (CompositeException) pluginRef.get().getCause();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+
+  static abstract class ForwardingCompletableObserver implements CompletableSubscriber {
+    private final RecordingSubscriber<Void> delegate;
+
+    ForwardingCompletableObserver(RecordingSubscriber<Void> delegate) {
+      this.delegate = delegate;
+    }
+
+    @Override public void onSubscribe(Subscription d) {
+    }
+
+    @Override public void onCompleted() {
+      delegate.onCompleted();
+    }
+
+    @Override public void onError(Throwable throwable) {
+      delegate.onError(throwable);
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableThrowingTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableThrowingTest.java
new file mode 100644
index 000000000..be4263b8c
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableThrowingTest.java
@@ -0,0 +1,124 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.function.Consumer;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+import rx.Completable;
+import rx.CompletableSubscriber;
+import rx.Subscription;
+import rx.exceptions.CompositeException;
+import rx.exceptions.Exceptions;
+import rx.plugins.RxJavaErrorHandler;
+import rx.plugins.RxJavaPlugins;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class CompletableThrowingTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final TestRule resetRule = new RxJavaPluginsResetRule();
+  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
+
+  interface Service {
+    @GET("/") Completable completable();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void throwingInOnCompleteDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (!pluginRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+      }
+    });
+
+    RecordingSubscriber<Void> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.completable().unsafeSubscribe(new ForwardingCompletableObserver(observer) {
+      @Override public void onCompleted() {
+        throw e;
+      }
+    });
+
+    assertThat(pluginRef.get()).isSameAs(e);
+  }
+
+  @Test public void bodyThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (!pluginRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+      }
+    });
+
+    RecordingSubscriber<Void> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    service.completable().unsafeSubscribe(new ForwardingCompletableObserver(observer) {
+      @Override public void onError(Throwable throwable) {
+        errorRef.set(throwable);
+        throw e;
+      }
+    });
+
+    CompositeException composite = (CompositeException) pluginRef.get();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+
+  static abstract class ForwardingCompletableObserver implements CompletableSubscriber {
+    private final RecordingSubscriber<Void> delegate;
+
+    ForwardingCompletableObserver(RecordingSubscriber<Void> delegate) {
+      this.delegate = delegate;
+    }
+
+    @Override public void onSubscribe(Subscription d) {
+    }
+
+    @Override public void onCompleted() {
+      delegate.onCompleted();
+    }
+
+    @Override public void onError(Throwable throwable) {
+      delegate.onError(throwable);
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableSchedulerTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableWithSchedulerTest.java
similarity index 83%
rename from retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableSchedulerTest.java
rename to retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableWithSchedulerTest.java
index bb02e3d47..02c4778b1 100644
--- a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableSchedulerTest.java
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableWithSchedulerTest.java
@@ -23,11 +23,11 @@
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
 import rx.Completable;
-import rx.observers.TestSubscriber;
 import rx.schedulers.TestScheduler;
 
-public final class CompletableSchedulerTest {
+public final class CompletableWithSchedulerTest {
   @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
 
   interface Service {
     @GET("/") Completable completable();
@@ -47,9 +47,9 @@
   @Test public void completableUsesScheduler() {
     server.enqueue(new MockResponse().setBody("Hi"));
 
-    TestSubscriber<Void> subscriber = new TestSubscriber<>();
-    service.completable().subscribe(subscriber);
-    subscriber.assertNoTerminalEvent();
+    RecordingSubscriber<String> subscriber = subscriberRule.create();
+    service.completable().unsafeSubscribe(subscriber);
+    subscriber.assertNoEvents();
 
     scheduler.triggerActions();
     subscriber.assertCompleted();
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ForwardingSubscriber.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ForwardingSubscriber.java
new file mode 100644
index 000000000..d32d6f6ae
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ForwardingSubscriber.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import rx.Subscriber;
+
+abstract class ForwardingSubscriber<T> extends Subscriber<T> {
+  private final Subscriber<T> delegate;
+
+  ForwardingSubscriber(Subscriber<T> delegate) {
+    this.delegate = delegate;
+  }
+
+  @Override public void onNext(T value) {
+    delegate.onNext(value);
+  }
+
+  @Override public void onCompleted() {
+    delegate.onCompleted();
+  }
+
+  @Override public void onError(Throwable throwable) {
+    delegate.onError(throwable);
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableTest.java
index f3e05adea..500c3c539 100644
--- a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableTest.java
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableTest.java
@@ -21,19 +21,20 @@
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+import org.junit.rules.TestRule;
 import retrofit2.Response;
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
 import rx.Observable;
-import rx.observables.BlockingObservable;
-import rx.observers.TestSubscriber;
+import rx.functions.Action1;
 
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
 
 public final class ObservableTest {
   @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final TestRule pluginsReset = new RxJavaPluginsResetRule();
+  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
 
   interface Service {
     @GET("/") Observable<String> body();
@@ -55,46 +56,38 @@
   @Test public void bodySuccess200() {
     server.enqueue(new MockResponse().setBody("Hi"));
 
-    BlockingObservable<String> o = service.body().toBlocking();
-    assertThat(o.first()).isEqualTo("Hi");
+    RecordingSubscriber<String> subscriber = subscriberRule.create();
+    service.body().unsafeSubscribe(subscriber);
+    subscriber.assertValue("Hi").assertCompleted();
   }
 
   @Test public void bodySuccess404() {
     server.enqueue(new MockResponse().setResponseCode(404));
 
-    BlockingObservable<String> o = service.body().toBlocking();
-    try {
-      o.first();
-      fail();
-    } catch (RuntimeException e) {
-      Throwable cause = e.getCause();
-      assertThat(cause).isInstanceOf(HttpException.class).hasMessage("HTTP 404 Client Error");
-    }
+    RecordingSubscriber<String> subscriber = subscriberRule.create();
+    service.body().unsafeSubscribe(subscriber);
+    // Required for backwards compatibility.
+    subscriber.assertError(HttpException.class, "HTTP 404 Client Error");
   }
 
   @Test public void bodyFailure() {
     server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
 
-    BlockingObservable<String> o = service.body().toBlocking();
-    try {
-      o.first();
-      fail();
-    } catch (RuntimeException e) {
-      assertThat(e.getCause()).isInstanceOf(IOException.class);
-    }
+    RecordingSubscriber<String> subscriber = subscriberRule.create();
+    service.body().unsafeSubscribe(subscriber);
+    subscriber.assertError(IOException.class);
   }
 
   @Test public void bodyRespectsBackpressure() {
     server.enqueue(new MockResponse().setBody("Hi"));
 
-    TestSubscriber<String> subscriber = new TestSubscriber<>(0);
-    Observable<String> o = service.body();
-
-    o.subscribe(subscriber);
-    assertThat(server.getRequestCount()).isEqualTo(0);
+    RecordingSubscriber<String> subscriber = subscriberRule.createWithInitialRequest(0);
+    service.body().unsafeSubscribe(subscriber);
+    assertThat(server.getRequestCount()).isEqualTo(1);
+    subscriber.assertNoEvents();
 
     subscriber.requestMore(1);
-    assertThat(server.getRequestCount()).isEqualTo(1);
+    subscriber.assertAnyValue().assertCompleted();
 
     subscriber.requestMore(Long.MAX_VALUE); // Subsequent requests do not trigger HTTP requests.
     assertThat(server.getRequestCount()).isEqualTo(1);
@@ -103,91 +96,97 @@
   @Test public void responseSuccess200() {
     server.enqueue(new MockResponse().setBody("Hi"));
 
-    BlockingObservable<Response<String>> o = service.response().toBlocking();
-    Response<String> response = o.first();
-    assertThat(response.isSuccessful()).isTrue();
-    assertThat(response.body()).isEqualTo("Hi");
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+    service.response().unsafeSubscribe(subscriber);
+    assertThat(subscriber.takeValue().body()).isEqualTo("Hi");
+    subscriber.assertCompleted();
   }
 
   @Test public void responseSuccess404() throws IOException {
-    server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
+    server.enqueue(new MockResponse().setResponseCode(404));
 
-    BlockingObservable<Response<String>> o = service.response().toBlocking();
-    Response<String> response = o.first();
-    assertThat(response.isSuccessful()).isFalse();
-    assertThat(response.errorBody().string()).isEqualTo("Hi");
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+    service.response().unsafeSubscribe(subscriber);
+    assertThat(subscriber.takeValue().code()).isEqualTo(404);
+    subscriber.assertCompleted();
   }
 
   @Test public void responseFailure() {
     server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
 
-    BlockingObservable<Response<String>> o = service.response().toBlocking();
-    try {
-      o.first();
-      fail();
-    } catch (RuntimeException t) {
-      assertThat(t.getCause()).isInstanceOf(IOException.class);
-    }
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+    service.response().unsafeSubscribe(subscriber);
+    subscriber.assertError(IOException.class);
   }
 
   @Test public void responseRespectsBackpressure() {
     server.enqueue(new MockResponse().setBody("Hi"));
 
-    TestSubscriber<Response<String>> subscriber = new TestSubscriber<>(0);
-    Observable<Response<String>> o = service.response();
-
-    o.subscribe(subscriber);
-    assertThat(server.getRequestCount()).isEqualTo(0);
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.createWithInitialRequest(0);
+    service.response().unsafeSubscribe(subscriber);
+    assertThat(server.getRequestCount()).isEqualTo(1);
+    subscriber.assertNoEvents();
 
     subscriber.requestMore(1);
-    assertThat(server.getRequestCount()).isEqualTo(1);
+    subscriber.assertAnyValue().assertCompleted();
 
     subscriber.requestMore(Long.MAX_VALUE); // Subsequent requests do not trigger HTTP requests.
     assertThat(server.getRequestCount()).isEqualTo(1);
   }
 
+  @Test public void responseUnsubscribedDoesNotCallCompleted() throws InterruptedException {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    final RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+    service.response()
+        .doOnNext(new Action1<Response<String>>() {
+          @Override
+          public void call(Response<String> response) {
+            subscriber.unsubscribe();
+          }
+        })
+        .subscribe(subscriber);
+
+    assertThat(subscriber.takeValue().body()).isEqualTo("Hi");
+  }
+
   @Test public void resultSuccess200() {
     server.enqueue(new MockResponse().setBody("Hi"));
 
-    BlockingObservable<Result<String>> o = service.result().toBlocking();
-    Result<String> result = o.first();
-    assertThat(result.isError()).isFalse();
-    Response<String> response = result.response();
-    assertThat(response.isSuccessful()).isTrue();
-    assertThat(response.body()).isEqualTo("Hi");
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+    service.result().unsafeSubscribe(subscriber);
+    assertThat(subscriber.takeValue().response().body()).isEqualTo("Hi");
+    subscriber.assertCompleted();
   }
 
   @Test public void resultSuccess404() throws IOException {
-    server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
-
-    BlockingObservable<Result<String>> o = service.result().toBlocking();
-    Result<String> result = o.first();
-    assertThat(result.isError()).isFalse();
-    Response<String> response = result.response();
-    assertThat(response.isSuccessful()).isFalse();
-    assertThat(response.errorBody().string()).isEqualTo("Hi");
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+    service.result().unsafeSubscribe(subscriber);
+    assertThat(subscriber.takeValue().response().code()).isEqualTo(404);
+    subscriber.assertCompleted();
   }
 
   @Test public void resultFailure() {
     server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
 
-    BlockingObservable<Result<String>> o = service.result().toBlocking();
-    Result<String> result = o.first();
-    assertThat(result.isError()).isTrue();
-    assertThat(result.error()).isInstanceOf(IOException.class);
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+    service.result().unsafeSubscribe(subscriber);
+    assertThat(subscriber.takeValue().error()).isInstanceOf(IOException.class);
+    subscriber.assertCompleted();
   }
 
   @Test public void resultRespectsBackpressure() {
     server.enqueue(new MockResponse().setBody("Hi"));
 
-    TestSubscriber<Result<String>> subscriber = new TestSubscriber<>(0);
-    Observable<Result<String>> o = service.result();
-
-    o.subscribe(subscriber);
-    assertThat(server.getRequestCount()).isEqualTo(0);
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.createWithInitialRequest(0);
+    service.result().unsafeSubscribe(subscriber);
+    assertThat(server.getRequestCount()).isEqualTo(1);
+    subscriber.assertNoEvents();
 
     subscriber.requestMore(1);
-    assertThat(server.getRequestCount()).isEqualTo(1);
+    subscriber.assertAnyValue().assertCompleted();
 
     subscriber.requestMore(Long.MAX_VALUE); // Subsequent requests do not trigger HTTP requests.
     assertThat(server.getRequestCount()).isEqualTo(1);
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableThrowingSafeSubscriberTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableThrowingSafeSubscriberTest.java
new file mode 100644
index 000000000..550d6cbc3
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableThrowingSafeSubscriberTest.java
@@ -0,0 +1,272 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+import rx.Observable;
+import rx.exceptions.CompositeException;
+import rx.exceptions.Exceptions;
+import rx.exceptions.OnCompletedFailedException;
+import rx.exceptions.OnErrorFailedException;
+import rx.plugins.RxJavaErrorHandler;
+import rx.plugins.RxJavaPlugins;
+
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class ObservableThrowingSafeSubscriberTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final TestRule resetRule = new RxJavaPluginsResetRule();
+  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
+
+  interface Service {
+    @GET("/") Observable<String> body();
+    @GET("/") Observable<Response<String>> response();
+    @GET("/") Observable<Result<String>> result();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodyThrowingInOnNextDeliveredToError() {
+    server.enqueue(new MockResponse());
+
+    RecordingSubscriber<String> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.body().subscribe(new ForwardingSubscriber<String>(observer) {
+      @Override public void onNext(String value) {
+        throw e;
+      }
+    });
+
+    observer.assertError(e);
+  }
+
+  @Test public void bodyThrowingInOnCompleteDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (throwable instanceof OnCompletedFailedException) {
+          if (!pluginRef.compareAndSet(null, throwable)) {
+            throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+          }
+        }
+      }
+    });
+
+    RecordingSubscriber<String> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.body().subscribe(new ForwardingSubscriber<String>(observer) {
+      @Override public void onCompleted() {
+        throw e;
+      }
+    });
+
+    observer.assertAnyValue();
+    assertThat(pluginRef.get().getCause()).isSameAs(e);
+  }
+
+  @Test public void bodyThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (throwable instanceof OnErrorFailedException) {
+          if (!pluginRef.compareAndSet(null, throwable)) {
+            throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+          }
+        }
+      }
+    });
+
+    RecordingSubscriber<String> observer = subscriberRule.create();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    final RuntimeException e = new RuntimeException();
+    service.body().subscribe(new ForwardingSubscriber<String>(observer) {
+      @Override public void onError(Throwable throwable) {
+        if (!errorRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+        throw e;
+      }
+    });
+
+    CompositeException composite = (CompositeException) pluginRef.get().getCause();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+
+  @Test public void responseThrowingInOnNextDeliveredToError() {
+    server.enqueue(new MockResponse());
+
+    RecordingSubscriber<Response<String>> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.response().subscribe(new ForwardingSubscriber<Response<String>>(observer) {
+      @Override public void onNext(Response<String> value) {
+        throw e;
+      }
+    });
+
+    observer.assertError(e);
+  }
+
+  @Test public void responseThrowingInOnCompleteDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (throwable instanceof OnCompletedFailedException) {
+          if (!pluginRef.compareAndSet(null, throwable)) {
+            throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+          }
+        }
+      }
+    });
+
+    RecordingSubscriber<Response<String>> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.response().subscribe(new ForwardingSubscriber<Response<String>>(observer) {
+      @Override public void onCompleted() {
+        throw e;
+      }
+    });
+
+    observer.assertAnyValue();
+    assertThat(pluginRef.get().getCause()).isSameAs(e);
+  }
+
+  @Test public void responseThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (throwable instanceof OnErrorFailedException) {
+          if (!pluginRef.compareAndSet(null, throwable)) {
+            throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+          }
+        }
+      }
+    });
+
+    RecordingSubscriber<Response<String>> observer = subscriberRule.create();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    final RuntimeException e = new RuntimeException();
+    service.response().subscribe(new ForwardingSubscriber<Response<String>>(observer) {
+      @Override public void onError(Throwable throwable) {
+        if (!errorRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+        throw e;
+      }
+    });
+
+    CompositeException composite = (CompositeException) pluginRef.get().getCause();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+
+  @Test public void resultThrowingInOnNextDeliveredToError() {
+    server.enqueue(new MockResponse());
+
+    RecordingSubscriber<Result<String>> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.result().subscribe(new ForwardingSubscriber<Result<String>>(observer) {
+      @Override public void onNext(Result<String> value) {
+        throw e;
+      }
+    });
+
+    observer.assertError(e);
+  }
+
+  @Test public void resultThrowingInOnCompletedDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (throwable instanceof OnCompletedFailedException) {
+          if (!pluginRef.compareAndSet(null, throwable)) {
+            throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+          }
+        }
+      }
+    });
+
+    RecordingSubscriber<Result<String>> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.result().subscribe(new ForwardingSubscriber<Result<String>>(observer) {
+      @Override public void onCompleted() {
+        throw e;
+      }
+    });
+
+    observer.assertAnyValue();
+    assertThat(pluginRef.get().getCause()).isSameAs(e);
+  }
+
+  @Test public void resultThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (throwable instanceof OnErrorFailedException) {
+          if (!pluginRef.compareAndSet(null, throwable)) {
+            throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+          }
+        }
+      }
+    });
+
+    RecordingSubscriber<Result<String>> observer = subscriberRule.create();
+    final RuntimeException first = new RuntimeException();
+    final RuntimeException second = new RuntimeException();
+    service.result().subscribe(new ForwardingSubscriber<Result<String>>(observer) {
+      @Override public void onNext(Result<String> value) {
+        // The only way to trigger onError for a result is if onNext throws.
+        throw first;
+      }
+
+      @Override public void onError(Throwable throwable) {
+        throw second;
+      }
+    });
+
+    CompositeException composite = (CompositeException) pluginRef.get().getCause();
+    assertThat(composite.getExceptions()).containsExactly(first, second);
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableThrowingTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableThrowingTest.java
new file mode 100644
index 000000000..59c8ae5ae
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableThrowingTest.java
@@ -0,0 +1,258 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+import rx.Observable;
+import rx.exceptions.CompositeException;
+import rx.exceptions.Exceptions;
+import rx.plugins.RxJavaErrorHandler;
+import rx.plugins.RxJavaPlugins;
+
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class ObservableThrowingTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final TestRule resetRule = new RxJavaPluginsResetRule();
+  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
+
+  interface Service {
+    @GET("/") Observable<String> body();
+    @GET("/") Observable<Response<String>> response();
+    @GET("/") Observable<Result<String>> result();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodyThrowingInOnNextDeliveredToError() {
+    server.enqueue(new MockResponse());
+
+    RecordingSubscriber<String> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.body().unsafeSubscribe(new ForwardingSubscriber<String>(observer) {
+      @Override public void onNext(String value) {
+        throw e;
+      }
+    });
+
+    observer.assertError(e);
+  }
+
+  @Test public void bodyThrowingInOnCompleteDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (!pluginRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+      }
+    });
+
+    RecordingSubscriber<String> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.body().unsafeSubscribe(new ForwardingSubscriber<String>(observer) {
+      @Override public void onCompleted() {
+        throw e;
+      }
+    });
+
+    observer.assertAnyValue();
+    assertThat(pluginRef.get()).isSameAs(e);
+  }
+
+  @Test public void bodyThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (!pluginRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+      }
+    });
+
+    RecordingSubscriber<String> observer = subscriberRule.create();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    final RuntimeException e = new RuntimeException();
+    service.body().unsafeSubscribe(new ForwardingSubscriber<String>(observer) {
+      @Override public void onError(Throwable throwable) {
+        if (!errorRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+        throw e;
+      }
+    });
+
+    CompositeException composite = (CompositeException) pluginRef.get();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+
+  @Test public void responseThrowingInOnNextDeliveredToError() {
+    server.enqueue(new MockResponse());
+
+    RecordingSubscriber<Response<String>> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.response().unsafeSubscribe(new ForwardingSubscriber<Response<String>>(observer) {
+      @Override public void onNext(Response<String> value) {
+        throw e;
+      }
+    });
+
+    observer.assertError(e);
+  }
+
+  @Test public void responseThrowingInOnCompleteDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (!pluginRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+      }
+    });
+
+    RecordingSubscriber<Response<String>> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.response().unsafeSubscribe(new ForwardingSubscriber<Response<String>>(observer) {
+      @Override public void onCompleted() {
+        throw e;
+      }
+    });
+
+    observer.assertAnyValue();
+    assertThat(pluginRef.get()).isSameAs(e);
+  }
+
+  @Test public void responseThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (!pluginRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+      }
+    });
+
+    RecordingSubscriber<Response<String>> observer = subscriberRule.create();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    final RuntimeException e = new RuntimeException();
+    service.response().unsafeSubscribe(new ForwardingSubscriber<Response<String>>(observer) {
+      @Override public void onError(Throwable throwable) {
+        if (!errorRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+        throw e;
+      }
+    });
+
+    CompositeException composite = (CompositeException) pluginRef.get();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+
+  @Test public void resultThrowingInOnNextDeliveredToError() {
+    server.enqueue(new MockResponse());
+
+    RecordingSubscriber<Result<String>> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.result().unsafeSubscribe(new ForwardingSubscriber<Result<String>>(observer) {
+      @Override public void onNext(Result<String> value) {
+        throw e;
+      }
+    });
+
+    observer.assertError(e);
+  }
+
+  @Test public void resultThrowingInOnCompletedDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (!pluginRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+      }
+    });
+
+    RecordingSubscriber<Result<String>> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.result().unsafeSubscribe(new ForwardingSubscriber<Result<String>>(observer) {
+      @Override public void onCompleted() {
+        throw e;
+      }
+    });
+
+    observer.assertAnyValue();
+    assertThat(pluginRef.get()).isSameAs(e);
+  }
+
+  @Test public void resultThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (!pluginRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+      }
+    });
+
+    RecordingSubscriber<Result<String>> observer = subscriberRule.create();
+    final RuntimeException first = new RuntimeException();
+    final RuntimeException second = new RuntimeException();
+    service.result().unsafeSubscribe(new ForwardingSubscriber<Result<String>>(observer) {
+      @Override public void onNext(Result<String> value) {
+        // The only way to trigger onError for a result is if onNext throws.
+        throw first;
+      }
+
+      @Override public void onError(Throwable throwable) {
+        throw second;
+      }
+    });
+
+    CompositeException composite = (CompositeException) pluginRef.get();
+    assertThat(composite.getExceptions()).containsExactly(first, second);
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableSchedulerTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableWithSchedulerTest.java
similarity index 70%
rename from retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableSchedulerTest.java
rename to retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableWithSchedulerTest.java
index e0a1c2d41..3cf00cd7a 100644
--- a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableSchedulerTest.java
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableWithSchedulerTest.java
@@ -24,11 +24,11 @@
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
 import rx.Observable;
-import rx.observers.TestSubscriber;
 import rx.schedulers.TestScheduler;
 
-public final class ObservableSchedulerTest {
+public final class ObservableWithSchedulerTest {
   @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
 
   interface Service {
     @GET("/") Observable<String> body();
@@ -51,39 +51,33 @@
   @Test public void bodyUsesScheduler() {
     server.enqueue(new MockResponse().setBody("Hi"));
 
-    TestSubscriber<String> subscriber = new TestSubscriber<>();
-    service.body().subscribe(subscriber);
-    subscriber.assertNoValues();
-    subscriber.assertNoTerminalEvent();
+    RecordingSubscriber<String> subscriber = subscriberRule.create();
+    service.body().unsafeSubscribe(subscriber);
+    subscriber.assertNoEvents();
 
     scheduler.triggerActions();
-    subscriber.assertValueCount(1);
-    subscriber.assertCompleted();
+    subscriber.assertAnyValue().assertCompleted();
   }
 
   @Test public void responseUsesScheduler() {
     server.enqueue(new MockResponse().setBody("Hi"));
 
-    TestSubscriber<Response<String>> subscriber = new TestSubscriber<>();
-    service.response().subscribe(subscriber);
-    subscriber.assertNoValues();
-    subscriber.assertNoTerminalEvent();
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+    service.response().unsafeSubscribe(subscriber);
+    subscriber.assertNoEvents();
 
     scheduler.triggerActions();
-    subscriber.assertValueCount(1);
-    subscriber.assertCompleted();
+    subscriber.assertAnyValue().assertCompleted();
   }
 
   @Test public void resultUsesScheduler() {
     server.enqueue(new MockResponse().setBody("Hi"));
 
-    TestSubscriber<Result<String>> subscriber = new TestSubscriber<>();
-    service.result().subscribe(subscriber);
-    subscriber.assertNoValues();
-    subscriber.assertNoTerminalEvent();
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+    service.result().unsafeSubscribe(subscriber);
+    subscriber.assertNoEvents();
 
     scheduler.triggerActions();
-    subscriber.assertValueCount(1);
-    subscriber.assertCompleted();
+    subscriber.assertAnyValue().assertCompleted();
   }
 }
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/RecordingSubscriber.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/RecordingSubscriber.java
new file mode 100644
index 000000000..4919ddcd5
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/RecordingSubscriber.java
@@ -0,0 +1,146 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Deque;
+import java.util.List;
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+import rx.Notification;
+import rx.Subscriber;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+/** A test {@link Subscriber} and JUnit rule which guarantees all events are asserted. */
+final class RecordingSubscriber<T> extends Subscriber<T> {
+  private final long initialRequest;
+  private final Deque<Notification<T>> events = new ArrayDeque<>();
+
+  private RecordingSubscriber(long initialRequest) {
+    this.initialRequest = initialRequest;
+  }
+
+  @Override public void onStart() {
+    request(initialRequest);
+  }
+
+  @Override public void onNext(T value) {
+    events.add(Notification.createOnNext(value));
+  }
+
+  @Override public void onCompleted() {
+    events.add(Notification.<T>createOnCompleted());
+  }
+
+  @Override public void onError(Throwable e) {
+    events.add(Notification.<T>createOnError(e));
+  }
+
+  private Notification<T> takeNotification() {
+    Notification<T> notification = events.pollFirst();
+    if (notification == null) {
+      throw new AssertionError("No event found!");
+    }
+    return notification;
+  }
+
+  public T takeValue() {
+    Notification<T> notification = takeNotification();
+    assertThat(notification.isOnNext())
+        .overridingErrorMessage("Expected onNext event but was %s", notification)
+        .isTrue();
+    return notification.getValue();
+  }
+
+  public Throwable takeError() {
+    Notification<T> notification = takeNotification();
+    assertThat(notification.isOnError())
+        .overridingErrorMessage("Expected onError event but was %s", notification)
+        .isTrue();
+    return notification.getThrowable();
+  }
+
+  public RecordingSubscriber<T> assertAnyValue() {
+    takeValue();
+    return this;
+  }
+
+  public RecordingSubscriber<T> assertValue(T value) {
+    assertThat(takeValue()).isEqualTo(value);
+    return this;
+  }
+
+  public void assertCompleted() {
+    Notification<T> notification = takeNotification();
+    assertThat(notification.isOnCompleted())
+        .overridingErrorMessage("Expected onCompleted event but was %s", notification)
+        .isTrue();
+    assertNoEvents();
+  }
+
+  public void assertError(Throwable throwable) {
+    assertThat(takeError()).isEqualTo(throwable);
+  }
+
+  public void assertError(Class<? extends Throwable> errorClass) {
+    assertError(errorClass, null);
+  }
+
+  public void assertError(Class<? extends Throwable> errorClass, String message) {
+    Throwable throwable = takeError();
+    assertThat(throwable).isInstanceOf(errorClass);
+    if (message != null) {
+      assertThat(throwable).hasMessage(message);
+    }
+    assertNoEvents();
+  }
+
+  public void assertNoEvents() {
+    assertThat(events).as("Unconsumed events found!").isEmpty();
+  }
+
+  public void requestMore(long amount) {
+    request(amount);
+  }
+
+  public static final class Rule implements TestRule {
+    final List<RecordingSubscriber<?>> subscribers = new ArrayList<>();
+
+    public <T> RecordingSubscriber<T> create() {
+      return createWithInitialRequest(Long.MAX_VALUE);
+    }
+
+    public <T> RecordingSubscriber<T> createWithInitialRequest(long initialRequest) {
+      RecordingSubscriber<T> subscriber = new RecordingSubscriber<>(initialRequest);
+      subscribers.add(subscriber);
+      return subscriber;
+    }
+
+    @Override public Statement apply(final Statement base, Description description) {
+      return new Statement() {
+        @Override public void evaluate() throws Throwable {
+          base.evaluate();
+          for (RecordingSubscriber<?> subscriber : subscribers) {
+            subscriber.assertNoEvents();
+          }
+        }
+      };
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactoryTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactoryTest.java
index 3c2e435ad..674575f74 100644
--- a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactoryTest.java
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactoryTest.java
@@ -54,7 +54,7 @@
   }
 
   @Test public void nonRxJavaTypeReturnsNull() {
-    CallAdapter<?> adapter = factory.get(String.class, NO_ANNOTATIONS, retrofit);
+    CallAdapter<?, ?> adapter = factory.get(String.class, NO_ANNOTATIONS, retrofit);
     assertThat(adapter).isNull();
   }
 
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/RxJavaPluginsResetRule.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/RxJavaPluginsResetRule.java
new file mode 100644
index 000000000..dfe336f07
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/RxJavaPluginsResetRule.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+import rx.plugins.RxJavaPlugins;
+
+/** A JUnit @Rule which resets RxJava's plugins before and after each test. */
+final class RxJavaPluginsResetRule implements TestRule {
+  @Override public Statement apply(final Statement base, Description description) {
+    return new Statement() {
+      @Override public void evaluate() throws Throwable {
+        RxJavaPlugins.getInstance().reset();
+        try {
+          base.evaluate();
+        } finally {
+          RxJavaPlugins.getInstance().reset();
+        }
+      }
+    };
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleTest.java
index 67c5a3d22..babd05c73 100644
--- a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleTest.java
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleTest.java
@@ -21,18 +21,19 @@
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+import org.junit.rules.TestRule;
 import retrofit2.Response;
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
 import rx.Single;
-import rx.singles.BlockingSingle;
 
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
 
 public final class SingleTest {
   @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final TestRule pluginsReset = new RxJavaPluginsResetRule();
+  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
 
   interface Service {
     @GET("/") Single<String> body();
@@ -54,93 +55,120 @@
   @Test public void bodySuccess200() {
     server.enqueue(new MockResponse().setBody("Hi"));
 
-    BlockingSingle<String> o = service.body().toBlocking();
-    assertThat(o.value()).isEqualTo("Hi");
+    RecordingSubscriber<String> subscriber = subscriberRule.create();
+    service.body().unsafeSubscribe(subscriber);
+    subscriber.assertValue("Hi").assertCompleted();
   }
 
   @Test public void bodySuccess404() {
     server.enqueue(new MockResponse().setResponseCode(404));
 
-    BlockingSingle<String> o = service.body().toBlocking();
-    try {
-      o.value();
-      fail();
-    } catch (RuntimeException e) {
-      Throwable cause = e.getCause();
-      assertThat(cause).isInstanceOf(HttpException.class).hasMessage("HTTP 404 Client Error");
-    }
+    RecordingSubscriber<String> subscriber = subscriberRule.create();
+    service.body().unsafeSubscribe(subscriber);
+    // Required for backwards compatibility.
+    subscriber.assertError(HttpException.class, "HTTP 404 Client Error");
   }
 
   @Test public void bodyFailure() {
     server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
 
-    BlockingSingle<String> o = service.body().toBlocking();
-    try {
-      o.value();
-      fail();
-    } catch (RuntimeException e) {
-      assertThat(e.getCause()).isInstanceOf(IOException.class);
-    }
+    RecordingSubscriber<String> subscriber = subscriberRule.create();
+    service.body().unsafeSubscribe(subscriber);
+    subscriber.assertError(IOException.class);
+  }
+
+  @Test public void bodyThrowingInOnNextDeliveredToError() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingSubscriber<String> subscriber = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.body().unsafeSubscribe(new ForwardingSubscriber<String>(subscriber) {
+      @Override public void onNext(String value) {
+        throw e;
+      }
+    });
+
+    subscriber.assertError(e);
   }
 
   @Test public void responseSuccess200() {
     server.enqueue(new MockResponse().setBody("Hi"));
 
-    BlockingSingle<Response<String>> o = service.response().toBlocking();
-    Response<String> response = o.value();
-    assertThat(response.isSuccessful()).isTrue();
-    assertThat(response.body()).isEqualTo("Hi");
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+    service.response().unsafeSubscribe(subscriber);
+    assertThat(subscriber.takeValue().body()).isEqualTo("Hi");
+    subscriber.assertCompleted();
   }
 
   @Test public void responseSuccess404() throws IOException {
-    server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
+    server.enqueue(new MockResponse().setResponseCode(404));
 
-    BlockingSingle<Response<String>> o = service.response().toBlocking();
-    Response<String> response = o.value();
-    assertThat(response.isSuccessful()).isFalse();
-    assertThat(response.errorBody().string()).isEqualTo("Hi");
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+    service.response().unsafeSubscribe(subscriber);
+    assertThat(subscriber.takeValue().code()).isEqualTo(404);
+    subscriber.assertCompleted();
   }
 
   @Test public void responseFailure() {
     server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
 
-    BlockingSingle<Response<String>> o = service.response().toBlocking();
-    try {
-      o.value();
-      fail();
-    } catch (RuntimeException t) {
-      assertThat(t.getCause()).isInstanceOf(IOException.class);
-    }
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+    service.response().unsafeSubscribe(subscriber);
+    subscriber.assertError(IOException.class);
+  }
+
+  @Test public void responseThrowingInOnNextDeliveredToError() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.response().unsafeSubscribe(new ForwardingSubscriber<Response<String>>(subscriber) {
+      @Override public void onNext(Response<String> value) {
+        throw e;
+      }
+    });
+
+    subscriber.assertError(e);
   }
 
   @Test public void resultSuccess200() {
     server.enqueue(new MockResponse().setBody("Hi"));
 
-    BlockingSingle<Result<String>> o = service.result().toBlocking();
-    Result<String> result = o.value();
-    assertThat(result.isError()).isFalse();
-    Response<String> response = result.response();
-    assertThat(response.isSuccessful()).isTrue();
-    assertThat(response.body()).isEqualTo("Hi");
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+    service.result().unsafeSubscribe(subscriber);
+    assertThat(subscriber.takeValue().response().body()).isEqualTo("Hi");
+    subscriber.assertCompleted();
   }
 
   @Test public void resultSuccess404() throws IOException {
-    server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
-
-    BlockingSingle<Result<String>> o = service.result().toBlocking();
-    Result<String> result = o.value();
-    assertThat(result.isError()).isFalse();
-    Response<String> response = result.response();
-    assertThat(response.isSuccessful()).isFalse();
-    assertThat(response.errorBody().string()).isEqualTo("Hi");
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+    service.result().unsafeSubscribe(subscriber);
+    assertThat(subscriber.takeValue().response().code()).isEqualTo(404);
+    subscriber.assertCompleted();
   }
 
   @Test public void resultFailure() {
     server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
 
-    BlockingSingle<Result<String>> o = service.result().toBlocking();
-    Result<String> result = o.value();
-    assertThat(result.isError()).isTrue();
-    assertThat(result.error()).isInstanceOf(IOException.class);
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+    service.result().unsafeSubscribe(subscriber);
+    assertThat(subscriber.takeValue().error()).isInstanceOf(IOException.class);
+    subscriber.assertCompleted();
+  }
+
+  @Test public void resultThrowingInOnNextDeliveredToError() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.result().unsafeSubscribe(new ForwardingSubscriber<Result<String>>(subscriber) {
+      @Override public void onNext(Result<String> value) {
+        throw e;
+      }
+    });
+
+    subscriber.assertError(e);
   }
 }
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleThrowingTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleThrowingTest.java
new file mode 100644
index 000000000..5266a4f44
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleThrowingTest.java
@@ -0,0 +1,234 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+import rx.Single;
+import rx.SingleSubscriber;
+import rx.Subscriber;
+import rx.exceptions.CompositeException;
+import rx.exceptions.Exceptions;
+import rx.plugins.RxJavaErrorHandler;
+import rx.plugins.RxJavaPlugins;
+
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class SingleThrowingTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final TestRule resetRule = new RxJavaPluginsResetRule();
+  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
+
+  interface Service {
+    @GET("/") Single<String> body();
+    @GET("/") Single<Response<String>> response();
+    @GET("/") Single<Result<String>> result();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodyThrowingInOnSuccessDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (!pluginRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+      }
+    });
+
+    RecordingSubscriber<String> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.body().subscribe(new ForwardingObserver<String>(observer) {
+      @Override public void onSuccess(String value) {
+        throw e;
+      }
+    });
+
+    assertThat(pluginRef.get()).isSameAs(e);
+  }
+
+  @Test public void bodyThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (!pluginRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+      }
+    });
+
+    RecordingSubscriber<String> observer = subscriberRule.create();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    final RuntimeException e = new RuntimeException();
+    service.body().subscribe(new ForwardingObserver<String>(observer) {
+      @Override public void onError(Throwable throwable) {
+        if (!errorRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+        throw e;
+      }
+    });
+
+    CompositeException composite = (CompositeException) pluginRef.get();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+
+  @Test public void responseThrowingInOnSuccessDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (!pluginRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+      }
+    });
+
+    RecordingSubscriber<Response<String>> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.response().subscribe(new ForwardingObserver<Response<String>>(observer) {
+      @Override public void onSuccess(Response<String> value) {
+        throw e;
+      }
+    });
+
+    assertThat(pluginRef.get()).isSameAs(e);
+  }
+
+  @Test public void responseThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (!pluginRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+      }
+    });
+
+    RecordingSubscriber<Response<String>> observer = subscriberRule.create();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    final RuntimeException e = new RuntimeException();
+    service.response().subscribe(new ForwardingObserver<Response<String>>(observer) {
+      @Override public void onError(Throwable throwable) {
+        if (!errorRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+        throw e;
+      }
+    });
+
+    CompositeException composite = (CompositeException) pluginRef.get();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+
+  @Test public void resultThrowingInOnSuccessDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (!pluginRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+      }
+    });
+
+    RecordingSubscriber<Result<String>> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.result().subscribe(new ForwardingObserver<Result<String>>(observer) {
+      @Override public void onSuccess(Result<String> value) {
+        throw e;
+      }
+    });
+
+    assertThat(pluginRef.get()).isSameAs(e);
+  }
+
+  @Ignore("Single's contract is onNext|onError so we have no way of triggering this case")
+  @Test public void resultThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (!pluginRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+      }
+    });
+
+    RecordingSubscriber<Result<String>> observer = subscriberRule.create();
+    final RuntimeException first = new RuntimeException();
+    final RuntimeException second = new RuntimeException();
+    service.result().subscribe(new ForwardingObserver<Result<String>>(observer) {
+      @Override public void onSuccess(Result<String> value) {
+        // The only way to trigger onError for Result is if onSuccess throws.
+        throw first;
+      }
+
+      @Override public void onError(Throwable throwable) {
+        throw second;
+      }
+    });
+
+    CompositeException composite = (CompositeException) pluginRef.get();
+    assertThat(composite.getExceptions()).containsExactly(first, second);
+  }
+
+  private static abstract class ForwardingObserver<T> extends SingleSubscriber<T> {
+    private final Subscriber<T> delegate;
+
+    ForwardingObserver(Subscriber<T> delegate) {
+      this.delegate = delegate;
+    }
+
+    @Override public void onSuccess(T value) {
+      delegate.onNext(value);
+      delegate.onCompleted();
+    }
+
+    @Override public void onError(Throwable throwable) {
+      delegate.onError(throwable);
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleSchedulerTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleWithSchedulerTest.java
similarity index 72%
rename from retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleSchedulerTest.java
rename to retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleWithSchedulerTest.java
index 671370e02..5188c0ed9 100644
--- a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleSchedulerTest.java
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleWithSchedulerTest.java
@@ -24,11 +24,11 @@
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
 import rx.Single;
-import rx.observers.TestSubscriber;
 import rx.schedulers.TestScheduler;
 
-public final class SingleSchedulerTest {
+public final class SingleWithSchedulerTest {
   @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
 
   interface Service {
     @GET("/") Single<String> body();
@@ -51,36 +51,33 @@
   @Test public void bodyUsesScheduler() {
     server.enqueue(new MockResponse().setBody("Hi"));
 
-    TestSubscriber<String> subscriber = new TestSubscriber<>();
-    service.body().subscribe(subscriber);
-    subscriber.assertNoValues();
-    subscriber.assertNoTerminalEvent();
+    RecordingSubscriber<String> subscriber = subscriberRule.create();
+    service.body().unsafeSubscribe(subscriber);
+    subscriber.assertNoEvents();
 
     scheduler.triggerActions();
-    subscriber.assertValueCount(1);
+    subscriber.assertAnyValue().assertCompleted();
   }
 
   @Test public void responseUsesScheduler() {
     server.enqueue(new MockResponse().setBody("Hi"));
 
-    TestSubscriber<Response<String>> subscriber = new TestSubscriber<>();
-    service.response().subscribe(subscriber);
-    subscriber.assertNoValues();
-    subscriber.assertNoTerminalEvent();
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+    service.response().unsafeSubscribe(subscriber);
+    subscriber.assertNoEvents();
 
     scheduler.triggerActions();
-    subscriber.assertValueCount(1);
+    subscriber.assertAnyValue().assertCompleted();
   }
 
   @Test public void resultUsesScheduler() {
     server.enqueue(new MockResponse().setBody("Hi"));
 
-    TestSubscriber<Result<String>> subscriber = new TestSubscriber<>();
-    service.result().subscribe(subscriber);
-    subscriber.assertNoValues();
-    subscriber.assertNoTerminalEvent();
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+    service.result().unsafeSubscribe(subscriber);
+    subscriber.assertNoEvents();
 
     scheduler.triggerActions();
-    subscriber.assertValueCount(1);
+    subscriber.assertAnyValue().assertCompleted();
   }
 }
diff --git a/retrofit-adapters/rxjava2/README.md b/retrofit-adapters/rxjava2/README.md
new file mode 100644
index 000000000..0512f9fbb
--- /dev/null
+++ b/retrofit-adapters/rxjava2/README.md
@@ -0,0 +1,64 @@
+RxJava2 Adapter
+==============
+
+An `Adapter` for adapting [RxJava 2.x][1] types.
+
+Available types:
+
+ * `Observable<T>`, `Observable<Response<T>>`, and `Observable<Result<T>>` where `T` is the body type.
+ * `Flowable<T>`, `Flowable<Response<T>>` and `Flowable<Result<T>>` where `T` is the body type.
+ * `Single<T>`, `Single<Response<T>>`, and `Single<Result<T>>`  where `T` is the body type.
+ * `Maybe<T>`, `Maybe<Response<T>>`, and `Maybe<Result<T>>`  where `T` is the body type.
+ * `Completable` where response bodies are discarded.
+
+
+Usage
+-----
+
+Add `RxJava2CallAdapterFactory` as a `Call` adapter when building your `Retrofit` instance:
+```java
+Retrofit retrofit = new Retrofit.Builder()
+    .baseUrl("https://example.com/")
+    .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
+    .build();
+```
+
+Your service methods can now use any of the above types as their return type.
+```java
+interface MyService {
+  @GET("/user")
+  Observable<User> getUser();
+}
+```
+
+By default all reactive types execute their requests synchronously. There are multiple ways to
+control the threading on which a request occurs:
+
+ * Call `subscribeOn` on the returned reactive type with a `Scheduler` of your choice.
+ * Use `createAsync()` when creating the factory which will use OkHttp's internal thread pool.
+ * Use `createWithScheduler(Scheduler)` to supply a default subscription `Scheduler`.
+
+Download
+--------
+
+Download [the latest JAR][2] or grab via [Maven][3]:
+```xml
+<dependency>
+  <groupId>com.squareup.retrofit2</groupId>
+  <artifactId>adapter-rxjava2</artifactId>
+  <version>latest.version</version>
+</dependency>
+```
+or [Gradle][3]:
+```groovy
+compile 'com.squareup.retrofit2:adapter-rxjava2:latest.version'
+```
+
+Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
+
+
+
+ [1]: https://github.com/ReactiveX/RxJava/tree/2.x
+ [2]: https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=adapter-rxjava2&v=LATEST
+ [3]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup.retrofit2%22%20a%3A%22adapter-rxjava2%22
+ [snap]: https://oss.sonatype.org/content/repositories/snapshots/
diff --git a/retrofit-adapters/rxjava2/pom.xml b/retrofit-adapters/rxjava2/pom.xml
new file mode 100644
index 000000000..d9a14127c
--- /dev/null
+++ b/retrofit-adapters/rxjava2/pom.xml
@@ -0,0 +1,53 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.retrofit2</groupId>
+    <artifactId>retrofit-adapters</artifactId>
+    <version>2.4.0-SNAPSHOT</version>
+    <relativePath>../pom.xml</relativePath>
+  </parent>
+
+  <artifactId>adapter-rxjava2</artifactId>
+  <name>Adapter: RxJava 2</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>retrofit</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>io.reactivex.rxjava2</groupId>
+      <artifactId>rxjava</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.assertj</groupId>
+      <artifactId>assertj-core</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp3</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+</project>
diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/BodyObservable.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/BodyObservable.java
new file mode 100644
index 000000000..c3f475604
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/BodyObservable.java
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2016 Jake Wharton
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Observable;
+import io.reactivex.Observer;
+import io.reactivex.disposables.Disposable;
+import io.reactivex.exceptions.CompositeException;
+import io.reactivex.exceptions.Exceptions;
+import io.reactivex.plugins.RxJavaPlugins;
+import retrofit2.Response;
+
+final class BodyObservable<T> extends Observable<T> {
+  private final Observable<Response<T>> upstream;
+
+  BodyObservable(Observable<Response<T>> upstream) {
+    this.upstream = upstream;
+  }
+
+  @Override protected void subscribeActual(Observer<? super T> observer) {
+    upstream.subscribe(new BodyObserver<T>(observer));
+  }
+
+  private static class BodyObserver<R> implements Observer<Response<R>> {
+    private final Observer<? super R> observer;
+    private boolean terminated;
+
+    BodyObserver(Observer<? super R> observer) {
+      this.observer = observer;
+    }
+
+    @Override public void onSubscribe(Disposable disposable) {
+      observer.onSubscribe(disposable);
+    }
+
+    @Override public void onNext(Response<R> response) {
+      if (response.isSuccessful()) {
+        observer.onNext(response.body());
+      } else {
+        terminated = true;
+        Throwable t = new HttpException(response);
+        try {
+          observer.onError(t);
+        } catch (Throwable inner) {
+          Exceptions.throwIfFatal(inner);
+          RxJavaPlugins.onError(new CompositeException(t, inner));
+        }
+      }
+    }
+
+    @Override public void onComplete() {
+      if (!terminated) {
+        observer.onComplete();
+      }
+    }
+
+    @Override public void onError(Throwable throwable) {
+      if (!terminated) {
+        observer.onError(throwable);
+      } else {
+        // This should never happen! onNext handles and forwards errors automatically.
+        Throwable broken = new AssertionError(
+            "This should never happen! Report as a bug with the full stacktrace.");
+        //noinspection UnnecessaryInitCause Two-arg AssertionError constructor is 1.7+ only.
+        broken.initCause(throwable);
+        RxJavaPlugins.onError(broken);
+      }
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallEnqueueObservable.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallEnqueueObservable.java
new file mode 100644
index 000000000..aa5ca67a8
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallEnqueueObservable.java
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2016 Jake Wharton
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Observable;
+import io.reactivex.Observer;
+import io.reactivex.disposables.Disposable;
+import io.reactivex.exceptions.CompositeException;
+import io.reactivex.exceptions.Exceptions;
+import io.reactivex.plugins.RxJavaPlugins;
+import retrofit2.Call;
+import retrofit2.Callback;
+import retrofit2.Response;
+
+final class CallEnqueueObservable<T> extends Observable<Response<T>> {
+  private final Call<T> originalCall;
+
+  CallEnqueueObservable(Call<T> originalCall) {
+    this.originalCall = originalCall;
+  }
+
+  @Override protected void subscribeActual(Observer<? super Response<T>> observer) {
+    // Since Call is a one-shot type, clone it for each new observer.
+    Call<T> call = originalCall.clone();
+    CallCallback<T> callback = new CallCallback<>(call, observer);
+    observer.onSubscribe(callback);
+    call.enqueue(callback);
+  }
+
+  private static final class CallCallback<T> implements Disposable, Callback<T> {
+    private final Call<?> call;
+    private final Observer<? super Response<T>> observer;
+    boolean terminated = false;
+
+    CallCallback(Call<?> call, Observer<? super Response<T>> observer) {
+      this.call = call;
+      this.observer = observer;
+    }
+
+    @Override public void onResponse(Call<T> call, Response<T> response) {
+      if (call.isCanceled()) return;
+
+      try {
+        observer.onNext(response);
+
+        if (!call.isCanceled()) {
+          terminated = true;
+          observer.onComplete();
+        }
+      } catch (Throwable t) {
+        if (terminated) {
+          RxJavaPlugins.onError(t);
+        } else if (!call.isCanceled()) {
+          try {
+            observer.onError(t);
+          } catch (Throwable inner) {
+            Exceptions.throwIfFatal(inner);
+            RxJavaPlugins.onError(new CompositeException(t, inner));
+          }
+        }
+      }
+    }
+
+    @Override public void onFailure(Call<T> call, Throwable t) {
+      if (call.isCanceled()) return;
+
+      try {
+        observer.onError(t);
+      } catch (Throwable inner) {
+        Exceptions.throwIfFatal(inner);
+        RxJavaPlugins.onError(new CompositeException(t, inner));
+      }
+    }
+
+    @Override public void dispose() {
+      call.cancel();
+    }
+
+    @Override public boolean isDisposed() {
+      return call.isCanceled();
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallExecuteObservable.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallExecuteObservable.java
new file mode 100644
index 000000000..bf9453368
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallExecuteObservable.java
@@ -0,0 +1,79 @@
+/*
+ * Copyright (C) 2016 Jake Wharton
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Observable;
+import io.reactivex.Observer;
+import io.reactivex.disposables.Disposable;
+import io.reactivex.exceptions.CompositeException;
+import io.reactivex.exceptions.Exceptions;
+import io.reactivex.plugins.RxJavaPlugins;
+import retrofit2.Call;
+import retrofit2.Response;
+
+final class CallExecuteObservable<T> extends Observable<Response<T>> {
+  private final Call<T> originalCall;
+
+  CallExecuteObservable(Call<T> originalCall) {
+    this.originalCall = originalCall;
+  }
+
+  @Override protected void subscribeActual(Observer<? super Response<T>> observer) {
+    // Since Call is a one-shot type, clone it for each new observer.
+    Call<T> call = originalCall.clone();
+    observer.onSubscribe(new CallDisposable(call));
+
+    boolean terminated = false;
+    try {
+      Response<T> response = call.execute();
+      if (!call.isCanceled()) {
+        observer.onNext(response);
+      }
+      if (!call.isCanceled()) {
+        terminated = true;
+        observer.onComplete();
+      }
+    } catch (Throwable t) {
+      Exceptions.throwIfFatal(t);
+      if (terminated) {
+        RxJavaPlugins.onError(t);
+      } else if (!call.isCanceled()) {
+        try {
+          observer.onError(t);
+        } catch (Throwable inner) {
+          Exceptions.throwIfFatal(inner);
+          RxJavaPlugins.onError(new CompositeException(t, inner));
+        }
+      }
+    }
+  }
+
+  private static final class CallDisposable implements Disposable {
+    private final Call<?> call;
+
+    CallDisposable(Call<?> call) {
+      this.call = call;
+    }
+
+    @Override public void dispose() {
+      call.cancel();
+    }
+
+    @Override public boolean isDisposed() {
+      return call.isCanceled();
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/HttpException.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/HttpException.java
new file mode 100644
index 000000000..6e282e583
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/HttpException.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import retrofit2.Response;
+
+/** @deprecated Use {@link retrofit2.HttpException}. */
+@Deprecated
+public final class HttpException extends retrofit2.HttpException {
+  public HttpException(Response<?> response) {
+    super(response);
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/Result.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/Result.java
new file mode 100644
index 000000000..e43d7204f
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/Result.java
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import java.io.IOException;
+import javax.annotation.Nullable;
+import retrofit2.Response;
+
+/** The result of executing an HTTP request. */
+public final class Result<T> {
+  @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
+  public static <T> Result<T> error(Throwable error) {
+    if (error == null) throw new NullPointerException("error == null");
+    return new Result<>(null, error);
+  }
+
+  @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
+  public static <T> Result<T> response(Response<T> response) {
+    if (response == null) throw new NullPointerException("response == null");
+    return new Result<>(response, null);
+  }
+
+  private final @Nullable Response<T> response;
+  private final @Nullable Throwable error;
+
+  private Result(@Nullable Response<T> response, @Nullable Throwable error) {
+    this.response = response;
+    this.error = error;
+  }
+
+  /**
+   * The response received from executing an HTTP request. Only present when {@link #isError()} is
+   * false, null otherwise.
+   */
+  public @Nullable Response<T> response() {
+    return response;
+  }
+
+  /**
+   * The error experienced while attempting to execute an HTTP request. Only present when {@link
+   * #isError()} is true, null otherwise.
+   * <p>
+   * If the error is an {@link IOException} then there was a problem with the transport to the
+   * remote server. Any other exception type indicates an unexpected failure and should be
+   * considered fatal (configuration error, programming error, etc.).
+   */
+  public @Nullable Throwable error() {
+    return error;
+  }
+
+  /** {@code true} if the request resulted in an error. See {@link #error()} for the cause. */
+  public boolean isError() {
+    return error != null;
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/ResultObservable.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/ResultObservable.java
new file mode 100644
index 000000000..4fb08fbd0
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/ResultObservable.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2016 Jake Wharton
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Observable;
+import io.reactivex.Observer;
+import io.reactivex.disposables.Disposable;
+import io.reactivex.exceptions.CompositeException;
+import io.reactivex.exceptions.Exceptions;
+import io.reactivex.plugins.RxJavaPlugins;
+import retrofit2.Response;
+
+final class ResultObservable<T> extends Observable<Result<T>> {
+  private final Observable<Response<T>> upstream;
+
+  ResultObservable(Observable<Response<T>> upstream) {
+    this.upstream = upstream;
+  }
+
+  @Override protected void subscribeActual(Observer<? super Result<T>> observer) {
+    upstream.subscribe(new ResultObserver<T>(observer));
+  }
+
+  private static class ResultObserver<R> implements Observer<Response<R>> {
+    private final Observer<? super Result<R>> observer;
+
+    ResultObserver(Observer<? super Result<R>> observer) {
+      this.observer = observer;
+    }
+
+    @Override public void onSubscribe(Disposable disposable) {
+      observer.onSubscribe(disposable);
+    }
+
+    @Override public void onNext(Response<R> response) {
+      observer.onNext(Result.response(response));
+    }
+
+    @Override public void onError(Throwable throwable) {
+      try {
+        observer.onNext(Result.<R>error(throwable));
+      } catch (Throwable t) {
+        try {
+          observer.onError(t);
+        } catch (Throwable inner) {
+          Exceptions.throwIfFatal(inner);
+          RxJavaPlugins.onError(new CompositeException(t, inner));
+        }
+        return;
+      }
+      observer.onComplete();
+    }
+
+    @Override public void onComplete() {
+      observer.onComplete();
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapter.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapter.java
new file mode 100644
index 000000000..eccd30da3
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapter.java
@@ -0,0 +1,88 @@
+/*
+ * Copyright (C) 2016 Jake Wharton
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.BackpressureStrategy;
+import io.reactivex.Observable;
+import io.reactivex.Scheduler;
+import java.lang.reflect.Type;
+import javax.annotation.Nullable;
+import retrofit2.Call;
+import retrofit2.CallAdapter;
+import retrofit2.Response;
+
+final class RxJava2CallAdapter<R> implements CallAdapter<R, Object> {
+  private final Type responseType;
+  private final @Nullable Scheduler scheduler;
+  private final boolean isAsync;
+  private final boolean isResult;
+  private final boolean isBody;
+  private final boolean isFlowable;
+  private final boolean isSingle;
+  private final boolean isMaybe;
+  private final boolean isCompletable;
+
+  RxJava2CallAdapter(Type responseType, @Nullable Scheduler scheduler, boolean isAsync,
+      boolean isResult, boolean isBody, boolean isFlowable, boolean isSingle, boolean isMaybe,
+      boolean isCompletable) {
+    this.responseType = responseType;
+    this.scheduler = scheduler;
+    this.isAsync = isAsync;
+    this.isResult = isResult;
+    this.isBody = isBody;
+    this.isFlowable = isFlowable;
+    this.isSingle = isSingle;
+    this.isMaybe = isMaybe;
+    this.isCompletable = isCompletable;
+  }
+
+  @Override public Type responseType() {
+    return responseType;
+  }
+
+  @Override public Object adapt(Call<R> call) {
+    Observable<Response<R>> responseObservable = isAsync
+        ? new CallEnqueueObservable<>(call)
+        : new CallExecuteObservable<>(call);
+
+    Observable<?> observable;
+    if (isResult) {
+      observable = new ResultObservable<>(responseObservable);
+    } else if (isBody) {
+      observable = new BodyObservable<>(responseObservable);
+    } else {
+      observable = responseObservable;
+    }
+
+    if (scheduler != null) {
+      observable = observable.subscribeOn(scheduler);
+    }
+
+    if (isFlowable) {
+      return observable.toFlowable(BackpressureStrategy.LATEST);
+    }
+    if (isSingle) {
+      return observable.singleOrError();
+    }
+    if (isMaybe) {
+      return observable.singleElement();
+    }
+    if (isCompletable) {
+      return observable.ignoreElements();
+    }
+    return observable;
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactory.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactory.java
new file mode 100644
index 000000000..8af54c505
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactory.java
@@ -0,0 +1,145 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Completable;
+import io.reactivex.Flowable;
+import io.reactivex.Maybe;
+import io.reactivex.Observable;
+import io.reactivex.Scheduler;
+import io.reactivex.Single;
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import javax.annotation.Nullable;
+import retrofit2.CallAdapter;
+import retrofit2.HttpException;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+
+/**
+ * A {@linkplain CallAdapter.Factory call adapter} which uses RxJava 2 for creating observables.
+ * <p>
+ * Adding this class to {@link Retrofit} allows you to return an {@link Observable},
+ * {@link Flowable}, {@link Single}, {@link Completable} or {@link Maybe} from service methods.
+ * <pre><code>
+ * interface MyService {
+ *   &#64;GET("user/me")
+ *   Observable&lt;User&gt; getUser()
+ * }
+ * </code></pre>
+ * There are three configurations supported for the {@code Observable}, {@code Flowable},
+ * {@code Single}, {@link Completable} and {@code Maybe} type parameter:
+ * <ul>
+ * <li>Direct body (e.g., {@code Observable<User>}) calls {@code onNext} with the deserialized body
+ * for 2XX responses and calls {@code onError} with {@link HttpException} for non-2XX responses and
+ * {@link IOException} for network errors.</li>
+ * <li>Response wrapped body (e.g., {@code Observable<Response<User>>}) calls {@code onNext}
+ * with a {@link Response} object for all HTTP responses and calls {@code onError} with
+ * {@link IOException} for network errors</li>
+ * <li>Result wrapped body (e.g., {@code Observable<Result<User>>}) calls {@code onNext} with a
+ * {@link Result} object for all HTTP responses and errors.</li>
+ * </ul>
+ */
+public final class RxJava2CallAdapterFactory extends CallAdapter.Factory {
+  /**
+   * Returns an instance which creates synchronous observables that do not operate on any scheduler
+   * by default.
+   */
+  public static RxJava2CallAdapterFactory create() {
+    return new RxJava2CallAdapterFactory(null, false);
+  }
+
+  /**
+   * Returns an instance which creates asynchronous observables. Applying
+   * {@link Observable#subscribeOn} has no effect on stream types created by this factory.
+   */
+  public static RxJava2CallAdapterFactory createAsync() {
+    return new RxJava2CallAdapterFactory(null, true);
+  }
+
+  /**
+   * Returns an instance which creates synchronous observables that
+   * {@linkplain Observable#subscribeOn(Scheduler) subscribe on} {@code scheduler} by default.
+   */
+  @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
+  public static RxJava2CallAdapterFactory createWithScheduler(Scheduler scheduler) {
+    if (scheduler == null) throw new NullPointerException("scheduler == null");
+    return new RxJava2CallAdapterFactory(scheduler, false);
+  }
+
+  private final @Nullable Scheduler scheduler;
+  private final boolean isAsync;
+
+  private RxJava2CallAdapterFactory(@Nullable Scheduler scheduler, boolean isAsync) {
+    this.scheduler = scheduler;
+    this.isAsync = isAsync;
+  }
+
+  @Override
+  public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+    Class<?> rawType = getRawType(returnType);
+
+    if (rawType == Completable.class) {
+      // Completable is not parameterized (which is what the rest of this method deals with) so it
+      // can only be created with a single configuration.
+      return new RxJava2CallAdapter(Void.class, scheduler, isAsync, false, true, false, false,
+          false, true);
+    }
+
+    boolean isFlowable = rawType == Flowable.class;
+    boolean isSingle = rawType == Single.class;
+    boolean isMaybe = rawType == Maybe.class;
+    if (rawType != Observable.class && !isFlowable && !isSingle && !isMaybe) {
+      return null;
+    }
+
+    boolean isResult = false;
+    boolean isBody = false;
+    Type responseType;
+    if (!(returnType instanceof ParameterizedType)) {
+      String name = isFlowable ? "Flowable"
+          : isSingle ? "Single"
+          : isMaybe ? "Maybe" : "Observable";
+      throw new IllegalStateException(name + " return type must be parameterized"
+          + " as " + name + "<Foo> or " + name + "<? extends Foo>");
+    }
+
+    Type observableType = getParameterUpperBound(0, (ParameterizedType) returnType);
+    Class<?> rawObservableType = getRawType(observableType);
+    if (rawObservableType == Response.class) {
+      if (!(observableType instanceof ParameterizedType)) {
+        throw new IllegalStateException("Response must be parameterized"
+            + " as Response<Foo> or Response<? extends Foo>");
+      }
+      responseType = getParameterUpperBound(0, (ParameterizedType) observableType);
+    } else if (rawObservableType == Result.class) {
+      if (!(observableType instanceof ParameterizedType)) {
+        throw new IllegalStateException("Result must be parameterized"
+            + " as Result<Foo> or Result<? extends Foo>");
+      }
+      responseType = getParameterUpperBound(0, (ParameterizedType) observableType);
+      isResult = true;
+    } else {
+      responseType = observableType;
+      isBody = true;
+    }
+
+    return new RxJava2CallAdapter(responseType, scheduler, isAsync, isResult, isBody, isFlowable,
+        isSingle, isMaybe, false);
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/package-info.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/package-info.java
new file mode 100644
index 000000000..c5fc01992
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/package-info.java
@@ -0,0 +1,4 @@
+@ParametersAreNonnullByDefault
+package retrofit2.adapter.rxjava2;
+
+import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/AsyncTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/AsyncTest.java
new file mode 100644
index 000000000..d008a5e70
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/AsyncTest.java
@@ -0,0 +1,133 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Completable;
+import io.reactivex.exceptions.CompositeException;
+import io.reactivex.exceptions.Exceptions;
+import io.reactivex.functions.Consumer;
+import io.reactivex.observers.TestObserver;
+import io.reactivex.plugins.RxJavaPlugins;
+import java.io.IOException;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Retrofit;
+import retrofit2.adapter.rxjava2.CompletableThrowingTest.ForwardingCompletableObserver;
+import retrofit2.http.GET;
+
+import static java.util.concurrent.TimeUnit.SECONDS;
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertFalse;
+
+public final class AsyncTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  interface Service {
+    @GET("/") Completable completable();
+  }
+
+  private Service service;
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addCallAdapterFactory(RxJava2CallAdapterFactory.createAsync())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void success() throws InterruptedException {
+    TestObserver<Void> observer = new TestObserver<>();
+    service.completable().subscribe(observer);
+    assertFalse(observer.await(1, SECONDS));
+
+    server.enqueue(new MockResponse());
+    observer.awaitTerminalEvent(1, SECONDS);
+    observer.assertComplete();
+  }
+
+
+  @Test public void failure() throws InterruptedException {
+    TestObserver<Void> observer = new TestObserver<>();
+    service.completable().subscribe(observer);
+    assertFalse(observer.await(1, SECONDS));
+
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+    observer.awaitTerminalEvent(1, SECONDS);
+    observer.assertError(IOException.class);
+  }
+
+  @Test public void throwingInOnCompleteDeliveredToPlugin() throws InterruptedException {
+    server.enqueue(new MockResponse());
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!errorRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+        latch.countDown();
+      }
+    });
+
+    TestObserver<Void> observer = new TestObserver<>();
+    final RuntimeException e = new RuntimeException();
+    service.completable().subscribe(new ForwardingCompletableObserver(observer) {
+      @Override public void onComplete() {
+        throw e;
+      }
+    });
+
+    latch.await(1, SECONDS);
+    assertThat(errorRef.get()).isSameAs(e);
+  }
+
+  @Test public void bodyThrowingInOnErrorDeliveredToPlugin() throws InterruptedException {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!pluginRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+        latch.countDown();
+      }
+    });
+
+    TestObserver<Void> observer = new TestObserver<>();
+    final RuntimeException e = new RuntimeException();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    service.completable().subscribe(new ForwardingCompletableObserver(observer) {
+      @Override public void onError(Throwable throwable) {
+        errorRef.set(throwable);
+        throw e;
+      }
+    });
+
+    latch.await(1, SECONDS);
+    //noinspection ThrowableResultOfMethodCallIgnored
+    CompositeException composite = (CompositeException) pluginRef.get();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CompletableTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CompletableTest.java
new file mode 100644
index 000000000..999cf31bd
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CompletableTest.java
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Completable;
+import java.io.IOException;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+
+public final class CompletableTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final RecordingCompletableObserver.Rule observerRule =
+      new RecordingCompletableObserver.Rule();
+
+  interface Service {
+    @GET("/") Completable completable();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void completableSuccess200() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingCompletableObserver observer = observerRule.create();
+    service.completable().subscribe(observer);
+    observer.assertComplete();
+  }
+
+  @Test public void completableSuccess404() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    RecordingCompletableObserver observer = observerRule.create();
+    service.completable().subscribe(observer);
+    // Required for backwards compatibility.
+    observer.assertError(HttpException.class, "HTTP 404 Client Error");
+  }
+
+  @Test public void completableFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    RecordingCompletableObserver observer = observerRule.create();
+    service.completable().subscribe(observer);
+    observer.assertError(IOException.class);
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CompletableThrowingTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CompletableThrowingTest.java
new file mode 100644
index 000000000..6c558b029
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CompletableThrowingTest.java
@@ -0,0 +1,126 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Completable;
+import io.reactivex.CompletableObserver;
+import io.reactivex.disposables.Disposable;
+import io.reactivex.exceptions.CompositeException;
+import io.reactivex.exceptions.Exceptions;
+import io.reactivex.functions.Consumer;
+import io.reactivex.plugins.RxJavaPlugins;
+import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class CompletableThrowingTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final TestRule resetRule = new RxJavaPluginsResetRule();
+  @Rule public final RecordingCompletableObserver.Rule observerRule =
+      new RecordingCompletableObserver.Rule();
+
+  interface Service {
+    @GET("/") Completable completable();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void throwingInOnCompleteDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!errorRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+      }
+    });
+
+    RecordingCompletableObserver observer = observerRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.completable().subscribe(new ForwardingCompletableObserver(observer) {
+      @Override public void onComplete() {
+        throw e;
+      }
+    });
+
+    assertThat(errorRef.get()).isSameAs(e);
+  }
+
+  @Test public void bodyThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!pluginRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+      }
+    });
+
+    RecordingCompletableObserver observer = observerRule.create();
+    final RuntimeException e = new RuntimeException();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    service.completable().subscribe(new ForwardingCompletableObserver(observer) {
+      @Override public void onError(Throwable throwable) {
+        errorRef.set(throwable);
+        throw e;
+      }
+    });
+
+    //noinspection ThrowableResultOfMethodCallIgnored
+    CompositeException composite = (CompositeException) pluginRef.get();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+
+  static abstract class ForwardingCompletableObserver implements CompletableObserver {
+    private final CompletableObserver delegate;
+
+    ForwardingCompletableObserver(CompletableObserver delegate) {
+      this.delegate = delegate;
+    }
+
+    @Override public void onSubscribe(Disposable disposable) {
+      delegate.onSubscribe(disposable);
+    }
+
+    @Override public void onComplete() {
+      delegate.onComplete();
+    }
+
+    @Override public void onError(Throwable throwable) {
+      delegate.onError(throwable);
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CompletableWithSchedulerTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CompletableWithSchedulerTest.java
new file mode 100644
index 000000000..b4a4bc9a2
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CompletableWithSchedulerTest.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Completable;
+import io.reactivex.schedulers.TestScheduler;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+public final class CompletableWithSchedulerTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final RecordingCompletableObserver.Rule observerRule =
+      new RecordingCompletableObserver.Rule();
+
+  interface Service {
+    @GET("/") Completable completable();
+  }
+
+  private final TestScheduler scheduler = new TestScheduler();
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addCallAdapterFactory(RxJava2CallAdapterFactory.createWithScheduler(scheduler))
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void completableUsesScheduler() {
+    server.enqueue(new MockResponse());
+
+    RecordingCompletableObserver observer = observerRule.create();
+    service.completable().subscribe(observer);
+    observer.assertNoEvents();
+
+    scheduler.triggerActions();
+    observer.assertComplete();
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/FlowableTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/FlowableTest.java
new file mode 100644
index 000000000..22efcee2b
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/FlowableTest.java
@@ -0,0 +1,187 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Flowable;
+import java.io.IOException;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class FlowableTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
+
+  interface Service {
+    @GET("/") Flowable<String> body();
+    @GET("/") Flowable<Response<String>> response();
+    @GET("/") Flowable<Result<String>> result();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodySuccess200() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingSubscriber<String> subscriber = subscriberRule.create();
+    service.body().subscribe(subscriber);
+    subscriber.assertValue("Hi").assertComplete();
+  }
+
+  @Test public void bodySuccess404() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    RecordingSubscriber<String> subscriber = subscriberRule.create();
+    service.body().subscribe(subscriber);
+    // Required for backwards compatibility.
+    subscriber.assertError(HttpException.class, "HTTP 404 Client Error");
+  }
+
+  @Test public void bodyFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    RecordingSubscriber<String> subscriber = subscriberRule.create();
+    service.body().subscribe(subscriber);
+    subscriber.assertError(IOException.class);
+  }
+
+  @Test public void bodyRespectsBackpressure() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingSubscriber<String> subscriber = subscriberRule.createWithInitialRequest(0);
+    Flowable<String> o = service.body();
+
+    o.subscribe(subscriber);
+    assertThat(server.getRequestCount()).isEqualTo(1);
+    subscriber.assertNoEvents();
+
+    subscriber.request(1);
+    subscriber.assertAnyValue().assertComplete();
+
+    subscriber.request(Long.MAX_VALUE); // Subsequent requests do not trigger HTTP or notifications.
+    assertThat(server.getRequestCount()).isEqualTo(1);
+  }
+
+  @Test public void responseSuccess200() {
+    server.enqueue(new MockResponse());
+
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+    service.response().subscribe(subscriber);
+    assertThat(subscriber.takeValue().isSuccessful()).isTrue();
+    subscriber.assertComplete();
+  }
+
+  @Test public void responseSuccess404() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+    service.response().subscribe(subscriber);
+    assertThat(subscriber.takeValue().isSuccessful()).isFalse();
+    subscriber.assertComplete();
+  }
+
+  @Test public void responseFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+    service.response().subscribe(subscriber);
+    subscriber.assertError(IOException.class);
+  }
+
+  @Test public void responseRespectsBackpressure() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.createWithInitialRequest(0);
+    Flowable<Response<String>> o = service.response();
+
+    o.subscribe(subscriber);
+    assertThat(server.getRequestCount()).isEqualTo(1);
+    subscriber.assertNoEvents();
+
+    subscriber.request(1);
+    subscriber.assertAnyValue().assertComplete();
+
+    subscriber.request(Long.MAX_VALUE); // Subsequent requests do not trigger HTTP or notifications.
+    assertThat(server.getRequestCount()).isEqualTo(1);
+  }
+
+  @Test public void resultSuccess200() {
+    server.enqueue(new MockResponse());
+
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+    service.result().subscribe(subscriber);
+    Result<String> result = subscriber.takeValue();
+    assertThat(result.isError()).isFalse();
+    assertThat(result.response().isSuccessful()).isTrue();
+    subscriber.assertComplete();
+  }
+
+  @Test public void resultSuccess404() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+    service.result().subscribe(subscriber);
+    Result<String> result = subscriber.takeValue();
+    assertThat(result.isError()).isFalse();
+    assertThat(result.response().isSuccessful()).isFalse();
+    subscriber.assertComplete();
+  }
+
+  @Test public void resultFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+    service.result().subscribe(subscriber);
+    Result<String> result = subscriber.takeValue();
+    assertThat(result.isError()).isTrue();
+    assertThat(result.error()).isInstanceOf(IOException.class);
+    subscriber.assertComplete();
+  }
+
+  @Test public void resultRespectsBackpressure() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.createWithInitialRequest(0);
+    Flowable<Result<String>> o = service.result();
+
+    o.subscribe(subscriber);
+    assertThat(server.getRequestCount()).isEqualTo(1);
+    subscriber.assertNoEvents();
+
+    subscriber.request(1);
+    subscriber.assertAnyValue().assertComplete();
+
+    subscriber.request(Long.MAX_VALUE); // Subsequent requests do not trigger HTTP or notifications.
+    assertThat(server.getRequestCount()).isEqualTo(1);
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/FlowableThrowingTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/FlowableThrowingTest.java
new file mode 100644
index 000000000..34afbbeef
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/FlowableThrowingTest.java
@@ -0,0 +1,288 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Flowable;
+import io.reactivex.exceptions.CompositeException;
+import io.reactivex.exceptions.Exceptions;
+import io.reactivex.functions.Consumer;
+import io.reactivex.plugins.RxJavaPlugins;
+import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import org.reactivestreams.Subscriber;
+import org.reactivestreams.Subscription;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class FlowableThrowingTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final TestRule resetRule = new RxJavaPluginsResetRule();
+  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
+
+  interface Service {
+    @GET("/") Flowable<String> body();
+    @GET("/") Flowable<Response<String>> response();
+    @GET("/") Flowable<Result<String>> result();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodyThrowingInOnNextDeliveredToError() {
+    server.enqueue(new MockResponse());
+
+    RecordingSubscriber<String> subscriber = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.body().safeSubscribe(new ForwardingSubscriber<String>(subscriber) {
+      @Override public void onNext(String value) {
+        throw e;
+      }
+    });
+
+    subscriber.assertError(e);
+  }
+
+  @Test public void bodyThrowingInOnCompleteDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingSubscriber<String> subscriber = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.body().subscribe(new ForwardingSubscriber<String>(subscriber) {
+      @Override public void onComplete() {
+        throw e;
+      }
+    });
+
+    subscriber.assertAnyValue();
+    assertThat(throwableRef.get()).isSameAs(e);
+
+  }
+
+  @Test public void bodyThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingSubscriber<String> subscriber = subscriberRule.create();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    final RuntimeException e = new RuntimeException();
+    service.body().subscribe(new ForwardingSubscriber<String>(subscriber) {
+      @Override public void onError(Throwable throwable) {
+        if (!errorRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+        throw e;
+      }
+    });
+
+    //noinspection ThrowableResultOfMethodCallIgnored
+    CompositeException composite = (CompositeException) throwableRef.get();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+
+  @Test public void responseThrowingInOnNextDeliveredToError() {
+    server.enqueue(new MockResponse());
+
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.response().safeSubscribe(new ForwardingSubscriber<Response<String>>(subscriber) {
+      @Override public void onNext(Response<String> value) {
+        throw e;
+      }
+    });
+
+    subscriber.assertError(e);
+  }
+
+  @Test public void responseThrowingInOnCompleteDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.response().subscribe(new ForwardingSubscriber<Response<String>>(subscriber) {
+      @Override public void onComplete() {
+        throw e;
+      }
+    });
+
+    subscriber.assertAnyValue();
+    assertThat(throwableRef.get()).isSameAs(e);
+  }
+
+  @Test public void responseThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    final RuntimeException e = new RuntimeException();
+    service.response().subscribe(new ForwardingSubscriber<Response<String>>(subscriber) {
+      @Override public void onError(Throwable throwable) {
+        if (!errorRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+        throw e;
+      }
+    });
+
+    //noinspection ThrowableResultOfMethodCallIgnored
+    CompositeException composite = (CompositeException) throwableRef.get();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+
+  @Test public void resultThrowingInOnNextDeliveredToError() {
+    server.enqueue(new MockResponse());
+
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.result().safeSubscribe(new ForwardingSubscriber<Result<String>>(subscriber) {
+      @Override public void onNext(Result<String> value) {
+        throw e;
+      }
+    });
+
+    subscriber.assertError(e);
+  }
+
+  @Test public void resultThrowingInOnCompletedDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.result().subscribe(new ForwardingSubscriber<Result<String>>(subscriber) {
+      @Override public void onComplete() {
+        throw e;
+      }
+    });
+
+    subscriber.assertAnyValue();
+    assertThat(throwableRef.get()).isSameAs(e);
+  }
+
+  @Test public void resultThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+    final RuntimeException first = new RuntimeException();
+    final RuntimeException second = new RuntimeException();
+    service.result().safeSubscribe(new ForwardingSubscriber<Result<String>>(subscriber) {
+      @Override public void onNext(Result<String> value) {
+        // The only way to trigger onError for a result is if onNext throws.
+        throw first;
+      }
+
+      @Override public void onError(Throwable throwable) {
+        throw second;
+      }
+    });
+
+    //noinspection ThrowableResultOfMethodCallIgnored
+    CompositeException composite = (CompositeException) throwableRef.get();
+    assertThat(composite.getExceptions()).containsExactly(first, second);
+  }
+
+  private static abstract class ForwardingSubscriber<T> implements Subscriber<T> {
+    private final Subscriber<T> delegate;
+
+    ForwardingSubscriber(Subscriber<T> delegate) {
+      this.delegate = delegate;
+    }
+
+    @Override public void onSubscribe(Subscription subscription) {
+      delegate.onSubscribe(subscription);
+    }
+
+    @Override public void onNext(T value) {
+      delegate.onNext(value);
+    }
+
+    @Override public void onError(Throwable throwable) {
+      delegate.onError(throwable);
+    }
+
+    @Override public void onComplete() {
+      delegate.onComplete();
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/FlowableWithSchedulerTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/FlowableWithSchedulerTest.java
new file mode 100644
index 000000000..946ff51f1
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/FlowableWithSchedulerTest.java
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Flowable;
+import io.reactivex.schedulers.TestScheduler;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+public final class FlowableWithSchedulerTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
+
+  interface Service {
+    @GET("/") Flowable<String> body();
+    @GET("/") Flowable<Response<String>> response();
+    @GET("/") Flowable<Result<String>> result();
+  }
+
+  private final TestScheduler scheduler = new TestScheduler();
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJava2CallAdapterFactory.createWithScheduler(scheduler))
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodyUsesScheduler() {
+    server.enqueue(new MockResponse());
+
+    RecordingSubscriber<Object> subscriber = subscriberRule.create();
+    service.body().subscribe(subscriber);
+    subscriber.assertNoEvents();
+
+    scheduler.triggerActions();
+    subscriber.assertAnyValue().assertComplete();
+  }
+
+  @Test public void responseUsesScheduler() {
+    server.enqueue(new MockResponse());
+
+    RecordingSubscriber<Object> subscriber = subscriberRule.create();
+    service.response().subscribe(subscriber);
+    subscriber.assertNoEvents();
+
+    scheduler.triggerActions();
+    subscriber.assertAnyValue().assertComplete();
+  }
+
+  @Test public void resultUsesScheduler() {
+    server.enqueue(new MockResponse());
+
+    RecordingSubscriber<Object> subscriber = subscriberRule.create();
+    service.result().subscribe(subscriber);
+    subscriber.assertNoEvents();
+
+    scheduler.triggerActions();
+    subscriber.assertAnyValue().assertComplete();
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/MaybeTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/MaybeTest.java
new file mode 100644
index 000000000..21f69c68a
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/MaybeTest.java
@@ -0,0 +1,133 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Maybe;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+import java.io.IOException;
+
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class MaybeTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final RecordingMaybeObserver.Rule observerRule = new RecordingMaybeObserver.Rule();
+
+  interface Service {
+    @GET("/") Maybe<String> body();
+    @GET("/") Maybe<Response<String>> response();
+    @GET("/") Maybe<Result<String>> result();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodySuccess200() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingMaybeObserver<String> observer = observerRule.create();
+    service.body().subscribe(observer);
+    observer.assertValue("Hi");
+  }
+
+  @Test public void bodySuccess404() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    RecordingMaybeObserver<String> observer = observerRule.create();
+    service.body().subscribe(observer);
+    // Required for backwards compatibility.
+    observer.assertError(HttpException.class, "HTTP 404 Client Error");
+  }
+
+  @Test public void bodyFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    RecordingMaybeObserver<String> observer = observerRule.create();
+    service.body().subscribe(observer);
+    observer.assertError(IOException.class);
+  }
+
+  @Test public void responseSuccess200() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingMaybeObserver<Response<String>> observer = observerRule.create();
+    service.response().subscribe(observer);
+    Response<String> response = observer.takeValue();
+    assertThat(response.isSuccessful()).isTrue();
+  }
+
+  @Test public void responseSuccess404() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    RecordingMaybeObserver<Response<String>> observer = observerRule.create();
+    service.response().subscribe(observer);
+    assertThat(observer.takeValue().isSuccessful()).isFalse();
+  }
+
+  @Test public void responseFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    RecordingMaybeObserver<Response<String>> observer = observerRule.create();
+    service.response().subscribe(observer);
+    observer.assertError(IOException.class);
+  }
+
+  @Test public void resultSuccess200() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingMaybeObserver<Result<String>> observer = observerRule.create();
+    service.result().subscribe(observer);
+    Result<String> result = observer.takeValue();
+    assertThat(result.isError()).isFalse();
+    assertThat(result.response().isSuccessful()).isTrue();
+  }
+
+  @Test public void resultSuccess404() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    RecordingMaybeObserver<Result<String>> observer = observerRule.create();
+    service.result().subscribe(observer);
+    Result<String> result = observer.takeValue();
+    assertThat(result.isError()).isFalse();
+    assertThat(result.response().isSuccessful()).isFalse();
+  }
+
+  @Test public void resultFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    RecordingMaybeObserver<Result<String>> observer = observerRule.create();
+    service.result().subscribe(observer);
+    Result<String> result = observer.takeValue();
+    assertThat(result.isError()).isTrue();
+    assertThat(result.error()).isInstanceOf(IOException.class);
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/MaybeThrowingTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/MaybeThrowingTest.java
new file mode 100644
index 000000000..d5f83e1bd
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/MaybeThrowingTest.java
@@ -0,0 +1,245 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Maybe;
+import io.reactivex.MaybeObserver;
+import io.reactivex.disposables.Disposable;
+import io.reactivex.exceptions.CompositeException;
+import io.reactivex.exceptions.Exceptions;
+import io.reactivex.functions.Consumer;
+import io.reactivex.plugins.RxJavaPlugins;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+import java.util.concurrent.atomic.AtomicReference;
+
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class MaybeThrowingTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final TestRule resetRule = new RxJavaPluginsResetRule();
+  @Rule public final RecordingMaybeObserver.Rule subscriberRule = new RecordingMaybeObserver.Rule();
+
+  interface Service {
+    @GET("/") Maybe<String> body();
+    @GET("/") Maybe<Response<String>> response();
+    @GET("/") Maybe<Result<String>> result();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodyThrowingInOnSuccessDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingMaybeObserver<String> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.body().subscribe(new ForwardingObserver<String>(observer) {
+      @Override public void onSuccess(String value) {
+        throw e;
+      }
+    });
+
+    assertThat(throwableRef.get()).isSameAs(e);
+  }
+
+  @Test public void bodyThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingMaybeObserver<String> observer = subscriberRule.create();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    final RuntimeException e = new RuntimeException();
+    service.body().subscribe(new ForwardingObserver<String>(observer) {
+      @Override public void onError(Throwable throwable) {
+        if (!errorRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+        throw e;
+      }
+    });
+
+    //noinspection ThrowableResultOfMethodCallIgnored
+    CompositeException composite = (CompositeException) throwableRef.get();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+
+  @Test public void responseThrowingInOnSuccessDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingMaybeObserver<Response<String>> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.response().subscribe(new ForwardingObserver<Response<String>>(observer) {
+      @Override public void onSuccess(Response<String> value) {
+        throw e;
+      }
+    });
+
+    assertThat(throwableRef.get()).isSameAs(e);
+  }
+
+  @Test public void responseThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingMaybeObserver<Response<String>> observer = subscriberRule.create();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    final RuntimeException e = new RuntimeException();
+    service.response().subscribe(new ForwardingObserver<Response<String>>(observer) {
+      @Override public void onError(Throwable throwable) {
+        if (!errorRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+        throw e;
+      }
+    });
+
+    //noinspection ThrowableResultOfMethodCallIgnored
+    CompositeException composite = (CompositeException) throwableRef.get();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+
+  @Test public void resultThrowingInOnSuccessDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingMaybeObserver<Result<String>> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.result().subscribe(new ForwardingObserver<Result<String>>(observer) {
+      @Override public void onSuccess(Result<String> value) {
+        throw e;
+      }
+    });
+
+    assertThat(throwableRef.get()).isSameAs(e);
+  }
+
+  @Ignore("Single's contract is onNext|onError so we have no way of triggering this case")
+  @Test public void resultThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingMaybeObserver<Result<String>> observer = subscriberRule.create();
+    final RuntimeException first = new RuntimeException();
+    final RuntimeException second = new RuntimeException();
+    service.result().subscribe(new ForwardingObserver<Result<String>>(observer) {
+      @Override public void onSuccess(Result<String> value) {
+        // The only way to trigger onError for Result is if onSuccess throws.
+        throw first;
+      }
+
+      @Override public void onError(Throwable throwable) {
+        throw second;
+      }
+    });
+
+    //noinspection ThrowableResultOfMethodCallIgnored
+    CompositeException composite = (CompositeException) throwableRef.get();
+    assertThat(composite.getExceptions()).containsExactly(first, second);
+  }
+
+  private static abstract class ForwardingObserver<T> implements MaybeObserver<T> {
+    private final MaybeObserver<T> delegate;
+
+    ForwardingObserver(MaybeObserver<T> delegate) {
+      this.delegate = delegate;
+    }
+
+    @Override public void onSubscribe(Disposable disposable) {
+      delegate.onSubscribe(disposable);
+    }
+
+    @Override public void onSuccess(T value) {
+      delegate.onSuccess(value);
+    }
+
+    @Override public void onError(Throwable throwable) {
+      delegate.onError(throwable);
+    }
+
+    @Override public void onComplete() {
+      delegate.onComplete();
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/MaybeWithSchedulerTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/MaybeWithSchedulerTest.java
new file mode 100644
index 000000000..53fe60d94
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/MaybeWithSchedulerTest.java
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Maybe;
+import io.reactivex.schedulers.TestScheduler;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+public final class MaybeWithSchedulerTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final RecordingMaybeObserver.Rule observerRule = new RecordingMaybeObserver.Rule();
+
+  interface Service {
+    @GET("/") Maybe<String> body();
+    @GET("/") Maybe<Response<String>> response();
+    @GET("/") Maybe<Result<String>> result();
+  }
+
+  private final TestScheduler scheduler = new TestScheduler();
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJava2CallAdapterFactory.createWithScheduler(scheduler))
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodyUsesScheduler() {
+    server.enqueue(new MockResponse());
+
+    RecordingMaybeObserver<Object> observer = observerRule.create();
+    service.body().subscribe(observer);
+    observer.assertNoEvents();
+
+    scheduler.triggerActions();
+    observer.assertAnyValue();
+  }
+
+  @Test public void responseUsesScheduler() {
+    server.enqueue(new MockResponse());
+
+    RecordingMaybeObserver<Object> observer = observerRule.create();
+    service.response().subscribe(observer);
+    observer.assertNoEvents();
+
+    scheduler.triggerActions();
+    observer.assertAnyValue();
+  }
+
+  @Test public void resultUsesScheduler() {
+    server.enqueue(new MockResponse());
+
+    RecordingMaybeObserver<Object> observer = observerRule.create();
+    service.result().subscribe(observer);
+    observer.assertNoEvents();
+
+    scheduler.triggerActions();
+    observer.assertAnyValue();
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ObservableTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ObservableTest.java
new file mode 100644
index 000000000..e421c1652
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ObservableTest.java
@@ -0,0 +1,136 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Observable;
+import java.io.IOException;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class ObservableTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final RecordingObserver.Rule observerRule = new RecordingObserver.Rule();
+
+  interface Service {
+    @GET("/") Observable<String> body();
+    @GET("/") Observable<Response<String>> response();
+    @GET("/") Observable<Result<String>> result();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodySuccess200() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingObserver<String> observer = observerRule.create();
+    service.body().subscribe(observer);
+    observer.assertValue("Hi").assertComplete();
+  }
+
+  @Test public void bodySuccess404() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    RecordingObserver<String> observer = observerRule.create();
+    service.body().subscribe(observer);
+    // Required for backwards compatibility.
+    observer.assertError(HttpException.class, "HTTP 404 Client Error");
+  }
+
+  @Test public void bodyFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    RecordingObserver<String> observer = observerRule.create();
+    service.body().subscribe(observer);
+    observer.assertError(IOException.class);
+  }
+
+  @Test public void responseSuccess200() {
+    server.enqueue(new MockResponse());
+
+    RecordingObserver<Response<String>> observer = observerRule.create();
+    service.response().subscribe(observer);
+    assertThat(observer.takeValue().isSuccessful()).isTrue();
+    observer.assertComplete();
+  }
+
+  @Test public void responseSuccess404() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    RecordingObserver<Response<String>> observer = observerRule.create();
+    service.response().subscribe(observer);
+    assertThat(observer.takeValue().isSuccessful()).isFalse();
+    observer.assertComplete();
+  }
+
+  @Test public void responseFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    RecordingObserver<Response<String>> observer = observerRule.create();
+    service.response().subscribe(observer);
+    observer.assertError(IOException.class);
+  }
+
+  @Test public void resultSuccess200() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingObserver<Result<String>> observer = observerRule.create();
+    service.result().subscribe(observer);
+    Result<String> result = observer.takeValue();
+    assertThat(result.isError()).isFalse();
+    assertThat(result.response().isSuccessful()).isTrue();
+    observer.assertComplete();
+  }
+
+  @Test public void resultSuccess404() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    RecordingObserver<Result<String>> observer = observerRule.create();
+    service.result().subscribe(observer);
+    Result<String> result = observer.takeValue();
+    assertThat(result.isError()).isFalse();
+    assertThat(result.response().isSuccessful()).isFalse();
+    observer.assertComplete();
+  }
+
+  @Test public void resultFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    RecordingObserver<Result<String>> observer = observerRule.create();
+    service.result().subscribe(observer);
+    Result<String> result = observer.takeValue();
+    assertThat(result.isError()).isTrue();
+    assertThat(result.error()).isInstanceOf(IOException.class);
+    observer.assertComplete();
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ObservableThrowingTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ObservableThrowingTest.java
new file mode 100644
index 000000000..05c1d4f8f
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ObservableThrowingTest.java
@@ -0,0 +1,288 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Observable;
+import io.reactivex.Observer;
+import io.reactivex.disposables.Disposable;
+import io.reactivex.exceptions.CompositeException;
+import io.reactivex.exceptions.Exceptions;
+import io.reactivex.functions.Consumer;
+import io.reactivex.plugins.RxJavaPlugins;
+import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class ObservableThrowingTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final TestRule resetRule = new RxJavaPluginsResetRule();
+  @Rule public final RecordingObserver.Rule subscriberRule = new RecordingObserver.Rule();
+
+  interface Service {
+    @GET("/") Observable<String> body();
+    @GET("/") Observable<Response<String>> response();
+    @GET("/") Observable<Result<String>> result();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodyThrowingInOnNextDeliveredToError() {
+    server.enqueue(new MockResponse());
+
+    RecordingObserver<String> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.body().subscribe(new ForwardingObserver<String>(observer) {
+      @Override public void onNext(String value) {
+        throw e;
+      }
+    });
+
+    observer.assertError(e);
+  }
+
+  @Test public void bodyThrowingInOnCompleteDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingObserver<String> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.body().subscribe(new ForwardingObserver<String>(observer) {
+      @Override public void onComplete() {
+        throw e;
+      }
+    });
+
+    observer.assertAnyValue();
+    assertThat(throwableRef.get()).isSameAs(e);
+
+  }
+
+  @Test public void bodyThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingObserver<String> observer = subscriberRule.create();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    final RuntimeException e = new RuntimeException();
+    service.body().subscribe(new ForwardingObserver<String>(observer) {
+      @Override public void onError(Throwable throwable) {
+        if (!errorRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+        throw e;
+      }
+    });
+
+    //noinspection ThrowableResultOfMethodCallIgnored
+    CompositeException composite = (CompositeException) throwableRef.get();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+
+  @Test public void responseThrowingInOnNextDeliveredToError() {
+    server.enqueue(new MockResponse());
+
+    RecordingObserver<Response<String>> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.response().subscribe(new ForwardingObserver<Response<String>>(observer) {
+      @Override public void onNext(Response<String> value) {
+        throw e;
+      }
+    });
+
+    observer.assertError(e);
+  }
+
+  @Test public void responseThrowingInOnCompleteDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingObserver<Response<String>> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.response().subscribe(new ForwardingObserver<Response<String>>(observer) {
+      @Override public void onComplete() {
+        throw e;
+      }
+    });
+
+    observer.assertAnyValue();
+    assertThat(throwableRef.get()).isSameAs(e);
+  }
+
+  @Test public void responseThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingObserver<Response<String>> observer = subscriberRule.create();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    final RuntimeException e = new RuntimeException();
+    service.response().subscribe(new ForwardingObserver<Response<String>>(observer) {
+      @Override public void onError(Throwable throwable) {
+        if (!errorRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+        throw e;
+      }
+    });
+
+    //noinspection ThrowableResultOfMethodCallIgnored
+    CompositeException composite = (CompositeException) throwableRef.get();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+
+  @Test public void resultThrowingInOnNextDeliveredToError() {
+    server.enqueue(new MockResponse());
+
+    RecordingObserver<Result<String>> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.result().subscribe(new ForwardingObserver<Result<String>>(observer) {
+      @Override public void onNext(Result<String> value) {
+        throw e;
+      }
+    });
+
+    observer.assertError(e);
+  }
+
+  @Test public void resultThrowingInOnCompletedDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingObserver<Result<String>> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.result().subscribe(new ForwardingObserver<Result<String>>(observer) {
+      @Override public void onComplete() {
+        throw e;
+      }
+    });
+
+    observer.assertAnyValue();
+    assertThat(throwableRef.get()).isSameAs(e);
+  }
+
+  @Test public void resultThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingObserver<Result<String>> observer = subscriberRule.create();
+    final RuntimeException first = new RuntimeException();
+    final RuntimeException second = new RuntimeException();
+    service.result().subscribe(new ForwardingObserver<Result<String>>(observer) {
+      @Override public void onNext(Result<String> value) {
+        // The only way to trigger onError for a result is if onNext throws.
+        throw first;
+      }
+
+      @Override public void onError(Throwable throwable) {
+        throw second;
+      }
+    });
+
+    //noinspection ThrowableResultOfMethodCallIgnored
+    CompositeException composite = (CompositeException) throwableRef.get();
+    assertThat(composite.getExceptions()).containsExactly(first, second);
+  }
+
+  private static abstract class ForwardingObserver<T> implements Observer<T> {
+    private final Observer<T> delegate;
+
+    ForwardingObserver(Observer<T> delegate) {
+      this.delegate = delegate;
+    }
+
+    @Override public void onSubscribe(Disposable disposable) {
+      delegate.onSubscribe(disposable);
+    }
+
+    @Override public void onNext(T value) {
+      delegate.onNext(value);
+    }
+
+    @Override public void onError(Throwable throwable) {
+      delegate.onError(throwable);
+    }
+
+    @Override public void onComplete() {
+      delegate.onComplete();
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ObservableWithSchedulerTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ObservableWithSchedulerTest.java
new file mode 100644
index 000000000..2379f2835
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ObservableWithSchedulerTest.java
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Observable;
+import io.reactivex.schedulers.TestScheduler;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+public final class ObservableWithSchedulerTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final RecordingObserver.Rule observerRule = new RecordingObserver.Rule();
+
+  interface Service {
+    @GET("/") Observable<String> body();
+    @GET("/") Observable<Response<String>> response();
+    @GET("/") Observable<Result<String>> result();
+  }
+
+  private final TestScheduler scheduler = new TestScheduler();
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJava2CallAdapterFactory.createWithScheduler(scheduler))
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodyUsesScheduler() {
+    server.enqueue(new MockResponse());
+
+    RecordingObserver<Object> observer = observerRule.create();
+    service.body().subscribe(observer);
+    observer.assertNoEvents();
+
+    scheduler.triggerActions();
+    observer.assertAnyValue().assertComplete();
+  }
+
+  @Test public void responseUsesScheduler() {
+    server.enqueue(new MockResponse());
+
+    RecordingObserver<Object> observer = observerRule.create();
+    service.response().subscribe(observer);
+    observer.assertNoEvents();
+
+    scheduler.triggerActions();
+    observer.assertAnyValue().assertComplete();
+  }
+
+  @Test public void resultUsesScheduler() {
+    server.enqueue(new MockResponse());
+
+    RecordingObserver<Object> observer = observerRule.create();
+    service.result().subscribe(observer);
+    observer.assertNoEvents();
+
+    scheduler.triggerActions();
+    observer.assertAnyValue().assertComplete();
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RecordingCompletableObserver.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RecordingCompletableObserver.java
new file mode 100644
index 000000000..de7c93055
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RecordingCompletableObserver.java
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.CompletableObserver;
+import io.reactivex.Notification;
+import io.reactivex.disposables.Disposable;
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Deque;
+import java.util.List;
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+/** A test {@link CompletableObserver} and JUnit rule which guarantees all events are asserted. */
+final class RecordingCompletableObserver implements CompletableObserver {
+  private final Deque<Notification<?>> events = new ArrayDeque<>();
+
+  private RecordingCompletableObserver() {
+  }
+
+  @Override public void onSubscribe(Disposable disposable) {
+  }
+
+  @Override public void onComplete() {
+    events.add(Notification.createOnComplete());
+  }
+
+  @Override public void onError(Throwable e) {
+    events.add(Notification.createOnError(e));
+  }
+
+  private Notification<?> takeNotification() {
+    Notification<?> notification = events.pollFirst();
+    if (notification == null) {
+      throw new AssertionError("No event found!");
+    }
+    return notification;
+  }
+
+  public Throwable takeError() {
+    Notification<?> notification = takeNotification();
+    assertThat(notification.isOnError())
+        .as("Expected onError event but was " + notification)
+        .isTrue();
+    return notification.getError();
+  }
+
+  public void assertComplete() {
+    Notification<?> notification = takeNotification();
+    assertThat(notification.isOnComplete())
+        .as("Expected onCompleted event but was " + notification)
+        .isTrue();
+    assertNoEvents();
+  }
+
+  public void assertError(Throwable throwable) {
+    assertThat(takeError()).isEqualTo(throwable);
+  }
+
+  public void assertError(Class<? extends Throwable> errorClass) {
+    assertError(errorClass, null);
+  }
+
+  public void assertError(Class<? extends Throwable> errorClass, String message) {
+    Throwable throwable = takeError();
+    assertThat(throwable).isInstanceOf(errorClass);
+    if (message != null) {
+      assertThat(throwable).hasMessage(message);
+    }
+    assertNoEvents();
+  }
+
+  public void assertNoEvents() {
+    assertThat(events).as("Unconsumed events found!").isEmpty();
+  }
+
+  public static final class Rule implements TestRule {
+    final List<RecordingCompletableObserver> subscribers = new ArrayList<>();
+
+    public <T> RecordingCompletableObserver create() {
+      RecordingCompletableObserver subscriber = new RecordingCompletableObserver();
+      subscribers.add(subscriber);
+      return subscriber;
+    }
+
+    @Override public Statement apply(final Statement base, Description description) {
+      return new Statement() {
+        @Override public void evaluate() throws Throwable {
+          base.evaluate();
+          for (RecordingCompletableObserver subscriber : subscribers) {
+            subscriber.assertNoEvents();
+          }
+        }
+      };
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RecordingMaybeObserver.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RecordingMaybeObserver.java
new file mode 100644
index 000000000..63d34499f
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RecordingMaybeObserver.java
@@ -0,0 +1,130 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.MaybeObserver;
+import io.reactivex.Notification;
+import io.reactivex.Observer;
+import io.reactivex.disposables.Disposable;
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Deque;
+import java.util.List;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+/** A test {@link Observer} and JUnit rule which guarantees all events are asserted. */
+final class RecordingMaybeObserver<T> implements MaybeObserver<T> {
+  private final Deque<Notification<T>> events = new ArrayDeque<>();
+
+  private RecordingMaybeObserver() {
+  }
+
+  @Override public void onSubscribe(Disposable disposable) {
+  }
+
+  @Override public void onSuccess(T value) {
+    events.add(Notification.createOnNext(value));
+  }
+
+  @Override public void onError(Throwable e) {
+    events.add(Notification.<T>createOnError(e));
+  }
+
+  @Override public void onComplete() {
+    events.add(Notification.<T>createOnComplete());
+  }
+
+  private Notification<T> takeNotification() {
+    Notification<T> notification = events.pollFirst();
+    if (notification == null) {
+      throw new AssertionError("No event found!");
+    }
+    return notification;
+  }
+
+  public T takeValue() {
+    Notification<T> notification = takeNotification();
+    assertThat(notification.isOnNext())
+        .as("Expected onNext event but was " + notification)
+        .isTrue();
+    return notification.getValue();
+  }
+
+  public Throwable takeError() {
+    Notification<T> notification = takeNotification();
+    assertThat(notification.isOnError())
+        .as("Expected onError event but was " + notification)
+        .isTrue();
+    return notification.getError();
+  }
+
+  public RecordingMaybeObserver<T> assertAnyValue() {
+    takeValue();
+    return this;
+  }
+
+  public RecordingMaybeObserver<T> assertValue(T value) {
+    assertThat(takeValue()).isEqualTo(value);
+    return this;
+  }
+
+  public void assertError(Throwable throwable) {
+    assertThat(takeError()).isEqualTo(throwable);
+  }
+
+  public void assertError(Class<? extends Throwable> errorClass) {
+    assertError(errorClass, null);
+  }
+
+  public void assertError(Class<? extends Throwable> errorClass, String message) {
+    Throwable throwable = takeError();
+    assertThat(throwable).isInstanceOf(errorClass);
+    if (message != null) {
+      assertThat(throwable).hasMessage(message);
+    }
+    assertNoEvents();
+  }
+
+  public void assertNoEvents() {
+    assertThat(events).as("Unconsumed events found!").isEmpty();
+  }
+
+  public static final class Rule implements TestRule {
+    final List<RecordingMaybeObserver<?>> subscribers = new ArrayList<>();
+
+    public <T> RecordingMaybeObserver<T> create() {
+      RecordingMaybeObserver<T> subscriber = new RecordingMaybeObserver<>();
+      subscribers.add(subscriber);
+      return subscriber;
+    }
+
+    @Override public Statement apply(final Statement base, Description description) {
+      return new Statement() {
+        @Override public void evaluate() throws Throwable {
+          base.evaluate();
+          for (RecordingMaybeObserver<?> subscriber : subscribers) {
+            subscriber.assertNoEvents();
+          }
+        }
+      };
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RecordingObserver.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RecordingObserver.java
new file mode 100644
index 000000000..033111ff4
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RecordingObserver.java
@@ -0,0 +1,136 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Notification;
+import io.reactivex.Observer;
+import io.reactivex.disposables.Disposable;
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Deque;
+import java.util.List;
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+/** A test {@link Observer} and JUnit rule which guarantees all events are asserted. */
+final class RecordingObserver<T> implements Observer<T> {
+  private final Deque<Notification<T>> events = new ArrayDeque<>();
+
+  private RecordingObserver() {
+  }
+
+  @Override public void onSubscribe(Disposable disposable) {
+  }
+
+  @Override public void onNext(T value) {
+    events.add(Notification.createOnNext(value));
+  }
+
+  @Override public void onComplete() {
+    events.add(Notification.<T>createOnComplete());
+  }
+
+  @Override public void onError(Throwable e) {
+    events.add(Notification.<T>createOnError(e));
+  }
+
+  private Notification<T> takeNotification() {
+    Notification<T> notification = events.pollFirst();
+    if (notification == null) {
+      throw new AssertionError("No event found!");
+    }
+    return notification;
+  }
+
+  public T takeValue() {
+    Notification<T> notification = takeNotification();
+    assertThat(notification.isOnNext())
+        .as("Expected onNext event but was " + notification)
+        .isTrue();
+    return notification.getValue();
+  }
+
+  public Throwable takeError() {
+    Notification<T> notification = takeNotification();
+    assertThat(notification.isOnError())
+        .as("Expected onError event but was " + notification)
+        .isTrue();
+    return notification.getError();
+  }
+
+  public RecordingObserver<T> assertAnyValue() {
+    takeValue();
+    return this;
+  }
+
+  public RecordingObserver<T> assertValue(T value) {
+    assertThat(takeValue()).isEqualTo(value);
+    return this;
+  }
+
+  public void assertComplete() {
+    Notification<T> notification = takeNotification();
+    assertThat(notification.isOnComplete())
+        .as("Expected onCompleted event but was " + notification)
+        .isTrue();
+    assertNoEvents();
+  }
+
+  public void assertError(Throwable throwable) {
+    assertThat(takeError()).isEqualTo(throwable);
+  }
+
+  public void assertError(Class<? extends Throwable> errorClass) {
+    assertError(errorClass, null);
+  }
+
+  public void assertError(Class<? extends Throwable> errorClass, String message) {
+    Throwable throwable = takeError();
+    assertThat(throwable).isInstanceOf(errorClass);
+    if (message != null) {
+      assertThat(throwable).hasMessage(message);
+    }
+    assertNoEvents();
+  }
+
+  public void assertNoEvents() {
+    assertThat(events).as("Unconsumed events found!").isEmpty();
+  }
+
+  public static final class Rule implements TestRule {
+    final List<RecordingObserver<?>> subscribers = new ArrayList<>();
+
+    public <T> RecordingObserver<T> create() {
+      RecordingObserver<T> subscriber = new RecordingObserver<>();
+      subscribers.add(subscriber);
+      return subscriber;
+    }
+
+    @Override public Statement apply(final Statement base, Description description) {
+      return new Statement() {
+        @Override public void evaluate() throws Throwable {
+          base.evaluate();
+          for (RecordingObserver<?> subscriber : subscribers) {
+            subscriber.assertNoEvents();
+          }
+        }
+      };
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RecordingSingleObserver.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RecordingSingleObserver.java
new file mode 100644
index 000000000..6c7b61f77
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RecordingSingleObserver.java
@@ -0,0 +1,125 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Notification;
+import io.reactivex.Observer;
+import io.reactivex.SingleObserver;
+import io.reactivex.disposables.Disposable;
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Deque;
+import java.util.List;
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+/** A test {@link Observer} and JUnit rule which guarantees all events are asserted. */
+final class RecordingSingleObserver<T> implements SingleObserver<T> {
+  private final Deque<Notification<T>> events = new ArrayDeque<>();
+
+  private RecordingSingleObserver() {
+  }
+
+  @Override public void onSubscribe(Disposable disposable) {
+  }
+
+  @Override public void onSuccess(T value) {
+    events.add(Notification.createOnNext(value));
+  }
+
+  @Override public void onError(Throwable e) {
+    events.add(Notification.<T>createOnError(e));
+  }
+
+  private Notification<T> takeNotification() {
+    Notification<T> notification = events.pollFirst();
+    if (notification == null) {
+      throw new AssertionError("No event found!");
+    }
+    return notification;
+  }
+
+  public T takeValue() {
+    Notification<T> notification = takeNotification();
+    assertThat(notification.isOnNext())
+        .as("Expected onNext event but was " + notification)
+        .isTrue();
+    return notification.getValue();
+  }
+
+  public Throwable takeError() {
+    Notification<T> notification = takeNotification();
+    assertThat(notification.isOnError())
+        .as("Expected onError event but was " + notification)
+        .isTrue();
+    return notification.getError();
+  }
+
+  public RecordingSingleObserver<T> assertAnyValue() {
+    takeValue();
+    return this;
+  }
+
+  public RecordingSingleObserver<T> assertValue(T value) {
+    assertThat(takeValue()).isEqualTo(value);
+    return this;
+  }
+
+  public void assertError(Throwable throwable) {
+    assertThat(takeError()).isEqualTo(throwable);
+  }
+
+  public void assertError(Class<? extends Throwable> errorClass) {
+    assertError(errorClass, null);
+  }
+
+  public void assertError(Class<? extends Throwable> errorClass, String message) {
+    Throwable throwable = takeError();
+    assertThat(throwable).isInstanceOf(errorClass);
+    if (message != null) {
+      assertThat(throwable).hasMessage(message);
+    }
+    assertNoEvents();
+  }
+
+  public void assertNoEvents() {
+    assertThat(events).as("Unconsumed events found!").isEmpty();
+  }
+
+  public static final class Rule implements TestRule {
+    final List<RecordingSingleObserver<?>> subscribers = new ArrayList<>();
+
+    public <T> RecordingSingleObserver<T> create() {
+      RecordingSingleObserver<T> subscriber = new RecordingSingleObserver<>();
+      subscribers.add(subscriber);
+      return subscriber;
+    }
+
+    @Override public Statement apply(final Statement base, Description description) {
+      return new Statement() {
+        @Override public void evaluate() throws Throwable {
+          base.evaluate();
+          for (RecordingSingleObserver<?> subscriber : subscribers) {
+            subscriber.assertNoEvents();
+          }
+        }
+      };
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RecordingSubscriber.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RecordingSubscriber.java
new file mode 100644
index 000000000..f81bfd97a
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RecordingSubscriber.java
@@ -0,0 +1,154 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Notification;
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Deque;
+import java.util.List;
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+import org.reactivestreams.Subscriber;
+import org.reactivestreams.Subscription;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+/** A test {@link Subscriber} and JUnit rule which guarantees all events are asserted. */
+final class RecordingSubscriber<T> implements Subscriber<T> {
+  private final long initialRequest;
+  private final Deque<Notification<T>> events = new ArrayDeque<>();
+
+  private Subscription subscription;
+
+  private RecordingSubscriber(long initialRequest) {
+    this.initialRequest = initialRequest;
+  }
+
+  @Override public void onSubscribe(Subscription subscription) {
+    this.subscription = subscription;
+
+    subscription.request(initialRequest);
+  }
+
+  @Override public void onNext(T value) {
+    events.add(Notification.createOnNext(value));
+  }
+
+  @Override public void onComplete() {
+    events.add(Notification.<T>createOnComplete());
+  }
+
+  @Override public void onError(Throwable e) {
+    events.add(Notification.<T>createOnError(e));
+  }
+
+  private Notification<T> takeNotification() {
+    Notification<T> notification = events.pollFirst();
+    if (notification == null) {
+      throw new AssertionError("No event found!");
+    }
+    return notification;
+  }
+
+  public T takeValue() {
+    Notification<T> notification = takeNotification();
+    assertThat(notification.isOnNext())
+        .as("Expected onNext event but was " + notification)
+        .isTrue();
+    return notification.getValue();
+  }
+
+  public Throwable takeError() {
+    Notification<T> notification = takeNotification();
+    assertThat(notification.isOnError())
+        .as("Expected onError event but was " + notification)
+        .isTrue();
+    return notification.getError();
+  }
+
+  public RecordingSubscriber<T> assertAnyValue() {
+    takeValue();
+    return this;
+  }
+
+  public RecordingSubscriber<T> assertValue(T value) {
+    assertThat(takeValue()).isEqualTo(value);
+    return this;
+  }
+
+  public void assertComplete() {
+    Notification<T> notification = takeNotification();
+    assertThat(notification.isOnComplete())
+        .as("Expected onCompleted event but was " + notification)
+        .isTrue();
+    assertNoEvents();
+  }
+
+  public void assertError(Throwable throwable) {
+    assertThat(takeError()).isEqualTo(throwable);
+  }
+
+  public void assertError(Class<? extends Throwable> errorClass) {
+    assertError(errorClass, null);
+  }
+
+  public void assertError(Class<? extends Throwable> errorClass, String message) {
+    Throwable throwable = takeError();
+    assertThat(throwable).isInstanceOf(errorClass);
+    if (message != null) {
+      assertThat(throwable).hasMessage(message);
+    }
+    assertNoEvents();
+  }
+
+  public void assertNoEvents() {
+    assertThat(events).as("Unconsumed events found!").isEmpty();
+  }
+
+  public void request(long amount) {
+    if (subscription == null) {
+      throw new IllegalStateException("onSubscribe has not been called yet. Did you subscribe()?");
+    }
+    subscription.request(amount);
+  }
+
+  public static final class Rule implements TestRule {
+    final List<RecordingSubscriber<?>> subscribers = new ArrayList<>();
+
+    public <T> RecordingSubscriber<T> create() {
+      return createWithInitialRequest(Long.MAX_VALUE);
+    }
+
+    public <T> RecordingSubscriber<T> createWithInitialRequest(long initialRequest) {
+      RecordingSubscriber<T> subscriber = new RecordingSubscriber<>(initialRequest);
+      subscribers.add(subscriber);
+      return subscriber;
+    }
+
+    @Override public Statement apply(final Statement base, Description description) {
+      return new Statement() {
+        @Override public void evaluate() throws Throwable {
+          base.evaluate();
+          for (RecordingSubscriber<?> subscriber : subscribers) {
+            subscriber.assertNoEvents();
+          }
+        }
+      };
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ResultTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ResultTest.java
new file mode 100644
index 000000000..a26043296
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ResultTest.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import java.io.IOException;
+import org.junit.Test;
+import retrofit2.Response;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class ResultTest {
+  @Test public void response() {
+    Response<String> response = Response.success("Hi");
+    Result<String> result = Result.response(response);
+    assertThat(result.isError()).isFalse();
+    assertThat(result.error()).isNull();
+    assertThat(result.response()).isSameAs(response);
+  }
+
+  @Test public void nullResponseThrows() {
+    try {
+      Result.response(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("response == null");
+    }
+  }
+
+  @Test public void error() {
+    Throwable error = new IOException();
+    Result<Object> result = Result.error(error);
+    assertThat(result.isError()).isTrue();
+    assertThat(result.error()).isSameAs(error);
+    assertThat(result.response()).isNull();
+  }
+
+  @Test public void nullErrorThrows() {
+    try {
+      Result.error(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("error == null");
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactoryTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactoryTest.java
new file mode 100644
index 000000000..dea046f63
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactoryTest.java
@@ -0,0 +1,274 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package retrofit2.adapter.rxjava2;
+
+import com.google.common.reflect.TypeToken;
+import io.reactivex.Completable;
+import io.reactivex.Flowable;
+import io.reactivex.Maybe;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import java.util.List;
+import org.junit.Before;
+import org.junit.Test;
+import retrofit2.CallAdapter;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import io.reactivex.Observable;
+import io.reactivex.Single;
+import io.reactivex.Flowable;
+import io.reactivex.Maybe;
+import io.reactivex.Completable;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public class RxJava2CallAdapterFactoryTest {
+  private static final Annotation[] NO_ANNOTATIONS = new Annotation[0];
+
+  private final CallAdapter.Factory factory = RxJava2CallAdapterFactory.create();
+  private Retrofit retrofit;
+
+  @Before public void setUp() {
+    retrofit = new Retrofit.Builder()
+        .baseUrl("http://localhost:1")
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(factory)
+        .build();
+  }
+
+  @Test public void nullSchedulerThrows() {
+    try {
+      RxJava2CallAdapterFactory.createWithScheduler(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("scheduler == null");
+    }
+  }
+
+  @Test public void nonRxJavaTypeReturnsNull() {
+    CallAdapter<?, ?> adapter = factory.get(String.class, NO_ANNOTATIONS, retrofit);
+    assertThat(adapter).isNull();
+  }
+
+  @Test public void responseTypes() {
+    Type oBodyClass = new TypeToken<Observable<String>>() {}.getType();
+    assertThat(factory.get(oBodyClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type sBodyClass = new TypeToken<Single<String>>() {}.getType();
+    assertThat(factory.get(sBodyClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type mBodyClass = new TypeToken<Maybe<String>>() {}.getType();
+    assertThat(factory.get(mBodyClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type fBodyClass = new TypeToken<Flowable<String>>() {}.getType();
+    assertThat(factory.get(fBodyClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+
+    Type oBodyWildcard = new TypeToken<Observable<? extends String>>() {}.getType();
+    assertThat(factory.get(oBodyWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type sBodyWildcard = new TypeToken<Single<? extends String>>() {}.getType();
+    assertThat(factory.get(sBodyWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type mBodyWildcard = new TypeToken<Maybe<? extends String>>() {}.getType();
+    assertThat(factory.get(mBodyWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type fBodyWildcard = new TypeToken<Flowable<? extends String>>() {}.getType();
+    assertThat(factory.get(fBodyWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+
+    Type oBodyGeneric = new TypeToken<Observable<List<String>>>() {}.getType();
+    assertThat(factory.get(oBodyGeneric, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(new TypeToken<List<String>>() {}.getType());
+    Type sBodyGeneric = new TypeToken<Single<List<String>>>() {}.getType();
+    assertThat(factory.get(sBodyGeneric, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(new TypeToken<List<String>>() {}.getType());
+    Type mBodyGeneric = new TypeToken<Maybe<List<String>>>() {}.getType();
+    assertThat(factory.get(mBodyGeneric, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(new TypeToken<List<String>>() {}.getType());
+    Type fBodyGeneric = new TypeToken<Flowable<List<String>>>() {}.getType();
+    assertThat(factory.get(fBodyGeneric, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(new TypeToken<List<String>>() {}.getType());
+
+    Type oResponseClass = new TypeToken<Observable<Response<String>>>() {}.getType();
+    assertThat(factory.get(oResponseClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type sResponseClass = new TypeToken<Single<Response<String>>>() {}.getType();
+    assertThat(factory.get(sResponseClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type mResponseClass = new TypeToken<Maybe<Response<String>>>() {}.getType();
+    assertThat(factory.get(mResponseClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type fResponseClass = new TypeToken<Flowable<Response<String>>>() {}.getType();
+    assertThat(factory.get(fResponseClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+
+    Type oResponseWildcard = new TypeToken<Observable<Response<? extends String>>>() {}.getType();
+    assertThat(factory.get(oResponseWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type sResponseWildcard = new TypeToken<Single<Response<? extends String>>>() {}.getType();
+    assertThat(factory.get(sResponseWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type mResponseWildcard = new TypeToken<Maybe<Response<? extends String>>>() {}.getType();
+    assertThat(factory.get(mResponseWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type fResponseWildcard = new TypeToken<Flowable<Response<? extends String>>>() {}.getType();
+    assertThat(factory.get(fResponseWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+
+    Type oResultClass = new TypeToken<Observable<Result<String>>>() {}.getType();
+    assertThat(factory.get(oResultClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type sResultClass = new TypeToken<Single<Result<String>>>() {}.getType();
+    assertThat(factory.get(sResultClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type mResultClass = new TypeToken<Maybe<Result<String>>>() {}.getType();
+    assertThat(factory.get(mResultClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type fResultClass = new TypeToken<Flowable<Result<String>>>() {}.getType();
+    assertThat(factory.get(fResultClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+
+    Type oResultWildcard = new TypeToken<Observable<Result<? extends String>>>() {}.getType();
+    assertThat(factory.get(oResultWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type sResultWildcard = new TypeToken<Single<Result<? extends String>>>() {}.getType();
+    assertThat(factory.get(sResultWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type mResultWildcard = new TypeToken<Maybe<Result<? extends String>>>() {}.getType();
+    assertThat(factory.get(mResultWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type fResultWildcard = new TypeToken<Flowable<Result<? extends String>>>() {}.getType();
+    assertThat(factory.get(fResultWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+  }
+
+  @Test public void rawBodyTypeThrows() {
+    Type observableType = new TypeToken<Observable>() {}.getType();
+    try {
+      factory.get(observableType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Observable return type must be parameterized as Observable<Foo> or Observable<? extends Foo>");
+    }
+
+    Type singleType = new TypeToken<Single>() {}.getType();
+    try {
+      factory.get(singleType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Single return type must be parameterized as Single<Foo> or Single<? extends Foo>");
+    }
+
+    Type maybeType = new TypeToken<Maybe>() {}.getType();
+    try {
+      factory.get(maybeType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Maybe return type must be parameterized as Maybe<Foo> or Maybe<? extends Foo>");
+    }
+
+    Type flowableType = new TypeToken<Flowable>() {}.getType();
+    try {
+      factory.get(flowableType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Flowable return type must be parameterized as Flowable<Foo> or Flowable<? extends Foo>");
+    }
+  }
+
+  @Test public void rawResponseTypeThrows() {
+    Type observableType = new TypeToken<Observable<Response>>() {}.getType();
+    try {
+      factory.get(observableType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Response must be parameterized as Response<Foo> or Response<? extends Foo>");
+    }
+
+    Type singleType = new TypeToken<Single<Response>>() {}.getType();
+    try {
+      factory.get(singleType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Response must be parameterized as Response<Foo> or Response<? extends Foo>");
+    }
+
+    Type maybeType = new TypeToken<Maybe<Response>>() {}.getType();
+    try {
+      factory.get(maybeType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Response must be parameterized as Response<Foo> or Response<? extends Foo>");
+    }
+
+    Type flowableType = new TypeToken<Flowable<Response>>() {}.getType();
+    try {
+      factory.get(flowableType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Response must be parameterized as Response<Foo> or Response<? extends Foo>");
+    }
+  }
+
+  @Test public void rawResultTypeThrows() {
+    Type observableType = new TypeToken<Observable<Result>>() {}.getType();
+    try {
+      factory.get(observableType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Result must be parameterized as Result<Foo> or Result<? extends Foo>");
+    }
+
+    Type singleType = new TypeToken<Single<Result>>() {}.getType();
+    try {
+      factory.get(singleType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Result must be parameterized as Result<Foo> or Result<? extends Foo>");
+    }
+
+    Type maybeType = new TypeToken<Maybe<Result>>() {}.getType();
+    try {
+      factory.get(maybeType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Result must be parameterized as Result<Foo> or Result<? extends Foo>");
+    }
+
+    Type flowableType = new TypeToken<Flowable<Result>>() {}.getType();
+    try {
+      factory.get(flowableType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Result must be parameterized as Result<Foo> or Result<? extends Foo>");
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RxJavaPluginsResetRule.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RxJavaPluginsResetRule.java
new file mode 100644
index 000000000..2e97cc6f4
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RxJavaPluginsResetRule.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.plugins.RxJavaPlugins;
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+
+final class RxJavaPluginsResetRule implements TestRule {
+  @Override public Statement apply(final Statement base, Description description) {
+    return new Statement() {
+      @Override public void evaluate() throws Throwable {
+        RxJavaPlugins.reset();
+        try {
+          base.evaluate();
+        } finally {
+          RxJavaPlugins.reset();
+        }
+      }
+    };
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/SingleTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/SingleTest.java
new file mode 100644
index 000000000..dba2dd62a
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/SingleTest.java
@@ -0,0 +1,132 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Single;
+import java.io.IOException;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class SingleTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final RecordingSingleObserver.Rule observerRule = new RecordingSingleObserver.Rule();
+
+  interface Service {
+    @GET("/") Single<String> body();
+    @GET("/") Single<Response<String>> response();
+    @GET("/") Single<Result<String>> result();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodySuccess200() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingSingleObserver<String> observer = observerRule.create();
+    service.body().subscribe(observer);
+    observer.assertValue("Hi");
+  }
+
+  @Test public void bodySuccess404() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    RecordingSingleObserver<String> observer = observerRule.create();
+    service.body().subscribe(observer);
+    // Required for backwards compatibility.
+    observer.assertError(HttpException.class, "HTTP 404 Client Error");
+  }
+
+  @Test public void bodyFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    RecordingSingleObserver<String> observer = observerRule.create();
+    service.body().subscribe(observer);
+    observer.assertError(IOException.class);
+  }
+
+  @Test public void responseSuccess200() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingSingleObserver<Response<String>> observer = observerRule.create();
+    service.response().subscribe(observer);
+    Response<String> response = observer.takeValue();
+    assertThat(response.isSuccessful()).isTrue();
+  }
+
+  @Test public void responseSuccess404() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    RecordingSingleObserver<Response<String>> observer = observerRule.create();
+    service.response().subscribe(observer);
+    assertThat(observer.takeValue().isSuccessful()).isFalse();
+  }
+
+  @Test public void responseFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    RecordingSingleObserver<Response<String>> observer = observerRule.create();
+    service.response().subscribe(observer);
+    observer.assertError(IOException.class);
+  }
+
+  @Test public void resultSuccess200() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingSingleObserver<Result<String>> observer = observerRule.create();
+    service.result().subscribe(observer);
+    Result<String> result = observer.takeValue();
+    assertThat(result.isError()).isFalse();
+    assertThat(result.response().isSuccessful()).isTrue();
+  }
+
+  @Test public void resultSuccess404() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    RecordingSingleObserver<Result<String>> observer = observerRule.create();
+    service.result().subscribe(observer);
+    Result<String> result = observer.takeValue();
+    assertThat(result.isError()).isFalse();
+    assertThat(result.response().isSuccessful()).isFalse();
+  }
+
+  @Test public void resultFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    RecordingSingleObserver<Result<String>> observer = observerRule.create();
+    service.result().subscribe(observer);
+    Result<String> result = observer.takeValue();
+    assertThat(result.isError()).isTrue();
+    assertThat(result.error()).isInstanceOf(IOException.class);
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/SingleThrowingTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/SingleThrowingTest.java
new file mode 100644
index 000000000..294722783
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/SingleThrowingTest.java
@@ -0,0 +1,240 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Single;
+import io.reactivex.SingleObserver;
+import io.reactivex.disposables.Disposable;
+import io.reactivex.exceptions.CompositeException;
+import io.reactivex.exceptions.Exceptions;
+import io.reactivex.functions.Consumer;
+import io.reactivex.plugins.RxJavaPlugins;
+import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class SingleThrowingTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final TestRule resetRule = new RxJavaPluginsResetRule();
+  @Rule public final RecordingSingleObserver.Rule subscriberRule = new RecordingSingleObserver.Rule();
+
+  interface Service {
+    @GET("/") Single<String> body();
+    @GET("/") Single<Response<String>> response();
+    @GET("/") Single<Result<String>> result();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodyThrowingInOnSuccessDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingSingleObserver<String> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.body().subscribe(new ForwardingObserver<String>(observer) {
+      @Override public void onSuccess(String value) {
+        throw e;
+      }
+    });
+
+    assertThat(throwableRef.get()).isSameAs(e);
+  }
+
+  @Test public void bodyThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingSingleObserver<String> observer = subscriberRule.create();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    final RuntimeException e = new RuntimeException();
+    service.body().subscribe(new ForwardingObserver<String>(observer) {
+      @Override public void onError(Throwable throwable) {
+        if (!errorRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+        throw e;
+      }
+    });
+
+    //noinspection ThrowableResultOfMethodCallIgnored
+    CompositeException composite = (CompositeException) throwableRef.get();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+
+  @Test public void responseThrowingInOnSuccessDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingSingleObserver<Response<String>> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.response().subscribe(new ForwardingObserver<Response<String>>(observer) {
+      @Override public void onSuccess(Response<String> value) {
+        throw e;
+      }
+    });
+
+    assertThat(throwableRef.get()).isSameAs(e);
+  }
+
+  @Test public void responseThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingSingleObserver<Response<String>> observer = subscriberRule.create();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    final RuntimeException e = new RuntimeException();
+    service.response().subscribe(new ForwardingObserver<Response<String>>(observer) {
+      @Override public void onError(Throwable throwable) {
+        if (!errorRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+        throw e;
+      }
+    });
+
+    //noinspection ThrowableResultOfMethodCallIgnored
+    CompositeException composite = (CompositeException) throwableRef.get();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+
+  @Test public void resultThrowingInOnSuccessDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingSingleObserver<Result<String>> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.result().subscribe(new ForwardingObserver<Result<String>>(observer) {
+      @Override public void onSuccess(Result<String> value) {
+        throw e;
+      }
+    });
+
+    assertThat(throwableRef.get()).isSameAs(e);
+  }
+
+  @Ignore("Single's contract is onNext|onError so we have no way of triggering this case")
+  @Test public void resultThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingSingleObserver<Result<String>> observer = subscriberRule.create();
+    final RuntimeException first = new RuntimeException();
+    final RuntimeException second = new RuntimeException();
+    service.result().subscribe(new ForwardingObserver<Result<String>>(observer) {
+      @Override public void onSuccess(Result<String> value) {
+        // The only way to trigger onError for Result is if onSuccess throws.
+        throw first;
+      }
+
+      @Override public void onError(Throwable throwable) {
+        throw second;
+      }
+    });
+
+    //noinspection ThrowableResultOfMethodCallIgnored
+    CompositeException composite = (CompositeException) throwableRef.get();
+    assertThat(composite.getExceptions()).containsExactly(first, second);
+  }
+
+  private static abstract class ForwardingObserver<T> implements SingleObserver<T> {
+    private final SingleObserver<T> delegate;
+
+    ForwardingObserver(SingleObserver<T> delegate) {
+      this.delegate = delegate;
+    }
+
+    @Override public void onSubscribe(Disposable disposable) {
+      delegate.onSubscribe(disposable);
+    }
+
+    @Override public void onSuccess(T value) {
+      delegate.onSuccess(value);
+    }
+
+    @Override public void onError(Throwable throwable) {
+      delegate.onError(throwable);
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/SingleWithSchedulerTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/SingleWithSchedulerTest.java
new file mode 100644
index 000000000..5198d7bf3
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/SingleWithSchedulerTest.java
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Single;
+import io.reactivex.schedulers.TestScheduler;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+public final class SingleWithSchedulerTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final RecordingSingleObserver.Rule observerRule = new RecordingSingleObserver.Rule();
+
+  interface Service {
+    @GET("/") Single<String> body();
+    @GET("/") Single<Response<String>> response();
+    @GET("/") Single<Result<String>> result();
+  }
+
+  private final TestScheduler scheduler = new TestScheduler();
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJava2CallAdapterFactory.createWithScheduler(scheduler))
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodyUsesScheduler() {
+    server.enqueue(new MockResponse());
+
+    RecordingSingleObserver<Object> observer = observerRule.create();
+    service.body().subscribe(observer);
+    observer.assertNoEvents();
+
+    scheduler.triggerActions();
+    observer.assertAnyValue();
+  }
+
+  @Test public void responseUsesScheduler() {
+    server.enqueue(new MockResponse());
+
+    RecordingSingleObserver<Object> observer = observerRule.create();
+    service.response().subscribe(observer);
+    observer.assertNoEvents();
+
+    scheduler.triggerActions();
+    observer.assertAnyValue();
+  }
+
+  @Test public void resultUsesScheduler() {
+    server.enqueue(new MockResponse());
+
+    RecordingSingleObserver<Object> observer = observerRule.create();
+    service.result().subscribe(observer);
+    observer.assertNoEvents();
+
+    scheduler.triggerActions();
+    observer.assertAnyValue();
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/StringConverterFactory.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/StringConverterFactory.java
new file mode 100644
index 000000000..5a6841840
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/StringConverterFactory.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import okhttp3.MediaType;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
+
+final class StringConverterFactory extends Converter.Factory {
+  @Override
+  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
+    return new Converter<ResponseBody, String>() {
+      @Override public String convert(ResponseBody value) throws IOException {
+        return value.string();
+      }
+    };
+  }
+
+  @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
+      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+    return new Converter<String, RequestBody>() {
+      @Override public RequestBody convert(String value) throws IOException {
+        return RequestBody.create(MediaType.parse("text/plain"), value);
+      }
+    };
+  }
+}
diff --git a/retrofit-converters/gson/README.md b/retrofit-converters/gson/README.md
index 1568926f2..980d1d1f0 100644
--- a/retrofit-converters/gson/README.md
+++ b/retrofit-converters/gson/README.md
@@ -4,7 +4,30 @@ Gson Converter
 A `Converter` which uses [Gson][1] for serialization to and from JSON.
 
 A default `Gson` instance will be created or one can be configured and passed to the
-`GsonConverter` construction to further control the serialization.
+`GsonConverterFactory` to further control the serialization.
+
+
+Download
+--------
+
+Download [the latest JAR][2] or grab via [Maven][3]:
+```xml
+<dependency>
+  <groupId>com.squareup.retrofit2</groupId>
+  <artifactId>converter-gson</artifactId>
+  <version>latest.version</version>
+</dependency>
+```
+or [Gradle][3]:
+```groovy
+compile 'com.squareup.retrofit2:converter-gson:latest.version'
+```
+
+Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
+
 
 
  [1]: https://github.com/google/gson
+ [2]: https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=converter-gson&v=LATEST
+ [3]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup.retrofit2%22%20a%3A%22converter-gson%22
+ [snap]: https://oss.sonatype.org/content/repositories/snapshots/
diff --git a/retrofit-converters/gson/pom.xml b/retrofit-converters/gson/pom.xml
index d19b63f4f..823e50491 100644
--- a/retrofit-converters/gson/pom.xml
+++ b/retrofit-converters/gson/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-converters</artifactId>
-    <version>2.0.1</version>
+    <version>2.4.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -23,6 +23,11 @@
       <groupId>com.google.code.gson</groupId>
       <artifactId>gson</artifactId>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
diff --git a/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonConverterFactory.java b/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonConverterFactory.java
index e6c702705..468d576d7 100644
--- a/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonConverterFactory.java
+++ b/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonConverterFactory.java
@@ -46,14 +46,15 @@ public static GsonConverterFactory create() {
    * Create an instance using {@code gson} for conversion. Encoding to JSON and
    * decoding from JSON (when no charset is specified by a header) will use UTF-8.
    */
+  @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
   public static GsonConverterFactory create(Gson gson) {
+    if (gson == null) throw new NullPointerException("gson == null");
     return new GsonConverterFactory(gson);
   }
 
   private final Gson gson;
 
   private GsonConverterFactory(Gson gson) {
-    if (gson == null) throw new NullPointerException("gson == null");
     this.gson = gson;
   }
 
diff --git a/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/package-info.java b/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/package-info.java
new file mode 100644
index 000000000..b8ad27810
--- /dev/null
+++ b/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/package-info.java
@@ -0,0 +1,4 @@
+@ParametersAreNonnullByDefault
+package retrofit2.converter.gson;
+
+import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-converters/guava/README.md b/retrofit-converters/guava/README.md
new file mode 100644
index 000000000..03eae96f5
--- /dev/null
+++ b/retrofit-converters/guava/README.md
@@ -0,0 +1,30 @@
+Guava Converter
+===============
+
+A `Converter` which supports Guava's `Optional<T>` by delegating to other converters for `T`
+and then wrapping it into `Optional`.
+
+
+Download
+--------
+
+Download [the latest JAR][1] or grab via [Maven][2]:
+```xml
+<dependency>
+  <groupId>com.squareup.retrofit2</groupId>
+  <artifactId>converter-guava</artifactId>
+  <version>latest.version</version>
+</dependency>
+```
+or [Gradle][2]:
+```groovy
+compile 'com.squareup.retrofit2:converter-guava:latest.version'
+```
+
+Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
+
+
+
+ [1]: https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=converter-guava&v=LATEST
+ [2]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup.retrofit2%22%20a%3A%22converter-guava%22
+ [snap]: https://oss.sonatype.org/content/repositories/snapshots/
diff --git a/retrofit-converters/guava/pom.xml b/retrofit-converters/guava/pom.xml
new file mode 100644
index 000000000..9ac3c5b5e
--- /dev/null
+++ b/retrofit-converters/guava/pom.xml
@@ -0,0 +1,48 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.retrofit2</groupId>
+    <artifactId>retrofit-converters</artifactId>
+    <version>2.4.0-SNAPSHOT</version>
+    <relativePath>../pom.xml</relativePath>
+  </parent>
+
+  <artifactId>converter-guava</artifactId>
+  <name>Converter: Guava</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>retrofit</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp3</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.assertj</groupId>
+      <artifactId>assertj-core</artifactId>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+</project>
diff --git a/retrofit-converters/guava/src/main/java/retrofit/converter/guava/GuavaOptionalConverterFactory.java b/retrofit-converters/guava/src/main/java/retrofit/converter/guava/GuavaOptionalConverterFactory.java
new file mode 100644
index 000000000..bfa033614
--- /dev/null
+++ b/retrofit-converters/guava/src/main/java/retrofit/converter/guava/GuavaOptionalConverterFactory.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.converter.guava;
+
+import com.google.common.base.Optional;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import javax.annotation.Nullable;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
+
+/**
+ * A {@linkplain Converter.Factory converter} for {@code Optional<T>} which delegates to another
+ * converter to deserialize {@code T} and then wraps it into {@link Optional}.
+ */
+public final class GuavaOptionalConverterFactory extends Converter.Factory {
+  public static GuavaOptionalConverterFactory create() {
+    return new GuavaOptionalConverterFactory();
+  }
+
+  private GuavaOptionalConverterFactory() {
+  }
+
+  @Nullable @Override
+  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
+    if (getRawType(type) != Optional.class) {
+      return null;
+    }
+
+    Type innerType = getParameterUpperBound(0, (ParameterizedType) type);
+    Converter<ResponseBody, Object> delegate =
+        retrofit.nextResponseBodyConverter(this, innerType, annotations);
+    return new OptionalConverter<>(delegate);
+  }
+}
diff --git a/retrofit-converters/guava/src/main/java/retrofit/converter/guava/OptionalConverter.java b/retrofit-converters/guava/src/main/java/retrofit/converter/guava/OptionalConverter.java
new file mode 100644
index 000000000..72f2184db
--- /dev/null
+++ b/retrofit-converters/guava/src/main/java/retrofit/converter/guava/OptionalConverter.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.converter.guava;
+
+import com.google.common.base.Optional;
+import java.io.IOException;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+
+final class OptionalConverter<T> implements Converter<ResponseBody, Optional<T>> {
+  private final Converter<ResponseBody, T> delegate;
+
+  OptionalConverter(Converter<ResponseBody, T> delegate) {
+    this.delegate = delegate;
+  }
+
+  @Override public Optional<T> convert(ResponseBody value) throws IOException {
+    return Optional.fromNullable(delegate.convert(value));
+  }
+}
diff --git a/retrofit-converters/guava/src/main/java/retrofit/converter/guava/package-info.java b/retrofit-converters/guava/src/main/java/retrofit/converter/guava/package-info.java
new file mode 100644
index 000000000..bd25d1fe4
--- /dev/null
+++ b/retrofit-converters/guava/src/main/java/retrofit/converter/guava/package-info.java
@@ -0,0 +1,4 @@
+@ParametersAreNonnullByDefault
+package retrofit.converter.guava;
+
+import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/SingleHelper.java b/retrofit-converters/guava/src/test/java/retrofit/converter/guava/AlwaysNullConverterFactory.java
similarity index 51%
rename from retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/SingleHelper.java
rename to retrofit-converters/guava/src/test/java/retrofit/converter/guava/AlwaysNullConverterFactory.java
index e0073cfae..923252301 100644
--- a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/SingleHelper.java
+++ b/retrofit-converters/guava/src/test/java/retrofit/converter/guava/AlwaysNullConverterFactory.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Square, Inc.
+ * Copyright (C) 2017 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,24 +13,22 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2.adapter.rxjava;
+package retrofit.converter.guava;
 
+import java.io.IOException;
+import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
-import retrofit2.Call;
-import retrofit2.CallAdapter;
-import rx.Observable;
-import rx.Single;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
 
-final class SingleHelper {
-  static CallAdapter<Single<?>> makeSingle(final CallAdapter<Observable<?>> callAdapter) {
-    return new CallAdapter<Single<?>>() {
-      @Override public Type responseType() {
-        return callAdapter.responseType();
-      }
-
-      @Override public <R> Single<?> adapt(Call<R> call) {
-        Observable<?> observable = callAdapter.adapt(call);
-        return observable.toSingle();
+final class AlwaysNullConverterFactory extends Converter.Factory {
+  @Override
+  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
+    return new Converter<ResponseBody, Object>() {
+      @Override public Object convert(ResponseBody value) throws IOException {
+        return null;
       }
     };
   }
diff --git a/retrofit-converters/guava/src/test/java/retrofit/converter/guava/GuavaOptionalConverterFactoryTest.java b/retrofit-converters/guava/src/test/java/retrofit/converter/guava/GuavaOptionalConverterFactoryTest.java
new file mode 100644
index 000000000..27680150e
--- /dev/null
+++ b/retrofit-converters/guava/src/test/java/retrofit/converter/guava/GuavaOptionalConverterFactoryTest.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.converter.guava;
+
+import com.google.common.base.Optional;
+import java.io.IOException;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Call;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class GuavaOptionalConverterFactoryTest {
+  interface Service {
+    @GET("/") Call<Optional<Object>> optional();
+    @GET("/") Call<Object> object();
+  }
+
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(GuavaOptionalConverterFactory.create())
+        .addConverterFactory(new AlwaysNullConverterFactory())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void optional() throws IOException {
+    server.enqueue(new MockResponse());
+
+    Optional<Object> optional = service.optional().execute().body();
+    assertThat(optional).isNotNull();
+    assertThat(optional.isPresent()).isFalse();
+  }
+
+  @Test public void onlyMatchesOptional() throws IOException {
+    server.enqueue(new MockResponse());
+
+    Object body = service.object().execute().body();
+    assertThat(body).isNull();
+  }
+}
diff --git a/retrofit-converters/jackson/README.md b/retrofit-converters/jackson/README.md
index d07b0afa6..2335d2903 100644
--- a/retrofit-converters/jackson/README.md
+++ b/retrofit-converters/jackson/README.md
@@ -4,7 +4,30 @@ Jackson Converter
 A `Converter` which uses [Jackson][1] for serialization to and from JSON.
 
 A default `ObjectMapper` instance will be created or one can be configured and passed to the
-`JacksonConverter` construction to further control the serialization.
+`JacksonConverterFactory` construction to further control the serialization.
+
+
+Download
+--------
+
+Download [the latest JAR][2] or grab via [Maven][3]:
+```xml
+<dependency>
+  <groupId>com.squareup.retrofit2</groupId>
+  <artifactId>converter-jackson</artifactId>
+  <version>latest.version</version>
+</dependency>
+```
+or [Gradle][3]:
+```groovy
+compile 'com.squareup.retrofit2:converter-jackson:latest.version'
+```
+
+Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
+
 
 
  [1]: http://wiki.fasterxml.com/JacksonHome
+ [2]: https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=converter-jackson&v=LATEST
+ [3]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup.retrofit2%22%20a%3A%22converter-jackson%22
+ [snap]: https://oss.sonatype.org/content/repositories/snapshots/
diff --git a/retrofit-converters/jackson/pom.xml b/retrofit-converters/jackson/pom.xml
index 160607b7f..f03526863 100644
--- a/retrofit-converters/jackson/pom.xml
+++ b/retrofit-converters/jackson/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-converters</artifactId>
-    <version>2.0.1</version>
+    <version>2.4.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -23,6 +23,11 @@
       <groupId>com.fasterxml.jackson.core</groupId>
       <artifactId>jackson-databind</artifactId>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
diff --git a/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonConverterFactory.java b/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonConverterFactory.java
index f6db311be..5e5106c45 100644
--- a/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonConverterFactory.java
+++ b/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonConverterFactory.java
@@ -41,14 +41,15 @@ public static JacksonConverterFactory create() {
   }
 
   /** Create an instance using {@code mapper} for conversion. */
+  @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
   public static JacksonConverterFactory create(ObjectMapper mapper) {
+    if (mapper == null) throw new NullPointerException("mapper == null");
     return new JacksonConverterFactory(mapper);
   }
 
   private final ObjectMapper mapper;
 
   private JacksonConverterFactory(ObjectMapper mapper) {
-    if (mapper == null) throw new NullPointerException("mapper == null");
     this.mapper = mapper;
   }
 
@@ -56,7 +57,7 @@ private JacksonConverterFactory(ObjectMapper mapper) {
   public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
       Retrofit retrofit) {
     JavaType javaType = mapper.getTypeFactory().constructType(type);
-    ObjectReader reader = mapper.reader(javaType);
+    ObjectReader reader = mapper.readerFor(javaType);
     return new JacksonResponseBodyConverter<>(reader);
   }
 
@@ -64,7 +65,7 @@ private JacksonConverterFactory(ObjectMapper mapper) {
   public Converter<?, RequestBody> requestBodyConverter(Type type,
       Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     JavaType javaType = mapper.getTypeFactory().constructType(type);
-    ObjectWriter writer = mapper.writerWithType(javaType);
+    ObjectWriter writer = mapper.writerFor(javaType);
     return new JacksonRequestBodyConverter<>(writer);
   }
 }
diff --git a/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/package-info.java b/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/package-info.java
new file mode 100644
index 000000000..f747a1d6d
--- /dev/null
+++ b/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/package-info.java
@@ -0,0 +1,4 @@
+@ParametersAreNonnullByDefault
+package retrofit2.converter.jackson;
+
+import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-converters/java8/README.md b/retrofit-converters/java8/README.md
new file mode 100644
index 000000000..696ac23c6
--- /dev/null
+++ b/retrofit-converters/java8/README.md
@@ -0,0 +1,30 @@
+Java 8 Converter
+================
+
+A `Converter` which supports Java 8's `Optional<T>` by delegating to other converters for `T`
+and then wrapping it into `Optional`.
+
+
+Download
+--------
+
+Download [the latest JAR][1] or grab via [Maven][2]:
+```xml
+<dependency>
+  <groupId>com.squareup.retrofit2</groupId>
+  <artifactId>converter-java8</artifactId>
+  <version>latest.version</version>
+</dependency>
+```
+or [Gradle][2]:
+```groovy
+compile 'com.squareup.retrofit2:converter-java8:latest.version'
+```
+
+Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
+
+
+
+ [1]: https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=converter-java8&v=LATEST
+ [2]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup.retrofit2%22%20a%3A%22converter-java8%22
+ [snap]: https://oss.sonatype.org/content/repositories/snapshots/
diff --git a/retrofit-converters/java8/pom.xml b/retrofit-converters/java8/pom.xml
new file mode 100644
index 000000000..c43d2a9bd
--- /dev/null
+++ b/retrofit-converters/java8/pom.xml
@@ -0,0 +1,65 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.retrofit2</groupId>
+    <artifactId>retrofit-converters</artifactId>
+    <version>2.4.0-SNAPSHOT</version>
+    <relativePath>../pom.xml</relativePath>
+  </parent>
+
+  <artifactId>converter-java8</artifactId>
+  <name>Converter: Java 8</name>
+
+  <properties>
+    <java.version>1.8</java.version>
+  </properties>
+
+  <dependencies>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>retrofit</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp3</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.assertj</groupId>
+      <artifactId>assertj-core</artifactId>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.codehaus.mojo</groupId>
+        <artifactId>animal-sniffer-maven-plugin</artifactId>
+        <version>${animal.sniffer.version}</version>
+        <configuration>
+          <signature>
+            <groupId>org.kaazing.mojo.signature</groupId>
+            <artifactId>java18</artifactId>
+            <version>1.0</version>
+          </signature>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
diff --git a/retrofit-converters/java8/src/main/java/retrofit/converter/java8/Java8OptionalConverterFactory.java b/retrofit-converters/java8/src/main/java/retrofit/converter/java8/Java8OptionalConverterFactory.java
new file mode 100644
index 000000000..7b55ca965
--- /dev/null
+++ b/retrofit-converters/java8/src/main/java/retrofit/converter/java8/Java8OptionalConverterFactory.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.converter.java8;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.util.Optional;
+import javax.annotation.Nullable;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
+
+/**
+ * A {@linkplain Converter.Factory converter} for {@code Optional<T>} which delegates to another
+ * converter to deserialize {@code T} and then wraps it into {@link Optional}.
+ */
+public final class Java8OptionalConverterFactory extends Converter.Factory {
+  public static Java8OptionalConverterFactory create() {
+    return new Java8OptionalConverterFactory();
+  }
+
+  private Java8OptionalConverterFactory() {
+  }
+
+  @Nullable @Override
+  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
+    if (getRawType(type) != Optional.class) {
+      return null;
+    }
+
+    Type innerType = getParameterUpperBound(0, (ParameterizedType) type);
+    Converter<ResponseBody, Object> delegate =
+        retrofit.nextResponseBodyConverter(this, innerType, annotations);
+    return new OptionalConverter<>(delegate);
+  }
+}
diff --git a/retrofit-converters/java8/src/main/java/retrofit/converter/java8/OptionalConverter.java b/retrofit-converters/java8/src/main/java/retrofit/converter/java8/OptionalConverter.java
new file mode 100644
index 000000000..438443256
--- /dev/null
+++ b/retrofit-converters/java8/src/main/java/retrofit/converter/java8/OptionalConverter.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.converter.java8;
+
+import java.io.IOException;
+import java.util.Optional;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+
+final class OptionalConverter<T> implements Converter<ResponseBody, Optional<T>> {
+  private final Converter<ResponseBody, T> delegate;
+
+  OptionalConverter(Converter<ResponseBody, T> delegate) {
+    this.delegate = delegate;
+  }
+
+  @Override public Optional<T> convert(ResponseBody value) throws IOException {
+    return Optional.ofNullable(delegate.convert(value));
+  }
+}
diff --git a/retrofit-converters/java8/src/main/java/retrofit/converter/java8/package-info.java b/retrofit-converters/java8/src/main/java/retrofit/converter/java8/package-info.java
new file mode 100644
index 000000000..e883be032
--- /dev/null
+++ b/retrofit-converters/java8/src/main/java/retrofit/converter/java8/package-info.java
@@ -0,0 +1,4 @@
+@ParametersAreNonnullByDefault
+package retrofit.converter.java8;
+
+import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-converters/java8/src/test/java/retrofit/converter/java8/AlwaysNullConverterFactory.java b/retrofit-converters/java8/src/test/java/retrofit/converter/java8/AlwaysNullConverterFactory.java
new file mode 100644
index 000000000..006b90624
--- /dev/null
+++ b/retrofit-converters/java8/src/test/java/retrofit/converter/java8/AlwaysNullConverterFactory.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.converter.java8;
+
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
+
+final class AlwaysNullConverterFactory extends Converter.Factory {
+  @Override
+  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
+    return new Converter<ResponseBody, Object>() {
+      @Override public Object convert(ResponseBody value) throws IOException {
+        return null;
+      }
+    };
+  }
+}
diff --git a/retrofit-converters/java8/src/test/java/retrofit/converter/java8/Java8OptionalConverterFactoryTest.java b/retrofit-converters/java8/src/test/java/retrofit/converter/java8/Java8OptionalConverterFactoryTest.java
new file mode 100644
index 000000000..73027907b
--- /dev/null
+++ b/retrofit-converters/java8/src/test/java/retrofit/converter/java8/Java8OptionalConverterFactoryTest.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.converter.java8;
+
+import java.io.IOException;
+import java.util.Optional;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Call;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class Java8OptionalConverterFactoryTest {
+  interface Service {
+    @GET("/") Call<Optional<Object>> optional();
+    @GET("/") Call<Object> object();
+  }
+
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(Java8OptionalConverterFactory.create())
+        .addConverterFactory(new AlwaysNullConverterFactory())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void optional() throws IOException {
+    server.enqueue(new MockResponse());
+
+    Optional<Object> optional = service.optional().execute().body();
+    assertThat(optional).isNotNull();
+    assertThat(optional.isPresent()).isFalse();
+  }
+
+  @Test public void onlyMatchesOptional() throws IOException {
+    server.enqueue(new MockResponse());
+
+    Object body = service.object().execute().body();
+    assertThat(body).isNull();
+  }
+}
diff --git a/retrofit-converters/moshi/README.md b/retrofit-converters/moshi/README.md
index 9968ccd38..c5668f9ab 100644
--- a/retrofit-converters/moshi/README.md
+++ b/retrofit-converters/moshi/README.md
@@ -7,4 +7,27 @@ A default `Moshi` instance will be created or one can be configured and passed t
 `MoshiConverterFactory.create()` to further control the serialization.
 
 
+Download
+--------
+
+Download [the latest JAR][2] or grab via [Maven][3]:
+```xml
+<dependency>
+  <groupId>com.squareup.retrofit2</groupId>
+  <artifactId>converter-moshi</artifactId>
+  <version>latest.version</version>
+</dependency>
+```
+or [Gradle][3]:
+```groovy
+compile 'com.squareup.retrofit2:converter-moshi:latest.version'
+```
+
+Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
+
+
+
  [1]: https://github.com/square/moshi
+ [2]: https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=converter-moshi&v=LATEST
+ [3]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup.retrofit2%22%20a%3A%22converter-moshi%22
+ [snap]: https://oss.sonatype.org/content/repositories/snapshots/
diff --git a/retrofit-converters/moshi/pom.xml b/retrofit-converters/moshi/pom.xml
index 8145deead..51f42efca 100644
--- a/retrofit-converters/moshi/pom.xml
+++ b/retrofit-converters/moshi/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-converters</artifactId>
-    <version>2.0.1</version>
+    <version>2.4.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -23,6 +23,11 @@
       <groupId>com.squareup.moshi</groupId>
       <artifactId>moshi</artifactId>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
diff --git a/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiConverterFactory.java b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiConverterFactory.java
index c4831f937..b7c016190 100644
--- a/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiConverterFactory.java
+++ b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiConverterFactory.java
@@ -16,14 +16,20 @@
 package retrofit2.converter.moshi;
 
 import com.squareup.moshi.JsonAdapter;
+import com.squareup.moshi.JsonQualifier;
 import com.squareup.moshi.Moshi;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+import java.util.Collections;
+import java.util.LinkedHashSet;
+import java.util.Set;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import retrofit2.Converter;
 import retrofit2.Retrofit;
 
+import static java.util.Collections.unmodifiableSet;
+
 /**
  * A {@linkplain Converter.Factory converter} which uses Moshi for JSON.
  * <p>
@@ -31,6 +37,10 @@
  * all types. If you are mixing JSON serialization with something else (such as protocol buffers),
  * you must {@linkplain Retrofit.Builder#addConverterFactory(Converter.Factory) add this instance}
  * last to allow the other converters a chance to see their types.
+ * <p>
+ * Any {@link JsonQualifier @JsonQualifier}-annotated annotations on the parameter will be used
+ * when looking up a request body converter and those on the method will be used when looking up a
+ * response body converter.
  */
 public final class MoshiConverterFactory extends Converter.Factory {
   /** Create an instance using a default {@link Moshi} instance for conversion. */
@@ -39,41 +49,81 @@ public static MoshiConverterFactory create() {
   }
 
   /** Create an instance using {@code moshi} for conversion. */
+  @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
   public static MoshiConverterFactory create(Moshi moshi) {
-    return new MoshiConverterFactory(moshi, false);
+    if (moshi == null) throw new NullPointerException("moshi == null");
+    return new MoshiConverterFactory(moshi, false, false, false);
   }
 
   private final Moshi moshi;
   private final boolean lenient;
+  private final boolean failOnUnknown;
+  private final boolean serializeNulls;
 
-  private MoshiConverterFactory(Moshi moshi, boolean lenient) {
-    if (moshi == null) throw new NullPointerException("moshi == null");
+  private MoshiConverterFactory(Moshi moshi, boolean lenient, boolean failOnUnknown,
+      boolean serializeNulls) {
     this.moshi = moshi;
     this.lenient = lenient;
+    this.failOnUnknown = failOnUnknown;
+    this.serializeNulls = serializeNulls;
   }
 
   /** Return a new factory which uses {@linkplain JsonAdapter#lenient() lenient} adapters. */
   public MoshiConverterFactory asLenient() {
-    return new MoshiConverterFactory(moshi, true);
+    return new MoshiConverterFactory(moshi, true, failOnUnknown, serializeNulls);
+  }
+
+  /**
+   * Return a new factory which uses {@link JsonAdapter#failOnUnknown()} adapters.
+   */
+  public MoshiConverterFactory failOnUnknown() {
+    return new MoshiConverterFactory(moshi, lenient, true, serializeNulls);
+  }
+
+  /** Return a new factory which includes null values into the serialized JSON. */
+  public MoshiConverterFactory withNullSerialization() {
+    return new MoshiConverterFactory(moshi, lenient, failOnUnknown, true);
   }
 
   @Override
   public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
       Retrofit retrofit) {
-    JsonAdapter<?> adapter = moshi.adapter(type);
+    JsonAdapter<?> adapter = moshi.adapter(type, jsonAnnotations(annotations));
     if (lenient) {
       adapter = adapter.lenient();
     }
+    if (failOnUnknown) {
+      adapter = adapter.failOnUnknown();
+    }
+    if (serializeNulls) {
+      adapter = adapter.serializeNulls();
+    }
     return new MoshiResponseBodyConverter<>(adapter);
   }
 
-  @Override
-  public Converter<?, RequestBody> requestBodyConverter(Type type,
+  @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
       Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
-    JsonAdapter<?> adapter = moshi.adapter(type);
+    JsonAdapter<?> adapter = moshi.adapter(type, jsonAnnotations(parameterAnnotations));
     if (lenient) {
       adapter = adapter.lenient();
     }
+    if (failOnUnknown) {
+      adapter = adapter.failOnUnknown();
+    }
+    if (serializeNulls) {
+      adapter = adapter.serializeNulls();
+    }
     return new MoshiRequestBodyConverter<>(adapter);
   }
+
+  private static Set<? extends Annotation> jsonAnnotations(Annotation[] annotations) {
+    Set<Annotation> result = null;
+    for (Annotation annotation : annotations) {
+      if (annotation.annotationType().isAnnotationPresent(JsonQualifier.class)) {
+        if (result == null) result = new LinkedHashSet<>();
+        result.add(annotation);
+      }
+    }
+    return result != null ? unmodifiableSet(result) : Collections.<Annotation>emptySet();
+  }
 }
diff --git a/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiRequestBodyConverter.java b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiRequestBodyConverter.java
index ac3d095d3..edbcf243e 100644
--- a/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiRequestBodyConverter.java
+++ b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiRequestBodyConverter.java
@@ -16,6 +16,7 @@
 package retrofit2.converter.moshi;
 
 import com.squareup.moshi.JsonAdapter;
+import com.squareup.moshi.JsonWriter;
 import java.io.IOException;
 import okhttp3.MediaType;
 import okhttp3.RequestBody;
@@ -33,7 +34,8 @@
 
   @Override public RequestBody convert(T value) throws IOException {
     Buffer buffer = new Buffer();
-    adapter.toJson(buffer, value);
+    JsonWriter writer = JsonWriter.of(buffer);
+    adapter.toJson(writer, value);
     return RequestBody.create(MEDIA_TYPE, buffer.readByteString());
   }
 }
diff --git a/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiResponseBodyConverter.java b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiResponseBodyConverter.java
index b45b99c42..199776ff2 100644
--- a/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiResponseBodyConverter.java
+++ b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiResponseBodyConverter.java
@@ -18,9 +18,13 @@
 import com.squareup.moshi.JsonAdapter;
 import java.io.IOException;
 import okhttp3.ResponseBody;
+import okio.BufferedSource;
+import okio.ByteString;
 import retrofit2.Converter;
 
 final class MoshiResponseBodyConverter<T> implements Converter<ResponseBody, T> {
+  private static final ByteString UTF8_BOM = ByteString.decodeHex("EFBBBF");
+
   private final JsonAdapter<T> adapter;
 
   MoshiResponseBodyConverter(JsonAdapter<T> adapter) {
@@ -28,8 +32,14 @@
   }
 
   @Override public T convert(ResponseBody value) throws IOException {
+    BufferedSource source = value.source();
     try {
-      return adapter.fromJson(value.source());
+      // Moshi has no document-level API so the responsibility of BOM skipping falls to whatever
+      // is delegating to it. Since it's a UTF-8-only library as well we only honor the UTF-8 BOM.
+      if (source.rangeEquals(0, UTF8_BOM)) {
+        source.skip(UTF8_BOM.size());
+      }
+      return adapter.fromJson(source);
     } finally {
       value.close();
     }
diff --git a/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/package-info.java b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/package-info.java
new file mode 100644
index 000000000..2d5a38a51
--- /dev/null
+++ b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/package-info.java
@@ -0,0 +1,4 @@
+@ParametersAreNonnullByDefault
+package retrofit2.converter.moshi;
+
+import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-converters/moshi/src/test/java/retrofit2/converter/moshi/MoshiConverterFactoryTest.java b/retrofit-converters/moshi/src/test/java/retrofit2/converter/moshi/MoshiConverterFactoryTest.java
index 3a54a7ebe..14b00dafd 100644
--- a/retrofit-converters/moshi/src/test/java/retrofit2/converter/moshi/MoshiConverterFactoryTest.java
+++ b/retrofit-converters/moshi/src/test/java/retrofit2/converter/moshi/MoshiConverterFactoryTest.java
@@ -16,14 +16,24 @@
 package retrofit2.converter.moshi;
 
 import com.squareup.moshi.FromJson;
+import com.squareup.moshi.JsonAdapter;
+import com.squareup.moshi.JsonDataException;
+import com.squareup.moshi.JsonQualifier;
 import com.squareup.moshi.JsonReader;
 import com.squareup.moshi.JsonWriter;
 import com.squareup.moshi.Moshi;
 import com.squareup.moshi.ToJson;
 import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.annotation.Retention;
+import java.lang.reflect.Type;
+import java.nio.charset.Charset;
+import java.util.Set;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.RecordedRequest;
+import okio.Buffer;
+import okio.ByteString;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
@@ -33,11 +43,19 @@
 import retrofit2.http.Body;
 import retrofit2.http.POST;
 
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 
 public final class MoshiConverterFactoryTest {
+  @Retention(RUNTIME)
+  @JsonQualifier
+  @interface Qualifier {}
+
+  @Retention(RUNTIME)
+  @interface NonQualifer {}
+
   interface AnInterface {
     String getName();
   }
@@ -54,7 +72,7 @@
     }
   }
 
-  static class AnInterfaceAdapter {
+  static class Adapters {
     @ToJson public void write(JsonWriter jsonWriter, AnInterface anInterface) throws IOException {
       jsonWriter.beginObject();
       jsonWriter.name("name").value(anInterface.getName());
@@ -76,24 +94,54 @@
       jsonReader.endObject();
       return new AnImplementation(name);
     }
+
+    @ToJson public void write(JsonWriter writer, @Qualifier String value) throws IOException {
+      writer.value("qualified!");
+    }
+
+    @FromJson @Qualifier public String readQualified(JsonReader reader) throws IOException {
+      String string = reader.nextString();
+      if (string.equals("qualified!")) {
+        return "it worked!";
+      }
+      throw new AssertionError("Found: " + string);
+    }
   }
 
   interface Service {
     @POST("/") Call<AnImplementation> anImplementation(@Body AnImplementation impl);
     @POST("/") Call<AnInterface> anInterface(@Body AnInterface impl);
+
+    @POST("/") @Qualifier @NonQualifer //
+    Call<String> annotations(@Body @Qualifier @NonQualifer String body);
   }
 
   @Rule public final MockWebServer server = new MockWebServer();
 
   private Service service;
   private Service serviceLenient;
+  private Service serviceNulls;
+  private Service serviceFailOnUnknown;
 
   @Before public void setUp() {
     Moshi moshi = new Moshi.Builder()
-        .add(new AnInterfaceAdapter())
+        .add(new JsonAdapter.Factory() {
+          @Override public JsonAdapter<?> create(Type type, Set<? extends Annotation> annotations,
+              Moshi moshi) {
+            for (Annotation annotation : annotations) {
+              if (!annotation.annotationType().isAnnotationPresent(JsonQualifier.class)) {
+                throw new AssertionError("Non-@JsonQualifier annotation: " + annotation);
+              }
+            }
+            return null;
+          }
+        })
+        .add(new Adapters())
         .build();
     MoshiConverterFactory factory = MoshiConverterFactory.create(moshi);
     MoshiConverterFactory factoryLenient = factory.asLenient();
+    MoshiConverterFactory factoryNulls = factory.withNullSerialization();
+    MoshiConverterFactory factoryFailOnUnknown = factory.failOnUnknown();
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
         .addConverterFactory(factory)
@@ -102,8 +150,18 @@
         .baseUrl(server.url("/"))
         .addConverterFactory(factoryLenient)
         .build();
+    Retrofit retrofitNulls = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(factoryNulls)
+        .build();
+    Retrofit retrofitFailOnUnknown = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(factoryFailOnUnknown)
+        .build();
     service = retrofit.create(Service.class);
     serviceLenient = retrofitLenient.create(Service.class);
+    serviceNulls = retrofitNulls.create(Service.class);
+    serviceFailOnUnknown = retrofitFailOnUnknown.create(Service.class);
   }
 
   @Test public void anInterface() throws IOException, InterruptedException {
@@ -132,6 +190,18 @@
     assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
   }
 
+  @Test public void annotations() throws IOException, InterruptedException {
+    server.enqueue(new MockResponse().setBody("\"qualified!\""));
+
+    Call<String> call = service.annotations("value");
+    Response<String> response = call.execute();
+    assertThat(response.body()).isEqualTo("it worked!");
+
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getBody().readUtf8()).isEqualTo("\"qualified!\"");
+    assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
+  }
+
   @Test public void asLenient() throws IOException, InterruptedException {
     MockResponse malformedResponse = new MockResponse().setBody("{\"theName\":value}");
     server.enqueue(malformedResponse);
@@ -151,4 +221,52 @@
     AnImplementation body = response.body();
     assertThat(body.theName).isEqualTo("value");
   }
+
+  @Test public void withNulls() throws IOException, InterruptedException {
+    server.enqueue(new MockResponse().setBody("{}"));
+
+    Call<AnImplementation> call = serviceNulls.anImplementation(new AnImplementation(null));
+    call.execute();
+    assertEquals("{\"theName\":null}", server.takeRequest().getBody().readUtf8());
+  }
+
+  @Test public void failOnUnknown() throws IOException, InterruptedException {
+    server.enqueue(new MockResponse().setBody("{\"taco\":\"delicious\"}"));
+
+    Call<AnImplementation> call = serviceFailOnUnknown.anImplementation(new AnImplementation(null));
+    try {
+      call.execute();
+      fail();
+    } catch (JsonDataException e) {
+      assertThat(e).hasMessage("Cannot skip unexpected STRING at $.taco");
+    }
+  }
+
+  @Test public void utf8BomSkipped() throws IOException {
+    Buffer responseBody = new Buffer()
+        .write(ByteString.decodeHex("EFBBBF"))
+        .writeUtf8("{\"theName\":\"value\"}");
+    MockResponse malformedResponse = new MockResponse().setBody(responseBody);
+    server.enqueue(malformedResponse);
+
+    Call<AnImplementation> call = service.anImplementation(new AnImplementation("value"));
+    Response<AnImplementation> response = call.execute();
+    AnImplementation body = response.body();
+    assertThat(body.theName).isEqualTo("value");
+  }
+
+  @Test public void nonUtf8BomIsNotSkipped() throws IOException {
+    Buffer responseBody = new Buffer()
+        .write(ByteString.decodeHex("FEFF"))
+        .writeString("{\"theName\":\"value\"}", Charset.forName("UTF-16"));
+    MockResponse malformedResponse = new MockResponse().setBody(responseBody);
+    server.enqueue(malformedResponse);
+
+    Call<AnImplementation> call = service.anImplementation(new AnImplementation("value"));
+    try {
+      call.execute();
+      fail();
+    } catch (IOException expected) {
+    }
+  }
 }
diff --git a/retrofit-converters/pom.xml b/retrofit-converters/pom.xml
index b706f411e..c6258b38c 100644
--- a/retrofit-converters/pom.xml
+++ b/retrofit-converters/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>parent</artifactId>
-    <version>2.0.1</version>
+    <version>2.4.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -16,8 +16,10 @@
 
   <modules>
     <module>gson</module>
+    <module>guava</module>
     <module>protobuf</module>
     <module>jackson</module>
+    <module>java8</module>
     <module>wire</module>
     <module>simplexml</module>
     <module>scalars</module>
diff --git a/retrofit-converters/protobuf/README.md b/retrofit-converters/protobuf/README.md
index ca4334147..7575a3d6c 100644
--- a/retrofit-converters/protobuf/README.md
+++ b/retrofit-converters/protobuf/README.md
@@ -4,4 +4,27 @@ Google Protocol Buffer Converter
 A `Converter` which uses [Protocol Buffer][1] binary serialization.
 
 
+Download
+--------
+
+Download [the latest JAR][2] or grab via [Maven][3]:
+```xml
+<dependency>
+  <groupId>com.squareup.retrofit2</groupId>
+  <artifactId>converter-protobuf</artifactId>
+  <version>latest.version</version>
+</dependency>
+```
+or [Gradle][3]:
+```groovy
+compile 'com.squareup.retrofit2:converter-protobuf:latest.version'
+```
+
+Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
+
+
+
  [1]: https://developers.google.com/protocol-buffers/
+ [2]: https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=converter-protobuf&v=LATEST
+ [3]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup.retrofit2%22%20a%3A%22converter-protobuf%22
+ [snap]: https://oss.sonatype.org/content/repositories/snapshots/
diff --git a/retrofit-converters/protobuf/pom.xml b/retrofit-converters/protobuf/pom.xml
index f678671db..e70cd7fba 100644
--- a/retrofit-converters/protobuf/pom.xml
+++ b/retrofit-converters/protobuf/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-converters</artifactId>
-    <version>2.0.1</version>
+    <version>2.4.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -23,6 +23,11 @@
       <groupId>com.google.protobuf</groupId>
       <artifactId>protobuf-java</artifactId>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
diff --git a/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoConverterFactory.java b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoConverterFactory.java
index aa4420c9d..6fb529429 100644
--- a/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoConverterFactory.java
+++ b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoConverterFactory.java
@@ -15,11 +15,15 @@
  */
 package retrofit2.converter.protobuf;
 
+import com.google.protobuf.ExtensionRegistryLite;
 import com.google.protobuf.MessageLite;
 import com.google.protobuf.Parser;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Field;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
 import java.lang.reflect.Type;
+import javax.annotation.Nullable;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import retrofit2.Converter;
@@ -33,7 +37,18 @@
  */
 public final class ProtoConverterFactory extends Converter.Factory {
   public static ProtoConverterFactory create() {
-    return new ProtoConverterFactory();
+    return new ProtoConverterFactory(null);
+  }
+
+  /** Create an instance which uses {@code registry} when deserializing. */
+  public static ProtoConverterFactory createWithRegistry(@Nullable ExtensionRegistryLite registry) {
+    return new ProtoConverterFactory(registry);
+  }
+
+  private final @Nullable ExtensionRegistryLite registry;
+
+  private ProtoConverterFactory(@Nullable ExtensionRegistryLite registry) {
+    this.registry = registry;
   }
 
   @Override
@@ -49,14 +64,24 @@ public static ProtoConverterFactory create() {
 
     Parser<MessageLite> parser;
     try {
-      Field field = c.getDeclaredField("PARSER");
+      Method method = c.getDeclaredMethod("parser");
       //noinspection unchecked
-      parser = (Parser<MessageLite>) field.get(null);
-    } catch (NoSuchFieldException | IllegalAccessException e) {
-      throw new IllegalArgumentException(
-          "Found a protobuf message but " + c.getName() + " had no PARSER field.");
+      parser = (Parser<MessageLite>) method.invoke(null);
+    } catch (InvocationTargetException e) {
+      throw new RuntimeException(e.getCause());
+    } catch (NoSuchMethodException | IllegalAccessException ignored) {
+      // If the method is missing, fall back to original static field for pre-3.0 support.
+      try {
+        Field field = c.getDeclaredField("PARSER");
+        //noinspection unchecked
+        parser = (Parser<MessageLite>) field.get(null);
+      } catch (NoSuchFieldException | IllegalAccessException e) {
+        throw new IllegalArgumentException("Found a protobuf message but "
+            + c.getName()
+            + " had no parser() method or PARSER field.");
+      }
     }
-    return new ProtoResponseBodyConverter<>(parser);
+    return new ProtoResponseBodyConverter<>(parser, registry);
   }
 
   @Override
diff --git a/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoResponseBodyConverter.java b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoResponseBodyConverter.java
index f2b78e1de..fc840dc64 100644
--- a/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoResponseBodyConverter.java
+++ b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoResponseBodyConverter.java
@@ -15,24 +15,28 @@
  */
 package retrofit2.converter.protobuf;
 
+import com.google.protobuf.ExtensionRegistryLite;
 import com.google.protobuf.InvalidProtocolBufferException;
 import com.google.protobuf.MessageLite;
 import com.google.protobuf.Parser;
 import java.io.IOException;
+import javax.annotation.Nullable;
 import okhttp3.ResponseBody;
 import retrofit2.Converter;
 
 final class ProtoResponseBodyConverter<T extends MessageLite>
     implements Converter<ResponseBody, T> {
   private final Parser<T> parser;
+  private final @Nullable ExtensionRegistryLite registry;
 
-  ProtoResponseBodyConverter(Parser<T> parser) {
+  ProtoResponseBodyConverter(Parser<T> parser, @Nullable ExtensionRegistryLite registry) {
     this.parser = parser;
+    this.registry = registry;
   }
 
   @Override public T convert(ResponseBody value) throws IOException {
     try {
-      return parser.parseFrom(value.byteStream());
+      return parser.parseFrom(value.byteStream(), registry);
     } catch (InvalidProtocolBufferException e) {
       throw new RuntimeException(e); // Despite extending IOException, this is data mismatch.
     } finally {
diff --git a/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/package-info.java b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/package-info.java
new file mode 100644
index 000000000..c976ca568
--- /dev/null
+++ b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/package-info.java
@@ -0,0 +1,4 @@
+@ParametersAreNonnullByDefault
+package retrofit2.converter.protobuf;
+
+import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/FallbackParserFinderTest.java b/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/FallbackParserFinderTest.java
new file mode 100644
index 000000000..b37ab55bc
--- /dev/null
+++ b/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/FallbackParserFinderTest.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.converter.protobuf;
+
+import com.google.protobuf.MessageLite;
+import com.google.protobuf.Parser;
+import java.lang.annotation.Annotation;
+import okhttp3.ResponseBody;
+import org.junit.Test;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
+import retrofit2.converter.protobuf.PhoneProtos.Phone;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class FallbackParserFinderTest {
+  @Test public void converterFactoryFallsBackToParserField() {
+    Retrofit retrofit = new Retrofit.Builder().baseUrl("http://localhost/").build();
+    ProtoConverterFactory factory = ProtoConverterFactory.create();
+    Converter<ResponseBody, ?> converter =
+        factory.responseBodyConverter(FakePhone.class, new Annotation[0], retrofit);
+    assertThat(converter).isNotNull();
+  }
+
+  @SuppressWarnings("unused") // Used reflectively.
+  public static abstract class FakePhone implements MessageLite {
+    public static final Parser<Phone> PARSER = Phone.parser();
+  }
+}
diff --git a/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/PhoneProtos.java b/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/PhoneProtos.java
index 69b41325b..3ad1bb0f6 100644
--- a/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/PhoneProtos.java
+++ b/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/PhoneProtos.java
@@ -3,17 +3,23 @@
 
 package retrofit2.converter.protobuf;
 
-import com.google.protobuf.AbstractMessage;
-
 public final class PhoneProtos {
   private PhoneProtos() {}
+  public static void registerAllExtensions(
+      com.google.protobuf.ExtensionRegistryLite registry) {
+    registry.add(retrofit2.converter.protobuf.PhoneProtos.voicemail);
+  }
+
   public static void registerAllExtensions(
       com.google.protobuf.ExtensionRegistry registry) {
+    registerAllExtensions(
+        (com.google.protobuf.ExtensionRegistryLite) registry);
   }
-  public interface PhoneOrBuilder
-      extends com.google.protobuf.MessageOrBuilder {
+  public interface PhoneOrBuilder extends
+      // @@protoc_insertion_point(interface_extends:retrofit2.converter.protobuf.Phone)
+      com.google.protobuf.GeneratedMessage.
+          ExtendableMessageOrBuilder<Phone> {
 
-    // optional string number = 1;
     /**
      * <code>optional string number = 1;</code>
      */
@@ -29,38 +35,31 @@ public static void registerAllExtensions(
         getNumberBytes();
   }
   /**
-   * Protobuf type {@code retrofit2.Phone}
+   * Protobuf type {@code retrofit2.converter.protobuf.Phone}
    */
-  public static final class Phone extends
-      com.google.protobuf.GeneratedMessage
-      implements PhoneOrBuilder {
+  public  static final class Phone extends
+      com.google.protobuf.GeneratedMessage.ExtendableMessage<
+        Phone> implements
+      // @@protoc_insertion_point(message_implements:retrofit2.converter.protobuf.Phone)
+      PhoneOrBuilder {
     // Use Phone.newBuilder() to construct.
-    private Phone(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
+    private Phone(com.google.protobuf.GeneratedMessage.ExtendableBuilder<retrofit2.converter.protobuf.PhoneProtos.Phone, ?> builder) {
       super(builder);
-      this.unknownFields = builder.getUnknownFields();
     }
-    private Phone(boolean noInit) { this.unknownFields = com.google.protobuf.UnknownFieldSet.getDefaultInstance(); }
-
-    private static final Phone defaultInstance;
-    public static Phone getDefaultInstance() {
-      return defaultInstance;
-    }
-
-    public Phone getDefaultInstanceForType() {
-      return defaultInstance;
+    private Phone() {
+      number_ = "";
     }
 
-    private final com.google.protobuf.UnknownFieldSet unknownFields;
     @java.lang.Override
     public final com.google.protobuf.UnknownFieldSet
-        getUnknownFields() {
+    getUnknownFields() {
       return this.unknownFields;
     }
     private Phone(
         com.google.protobuf.CodedInputStream input,
         com.google.protobuf.ExtensionRegistryLite extensionRegistry)
         throws com.google.protobuf.InvalidProtocolBufferException {
-      initFields();
+      this();
       int mutable_bitField0_ = 0;
       com.google.protobuf.UnknownFieldSet.Builder unknownFields =
           com.google.protobuf.UnknownFieldSet.newBuilder();
@@ -80,8 +79,9 @@ private Phone(
               break;
             }
             case 10: {
+              com.google.protobuf.ByteString bs = input.readBytes();
               bitField0_ |= 0x00000001;
-              number_ = input.readBytes();
+              number_ = bs;
               break;
             }
           }
@@ -90,7 +90,7 @@ private Phone(
         throw e.setUnfinishedMessage(this);
       } catch (java.io.IOException e) {
         throw new com.google.protobuf.InvalidProtocolBufferException(
-            e.getMessage()).setUnfinishedMessage(this);
+            e).setUnfinishedMessage(this);
       } finally {
         this.unknownFields = unknownFields.build();
         makeExtensionsImmutable();
@@ -98,35 +98,19 @@ private Phone(
     }
     public static final com.google.protobuf.Descriptors.Descriptor
         getDescriptor() {
-      return PhoneProtos.internal_static_retrofit_Phone_descriptor;
+      return retrofit2.converter.protobuf.PhoneProtos.internal_static_retrofit2_converter_protobuf_Phone_descriptor;
     }
 
     protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
         internalGetFieldAccessorTable() {
-      return PhoneProtos.internal_static_retrofit_Phone_fieldAccessorTable
+      return retrofit2.converter.protobuf.PhoneProtos.internal_static_retrofit2_converter_protobuf_Phone_fieldAccessorTable
           .ensureFieldAccessorsInitialized(
-              PhoneProtos.Phone.class, PhoneProtos.Phone.Builder.class);
-    }
-
-    public static com.google.protobuf.Parser<Phone> PARSER =
-        new com.google.protobuf.AbstractParser<Phone>() {
-      public Phone parsePartialFrom(
-          com.google.protobuf.CodedInputStream input,
-          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
-          throws com.google.protobuf.InvalidProtocolBufferException {
-        return new Phone(input, extensionRegistry);
-      }
-    };
-
-    @java.lang.Override
-    public com.google.protobuf.Parser<Phone> getParserForType() {
-      return PARSER;
+              retrofit2.converter.protobuf.PhoneProtos.Phone.class, retrofit2.converter.protobuf.PhoneProtos.Phone.Builder.class);
     }
 
     private int bitField0_;
-    // optional string number = 1;
     public static final int NUMBER_FIELD_NUMBER = 1;
-    private java.lang.Object number_;
+    private volatile java.lang.Object number_;
     /**
      * <code>optional string number = 1;</code>
      */
@@ -141,7 +125,7 @@ public boolean hasNumber() {
       if (ref instanceof java.lang.String) {
         return (java.lang.String) ref;
       } else {
-        com.google.protobuf.ByteString bs =
+        com.google.protobuf.ByteString bs = 
             (com.google.protobuf.ByteString) ref;
         java.lang.String s = bs.toStringUtf8();
         if (bs.isValidUtf8()) {
@@ -157,7 +141,7 @@ public boolean hasNumber() {
         getNumberBytes() {
       java.lang.Object ref = number_;
       if (ref instanceof java.lang.String) {
-        com.google.protobuf.ByteString b =
+        com.google.protobuf.ByteString b = 
             com.google.protobuf.ByteString.copyFromUtf8(
                 (java.lang.String) ref);
         number_ = b;
@@ -167,108 +151,156 @@ public boolean hasNumber() {
       }
     }
 
-    private void initFields() {
-      number_ = "";
-    }
     private byte memoizedIsInitialized = -1;
     public final boolean isInitialized() {
       byte isInitialized = memoizedIsInitialized;
-      if (isInitialized != -1) return isInitialized == 1;
+      if (isInitialized == 1) return true;
+      if (isInitialized == 0) return false;
 
+      if (!extensionsAreInitialized()) {
+        memoizedIsInitialized = 0;
+        return false;
+      }
       memoizedIsInitialized = 1;
       return true;
     }
 
     public void writeTo(com.google.protobuf.CodedOutputStream output)
                         throws java.io.IOException {
-      getSerializedSize();
+      com.google.protobuf.GeneratedMessage
+        .ExtendableMessage<retrofit2.converter.protobuf.PhoneProtos.Phone>.ExtensionWriter
+          extensionWriter = newExtensionWriter();
       if (((bitField0_ & 0x00000001) == 0x00000001)) {
-        output.writeBytes(1, getNumberBytes());
+        com.google.protobuf.GeneratedMessage.writeString(output, 1, number_);
       }
-      getUnknownFields().writeTo(output);
+      extensionWriter.writeUntil(3, output);
+      unknownFields.writeTo(output);
     }
 
-    private int memoizedSerializedSize = -1;
     public int getSerializedSize() {
-      int size = memoizedSerializedSize;
+      int size = memoizedSize;
       if (size != -1) return size;
 
       size = 0;
       if (((bitField0_ & 0x00000001) == 0x00000001)) {
-        size += com.google.protobuf.CodedOutputStream
-          .computeBytesSize(1, getNumberBytes());
+        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, number_);
       }
-      size += getUnknownFields().getSerializedSize();
-      memoizedSerializedSize = size;
+      size += extensionsSerializedSize();
+      size += unknownFields.getSerializedSize();
+      memoizedSize = size;
       return size;
     }
 
     private static final long serialVersionUID = 0L;
     @java.lang.Override
-    protected java.lang.Object writeReplace()
-        throws java.io.ObjectStreamException {
-      return super.writeReplace();
+    public boolean equals(final java.lang.Object obj) {
+      if (obj == this) {
+       return true;
+      }
+      if (!(obj instanceof retrofit2.converter.protobuf.PhoneProtos.Phone)) {
+        return super.equals(obj);
+      }
+      retrofit2.converter.protobuf.PhoneProtos.Phone other = (retrofit2.converter.protobuf.PhoneProtos.Phone) obj;
+
+      boolean result = true;
+      result = result && (hasNumber() == other.hasNumber());
+      if (hasNumber()) {
+        result = result && getNumber()
+            .equals(other.getNumber());
+      }
+      result = result && unknownFields.equals(other.unknownFields);
+      result = result &&
+          getExtensionFields().equals(other.getExtensionFields());
+      return result;
     }
 
-    public static PhoneProtos.Phone parseFrom(
+    @java.lang.Override
+    public int hashCode() {
+      if (memoizedHashCode != 0) {
+        return memoizedHashCode;
+      }
+      int hash = 41;
+      hash = (19 * hash) + getDescriptorForType().hashCode();
+      if (hasNumber()) {
+        hash = (37 * hash) + NUMBER_FIELD_NUMBER;
+        hash = (53 * hash) + getNumber().hashCode();
+      }
+      hash = hashFields(hash, getExtensionFields());
+      hash = (29 * hash) + unknownFields.hashCode();
+      memoizedHashCode = hash;
+      return hash;
+    }
+
+    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(
         com.google.protobuf.ByteString data)
         throws com.google.protobuf.InvalidProtocolBufferException {
       return PARSER.parseFrom(data);
     }
-    public static PhoneProtos.Phone parseFrom(
+    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(
         com.google.protobuf.ByteString data,
         com.google.protobuf.ExtensionRegistryLite extensionRegistry)
         throws com.google.protobuf.InvalidProtocolBufferException {
       return PARSER.parseFrom(data, extensionRegistry);
     }
-    public static PhoneProtos.Phone parseFrom(byte[] data)
+    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(byte[] data)
         throws com.google.protobuf.InvalidProtocolBufferException {
       return PARSER.parseFrom(data);
     }
-    public static PhoneProtos.Phone parseFrom(
+    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(
         byte[] data,
         com.google.protobuf.ExtensionRegistryLite extensionRegistry)
         throws com.google.protobuf.InvalidProtocolBufferException {
       return PARSER.parseFrom(data, extensionRegistry);
     }
-    public static PhoneProtos.Phone parseFrom(java.io.InputStream input)
+    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(java.io.InputStream input)
         throws java.io.IOException {
-      return PARSER.parseFrom(input);
+      return com.google.protobuf.GeneratedMessage
+          .parseWithIOException(PARSER, input);
     }
-    public static PhoneProtos.Phone parseFrom(
+    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(
         java.io.InputStream input,
         com.google.protobuf.ExtensionRegistryLite extensionRegistry)
         throws java.io.IOException {
-      return PARSER.parseFrom(input, extensionRegistry);
+      return com.google.protobuf.GeneratedMessage
+          .parseWithIOException(PARSER, input, extensionRegistry);
     }
-    public static PhoneProtos.Phone parseDelimitedFrom(java.io.InputStream input)
+    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseDelimitedFrom(java.io.InputStream input)
         throws java.io.IOException {
-      return PARSER.parseDelimitedFrom(input);
+      return com.google.protobuf.GeneratedMessage
+          .parseDelimitedWithIOException(PARSER, input);
     }
-    public static PhoneProtos.Phone parseDelimitedFrom(
+    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseDelimitedFrom(
         java.io.InputStream input,
         com.google.protobuf.ExtensionRegistryLite extensionRegistry)
         throws java.io.IOException {
-      return PARSER.parseDelimitedFrom(input, extensionRegistry);
+      return com.google.protobuf.GeneratedMessage
+          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
     }
-    public static PhoneProtos.Phone parseFrom(
+    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(
         com.google.protobuf.CodedInputStream input)
         throws java.io.IOException {
-      return PARSER.parseFrom(input);
+      return com.google.protobuf.GeneratedMessage
+          .parseWithIOException(PARSER, input);
     }
-    public static PhoneProtos.Phone parseFrom(
+    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(
         com.google.protobuf.CodedInputStream input,
         com.google.protobuf.ExtensionRegistryLite extensionRegistry)
         throws java.io.IOException {
-      return PARSER.parseFrom(input, extensionRegistry);
+      return com.google.protobuf.GeneratedMessage
+          .parseWithIOException(PARSER, input, extensionRegistry);
     }
 
-    public static Builder newBuilder() { return Builder.create(); }
     public Builder newBuilderForType() { return newBuilder(); }
-    public static Builder newBuilder(PhoneProtos.Phone prototype) {
-      return newBuilder().mergeFrom(prototype);
+    public static Builder newBuilder() {
+      return DEFAULT_INSTANCE.toBuilder();
+    }
+    public static Builder newBuilder(retrofit2.converter.protobuf.PhoneProtos.Phone prototype) {
+      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
+    }
+    public Builder toBuilder() {
+      return this == DEFAULT_INSTANCE
+          ? new Builder() : new Builder().mergeFrom(this);
     }
-    public Builder toBuilder() { return newBuilder(this); }
 
     @java.lang.Override
     protected Builder newBuilderForType(
@@ -277,21 +309,23 @@ protected Builder newBuilderForType(
       return builder;
     }
     /**
-     * Protobuf type {@code retrofit2.Phone}
+     * Protobuf type {@code retrofit2.converter.protobuf.Phone}
      */
     public static final class Builder extends
-        com.google.protobuf.GeneratedMessage.Builder<Builder>
-       implements PhoneProtos.PhoneOrBuilder {
+        com.google.protobuf.GeneratedMessage.ExtendableBuilder<
+          retrofit2.converter.protobuf.PhoneProtos.Phone, Builder> implements
+        // @@protoc_insertion_point(builder_implements:retrofit2.converter.protobuf.Phone)
+        retrofit2.converter.protobuf.PhoneProtos.PhoneOrBuilder {
       public static final com.google.protobuf.Descriptors.Descriptor
           getDescriptor() {
-        return PhoneProtos.internal_static_retrofit_Phone_descriptor;
+        return retrofit2.converter.protobuf.PhoneProtos.internal_static_retrofit2_converter_protobuf_Phone_descriptor;
       }
 
       protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
           internalGetFieldAccessorTable() {
-        return PhoneProtos.internal_static_retrofit_Phone_fieldAccessorTable
+        return retrofit2.converter.protobuf.PhoneProtos.internal_static_retrofit2_converter_protobuf_Phone_fieldAccessorTable
             .ensureFieldAccessorsInitialized(
-                PhoneProtos.Phone.class, PhoneProtos.Phone.Builder.class);
+                retrofit2.converter.protobuf.PhoneProtos.Phone.class, retrofit2.converter.protobuf.PhoneProtos.Phone.Builder.class);
       }
 
       // Construct using retrofit2.converter.protobuf.PhoneProtos.Phone.newBuilder()
@@ -308,10 +342,6 @@ private void maybeForceBuilderInitialization() {
         if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {
         }
       }
-      private static Builder create() {
-        return new Builder();
-      }
-
       public Builder clear() {
         super.clear();
         number_ = "";
@@ -319,29 +349,25 @@ public Builder clear() {
         return this;
       }
 
-      public Builder clone() {
-        return create().mergeFrom(buildPartial());
-      }
-
       public com.google.protobuf.Descriptors.Descriptor
           getDescriptorForType() {
-        return PhoneProtos.internal_static_retrofit_Phone_descriptor;
+        return retrofit2.converter.protobuf.PhoneProtos.internal_static_retrofit2_converter_protobuf_Phone_descriptor;
       }
 
-      public PhoneProtos.Phone getDefaultInstanceForType() {
-        return PhoneProtos.Phone.getDefaultInstance();
+      public retrofit2.converter.protobuf.PhoneProtos.Phone getDefaultInstanceForType() {
+        return retrofit2.converter.protobuf.PhoneProtos.Phone.getDefaultInstance();
       }
 
-      public PhoneProtos.Phone build() {
-        PhoneProtos.Phone result = buildPartial();
+      public retrofit2.converter.protobuf.PhoneProtos.Phone build() {
+        retrofit2.converter.protobuf.PhoneProtos.Phone result = buildPartial();
         if (!result.isInitialized()) {
-          throw AbstractMessage.Builder.newUninitializedMessageException(result);
+          throw newUninitializedMessageException(result);
         }
         return result;
       }
 
-      public PhoneProtos.Phone buildPartial() {
-        PhoneProtos.Phone result = new PhoneProtos.Phone(this);
+      public retrofit2.converter.protobuf.PhoneProtos.Phone buildPartial() {
+        retrofit2.converter.protobuf.PhoneProtos.Phone result = new retrofit2.converter.protobuf.PhoneProtos.Phone(this);
         int from_bitField0_ = bitField0_;
         int to_bitField0_ = 0;
         if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
@@ -353,27 +379,81 @@ public Builder clone() {
         return result;
       }
 
+      public Builder clone() {
+        return (Builder) super.clone();
+      }
+      public Builder setField(
+          com.google.protobuf.Descriptors.FieldDescriptor field,
+          Object value) {
+        return (Builder) super.setField(field, value);
+      }
+      public Builder clearField(
+          com.google.protobuf.Descriptors.FieldDescriptor field) {
+        return (Builder) super.clearField(field);
+      }
+      public Builder clearOneof(
+          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
+        return (Builder) super.clearOneof(oneof);
+      }
+      public Builder setRepeatedField(
+          com.google.protobuf.Descriptors.FieldDescriptor field,
+          int index, Object value) {
+        return (Builder) super.setRepeatedField(field, index, value);
+      }
+      public Builder addRepeatedField(
+          com.google.protobuf.Descriptors.FieldDescriptor field,
+          Object value) {
+        return (Builder) super.addRepeatedField(field, value);
+      }
+      public <Type> Builder setExtension(
+          com.google.protobuf.GeneratedMessage.GeneratedExtension<
+              retrofit2.converter.protobuf.PhoneProtos.Phone, Type> extension,
+          Type value) {
+        return (Builder) super.setExtension(extension, value);
+      }
+      public <Type> Builder setExtension(
+          com.google.protobuf.GeneratedMessage.GeneratedExtension<
+              retrofit2.converter.protobuf.PhoneProtos.Phone, java.util.List<Type>> extension,
+          int index, Type value) {
+        return (Builder) super.setExtension(extension, index, value);
+      }
+      public <Type> Builder addExtension(
+          com.google.protobuf.GeneratedMessage.GeneratedExtension<
+              retrofit2.converter.protobuf.PhoneProtos.Phone, java.util.List<Type>> extension,
+          Type value) {
+        return (Builder) super.addExtension(extension, value);
+      }
+      public <Type> Builder clearExtension(
+          com.google.protobuf.GeneratedMessage.GeneratedExtension<
+              retrofit2.converter.protobuf.PhoneProtos.Phone, ?> extension) {
+        return (Builder) super.clearExtension(extension);
+      }
       public Builder mergeFrom(com.google.protobuf.Message other) {
-        if (other instanceof PhoneProtos.Phone) {
-          return mergeFrom((PhoneProtos.Phone)other);
+        if (other instanceof retrofit2.converter.protobuf.PhoneProtos.Phone) {
+          return mergeFrom((retrofit2.converter.protobuf.PhoneProtos.Phone)other);
         } else {
           super.mergeFrom(other);
           return this;
         }
       }
 
-      public Builder mergeFrom(PhoneProtos.Phone other) {
-        if (other == PhoneProtos.Phone.getDefaultInstance()) return this;
+      public Builder mergeFrom(retrofit2.converter.protobuf.PhoneProtos.Phone other) {
+        if (other == retrofit2.converter.protobuf.PhoneProtos.Phone.getDefaultInstance()) return this;
         if (other.hasNumber()) {
           bitField0_ |= 0x00000001;
           number_ = other.number_;
           onChanged();
         }
-        this.mergeUnknownFields(other.getUnknownFields());
+        this.mergeExtensionFields(other);
+        this.mergeUnknownFields(other.unknownFields);
+        onChanged();
         return this;
       }
 
       public final boolean isInitialized() {
+        if (!extensionsAreInitialized()) {
+          return false;
+        }
         return true;
       }
 
@@ -381,12 +461,12 @@ public Builder mergeFrom(
           com.google.protobuf.CodedInputStream input,
           com.google.protobuf.ExtensionRegistryLite extensionRegistry)
           throws java.io.IOException {
-        PhoneProtos.Phone parsedMessage = null;
+        retrofit2.converter.protobuf.PhoneProtos.Phone parsedMessage = null;
         try {
           parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
         } catch (com.google.protobuf.InvalidProtocolBufferException e) {
-          parsedMessage = (PhoneProtos.Phone) e.getUnfinishedMessage();
-          throw e;
+          parsedMessage = (retrofit2.converter.protobuf.PhoneProtos.Phone) e.getUnfinishedMessage();
+          throw e.unwrapIOException();
         } finally {
           if (parsedMessage != null) {
             mergeFrom(parsedMessage);
@@ -396,7 +476,6 @@ public Builder mergeFrom(
       }
       private int bitField0_;
 
-      // optional string number = 1;
       private java.lang.Object number_ = "";
       /**
        * <code>optional string number = 1;</code>
@@ -410,9 +489,12 @@ public boolean hasNumber() {
       public java.lang.String getNumber() {
         java.lang.Object ref = number_;
         if (!(ref instanceof java.lang.String)) {
-          java.lang.String s = ((com.google.protobuf.ByteString) ref)
-              .toStringUtf8();
-          number_ = s;
+          com.google.protobuf.ByteString bs =
+              (com.google.protobuf.ByteString) ref;
+          java.lang.String s = bs.toStringUtf8();
+          if (bs.isValidUtf8()) {
+            number_ = s;
+          }
           return s;
         } else {
           return (java.lang.String) ref;
@@ -425,7 +507,7 @@ public boolean hasNumber() {
           getNumberBytes() {
         java.lang.Object ref = number_;
         if (ref instanceof String) {
-          com.google.protobuf.ByteString b =
+          com.google.protobuf.ByteString b = 
               com.google.protobuf.ByteString.copyFromUtf8(
                   (java.lang.String) ref);
           number_ = b;
@@ -469,54 +551,105 @@ public Builder setNumberBytes(
         onChanged();
         return this;
       }
+      public final Builder setUnknownFields(
+          final com.google.protobuf.UnknownFieldSet unknownFields) {
+        return super.setUnknownFields(unknownFields);
+      }
+
+      public final Builder mergeUnknownFields(
+          final com.google.protobuf.UnknownFieldSet unknownFields) {
+        return super.mergeUnknownFields(unknownFields);
+      }
+
 
-      // @@protoc_insertion_point(builder_scope:retrofit2.Phone)
+      // @@protoc_insertion_point(builder_scope:retrofit2.converter.protobuf.Phone)
     }
 
+    // @@protoc_insertion_point(class_scope:retrofit2.converter.protobuf.Phone)
+    private static final retrofit2.converter.protobuf.PhoneProtos.Phone DEFAULT_INSTANCE;
     static {
-      defaultInstance = new Phone(true);
-      defaultInstance.initFields();
+      DEFAULT_INSTANCE = new retrofit2.converter.protobuf.PhoneProtos.Phone();
+    }
+
+    public static retrofit2.converter.protobuf.PhoneProtos.Phone getDefaultInstance() {
+      return DEFAULT_INSTANCE;
+    }
+
+    @java.lang.Deprecated public static final com.google.protobuf.Parser<Phone>
+        PARSER = new com.google.protobuf.AbstractParser<Phone>() {
+      public Phone parsePartialFrom(
+          com.google.protobuf.CodedInputStream input,
+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+          throws com.google.protobuf.InvalidProtocolBufferException {
+          return new Phone(input, extensionRegistry);
+      }
+    };
+
+    public static com.google.protobuf.Parser<Phone> parser() {
+      return PARSER;
+    }
+
+    @java.lang.Override
+    public com.google.protobuf.Parser<Phone> getParserForType() {
+      return PARSER;
+    }
+
+    public retrofit2.converter.protobuf.PhoneProtos.Phone getDefaultInstanceForType() {
+      return DEFAULT_INSTANCE;
     }
 
-    // @@protoc_insertion_point(class_scope:retrofit2.Phone)
   }
 
-  private static com.google.protobuf.Descriptors.Descriptor
-    internal_static_retrofit_Phone_descriptor;
-  private static
+  public static final int VOICEMAIL_FIELD_NUMBER = 2;
+  /**
+   * <code>extend .retrofit2.converter.protobuf.Phone { ... }</code>
+   */
+  public static final
+    com.google.protobuf.GeneratedMessage.GeneratedExtension<
+      retrofit2.converter.protobuf.PhoneProtos.Phone,
+      java.lang.Boolean> voicemail = com.google.protobuf.GeneratedMessage
+          .newFileScopedGeneratedExtension(
+        java.lang.Boolean.class,
+        null);
+  private static final com.google.protobuf.Descriptors.Descriptor
+    internal_static_retrofit2_converter_protobuf_Phone_descriptor;
+  private static final 
     com.google.protobuf.GeneratedMessage.FieldAccessorTable
-      internal_static_retrofit_Phone_fieldAccessorTable;
+      internal_static_retrofit2_converter_protobuf_Phone_fieldAccessorTable;
 
   public static com.google.protobuf.Descriptors.FileDescriptor
       getDescriptor() {
     return descriptor;
   }
-  private static com.google.protobuf.Descriptors.FileDescriptor
+  private static  com.google.protobuf.Descriptors.FileDescriptor
       descriptor;
   static {
     java.lang.String[] descriptorData = {
-      "\n\022protos/phone.proto\022\010retrofit\"\027\n\005Phone\022" +
-      "\016\n\006number\030\001 \001(\tB!\n\022retrofit.converterB\013P" +
-      "honeProtos"
+      "\n\022protos/phone.proto\022\034retrofit2.converte" +
+      "r.protobuf\"\035\n\005Phone\022\016\n\006number\030\001 \001(\t*\004\010\002\020" +
+      "\003:6\n\tvoicemail\022#.retrofit2.converter.pro" +
+      "tobuf.Phone\030\002 \001(\010B+\n\034retrofit2.converter" +
+      ".protobufB\013PhoneProtos"
     };
     com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner assigner =
-      new com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner() {
-        public com.google.protobuf.ExtensionRegistry assignDescriptors(
-            com.google.protobuf.Descriptors.FileDescriptor root) {
-          descriptor = root;
-          internal_static_retrofit_Phone_descriptor =
-            getDescriptor().getMessageTypes().get(0);
-          internal_static_retrofit_Phone_fieldAccessorTable = new
-            com.google.protobuf.GeneratedMessage.FieldAccessorTable(
-              internal_static_retrofit_Phone_descriptor,
-              new java.lang.String[] { "Number", });
-          return null;
-        }
-      };
+        new com.google.protobuf.Descriptors.FileDescriptor.    InternalDescriptorAssigner() {
+          public com.google.protobuf.ExtensionRegistry assignDescriptors(
+              com.google.protobuf.Descriptors.FileDescriptor root) {
+            descriptor = root;
+            return null;
+          }
+        };
     com.google.protobuf.Descriptors.FileDescriptor
       .internalBuildGeneratedFileFrom(descriptorData,
         new com.google.protobuf.Descriptors.FileDescriptor[] {
         }, assigner);
+    internal_static_retrofit2_converter_protobuf_Phone_descriptor =
+      getDescriptor().getMessageTypes().get(0);
+    internal_static_retrofit2_converter_protobuf_Phone_fieldAccessorTable = new
+      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
+        internal_static_retrofit2_converter_protobuf_Phone_descriptor,
+        new java.lang.String[] { "Number", });
+    voicemail.internalInit(descriptor.getExtensions().get(0));
   }
 
   // @@protoc_insertion_point(outer_class_scope)
diff --git a/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/ProtoConverterFactoryTest.java b/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/ProtoConverterFactoryTest.java
index f2ca958f4..5a585b21f 100644
--- a/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/ProtoConverterFactoryTest.java
+++ b/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/ProtoConverterFactoryTest.java
@@ -15,6 +15,7 @@
  */
 package retrofit2.converter.protobuf;
 
+import com.google.protobuf.ExtensionRegistry;
 import com.google.protobuf.InvalidProtocolBufferException;
 import java.io.IOException;
 import java.util.List;
@@ -44,10 +45,14 @@
     @GET("/") Call<String> wrongClass();
     @GET("/") Call<List<String>> wrongType();
   }
+  interface ServiceWithRegistry {
+    @GET("/") Call<Phone> get();
+  }
 
   @Rule public final MockWebServer server = new MockWebServer();
 
   private Service service;
+  private ServiceWithRegistry serviceWithRegistry;
 
   @Before public void setUp() {
     Retrofit retrofit = new Retrofit.Builder()
@@ -55,6 +60,14 @@
         .addConverterFactory(ProtoConverterFactory.create())
         .build();
     service = retrofit.create(Service.class);
+
+    ExtensionRegistry registry = ExtensionRegistry.newInstance();
+    PhoneProtos.registerAllExtensions(registry);
+    Retrofit retrofitWithRegistry = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(ProtoConverterFactory.createWithRegistry(registry))
+        .build();
+    serviceWithRegistry = retrofitWithRegistry.create(ServiceWithRegistry.class);
   }
 
   @Test public void serializeAndDeserialize() throws IOException, InterruptedException {
@@ -80,6 +93,17 @@
     assertThat(body.hasNumber()).isFalse();
   }
 
+  @Test public void deserializeUsesRegistry() throws IOException {
+    ByteString encoded = ByteString.decodeBase64("Cg4oNTE5KSA4NjctNTMwORAB");
+    server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));
+
+    Call<Phone> call = serviceWithRegistry.get();
+    Response<Phone> response = call.execute();
+    Phone body = response.body();
+    assertThat(body.getNumber()).isEqualTo("(519) 867-5309");
+    assertThat(body.getExtension(PhoneProtos.voicemail)).isEqualTo(true);
+  }
+
   @Test public void deserializeWrongClass() throws IOException {
     ByteString encoded = ByteString.decodeBase64("Cg4oNTE5KSA4NjctNTMwOQ==");
     server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));
diff --git a/retrofit-converters/protobuf/src/test/protos/phone.proto b/retrofit-converters/protobuf/src/test/protos/phone.proto
index 69876668b..02e4b9268 100644
--- a/retrofit-converters/protobuf/src/test/protos/phone.proto
+++ b/retrofit-converters/protobuf/src/test/protos/phone.proto
@@ -1,8 +1,14 @@
 package retrofit2.converter.protobuf;
 
-option java_package = "retrofit2";
+option java_package = "retrofit2.converter.protobuf";
 option java_outer_classname = "PhoneProtos";
 
 message Phone {
   optional string number = 1;
+
+  extensions 2;
+}
+
+extend Phone {
+  optional bool voicemail = 2;
 }
diff --git a/retrofit-converters/scalars/README.md b/retrofit-converters/scalars/README.md
index e3edef925..5231b6129 100644
--- a/retrofit-converters/scalars/README.md
+++ b/retrofit-converters/scalars/README.md
@@ -3,3 +3,28 @@ Java Scalars Converter
 
 A `Converter` which supports converting strings and both primitives and their boxed types to
 `text/plain` bodies.
+
+
+Download
+--------
+
+Download [the latest JAR][1] or grab via [Maven][2]:
+```xml
+<dependency>
+  <groupId>com.squareup.retrofit2</groupId>
+  <artifactId>converter-scalars</artifactId>
+  <version>latest.version</version>
+</dependency>
+```
+or [Gradle][2]:
+```groovy
+compile 'com.squareup.retrofit2:converter-scalars:latest.version'
+```
+
+Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
+
+
+
+ [1]: https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=converter-scalars&v=LATEST
+ [2]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup.retrofit2%22%20a%3A%22converter-scalars%22
+ [snap]: https://oss.sonatype.org/content/repositories/snapshots/
diff --git a/retrofit-converters/scalars/pom.xml b/retrofit-converters/scalars/pom.xml
index a9fb47d78..56140758a 100644
--- a/retrofit-converters/scalars/pom.xml
+++ b/retrofit-converters/scalars/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-converters</artifactId>
-    <version>2.0.1</version>
+    <version>2.4.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -19,6 +19,11 @@
       <artifactId>retrofit</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
diff --git a/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/package-info.java b/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/package-info.java
new file mode 100644
index 000000000..0ea2f7740
--- /dev/null
+++ b/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/package-info.java
@@ -0,0 +1,4 @@
+@ParametersAreNonnullByDefault
+package retrofit2.converter.scalars;
+
+import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-converters/scalars/src/test/java/retrofit2/converter/scalars/ScalarsConverterPrimitivesFactoryTest.java b/retrofit-converters/scalars/src/test/java/retrofit2/converter/scalars/ScalarsConverterPrimitivesFactoryTest.java
index 3bbd190bb..8145bde2d 100644
--- a/retrofit-converters/scalars/src/test/java/retrofit2/converter/scalars/ScalarsConverterPrimitivesFactoryTest.java
+++ b/retrofit-converters/scalars/src/test/java/retrofit2/converter/scalars/ScalarsConverterPrimitivesFactoryTest.java
@@ -50,8 +50,8 @@
 
   static class DirectCallAdapterFactory extends CallAdapter.Factory {
     @Override
-    public CallAdapter<?> get(final Type returnType, Annotation[] annotations, Retrofit retrofit) {
-      return new CallAdapter<Object>() {
+    public CallAdapter<?, ?> get(final Type returnType, Annotation[] annotations, Retrofit retrofit) {
+      return new CallAdapter<Object, Object>() {
         @Override public Type responseType() {
           return returnType;
         }
diff --git a/retrofit-converters/simplexml/README.md b/retrofit-converters/simplexml/README.md
index 8d5b8e369..b791e8122 100644
--- a/retrofit-converters/simplexml/README.md
+++ b/retrofit-converters/simplexml/README.md
@@ -15,5 +15,27 @@ a Maven or Gradle dependency, exclude the following transitive dependencies: `st
 `stax:stax`, and `xpp3:xpp3`.
 
 
+Download
+--------
+
+Download [the latest JAR][2] or grab via [Maven][3]:
+```xml
+<dependency>
+  <groupId>com.squareup.retrofit2</groupId>
+  <artifactId>converter-simplexml</artifactId>
+  <version>latest.version</version>
+</dependency>
+```
+or [Gradle][3]:
+```groovy
+compile 'com.squareup.retrofit2:converter-simplexml:latest.version'
+```
+
+Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
+
+
 
  [1]: http://simple.sourceforge.net/
+ [2]: https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=converter-simplexml&v=LATEST
+ [3]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup.retrofit2%22%20a%3A%22converter-simplexml%22
+ [snap]: https://oss.sonatype.org/content/repositories/snapshots/
diff --git a/retrofit-converters/simplexml/pom.xml b/retrofit-converters/simplexml/pom.xml
index c5d7bd255..f119e08d1 100644
--- a/retrofit-converters/simplexml/pom.xml
+++ b/retrofit-converters/simplexml/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-converters</artifactId>
-    <version>2.0.1</version>
+    <version>2.4.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -23,6 +23,11 @@
       <groupId>org.simpleframework</groupId>
       <artifactId>simple-xml</artifactId>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
diff --git a/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlConverterFactory.java b/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlConverterFactory.java
index b7563455e..4cbe2d86f 100644
--- a/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlConverterFactory.java
+++ b/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlConverterFactory.java
@@ -47,7 +47,9 @@ public static SimpleXmlConverterFactory createNonStrict() {
   }
 
   /** Create an instance using {@code serializer} for non-strict conversion. */
+  @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
   public static SimpleXmlConverterFactory createNonStrict(Serializer serializer) {
+    if (serializer == null) throw new NullPointerException("serializer == null");
     return new SimpleXmlConverterFactory(serializer, false);
   }
 
@@ -55,7 +57,6 @@ public static SimpleXmlConverterFactory createNonStrict(Serializer serializer) {
   private final boolean strict;
 
   private SimpleXmlConverterFactory(Serializer serializer, boolean strict) {
-    if (serializer == null) throw new NullPointerException("serializer == null");
     this.serializer = serializer;
     this.strict = strict;
   }
diff --git a/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlResponseBodyConverter.java b/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlResponseBodyConverter.java
index 21bf3ae6c..01759f449 100644
--- a/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlResponseBodyConverter.java
+++ b/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlResponseBodyConverter.java
@@ -33,7 +33,7 @@
 
   @Override public T convert(ResponseBody value) throws IOException {
     try {
-      T read = serializer.read(cls, value.byteStream(), strict);
+      T read = serializer.read(cls, value.charStream(), strict);
       if (read == null) {
         throw new IllegalStateException("Could not deserialize body as " + cls);
       }
diff --git a/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/package-info.java b/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/package-info.java
new file mode 100644
index 000000000..69507b872
--- /dev/null
+++ b/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/package-info.java
@@ -0,0 +1,4 @@
+@ParametersAreNonnullByDefault
+package retrofit2.converter.simplexml;
+
+import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-converters/simplexml/src/test/java/retrofit2/converter/simplexml/SimpleXmlConverterFactoryTest.java b/retrofit-converters/simplexml/src/test/java/retrofit2/converter/simplexml/SimpleXmlConverterFactoryTest.java
index 8a74a8055..7ad58b22d 100644
--- a/retrofit-converters/simplexml/src/test/java/retrofit2/converter/simplexml/SimpleXmlConverterFactoryTest.java
+++ b/retrofit-converters/simplexml/src/test/java/retrofit2/converter/simplexml/SimpleXmlConverterFactoryTest.java
@@ -16,9 +16,11 @@
 package retrofit2.converter.simplexml;
 
 import java.io.IOException;
+import java.nio.charset.Charset;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.RecordedRequest;
+import okio.Buffer;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
@@ -69,11 +71,25 @@
     assertThat(body.getCount()).isEqualTo(10);
 
     RecordedRequest request = server.takeRequest();
-    assertThat(request.getBody().readUtf8()).isEqualTo(
-        "<my-object><message>hello world</message><count>10</count></my-object>");
+    assertThat(request.getBody().readUtf8()).isIn(
+        "<my-object><message>hello world</message><count>10</count></my-object>",
+        "<my-object><count>10</count><message>hello world</message></my-object>");
     assertThat(request.getHeader("Content-Type")).isEqualTo("application/xml; charset=UTF-8");
   }
 
+  @Test public void honorsCharacterEncoding() throws IOException {
+    Buffer buffer = new Buffer().writeString(
+        "<my-object><message>你好，世界</message><count>10</count></my-object>",
+        Charset.forName("GBK"));
+    server.enqueue(
+        new MockResponse().setBody(buffer).addHeader("Content-Type", "text/xml;charset=GBK"));
+
+    Call<MyObject> call = service.get();
+    Response<MyObject> response = call.execute();
+    MyObject body = response.body();
+    assertThat(body.getMessage()).isEqualTo("你好，世界");
+  }
+
   @Test public void deserializeWrongValue() throws IOException {
     server.enqueue(new MockResponse().setBody("<myObject><foo/><bar/></myObject>"));
 
diff --git a/retrofit-converters/wire/README.md b/retrofit-converters/wire/README.md
index 9c82b143e..6289cc8a7 100644
--- a/retrofit-converters/wire/README.md
+++ b/retrofit-converters/wire/README.md
@@ -4,4 +4,27 @@ Wire Converter
 A `Converter` which uses [Wire][1] for protocol buffer-compatible serialization.
 
 
+Download
+--------
+
+Download [the latest JAR][2] or grab via [Maven][3]:
+```xml
+<dependency>
+  <groupId>com.squareup.retrofit2</groupId>
+  <artifactId>converter-wire</artifactId>
+  <version>latest.version</version>
+</dependency>
+```
+or [Gradle][3]:
+```groovy
+compile 'com.squareup.retrofit2:converter-wire:latest.version'
+```
+
+Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
+
+
+
  [1]: https://github.com/square/wire
+ [2]: https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=converter-wire&v=LATEST
+ [3]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup.retrofit2%22%20a%3A%22converter-wire%22
+ [snap]: https://oss.sonatype.org/content/repositories/snapshots/
diff --git a/retrofit-converters/wire/pom.xml b/retrofit-converters/wire/pom.xml
index 5f0ce2edf..a965b89f8 100644
--- a/retrofit-converters/wire/pom.xml
+++ b/retrofit-converters/wire/pom.xml
@@ -10,7 +10,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-converters</artifactId>
-    <version>2.0.1</version>
+    <version>2.4.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -34,6 +34,11 @@
         </exclusion>
       </exclusions>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
diff --git a/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/package-info.java b/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/package-info.java
new file mode 100644
index 000000000..483b65c81
--- /dev/null
+++ b/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/package-info.java
@@ -0,0 +1,4 @@
+@ParametersAreNonnullByDefault
+package retrofit2.converter.wire;
+
+import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-mock/README.md b/retrofit-mock/README.md
new file mode 100644
index 000000000..4474e5af3
--- /dev/null
+++ b/retrofit-mock/README.md
@@ -0,0 +1,26 @@
+Mock Web Server
+==============
+
+An mock web server for mocking HTTP responses from a server, and simulating network behaviour.
+
+Download
+--------
+
+Download [the latest JAR][1] or grab via [Maven][2]:
+```xml
+<dependency>
+  <groupId>com.squareup.retrofit2</groupId>
+  <artifactId>retrofit-mock</artifactId>
+  <version>see.latest.version</version>
+</dependency>
+```
+or [Gradle][1]:
+```groovy
+compile 'com.squareup.retrofit2:retrofit-mock:see.latest.version'
+```
+
+Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
+
+ [1]: https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=retrofit-mock&v=LATEST
+ [2]: http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22retrofit-mock%22
+ [snap]: https://oss.sonatype.org/content/repositories/snapshots/
diff --git a/retrofit-mock/pom.xml b/retrofit-mock/pom.xml
index 48b3847aa..85959397a 100644
--- a/retrofit-mock/pom.xml
+++ b/retrofit-mock/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>parent</artifactId>
-    <version>2.0.1</version>
+    <version>2.4.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -19,6 +19,11 @@
       <artifactId>retrofit</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
diff --git a/retrofit-mock/src/main/java/retrofit2/mock/BehaviorCall.java b/retrofit-mock/src/main/java/retrofit2/mock/BehaviorCall.java
index cfc92c5f7..696b12a45 100644
--- a/retrofit-mock/src/main/java/retrofit2/mock/BehaviorCall.java
+++ b/retrofit-mock/src/main/java/retrofit2/mock/BehaviorCall.java
@@ -51,6 +51,7 @@
     return delegate.request();
   }
 
+  @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
   @Override public void enqueue(final Callback<T> callback) {
     if (callback == null) throw new NullPointerException("callback == null");
 
@@ -79,6 +80,11 @@ boolean delaySleep() {
           if (delaySleep()) {
             callback.onFailure(BehaviorCall.this, behavior.failureException());
           }
+        } else if (behavior.calculateIsError()) {
+          if (delaySleep()) {
+            //noinspection unchecked An error response has no body.
+            callback.onResponse(BehaviorCall.this, (Response<T>) behavior.createErrorResponse());
+          }
         } else {
           delegate.enqueue(new Callback<T>() {
             @Override public void onResponse(Call<T> call, Response<T> response) {
diff --git a/retrofit-mock/src/main/java/retrofit2/mock/BehaviorDelegate.java b/retrofit-mock/src/main/java/retrofit2/mock/BehaviorDelegate.java
index 7c9361f65..b525696fb 100644
--- a/retrofit-mock/src/main/java/retrofit2/mock/BehaviorDelegate.java
+++ b/retrofit-mock/src/main/java/retrofit2/mock/BehaviorDelegate.java
@@ -21,6 +21,7 @@
 import java.lang.reflect.Proxy;
 import java.lang.reflect.Type;
 import java.util.concurrent.ExecutorService;
+import javax.annotation.Nullable;
 import retrofit2.Call;
 import retrofit2.CallAdapter;
 import retrofit2.Retrofit;
@@ -46,20 +47,21 @@
     this.service = service;
   }
 
-  public T returningResponse(Object response) {
+  public T returningResponse(@Nullable Object response) {
     return returning(Calls.response(response));
   }
 
   @SuppressWarnings("unchecked") // Single-interface proxy creation guarded by parameter safety.
-  public T returning(Call<?> call) {
-    final Call<?> behaviorCall = new BehaviorCall<>(behavior, executor, call);
+  public <R> T returning(Call<R> call) {
+    final Call<R> behaviorCall = new BehaviorCall<>(behavior, executor, call);
     return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class[] { service },
         new InvocationHandler() {
           @Override
-          public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
+          public T invoke(Object proxy, Method method, Object[] args) throws Throwable {
             Type returnType = method.getGenericReturnType();
             Annotation[] methodAnnotations = method.getAnnotations();
-            CallAdapter<?> callAdapter = retrofit.callAdapter(returnType, methodAnnotations);
+            CallAdapter<R, T> callAdapter =
+                (CallAdapter<R, T>) retrofit.callAdapter(returnType, methodAnnotations);
             return callAdapter.adapt(behaviorCall);
           }
         });
diff --git a/retrofit-mock/src/main/java/retrofit2/mock/Calls.java b/retrofit-mock/src/main/java/retrofit2/mock/Calls.java
index 49b490aee..42947a95f 100644
--- a/retrofit-mock/src/main/java/retrofit2/mock/Calls.java
+++ b/retrofit-mock/src/main/java/retrofit2/mock/Calls.java
@@ -16,6 +16,9 @@
 package retrofit2.mock;
 
 import java.io.IOException;
+import java.util.concurrent.Callable;
+import java.util.concurrent.atomic.AtomicBoolean;
+import javax.annotation.Nullable;
 import okhttp3.Request;
 import retrofit2.Call;
 import retrofit2.Callback;
@@ -23,75 +26,147 @@
 
 /** Factory methods for creating {@link Call} instances which immediately respond or fail. */
 public final class Calls {
-  public static <T> Call<T> response(T successValue) {
-    return response(Response.success(successValue));
+  /**
+   * Invokes {@code callable} once for the returned {@link Call} and once for each instance that is
+   * obtained from {@linkplain Call#clone() cloning} the returned {@link Call}.
+   */
+  public static <T> Call<T> defer(Callable<Call<T>> callable) {
+    return new DeferredCall<>(callable);
   }
 
-  public static <T> Call<T> response(final Response<T> response) {
-    return new Call<T>() {
-      @Override public Response<T> execute() throws IOException {
+  public static <T> Call<T> response(@Nullable T successValue) {
+    return new FakeCall<>(Response.success(successValue), null);
+  }
+
+  public static <T> Call<T> response(Response<T> response) {
+    return new FakeCall<>(response, null);
+  }
+
+  public static <T> Call<T> failure(IOException failure) {
+    return new FakeCall<>(null, failure);
+  }
+
+  private Calls() {
+    throw new AssertionError("No instances.");
+  }
+
+  static final class FakeCall<T> implements Call<T> {
+    private final Response<T> response;
+    private final IOException error;
+    private final AtomicBoolean canceled = new AtomicBoolean();
+    private final AtomicBoolean executed = new AtomicBoolean();
+
+    FakeCall(@Nullable Response<T> response, @Nullable IOException error) {
+      if ((response == null) == (error == null)) {
+        throw new AssertionError("Only one of response or error can be set.");
+      }
+      this.response = response;
+      this.error = error;
+    }
+
+    @Override public Response<T> execute() throws IOException {
+      if (!executed.compareAndSet(false, true)) {
+        throw new IllegalStateException("Already executed");
+      }
+      if (canceled.get()) {
+        throw new IOException("canceled");
+      }
+      if (response != null) {
         return response;
       }
+      throw error;
+    }
 
-      @Override public void enqueue(Callback<T> callback) {
+    @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
+    @Override public void enqueue(Callback<T> callback) {
+      if (callback == null) {
+        throw new NullPointerException("callback == null");
+      }
+      if (!executed.compareAndSet(false, true)) {
+        throw new IllegalStateException("Already executed");
+      }
+      if (canceled.get()) {
+        callback.onFailure(this, new IOException("canceled"));
+      } else if (response != null) {
         callback.onResponse(this, response);
+      } else {
+        callback.onFailure(this, error);
       }
+    }
 
-      @Override public boolean isExecuted() {
-        return false;
-      }
+    @Override public boolean isExecuted() {
+      return executed.get();
+    }
 
-      @Override public void cancel() {
-      }
+    @Override public void cancel() {
+      canceled.set(true);
+    }
 
-      @Override public boolean isCanceled() {
-        return false;
-      }
+    @Override public boolean isCanceled() {
+      return canceled.get();
+    }
 
-      @SuppressWarnings("CloneDoesntCallSuperClone") // Immutable object.
-      @Override public Call<T> clone() {
-        return this;
-      }
+    @Override public Call<T> clone() {
+      return new FakeCall<>(response, error);
+    }
 
-      @Override public Request request() {
+    @Override public Request request() {
+      if (response != null) {
         return response.raw().request();
       }
-    };
+      return new Request.Builder().url("http://localhost").build();
+    }
   }
 
-  public static <T> Call<T> failure(final IOException failure) {
-    return new Call<T>() {
-      @Override public Response<T> execute() throws IOException {
-        throw failure;
+  static final class DeferredCall<T> implements Call<T> {
+    private final Callable<Call<T>> callable;
+    private Call<T> delegate;
+
+    DeferredCall(Callable<Call<T>> callable) {
+      this.callable = callable;
+    }
+
+    private synchronized Call<T> getDelegate() {
+      Call<T> delegate = this.delegate;
+      if (delegate == null) {
+        try {
+          delegate = callable.call();
+        } catch (IOException e) {
+          delegate = failure(e);
+        } catch (Exception e) {
+          throw new IllegalStateException("Callable threw unrecoverable exception", e);
+        }
+        this.delegate = delegate;
       }
+      return delegate;
+    }
 
-      @Override public void enqueue(Callback<T> callback) {
-        callback.onFailure(this, failure);
-      }
+    @Override public Response<T> execute() throws IOException {
+      return getDelegate().execute();
+    }
 
-      @Override public boolean isExecuted() {
-        return false;
-      }
+    @Override public void enqueue(Callback<T> callback) {
+      getDelegate().enqueue(callback);
+    }
 
-      @Override public void cancel() {
-      }
+    @Override public boolean isExecuted() {
+      return getDelegate().isExecuted();
+    }
 
-      @Override public boolean isCanceled() {
-        return false;
-      }
+    @Override public void cancel() {
+      getDelegate().cancel();
+    }
 
-      @SuppressWarnings("CloneDoesntCallSuperClone") // Immutable object.
-      @Override public Call<T> clone() {
-        return this;
-      }
+    @Override public boolean isCanceled() {
+      return getDelegate().isCanceled();
+    }
 
-      @Override public Request request() {
-        return new Request.Builder().url("http://localhost").build();
-      }
-    };
-  }
+    @Override public Call<T> clone() {
+      return new DeferredCall<>(callable);
+    }
 
-  private Calls() {
-    throw new AssertionError("No instances.");
+    @Override public Request request() {
+      return getDelegate().request();
+    }
   }
 }
diff --git a/retrofit-mock/src/main/java/retrofit2/mock/MockRetrofit.java b/retrofit-mock/src/main/java/retrofit2/mock/MockRetrofit.java
index 3c75b47a2..40185baaa 100644
--- a/retrofit-mock/src/main/java/retrofit2/mock/MockRetrofit.java
+++ b/retrofit-mock/src/main/java/retrofit2/mock/MockRetrofit.java
@@ -53,17 +53,20 @@ public Executor backgroundExecutor() {
     private NetworkBehavior behavior;
     private ExecutorService executor;
 
+    @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
     public Builder(Retrofit retrofit) {
       if (retrofit == null) throw new NullPointerException("retrofit == null");
       this.retrofit = retrofit;
     }
 
+    @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
     public Builder networkBehavior(NetworkBehavior behavior) {
       if (behavior == null) throw new NullPointerException("behavior == null");
       this.behavior = behavior;
       return this;
     }
 
+    @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
     public Builder backgroundExecutor(ExecutorService executor) {
       if (executor == null) throw new NullPointerException("executor == null");
       this.executor = executor;
diff --git a/retrofit-mock/src/main/java/retrofit2/mock/MockRetrofitIOException.java b/retrofit-mock/src/main/java/retrofit2/mock/MockRetrofitIOException.java
new file mode 100644
index 000000000..d4cdfc2c0
--- /dev/null
+++ b/retrofit-mock/src/main/java/retrofit2/mock/MockRetrofitIOException.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.mock;
+
+import java.io.IOException;
+
+final class MockRetrofitIOException extends IOException {
+  MockRetrofitIOException() {
+    super("Failure triggered by MockRetrofit's NetworkBehavior");
+  }
+}
diff --git a/retrofit-mock/src/main/java/retrofit2/mock/NetworkBehavior.java b/retrofit-mock/src/main/java/retrofit2/mock/NetworkBehavior.java
index d182862cb..263808dd4 100644
--- a/retrofit-mock/src/main/java/retrofit2/mock/NetworkBehavior.java
+++ b/retrofit-mock/src/main/java/retrofit2/mock/NetworkBehavior.java
@@ -17,7 +17,10 @@
 
 import java.io.IOException;
 import java.util.Random;
+import java.util.concurrent.Callable;
 import java.util.concurrent.TimeUnit;
+import okhttp3.ResponseBody;
+import retrofit2.Response;
 
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 
@@ -33,22 +36,14 @@
  * Behavior can be applied to a Retrofit interface with {@link MockRetrofit}. Behavior can also
  * be applied elsewhere using {@link #calculateDelay(TimeUnit)} and {@link #calculateIsFailure()}.
  * <p>
- * By default, instances of this class will use a 2 second delay with 40% variance and failures
- * will occur 3% of the time.
+ * By default, instances of this class will use a 2 second delay with 40% variance. Failures
+ * will occur 3% of the time. HTTP errors will occur 0% of the time.
  */
 public final class NetworkBehavior {
   private static final int DEFAULT_DELAY_MS = 2000; // Network calls will take 2 seconds.
   private static final int DEFAULT_VARIANCE_PERCENT = 40; // Network delay varies by ±40%.
   private static final int DEFAULT_FAILURE_PERCENT = 3; // 3% of network calls will fail.
-
-  /** Applies {@link NetworkBehavior} to instances of {@code T}. */
-  public interface Adapter<T> {
-    /**
-     * Apply {@code behavior} to {@code value} so that it exhibits the configured network behavior
-     * traits when interacted with.
-     */
-    T applyBehavior(NetworkBehavior behavior, T value);
-  }
+  private static final int DEFAULT_ERROR_PERCENT = 0; // 0% of network calls will return errors.
 
   /** Create an instance with default behavior. */
   public static NetworkBehavior create() {
@@ -59,6 +54,7 @@ public static NetworkBehavior create() {
    * Create an instance with default behavior which uses {@code random} to control variance and
    * failure calculation.
    */
+  @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
   public static NetworkBehavior create(Random random) {
     if (random == null) throw new NullPointerException("random == null");
     return new NetworkBehavior(random);
@@ -69,10 +65,19 @@ public static NetworkBehavior create(Random random) {
   private volatile long delayMs = DEFAULT_DELAY_MS;
   private volatile int variancePercent = DEFAULT_VARIANCE_PERCENT;
   private volatile int failurePercent = DEFAULT_FAILURE_PERCENT;
-  private volatile Throwable failureException = new IOException("Mock failure!");
+  private volatile Throwable failureException;
+  private volatile int errorPercent = DEFAULT_ERROR_PERCENT;
+  private volatile Callable<Response<?>> errorFactory = new Callable<Response<?>>() {
+    @Override public Response<?> call() {
+      return Response.error(500, ResponseBody.create(null, new byte[0]));
+    }
+  };
 
   private NetworkBehavior(Random random) {
     this.random = random;
+
+    failureException = new MockRetrofitIOException();
+    failureException.setStackTrace(new StackTraceElement[0]);
   }
 
   /** Set the network round trip delay. */
@@ -90,9 +95,7 @@ public long delay(TimeUnit unit) {
 
   /** Set the plus-or-minus variance percentage of the network round trip delay. */
   public void setVariancePercent(int variancePercent) {
-    if (variancePercent < 0 || variancePercent > 100) {
-      throw new IllegalArgumentException("Variance percentage must be between 0 and 100.");
-    }
+    checkPercentageValidity(variancePercent, "Variance percentage must be between 0 and 100.");
     this.variancePercent = variancePercent;
   }
 
@@ -103,9 +106,7 @@ public int variancePercent() {
 
   /** Set the percentage of calls to {@link #calculateIsFailure()} that return {@code true}. */
   public void setFailurePercent(int failurePercent) {
-    if (failurePercent < 0 || failurePercent > 100) {
-      throw new IllegalArgumentException("Failure percentage must be between 0 and 100.");
-    }
+    checkPercentageValidity(failurePercent, "Failure percentage must be between 0 and 100.");
     this.failurePercent = failurePercent;
   }
 
@@ -114,12 +115,18 @@ public int failurePercent() {
     return failurePercent;
   }
 
-  /** Set the exception to be used when a failure is triggered. */
-  public void setFailureException(Throwable t) {
-    if (t == null) {
-      throw new NullPointerException("t == null");
+  /**
+   * Set the exception to be used when a failure is triggered.
+   * <p>
+   * It is a best practice to remove the stack trace from {@code exception} since it can
+   * misleadingly point to code unrelated to this class.
+   */
+  @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
+  public void setFailureException(Throwable exception) {
+    if (exception == null) {
+      throw new NullPointerException("exception == null");
     }
-    this.failureException = t;
+    this.failureException = exception;
   }
 
   /** The exception to be used when a failure is triggered. */
@@ -127,13 +134,60 @@ public Throwable failureException() {
     return failureException;
   }
 
+  /** The percentage of calls to {@link #calculateIsError()} that return {@code true}. */
+  public int errorPercent() {
+    return errorPercent;
+  }
+
+  /** Set the percentage of calls to {@link #calculateIsError()} that return {@code true}. */
+  public void setErrorPercent(int errorPercent) {
+    checkPercentageValidity(errorPercent, "Error percentage must be between 0 and 100.");
+    this.errorPercent = errorPercent;
+  }
+
+  /**
+   * Set the error response factory to be used when an error is triggered. This factory may only
+   * return responses for which {@link Response#isSuccessful()} returns false.
+   */
+  @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
+  public void setErrorFactory(Callable<Response<?>> errorFactory) {
+    if (errorFactory == null) {
+      throw new NullPointerException("errorFactory == null");
+    }
+    this.errorFactory = errorFactory;
+  }
+
+  /** The HTTP error to be used when an error is triggered. */
+  public Response<?> createErrorResponse() {
+    Response<?> call;
+    try {
+      call = errorFactory.call();
+    } catch (Exception e) {
+      throw new IllegalStateException("Error factory threw an exception.", e);
+    }
+    if (call == null) {
+      throw new IllegalStateException("Error factory returned null.");
+    }
+    if (call.isSuccessful()) {
+      throw new IllegalStateException("Error factory returned successful response.");
+    }
+    return call;
+  }
+
   /**
    * Randomly determine whether this call should result in a network failure in accordance with
    * configured behavior. When true, {@link #failureException()} should be thrown.
    */
   public boolean calculateIsFailure() {
-    int randomValue = random.nextInt(100);
-    return randomValue < failurePercent;
+    return random.nextInt(100) < failurePercent;
+  }
+
+  /**
+   * Randomly determine whether this call should result in an HTTP error in accordance with
+   * configured behavior. When true, {@link #createErrorResponse()} should be returned.
+   */
+  public boolean calculateIsError() {
+    return random.nextInt(100) < errorPercent;
   }
 
   /**
@@ -149,4 +203,10 @@ public long calculateDelay(TimeUnit unit) {
     long callDelayMs = (long) (delayMs * delayPercent);
     return MILLISECONDS.convert(callDelayMs, unit);
   }
+
+  private static void checkPercentageValidity(int percentage, String message) {
+    if (percentage < 0 || percentage > 100) {
+      throw new IllegalArgumentException(message);
+    }
+  }
 }
diff --git a/retrofit-mock/src/main/java/retrofit2/mock/package-info.java b/retrofit-mock/src/main/java/retrofit2/mock/package-info.java
new file mode 100644
index 000000000..cb99df00c
--- /dev/null
+++ b/retrofit-mock/src/main/java/retrofit2/mock/package-info.java
@@ -0,0 +1,4 @@
+@ParametersAreNonnullByDefault
+package retrofit2.mock;
+
+import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-mock/src/test/java/retrofit2/mock/CallsTest.java b/retrofit-mock/src/test/java/retrofit2/mock/CallsTest.java
new file mode 100644
index 000000000..f32f4c4ee
--- /dev/null
+++ b/retrofit-mock/src/test/java/retrofit2/mock/CallsTest.java
@@ -0,0 +1,263 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.mock;
+
+import java.io.IOException;
+import java.util.concurrent.Callable;
+import java.util.concurrent.atomic.AtomicReference;
+import org.junit.Test;
+import retrofit2.Call;
+import retrofit2.Callback;
+import retrofit2.Response;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class CallsTest {
+  @Test public void bodyExecute() throws IOException {
+    Call<String> taco = Calls.response("Taco");
+    assertEquals("Taco", taco.execute().body());
+  }
+
+  @Test public void bodyEnqueue() throws IOException {
+    Call<String> taco = Calls.response("Taco");
+    final AtomicReference<Response<String>> responseRef = new AtomicReference<>();
+    taco.enqueue(new Callback<String>() {
+      @Override public void onResponse(Call<String> call, Response<String> response) {
+        responseRef.set(response);
+      }
+
+      @Override public void onFailure(Call<String> call, Throwable t) {
+        fail();
+      }
+    });
+    assertThat(responseRef.get().body()).isEqualTo("Taco");
+  }
+
+  @Test public void responseExecute() throws IOException {
+    Response<String> response = Response.success("Taco");
+    Call<String> taco = Calls.response(response);
+    assertFalse(taco.isExecuted());
+    assertSame(response, taco.execute());
+    assertTrue(taco.isExecuted());
+    try {
+      taco.execute();
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage("Already executed");
+    }
+  }
+
+  @Test public void responseEnqueue() {
+    Response<String> response = Response.success("Taco");
+    Call<String> taco = Calls.response(response);
+    assertFalse(taco.isExecuted());
+
+    final AtomicReference<Response<String>> responseRef = new AtomicReference<>();
+    taco.enqueue(new Callback<String>() {
+      @Override public void onResponse(Call<String> call, Response<String> response) {
+        responseRef.set(response);
+      }
+
+      @Override public void onFailure(Call<String> call, Throwable t) {
+        fail();
+      }
+    });
+    assertSame(response, responseRef.get());
+    assertTrue(taco.isExecuted());
+
+    try {
+      taco.enqueue(new Callback<String>() {
+        @Override public void onResponse(Call<String> call, Response<String> response) {
+          fail();
+        }
+
+        @Override public void onFailure(Call<String> call, Throwable t) {
+          fail();
+        }
+      });
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage("Already executed");
+    }
+  }
+
+  @Test public void enqueueNullThrows() {
+    Call<String> taco = Calls.response("Taco");
+    try {
+      taco.enqueue(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("callback == null");
+    }
+  }
+
+  @Test public void responseCancelExecute() {
+    Call<String> taco = Calls.response(Response.success("Taco"));
+    assertFalse(taco.isCanceled());
+    taco.cancel();
+    assertTrue(taco.isCanceled());
+
+    try {
+      taco.execute();
+      fail();
+    } catch (IOException e) {
+      assertThat(e).hasMessage("canceled");
+    }
+  }
+
+  @Test public void responseCancelEnqueue() throws IOException {
+    Call<String> taco = Calls.response(Response.success("Taco"));
+    assertFalse(taco.isCanceled());
+    taco.cancel();
+    assertTrue(taco.isCanceled());
+
+    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+    taco.enqueue(new Callback<String>() {
+      @Override public void onResponse(Call<String> call, Response<String> response) {
+        fail();
+      }
+
+      @Override public void onFailure(Call<String> call, Throwable t) {
+        failureRef.set(t);
+      }
+    });
+    assertThat(failureRef.get()).isInstanceOf(IOException.class).hasMessage("canceled");
+  }
+
+  @Test public void failureExecute() {
+    IOException failure = new IOException("Hey");
+    Call<Object> taco = Calls.failure(failure);
+    assertFalse(taco.isExecuted());
+    try {
+      taco.execute();
+      fail();
+    } catch (IOException e) {
+      assertSame(failure, e);
+    }
+    assertTrue(taco.isExecuted());
+  }
+
+  @Test public void failureEnqueue() {
+    IOException failure = new IOException("Hey");
+    Call<Object> taco = Calls.failure(failure);
+    assertFalse(taco.isExecuted());
+
+    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+    taco.enqueue(new Callback<Object>() {
+      @Override public void onResponse(Call<Object> call, Response<Object> response) {
+        fail();
+      }
+
+      @Override public void onFailure(Call<Object> call, Throwable t) {
+        failureRef.set(t);
+      }
+    });
+    assertSame(failure, failureRef.get());
+    assertTrue(taco.isExecuted());
+  }
+
+  @Test public void cloneHasOwnState() throws IOException {
+    Call<String> taco = Calls.response("Taco");
+    assertEquals("Taco", taco.execute().body());
+    Call<String> anotherTaco = taco.clone();
+    assertFalse(anotherTaco.isExecuted());
+    assertEquals("Taco", anotherTaco.execute().body());
+    assertTrue(anotherTaco.isExecuted());
+  }
+
+  @Test public void deferredReturnExecute() throws IOException {
+    Call<Integer> counts = Calls.defer(new Callable<Call<Integer>>() {
+      private int count = 0;
+
+      @Override public Call<Integer> call() throws Exception {
+        return Calls.response(++count);
+      }
+    });
+    Call<Integer> a = counts.clone();
+    Call<Integer> b = counts.clone();
+
+    assertEquals(1, b.execute().body().intValue());
+    assertEquals(2, a.execute().body().intValue());
+  }
+
+  @Test public void deferredReturnEnqueue() {
+    Call<Integer> counts = Calls.defer(new Callable<Call<Integer>>() {
+      private int count = 0;
+
+      @Override public Call<Integer> call() throws Exception {
+        return Calls.response(++count);
+      }
+    });
+    Call<Integer> a = counts.clone();
+    Call<Integer> b = counts.clone();
+
+    final AtomicReference<Response<Integer>> responseRef = new AtomicReference<>();
+    Callback<Integer> callback = new Callback<Integer>() {
+      @Override public void onResponse(Call<Integer> call, Response<Integer> response) {
+        responseRef.set(response);
+      }
+
+      @Override public void onFailure(Call<Integer> call, Throwable t) {
+        fail();
+      }
+    };
+    b.enqueue(callback);
+    assertEquals(1, responseRef.get().body().intValue());
+
+    a.enqueue(callback);
+    assertEquals(2, responseRef.get().body().intValue());
+  }
+
+  @Test public void deferredThrowExecute() throws IOException {
+    final IOException failure = new IOException("Hey");
+    Call<Object> failing = Calls.defer(new Callable<Call<Object>>() {
+      @Override public Call<Object> call() throws Exception {
+        throw failure;
+      }
+    });
+    try {
+      failing.execute();
+      fail();
+    } catch (IOException e) {
+      assertSame(failure, e);
+    }
+  }
+
+  @Test public void deferredThrowEnqueue() {
+    final IOException failure = new IOException("Hey");
+    Call<Object> failing = Calls.defer(new Callable<Call<Object>>() {
+      @Override public Call<Object> call() throws Exception {
+        throw failure;
+      }
+    });
+    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+    failing.enqueue(new Callback<Object>() {
+      @Override public void onResponse(Call<Object> call, Response<Object> response) {
+        fail();
+      }
+
+      @Override public void onFailure(Call<Object> call, Throwable t) {
+        failureRef.set(t);
+      }
+    });
+    assertSame(failure, failureRef.get());
+  }
+}
diff --git a/retrofit-mock/src/test/java/retrofit2/mock/NetworkBehaviorTest.java b/retrofit-mock/src/test/java/retrofit2/mock/NetworkBehaviorTest.java
index 7ccccc0df..73de57911 100644
--- a/retrofit-mock/src/test/java/retrofit2/mock/NetworkBehaviorTest.java
+++ b/retrofit-mock/src/test/java/retrofit2/mock/NetworkBehaviorTest.java
@@ -15,17 +15,29 @@
  */
 package retrofit2.mock;
 
+import java.io.IOException;
 import java.util.Random;
+import java.util.concurrent.Callable;
+import okhttp3.ResponseBody;
 import org.junit.Test;
+import retrofit2.Response;
 
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static java.util.concurrent.TimeUnit.SECONDS;
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 
 public final class NetworkBehaviorTest {
   private final NetworkBehavior behavior = NetworkBehavior.create(new Random(2847));
 
+  @Test public void defaultThrowable() {
+    Throwable t = behavior.failureException();
+    assertThat(t).isInstanceOf(IOException.class)
+        .isExactlyInstanceOf(MockRetrofitIOException.class);
+    assertThat(t.getStackTrace()).isEmpty();
+  }
+
   @Test public void delayMustBePositive() {
     try {
       behavior.setDelay(-1, SECONDS);
@@ -65,6 +77,97 @@
     }
   }
 
+  @Test public void failureExceptionIsNotNull() {
+    try {
+      behavior.setFailureException(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("exception == null");
+    }
+  }
+
+  @Test public void errorRestrictsRange() {
+    try {
+      behavior.setErrorPercent(-13);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Error percentage must be between 0 and 100.");
+    }
+    try {
+      behavior.setErrorPercent(174);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Error percentage must be between 0 and 100.");
+    }
+  }
+
+  @Test public void errorFactoryIsNotNull() {
+    try {
+      behavior.setErrorFactory(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("errorFactory == null");
+    }
+  }
+
+  @Test public void errorFactoryCannotReturnNull() {
+    behavior.setErrorFactory(new Callable<Response<?>>() {
+      @Override public Response<?> call() throws Exception {
+        return null;
+      }
+    });
+    try {
+      behavior.createErrorResponse();
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage("Error factory returned null.");
+    }
+  }
+
+  @Test public void errorFactoryCannotThrow() {
+    final RuntimeException broken = new RuntimeException("Broken");
+    behavior.setErrorFactory(new Callable<Response<?>>() {
+      @Override public Response<?> call() throws Exception {
+        throw broken;
+      }
+    });
+    try {
+      behavior.createErrorResponse();
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage("Error factory threw an exception.");
+      assertThat(e.getCause()).isSameAs(broken);
+    }
+  }
+
+  @Test public void errorFactoryCannotReturnSuccess() {
+    behavior.setErrorFactory(new Callable<Response<?>>() {
+      @Override public Response<?> call() throws Exception {
+        return Response.success("Taco");
+      }
+    });
+    try {
+      behavior.createErrorResponse();
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage("Error factory returned successful response.");
+    }
+  }
+
+  @Test public void errorFactoryCalledEachTime() {
+    behavior.setErrorFactory(new Callable<Response<?>>() {
+      private int code = 500;
+
+      @Override public Response<?> call() throws Exception {
+        return Response.error(code++, ResponseBody.create(null, new byte[0]));
+      }
+    });
+
+    assertEquals(500, behavior.createErrorResponse().code());
+    assertEquals(501, behavior.createErrorResponse().code());
+    assertEquals(502, behavior.createErrorResponse().code());
+  }
+
   @Test public void failurePercentageIsAccurate() {
     behavior.setFailurePercent(0);
     for (int i = 0; i < 10000; i++) {
@@ -81,6 +184,22 @@
     assertThat(failures).isEqualTo(2964); // ~3% of 100k
   }
 
+  @Test public void errorPercentageIsAccurate() {
+    behavior.setErrorPercent(0);
+    for (int i = 0; i < 10000; i++) {
+      assertThat(behavior.calculateIsError()).isFalse();
+    }
+
+    behavior.setErrorPercent(3);
+    int errors = 0;
+    for (int i = 0; i < 100000; i++) {
+      if (behavior.calculateIsError()) {
+        errors += 1;
+      }
+    }
+    assertThat(errors).isEqualTo(2964); // ~3% of 100k
+  }
+
   @Test public void delayVarianceIsAccurate() {
     behavior.setDelay(2, SECONDS);
 
diff --git a/retrofit/pom.xml b/retrofit/pom.xml
index 3b39fd483..6a2cea74b 100644
--- a/retrofit/pom.xml
+++ b/retrofit/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>parent</artifactId>
-    <version>2.0.1</version>
+    <version>2.4.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -30,6 +30,11 @@
       <artifactId>animal-sniffer-annotations</artifactId>
       <optional>true</optional>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
diff --git a/retrofit/src/main/java/retrofit2/BuiltInConverters.java b/retrofit/src/main/java/retrofit2/BuiltInConverters.java
index d580c00fb..f729383a3 100644
--- a/retrofit/src/main/java/retrofit2/BuiltInConverters.java
+++ b/retrofit/src/main/java/retrofit2/BuiltInConverters.java
@@ -27,10 +27,9 @@
   public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
       Retrofit retrofit) {
     if (type == ResponseBody.class) {
-      if (Utils.isAnnotationPresent(annotations, Streaming.class)) {
-        return StreamingResponseBodyConverter.INSTANCE;
-      }
-      return BufferingResponseBodyConverter.INSTANCE;
+      return Utils.isAnnotationPresent(annotations, Streaming.class)
+          ? StreamingResponseBodyConverter.INSTANCE
+          : BufferingResponseBodyConverter.INSTANCE;
     }
     if (type == Void.class) {
       return VoidResponseBodyConverter.INSTANCE;
@@ -47,22 +46,6 @@
     return null;
   }
 
-  @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
-    if (type == String.class) {
-      return StringConverter.INSTANCE;
-    }
-    return null;
-  }
-
-  static final class StringConverter implements Converter<String, String> {
-    static final StringConverter INSTANCE = new StringConverter();
-
-    @Override public String convert(String value) throws IOException {
-      return value;
-    }
-  }
-
   static final class VoidResponseBodyConverter implements Converter<ResponseBody, Void> {
     static final VoidResponseBodyConverter INSTANCE = new VoidResponseBodyConverter();
 
diff --git a/retrofit/src/main/java/retrofit2/CallAdapter.java b/retrofit/src/main/java/retrofit2/CallAdapter.java
index 0c42d9420..97d34585d 100644
--- a/retrofit/src/main/java/retrofit2/CallAdapter.java
+++ b/retrofit/src/main/java/retrofit2/CallAdapter.java
@@ -18,13 +18,15 @@
 import java.lang.annotation.Annotation;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
+import javax.annotation.Nullable;
 
 /**
- * Adapts a {@link Call} into the type of {@code T}. Instances are created by {@linkplain Factory a
- * factory} which is {@linkplain Retrofit.Builder#addCallAdapterFactory(Factory) installed} into
- * the {@link Retrofit} instance.
+ * Adapts a {@link Call} with response type {@code R} into the type of {@code T}. Instances are
+ * created by {@linkplain Factory a factory} which is
+ * {@linkplain Retrofit.Builder#addCallAdapterFactory(Factory) installed} into the {@link Retrofit}
+ * instance.
  */
-public interface CallAdapter<T> {
+public interface CallAdapter<R, T> {
   /**
    * Returns the value type that this adapter uses when converting the HTTP response body to a Java
    * object. For example, the response type for {@code Call<Repo>} is {@code Repo}. This type
@@ -40,19 +42,19 @@
    * <p>
    * For example, given an instance for a hypothetical utility, {@code Async}, this instance would
    * return a new {@code Async<R>} which invoked {@code call} when run.
-   * <pre>{@code
+   * <pre><code>
    * &#64;Override
-   * public <R> Async<R> adapt(final Call<R> call) {
-   *   return Async.create(new Callable<Response<R>>() {
+   * public &lt;R&gt; Async&lt;R&gt; adapt(final Call&lt;R&gt; call) {
+   *   return Async.create(new Callable&lt;Response&lt;R&gt;&gt;() {
    *     &#64;Override
-   *     public Response<R> call() throws Exception {
+   *     public Response&lt;R&gt; call() throws Exception {
    *       return call.execute();
    *     }
    *   });
    * }
-   * }</pre>
+   * </code></pre>
    */
-  <R> T adapt(Call<R> call);
+  T adapt(Call<R> call);
 
   /**
    * Creates {@link CallAdapter} instances based on the return type of {@linkplain
@@ -63,7 +65,7 @@
      * Returns a call adapter for interface methods that return {@code returnType}, or null if it
      * cannot be handled by this factory.
      */
-    public abstract CallAdapter<?> get(Type returnType, Annotation[] annotations,
+    public abstract @Nullable CallAdapter<?, ?> get(Type returnType, Annotation[] annotations,
         Retrofit retrofit);
 
     /**
diff --git a/retrofit/src/main/java/retrofit2/Converter.java b/retrofit/src/main/java/retrofit2/Converter.java
index 9fd8eddaf..37a64f8d1 100644
--- a/retrofit/src/main/java/retrofit2/Converter.java
+++ b/retrofit/src/main/java/retrofit2/Converter.java
@@ -17,13 +17,16 @@
 
 import java.io.IOException;
 import java.lang.annotation.Annotation;
+import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
+import javax.annotation.Nullable;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import retrofit2.http.Body;
 import retrofit2.http.Field;
 import retrofit2.http.FieldMap;
 import retrofit2.http.Header;
+import retrofit2.http.HeaderMap;
 import retrofit2.http.Part;
 import retrofit2.http.PartMap;
 import retrofit2.http.Path;
@@ -46,8 +49,8 @@
      * response types such as {@code SimpleResponse} from a {@code Call<SimpleResponse>}
      * declaration.
      */
-    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-        Retrofit retrofit) {
+    public @Nullable Converter<ResponseBody, ?> responseBodyConverter(Type type,
+        Annotation[] annotations, Retrofit retrofit) {
       return null;
     }
 
@@ -57,7 +60,7 @@
      * specified by {@link Body @Body}, {@link Part @Part}, and {@link PartMap @PartMap}
      * values.
      */
-    public Converter<?, RequestBody> requestBodyConverter(Type type,
+    public @Nullable Converter<?, RequestBody> requestBodyConverter(Type type,
         Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
       return null;
     }
@@ -66,12 +69,28 @@
      * Returns a {@link Converter} for converting {@code type} to a {@link String}, or null if
      * {@code type} cannot be handled by this factory. This is used to create converters for types
      * specified by {@link Field @Field}, {@link FieldMap @FieldMap} values,
-     * {@link Header @Header}, {@link Path @Path}, {@link Query @Query}, and
-     * {@link QueryMap @QueryMap} values.
+     * {@link Header @Header}, {@link HeaderMap @HeaderMap}, {@link Path @Path},
+     * {@link Query @Query}, and {@link QueryMap @QueryMap} values.
      */
-    public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+    public @Nullable Converter<?, String> stringConverter(Type type, Annotation[] annotations,
         Retrofit retrofit) {
       return null;
     }
+
+    /**
+     * Extract the upper bound of the generic parameter at {@code index} from {@code type}. For
+     * example, index 1 of {@code Map<String, ? extends Runnable>} returns {@code Runnable}.
+     */
+    protected static Type getParameterUpperBound(int index, ParameterizedType type) {
+      return Utils.getParameterUpperBound(index, type);
+    }
+
+    /**
+     * Extract the raw class type from {@code type}. For example, the type representing
+     * {@code List<? extends Runnable>} returns {@code List.class}.
+     */
+    protected static Class<?> getRawType(Type type) {
+      return Utils.getRawType(type);
+    }
   }
 }
diff --git a/retrofit/src/main/java/retrofit2/DefaultCallAdapterFactory.java b/retrofit/src/main/java/retrofit2/DefaultCallAdapterFactory.java
index dd6e79244..c0f114cf3 100644
--- a/retrofit/src/main/java/retrofit2/DefaultCallAdapterFactory.java
+++ b/retrofit/src/main/java/retrofit2/DefaultCallAdapterFactory.java
@@ -27,18 +27,18 @@
   static final CallAdapter.Factory INSTANCE = new DefaultCallAdapterFactory();
 
   @Override
-  public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+  public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
     if (getRawType(returnType) != Call.class) {
       return null;
     }
 
     final Type responseType = Utils.getCallResponseType(returnType);
-    return new CallAdapter<Call<?>>() {
+    return new CallAdapter<Object, Call<?>>() {
       @Override public Type responseType() {
         return responseType;
       }
 
-      @Override public <R> Call<R> adapt(Call<R> call) {
+      @Override public Call<Object> adapt(Call<Object> call) {
         return call;
       }
     };
diff --git a/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java b/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java
index e1bcd0ffd..be9f2d9fa 100644
--- a/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java
+++ b/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java
@@ -22,6 +22,8 @@
 
 import okhttp3.Request;
 
+import static retrofit2.Utils.checkNotNull;
+
 final class ExecutorCallAdapterFactory extends CallAdapter.Factory {
   final Executor callbackExecutor;
 
@@ -30,17 +32,17 @@
   }
 
   @Override
-  public CallAdapter<Call<?>> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+  public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
     if (getRawType(returnType) != Call.class) {
       return null;
     }
     final Type responseType = Utils.getCallResponseType(returnType);
-    return new CallAdapter<Call<?>>() {
+    return new CallAdapter<Object, Call<?>>() {
       @Override public Type responseType() {
         return responseType;
       }
 
-      @Override public <R> Call<R> adapt(Call<R> call) {
+      @Override public Call<Object> adapt(Call<Object> call) {
         return new ExecutorCallbackCall<>(callbackExecutor, call);
       }
     };
@@ -56,7 +58,7 @@
     }
 
     @Override public void enqueue(final Callback<T> callback) {
-      if (callback == null) throw new NullPointerException("callback == null");
+      checkNotNull(callback, "callback == null");
 
       callbackExecutor.execute(new Runnable() {
         @Override public void run() {
@@ -64,25 +66,25 @@
         }
       });
       delegate.enqueue(new Callback<T>() {
-        @Override public void onResponse(final Call<T> call, final Response<T> response) {
+        @Override public void onResponse(Call<T> call, final Response<T> response) {
           callbackExecutor.execute(new Runnable() {
             @Override public void run() {
               if (delegate.isCanceled()) {
                 // Emulate OkHttp's behavior of throwing/delivering an IOException on cancellation.
-                callback.onFailure(call, new IOException("Canceled"));
+                callback.onFailure(ExecutorCallbackCall.this, new IOException("Canceled"));
               } else {
-                callback.onResponse(call, response);
+                callback.onResponse(ExecutorCallbackCall.this, response);
               }
               callback.onCallFinish();
             }
           });
         }
 
-        @Override public void onFailure(final Call<T> call, final Throwable t) {
+        @Override public void onFailure(Call<T> call, final Throwable t) {
           callbackExecutor.execute(new Runnable() {
             @Override public void run() {
-              callback.onFailure(call, t);
-              callback.onCallFinish();
+              callback.onFailure(ExecutorCallbackCall.this, t);
+                callback.onCallFinish();
             }
           });
         }
diff --git a/retrofit/src/main/java/retrofit2/HttpException.java b/retrofit/src/main/java/retrofit2/HttpException.java
new file mode 100644
index 000000000..c01f97dfe
--- /dev/null
+++ b/retrofit/src/main/java/retrofit2/HttpException.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import static retrofit2.Utils.checkNotNull;
+
+/** Exception for an unexpected, non-2xx HTTP response. */
+public class HttpException extends RuntimeException {
+  private static String getMessage(Response<?> response) {
+    checkNotNull(response, "response == null");
+    return "HTTP " + response.code() + " " + response.message();
+  }
+
+  private final int code;
+  private final String message;
+  private final transient Response<?> response;
+
+  public HttpException(Response<?> response) {
+    super(getMessage(response));
+    this.code = response.code();
+    this.message = response.message();
+    this.response = response;
+  }
+
+  /** HTTP status code. */
+  public int code() {
+    return code;
+  }
+
+  /** HTTP status message. */
+  public String message() {
+    return message;
+  }
+
+  /**
+   * The full HTTP response. This may be null if the exception was serialized.
+   */
+  public Response<?> response() {
+    return response;
+  }
+}
diff --git a/retrofit/src/main/java/retrofit2/OkHttpCall.java b/retrofit/src/main/java/retrofit2/OkHttpCall.java
index 5aa102db2..c547caf6b 100644
--- a/retrofit/src/main/java/retrofit2/OkHttpCall.java
+++ b/retrofit/src/main/java/retrofit2/OkHttpCall.java
@@ -16,6 +16,8 @@
 package retrofit2;
 
 import java.io.IOException;
+import javax.annotation.Nullable;
+import javax.annotation.concurrent.GuardedBy;
 import okhttp3.MediaType;
 import okhttp3.Request;
 import okhttp3.ResponseBody;
@@ -24,18 +26,22 @@
 import okio.ForwardingSource;
 import okio.Okio;
 
+import static retrofit2.Utils.checkNotNull;
+
 final class OkHttpCall<T> implements Call<T> {
-  private final ServiceMethod<T> serviceMethod;
-  private final Object[] args;
+  private final ServiceMethod<T, ?> serviceMethod;
+  private final @Nullable Object[] args;
 
   private volatile boolean canceled;
 
-  // All guarded by this.
-  private okhttp3.Call rawCall;
-  private Throwable creationFailure; // Either a RuntimeException or IOException.
+  @GuardedBy("this")
+  private @Nullable okhttp3.Call rawCall;
+  @GuardedBy("this")
+  private @Nullable Throwable creationFailure; // Either a RuntimeException or IOException.
+  @GuardedBy("this")
   private boolean executed;
 
-  OkHttpCall(ServiceMethod<T> serviceMethod, Object[] args) {
+  OkHttpCall(ServiceMethod<T, ?> serviceMethod, @Nullable Object[] args) {
     this.serviceMethod = serviceMethod;
     this.args = args;
   }
@@ -69,7 +75,7 @@
   }
 
   @Override public void enqueue(final Callback<T> callback) {
-    if (callback == null) throw new NullPointerException("callback == null");
+    checkNotNull(callback, "callback == null");
 
     okhttp3.Call call;
     Throwable failure;
@@ -112,11 +118,7 @@
       }
 
       @Override public void onFailure(okhttp3.Call call, IOException e) {
-        try {
-          callback.onFailure(OkHttpCall.this, e);
-        } catch (Throwable t) {
-          t.printStackTrace();
-        }
+        callFailure(e);
       }
 
       private void callFailure(Throwable e) {
@@ -203,6 +205,7 @@ private void callSuccess(Response<T> response) {
     }
 
     if (code == 204 || code == 205) {
+      rawBody.close();
       return Response.success(null, rawResponse);
     }
 
@@ -231,7 +234,12 @@ public void cancel() {
   }
 
   @Override public boolean isCanceled() {
-    return canceled;
+    if (canceled) {
+      return true;
+    }
+    synchronized (this) {
+      return rawCall != null && rawCall.isCanceled();
+    }
   }
 
   static final class NoContentResponseBody extends ResponseBody {
diff --git a/retrofit/src/main/java/retrofit2/ParameterHandler.java b/retrofit/src/main/java/retrofit2/ParameterHandler.java
index 38e21e559..10238b026 100644
--- a/retrofit/src/main/java/retrofit2/ParameterHandler.java
+++ b/retrofit/src/main/java/retrofit2/ParameterHandler.java
@@ -18,6 +18,7 @@
 import java.io.IOException;
 import java.lang.reflect.Array;
 import java.util.Map;
+import javax.annotation.Nullable;
 import okhttp3.Headers;
 import okhttp3.MultipartBody;
 import okhttp3.RequestBody;
@@ -25,11 +26,12 @@
 import static retrofit2.Utils.checkNotNull;
 
 abstract class ParameterHandler<T> {
-  abstract void apply(RequestBuilder builder, T value) throws IOException;
+  abstract void apply(RequestBuilder builder, @Nullable T value) throws IOException;
 
   final ParameterHandler<Iterable<T>> iterable() {
     return new ParameterHandler<Iterable<T>>() {
-      @Override void apply(RequestBuilder builder, Iterable<T> values) throws IOException {
+      @Override void apply(RequestBuilder builder, @Nullable Iterable<T> values)
+          throws IOException {
         if (values == null) return; // Skip null values.
 
         for (T value : values) {
@@ -41,7 +43,7 @@
 
   final ParameterHandler<Object> array() {
     return new ParameterHandler<Object>() {
-      @Override void apply(RequestBuilder builder, Object values) throws IOException {
+      @Override void apply(RequestBuilder builder, @Nullable Object values) throws IOException {
         if (values == null) return; // Skip null values.
 
         for (int i = 0, size = Array.getLength(values); i < size; i++) {
@@ -53,7 +55,8 @@
   }
 
   static final class RelativeUrl extends ParameterHandler<Object> {
-    @Override void apply(RequestBuilder builder, Object value) {
+    @Override void apply(RequestBuilder builder, @Nullable Object value) {
+      checkNotNull(value, "@Url parameter is null.");
       builder.setRelativeUrl(value);
     }
   }
@@ -67,9 +70,13 @@
       this.valueConverter = valueConverter;
     }
 
-    @Override void apply(RequestBuilder builder, T value) throws IOException {
+    @Override void apply(RequestBuilder builder, @Nullable T value) throws IOException {
       if (value == null) return; // Skip null values.
-      builder.addHeader(name, valueConverter.convert(value));
+
+      String headerValue = valueConverter.convert(value);
+      if (headerValue == null) return; // Skip converted but null values.
+
+      builder.addHeader(name, headerValue);
     }
   }
 
@@ -84,7 +91,7 @@
       this.encoded = encoded;
     }
 
-    @Override void apply(RequestBuilder builder, T value) throws IOException {
+    @Override void apply(RequestBuilder builder, @Nullable T value) throws IOException {
       if (value == null) {
         throw new IllegalArgumentException(
             "Path parameter \"" + name + "\" value must not be null.");
@@ -104,9 +111,28 @@
       this.encoded = encoded;
     }
 
-    @Override void apply(RequestBuilder builder, T value) throws IOException {
+    @Override void apply(RequestBuilder builder, @Nullable T value) throws IOException {
       if (value == null) return; // Skip null values.
-      builder.addQueryParam(name, valueConverter.convert(value), encoded);
+
+      String queryValue = valueConverter.convert(value);
+      if (queryValue == null) return; // Skip converted but null values
+
+      builder.addQueryParam(name, queryValue, encoded);
+    }
+  }
+
+  static final class QueryName<T> extends ParameterHandler<T> {
+    private final Converter<T, String> nameConverter;
+    private final boolean encoded;
+
+    QueryName(Converter<T, String> nameConverter, boolean encoded) {
+      this.nameConverter = nameConverter;
+      this.encoded = encoded;
+    }
+
+    @Override void apply(RequestBuilder builder, @Nullable T value) throws IOException {
+      if (value == null) return; // Skip null values.
+      builder.addQueryParam(nameConverter.convert(value), null, encoded);
     }
   }
 
@@ -119,7 +145,8 @@
       this.encoded = encoded;
     }
 
-    @Override void apply(RequestBuilder builder, Map<String, T> value) throws IOException {
+    @Override void apply(RequestBuilder builder, @Nullable Map<String, T> value)
+        throws IOException {
       if (value == null) {
         throw new IllegalArgumentException("Query map was null.");
       }
@@ -134,7 +161,47 @@
           throw new IllegalArgumentException(
               "Query map contained null value for key '" + entryKey + "'.");
         }
-        builder.addQueryParam(entryKey, valueConverter.convert(entryValue), encoded);
+
+        String convertedEntryValue = valueConverter.convert(entryValue);
+        if (convertedEntryValue == null) {
+          throw new IllegalArgumentException("Query map value '"
+              + entryValue
+              + "' converted to null by "
+              + valueConverter.getClass().getName()
+              + " for key '"
+              + entryKey
+              + "'.");
+        }
+
+        builder.addQueryParam(entryKey, convertedEntryValue, encoded);
+      }
+    }
+  }
+
+  static final class HeaderMap<T> extends ParameterHandler<Map<String, T>> {
+    private final Converter<T, String> valueConverter;
+
+    HeaderMap(Converter<T, String> valueConverter) {
+      this.valueConverter = valueConverter;
+    }
+
+    @Override void apply(RequestBuilder builder, @Nullable Map<String, T> value)
+        throws IOException {
+      if (value == null) {
+        throw new IllegalArgumentException("Header map was null.");
+      }
+
+      for (Map.Entry<String, T> entry : value.entrySet()) {
+        String headerName = entry.getKey();
+        if (headerName == null) {
+          throw new IllegalArgumentException("Header map contained null key.");
+        }
+        T headerValue = entry.getValue();
+        if (headerValue == null) {
+          throw new IllegalArgumentException(
+              "Header map contained null value for key '" + headerName + "'.");
+        }
+        builder.addHeader(headerName, valueConverter.convert(headerValue));
       }
     }
   }
@@ -150,9 +217,13 @@
       this.encoded = encoded;
     }
 
-    @Override void apply(RequestBuilder builder, T value) throws IOException {
+    @Override void apply(RequestBuilder builder, @Nullable T value) throws IOException {
       if (value == null) return; // Skip null values.
-      builder.addFormField(name, valueConverter.convert(value), encoded);
+
+      String fieldValue = valueConverter.convert(value);
+      if (fieldValue == null) return; // Skip null converted values
+
+      builder.addFormField(name, fieldValue, encoded);
     }
   }
 
@@ -165,7 +236,8 @@
       this.encoded = encoded;
     }
 
-    @Override void apply(RequestBuilder builder, Map<String, T> value) throws IOException {
+    @Override void apply(RequestBuilder builder, @Nullable Map<String, T> value)
+        throws IOException {
       if (value == null) {
         throw new IllegalArgumentException("Field map was null.");
       }
@@ -180,7 +252,19 @@
           throw new IllegalArgumentException(
               "Field map contained null value for key '" + entryKey + "'.");
         }
-        builder.addFormField(entryKey, valueConverter.convert(entryValue), encoded);
+
+        String fieldEntry = valueConverter.convert(entryValue);
+        if (fieldEntry == null) {
+          throw new IllegalArgumentException("Field map value '"
+              + entryValue
+              + "' converted to null by "
+              + valueConverter.getClass().getName()
+              + " for key '"
+              + entryKey
+              + "'.");
+        }
+
+        builder.addFormField(entryKey, fieldEntry, encoded);
       }
     }
   }
@@ -194,7 +278,7 @@
       this.converter = converter;
     }
 
-    @Override void apply(RequestBuilder builder, T value) {
+    @Override void apply(RequestBuilder builder, @Nullable T value) {
       if (value == null) return; // Skip null values.
 
       RequestBody body;
@@ -213,7 +297,8 @@
     private RawPart() {
     }
 
-    @Override void apply(RequestBuilder builder, MultipartBody.Part value) throws IOException {
+    @Override void apply(RequestBuilder builder, @Nullable MultipartBody.Part value)
+        throws IOException {
       if (value != null) { // Skip null values.
         builder.addPart(value);
       }
@@ -229,7 +314,8 @@ private RawPart() {
       this.transferEncoding = transferEncoding;
     }
 
-    @Override void apply(RequestBuilder builder, Map<String, T> value) throws IOException {
+    @Override void apply(RequestBuilder builder, @Nullable Map<String, T> value)
+        throws IOException {
       if (value == null) {
         throw new IllegalArgumentException("Part map was null.");
       }
@@ -261,7 +347,7 @@ private RawPart() {
       this.converter = converter;
     }
 
-    @Override void apply(RequestBuilder builder, T value) {
+    @Override void apply(RequestBuilder builder, @Nullable T value) {
       if (value == null) {
         throw new IllegalArgumentException("Body parameter value must not be null.");
       }
diff --git a/retrofit/src/main/java/retrofit2/Platform.java b/retrofit/src/main/java/retrofit2/Platform.java
index 444b80b18..fb768ecdc 100644
--- a/retrofit/src/main/java/retrofit2/Platform.java
+++ b/retrofit/src/main/java/retrofit2/Platform.java
@@ -18,12 +18,9 @@
 import android.os.Build;
 import android.os.Handler;
 import android.os.Looper;
-
-import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.util.concurrent.Executor;
 
-
 class Platform {
   private static final Platform PLATFORM = findPlatform();
 
@@ -43,20 +40,15 @@ private static Platform findPlatform() {
 //      Class.forName("java.util.Optional");
 //      return new Java8();
 //    } catch (ClassNotFoundException ignored) {
-//    }
-//    try {
-//      Class.forName("org.robovm.apple.foundation.NSObject");
-//      return new IOS();
-//    } catch (ClassNotFoundException ignored) {
 //    }
     return new Platform();
   }
 
-  Executor defaultCallbackExecutor() {
+   Executor defaultCallbackExecutor() {
     return null;
   }
 
-  CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) {
+  CallAdapter.Factory defaultCallAdapterFactory( Executor callbackExecutor) {
     if (callbackExecutor != null) {
       return new ExecutorCallAdapterFactory(callbackExecutor);
     }
@@ -67,8 +59,8 @@ boolean isDefaultMethod(Method method) {
     return false;
   }
 
-  Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object, Object... args)
-      throws Throwable {
+  Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object,
+       Object... args) throws Throwable {
     throw new UnsupportedOperationException();
   }
 
@@ -79,7 +71,7 @@ Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object
 //    }
 //
 //    @Override Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object,
-//        Object... args) throws Throwable {
+//        @Nullable Object... args) throws Throwable {
 //      // Because the service interface might not be public, we need to use a MethodHandle lookup
 //      // that ignores the visibility of the declaringClass.
 //      Constructor<Lookup> constructor = Lookup.class.getDeclaredConstructor(Class.class, int.class);
@@ -96,7 +88,8 @@ Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object
       return new MainThreadExecutor();
     }
 
-    @Override CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) {
+    @Override CallAdapter.Factory defaultCallAdapterFactory( Executor callbackExecutor) {
+      if (callbackExecutor == null) throw new AssertionError();
       return new ExecutorCallAdapterFactory(callbackExecutor);
     }
 
@@ -108,47 +101,4 @@ Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object
       }
     }
   }
-
-  static class IOS extends Platform {
-    @Override public Executor defaultCallbackExecutor() {
-      return new MainThreadExecutor();
-    }
-
-    @Override CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) {
-      return new ExecutorCallAdapterFactory(callbackExecutor);
-    }
-
-    static class MainThreadExecutor implements Executor {
-      private static Object queue;
-      private static Method addOperation;
-
-      static {
-        try {
-          // queue = NSOperationQueue.getMainQueue();
-          Class<?> operationQueue = Class.forName("org.robovm.apple.foundation.NSOperationQueue");
-          queue = operationQueue.getDeclaredMethod("getMainQueue").invoke(null);
-          addOperation = operationQueue.getDeclaredMethod("addOperation", Runnable.class);
-        } catch (Exception e) {
-          throw new AssertionError(e);
-        }
-      }
-
-      @Override public void execute(Runnable r) {
-        try {
-          // queue.addOperation(r);
-          addOperation.invoke(queue, r);
-        } catch (IllegalArgumentException | IllegalAccessException e) {
-          throw new AssertionError(e);
-        } catch (InvocationTargetException e) {
-          Throwable cause = e.getCause();
-          if (cause instanceof RuntimeException) {
-            throw (RuntimeException) cause;
-          } else if (cause instanceof Error) {
-            throw (Error) cause;
-          }
-          throw new RuntimeException(cause);
-        }
-      }
-    }
-  }
 }
diff --git a/retrofit/src/main/java/retrofit2/RequestBuilder.java b/retrofit/src/main/java/retrofit2/RequestBuilder.java
index 1303418d3..f27db26ee 100644
--- a/retrofit/src/main/java/retrofit2/RequestBuilder.java
+++ b/retrofit/src/main/java/retrofit2/RequestBuilder.java
@@ -16,6 +16,7 @@
 package retrofit2;
 
 import java.io.IOException;
+import javax.annotation.Nullable;
 import okhttp3.FormBody;
 import okhttp3.Headers;
 import okhttp3.HttpUrl;
@@ -34,19 +35,20 @@
   private final String method;
 
   private final HttpUrl baseUrl;
-  private String relativeUrl;
-  private HttpUrl.Builder urlBuilder;
+  private @Nullable String relativeUrl;
+  private @Nullable HttpUrl.Builder urlBuilder;
 
   private final Request.Builder requestBuilder;
-  private MediaType contentType;
+  private @Nullable MediaType contentType;
 
   private final boolean hasBody;
-  private MultipartBody.Builder multipartBuilder;
-  private FormBody.Builder formBuilder;
-  private RequestBody body;
+  private @Nullable MultipartBody.Builder multipartBuilder;
+  private @Nullable FormBody.Builder formBuilder;
+  private @Nullable RequestBody body;
 
-  RequestBuilder(String method, HttpUrl baseUrl, String relativeUrl, Headers headers,
-      MediaType contentType, boolean hasBody, boolean isFormEncoded, boolean isMultipart) {
+  RequestBuilder(String method, HttpUrl baseUrl, @Nullable String relativeUrl,
+      @Nullable Headers headers, @Nullable MediaType contentType, boolean hasBody,
+      boolean isFormEncoded, boolean isMultipart) {
     this.method = method;
     this.baseUrl = baseUrl;
     this.relativeUrl = relativeUrl;
@@ -69,13 +71,16 @@
   }
 
   void setRelativeUrl(Object relativeUrl) {
-    if (relativeUrl == null) throw new NullPointerException("@Url parameter is null.");
     this.relativeUrl = relativeUrl.toString();
   }
 
   void addHeader(String name, String value) {
     if ("Content-Type".equalsIgnoreCase(name)) {
-      contentType = MediaType.parse(value);
+      MediaType type = MediaType.parse(value);
+      if (type == null) {
+        throw new IllegalArgumentException("Malformed content type: " + value);
+      }
+      contentType = type;
     } else {
       requestBuilder.addHeader(name, value);
     }
@@ -138,7 +143,7 @@ private static void canonicalizeForPath(Buffer out, String input, int pos, int l
     }
   }
 
-  void addQueryParam(String name, String value, boolean encoded) {
+  void addQueryParam(String name, @Nullable String value, boolean encoded) {
     if (relativeUrl != null) {
       // Do a one-time combination of the built relative URL and the base URL.
       urlBuilder = baseUrl.newBuilder(relativeUrl);
@@ -150,12 +155,15 @@ void addQueryParam(String name, String value, boolean encoded) {
     }
 
     if (encoded) {
+      //noinspection ConstantConditions Checked to be non-null by above 'if' block.
       urlBuilder.addEncodedQueryParameter(name, value);
     } else {
+      //noinspection ConstantConditions Checked to be non-null by above 'if' block.
       urlBuilder.addQueryParameter(name, value);
     }
   }
 
+  @SuppressWarnings("ConstantConditions") // Only called when isFormEncoded was true.
   void addFormField(String name, String value, boolean encoded) {
     if (encoded) {
       formBuilder.addEncoded(name, value);
@@ -164,10 +172,12 @@ void addFormField(String name, String value, boolean encoded) {
     }
   }
 
+  @SuppressWarnings("ConstantConditions") // Only called when isMultipart was true.
   void addPart(Headers headers, RequestBody body) {
     multipartBuilder.addPart(headers, body);
   }
 
+  @SuppressWarnings("ConstantConditions") // Only called when isMultipart was true.
   void addPart(MultipartBody.Part part) {
     multipartBuilder.addPart(part);
   }
@@ -183,6 +193,7 @@ Request build() {
       url = urlBuilder.build();
     } else {
       // No query parameters triggered builder creation, just combine the relative URL and base URL.
+      //noinspection ConstantConditions Non-null if urlBuilder is null.
       url = baseUrl.resolve(relativeUrl);
       if (url == null) {
         throw new IllegalArgumentException(
diff --git a/retrofit/src/main/java/retrofit2/Response.java b/retrofit/src/main/java/retrofit2/Response.java
index cb0518f00..11d6ecb24 100644
--- a/retrofit/src/main/java/retrofit2/Response.java
+++ b/retrofit/src/main/java/retrofit2/Response.java
@@ -15,15 +15,18 @@
  */
 package retrofit2;
 
+import javax.annotation.Nullable;
 import okhttp3.Headers;
 import okhttp3.Protocol;
 import okhttp3.Request;
 import okhttp3.ResponseBody;
 
+import static retrofit2.Utils.checkNotNull;
+
 /** An HTTP response. */
 public final class Response<T> {
   /** Create a synthetic successful response with {@code body} as the deserialized body. */
-  public static <T> Response<T> success(T body) {
+  public static <T> Response<T> success(@Nullable T body) {
     return success(body, new okhttp3.Response.Builder() //
         .code(200)
         .message("OK")
@@ -36,8 +39,8 @@
    * Create a synthetic successful response using {@code headers} with {@code body} as the
    * deserialized body.
    */
-  public static <T> Response<T> success(T body, Headers headers) {
-    if (headers == null) throw new NullPointerException("headers == null");
+  public static <T> Response<T> success(@Nullable T body, Headers headers) {
+    checkNotNull(headers, "headers == null");
     return success(body, new okhttp3.Response.Builder() //
         .code(200)
         .message("OK")
@@ -51,8 +54,8 @@
    * Create a successful response from {@code rawResponse} with {@code body} as the deserialized
    * body.
    */
-  public static <T> Response<T> success(T body, okhttp3.Response rawResponse) {
-    if (rawResponse == null) throw new NullPointerException("rawResponse == null");
+  public static <T> Response<T> success(@Nullable T body, okhttp3.Response rawResponse) {
+    checkNotNull(rawResponse, "rawResponse == null");
     if (!rawResponse.isSuccessful()) {
       throw new IllegalArgumentException("rawResponse must be successful response");
     }
@@ -67,6 +70,7 @@
     if (code < 400) throw new IllegalArgumentException("code < 400: " + code);
     return error(body, new okhttp3.Response.Builder() //
         .code(code)
+        .message("Response.error()")
         .protocol(Protocol.HTTP_1_1)
         .request(new Request.Builder().url("http://localhost/").build())
         .build());
@@ -74,8 +78,8 @@
 
   /** Create an error response from {@code rawResponse} with {@code body} as the error body. */
   public static <T> Response<T> error(ResponseBody body, okhttp3.Response rawResponse) {
-    if (body == null) throw new NullPointerException("body == null");
-    if (rawResponse == null) throw new NullPointerException("rawResponse == null");
+    checkNotNull(body, "body == null");
+    checkNotNull(rawResponse, "rawResponse == null");
     if (rawResponse.isSuccessful()) {
       throw new IllegalArgumentException("rawResponse should not be successful response");
     }
@@ -83,11 +87,12 @@
   }
 
   private final okhttp3.Response rawResponse;
-  private final T body;
-  private final ResponseBody errorBody;
+  private final @Nullable T body;
+  private final @Nullable ResponseBody errorBody;
   private String errorBodyString;
 
-  private Response(okhttp3.Response rawResponse, T body, ResponseBody errorBody) {
+  private Response(okhttp3.Response rawResponse, @Nullable T body,
+      @Nullable ResponseBody errorBody) {
     this.rawResponse = rawResponse;
     this.body = body;
     this.errorBody = errorBody;
@@ -133,12 +138,16 @@ public boolean isSuccessful() {
   }
 
   /** The deserialized response body of a {@linkplain #isSuccessful() successful} response. */
-  public T body() {
+  public @Nullable T body() {
     return body;
   }
 
   /** The raw response body of an {@linkplain #isSuccessful() unsuccessful} response. */
-  public ResponseBody errorBody() {
+  public @Nullable ResponseBody errorBody() {
     return errorBody;
   }
+
+  @Override public String toString() {
+    return rawResponse.toString();
+  }
 }
diff --git a/retrofit/src/main/java/retrofit2/Retrofit.java b/retrofit/src/main/java/retrofit2/Retrofit.java
index 3f7455e40..cd04053b0 100644
--- a/retrofit/src/main/java/retrofit2/Retrofit.java
+++ b/retrofit/src/main/java/retrofit2/Retrofit.java
@@ -21,10 +21,11 @@
 import java.lang.reflect.Proxy;
 import java.lang.reflect.Type;
 import java.util.ArrayList;
-import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.Executor;
+import javax.annotation.Nullable;
 import okhttp3.HttpUrl;
 import okhttp3.OkHttpClient;
 import okhttp3.RequestBody;
@@ -44,32 +45,32 @@
  * the builder} and pass your interface to {@link #create} to generate an implementation.
  * <p>
  * For example,
- * <pre>{@code
+ * <pre><code>
  * Retrofit retrofit = new Retrofit.Builder()
  *     .baseUrl("https://api.example.com/")
  *     .addConverterFactory(GsonConverterFactory.create())
  *     .build();
  *
  * MyApi api = retrofit.create(MyApi.class);
- * Response<User> user = api.getUser().execute();
- * }</pre>
+ * Response&lt;User&gt; user = api.getUser().execute();
+ * </code></pre>
  *
  * @author Bob Lee (bob@squareup.com)
  * @author Jake Wharton (jw@squareup.com)
  */
 public final class Retrofit {
-  private final Map<Method, ServiceMethod> serviceMethodCache = new LinkedHashMap<>();
+  private final Map<Method, ServiceMethod<?, ?>> serviceMethodCache = new ConcurrentHashMap<>();
 
-  private final okhttp3.Call.Factory callFactory;
-  private final HttpUrl baseUrl;
-  private final List<Converter.Factory> converterFactories;
-  private final List<CallAdapter.Factory> adapterFactories;
-  private final Executor callbackExecutor;
-  private final boolean validateEagerly;
+  final okhttp3.Call.Factory callFactory;
+  final HttpUrl baseUrl;
+  final List<Converter.Factory> converterFactories;
+  final List<CallAdapter.Factory> adapterFactories;
+  final @Nullable Executor callbackExecutor;
+  final boolean validateEagerly;
 
   Retrofit(okhttp3.Call.Factory callFactory, HttpUrl baseUrl,
       List<Converter.Factory> converterFactories, List<CallAdapter.Factory> adapterFactories,
-      Executor callbackExecutor, boolean validateEagerly) {
+      @Nullable Executor callbackExecutor, boolean validateEagerly) {
     this.callFactory = callFactory;
     this.baseUrl = baseUrl;
     this.converterFactories = unmodifiableList(converterFactories); // Defensive copy at call site.
@@ -134,7 +135,7 @@
         new InvocationHandler() {
           private final Platform platform = Platform.get();
 
-          @Override public Object invoke(Object proxy, Method method, Object... args)
+          @Override public Object invoke(Object proxy, Method method, @Nullable Object[] args)
               throws Throwable {
             // If the method is a method from Object then defer to normal invocation.
             if (method.getDeclaringClass() == Object.class) {
@@ -143,8 +144,9 @@
             if (platform.isDefaultMethod(method)) {
               return platform.invokeDefaultMethod(method, service, proxy, args);
             }
-            ServiceMethod serviceMethod = loadServiceMethod(method);
-            OkHttpCall okHttpCall = new OkHttpCall<>(serviceMethod, args);
+            ServiceMethod<Object, Object> serviceMethod =
+                (ServiceMethod<Object, Object>) loadServiceMethod(method);
+            OkHttpCall<Object> okHttpCall = new OkHttpCall<>(serviceMethod, args);
             // 如果参数里有 callback 则 直接执行
             if (RetrofitUtil.isDirectCall(method,args)) {
               Call call = (Call)serviceMethod.callAdapter.adapt(okHttpCall);
@@ -164,12 +166,14 @@ private void eagerlyValidateMethods(Class<?> service) {
     }
   }
 
-  ServiceMethod loadServiceMethod(Method method) {
-    ServiceMethod result;
+  ServiceMethod<?, ?> loadServiceMethod(Method method) {
+    ServiceMethod<?, ?> result = serviceMethodCache.get(method);
+    if (result != null) return result;
+
     synchronized (serviceMethodCache) {
       result = serviceMethodCache.get(method);
       if (result == null) {
-        result = new ServiceMethod.Builder(this, method).build();
+        result = new ServiceMethod.Builder<>(this, method).build();
         serviceMethodCache.put(method, result);
       }
     }
@@ -203,7 +207,7 @@ public HttpUrl baseUrl() {
    *
    * @throws IllegalArgumentException if no call adapter available for {@code type}.
    */
-  public CallAdapter<?> callAdapter(Type returnType, Annotation[] annotations) {
+  public CallAdapter<?, ?> callAdapter(Type returnType, Annotation[] annotations) {
     return nextCallAdapter(null, returnType, annotations);
   }
 
@@ -213,14 +217,14 @@ public HttpUrl baseUrl() {
    *
    * @throws IllegalArgumentException if no call adapter available for {@code type}.
    */
-  public CallAdapter<?> nextCallAdapter(CallAdapter.Factory skipPast, Type returnType,
+  public CallAdapter<?, ?> nextCallAdapter(@Nullable CallAdapter.Factory skipPast, Type returnType,
       Annotation[] annotations) {
     checkNotNull(returnType, "returnType == null");
     checkNotNull(annotations, "annotations == null");
 
     int start = adapterFactories.indexOf(skipPast) + 1;
     for (int i = start, count = adapterFactories.size(); i < count; i++) {
-      CallAdapter<?> adapter = adapterFactories.get(i).get(returnType, annotations, this);
+      CallAdapter<?, ?> adapter = adapterFactories.get(i).get(returnType, annotations, this);
       if (adapter != null) {
         return adapter;
       }
@@ -270,8 +274,9 @@ public HttpUrl baseUrl() {
    *
    * @throws IllegalArgumentException if no converter available for {@code type}.
    */
-  public <T> Converter<T, RequestBody> nextRequestBodyConverter(Converter.Factory skipPast,
-      Type type, Annotation[] parameterAnnotations, Annotation[] methodAnnotations) {
+  public <T> Converter<T, RequestBody> nextRequestBodyConverter(
+      @Nullable Converter.Factory skipPast, Type type, Annotation[] parameterAnnotations,
+      Annotation[] methodAnnotations) {
     checkNotNull(type, "type == null");
     checkNotNull(parameterAnnotations, "parameterAnnotations == null");
     checkNotNull(methodAnnotations, "methodAnnotations == null");
@@ -320,8 +325,8 @@ public HttpUrl baseUrl() {
    *
    * @throws IllegalArgumentException if no converter available for {@code type}.
    */
-  public <T> Converter<ResponseBody, T> nextResponseBodyConverter(Converter.Factory skipPast,
-      Type type, Annotation[] annotations) {
+  public <T> Converter<ResponseBody, T> nextResponseBodyConverter(
+      @Nullable Converter.Factory skipPast, Type type, Annotation[] annotations) {
     checkNotNull(type, "type == null");
     checkNotNull(annotations, "annotations == null");
 
@@ -378,10 +383,14 @@ public HttpUrl baseUrl() {
    * The executor used for {@link Callback} methods on a {@link Call}. This may be {@code null},
    * in which case callbacks should be made synchronously on the background thread.
    */
-  public Executor callbackExecutor() {
+  public @Nullable Executor callbackExecutor() {
     return callbackExecutor;
   }
 
+  public Builder newBuilder() {
+    return new Builder(this);
+  }
+
   /**
    * Build a new {@link Retrofit}.
    * <p>
@@ -389,12 +398,12 @@ public Executor callbackExecutor() {
    * are optional.
    */
   public static final class Builder {
-    private Platform platform;
-    private okhttp3.Call.Factory callFactory;
+    private final Platform platform;
+    private @Nullable okhttp3.Call.Factory callFactory;
     private HttpUrl baseUrl;
-    private List<Converter.Factory> converterFactories = new ArrayList<>();
-    private List<CallAdapter.Factory> adapterFactories = new ArrayList<>();
-    private Executor callbackExecutor;
+    private final List<Converter.Factory> converterFactories = new ArrayList<>();
+    private final List<CallAdapter.Factory> adapterFactories = new ArrayList<>();
+    private @Nullable Executor callbackExecutor;
     private boolean validateEagerly;
 
     Builder(Platform platform) {
@@ -408,14 +417,22 @@ public Builder() {
       this(Platform.get());
     }
 
+    Builder(Retrofit retrofit) {
+      platform = Platform.get();
+      callFactory = retrofit.callFactory;
+      baseUrl = retrofit.baseUrl;
+      converterFactories.addAll(retrofit.converterFactories);
+      adapterFactories.addAll(retrofit.adapterFactories);
+      // Remove the default, platform-aware call adapter added by build().
+      adapterFactories.remove(adapterFactories.size() - 1);
+      callbackExecutor = retrofit.callbackExecutor;
+      validateEagerly = retrofit.validateEagerly;
+    }
+
     /**
      * The HTTP client used for requests.
      * <p>
      * This is a convenience method for calling {@link #callFactory}.
-     * <p>
-     * Note: This method <b>does not</b> make a defensive copy of {@code client}. Changes to its
-     * settings will affect subsequent requests. Pass in a {@linkplain OkHttpClient#clone() cloned}
-     * instance to prevent this if desired.
      */
     public Builder client(OkHttpClient client) {
       return callFactory(checkNotNull(client, "client == null"));
diff --git a/retrofit/src/main/java/retrofit2/ServiceMethod.java b/retrofit/src/main/java/retrofit2/ServiceMethod.java
index ef816ea3f..a5b4f1e66 100644
--- a/retrofit/src/main/java/retrofit2/ServiceMethod.java
+++ b/retrofit/src/main/java/retrofit2/ServiceMethod.java
@@ -26,6 +26,7 @@
 import java.util.Set;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
+import javax.annotation.Nullable;
 import okhttp3.Headers;
 import okhttp3.HttpUrl;
 import okhttp3.MediaType;
@@ -42,6 +43,7 @@
 import retrofit2.http.HEAD;
 import retrofit2.http.HTTP;
 import retrofit2.http.Header;
+import retrofit2.http.HeaderMap;
 import retrofit2.http.Multipart;
 import retrofit2.http.OPTIONS;
 import retrofit2.http.PATCH;
@@ -52,22 +54,23 @@
 import retrofit2.http.Path;
 import retrofit2.http.Query;
 import retrofit2.http.QueryMap;
+import retrofit2.http.QueryName;
 import retrofit2.http.Url;
 import retrofit2.plus.HTTPS;
 import retrofit2.plus.RetrofitUtil;
 
 /** Adapts an invocation of an interface method into an HTTP call. */
-final class ServiceMethod<T> {
+final class ServiceMethod<R, T> {
   // Upper and lower characters, digits, underscores, and hyphens, starting with a character.
   static final String PARAM = "[a-zA-Z][a-zA-Z0-9_-]*";
   static final Pattern PARAM_URL_REGEX = Pattern.compile("\\{(" + PARAM + ")\\}");
   static final Pattern PARAM_NAME_REGEX = Pattern.compile(PARAM);
 
   final okhttp3.Call.Factory callFactory;
-  final CallAdapter<?> callAdapter;
+  final CallAdapter<R, T> callAdapter;
 
   private final HttpUrl baseUrl;
-  private final Converter<ResponseBody, T> responseConverter;
+  private final Converter<ResponseBody, R> responseConverter;
   private final String httpMethod;
   private final String relativeUrl;
   private final Headers headers;
@@ -77,7 +80,7 @@
   private final boolean isMultipart;
   private final ParameterHandler<?>[] parameterHandlers;
 
-  ServiceMethod(Builder<T> builder) {
+  ServiceMethod(Builder<R, T> builder) {
     this.callFactory = builder.retrofit.callFactory();
     this.callAdapter = builder.callAdapter;
     this.baseUrl = builder.baseUrl;
@@ -93,7 +96,7 @@
   }
 
   /** Builds an HTTP request from method arguments. */
-  Request toRequest(Object... args) throws IOException {
+  Request toRequest(@Nullable Object... args) throws IOException {
     RequestBuilder requestBuilder = new RequestBuilder(httpMethod, baseUrl, relativeUrl, headers,
         contentType, hasBody, isFormEncoded, isMultipart);
 
@@ -114,7 +117,7 @@ Request toRequest(Object... args) throws IOException {
   }
 
   /** Builds a method return value from an HTTP response body. */
-  T toResponse(ResponseBody body) throws IOException {
+  R toResponse(ResponseBody body) throws IOException {
     return responseConverter.convert(body);
   }
 
@@ -123,7 +126,7 @@ T toResponse(ResponseBody body) throws IOException {
    * requires potentially-expensive reflection so it is best to build each service method only once
    * and reuse it. Builders cannot be reused.
    */
-  static final class Builder<T> {
+  static final class Builder<T, R> {
     final Retrofit retrofit;
     final Method method;
     final Annotation[] methodAnnotations;
@@ -147,10 +150,10 @@ T toResponse(ResponseBody body) throws IOException {
     Set<String> relativeUrlParamNames;
     ParameterHandler<?>[] parameterHandlers;
     Converter<ResponseBody, T> responseConverter;
-    CallAdapter<?> callAdapter;
+    CallAdapter<T, R> callAdapter;
     HttpUrl baseUrl;
 
-    public Builder(Retrofit retrofit, Method method) {
+    Builder(Retrofit retrofit, Method method) {
       this.retrofit = retrofit;
       this.method = method;
       this.methodAnnotations = method.getAnnotations();
@@ -221,15 +224,16 @@ public ServiceMethod build() {
       return new ServiceMethod<>(this);
     }
 
-    private CallAdapter<?> createCallAdapter() {
-      Type returnType = RetrofitUtil.getReturnTypeIfWithCallbackArg(method);
+    private CallAdapter<T, R> createCallAdapter() {
+      Type returnType = RetrofitUtil.getReturnTypeIfWithCallbackArg(method);;
       if (Utils.hasUnresolvableType(returnType)) {
         throw methodError(
                 "Method return type must not include a type variable or wildcard: %s", returnType);
       }
       Annotation[] annotations = method.getAnnotations();
       try {
-        return retrofit.callAdapter(returnType, annotations);
+        //noinspection unchecked
+        return (CallAdapter<T, R>) retrofit.callAdapter(returnType, annotations);
       } catch (RuntimeException e) { // Wide exception range because factories are user code.
         throw methodError(e, "Unable to create call adapter for %s", returnType);
       }
@@ -316,7 +320,11 @@ private Headers parseHeaders(String[] headers) {
         String headerName = header.substring(0, colon);
         String headerValue = header.substring(colon + 1).trim();
         if ("Content-Type".equalsIgnoreCase(headerName)) {
-          contentType = MediaType.parse(headerValue);
+          MediaType type = MediaType.parse(headerValue);
+          if (type == null) {
+            throw methodError("Malformed content type: %s", headerValue);
+          }
+          contentType = type;
         } else {
           builder.add(headerName, headerValue);
         }
@@ -426,6 +434,35 @@ private Headers parseHeaders(String[] headers) {
           return new ParameterHandler.Query<>(name, converter, encoded);
         }
 
+      } else if (annotation instanceof QueryName) {
+        QueryName query = (QueryName) annotation;
+        boolean encoded = query.encoded();
+
+        Class<?> rawParameterType = Utils.getRawType(type);
+        gotQuery = true;
+        if (Iterable.class.isAssignableFrom(rawParameterType)) {
+          if (!(type instanceof ParameterizedType)) {
+            throw parameterError(p, rawParameterType.getSimpleName()
+                + " must include generic type (e.g., "
+                + rawParameterType.getSimpleName()
+                + "<String>)");
+          }
+          ParameterizedType parameterizedType = (ParameterizedType) type;
+          Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
+          Converter<?, String> converter =
+              retrofit.stringConverter(iterableType, annotations);
+          return new ParameterHandler.QueryName<>(converter, encoded).iterable();
+        } else if (rawParameterType.isArray()) {
+          Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
+          Converter<?, String> converter =
+              retrofit.stringConverter(arrayComponentType, annotations);
+          return new ParameterHandler.QueryName<>(converter, encoded).array();
+        } else {
+          Converter<?, String> converter =
+              retrofit.stringConverter(type, annotations);
+          return new ParameterHandler.QueryName<>(converter, encoded);
+        }
+
       } else if (annotation instanceof QueryMap) {
         Class<?> rawParameterType = Utils.getRawType(type);
         if (!Map.class.isAssignableFrom(rawParameterType)) {
@@ -474,6 +511,26 @@ private Headers parseHeaders(String[] headers) {
           return new ParameterHandler.Header<>(name, converter);
         }
 
+      } else if (annotation instanceof HeaderMap) {
+        Class<?> rawParameterType = Utils.getRawType(type);
+        if (!Map.class.isAssignableFrom(rawParameterType)) {
+          throw parameterError(p, "@HeaderMap parameter type must be Map.");
+        }
+        Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
+        if (!(mapType instanceof ParameterizedType)) {
+          throw parameterError(p, "Map must include generic types (e.g., Map<String, String>)");
+        }
+        ParameterizedType parameterizedType = (ParameterizedType) mapType;
+        Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
+        if (String.class != keyType) {
+          throw parameterError(p, "@HeaderMap keys must be of type String: " + keyType);
+        }
+        Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
+        Converter<?, String> valueConverter =
+            retrofit.stringConverter(valueType, annotations);
+
+        return new ParameterHandler.HeaderMap<>(valueConverter);
+
       } else if (annotation instanceof Field) {
         if (!isFormEncoded) {
           throw parameterError(p, "@Field parameters can only be used with form encoding.");
diff --git a/retrofit/src/main/java/retrofit2/Utils.java b/retrofit/src/main/java/retrofit2/Utils.java
index f3fa87571..1b05c65a0 100644
--- a/retrofit/src/main/java/retrofit2/Utils.java
+++ b/retrofit/src/main/java/retrofit2/Utils.java
@@ -26,6 +26,7 @@
 import java.lang.reflect.WildcardType;
 import java.util.Arrays;
 import java.util.NoSuchElementException;
+import javax.annotation.Nullable;
 import okhttp3.ResponseBody;
 import okio.Buffer;
 
@@ -36,12 +37,14 @@ private Utils() {
     // No instances.
   }
 
-  public static Class<?> getRawType(Type type) {
+  static Class<?> getRawType(Type type) {
+    checkNotNull(type, "type == null");
+
     if (type instanceof Class<?>) {
       // Type is a normal class.
       return (Class<?>) type;
-
-    } else if (type instanceof ParameterizedType) {
+    }
+    if (type instanceof ParameterizedType) {
       ParameterizedType parameterizedType = (ParameterizedType) type;
 
       // I'm not exactly sure why getRawType() returns Type instead of Class. Neal isn't either but
@@ -49,28 +52,26 @@ private Utils() {
       Type rawType = parameterizedType.getRawType();
       if (!(rawType instanceof Class)) throw new IllegalArgumentException();
       return (Class<?>) rawType;
-
-    } else if (type instanceof GenericArrayType) {
+    }
+    if (type instanceof GenericArrayType) {
       Type componentType = ((GenericArrayType) type).getGenericComponentType();
       return Array.newInstance(getRawType(componentType), 0).getClass();
-
-    } else if (type instanceof TypeVariable) {
+    }
+    if (type instanceof TypeVariable) {
       // We could use the variable's bounds, but that won't work if there are multiple. Having a raw
       // type that's more general than necessary is okay.
       return Object.class;
-
-    } else if (type instanceof WildcardType) {
+    }
+    if (type instanceof WildcardType) {
       return getRawType(((WildcardType) type).getUpperBounds()[0]);
-
-    } else {
-      String className = type == null ? "null" : type.getClass().getName();
-      throw new IllegalArgumentException("Expected a Class, ParameterizedType, or "
-          + "GenericArrayType, but <" + type + "> is of type " + className);
     }
+
+    throw new IllegalArgumentException("Expected a Class, ParameterizedType, or "
+          + "GenericArrayType, but <" + type + "> is of type " + type.getClass().getName());
   }
 
   /** Returns true if {@code a} and {@code b} are equal. */
-  public static boolean equals(Type a, Type b) {
+  static boolean equals(Type a, Type b) {
     if (a == b) {
       return true; // Also handles (a == null && b == null).
 
@@ -162,7 +163,7 @@ static int hashCodeOrZero(Object o) {
     return o != null ? o.hashCode() : 0;
   }
 
-  public static String typeToString(Type type) {
+  static String typeToString(Type type) {
     return type instanceof Class ? ((Class<?>) type).getName() : type.toString();
   }
 
@@ -173,13 +174,13 @@ public static String typeToString(Type type) {
    *
    * @param supertype a superclass of, or interface implemented by, this.
    */
-  public static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) {
+  static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) {
     if (!supertype.isAssignableFrom(contextRawType)) throw new IllegalArgumentException();
     return resolve(context, contextRawType,
         getGenericSupertype(context, contextRawType, supertype));
   }
 
-  public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {
+  static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {
     // This implementation is made a little more complicated in an attempt to avoid object-creation.
     while (true) {
       if (toResolve instanceof TypeVariable) {
@@ -280,7 +281,7 @@ static void checkNotPrimitive(Type type) {
     }
   }
 
-  static <T> T checkNotNull(T object, String message) {
+  static <T> T checkNotNull(@Nullable T object, String message) {
     if (object == null) {
       throw new NullPointerException(message);
     }
@@ -318,9 +319,9 @@ static ResponseBody buffer(final ResponseBody body) throws IOException {
 
   static Type getParameterUpperBound(int index, ParameterizedType type) {
     Type[] types = type.getActualTypeArguments();
-    if (types.length <= index) {
+    if (index < 0 || index >= types.length) {
       throw new IllegalArgumentException(
-          "Expected at least " + index + " type argument(s) but got: " + Arrays.toString(types));
+          "Index " + index + " not in range [0," + types.length + ") for " + type);
     }
     Type paramType = types[index];
     if (paramType instanceof WildcardType) {
@@ -369,21 +370,21 @@ static Type getCallResponseType(Type returnType) {
     private final Type rawType;
     private final Type[] typeArguments;
 
-    public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments) {
+    ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments) {
       // Require an owner type if the raw type needs it.
       if (rawType instanceof Class<?>
           && (ownerType == null) != (((Class<?>) rawType).getEnclosingClass() == null)) {
         throw new IllegalArgumentException();
       }
 
+      for (Type typeArgument : typeArguments) {
+        checkNotNull(typeArgument, "typeArgument == null");
+        checkNotPrimitive(typeArgument);
+      }
+
       this.ownerType = ownerType;
       this.rawType = rawType;
       this.typeArguments = typeArguments.clone();
-
-      for (Type typeArgument : this.typeArguments) {
-        if (typeArgument == null) throw new NullPointerException();
-        checkNotPrimitive(typeArgument);
-      }
     }
 
     @Override public Type[] getActualTypeArguments() {
@@ -407,9 +408,9 @@ public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments
     }
 
     @Override public String toString() {
+      if (typeArguments.length == 0) return typeToString(rawType);
       StringBuilder result = new StringBuilder(30 * (typeArguments.length + 1));
       result.append(typeToString(rawType));
-      if (typeArguments.length == 0) return result.toString();
       result.append("<").append(typeToString(typeArguments[0]));
       for (int i = 1; i < typeArguments.length; i++) {
         result.append(", ").append(typeToString(typeArguments[i]));
@@ -421,7 +422,7 @@ public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments
   private static final class GenericArrayTypeImpl implements GenericArrayType {
     private final Type componentType;
 
-    public GenericArrayTypeImpl(Type componentType) {
+    GenericArrayTypeImpl(Type componentType) {
       this.componentType = componentType;
     }
 
@@ -452,7 +453,7 @@ public GenericArrayTypeImpl(Type componentType) {
     private final Type upperBound;
     private final Type lowerBound;
 
-    public WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {
+    WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {
       if (lowerBounds.length > 1) throw new IllegalArgumentException();
       if (upperBounds.length != 1) throw new IllegalArgumentException();
 
diff --git a/retrofit/src/main/java/retrofit2/http/Body.java b/retrofit/src/main/java/retrofit2/http/Body.java
index 673a0a528..98d1d8684 100644
--- a/retrofit/src/main/java/retrofit2/http/Body.java
+++ b/retrofit/src/main/java/retrofit2/http/Body.java
@@ -32,8 +32,6 @@
  * request body.
  * <p>
  * Body parameters may not be {@code null}.
- *
- * @author Eric Denman (edenman@squareup.com)
  */
 @Documented
 @Target(PARAMETER)
diff --git a/retrofit/src/main/java/retrofit2/http/Field.java b/retrofit/src/main/java/retrofit2/http/Field.java
index 9c6d354c8..06e369bc7 100644
--- a/retrofit/src/main/java/retrofit2/http/Field.java
+++ b/retrofit/src/main/java/retrofit2/http/Field.java
@@ -15,9 +15,12 @@
  */
 package retrofit2.http;
 
+import java.lang.annotation.Annotation;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+import java.lang.reflect.Type;
+import retrofit2.Retrofit;
 
 import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
@@ -25,27 +28,29 @@
 /**
  * Named pair for a form-encoded request.
  * <p>
- * Values are converted to strings using {@link String#valueOf(Object)} and then form URL encoded.
+ * Values are converted to strings using {@link Retrofit#stringConverter(Type, Annotation[])}
+ * (or {@link Object#toString()}, if no matching string converter is installed)
+ * and then form URL encoded.
  * {@code null} values are ignored. Passing a {@link java.util.List List} or array will result in a
  * field pair for each non-{@code null} item.
  * <p>
  * Simple Example:
- * <pre>{@code
+ * <pre><code>
  * &#64;FormUrlEncoded
  * &#64;POST("/")
- * Call&lt;ResponseBody> example(
+ * Call&lt;ResponseBody&gt; example(
  *     &#64;Field("name") String name,
  *     &#64;Field("occupation") String occupation);
- * }</pre>
+ * </code></pre>
  * Calling with {@code foo.example("Bob Smith", "President")} yields a request body of
  * {@code name=Bob+Smith&occupation=President}.
  * <p>
  * Array/Varargs Example:
- * <pre>{@code
+ * <pre><code>
  * &#64;FormUrlEncoded
  * &#64;POST("/list")
- * Call&lt;ResponseBody> example(@Field("name") String... names);
- * }</pre>
+ * Call&lt;ResponseBody&gt; example(@Field("name") String... names);
+ * </code></pre>
  * Calling with {@code foo.example("Bob Smith", "Jane Doe")} yields a request body of
  * {@code name=Bob+Smith&name=Jane+Doe}.
  *
diff --git a/retrofit/src/main/java/retrofit2/http/FieldMap.java b/retrofit/src/main/java/retrofit2/http/FieldMap.java
index ec729d670..a7eb1ee86 100644
--- a/retrofit/src/main/java/retrofit2/http/FieldMap.java
+++ b/retrofit/src/main/java/retrofit2/http/FieldMap.java
@@ -26,11 +26,11 @@
  * Named key/value pairs for a form-encoded request.
  * <p>
  * Simple Example:
- * <pre>{@code
+ * <pre><code>
  * &#64;FormUrlEncoded
  * &#64;POST("/things")
- * Call&lt;ResponseBody> things(@FieldMap Map&lt;String, String&gt; fields);
- * }</pre>
+ * Call&lt;ResponseBody&gt; things(@FieldMap Map&lt;String, String&gt; fields);
+ * </code></pre>
  * Calling with {@code foo.things(ImmutableMap.of("foo", "bar", "kit", "kat")} yields a request
  * body of {@code foo=bar&kit=kat}.
  * <p>
diff --git a/retrofit/src/main/java/retrofit2/http/HTTP.java b/retrofit/src/main/java/retrofit2/http/HTTP.java
index ab474e0ff..101eecf3b 100644
--- a/retrofit/src/main/java/retrofit2/http/HTTP.java
+++ b/retrofit/src/main/java/retrofit2/http/HTTP.java
@@ -25,19 +25,19 @@
 
 /**
  * Use a custom HTTP verb for a request.
- * <pre>{@code
+ * <pre><code>
  * interface Service {
  *   &#064;HTTP(method = "CUSTOM", path = "custom/endpoint/")
- *   Call<ResponseBody> customEndpoint();
+ *   Call&lt;ResponseBody&gt; customEndpoint();
  * }
- * }</pre>
+ * </code></pre>
  * This annotation can also used for sending {@code DELETE} with a request body:
- * <pre>{@code
+ * <pre><code>
  * interface Service {
  *   &#064;HTTP(method = "DELETE", path = "remove/", hasBody = true)
- *   Call<ResponseBody> deleteObject(@Body RequestBody object);
+ *   Call&lt;ResponseBody&gt; deleteObject(@Body RequestBody object);
  * }
- * }</pre>
+ * </code></pre>
  */
 @Documented
 @Target(METHOD)
diff --git a/retrofit/src/main/java/retrofit2/http/Header.java b/retrofit/src/main/java/retrofit2/http/Header.java
index b51aaf5a2..b8f7a70ea 100644
--- a/retrofit/src/main/java/retrofit2/http/Header.java
+++ b/retrofit/src/main/java/retrofit2/http/Header.java
@@ -24,19 +24,18 @@
 
 /**
  * Replaces the header with the value of its target.
- * <p>
- * <pre>{@code
+ * <pre><code>
  * &#64;GET("/")
- * Call&lt;ResponseBody> foo(@Header("Accept-Language") String lang);
- * }</pre>
- * <p>
+ * Call&lt;ResponseBody&gt; foo(@Header("Accept-Language") String lang);
+ * </code></pre>
  * Header parameters may be {@code null} which will omit them from the request. Passing a
  * {@link java.util.List List} or array will result in a header for each non-{@code null} item.
  * <p>
  * <strong>Note:</strong> Headers do not overwrite each other. All headers with the same name will
  * be included in the request.
  *
- * @author Adrian Cole (adrianc@netflix.com)
+ * @see Headers
+ * @see HeaderMap
  */
 @Documented
 @Retention(RUNTIME)
diff --git a/retrofit/src/main/java/retrofit2/http/HeaderMap.java b/retrofit/src/main/java/retrofit2/http/HeaderMap.java
new file mode 100644
index 000000000..248abc15e
--- /dev/null
+++ b/retrofit/src/main/java/retrofit2/http/HeaderMap.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.http;
+
+import static java.lang.annotation.ElementType.PARAMETER;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import java.lang.annotation.Annotation;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+import java.lang.reflect.Type;
+import java.util.Map;
+import retrofit2.Retrofit;
+
+/**
+ * Adds headers specified in the {@link Map}.
+ * <p>
+ * Values are converted to strings using {@link Retrofit#stringConverter(Type, Annotation[])}
+ * (or {@link Object#toString()}, if no matching string converter is installed).
+ * <p>
+ * Simple Example:
+ * <pre>
+ * &#64;GET("/search")
+ * void list(@HeaderMap Map&lt;String, String&gt; headers);
+ *
+ * ...
+ *
+ * // The following call yields /search with headers
+ * // Accept: text/plain and Accept-Charset: utf-8
+ * foo.list(ImmutableMap.of("Accept", "text/plain", "Accept-Charset", "utf-8"));
+ * </pre>
+ *
+ * @see Header
+ * @see Headers
+ */
+@Documented
+@Target(PARAMETER)
+@Retention(RUNTIME)
+public @interface HeaderMap {
+
+}
diff --git a/retrofit/src/main/java/retrofit2/http/Headers.java b/retrofit/src/main/java/retrofit2/http/Headers.java
index abc16409f..b360f3ec3 100644
--- a/retrofit/src/main/java/retrofit2/http/Headers.java
+++ b/retrofit/src/main/java/retrofit2/http/Headers.java
@@ -24,8 +24,7 @@
 
 /**
  * Adds headers literally supplied in the {@code value}.
- * <p>
- * <pre>{@code
+ * <pre><code>
  * &#64;Headers("Cache-Control: max-age=640000")
  * &#64;GET("/")
  * ...
@@ -36,12 +35,12 @@
  * })
  * &#64;GET("/")
  * ...
- * }</pre>
- * <p>
+ * </code></pre>
  * <strong>Note:</strong> Headers do not overwrite each other. All headers with the same name will
  * be included in the request.
  *
- * @author Adrian Cole (adrianc@netflix.com)
+ * @see Header
+ * @see HeaderMap
  */
 @Documented
 @Target(METHOD)
diff --git a/retrofit/src/main/java/retrofit2/http/Part.java b/retrofit/src/main/java/retrofit2/http/Part.java
index 726db52f9..f320c088f 100644
--- a/retrofit/src/main/java/retrofit2/http/Part.java
+++ b/retrofit/src/main/java/retrofit2/http/Part.java
@@ -40,13 +40,13 @@
  * <p>
  * Values may be {@code null} which will omit them from the request body.
  * <p>
- * <pre>{@code
+ * <pre><code>
  * &#64;Multipart
  * &#64;POST("/")
- * Call&lt;ResponseBody> example(
+ * Call&lt;ResponseBody&gt; example(
  *     &#64;Part("description") String description,
  *     &#64;Part(value = "image", encoding = "8-bit") RequestBody image);
- * }</pre>
+ * </code></pre>
  * <p>
  * Part parameters may not be {@code null}.
  */
diff --git a/retrofit/src/main/java/retrofit2/http/PartMap.java b/retrofit/src/main/java/retrofit2/http/PartMap.java
index 5c2f593ea..79eae2147 100644
--- a/retrofit/src/main/java/retrofit2/http/PartMap.java
+++ b/retrofit/src/main/java/retrofit2/http/PartMap.java
@@ -34,13 +34,13 @@
  * {@linkplain Converter a converter}.</li>
  * </ul>
  * <p>
- * <pre>{@code
+ * <pre><code>
  * &#64;Multipart
  * &#64;POST("/upload")
- * Call&lt;ResponseBody> upload(
+ * Call&lt;ResponseBody&gt; upload(
  *     &#64;Part("file") RequestBody file,
  *     &#64;PartMap Map&lt;String, RequestBody&gt; params);
- * }</pre>
+ * </code></pre>
  * <p>
  * A {@code null} value for the map, as a key, or as a value is not allowed.
  *
diff --git a/retrofit/src/main/java/retrofit2/http/Path.java b/retrofit/src/main/java/retrofit2/http/Path.java
index feaf34b27..52af62511 100644
--- a/retrofit/src/main/java/retrofit2/http/Path.java
+++ b/retrofit/src/main/java/retrofit2/http/Path.java
@@ -15,32 +15,36 @@
  */
 package retrofit2.http;
 
+import java.lang.annotation.Annotation;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+import java.lang.reflect.Type;
+import retrofit2.Retrofit;
 
 import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 /**
- * Named replacement in a URL path segment. Values are converted to string using
- * {@link String#valueOf(Object)} and URL encoded.
+ * Named replacement in a URL path segment. Values are converted to strings using
+ * {@link Retrofit#stringConverter(Type, Annotation[])} (or {@link Object#toString()},
+ * if no matching string converter is installed) and then URL encoded.
  * <p>
  * Simple example:
- * <pre>{@code
+ * <pre><code>
  * &#64;GET("/image/{id}")
- * Call&lt;ResponseBody> example(@Path("id") int id);
- * }</pre>
+ * Call&lt;ResponseBody&gt; example(@Path("id") int id);
+ * </code></pre>
  * Calling with {@code foo.example(1)} yields {@code /image/1}.
  * <p>
  * Values are URL encoded by default. Disable with {@code encoded=true}.
- * <pre>{@code
+ * <pre><code>
  * &#64;GET("/user/{name}")
- * Call&lt;ResponseBody> encoded(@Path("name") String name);
+ * Call&lt;ResponseBody&gt; encoded(@Path("name") String name);
  *
  * &#64;GET("/user/{name}")
- * Call&lt;ResponseBody> notEncoded(@Path(value="name", encoded=true) String name);
- * }</pre>
+ * Call&lt;ResponseBody&gt; notEncoded(@Path(value="name", encoded=true) String name);
+ * </code></pre>
  * Calling {@code foo.encoded("John+Doe")} yields {@code /user/John%2BDoe} whereas
  * {@code foo.notEncoded("John+Doe")} yields {@code /user/John+Doe}.
  * <p>
diff --git a/retrofit/src/main/java/retrofit2/http/Query.java b/retrofit/src/main/java/retrofit2/http/Query.java
index 29205bebc..17c36c154 100644
--- a/retrofit/src/main/java/retrofit2/http/Query.java
+++ b/retrofit/src/main/java/retrofit2/http/Query.java
@@ -15,9 +15,12 @@
  */
 package retrofit2.http;
 
+import java.lang.annotation.Annotation;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+import java.lang.reflect.Type;
+import retrofit2.Retrofit;
 
 import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
@@ -25,41 +28,44 @@
 /**
  * Query parameter appended to the URL.
  * <p>
- * Values are converted to strings using {@link String#valueOf(Object)} and then URL encoded.
+ * Values are converted to strings using {@link Retrofit#stringConverter(Type, Annotation[])}
+ * (or {@link Object#toString()}, if no matching string converter is installed)
+ * and then URL encoded.
  * {@code null} values are ignored. Passing a {@link java.util.List List} or array will result in a
  * query parameter for each non-{@code null} item.
  * <p>
  * Simple Example:
- * <pre>{@code
- * &#64;GET("/list")
- * Call&lt;ResponseBody> list(@Query("page") int page);
- * }</pre>
- * Calling with {@code foo.list(1)} yields {@code /list?page=1}.
+ * <pre><code>
+ * &#64;GET("/friends")
+ * Call&lt;ResponseBody&gt; friends(@Query("page") int page);
+ * </code></pre>
+ * Calling with {@code foo.friends(1)} yields {@code /friends?page=1}.
  * <p>
  * Example with {@code null}:
- * <pre>{@code
- * &#64;GET("/list")
- * Call&lt;ResponseBody> list(@Query("category") String category);
- * }</pre>
- * Calling with {@code foo.list(null)} yields {@code /list}.
+ * <pre><code>
+ * &#64;GET("/friends")
+ * Call&lt;ResponseBody&gt; friends(@Query("group") String group);
+ * </code></pre>
+ * Calling with {@code foo.friends(null)} yields {@code /friends}.
  * <p>
  * Array/Varargs Example:
- * <pre>{@code
- * &#64;GET("/list")
- * Call&lt;ResponseBody> list(@Query("category") String... categories);
- * }</pre>
- * Calling with {@code foo.list("bar", "baz")} yields
- * {@code /list?category=bar&category=baz}.
+ * <pre><code>
+ * &#64;GET("/friends")
+ * Call&lt;ResponseBody&gt; friends(@Query("group") String... groups);
+ * </code></pre>
+ * Calling with {@code foo.friends("coworker", "bowling")} yields
+ * {@code /friends?group=coworker&group=bowling}.
  * <p>
  * Parameter names and values are URL encoded by default. Specify {@link #encoded() encoded=true}
  * to change this behavior.
- * <pre>{@code
- * &#64;GET("/search")
- * Call&lt;ResponseBody> list(@Query(value="foo", encoded=true) String foo);
- * }</pre>
- * Calling with {@code foo.list("foo+bar"))} yields {@code /search?foo=foo+bar}.
+ * <pre><code>
+ * &#64;GET("/friends")
+ * Call&lt;ResponseBody&gt; friends(@Query(value="group", encoded=true) String group);
+ * </code></pre>
+ * Calling with {@code foo.friends("foo+bar"))} yields {@code /friends?group=foo+bar}.
  *
  * @see QueryMap
+ * @see QueryName
  */
 @Documented
 @Target(PARAMETER)
diff --git a/retrofit/src/main/java/retrofit2/http/QueryMap.java b/retrofit/src/main/java/retrofit2/http/QueryMap.java
index 50737668c..fcf01652f 100644
--- a/retrofit/src/main/java/retrofit2/http/QueryMap.java
+++ b/retrofit/src/main/java/retrofit2/http/QueryMap.java
@@ -15,9 +15,12 @@
  */
 package retrofit2.http;
 
+import java.lang.annotation.Annotation;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+import java.lang.reflect.Type;
+import retrofit2.Retrofit;
 
 import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
@@ -25,28 +28,30 @@
 /**
  * Query parameter keys and values appended to the URL.
  * <p>
- * Both keys and values are converted to strings using {@link String#valueOf(Object)}.
+ * Values are converted to strings using {@link Retrofit#stringConverter(Type, Annotation[])}
+ * (or {@link Object#toString()}, if no matching string converter is installed).
  * <p>
  * Simple Example:
- * <pre>{@code
- * &#64;GET("/search")
- * Call&lt;ResponseBody> list(@QueryMap Map&lt;String, String&gt; filters);
- * }</pre>
- * Calling with {@code foo.list(ImmutableMap.of("foo", "bar", "kit", "kat"))} yields
- * {@code /search?foo=bar&kit=kat}.
+ * <pre><code>
+ * &#64;GET("/friends")
+ * Call&lt;ResponseBody&gt; friends(@QueryMap Map&lt;String, String&gt; filters);
+ * </code></pre>
+ * Calling with {@code foo.friends(ImmutableMap.of("group", "coworker", "age", "42"))} yields
+ * {@code /friends?group=coworker&age=42}.
  * <p>
  * Map keys and values representing parameter values are URL encoded by default. Specify
  * {@link #encoded() encoded=true} to change this behavior.
- * <pre>{@code
- * &#64;GET("/search")
- * Call&lt;ResponseBody> list(@QueryMap(encoded=true) Map&lt;String, String&gt; filters);
- * }</pre>
- * Calling with {@code foo.list(ImmutableMap.of("foo", "foo+bar"))} yields
- * {@code /search?foo=foo+bar}.
+ * <pre><code>
+ * &#64;GET("/friends")
+ * Call&lt;ResponseBody&gt; friends(@QueryMap(encoded=true) Map&lt;String, String&gt; filters);
+ * </code></pre>
+ * Calling with {@code foo.list(ImmutableMap.of("group", "coworker+bowling"))} yields
+ * {@code /search?group=coworker+bowling}.
  * <p>
  * A {@code null} value for the map, as a key, or as a value is not allowed.
  *
  * @see Query
+ * @see QueryName
  */
 @Documented
 @Target(PARAMETER)
diff --git a/retrofit/src/main/java/retrofit2/http/QueryName.java b/retrofit/src/main/java/retrofit2/http/QueryName.java
new file mode 100644
index 000000000..5d6f0e948
--- /dev/null
+++ b/retrofit/src/main/java/retrofit2/http/QueryName.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.http;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.PARAMETER;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Query parameter appended to the URL that has no value.
+ * <p>
+ * Passing a {@link java.util.List List} or array will result in a query parameter for each
+ * non-{@code null} item.
+ * <p>
+ * Simple Example:
+ * <pre><code>
+ * &#64;GET("/friends")
+ * Call&lt;ResponseBody&gt; friends(@QueryName String filter);
+ * </code></pre>
+ * Calling with {@code foo.friends("contains(Bob)")} yields {@code /friends?contains(Bob)}.
+ * <p>
+ * Array/Varargs Example:
+ * <pre><code>
+ * &#64;GET("/friends")
+ * Call&lt;ResponseBody&gt; friends(@QueryName String... filters);
+ * </code></pre>
+ * Calling with {@code foo.friends("contains(Bob)", "age(42)")} yields
+ * {@code /friends?contains(Bob)&age(42)}.
+ * <p>
+ * Parameter names are URL encoded by default. Specify {@link #encoded() encoded=true} to change
+ * this behavior.
+ * <pre><code>
+ * &#64;GET("/friends")
+ * Call&lt;ResponseBody&gt; friends(@QueryName(encoded=true) String filter);
+ * </code></pre>
+ * Calling with {@code foo.friends("name+age"))} yields {@code /friends?name+age}.
+ *
+ * @see Query
+ * @see QueryMap
+ */
+@Documented
+@Target(PARAMETER)
+@Retention(RUNTIME)
+public @interface QueryName {
+  /**
+   * Specifies whether the parameter is already URL encoded.
+   */
+  boolean encoded() default false;
+}
diff --git a/retrofit/src/main/java/retrofit2/http/Url.java b/retrofit/src/main/java/retrofit2/http/Url.java
index 956a9a088..31187ca3d 100644
--- a/retrofit/src/main/java/retrofit2/http/Url.java
+++ b/retrofit/src/main/java/retrofit2/http/Url.java
@@ -26,10 +26,10 @@
 
 /**
  * URL resolved against the {@linkplain Retrofit#baseUrl() base URL}.
- * <pre>{@code
+ * <pre><code>
  * &#64;GET
- * Call&lt;ResponseBody> list(@Url String url);
- * }</pre>
+ * Call&lt;ResponseBody&gt; list(@Url String url);
+ * </code></pre>
  * <p>
  * See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
  * the value will be resolved against a base URL to create the full endpoint URL.
diff --git a/retrofit/src/main/java/retrofit2/package-info.java b/retrofit/src/main/java/retrofit2/package-info.java
index 44f5b357a..135079424 100644
--- a/retrofit/src/main/java/retrofit2/package-info.java
+++ b/retrofit/src/main/java/retrofit2/package-info.java
@@ -9,4 +9,7 @@
  * }
  * </pre>
  */
+@ParametersAreNonnullByDefault
 package retrofit2;
+
+import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit/src/test/java/retrofit2/RequestBuilderTest.java b/retrofit/src/test/java/retrofit2/RequestBuilderTest.java
deleted file mode 100644
index 65595b918..000000000
--- a/retrofit/src/test/java/retrofit2/RequestBuilderTest.java
+++ /dev/null
@@ -1,2381 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2;
-
-import java.io.IOException;
-import java.lang.reflect.Method;
-import java.math.BigInteger;
-import java.net.URI;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.atomic.AtomicReference;
-import okhttp3.HttpUrl;
-import okhttp3.MediaType;
-import okhttp3.MultipartBody;
-import okhttp3.Request;
-import okhttp3.RequestBody;
-import okhttp3.ResponseBody;
-import okio.Buffer;
-import org.junit.Ignore;
-import org.junit.Test;
-import retrofit2.helpers.ToStringConverterFactory;
-import retrofit2.http.Body;
-import retrofit2.http.DELETE;
-import retrofit2.http.Field;
-import retrofit2.http.FieldMap;
-import retrofit2.http.FormUrlEncoded;
-import retrofit2.http.GET;
-import retrofit2.http.HEAD;
-import retrofit2.http.HTTP;
-import retrofit2.http.Header;
-import retrofit2.http.Headers;
-import retrofit2.http.Multipart;
-import retrofit2.http.OPTIONS;
-import retrofit2.http.PATCH;
-import retrofit2.http.POST;
-import retrofit2.http.PUT;
-import retrofit2.http.Part;
-import retrofit2.http.PartMap;
-import retrofit2.http.Path;
-import retrofit2.http.Query;
-import retrofit2.http.QueryMap;
-import retrofit2.http.Url;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.fail;
-
-@SuppressWarnings({"UnusedParameters", "unused"}) // Parameters inspected reflectively.
-public final class RequestBuilderTest {
-  private static final MediaType TEXT_PLAIN = MediaType.parse("text/plain");
-
-  @Test public void customMethodNoBody() {
-    class Example {
-      @HTTP(method = "CUSTOM1", path = "/foo")
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class);
-    assertThat(request.method()).isEqualTo("CUSTOM1");
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo");
-    assertThat(request.body()).isNull();
-  }
-
-  @Ignore("https://github.com/square/okhttp/issues/229")
-  @Test public void customMethodWithBody() {
-    class Example {
-      @HTTP(method = "CUSTOM2", path = "/foo", hasBody = true)
-      Call<ResponseBody> method(@Body RequestBody body) {
-        return null;
-      }
-    }
-
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
-    Request request = buildRequest(Example.class, body);
-    assertThat(request.method()).isEqualTo("CUSTOM2");
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo");
-    assertBody(request.body(), "hi");
-  }
-
-  @Test public void onlyOneEncodingIsAllowedMultipartFirst() {
-    class Example {
-      @Multipart //
-      @FormUrlEncoded //
-      @POST("/") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Only one encoding annotation is allowed.\n    for method Example.method");
-    }
-  }
-
-  @Test public void onlyOneEncodingIsAllowedFormEncodingFirst() {
-    class Example {
-      @FormUrlEncoded //
-      @Multipart //
-      @POST("/") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Only one encoding annotation is allowed.\n    for method Example.method");
-    }
-  }
-
-  @Test public void invalidPathParam() throws Exception {
-    class Example {
-      @GET("/") //
-      Call<ResponseBody> method(@Path("hey!") String thing) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@Path parameter name must match \\{([a-zA-Z][a-zA-Z0-9_-]*)\\}."
-              + " Found: hey! (parameter #1)\n    for method Example.method");
-    }
-  }
-
-  @Test public void pathParamNotAllowedInQuery() throws Exception {
-    class Example {
-      @GET("/foo?bar={bar}") //
-      Call<ResponseBody> method(@Path("bar") String thing) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "URL query string \"bar={bar}\" must not have replace block."
-              + " For dynamic query parameters use @Query.\n    for method Example.method");
-    }
-  }
-
-  @Test public void multipleParameterAnnotationsNotAllowed() throws Exception {
-    class Example {
-      @GET("/") //
-      Call<ResponseBody> method(@Body @Query("nope") String o) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Multiple Retrofit annotations found, only one allowed. (parameter #1)\n    for method Example.method");
-    }
-  }
-
-  @interface NonNull {}
-
-  @Test public void multipleParameterAnnotationsOnlyOneRetrofitAllowed() throws Exception {
-    class Example {
-      @GET("/") //
-      Call<ResponseBody> method(@Query("maybe") @NonNull Object o) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "yep");
-    assertThat(request.url().toString()).isEqualTo("http://example.com/?maybe=yep");
-  }
-
-  @Test public void twoMethodsFail() {
-    class Example {
-      @PATCH("/foo") //
-      @POST("/foo") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Only one HTTP method is allowed. Found: PATCH and POST.\n    for method Example.method");
-    }
-  }
-
-  @Test public void lackingMethod() {
-    class Example {
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "HTTP method annotation is required (e.g., @GET, @POST, etc.).\n    for method Example.method");
-    }
-  }
-
-  @Test public void implicitMultipartForbidden() {
-    class Example {
-      @POST("/") //
-      Call<ResponseBody> method(@Part("a") int a) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@Part parameters can only be used with multipart encoding. (parameter #1)\n    for method Example.method");
-    }
-  }
-
-  @Test public void implicitMultipartWithPartMapForbidden() {
-    class Example {
-      @POST("/") //
-      Call<ResponseBody> method(@PartMap Map<String, String> params) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@PartMap parameters can only be used with multipart encoding. (parameter #1)\n    for method Example.method");
-    }
-  }
-
-  @Test public void multipartFailsOnNonBodyMethod() {
-    class Example {
-      @Multipart //
-      @GET("/") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Multipart can only be specified on HTTP methods with request body (e.g., @POST).\n    for method Example.method");
-    }
-  }
-
-  @Test public void multipartFailsWithNoParts() {
-    class Example {
-      @Multipart //
-      @POST("/") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Multipart method must contain at least one @Part.\n    for method Example.method");
-    }
-  }
-
-  @Test public void implicitFormEncodingByFieldForbidden() {
-    class Example {
-      @POST("/") //
-      Call<ResponseBody> method(@Field("a") int a) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@Field parameters can only be used with form encoding. (parameter #1)\n    for method Example.method");
-    }
-  }
-
-  @Test public void implicitFormEncodingByFieldMapForbidden() {
-    class Example {
-      @POST("/") //
-      Call<ResponseBody> method(@FieldMap Map<String, String> a) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@FieldMap parameters can only be used with form encoding. (parameter #1)\n    for method Example.method");
-    }
-  }
-
-  @Test public void formEncodingFailsOnNonBodyMethod() {
-    class Example {
-      @FormUrlEncoded //
-      @GET("/") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "FormUrlEncoded can only be specified on HTTP methods with request body (e.g., @POST).\n    for method Example.method");
-    }
-  }
-
-  @Test public void formEncodingFailsWithNoParts() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Form-encoded method must contain at least one @Field.\n    for method Example.method");
-    }
-  }
-
-  @Test public void headersFailWhenEmptyOnMethod() {
-    class Example {
-      @GET("/") //
-      @Headers({}) //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("@Headers annotation is empty.\n    for method Example.method");
-    }
-  }
-
-  @Test public void headersFailWhenMalformed() {
-    class Example {
-      @GET("/") //
-      @Headers("Malformed") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@Headers value must be in the form \"Name: Value\". Found: \"Malformed\"\n    for method Example.method");
-    }
-  }
-
-  @Test public void pathParamNonPathParamAndTypedBytes() {
-    class Example {
-      @PUT("/{a}") //
-      Call<ResponseBody> method(@Path("a") int a, @Path("b") int b, @Body int c) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "URL \"/{a}\" does not contain \"{b}\". (parameter #2)\n    for method Example.method");
-    }
-  }
-
-  @Test public void parameterWithoutAnnotation() {
-    class Example {
-      @GET("/") //
-      Call<ResponseBody> method(String a) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "No Retrofit annotation found. (parameter #1)\n    for method Example.method");
-    }
-  }
-
-  @Test public void nonBodyHttpMethodWithSingleEntity() {
-    class Example {
-      @GET("/") //
-      Call<ResponseBody> method(@Body String o) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Non-body HTTP method cannot contain @Body.\n    for method Example.method");
-    }
-  }
-
-  @Test public void queryMapMustBeAMap() {
-    class Example {
-      @GET("/") //
-      Call<ResponseBody> method(@QueryMap List<String> a) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@QueryMap parameter type must be Map. (parameter #1)\n    for method Example.method");
-    }
-  }
-
-  @Test public void queryMapSupportsSubclasses() {
-    class Foo extends HashMap<String, String> {
-    }
-
-    class Example {
-      @GET("/") //
-      Call<ResponseBody> method(@QueryMap Foo a) {
-        return null;
-      }
-    }
-
-    Foo foo = new Foo();
-    foo.put("hello", "world");
-
-    Request request = buildRequest(Example.class, foo);
-    assertThat(request.url().toString()).isEqualTo("http://example.com/?hello=world");
-  }
-
-  @Test public void queryMapRejectsNull() {
-    class Example {
-      @GET("/") //
-      Call<ResponseBody> method(@QueryMap Map<String, String> a) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Query map was null.");
-    }
-  }
-
-  @Test public void queryMapRejectsNullKeys() {
-    class Example {
-      @GET("/") //
-      Call<ResponseBody> method(@QueryMap Map<String, String> a) {
-        return null;
-      }
-    }
-
-    Map<String, String> queryParams = new LinkedHashMap<>();
-    queryParams.put("ping", "pong");
-    queryParams.put(null, "kat");
-
-    try {
-      buildRequest(Example.class, queryParams);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Query map contained null key.");
-    }
-  }
-
-  @Test public void queryMapRejectsNullValues() {
-    class Example {
-      @GET("/") //
-      Call<ResponseBody> method(@QueryMap Map<String, String> a) {
-        return null;
-      }
-    }
-
-    Map<String, String> queryParams = new LinkedHashMap<>();
-    queryParams.put("ping", "pong");
-    queryParams.put("kit", null);
-
-    try {
-      buildRequest(Example.class, queryParams);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Query map contained null value for key 'kit'.");
-    }
-  }
-
-  @Test public void twoBodies() {
-    class Example {
-      @PUT("/") //
-      Call<ResponseBody> method(@Body String o1, @Body String o2) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Multiple @Body method annotations found. (parameter #2)\n    for method Example.method");
-    }
-  }
-
-  @Test public void bodyInNonBodyRequest() {
-    class Example {
-      @Multipart //
-      @PUT("/") //
-      Call<ResponseBody> method(@Part("one") String o1, @Body String o2) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@Body parameters cannot be used with form or multi-part encoding. (parameter #2)\n    for method Example.method");
-    }
-  }
-
-  @Test public void get() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class);
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void delete() {
-    class Example {
-      @DELETE("/foo/bar/") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class);
-    assertThat(request.method()).isEqualTo("DELETE");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertNull(request.body());
-  }
-
-  @Test public void head() {
-    class Example {
-      @HEAD("/foo/bar/") //
-      Call<Void> method() {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class);
-    assertThat(request.method()).isEqualTo("HEAD");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void headWithoutVoidThrows() {
-    class Example {
-      @HEAD("/foo/bar/") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "HEAD method must use Void as response type.\n    for method Example.method");
-    }
-  }
-
-  @Test public void post() {
-    class Example {
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Body RequestBody body) {
-        return null;
-      }
-    }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
-    Request request = buildRequest(Example.class, body);
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertBody(request.body(), "hi");
-  }
-
-  @Test public void put() {
-    class Example {
-      @PUT("/foo/bar/") //
-      Call<ResponseBody> method(@Body RequestBody body) {
-        return null;
-      }
-    }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
-    Request request = buildRequest(Example.class, body);
-    assertThat(request.method()).isEqualTo("PUT");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertBody(request.body(), "hi");
-  }
-
-  @Test public void patch() {
-    class Example {
-      @PATCH("/foo/bar/") //
-      Call<ResponseBody> method(@Body RequestBody body) {
-        return null;
-      }
-    }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
-    Request request = buildRequest(Example.class, body);
-    assertThat(request.method()).isEqualTo("PATCH");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertBody(request.body(), "hi");
-  }
-
-  @Test public void options() {
-    class Example {
-      @OPTIONS("/foo/bar/") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class);
-    assertThat(request.method()).isEqualTo("OPTIONS");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithPathParam() {
-    class Example {
-      @GET("/foo/bar/{ping}/") //
-      Call<ResponseBody> method(@Path("ping") String ping) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "po ng");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/po%20ng/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithUnusedAndInvalidNamedPathParam() {
-    class Example {
-      @GET("/foo/bar/{ping}/{kit,kat}/") //
-      Call<ResponseBody> method(@Path("ping") String ping) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "pong");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong/%7Bkit,kat%7D/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithEncodedPathParam() {
-    class Example {
-      @GET("/foo/bar/{ping}/") //
-      Call<ResponseBody> method(@Path(value = "ping", encoded = true) String ping) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "po%20ng");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/po%20ng/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithEncodedPathSegments() {
-    class Example {
-      @GET("/foo/bar/{ping}/") //
-      Call<ResponseBody> method(@Path(value = "ping", encoded = true) String ping) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "baz/pong/more");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/baz/pong/more/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithUnencodedPathSegmentsPreventsRequestSplitting() {
-    class Example {
-      @GET("/foo/bar/{ping}/") //
-      Call<ResponseBody> method(@Path(value = "ping", encoded = false) String ping) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "baz/\r\nheader: blue");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/baz%2F%0D%0Aheader:%20blue/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithEncodedPathStillPreventsRequestSplitting() {
-    class Example {
-      @GET("/foo/bar/{ping}/") //
-      Call<ResponseBody> method(@Path(value = "ping", encoded = true) String ping) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "baz/\r\npong");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/baz/pong/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void pathParamRequired() {
-    class Example {
-      @GET("/foo/bar/{ping}/") //
-      Call<ResponseBody> method(@Path("ping") String ping) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e.getMessage()).isEqualTo("Path parameter \"ping\" value must not be null.");
-    }
-  }
-
-  @Test public void getWithQueryParam() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method(@Query("ping") String ping) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "pong");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?ping=pong");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithEncodedQueryParam() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method(@Query(value = "pi%20ng", encoded = true) String ping) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "p%20o%20n%20g");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?pi%20ng=p%20o%20n%20g");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void queryParamOptionalOmitsQuery() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method(@Query("ping") String ping) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, new Object[] { null });
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-  }
-
-  @Test public void queryParamOptional() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method(@Query("foo") String foo, @Query("ping") String ping,
-          @Query("kit") String kit) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "bar", null, "kat");
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?foo=bar&kit=kat");
-  }
-
-  @Test public void getWithQueryUrlAndParam() {
-    class Example {
-      @GET("/foo/bar/?hi=mom") //
-      Call<ResponseBody> method(@Query("ping") String ping) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "pong");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?hi=mom&ping=pong");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithQuery() {
-    class Example {
-      @GET("/foo/bar/?hi=mom") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class);
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?hi=mom");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithPathAndQueryParam() {
-    class Example {
-      @GET("/foo/bar/{ping}/") //
-      Call<ResponseBody> method(@Path("ping") String ping, @Query("kit") String kit,
-          @Query("riff") String riff) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, "pong", "kat", "raff");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong/?kit=kat&riff=raff");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithQueryThenPathThrows() {
-    class Example {
-      @GET("/foo/bar/{ping}/") //
-      Call<ResponseBody> method(@Query("kit") String kit, @Path("ping") String ping) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, "kat", "pong");
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("A @Path parameter must not come after a @Query. (parameter #2)\n"
-          + "    for method Example.method");
-    }
-  }
-
-  @Test public void getWithPathAndQueryQuestionMarkParam() {
-    class Example {
-      @GET("/foo/bar/{ping}/") //
-      Call<ResponseBody> method(@Path("ping") String ping, @Query("kit") String kit) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, "pong?", "kat?");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong%3F/?kit=kat?");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithPathAndQueryAmpersandParam() {
-    class Example {
-      @GET("/foo/bar/{ping}/") //
-      Call<ResponseBody> method(@Path("ping") String ping, @Query("kit") String kit) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, "pong&", "kat&");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong&/?kit=kat%26");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithPathAndQueryHashParam() {
-    class Example {
-      @GET("/foo/bar/{ping}/") //
-      Call<ResponseBody> method(@Path("ping") String ping, @Query("kit") String kit) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, "pong#", "kat#");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong%23/?kit=kat%23");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithQueryParamList() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method(@Query("key") List<Object> keys) {
-        return null;
-      }
-    }
-
-    List<Object> values = Arrays.<Object>asList(1, 2, null, "three");
-    Request request = buildRequest(Example.class, values);
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?key=1&key=2&key=three");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithQueryParamArray() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method(@Query("key") Object[] keys) {
-        return null;
-      }
-    }
-
-    Object[] values = { 1, 2, null, "three" };
-    Request request = buildRequest(Example.class, new Object[] { values });
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?key=1&key=2&key=three");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithQueryParamPrimitiveArray() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method(@Query("key") int[] keys) {
-        return null;
-      }
-    }
-
-    int[] values = { 1, 2, 3 };
-    Request request = buildRequest(Example.class, new Object[] { values });
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?key=1&key=2&key=3");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithQueryParamMap() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method(@QueryMap Map<String, Object> query) {
-        return null;
-      }
-    }
-
-    Map<String, Object> params = new LinkedHashMap<>();
-    params.put("kit", "kat");
-    params.put("ping", "pong");
-
-    Request request = buildRequest(Example.class, params);
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?kit=kat&ping=pong");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithEncodedQueryParamMap() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method(@QueryMap(encoded = true) Map<String, Object> query) {
-        return null;
-      }
-    }
-
-    Map<String, Object> params = new LinkedHashMap<>();
-    params.put("kit", "k%20t");
-    params.put("pi%20ng", "p%20g");
-
-    Request request = buildRequest(Example.class, params);
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?kit=k%20t&pi%20ng=p%20g");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getAbsoluteUrl() {
-    class Example {
-      @GET("http://example2.com/foo/bar/")
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class);
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example2.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithStringUrl() {
-    class Example {
-      @GET
-      Call<ResponseBody> method(@Url String url) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, "foo/bar/");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithJavaUriUrl() {
-    class Example {
-      @GET
-      Call<ResponseBody> method(@Url URI url) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, URI.create("foo/bar/"));
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithStringUrlAbsolute() {
-    class Example {
-      @GET
-      Call<ResponseBody> method(@Url String url) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, "https://example2.com/foo/bar/");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("https://example2.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithJavaUriUrlAbsolute() {
-    class Example {
-      @GET
-      Call<ResponseBody> method(@Url URI url) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, URI.create("https://example2.com/foo/bar/"));
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("https://example2.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithUrlAbsoluteSameHost() {
-    class Example {
-      @GET
-      Call<ResponseBody> method(@Url String url) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, "http://example.com/foo/bar/");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithHttpUrl() {
-    class Example {
-      @GET
-      Call<ResponseBody> method(@Url HttpUrl url) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, HttpUrl.parse("http://example.com/foo/bar/"));
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url()).isEqualTo(HttpUrl.parse("http://example.com/foo/bar/"));
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithNullUrl() {
-    class Example {
-      @GET
-      Call<ResponseBody> method(@Url HttpUrl url) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, (HttpUrl) null);
-      fail();
-    } catch (NullPointerException expected) {
-      assertThat(expected).hasMessage("@Url parameter is null.");
-    }
-  }
-
-  @Test public void getWithNonStringUrlThrows() {
-    class Example {
-      @GET
-      Call<ResponseBody> method(@Url Object url) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, "foo/bar");
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@Url must be okhttp3.HttpUrl, String, java.net.URI, or android.net.Uri type."
-              + " (parameter #1)\n"
-              + "    for method Example.method");
-    }
-  }
-
-  @Test public void getUrlAndUrlParamThrows() {
-    class Example {
-      @GET("foo/bar")
-      Call<ResponseBody> method(@Url Object url) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, "foo/bar");
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("@Url cannot be used with @GET URL (parameter #1)\n"
-          + "    for method Example.method");
-    }
-  }
-
-  @Test public void getWithoutUrlThrows() {
-    class Example {
-      @GET
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Missing either @GET URL or @Url parameter.\n"
-          + "    for method Example.method");
-    }
-  }
-
-  @Test public void getWithUrlThenPathThrows() {
-    class Example {
-      @GET
-      Call<ResponseBody> method(@Url String url, @Path("hey") String hey) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, "foo/bar");
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("@Path parameters may not be used with @Url. (parameter #2)\n"
-          + "    for method Example.method");
-    }
-  }
-
-  @Test public void getWithPathThenUrlThrows() {
-    class Example {
-      @GET
-      Call<ResponseBody> method(@Path("hey") String hey, @Url Object url) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, "foo/bar");
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("@Path can only be used with relative url on @GET (parameter #1)\n"
-          + "    for method Example.method");
-    }
-  }
-
-  @Test public void getWithQueryThenUrlThrows() {
-    class Example {
-      @GET("foo/bar")
-      Call<ResponseBody> method(@Query("hey") String hey, @Url Object url) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, "hey", "foo/bar/");
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("A @Url parameter must not come after a @Query (parameter #2)\n"
-          + "    for method Example.method");
-    }
-  }
-
-  @Test public void getWithUrlThenQuery() {
-    class Example {
-      @GET
-      Call<ResponseBody> method(@Url String url, @Query("hey") String hey) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, "foo/bar/", "hey!");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?hey=hey!");
-  }
-
-  @Test public void postWithUrl() {
-    class Example {
-      @POST
-      Call<ResponseBody> method(@Url String url, @Body RequestBody body) {
-        return null;
-      }
-    }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
-    Request request = buildRequest(Example.class, "http://example.com/foo/bar", body);
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar");
-    assertBody(request.body(), "hi");
-  }
-
-  @Test public void normalPostWithPathParam() {
-    class Example {
-      @POST("/foo/bar/{ping}/") //
-      Call<ResponseBody> method(@Path("ping") String ping, @Body RequestBody body) {
-        return null;
-      }
-    }
-    RequestBody body = RequestBody.create(TEXT_PLAIN, "Hi!");
-    Request request = buildRequest(Example.class, "pong", body);
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong/");
-    assertBody(request.body(), "Hi!");
-  }
-
-  @Test public void emptyBody() {
-    class Example {
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class);
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertBody(request.body(), "");
-  }
-
-  @Ignore("https://github.com/square/okhttp/issues/229")
-  @Test public void customMethodEmptyBody() {
-    class Example {
-      @HTTP(method = "CUSTOM", path = "/foo/bar/", hasBody = true) //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class);
-    assertThat(request.method()).isEqualTo("CUSTOM");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertBody(request.body(), "");
-  }
-
-  @Test public void bodyResponseBody() {
-    class Example {
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Body RequestBody body) {
-        return null;
-      }
-    }
-    RequestBody body = RequestBody.create(TEXT_PLAIN, "hi");
-    Request request = buildRequest(Example.class, body);
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertBody(request.body(), "hi");
-  }
-
-  @Test public void bodyRequired() {
-    class Example {
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Body RequestBody body) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e.getMessage()).isEqualTo("Body parameter value must not be null.");
-    }
-  }
-
-  @Test public void bodyWithPathParams() {
-    class Example {
-      @POST("/foo/bar/{ping}/{kit}/") //
-      Call<ResponseBody> method(@Path("ping") String ping, @Body RequestBody body, @Path("kit") String kit) {
-        return null;
-      }
-    }
-    RequestBody body = RequestBody.create(TEXT_PLAIN, "Hi!");
-    Request request = buildRequest(Example.class, "pong", body, "kat");
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong/kat/");
-    assertBody(request.body(), "Hi!");
-  }
-
-  @Test public void simpleMultipart() throws IOException {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part("ping") String ping, @Part("kit") RequestBody kit) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, "pong", RequestBody.create(
-        MediaType.parse("text/plain"), "kat"));
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-
-    RequestBody body = request.body();
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    String bodyString = buffer.readUtf8();
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"ping\"\r\n")
-        .contains("\r\npong\r\n--");
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"kit\"")
-        .contains("\r\nkat\r\n--");
-  }
-
-  @Test public void multipartArray() throws IOException {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part("ping") String[] ping) {
-        return null;
-      }
-    }
-
-    Request request =
-        buildRequest(Example.class, new Object[] { new String[] { "pong1", "pong2" } });
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-
-    RequestBody body = request.body();
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    String bodyString = buffer.readUtf8();
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"ping\"\r\n")
-        .contains("\r\npong1\r\n--");
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"ping\"")
-        .contains("\r\npong2\r\n--");
-  }
-
-  @Test public void multipartRequiresName() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part RequestBody part) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@Part annotation must supply a name or use MultipartBody.Part parameter type. (parameter #1)\n"
-              + "    for method Example.method");
-    }
-  }
-
-  @Test public void multipartIterableRequiresName() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part List<RequestBody> part) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@Part annotation must supply a name or use MultipartBody.Part parameter type. (parameter #1)\n"
-              + "    for method Example.method");
-    }
-  }
-
-  @Test public void multipartArrayRequiresName() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part RequestBody[] part) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@Part annotation must supply a name or use MultipartBody.Part parameter type. (parameter #1)\n"
-              + "    for method Example.method");
-    }
-  }
-
-  @Test public void multipartOkHttpPartForbidsName() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part("name") MultipartBody.Part part) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@Part parameters using the MultipartBody.Part must not include a part name in the annotation. (parameter #1)\n"
-              + "    for method Example.method");
-    }
-  }
-
-  @Test public void multipartOkHttpPart() throws IOException {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part MultipartBody.Part part) {
-        return null;
-      }
-    }
-
-    MultipartBody.Part part = MultipartBody.Part.createFormData("kit", "kat");
-    Request request = buildRequest(Example.class, part);
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-
-    RequestBody body = request.body();
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    String bodyString = buffer.readUtf8();
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"kit\"\r\n")
-        .contains("\r\nkat\r\n--");
-  }
-
-  @Test public void multipartOkHttpIterablePart() throws IOException {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part List<MultipartBody.Part> part) {
-        return null;
-      }
-    }
-
-    MultipartBody.Part part1 = MultipartBody.Part.createFormData("foo", "bar");
-    MultipartBody.Part part2 = MultipartBody.Part.createFormData("kit", "kat");
-    Request request = buildRequest(Example.class, Arrays.asList(part1, part2));
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-
-    RequestBody body = request.body();
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    String bodyString = buffer.readUtf8();
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"foo\"\r\n")
-        .contains("\r\nbar\r\n--");
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"kit\"\r\n")
-        .contains("\r\nkat\r\n--");
-  }
-
-  @Test public void multipartOkHttpArrayPart() throws IOException {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part MultipartBody.Part[] part) {
-        return null;
-      }
-    }
-
-    MultipartBody.Part part1 = MultipartBody.Part.createFormData("foo", "bar");
-    MultipartBody.Part part2 = MultipartBody.Part.createFormData("kit", "kat");
-    Request request =
-        buildRequest(Example.class, new Object[] { new MultipartBody.Part[] { part1, part2 } });
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-
-    RequestBody body = request.body();
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    String bodyString = buffer.readUtf8();
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"foo\"\r\n")
-        .contains("\r\nbar\r\n--");
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"kit\"\r\n")
-        .contains("\r\nkat\r\n--");
-  }
-
-  @Test public void multipartOkHttpPartWithFilename() throws IOException {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part MultipartBody.Part part) {
-        return null;
-      }
-    }
-
-    MultipartBody.Part part =
-        MultipartBody.Part.createFormData("kit", "kit.txt", RequestBody.create(null, "kat"));
-    Request request = buildRequest(Example.class, part);
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-
-    RequestBody body = request.body();
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    String bodyString = buffer.readUtf8();
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"kit\"; filename=\"kit.txt\"\r\n")
-        .contains("\r\nkat\r\n--");
-  }
-
-  @Test public void multipartIterable() throws IOException {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part("ping") List<String> ping) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, Arrays.asList("pong1", "pong2"));
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-
-    RequestBody body = request.body();
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    String bodyString = buffer.readUtf8();
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"ping\"\r\n")
-        .contains("\r\npong1\r\n--");
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"ping\"")
-        .contains("\r\npong2\r\n--");
-  }
-
-  @Test public void multipartIterableOkHttpPart() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part("ping") List<MultipartBody.Part> part) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@Part parameters using the MultipartBody.Part must not include a part name in the annotation. (parameter #1)\n"
-              + "    for method Example.method");
-    }
-  }
-
-  @Test public void multipartArrayOkHttpPart() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part("ping") MultipartBody.Part[] part) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@Part parameters using the MultipartBody.Part must not include a part name in the annotation. (parameter #1)\n"
-              + "    for method Example.method");
-    }
-  }
-
-  @Test public void multipartWithEncoding() throws IOException {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part(value = "ping", encoding = "8-bit") String ping,
-          @Part(value = "kit", encoding = "7-bit") RequestBody kit) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, "pong", RequestBody.create(
-        MediaType.parse("text/plain"), "kat"));
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-
-    RequestBody body = request.body();
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    String bodyString = buffer.readUtf8();
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"ping\"\r\n")
-        .contains("Content-Transfer-Encoding: 8-bit")
-        .contains("\r\npong\r\n--");
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"kit\"")
-        .contains("Content-Transfer-Encoding: 7-bit")
-        .contains("\r\nkat\r\n--");
-  }
-
-  @Test public void multipartPartMap() throws IOException {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@PartMap Map<String, RequestBody> parts) {
-        return null;
-      }
-    }
-
-    Map<String, RequestBody> params = new LinkedHashMap<>();
-    params.put("ping", RequestBody.create(null, "pong"));
-    params.put("kit", RequestBody.create(null, "kat"));
-
-    Request request = buildRequest(Example.class, params);
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-
-    RequestBody body = request.body();
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    String bodyString = buffer.readUtf8();
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"ping\"\r\n")
-        .contains("\r\npong\r\n--");
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"kit\"")
-        .contains("\r\nkat\r\n--");
-  }
-
-  @Test public void multipartPartMapWithEncoding() throws IOException {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@PartMap(encoding = "8-bit") Map<String, RequestBody> parts) {
-        return null;
-      }
-    }
-
-    Map<String, RequestBody> params = new LinkedHashMap<>();
-    params.put("ping", RequestBody.create(null, "pong"));
-    params.put("kit", RequestBody.create(null, "kat"));
-
-    Request request = buildRequest(Example.class, params);
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-
-    RequestBody body = request.body();
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    String bodyString = buffer.readUtf8();
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"ping\"\r\n")
-        .contains("Content-Transfer-Encoding: 8-bit")
-        .contains("\r\npong\r\n--");
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"kit\"")
-        .contains("Content-Transfer-Encoding: 8-bit")
-        .contains("\r\nkat\r\n--");
-  }
-
-  @Test public void multipartPartMapRejectsNonStringKeys() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@PartMap Map<Object, RequestBody> parts) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@PartMap keys must be of type String: class java.lang.Object (parameter #1)\n"
-              + "    for method Example.method");
-    }
-  }
-
-  @Test public void multipartPartMapRejectsOkHttpPartValues() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@PartMap Map<String, MultipartBody.Part> parts) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@PartMap values cannot be MultipartBody.Part. Use @Part List<Part> or a different value type instead. (parameter #1)\n"
-              + "    for method Example.method");
-    }
-  }
-
-  @Test public void multipartPartMapRejectsNull() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@PartMap Map<String, RequestBody> parts) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Part map was null.");
-    }
-  }
-
-  @Test public void multipartPartMapRejectsNullKeys() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@PartMap Map<String, RequestBody> parts) {
-        return null;
-      }
-    }
-
-    Map<String, RequestBody> params = new LinkedHashMap<>();
-    params.put("ping", RequestBody.create(null, "pong"));
-    params.put(null, RequestBody.create(null, "kat"));
-
-    try {
-      buildRequest(Example.class, params);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Part map contained null key.");
-    }
-  }
-
-  @Test public void multipartPartMapRejectsNullValues() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@PartMap Map<String, RequestBody> parts) {
-        return null;
-      }
-    }
-
-    Map<String, RequestBody> params = new LinkedHashMap<>();
-    params.put("ping", RequestBody.create(null, "pong"));
-    params.put("kit", null);
-
-    try {
-      buildRequest(Example.class, params);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Part map contained null value for key 'kit'.");
-    }
-  }
-
-  @Test public void multipartPartMapMustBeMap() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@PartMap List<Object> parts) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, Collections.emptyList());
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@PartMap parameter type must be Map. (parameter #1)\n    for method Example.method");
-    }
-  }
-
-  @Test public void multipartPartMapSupportsSubclasses() throws IOException {
-    class Foo extends HashMap<String, String> {
-    }
-
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@PartMap Foo parts) {
-        return null;
-      }
-    }
-
-    Foo foo = new Foo();
-    foo.put("hello", "world");
-
-    Request request = buildRequest(Example.class, foo);
-    Buffer buffer = new Buffer();
-    request.body().writeTo(buffer);
-    assertThat(buffer.readUtf8())
-        .contains("name=\"hello\"")
-        .contains("\r\n\r\nworld\r\n--");
-  }
-
-  @Test public void multipartNullRemovesPart() throws IOException {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part("ping") String ping, @Part("fizz") String fizz) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "pong", null);
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-
-    RequestBody body = request.body();
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    String bodyString = buffer.readUtf8();
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"ping\"")
-        .contains("\r\npong\r\n--");
-  }
-
-  @Test public void multipartPartOptional() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part("ping") RequestBody ping) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e.getMessage()).isEqualTo("Multipart body must have at least one part.");
-    }
-  }
-
-  @Test public void simpleFormEncoded() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/foo") //
-      Call<ResponseBody> method(@Field("foo") String foo, @Field("ping") String ping) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "bar", "pong");
-    assertBody(request.body(), "foo=bar&ping=pong");
-  }
-
-  @Test public void formEncodedWithEncodedNameFieldParam() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/foo") //
-      Call<ResponseBody> method(@Field(value = "na%20me", encoded = true) String foo) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "ba%20r");
-    assertBody(request.body(), "na%20me=ba%20r");
-  }
-
-  @Test public void formEncodedFieldOptional() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/foo") //
-      Call<ResponseBody> method(@Field("foo") String foo, @Field("ping") String ping,
-          @Field("kit") String kit) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "bar", null, "kat");
-    assertBody(request.body(), "foo=bar&kit=kat");
-  }
-
-  @Test public void formEncodedFieldList() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/foo") //
-      Call<ResponseBody> method(@Field("foo") List<Object> fields, @Field("kit") String kit) {
-        return null;
-      }
-    }
-
-    List<Object> values = Arrays.<Object>asList("foo", "bar", null, 3);
-    Request request = buildRequest(Example.class, values, "kat");
-    assertBody(request.body(), "foo=foo&foo=bar&foo=3&kit=kat");
-  }
-
-  @Test public void formEncodedFieldArray() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/foo") //
-      Call<ResponseBody> method(@Field("foo") Object[] fields, @Field("kit") String kit) {
-        return null;
-      }
-    }
-
-    Object[] values = { 1, 2, null, "three" };
-    Request request = buildRequest(Example.class, values, "kat");
-    assertBody(request.body(), "foo=1&foo=2&foo=three&kit=kat");
-  }
-
-  @Test public void formEncodedFieldPrimitiveArray() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/foo") //
-      Call<ResponseBody> method(@Field("foo") int[] fields, @Field("kit") String kit) {
-        return null;
-      }
-    }
-
-    int[] values = { 1, 2, 3 };
-    Request request = buildRequest(Example.class, values, "kat");
-    assertBody(request.body(), "foo=1&foo=2&foo=3&kit=kat");
-  }
-
-  @Test public void formEncodedWithEncodedNameFieldParamMap() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/foo") //
-      Call<ResponseBody> method(@FieldMap(encoded = true) Map<String, Object> fieldMap) {
-        return null;
-      }
-    }
-
-    Map<String, Object> fieldMap = new LinkedHashMap<>();
-    fieldMap.put("k%20it", "k%20at");
-    fieldMap.put("pin%20g", "po%20ng");
-
-    Request request = buildRequest(Example.class, fieldMap);
-    assertBody(request.body(), "k%20it=k%20at&pin%20g=po%20ng");
-  }
-
-  @Test public void formEncodedFieldMap() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/foo") //
-      Call<ResponseBody> method(@FieldMap Map<String, Object> fieldMap) {
-        return null;
-      }
-    }
-
-    Map<String, Object> fieldMap = new LinkedHashMap<>();
-    fieldMap.put("kit", "kat");
-    fieldMap.put("ping", "pong");
-
-    Request request = buildRequest(Example.class, fieldMap);
-    assertBody(request.body(), "kit=kat&ping=pong");
-  }
-
-  @Test public void fieldMapRejectsNull() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/") //
-      Call<ResponseBody> method(@FieldMap Map<String, Object> a) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Field map was null.");
-    }
-  }
-
-  @Test public void fieldMapRejectsNullKeys() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/") //
-      Call<ResponseBody> method(@FieldMap Map<String, Object> a) {
-        return null;
-      }
-    }
-
-    Map<String, Object> fieldMap = new LinkedHashMap<>();
-    fieldMap.put("kit", "kat");
-    fieldMap.put(null, "pong");
-
-    try {
-      buildRequest(Example.class, fieldMap);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Field map contained null key.");
-    }
-  }
-
-  @Test public void fieldMapRejectsNullValues() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/") //
-      Call<ResponseBody> method(@FieldMap Map<String, Object> a) {
-        return null;
-      }
-    }
-
-    Map<String, Object> fieldMap = new LinkedHashMap<>();
-    fieldMap.put("kit", "kat");
-    fieldMap.put("foo", null);
-
-    try {
-      buildRequest(Example.class, fieldMap);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Field map contained null value for key 'foo'.");
-    }
-  }
-
-  @Test public void fieldMapMustBeAMap() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/") //
-      Call<ResponseBody> method(@FieldMap List<String> a) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@FieldMap parameter type must be Map. (parameter #1)\n    for method Example.method");
-    }
-  }
-
-  @Test public void fieldMapSupportsSubclasses() throws IOException {
-    class Foo extends HashMap<String, String> {
-    }
-
-    class Example {
-      @FormUrlEncoded //
-      @POST("/") //
-      Call<ResponseBody> method(@FieldMap Foo a) {
-        return null;
-      }
-    }
-
-    Foo foo = new Foo();
-    foo.put("hello", "world");
-
-    Request request = buildRequest(Example.class, foo);
-    Buffer buffer = new Buffer();
-    request.body().writeTo(buffer);
-    assertThat(buffer.readUtf8()).isEqualTo("hello=world");
-  }
-
-  @Test public void simpleHeaders() {
-    class Example {
-      @GET("/foo/bar/")
-      @Headers({
-          "ping: pong",
-          "kit: kat"
-      })
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class);
-    assertThat(request.method()).isEqualTo("GET");
-    okhttp3.Headers headers = request.headers();
-    assertThat(headers.size()).isEqualTo(2);
-    assertThat(headers.get("ping")).isEqualTo("pong");
-    assertThat(headers.get("kit")).isEqualTo("kat");
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void headerParamToString() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method(@Header("kit") BigInteger kit) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, new BigInteger("1234"));
-    assertThat(request.method()).isEqualTo("GET");
-    okhttp3.Headers headers = request.headers();
-    assertThat(headers.size()).isEqualTo(1);
-    assertThat(headers.get("kit")).isEqualTo("1234");
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void headerParam() {
-    class Example {
-      @GET("/foo/bar/") //
-      @Headers("ping: pong") //
-      Call<ResponseBody> method(@Header("kit") String kit) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "kat");
-    assertThat(request.method()).isEqualTo("GET");
-    okhttp3.Headers headers = request.headers();
-    assertThat(headers.size()).isEqualTo(2);
-    assertThat(headers.get("ping")).isEqualTo("pong");
-    assertThat(headers.get("kit")).isEqualTo("kat");
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void headerParamList() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method(@Header("foo") List<String> kit) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, Arrays.asList("bar", null, "baz"));
-    assertThat(request.method()).isEqualTo("GET");
-    okhttp3.Headers headers = request.headers();
-    assertThat(headers.size()).isEqualTo(2);
-    assertThat(headers.values("foo")).containsExactly("bar", "baz");
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void headerParamArray() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method(@Header("foo") String[] kit) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, (Object) new String[] { "bar", null, "baz" });
-    assertThat(request.method()).isEqualTo("GET");
-    okhttp3.Headers headers = request.headers();
-    assertThat(headers.size()).isEqualTo(2);
-    assertThat(headers.values("foo")).containsExactly("bar", "baz");
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void contentTypeAnnotationHeaderOverrides() {
-    class Example {
-      @POST("/") //
-      @Headers("Content-Type: text/not-plain") //
-      Call<ResponseBody> method(@Body RequestBody body) {
-        return null;
-      }
-    }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
-    Request request = buildRequest(Example.class, body);
-    assertThat(request.body().contentType().toString()).isEqualTo("text/not-plain");
-  }
-
-  @Test public void contentTypeAnnotationHeaderAddsHeaderWithNoBody() {
-    class Example {
-      @DELETE("/") //
-      @Headers("Content-Type: text/not-plain") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class);
-    assertThat(request.headers().get("Content-Type")).isEqualTo("text/not-plain");
-  }
-
-  @Test public void contentTypeParameterHeaderOverrides() {
-    class Example {
-      @POST("/") //
-      Call<ResponseBody> method(@Header("Content-Type") String contentType, @Body RequestBody body) {
-        return null;
-      }
-    }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "Plain");
-    Request request = buildRequest(Example.class, "text/not-plain", body);
-    assertThat(request.body().contentType().toString()).isEqualTo("text/not-plain");
-  }
-
-  @Test public void malformedAnnotationRelativeUrlThrows() {
-    class Example {
-      @GET("ftp://example.org")
-      Call<ResponseBody> get() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Malformed URL. Base: http://example.com/, Relative: ftp://example.org");
-    }
-  }
-
-  @Test public void malformedParameterRelativeUrlThrows() {
-    class Example {
-      @GET
-      Call<ResponseBody> get(@Url String relativeUrl) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class, "ftp://example.org");
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Malformed URL. Base: http://example.com/, Relative: ftp://example.org");
-    }
-  }
-
-  private static void assertBody(RequestBody body, String expected) {
-    assertThat(body).isNotNull();
-    Buffer buffer = new Buffer();
-    try {
-      body.writeTo(buffer);
-      assertThat(buffer.readUtf8()).isEqualTo(expected);
-    } catch (IOException e) {
-      throw new RuntimeException(e);
-    }
-  }
-
-  static Request buildRequest(Class<?> cls, Object... args) {
-    final AtomicReference<Request> requestRef = new AtomicReference<>();
-    okhttp3.Call.Factory callFactory = new okhttp3.Call.Factory() {
-      @Override public okhttp3.Call newCall(Request request) {
-        requestRef.set(request);
-        throw new UnsupportedOperationException("Not implemented");
-      }
-    };
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addConverterFactory(new ToStringConverterFactory())
-        .callFactory(callFactory)
-        .build();
-
-    Method method = TestingUtils.onlyMethod(cls);
-    ServiceMethod<?> serviceMethod = retrofit.loadServiceMethod(method);
-    OkHttpCall<?> okHttpCall = new OkHttpCall<>(serviceMethod, args);
-    Call<?> call = (Call<?>) serviceMethod.callAdapter.adapt(okHttpCall);
-    try {
-      call.execute();
-      throw new AssertionError();
-    } catch (UnsupportedOperationException ignored) {
-      return requestRef.get();
-    } catch (RuntimeException e) {
-      throw e;
-    } catch (Exception e) {
-      throw new AssertionError(e);
-    }
-  }
-}
diff --git a/samples/pom.xml b/samples/pom.xml
index 62089676a..410ef4bfc 100644
--- a/samples/pom.xml
+++ b/samples/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>parent</artifactId>
-    <version>2.0.1</version>
+    <version>2.4.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -24,6 +24,11 @@
       <artifactId>retrofit-mock</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>converter-moshi</artifactId>
+      <version>${project.version}</version>
+    </dependency>
     <dependency>
       <groupId>${project.groupId}</groupId>
       <artifactId>converter-gson</artifactId>
@@ -34,6 +39,11 @@
       <artifactId>converter-simplexml</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>adapter-rxjava</artifactId>
+      <version>${project.version}</version>
+    </dependency>
     <dependency>
       <groupId>com.squareup.okhttp3</groupId>
       <artifactId>mockwebserver</artifactId>
diff --git a/samples/src/main/java/com/example/retrofit/AnnotatedConverters.java b/samples/src/main/java/com/example/retrofit/AnnotatedConverters.java
new file mode 100644
index 000000000..0664d3482
--- /dev/null
+++ b/samples/src/main/java/com/example/retrofit/AnnotatedConverters.java
@@ -0,0 +1,155 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.retrofit;
+
+import com.google.gson.GsonBuilder;
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.annotation.Retention;
+import java.lang.reflect.Type;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.simpleframework.xml.Attribute;
+import org.simpleframework.xml.Default;
+import org.simpleframework.xml.DefaultType;
+import retrofit2.Call;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
+import retrofit2.converter.gson.GsonConverterFactory;
+import retrofit2.converter.moshi.MoshiConverterFactory;
+import retrofit2.converter.simplexml.SimpleXmlConverterFactory;
+import retrofit2.http.GET;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+final class AnnotatedConverters {
+  public static final class AnnotatedConverterFactory extends Converter.Factory {
+    private final Map<Class<? extends Annotation>, Converter.Factory> factories;
+
+    public static final class Builder {
+      private final Map<Class<? extends Annotation>, Converter.Factory> factories =
+          new LinkedHashMap<>();
+
+      public Builder add(Class<? extends Annotation> cls, Converter.Factory factory) {
+        if (cls == null) {
+          throw new NullPointerException("cls == null");
+        }
+        if (factory == null) {
+          throw new NullPointerException("factory == null");
+        }
+        factories.put(cls, factory);
+        return this;
+      }
+
+      public AnnotatedConverterFactory build() {
+        return new AnnotatedConverterFactory(factories);
+      }
+    }
+
+    AnnotatedConverterFactory(Map<Class<? extends Annotation>, Converter.Factory> factories) {
+      this.factories = new LinkedHashMap<>(factories);
+    }
+
+    @Override
+    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+        Retrofit retrofit) {
+      for (Annotation annotation : annotations) {
+        Converter.Factory factory = factories.get(annotation.annotationType());
+        if (factory != null) {
+          return factory.responseBodyConverter(type, annotations, retrofit);
+        }
+      }
+      return null;
+    }
+
+    @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
+        Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+      for (Annotation annotation : parameterAnnotations) {
+        Converter.Factory factory = factories.get(annotation.annotationType());
+        if (factory != null) {
+          return factory.requestBodyConverter(type, parameterAnnotations, methodAnnotations,
+              retrofit);
+        }
+      }
+      return null;
+    }
+  }
+
+  @Retention(RUNTIME) public @interface Moshi {
+  }
+
+  @Retention(RUNTIME) public @interface Gson {
+  }
+
+  @Retention(RUNTIME) public @interface SimpleXml {
+  }
+
+  @Default(value = DefaultType.FIELD) static final class Library {
+    @Attribute String name;
+  }
+
+  interface Service {
+    @GET("/") @Moshi Call<Library> exampleMoshi();
+
+    @GET("/") @Gson Call<Library> exampleGson();
+
+    @GET("/") @SimpleXml Call<Library> exampleSimpleXml();
+
+    @GET("/") Call<Library> exampleDefault();
+  }
+
+  public static void main(String... args) throws IOException {
+    MockWebServer server = new MockWebServer();
+    server.start();
+    server.enqueue(new MockResponse().setBody("{\"name\": \"Moshi\"}"));
+    server.enqueue(new MockResponse().setBody("{\"name\": \"Gson\"}"));
+    server.enqueue(new MockResponse().setBody("<user name=\"SimpleXML\"/>"));
+    server.enqueue(new MockResponse().setBody("{\"name\": \"Gson\"}"));
+
+    com.squareup.moshi.Moshi moshi = new com.squareup.moshi.Moshi.Builder().build();
+    com.google.gson.Gson gson = new GsonBuilder().create();
+    MoshiConverterFactory moshiConverterFactory = MoshiConverterFactory.create(moshi);
+    GsonConverterFactory gsonConverterFactory = GsonConverterFactory.create(gson);
+    SimpleXmlConverterFactory simpleXmlConverterFactory = SimpleXmlConverterFactory.create();
+    Retrofit retrofit = new Retrofit.Builder().baseUrl(server.url("/"))
+        .addConverterFactory(
+            new AnnotatedConverterFactory.Builder().add(Moshi.class, moshiConverterFactory)
+                .add(Gson.class, gsonConverterFactory)
+                .add(SimpleXml.class, simpleXmlConverterFactory)
+                .build())
+        .addConverterFactory(gsonConverterFactory)
+        .build();
+    Service service = retrofit.create(Service.class);
+
+    Library library1 = service.exampleMoshi().execute().body();
+    System.out.println("Library 1: " + library1.name);
+
+    Library library2 = service.exampleGson().execute().body();
+    System.out.println("Library 2: " + library2.name);
+
+    Library library3 = service.exampleSimpleXml().execute().body();
+    System.out.println("Library 3: " + library3.name);
+
+    Library library4 = service.exampleDefault().execute().body();
+    System.out.println("Library 4: " + library4.name);
+
+    server.shutdown();
+  }
+}
diff --git a/samples/src/main/java/com/example/retrofit/Crawler.java b/samples/src/main/java/com/example/retrofit/Crawler.java
index 97c739e39..1e213e9a1 100644
--- a/samples/src/main/java/com/example/retrofit/Crawler.java
+++ b/samples/src/main/java/com/example/retrofit/Crawler.java
@@ -77,7 +77,7 @@ public void crawlPage(HttpUrl url) {
         // Enqueue its links for visiting.
         for (String link : page.links) {
           HttpUrl linkUrl = base.resolve(link);
-          if (linkUrl != null && !fetchedUrls.add(linkUrl)) {
+          if (linkUrl != null && fetchedUrls.add(linkUrl)) {
             crawlPage(linkUrl);
           }
         }
@@ -116,10 +116,10 @@ public static void main(String... args) throws Exception {
   }
 
   static class Page {
-    public final String title;
-    public final List<String> links;
+    final String title;
+    final List<String> links;
 
-    public Page(String title, List<String> links) {
+    Page(String title, List<String> links) {
       this.title = title;
       this.links = links;
     }
diff --git a/samples/src/main/java/com/example/retrofit/ErrorHandlingCallAdapter.java b/samples/src/main/java/com/example/retrofit/ErrorHandlingAdapter.java
similarity index 86%
rename from samples/src/main/java/com/example/retrofit/ErrorHandlingCallAdapter.java
rename to samples/src/main/java/com/example/retrofit/ErrorHandlingAdapter.java
index 0189da92b..28e8521ac 100644
--- a/samples/src/main/java/com/example/retrofit/ErrorHandlingCallAdapter.java
+++ b/samples/src/main/java/com/example/retrofit/ErrorHandlingAdapter.java
@@ -32,7 +32,7 @@
  * A sample showing a custom {@link CallAdapter} which adapts the built-in {@link Call} to a custom
  * version whose callback has more granular methods.
  */
-public final class ErrorHandlingCallAdapter {
+public final class ErrorHandlingAdapter {
   /** A callback which offers granular callbacks for various conditions. */
   interface MyCallback<T> {
     /** Called for [200, 300) responses. */
@@ -59,7 +59,7 @@
   }
 
   public static class ErrorHandlingCallAdapterFactory extends CallAdapter.Factory {
-    @Override public CallAdapter<MyCall<?>> get(Type returnType, Annotation[] annotations,
+    @Override public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations,
         Retrofit retrofit) {
       if (getRawType(returnType) != MyCall.class) {
         return null;
@@ -68,17 +68,27 @@
         throw new IllegalStateException(
             "MyCall must have generic type (e.g., MyCall<ResponseBody>)");
       }
-      final Type responseType = getParameterUpperBound(0, (ParameterizedType) returnType);
-      final Executor callbackExecutor = retrofit.callbackExecutor();
-      return new CallAdapter<MyCall<?>>() {
-        @Override public Type responseType() {
-          return responseType;
-        }
+      Type responseType = getParameterUpperBound(0, (ParameterizedType) returnType);
+      Executor callbackExecutor = retrofit.callbackExecutor();
+      return new ErrorHandlingCallAdapter<>(responseType, callbackExecutor);
+    }
 
-        @Override public <R> MyCall<R> adapt(Call<R> call) {
-          return new MyCallAdapter<>(call, callbackExecutor);
-        }
-      };
+    private static final class ErrorHandlingCallAdapter<R> implements CallAdapter<R, MyCall<R>> {
+      private final Type responseType;
+      private final Executor callbackExecutor;
+
+      ErrorHandlingCallAdapter(Type responseType, Executor callbackExecutor) {
+        this.responseType = responseType;
+        this.callbackExecutor = callbackExecutor;
+      }
+
+      @Override public Type responseType() {
+        return responseType;
+      }
+
+      @Override public MyCall<R> adapt(Call<R> call) {
+        return new MyCallAdapter<>(call, callbackExecutor);
+      }
     }
   }
 
diff --git a/samples/src/main/java/com/example/retrofit/JsonQueryParameters.java b/samples/src/main/java/com/example/retrofit/JsonQueryParameters.java
index bc29f8355..724c75fb2 100644
--- a/samples/src/main/java/com/example/retrofit/JsonQueryParameters.java
+++ b/samples/src/main/java/com/example/retrofit/JsonQueryParameters.java
@@ -78,9 +78,9 @@
   }
 
   static class Filter {
-    public final String userId;
+    final String userId;
 
-    public Filter(String userId) {
+    Filter(String userId) {
       this.userId = userId;
     }
   }
diff --git a/samples/src/main/java/com/example/retrofit/RxJavaObserveOnMainThread.java b/samples/src/main/java/com/example/retrofit/RxJavaObserveOnMainThread.java
new file mode 100644
index 000000000..6c4fec40d
--- /dev/null
+++ b/samples/src/main/java/com/example/retrofit/RxJavaObserveOnMainThread.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.retrofit;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import retrofit2.Call;
+import retrofit2.CallAdapter;
+import retrofit2.Retrofit;
+import retrofit2.adapter.rxjava.RxJavaCallAdapterFactory;
+import rx.Observable;
+import rx.Scheduler;
+import rx.schedulers.Schedulers;
+
+import static rx.schedulers.Schedulers.io;
+
+public final class RxJavaObserveOnMainThread {
+  public static void main(String... args) {
+    Scheduler observeOn = Schedulers.computation(); // Or use mainThread() for Android.
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com")
+        .addCallAdapterFactory(new ObserveOnMainCallAdapterFactory(observeOn))
+        .addCallAdapterFactory(RxJavaCallAdapterFactory.createWithScheduler(io()))
+        .build();
+
+    // Services created with this instance that use Observable will execute on the 'io' scheduler
+    // and notify their observer on the 'computation' scheduler.
+  }
+
+  static final class ObserveOnMainCallAdapterFactory extends CallAdapter.Factory {
+    final Scheduler scheduler;
+
+    ObserveOnMainCallAdapterFactory(Scheduler scheduler) {
+      this.scheduler = scheduler;
+    }
+
+    @Override
+    public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+      if (getRawType(returnType) != Observable.class) {
+        return null; // Ignore non-Observable types.
+      }
+
+      // Look up the next call adapter which would otherwise be used if this one was not present.
+      //noinspection unchecked returnType checked above to be Observable.
+      final CallAdapter<Object, Observable<?>> delegate =
+          (CallAdapter<Object, Observable<?>>) retrofit.nextCallAdapter(this, returnType,
+              annotations);
+
+      return new CallAdapter<Object, Object>() {
+        @Override public Object adapt(Call<Object> call) {
+          // Delegate to get the normal Observable...
+          Observable<?> o = delegate.adapt(call);
+          // ...and change it to send notifications to the observer on the specified scheduler.
+          return o.observeOn(scheduler);
+        }
+
+        @Override public Type responseType() {
+          return delegate.responseType();
+        }
+      };
+    }
+  }
+}
diff --git a/samples/src/main/java/com/example/retrofit/SimpleMockService.java b/samples/src/main/java/com/example/retrofit/SimpleMockService.java
index 347c911af..7c8a98e37 100644
--- a/samples/src/main/java/com/example/retrofit/SimpleMockService.java
+++ b/samples/src/main/java/com/example/retrofit/SimpleMockService.java
@@ -26,7 +26,7 @@
     private final BehaviorDelegate<GitHub> delegate;
     private final Map<String, Map<String, List<Contributor>>> ownerRepoContributors;
 
-    public MockGitHub(BehaviorDelegate<GitHub> delegate) {
+    MockGitHub(BehaviorDelegate<GitHub> delegate) {
       this.delegate = delegate;
       ownerRepoContributors = new LinkedHashMap<>();
 
@@ -50,7 +50,7 @@ public MockGitHub(BehaviorDelegate<GitHub> delegate) {
       return delegate.returningResponse(response).contributors(owner, repo);
     }
 
-    public void addContributor(String owner, String repo, String name, int contributions) {
+    void addContributor(String owner, String repo, String name, int contributions) {
       Map<String, List<Contributor>> repoContributors = ownerRepoContributors.get(owner);
       if (repoContributors == null) {
         repoContributors = new LinkedHashMap<>();
diff --git a/website/index.html b/website/index.html
index 92c160b86..fa15e43f0 100644
--- a/website/index.html
+++ b/website/index.html
@@ -64,7 +64,6 @@ <h3>Introduction</h3>
                 <li>Object conversion to request body (e.g., JSON, protocol buffers)</li>
                 <li>Multipart request body and file upload</li>
               </ul>
-              <p><em>Note:</em> This site is still in the process of being expanded for the new 2.0 APIs.</p>
             </section>
 
             <section id="api-declaration">
@@ -152,7 +151,7 @@ <h4>Converters</h4>
 
 GitHubService service = retrofit.create(GitHubService.class);</pre>
               <h4>Custom Converters</h4>
-              <p>If you need to communicate with an API that uses a content-format that Retrofit does not support out of the box (e.g. YAML, txt, custom format) or you wish to use a different library to implement an existing format, you can easily create your own converter. Create a class that extends the <a href="https://github.com/square/retrofit/blob/master/retrofit/src/main/java/retrofit/Converter.java"><code>Converter.Factory</code> class</a> and pass in an instance when building your adapter.</p>
+              <p>If you need to communicate with an API that uses a content-format that Retrofit does not support out of the box (e.g. YAML, txt, custom format) or you wish to use a different library to implement an existing format, you can easily create your own converter. Create a class that extends the <a href="https://github.com/square/retrofit/blob/master/retrofit/src/main/java/retrofit2/Converter.java"><code>Converter.Factory</code> class</a> and pass in an instance when building your adapter.</p>
             </section>
 
             <section id="download">
@@ -172,13 +171,18 @@ <h4>Gradle</h4>
               <p>Retrofit requires at minimum Java 7 or Android 2.3.</p>
 
               <h4>ProGuard</h4>
-              <p>If you are using Proguard in your project add the following lines to your configuration:</p>
+              <p>If you are using ProGuard in your project add the following lines to your configuration:</p>
               <pre class="prettyprint">
--dontwarn retrofit2.**
--keep class retrofit2.** { *; }
+# Platform calls Class.forName on types which do not exist on Android to determine platform.
+-dontnote retrofit2.Platform
+# Platform used when running on Java 8 VMs. Will not be used at runtime.
+-dontwarn retrofit2.Platform$Java8
+# Retain generic type information for use by reflection by converters and adapters.
 -keepattributes Signature
+# Retain declared checked exceptions for use by a Proxy instance.
 -keepattributes Exceptions
 </pre>
+            <p>Retrofit uses <a href="https://github.com/square/okio">Okio</a> under the hood, so you may want to look at its <a href="https://github.com/square/okio#proguard">ProGuard rules</a> as well.</p>
             </section>
 
             <section id="contributing">
