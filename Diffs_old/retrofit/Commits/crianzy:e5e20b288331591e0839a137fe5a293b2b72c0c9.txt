diff --git a/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/Java8CallAdapterFactory.java b/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/Java8CallAdapterFactory.java
index d8a87c73c..96c3d7e96 100644
--- a/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/Java8CallAdapterFactory.java
+++ b/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/Java8CallAdapterFactory.java
@@ -19,6 +19,7 @@
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import java.util.concurrent.CompletableFuture;
+
 import retrofit2.Call;
 import retrofit2.CallAdapter;
 import retrofit2.Callback;
@@ -26,109 +27,119 @@
 import retrofit2.Retrofit;
 
 public final class Java8CallAdapterFactory extends CallAdapter.Factory {
-  public static Java8CallAdapterFactory create() {
-    return new Java8CallAdapterFactory();
-  }
-
-  private Java8CallAdapterFactory() {
-  }
-
-  @Override
-  public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
-    if (getRawType(returnType) != CompletableFuture.class) {
-      return null;
+    public static Java8CallAdapterFactory create() {
+        return new Java8CallAdapterFactory();
     }
-    if (!(returnType instanceof ParameterizedType)) {
-      throw new IllegalStateException("CompletableFuture return type must be parameterized"
-          + " as CompletableFuture<Foo> or CompletableFuture<? extends Foo>");
-    }
-    Type innerType = getParameterUpperBound(0, (ParameterizedType) returnType);
 
-    if (getRawType(innerType) != Response.class) {
-      // Generic type is not Response<T>. Use it for body-only adapter.
-      return new BodyCallAdapter(innerType);
+    private Java8CallAdapterFactory() {
     }
 
-    // Generic type is Response<T>. Extract T and create the Response version of the adapter.
-    if (!(innerType instanceof ParameterizedType)) {
-      throw new IllegalStateException("Response must be parameterized"
-          + " as Response<Foo> or Response<? extends Foo>");
-    }
-    Type responseType = getParameterUpperBound(0, (ParameterizedType) innerType);
-    return new ResponseCallAdapter(responseType);
-  }
+    @Override
+    public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+        if (getRawType(returnType) != CompletableFuture.class) {
+            return null;
+        }
+        if (!(returnType instanceof ParameterizedType)) {
+            throw new IllegalStateException("CompletableFuture return type must be parameterized"
+                    + " as CompletableFuture<Foo> or CompletableFuture<? extends Foo>");
+        }
+        Type innerType = getParameterUpperBound(0, (ParameterizedType) returnType);
 
-  private static class BodyCallAdapter implements CallAdapter<CompletableFuture<?>> {
-    private final Type responseType;
+        if (getRawType(innerType) != Response.class) {
+            // Generic type is not Response<T>. Use it for body-only adapter.
+            return new BodyCallAdapter(innerType);
+        }
 
-    BodyCallAdapter(Type responseType) {
-      this.responseType = responseType;
+        // Generic type is Response<T>. Extract T and create the Response version of the adapter.
+        if (!(innerType instanceof ParameterizedType)) {
+            throw new IllegalStateException("Response must be parameterized"
+                    + " as Response<Foo> or Response<? extends Foo>");
+        }
+        Type responseType = getParameterUpperBound(0, (ParameterizedType) innerType);
+        return new ResponseCallAdapter(responseType);
     }
 
-    @Override public Type responseType() {
-      return responseType;
-    }
+    private static class BodyCallAdapter implements CallAdapter<CompletableFuture<?>> {
+        private final Type responseType;
 
-    @Override public <R> CompletableFuture<R> adapt(final Call<R> call) {
-      final CompletableFuture<R> future = new CompletableFuture<R>() {
-        @Override public boolean cancel(boolean mayInterruptIfRunning) {
-          if (mayInterruptIfRunning) {
-            call.cancel();
-          }
-          return super.cancel(mayInterruptIfRunning);
-        }
-      };
-
-      call.enqueue(new Callback<R>() {
-        @Override public void onResponse(Call<R> call, Response<R> response) {
-          if (response.isSuccessful()) {
-            future.complete(response.body());
-          } else {
-            future.completeExceptionally(new HttpException(response));
-          }
+        BodyCallAdapter(Type responseType) {
+            this.responseType = responseType;
         }
 
-        @Override public void onFailure(Call<R> call, Throwable t) {
-          future.completeExceptionally(t);
+        @Override
+        public Type responseType() {
+            return responseType;
         }
-      });
-
-      return future;
-    }
-  }
 
-  private static class ResponseCallAdapter implements CallAdapter<CompletableFuture<?>> {
-    private final Type responseType;
-
-    ResponseCallAdapter(Type responseType) {
-      this.responseType = responseType;
+        @Override
+        public <R> CompletableFuture<R> adapt(final Call<R> call) {
+            final CompletableFuture<R> future = new CompletableFuture<R>() {
+                @Override
+                public boolean cancel(boolean mayInterruptIfRunning) {
+                    if (mayInterruptIfRunning) {
+                        call.cancel();
+                    }
+                    return super.cancel(mayInterruptIfRunning);
+                }
+            };
+
+            call.enqueue(new Callback<R>() {
+                @Override
+                public void onResponse(Call<R> call, Response<R> response) {
+                    if (response.isSuccessful()) {
+                        future.complete(response.body());
+                    } else {
+                        future.completeExceptionally(new HttpException(response));
+                    }
+                }
+
+                @Override
+                public void onFailure(Call<R> call, Throwable t) {
+                    future.completeExceptionally(t);
+                }
+            });
+
+            return future;
+        }
     }
 
-    @Override public Type responseType() {
-      return responseType;
-    }
+    private static class ResponseCallAdapter implements CallAdapter<CompletableFuture<?>> {
+        private final Type responseType;
 
-    @Override public <R> CompletableFuture<Response<R>> adapt(final Call<R> call) {
-      final CompletableFuture<Response<R>> future = new CompletableFuture<Response<R>>() {
-        @Override public boolean cancel(boolean mayInterruptIfRunning) {
-          if (mayInterruptIfRunning) {
-            call.cancel();
-          }
-          return super.cancel(mayInterruptIfRunning);
+        ResponseCallAdapter(Type responseType) {
+            this.responseType = responseType;
         }
-      };
 
-      call.enqueue(new Callback<R>() {
-        @Override public void onResponse(Call<R> call, Response<R> response) {
-          future.complete(response);
+        @Override
+        public Type responseType() {
+            return responseType;
         }
 
-        @Override public void onFailure(Call<R> call, Throwable t) {
-          future.completeExceptionally(t);
+        @Override
+        public <R> CompletableFuture<Response<R>> adapt(final Call<R> call) {
+            final CompletableFuture<Response<R>> future = new CompletableFuture<Response<R>>() {
+                @Override
+                public boolean cancel(boolean mayInterruptIfRunning) {
+                    if (mayInterruptIfRunning) {
+                        call.cancel();
+                    }
+                    return super.cancel(mayInterruptIfRunning);
+                }
+            };
+
+            call.enqueue(new Callback<R>() {
+                @Override
+                public void onResponse(Call<R> call, Response<R> response) {
+                    future.complete(response);
+                }
+
+                @Override
+                public void onFailure(Call<R> call, Throwable t) {
+                    future.completeExceptionally(t);
+                }
+            });
+
+            return future;
         }
-      });
-
-      return future;
     }
-  }
 }
diff --git a/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlConverterFactory.java b/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlConverterFactory.java
index b7563455e..361efb547 100644
--- a/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlConverterFactory.java
+++ b/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlConverterFactory.java
@@ -17,6 +17,7 @@
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import org.simpleframework.xml.Serializer;
@@ -31,55 +32,63 @@
  * not handled.
  */
 public final class SimpleXmlConverterFactory extends Converter.Factory {
-  /** Create an instance using a default {@link Persister} instance for conversion. */
-  public static SimpleXmlConverterFactory create() {
-    return create(new Persister());
-  }
+    /**
+     * Create an instance using a default {@link Persister} instance for conversion.
+     */
+    public static SimpleXmlConverterFactory create() {
+        return create(new Persister());
+    }
 
-  /** Create an instance using {@code serializer} for conversion. */
-  public static SimpleXmlConverterFactory create(Serializer serializer) {
-    return new SimpleXmlConverterFactory(serializer, true);
-  }
+    /**
+     * Create an instance using {@code serializer} for conversion.
+     */
+    public static SimpleXmlConverterFactory create(Serializer serializer) {
+        return new SimpleXmlConverterFactory(serializer, true);
+    }
 
-  /** Create an instance using a default {@link Persister} instance for non-strict conversion. */
-  public static SimpleXmlConverterFactory createNonStrict() {
-    return createNonStrict(new Persister());
-  }
+    /**
+     * Create an instance using a default {@link Persister} instance for non-strict conversion.
+     */
+    public static SimpleXmlConverterFactory createNonStrict() {
+        return createNonStrict(new Persister());
+    }
 
-  /** Create an instance using {@code serializer} for non-strict conversion. */
-  public static SimpleXmlConverterFactory createNonStrict(Serializer serializer) {
-    return new SimpleXmlConverterFactory(serializer, false);
-  }
+    /**
+     * Create an instance using {@code serializer} for non-strict conversion.
+     */
+    public static SimpleXmlConverterFactory createNonStrict(Serializer serializer) {
+        return new SimpleXmlConverterFactory(serializer, false);
+    }
 
-  private final Serializer serializer;
-  private final boolean strict;
+    private final Serializer serializer;
+    private final boolean strict;
 
-  private SimpleXmlConverterFactory(Serializer serializer, boolean strict) {
-    if (serializer == null) throw new NullPointerException("serializer == null");
-    this.serializer = serializer;
-    this.strict = strict;
-  }
+    private SimpleXmlConverterFactory(Serializer serializer, boolean strict) {
+        if (serializer == null) throw new NullPointerException("serializer == null");
+        this.serializer = serializer;
+        this.strict = strict;
+    }
 
-  public boolean isStrict() {
-    return strict;
-  }
+    public boolean isStrict() {
+        return strict;
+    }
 
-  @Override
-  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
-    if (!(type instanceof Class)) {
-      return null;
+    @Override
+    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+                                                            Retrofit retrofit) {
+        if (!(type instanceof Class)) {
+            return null;
+        }
+        Class<?> cls = (Class<?>) type;
+        return new SimpleXmlResponseBodyConverter<>(cls, serializer, strict);
     }
-    Class<?> cls = (Class<?>) type;
-    return new SimpleXmlResponseBodyConverter<>(cls, serializer, strict);
-  }
 
-  @Override
-  public Converter<?, RequestBody> requestBodyConverter(Type type,
-      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
-    if (!(type instanceof Class)) {
-      return null;
+    @Override
+    public Converter<?, RequestBody> requestBodyConverter(Type type,
+                                                          Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+        if (!(type instanceof Class)) {
+            return null;
+        }
+        return new SimpleXmlRequestBodyConverter<>(serializer);
     }
-    return new SimpleXmlRequestBodyConverter<>(serializer);
-  }
 }
diff --git a/retrofit/src/main/java/retrofit2/BuiltInConverters.java b/retrofit/src/main/java/retrofit2/BuiltInConverters.java
index 5a83fb440..04fda2eb3 100644
--- a/retrofit/src/main/java/retrofit2/BuiltInConverters.java
+++ b/retrofit/src/main/java/retrofit2/BuiltInConverters.java
@@ -24,7 +24,7 @@
 import retrofit2.http.Streaming;
 
 /**
- * 转换器
+ * 默认的转换器
  */
 final class BuiltInConverters extends Converter.Factory {
     @Override
diff --git a/samples/src/main/java/com/example/retrofit/ChunkingConverter.java b/samples/src/main/java/com/example/retrofit/ChunkingConverter.java
index 790675975..50cbb4e51 100644
--- a/samples/src/main/java/com/example/retrofit/ChunkingConverter.java
+++ b/samples/src/main/java/com/example/retrofit/ChunkingConverter.java
@@ -20,6 +20,7 @@
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 import java.lang.reflect.Type;
+
 import okhttp3.MediaType;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
@@ -38,92 +39,102 @@
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 public final class ChunkingConverter {
-  @Target(PARAMETER)
-  @Retention(RUNTIME)
-  @interface Chunked {
-  }
-
-  /**
-   * A converter which removes known content lengths to force chunking when {@code @Chunked} is
-   * present on {@code @Body} params.
-   */
-  static class ChunkingConverterFactory extends Converter.Factory {
-    @Override
-    public Converter<?, RequestBody> requestBodyConverter(Type type,
-        Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
-      boolean isBody = false;
-      boolean isChunked = false;
-      for (Annotation annotation : parameterAnnotations) {
-        isBody |= annotation instanceof Body;
-        isChunked |= annotation instanceof Chunked;
-      }
-      if (!isBody || !isChunked) {
-        return null;
-      }
-
-      // Look up the real converter to delegate to.
-      final Converter<Object, RequestBody> delegate =
-          retrofit.nextRequestBodyConverter(this, type, parameterAnnotations, methodAnnotations);
-      // Wrap it in a Converter which removes the content length from the delegate's body.
-      return new Converter<Object, RequestBody>() {
-        @Override public RequestBody convert(Object value) throws IOException {
-          final RequestBody realBody = delegate.convert(value);
-          return new RequestBody() {
-            @Override public MediaType contentType() {
-              return realBody.contentType();
-            }
+    @Target(PARAMETER)
+    @Retention(RUNTIME)
+    // 表示 post 请求是否分块传输
+    @interface Chunked {
+    }
 
-            @Override public void writeTo(BufferedSink sink) throws IOException {
-              realBody.writeTo(sink);
+    /**
+     * A converter which removes known content lengths to force chunking when {@code @Chunked} is
+     * present on {@code @Body} params.
+     *
+     * 转换后 去掉了  content lengths  就能达到分块传输的目的
+     */
+    static class ChunkingConverterFactory extends Converter.Factory {
+        @Override
+        public Converter<?, RequestBody> requestBodyConverter(Type type,
+                                                              Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+            boolean isBody = false;
+            boolean isChunked = false;
+            // 判断是否符合要求的 逻辑
+            for (Annotation annotation : parameterAnnotations) {
+                isBody |= annotation instanceof Body;
+                isChunked |= annotation instanceof Chunked;
             }
-          };
+            if (!isBody || !isChunked) {
+                return null;
+            }
+
+            // Look up the real converter to delegate to.
+            // 找 在自己后面的 转换器
+            final Converter<Object, RequestBody> delegate =
+                    retrofit.nextRequestBodyConverter(this, type, parameterAnnotations, methodAnnotations);
+            // Wrap it in a Converter which removes the content length from the delegate's body.
+            return new Converter<Object, RequestBody>() {
+                @Override
+                public RequestBody convert(Object value) throws IOException {
+                    final RequestBody realBody = delegate.convert(value);
+                    // 更具 retrofit 已经穿在 convert 转换出来的 RequestBody  再处理一下
+                    return new RequestBody() {
+                        @Override
+                        public MediaType contentType() {
+                            return realBody.contentType();
+                        }
+
+                        @Override
+                        public void writeTo(BufferedSink sink) throws IOException {
+                            realBody.writeTo(sink);
+                        }
+                    };
+                }
+            };
         }
-      };
     }
-  }
 
-  static class Repo {
-    final String owner;
-    final String name;
+    static class Repo {
+        final String owner;
+        final String name;
+
+        Repo(String owner, String name) {
+            this.owner = owner;
+            this.name = name;
+        }
+    }
+
+    interface Service {
+        @POST("/")
+        Call<ResponseBody> sendNormal(@Body Repo repo);
+
+        @POST("/")
+        Call<ResponseBody> sendChunked(@Chunked @Body Repo repo);
+    }
+
+    public static void main(String... args) throws IOException, InterruptedException {
+        MockWebServer server = new MockWebServer();
+        server.enqueue(new MockResponse());
+        server.enqueue(new MockResponse());
+        server.start();
+
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ChunkingConverterFactory())
+                .addConverterFactory(GsonConverterFactory.create())
+                .build();
+        Service service = retrofit.create(Service.class);
+
+        Repo retrofitRepo = new Repo("square", "retrofit");
+
+        service.sendNormal(retrofitRepo).execute();
+        RecordedRequest normalRequest = server.takeRequest();
+        System.out.println(
+                "Normal @Body Transfer-Encoding: " + normalRequest.getHeader("Transfer-Encoding"));
+
+        service.sendChunked(retrofitRepo).execute();
+        RecordedRequest chunkedRequest = server.takeRequest();
+        System.out.println(
+                "@Chunked @Body Transfer-Encoding: " + chunkedRequest.getHeader("Transfer-Encoding"));
 
-    Repo(String owner, String name) {
-      this.owner = owner;
-      this.name = name;
+        server.shutdown();
     }
-  }
-
-  interface Service {
-    @POST("/")
-    Call<ResponseBody> sendNormal(@Body Repo repo);
-    @POST("/")
-    Call<ResponseBody> sendChunked(@Chunked @Body Repo repo);
-  }
-
-  public static void main(String... args) throws IOException, InterruptedException {
-    MockWebServer server = new MockWebServer();
-    server.enqueue(new MockResponse());
-    server.enqueue(new MockResponse());
-    server.start();
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ChunkingConverterFactory())
-        .addConverterFactory(GsonConverterFactory.create())
-        .build();
-    Service service = retrofit.create(Service.class);
-
-    Repo retrofitRepo = new Repo("square", "retrofit");
-
-    service.sendNormal(retrofitRepo).execute();
-    RecordedRequest normalRequest = server.takeRequest();
-    System.out.println(
-        "Normal @Body Transfer-Encoding: " + normalRequest.getHeader("Transfer-Encoding"));
-
-    service.sendChunked(retrofitRepo).execute();
-    RecordedRequest chunkedRequest = server.takeRequest();
-    System.out.println(
-        "@Chunked @Body Transfer-Encoding: " + chunkedRequest.getHeader("Transfer-Encoding"));
-
-    server.shutdown();
-  }
 }
diff --git a/samples/src/main/java/com/example/retrofit/Crawler.java b/samples/src/main/java/com/example/retrofit/Crawler.java
index 97c739e39..dba2c96f4 100644
--- a/samples/src/main/java/com/example/retrofit/Crawler.java
+++ b/samples/src/main/java/com/example/retrofit/Crawler.java
@@ -27,6 +27,7 @@
 import java.util.concurrent.Executors;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
+
 import okhttp3.ConnectionPool;
 import okhttp3.Dispatcher;
 import okhttp3.HttpUrl;
@@ -43,104 +44,114 @@
 import retrofit2.http.GET;
 import retrofit2.http.Url;
 
-/** A simple web crawler that uses a Retrofit service to turn URLs into webpages. */
+/**
+ * A simple web crawler that uses a Retrofit service to turn URLs into webpages.
+ * 爬虫
+ */
 public final class Crawler {
-  private final Set<HttpUrl> fetchedUrls = Collections.synchronizedSet(
-      new LinkedHashSet<HttpUrl>());
-  private final ConcurrentHashMap<String, AtomicInteger> hostnames = new ConcurrentHashMap<>();
-  private final PageService pageService;
-
-  public Crawler(PageService pageService) {
-    this.pageService = pageService;
-  }
-
-  public void crawlPage(HttpUrl url) {
-    // Skip hosts that we've visited many times.
-    AtomicInteger hostnameCount = new AtomicInteger();
-    AtomicInteger previous = hostnames.putIfAbsent(url.host(), hostnameCount);
-    if (previous != null) hostnameCount = previous;
-    if (hostnameCount.incrementAndGet() > 100) return;
-
-    // Asynchronously visit URL.
-    pageService.get(url).enqueue(new Callback<Page>() {
-      @Override public void onResponse(Call<Page> call, Response<Page> response) {
-        if (!response.isSuccessful()) {
-          System.out.println(call.request().url() + ": failed: " + response.code());
-          return;
-        }
+    private final Set<HttpUrl> fetchedUrls = Collections.synchronizedSet(
+            new LinkedHashSet<HttpUrl>());
+    private final ConcurrentHashMap<String, AtomicInteger> hostnames = new ConcurrentHashMap<>();
+    private final PageService pageService;
+
+    public Crawler(PageService pageService) {
+        this.pageService = pageService;
+    }
+
+    public void crawlPage(HttpUrl url) {
+        // Skip hosts that we've visited many times.
+        AtomicInteger hostnameCount = new AtomicInteger();
+        AtomicInteger previous = hostnames.putIfAbsent(url.host(), hostnameCount);
+        if (previous != null) hostnameCount = previous;
+        if (hostnameCount.incrementAndGet() > 100) return;
+
+        // Asynchronously visit URL.
+        pageService.get(url).enqueue(new Callback<Page>() {
+            @Override
+            public void onResponse(Call<Page> call, Response<Page> response) {
+                if (!response.isSuccessful()) {
+                    System.out.println(call.request().url() + ": failed: " + response.code());
+                    return;
+                }
+
+                // Print this page's URL and title.
+                Page page = response.body();
+                HttpUrl base = response.raw().request().url();
+                System.out.println(base + ": " + page.title);
+
+                // Enqueue its links for visiting.
+                for (String link : page.links) {
+                    HttpUrl linkUrl = base.resolve(link);
+                    if (linkUrl != null && !fetchedUrls.add(linkUrl)) {
+                        // 获取掉连接后再起请求 数据
+                        crawlPage(linkUrl);
+                    }
+                }
+            }
+
+            @Override
+            public void onFailure(Call<Page> call, Throwable t) {
+                System.out.println(call.request().url() + ": failed: " + t);
+            }
+        });
+    }
+
+    public static void main(String... args) throws Exception {
+        Dispatcher dispatcher = new Dispatcher(Executors.newFixedThreadPool(20));
+        dispatcher.setMaxRequests(20);
+        dispatcher.setMaxRequestsPerHost(1);
+
+        OkHttpClient okHttpClient = new OkHttpClient.Builder()
+                .dispatcher(dispatcher)
+                .connectionPool(new ConnectionPool(100, 30, TimeUnit.SECONDS))
+                .build();
 
-        // Print this page's URL and title.
-        Page page = response.body();
-        HttpUrl base = response.raw().request().url();
-        System.out.println(base + ": " + page.title);
-
-        // Enqueue its links for visiting.
-        for (String link : page.links) {
-          HttpUrl linkUrl = base.resolve(link);
-          if (linkUrl != null && !fetchedUrls.add(linkUrl)) {
-            crawlPage(linkUrl);
-          }
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(HttpUrl.parse("http://zuimeia.com/"))
+                .addConverterFactory(PageAdapter.FACTORY)
+                .client(okHttpClient)
+                .build();
+
+        PageService pageService = retrofit.create(PageService.class);
+
+        Crawler crawler = new Crawler(pageService);
+        crawler.crawlPage(HttpUrl.parse("http://zuimeia.com/"));
+    }
+
+    interface PageService {
+        @GET
+        Call<Page> get(@Url HttpUrl url);
+    }
+
+    static class Page {
+        public final String title;
+        public final List<String> links;
+
+        public Page(String title, List<String> links) {
+            this.title = title;
+            this.links = links;
         }
-      }
-
-      @Override public void onFailure(Call<Page> call, Throwable t) {
-        System.out.println(call.request().url() + ": failed: " + t);
-      }
-    });
-  }
-
-  public static void main(String... args) throws Exception {
-    Dispatcher dispatcher = new Dispatcher(Executors.newFixedThreadPool(20));
-    dispatcher.setMaxRequests(20);
-    dispatcher.setMaxRequestsPerHost(1);
-
-    OkHttpClient okHttpClient = new OkHttpClient.Builder()
-        .dispatcher(dispatcher)
-        .connectionPool(new ConnectionPool(100, 30, TimeUnit.SECONDS))
-        .build();
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(HttpUrl.parse("https://example.com/"))
-        .addConverterFactory(PageAdapter.FACTORY)
-        .client(okHttpClient)
-        .build();
-
-    PageService pageService = retrofit.create(PageService.class);
-
-    Crawler crawler = new Crawler(pageService);
-    crawler.crawlPage(HttpUrl.parse(args[0]));
-  }
-
-  interface PageService {
-    @GET Call<Page> get(@Url HttpUrl url);
-  }
-
-  static class Page {
-    public final String title;
-    public final List<String> links;
-
-    public Page(String title, List<String> links) {
-      this.title = title;
-      this.links = links;
     }
-  }
-
-  static final class PageAdapter implements Converter<ResponseBody, Page> {
-    static final Converter.Factory FACTORY = new Converter.Factory() {
-      @Override public Converter<ResponseBody, ?> responseBodyConverter(
-          Type type, Annotation[] annotations, Retrofit retrofit) {
-        if (type == Page.class) return new PageAdapter();
-        return null;
-      }
-    };
-
-    @Override public Page convert(ResponseBody responseBody) throws IOException {
-      Document document = Jsoup.parse(responseBody.string());
-      List<String> links = new ArrayList<>();
-      for (Element element : document.select("a[href]")) {
-        links.add(element.attr("href"));
-      }
-      return new Page(document.title(), Collections.unmodifiableList(links));
+
+    static final class PageAdapter implements Converter<ResponseBody, Page> {
+        static final Converter.Factory FACTORY = new Converter.Factory() {
+            @Override
+            public Converter<ResponseBody, ?> responseBodyConverter(
+                    Type type, Annotation[] annotations, Retrofit retrofit) {
+                if (type == Page.class) return new PageAdapter();
+                return null;
+            }
+        };
+
+        @Override
+        public Page convert(ResponseBody responseBody) throws IOException {
+            Document document = Jsoup.parse(responseBody.string());
+            List<String> links = new ArrayList<>();
+            // 获取网页上的 连接
+            for (Element element : document.select("a[href]")) {
+                links.add(element.attr("href"));
+            }
+            return new Page(document.title(), Collections.unmodifiableList(links));
+        }
     }
-  }
 }
diff --git a/samples/src/main/java/com/example/retrofit/DynamicBaseUrl.java b/samples/src/main/java/com/example/retrofit/DynamicBaseUrl.java
index 7507b840a..1df816509 100644
--- a/samples/src/main/java/com/example/retrofit/DynamicBaseUrl.java
+++ b/samples/src/main/java/com/example/retrofit/DynamicBaseUrl.java
@@ -62,6 +62,7 @@ public void setHost(String host) {
   public static void main(String... args) throws IOException {
     HostSelectionInterceptor hostSelectionInterceptor = new HostSelectionInterceptor();
 
+    // 在 okHttp 这里设置拦截器
     OkHttpClient okHttpClient = new OkHttpClient.Builder()
         .addInterceptor(hostSelectionInterceptor)
         .build();
diff --git a/samples/src/main/java/com/example/retrofit/ErrorHandlingCallAdapter.java b/samples/src/main/java/com/example/retrofit/ErrorHandlingCallAdapter.java
index 0189da92b..04d53ef7c 100644
--- a/samples/src/main/java/com/example/retrofit/ErrorHandlingCallAdapter.java
+++ b/samples/src/main/java/com/example/retrofit/ErrorHandlingCallAdapter.java
@@ -20,6 +20,7 @@
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import java.util.concurrent.Executor;
+
 import retrofit2.Call;
 import retrofit2.CallAdapter;
 import retrofit2.Callback;
@@ -33,149 +34,186 @@
  * version whose callback has more granular methods.
  */
 public final class ErrorHandlingCallAdapter {
-  /** A callback which offers granular callbacks for various conditions. */
-  interface MyCallback<T> {
-    /** Called for [200, 300) responses. */
-    void success(Response<T> response);
-    /** Called for 401 responses. */
-    void unauthenticated(Response<?> response);
-    /** Called for [400, 500) responses, except 401. */
-    void clientError(Response<?> response);
-    /** Called for [500, 600) response. */
-    void serverError(Response<?> response);
-    /** Called for network errors while making the call. */
-    void networkError(IOException e);
-    /** Called for unexpected errors while making the call. */
-    void unexpectedError(Throwable t);
-  }
-
-  interface MyCall<T> {
-    void cancel();
-    void enqueue(MyCallback<T> callback);
-    MyCall<T> clone();
-
-    // Left as an exercise for the reader...
-    // TODO MyResponse<T> execute() throws MyHttpException;
-  }
-
-  public static class ErrorHandlingCallAdapterFactory extends CallAdapter.Factory {
-    @Override public CallAdapter<MyCall<?>> get(Type returnType, Annotation[] annotations,
-        Retrofit retrofit) {
-      if (getRawType(returnType) != MyCall.class) {
-        return null;
-      }
-      if (!(returnType instanceof ParameterizedType)) {
-        throw new IllegalStateException(
-            "MyCall must have generic type (e.g., MyCall<ResponseBody>)");
-      }
-      final Type responseType = getParameterUpperBound(0, (ParameterizedType) returnType);
-      final Executor callbackExecutor = retrofit.callbackExecutor();
-      return new CallAdapter<MyCall<?>>() {
-        @Override public Type responseType() {
-          return responseType;
-        }
-
-        @Override public <R> MyCall<R> adapt(Call<R> call) {
-          return new MyCallAdapter<>(call, callbackExecutor);
-        }
-      };
+    /**
+     * A callback which offers granular callbacks for various conditions.
+     */
+    interface MyCallback<T> {
+        /**
+         * Called for [200, 300) responses.
+         */
+        void success(Response<T> response);
+
+        /**
+         * Called for 401 responses.
+         */
+        void unauthenticated(Response<?> response);
+
+        /**
+         * Called for [400, 500) responses, except 401.
+         */
+        void clientError(Response<?> response);
+
+        /**
+         * Called for [500, 600) response.
+         */
+        void serverError(Response<?> response);
+
+        /**
+         * Called for network errors while making the call.
+         */
+        void networkError(IOException e);
+
+        /**
+         * Called for unexpected errors while making the call.
+         */
+        void unexpectedError(Throwable t);
     }
-  }
 
-  /** Adapts a {@link Call} to {@link MyCall}. */
-  static class MyCallAdapter<T> implements MyCall<T> {
-    private final Call<T> call;
-    private final Executor callbackExecutor;
+    interface MyCall<T> {
+        void cancel();
 
-    MyCallAdapter(Call<T> call, Executor callbackExecutor) {
-      this.call = call;
-      this.callbackExecutor = callbackExecutor;
+        void enqueue(MyCallback<T> callback);
+
+        MyCall<T> clone();
+
+        // Left as an exercise for the reader...
+        // TODO MyResponse<T> execute() throws MyHttpException;
     }
 
-    @Override public void cancel() {
-      call.cancel();
+    public static class ErrorHandlingCallAdapterFactory extends CallAdapter.Factory {
+        @Override
+        public CallAdapter<MyCall<?>> get(Type returnType, Annotation[] annotations,
+                                          Retrofit retrofit) {
+            if (getRawType(returnType) != MyCall.class) {
+                return null;
+            }
+            if (!(returnType instanceof ParameterizedType)) {
+                throw new IllegalStateException(
+                        "MyCall must have generic type (e.g., MyCall<ResponseBody>)");
+            }
+            final Type responseType = getParameterUpperBound(0, (ParameterizedType) returnType);
+            final Executor callbackExecutor = retrofit.callbackExecutor();
+            return new CallAdapter<MyCall<?>>() {
+                @Override
+                public Type responseType() {
+                    return responseType;
+                }
+
+                @Override
+                public <R> MyCall<R> adapt(Call<R> call) {
+                    return new MyCallAdapter<>(call, callbackExecutor);
+                }
+            };
+        }
     }
 
-    @Override public void enqueue(final MyCallback<T> callback) {
-      call.enqueue(new Callback<T>() {
-        @Override public void onResponse(Call<T> call, Response<T> response) {
-          // TODO if 'callbackExecutor' is not null, the 'callback' methods should be executed
-          // on that executor by submitting a Runnable. This is left as an exercise for the reader.
-
-          int code = response.code();
-          if (code >= 200 && code < 300) {
-            callback.success(response);
-          } else if (code == 401) {
-            callback.unauthenticated(response);
-          } else if (code >= 400 && code < 500) {
-            callback.clientError(response);
-          } else if (code >= 500 && code < 600) {
-            callback.serverError(response);
-          } else {
-            callback.unexpectedError(new RuntimeException("Unexpected response " + response));
-          }
+    /**
+     * Adapts a {@link Call} to {@link MyCall}.
+     */
+    static class MyCallAdapter<T> implements MyCall<T> {
+        private final Call<T> call;
+        private final Executor callbackExecutor;
+
+        MyCallAdapter(Call<T> call, Executor callbackExecutor) {
+            this.call = call;
+            this.callbackExecutor = callbackExecutor;
         }
 
-        @Override public void onFailure(Call<T> call, Throwable t) {
-          // TODO if 'callbackExecutor' is not null, the 'callback' methods should be executed
-          // on that executor by submitting a Runnable. This is left as an exercise for the reader.
+        @Override
+        public void cancel() {
+            call.cancel();
+        }
+
+        @Override
+        public void enqueue(final MyCallback<T> callback) {
+            call.enqueue(new Callback<T>() {
+                @Override
+                public void onResponse(Call<T> call, Response<T> response) {
+                    // TODO if 'callbackExecutor' is not null, the 'callback' methods should be executed
+                    // on that executor by submitting a Runnable. This is left as an exercise for the reader.
+
+                    int code = response.code();
+                    if (code >= 200 && code < 300) {
+                        callback.success(response);
+                    } else if (code == 401) {
+                        callback.unauthenticated(response);
+                    } else if (code >= 400 && code < 500) {
+                        callback.clientError(response);
+                    } else if (code >= 500 && code < 600) {
+                        callback.serverError(response);
+                    } else {
+                        callback.unexpectedError(new RuntimeException("Unexpected response " + response));
+                    }
+                }
+
+                @Override
+                public void onFailure(Call<T> call, Throwable t) {
+                    // TODO if 'callbackExecutor' is not null, the 'callback' methods should be executed
+                    // on that executor by submitting a Runnable. This is left as an exercise for the reader.
+
+                    if (t instanceof IOException) {
+                        callback.networkError((IOException) t);
+                    } else {
+                        callback.unexpectedError(t);
+                    }
+                }
+            });
+        }
 
-          if (t instanceof IOException) {
-            callback.networkError((IOException) t);
-          } else {
-            callback.unexpectedError(t);
-          }
+        @Override
+        public MyCall<T> clone() {
+            return new MyCallAdapter<>(call.clone(), callbackExecutor);
         }
-      });
     }
 
-    @Override public MyCall<T> clone() {
-      return new MyCallAdapter<>(call.clone(), callbackExecutor);
+    interface HttpBinService {
+        @GET("/ip")
+        MyCall<Ip> getIp();
+    }
+
+    static class Ip {
+        String origin;
+    }
+
+    public static void main(String... args) {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://httpbin.org")
+                .addCallAdapterFactory(new ErrorHandlingCallAdapterFactory())
+                .addConverterFactory(GsonConverterFactory.create())
+                .build();
+
+        HttpBinService service = retrofit.create(HttpBinService.class);
+        MyCall<Ip> ip = service.getIp();
+        ip.enqueue(new MyCallback<Ip>() {
+            @Override
+            public void success(Response<Ip> response) {
+                System.out.println("SUCCESS! " + response.body().origin);
+            }
+
+            @Override
+            public void unauthenticated(Response<?> response) {
+                System.out.println("UNAUTHENTICATED");
+            }
+
+            @Override
+            public void clientError(Response<?> response) {
+                System.out.println("CLIENT ERROR " + response.code() + " " + response.message());
+            }
+
+            @Override
+            public void serverError(Response<?> response) {
+                System.out.println("SERVER ERROR " + response.code() + " " + response.message());
+            }
+
+            @Override
+            public void networkError(IOException e) {
+                System.err.println("NETOWRK ERROR " + e.getMessage());
+            }
+
+            @Override
+            public void unexpectedError(Throwable t) {
+                System.err.println("FATAL ERROR " + t.getMessage());
+            }
+        });
     }
-  }
-
-  interface HttpBinService {
-    @GET("/ip")
-    MyCall<Ip> getIp();
-  }
-
-  static class Ip {
-    String origin;
-  }
-
-  public static void main(String... args) {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://httpbin.org")
-        .addCallAdapterFactory(new ErrorHandlingCallAdapterFactory())
-        .addConverterFactory(GsonConverterFactory.create())
-        .build();
-
-    HttpBinService service = retrofit.create(HttpBinService.class);
-    MyCall<Ip> ip = service.getIp();
-    ip.enqueue(new MyCallback<Ip>() {
-      @Override public void success(Response<Ip> response) {
-        System.out.println("SUCCESS! " + response.body().origin);
-      }
-
-      @Override public void unauthenticated(Response<?> response) {
-        System.out.println("UNAUTHENTICATED");
-      }
-
-      @Override public void clientError(Response<?> response) {
-        System.out.println("CLIENT ERROR " + response.code() + " " + response.message());
-      }
-
-      @Override public void serverError(Response<?> response) {
-        System.out.println("SERVER ERROR " + response.code() + " " + response.message());
-      }
-
-      @Override public void networkError(IOException e) {
-        System.err.println("NETOWRK ERROR " + e.getMessage());
-      }
-
-      @Override public void unexpectedError(Throwable t) {
-        System.err.println("FATAL ERROR " + t.getMessage());
-      }
-    });
-  }
 }
diff --git a/samples/src/main/java/com/example/retrofit/JsonAndXmlConverters.java b/samples/src/main/java/com/example/retrofit/JsonAndXmlConverters.java
index 2163f3dec..1f6759809 100644
--- a/samples/src/main/java/com/example/retrofit/JsonAndXmlConverters.java
+++ b/samples/src/main/java/com/example/retrofit/JsonAndXmlConverters.java
@@ -19,6 +19,7 @@
 import java.lang.annotation.Annotation;
 import java.lang.annotation.Retention;
 import java.lang.reflect.Type;
+
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import okhttp3.mockwebserver.MockResponse;
@@ -43,86 +44,90 @@
  * converter.
  */
 public final class JsonAndXmlConverters {
-  @Retention(RUNTIME)
-  @interface Json {
-  }
+    @Retention(RUNTIME)
+    @interface Json {
+    }
 
-  @Retention(RUNTIME)
-  @interface Xml {
-  }
+    @Retention(RUNTIME)
+    @interface Xml {
+    }
 
-  static class QualifiedTypeConverterFactory extends Converter.Factory {
-    private final Converter.Factory jsonFactory;
-    private final Converter.Factory xmlFactory;
+    static class QualifiedTypeConverterFactory extends Converter.Factory {
+        private final Converter.Factory jsonFactory;
+        private final Converter.Factory xmlFactory;
 
-    QualifiedTypeConverterFactory(Converter.Factory jsonFactory, Converter.Factory xmlFactory) {
-      this.jsonFactory = jsonFactory;
-      this.xmlFactory = xmlFactory;
-    }
+        QualifiedTypeConverterFactory(Converter.Factory jsonFactory, Converter.Factory xmlFactory) {
+            this.jsonFactory = jsonFactory;
+            this.xmlFactory = xmlFactory;
+        }
 
-    @Override
-    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-        Retrofit retrofit) {
-      for (Annotation annotation : annotations) {
-        if (annotation instanceof Json) {
-          return jsonFactory.responseBodyConverter(type, annotations, retrofit);
+        @Override
+        public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+                                                                Retrofit retrofit) {
+            for (Annotation annotation : annotations) {
+                if (annotation instanceof Json) {
+                    return jsonFactory.responseBodyConverter(type, annotations, retrofit);
+                }
+                if (annotation instanceof Xml) {
+                    return xmlFactory.responseBodyConverter(type, annotations, retrofit);
+                }
+            }
+            return null;
         }
-        if (annotation instanceof Xml) {
-          return xmlFactory.responseBodyConverter(type, annotations, retrofit);
+
+        @Override
+        public Converter<?, RequestBody> requestBodyConverter(Type type,
+                                                              Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+            for (Annotation annotation : parameterAnnotations) {
+                if (annotation instanceof Json) {
+                    return jsonFactory.requestBodyConverter(type, parameterAnnotations, methodAnnotations,
+                            retrofit);
+                }
+                if (annotation instanceof Xml) {
+                    return xmlFactory.requestBodyConverter(type, parameterAnnotations, methodAnnotations,
+                            retrofit);
+                }
+            }
+            return null;
         }
-      }
-      return null;
     }
 
-    @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
-        Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
-      for (Annotation annotation : parameterAnnotations) {
-        if (annotation instanceof Json) {
-          return jsonFactory.requestBodyConverter(type, parameterAnnotations, methodAnnotations,
-              retrofit);
-        }
-        if (annotation instanceof Xml) {
-          return xmlFactory.requestBodyConverter(type, parameterAnnotations, methodAnnotations,
-              retrofit);
-        }
-      }
-      return null;
+    @Default(value = DefaultType.FIELD)
+    static class User {
+        @Attribute
+        public String name;
+    }
+
+    interface Service {
+        @GET("/")
+        @Json
+        Call<User> exampleJson();
+
+        @GET("/")
+        @Xml
+        Call<User> exampleXml();
+    }
+
+    public static void main(String... args) throws IOException {
+        MockWebServer server = new MockWebServer();
+        server.start();
+        server.enqueue(new MockResponse().setBody("{\"name\": \"Jason\"}"));
+        server.enqueue(new MockResponse().setBody("<user name=\"Eximel\"/>"));
+
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new QualifiedTypeConverterFactory(
+                        GsonConverterFactory.create(),
+                        SimpleXmlConverterFactory.create()))
+                .build();
+        Service service = retrofit.create(Service.class);
+
+        User user1 = service.exampleJson().execute().body();
+        System.out.println("User 1: " + user1.name);
+
+        User user2 = service.exampleXml().execute().body();
+        System.out.println("User 2: " + user2.name);
+
+        server.shutdown();
     }
-  }
-
-  @Default(value = DefaultType.FIELD)
-  static class User {
-    @Attribute
-    public String name;
-  }
-
-  interface Service {
-    @GET("/") @Json
-    Call<User> exampleJson();
-    @GET("/") @Xml
-    Call<User> exampleXml();
-  }
-
-  public static void main(String... args) throws IOException {
-    MockWebServer server = new MockWebServer();
-    server.start();
-    server.enqueue(new MockResponse().setBody("{\"name\": \"Jason\"}"));
-    server.enqueue(new MockResponse().setBody("<user name=\"Eximel\"/>"));
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new QualifiedTypeConverterFactory(
-            GsonConverterFactory.create(),
-            SimpleXmlConverterFactory.create()))
-        .build();
-    Service service = retrofit.create(Service.class);
-
-    User user1 = service.exampleJson().execute().body();
-    System.out.println("User 1: " + user1.name);
-
-    User user2 = service.exampleXml().execute().body();
-    System.out.println("User 2: " + user2.name);
-
-    server.shutdown();
-  }
 }
diff --git a/samples/src/main/java/com/example/retrofit/JsonQueryParameters.java b/samples/src/main/java/com/example/retrofit/JsonQueryParameters.java
index bc29f8355..c24b6ee7d 100644
--- a/samples/src/main/java/com/example/retrofit/JsonQueryParameters.java
+++ b/samples/src/main/java/com/example/retrofit/JsonQueryParameters.java
@@ -19,6 +19,7 @@
 import java.lang.annotation.Annotation;
 import java.lang.annotation.Retention;
 import java.lang.reflect.Type;
+
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import okhttp3.mockwebserver.MockResponse;
@@ -36,79 +37,81 @@
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 public final class JsonQueryParameters {
-  @Retention(RUNTIME)
-  @interface Json {
-  }
+    @Retention(RUNTIME)
+    @interface Json {
+    }
 
-  static class JsonStringConverterFactory extends Converter.Factory {
-    private final Converter.Factory delegateFactory;
+    static class JsonStringConverterFactory extends Converter.Factory {
+        private final Converter.Factory delegateFactory;
 
-    JsonStringConverterFactory(Converter.Factory delegateFactory) {
-      this.delegateFactory = delegateFactory;
-    }
+        JsonStringConverterFactory(Converter.Factory delegateFactory) {
+            this.delegateFactory = delegateFactory;
+        }
 
-    @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
-        Retrofit retrofit) {
-      for (Annotation annotation : annotations) {
-        if (annotation instanceof Json) {
-          // NOTE: If you also have a JSON converter factory installed in addition to this factory,
-          // you can call retrofit.requestBodyConverter(type, annotations) instead of having a
-          // reference to it explicitly as a field.
-          Converter<?, RequestBody> delegate =
-              delegateFactory.requestBodyConverter(type, annotations, new Annotation[0], retrofit);
-          return new DelegateToStringConverter<>(delegate);
+        @Override
+        public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+                                                    Retrofit retrofit) {
+            for (Annotation annotation : annotations) {
+                if (annotation instanceof Json) {
+                    // NOTE: If you also have a JSON converter factory installed in addition to this factory,
+                    // you can call retrofit.requestBodyConverter(type, annotations) instead of having a
+                    // reference to it explicitly as a field.
+                    Converter<?, RequestBody> delegate =
+                            delegateFactory.requestBodyConverter(type, annotations, new Annotation[0], retrofit);
+                    return new DelegateToStringConverter<>(delegate);
+                }
+            }
+            return null;
+        }
+
+        static class DelegateToStringConverter<T> implements Converter<T, String> {
+            private final Converter<T, RequestBody> delegate;
+
+            DelegateToStringConverter(Converter<T, RequestBody> delegate) {
+                this.delegate = delegate;
+            }
+
+            @Override
+            public String convert(T value) throws IOException {
+                Buffer buffer = new Buffer();
+                delegate.convert(value).writeTo(buffer);
+                return buffer.readUtf8();
+            }
         }
-      }
-      return null;
     }
 
-    static class DelegateToStringConverter<T> implements Converter<T, String> {
-      private final Converter<T, RequestBody> delegate;
+    static class Filter {
+        public final String userId;
 
-      DelegateToStringConverter(Converter<T, RequestBody> delegate) {
-        this.delegate = delegate;
-      }
+        public Filter(String userId) {
+            this.userId = userId;
+        }
+    }
 
-      @Override public String convert(T value) throws IOException {
-        Buffer buffer = new Buffer();
-        delegate.convert(value).writeTo(buffer);
-        return buffer.readUtf8();
-      }
+    interface Service {
+        @GET("/filter")
+        Call<ResponseBody> example(@Json @Query("value") Filter value);
     }
-  }
 
-  static class Filter {
-    public final String userId;
+    public static void main(String... args) throws IOException, InterruptedException {
+        MockWebServer server = new MockWebServer();
+        server.start();
+        server.enqueue(new MockResponse());
+
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new JsonStringConverterFactory(GsonConverterFactory.create()))
+                .build();
+        Service service = retrofit.create(Service.class);
+
+        Call<ResponseBody> call = service.example(new Filter("123"));
+        Response<ResponseBody> response = call.execute();
+        // TODO handle user response...
+
+        // Print the request path that the server saw to show the JSON query param:
+        RecordedRequest recordedRequest = server.takeRequest();
+        System.out.println(recordedRequest.getPath());
 
-    public Filter(String userId) {
-      this.userId = userId;
+        server.shutdown();
     }
-  }
-
-  interface Service {
-    @GET("/filter")
-    Call<ResponseBody> example(@Json @Query("value") Filter value);
-  }
-
-  public static void main(String... args) throws IOException, InterruptedException {
-    MockWebServer server = new MockWebServer();
-    server.start();
-    server.enqueue(new MockResponse());
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new JsonStringConverterFactory(GsonConverterFactory.create()))
-        .build();
-    Service service = retrofit.create(Service.class);
-
-    Call<ResponseBody> call = service.example(new Filter("123"));
-    Response<ResponseBody> response = call.execute();
-    // TODO handle user response...
-
-    // Print the request path that the server saw to show the JSON query param:
-    RecordedRequest recordedRequest = server.takeRequest();
-    System.out.println(recordedRequest.getPath());
-
-    server.shutdown();
-  }
 }
