diff --git a/CONTRIBUTING.md b/.github/CONTRIBUTING.md
similarity index 100%
rename from CONTRIBUTING.md
rename to .github/CONTRIBUTING.md
diff --git a/.github/ISSUE_TEMPLATE.md b/.github/ISSUE_TEMPLATE.md
new file mode 100644
index 000000000..85c3e77b7
--- /dev/null
+++ b/.github/ISSUE_TEMPLATE.md
@@ -0,0 +1,12 @@
+What kind of issue is this?
+
+ - [ ] Question. This issue tracker is not the place for questions. If you want to ask how to do
+       something, or to understand why something isn't working the way you expect it to, use Stack
+       Overflow. https://stackoverflow.com/questions/tagged/retrofit
+
+ - [ ] Bug report. If you’ve found a bug, spend the time to write a failing test. Bugs with tests
+       get fixed. Here’s an example: https://gist.github.com/swankjesse/6608b4713ad80988cdc9
+
+ - [ ] Feature Request. Start by telling us what problem you’re trying to solve. Often a solution
+       already exists! Don’t send pull requests to implement new features without first getting our
+       support. Sometimes we leave features out on purpose to keep the project small.
diff --git a/CHANGELOG.md b/CHANGELOG.md
index a8fef71ff..a75225a80 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,6 +1,32 @@
 Change Log
 ==========
 
+Version 2.0.0-beta4 *(2016-02-04)*
+----------------------------------
+
+ * New: `Call` instance is now passed to both `onResponse` and `onFailure` methods of `Callback`. This aids
+   in detecting when `onFailure` is called as a result of `Call.cancel()` by checking `Call.isCanceled()`.
+ * New: `Call.request()` returns (optionally creating) the `Request` object for the call. Note: If this is
+   called before `Call.execute()` or `Call.enqueue()` this will do relatively expensive work synchronously.
+   Doing so in performance-critical sections (like on the Android main thread) should be avoided.
+ * New: Support for the release version of OkHttp 3.0 and newer.
+ * New: `adapter-guava` module provides a `CallAdapter.Factory` for Guava's `ListenableFuture`.
+ * New: `adapter-java8` module provides a `CallAdapter.Factory` for Java 8's `CompleteableFuture`.
+ * New: `ScalarsConverterFactory` (from `converter-scalars` module) now supports parsing response bodies
+   into either `String`, the 8 primitive types, or the 8 boxed primitive types.
+ * New: Automatic support for sending callbacks to the iOS main thread when running via RoboVM.
+ * New: Method annotations are now passed to the factory for request body converters. This allows converters
+   to alter the structure of both request bodies and response bodies with a single method-level annotation.
+ * Each converter has been moved to its own package under `retrofit2.converter.<name>`. This prevents type
+   collisions when many converters are simultaneously in use.
+ * Fix: Exceptions thrown when unable to locate a `CallAdapter.Factory` for a method return type now
+   correctly list the `CallAdapter.Factory` instances checked.
+ * Fix: Ensure default methods on service interfaces can be invoked.
+ * Fix: Correctly resolve the generic parameter types of collection interfaces when subclasses of those
+   collections are used as method parameters.
+ * Fix: Do not encode `/` characters in `@Path` replacements when `encoded = true`.
+
+
 Version 2.0.0-beta3 *(2016-01-05)*
 ----------------------------------
 
@@ -22,7 +48,7 @@ Version 2.0.0-beta3 *(2016-01-05)*
    `client(OkHttpClient)` method on `Retrofit.Builder` still exists as a convenience.
  * New: `isExecuted()` method returns whether a `Call` has been synchronously or asynchronously executed.
  * New: `isCanceled()` method returns whether a `Call` has been canceled. Use this in `onFailure` to determine
-   whether the callback was invoked from cancelation or actual transport failure.
+   whether the callback was invoked from cancellation or actual transport failure.
  * New: `converter-scalars` module provides a `Converter.Factory` for converting `String`, the 8 primitive
    types, and the 8 boxed primitive types as `text/plain` bodies. Install this before your normal converter
    to avoid passing these simple scalars through, for example, a JSON converter.
diff --git a/README.md b/README.md
index 313c353a8..2d3ddcf9a 100644
--- a/README.md
+++ b/README.md
@@ -14,12 +14,12 @@ Download [the latest JAR][2] or grab via Maven:
 <dependency>
   <groupId>com.squareup.retrofit2</groupId>
   <artifactId>retrofit</artifactId>
-  <version>2.0.0-beta3</version>
+  <version>2.0.0-beta4</version>
 </dependency>
 ```
 or Gradle:
 ```groovy
-compile 'com.squareup.retrofit2:retrofit:2.0.0-beta3'
+compile 'com.squareup.retrofit2:retrofit:2.0.0-beta4'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/checkstyle.xml b/checkstyle.xml
index ceb1d5cdf..a729c26a7 100644
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -4,7 +4,9 @@
     "http://www.puppycrawl.com/dtds/configuration_1_2.dtd">
 
 <module name="Checker">
-    <module name="NewlineAtEndOfFile"/>
+    <module name="NewlineAtEndOfFile">
+        <property name="lineSeparator" value="lf" />
+    </module>
     <module name="FileLength"/>
     <module name="FileTabCharacter"/>
 
diff --git a/pom.xml b/pom.xml
index f9016a72c..a2206239d 100644
--- a/pom.xml
+++ b/pom.xml
@@ -49,19 +49,19 @@
 
     <!-- Dependencies -->
     <android.version>4.1.1.4</android.version>
-    <okhttp.version>3.0.1</okhttp.version>
+    <okhttp.version>3.1.2</okhttp.version>
     <animal.sniffer.version>1.14</animal.sniffer.version>
 
     <!-- Adapter Dependencies -->
-    <rxjava.version>1.1.0</rxjava.version>
+    <rxjava.version>1.1.1</rxjava.version>
 
     <!-- Converter Dependencies -->
-    <gson.version>2.4</gson.version>
+    <gson.version>2.6.1</gson.version>
     <protobuf.version>2.5.0</protobuf.version>
-    <jackson.version>2.4.3</jackson.version>
-    <wire.version>2.0.0</wire.version>
+    <jackson.version>2.7.1</jackson.version>
+    <wire.version>2.1.0</wire.version>
     <simplexml.version>2.7.1</simplexml.version>
-    <moshi.version>1.0.0</moshi.version>
+    <moshi.version>1.1.0</moshi.version>
 
     <!-- Test Dependencies -->
     <junit.version>4.12</junit.version>
diff --git a/retrofit-adapters/guava/pom.xml b/retrofit-adapters/guava/pom.xml
new file mode 100644
index 000000000..214c7ba8c
--- /dev/null
+++ b/retrofit-adapters/guava/pom.xml
@@ -0,0 +1,43 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.retrofit2</groupId>
+    <artifactId>retrofit-adapters</artifactId>
+    <version>2.0.0-SNAPSHOT</version>
+    <relativePath>../pom.xml</relativePath>
+  </parent>
+
+  <artifactId>adapter-guava</artifactId>
+  <name>Adapter: Guava</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>retrofit</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.assertj</groupId>
+      <artifactId>assertj-core</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp3</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+</project>
diff --git a/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/GuavaCallAdapterFactory.java b/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/GuavaCallAdapterFactory.java
new file mode 100644
index 000000000..1404da028
--- /dev/null
+++ b/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/GuavaCallAdapterFactory.java
@@ -0,0 +1,129 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.guava;
+
+import com.google.common.util.concurrent.AbstractFuture;
+import com.google.common.util.concurrent.ListenableFuture;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import retrofit2.Call;
+import retrofit2.CallAdapter;
+import retrofit2.Callback;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+
+public final class GuavaCallAdapterFactory extends CallAdapter.Factory {
+  public static GuavaCallAdapterFactory create() {
+    return new GuavaCallAdapterFactory();
+  }
+
+  private GuavaCallAdapterFactory() {
+  }
+
+  @Override
+  public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+    if (getRawType(returnType) != ListenableFuture.class) {
+      return null;
+    }
+    if (!(returnType instanceof ParameterizedType)) {
+      throw new IllegalStateException("ListenableFuture return type must be parameterized"
+          + " as ListenableFuture<Foo> or ListenableFuture<? extends Foo>");
+    }
+    Type innerType = getParameterUpperBound(0, (ParameterizedType) returnType);
+
+    if (getRawType(innerType) != Response.class) {
+      // Generic type is not Response<T>. Use it for body-only adapter.
+      return new BodyCallAdapter(innerType);
+    }
+
+    // Generic type is Response<T>. Extract T and create the Response version of the adapter.
+    if (!(innerType instanceof ParameterizedType)) {
+      throw new IllegalStateException("Response must be parameterized"
+          + " as Response<Foo> or Response<? extends Foo>");
+    }
+    Type responseType = getParameterUpperBound(0, (ParameterizedType) innerType);
+    return new ResponseCallAdapter(responseType);
+  }
+
+  private static class BodyCallAdapter implements CallAdapter<ListenableFuture<?>> {
+    private final Type responseType;
+
+    BodyCallAdapter(Type responseType) {
+      this.responseType = responseType;
+    }
+
+    @Override public Type responseType() {
+      return responseType;
+    }
+
+    @Override public <R> ListenableFuture<R> adapt(final Call<R> call) {
+      return new AbstractFuture<R>() {
+        {
+          call.enqueue(new Callback<R>() {
+            @Override public void onResponse(Call<R> call, Response<R> response) {
+              if (response.isSuccess()) {
+                set(response.body());
+              } else {
+                setException(new HttpException(response));
+              }
+            }
+
+            @Override public void onFailure(Call<R> call, Throwable t) {
+              setException(t);
+            }
+          });
+        }
+
+        @Override protected void interruptTask() {
+          call.cancel();
+        }
+      };
+    }
+  }
+
+  private static class ResponseCallAdapter implements CallAdapter<ListenableFuture<?>> {
+    private final Type responseType;
+
+    ResponseCallAdapter(Type responseType) {
+      this.responseType = responseType;
+    }
+
+    @Override public Type responseType() {
+      return responseType;
+    }
+
+    @Override public <R> ListenableFuture<Response<R>> adapt(final Call<R> call) {
+      return new AbstractFuture<Response<R>>() {
+        {
+          call.enqueue(new Callback<R>() {
+            @Override public void onResponse(Call<R> call, Response<R> response) {
+              set(response);
+            }
+
+            @Override public void onFailure(Call<R> call, Throwable t) {
+              setException(t);
+            }
+          });
+        }
+
+        @Override protected void interruptTask() {
+          call.cancel();
+        }
+      };
+    }
+  }
+}
diff --git a/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/HttpException.java b/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/HttpException.java
new file mode 100644
index 000000000..f18a81955
--- /dev/null
+++ b/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/HttpException.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.guava;
+
+import retrofit2.Response;
+
+/** Exception for an unexpected, non-2xx HTTP response. */
+public final class HttpException extends Exception {
+  private final int code;
+  private final String message;
+  private final transient Response<?> response;
+
+  public HttpException(Response<?> response) {
+    super("HTTP " + response.code() + " " + response.message());
+    this.code = response.code();
+    this.message = response.message();
+    this.response = response;
+  }
+
+  /** HTTP status code. */
+  public int code() {
+    return code;
+  }
+
+  /** HTTP status message. */
+  public String message() {
+    return message;
+  }
+
+  /**
+   * The full HTTP response. This may be null if the exception was serialized.
+   */
+  public Response<?> response() {
+    return response;
+  }
+}
diff --git a/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/GuavaCallAdapterFactoryTest.java b/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/GuavaCallAdapterFactoryTest.java
new file mode 100644
index 000000000..62d449eb9
--- /dev/null
+++ b/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/GuavaCallAdapterFactoryTest.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.guava;
+
+import com.google.common.reflect.TypeToken;
+import com.google.common.util.concurrent.ListenableFuture;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import java.util.List;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.CallAdapter;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class GuavaCallAdapterFactoryTest {
+  private static final Annotation[] NO_ANNOTATIONS = new Annotation[0];
+
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private final CallAdapter.Factory factory = GuavaCallAdapterFactory.create();
+  private Retrofit retrofit;
+
+  @Before public void setUp() {
+    retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(factory)
+        .build();
+  }
+
+  @Test public void responseType() {
+    Type bodyClass = new TypeToken<ListenableFuture<String>>() {}.getType();
+    assertThat(factory.get(bodyClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type bodyWildcard = new TypeToken<ListenableFuture<? extends String>>() {}.getType();
+    assertThat(factory.get(bodyWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type bodyGeneric = new TypeToken<ListenableFuture<List<String>>>() {}.getType();
+    assertThat(factory.get(bodyGeneric, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(new TypeToken<List<String>>() {}.getType());
+    Type responseClass = new TypeToken<ListenableFuture<Response<String>>>() {}.getType();
+    assertThat(factory.get(responseClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type responseWildcard = new TypeToken<ListenableFuture<Response<? extends String>>>() {}.getType();
+    assertThat(factory.get(responseWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type resultClass = new TypeToken<ListenableFuture<Response<String>>>() {}.getType();
+    assertThat(factory.get(resultClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type resultWildcard = new TypeToken<ListenableFuture<Response<? extends String>>>() {}.getType();
+    assertThat(factory.get(resultWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+  }
+
+  @Test public void nonListenableFutureReturnsNull() {
+    CallAdapter<?> adapter = factory.get(String.class, NO_ANNOTATIONS, retrofit);
+    assertThat(adapter).isNull();
+  }
+
+  @Test public void rawTypeThrows() {
+    Type observableType = new TypeToken<ListenableFuture>() {}.getType();
+    try {
+      factory.get(observableType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "ListenableFuture return type must be parameterized as ListenableFuture<Foo> or ListenableFuture<? extends Foo>");
+    }
+  }
+
+  @Test public void rawResponseTypeThrows() {
+    Type observableType = new TypeToken<ListenableFuture<Response>>() {}.getType();
+    try {
+      factory.get(observableType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Response must be parameterized as Response<Foo> or Response<? extends Foo>");
+    }
+  }
+}
diff --git a/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/ListenableFutureTest.java b/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/ListenableFutureTest.java
new file mode 100644
index 000000000..b87b9f24b
--- /dev/null
+++ b/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/ListenableFutureTest.java
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.guava;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import java.io.IOException;
+import java.util.concurrent.ExecutionException;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class ListenableFutureTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  interface Service {
+    @GET("/") ListenableFuture<String> body();
+    @GET("/") ListenableFuture<Response<String>> response();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(GuavaCallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodySuccess200() throws Exception {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    ListenableFuture<String> future = service.body();
+    assertThat(future.get()).isEqualTo("Hi");
+  }
+
+  @Test public void bodySuccess404() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    ListenableFuture<String> future = service.body();
+    try {
+      future.get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).isInstanceOf(HttpException.class)
+          .hasMessage("HTTP 404 Client Error");
+    }
+  }
+
+  @Test public void bodyFailure() throws Exception {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    ListenableFuture<String> future = service.body();
+    try {
+      future.get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).isInstanceOf(IOException.class);
+    }
+  }
+
+  @Test public void responseSuccess200() throws Exception {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    ListenableFuture<Response<String>> future = service.response();
+    Response<String> response = future.get();
+    assertThat(response.isSuccess()).isTrue();
+    assertThat(response.body()).isEqualTo("Hi");
+  }
+
+  @Test public void responseSuccess404() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
+
+    ListenableFuture<Response<String>> future = service.response();
+    Response<String> response = future.get();
+    assertThat(response.isSuccess()).isFalse();
+    assertThat(response.errorBody().string()).isEqualTo("Hi");
+  }
+
+  @Test public void responseFailure() throws Exception {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    ListenableFuture<Response<String>> future = service.response();
+    try {
+      future.get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).isInstanceOf(IOException.class);
+    }
+  }
+}
diff --git a/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/StringConverterFactory.java b/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/StringConverterFactory.java
new file mode 100644
index 000000000..bb9ccf189
--- /dev/null
+++ b/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/StringConverterFactory.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.guava;
+
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import okhttp3.MediaType;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
+
+final class StringConverterFactory extends Converter.Factory {
+  @Override
+  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
+    return new Converter<ResponseBody, String>() {
+      @Override public String convert(ResponseBody value) throws IOException {
+        return value.string();
+      }
+    };
+  }
+
+  @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
+      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+    return new Converter<String, RequestBody>() {
+      @Override public RequestBody convert(String value) throws IOException {
+        return RequestBody.create(MediaType.parse("text/plain"), value);
+      }
+    };
+  }
+}
diff --git a/retrofit-adapters/java8/pom.xml b/retrofit-adapters/java8/pom.xml
new file mode 100644
index 000000000..7186177b1
--- /dev/null
+++ b/retrofit-adapters/java8/pom.xml
@@ -0,0 +1,65 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.retrofit2</groupId>
+    <artifactId>retrofit-adapters</artifactId>
+    <version>2.0.0-SNAPSHOT</version>
+    <relativePath>../pom.xml</relativePath>
+  </parent>
+
+  <artifactId>adapter-java8</artifactId>
+  <name>Adapter: Java 8</name>
+
+  <properties>
+    <java.version>1.8</java.version>
+  </properties>
+
+  <dependencies>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>retrofit</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.assertj</groupId>
+      <artifactId>assertj-core</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp3</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.codehaus.mojo</groupId>
+        <artifactId>animal-sniffer-maven-plugin</artifactId>
+        <version>${animal.sniffer.version}</version>
+        <configuration>
+          <signature>
+            <groupId>org.kaazing.mojo.signature</groupId>
+            <artifactId>java18</artifactId>
+            <version>1.0</version>
+          </signature>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
diff --git a/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/HttpException.java b/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/HttpException.java
new file mode 100644
index 000000000..022fa9848
--- /dev/null
+++ b/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/HttpException.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.java8;
+
+import retrofit2.Response;
+
+/** Exception for an unexpected, non-2xx HTTP response. */
+public final class HttpException extends Exception {
+  private final int code;
+  private final String message;
+  private final transient Response<?> response;
+
+  public HttpException(Response<?> response) {
+    super("HTTP " + response.code() + " " + response.message());
+    this.code = response.code();
+    this.message = response.message();
+    this.response = response;
+  }
+
+  /** HTTP status code. */
+  public int code() {
+    return code;
+  }
+
+  /** HTTP status message. */
+  public String message() {
+    return message;
+  }
+
+  /**
+   * The full HTTP response. This may be null if the exception was serialized.
+   */
+  public Response<?> response() {
+    return response;
+  }
+}
diff --git a/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/Java8CallAdapterFactory.java b/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/Java8CallAdapterFactory.java
new file mode 100644
index 000000000..e94e7495d
--- /dev/null
+++ b/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/Java8CallAdapterFactory.java
@@ -0,0 +1,134 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.java8;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.util.concurrent.CompletableFuture;
+import retrofit2.Call;
+import retrofit2.CallAdapter;
+import retrofit2.Callback;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+
+public final class Java8CallAdapterFactory extends CallAdapter.Factory {
+  public static Java8CallAdapterFactory create() {
+    return new Java8CallAdapterFactory();
+  }
+
+  private Java8CallAdapterFactory() {
+  }
+
+  @Override
+  public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+    if (getRawType(returnType) != CompletableFuture.class) {
+      return null;
+    }
+    if (!(returnType instanceof ParameterizedType)) {
+      throw new IllegalStateException("CompletableFuture return type must be parameterized"
+          + " as CompletableFuture<Foo> or CompletableFuture<? extends Foo>");
+    }
+    Type innerType = getParameterUpperBound(0, (ParameterizedType) returnType);
+
+    if (getRawType(innerType) != Response.class) {
+      // Generic type is not Response<T>. Use it for body-only adapter.
+      return new BodyCallAdapter(innerType);
+    }
+
+    // Generic type is Response<T>. Extract T and create the Response version of the adapter.
+    if (!(innerType instanceof ParameterizedType)) {
+      throw new IllegalStateException("Response must be parameterized"
+          + " as Response<Foo> or Response<? extends Foo>");
+    }
+    Type responseType = getParameterUpperBound(0, (ParameterizedType) innerType);
+    return new ResponseCallAdapter(responseType);
+  }
+
+  private static class BodyCallAdapter implements CallAdapter<CompletableFuture<?>> {
+    private final Type responseType;
+
+    BodyCallAdapter(Type responseType) {
+      this.responseType = responseType;
+    }
+
+    @Override public Type responseType() {
+      return responseType;
+    }
+
+    @Override public <R> CompletableFuture<R> adapt(final Call<R> call) {
+      final CompletableFuture<R> future = new CompletableFuture<R>() {
+        @Override public boolean cancel(boolean mayInterruptIfRunning) {
+          if (mayInterruptIfRunning) {
+            call.cancel();
+          }
+          return super.cancel(mayInterruptIfRunning);
+        }
+      };
+
+      call.enqueue(new Callback<R>() {
+        @Override public void onResponse(Call<R> call, Response<R> response) {
+          if (response.isSuccess()) {
+            future.complete(response.body());
+          } else {
+            future.completeExceptionally(new HttpException(response));
+          }
+        }
+
+        @Override public void onFailure(Call<R> call, Throwable t) {
+          future.completeExceptionally(t);
+        }
+      });
+
+      return future;
+    }
+  }
+
+  private static class ResponseCallAdapter implements CallAdapter<CompletableFuture<?>> {
+    private final Type responseType;
+
+    ResponseCallAdapter(Type responseType) {
+      this.responseType = responseType;
+    }
+
+    @Override public Type responseType() {
+      return responseType;
+    }
+
+    @Override public <R> CompletableFuture<Response<R>> adapt(final Call<R> call) {
+      final CompletableFuture<Response<R>> future = new CompletableFuture<Response<R>>() {
+        @Override public boolean cancel(boolean mayInterruptIfRunning) {
+          if (mayInterruptIfRunning) {
+            call.cancel();
+          }
+          return super.cancel(mayInterruptIfRunning);
+        }
+      };
+
+      call.enqueue(new Callback<R>() {
+        @Override public void onResponse(Call<R> call, Response<R> response) {
+          future.complete(response);
+        }
+
+        @Override public void onFailure(Call<R> call, Throwable t) {
+          future.completeExceptionally(t);
+        }
+      });
+
+      return future;
+    }
+  }
+}
diff --git a/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/CompletableFutureTest.java b/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/CompletableFutureTest.java
new file mode 100644
index 000000000..76bbc01c3
--- /dev/null
+++ b/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/CompletableFutureTest.java
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.java8;
+
+import java.io.IOException;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ExecutionException;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class CompletableFutureTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  interface Service {
+    @GET("/") CompletableFuture<String> body();
+    @GET("/") CompletableFuture<Response<String>> response();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(Java8CallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodySuccess200() throws Exception {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    CompletableFuture<String> future = service.body();
+    assertThat(future.get()).isEqualTo("Hi");
+  }
+
+  @Test public void bodySuccess404() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    CompletableFuture<String> future = service.body();
+    try {
+      future.get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).isInstanceOf(HttpException.class)
+          .hasMessage("HTTP 404 Client Error");
+    }
+  }
+
+  @Test public void bodyFailure() throws Exception {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    CompletableFuture<String> future = service.body();
+    try {
+      future.get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).isInstanceOf(IOException.class);
+    }
+  }
+
+  @Test public void responseSuccess200() throws Exception {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    CompletableFuture<Response<String>> future = service.response();
+    Response<String> response = future.get();
+    assertThat(response.isSuccess()).isTrue();
+    assertThat(response.body()).isEqualTo("Hi");
+  }
+
+  @Test public void responseSuccess404() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
+
+    CompletableFuture<Response<String>> future = service.response();
+    Response<String> response = future.get();
+    assertThat(response.isSuccess()).isFalse();
+    assertThat(response.errorBody().string()).isEqualTo("Hi");
+  }
+
+  @Test public void responseFailure() throws Exception {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    CompletableFuture<Response<String>> future = service.response();
+    try {
+      future.get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).isInstanceOf(IOException.class);
+    }
+  }
+}
diff --git a/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/Java8CallAdapterFactoryTest.java b/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/Java8CallAdapterFactoryTest.java
new file mode 100644
index 000000000..89d2b9537
--- /dev/null
+++ b/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/Java8CallAdapterFactoryTest.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.java8;
+
+import com.google.common.reflect.TypeToken;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import java.util.List;
+import java.util.concurrent.CompletableFuture;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.CallAdapter;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class Java8CallAdapterFactoryTest {
+  private static final Annotation[] NO_ANNOTATIONS = new Annotation[0];
+
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private final CallAdapter.Factory factory = Java8CallAdapterFactory.create();
+  private Retrofit retrofit;
+
+  @Before public void setUp() {
+    retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(factory)
+        .build();
+  }
+
+  @Test public void responseType() {
+    Type bodyClass = new TypeToken<CompletableFuture<String>>() {}.getType();
+    assertThat(factory.get(bodyClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type bodyWildcard = new TypeToken<CompletableFuture<? extends String>>() {}.getType();
+    assertThat(factory.get(bodyWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type bodyGeneric = new TypeToken<CompletableFuture<List<String>>>() {}.getType();
+    assertThat(factory.get(bodyGeneric, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(new TypeToken<List<String>>() {}.getType());
+    Type responseClass = new TypeToken<CompletableFuture<Response<String>>>() {}.getType();
+    assertThat(factory.get(responseClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type responseWildcard = new TypeToken<CompletableFuture<Response<? extends String>>>() {}.getType();
+    assertThat(factory.get(responseWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type resultClass = new TypeToken<CompletableFuture<Response<String>>>() {}.getType();
+    assertThat(factory.get(resultClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type resultWildcard = new TypeToken<CompletableFuture<Response<? extends String>>>() {}.getType();
+    assertThat(factory.get(resultWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+  }
+
+  @Test public void nonListenableFutureReturnsNull() {
+    CallAdapter<?> adapter = factory.get(String.class, NO_ANNOTATIONS, retrofit);
+    assertThat(adapter).isNull();
+  }
+
+  @Test public void rawTypeThrows() {
+    Type observableType = new TypeToken<CompletableFuture>() {}.getType();
+    try {
+      factory.get(observableType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "CompletableFuture return type must be parameterized as CompletableFuture<Foo> or CompletableFuture<? extends Foo>");
+    }
+  }
+
+  @Test public void rawResponseTypeThrows() {
+    Type observableType = new TypeToken<CompletableFuture<Response>>() {}.getType();
+    try {
+      factory.get(observableType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Response must be parameterized as Response<Foo> or Response<? extends Foo>");
+    }
+  }
+}
diff --git a/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/StringConverterFactory.java b/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/StringConverterFactory.java
new file mode 100644
index 000000000..de4b63e61
--- /dev/null
+++ b/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/StringConverterFactory.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.java8;
+
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import okhttp3.MediaType;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
+
+final class StringConverterFactory extends Converter.Factory {
+  @Override
+  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
+    return new Converter<ResponseBody, String>() {
+      @Override public String convert(ResponseBody value) throws IOException {
+        return value.string();
+      }
+    };
+  }
+
+  @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
+      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+    return new Converter<String, RequestBody>() {
+      @Override public RequestBody convert(String value) throws IOException {
+        return RequestBody.create(MediaType.parse("text/plain"), value);
+      }
+    };
+  }
+}
diff --git a/retrofit-adapters/pom.xml b/retrofit-adapters/pom.xml
index 8a677d359..5efb36b58 100644
--- a/retrofit-adapters/pom.xml
+++ b/retrofit-adapters/pom.xml
@@ -15,6 +15,8 @@
   <packaging>pom</packaging>
 
   <modules>
+    <module>guava</module>
+    <module>java8</module>
     <module>rxjava</module>
   </modules>
 </project>
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/CompletableHelper.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/CompletableHelper.java
new file mode 100644
index 000000000..8e99c96ec
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/CompletableHelper.java
@@ -0,0 +1,92 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import java.lang.reflect.Type;
+import retrofit2.Call;
+import retrofit2.CallAdapter;
+import retrofit2.Response;
+import rx.Completable;
+import rx.Completable.CompletableOnSubscribe;
+import rx.Completable.CompletableSubscriber;
+import rx.Scheduler;
+import rx.Subscription;
+import rx.exceptions.Exceptions;
+import rx.functions.Action0;
+import rx.subscriptions.Subscriptions;
+
+final class CompletableHelper {
+  static CallAdapter<Completable> createCallAdapter(Scheduler scheduler) {
+    return new CompletableCallAdapter(scheduler);
+  }
+
+  private static final class CompletableCallOnSubscribe implements CompletableOnSubscribe {
+    private final Call originalCall;
+
+    CompletableCallOnSubscribe(Call originalCall) {
+      this.originalCall = originalCall;
+    }
+
+    @Override public void call(CompletableSubscriber subscriber) {
+      // Since Call is a one-shot type, clone it for each new subscriber.
+      final Call call = originalCall.clone();
+
+      // Attempt to cancel the call if it is still in-flight on unsubscription.
+      Subscription subscription = Subscriptions.create(new Action0() {
+        @Override public void call() {
+          call.cancel();
+        }
+      });
+      subscriber.onSubscribe(subscription);
+
+      try {
+        Response response = call.execute();
+        if (!subscription.isUnsubscribed()) {
+          if (response.isSuccess()) {
+            subscriber.onCompleted();
+          } else {
+            subscriber.onError(new HttpException(response));
+          }
+        }
+      } catch (Throwable t) {
+        Exceptions.throwIfFatal(t);
+        if (!subscription.isUnsubscribed()) {
+          subscriber.onError(t);
+        }
+      }
+    }
+  }
+
+  static class CompletableCallAdapter implements CallAdapter<Completable> {
+    private final Scheduler scheduler;
+
+    CompletableCallAdapter(Scheduler scheduler) {
+      this.scheduler = scheduler;
+    }
+
+    @Override public Type responseType() {
+      return Void.class;
+    }
+
+    @Override public Completable adapt(Call call) {
+      Completable completable = Completable.create(new CompletableCallOnSubscribe(call));
+      if (scheduler != null) {
+        return completable.subscribeOn(scheduler);
+      }
+      return completable;
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/HttpException.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/HttpException.java
similarity index 92%
rename from retrofit-adapters/rxjava/src/main/java/retrofit2/HttpException.java
rename to retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/HttpException.java
index d8d199766..7b5377ea5 100644
--- a/retrofit-adapters/rxjava/src/main/java/retrofit2/HttpException.java
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/HttpException.java
@@ -1,4 +1,6 @@
-package retrofit2;
+package retrofit2.adapter.rxjava;
+
+import retrofit2.Response;
 
 /** Exception for an unexpected, non-2xx HTTP response. */
 public final class HttpException extends Exception {
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/Result.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/Result.java
similarity index 83%
rename from retrofit-adapters/rxjava/src/main/java/retrofit2/Result.java
rename to retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/Result.java
index 751b629da..8d68e9e7f 100644
--- a/retrofit-adapters/rxjava/src/main/java/retrofit2/Result.java
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/Result.java
@@ -13,26 +13,27 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.adapter.rxjava;
 
 import java.io.IOException;
-
-import static retrofit2.Utils.checkNotNull;
+import retrofit2.Response;
 
 /** The result of executing an HTTP request. */
 public final class Result<T> {
   public static <T> Result<T> error(Throwable error) {
-    return new Result<>(null, checkNotNull(error, "error == null"));
+    if (error == null) throw new NullPointerException("error == null");
+    return new Result<>(null, error);
   }
 
   public static <T> Result<T> response(Response<T> response) {
-    return new Result<>(checkNotNull(response, "response == null"), null);
+    if (response == null) throw new NullPointerException("response == null");
+    return new Result<>(response, null);
   }
 
   private final Response<T> response;
   private final Throwable error;
 
-  Result(Response<T> response, Throwable error) {
+  private Result(Response<T> response, Throwable error) {
     this.response = response;
     this.error = error;
   }
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/RxJavaCallAdapterFactory.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactory.java
similarity index 61%
rename from retrofit-adapters/rxjava/src/main/java/retrofit2/RxJavaCallAdapterFactory.java
rename to retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactory.java
index 0f2687cc3..e599e6262 100644
--- a/retrofit-adapters/rxjava/src/main/java/retrofit2/RxJavaCallAdapterFactory.java
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactory.java
@@ -13,12 +13,17 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.adapter.rxjava;
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
+import retrofit2.Call;
+import retrofit2.CallAdapter;
+import retrofit2.Response;
+import retrofit2.Retrofit;
 import rx.Observable;
+import rx.Scheduler;
 import rx.Subscriber;
 import rx.exceptions.Exceptions;
 import rx.functions.Action0;
@@ -28,31 +33,52 @@
 /**
  * TODO docs
  */
-public final class RxJavaCallAdapterFactory implements CallAdapter.Factory {
+public final class RxJavaCallAdapterFactory extends CallAdapter.Factory {
   /**
    * TODO
    */
   public static RxJavaCallAdapterFactory create() {
-    return new RxJavaCallAdapterFactory();
+    return new RxJavaCallAdapterFactory(null);
   }
 
-  private RxJavaCallAdapterFactory() {
+  /**
+   * TODO
+   */
+  public static RxJavaCallAdapterFactory createWithScheduler(Scheduler scheduler) {
+    if (scheduler == null) throw new NullPointerException("scheduler == null");
+    return new RxJavaCallAdapterFactory(scheduler);
+  }
+
+  private final Scheduler scheduler;
+
+  private RxJavaCallAdapterFactory(Scheduler scheduler) {
+    this.scheduler = scheduler;
   }
 
   @Override
   public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
-    Class<?> rawType = Utils.getRawType(returnType);
-    boolean isSingle = "rx.Single".equals(rawType.getCanonicalName());
-    if (rawType != Observable.class && !isSingle) {
+    Class<?> rawType = getRawType(returnType);
+    String canonicalName = rawType.getCanonicalName();
+    boolean isSingle = "rx.Single".equals(canonicalName);
+    boolean isCompletable = "rx.Completable".equals(canonicalName);
+    if (rawType != Observable.class && !isSingle && !isCompletable) {
       return null;
     }
-    if (!(returnType instanceof ParameterizedType)) {
+    if (!isCompletable && !(returnType instanceof ParameterizedType)) {
       String name = isSingle ? "Single" : "Observable";
       throw new IllegalStateException(name + " return type must be parameterized"
           + " as " + name + "<Foo> or " + name + "<? extends Foo>");
     }
 
-    CallAdapter<Observable<?>> callAdapter = getCallAdapter(returnType);
+    if (isCompletable) {
+      // Add Completable-converter wrapper from a separate class. This defers classloading such that
+      // regular Observable operation can be leveraged without relying on this unstable RxJava API.
+      // Note that this has to be done separately since Completable doesn't have a parametrized
+      // type.
+      return CompletableHelper.createCallAdapter(scheduler);
+    }
+
+    CallAdapter<Observable<?>> callAdapter = getCallAdapter(returnType, scheduler);
     if (isSingle) {
       // Add Single-converter wrapper from a separate class. This defers classloading such that
       // regular Observable operation can be leveraged without relying on this unstable RxJava API.
@@ -61,16 +87,16 @@ private RxJavaCallAdapterFactory() {
     return callAdapter;
   }
 
-  private CallAdapter<Observable<?>> getCallAdapter(Type returnType) {
-    Type observableType = Utils.getParameterUpperBound(0, (ParameterizedType) returnType);
-    Class<?> rawObservableType = Utils.getRawType(observableType);
+  private CallAdapter<Observable<?>> getCallAdapter(Type returnType, Scheduler scheduler) {
+    Type observableType = getParameterUpperBound(0, (ParameterizedType) returnType);
+    Class<?> rawObservableType = getRawType(observableType);
     if (rawObservableType == Response.class) {
       if (!(observableType instanceof ParameterizedType)) {
         throw new IllegalStateException("Response must be parameterized"
             + " as Response<Foo> or Response<? extends Foo>");
       }
-      Type responseType = Utils.getParameterUpperBound(0, (ParameterizedType) observableType);
-      return new ResponseCallAdapter(responseType);
+      Type responseType = getParameterUpperBound(0, (ParameterizedType) observableType);
+      return new ResponseCallAdapter(responseType, scheduler);
     }
 
     if (rawObservableType == Result.class) {
@@ -78,11 +104,11 @@ private RxJavaCallAdapterFactory() {
         throw new IllegalStateException("Result must be parameterized"
             + " as Result<Foo> or Result<? extends Foo>");
       }
-      Type responseType = Utils.getParameterUpperBound(0, (ParameterizedType) observableType);
-      return new ResultCallAdapter(responseType);
+      Type responseType = getParameterUpperBound(0, (ParameterizedType) observableType);
+      return new ResultCallAdapter(responseType, scheduler);
     }
 
-    return new SimpleCallAdapter(observableType);
+    return new SimpleCallAdapter(observableType, scheduler);
   }
 
   static final class CallOnSubscribe<T> implements Observable.OnSubscribe<Response<T>> {
@@ -124,9 +150,11 @@ private RxJavaCallAdapterFactory() {
 
   static final class ResponseCallAdapter implements CallAdapter<Observable<?>> {
     private final Type responseType;
+    private final Scheduler scheduler;
 
-    ResponseCallAdapter(Type responseType) {
+    ResponseCallAdapter(Type responseType, Scheduler scheduler) {
       this.responseType = responseType;
+      this.scheduler = scheduler;
     }
 
     @Override public Type responseType() {
@@ -134,15 +162,21 @@ private RxJavaCallAdapterFactory() {
     }
 
     @Override public <R> Observable<Response<R>> adapt(Call<R> call) {
-      return Observable.create(new CallOnSubscribe<>(call));
+      Observable<Response<R>> observable = Observable.create(new CallOnSubscribe<>(call));
+      if (scheduler != null) {
+        return observable.subscribeOn(scheduler);
+      }
+      return observable;
     }
   }
 
   static final class SimpleCallAdapter implements CallAdapter<Observable<?>> {
     private final Type responseType;
+    private final Scheduler scheduler;
 
-    SimpleCallAdapter(Type responseType) {
+    SimpleCallAdapter(Type responseType, Scheduler scheduler) {
       this.responseType = responseType;
+      this.scheduler = scheduler;
     }
 
     @Override public Type responseType() {
@@ -150,7 +184,7 @@ private RxJavaCallAdapterFactory() {
     }
 
     @Override public <R> Observable<R> adapt(Call<R> call) {
-      return Observable.create(new CallOnSubscribe<>(call)) //
+      Observable<R> observable = Observable.create(new CallOnSubscribe<>(call)) //
           .flatMap(new Func1<Response<R>, Observable<R>>() {
             @Override public Observable<R> call(Response<R> response) {
               if (response.isSuccess()) {
@@ -159,14 +193,20 @@ private RxJavaCallAdapterFactory() {
               return Observable.error(new HttpException(response));
             }
           });
+      if (scheduler != null) {
+        return observable.subscribeOn(scheduler);
+      }
+      return observable;
     }
   }
 
   static final class ResultCallAdapter implements CallAdapter<Observable<?>> {
     private final Type responseType;
+    private final Scheduler scheduler;
 
-    ResultCallAdapter(Type responseType) {
+    ResultCallAdapter(Type responseType, Scheduler scheduler) {
       this.responseType = responseType;
+      this.scheduler = scheduler;
     }
 
     @Override public Type responseType() {
@@ -174,17 +214,20 @@ private RxJavaCallAdapterFactory() {
     }
 
     @Override public <R> Observable<Result<R>> adapt(Call<R> call) {
-      return Observable.create(new CallOnSubscribe<>(call)) //
+      Observable<Result<R>> observable = Observable.create(new CallOnSubscribe<>(call)) //
           .map(new Func1<Response<R>, Result<R>>() {
             @Override public Result<R> call(Response<R> response) {
               return Result.response(response);
             }
-          })
-          .onErrorReturn(new Func1<Throwable, Result<R>>() {
+          }).onErrorReturn(new Func1<Throwable, Result<R>>() {
             @Override public Result<R> call(Throwable throwable) {
               return Result.error(throwable);
             }
           });
+      if (scheduler != null) {
+        return observable.subscribeOn(scheduler);
+      }
+      return observable;
     }
   }
 }
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/SingleHelper.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/SingleHelper.java
similarity index 92%
rename from retrofit-adapters/rxjava/src/main/java/retrofit2/SingleHelper.java
rename to retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/SingleHelper.java
index b4c2808d3..e0073cfae 100644
--- a/retrofit-adapters/rxjava/src/main/java/retrofit2/SingleHelper.java
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/SingleHelper.java
@@ -13,9 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.adapter.rxjava;
 
 import java.lang.reflect.Type;
+import retrofit2.Call;
+import retrofit2.CallAdapter;
 import rx.Observable;
 import rx.Single;
 
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/RxJavaCallAdapterFactoryTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/RxJavaCallAdapterFactoryTest.java
deleted file mode 100644
index 7ab26be0a..000000000
--- a/retrofit-adapters/rxjava/src/test/java/retrofit2/RxJavaCallAdapterFactoryTest.java
+++ /dev/null
@@ -1,352 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2;
-
-import com.google.common.reflect.TypeToken;
-import java.io.IOException;
-import java.lang.annotation.Annotation;
-import java.lang.reflect.Type;
-import java.util.List;
-import okhttp3.MediaType;
-import okhttp3.RequestBody;
-import okhttp3.ResponseBody;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import retrofit2.http.GET;
-import rx.Observable;
-import rx.Single;
-import rx.observables.BlockingObservable;
-import rx.singles.BlockingSingle;
-
-import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class RxJavaCallAdapterFactoryTest {
-  private static final Annotation[] NO_ANNOTATIONS = new Annotation[0];
-
-  @Rule public final MockWebServer server = new MockWebServer();
-
-  interface Service {
-    @GET("/") Observable<String> observableBody();
-    @GET("/") Observable<Response<String>> observableResponse();
-    @GET("/") Observable<Result<String>> observableResult();
-    @GET("/") Single<String> singleBody();
-    @GET("/") Single<Response<String>> singleResponse();
-    @GET("/") Single<Result<String>> singleResult();
-  }
-
-  private Retrofit retrofit;
-  private Service service;
-
-  @Before public void setUp() {
-    retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new StringConverterFactory())
-        .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
-        .build();
-    service = retrofit.create(Service.class);
-  }
-
-  @Test public void bodySuccess200() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    BlockingObservable<String> o = service.observableBody().toBlocking();
-    assertThat(o.first()).isEqualTo("Hi");
-  }
-
-  @Test public void bodySuccess404() {
-    server.enqueue(new MockResponse().setResponseCode(404));
-
-    BlockingObservable<String> o = service.observableBody().toBlocking();
-    try {
-      o.first();
-      fail();
-    } catch (RuntimeException e) {
-      Throwable cause = e.getCause();
-      assertThat(cause).isInstanceOf(HttpException.class).hasMessage("HTTP 404 Client Error");
-    }
-  }
-
-  @Test public void bodyFailure() {
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
-
-    BlockingObservable<String> o = service.observableBody().toBlocking();
-    try {
-      o.first();
-      fail();
-    } catch (RuntimeException e) {
-      assertThat(e.getCause()).isInstanceOf(IOException.class);
-    }
-  }
-
-  @Test public void responseSuccess200() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    BlockingObservable<Response<String>> o = service.observableResponse().toBlocking();
-    Response<String> response = o.first();
-    assertThat(response.isSuccess()).isTrue();
-    assertThat(response.body()).isEqualTo("Hi");
-  }
-
-  @Test public void responseSuccess404() throws IOException {
-    server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
-
-    BlockingObservable<Response<String>> o = service.observableResponse().toBlocking();
-    Response<String> response = o.first();
-    assertThat(response.isSuccess()).isFalse();
-    assertThat(response.errorBody().string()).isEqualTo("Hi");
-  }
-
-  @Test public void responseFailure() {
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
-
-    BlockingObservable<Response<String>> o = service.observableResponse().toBlocking();
-    try {
-      o.first();
-      fail();
-    } catch (RuntimeException t) {
-      assertThat(t.getCause()).isInstanceOf(IOException.class);
-    }
-  }
-
-  @Test public void resultSuccess200() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    BlockingObservable<Result<String>> o = service.observableResult().toBlocking();
-    Result<String> result = o.first();
-    assertThat(result.isError()).isFalse();
-    Response<String> response = result.response();
-    assertThat(response.isSuccess()).isTrue();
-    assertThat(response.body()).isEqualTo("Hi");
-  }
-
-  @Test public void resultSuccess404() throws IOException {
-    server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
-
-    BlockingObservable<Result<String>> o = service.observableResult().toBlocking();
-    Result<String> result = o.first();
-    assertThat(result.isError()).isFalse();
-    Response<String> response = result.response();
-    assertThat(response.isSuccess()).isFalse();
-    assertThat(response.errorBody().string()).isEqualTo("Hi");
-  }
-
-  @Test public void resultFailure() {
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
-
-    BlockingObservable<Result<String>> o = service.observableResult().toBlocking();
-    Result<String> result = o.first();
-    assertThat(result.isError()).isTrue();
-    assertThat(result.error()).isInstanceOf(IOException.class);
-  }
-
-  @Test public void responseType() {
-    CallAdapter.Factory factory = RxJavaCallAdapterFactory.create();
-    Type classType = new TypeToken<Observable<String>>() {}.getType();
-    assertThat(factory.get(classType, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-    Type wilcardType = new TypeToken<Observable<? extends String>>() {}.getType();
-    assertThat(factory.get(wilcardType, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-    Type genericType = new TypeToken<Observable<List<String>>>() {}.getType();
-    assertThat(factory.get(genericType, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(new TypeToken<List<String>>() {}.getType());
-    Type responseType = new TypeToken<Observable<Response<String>>>() {}.getType();
-    assertThat(factory.get(responseType, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-    Type resultType = new TypeToken<Observable<Response<String>>>() {}.getType();
-    assertThat(factory.get(resultType, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-  }
-
-  @Test public void nonObservableTypeReturnsNull() {
-    CallAdapter.Factory factory = RxJavaCallAdapterFactory.create();
-    CallAdapter<?> adapter = factory.get(String.class, NO_ANNOTATIONS, retrofit);
-    assertThat(adapter).isNull();
-  }
-
-  @Test public void rawTypeThrows() {
-    CallAdapter.Factory factory = RxJavaCallAdapterFactory.create();
-    Type observableType = new TypeToken<Observable>() {}.getType();
-    try {
-      factory.get(observableType, NO_ANNOTATIONS, retrofit);
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage("Observable return type must be parameterized as Observable<Foo> or Observable<? extends Foo>");
-    }
-    Type singleType = new TypeToken<Single>() {}.getType();
-    try {
-      factory.get(singleType, NO_ANNOTATIONS, retrofit);
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage("Single return type must be parameterized as Single<Foo> or Single<? extends Foo>");
-    }
-  }
-
-  @Test public void rawObservableResponseTypeThrows() {
-    CallAdapter.Factory factory = RxJavaCallAdapterFactory.create();
-    Type observableType = new TypeToken<Observable<Response>>() {}.getType();
-    try {
-      factory.get(observableType, NO_ANNOTATIONS, retrofit);
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage("Response must be parameterized as Response<Foo> or Response<? extends Foo>");
-    }
-    Type singleType = new TypeToken<Single<Response>>() {}.getType();
-    try {
-      factory.get(singleType, NO_ANNOTATIONS, retrofit);
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage("Response must be parameterized as Response<Foo> or Response<? extends Foo>");
-    }
-  }
-
-  @Test public void rawResultTypeThrows() {
-    CallAdapter.Factory factory = RxJavaCallAdapterFactory.create();
-    Type observableType = new TypeToken<Observable<Result>>() {}.getType();
-    try {
-      factory.get(observableType, NO_ANNOTATIONS, retrofit);
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage("Result must be parameterized as Result<Foo> or Result<? extends Foo>");
-    }
-    Type singleType = new TypeToken<Single<Result>>() {}.getType();
-    try {
-      factory.get(singleType, NO_ANNOTATIONS, retrofit);
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage("Result must be parameterized as Result<Foo> or Result<? extends Foo>");
-    }
-  }
-
-  @Test public void singleBodySuccess200() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    BlockingSingle<String> o = service.singleBody().toBlocking();
-    assertThat(o.value()).isEqualTo("Hi");
-  }
-
-  @Test public void singleBodySuccess404() {
-    server.enqueue(new MockResponse().setResponseCode(404));
-
-    BlockingSingle<String> o = service.singleBody().toBlocking();
-    try {
-      o.value();
-      fail();
-    } catch (RuntimeException e) {
-      Throwable cause = e.getCause();
-      assertThat(cause).isInstanceOf(HttpException.class).hasMessage("HTTP 404 Client Error");
-    }
-  }
-
-  @Test public void singleBodyFailure() {
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
-
-    BlockingSingle<String> o = service.singleBody().toBlocking();
-    try {
-      o.value();
-      fail();
-    } catch (RuntimeException e) {
-      assertThat(e.getCause()).isInstanceOf(IOException.class);
-    }
-  }
-
-  @Test public void singleResponseSuccess200() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    BlockingSingle<Response<String>> o = service.singleResponse().toBlocking();
-    Response<String> response = o.value();
-    assertThat(response.isSuccess()).isTrue();
-    assertThat(response.body()).isEqualTo("Hi");
-  }
-
-  @Test public void singleResponseSuccess404() throws IOException {
-    server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
-
-    BlockingSingle<Response<String>> o = service.singleResponse().toBlocking();
-    Response<String> response = o.value();
-    assertThat(response.isSuccess()).isFalse();
-    assertThat(response.errorBody().string()).isEqualTo("Hi");
-  }
-
-  @Test public void singleResponseFailure() {
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
-
-    BlockingSingle<Response<String>> o = service.singleResponse().toBlocking();
-    try {
-      o.value();
-      fail();
-    } catch (RuntimeException t) {
-      assertThat(t.getCause()).isInstanceOf(IOException.class);
-    }
-  }
-
-  @Test public void singleResultSuccess200() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    BlockingSingle<Result<String>> o = service.singleResult().toBlocking();
-    Result<String> result = o.value();
-    assertThat(result.isError()).isFalse();
-    Response<String> response = result.response();
-    assertThat(response.isSuccess()).isTrue();
-    assertThat(response.body()).isEqualTo("Hi");
-  }
-
-  @Test public void singleResultSuccess404() throws IOException {
-    server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
-
-    BlockingSingle<Result<String>> o = service.singleResult().toBlocking();
-    Result<String> result = o.value();
-    assertThat(result.isError()).isFalse();
-    Response<String> response = result.response();
-    assertThat(response.isSuccess()).isFalse();
-    assertThat(response.errorBody().string()).isEqualTo("Hi");
-  }
-
-  @Test public void singleResultFailure() {
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
-
-    BlockingSingle<Result<String>> o = service.singleResult().toBlocking();
-    Result<String> result = o.value();
-    assertThat(result.isError()).isTrue();
-    assertThat(result.error()).isInstanceOf(IOException.class);
-  }
-
-  static class StringConverterFactory extends Converter.Factory {
-    @Override
-    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-        Retrofit retrofit) {
-      return new Converter<ResponseBody, String>() {
-        @Override public String convert(ResponseBody value) throws IOException {
-          return value.string();
-        }
-      };
-    }
-
-    @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
-        Annotation[] annotations, Retrofit retrofit) {
-      return new Converter<String, RequestBody>() {
-        @Override public RequestBody convert(String value) throws IOException {
-          return RequestBody.create(MediaType.parse("text/plain"), value);
-        }
-      };
-    }
-  }
-}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableSchedulerTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableSchedulerTest.java
new file mode 100644
index 000000000..bb02e3d47
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableSchedulerTest.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+import rx.Completable;
+import rx.observers.TestSubscriber;
+import rx.schedulers.TestScheduler;
+
+public final class CompletableSchedulerTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  interface Service {
+    @GET("/") Completable completable();
+  }
+
+  private final TestScheduler scheduler = new TestScheduler();
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addCallAdapterFactory(RxJavaCallAdapterFactory.createWithScheduler(scheduler))
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void completableUsesScheduler() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    TestSubscriber<Void> subscriber = new TestSubscriber<>();
+    service.completable().subscribe(subscriber);
+    subscriber.assertNoTerminalEvent();
+
+    scheduler.triggerActions();
+    subscriber.assertCompleted();
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableTest.java
new file mode 100644
index 000000000..0cdd11155
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableTest.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import java.io.IOException;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+import rx.Completable;
+
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class CompletableTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  interface Service {
+    @GET("/") Completable completable();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void completableSuccess200() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+    service.completable().await();
+  }
+
+  @Test public void completableSuccess404() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    try {
+      service.completable().await();
+      fail();
+    } catch (RuntimeException e) {
+      Throwable cause = e.getCause();
+      assertThat(cause).isInstanceOf(HttpException.class).hasMessage("HTTP 404 Client Error");
+    }
+  }
+
+  @Test public void completableFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    try {
+      service.completable().await();
+      fail();
+    } catch (RuntimeException e) {
+      assertThat(e.getCause()).isInstanceOf(IOException.class);
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableSchedulerTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableSchedulerTest.java
new file mode 100644
index 000000000..e0a1c2d41
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableSchedulerTest.java
@@ -0,0 +1,89 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+import rx.Observable;
+import rx.observers.TestSubscriber;
+import rx.schedulers.TestScheduler;
+
+public final class ObservableSchedulerTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  interface Service {
+    @GET("/") Observable<String> body();
+    @GET("/") Observable<Response<String>> response();
+    @GET("/") Observable<Result<String>> result();
+  }
+
+  private final TestScheduler scheduler = new TestScheduler();
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJavaCallAdapterFactory.createWithScheduler(scheduler))
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodyUsesScheduler() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    TestSubscriber<String> subscriber = new TestSubscriber<>();
+    service.body().subscribe(subscriber);
+    subscriber.assertNoValues();
+    subscriber.assertNoTerminalEvent();
+
+    scheduler.triggerActions();
+    subscriber.assertValueCount(1);
+    subscriber.assertCompleted();
+  }
+
+  @Test public void responseUsesScheduler() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    TestSubscriber<Response<String>> subscriber = new TestSubscriber<>();
+    service.response().subscribe(subscriber);
+    subscriber.assertNoValues();
+    subscriber.assertNoTerminalEvent();
+
+    scheduler.triggerActions();
+    subscriber.assertValueCount(1);
+    subscriber.assertCompleted();
+  }
+
+  @Test public void resultUsesScheduler() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    TestSubscriber<Result<String>> subscriber = new TestSubscriber<>();
+    service.result().subscribe(subscriber);
+    subscriber.assertNoValues();
+    subscriber.assertNoTerminalEvent();
+
+    scheduler.triggerActions();
+    subscriber.assertValueCount(1);
+    subscriber.assertCompleted();
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableTest.java
new file mode 100644
index 000000000..2d6eda999
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableTest.java
@@ -0,0 +1,146 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import java.io.IOException;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+import rx.Observable;
+import rx.observables.BlockingObservable;
+
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class ObservableTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  interface Service {
+    @GET("/") Observable<String> body();
+    @GET("/") Observable<Response<String>> response();
+    @GET("/") Observable<Result<String>> result();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodySuccess200() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    BlockingObservable<String> o = service.body().toBlocking();
+    assertThat(o.first()).isEqualTo("Hi");
+  }
+
+  @Test public void bodySuccess404() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    BlockingObservable<String> o = service.body().toBlocking();
+    try {
+      o.first();
+      fail();
+    } catch (RuntimeException e) {
+      Throwable cause = e.getCause();
+      assertThat(cause).isInstanceOf(HttpException.class).hasMessage("HTTP 404 Client Error");
+    }
+  }
+
+  @Test public void bodyFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    BlockingObservable<String> o = service.body().toBlocking();
+    try {
+      o.first();
+      fail();
+    } catch (RuntimeException e) {
+      assertThat(e.getCause()).isInstanceOf(IOException.class);
+    }
+  }
+
+  @Test public void responseSuccess200() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    BlockingObservable<Response<String>> o = service.response().toBlocking();
+    Response<String> response = o.first();
+    assertThat(response.isSuccess()).isTrue();
+    assertThat(response.body()).isEqualTo("Hi");
+  }
+
+  @Test public void responseSuccess404() throws IOException {
+    server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
+
+    BlockingObservable<Response<String>> o = service.response().toBlocking();
+    Response<String> response = o.first();
+    assertThat(response.isSuccess()).isFalse();
+    assertThat(response.errorBody().string()).isEqualTo("Hi");
+  }
+
+  @Test public void responseFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    BlockingObservable<Response<String>> o = service.response().toBlocking();
+    try {
+      o.first();
+      fail();
+    } catch (RuntimeException t) {
+      assertThat(t.getCause()).isInstanceOf(IOException.class);
+    }
+  }
+
+  @Test public void resultSuccess200() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    BlockingObservable<Result<String>> o = service.result().toBlocking();
+    Result<String> result = o.first();
+    assertThat(result.isError()).isFalse();
+    Response<String> response = result.response();
+    assertThat(response.isSuccess()).isTrue();
+    assertThat(response.body()).isEqualTo("Hi");
+  }
+
+  @Test public void resultSuccess404() throws IOException {
+    server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
+
+    BlockingObservable<Result<String>> o = service.result().toBlocking();
+    Result<String> result = o.first();
+    assertThat(result.isError()).isFalse();
+    Response<String> response = result.response();
+    assertThat(response.isSuccess()).isFalse();
+    assertThat(response.errorBody().string()).isEqualTo("Hi");
+  }
+
+  @Test public void resultFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    BlockingObservable<Result<String>> o = service.result().toBlocking();
+    Result<String> result = o.first();
+    assertThat(result.isError()).isTrue();
+    assertThat(result.error()).isInstanceOf(IOException.class);
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/ResultTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ResultTest.java
similarity index 94%
rename from retrofit-adapters/rxjava/src/test/java/retrofit2/ResultTest.java
rename to retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ResultTest.java
index 935a2b9f7..7c62c14ad 100644
--- a/retrofit-adapters/rxjava/src/test/java/retrofit2/ResultTest.java
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ResultTest.java
@@ -13,10 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.adapter.rxjava;
 
 import java.io.IOException;
 import org.junit.Test;
+import retrofit2.Response;
+import retrofit2.adapter.rxjava.Result;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactoryTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactoryTest.java
new file mode 100644
index 000000000..3c2e435ad
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactoryTest.java
@@ -0,0 +1,171 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import com.google.common.reflect.TypeToken;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import java.util.List;
+import org.junit.Before;
+import org.junit.Test;
+import retrofit2.CallAdapter;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import rx.Observable;
+import rx.Single;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class RxJavaCallAdapterFactoryTest {
+  private static final Annotation[] NO_ANNOTATIONS = new Annotation[0];
+
+  private final CallAdapter.Factory factory = RxJavaCallAdapterFactory.create();
+  private Retrofit retrofit;
+
+  @Before public void setUp() {
+    retrofit = new Retrofit.Builder()
+        .baseUrl("http://localhost:1")
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(factory)
+        .build();
+  }
+
+  @Test public void nullSchedulerThrows() {
+    try {
+      RxJavaCallAdapterFactory.createWithScheduler(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("scheduler == null");
+    }
+  }
+
+  @Test public void nonRxJavaTypeReturnsNull() {
+    CallAdapter<?> adapter = factory.get(String.class, NO_ANNOTATIONS, retrofit);
+    assertThat(adapter).isNull();
+  }
+
+  @Test public void responseTypes() {
+    Type oBodyClass = new TypeToken<Observable<String>>() {}.getType();
+    assertThat(factory.get(oBodyClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type sBodyClass = new TypeToken<Single<String>>() {}.getType();
+    assertThat(factory.get(sBodyClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+
+    Type oBodyWildcard = new TypeToken<Observable<? extends String>>() {}.getType();
+    assertThat(factory.get(oBodyWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type sBodyWildcard = new TypeToken<Single<? extends String>>() {}.getType();
+    assertThat(factory.get(sBodyWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+
+    Type oBodyGeneric = new TypeToken<Observable<List<String>>>() {}.getType();
+    assertThat(factory.get(oBodyGeneric, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(new TypeToken<List<String>>() {}.getType());
+    Type sBodyGeneric = new TypeToken<Single<List<String>>>() {}.getType();
+    assertThat(factory.get(sBodyGeneric, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(new TypeToken<List<String>>() {}.getType());
+
+    Type oResponseClass = new TypeToken<Observable<Response<String>>>() {}.getType();
+    assertThat(factory.get(oResponseClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type sResponseClass = new TypeToken<Single<Response<String>>>() {}.getType();
+    assertThat(factory.get(sResponseClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+
+    Type oResponseWildcard = new TypeToken<Observable<Response<? extends String>>>() {}.getType();
+    assertThat(factory.get(oResponseWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type sResponseWildcard = new TypeToken<Single<Response<? extends String>>>() {}.getType();
+    assertThat(factory.get(sResponseWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+
+    Type oResultClass = new TypeToken<Observable<Result<String>>>() {}.getType();
+    assertThat(factory.get(oResultClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type sResultClass = new TypeToken<Single<Result<String>>>() {}.getType();
+    assertThat(factory.get(sResultClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+
+    Type oResultWildcard = new TypeToken<Observable<Result<? extends String>>>() {}.getType();
+    assertThat(factory.get(oResultWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type sResultWildcard = new TypeToken<Single<Result<? extends String>>>() {}.getType();
+    assertThat(factory.get(sResultWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+  }
+
+  @Test public void rawBodyTypeThrows() {
+    Type observableType = new TypeToken<Observable>() {}.getType();
+    try {
+      factory.get(observableType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Observable return type must be parameterized as Observable<Foo> or Observable<? extends Foo>");
+    }
+
+    Type singleType = new TypeToken<Single>() {}.getType();
+    try {
+      factory.get(singleType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Single return type must be parameterized as Single<Foo> or Single<? extends Foo>");
+    }
+  }
+
+  @Test public void rawResponseTypeThrows() {
+    Type observableType = new TypeToken<Observable<Response>>() {}.getType();
+    try {
+      factory.get(observableType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Response must be parameterized as Response<Foo> or Response<? extends Foo>");
+    }
+
+    Type singleType = new TypeToken<Single<Response>>() {}.getType();
+    try {
+      factory.get(singleType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Response must be parameterized as Response<Foo> or Response<? extends Foo>");
+    }
+  }
+
+  @Test public void rawResultTypeThrows() {
+    Type observableType = new TypeToken<Observable<Result>>() {}.getType();
+    try {
+      factory.get(observableType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Result must be parameterized as Result<Foo> or Result<? extends Foo>");
+    }
+
+    Type singleType = new TypeToken<Single<Result>>() {}.getType();
+    try {
+      factory.get(singleType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Result must be parameterized as Result<Foo> or Result<? extends Foo>");
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleSchedulerTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleSchedulerTest.java
new file mode 100644
index 000000000..671370e02
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleSchedulerTest.java
@@ -0,0 +1,86 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+import rx.Single;
+import rx.observers.TestSubscriber;
+import rx.schedulers.TestScheduler;
+
+public final class SingleSchedulerTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  interface Service {
+    @GET("/") Single<String> body();
+    @GET("/") Single<Response<String>> response();
+    @GET("/") Single<Result<String>> result();
+  }
+
+  private final TestScheduler scheduler = new TestScheduler();
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJavaCallAdapterFactory.createWithScheduler(scheduler))
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodyUsesScheduler() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    TestSubscriber<String> subscriber = new TestSubscriber<>();
+    service.body().subscribe(subscriber);
+    subscriber.assertNoValues();
+    subscriber.assertNoTerminalEvent();
+
+    scheduler.triggerActions();
+    subscriber.assertValueCount(1);
+  }
+
+  @Test public void responseUsesScheduler() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    TestSubscriber<Response<String>> subscriber = new TestSubscriber<>();
+    service.response().subscribe(subscriber);
+    subscriber.assertNoValues();
+    subscriber.assertNoTerminalEvent();
+
+    scheduler.triggerActions();
+    subscriber.assertValueCount(1);
+  }
+
+  @Test public void resultUsesScheduler() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    TestSubscriber<Result<String>> subscriber = new TestSubscriber<>();
+    service.result().subscribe(subscriber);
+    subscriber.assertNoValues();
+    subscriber.assertNoTerminalEvent();
+
+    scheduler.triggerActions();
+    subscriber.assertValueCount(1);
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleTest.java
new file mode 100644
index 000000000..ff065cd40
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleTest.java
@@ -0,0 +1,146 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import java.io.IOException;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+import rx.Single;
+import rx.singles.BlockingSingle;
+
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class SingleTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  interface Service {
+    @GET("/") Single<String> body();
+    @GET("/") Single<Response<String>> response();
+    @GET("/") Single<Result<String>> result();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodySuccess200() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    BlockingSingle<String> o = service.body().toBlocking();
+    assertThat(o.value()).isEqualTo("Hi");
+  }
+
+  @Test public void bodySuccess404() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    BlockingSingle<String> o = service.body().toBlocking();
+    try {
+      o.value();
+      fail();
+    } catch (RuntimeException e) {
+      Throwable cause = e.getCause();
+      assertThat(cause).isInstanceOf(HttpException.class).hasMessage("HTTP 404 Client Error");
+    }
+  }
+
+  @Test public void bodyFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    BlockingSingle<String> o = service.body().toBlocking();
+    try {
+      o.value();
+      fail();
+    } catch (RuntimeException e) {
+      assertThat(e.getCause()).isInstanceOf(IOException.class);
+    }
+  }
+
+  @Test public void responseSuccess200() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    BlockingSingle<Response<String>> o = service.response().toBlocking();
+    Response<String> response = o.value();
+    assertThat(response.isSuccess()).isTrue();
+    assertThat(response.body()).isEqualTo("Hi");
+  }
+
+  @Test public void responseSuccess404() throws IOException {
+    server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
+
+    BlockingSingle<Response<String>> o = service.response().toBlocking();
+    Response<String> response = o.value();
+    assertThat(response.isSuccess()).isFalse();
+    assertThat(response.errorBody().string()).isEqualTo("Hi");
+  }
+
+  @Test public void responseFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    BlockingSingle<Response<String>> o = service.response().toBlocking();
+    try {
+      o.value();
+      fail();
+    } catch (RuntimeException t) {
+      assertThat(t.getCause()).isInstanceOf(IOException.class);
+    }
+  }
+
+  @Test public void resultSuccess200() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    BlockingSingle<Result<String>> o = service.result().toBlocking();
+    Result<String> result = o.value();
+    assertThat(result.isError()).isFalse();
+    Response<String> response = result.response();
+    assertThat(response.isSuccess()).isTrue();
+    assertThat(response.body()).isEqualTo("Hi");
+  }
+
+  @Test public void resultSuccess404() throws IOException {
+    server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
+
+    BlockingSingle<Result<String>> o = service.result().toBlocking();
+    Result<String> result = o.value();
+    assertThat(result.isError()).isFalse();
+    Response<String> response = result.response();
+    assertThat(response.isSuccess()).isFalse();
+    assertThat(response.errorBody().string()).isEqualTo("Hi");
+  }
+
+  @Test public void resultFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    BlockingSingle<Result<String>> o = service.result().toBlocking();
+    Result<String> result = o.value();
+    assertThat(result.isError()).isTrue();
+    assertThat(result.error()).isInstanceOf(IOException.class);
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/StringConverterFactory.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/StringConverterFactory.java
new file mode 100644
index 000000000..c44038d02
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/StringConverterFactory.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import okhttp3.MediaType;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
+
+final class StringConverterFactory extends Converter.Factory {
+  @Override
+  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
+    return new Converter<ResponseBody, String>() {
+      @Override public String convert(ResponseBody value) throws IOException {
+        return value.string();
+      }
+    };
+  }
+
+  @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
+      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+    return new Converter<String, RequestBody>() {
+      @Override public RequestBody convert(String value) throws IOException {
+        return RequestBody.create(MediaType.parse("text/plain"), value);
+      }
+    };
+  }
+}
diff --git a/retrofit-converters/gson/src/main/java/retrofit2/GsonConverterFactory.java b/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonConverterFactory.java
similarity index 91%
rename from retrofit-converters/gson/src/main/java/retrofit2/GsonConverterFactory.java
rename to retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonConverterFactory.java
index 28ae49c4d..e6c702705 100644
--- a/retrofit-converters/gson/src/main/java/retrofit2/GsonConverterFactory.java
+++ b/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonConverterFactory.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.gson;
 
 import com.google.gson.Gson;
 import com.google.gson.TypeAdapter;
@@ -22,6 +22,8 @@
 import java.lang.reflect.Type;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
 
 /**
  * A {@linkplain Converter.Factory converter} which uses Gson for JSON.
@@ -59,12 +61,12 @@ private GsonConverterFactory(Gson gson) {
   public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
       Retrofit retrofit) {
     TypeAdapter<?> adapter = gson.getAdapter(TypeToken.get(type));
-    return new GsonResponseBodyConverter<>(adapter);
+    return new GsonResponseBodyConverter<>(gson, adapter);
   }
 
   @Override
-  public Converter<?, RequestBody> requestBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
+  public Converter<?, RequestBody> requestBodyConverter(Type type,
+      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     TypeAdapter<?> adapter = gson.getAdapter(TypeToken.get(type));
     return new GsonRequestBodyConverter<>(gson, adapter);
   }
diff --git a/retrofit-converters/gson/src/main/java/retrofit2/GsonRequestBodyConverter.java b/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonRequestBodyConverter.java
similarity index 89%
rename from retrofit-converters/gson/src/main/java/retrofit2/GsonRequestBodyConverter.java
rename to retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonRequestBodyConverter.java
index 28b5ec73a..2e30a4478 100644
--- a/retrofit-converters/gson/src/main/java/retrofit2/GsonRequestBodyConverter.java
+++ b/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonRequestBodyConverter.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.gson;
 
 import com.google.gson.Gson;
 import com.google.gson.TypeAdapter;
@@ -25,6 +25,7 @@
 import okhttp3.MediaType;
 import okhttp3.RequestBody;
 import okio.Buffer;
+import retrofit2.Converter;
 
 final class GsonRequestBodyConverter<T> implements Converter<T, RequestBody> {
   private static final MediaType MEDIA_TYPE = MediaType.parse("application/json; charset=UTF-8");
@@ -42,12 +43,8 @@
     Buffer buffer = new Buffer();
     Writer writer = new OutputStreamWriter(buffer.outputStream(), UTF_8);
     JsonWriter jsonWriter = gson.newJsonWriter(writer);
-    try {
-      adapter.write(jsonWriter, value);
-      jsonWriter.flush();
-    } catch (IOException e) {
-      throw new AssertionError(e); // Writing to Buffer does no I/O.
-    }
+    adapter.write(jsonWriter, value);
+    jsonWriter.close();
     return RequestBody.create(MEDIA_TYPE, buffer.readByteString());
   }
 }
diff --git a/retrofit-converters/gson/src/main/java/retrofit2/GsonResponseBodyConverter.java b/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonResponseBodyConverter.java
similarity index 73%
rename from retrofit-converters/gson/src/main/java/retrofit2/GsonResponseBodyConverter.java
rename to retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonResponseBodyConverter.java
index ab1745ab4..bd9509a18 100644
--- a/retrofit-converters/gson/src/main/java/retrofit2/GsonResponseBodyConverter.java
+++ b/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonResponseBodyConverter.java
@@ -13,22 +13,28 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.gson;
 
+import com.google.gson.Gson;
 import com.google.gson.TypeAdapter;
+import com.google.gson.stream.JsonReader;
 import java.io.IOException;
 import okhttp3.ResponseBody;
+import retrofit2.Converter;
 
 final class GsonResponseBodyConverter<T> implements Converter<ResponseBody, T> {
+  private final Gson gson;
   private final TypeAdapter<T> adapter;
 
-  GsonResponseBodyConverter(TypeAdapter<T> adapter) {
+  GsonResponseBodyConverter(Gson gson, TypeAdapter<T> adapter) {
+    this.gson = gson;
     this.adapter = adapter;
   }
 
   @Override public T convert(ResponseBody value) throws IOException {
+    JsonReader jsonReader = gson.newJsonReader(value.charStream());
     try {
-      return adapter.fromJson(value.charStream());
+      return adapter.read(jsonReader);
     } finally {
       value.close();
     }
diff --git a/retrofit-converters/gson/src/test/java/retrofit2/GsonConverterFactoryTest.java b/retrofit-converters/gson/src/test/java/retrofit2/converter/gson/GsonConverterFactoryTest.java
similarity index 90%
rename from retrofit-converters/gson/src/test/java/retrofit2/GsonConverterFactoryTest.java
rename to retrofit-converters/gson/src/test/java/retrofit2/converter/gson/GsonConverterFactoryTest.java
index b39f794b8..5f584ec85 100644
--- a/retrofit-converters/gson/src/test/java/retrofit2/GsonConverterFactoryTest.java
+++ b/retrofit-converters/gson/src/test/java/retrofit2/converter/gson/GsonConverterFactoryTest.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.gson;
 
 import com.google.gson.Gson;
 import com.google.gson.GsonBuilder;
@@ -28,6 +28,9 @@
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+import retrofit2.Call;
+import retrofit2.Response;
+import retrofit2.Retrofit;
 import retrofit2.http.Body;
 import retrofit2.http.POST;
 
@@ -86,6 +89,7 @@
   @Before public void setUp() {
     Gson gson = new GsonBuilder()
         .registerTypeAdapter(AnInterface.class, new AnInterfaceAdapter())
+        .setLenient()
         .create();
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
@@ -129,4 +133,12 @@
     assertThat(request.getBody().readUtf8()).isEqualTo("{}"); // Null value was not serialized.
     assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
   }
+
+  @Test public void deserializeUsesConfiguration() throws IOException, InterruptedException {
+    server.enqueue(new MockResponse().setBody("{/* a comment! */}"));
+
+    Response<AnImplementation> response =
+        service.anImplementation(new AnImplementation("value")).execute();
+    assertThat(response.body().getName()).isNull();
+  }
 }
diff --git a/retrofit-converters/jackson/src/main/java/retrofit2/JacksonConverterFactory.java b/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonConverterFactory.java
similarity index 93%
rename from retrofit-converters/jackson/src/main/java/retrofit2/JacksonConverterFactory.java
rename to retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonConverterFactory.java
index 9f4858d83..f6db311be 100644
--- a/retrofit-converters/jackson/src/main/java/retrofit2/JacksonConverterFactory.java
+++ b/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonConverterFactory.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.jackson;
 
 import com.fasterxml.jackson.databind.JavaType;
 import com.fasterxml.jackson.databind.ObjectMapper;
@@ -23,6 +23,8 @@
 import java.lang.reflect.Type;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
 
 /**
  * A {@linkplain Converter.Factory converter} which uses Jackson.
@@ -59,8 +61,8 @@ private JacksonConverterFactory(ObjectMapper mapper) {
   }
 
   @Override
-  public Converter<?, RequestBody> requestBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
+  public Converter<?, RequestBody> requestBodyConverter(Type type,
+      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     JavaType javaType = mapper.getTypeFactory().constructType(type);
     ObjectWriter writer = mapper.writerWithType(javaType);
     return new JacksonRequestBodyConverter<>(writer);
diff --git a/retrofit-converters/jackson/src/main/java/retrofit2/JacksonRequestBodyConverter.java b/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonRequestBodyConverter.java
similarity index 94%
rename from retrofit-converters/jackson/src/main/java/retrofit2/JacksonRequestBodyConverter.java
rename to retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonRequestBodyConverter.java
index 39e8fb88f..bd20a0ae0 100644
--- a/retrofit-converters/jackson/src/main/java/retrofit2/JacksonRequestBodyConverter.java
+++ b/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonRequestBodyConverter.java
@@ -13,12 +13,13 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.jackson;
 
 import com.fasterxml.jackson.databind.ObjectWriter;
 import java.io.IOException;
 import okhttp3.MediaType;
 import okhttp3.RequestBody;
+import retrofit2.Converter;
 
 final class JacksonRequestBodyConverter<T> implements Converter<T, RequestBody> {
   private static final MediaType MEDIA_TYPE = MediaType.parse("application/json; charset=UTF-8");
diff --git a/retrofit-converters/jackson/src/main/java/retrofit2/JacksonResponseBodyConverter.java b/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonResponseBodyConverter.java
similarity index 94%
rename from retrofit-converters/jackson/src/main/java/retrofit2/JacksonResponseBodyConverter.java
rename to retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonResponseBodyConverter.java
index 0cbce4f80..f51fde7df 100644
--- a/retrofit-converters/jackson/src/main/java/retrofit2/JacksonResponseBodyConverter.java
+++ b/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonResponseBodyConverter.java
@@ -13,11 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.jackson;
 
 import com.fasterxml.jackson.databind.ObjectReader;
 import java.io.IOException;
 import okhttp3.ResponseBody;
+import retrofit2.Converter;
 
 final class JacksonResponseBodyConverter<T> implements Converter<ResponseBody, T> {
   private final ObjectReader adapter;
diff --git a/retrofit-converters/jackson/src/test/java/retrofit2/JacksonConverterFactoryTest.java b/retrofit-converters/jackson/src/test/java/retrofit2/converter/jackson/JacksonConverterFactoryTest.java
similarity index 96%
rename from retrofit-converters/jackson/src/test/java/retrofit2/JacksonConverterFactoryTest.java
rename to retrofit-converters/jackson/src/test/java/retrofit2/converter/jackson/JacksonConverterFactoryTest.java
index 11757d6e7..19c18538e 100644
--- a/retrofit-converters/jackson/src/test/java/retrofit2/JacksonConverterFactoryTest.java
+++ b/retrofit-converters/jackson/src/test/java/retrofit2/converter/jackson/JacksonConverterFactoryTest.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.jackson;
 
 import com.fasterxml.jackson.annotation.JsonAutoDetect;
 import com.fasterxml.jackson.core.JsonGenerator;
@@ -33,6 +33,10 @@
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+import retrofit2.Call;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.converter.jackson.JacksonConverterFactory;
 import retrofit2.http.Body;
 import retrofit2.http.POST;
 
diff --git a/retrofit-converters/moshi/src/main/java/retrofit2/MoshiConverterFactory.java b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiConverterFactory.java
similarity index 76%
rename from retrofit-converters/moshi/src/main/java/retrofit2/MoshiConverterFactory.java
rename to retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiConverterFactory.java
index b7e4a9e98..c4831f937 100644
--- a/retrofit-converters/moshi/src/main/java/retrofit2/MoshiConverterFactory.java
+++ b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiConverterFactory.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.moshi;
 
 import com.squareup.moshi.JsonAdapter;
 import com.squareup.moshi.Moshi;
@@ -21,6 +21,8 @@
 import java.lang.reflect.Type;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
 
 /**
  * A {@linkplain Converter.Factory converter} which uses Moshi for JSON.
@@ -38,27 +40,40 @@ public static MoshiConverterFactory create() {
 
   /** Create an instance using {@code moshi} for conversion. */
   public static MoshiConverterFactory create(Moshi moshi) {
-    return new MoshiConverterFactory(moshi);
+    return new MoshiConverterFactory(moshi, false);
   }
 
   private final Moshi moshi;
+  private final boolean lenient;
 
-  private MoshiConverterFactory(Moshi moshi) {
+  private MoshiConverterFactory(Moshi moshi, boolean lenient) {
     if (moshi == null) throw new NullPointerException("moshi == null");
     this.moshi = moshi;
+    this.lenient = lenient;
+  }
+
+  /** Return a new factory which uses {@linkplain JsonAdapter#lenient() lenient} adapters. */
+  public MoshiConverterFactory asLenient() {
+    return new MoshiConverterFactory(moshi, true);
   }
 
   @Override
   public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
       Retrofit retrofit) {
     JsonAdapter<?> adapter = moshi.adapter(type);
+    if (lenient) {
+      adapter = adapter.lenient();
+    }
     return new MoshiResponseBodyConverter<>(adapter);
   }
 
   @Override
-  public Converter<?, RequestBody> requestBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
+  public Converter<?, RequestBody> requestBodyConverter(Type type,
+      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     JsonAdapter<?> adapter = moshi.adapter(type);
+    if (lenient) {
+      adapter = adapter.lenient();
+    }
     return new MoshiRequestBodyConverter<>(adapter);
   }
 }
diff --git a/retrofit-converters/moshi/src/main/java/retrofit2/MoshiRequestBodyConverter.java b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiRequestBodyConverter.java
similarity index 87%
rename from retrofit-converters/moshi/src/main/java/retrofit2/MoshiRequestBodyConverter.java
rename to retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiRequestBodyConverter.java
index a32002ce7..ac3d095d3 100644
--- a/retrofit-converters/moshi/src/main/java/retrofit2/MoshiRequestBodyConverter.java
+++ b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiRequestBodyConverter.java
@@ -13,13 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.moshi;
 
 import com.squareup.moshi.JsonAdapter;
 import java.io.IOException;
 import okhttp3.MediaType;
 import okhttp3.RequestBody;
 import okio.Buffer;
+import retrofit2.Converter;
 
 final class MoshiRequestBodyConverter<T> implements Converter<T, RequestBody> {
   private static final MediaType MEDIA_TYPE = MediaType.parse("application/json; charset=UTF-8");
@@ -32,11 +33,7 @@
 
   @Override public RequestBody convert(T value) throws IOException {
     Buffer buffer = new Buffer();
-    try {
-      adapter.toJson(buffer, value);
-    } catch (IOException e) {
-      throw new AssertionError(e); // Writing to Buffer does no I/O.
-    }
+    adapter.toJson(buffer, value);
     return RequestBody.create(MEDIA_TYPE, buffer.readByteString());
   }
 }
diff --git a/retrofit-converters/moshi/src/main/java/retrofit2/MoshiResponseBodyConverter.java b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiResponseBodyConverter.java
similarity index 94%
rename from retrofit-converters/moshi/src/main/java/retrofit2/MoshiResponseBodyConverter.java
rename to retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiResponseBodyConverter.java
index 8d093ae0c..b45b99c42 100644
--- a/retrofit-converters/moshi/src/main/java/retrofit2/MoshiResponseBodyConverter.java
+++ b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiResponseBodyConverter.java
@@ -13,11 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.moshi;
 
 import com.squareup.moshi.JsonAdapter;
 import java.io.IOException;
 import okhttp3.ResponseBody;
+import retrofit2.Converter;
 
 final class MoshiResponseBodyConverter<T> implements Converter<ResponseBody, T> {
   private final JsonAdapter<T> adapter;
diff --git a/retrofit-converters/moshi/src/test/java/retrofit2/MoshiConverterFactoryTest.java b/retrofit-converters/moshi/src/test/java/retrofit2/converter/moshi/MoshiConverterFactoryTest.java
similarity index 73%
rename from retrofit-converters/moshi/src/test/java/retrofit2/MoshiConverterFactoryTest.java
rename to retrofit-converters/moshi/src/test/java/retrofit2/converter/moshi/MoshiConverterFactoryTest.java
index aefed5625..3a54a7ebe 100644
--- a/retrofit-converters/moshi/src/test/java/retrofit2/MoshiConverterFactoryTest.java
+++ b/retrofit-converters/moshi/src/test/java/retrofit2/converter/moshi/MoshiConverterFactoryTest.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.moshi;
 
 import com.squareup.moshi.FromJson;
 import com.squareup.moshi.JsonReader;
@@ -27,10 +27,15 @@
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+import retrofit2.Call;
+import retrofit2.Response;
+import retrofit2.Retrofit;
 import retrofit2.http.Body;
 import retrofit2.http.POST;
 
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
 
 public final class MoshiConverterFactoryTest {
   interface AnInterface {
@@ -81,16 +86,24 @@
   @Rule public final MockWebServer server = new MockWebServer();
 
   private Service service;
+  private Service serviceLenient;
 
   @Before public void setUp() {
     Moshi moshi = new Moshi.Builder()
         .add(new AnInterfaceAdapter())
         .build();
+    MoshiConverterFactory factory = MoshiConverterFactory.create(moshi);
+    MoshiConverterFactory factoryLenient = factory.asLenient();
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
-        .addConverterFactory(MoshiConverterFactory.create(moshi))
+        .addConverterFactory(factory)
+        .build();
+    Retrofit retrofitLenient = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(factoryLenient)
         .build();
     service = retrofit.create(Service.class);
+    serviceLenient = retrofitLenient.create(Service.class);
   }
 
   @Test public void anInterface() throws IOException, InterruptedException {
@@ -118,4 +131,24 @@
     assertThat(request.getBody().readUtf8()).isEqualTo("{\"theName\":\"value\"}");
     assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
   }
+
+  @Test public void asLenient() throws IOException, InterruptedException {
+    MockResponse malformedResponse = new MockResponse().setBody("{\"theName\":value}");
+    server.enqueue(malformedResponse);
+    server.enqueue(malformedResponse);
+
+    Call<AnImplementation> call = service.anImplementation(new AnImplementation("value"));
+    try {
+      call.execute();
+      fail();
+    } catch (IOException e) {
+      assertEquals(e.getMessage(),
+          "Use JsonReader.setLenient(true) to accept malformed JSON at path $.theName");
+    }
+
+    Call<AnImplementation> call2 = serviceLenient.anImplementation(new AnImplementation("value"));
+    Response<AnImplementation> response = call2.execute();
+    AnImplementation body = response.body();
+    assertThat(body.theName).isEqualTo("value");
+  }
 }
diff --git a/retrofit-converters/protobuf/src/main/java/retrofit2/ProtoConverterFactory.java b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoConverterFactory.java
similarity index 92%
rename from retrofit-converters/protobuf/src/main/java/retrofit2/ProtoConverterFactory.java
rename to retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoConverterFactory.java
index 218b44e52..aa4420c9d 100644
--- a/retrofit-converters/protobuf/src/main/java/retrofit2/ProtoConverterFactory.java
+++ b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoConverterFactory.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.protobuf;
 
 import com.google.protobuf.MessageLite;
 import com.google.protobuf.Parser;
@@ -22,6 +22,8 @@
 import java.lang.reflect.Type;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
 
 /**
  * A {@linkplain Converter.Factory converter} which uses Protocol Buffers.
@@ -58,8 +60,8 @@ public static ProtoConverterFactory create() {
   }
 
   @Override
-  public Converter<?, RequestBody> requestBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
+  public Converter<?, RequestBody> requestBodyConverter(Type type,
+      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     if (!(type instanceof Class<?>)) {
       return null;
     }
diff --git a/retrofit-converters/protobuf/src/main/java/retrofit2/ProtoRequestBodyConverter.java b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoRequestBodyConverter.java
similarity index 94%
rename from retrofit-converters/protobuf/src/main/java/retrofit2/ProtoRequestBodyConverter.java
rename to retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoRequestBodyConverter.java
index a8b87f418..814dc326b 100644
--- a/retrofit-converters/protobuf/src/main/java/retrofit2/ProtoRequestBodyConverter.java
+++ b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoRequestBodyConverter.java
@@ -13,12 +13,13 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.protobuf;
 
 import com.google.protobuf.MessageLite;
 import java.io.IOException;
 import okhttp3.MediaType;
 import okhttp3.RequestBody;
+import retrofit2.Converter;
 
 final class ProtoRequestBodyConverter<T extends MessageLite> implements Converter<T, RequestBody> {
   private static final MediaType MEDIA_TYPE = MediaType.parse("application/x-protobuf");
diff --git a/retrofit-converters/protobuf/src/main/java/retrofit2/ProtoResponseBodyConverter.java b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoResponseBodyConverter.java
similarity index 95%
rename from retrofit-converters/protobuf/src/main/java/retrofit2/ProtoResponseBodyConverter.java
rename to retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoResponseBodyConverter.java
index c3108ee11..f2b78e1de 100644
--- a/retrofit-converters/protobuf/src/main/java/retrofit2/ProtoResponseBodyConverter.java
+++ b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoResponseBodyConverter.java
@@ -13,13 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.protobuf;
 
 import com.google.protobuf.InvalidProtocolBufferException;
 import com.google.protobuf.MessageLite;
 import com.google.protobuf.Parser;
 import java.io.IOException;
 import okhttp3.ResponseBody;
+import retrofit2.Converter;
 
 final class ProtoResponseBodyConverter<T extends MessageLite>
     implements Converter<ResponseBody, T> {
diff --git a/retrofit-converters/protobuf/src/test/java/retrofit2/PhoneProtos.java b/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/PhoneProtos.java
similarity index 99%
rename from retrofit-converters/protobuf/src/test/java/retrofit2/PhoneProtos.java
rename to retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/PhoneProtos.java
index e75ba0979..69b41325b 100644
--- a/retrofit-converters/protobuf/src/test/java/retrofit2/PhoneProtos.java
+++ b/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/PhoneProtos.java
@@ -1,7 +1,7 @@
 // Generated by the protocol buffer compiler.  DO NOT EDIT!
 // source: protos/phone.proto
 
-package retrofit2;
+package retrofit2.converter.protobuf;
 
 import com.google.protobuf.AbstractMessage;
 
@@ -294,7 +294,7 @@ protected Builder newBuilderForType(
                 PhoneProtos.Phone.class, PhoneProtos.Phone.Builder.class);
       }
 
-      // Construct using retrofit2.PhoneProtos.Phone.newBuilder()
+      // Construct using retrofit2.converter.protobuf.PhoneProtos.Phone.newBuilder()
       private Builder() {
         maybeForceBuilderInitialization();
       }
diff --git a/retrofit-converters/protobuf/src/test/java/retrofit2/ProtoConverterFactoryTest.java b/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/ProtoConverterFactoryTest.java
similarity index 80%
rename from retrofit-converters/protobuf/src/test/java/retrofit2/ProtoConverterFactoryTest.java
rename to retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/ProtoConverterFactoryTest.java
index 4eea462cf..f2ca958f4 100644
--- a/retrofit-converters/protobuf/src/test/java/retrofit2/ProtoConverterFactoryTest.java
+++ b/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/ProtoConverterFactoryTest.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.protobuf;
 
 import com.google.protobuf.InvalidProtocolBufferException;
 import java.io.IOException;
@@ -26,13 +26,16 @@
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+import retrofit2.Call;
+import retrofit2.Response;
+import retrofit2.Retrofit;
 import retrofit2.http.Body;
 import retrofit2.http.GET;
 import retrofit2.http.POST;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
-import static retrofit2.PhoneProtos.Phone;
+import static retrofit2.converter.protobuf.PhoneProtos.Phone;
 
 public final class ProtoConverterFactoryTest {
   interface Service {
@@ -85,12 +88,14 @@
       service.wrongClass();
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Unable to create converter for class java.lang.String\n"
+      assertThat(e).hasMessage(""
+          + "Unable to create converter for class java.lang.String\n"
           + "    for method Service.wrongClass");
-      assertThat(e.getCause()).hasMessage(
-          "Could not locate ResponseBody converter for class java.lang.String. Tried:\n"
-              + " * retrofit2.BuiltInConverters\n"
-              + " * retrofit2.ProtoConverterFactory");
+      assertThat(e.getCause()).hasMessage(""
+          + "Could not locate ResponseBody converter for class java.lang.String.\n"
+          + "  Tried:\n"
+          + "   * retrofit2.BuiltInConverters\n"
+          + "   * retrofit2.converter.protobuf.ProtoConverterFactory");
     }
   }
 
@@ -102,12 +107,14 @@
       service.wrongType();
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Unable to create converter for java.util.List<java.lang.String>\n"
+      assertThat(e).hasMessage(""
+          + "Unable to create converter for java.util.List<java.lang.String>\n"
           + "    for method Service.wrongType");
-      assertThat(e.getCause()).hasMessage(
-          "Could not locate ResponseBody converter for java.util.List<java.lang.String>. Tried:\n"
-              + " * retrofit2.BuiltInConverters\n"
-              + " * retrofit2.ProtoConverterFactory");
+      assertThat(e.getCause()).hasMessage(""
+          + "Could not locate ResponseBody converter for java.util.List<java.lang.String>.\n"
+          + "  Tried:\n"
+          + "   * retrofit2.BuiltInConverters\n"
+          + "   * retrofit2.converter.protobuf.ProtoConverterFactory");
     }
   }
 
diff --git a/retrofit-converters/protobuf/src/test/protos/phone.proto b/retrofit-converters/protobuf/src/test/protos/phone.proto
index 00fb8e133..69876668b 100644
--- a/retrofit-converters/protobuf/src/test/protos/phone.proto
+++ b/retrofit-converters/protobuf/src/test/protos/phone.proto
@@ -1,4 +1,4 @@
-package retrofit2;
+package retrofit2.converter.protobuf;
 
 option java_package = "retrofit2";
 option java_outer_classname = "PhoneProtos";
diff --git a/retrofit-converters/scalars/src/main/java/retrofit2/ScalarRequestBodyConverter.java b/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarRequestBodyConverter.java
similarity index 94%
rename from retrofit-converters/scalars/src/main/java/retrofit2/ScalarRequestBodyConverter.java
rename to retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarRequestBodyConverter.java
index f2953485d..fd65200d4 100644
--- a/retrofit-converters/scalars/src/main/java/retrofit2/ScalarRequestBodyConverter.java
+++ b/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarRequestBodyConverter.java
@@ -13,11 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.scalars;
 
 import java.io.IOException;
 import okhttp3.MediaType;
 import okhttp3.RequestBody;
+import retrofit2.Converter;
 
 final class ScalarRequestBodyConverter<T> implements Converter<T, RequestBody> {
   static final ScalarRequestBodyConverter<Object> INSTANCE = new ScalarRequestBodyConverter<>();
diff --git a/retrofit-converters/scalars/src/main/java/retrofit2/ScalarResponseBodyConverters.java b/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarResponseBodyConverters.java
similarity index 98%
rename from retrofit-converters/scalars/src/main/java/retrofit2/ScalarResponseBodyConverters.java
rename to retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarResponseBodyConverters.java
index bee93503a..a91d87c82 100644
--- a/retrofit-converters/scalars/src/main/java/retrofit2/ScalarResponseBodyConverters.java
+++ b/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarResponseBodyConverters.java
@@ -13,10 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.scalars;
 
 import java.io.IOException;
 import okhttp3.ResponseBody;
+import retrofit2.Converter;
 
 final class ScalarResponseBodyConverters {
   private ScalarResponseBodyConverters() {
diff --git a/retrofit-converters/scalars/src/main/java/retrofit2/ScalarsConverterFactory.java b/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarsConverterFactory.java
similarity index 60%
rename from retrofit-converters/scalars/src/main/java/retrofit2/ScalarsConverterFactory.java
rename to retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarsConverterFactory.java
index 3acc52790..5bf838fe9 100644
--- a/retrofit-converters/scalars/src/main/java/retrofit2/ScalarsConverterFactory.java
+++ b/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarsConverterFactory.java
@@ -13,21 +13,23 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.scalars;
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
-import retrofit2.ScalarResponseBodyConverters.BooleanResponseBodyConverter;
-import retrofit2.ScalarResponseBodyConverters.ByteResponseBodyConverter;
-import retrofit2.ScalarResponseBodyConverters.CharacterResponseBodyConverter;
-import retrofit2.ScalarResponseBodyConverters.DoubleResponseBodyConverter;
-import retrofit2.ScalarResponseBodyConverters.FloatResponseBodyConverter;
-import retrofit2.ScalarResponseBodyConverters.IntegerResponseBodyConverter;
-import retrofit2.ScalarResponseBodyConverters.LongResponseBodyConverter;
-import retrofit2.ScalarResponseBodyConverters.ShortResponseBodyConverter;
-import retrofit2.ScalarResponseBodyConverters.StringResponseBodyConverter;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
+import retrofit2.converter.scalars.ScalarResponseBodyConverters.BooleanResponseBodyConverter;
+import retrofit2.converter.scalars.ScalarResponseBodyConverters.ByteResponseBodyConverter;
+import retrofit2.converter.scalars.ScalarResponseBodyConverters.CharacterResponseBodyConverter;
+import retrofit2.converter.scalars.ScalarResponseBodyConverters.DoubleResponseBodyConverter;
+import retrofit2.converter.scalars.ScalarResponseBodyConverters.FloatResponseBodyConverter;
+import retrofit2.converter.scalars.ScalarResponseBodyConverters.IntegerResponseBodyConverter;
+import retrofit2.converter.scalars.ScalarResponseBodyConverters.LongResponseBodyConverter;
+import retrofit2.converter.scalars.ScalarResponseBodyConverters.ShortResponseBodyConverter;
+import retrofit2.converter.scalars.ScalarResponseBodyConverters.StringResponseBodyConverter;
 
 /**
  * A {@linkplain Converter.Factory converter} for strings and both primitives and their boxed types
@@ -41,9 +43,8 @@ public static ScalarsConverterFactory create() {
   private ScalarsConverterFactory() {
   }
 
-  @Override
-  public Converter<?, RequestBody> requestBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
+  @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
+      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     if (type == String.class
         || type == boolean.class
         || type == Boolean.class
@@ -72,28 +73,28 @@ private ScalarsConverterFactory() {
     if (type == String.class) {
       return StringResponseBodyConverter.INSTANCE;
     }
-    if (type == Boolean.class) {
+    if (type == Boolean.class || type == boolean.class) {
       return BooleanResponseBodyConverter.INSTANCE;
     }
-    if (type == Byte.class) {
+    if (type == Byte.class || type == byte.class) {
       return ByteResponseBodyConverter.INSTANCE;
     }
-    if (type == Character.class) {
+    if (type == Character.class || type == char.class) {
       return CharacterResponseBodyConverter.INSTANCE;
     }
-    if (type == Double.class) {
+    if (type == Double.class || type == double.class) {
       return DoubleResponseBodyConverter.INSTANCE;
     }
-    if (type == Float.class) {
+    if (type == Float.class || type == float.class) {
       return FloatResponseBodyConverter.INSTANCE;
     }
-    if (type == Integer.class) {
+    if (type == Integer.class || type == int.class) {
       return IntegerResponseBodyConverter.INSTANCE;
     }
-    if (type == Long.class) {
+    if (type == Long.class || type == long.class) {
       return LongResponseBodyConverter.INSTANCE;
     }
-    if (type == Short.class) {
+    if (type == Short.class || type == short.class) {
       return ShortResponseBodyConverter.INSTANCE;
     }
     return null;
diff --git a/retrofit-converters/scalars/src/test/java/retrofit2/ScalarsConverterFactoryTest.java b/retrofit-converters/scalars/src/test/java/retrofit2/converter/scalars/ScalarsConverterFactoryTest.java
similarity index 91%
rename from retrofit-converters/scalars/src/test/java/retrofit2/ScalarsConverterFactoryTest.java
rename to retrofit-converters/scalars/src/test/java/retrofit2/converter/scalars/ScalarsConverterFactoryTest.java
index f32052188..cc19d4fbc 100644
--- a/retrofit-converters/scalars/src/test/java/retrofit2/ScalarsConverterFactoryTest.java
+++ b/retrofit-converters/scalars/src/test/java/retrofit2/converter/scalars/ScalarsConverterFactoryTest.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.scalars;
 
 import java.io.IOException;
 import okhttp3.ResponseBody;
@@ -23,6 +23,10 @@
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+import retrofit2.Call;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.converter.scalars.ScalarsConverterFactory;
 import retrofit2.http.Body;
 import retrofit2.http.GET;
 import retrofit2.http.POST;
@@ -82,13 +86,14 @@
       service.object(null);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Unable to create @Body converter for class java.lang.Object (parameter #1)\n"
-              + "    for method Service.object");
-      assertThat(e.getCause()).hasMessage(
-          "Could not locate RequestBody converter for class java.lang.Object. Tried:\n"
-              + " * retrofit2.BuiltInConverters\n"
-              + " * retrofit2.ScalarsConverterFactory");
+      assertThat(e).hasMessage(""
+          + "Unable to create @Body converter for class java.lang.Object (parameter #1)\n"
+          + "    for method Service.object");
+      assertThat(e.getCause()).hasMessage(""
+          + "Could not locate RequestBody converter for class java.lang.Object.\n"
+          + "  Tried:\n"
+          + "   * retrofit2.BuiltInConverters\n"
+          + "   * retrofit2.converter.scalars.ScalarsConverterFactory");
     }
   }
 
@@ -220,12 +225,14 @@
       service.object();
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Unable to create converter for class java.lang.Object\n"
-              + "    for method Service.object");
-      assertThat(e.getCause()).hasMessage(
-          "Could not locate ResponseBody converter for class java.lang.Object. Tried:\n"
-              + " * retrofit2.BuiltInConverters\n" + " * retrofit2.ScalarsConverterFactory");
+      assertThat(e).hasMessage(""
+          + "Unable to create converter for class java.lang.Object\n"
+          + "    for method Service.object");
+      assertThat(e.getCause()).hasMessage(""
+          + "Could not locate ResponseBody converter for class java.lang.Object.\n"
+          + "  Tried:\n"
+          + "   * retrofit2.BuiltInConverters\n"
+          + "   * retrofit2.converter.scalars.ScalarsConverterFactory");
     }
   }
 
diff --git a/retrofit-converters/scalars/src/test/java/retrofit2/converter/scalars/ScalarsConverterPrimitivesFactoryTest.java b/retrofit-converters/scalars/src/test/java/retrofit2/converter/scalars/ScalarsConverterPrimitivesFactoryTest.java
new file mode 100644
index 000000000..3bbd190bb
--- /dev/null
+++ b/retrofit-converters/scalars/src/test/java/retrofit2/converter/scalars/ScalarsConverterPrimitivesFactoryTest.java
@@ -0,0 +1,130 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.converter.scalars;
+
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Call;
+import retrofit2.CallAdapter;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class ScalarsConverterPrimitivesFactoryTest {
+  interface Service {
+    @GET("/") boolean booleanPrimitive();
+    @GET("/") byte bytePrimitive();
+    @GET("/") char charPrimitive();
+    @GET("/") double doublePrimitive();
+    @GET("/") float floatPrimitive();
+    @GET("/") int integerPrimitive();
+    @GET("/") long longPrimitive();
+    @GET("/") short shortPrimitive();
+  }
+
+  static class DirectCallIOException extends RuntimeException {
+    DirectCallIOException(String message, IOException e) {
+      super(message, e);
+    }
+  }
+
+  static class DirectCallAdapterFactory extends CallAdapter.Factory {
+    @Override
+    public CallAdapter<?> get(final Type returnType, Annotation[] annotations, Retrofit retrofit) {
+      return new CallAdapter<Object>() {
+        @Override public Type responseType() {
+          return returnType;
+        }
+
+        @Override public Object adapt(Call call) {
+          try {
+            return call.execute().body();
+          } catch (IOException e) {
+            throw new DirectCallIOException(e.getMessage(), e);
+          }
+        }
+      };
+    }
+  }
+
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(ScalarsConverterFactory.create())
+        .addCallAdapterFactory(new DirectCallAdapterFactory())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void supportedResponseTypes() throws IOException, InterruptedException {
+    server.enqueue(new MockResponse().setBody("true"));
+    boolean booleanResponse = service.booleanPrimitive();
+    assertThat(booleanResponse).isTrue();
+
+    server.enqueue(new MockResponse().setBody("5"));
+    byte byteResponse = service.bytePrimitive();
+    assertThat(byteResponse).isEqualTo((byte) 5);
+
+    server.enqueue(new MockResponse().setBody("b"));
+    char characterResponse = service.charPrimitive();
+    assertThat(characterResponse).isEqualTo('b');
+
+    server.enqueue(new MockResponse().setBody(""));
+    try {
+      service.charPrimitive();
+    } catch (DirectCallIOException e) {
+      assertThat(e).hasMessage("Expected body of length 1 for Character conversion but was 0");
+    }
+
+    server.enqueue(new MockResponse().setBody("bb"));
+    try {
+      service.charPrimitive();
+    } catch (DirectCallIOException e) {
+      assertThat(e).hasMessage("Expected body of length 1 for Character conversion but was 2");
+    }
+
+    server.enqueue(new MockResponse().setBody("13.13"));
+    double doubleResponse = service.doublePrimitive();
+    assertThat(doubleResponse).isEqualTo(13.13);
+
+    server.enqueue(new MockResponse().setBody("13.13"));
+    float floatResponse = service.floatPrimitive();
+    assertThat(floatResponse).isEqualTo(13.13f);
+
+    server.enqueue(new MockResponse().setBody("13"));
+    int integerResponse = service.integerPrimitive();
+    assertThat(integerResponse).isEqualTo(13);
+
+    server.enqueue(new MockResponse().setBody("1347"));
+    long longResponse = service.longPrimitive();
+    assertThat(longResponse).isEqualTo(1347L);
+
+    server.enqueue(new MockResponse().setBody("134"));
+    short shortResponse = service.shortPrimitive();
+    assertThat(shortResponse).isEqualTo((short) 134);
+  }
+}
diff --git a/retrofit-converters/simplexml/src/main/java/retrofit2/SimpleXmlConverterFactory.java b/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlConverterFactory.java
similarity index 93%
rename from retrofit-converters/simplexml/src/main/java/retrofit2/SimpleXmlConverterFactory.java
rename to retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlConverterFactory.java
index bc0b0db2b..b7563455e 100644
--- a/retrofit-converters/simplexml/src/main/java/retrofit2/SimpleXmlConverterFactory.java
+++ b/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlConverterFactory.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.simplexml;
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
@@ -21,6 +21,8 @@
 import okhttp3.ResponseBody;
 import org.simpleframework.xml.Serializer;
 import org.simpleframework.xml.core.Persister;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
 
 /**
  * A {@linkplain Converter.Factory converter} which uses Simple Framework for XML.
@@ -73,8 +75,8 @@ public boolean isStrict() {
   }
 
   @Override
-  public Converter<?, RequestBody> requestBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
+  public Converter<?, RequestBody> requestBodyConverter(Type type,
+      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     if (!(type instanceof Class)) {
       return null;
     }
diff --git a/retrofit-converters/simplexml/src/main/java/retrofit2/SimpleXmlRequestBodyConverter.java b/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlRequestBodyConverter.java
similarity index 95%
rename from retrofit-converters/simplexml/src/main/java/retrofit2/SimpleXmlRequestBodyConverter.java
rename to retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlRequestBodyConverter.java
index 03344875a..06aeee1e6 100644
--- a/retrofit-converters/simplexml/src/main/java/retrofit2/SimpleXmlRequestBodyConverter.java
+++ b/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlRequestBodyConverter.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.simplexml;
 
 import java.io.IOException;
 import java.io.OutputStreamWriter;
@@ -21,6 +21,7 @@
 import okhttp3.RequestBody;
 import okio.Buffer;
 import org.simpleframework.xml.Serializer;
+import retrofit2.Converter;
 
 final class SimpleXmlRequestBodyConverter<T> implements Converter<T, RequestBody> {
   private static final MediaType MEDIA_TYPE = MediaType.parse("application/xml; charset=UTF-8");
diff --git a/retrofit-converters/simplexml/src/main/java/retrofit2/SimpleXmlResponseBodyConverter.java b/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlResponseBodyConverter.java
similarity index 95%
rename from retrofit-converters/simplexml/src/main/java/retrofit2/SimpleXmlResponseBodyConverter.java
rename to retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlResponseBodyConverter.java
index f50c012fe..21bf3ae6c 100644
--- a/retrofit-converters/simplexml/src/main/java/retrofit2/SimpleXmlResponseBodyConverter.java
+++ b/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlResponseBodyConverter.java
@@ -13,11 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.simplexml;
 
 import java.io.IOException;
 import okhttp3.ResponseBody;
 import org.simpleframework.xml.Serializer;
+import retrofit2.Converter;
 
 final class SimpleXmlResponseBodyConverter<T> implements Converter<ResponseBody, T> {
   private final Class<T> cls;
diff --git a/retrofit-converters/simplexml/src/test/java/retrofit2/MyObject.java b/retrofit-converters/simplexml/src/test/java/retrofit2/converter/simplexml/MyObject.java
similarity index 97%
rename from retrofit-converters/simplexml/src/test/java/retrofit2/MyObject.java
rename to retrofit-converters/simplexml/src/test/java/retrofit2/converter/simplexml/MyObject.java
index 3730b9544..18d2e146f 100644
--- a/retrofit-converters/simplexml/src/test/java/retrofit2/MyObject.java
+++ b/retrofit-converters/simplexml/src/test/java/retrofit2/converter/simplexml/MyObject.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.simplexml;
 
 import org.simpleframework.xml.Default;
 import org.simpleframework.xml.DefaultType;
diff --git a/retrofit-converters/simplexml/src/test/java/retrofit2/SimpleXmlConverterFactoryTest.java b/retrofit-converters/simplexml/src/test/java/retrofit2/converter/simplexml/SimpleXmlConverterFactoryTest.java
similarity index 95%
rename from retrofit-converters/simplexml/src/test/java/retrofit2/SimpleXmlConverterFactoryTest.java
rename to retrofit-converters/simplexml/src/test/java/retrofit2/converter/simplexml/SimpleXmlConverterFactoryTest.java
index 324664611..8a74a8055 100644
--- a/retrofit-converters/simplexml/src/test/java/retrofit2/SimpleXmlConverterFactoryTest.java
+++ b/retrofit-converters/simplexml/src/test/java/retrofit2/converter/simplexml/SimpleXmlConverterFactoryTest.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.simplexml;
 
 import java.io.IOException;
 import okhttp3.mockwebserver.MockResponse;
@@ -27,6 +27,9 @@
 import org.simpleframework.xml.stream.Format;
 import org.simpleframework.xml.stream.HyphenStyle;
 import org.simpleframework.xml.stream.Verbosity;
+import retrofit2.Call;
+import retrofit2.Response;
+import retrofit2.Retrofit;
 import retrofit2.http.Body;
 import retrofit2.http.GET;
 import retrofit2.http.POST;
@@ -80,7 +83,7 @@
       fail();
     } catch (RuntimeException e) {
       assertThat(e.getCause()).isInstanceOf(ElementException.class)
-          .hasMessageStartingWith("Element 'foo' does not have a match in class retrofit2.MyObject");
+          .hasMessageStartingWith("Element 'foo' does not have a match in class retrofit2.converter.simplexml.MyObject");
     }
   }
 
diff --git a/retrofit-converters/wire/src/main/java/retrofit2/WireConverterFactory.java b/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireConverterFactory.java
similarity index 91%
rename from retrofit-converters/wire/src/main/java/retrofit2/WireConverterFactory.java
rename to retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireConverterFactory.java
index 2437ca696..fbaaeac4a 100644
--- a/retrofit-converters/wire/src/main/java/retrofit2/WireConverterFactory.java
+++ b/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireConverterFactory.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.wire;
 
 import com.squareup.wire.Message;
 import com.squareup.wire.ProtoAdapter;
@@ -21,6 +21,8 @@
 import java.lang.reflect.Type;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
 
 /**
  * A {@linkplain Converter.Factory converter} that uses Wire for protocol buffers.
@@ -51,8 +53,8 @@ private WireConverterFactory() {
   }
 
   @Override
-  public Converter<?, RequestBody> requestBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
+  public Converter<?, RequestBody> requestBodyConverter(Type type,
+      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     if (!(type instanceof Class<?>)) {
       return null;
     }
diff --git a/retrofit-converters/wire/src/main/java/retrofit2/WireRequestBodyConverter.java b/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireRequestBodyConverter.java
similarity index 95%
rename from retrofit-converters/wire/src/main/java/retrofit2/WireRequestBodyConverter.java
rename to retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireRequestBodyConverter.java
index 6a47d02ec..d388a944c 100644
--- a/retrofit-converters/wire/src/main/java/retrofit2/WireRequestBodyConverter.java
+++ b/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireRequestBodyConverter.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.wire;
 
 import com.squareup.wire.Message;
 import com.squareup.wire.ProtoAdapter;
@@ -21,6 +21,7 @@
 import okhttp3.MediaType;
 import okhttp3.RequestBody;
 import okio.Buffer;
+import retrofit2.Converter;
 
 final class WireRequestBodyConverter<T extends Message<T, ?>> implements Converter<T, RequestBody> {
   private static final MediaType MEDIA_TYPE = MediaType.parse("application/x-protobuf");
diff --git a/retrofit-converters/wire/src/main/java/retrofit2/WireResponseBodyConverter.java b/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireResponseBodyConverter.java
similarity index 94%
rename from retrofit-converters/wire/src/main/java/retrofit2/WireResponseBodyConverter.java
rename to retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireResponseBodyConverter.java
index 03235e8f5..5ab321381 100644
--- a/retrofit-converters/wire/src/main/java/retrofit2/WireResponseBodyConverter.java
+++ b/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireResponseBodyConverter.java
@@ -13,12 +13,13 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.wire;
 
 import com.squareup.wire.Message;
 import com.squareup.wire.ProtoAdapter;
 import java.io.IOException;
 import okhttp3.ResponseBody;
+import retrofit2.Converter;
 
 final class WireResponseBodyConverter<T extends Message<T, ?>>
     implements Converter<ResponseBody, T> {
diff --git a/retrofit-converters/wire/src/test/java/retrofit2/Phone.java b/retrofit-converters/wire/src/test/java/retrofit2/converter/wire/Phone.java
similarity index 83%
rename from retrofit-converters/wire/src/test/java/retrofit2/Phone.java
rename to retrofit-converters/wire/src/test/java/retrofit2/converter/wire/Phone.java
index 078a4c80a..c085094bb 100644
--- a/retrofit-converters/wire/src/test/java/retrofit2/Phone.java
+++ b/retrofit-converters/wire/src/test/java/retrofit2/converter/wire/Phone.java
@@ -1,12 +1,14 @@
 // Code generated by Wire protocol buffer compiler, do not edit.
-// Source file: test.proto at 2:1
-package retrofit2;
+// Source file: phone.proto at 6:1
+package retrofit2.converter.wire;
 
 import com.squareup.wire.FieldEncoding;
 import com.squareup.wire.Message;
 import com.squareup.wire.ProtoAdapter;
 import com.squareup.wire.ProtoReader;
 import com.squareup.wire.ProtoWriter;
+import com.squareup.wire.WireField;
+import com.squareup.wire.internal.Internal;
 import java.io.IOException;
 import java.lang.Object;
 import java.lang.Override;
@@ -15,49 +17,16 @@
 import okio.ByteString;
 
 public final class Phone extends Message<Phone, Phone.Builder> {
-  public static final ProtoAdapter<Phone> ADAPTER = new ProtoAdapter<Phone>(FieldEncoding.LENGTH_DELIMITED, Phone.class) {
-    @Override
-    public int encodedSize(Phone value) {
-      return (value.number != null ? ProtoAdapter.STRING.encodedSizeWithTag(1, value.number) : 0)
-          + value.unknownFields().size();
-    }
-
-    @Override
-    public void encode(ProtoWriter writer, Phone value) throws IOException {
-      if (value.number != null) ProtoAdapter.STRING.encodeWithTag(writer, 1, value.number);
-      writer.writeBytes(value.unknownFields());
-    }
-
-    @Override
-    public Phone decode(ProtoReader reader) throws IOException {
-      Builder builder = new Builder();
-      long token = reader.beginMessage();
-      for (int tag; (tag = reader.nextTag()) != -1;) {
-        switch (tag) {
-          case 1: builder.number(ProtoAdapter.STRING.decode(reader)); break;
-          default: {
-            FieldEncoding fieldEncoding = reader.peekFieldEncoding();
-            Object value = fieldEncoding.rawProtoAdapter().decode(reader);
-            builder.addUnknownField(tag, fieldEncoding, value);
-          }
-        }
-      }
-      reader.endMessage(token);
-      return builder.build();
-    }
-
-    @Override
-    public Phone redact(Phone value) {
-      Builder builder = value.newBuilder();
-      builder.clearUnknownFields();
-      return builder.build();
-    }
-  };
+  public static final ProtoAdapter<Phone> ADAPTER = new ProtoAdapter_Phone();
 
   private static final long serialVersionUID = 0L;
 
   public static final String DEFAULT_NUMBER = "";
 
+  @WireField(
+      tag = 1,
+      adapter = "com.squareup.wire.ProtoAdapter#STRING"
+  )
   public final String number;
 
   public Phone(String number) {
@@ -65,7 +34,7 @@ public Phone(String number) {
   }
 
   public Phone(String number, ByteString unknownFields) {
-    super(unknownFields);
+    super(ADAPTER, unknownFields);
     this.number = number;
   }
 
@@ -82,8 +51,8 @@ public boolean equals(Object other) {
     if (other == this) return true;
     if (!(other instanceof Phone)) return false;
     Phone o = (Phone) other;
-    return equals(unknownFields(), o.unknownFields())
-        && equals(number, o.number);
+    return Internal.equals(unknownFields(), o.unknownFields())
+        && Internal.equals(number, o.number);
   }
 
   @Override
@@ -104,7 +73,7 @@ public String toString() {
     return builder.replace(0, 2, "Phone{").append('}').toString();
   }
 
-  public static final class Builder extends com.squareup.wire.Message.Builder<Phone, Builder> {
+  public static final class Builder extends Message.Builder<Phone, Builder> {
     public String number;
 
     public Builder() {
@@ -120,4 +89,47 @@ public Phone build() {
       return new Phone(number, buildUnknownFields());
     }
   }
+
+  private static final class ProtoAdapter_Phone extends ProtoAdapter<Phone> {
+    ProtoAdapter_Phone() {
+      super(FieldEncoding.LENGTH_DELIMITED, Phone.class);
+    }
+
+    @Override
+    public int encodedSize(Phone value) {
+      return (value.number != null ? ProtoAdapter.STRING.encodedSizeWithTag(1, value.number) : 0)
+          + value.unknownFields().size();
+    }
+
+    @Override
+    public void encode(ProtoWriter writer, Phone value) throws IOException {
+      if (value.number != null) ProtoAdapter.STRING.encodeWithTag(writer, 1, value.number);
+      writer.writeBytes(value.unknownFields());
+    }
+
+    @Override
+    public Phone decode(ProtoReader reader) throws IOException {
+      Builder builder = new Builder();
+      long token = reader.beginMessage();
+      for (int tag; (tag = reader.nextTag()) != -1;) {
+        switch (tag) {
+          case 1: builder.number(ProtoAdapter.STRING.decode(reader)); break;
+          default: {
+            FieldEncoding fieldEncoding = reader.peekFieldEncoding();
+            Object value = fieldEncoding.rawProtoAdapter().decode(reader);
+            builder.addUnknownField(tag, fieldEncoding, value);
+          }
+        }
+      }
+      reader.endMessage(token);
+      return builder.build();
+    }
+
+    @Override
+    public Phone redact(Phone value) {
+      Builder builder = value.newBuilder();
+      builder.clearUnknownFields();
+      return builder.build();
+    }
+  }
 }
diff --git a/retrofit-converters/wire/src/test/java/retrofit2/WireConverterFactoryTest.java b/retrofit-converters/wire/src/test/java/retrofit2/converter/wire/WireConverterFactoryTest.java
similarity index 80%
rename from retrofit-converters/wire/src/test/java/retrofit2/WireConverterFactoryTest.java
rename to retrofit-converters/wire/src/test/java/retrofit2/converter/wire/WireConverterFactoryTest.java
index 4a868e652..e972d5287 100644
--- a/retrofit-converters/wire/src/test/java/retrofit2/WireConverterFactoryTest.java
+++ b/retrofit-converters/wire/src/test/java/retrofit2/converter/wire/WireConverterFactoryTest.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.wire;
 
 import java.io.EOFException;
 import java.io.IOException;
@@ -26,6 +26,9 @@
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+import retrofit2.Call;
+import retrofit2.Response;
+import retrofit2.Retrofit;
 import retrofit2.http.Body;
 import retrofit2.http.GET;
 import retrofit2.http.POST;
@@ -84,12 +87,14 @@
       service.wrongClass();
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Unable to create converter for class java.lang.String\n"
+      assertThat(e).hasMessage(""
+          + "Unable to create converter for class java.lang.String\n"
           + "    for method Service.wrongClass");
-      assertThat(e.getCause()).hasMessage(
-          "Could not locate ResponseBody converter for class java.lang.String. Tried:\n"
-              + " * retrofit2.BuiltInConverters\n"
-              + " * retrofit2.WireConverterFactory");
+      assertThat(e.getCause()).hasMessage(""
+          + "Could not locate ResponseBody converter for class java.lang.String.\n"
+          + "  Tried:\n"
+          + "   * retrofit2.BuiltInConverters\n"
+          + "   * retrofit2.converter.wire.WireConverterFactory");
     }
   }
 
@@ -101,12 +106,14 @@
       service.wrongType();
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Unable to create converter for java.util.List<java.lang.String>\n"
+      assertThat(e).hasMessage(""
+          + "Unable to create converter for java.util.List<java.lang.String>\n"
           + "    for method Service.wrongType");
-      assertThat(e.getCause()).hasMessage(
-          "Could not locate ResponseBody converter for java.util.List<java.lang.String>. Tried:\n"
-              + " * retrofit2.BuiltInConverters\n"
-              + " * retrofit2.WireConverterFactory");
+      assertThat(e.getCause()).hasMessage(""
+          + "Could not locate ResponseBody converter for java.util.List<java.lang.String>.\n"
+          + "  Tried:\n"
+          + "   * retrofit2.BuiltInConverters\n"
+          + "   * retrofit2.converter.wire.WireConverterFactory");
     }
   }
 
diff --git a/retrofit/src/main/java/retrofit2/BuiltInConverters.java b/retrofit/src/main/java/retrofit2/BuiltInConverters.java
index 2d224f8ec..b7983035b 100644
--- a/retrofit/src/main/java/retrofit2/BuiltInConverters.java
+++ b/retrofit/src/main/java/retrofit2/BuiltInConverters.java
@@ -39,15 +39,16 @@
   }
 
   @Override
-  public Converter<?, RequestBody> requestBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
-    if (RequestBody.class.isAssignableFrom(Utils.getRawType(type))) {
+  public Converter<?, RequestBody> requestBodyConverter(Type type,
+      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+    if (RequestBody.class.isAssignableFrom(Types.getRawType(type))) {
       return RequestBodyConverter.INSTANCE;
     }
     return null;
   }
 
-  @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations) {
+  @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
     if (type == String.class) {
       return StringConverter.INSTANCE;
     }
diff --git a/retrofit/src/main/java/retrofit2/CallAdapter.java b/retrofit/src/main/java/retrofit2/CallAdapter.java
index 7c289f5f4..7eb7104d8 100644
--- a/retrofit/src/main/java/retrofit2/CallAdapter.java
+++ b/retrofit/src/main/java/retrofit2/CallAdapter.java
@@ -16,6 +16,7 @@
 package retrofit2;
 
 import java.lang.annotation.Annotation;
+import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 
 /**
@@ -57,11 +58,28 @@
    * Creates {@link CallAdapter} instances based on the return type of {@linkplain
    * Retrofit#create(Class) the service interface} methods.
    */
-  interface Factory {
+  abstract class Factory {
     /**
      * Returns a call adapter for interface methods that return {@code returnType}, or null if it
      * cannot be handled by this factory.
      */
-    CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit);
+    public abstract CallAdapter<?> get(Type returnType, Annotation[] annotations,
+        Retrofit retrofit);
+
+    /**
+     * Extract the upper bound of the generic parameter at {@code index} from {@code type}. For
+     * example, index 1 of {@code Map<String, ? extends Runnable>} returns {@code Runnable}.
+     */
+    protected static Type getParameterUpperBound(int index, ParameterizedType type) {
+      return Utils.getParameterUpperBound(index, type);
+    }
+
+    /**
+     * Extract the raw class type from {@code type}. For example, the type representing
+     * {@code List<? extends Runnable>} returns {@code List.class}.
+     */
+    protected static Class<?> getRawType(Type type) {
+      return Types.getRawType(type);
+    }
   }
 }
diff --git a/retrofit/src/main/java/retrofit2/Converter.java b/retrofit/src/main/java/retrofit2/Converter.java
index b3ed88613..9fd8eddaf 100644
--- a/retrofit/src/main/java/retrofit2/Converter.java
+++ b/retrofit/src/main/java/retrofit2/Converter.java
@@ -57,8 +57,8 @@
      * specified by {@link Body @Body}, {@link Part @Part}, and {@link PartMap @PartMap}
      * values.
      */
-    public Converter<?, RequestBody> requestBodyConverter(Type type, Annotation[] annotations,
-        Retrofit retrofit) {
+    public Converter<?, RequestBody> requestBodyConverter(Type type,
+        Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
       return null;
     }
 
@@ -69,7 +69,8 @@
      * {@link Header @Header}, {@link Path @Path}, {@link Query @Query}, and
      * {@link QueryMap @QueryMap} values.
      */
-    public Converter<?, String> stringConverter(Type type, Annotation[] annotations) {
+    public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+        Retrofit retrofit) {
       return null;
     }
   }
diff --git a/retrofit/src/main/java/retrofit2/DefaultCallAdapter.java b/retrofit/src/main/java/retrofit2/DefaultCallAdapter.java
deleted file mode 100644
index 96408ac61..000000000
--- a/retrofit/src/main/java/retrofit2/DefaultCallAdapter.java
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2;
-
-import java.lang.annotation.Annotation;
-import java.lang.reflect.Type;
-
-/**
- * A call adapter that uses the same thread for both I/O and application-level callbacks. For
- * synchronous calls this is the application thread making the request; for asynchronous calls this
- * is a thread provided by OkHttp's dispatcher.
- */
-final class DefaultCallAdapter implements CallAdapter<Call<?>> {
-  static final Factory FACTORY = new Factory() {
-    @Override
-    public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
-      if (Utils.getRawType(returnType) != Call.class) {
-        return null;
-      }
-      Type responseType = Utils.getCallResponseType(returnType);
-      return new DefaultCallAdapter(responseType);
-    }
-  };
-
-  private final Type responseType;
-
-  DefaultCallAdapter(Type responseType) {
-    this.responseType = responseType;
-  }
-
-  @Override public Type responseType() {
-    return responseType;
-  }
-
-  @Override public <R> Call<R> adapt(Call<R> call) {
-    return call;
-  }
-}
diff --git a/retrofit/src/main/java/retrofit2/DefaultCallAdapterFactory.java b/retrofit/src/main/java/retrofit2/DefaultCallAdapterFactory.java
new file mode 100644
index 000000000..dd6e79244
--- /dev/null
+++ b/retrofit/src/main/java/retrofit2/DefaultCallAdapterFactory.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+
+/**
+ * Creates call adapters for that uses the same thread for both I/O and application-level
+ * callbacks. For synchronous calls this is the application thread making the request; for
+ * asynchronous calls this is a thread provided by OkHttp's dispatcher.
+ */
+final class DefaultCallAdapterFactory extends CallAdapter.Factory {
+  static final CallAdapter.Factory INSTANCE = new DefaultCallAdapterFactory();
+
+  @Override
+  public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+    if (getRawType(returnType) != Call.class) {
+      return null;
+    }
+
+    final Type responseType = Utils.getCallResponseType(returnType);
+    return new CallAdapter<Call<?>>() {
+      @Override public Type responseType() {
+        return responseType;
+      }
+
+      @Override public <R> Call<R> adapt(Call<R> call) {
+        return call;
+      }
+    };
+  }
+}
diff --git a/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java b/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java
index 983b5eb40..155dc528c 100644
--- a/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java
+++ b/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java
@@ -21,7 +21,7 @@
 import java.util.concurrent.Executor;
 import okhttp3.Request;
 
-final class ExecutorCallAdapterFactory implements CallAdapter.Factory {
+final class ExecutorCallAdapterFactory extends CallAdapter.Factory {
   final Executor callbackExecutor;
 
   ExecutorCallAdapterFactory(Executor callbackExecutor) {
@@ -30,7 +30,7 @@
 
   @Override
   public CallAdapter<Call<?>> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
-    if (Utils.getRawType(returnType) != Call.class) {
+    if (getRawType(returnType) != Call.class) {
       return null;
     }
     final Type responseType = Utils.getCallResponseType(returnType);
@@ -60,7 +60,7 @@
           callbackExecutor.execute(new Runnable() {
             @Override public void run() {
               if (delegate.isCanceled()) {
-                // Emulate OkHttp's behavior of throwing/delivering an IOException on cancelation
+                // Emulate OkHttp's behavior of throwing/delivering an IOException on cancellation.
                 callback.onFailure(call, new IOException("Canceled"));
               } else {
                 callback.onResponse(call, response);
diff --git a/retrofit/src/main/java/retrofit2/MethodHandler.java b/retrofit/src/main/java/retrofit2/MethodHandler.java
index c0fea9d3d..ee6418a55 100644
--- a/retrofit/src/main/java/retrofit2/MethodHandler.java
+++ b/retrofit/src/main/java/retrofit2/MethodHandler.java
@@ -26,7 +26,7 @@ static MethodHandler create(Retrofit retrofit, Method method) {
     Type responseType = callAdapter.responseType();
     if (responseType == Response.class || responseType == okhttp3.Response.class) {
       throw Utils.methodError(method, "'"
-          + Utils.getRawType(responseType).getName()
+          + Types.getRawType(responseType).getName()
           + "' is not a valid response body type. Did you mean ResponseBody?");
     }
     Converter<ResponseBody, ?> responseConverter =
diff --git a/retrofit/src/main/java/retrofit2/Platform.java b/retrofit/src/main/java/retrofit2/Platform.java
index 327d79208..e67159bff 100644
--- a/retrofit/src/main/java/retrofit2/Platform.java
+++ b/retrofit/src/main/java/retrofit2/Platform.java
@@ -18,7 +18,9 @@
 import android.os.Build;
 import android.os.Handler;
 import android.os.Looper;
-import java.lang.invoke.MethodHandles;
+import java.lang.invoke.MethodHandles.Lookup;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.util.concurrent.Executor;
 import org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement;
@@ -43,14 +45,23 @@ private static Platform findPlatform() {
       return new Java8();
     } catch (ClassNotFoundException ignored) {
     }
+    try {
+      Class.forName("org.robovm.apple.foundation.NSObject");
+      return new IOS();
+    } catch (ClassNotFoundException ignored) {
+    }
     return new Platform();
   }
 
+  Executor defaultCallbackExecutor() {
+    return null;
+  }
+
   CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) {
     if (callbackExecutor != null) {
       return new ExecutorCallAdapterFactory(callbackExecutor);
     }
-    return DefaultCallAdapter.FACTORY;
+    return DefaultCallAdapterFactory.INSTANCE;
   }
 
   boolean isDefaultMethod(Method method) {
@@ -70,8 +81,11 @@ Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object
 
     @Override Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object,
         Object... args) throws Throwable {
-      return MethodHandles.lookup()
-          .in(declaringClass)
+      // Because the service interface might not be public, we need to use a MethodHandle lookup
+      // that ignores the visibility of the declaringClass.
+      Constructor<Lookup> constructor = Lookup.class.getDeclaredConstructor(Class.class, int.class);
+      constructor.setAccessible(true);
+      return constructor.newInstance(declaringClass, -1 /* trusted */)
           .unreflectSpecial(method, declaringClass)
           .bindTo(object)
           .invokeWithArguments(args);
@@ -79,10 +93,11 @@ Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object
   }
 
   static class Android extends Platform {
+    @Override public Executor defaultCallbackExecutor() {
+      return new MainThreadExecutor();
+    }
+
     @Override CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) {
-      if (callbackExecutor == null) {
-        callbackExecutor = new MainThreadExecutor();
-      }
       return new ExecutorCallAdapterFactory(callbackExecutor);
     }
 
@@ -94,4 +109,47 @@ Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object
       }
     }
   }
+
+  static class IOS extends Platform {
+    @Override public Executor defaultCallbackExecutor() {
+      return new MainThreadExecutor();
+    }
+
+    @Override CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) {
+      return new ExecutorCallAdapterFactory(callbackExecutor);
+    }
+
+    static class MainThreadExecutor implements Executor {
+      private static Object queue;
+      private static Method addOperation;
+
+      static {
+        try {
+          // queue = NSOperationQueue.getMainQueue();
+          Class<?> operationQueue = Class.forName("org.robovm.apple.foundation.NSOperationQueue");
+          queue = operationQueue.getDeclaredMethod("getMainQueue").invoke(null);
+          addOperation = operationQueue.getDeclaredMethod("addOperation", Runnable.class);
+        } catch (Exception e) {
+          throw new AssertionError(e);
+        }
+      }
+
+      @Override public void execute(Runnable r) {
+        try {
+          // queue.addOperation(r);
+          addOperation.invoke(queue, r);
+        } catch (IllegalArgumentException | IllegalAccessException e) {
+          throw new AssertionError(e);
+        } catch (InvocationTargetException e) {
+          Throwable cause = e.getCause();
+          if (cause instanceof RuntimeException) {
+            throw (RuntimeException) cause;
+          } else if (cause instanceof Error) {
+            throw (Error) cause;
+          }
+          throw new RuntimeException(cause);
+        }
+      }
+    }
+  }
 }
diff --git a/retrofit/src/main/java/retrofit2/RequestBuilder.java b/retrofit/src/main/java/retrofit2/RequestBuilder.java
index 0b97ab8e6..902c5a509 100644
--- a/retrofit/src/main/java/retrofit2/RequestBuilder.java
+++ b/retrofit/src/main/java/retrofit2/RequestBuilder.java
@@ -29,7 +29,7 @@
 final class RequestBuilder {
   private static final char[] HEX_DIGITS =
       { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
-  private static final String PATH_SEGMENT_ENCODE_SET = " \"<>^`{}|/\\?#";
+  private static final String PATH_SEGMENT_ALWAYS_ENCODE_SET = " \"<>^`{}|\\?#";
 
   private final String method;
 
@@ -85,20 +85,20 @@ void addPathParam(String name, String value, boolean encoded) {
       // The relative URL is cleared when the first query parameter is set.
       throw new AssertionError();
     }
-    relativeUrl = relativeUrl.replace("{" + name + "}", canonicalize(value, encoded));
+    relativeUrl = relativeUrl.replace("{" + name + "}", canonicalizeForPath(value, encoded));
   }
 
-  private static String canonicalize(String input, boolean alreadyEncoded) {
+  private static String canonicalizeForPath(String input, boolean alreadyEncoded) {
     int codePoint;
     for (int i = 0, limit = input.length(); i < limit; i += Character.charCount(codePoint)) {
       codePoint = input.codePointAt(i);
       if (codePoint < 0x20 || codePoint >= 0x7f
-          || PATH_SEGMENT_ENCODE_SET.indexOf(codePoint) != -1
-          || (codePoint == '%' && !alreadyEncoded)) {
+          || PATH_SEGMENT_ALWAYS_ENCODE_SET.indexOf(codePoint) != -1
+          || (!alreadyEncoded && (codePoint == '/' || codePoint == '%'))) {
         // Slow path: the character at i requires encoding!
         Buffer out = new Buffer();
         out.writeUtf8(input, 0, i);
-        canonicalize(out, input, i, limit, alreadyEncoded);
+        canonicalizeForPath(out, input, i, limit, alreadyEncoded);
         return out.readUtf8();
       }
     }
@@ -107,7 +107,7 @@ private static String canonicalize(String input, boolean alreadyEncoded) {
     return input;
   }
 
-  private static void canonicalize(Buffer out, String input, int pos, int limit,
+  private static void canonicalizeForPath(Buffer out, String input, int pos, int limit,
       boolean alreadyEncoded) {
     Buffer utf8Buffer = null; // Lazily allocated.
     int codePoint;
@@ -116,10 +116,9 @@ private static void canonicalize(Buffer out, String input, int pos, int limit,
       if (alreadyEncoded
           && (codePoint == '\t' || codePoint == '\n' || codePoint == '\f' || codePoint == '\r')) {
         // Skip this character.
-      } else if (codePoint < 0x20
-          || codePoint >= 0x7f
-          || PATH_SEGMENT_ENCODE_SET.indexOf(codePoint) != -1
-          || (codePoint == '%' && !alreadyEncoded)) {
+      } else if (codePoint < 0x20 || codePoint >= 0x7f
+          || PATH_SEGMENT_ALWAYS_ENCODE_SET.indexOf(codePoint) != -1
+          || (!alreadyEncoded && (codePoint == '/' || codePoint == '%'))) {
         // Percent encode this character.
         if (utf8Buffer == null) {
           utf8Buffer = new Buffer();
@@ -142,6 +141,10 @@ void addQueryParam(String name, String value, boolean encoded) {
     if (relativeUrl != null) {
       // Do a one-time combination of the built relative URL and the base URL.
       urlBuilder = baseUrl.newBuilder(relativeUrl);
+      if (urlBuilder == null) {
+        throw new IllegalArgumentException(
+            "Malformed URL. Base: " + baseUrl + ", Relative: " + relativeUrl);
+      }
       relativeUrl = null;
     }
 
@@ -176,6 +179,10 @@ Request build() {
     } else {
       // No query parameters triggered builder creation, just combine the relative URL and base URL.
       url = baseUrl.resolve(relativeUrl);
+      if (url == null) {
+        throw new IllegalArgumentException(
+            "Malformed URL. Base: " + baseUrl + ", Relative: " + relativeUrl);
+      }
     }
 
     RequestBody body = this.body;
diff --git a/retrofit/src/main/java/retrofit2/RequestFactoryParser.java b/retrofit/src/main/java/retrofit2/RequestFactoryParser.java
index 682f617bc..15ff19a4a 100644
--- a/retrofit/src/main/java/retrofit2/RequestFactoryParser.java
+++ b/retrofit/src/main/java/retrofit2/RequestFactoryParser.java
@@ -59,8 +59,11 @@
 
   static RequestFactory parse(Method method, Type responseType, Retrofit retrofit) {
     RequestFactoryParser parser = new RequestFactoryParser(method);
-    parser.parseMethodAnnotations(responseType);
-    parser.parseParameters(retrofit);
+
+    Annotation[] methodAnnotations = method.getAnnotations();
+    parser.parseMethodAnnotations(responseType, methodAnnotations);
+    parser.parseParameters(retrofit, methodAnnotations);
+
     return parser.toRequestFactory(retrofit.baseUrl());
   }
 
@@ -95,8 +98,8 @@ private RuntimeException parameterError(int index, String message, Object... arg
     return methodError(method, message + " (parameter #" + (index + 1) + ")", args);
   }
 
-  private void parseMethodAnnotations(Type responseType) {
-    for (Annotation annotation : method.getAnnotations()) {
+  private void parseMethodAnnotations(Type responseType, Annotation[] methodAnnotations) {
+    for (Annotation annotation : methodAnnotations) {
       if (annotation instanceof DELETE) {
         parseHttpMethodAndPath("DELETE", ((DELETE) annotation).value(), false);
       } else if (annotation instanceof GET) {
@@ -199,9 +202,9 @@ private void parseHttpMethodAndPath(String httpMethod, String value, boolean has
     return builder.build();
   }
 
-  private void parseParameters(Retrofit retrofit) {
-    Type[] methodParameterTypes = method.getGenericParameterTypes();
-    Annotation[][] methodParameterAnnotationArrays = method.getParameterAnnotations();
+  private void parseParameters(Retrofit retrofit, Annotation[] methodAnnotations) {
+    Type[] parameterTypes = method.getGenericParameterTypes();
+    Annotation[][] parameterAnnotationsArray = method.getParameterAnnotations();
 
     boolean gotField = false;
     boolean gotPart = false;
@@ -210,20 +213,20 @@ private void parseParameters(Retrofit retrofit) {
     boolean gotQuery = false;
     boolean gotUrl = false;
 
-    int count = methodParameterAnnotationArrays.length;
+    int count = parameterAnnotationsArray.length;
     RequestAction[] requestActions = new RequestAction[count];
     for (int i = 0; i < count; i++) {
-      Type methodParameterType = methodParameterTypes[i];
-      if (Utils.hasUnresolvableType(methodParameterType)) {
+      Type parameterType = parameterTypes[i];
+      if (Utils.hasUnresolvableType(parameterType)) {
         throw parameterError(i, "Parameter type must not include a type variable or wildcard: %s",
-            methodParameterType);
+            parameterType);
       }
 
-      Annotation[] methodParameterAnnotations = methodParameterAnnotationArrays[i];
-      if (methodParameterAnnotations != null) {
-        for (Annotation methodParameterAnnotation : methodParameterAnnotations) {
+      Annotation[] parameterAnnotations = parameterAnnotationsArray[i];
+      if (parameterAnnotations != null) {
+        for (Annotation parameterAnnotation : parameterAnnotations) {
           RequestAction action = null;
-          if (methodParameterAnnotation instanceof Url) {
+          if (parameterAnnotation instanceof Url) {
             if (gotUrl) {
               throw parameterError(i, "Multiple @Url method annotations found.");
             }
@@ -236,12 +239,12 @@ private void parseParameters(Retrofit retrofit) {
             if (relativeUrl != null) {
               throw parameterError(i, "@Url cannot be used with @%s URL", httpMethod);
             }
-            if (methodParameterType == String.class) {
+            if (parameterType == String.class) {
               action = new RequestAction.StringUrl();
-            } else if (methodParameterType == URI.class) {
+            } else if (parameterType == URI.class) {
               action = new RequestAction.JavaUriUrl();
-            } else if (methodParameterType instanceof Class
-                && "android.net.Uri".equals(((Class<?>) methodParameterType).getCanonicalName())) {
+            } else if (parameterType instanceof Class
+                && "android.net.Uri".equals(((Class<?>) parameterType).getCanonicalName())) {
               action = new RequestAction.AndroidUriUrl();
             } else {
               throw parameterError(i,
@@ -249,7 +252,7 @@ private void parseParameters(Retrofit retrofit) {
             }
             gotUrl = true;
 
-          } else if (methodParameterAnnotation instanceof Path) {
+          } else if (parameterAnnotation instanceof Path) {
             if (gotQuery) {
               throw parameterError(i, "A @Path parameter must not come after a @Query.");
             }
@@ -262,209 +265,219 @@ private void parseParameters(Retrofit retrofit) {
             }
             gotPath = true;
 
-            Path path = (Path) methodParameterAnnotation;
+            Path path = (Path) parameterAnnotation;
             String name = path.value();
             validatePathName(i, name);
 
-            Converter<?, String> valueConverter =
-                retrofit.stringConverter(methodParameterType, methodParameterAnnotations);
-            action = new RequestAction.Path<>(name, valueConverter, path.encoded());
+            Converter<?, String> converter =
+                retrofit.stringConverter(parameterType, parameterAnnotations);
+            action = new RequestAction.Path<>(name, converter, path.encoded());
 
-          } else if (methodParameterAnnotation instanceof Query) {
-            Query query = (Query) methodParameterAnnotation;
+          } else if (parameterAnnotation instanceof Query) {
+            Query query = (Query) parameterAnnotation;
             String name = query.value();
             boolean encoded = query.encoded();
 
-            Class<?> rawParameterType = Utils.getRawType(methodParameterType);
+            Class<?> rawParameterType = Types.getRawType(parameterType);
             if (Iterable.class.isAssignableFrom(rawParameterType)) {
-              if (!(methodParameterType instanceof ParameterizedType)) {
+              if (!(parameterType instanceof ParameterizedType)) {
                 throw parameterError(i, rawParameterType.getSimpleName()
                     + " must include generic type (e.g., "
                     + rawParameterType.getSimpleName()
                     + "<String>)");
               }
-              ParameterizedType parameterizedType = (ParameterizedType) methodParameterType;
+              ParameterizedType parameterizedType = (ParameterizedType) parameterType;
               Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
-              Converter<?, String> valueConverter =
-                  retrofit.stringConverter(iterableType, methodParameterAnnotations);
-              action = new RequestAction.Query<>(name, valueConverter, encoded).iterable();
+              Converter<?, String> converter =
+                  retrofit.stringConverter(iterableType, parameterAnnotations);
+              action = new RequestAction.Query<>(name, converter, encoded).iterable();
             } else if (rawParameterType.isArray()) {
               Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
-              Converter<?, String> valueConverter =
-                  retrofit.stringConverter(arrayComponentType, methodParameterAnnotations);
-              action = new RequestAction.Query<>(name, valueConverter, encoded).array();
+              Converter<?, String> converter =
+                  retrofit.stringConverter(arrayComponentType, parameterAnnotations);
+              action = new RequestAction.Query<>(name, converter, encoded).array();
             } else {
-              Converter<?, String> valueConverter =
-                  retrofit.stringConverter(methodParameterType, methodParameterAnnotations);
-              action = new RequestAction.Query<>(name, valueConverter, encoded);
+              Converter<?, String> converter =
+                  retrofit.stringConverter(parameterType, parameterAnnotations);
+              action = new RequestAction.Query<>(name, converter, encoded);
             }
 
             gotQuery = true;
 
-          } else if (methodParameterAnnotation instanceof QueryMap) {
-            if (!Map.class.isAssignableFrom(Utils.getRawType(methodParameterType))) {
+          } else if (parameterAnnotation instanceof QueryMap) {
+            Class<?> rawParameterType = Types.getRawType(parameterType);
+            if (!Map.class.isAssignableFrom(rawParameterType)) {
               throw parameterError(i, "@QueryMap parameter type must be Map.");
             }
-            if (!(methodParameterType instanceof ParameterizedType)) {
+            Type mapType = Types.getSupertype(parameterType, rawParameterType, Map.class);
+            if (!(mapType instanceof ParameterizedType)) {
               throw parameterError(i, "Map must include generic types (e.g., Map<String, String>)");
             }
-            ParameterizedType parameterizedType = (ParameterizedType) methodParameterType;
+            ParameterizedType parameterizedType = (ParameterizedType) mapType;
             Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
             if (String.class != keyType) {
               throw parameterError(i, "@QueryMap keys must be of type String: " + keyType);
             }
             Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
             Converter<?, String> valueConverter =
-                retrofit.stringConverter(valueType, methodParameterAnnotations);
+                retrofit.stringConverter(valueType, parameterAnnotations);
 
-            QueryMap queryMap = (QueryMap) methodParameterAnnotation;
+            QueryMap queryMap = (QueryMap) parameterAnnotation;
             action = new RequestAction.QueryMap<>(valueConverter, queryMap.encoded());
 
-          } else if (methodParameterAnnotation instanceof Header) {
-            Header header = (Header) methodParameterAnnotation;
+          } else if (parameterAnnotation instanceof Header) {
+            Header header = (Header) parameterAnnotation;
             String name = header.value();
 
-            Class<?> rawParameterType = Utils.getRawType(methodParameterType);
+            Class<?> rawParameterType = Types.getRawType(parameterType);
             if (Iterable.class.isAssignableFrom(rawParameterType)) {
-              if (!(methodParameterType instanceof ParameterizedType)) {
+              if (!(parameterType instanceof ParameterizedType)) {
                 throw parameterError(i, rawParameterType.getSimpleName()
                     + " must include generic type (e.g., "
                     + rawParameterType.getSimpleName()
                     + "<String>)");
               }
-              ParameterizedType parameterizedType = (ParameterizedType) methodParameterType;
+              ParameterizedType parameterizedType = (ParameterizedType) parameterType;
               Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
-              Converter<?, String> valueConverter =
-                  retrofit.stringConverter(iterableType, methodParameterAnnotations);
-              action = new RequestAction.Header<>(name, valueConverter).iterable();
+              Converter<?, String> converter =
+                  retrofit.stringConverter(iterableType, parameterAnnotations);
+              action = new RequestAction.Header<>(name, converter).iterable();
             } else if (rawParameterType.isArray()) {
               Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
-              Converter<?, String> valueConverter =
-                  retrofit.stringConverter(arrayComponentType, methodParameterAnnotations);
-              action = new RequestAction.Header<>(name, valueConverter).array();
+              Converter<?, String> converter =
+                  retrofit.stringConverter(arrayComponentType, parameterAnnotations);
+              action = new RequestAction.Header<>(name, converter).array();
             } else {
-              Converter<?, String> valueConverter =
-                  retrofit.stringConverter(methodParameterType, methodParameterAnnotations);
-              action = new RequestAction.Header<>(name, valueConverter);
+              Converter<?, String> converter =
+                  retrofit.stringConverter(parameterType, parameterAnnotations);
+              action = new RequestAction.Header<>(name, converter);
             }
 
-          } else if (methodParameterAnnotation instanceof Field) {
+          } else if (parameterAnnotation instanceof Field) {
             if (!isFormEncoded) {
               throw parameterError(i, "@Field parameters can only be used with form encoding.");
             }
-            Field field = (Field) methodParameterAnnotation;
+            Field field = (Field) parameterAnnotation;
             String name = field.value();
             boolean encoded = field.encoded();
 
-            Class<?> rawParameterType = Utils.getRawType(methodParameterType);
+            Class<?> rawParameterType = Types.getRawType(parameterType);
             if (Iterable.class.isAssignableFrom(rawParameterType)) {
-              if (!(methodParameterType instanceof ParameterizedType)) {
+              if (!(parameterType instanceof ParameterizedType)) {
                 throw parameterError(i, rawParameterType.getSimpleName()
                     + " must include generic type (e.g., "
                     + rawParameterType.getSimpleName()
                     + "<String>)");
               }
-              ParameterizedType parameterizedType = (ParameterizedType) methodParameterType;
+              ParameterizedType parameterizedType = (ParameterizedType) parameterType;
               Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
-              Converter<?, String> valueConverter =
-                  retrofit.stringConverter(iterableType, methodParameterAnnotations);
-              action = new RequestAction.Field<>(name, valueConverter, encoded).iterable();
+              Converter<?, String> converter =
+                  retrofit.stringConverter(iterableType, parameterAnnotations);
+              action = new RequestAction.Field<>(name, converter, encoded).iterable();
             } else if (rawParameterType.isArray()) {
               Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
-              Converter<?, String> valueConverter =
-                  retrofit.stringConverter(arrayComponentType, methodParameterAnnotations);
-              action = new RequestAction.Field<>(name, valueConverter, encoded).array();
+              Converter<?, String> converter =
+                  retrofit.stringConverter(arrayComponentType, parameterAnnotations);
+              action = new RequestAction.Field<>(name, converter, encoded).array();
             } else {
-              Converter<?, String> valueConverter =
-                  retrofit.stringConverter(methodParameterType, methodParameterAnnotations);
-              action = new RequestAction.Field<>(name, valueConverter, encoded);
+              Converter<?, String> converter =
+                  retrofit.stringConverter(parameterType, parameterAnnotations);
+              action = new RequestAction.Field<>(name, converter, encoded);
             }
 
             gotField = true;
 
-          } else if (methodParameterAnnotation instanceof FieldMap) {
+          } else if (parameterAnnotation instanceof FieldMap) {
             if (!isFormEncoded) {
               throw parameterError(i, "@FieldMap parameters can only be used with form encoding.");
             }
-            if (!Map.class.isAssignableFrom(Utils.getRawType(methodParameterType))) {
+            Class<?> rawParameterType = Types.getRawType(parameterType);
+            if (!Map.class.isAssignableFrom(rawParameterType)) {
               throw parameterError(i, "@FieldMap parameter type must be Map.");
             }
-            if (!(methodParameterType instanceof ParameterizedType)) {
+            Type mapType = Types.getSupertype(parameterType, rawParameterType, Map.class);
+            if (!(mapType instanceof ParameterizedType)) {
               throw parameterError(i, "Map must include generic types (e.g., Map<String, String>)");
             }
-            ParameterizedType parameterizedType = (ParameterizedType) methodParameterType;
+            ParameterizedType parameterizedType = (ParameterizedType) mapType;
             Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
             if (String.class != keyType) {
               throw parameterError(i, "@FieldMap keys must be of type String: " + keyType);
             }
             Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
             Converter<?, String> valueConverter =
-                retrofit.stringConverter(valueType, methodParameterAnnotations);
+                retrofit.stringConverter(valueType, parameterAnnotations);
 
-            FieldMap fieldMap = (FieldMap) methodParameterAnnotation;
+            FieldMap fieldMap = (FieldMap) parameterAnnotation;
             action = new RequestAction.FieldMap<>(valueConverter, fieldMap.encoded());
             gotField = true;
 
-          } else if (methodParameterAnnotation instanceof Part) {
+          } else if (parameterAnnotation instanceof Part) {
             if (!isMultipart) {
               throw parameterError(i, "@Part parameters can only be used with multipart encoding.");
             }
-            Part part = (Part) methodParameterAnnotation;
+            Part part = (Part) parameterAnnotation;
             okhttp3.Headers headers = okhttp3.Headers.of(
                 "Content-Disposition", "form-data; name=\"" + part.value() + "\"",
                 "Content-Transfer-Encoding", part.encoding());
 
-            Class<?> rawParameterType = Utils.getRawType(methodParameterType);
+            Class<?> rawParameterType = Types.getRawType(parameterType);
             if (Iterable.class.isAssignableFrom(rawParameterType)) {
-              if (!(methodParameterType instanceof ParameterizedType)) {
+              if (!(parameterType instanceof ParameterizedType)) {
                 throw parameterError(i, rawParameterType.getSimpleName()
                     + " must include generic type (e.g., "
                     + rawParameterType.getSimpleName()
                     + "<String>)");
               }
-              ParameterizedType parameterizedType = (ParameterizedType) methodParameterType;
+              ParameterizedType parameterizedType = (ParameterizedType) parameterType;
               Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
-              Converter<?, RequestBody> valueConverter =
-                  retrofit.requestBodyConverter(iterableType, methodParameterAnnotations);
-              action = new RequestAction.Part<>(headers, valueConverter).iterable();
+              Converter<?, RequestBody> converter =
+                  retrofit.requestBodyConverter(iterableType, parameterAnnotations,
+                      methodAnnotations);
+              action = new RequestAction.Part<>(headers, converter).iterable();
             } else if (rawParameterType.isArray()) {
               Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
-              Converter<?, RequestBody> valueConverter =
-                  retrofit.requestBodyConverter(arrayComponentType, methodParameterAnnotations);
-              action = new RequestAction.Part<>(headers, valueConverter).array();
+              Converter<?, RequestBody> converter =
+                  retrofit.requestBodyConverter(arrayComponentType, parameterAnnotations,
+                      methodAnnotations);
+              action = new RequestAction.Part<>(headers, converter).array();
             } else {
-              Converter<?, RequestBody> valueConverter =
-                  retrofit.requestBodyConverter(methodParameterType, methodParameterAnnotations);
-              action = new RequestAction.Part<>(headers, valueConverter);
+              Converter<?, RequestBody> converter =
+                  retrofit.requestBodyConverter(parameterType, parameterAnnotations,
+                      methodAnnotations);
+              action = new RequestAction.Part<>(headers, converter);
             }
 
             gotPart = true;
 
-          } else if (methodParameterAnnotation instanceof PartMap) {
+          } else if (parameterAnnotation instanceof PartMap) {
             if (!isMultipart) {
               throw parameterError(i,
                   "@PartMap parameters can only be used with multipart encoding.");
             }
-            if (!Map.class.isAssignableFrom(Utils.getRawType(methodParameterType))) {
+            Class<?> rawParameterType = Types.getRawType(parameterType);
+            if (!Map.class.isAssignableFrom(rawParameterType)) {
               throw parameterError(i, "@PartMap parameter type must be Map.");
             }
-            if (!(methodParameterType instanceof ParameterizedType)) {
+            Type mapType = Types.getSupertype(parameterType, rawParameterType, Map.class);
+            if (!(mapType instanceof ParameterizedType)) {
               throw parameterError(i, "Map must include generic types (e.g., Map<String, String>)");
             }
-            ParameterizedType parameterizedType = (ParameterizedType) methodParameterType;
+            ParameterizedType parameterizedType = (ParameterizedType) mapType;
             Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
             if (String.class != keyType) {
               throw parameterError(i, "@PartMap keys must be of type String: " + keyType);
             }
             Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
             Converter<?, RequestBody> valueConverter =
-                retrofit.requestBodyConverter(valueType, methodParameterAnnotations);
+                retrofit.requestBodyConverter(valueType, parameterAnnotations,
+                    methodAnnotations);
 
-            PartMap partMap = (PartMap) methodParameterAnnotation;
+            PartMap partMap = (PartMap) parameterAnnotation;
             action = new RequestAction.PartMap<>(valueConverter, partMap.encoding());
             gotPart = true;
 
-          } else if (methodParameterAnnotation instanceof Body) {
+          } else if (parameterAnnotation instanceof Body) {
             if (isFormEncoded || isMultipart) {
               throw parameterError(i,
                   "@Body parameters cannot be used with form or multi-part encoding.");
@@ -475,11 +488,10 @@ private void parseParameters(Retrofit retrofit) {
 
             Converter<?, RequestBody> converter;
             try {
-              converter =
-                  retrofit.requestBodyConverter(methodParameterType, methodParameterAnnotations);
+              converter = retrofit.requestBodyConverter(parameterType, parameterAnnotations,
+                  methodAnnotations);
             } catch (RuntimeException e) { // Wide exception range because factories are user code.
-              throw parameterError(e, i, "Unable to create @Body converter for %s",
-                  methodParameterType);
+              throw parameterError(e, i, "Unable to create @Body converter for %s", parameterType);
             }
             action = new RequestAction.Body<>(converter);
             gotBody = true;
diff --git a/retrofit/src/main/java/retrofit2/Response.java b/retrofit/src/main/java/retrofit2/Response.java
index 7bfcf39fd..5445ec09b 100644
--- a/retrofit/src/main/java/retrofit2/Response.java
+++ b/retrofit/src/main/java/retrofit2/Response.java
@@ -32,6 +32,21 @@
         .build());
   }
 
+  /**
+   * Create a synthetic successful response using {@code headers} with {@code body} as the
+   * deserialized body.
+   */
+  public static <T> Response<T> success(T body, Headers headers) {
+    if (headers == null) throw new NullPointerException("headers == null");
+    return success(body, new okhttp3.Response.Builder() //
+        .code(200)
+        .message("OK")
+        .protocol(Protocol.HTTP_1_1)
+        .headers(headers)
+        .request(new Request.Builder().url("http://localhost").build())
+        .build());
+  }
+
   /**
    * Create a successful response from {@code rawResponse} with {@code body} as the deserialized
    * body.
diff --git a/retrofit/src/main/java/retrofit2/Retrofit.java b/retrofit/src/main/java/retrofit2/Retrofit.java
index 2ce5ef8e5..56d36eaa8 100644
--- a/retrofit/src/main/java/retrofit2/Retrofit.java
+++ b/retrofit/src/main/java/retrofit2/Retrofit.java
@@ -215,15 +215,17 @@ public BaseUrl baseUrl() {
 
     StringBuilder builder = new StringBuilder("Could not locate call adapter for ")
         .append(returnType)
-        .append(". Tried:");
-    for (int i = start, count = adapterFactories.size(); i < count; i++) {
-      builder.append("\n * ").append(adapterFactories.get(i).getClass().getName());
-    }
+        .append(".\n");
     if (skipPast != null) {
-      builder.append("\nSkipped:");
+      builder.append("  Skipped:");
       for (int i = 0; i < start; i++) {
-        builder.append("\n * ").append(adapterFactories.get(i).getClass().getName());
+        builder.append("\n   * ").append(adapterFactories.get(i).getClass().getName());
       }
+      builder.append('\n');
+    }
+    builder.append("  Tried:");
+    for (int i = start, count = adapterFactories.size(); i < count; i++) {
+      builder.append("\n   * ").append(adapterFactories.get(i).getClass().getName());
     }
     throw new IllegalArgumentException(builder.toString());
   }
@@ -241,8 +243,9 @@ public BaseUrl baseUrl() {
    *
    * @throws IllegalArgumentException if no converter available for {@code type}.
    */
-  public <T> Converter<T, RequestBody> requestBodyConverter(Type type, Annotation[] annotations) {
-    return nextRequestBodyConverter(null, type, annotations);
+  public <T> Converter<T, RequestBody> requestBodyConverter(Type type,
+      Annotation[] parameterAnnotations, Annotation[] methodAnnotations) {
+    return nextRequestBodyConverter(null, type, parameterAnnotations, methodAnnotations);
   }
 
   /**
@@ -252,14 +255,16 @@ public BaseUrl baseUrl() {
    * @throws IllegalArgumentException if no converter available for {@code type}.
    */
   public <T> Converter<T, RequestBody> nextRequestBodyConverter(Converter.Factory skipPast,
-      Type type, Annotation[] annotations) {
+      Type type, Annotation[] parameterAnnotations, Annotation[] methodAnnotations) {
     checkNotNull(type, "type == null");
-    checkNotNull(annotations, "annotations == null");
+    checkNotNull(parameterAnnotations, "parameterAnnotations == null");
+    checkNotNull(methodAnnotations, "methodAnnotations == null");
 
     int start = converterFactories.indexOf(skipPast) + 1;
     for (int i = start, count = converterFactories.size(); i < count; i++) {
+      Converter.Factory factory = converterFactories.get(i);
       Converter<?, RequestBody> converter =
-          converterFactories.get(i).requestBodyConverter(type, annotations, this);
+          factory.requestBodyConverter(type, parameterAnnotations, methodAnnotations, this);
       if (converter != null) {
         //noinspection unchecked
         return (Converter<T, RequestBody>) converter;
@@ -268,15 +273,17 @@ public BaseUrl baseUrl() {
 
     StringBuilder builder = new StringBuilder("Could not locate RequestBody converter for ")
         .append(type)
-        .append(". Tried:");
-    for (int i = start, count = converterFactories.size(); i < count; i++) {
-      builder.append("\n * ").append(converterFactories.get(i).getClass().getName());
-    }
+        .append(".\n");
     if (skipPast != null) {
-      builder.append("\nSkipped:");
+      builder.append("  Skipped:");
       for (int i = 0; i < start; i++) {
-        builder.append("\n * ").append(adapterFactories.get(i).getClass().getName());
+        builder.append("\n   * ").append(converterFactories.get(i).getClass().getName());
       }
+      builder.append('\n');
+    }
+    builder.append("  Tried:");
+    for (int i = start, count = converterFactories.size(); i < count; i++) {
+      builder.append("\n   * ").append(converterFactories.get(i).getClass().getName());
     }
     throw new IllegalArgumentException(builder.toString());
   }
@@ -314,15 +321,17 @@ public BaseUrl baseUrl() {
 
     StringBuilder builder = new StringBuilder("Could not locate ResponseBody converter for ")
         .append(type)
-        .append(". Tried:");
-    for (int i = start, count = converterFactories.size(); i < count; i++) {
-      builder.append("\n * ").append(converterFactories.get(i).getClass().getName());
-    }
+        .append(".\n");
     if (skipPast != null) {
-      builder.append("\nSkipped:");
+      builder.append("  Skipped:");
       for (int i = 0; i < start; i++) {
-        builder.append("\n * ").append(adapterFactories.get(i).getClass().getName());
+        builder.append("\n   * ").append(converterFactories.get(i).getClass().getName());
       }
+      builder.append('\n');
+    }
+    builder.append("  Tried:");
+    for (int i = start, count = converterFactories.size(); i < count; i++) {
+      builder.append("\n   * ").append(converterFactories.get(i).getClass().getName());
     }
     throw new IllegalArgumentException(builder.toString());
   }
@@ -337,7 +346,7 @@ public BaseUrl baseUrl() {
 
     for (int i = 0, count = converterFactories.size(); i < count; i++) {
       Converter<?, String> converter =
-          converterFactories.get(i).stringConverter(type, annotations);
+          converterFactories.get(i).stringConverter(type, annotations, this);
       if (converter != null) {
         //noinspection unchecked
         return (Converter<T, String>) converter;
@@ -349,7 +358,10 @@ public BaseUrl baseUrl() {
     return (Converter<T, String>) BuiltInConverters.ToStringConverter.INSTANCE;
   }
 
-  /** The executor used for {@link Callback} methods on a {@link Call}. */
+  /**
+   * The executor used for {@link Callback} methods on a {@link Call}. This may be {@code null},
+   * in which case callbacks should be made synchronously on the background thread.
+   */
   public Executor callbackExecutor() {
     return callbackExecutor;
   }
@@ -361,6 +373,7 @@ public Executor callbackExecutor() {
    * are optional.
    */
   public static final class Builder {
+    private Platform platform;
     private okhttp3.Call.Factory callFactory;
     private BaseUrl baseUrl;
     private List<Converter.Factory> converterFactories = new ArrayList<>();
@@ -368,12 +381,17 @@ public Executor callbackExecutor() {
     private Executor callbackExecutor;
     private boolean validateEagerly;
 
-    public Builder() {
+    Builder(Platform platform) {
+      this.platform = platform;
       // Add the built-in converter factory first. This prevents overriding its behavior but also
       // ensures correct behavior when using converters that consume all types.
       converterFactories.add(new BuiltInConverters());
     }
 
+    public Builder() {
+      this(Platform.get());
+    }
+
     /**
      * The HTTP client used for requests.
      * <p>
@@ -536,9 +554,14 @@ public Retrofit build() {
         callFactory = new OkHttpClient();
       }
 
+      Executor callbackExecutor = this.callbackExecutor;
+      if (callbackExecutor == null) {
+        callbackExecutor = platform.defaultCallbackExecutor();
+      }
+
       // Make a defensive copy of the adapters and add the default Call adapter.
       List<CallAdapter.Factory> adapterFactories = new ArrayList<>(this.adapterFactories);
-      adapterFactories.add(Platform.get().defaultCallAdapterFactory(callbackExecutor));
+      adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));
 
       // Make a defensive copy of the converters.
       List<Converter.Factory> converterFactories = new ArrayList<>(this.converterFactories);
diff --git a/retrofit/src/main/java/retrofit2/Types.java b/retrofit/src/main/java/retrofit2/Types.java
new file mode 100644
index 000000000..8ac490d57
--- /dev/null
+++ b/retrofit/src/main/java/retrofit2/Types.java
@@ -0,0 +1,408 @@
+/*
+ * Copyright (C) 2008 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import java.lang.reflect.Array;
+import java.lang.reflect.GenericArrayType;
+import java.lang.reflect.GenericDeclaration;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.lang.reflect.TypeVariable;
+import java.lang.reflect.WildcardType;
+import java.util.Arrays;
+import java.util.NoSuchElementException;
+
+final class Types {
+  private static final Type[] EMPTY_TYPE_ARRAY = new Type[0];
+
+  private Types() {
+    // No instances.
+  }
+
+  public static Class<?> getRawType(Type type) {
+    if (type instanceof Class<?>) {
+      // Type is a normal class.
+      return (Class<?>) type;
+
+    } else if (type instanceof ParameterizedType) {
+      ParameterizedType parameterizedType = (ParameterizedType) type;
+
+      // I'm not exactly sure why getRawType() returns Type instead of Class. Neal isn't either but
+      // suspects some pathological case related to nested classes exists.
+      Type rawType = parameterizedType.getRawType();
+      if (!(rawType instanceof Class)) throw new IllegalArgumentException();
+      return (Class<?>) rawType;
+
+    } else if (type instanceof GenericArrayType) {
+      Type componentType = ((GenericArrayType) type).getGenericComponentType();
+      return Array.newInstance(getRawType(componentType), 0).getClass();
+
+    } else if (type instanceof TypeVariable) {
+      // We could use the variable's bounds, but that won't work if there are multiple. Having a raw
+      // type that's more general than necessary is okay.
+      return Object.class;
+
+    } else if (type instanceof WildcardType) {
+      return getRawType(((WildcardType) type).getUpperBounds()[0]);
+
+    } else {
+      String className = type == null ? "null" : type.getClass().getName();
+      throw new IllegalArgumentException("Expected a Class, ParameterizedType, or "
+          + "GenericArrayType, but <" + type + "> is of type " + className);
+    }
+  }
+
+  /** Returns true if {@code a} and {@code b} are equal. */
+  public static boolean equals(Type a, Type b) {
+    if (a == b) {
+      return true; // Also handles (a == null && b == null).
+
+    } else if (a instanceof Class) {
+      return a.equals(b); // Class already specifies equals().
+
+    } else if (a instanceof ParameterizedType) {
+      if (!(b instanceof ParameterizedType)) return false;
+      ParameterizedType pa = (ParameterizedType) a;
+      ParameterizedType pb = (ParameterizedType) b;
+      return equal(pa.getOwnerType(), pb.getOwnerType())
+          && pa.getRawType().equals(pb.getRawType())
+          && Arrays.equals(pa.getActualTypeArguments(), pb.getActualTypeArguments());
+
+    } else if (a instanceof GenericArrayType) {
+      if (!(b instanceof GenericArrayType)) return false;
+      GenericArrayType ga = (GenericArrayType) a;
+      GenericArrayType gb = (GenericArrayType) b;
+      return equals(ga.getGenericComponentType(), gb.getGenericComponentType());
+
+    } else if (a instanceof WildcardType) {
+      if (!(b instanceof WildcardType)) return false;
+      WildcardType wa = (WildcardType) a;
+      WildcardType wb = (WildcardType) b;
+      return Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds())
+          && Arrays.equals(wa.getLowerBounds(), wb.getLowerBounds());
+
+    } else if (a instanceof TypeVariable) {
+      if (!(b instanceof TypeVariable)) return false;
+      TypeVariable<?> va = (TypeVariable<?>) a;
+      TypeVariable<?> vb = (TypeVariable<?>) b;
+      return va.getGenericDeclaration() == vb.getGenericDeclaration()
+          && va.getName().equals(vb.getName());
+
+    } else {
+      return false; // This isn't a type we support!
+    }
+  }
+
+  /**
+   * Returns the generic supertype for {@code supertype}. For example, given a class {@code
+   * IntegerSet}, the result for when supertype is {@code Set.class} is {@code Set<Integer>} and the
+   * result when the supertype is {@code Collection.class} is {@code Collection<Integer>}.
+   */
+  static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResolve) {
+    if (toResolve == rawType) return context;
+
+    // We skip searching through interfaces if unknown is an interface.
+    if (toResolve.isInterface()) {
+      Class<?>[] interfaces = rawType.getInterfaces();
+      for (int i = 0, length = interfaces.length; i < length; i++) {
+        if (interfaces[i] == toResolve) {
+          return rawType.getGenericInterfaces()[i];
+        } else if (toResolve.isAssignableFrom(interfaces[i])) {
+          return getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], toResolve);
+        }
+      }
+    }
+
+    // Check our supertypes.
+    if (!rawType.isInterface()) {
+      while (rawType != Object.class) {
+        Class<?> rawSupertype = rawType.getSuperclass();
+        if (rawSupertype == toResolve) {
+          return rawType.getGenericSuperclass();
+        } else if (toResolve.isAssignableFrom(rawSupertype)) {
+          return getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, toResolve);
+        }
+        rawType = rawSupertype;
+      }
+    }
+
+    // We can't resolve this further.
+    return toResolve;
+  }
+
+  private static int indexOf(Object[] array, Object toFind) {
+    for (int i = 0; i < array.length; i++) {
+      if (toFind.equals(array[i])) return i;
+    }
+    throw new NoSuchElementException();
+  }
+
+  private static boolean equal(Object a, Object b) {
+    return a == b || (a != null && a.equals(b));
+  }
+
+  private static int hashCodeOrZero(Object o) {
+    return o != null ? o.hashCode() : 0;
+  }
+
+  public static String typeToString(Type type) {
+    return type instanceof Class ? ((Class<?>) type).getName() : type.toString();
+  }
+
+  /**
+   * Returns the generic form of {@code supertype}. For example, if this is {@code
+   * ArrayList<String>}, this returns {@code Iterable<String>} given the input {@code
+   * Iterable.class}.
+   *
+   * @param supertype a superclass of, or interface implemented by, this.
+   */
+  public static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) {
+    if (!supertype.isAssignableFrom(contextRawType)) throw new IllegalArgumentException();
+    return resolve(context, contextRawType,
+        getGenericSupertype(context, contextRawType, supertype));
+  }
+
+  public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {
+    // This implementation is made a little more complicated in an attempt to avoid object-creation.
+    while (true) {
+      if (toResolve instanceof TypeVariable) {
+        TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;
+        toResolve = resolveTypeVariable(context, contextRawType, typeVariable);
+        if (toResolve == typeVariable) {
+          return toResolve;
+        }
+
+      } else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {
+        Class<?> original = (Class<?>) toResolve;
+        Type componentType = original.getComponentType();
+        Type newComponentType = resolve(context, contextRawType, componentType);
+        return componentType == newComponentType ? original : new GenericArrayTypeImpl(
+            newComponentType);
+
+      } else if (toResolve instanceof GenericArrayType) {
+        GenericArrayType original = (GenericArrayType) toResolve;
+        Type componentType = original.getGenericComponentType();
+        Type newComponentType = resolve(context, contextRawType, componentType);
+        return componentType == newComponentType ? original : new GenericArrayTypeImpl(
+            newComponentType);
+
+      } else if (toResolve instanceof ParameterizedType) {
+        ParameterizedType original = (ParameterizedType) toResolve;
+        Type ownerType = original.getOwnerType();
+        Type newOwnerType = resolve(context, contextRawType, ownerType);
+        boolean changed = newOwnerType != ownerType;
+
+        Type[] args = original.getActualTypeArguments();
+        for (int t = 0, length = args.length; t < length; t++) {
+          Type resolvedTypeArgument = resolve(context, contextRawType, args[t]);
+          if (resolvedTypeArgument != args[t]) {
+            if (!changed) {
+              args = args.clone();
+              changed = true;
+            }
+            args[t] = resolvedTypeArgument;
+          }
+        }
+
+        return changed
+            ? new ParameterizedTypeImpl(newOwnerType, original.getRawType(), args)
+            : original;
+
+      } else if (toResolve instanceof WildcardType) {
+        WildcardType original = (WildcardType) toResolve;
+        Type[] originalLowerBound = original.getLowerBounds();
+        Type[] originalUpperBound = original.getUpperBounds();
+
+        if (originalLowerBound.length == 1) {
+          Type lowerBound = resolve(context, contextRawType, originalLowerBound[0]);
+          if (lowerBound != originalLowerBound[0]) {
+            return new WildcardTypeImpl(new Type[] { Object.class }, new Type[] { lowerBound });
+          }
+        } else if (originalUpperBound.length == 1) {
+          Type upperBound = resolve(context, contextRawType, originalUpperBound[0]);
+          if (upperBound != originalUpperBound[0]) {
+            return new WildcardTypeImpl(new Type[] { upperBound }, EMPTY_TYPE_ARRAY);
+          }
+        }
+        return original;
+
+      } else {
+        return toResolve;
+      }
+    }
+  }
+
+  private static Type resolveTypeVariable(
+      Type context, Class<?> contextRawType, TypeVariable<?> unknown) {
+    Class<?> declaredByRaw = declaringClassOf(unknown);
+
+    // We can't reduce this further.
+    if (declaredByRaw == null) return unknown;
+
+    Type declaredBy = getGenericSupertype(context, contextRawType, declaredByRaw);
+    if (declaredBy instanceof ParameterizedType) {
+      int index = indexOf(declaredByRaw.getTypeParameters(), unknown);
+      return ((ParameterizedType) declaredBy).getActualTypeArguments()[index];
+    }
+
+    return unknown;
+  }
+
+  /**
+   * Returns the declaring class of {@code typeVariable}, or {@code null} if it was not declared by
+   * a class.
+   */
+  private static Class<?> declaringClassOf(TypeVariable<?> typeVariable) {
+    GenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();
+    return genericDeclaration instanceof Class ? (Class<?>) genericDeclaration : null;
+  }
+
+  private static void checkNotPrimitive(Type type) {
+    if (type instanceof Class<?> && ((Class<?>) type).isPrimitive()) {
+      throw new IllegalArgumentException();
+    }
+  }
+
+  private static final class ParameterizedTypeImpl implements ParameterizedType {
+    private final Type ownerType;
+    private final Type rawType;
+    private final Type[] typeArguments;
+
+    public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments) {
+      // Require an owner type if the raw type needs it.
+      if (rawType instanceof Class<?>
+          && (ownerType == null) != (((Class<?>) rawType).getEnclosingClass() == null)) {
+        throw new IllegalArgumentException();
+      }
+
+      this.ownerType = ownerType;
+      this.rawType = rawType;
+      this.typeArguments = typeArguments.clone();
+
+      for (Type typeArgument : this.typeArguments) {
+        if (typeArgument == null) throw new NullPointerException();
+        checkNotPrimitive(typeArgument);
+      }
+    }
+
+    @Override public Type[] getActualTypeArguments() {
+      return typeArguments.clone();
+    }
+
+    @Override public Type getRawType() {
+      return rawType;
+    }
+
+    @Override public Type getOwnerType() {
+      return ownerType;
+    }
+
+    @Override public boolean equals(Object other) {
+      return other instanceof ParameterizedType && Types.equals(this, (ParameterizedType) other);
+    }
+
+    @Override public int hashCode() {
+      return Arrays.hashCode(typeArguments) ^ rawType.hashCode() ^ hashCodeOrZero(ownerType);
+    }
+
+    @Override public String toString() {
+      StringBuilder result = new StringBuilder(30 * (typeArguments.length + 1));
+      result.append(typeToString(rawType));
+      if (typeArguments.length == 0) return result.toString();
+      result.append("<").append(typeToString(typeArguments[0]));
+      for (int i = 1; i < typeArguments.length; i++) {
+        result.append(", ").append(typeToString(typeArguments[i]));
+      }
+      return result.append(">").toString();
+    }
+  }
+
+  private static final class GenericArrayTypeImpl implements GenericArrayType {
+    private final Type componentType;
+
+    public GenericArrayTypeImpl(Type componentType) {
+      this.componentType = componentType;
+    }
+
+    @Override public Type getGenericComponentType() {
+      return componentType;
+    }
+
+    @Override public boolean equals(Object o) {
+      return o instanceof GenericArrayType
+          && Types.equals(this, (GenericArrayType) o);
+    }
+
+    @Override public int hashCode() {
+      return componentType.hashCode();
+    }
+
+    @Override public String toString() {
+      return typeToString(componentType) + "[]";
+    }
+  }
+
+  /**
+   * The WildcardType interface supports multiple upper bounds and multiple
+   * lower bounds. We only support what the Java 6 language needs - at most one
+   * bound. If a lower bound is set, the upper bound must be Object.class.
+   */
+  private static final class WildcardTypeImpl implements WildcardType {
+    private final Type upperBound;
+    private final Type lowerBound;
+
+    public WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {
+      if (lowerBounds.length > 1) throw new IllegalArgumentException();
+      if (upperBounds.length != 1) throw new IllegalArgumentException();
+
+      if (lowerBounds.length == 1) {
+        if (lowerBounds[0] == null) throw new NullPointerException();
+        checkNotPrimitive(lowerBounds[0]);
+        if (upperBounds[0] != Object.class) throw new IllegalArgumentException();
+        this.lowerBound = lowerBounds[0];
+        this.upperBound = Object.class;
+      } else {
+        if (upperBounds[0] == null) throw new NullPointerException();
+        checkNotPrimitive(upperBounds[0]);
+        this.lowerBound = null;
+        this.upperBound = upperBounds[0];
+      }
+    }
+
+    @Override public Type[] getUpperBounds() {
+      return new Type[] { upperBound };
+    }
+
+    @Override public Type[] getLowerBounds() {
+      return lowerBound != null ? new Type[] { lowerBound } : EMPTY_TYPE_ARRAY;
+    }
+
+    @Override public boolean equals(Object other) {
+      return other instanceof WildcardType && Types.equals(this, (WildcardType) other);
+    }
+
+    @Override public int hashCode() {
+      // This equals Arrays.hashCode(getLowerBounds()) ^ Arrays.hashCode(getUpperBounds()).
+      return (lowerBound != null ? 31 + lowerBound.hashCode() : 1) ^ (31 + upperBound.hashCode());
+    }
+
+    @Override public String toString() {
+      if (lowerBound != null) return "? super " + typeToString(lowerBound);
+      if (upperBound == Object.class) return "?";
+      return "? extends " + typeToString(upperBound);
+    }
+  }
+}
diff --git a/retrofit/src/main/java/retrofit2/Utils.java b/retrofit/src/main/java/retrofit2/Utils.java
index 3c2bbf3b8..20c2d98a8 100644
--- a/retrofit/src/main/java/retrofit2/Utils.java
+++ b/retrofit/src/main/java/retrofit2/Utils.java
@@ -18,7 +18,6 @@
 
 import java.io.IOException;
 import java.lang.annotation.Annotation;
-import java.lang.reflect.Array;
 import java.lang.reflect.GenericArrayType;
 import java.lang.reflect.Method;
 import java.lang.reflect.ParameterizedType;
@@ -106,40 +105,6 @@ static boolean hasUnresolvableType(Type type) {
         + "GenericArrayType, but <" + type + "> is of type " + className);
   }
 
-  // This method is copyright 2008 Google Inc. and is taken from Gson under the Apache 2.0 license.
-  static Class<?> getRawType(Type type) {
-    if (type instanceof Class<?>) {
-      // Type is a normal class.
-      return (Class<?>) type;
-
-    } else if (type instanceof ParameterizedType) {
-      ParameterizedType parameterizedType = (ParameterizedType) type;
-
-      // I'm not exactly sure why getRawType() returns Type instead of Class. Neal isn't either but
-      // suspects some pathological case related to nested classes exists.
-      Type rawType = parameterizedType.getRawType();
-      if (!(rawType instanceof Class)) throw new IllegalArgumentException();
-      return (Class<?>) rawType;
-
-    } else if (type instanceof GenericArrayType) {
-      Type componentType = ((GenericArrayType) type).getGenericComponentType();
-      return Array.newInstance(getRawType(componentType), 0).getClass();
-
-    } else if (type instanceof TypeVariable) {
-      // We could use the variable's bounds, but that won't work if there are multiple. Having a raw
-      // type that's more general than necessary is okay.
-      return Object.class;
-
-    } else if (type instanceof WildcardType) {
-      return getRawType(((WildcardType) type).getUpperBounds()[0]);
-
-    } else {
-      String className = type == null ? "null" : type.getClass().getName();
-      throw new IllegalArgumentException("Expected a Class, ParameterizedType, or "
-          + "GenericArrayType, but <" + type + "> is of type " + className);
-    }
-  }
-
   static RuntimeException methodError(Method method, String message, Object... args) {
     return methodError(null, method, message, args);
   }
diff --git a/retrofit/src/test/java/retrofit2/CallTest.java b/retrofit/src/test/java/retrofit2/CallTest.java
index ae08c0be6..e19d25c97 100644
--- a/retrofit/src/test/java/retrofit2/CallTest.java
+++ b/retrofit/src/test/java/retrofit2/CallTest.java
@@ -34,6 +34,7 @@
 import okio.Okio;
 import org.junit.Rule;
 import org.junit.Test;
+import retrofit2.helpers.ToStringConverterFactory;
 import retrofit2.http.Body;
 import retrofit2.http.GET;
 import retrofit2.http.POST;
@@ -194,7 +195,8 @@
         .baseUrl(server.url("/"))
         .addConverterFactory(new ToStringConverterFactory() {
           @Override
-          public Converter<?, RequestBody> requestBodyConverter(Type type, Annotation[] annotations,
+          public Converter<?, RequestBody> requestBodyConverter(Type type,
+              Annotation[] parameterAnnotations, Annotation[] methodAnnotations,
               Retrofit retrofit) {
             return new Converter<String, RequestBody>() {
               @Override public RequestBody convert(String value) throws IOException {
@@ -220,7 +222,8 @@
         .baseUrl(server.url("/"))
         .addConverterFactory(new ToStringConverterFactory() {
           @Override
-          public Converter<?, RequestBody> requestBodyConverter(Type type, Annotation[] annotations,
+          public Converter<?, RequestBody> requestBodyConverter(Type type,
+              Annotation[] parameterAnnotations, Annotation[] methodAnnotations,
               Retrofit retrofit) {
             return new Converter<String, RequestBody>() {
               @Override public RequestBody convert(String value) throws IOException {
diff --git a/retrofit/src/test/java/retrofit2/Java8DefaultMethodsTest.java b/retrofit/src/test/java/retrofit2/Java8DefaultMethodsTest.java
new file mode 100644
index 000000000..b091ee530
--- /dev/null
+++ b/retrofit/src/test/java/retrofit2/Java8DefaultMethodsTest.java
@@ -0,0 +1,30 @@
+package retrofit2;
+
+// TODO this test doesn't play nice in the IDE because it relies on Java 8 language features.
+public final class Java8DefaultMethodsTest {
+  //@Rule public final MockWebServer server = new MockWebServer();
+  //
+  //interface Example {
+  //  @GET("/") Call<String> user(@Query("name") String name);
+  //
+  //  default Call<String> user() {
+  //    return user("hey");
+  //  }
+  //}
+  //
+  //@Test public void test() throws IOException {
+  //  server.enqueue(new MockResponse().setBody("Hi"));
+  //  server.enqueue(new MockResponse().setBody("Hi"));
+  //
+  //  Retrofit retrofit = new Retrofit.Builder()
+  //      .baseUrl(server.url("/"))
+  //      .addConverterFactory(new ToStringConverterFactory())
+  //      .build();
+  //  Example example = retrofit.create(Example.class);
+  //
+  //  Response<String> response = example.user().execute();
+  //  assertThat(response.body()).isEqualTo("Hi");
+  //  Response<String> response = example.user("hi").execute();
+  //  assertThat(response.body()).isEqualTo("Hi");
+  //}
+}
diff --git a/retrofit/src/test/java/retrofit2/RequestBuilderTest.java b/retrofit/src/test/java/retrofit2/RequestBuilderTest.java
index 57d3517f9..e46cfee45 100644
--- a/retrofit/src/test/java/retrofit2/RequestBuilderTest.java
+++ b/retrofit/src/test/java/retrofit2/RequestBuilderTest.java
@@ -7,6 +7,7 @@
 import java.net.URI;
 import java.util.Arrays;
 import java.util.Collections;
+import java.util.HashMap;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
@@ -18,6 +19,7 @@
 import okio.Buffer;
 import org.junit.Ignore;
 import org.junit.Test;
+import retrofit2.helpers.ToStringConverterFactory;
 import retrofit2.http.Body;
 import retrofit2.http.DELETE;
 import retrofit2.http.Field;
@@ -439,6 +441,24 @@
     }
   }
 
+  @Test public void queryMapSupportsSubclasses() {
+    class Foo extends HashMap<String, String> {
+    }
+
+    class Example {
+      @GET("/") //
+      Call<ResponseBody> method(@QueryMap Foo a) {
+        return null;
+      }
+    }
+
+    Foo foo = new Foo();
+    foo.put("hello", "world");
+
+    Request request = buildRequest(Example.class, foo);
+    assertThat(request.url().toString()).isEqualTo("http://example.com/?hello=world");
+  }
+
   @Test public void queryMapRejectsNullKeys() {
     class Example {
       @GET("/") //
@@ -650,6 +670,48 @@
     assertThat(request.body()).isNull();
   }
 
+  @Test public void getWithEncodedPathSegments() {
+    class Example {
+      @GET("/foo/bar/{ping}/") //
+      Call<ResponseBody> method(@Path(value = "ping", encoded = true) String ping) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, "baz/pong/more");
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/baz/pong/more/");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithUnencodedPathSegmentsPreventsRequestSplitting() {
+    class Example {
+      @GET("/foo/bar/{ping}/") //
+      Call<ResponseBody> method(@Path(value = "ping", encoded = false) String ping) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, "baz/\r\nheader: blue");
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/baz%2F%0D%0Aheader:%20blue/");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithEncodedPathStillPreventsRequestSplitting() {
+    class Example {
+      @GET("/foo/bar/{ping}/") //
+      Call<ResponseBody> method(@Path(value = "ping", encoded = true) String ping) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, "baz/\r\npong");
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/baz/pong/");
+    assertThat(request.body()).isNull();
+  }
+
   @Test public void pathParamRequired() {
     class Example {
       @GET("/foo/bar/{ping}/") //
@@ -1462,6 +1524,29 @@
     }
   }
 
+  @Test public void multipartPartMapSupportsSubclasses() throws IOException {
+    class Foo extends HashMap<String, String> {
+    }
+
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method(@PartMap Foo parts) {
+        return null;
+      }
+    }
+
+    Foo foo = new Foo();
+    foo.put("hello", "world");
+
+    Request request = buildRequest(Example.class, foo);
+    Buffer buffer = new Buffer();
+    request.body().writeTo(buffer);
+    assertThat(buffer.readUtf8())
+        .contains("name=\"hello\"")
+        .contains("\r\n\r\nworld\r\n--");
+  }
+
   @Test public void multipartNullRemovesPart() throws IOException {
     class Example {
       @Multipart //
@@ -1655,6 +1740,27 @@
     }
   }
 
+  @Test public void fieldMapSupportsSubclasses() throws IOException {
+    class Foo extends HashMap<String, String> {
+    }
+
+    class Example {
+      @FormUrlEncoded //
+      @POST("/") //
+      Call<ResponseBody> method(@FieldMap Foo a) {
+        return null;
+      }
+    }
+
+    Foo foo = new Foo();
+    foo.put("hello", "world");
+
+    Request request = buildRequest(Example.class, foo);
+    Buffer buffer = new Buffer();
+    request.body().writeTo(buffer);
+    assertThat(buffer.readUtf8()).isEqualTo("hello=world");
+  }
+
   @Test public void simpleHeaders() {
     class Example {
       @GET("/foo/bar/")
@@ -1779,6 +1885,38 @@
     assertThat(request.body().contentType().toString()).isEqualTo("text/not-plain");
   }
 
+  @Test public void malformedAnnotationRelativeUrlThrows() {
+    class Example {
+      @GET("ftp://example.org")
+      Call<ResponseBody> get() {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "Malformed URL. Base: http://example.com/, Relative: ftp://example.org");
+    }
+  }
+
+  @Test public void malformedParameterRelativeUrlThrows() {
+    class Example {
+      @GET
+      Call<ResponseBody> get(@Url String relativeUrl) {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class, "ftp://example.org");
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "Malformed URL. Base: http://example.com/, Relative: ftp://example.org");
+    }
+  }
+
   private static void assertBody(RequestBody body, String expected) {
     assertThat(body).isNotNull();
     Buffer buffer = new Buffer();
diff --git a/retrofit/src/test/java/retrofit2/ResponseTest.java b/retrofit/src/test/java/retrofit2/ResponseTest.java
index e4594bbc5..d863f7d08 100644
--- a/retrofit/src/test/java/retrofit2/ResponseTest.java
+++ b/retrofit/src/test/java/retrofit2/ResponseTest.java
@@ -15,6 +15,7 @@
  */
 package retrofit2;
 
+import okhttp3.Headers;
 import okhttp3.Protocol;
 import okhttp3.ResponseBody;
 import org.junit.Test;
@@ -54,6 +55,28 @@
     assertThat(response.body()).isNull();
   }
 
+  @Test public void successWithHeaders() {
+    Object body = new Object();
+    Headers headers = Headers.of("foo", "bar");
+    Response<Object> response = Response.success(body, headers);
+    assertThat(response.raw()).isNotNull();
+    assertThat(response.code()).isEqualTo(200);
+    assertThat(response.message()).isEqualTo("OK");
+    assertThat(response.headers().toMultimap()).isEqualTo(headers.toMultimap());
+    assertThat(response.isSuccess()).isTrue();
+    assertThat(response.body()).isSameAs(body);
+    assertThat(response.errorBody()).isNull();
+  }
+
+  @Test public void successWithNullHeadersThrows() {
+    try {
+      Response.success("", (okhttp3.Headers) null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("headers == null");
+    }
+  }
+
   @Test public void successWithRawResponse() {
     Object body = new Object();
     Response<Object> response = Response.success(body, successResponse);
@@ -68,7 +91,7 @@
 
   @Test public void successWithNullRawResponseThrows() {
     try {
-      Response.success("", null);
+      Response.success("", (okhttp3.Response) null);
       fail();
     } catch (NullPointerException e) {
       assertThat(e).hasMessage("rawResponse == null");
diff --git a/retrofit/src/test/java/retrofit2/RetrofitTest.java b/retrofit/src/test/java/retrofit2/RetrofitTest.java
index 7c87a2434..426e05b26 100644
--- a/retrofit/src/test/java/retrofit2/RetrofitTest.java
+++ b/retrofit/src/test/java/retrofit2/RetrofitTest.java
@@ -11,6 +11,7 @@
 import java.util.Set;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.Executor;
+import java.util.concurrent.Executors;
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
@@ -25,6 +26,10 @@
 import okhttp3.mockwebserver.MockWebServer;
 import org.junit.Rule;
 import org.junit.Test;
+import retrofit2.helpers.DelegatingCallAdapterFactory;
+import retrofit2.helpers.NonMatchingCallAdapterFactory;
+import retrofit2.helpers.NonMatchingConverterFactory;
+import retrofit2.helpers.ToStringConverterFactory;
 import retrofit2.http.Body;
 import retrofit2.http.GET;
 import retrofit2.http.POST;
@@ -207,16 +212,16 @@
   @Test public void callCallCustomAdapter() {
     final AtomicBoolean factoryCalled = new AtomicBoolean();
     final AtomicBoolean adapterCalled = new AtomicBoolean();
-    class MyCallAdapterFactory implements CallAdapter.Factory {
+    class MyCallAdapterFactory extends CallAdapter.Factory {
       @Override public CallAdapter<?> get(final Type returnType, Annotation[] annotations,
           Retrofit retrofit) {
         factoryCalled.set(true);
-        if (Utils.getRawType(returnType) != Call.class) {
+        if (getRawType(returnType) != Call.class) {
           return null;
         }
         return new CallAdapter<Call<?>>() {
           @Override public Type responseType() {
-            return Utils.getParameterUpperBound(0, (ParameterizedType) returnType);
+            return getParameterUpperBound(0, (ParameterizedType) returnType);
           }
 
           @Override public <R> Call<R> adapt(Call<R> call) {
@@ -238,10 +243,10 @@
   }
 
   @Test public void customCallAdapter() {
-    class GreetingCallAdapterFactory implements CallAdapter.Factory {
+    class GreetingCallAdapterFactory extends CallAdapter.Factory {
       @Override public CallAdapter<String> get(Type returnType, Annotation[] annotations,
           Retrofit retrofit) {
-        if (Utils.getRawType(returnType) != String.class) {
+        if (getRawType(returnType) != String.class) {
           return null;
         }
         return new CallAdapter<String>() {
@@ -267,7 +272,7 @@
 
   @Test public void methodAnnotationsPassedToCallAdapter() {
     final AtomicReference<Annotation[]> annotationsRef = new AtomicReference<>();
-    class MyCallAdapterFactory implements CallAdapter.Factory {
+    class MyCallAdapterFactory extends CallAdapter.Factory {
       @Override public CallAdapter<?> get(Type returnType, Annotation[] annotations,
           Retrofit retrofit) {
         annotationsRef.set(annotations);
@@ -295,12 +300,13 @@
       example.method();
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Unable to create call adapter for java.util.concurrent.Future<java.lang.String>\n"
-              + "    for method FutureMethod.method");
-      assertThat(e.getCause()).hasMessage(
-          "Could not locate call adapter for java.util.concurrent.Future<java.lang.String>. Tried:\n"
-              + " * retrofit2.DefaultCallAdapter$1");
+      assertThat(e).hasMessage(""
+          + "Unable to create call adapter for java.util.concurrent.Future<java.lang.String>\n"
+          + "    for method FutureMethod.method");
+      assertThat(e.getCause()).hasMessage(""
+          + "Could not locate call adapter for java.util.concurrent.Future<java.lang.String>.\n"
+          + "  Tried:\n"
+          + "   * retrofit2.DefaultCallAdapterFactory");
     }
   }
 
@@ -325,14 +331,18 @@
     assertThat(annotations).hasAtLeastOneElementOfType(Annotated.Foo.class);
   }
 
-  @Test public void parameterAnnotationsPassedToRequestBodyConverter() {
-    final AtomicReference<Annotation[]> annotationsRef = new AtomicReference<>();
+  @Test public void methodAndParameterAnnotationsPassedToRequestBodyConverter() {
+    final AtomicReference<Annotation[]> parameterAnnotationsRef = new AtomicReference<>();
+    final AtomicReference<Annotation[]> methodAnnotationsRef = new AtomicReference<>();
+
     class MyConverterFactory extends Converter.Factory {
       @Override
-      public Converter<?, RequestBody> requestBodyConverter(Type type, Annotation[] annotations,
-          Retrofit retrofit) {
-        annotationsRef.set(annotations);
-        return new ToStringConverterFactory().requestBodyConverter(type, annotations, retrofit);
+      public Converter<?, RequestBody> requestBodyConverter(Type type,
+          Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+        parameterAnnotationsRef.set(parameterAnnotations);
+        methodAnnotationsRef.set(methodAnnotations);
+        return new ToStringConverterFactory().requestBodyConverter(type, parameterAnnotations,
+            methodAnnotations, retrofit);
       }
     }
     Retrofit retrofit = new Retrofit.Builder()
@@ -342,14 +352,15 @@
     Annotated annotated = retrofit.create(Annotated.class);
     annotated.bodyParameter(null); // Trigger internal setup.
 
-    Annotation[] annotations = annotationsRef.get();
-    assertThat(annotations).hasAtLeastOneElementOfType(Annotated.Foo.class);
+    assertThat(parameterAnnotationsRef.get()).hasAtLeastOneElementOfType(Annotated.Foo.class);
+    assertThat(methodAnnotationsRef.get()).hasAtLeastOneElementOfType(POST.class);
   }
 
   @Test public void parameterAnnotationsPassedToStringConverter() {
     final AtomicReference<Annotation[]> annotationsRef = new AtomicReference<>();
     class MyConverterFactory extends Converter.Factory {
-      @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations) {
+      @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+          Retrofit retrofit) {
         annotationsRef.set(annotations);
 
         return new Converter<Object, String>() {
@@ -372,7 +383,8 @@
 
   @Test public void stringConverterNotCalledForString() {
     class MyConverterFactory extends Converter.Factory {
-      @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations) {
+      @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+          Retrofit retrofit) {
         throw new AssertionError();
       }
     }
@@ -389,7 +401,8 @@
   @Test public void stringConverterReturningNullResultsInDefault() {
     final AtomicBoolean factoryCalled = new AtomicBoolean();
     class MyConverterFactory extends Converter.Factory {
-      @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations) {
+      @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+          Retrofit retrofit) {
         factoryCalled.set(true);
         return null;
       }
@@ -413,12 +426,13 @@
       example.disallowed("Hi!");
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Unable to create @Body converter for class java.lang.String (parameter #1)\n"
-              + "    for method CallMethod.disallowed");
-      assertThat(e.getCause()).hasMessage(
-          "Could not locate RequestBody converter for class java.lang.String. Tried:\n"
-              + " * retrofit2.BuiltInConverters");
+      assertThat(e).hasMessage(""
+          + "Unable to create @Body converter for class java.lang.String (parameter #1)\n"
+          + "    for method CallMethod.disallowed");
+      assertThat(e.getCause()).hasMessage(""
+          + "Could not locate RequestBody converter for class java.lang.String.\n"
+          + "  Tried:\n"
+          + "   * retrofit2.BuiltInConverters");
     }
   }
 
@@ -434,31 +448,13 @@
       example.disallowed();
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Unable to create converter for class java.lang.String\n"
-          + "    for method CallMethod.disallowed");
-      assertThat(e.getCause()).hasMessage(
-          "Could not locate ResponseBody converter for class java.lang.String. Tried:\n"
-              + " * retrofit2.BuiltInConverters");
-    }
-  }
-
-  @Test public void converterReturningNullThrows() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new Converter.Factory() {})
-        .build();
-    CallMethod service = retrofit.create(CallMethod.class);
-
-    try {
-      service.disallowed();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Unable to create converter for class java.lang.String\n"
+      assertThat(e).hasMessage(""
+          + "Unable to create converter for class java.lang.String\n"
           + "    for method CallMethod.disallowed");
-      assertThat(e.getCause()).hasMessage(
-          "Could not locate ResponseBody converter for class java.lang.String. Tried:\n"
-              + " * retrofit2.BuiltInConverters\n"
-              + " * retrofit2.RetrofitTest$1");
+      assertThat(e.getCause()).hasMessage(""
+          + "Could not locate ResponseBody converter for class java.lang.String.\n"
+          + "  Tried:\n"
+          + "   * retrofit2.BuiltInConverters");
     }
   }
 
@@ -795,7 +791,8 @@
 
   @Test public void requestConverterFactoryQueried() {
     Type type = String.class;
-    Annotation[] annotations = new Annotation[0];
+    Annotation[] parameterAnnotations = new Annotation[0];
+    Annotation[] methodAnnotations = new Annotation[1];
 
     Converter<?, RequestBody> expectedAdapter = mock(Converter.class);
     Converter.Factory factory = mock(Converter.Factory.class);
@@ -805,12 +802,14 @@
         .addConverterFactory(factory)
         .build();
 
-    doReturn(expectedAdapter).when(factory).requestBodyConverter(type, annotations, retrofit);
+    doReturn(expectedAdapter).when(factory).requestBodyConverter(type, parameterAnnotations,
+        methodAnnotations, retrofit);
 
-    Converter<?, RequestBody> actualAdapter = retrofit.requestBodyConverter(type, annotations);
+    Converter<?, RequestBody> actualAdapter = retrofit.requestBodyConverter(type,
+        parameterAnnotations, methodAnnotations);
     assertThat(actualAdapter).isSameAs(expectedAdapter);
 
-    verify(factory).requestBodyConverter(type, annotations, retrofit);
+    verify(factory).requestBodyConverter(type, parameterAnnotations, methodAnnotations, retrofit);
     verifyNoMoreInteractions(factory);
   }
 
@@ -818,28 +817,55 @@
     Type type = String.class;
     Annotation[] annotations = new Annotation[0];
 
-    Converter.Factory factory1 = spy(new Converter.Factory() {
-      @Override
-      public Converter<?, RequestBody> requestBodyConverter(Type returnType,
-          Annotation[] annotations, Retrofit retrofit) {
-        return null;
-      }
-    });
+    NonMatchingConverterFactory nonMatchingFactory = new NonMatchingConverterFactory();
 
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl("http://example.com/")
-        .addConverterFactory(factory1)
+        .addConverterFactory(nonMatchingFactory)
         .build();
 
     try {
-      retrofit.requestBodyConverter(type, annotations);
+      retrofit.requestBodyConverter(type, annotations, annotations);
+      fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessageStartingWith(
-          "Could not locate RequestBody converter for class java.lang.String. Tried:");
+      assertThat(e).hasMessage(""
+          + "Could not locate RequestBody converter for class java.lang.String.\n"
+          + "  Tried:\n"
+          + "   * retrofit2.BuiltInConverters\n"
+          + "   * retrofit2.helpers.NonMatchingConverterFactory");
     }
 
-    verify(factory1).requestBodyConverter(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory1);
+    assertThat(nonMatchingFactory.called).isTrue();
+  }
+
+  @Test public void requestConverterFactorySkippedNoMatchThrows() {
+    Type type = String.class;
+    Annotation[] annotations = new Annotation[0];
+
+    NonMatchingConverterFactory nonMatchingFactory1 = new NonMatchingConverterFactory();
+    NonMatchingConverterFactory nonMatchingFactory2 = new NonMatchingConverterFactory();
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .addConverterFactory(nonMatchingFactory1)
+        .addConverterFactory(nonMatchingFactory2)
+        .build();
+
+    try {
+      retrofit.nextRequestBodyConverter(nonMatchingFactory1, type, annotations, annotations);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(""
+          + "Could not locate RequestBody converter for class java.lang.String.\n"
+          + "  Skipped:\n"
+          + "   * retrofit2.BuiltInConverters\n"
+          + "   * retrofit2.helpers.NonMatchingConverterFactory\n"
+          + "  Tried:\n"
+          + "   * retrofit2.helpers.NonMatchingConverterFactory");
+    }
+
+    assertThat(nonMatchingFactory1.called).isFalse();
+    assertThat(nonMatchingFactory2.called).isTrue();
   }
 
   @Test public void responseConverterFactoryQueried() {
@@ -867,28 +893,55 @@
     Type type = String.class;
     Annotation[] annotations = new Annotation[0];
 
-    Converter.Factory factory1 = spy(new Converter.Factory() {
-      @Override
-      public Converter<ResponseBody, ?> responseBodyConverter(Type returnType,
-          Annotation[] annotations, Retrofit retrofit) {
-        return null;
-      }
-    });
+    NonMatchingConverterFactory nonMatchingFactory = new NonMatchingConverterFactory();
 
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl("http://example.com/")
-        .addConverterFactory(factory1)
+        .addConverterFactory(nonMatchingFactory)
         .build();
 
     try {
       retrofit.responseBodyConverter(type, annotations);
+      fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessageStartingWith(
-          "Could not locate ResponseBody converter for class java.lang.String. Tried:");
+      assertThat(e).hasMessage(""
+          + "Could not locate ResponseBody converter for class java.lang.String.\n"
+          + "  Tried:\n"
+          + "   * retrofit2.BuiltInConverters\n"
+          + "   * retrofit2.helpers.NonMatchingConverterFactory");
     }
 
-    verify(factory1).responseBodyConverter(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory1);
+    assertThat(nonMatchingFactory.called).isTrue();
+  }
+
+  @Test public void responseConverterFactorySkippedNoMatchThrows() {
+    Type type = String.class;
+    Annotation[] annotations = new Annotation[0];
+
+    NonMatchingConverterFactory nonMatchingFactory1 = new NonMatchingConverterFactory();
+    NonMatchingConverterFactory nonMatchingFactory2 = new NonMatchingConverterFactory();
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .addConverterFactory(nonMatchingFactory1)
+        .addConverterFactory(nonMatchingFactory2)
+        .build();
+
+    try {
+      retrofit.nextResponseBodyConverter(nonMatchingFactory1, type, annotations);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(""
+          + "Could not locate ResponseBody converter for class java.lang.String.\n"
+          + "  Skipped:\n"
+          + "   * retrofit2.BuiltInConverters\n"
+          + "   * retrofit2.helpers.NonMatchingConverterFactory\n"
+          + "  Tried:\n"
+          + "   * retrofit2.helpers.NonMatchingConverterFactory");
+    }
+
+    assertThat(nonMatchingFactory1.called).isFalse();
+    assertThat(nonMatchingFactory2.called).isTrue();
   }
 
   @Test public void stringConverterFactoryQueried() {
@@ -903,12 +956,12 @@
         .addConverterFactory(factory)
         .build();
 
-    doReturn(expectedAdapter).when(factory).stringConverter(type, annotations);
+    doReturn(expectedAdapter).when(factory).stringConverter(type, annotations, retrofit);
 
     Converter<?, String> actualAdapter = retrofit.stringConverter(type, annotations);
     assertThat(actualAdapter).isSameAs(expectedAdapter);
 
-    verify(factory).stringConverter(type, annotations);
+    verify(factory).stringConverter(type, annotations, retrofit);
     verifyNoMoreInteractions(factory);
   }
 
@@ -1040,52 +1093,59 @@
     Type type = String.class;
     Annotation[] annotations = new Annotation[0];
 
-    CallAdapter.Factory factory = mock(CallAdapter.Factory.class);
+    NonMatchingCallAdapterFactory nonMatchingFactory = new NonMatchingCallAdapterFactory();
 
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl("http://example.com/")
-        .addCallAdapterFactory(factory)
+        .addCallAdapterFactory(nonMatchingFactory)
         .build();
 
-    doReturn(null).when(factory).get(type, annotations, retrofit);
-
     try {
       retrofit.callAdapter(type, annotations);
+      fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessageStartingWith(
-          "Could not locate call adapter for class java.lang.String. Tried:");
+      assertThat(e).hasMessage(""
+          + "Could not locate call adapter for class java.lang.String.\n"
+          + "  Tried:\n"
+          + "   * retrofit2.helpers.NonMatchingCallAdapterFactory\n"
+          + "   * retrofit2.DefaultCallAdapterFactory");
     }
 
-    verify(factory).get(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory);
+    assertThat(nonMatchingFactory.called).isTrue();
   }
 
   @Test public void callAdapterFactoryDelegateNoMatchThrows() {
     Type type = String.class;
     Annotation[] annotations = new Annotation[0];
 
-    CallAdapter.Factory factory1 = spy(new CallAdapter.Factory() {
-      @Override
-      public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
-        return retrofit.nextCallAdapter(this, returnType, annotations);
-      }
-    });
+    DelegatingCallAdapterFactory delegatingFactory1 = new DelegatingCallAdapterFactory();
+    DelegatingCallAdapterFactory delegatingFactory2 = new DelegatingCallAdapterFactory();
+    NonMatchingCallAdapterFactory nonMatchingFactory = new NonMatchingCallAdapterFactory();
 
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl("http://example.com/")
-        .addCallAdapterFactory(factory1)
+        .addCallAdapterFactory(delegatingFactory1)
+        .addCallAdapterFactory(delegatingFactory2)
+        .addCallAdapterFactory(nonMatchingFactory)
         .build();
 
     try {
       retrofit.callAdapter(type, annotations);
+      fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessageContaining("Skipped:")
-          .hasMessageStartingWith(
-              "Could not locate call adapter for class java.lang.String. Tried:");
+      assertThat(e).hasMessage(""
+          + "Could not locate call adapter for class java.lang.String.\n"
+          + "  Skipped:\n"
+          + "   * retrofit2.helpers.DelegatingCallAdapterFactory\n"
+          + "   * retrofit2.helpers.DelegatingCallAdapterFactory\n"
+          + "  Tried:\n"
+          + "   * retrofit2.helpers.NonMatchingCallAdapterFactory\n"
+          + "   * retrofit2.DefaultCallAdapterFactory");
     }
 
-    verify(factory1).get(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory1);
+    assertThat(delegatingFactory1.called).isTrue();
+    assertThat(delegatingFactory2.called).isTrue();
+    assertThat(nonMatchingFactory.called).isTrue();
   }
 
   @Test public void callbackExecutorNullThrows() {
@@ -1097,13 +1157,26 @@
     }
   }
 
-  @Test public void callbackExecutorNoDefault() {
+  @Test public void callbackExecutorPropagatesDefaultJvm() {
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl("http://example.com/")
         .build();
     assertThat(retrofit.callbackExecutor()).isNull();
   }
 
+  @Test public void callbackExecutorPropagatesDefaultAndroid() {
+    final Executor executor = Executors.newSingleThreadExecutor();
+    Platform platform = new Platform() {
+      @Override Executor defaultCallbackExecutor() {
+        return executor;
+      }
+    };
+    Retrofit retrofit = new Retrofit.Builder(platform)
+        .baseUrl("http://example.com/")
+        .build();
+    assertThat(retrofit.callbackExecutor()).isSameAs(executor);
+  }
+
   @Test public void callbackExecutorPropagated() {
     Executor executor = mock(Executor.class);
     Retrofit retrofit = new Retrofit.Builder()
diff --git a/retrofit/src/test/java/retrofit2/helpers/DelegatingCallAdapterFactory.java b/retrofit/src/test/java/retrofit2/helpers/DelegatingCallAdapterFactory.java
new file mode 100644
index 000000000..918b0ea0f
--- /dev/null
+++ b/retrofit/src/test/java/retrofit2/helpers/DelegatingCallAdapterFactory.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.helpers;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import retrofit2.CallAdapter;
+import retrofit2.Retrofit;
+
+public final class DelegatingCallAdapterFactory extends CallAdapter.Factory {
+  public boolean called;
+
+  @Override
+  public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+    called = true;
+    return retrofit.nextCallAdapter(this, returnType, annotations);
+  }
+}
diff --git a/retrofit/src/test/java/retrofit2/helpers/NonMatchingCallAdapterFactory.java b/retrofit/src/test/java/retrofit2/helpers/NonMatchingCallAdapterFactory.java
new file mode 100644
index 000000000..2b4954813
--- /dev/null
+++ b/retrofit/src/test/java/retrofit2/helpers/NonMatchingCallAdapterFactory.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.helpers;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import retrofit2.CallAdapter;
+import retrofit2.Retrofit;
+
+public final class NonMatchingCallAdapterFactory extends CallAdapter.Factory {
+  public boolean called;
+
+  @Override
+  public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+    called = true;
+    return null;
+  }
+}
diff --git a/retrofit/src/test/java/retrofit2/helpers/NonMatchingConverterFactory.java b/retrofit/src/test/java/retrofit2/helpers/NonMatchingConverterFactory.java
new file mode 100644
index 000000000..343839944
--- /dev/null
+++ b/retrofit/src/test/java/retrofit2/helpers/NonMatchingConverterFactory.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.helpers;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
+
+public final class NonMatchingConverterFactory extends Converter.Factory {
+  public boolean called;
+
+  @Override
+  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
+    called = true;
+    return null;
+  }
+
+  @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
+      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+    called = true;
+    return null;
+  }
+
+  @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
+    called = true;
+    return null;
+  }
+}
diff --git a/retrofit/src/test/java/retrofit2/ToStringConverterFactory.java b/retrofit/src/test/java/retrofit2/helpers/ToStringConverterFactory.java
similarity index 86%
rename from retrofit/src/test/java/retrofit2/ToStringConverterFactory.java
rename to retrofit/src/test/java/retrofit2/helpers/ToStringConverterFactory.java
index 58492e4af..0a70e3ddb 100644
--- a/retrofit/src/test/java/retrofit2/ToStringConverterFactory.java
+++ b/retrofit/src/test/java/retrofit2/helpers/ToStringConverterFactory.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.helpers;
 
 import java.io.IOException;
 import java.lang.annotation.Annotation;
@@ -21,8 +21,10 @@
 import okhttp3.MediaType;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
 
-class ToStringConverterFactory extends Converter.Factory {
+public class ToStringConverterFactory extends Converter.Factory {
   static final MediaType MEDIA_TYPE = MediaType.parse("text/plain");
 
   @Override
@@ -39,7 +41,7 @@
   }
 
   @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
-      Annotation[] annotations, Retrofit retrofit) {
+      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     if (String.class.equals(type)) {
       return new Converter<String, RequestBody>() {
         @Override public RequestBody convert(String value) throws IOException {
diff --git a/samples/pom.xml b/samples/pom.xml
index 06b4590f3..ca759a16f 100644
--- a/samples/pom.xml
+++ b/samples/pom.xml
@@ -29,6 +29,11 @@
       <artifactId>converter-gson</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>converter-simplexml</artifactId>
+      <version>${project.version}</version>
+    </dependency>
     <dependency>
       <groupId>com.squareup.okhttp3</groupId>
       <artifactId>mockwebserver</artifactId>
diff --git a/samples/src/main/java/com/example/retrofit/ChunkingConverter.java b/samples/src/main/java/com/example/retrofit/ChunkingConverter.java
index 8f6a80a3d..790675975 100644
--- a/samples/src/main/java/com/example/retrofit/ChunkingConverter.java
+++ b/samples/src/main/java/com/example/retrofit/ChunkingConverter.java
@@ -29,7 +29,7 @@
 import okio.BufferedSink;
 import retrofit2.Call;
 import retrofit2.Converter;
-import retrofit2.GsonConverterFactory;
+import retrofit2.converter.gson.GsonConverterFactory;
 import retrofit2.Retrofit;
 import retrofit2.http.Body;
 import retrofit2.http.POST;
@@ -49,11 +49,11 @@
    */
   static class ChunkingConverterFactory extends Converter.Factory {
     @Override
-    public Converter<?, RequestBody> requestBodyConverter(Type type, Annotation[] annotations,
-        Retrofit retrofit) {
+    public Converter<?, RequestBody> requestBodyConverter(Type type,
+        Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
       boolean isBody = false;
       boolean isChunked = false;
-      for (Annotation annotation : annotations) {
+      for (Annotation annotation : parameterAnnotations) {
         isBody |= annotation instanceof Body;
         isChunked |= annotation instanceof Chunked;
       }
@@ -63,7 +63,7 @@
 
       // Look up the real converter to delegate to.
       final Converter<Object, RequestBody> delegate =
-          retrofit.nextRequestBodyConverter(this, type, annotations);
+          retrofit.nextRequestBodyConverter(this, type, parameterAnnotations, methodAnnotations);
       // Wrap it in a Converter which removes the content length from the delegate's body.
       return new Converter<Object, RequestBody>() {
         @Override public RequestBody convert(Object value) throws IOException {
diff --git a/samples/src/main/java/com/example/retrofit/CustomCallAdapter.java b/samples/src/main/java/com/example/retrofit/CustomCallAdapter.java
deleted file mode 100644
index 167d5cfee..000000000
--- a/samples/src/main/java/com/example/retrofit/CustomCallAdapter.java
+++ /dev/null
@@ -1,118 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.example.retrofit;
-
-import com.google.common.reflect.TypeToken;
-import com.google.common.util.concurrent.AbstractFuture;
-import com.google.common.util.concurrent.ListenableFuture;
-import java.io.IOException;
-import java.lang.annotation.Annotation;
-import java.lang.reflect.ParameterizedType;
-import java.lang.reflect.Type;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.Executors;
-import retrofit2.Call;
-import retrofit2.CallAdapter;
-import retrofit2.Callback;
-import retrofit2.GsonConverterFactory;
-import retrofit2.Response;
-import retrofit2.Retrofit;
-import retrofit2.http.GET;
-
-/**
- * A sample showing a custom {@link CallAdapter} which adapts Guava's {@link ListenableFuture} as
- * a service method return type.
- */
-public final class CustomCallAdapter {
-  public static class ListenableFutureCallAdapterFactory implements CallAdapter.Factory {
-    @Override public CallAdapter<ListenableFuture<?>> get(Type returnType, Annotation[] annotations,
-        Retrofit retrofit) {
-      TypeToken<?> token = TypeToken.of(returnType);
-      if (token.getRawType() != ListenableFuture.class) {
-        return null;
-      }
-      if (!(returnType instanceof ParameterizedType)) {
-        throw new IllegalStateException(
-            "ListenableFuture must have generic type (e.g., ListenableFuture<ResponseBody>)");
-      }
-      final Type responseType = ((ParameterizedType) returnType).getActualTypeArguments()[0];
-      return new CallAdapter<ListenableFuture<?>>() {
-        @Override public Type responseType() {
-          return responseType;
-        }
-
-        @Override public <R> ListenableFuture<R> adapt(Call<R> call) {
-          CallFuture<R> future = new CallFuture<>(call);
-          call.enqueue(future);
-          return future;
-        }
-      };
-    }
-
-    private static final class CallFuture<T> extends AbstractFuture<T> implements Callback<T> {
-      private final Call<T> call;
-
-      private CallFuture(Call<T> call) {
-        this.call = call;
-      }
-
-      @Override protected void interruptTask() {
-        call.cancel();
-      }
-
-      @Override public void onResponse(Call<T> call, Response<T> response) {
-        if (response.isSuccess()) {
-          set(response.body());
-        } else {
-          setException(new IOException()); // TODO something more useful.
-        }
-      }
-
-      @Override public void onFailure(Call<T> call, Throwable t) {
-        setException(t);
-      }
-    }
-  }
-
-  interface HttpBinService {
-    @GET("/ip")
-    ListenableFuture<Ip> getIp();
-  }
-
-  static class Ip {
-    String origin;
-  }
-
-  public static void main(String... args) {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://httpbin.org")
-        .addCallAdapterFactory(new ListenableFutureCallAdapterFactory())
-        .addConverterFactory(GsonConverterFactory.create())
-        .build();
-
-    HttpBinService service = retrofit.create(HttpBinService.class);
-    final ListenableFuture<Ip> ip = service.getIp();
-    ip.addListener(new Runnable() {
-      @Override public void run() {
-        try {
-          System.out.println("IP: " + ip.get().origin);
-        } catch (InterruptedException | ExecutionException e) {
-          e.printStackTrace();
-        }
-      }
-    }, Executors.newSingleThreadExecutor());
-  }
-}
diff --git a/samples/src/main/java/com/example/retrofit/DeserializeErrorBody.java b/samples/src/main/java/com/example/retrofit/DeserializeErrorBody.java
index a2f4dd9e8..4fc6c8669 100644
--- a/samples/src/main/java/com/example/retrofit/DeserializeErrorBody.java
+++ b/samples/src/main/java/com/example/retrofit/DeserializeErrorBody.java
@@ -22,7 +22,7 @@
 import okhttp3.mockwebserver.MockWebServer;
 import retrofit2.Call;
 import retrofit2.Converter;
-import retrofit2.GsonConverterFactory;
+import retrofit2.converter.gson.GsonConverterFactory;
 import retrofit2.Response;
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
diff --git a/samples/src/main/java/com/example/retrofit/ErrorHandlingCallAdapter.java b/samples/src/main/java/com/example/retrofit/ErrorHandlingCallAdapter.java
index 9dc8605b7..0189da92b 100644
--- a/samples/src/main/java/com/example/retrofit/ErrorHandlingCallAdapter.java
+++ b/samples/src/main/java/com/example/retrofit/ErrorHandlingCallAdapter.java
@@ -15,15 +15,15 @@
  */
 package com.example.retrofit;
 
-import com.google.common.reflect.TypeToken;
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
+import java.util.concurrent.Executor;
 import retrofit2.Call;
 import retrofit2.CallAdapter;
 import retrofit2.Callback;
-import retrofit2.GsonConverterFactory;
+import retrofit2.converter.gson.GsonConverterFactory;
 import retrofit2.Response;
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
@@ -58,25 +58,25 @@
     // TODO MyResponse<T> execute() throws MyHttpException;
   }
 
-  public static class ErrorHandlingCallAdapterFactory implements CallAdapter.Factory {
+  public static class ErrorHandlingCallAdapterFactory extends CallAdapter.Factory {
     @Override public CallAdapter<MyCall<?>> get(Type returnType, Annotation[] annotations,
         Retrofit retrofit) {
-      TypeToken<?> token = TypeToken.of(returnType);
-      if (token.getRawType() != MyCall.class) {
+      if (getRawType(returnType) != MyCall.class) {
         return null;
       }
       if (!(returnType instanceof ParameterizedType)) {
         throw new IllegalStateException(
             "MyCall must have generic type (e.g., MyCall<ResponseBody>)");
       }
-      final Type responseType = ((ParameterizedType) returnType).getActualTypeArguments()[0];
+      final Type responseType = getParameterUpperBound(0, (ParameterizedType) returnType);
+      final Executor callbackExecutor = retrofit.callbackExecutor();
       return new CallAdapter<MyCall<?>>() {
         @Override public Type responseType() {
           return responseType;
         }
 
         @Override public <R> MyCall<R> adapt(Call<R> call) {
-          return new MyCallAdapter<>(call);
+          return new MyCallAdapter<>(call, callbackExecutor);
         }
       };
     }
@@ -85,9 +85,11 @@
   /** Adapts a {@link Call} to {@link MyCall}. */
   static class MyCallAdapter<T> implements MyCall<T> {
     private final Call<T> call;
+    private final Executor callbackExecutor;
 
-    MyCallAdapter(Call<T> call) {
+    MyCallAdapter(Call<T> call, Executor callbackExecutor) {
       this.call = call;
+      this.callbackExecutor = callbackExecutor;
     }
 
     @Override public void cancel() {
@@ -97,6 +99,9 @@
     @Override public void enqueue(final MyCallback<T> callback) {
       call.enqueue(new Callback<T>() {
         @Override public void onResponse(Call<T> call, Response<T> response) {
+          // TODO if 'callbackExecutor' is not null, the 'callback' methods should be executed
+          // on that executor by submitting a Runnable. This is left as an exercise for the reader.
+
           int code = response.code();
           if (code >= 200 && code < 300) {
             callback.success(response);
@@ -112,6 +117,9 @@
         }
 
         @Override public void onFailure(Call<T> call, Throwable t) {
+          // TODO if 'callbackExecutor' is not null, the 'callback' methods should be executed
+          // on that executor by submitting a Runnable. This is left as an exercise for the reader.
+
           if (t instanceof IOException) {
             callback.networkError((IOException) t);
           } else {
@@ -122,7 +130,7 @@
     }
 
     @Override public MyCall<T> clone() {
-      return new MyCallAdapter<>(call.clone());
+      return new MyCallAdapter<>(call.clone(), callbackExecutor);
     }
   }
 
diff --git a/samples/src/main/java/com/example/retrofit/JsonAndXmlConverters.java b/samples/src/main/java/com/example/retrofit/JsonAndXmlConverters.java
new file mode 100644
index 000000000..2163f3dec
--- /dev/null
+++ b/samples/src/main/java/com/example/retrofit/JsonAndXmlConverters.java
@@ -0,0 +1,128 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.retrofit;
+
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.annotation.Retention;
+import java.lang.reflect.Type;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.simpleframework.xml.Attribute;
+import org.simpleframework.xml.Default;
+import org.simpleframework.xml.DefaultType;
+import retrofit2.Call;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
+import retrofit2.converter.gson.GsonConverterFactory;
+import retrofit2.converter.simplexml.SimpleXmlConverterFactory;
+import retrofit2.http.GET;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Both the Gson converter and the Simple Framework converter accept all types. Because of this,
+ * you cannot use both in a single service by default. In order to work around this, we can create
+ * an @Json and @Xml annotation to declare which serialization format each endpoint should use and
+ * then write our own Converter.Factory which delegates to either the Gson or Simple Framework
+ * converter.
+ */
+public final class JsonAndXmlConverters {
+  @Retention(RUNTIME)
+  @interface Json {
+  }
+
+  @Retention(RUNTIME)
+  @interface Xml {
+  }
+
+  static class QualifiedTypeConverterFactory extends Converter.Factory {
+    private final Converter.Factory jsonFactory;
+    private final Converter.Factory xmlFactory;
+
+    QualifiedTypeConverterFactory(Converter.Factory jsonFactory, Converter.Factory xmlFactory) {
+      this.jsonFactory = jsonFactory;
+      this.xmlFactory = xmlFactory;
+    }
+
+    @Override
+    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+        Retrofit retrofit) {
+      for (Annotation annotation : annotations) {
+        if (annotation instanceof Json) {
+          return jsonFactory.responseBodyConverter(type, annotations, retrofit);
+        }
+        if (annotation instanceof Xml) {
+          return xmlFactory.responseBodyConverter(type, annotations, retrofit);
+        }
+      }
+      return null;
+    }
+
+    @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
+        Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+      for (Annotation annotation : parameterAnnotations) {
+        if (annotation instanceof Json) {
+          return jsonFactory.requestBodyConverter(type, parameterAnnotations, methodAnnotations,
+              retrofit);
+        }
+        if (annotation instanceof Xml) {
+          return xmlFactory.requestBodyConverter(type, parameterAnnotations, methodAnnotations,
+              retrofit);
+        }
+      }
+      return null;
+    }
+  }
+
+  @Default(value = DefaultType.FIELD)
+  static class User {
+    @Attribute
+    public String name;
+  }
+
+  interface Service {
+    @GET("/") @Json
+    Call<User> exampleJson();
+    @GET("/") @Xml
+    Call<User> exampleXml();
+  }
+
+  public static void main(String... args) throws IOException {
+    MockWebServer server = new MockWebServer();
+    server.start();
+    server.enqueue(new MockResponse().setBody("{\"name\": \"Jason\"}"));
+    server.enqueue(new MockResponse().setBody("<user name=\"Eximel\"/>"));
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new QualifiedTypeConverterFactory(
+            GsonConverterFactory.create(),
+            SimpleXmlConverterFactory.create()))
+        .build();
+    Service service = retrofit.create(Service.class);
+
+    User user1 = service.exampleJson().execute().body();
+    System.out.println("User 1: " + user1.name);
+
+    User user2 = service.exampleXml().execute().body();
+    System.out.println("User 2: " + user2.name);
+
+    server.shutdown();
+  }
+}
diff --git a/samples/src/main/java/com/example/retrofit/JsonQueryParameters.java b/samples/src/main/java/com/example/retrofit/JsonQueryParameters.java
new file mode 100644
index 000000000..bc29f8355
--- /dev/null
+++ b/samples/src/main/java/com/example/retrofit/JsonQueryParameters.java
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.retrofit;
+
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.annotation.Retention;
+import java.lang.reflect.Type;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
+import okio.Buffer;
+import retrofit2.Call;
+import retrofit2.Converter;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.converter.gson.GsonConverterFactory;
+import retrofit2.http.GET;
+import retrofit2.http.Query;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+public final class JsonQueryParameters {
+  @Retention(RUNTIME)
+  @interface Json {
+  }
+
+  static class JsonStringConverterFactory extends Converter.Factory {
+    private final Converter.Factory delegateFactory;
+
+    JsonStringConverterFactory(Converter.Factory delegateFactory) {
+      this.delegateFactory = delegateFactory;
+    }
+
+    @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+        Retrofit retrofit) {
+      for (Annotation annotation : annotations) {
+        if (annotation instanceof Json) {
+          // NOTE: If you also have a JSON converter factory installed in addition to this factory,
+          // you can call retrofit.requestBodyConverter(type, annotations) instead of having a
+          // reference to it explicitly as a field.
+          Converter<?, RequestBody> delegate =
+              delegateFactory.requestBodyConverter(type, annotations, new Annotation[0], retrofit);
+          return new DelegateToStringConverter<>(delegate);
+        }
+      }
+      return null;
+    }
+
+    static class DelegateToStringConverter<T> implements Converter<T, String> {
+      private final Converter<T, RequestBody> delegate;
+
+      DelegateToStringConverter(Converter<T, RequestBody> delegate) {
+        this.delegate = delegate;
+      }
+
+      @Override public String convert(T value) throws IOException {
+        Buffer buffer = new Buffer();
+        delegate.convert(value).writeTo(buffer);
+        return buffer.readUtf8();
+      }
+    }
+  }
+
+  static class Filter {
+    public final String userId;
+
+    public Filter(String userId) {
+      this.userId = userId;
+    }
+  }
+
+  interface Service {
+    @GET("/filter")
+    Call<ResponseBody> example(@Json @Query("value") Filter value);
+  }
+
+  public static void main(String... args) throws IOException, InterruptedException {
+    MockWebServer server = new MockWebServer();
+    server.start();
+    server.enqueue(new MockResponse());
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new JsonStringConverterFactory(GsonConverterFactory.create()))
+        .build();
+    Service service = retrofit.create(Service.class);
+
+    Call<ResponseBody> call = service.example(new Filter("123"));
+    Response<ResponseBody> response = call.execute();
+    // TODO handle user response...
+
+    // Print the request path that the server saw to show the JSON query param:
+    RecordedRequest recordedRequest = server.takeRequest();
+    System.out.println(recordedRequest.getPath());
+
+    server.shutdown();
+  }
+}
diff --git a/samples/src/main/java/com/example/retrofit/SimpleService.java b/samples/src/main/java/com/example/retrofit/SimpleService.java
index 135eb818c..ef5a3060e 100644
--- a/samples/src/main/java/com/example/retrofit/SimpleService.java
+++ b/samples/src/main/java/com/example/retrofit/SimpleService.java
@@ -18,7 +18,7 @@
 import java.io.IOException;
 import java.util.List;
 import retrofit2.Call;
-import retrofit2.GsonConverterFactory;
+import retrofit2.converter.gson.GsonConverterFactory;
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
 import retrofit2.http.Path;
diff --git a/website/index.html b/website/index.html
index a0898a502..92c160b86 100644
--- a/website/index.html
+++ b/website/index.html
@@ -52,7 +52,7 @@ <h3>Introduction</h3>
 }</pre>
               <p>The <code>Retrofit</code> class generates an implementation of the <code>GitHubService</code> interface.</p>
               <pre class="prettyprint">Retrofit retrofit = new Retrofit.Builder()
-    .baseUrl("https://api.github.com")
+    .baseUrl("https://api.github.com/")
     .build();
 
 GitHubService service = retrofit.create(GitHubService.class);</pre>
