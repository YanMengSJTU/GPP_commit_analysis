diff --git a/retrofit/src/main/java/retrofit2/BuiltInConverters.java b/retrofit/src/main/java/retrofit2/BuiltInConverters.java
index d580c00fb..4156edb00 100644
--- a/retrofit/src/main/java/retrofit2/BuiltInConverters.java
+++ b/retrofit/src/main/java/retrofit2/BuiltInConverters.java
@@ -15,13 +15,14 @@
  */
 package retrofit2;
 
-import java.io.IOException;
-import java.lang.annotation.Annotation;
-import java.lang.reflect.Type;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import retrofit2.http.Streaming;
 
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+
 final class BuiltInConverters extends Converter.Factory {
   @Override
   public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
diff --git a/retrofit/src/main/java/retrofit2/Call.java b/retrofit/src/main/java/retrofit2/Call.java
index 171d9e0c4..d3bac3065 100644
--- a/retrofit/src/main/java/retrofit2/Call.java
+++ b/retrofit/src/main/java/retrofit2/Call.java
@@ -15,15 +15,16 @@
  */
 package retrofit2;
 
-import java.io.IOException;
 import okhttp3.Request;
 
+import java.io.IOException;
+
 /**
  * An invocation of a Retrofit method that sends a request to a webserver and returns a response.
  * Each call yields its own HTTP request and response pair. Use {@link #clone} to make multiple
  * calls with the same parameters to the same webserver; this may be used to implement polling or
  * to retry a failed call.
- *
+ * <p>
  * <p>Calls may be executed synchronously with {@link #execute}, or asynchronously with {@link
  * #enqueue}. In either case the call can be canceled at any time with {@link #cancel}. A call that
  * is busy writing its request or reading its response may receive a {@link IOException}; this is
@@ -31,43 +32,50 @@
  *
  * @param <T> Successful response body type.
  */
+
+//类装饰器模式
+//子类代理真正实现网络请求的Call
 public interface Call<T> extends Cloneable {
-  /**
-   * Synchronously send the request and return its response.
-   *
-   * @throws IOException if a problem occurred talking to the server.
-   * @throws RuntimeException (and subclasses) if an unexpected error occurs creating the request
-   * or decoding the response.
-   */
-  Response<T> execute() throws IOException;
+    /**
+     * Synchronously send the request and return its response.
+     *
+     * @throws IOException      if a problem occurred talking to the server.
+     * @throws RuntimeException (and subclasses) if an unexpected error occurs creating the request
+     *                          or decoding the response.
+     */
+    Response<T> execute() throws IOException;
 
-  /**
-   * Asynchronously send the request and notify {@code callback} of its response or if an error
-   * occurred talking to the server, creating the request, or processing the response.
-   */
-  void enqueue(Callback<T> callback);
+    /**
+     * Asynchronously send the request and notify {@code callback} of its response or if an error
+     * occurred talking to the server, creating the request, or processing the response.
+     */
+    void enqueue(Callback<T> callback);
 
-  /**
-   * Returns true if this call has been either {@linkplain #execute() executed} or {@linkplain
-   * #enqueue(Callback) enqueued}. It is an error to execute or enqueue a call more than once.
-   */
-  boolean isExecuted();
+    /**
+     * Returns true if this call has been either {@linkplain #execute() executed} or {@linkplain
+     * #enqueue(Callback) enqueued}. It is an error to execute or enqueue a call more than once.
+     */
+    boolean isExecuted();
 
-  /**
-   * Cancel this call. An attempt will be made to cancel in-flight calls, and if the call has not
-   * yet been executed it never will be.
-   */
-  void cancel();
+    /**
+     * Cancel this call. An attempt will be made to cancel in-flight calls, and if the call has not
+     * yet been executed it never will be.
+     */
+    void cancel();
 
-  /** True if {@link #cancel()} was called. */
-  boolean isCanceled();
+    /**
+     * True if {@link #cancel()} was called.
+     */
+    boolean isCanceled();
 
-  /**
-   * Create a new, identical call to this one which can be enqueued or executed even if this call
-   * has already been.
-   */
-  Call<T> clone();
+    /**
+     * Create a new, identical call to this one which can be enqueued or executed even if this call
+     * has already been.
+     */
+    Call<T> clone();
 
-  /** The original HTTP request. */
-  Request request();
+    /**
+     * The original HTTP request.
+     */
+    Request request();
 }
diff --git a/retrofit/src/main/java/retrofit2/OkHttpCall.java b/retrofit/src/main/java/retrofit2/OkHttpCall.java
index 85e55cc5a..a95f4ff4d 100644
--- a/retrofit/src/main/java/retrofit2/OkHttpCall.java
+++ b/retrofit/src/main/java/retrofit2/OkHttpCall.java
@@ -194,6 +194,7 @@ public synchronized boolean isExecuted() {
         return parseResponse(call.execute());
     }
 
+    //感觉有点像装饰器模式,真正的功能都是OkHttpCall实现
     //创建原始请求
     private okhttp3.Call createRawCall() throws IOException {
         Request request = serviceMethod.toRequest(args);
diff --git a/retrofit/src/main/java/retrofit2/Retrofit.java b/retrofit/src/main/java/retrofit2/Retrofit.java
index f0e32eebc..0901c79cf 100644
--- a/retrofit/src/main/java/retrofit2/Retrofit.java
+++ b/retrofit/src/main/java/retrofit2/Retrofit.java
@@ -57,6 +57,7 @@
  * @author Bob Lee (bob@squareup.com)
  * @author Jake Wharton (jw@squareup.com)
  */
+
 public final class Retrofit {
     //缓存service中的业务方法,所以一般Retrofit设置为单例
     private final Map<Method, ServiceMethod> serviceMethodCache = new LinkedHashMap<>();
@@ -383,6 +384,8 @@ public HttpUrl baseUrl() {
 
         // Nothing matched. Resort to default converter which just calls toString().
         //noinspection unchecked
+
+        //普通的键值对解析
         return (Converter<T, String>) BuiltInConverters.ToStringConverter.INSTANCE;
     }
 
diff --git a/retrofit/src/main/java/retrofit2/ServiceMethod.java b/retrofit/src/main/java/retrofit2/ServiceMethod.java
index 984b06e7e..94dde7996 100644
--- a/retrofit/src/main/java/retrofit2/ServiceMethod.java
+++ b/retrofit/src/main/java/retrofit2/ServiceMethod.java
@@ -33,8 +33,6 @@
 
 /**
  * Adapts an invocation of an interface method into an HTTP call.
- * <p>
- * 缓存api上的各种注解配置  例如:@GET 存储get  不用每次都重新解析
  */
 final class ServiceMethod<T> {
     // Upper and lower characters, digits, underscores, and hyphens, starting with a character.
@@ -54,9 +52,6 @@
     private final boolean hasBody;
     private final boolean isFormEncoded;
     private final boolean isMultipart;
-
-
-    //参数解析器  和参数个数 一一对应
     private final ParameterHandler<?>[] parameterHandlers;
 
     ServiceMethod(Builder<T> builder) {
@@ -154,14 +149,12 @@ public ServiceMethod build() {
             callAdapter = createCallAdapter();
             //返回类型
             responseType = callAdapter.responseType();
-
-            //不能直接返回Response,需要用Call<Response>包装
             if (responseType == Response.class || responseType == okhttp3.Response.class) {
                 throw methodError("'"
                         + Utils.getRawType(responseType).getName()
                         + "' is not a valid response body type. Did you mean ResponseBody?");
             }
-            //获取响应解析器
+            //创建响应解析器
             responseConverter = createResponseConverter();
 
             //解析方法上面的注解 get,post,delete eg..
@@ -185,9 +178,7 @@ public ServiceMethod build() {
             }
 
             int parameterCount = parameterAnnotationsArray.length;
-            //生成方法参数上面的解析器
-
-            //负责解析api 上面的参数,为生成Request做准备
+            //参数拼接
             parameterHandlers = new ParameterHandler<?>[parameterCount];
             for (int p = 0; p < parameterCount; p++) {
                 //注解类型
@@ -231,7 +222,6 @@ public ServiceMethod build() {
             if (returnType == void.class) {
                 throw methodError("Service methods cannot return void.");
             }
-            //获取方法上面的注解
             Annotation[] annotations = method.getAnnotations();
             try {
                 return retrofit.callAdapter(returnType, annotations);
