diff --git a/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java b/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java
index a633d60e8..a00a82e14 100644
--- a/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java
+++ b/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java
@@ -33,6 +33,7 @@
     if (getRawType(returnType) != Call.class) {
       return null;
     }
+    //responseType 例如:Call<User>,则返回User类型
     final Type responseType = Utils.getCallResponseType(returnType);
     return new CallAdapter<Object, Call<?>>() {
       @Override public Type responseType() {
diff --git a/retrofit/src/main/java/retrofit2/Retrofit.java b/retrofit/src/main/java/retrofit2/Retrofit.java
index 15ac84da9..cbbd6b95e 100644
--- a/retrofit/src/main/java/retrofit2/Retrofit.java
+++ b/retrofit/src/main/java/retrofit2/Retrofit.java
@@ -139,6 +139,7 @@
             eagerlyValidateMethods(service);
         }
         //java的动态代理 返回service的代理 现在的java动态代理只能代理接口 不能代理普通类
+        //动态代理就是拦截调用的那个方法，在方法前后来做一些操作
         return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[]{service},
                 new InvocationHandler() {
                     private final Platform platform = Platform.get();
