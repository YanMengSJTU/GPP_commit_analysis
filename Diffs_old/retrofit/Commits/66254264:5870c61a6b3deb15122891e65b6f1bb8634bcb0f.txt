diff --git a/.travis.yml b/.travis.yml
index d5b32858e..bcbd5d7b9 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,7 +1,7 @@
 language: java
 
 jdk:
-  - oraclejdk8
+  - openjdk8
 
 # Ensure Javadoc and source jar generation is exercised.
 install: mvn install javadoc:jar source:jar -DskipTests=true -B -V
diff --git a/retrofit/src/main/java/retrofit2/DefaultCallAdapterFactory.java b/retrofit/src/main/java/retrofit2/DefaultCallAdapterFactory.java
index 8c7134565..e7a9c3b5f 100644
--- a/retrofit/src/main/java/retrofit2/DefaultCallAdapterFactory.java
+++ b/retrofit/src/main/java/retrofit2/DefaultCallAdapterFactory.java
@@ -19,12 +19,11 @@
 import java.lang.annotation.Annotation;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
+import java.util.Objects;
 import java.util.concurrent.Executor;
 import javax.annotation.Nullable;
 import okhttp3.Request;
 
-import static retrofit2.Utils.checkNotNull;
-
 final class DefaultCallAdapterFactory extends CallAdapter.Factory {
   private final @Nullable Executor callbackExecutor;
 
@@ -70,7 +69,7 @@
     }
 
     @Override public void enqueue(final Callback<T> callback) {
-      checkNotNull(callback, "callback == null");
+      Objects.requireNonNull(callback, "callback == null");
 
       delegate.enqueue(new Callback<T>() {
         @Override public void onResponse(Call<T> call, final Response<T> response) {
diff --git a/retrofit/src/main/java/retrofit2/HttpException.java b/retrofit/src/main/java/retrofit2/HttpException.java
index f53e76e78..0159817c1 100644
--- a/retrofit/src/main/java/retrofit2/HttpException.java
+++ b/retrofit/src/main/java/retrofit2/HttpException.java
@@ -15,14 +15,13 @@
  */
 package retrofit2;
 
+import java.util.Objects;
 import javax.annotation.Nullable;
 
-import static retrofit2.Utils.checkNotNull;
-
 /** Exception for an unexpected, non-2xx HTTP response. */
 public class HttpException extends RuntimeException {
   private static String getMessage(Response<?> response) {
-    checkNotNull(response, "response == null");
+    Objects.requireNonNull(response, "response == null");
     return "HTTP " + response.code() + " " + response.message();
   }
 
diff --git a/retrofit/src/main/java/retrofit2/HttpServiceMethod.java b/retrofit/src/main/java/retrofit2/HttpServiceMethod.java
index bc8bdf814..e79205ab2 100644
--- a/retrofit/src/main/java/retrofit2/HttpServiceMethod.java
+++ b/retrofit/src/main/java/retrofit2/HttpServiceMethod.java
@@ -186,9 +186,22 @@
 
       //noinspection unchecked Checked by reflection inside RequestFactory.
       Continuation<ResponseT> continuation = (Continuation<ResponseT>) args[args.length - 1];
-      return isNullable
-          ? KotlinExtensions.awaitNullable(call, continuation)
-          : KotlinExtensions.await(call, continuation);
+
+      // Calls to OkHttp Call.enqueue() like those inside await and awaitNullable can sometimes
+      // invoke the supplied callback with an exception before the invoking stack frame can return.
+      // Coroutines will intercept the subsequent invocation of the Continuation and throw the
+      // exception synchronously. A Java Proxy cannot throw checked exceptions without them being
+      // declared on the interface method. To avoid the synchronous checked exception being wrapped
+      // in an UndeclaredThrowableException, it is intercepted and supplied to a helper which will
+      // force suspension to occur so that it can be instead delivered to the continuation to
+      // bypass this restriction.
+      try {
+        return isNullable
+            ? KotlinExtensions.awaitNullable(call, continuation)
+            : KotlinExtensions.await(call, continuation);
+      } catch (Exception e) {
+        return KotlinExtensions.yieldAndThrow(e, continuation);
+      }
     }
   }
 }
diff --git a/retrofit/src/main/java/retrofit2/Invocation.java b/retrofit/src/main/java/retrofit2/Invocation.java
index 6f1ca5fb4..01468658c 100644
--- a/retrofit/src/main/java/retrofit2/Invocation.java
+++ b/retrofit/src/main/java/retrofit2/Invocation.java
@@ -19,8 +19,7 @@
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
-
-import static retrofit2.Utils.checkNotNull;
+import java.util.Objects;
 
 /**
  * A single invocation of a Retrofit service interface method. This class captures both the method
@@ -51,8 +50,8 @@
  */
 public final class Invocation {
   public static Invocation of(Method method, List<?> arguments) {
-    checkNotNull(method, "method == null");
-    checkNotNull(arguments, "arguments == null");
+    Objects.requireNonNull(method, "method == null");
+    Objects.requireNonNull(arguments, "arguments == null");
     return new Invocation(method, new ArrayList<>(arguments)); // Defensive copy.
   }
 
diff --git a/retrofit/src/main/java/retrofit2/KotlinExtensions.kt b/retrofit/src/main/java/retrofit2/KotlinExtensions.kt
index b24212e08..7137ac928 100644
--- a/retrofit/src/main/java/retrofit2/KotlinExtensions.kt
+++ b/retrofit/src/main/java/retrofit2/KotlinExtensions.kt
@@ -19,6 +19,7 @@
 package retrofit2
 
 import kotlinx.coroutines.suspendCancellableCoroutine
+import kotlinx.coroutines.yield
 import kotlin.coroutines.resume
 import kotlin.coroutines.resumeWithException
 
@@ -95,3 +96,8 @@ suspend fun <T : Any> Call<T>.awaitResponse(): Response<T> {
     })
   }
 }
+
+internal suspend fun Exception.yieldAndThrow(): Nothing {
+  yield()
+  throw this
+}
diff --git a/retrofit/src/main/java/retrofit2/OkHttpCall.java b/retrofit/src/main/java/retrofit2/OkHttpCall.java
index a5b5b9237..cc348a660 100644
--- a/retrofit/src/main/java/retrofit2/OkHttpCall.java
+++ b/retrofit/src/main/java/retrofit2/OkHttpCall.java
@@ -16,6 +16,7 @@
 package retrofit2;
 
 import java.io.IOException;
+import java.util.Objects;
 import javax.annotation.Nullable;
 import javax.annotation.concurrent.GuardedBy;
 import okhttp3.MediaType;
@@ -26,7 +27,6 @@
 import okio.ForwardingSource;
 import okio.Okio;
 
-import static retrofit2.Utils.checkNotNull;
 import static retrofit2.Utils.throwIfFatal;
 
 final class OkHttpCall<T> implements Call<T> {
@@ -84,7 +84,7 @@
   }
 
   @Override public void enqueue(final Callback<T> callback) {
-    checkNotNull(callback, "callback == null");
+    Objects.requireNonNull(callback, "callback == null");
 
     okhttp3.Call call;
     Throwable failure;
diff --git a/retrofit/src/main/java/retrofit2/ParameterHandler.java b/retrofit/src/main/java/retrofit2/ParameterHandler.java
index 1d416c475..7dcf4741f 100644
--- a/retrofit/src/main/java/retrofit2/ParameterHandler.java
+++ b/retrofit/src/main/java/retrofit2/ParameterHandler.java
@@ -19,12 +19,11 @@
 import java.lang.reflect.Array;
 import java.lang.reflect.Method;
 import java.util.Map;
+import java.util.Objects;
 import javax.annotation.Nullable;
 import okhttp3.MultipartBody;
 import okhttp3.RequestBody;
 
-import static retrofit2.Utils.checkNotNull;
-
 abstract class ParameterHandler<T> {
   abstract void apply(RequestBuilder builder, @Nullable T value) throws IOException;
 
@@ -76,7 +75,7 @@
     private final Converter<T, String> valueConverter;
 
     Header(String name, Converter<T, String> valueConverter) {
-      this.name = checkNotNull(name, "name == null");
+      this.name = Objects.requireNonNull(name, "name == null");
       this.valueConverter = valueConverter;
     }
 
@@ -101,7 +100,7 @@
     Path(Method method, int p, String name, Converter<T, String> valueConverter, boolean encoded) {
       this.method = method;
       this.p = p;
-      this.name = checkNotNull(name, "name == null");
+      this.name = Objects.requireNonNull(name, "name == null");
       this.valueConverter = valueConverter;
       this.encoded = encoded;
     }
@@ -121,7 +120,7 @@
     private final boolean encoded;
 
     Query(String name, Converter<T, String> valueConverter, boolean encoded) {
-      this.name = checkNotNull(name, "name == null");
+      this.name = Objects.requireNonNull(name, "name == null");
       this.valueConverter = valueConverter;
       this.encoded = encoded;
     }
@@ -252,7 +251,7 @@
     private final boolean encoded;
 
     Field(String name, Converter<T, String> valueConverter, boolean encoded) {
-      this.name = checkNotNull(name, "name == null");
+      this.name = Objects.requireNonNull(name, "name == null");
       this.valueConverter = valueConverter;
       this.encoded = encoded;
     }
diff --git a/retrofit/src/main/java/retrofit2/Response.java b/retrofit/src/main/java/retrofit2/Response.java
index 598bcf02b..7c5a4646c 100644
--- a/retrofit/src/main/java/retrofit2/Response.java
+++ b/retrofit/src/main/java/retrofit2/Response.java
@@ -15,14 +15,13 @@
  */
 package retrofit2;
 
+import java.util.Objects;
 import javax.annotation.Nullable;
 import okhttp3.Headers;
 import okhttp3.Protocol;
 import okhttp3.Request;
 import okhttp3.ResponseBody;
 
-import static retrofit2.Utils.checkNotNull;
-
 /** An HTTP response. */
 public final class Response<T> {
   /** Create a synthetic successful response with {@code body} as the deserialized body. */
@@ -56,7 +55,7 @@
    * deserialized body.
    */
   public static <T> Response<T> success(@Nullable T body, Headers headers) {
-    checkNotNull(headers, "headers == null");
+    Objects.requireNonNull(headers, "headers == null");
     return success(body, new okhttp3.Response.Builder() //
         .code(200)
         .message("OK")
@@ -71,7 +70,7 @@
    * body.
    */
   public static <T> Response<T> success(@Nullable T body, okhttp3.Response rawResponse) {
-    checkNotNull(rawResponse, "rawResponse == null");
+    Objects.requireNonNull(rawResponse, "rawResponse == null");
     if (!rawResponse.isSuccessful()) {
       throw new IllegalArgumentException("rawResponse must be successful response");
     }
@@ -83,7 +82,7 @@
    * as the error body.
    */
   public static <T> Response<T> error(int code, ResponseBody body) {
-    checkNotNull(body, "body == null");
+    Objects.requireNonNull(body, "body == null");
     if (code < 400) throw new IllegalArgumentException("code < 400: " + code);
     return error(body, new okhttp3.Response.Builder() //
         .body(new OkHttpCall.NoContentResponseBody(body.contentType(), body.contentLength()))
@@ -96,8 +95,8 @@
 
   /** Create an error response from {@code rawResponse} with {@code body} as the error body. */
   public static <T> Response<T> error(ResponseBody body, okhttp3.Response rawResponse) {
-    checkNotNull(body, "body == null");
-    checkNotNull(rawResponse, "rawResponse == null");
+    Objects.requireNonNull(body, "body == null");
+    Objects.requireNonNull(rawResponse, "rawResponse == null");
     if (rawResponse.isSuccessful()) {
       throw new IllegalArgumentException("rawResponse should not be successful response");
     }
diff --git a/retrofit/src/main/java/retrofit2/Retrofit.java b/retrofit/src/main/java/retrofit2/Retrofit.java
index 7453a9ac2..ebabe714f 100644
--- a/retrofit/src/main/java/retrofit2/Retrofit.java
+++ b/retrofit/src/main/java/retrofit2/Retrofit.java
@@ -22,9 +22,13 @@
 import java.lang.reflect.Proxy;
 import java.lang.reflect.Type;
 import java.net.URL;
+import java.util.ArrayDeque;
 import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Deque;
 import java.util.List;
 import java.util.Map;
+import java.util.Objects;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.Executor;
 import javax.annotation.Nullable;
@@ -38,7 +42,6 @@
 import retrofit2.http.Url;
 
 import static java.util.Collections.unmodifiableList;
-import static retrofit2.Utils.checkNotNull;
 
 /**
  * Retrofit adapts a Java interface to HTTP calls by using annotations on the declared methods to
@@ -128,10 +131,7 @@
    */
   @SuppressWarnings("unchecked") // Single-interface proxy creation guarded by parameter safety.
   public <T> T create(final Class<T> service) {
-    Utils.validateServiceInterface(service);
-    if (validateEagerly) {
-      eagerlyValidateMethods(service);
-    }
+    validateServiceInterface(service);
     return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service },
         new InvocationHandler() {
           private final Platform platform = Platform.get();
@@ -151,11 +151,33 @@
         });
   }
 
-  private void eagerlyValidateMethods(Class<?> service) {
-    Platform platform = Platform.get();
-    for (Method method : service.getDeclaredMethods()) {
-      if (!platform.isDefaultMethod(method) && !Modifier.isStatic(method.getModifiers())) {
-        loadServiceMethod(method);
+  private void validateServiceInterface(Class<?> service) {
+    if (!service.isInterface()) {
+      throw new IllegalArgumentException("API declarations must be interfaces.");
+    }
+
+    Deque<Class<?>> check = new ArrayDeque<>(1);
+    check.add(service);
+    while (!check.isEmpty()) {
+      Class<?> candidate = check.removeFirst();
+      if (candidate.getTypeParameters().length != 0) {
+        StringBuilder message = new StringBuilder("Type parameters are unsupported on ")
+            .append(candidate.getName());
+        if (candidate != service) {
+          message.append(" which is an interface of ")
+              .append(service.getName());
+        }
+        throw new IllegalArgumentException(message.toString());
+      }
+      Collections.addAll(check, candidate.getInterfaces());
+    }
+
+    if (validateEagerly) {
+      Platform platform = Platform.get();
+      for (Method method : service.getDeclaredMethods()) {
+        if (!platform.isDefaultMethod(method) && !Modifier.isStatic(method.getModifiers())) {
+          loadServiceMethod(method);
+        }
       }
     }
   }
@@ -213,8 +235,8 @@ public HttpUrl baseUrl() {
    */
   public CallAdapter<?, ?> nextCallAdapter(@Nullable CallAdapter.Factory skipPast, Type returnType,
       Annotation[] annotations) {
-    checkNotNull(returnType, "returnType == null");
-    checkNotNull(annotations, "annotations == null");
+    Objects.requireNonNull(returnType, "returnType == null");
+    Objects.requireNonNull(annotations, "annotations == null");
 
     int start = callAdapterFactories.indexOf(skipPast) + 1;
     for (int i = start, count = callAdapterFactories.size(); i < count; i++) {
@@ -271,9 +293,9 @@ public HttpUrl baseUrl() {
   public <T> Converter<T, RequestBody> nextRequestBodyConverter(
       @Nullable Converter.Factory skipPast, Type type, Annotation[] parameterAnnotations,
       Annotation[] methodAnnotations) {
-    checkNotNull(type, "type == null");
-    checkNotNull(parameterAnnotations, "parameterAnnotations == null");
-    checkNotNull(methodAnnotations, "methodAnnotations == null");
+    Objects.requireNonNull(type, "type == null");
+    Objects.requireNonNull(parameterAnnotations, "parameterAnnotations == null");
+    Objects.requireNonNull(methodAnnotations, "methodAnnotations == null");
 
     int start = converterFactories.indexOf(skipPast) + 1;
     for (int i = start, count = converterFactories.size(); i < count; i++) {
@@ -321,8 +343,8 @@ public HttpUrl baseUrl() {
    */
   public <T> Converter<ResponseBody, T> nextResponseBodyConverter(
       @Nullable Converter.Factory skipPast, Type type, Annotation[] annotations) {
-    checkNotNull(type, "type == null");
-    checkNotNull(annotations, "annotations == null");
+    Objects.requireNonNull(type, "type == null");
+    Objects.requireNonNull(annotations, "annotations == null");
 
     int start = converterFactories.indexOf(skipPast) + 1;
     for (int i = start, count = converterFactories.size(); i < count; i++) {
@@ -356,8 +378,8 @@ public HttpUrl baseUrl() {
    * {@linkplain #converterFactories() factories}.
    */
   public <T> Converter<T, String> stringConverter(Type type, Annotation[] annotations) {
-    checkNotNull(type, "type == null");
-    checkNotNull(annotations, "annotations == null");
+    Objects.requireNonNull(type, "type == null");
+    Objects.requireNonNull(annotations, "annotations == null");
 
     for (int i = 0, count = converterFactories.size(); i < count; i++) {
       Converter<?, String> converter =
@@ -437,7 +459,7 @@ public Builder() {
      * This is a convenience method for calling {@link #callFactory}.
      */
     public Builder client(OkHttpClient client) {
-      return callFactory(checkNotNull(client, "client == null"));
+      return callFactory(Objects.requireNonNull(client, "client == null"));
     }
 
     /**
@@ -446,7 +468,7 @@ public Builder client(OkHttpClient client) {
      * Note: Calling {@link #client} automatically sets this value.
      */
     public Builder callFactory(okhttp3.Call.Factory factory) {
-      this.callFactory = checkNotNull(factory, "factory == null");
+      this.callFactory = Objects.requireNonNull(factory, "factory == null");
       return this;
     }
 
@@ -456,7 +478,7 @@ public Builder callFactory(okhttp3.Call.Factory factory) {
      * @see #baseUrl(HttpUrl)
      */
     public Builder baseUrl(URL baseUrl) {
-      checkNotNull(baseUrl, "baseUrl == null");
+      Objects.requireNonNull(baseUrl, "baseUrl == null");
       return baseUrl(HttpUrl.get(baseUrl.toString()));
     }
 
@@ -466,7 +488,7 @@ public Builder baseUrl(URL baseUrl) {
      * @see #baseUrl(HttpUrl)
      */
     public Builder baseUrl(String baseUrl) {
-      checkNotNull(baseUrl, "baseUrl == null");
+      Objects.requireNonNull(baseUrl, "baseUrl == null");
       return baseUrl(HttpUrl.get(baseUrl));
     }
 
@@ -521,7 +543,7 @@ public Builder baseUrl(String baseUrl) {
      * Result: http://github.com/square/retrofit/ (note the scheme stays 'http')
      */
     public Builder baseUrl(HttpUrl baseUrl) {
-      checkNotNull(baseUrl, "baseUrl == null");
+      Objects.requireNonNull(baseUrl, "baseUrl == null");
       List<String> pathSegments = baseUrl.pathSegments();
       if (!"".equals(pathSegments.get(pathSegments.size() - 1))) {
         throw new IllegalArgumentException("baseUrl must end in /: " + baseUrl);
@@ -532,7 +554,7 @@ public Builder baseUrl(HttpUrl baseUrl) {
 
     /** Add converter factory for serialization and deserialization of objects. */
     public Builder addConverterFactory(Converter.Factory factory) {
-      converterFactories.add(checkNotNull(factory, "factory == null"));
+      converterFactories.add(Objects.requireNonNull(factory, "factory == null"));
       return this;
     }
 
@@ -541,7 +563,7 @@ public Builder addConverterFactory(Converter.Factory factory) {
      * Call}.
      */
     public Builder addCallAdapterFactory(CallAdapter.Factory factory) {
-      callAdapterFactories.add(checkNotNull(factory, "factory == null"));
+      callAdapterFactories.add(Objects.requireNonNull(factory, "factory == null"));
       return this;
     }
 
@@ -553,7 +575,7 @@ public Builder addCallAdapterFactory(CallAdapter.Factory factory) {
      * return types}.
      */
     public Builder callbackExecutor(Executor executor) {
-      this.callbackExecutor = checkNotNull(executor, "executor == null");
+      this.callbackExecutor = Objects.requireNonNull(executor, "executor == null");
       return this;
     }
 
diff --git a/retrofit/src/main/java/retrofit2/Utils.java b/retrofit/src/main/java/retrofit2/Utils.java
index 25fdcbf5e..6ddf88028 100644
--- a/retrofit/src/main/java/retrofit2/Utils.java
+++ b/retrofit/src/main/java/retrofit2/Utils.java
@@ -27,6 +27,7 @@
 import java.lang.reflect.WildcardType;
 import java.util.Arrays;
 import java.util.NoSuchElementException;
+import java.util.Objects;
 import javax.annotation.Nullable;
 import okhttp3.ResponseBody;
 import okio.Buffer;
@@ -62,7 +63,7 @@ static RuntimeException parameterError(Method method, int p, String message, Obj
   }
 
   static Class<?> getRawType(Type type) {
-    checkNotNull(type, "type == null");
+    Objects.requireNonNull(type, "type == null");
 
     if (type instanceof Class<?>) {
       // Type is a normal class.
@@ -299,13 +300,6 @@ static void checkNotPrimitive(Type type) {
     }
   }
 
-  static <T> T checkNotNull(@Nullable T object, String message) {
-    if (object == null) {
-      throw new NullPointerException(message);
-    }
-    return object;
-  }
-
   /** Returns true if {@code annotations} contains an instance of {@code cls}. */
   static boolean isAnnotationPresent(Annotation[] annotations,
       Class<? extends Annotation> cls) {
@@ -323,18 +317,6 @@ static ResponseBody buffer(final ResponseBody body) throws IOException {
     return ResponseBody.create(body.contentType(), body.contentLength(), buffer);
   }
 
-  static <T> void validateServiceInterface(Class<T> service) {
-    if (!service.isInterface()) {
-      throw new IllegalArgumentException("API declarations must be interfaces.");
-    }
-    // Prevent API interfaces from extending other interfaces. This not only avoids a bug in
-    // Android (http://b.android.com/58753) but it forces composition of API declarations which is
-    // the recommended pattern.
-    if (service.getInterfaces().length > 0) {
-      throw new IllegalArgumentException("API interfaces must not extend other interfaces.");
-    }
-  }
-
   static Type getParameterUpperBound(int index, ParameterizedType type) {
     Type[] types = type.getActualTypeArguments();
     if (index < 0 || index >= types.length) {
@@ -396,7 +378,7 @@ static boolean hasUnresolvableType(@Nullable Type type) {
       }
 
       for (Type typeArgument : typeArguments) {
-        checkNotNull(typeArgument, "typeArgument == null");
+        Objects.requireNonNull(typeArgument, "typeArgument == null");
         checkNotPrimitive(typeArgument);
       }
 
diff --git a/retrofit/src/test/java/retrofit2/KotlinSuspendTest.kt b/retrofit/src/test/java/retrofit2/KotlinSuspendTest.kt
index 629b02624..e3c005e81 100644
--- a/retrofit/src/test/java/retrofit2/KotlinSuspendTest.kt
+++ b/retrofit/src/test/java/retrofit2/KotlinSuspendTest.kt
@@ -273,4 +273,26 @@ class KotlinSuspendTest {
     val body = runBlocking { example.body() }
     assertThat(body).isEqualTo("HiHiHiHiHi")
   }
+
+  @Test fun checkedExceptionsAreNotSynchronouslyThrown() = runBlocking {
+    val retrofit = Retrofit.Builder()
+        .baseUrl("https://unresolved-host.com/")
+        .addConverterFactory(ToStringConverterFactory())
+        .build()
+    val example = retrofit.create(Service::class.java)
+
+    server.shutdown()
+
+    // The problematic behavior of the UnknownHostException being synchronously thrown is
+    // probabilistic based on thread preemption. Running a thousand times will almost always
+    // trigger it, so we run an order of magnitude more to be safe.
+    repeat(10000) {
+      try {
+        example.body()
+        fail()
+      } catch (_: IOException) {
+        // We expect IOException, the bad behavior will wrap this in UndeclaredThrowableException.
+      }
+    }
+  }
 }
diff --git a/retrofit/src/test/java/retrofit2/RetrofitTest.java b/retrofit/src/test/java/retrofit2/RetrofitTest.java
index 2310a74ce..3ffabbc5b 100644
--- a/retrofit/src/test/java/retrofit2/RetrofitTest.java
+++ b/retrofit/src/test/java/retrofit2/RetrofitTest.java
@@ -85,6 +85,10 @@
   }
   interface Extending extends CallMethod {
   }
+  interface TypeParam<T> {
+  }
+  interface ExtendingTypeParam extends TypeParam<String> {
+  }
   interface StringService {
     @GET("/") String get();
   }
@@ -129,15 +133,47 @@
     assertThat(example.toString()).isNotEmpty();
   }
 
-  @Test public void interfaceWithExtendIsNotSupported() {
+  @Test public void interfaceWithTypeParameterThrows() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .build();
+
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    try {
+      retrofit.create(TypeParam.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Type parameters are unsupported on retrofit2.RetrofitTest$TypeParam");
+    }
+  }
+
+  @Test public void interfaceWithExtend() throws IOException {
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
         .build();
+
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    Extending extending = retrofit.create(Extending.class);
+    String result = extending.getResponseBody().execute().body().string();
+    assertEquals("Hi", result);
+  }
+
+  @Test public void interfaceWithExtendWithTypeParameterThrows() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .build();
+
+    server.enqueue(new MockResponse().setBody("Hi"));
+
     try {
-      retrofit.create(Extending.class);
+      retrofit.create(ExtendingTypeParam.class);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("API interfaces must not extend other interfaces.");
+      assertThat(e).hasMessage(
+          "Type parameters are unsupported on retrofit2.RetrofitTest$TypeParam "
+              + "which is an interface of retrofit2.RetrofitTest$ExtendingTypeParam");
     }
   }
 
