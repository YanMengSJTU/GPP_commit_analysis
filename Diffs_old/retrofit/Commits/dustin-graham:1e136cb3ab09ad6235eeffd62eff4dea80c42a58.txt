diff --git a/checkstyle.xml b/checkstyle.xml
index c75dc8d30..97406003b 100644
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -79,7 +79,7 @@
 
         <!-- Checks for blocks. You know, those {}'s         -->
         <!-- See http://checkstyle.sf.net/config_blocks.html -->
-        <module name="AvoidNestedBlocks"/>
+        <!--module name="AvoidNestedBlocks"/-->
         <!--module name="EmptyBlock"/-->
         <module name="LeftCurly"/>
         <!--module name="NeedBraces"/-->
diff --git a/pom.xml b/pom.xml
index 414cad2c4..0479a3d74 100644
--- a/pom.xml
+++ b/pom.xml
@@ -50,8 +50,9 @@
     <!-- Dependencies -->
     <android.version>4.1.1.4</android.version>
     <android.platform>16</android.platform>
-    <gson.version>2.2.2</gson.version>
+    <gson.version>2.2.3</gson.version>
     <javax.inject.version>1</javax.inject.version>
+    <okhttp.version>1.0.1</okhttp.version>
 
     <!-- Test Dependencies -->
     <junit.version>4.10</junit.version>
@@ -66,21 +67,6 @@
     <developerConnection>scm:git:ssh://git@github.com/square/retrofit.git</developerConnection>
   </scm>
 
-  <!-- Bring in Maven Central Snapshots for Gson 2.2.3-SNAPSHOT -->
-  <repositories>
-    <repository>
-      <id>sonatype-nexus-snapshots</id>
-      <name>Sonatype Nexus Snapshots</name>
-      <url>https://oss.sonatype.org/content/repositories/snapshots</url>
-      <releases>
-        <enabled>false</enabled>
-      </releases>
-      <snapshots>
-        <enabled>true</enabled>
-      </snapshots>
-    </repository>
-  </repositories>
-
   <issueManagement>
     <system>GitHub Issues</system>
     <url>http://github.com/square/retrofit/issues</url>
@@ -105,6 +91,11 @@
         <artifactId>android</artifactId>
         <version>${android.version}</version>
       </dependency>
+      <dependency>
+        <groupId>com.squareup.okhttp</groupId>
+        <artifactId>okhttp</artifactId>
+        <version>${okhttp.version}</version>
+      </dependency>
       <dependency>
         <groupId>com.google.code.gson</groupId>
         <artifactId>gson</artifactId>
diff --git a/retrofit/pom.xml b/retrofit/pom.xml
index f2ecdc6c2..caedfd85a 100644
--- a/retrofit/pom.xml
+++ b/retrofit/pom.xml
@@ -25,6 +25,11 @@
       <artifactId>android</artifactId>
       <optional>true</optional>
     </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>okhttp</artifactId>
+      <optional>true</optional>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
diff --git a/retrofit/src/main/java/retrofit/http/SingleEntity.java b/retrofit/src/main/java/retrofit/http/Body.java
similarity index 53%
rename from retrofit/src/main/java/retrofit/http/SingleEntity.java
rename to retrofit/src/main/java/retrofit/http/Body.java
index ff0be889b..2b560989a 100644
--- a/retrofit/src/main/java/retrofit/http/SingleEntity.java
+++ b/retrofit/src/main/java/retrofit/http/Body.java
@@ -1,4 +1,18 @@
-// Copyright 2011 Square, Inc.
+/*
+ * Copyright (C) 2011 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package retrofit.http;
 
 import java.lang.annotation.Retention;
@@ -16,7 +30,6 @@
  *
  * @author Eric Denman (edenman@squareup.com)
  */
-@Retention(RUNTIME)
-@Target(PARAMETER)
-public @interface SingleEntity {
+@Target(PARAMETER) @Retention(RUNTIME)
+public @interface Body {
 }
diff --git a/retrofit/src/main/java/retrofit/http/Callback.java b/retrofit/src/main/java/retrofit/http/Callback.java
index 28a556f22..8cdbc9b44 100644
--- a/retrofit/src/main/java/retrofit/http/Callback.java
+++ b/retrofit/src/main/java/retrofit/http/Callback.java
@@ -1,4 +1,18 @@
-// Copyright 2012 Square, Inc.
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package retrofit.http;
 
 import retrofit.http.client.Response;
diff --git a/retrofit/src/main/java/retrofit/http/CallbackRunnable.java b/retrofit/src/main/java/retrofit/http/CallbackRunnable.java
index debfa2610..4d291ea10 100644
--- a/retrofit/src/main/java/retrofit/http/CallbackRunnable.java
+++ b/retrofit/src/main/java/retrofit/http/CallbackRunnable.java
@@ -1,4 +1,18 @@
-// Copyright 2012 Square, Inc.
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package retrofit.http;
 
 import java.util.concurrent.Executor;
diff --git a/retrofit/src/main/java/retrofit/http/ChangeableServer.java b/retrofit/src/main/java/retrofit/http/ChangeableServer.java
index f247024fa..b0c9ef695 100644
--- a/retrofit/src/main/java/retrofit/http/ChangeableServer.java
+++ b/retrofit/src/main/java/retrofit/http/ChangeableServer.java
@@ -1,3 +1,18 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package retrofit.http;
 
 /** A {@link Server} whose URL and name can be changed at runtime. */
diff --git a/retrofit/src/main/java/retrofit/http/ConversionException.java b/retrofit/src/main/java/retrofit/http/ConversionException.java
index bb0eff949..5619f54e6 100644
--- a/retrofit/src/main/java/retrofit/http/ConversionException.java
+++ b/retrofit/src/main/java/retrofit/http/ConversionException.java
@@ -1,3 +1,18 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package retrofit.http;
 
 /** Indicate that conversion was unable to complete successfully. */
diff --git a/retrofit/src/main/java/retrofit/http/Converter.java b/retrofit/src/main/java/retrofit/http/Converter.java
index 638e2eb5c..73289cff8 100644
--- a/retrofit/src/main/java/retrofit/http/Converter.java
+++ b/retrofit/src/main/java/retrofit/http/Converter.java
@@ -1,4 +1,18 @@
-// Copyright 2012 Square, Inc.
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package retrofit.http;
 
 import java.lang.reflect.Type;
@@ -17,8 +31,10 @@
    * @param body HTTP response body.
    * @param type Target object type.
    * @return Instance of {@code type} which will be cast by the caller.
-   * @throws ConversionException If conversion was unable to complete. This will trigger a call to
-   * {@link Callback#failure(RetrofitError)} or throw a {@link retrofit.http.RetrofitError}.
+   * @throws ConversionException if conversion was unable to complete. This will trigger a call to
+   * {@link Callback#failure(RetrofitError)} or throw a {@link retrofit.http.RetrofitError}. The
+   * exception message should report all necessary information about its cause as the response body
+   * will be set to {@code null}.
    */
   Object fromBody(TypedInput body, Type type) throws ConversionException;
 
diff --git a/retrofit/src/main/java/retrofit/http/DELETE.java b/retrofit/src/main/java/retrofit/http/DELETE.java
index ca0314bcf..02273e6d0 100644
--- a/retrofit/src/main/java/retrofit/http/DELETE.java
+++ b/retrofit/src/main/java/retrofit/http/DELETE.java
@@ -1,3 +1,18 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package retrofit.http;
 
 import java.lang.annotation.Retention;
diff --git a/retrofit/src/main/java/retrofit/http/Field.java b/retrofit/src/main/java/retrofit/http/Field.java
new file mode 100644
index 000000000..4e9bdb126
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/http/Field.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.http;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.PARAMETER;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Named pair for a form-encoded request.
+ *
+ * <pre>
+ * &#64;FormUrlEncoded
+ * &#64;POST("/")
+ * void example(@Field("name") String name, @Field("occupation") String occupation, ..);
+ * }
+ * </pre>
+ */
+@Target(PARAMETER) @Retention(RUNTIME)
+public @interface Field {
+  String value();
+}
diff --git a/retrofit/src/main/java/retrofit/http/FormUrlEncoded.java b/retrofit/src/main/java/retrofit/http/FormUrlEncoded.java
new file mode 100644
index 000000000..83943dca7
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/http/FormUrlEncoded.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.http;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Denotes that the request body will use form URL encoding. Fields should be declared as
+ * parameters and annotated with {@link Field @Field}.
+ * <p>
+ * Requests made with this annotation will have {@code application/x-www-form-urlencoded} MIME
+ * type. Field names and values will be UTF-8 encoded before being URI-encoded in accordance to
+ * <a href="http://tools.ietf.org/html/rfc3986">RFC-3986</a>.
+ */
+@Target(METHOD) @Retention(RUNTIME)
+public @interface FormUrlEncoded {
+}
diff --git a/retrofit/src/main/java/retrofit/http/GET.java b/retrofit/src/main/java/retrofit/http/GET.java
index 6cb78064e..5cd11b5f2 100644
--- a/retrofit/src/main/java/retrofit/http/GET.java
+++ b/retrofit/src/main/java/retrofit/http/GET.java
@@ -1,3 +1,18 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package retrofit.http;
 
 import java.lang.annotation.Retention;
diff --git a/retrofit/src/main/java/retrofit/http/GsonConverter.java b/retrofit/src/main/java/retrofit/http/GsonConverter.java
index a2372291b..a8cb84992 100644
--- a/retrofit/src/main/java/retrofit/http/GsonConverter.java
+++ b/retrofit/src/main/java/retrofit/http/GsonConverter.java
@@ -1,4 +1,18 @@
-// Copyright 2012 Square, Inc.
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package retrofit.http;
 
 import com.google.gson.Gson;
@@ -58,6 +72,10 @@ public GsonConverter(Gson gson) {
       this.jsonBytes = jsonBytes;
     }
 
+    @Override public String fileName() {
+      return null;
+    }
+
     @Override public String mimeType() {
       return "application/json; charset=UTF-8";
     }
diff --git a/retrofit/src/main/java/retrofit/http/HEAD.java b/retrofit/src/main/java/retrofit/http/HEAD.java
index 103477016..14db77338 100644
--- a/retrofit/src/main/java/retrofit/http/HEAD.java
+++ b/retrofit/src/main/java/retrofit/http/HEAD.java
@@ -1,4 +1,18 @@
-// Copyright 2013 Square, Inc.
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package retrofit.http;
 
 import java.lang.annotation.Retention;
diff --git a/retrofit/src/main/java/retrofit/http/Header.java b/retrofit/src/main/java/retrofit/http/Header.java
index 6d8ca9d02..05979fd5f 100644
--- a/retrofit/src/main/java/retrofit/http/Header.java
+++ b/retrofit/src/main/java/retrofit/http/Header.java
@@ -1,43 +1,41 @@
-// Copyright 2012 Square, Inc.
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package retrofit.http;
 
-/** Represents an HTTP header name/value pair. */
-public final class Header {
-  private final String name;
-  private final String value;
-
-  public Header(String name, String value) {
-    this.name = name;
-    this.value = value;
-  }
-
-  public String getName() {
-    return name;
-  }
-
-  public String getValue() {
-    return value;
-  }
-
-  @Override public boolean equals(Object o) {
-    if (this == o) return true;
-    if (o == null || getClass() != o.getClass()) return false;
-
-    Header header = (Header) o;
-
-    if (name != null ? !name.equals(header.name) : header.name != null) return false;
-    if (value != null ? !value.equals(header.value) : header.value != null) return false;
-
-    return true;
-  }
-
-  @Override public int hashCode() {
-    int result = name != null ? name.hashCode() : 0;
-    result = 31 * result + (value != null ? value.hashCode() : 0);
-    return result;
-  }
-
-  @Override public String toString() {
-    return (name != null ? name : "") + ": " + (value != null ? value : "");
-  }
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.PARAMETER;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Replaces the header with the the value of its target. If the target is null,
+ * the header is removed.
+ * <p>
+ * <pre>
+ * &#64;GET("/")
+ * void foo(@Header("Accept-Language") String lang, Callback&lt;Response> cb);
+ * </pre>
+ * <p>
+ * <strong>Note:</strong> Headers do not overwrite each other. All headers with the same name will
+ * be included in the request.
+ *
+ * @author Adrian Cole (adrianc@netflix.com)
+ */
+@Retention(RUNTIME) @Target(PARAMETER)
+public @interface Header {
+  String value();
 }
diff --git a/retrofit/src/main/java/retrofit/http/Headers.java b/retrofit/src/main/java/retrofit/http/Headers.java
index 2220d588c..580834c6f 100644
--- a/retrofit/src/main/java/retrofit/http/Headers.java
+++ b/retrofit/src/main/java/retrofit/http/Headers.java
@@ -1,21 +1,48 @@
-// Copyright 2013 Square, Inc.
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package retrofit.http;
 
-import java.util.Collections;
-import java.util.List;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
 
-/** Manages headers for each request. */
-public interface Headers {
-  /**
-   * Get a list of headers for a request. This method will be called once for each request allowing
-   * you to change the list as the state of your application changes.
-   */
-  List<Header> get();
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
-  /** Empty header list. */
-  Headers NONE = new Headers() {
-    @Override public List<Header> get() {
-      return Collections.emptyList();
-    }
-  };
+/**
+ * Adds headers literally supplied in the {@code value}.
+ * <p>
+ * <pre>
+ * &#64;Headers("Cache-Control: max-age=640000")
+ * &#64;GET("/")
+ * ...
+ *
+ * &#64;Headers({
+ *   "X-Foo: Bar",
+ *   "X-Ping: Pong"
+ * })
+ * &#64;GET("/")
+ * ...
+ * </pre>
+ * <p>
+ * <strong>Note:</strong> Headers do not overwrite each other. All headers with the same name will
+ * be included in the request.
+ *
+ * @author Adrian Cole (adrianc@netflix.com)
+ */
+@Target(METHOD) @Retention(RUNTIME)
+public @interface Headers {
+  String[] value();
 }
diff --git a/retrofit/src/main/java/retrofit/http/Multipart.java b/retrofit/src/main/java/retrofit/http/Multipart.java
index 513f6554f..8e0f2aeeb 100644
--- a/retrofit/src/main/java/retrofit/http/Multipart.java
+++ b/retrofit/src/main/java/retrofit/http/Multipart.java
@@ -1,4 +1,18 @@
-// Copyright 2013 Square, Inc.
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package retrofit.http;
 
 import java.lang.annotation.Retention;
@@ -7,6 +21,10 @@
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
+/**
+ * Denotes that the request body is multi-part. Parts should be declared as parameters and
+ * annotated with {@link Part @Part}.
+ */
 @Target(METHOD) @Retention(RUNTIME)
 public @interface Multipart {
 }
diff --git a/retrofit/src/main/java/retrofit/http/MultipartTypedOutput.java b/retrofit/src/main/java/retrofit/http/MultipartTypedOutput.java
deleted file mode 100644
index f85e0ea0c..000000000
--- a/retrofit/src/main/java/retrofit/http/MultipartTypedOutput.java
+++ /dev/null
@@ -1,83 +0,0 @@
-// Copyright 2013 Square, Inc.
-package retrofit.http;
-
-import java.io.IOException;
-import java.io.OutputStream;
-import java.util.LinkedHashMap;
-import java.util.Map;
-import java.util.UUID;
-import retrofit.http.mime.TypedFile;
-import retrofit.http.mime.TypedOutput;
-
-final class MultipartTypedOutput implements TypedOutput {
-  final Map<String, TypedOutput> parts = new LinkedHashMap<String, TypedOutput>();
-  private final String boundary;
-
-  MultipartTypedOutput() {
-    boundary = UUID.randomUUID().toString();
-  }
-
-  void addPart(String name, TypedOutput body) {
-    if (name == null) {
-      throw new NullPointerException("Part name must not be null.");
-    }
-    if (body == null) {
-      throw new NullPointerException("Part body must not be null.");
-    }
-    parts.put(name, body);
-  }
-
-  @Override public String mimeType() {
-    return "multipart/form-data; boundary=" + boundary;
-  }
-
-  @Override public long length() {
-    return -1;
-  }
-
-  @Override public void writeTo(OutputStream out) throws IOException {
-    boolean first = true;
-    for (Map.Entry<String, TypedOutput> part : parts.entrySet()) {
-      writeBoundary(out, boundary, first, false);
-      writePart(out, part);
-      first = false;
-    }
-    writeBoundary(out, boundary, false, true);
-  }
-
-  private static void writeBoundary(OutputStream out, String boundary, boolean first, boolean last)
-      throws IOException {
-    StringBuilder sb = new StringBuilder();
-    if (!first) {
-      sb.append("\r\n");
-    }
-    sb.append("--");
-    sb.append(boundary);
-    if (last) {
-      sb.append("--");
-    } else {
-      sb.append("\r\n");
-    }
-    out.write(sb.toString().getBytes("UTF-8"));
-  }
-
-  private static void writePart(OutputStream out, Map.Entry<String, TypedOutput> part)
-      throws IOException {
-    String name = part.getKey();
-    TypedOutput value = part.getValue();
-
-    StringBuilder headers = new StringBuilder();
-    headers.append("Content-Disposition: form-data; name=\"");
-    headers.append(name);
-    if (value instanceof TypedFile) {
-      headers.append("\"; filename=\"");
-      headers.append(((TypedFile) value).file().getName());
-    }
-    headers.append("\"\r\nContent-Type: ");
-    headers.append(value.mimeType());
-    headers.append("\r\nContent-Transfer-Encoding: binary\r\n\r\n");
-    out.write(headers.toString().getBytes("UTF-8"));
-
-    value.writeTo(out);
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/http/Name.java b/retrofit/src/main/java/retrofit/http/Name.java
deleted file mode 100644
index b872502cd..000000000
--- a/retrofit/src/main/java/retrofit/http/Name.java
+++ /dev/null
@@ -1,13 +0,0 @@
-// Copyright 2013 Square, Inc.
-package retrofit.http;
-
-import java.lang.annotation.Retention;
-import java.lang.annotation.Target;
-
-import static java.lang.annotation.ElementType.PARAMETER;
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
-@Retention(RUNTIME) @Target(PARAMETER)
-public @interface Name {
-  String value();
-}
diff --git a/retrofit/src/main/java/retrofit/http/POST.java b/retrofit/src/main/java/retrofit/http/POST.java
index 3fc31d5ee..37b971c54 100644
--- a/retrofit/src/main/java/retrofit/http/POST.java
+++ b/retrofit/src/main/java/retrofit/http/POST.java
@@ -1,3 +1,18 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package retrofit.http;
 
 import java.lang.annotation.Retention;
diff --git a/retrofit/src/main/java/retrofit/http/PUT.java b/retrofit/src/main/java/retrofit/http/PUT.java
index f0e59b264..982df96d5 100644
--- a/retrofit/src/main/java/retrofit/http/PUT.java
+++ b/retrofit/src/main/java/retrofit/http/PUT.java
@@ -1,3 +1,18 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package retrofit.http;
 
 import java.lang.annotation.Retention;
diff --git a/retrofit/src/main/java/retrofit/http/Parameter.java b/retrofit/src/main/java/retrofit/http/Parameter.java
index 7812e7591..daf402a07 100644
--- a/retrofit/src/main/java/retrofit/http/Parameter.java
+++ b/retrofit/src/main/java/retrofit/http/Parameter.java
@@ -1,4 +1,18 @@
-// Copyright 2013 Square, Inc.
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package retrofit.http;
 
 import java.lang.reflect.Type;
diff --git a/retrofit/src/main/java/retrofit/http/Part.java b/retrofit/src/main/java/retrofit/http/Part.java
new file mode 100644
index 000000000..33731a1f3
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/http/Part.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.http;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.PARAMETER;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Denotes a single part of a mutli-part request.
+ * <p>
+ * The parameter type on which this annotation exists will be processed in one of two ways:
+ * <ul>
+ * <li>If the type implements {@link retrofit.http.mime.TypedOutput TypedOutput} the headers and
+ * body will be used directly.</li>
+ * <li>Other object types will be converted to an appropriate representation by calling {@link
+ * Converter#toBody(Object)}.</li>
+ * </ul>
+ * <p>
+ * <pre>
+ * &#64;Multipart
+ * &#64;POST("/")
+ * void example(&#64;Part("description") TypedString description,
+ *              &#64;Part("image") TypedFile image,
+ *              ...
+ * );
+ * </pre>
+ */
+@Target(PARAMETER) @Retention(RUNTIME)
+public @interface Part {
+  String value();
+}
diff --git a/retrofit/src/main/java/retrofit/http/Path.java b/retrofit/src/main/java/retrofit/http/Path.java
new file mode 100644
index 000000000..479279e88
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/http/Path.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.http;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.PARAMETER;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Named replacement in the URL path. Values are converted to string using
+ * {@link String#valueOf(Object)}.
+ * <p>
+ * <pre>
+ * &#64;GET("/image/{id}")
+ * void example(@Path("id") int id, ..);
+ * </pre>
+ */
+@Retention(RUNTIME) @Target(PARAMETER)
+public @interface Path {
+  String value();
+}
diff --git a/retrofit/src/main/java/retrofit/http/Platform.java b/retrofit/src/main/java/retrofit/http/Platform.java
index da9bfc7fe..52af0b98c 100644
--- a/retrofit/src/main/java/retrofit/http/Platform.java
+++ b/retrofit/src/main/java/retrofit/http/Platform.java
@@ -1,3 +1,18 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package retrofit.http;
 
 import android.os.Build;
@@ -7,15 +22,15 @@
 import java.util.concurrent.Executor;
 import java.util.concurrent.Executors;
 import java.util.concurrent.ThreadFactory;
-import java.util.concurrent.atomic.AtomicInteger;
 import retrofit.http.android.AndroidApacheClient;
 import retrofit.http.android.MainThreadExecutor;
 import retrofit.http.client.Client;
+import retrofit.http.client.OkClient;
 import retrofit.http.client.UrlConnectionClient;
 
 import static android.os.Process.THREAD_PRIORITY_BACKGROUND;
 import static java.lang.Thread.MIN_PRIORITY;
-import static retrofit.http.RestAdapter.THREAD_PREFIX;
+import static retrofit.http.RestAdapter.IDLE_THREAD_NAME;
 import static retrofit.http.Utils.SynchronousExecutor;
 
 abstract class Platform {
@@ -37,6 +52,7 @@ private static Platform findPlatform() {
   Converter defaultConverter() {
     return new GsonConverter(new Gson());
   }
+
   abstract Client.Provider defaultClient();
   abstract Executor defaultHttpExecutor();
   abstract Executor defaultCallbackExecutor();
@@ -45,7 +61,12 @@ Converter defaultConverter() {
   /** Provides sane defaults for operation on the JVM. */
   private static class Base extends Platform {
     @Override Client.Provider defaultClient() {
-      final Client client = new UrlConnectionClient();
+      final Client client;
+      if (hasOkHttpOnClasspath()) {
+        client = OkClientInstantiator.instantiate();
+      } else {
+        client = new UrlConnectionClient();
+      }
       return new Client.Provider() {
         @Override public Client get() {
           return client;
@@ -55,15 +76,13 @@ Converter defaultConverter() {
 
     @Override Executor defaultHttpExecutor() {
       return Executors.newCachedThreadPool(new ThreadFactory() {
-        private final AtomicInteger threadCounter = new AtomicInteger();
-
         @Override public Thread newThread(final Runnable r) {
           return new Thread(new Runnable() {
             @Override public void run() {
               Thread.currentThread().setPriority(MIN_PRIORITY);
               r.run();
             }
-          }, THREAD_PREFIX + threadCounter.getAndIncrement());
+          }, IDLE_THREAD_NAME);
         }
       });
     }
@@ -85,7 +104,9 @@ Converter defaultConverter() {
   private static class Android extends Platform {
     @Override Client.Provider defaultClient() {
       final Client client;
-      if (Build.VERSION.SDK_INT < Build.VERSION_CODES.GINGERBREAD) {
+      if (hasOkHttpOnClasspath()) {
+        client = OkClientInstantiator.instantiate();
+      } else if (Build.VERSION.SDK_INT < Build.VERSION_CODES.GINGERBREAD) {
         client = new AndroidApacheClient();
       } else {
         client = new UrlConnectionClient();
@@ -99,15 +120,13 @@ Converter defaultConverter() {
 
     @Override Executor defaultHttpExecutor() {
       return Executors.newCachedThreadPool(new ThreadFactory() {
-        private final AtomicInteger threadCounter = new AtomicInteger();
-
         @Override public Thread newThread(final Runnable r) {
           return new Thread(new Runnable() {
             @Override public void run() {
               Process.setThreadPriority(THREAD_PRIORITY_BACKGROUND);
               r.run();
             }
-          }, THREAD_PREFIX + threadCounter.getAndIncrement());
+          }, IDLE_THREAD_NAME);
         }
       });
     }
@@ -124,4 +143,24 @@ Converter defaultConverter() {
       };
     }
   }
+
+  /** Determine whether or not OkHttp is present on the runtime classpath. */
+  private static boolean hasOkHttpOnClasspath() {
+    try {
+      Class.forName("com.squareup.okhttp.OkHttpClient");
+      return true;
+    } catch (ClassNotFoundException e) {
+      return false;
+    }
+  }
+
+  /**
+   * Indirection for OkHttp class to prevent VerifyErrors on Android 2.0 and earlier when the
+   * dependency is not present..
+   */
+  private static class OkClientInstantiator {
+    static Client instantiate() {
+      return new OkClient();
+    }
+  }
 }
diff --git a/retrofit/src/main/java/retrofit/http/Profiler.java b/retrofit/src/main/java/retrofit/http/Profiler.java
index f1737906c..f8213c948 100644
--- a/retrofit/src/main/java/retrofit/http/Profiler.java
+++ b/retrofit/src/main/java/retrofit/http/Profiler.java
@@ -1,4 +1,18 @@
-// Copyright 2012 Square, Inc.
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package retrofit.http;
 
 /**
diff --git a/retrofit/src/main/java/retrofit/http/Query.java b/retrofit/src/main/java/retrofit/http/Query.java
new file mode 100644
index 000000000..3ae1a3918
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/http/Query.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.http;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.PARAMETER;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Query parameter appended to the URL. Values are converted to strings using
+ * {@link String#valueOf(Object)}.
+ * <p>
+ * <pre>
+ * &#64;GET("/list")
+ * void example(@Query("page") int page, ..);
+ * </pre>
+ */
+@Target(PARAMETER) @Retention(RUNTIME)
+public @interface Query {
+  String value();
+}
diff --git a/retrofit/src/main/java/retrofit/http/QueryParam.java b/retrofit/src/main/java/retrofit/http/QueryParam.java
deleted file mode 100644
index fced456ae..000000000
--- a/retrofit/src/main/java/retrofit/http/QueryParam.java
+++ /dev/null
@@ -1,18 +0,0 @@
-package retrofit.http;
-
-import java.lang.annotation.Retention;
-import java.lang.annotation.Target;
-
-import static java.lang.annotation.ElementType.METHOD;
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
-/**
- * Specifies a query parameter.
- *
- * @author Patrick Forhan (patrick@squareup.com)
- */
-@Target(METHOD) @Retention(RUNTIME)
-public @interface QueryParam {
-  String name();
-  String value();
-}
diff --git a/retrofit/src/main/java/retrofit/http/QueryParams.java b/retrofit/src/main/java/retrofit/http/QueryParams.java
deleted file mode 100644
index b0467c214..000000000
--- a/retrofit/src/main/java/retrofit/http/QueryParams.java
+++ /dev/null
@@ -1,17 +0,0 @@
-package retrofit.http;
-
-import java.lang.annotation.Retention;
-import java.lang.annotation.Target;
-
-import static java.lang.annotation.ElementType.METHOD;
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
-/**
- * Specifies a query parameter.
- *
- * @author Patrick Forhan (patrick@squareup.com)
- */
-@Target(METHOD) @Retention(RUNTIME)
-public @interface QueryParams {
-  QueryParam[] value();
-}
diff --git a/retrofit/src/main/java/retrofit/http/RequestBuilder.java b/retrofit/src/main/java/retrofit/http/RequestBuilder.java
index a7b849569..7e6dd73fd 100644
--- a/retrofit/src/main/java/retrofit/http/RequestBuilder.java
+++ b/retrofit/src/main/java/retrofit/http/RequestBuilder.java
@@ -1,163 +1,190 @@
-// Copyright 2012 Square, Inc.
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package retrofit.http;
 
 import java.io.UnsupportedEncodingException;
 import java.net.URLEncoder;
 import java.util.ArrayList;
-import java.util.LinkedHashSet;
 import java.util.List;
-import java.util.Set;
+import retrofit.http.client.Header;
 import retrofit.http.client.Request;
+import retrofit.http.mime.FormUrlEncodedTypedOutput;
+import retrofit.http.mime.MultipartTypedOutput;
 import retrofit.http.mime.TypedOutput;
-import retrofit.http.mime.TypedString;
-
-import static retrofit.http.RestMethodInfo.NO_SINGLE_ENTITY;
-
-/**
- * Builds HTTP requests from Java method invocations.  Handles "path parameters" in the
- * {@code apiUrl} in the form of "path/to/url/{id}/action" where a parameter annotated with
- * {@code @Name("id")} is inserted into the url.  Note that this replacement can be recursive if:
- * <ol>
- * <li>Multiple sets of brackets are nested ("path/to/{{key}a}.</li>
- * <li>The order of {@link Name @Name} values go from innermost to outermost.</li>
- * <li>The values replaced correspond to {@link Name @Name} parameters.</li>
- * </ol>
- */
+
+import static retrofit.http.RestMethodInfo.NO_BODY;
+
+/** Builds HTTP requests from Java method invocations. */
 final class RequestBuilder {
   private final Converter converter;
 
   private RestMethodInfo methodInfo;
   private Object[] args;
   private String apiUrl;
-  private List<Header> headers;
+  private List<retrofit.http.client.Header> headers;
 
   RequestBuilder(Converter converter) {
     this.converter = converter;
   }
 
-  RequestBuilder setMethodInfo(RestMethodInfo methodDetails) {
+  /** Supply cached method metadata info. */
+  RequestBuilder methodInfo(RestMethodInfo methodDetails) {
     this.methodInfo = methodDetails;
     return this;
   }
 
-  RequestBuilder setApiUrl(String apiUrl) {
+  /** Base API url. */
+  RequestBuilder apiUrl(String apiUrl) {
     this.apiUrl = apiUrl;
     return this;
   }
 
-  RequestBuilder setArgs(Object[] args) {
+  /** Arguments from method invocation. */
+  RequestBuilder args(Object[] args) {
     this.args = args;
     return this;
   }
 
-  RequestBuilder setHeaders(List<Header> headers) {
+  /** A list of custom headers. */
+  RequestBuilder headers(List<retrofit.http.client.Header> headers) {
     this.headers = headers;
     return this;
   }
 
-  /** List of all URL parameters. Return value will be mutated. */
-  private List<Parameter> createParamList() {
-    List<Parameter> params = new ArrayList<Parameter>();
-
-    // Add arguments as parameters.
-    String[] pathNamedParams = methodInfo.namedParams;
-    int singleEntityArgumentIndex = methodInfo.singleEntityArgumentIndex;
-    for (int i = 0; i < pathNamedParams.length; i++) {
-      Object arg = args[i];
-      if (arg == null) continue;
-      if (i != singleEntityArgumentIndex) {
-        params.add(new Parameter(pathNamedParams[i], arg, arg.getClass()));
-      }
+  /**
+   * Construct a {@link Request} from the supplied information. You <strong>must</strong> call
+   * {@link #methodInfo}, {@link #apiUrl}, {@link #args}, and {@link #headers} before invoking this
+   * method.
+   */
+  Request build() throws UnsupportedEncodingException {
+    String apiUrl = this.apiUrl;
+
+    StringBuilder url = new StringBuilder(apiUrl);
+    if (apiUrl.endsWith("/")) {
+      // We require relative paths to start with '/'. Prevent a double-slash.
+      url.deleteCharAt(url.length() - 1);
     }
 
-    return params;
-  }
+    // Append the method relative URL.
+    url.append(buildRelativeUrl());
 
-  Request build() {
-    // Alter parameter list if path parameters are present.
-    Set<String> pathParams = new LinkedHashSet<String>(methodInfo.pathParams);
-    List<Parameter> paramList = createParamList();
-    String replacedPath = methodInfo.path;
-    for (String pathParam : pathParams) {
-      Parameter found = null;
-      for (Parameter param : paramList) {
-        if (param.getName().equals(pathParam)) {
-          found = param;
-          break;
-        }
+    // Append query parameters, if needed.
+    if (methodInfo.hasQueryParams) {
+      boolean first = true;
+      String requestQuery = methodInfo.requestQuery;
+      if (requestQuery != null) {
+        url.append(requestQuery);
+        first = false;
       }
-      if (found != null) {
-        String value = getUrlEncodedValue(found);
-        replacedPath = replacedPath.replace("{" + found.getName() + "}", value);
-        paramList.remove(found);
-      } else {
-        throw new IllegalArgumentException(
-            "URL param " + pathParam + " has no matching method @Name param.");
+      String[] requestQueryName = methodInfo.requestQueryName;
+      for (int i = 0; i < requestQueryName.length; i++) {
+        String query = requestQueryName[i];
+        if (query != null) {
+          String value = URLEncoder.encode(String.valueOf(args[i]), "UTF-8");
+          url.append(first ? '?' : '&').append(query).append('=').append(value);
+          first = false;
+        }
       }
     }
 
-    if (methodInfo.singleEntityArgumentIndex != NO_SINGLE_ENTITY) {
-      // We're passing a JSON object as the entity: paramList should only contain path param values.
-      if (!paramList.isEmpty()) {
-        throw new IllegalStateException(
-            "Found @Name param on single-entity request that was not used for path substitution.");
+    List<retrofit.http.client.Header> headers = new ArrayList<retrofit.http.client.Header>();
+    if (this.headers != null) {
+      headers.addAll(this.headers);
+    }
+    List<Header> methodHeaders = methodInfo.headers;
+    if (methodHeaders != null) {
+      headers.addAll(methodHeaders);
+    }
+    // RFC 2616: Header names are case-insensitive.
+    String[] requestParamHeader = methodInfo.requestParamHeader;
+    if (requestParamHeader != null) {
+      for (int i = 0; i < requestParamHeader.length; i++) {
+        String name = requestParamHeader[i];
+        if (name == null) continue;
+        Object arg = args[i];
+        if (arg != null) {
+          headers.add(new retrofit.http.client.Header(name, String.valueOf(arg)));
+        }
       }
     }
 
-    StringBuilder url = new StringBuilder(apiUrl);
-    if (apiUrl.endsWith("/")) {
-      // We enforce relative paths to start with '/'. Prevent a double-slash.
-      url.deleteCharAt(url.length() - 1);
-    }
-    url.append(replacedPath);
+    return new Request(methodInfo.requestMethod, url.toString(), headers, buildBody());
+  }
 
-    // Add query parameter(s), if specified.
-    for (QueryParam annotation : methodInfo.pathQueryParams) {
-      paramList.add(new Parameter(annotation.name(), annotation.value(), String.class));
+  /** Create the final relative URL by performing parameter replacement. */
+  private String buildRelativeUrl() throws UnsupportedEncodingException {
+    String replacedPath = methodInfo.requestUrl;
+    String[] requestUrlParam = methodInfo.requestUrlParam;
+    for (int i = 0; i < requestUrlParam.length; i++) {
+      String param = requestUrlParam[i];
+      if (param != null) {
+        String value = URLEncoder.encode(String.valueOf(args[i]), "UTF-8");
+        replacedPath = replacedPath.replace("{" + param + "}", value);
+      }
     }
+    return replacedPath;
+  }
 
-    TypedOutput body = null;
-    if (!methodInfo.restMethod.hasBody()) {
-      for (int i = 0, count = paramList.size(); i < count; i++) {
-        url.append((i == 0) ? '?' : '&');
-        Parameter nonPathParam = paramList.get(i);
-        String value = getUrlEncodedValue(nonPathParam);
-        url.append(nonPathParam.getName()).append("=").append(value);
+  /** Create the request body using the method info and invocation arguments. */
+  private TypedOutput buildBody() {
+    switch (methodInfo.requestType) {
+      case SIMPLE: {
+        int bodyIndex = methodInfo.bodyIndex;
+        if (bodyIndex == NO_BODY) {
+          return null;
+        }
+        Object body = args[bodyIndex];
+        if (body instanceof TypedOutput) {
+          return (TypedOutput) body;
+        } else {
+          return converter.toBody(body);
+        }
       }
-    } else if (!paramList.isEmpty()) {
-      if (methodInfo.isMultipart) {
-        MultipartTypedOutput multipartBody = new MultipartTypedOutput();
-        for (Parameter parameter : paramList) {
-          Object value = parameter.getValue();
-          TypedOutput typedOutput;
-          if (value instanceof TypedOutput) {
-            typedOutput = (TypedOutput) value;
-          } else {
-            typedOutput = new TypedString(value.toString());
+
+      case FORM_URL_ENCODED: {
+        FormUrlEncodedTypedOutput body = new FormUrlEncodedTypedOutput();
+        String[] requestFormPair = methodInfo.requestFormPair;
+        for (int i = 0; i < requestFormPair.length; i++) {
+          String name = requestFormPair[i];
+          if (name != null) {
+            body.addPair(name, String.valueOf(args[i]));
           }
-          multipartBody.addPart(parameter.getName(), typedOutput);
         }
-        body = multipartBody;
-      } else {
-        body = converter.toBody(paramList);
-      }
-    } else if (methodInfo.singleEntityArgumentIndex != NO_SINGLE_ENTITY) {
-      Object singleEntity = args[methodInfo.singleEntityArgumentIndex];
-      if (singleEntity instanceof TypedOutput) {
-        body = (TypedOutput) singleEntity;
-      } else {
-        body = converter.toBody(singleEntity);
+        return body;
       }
-    }
 
-    return new Request(methodInfo.restMethod.value(), url.toString(), headers, body);
-  }
+      case MULTIPART: {
+        MultipartTypedOutput body = new MultipartTypedOutput();
+        String[] requestMultipartPart = methodInfo.requestMultipartPart;
+        for (int i = 0; i < requestMultipartPart.length; i++) {
+          String name = requestMultipartPart[i];
+          if (name != null) {
+            Object value = args[i];
+            if (value instanceof TypedOutput) {
+              body.addPart(name, (TypedOutput) value);
+            } else {
+              body.addPart(name, converter.toBody(value));
+            }
+          }
+        }
+        return body;
+      }
 
-  private static String getUrlEncodedValue(Parameter found) {
-    try {
-      return URLEncoder.encode(String.valueOf(found.getValue()), "UTF-8");
-    } catch (UnsupportedEncodingException e) {
-      throw new AssertionError(e);
+      default:
+        throw new IllegalArgumentException("Unknown request type " + methodInfo.requestType);
     }
   }
-}
\ No newline at end of file
+}
diff --git a/retrofit/src/main/java/retrofit/http/RequestHeaders.java b/retrofit/src/main/java/retrofit/http/RequestHeaders.java
new file mode 100644
index 000000000..b8b26a1f6
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/http/RequestHeaders.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.http;
+
+import java.util.Collections;
+import java.util.List;
+import retrofit.http.client.Header;
+
+/** Manages headers for each request. */
+public interface RequestHeaders {
+  /**
+   * Get a list of headers for a request. This method will be called once for each request allowing
+   * you to change the list as the state of your application changes.
+   */
+  List<retrofit.http.client.Header> get();
+
+  /** Empty header list. */
+  RequestHeaders NONE = new RequestHeaders() {
+    @Override public List<Header> get() {
+      return Collections.emptyList();
+    }
+  };
+}
diff --git a/retrofit/src/main/java/retrofit/http/ResponseWrapper.java b/retrofit/src/main/java/retrofit/http/ResponseWrapper.java
index 4be0b7822..8fe9d7ffe 100644
--- a/retrofit/src/main/java/retrofit/http/ResponseWrapper.java
+++ b/retrofit/src/main/java/retrofit/http/ResponseWrapper.java
@@ -1,3 +1,18 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package retrofit.http;
 
 import retrofit.http.client.Response;
diff --git a/retrofit/src/main/java/retrofit/http/RestAdapter.java b/retrofit/src/main/java/retrofit/http/RestAdapter.java
index e77f41219..9a1fbb4dd 100644
--- a/retrofit/src/main/java/retrofit/http/RestAdapter.java
+++ b/retrofit/src/main/java/retrofit/http/RestAdapter.java
@@ -1,4 +1,18 @@
-// Copyright 2012 Square, Inc.
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package retrofit.http;
 
 import java.io.ByteArrayOutputStream;
@@ -14,6 +28,7 @@
 import java.util.concurrent.TimeUnit;
 import retrofit.http.Profiler.RequestInformation;
 import retrofit.http.client.Client;
+import retrofit.http.client.Header;
 import retrofit.http.client.Request;
 import retrofit.http.client.Response;
 import retrofit.http.mime.TypedByteArray;
@@ -23,7 +38,61 @@
 import static retrofit.http.Utils.SynchronousExecutor;
 
 /**
- * Converts Java method calls to Rest calls.
+ * Adapts a Java interface to a REST API.
+ * <p>
+ * API endpoints are defined as methods on an interface with annotations providing metadata about
+ * the form in which the HTTP call should be made.
+ * <p>
+ * The relative path for a given method is obtained from an annotation on the method describing
+ * the request type. The built-in methods are {@link GET}, {@link PUT}, {@link POST}, {@link HEAD},
+ * and {@link DELETE}. You can define your own HTTP method by creating an annotation that takes a
+ * {code String} value and itself is annotated with {@link RestMethod @RestMethod}.
+ * <p>
+ * Method parameters can be used to replace parts of the URL by annotating them with
+ * {@link Path @Path}. Replacement sections are denoted by an identifier surrounded by curly braces
+ * (e.g., "{foo}"). To add items to the query string of a URL use {@link Query @Query}.
+ * <p>
+ * HTTP requests happen in one of two ways:
+ * <ul>
+ * <li>On the provided HTTP {@link Executor} with callbacks marshaled to the callback
+ * {@link Executor}. The last method parameter should be of type {@link Callback}. The HTTP
+ * response will be converted to the callback's parameter type using the specified
+ * {@link Converter}. If the callback parameter type uses a wildcard, the lower bound will be
+ * used as the conversion type.
+ * <li>On the current thread returning the response or throwing a {@link RetrofitError}. The HTTP
+ * response will be converted to the method's return type using the specified {@link Converter}.
+ * </ul>
+ * <p>
+ * The body of a request is denoted by the {@link Body @Body} annotation. The object will be
+ * converted to request representation by a call to {@link Converter#toBody(Object) toBody} on the
+ * supplied {@link Converter} for this instance. The body can also be a {@link TypedOutput} where
+ * it will be used directly.
+ * <p>
+ * Alternative request body formats are supported by method annotations and corresponding parameter
+ * annotations:
+ * <ul>
+ * <li>{@link FormUrlEncoded @FormUrlEncoded} - Form-encoded data with pairs specified by the
+ * {@link Field @Field} parameter annotation.
+ * <li>{@link Multipart @Multipart} - RFC 2387-compliant multi-part data with parts specified by
+ * the {@link Part @Part} parameter annotation.
+ * </ul>
+ * <p>
+ * Additional static headers can be added for an endpoint using the {@link Headers @Headers} method
+ * annotation. For per-request control over a header annotate a parameter with
+ * {@link Header @Header}.
+ * <p>
+ * For example:
+ * <pre>
+ * public interface MyApi {
+ *   &#64;POST("/category/{cat}") // Asynchronous execution.
+ *   void categoryList(@Path("cat") String a, @Query("page") int b, Callback&lt;List&lt;Item>> cb);
+ *   &#64;POST("/category/{cat}") // Synchronous execution.
+ *   List&lt;Item> categoryList(@Path("cat") String a, @Query("page") int b);
+ * }
+ * </pre>
+ * <p>
+ * Calling {@link #create(Class)} with {@code MyApi.class} will validate and create a new
+ * implementation of the API.
  *
  * @author Bob Lee (bob@squareup.com)
  * @author Jake Wharton (jw@squareup.com)
@@ -31,6 +100,7 @@
 public class RestAdapter {
   private static final int LOG_CHUNK_SIZE = 4000;
   static final String THREAD_PREFIX = "Retrofit-";
+  static final String IDLE_THREAD_NAME = THREAD_PREFIX + "Idle";
 
   /** Simple logging abstraction for debug messages. */
   public interface Log {
@@ -42,20 +112,20 @@
   private final Client.Provider clientProvider;
   private final Executor httpExecutor;
   private final Executor callbackExecutor;
-  private final Headers headers;
+  private final RequestHeaders requestHeaders;
   private final Converter converter;
   private final Profiler profiler;
   private final Log log;
   private volatile boolean debug;
 
   private RestAdapter(Server server, Client.Provider clientProvider, Executor httpExecutor,
-      Executor callbackExecutor, Headers headers, Converter converter, Profiler profiler, Log log,
-      boolean debug) {
+      Executor callbackExecutor, RequestHeaders requestHeaders, Converter converter,
+      Profiler profiler, Log log, boolean debug) {
     this.server = server;
     this.clientProvider = clientProvider;
     this.httpExecutor = httpExecutor;
     this.callbackExecutor = callbackExecutor;
-    this.headers = headers;
+    this.requestHeaders = requestHeaders;
     this.converter = converter;
     this.profiler = profiler;
     this.log = log;
@@ -67,43 +137,13 @@ public void setDebug(boolean debug) {
     this.debug = debug;
   }
 
-  /**
-   * Adapts a Java interface to a REST API.
-   * <p>
-   * The relative path for a given method is obtained from an annotation on the method describing
-   * the request type. The names of URL parameters are retrieved from {@link Name}
-   * annotations on the method parameters.
-   * <p>
-   * HTTP requests happen in one of two ways:
-   * <ul>
-   * <li>On the provided HTTP {@link Executor} with callbacks marshaled to the callback
-   * {@link Executor}. The last method parameter should be of type {@link Callback}. The HTTP
-   * response will be converted to the callback's parameter type using the specified
-   * {@link Converter}. If the callback parameter type uses a wildcard, the lower bound will be
-   * used as the conversion type.</li>
-   * <li>On the current thread returning the response or throwing a {@link RetrofitError}. The HTTP
-   * response will be converted to the method's return type using the specified
-   * {@link Converter}.</li>
-   * </ul>
-   * <p>
-   * For example:
-   * <pre>
-   *   public interface MyApi {
-   *     &#64;POST("go") // Asynchronous execution.
-   *     void go(@Name("a") String a, @Name("b") int b, Callback&lt;? super MyResult> callback);
-   *     &#64;POST("go") // Synchronous execution.
-   *     MyResult go(@Name("a") String a, @Name("b") int b);
-   *   }
-   * </pre>
-   *
-   * @param type to implement
-   */
+  /** Create an implementation of the API defined by the specified {@code service} interface. */
   @SuppressWarnings("unchecked")
-  public <T> T create(Class<T> type) {
-    if (!type.isInterface()) {
+  public <T> T create(Class<T> service) {
+    if (!service.isInterface()) {
       throw new IllegalArgumentException("Only interface endpoint definitions are supported.");
     }
-    return (T) Proxy.newProxyInstance(type.getClassLoader(), new Class<?>[] { type },
+    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service },
         new RestHandler());
   }
 
@@ -159,10 +199,10 @@ private Object invokeRequest(RestMethodInfo methodDetails, Object[] args) {
       String url = serverUrl; // Keep some url in case RequestBuilder throws an exception.
       try {
         Request request = new RequestBuilder(converter) //
-            .setApiUrl(serverUrl)
-            .setArgs(args)
-            .setHeaders(headers.get())
-            .setMethodInfo(methodDetails)
+            .apiUrl(serverUrl) //
+            .args(args) //
+            .headers(requestHeaders.get()) //
+            .methodInfo(methodDetails) //
             .build();
         url = request.getUrl();
 
@@ -194,14 +234,20 @@ private Object invokeRequest(RestMethodInfo methodDetails, Object[] args) {
           response = logAndReplaceResponse(url, response, elapsedTime);
         }
 
-        Type type = methodDetails.type;
+        Type type = methodDetails.responseObjectType;
+
         if (statusCode >= 200 && statusCode < 300) { // 2XX == successful request
+          // Caller requested the raw Response object directly.
           if (type.equals(Response.class)) {
+            // Read the entire stream and replace with one backed by a byte[]
+            response = Utils.readBodyToBytesIfNecessary(response);
+
             if (methodDetails.isSynchronous) {
               return response;
             }
             return new ResponseWrapper(response, response);
           }
+
           TypedInput body = response.getBody();
           if (body == null) {
             return new ResponseWrapper(response, null);
@@ -213,9 +259,14 @@ private Object invokeRequest(RestMethodInfo methodDetails, Object[] args) {
             }
             return new ResponseWrapper(response, convert);
           } catch (ConversionException e) {
+            // The response body was partially read by the converter. Replace it with null.
+            response = Utils.replaceResponseBody(response, null);
+
             throw RetrofitError.conversionError(url, response, converter, type, e);
           }
         }
+
+        response = Utils.readBodyToBytesIfNecessary(response);
         throw RetrofitError.httpError(url, response, converter, type);
       } catch (RetrofitError e) {
         throw e; // Pass through our own errors.
@@ -223,6 +274,10 @@ private Object invokeRequest(RestMethodInfo methodDetails, Object[] args) {
         throw RetrofitError.networkError(url, e);
       } catch (Throwable t) {
         throw RetrofitError.unexpectedError(url, t);
+      } finally {
+        if (!methodDetails.isSynchronous) {
+          Thread.currentThread().setName(IDLE_THREAD_NAME);
+        }
       }
     }
   }
@@ -248,8 +303,8 @@ private Request logAndReplaceRequest(Request request) throws IOException {
       bodySize = bodyBytes.length;
       String bodyMime = body.mimeType();
       String bodyString = new String(bodyBytes, Utils.parseCharset(bodyMime));
-      for (int i = 0; i < bodyString.length(); i += LOG_CHUNK_SIZE) {
-        int end = Math.min(bodyString.length(), i + LOG_CHUNK_SIZE);
+      for (int i = 0, len = bodyString.length(); i < len; i += LOG_CHUNK_SIZE) {
+        int end = Math.min(len, i + LOG_CHUNK_SIZE);
         log.log(bodyString.substring(i, end));
       }
 
@@ -278,23 +333,26 @@ private Response logAndReplaceResponse(String url, Response response, long elaps
         log.log("");
       }
 
-      byte[] bodyBytes = Utils.streamToBytes(body.in());
+      if (!(body instanceof TypedByteArray)) {
+        // Read the entire response body to we can log it and replace the original response
+        response = Utils.readBodyToBytesIfNecessary(response);
+        body = response.getBody();
+      }
+
+      byte[] bodyBytes = ((TypedByteArray) body).getBytes();
       bodySize = bodyBytes.length;
       String bodyMime = body.mimeType();
       String bodyCharset = Utils.parseCharset(bodyMime);
       String bodyString = new String(bodyBytes, bodyCharset);
-      for (int i = 0; i < bodyString.length(); i += LOG_CHUNK_SIZE) {
-        int end = Math.min(bodyString.length(), i + LOG_CHUNK_SIZE);
+      for (int i = 0, len = bodyString.length(); i < len; i += LOG_CHUNK_SIZE) {
+        int end = Math.min(len, i + LOG_CHUNK_SIZE);
         log.log(bodyString.substring(i, end));
       }
-
-      body = new TypedByteArray(bodyMime, bodyBytes);
     }
 
-    log.log(String.format("---> END HTTP (%s-byte body)", bodySize));
+    log.log(String.format("<--- END HTTP (%s-byte body)", bodySize));
 
-    // Since we consumed the original response, return a new, identical one from its bytes.
-    return new Response(response.getStatus(), response.getReason(), response.getHeaders(), body);
+    return response;
   }
 
   private static Profiler.RequestInformation getRequestInfo(String serverUrl,
@@ -308,8 +366,8 @@ private Response logAndReplaceResponse(String url, Response response, long elaps
       contentType = body.mimeType();
     }
 
-    return new Profiler.RequestInformation(methodDetails.restMethod.value(), serverUrl,
-        methodDetails.path, contentLength, contentType);
+    return new Profiler.RequestInformation(methodDetails.requestMethod, serverUrl,
+        methodDetails.requestUrl, contentLength, contentType);
   }
 
   /**
@@ -333,7 +391,7 @@ private Response logAndReplaceResponse(String url, Response response, long elaps
     private Client.Provider clientProvider;
     private Executor httpExecutor;
     private Executor callbackExecutor;
-    private Headers headers;
+    private RequestHeaders requestHeaders;
     private Converter converter;
     private Profiler profiler;
     private Log log;
@@ -381,9 +439,9 @@ public Builder setExecutors(Executor httpExecutor, Executor callbackExecutor) {
       return this;
     }
 
-    public Builder setHeaders(Headers headers) {
-      if (headers == null) throw new NullPointerException("headers");
-      this.headers = headers;
+    public Builder setRequestHeaders(RequestHeaders requestHeaders) {
+      if (requestHeaders == null) throw new NullPointerException("requestHeaders");
+      this.requestHeaders = requestHeaders;
       return this;
     }
 
@@ -415,7 +473,7 @@ public RestAdapter build() {
         throw new IllegalArgumentException("Server may not be null.");
       }
       ensureSaneDefaults();
-      return new RestAdapter(server, clientProvider, httpExecutor, callbackExecutor, headers,
+      return new RestAdapter(server, clientProvider, httpExecutor, callbackExecutor, requestHeaders,
           converter, profiler, log, debug);
     }
 
@@ -435,8 +493,8 @@ private void ensureSaneDefaults() {
       if (log == null) {
         log = Platform.get().defaultLog();
       }
-      if (headers == null) {
-        headers = Headers.NONE;
+      if (requestHeaders == null) {
+        requestHeaders = RequestHeaders.NONE;
       }
     }
   }
diff --git a/retrofit/src/main/java/retrofit/http/RestMethod.java b/retrofit/src/main/java/retrofit/http/RestMethod.java
index bdc9bed8c..363d7604c 100644
--- a/retrofit/src/main/java/retrofit/http/RestMethod.java
+++ b/retrofit/src/main/java/retrofit/http/RestMethod.java
@@ -1,4 +1,18 @@
-// Copyright 2013 Square, Inc.
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package retrofit.http;
 
 import java.lang.annotation.Retention;
diff --git a/retrofit/src/main/java/retrofit/http/RestMethodInfo.java b/retrofit/src/main/java/retrofit/http/RestMethodInfo.java
index e7ac42b56..63bcf350d 100644
--- a/retrofit/src/main/java/retrofit/http/RestMethodInfo.java
+++ b/retrofit/src/main/java/retrofit/http/RestMethodInfo.java
@@ -1,4 +1,18 @@
-// Copyright 2013 Square, Inc.
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package retrofit.http;
 
 import java.lang.annotation.Annotation;
@@ -6,30 +20,53 @@
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import java.lang.reflect.WildcardType;
+import java.util.ArrayList;
 import java.util.LinkedHashSet;
+import java.util.List;
 import java.util.Set;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
-import retrofit.http.mime.TypedOutput;
 
-/** Cached details about an interface method. */
+/** Request metadata about a service interface declaration. */
 final class RestMethodInfo {
-  static final int NO_SINGLE_ENTITY = -1;
-  private static final Pattern PATH_PARAMETERS = Pattern.compile("\\{([a-z_-]+)\\}");
+  static final int NO_BODY = -1;
+
+  // Matches strings containing lowercase characters, digits, underscores, or hyphens that start
+  // with a lowercase character in between '{' and '}'.
+  private static final Pattern URL_PARAMETERS = Pattern.compile("\\{([a-z][a-z0-9_-]*)}");
+
+  enum RequestType {
+    /** No content-specific logic required. */
+    SIMPLE,
+    /** Multi-part request body. */
+    MULTIPART,
+    /** Form URL-encoded request body. */
+    FORM_URL_ENCODED
+  }
 
   final Method method;
-  final boolean isSynchronous;
 
   boolean loaded = false;
 
-  Type type;
-  RestMethod restMethod;
-  String path;
-  Set<String> pathParams;
-  QueryParam[] pathQueryParams;
-  String[] namedParams;
-  int singleEntityArgumentIndex = NO_SINGLE_ENTITY;
-  boolean isMultipart = false;
+  // Method-level details
+  final boolean isSynchronous;
+  Type responseObjectType;
+  RequestType requestType = RequestType.SIMPLE;
+  String requestMethod;
+  boolean requestHasBody;
+  String requestUrl;
+  Set<String> requestUrlParamNames;
+  String requestQuery;
+  List<retrofit.http.client.Header> headers;
+
+  // Parameter-level details
+  String[] requestUrlParam;
+  String[] requestQueryName;
+  boolean hasQueryParams = false;
+  String[] requestFormPair;
+  String[] requestMultipartPart;
+  String[] requestParamHeader;
+  int bodyIndex = NO_BODY;
 
   RestMethodInfo(Method method) {
     this.method = method;
@@ -45,74 +82,136 @@ synchronized void init() {
     loaded = true;
   }
 
-  /**
-   * Loads {@link #restMethod}, {@link #path}, {@link #pathParams}, {@link #pathQueryParams}, and
-   * {@link #isMultipart}.
-   */
+  /** Loads {@link #requestMethod} and {@link #requestType}. */
   private void parseMethodAnnotations() {
     for (Annotation methodAnnotation : method.getAnnotations()) {
       Class<? extends Annotation> annotationType = methodAnnotation.annotationType();
       RestMethod methodInfo = null;
+
+      // Look for a @RestMethod annotation on the parameter annotation indicating request method.
       for (Annotation innerAnnotation : annotationType.getAnnotations()) {
         if (RestMethod.class == innerAnnotation.annotationType()) {
           methodInfo = (RestMethod) innerAnnotation;
           break;
         }
       }
+
       if (methodInfo != null) {
-        if (restMethod != null) {
-          throw new IllegalArgumentException("Method contains multiple HTTP annotations.");
+        if (requestMethod != null) {
+          throw new IllegalArgumentException("Method "
+              + method.getName()
+              + " contains multiple HTTP methods. Found: "
+              + requestMethod
+              + " and "
+              + methodInfo.value());
         }
+        String path;
         try {
           path = (String) annotationType.getMethod("value").invoke(methodAnnotation);
         } catch (Exception e) {
-          throw new RuntimeException("Failed to extract URI path.", e);
+          throw new RuntimeException("Failed to extract path from "
+              + annotationType.getSimpleName()
+              + " annotation on "
+              + method.getName()
+              + ".", e);
         }
-        if (!path.startsWith("/")) {
-          throw new IllegalArgumentException("URL path must be prefixed with '/'.");
+        parsePath(path);
+        requestMethod = methodInfo.value();
+        requestHasBody = methodInfo.hasBody();
+      } else if (annotationType == Headers.class) {
+        String[] headersToParse = ((Headers) methodAnnotation).value();
+        if (headersToParse.length == 0) {
+          throw new IllegalStateException("Headers annotation was empty.");
         }
-        pathParams = parsePathParameters(path);
-        restMethod = methodInfo;
-      } else if (annotationType == QueryParams.class) {
-        if (pathQueryParams != null) {
+        headers = parseHeaders(headersToParse);
+      } else if (annotationType == Multipart.class) {
+        if (requestType != RequestType.SIMPLE) {
           throw new IllegalStateException(
-              "QueryParam and QueryParams annotations are mutually exclusive.");
-        }
-        pathQueryParams = ((QueryParams) methodAnnotation).value();
-        if (pathQueryParams.length == 0) {
-          throw new IllegalStateException("QueryParams annotation was empty.");
+              "Only one encoding annotation per method is allowed: " + method.getName());
         }
-      } else if (annotationType == QueryParam.class) {
-        if (pathQueryParams != null) {
+        requestType = RequestType.MULTIPART;
+      } else if (annotationType == FormUrlEncoded.class) {
+        if (requestType != RequestType.SIMPLE) {
           throw new IllegalStateException(
-              "QueryParam and QueryParams annotations are mutually exclusive.");
+              "Only one encoding annotation per method is allowed: " + method.getName());
         }
-        pathQueryParams = new QueryParam[] { (QueryParam) methodAnnotation };
-      } else if (annotationType == Multipart.class) {
-        isMultipart = true;
+        requestType = RequestType.FORM_URL_ENCODED;
       }
     }
 
-    if (restMethod == null) {
+    if (requestMethod == null) {
       throw new IllegalStateException(
-          "Method " + method + " not annotated with request type (e.g., GET, POST).");
+          "Method " + method.getName() + " not annotated with request type (e.g., GET, POST).");
     }
-    if (!restMethod.hasBody() && isMultipart) {
-      throw new IllegalStateException(
-          "Multipart can only be specific on HTTP methods with request body (e.g., POST).");
-    }
-    if (pathQueryParams == null) {
-      pathQueryParams = new QueryParam[0];
-    } else {
-      for (QueryParam pathQueryParam : pathQueryParams) {
-        if (pathParams.contains(pathQueryParam.name())) {
-          throw new IllegalStateException("Query parameters cannot be present in URL.");
-        }
+    if (!requestHasBody) {
+      if (requestType == RequestType.MULTIPART) {
+        throw new IllegalStateException(
+            "Multipart can only be specific on HTTP methods with request body (e.g., POST). ("
+                + method.getName()
+                + ")");
+      }
+      if (requestType == RequestType.FORM_URL_ENCODED) {
+        throw new IllegalStateException(
+            "Multipart can only be specific on HTTP methods with request body (e.g., POST). ("
+                + method.getName()
+                + ")");
+      }
+    }
+  }
+
+  /** Loads {@link #requestUrl}, {@link #requestUrlParamNames}, and {@link #requestQuery}. */
+  private void parsePath(String path) {
+    if (path == null || path.length() == 0 || path.charAt(0) != '/') {
+      throw new IllegalArgumentException("URL path \""
+          + path
+          + "\" on method "
+          + method.getName()
+          + " must start with '/'. ("
+          + method.getName()
+          + ")");
+    }
+
+    // Get the relative URL path and existing query string, if present.
+    String url = path;
+    String query = null;
+    int question = path.indexOf('?');
+    if (question != -1 && question < path.length() - 1) {
+      url = path.substring(0, question);
+      query = path.substring(question + 1);
+      hasQueryParams = true;
+
+      // Ensure the query string does not have any named parameters.
+      Matcher queryParamMatcher = URL_PARAMETERS.matcher(query);
+      if (queryParamMatcher.find()) {
+        throw new IllegalStateException("URL query string \""
+            + query
+            + "\" on method "
+            + method.getName()
+            + " may not have replace block.");
+      }
+    }
+
+    Set<String> urlParams = parsePathParameters(path);
+
+    requestUrl = url;
+    requestUrlParamNames = urlParams;
+    requestQuery = query;
+  }
+
+  private List<retrofit.http.client.Header> parseHeaders(String[] headers) {
+    List<retrofit.http.client.Header> headerList = new ArrayList<retrofit.http.client.Header>();
+    for (String header : headers) {
+      int colon = header.indexOf(':');
+      if (colon == -1 || colon == 0 || colon == headers.length - 1) {
+        throw new IllegalStateException("Header must be in the form 'Name: Value': " + header);
       }
+      headerList.add(new retrofit.http.client.Header(header.substring(0, colon),
+          header.substring(colon + 1).trim()));
     }
+    return headerList;
   }
 
-  /** Loads {@link #type}. Returns true if the method is synchronous. */
+  /** Loads {@link #responseObjectType}. Returns {@code true} if method is synchronous. */
   private boolean parseResponseType() {
     // Synchronous methods have a non-void return type.
     Type returnType = method.getGenericReturnType();
@@ -137,16 +236,18 @@ private boolean parseResponseType() {
 
     // Check for invalid configurations.
     if (hasReturnType && hasCallback) {
-      throw new IllegalArgumentException(
-          "Method may only have return type or Callback as last argument, not both.");
+      throw new IllegalArgumentException("Method "
+          + method.getName()
+          + " may only have return type or Callback as last argument, not both.");
     }
     if (!hasReturnType && !hasCallback) {
-      throw new IllegalArgumentException(
-          "Method must have either a return type or Callback as last argument.");
+      throw new IllegalArgumentException("Method "
+          + method.getName()
+          + " must have either a return type or Callback as last argument.");
     }
 
     if (hasReturnType) {
-      type = returnType;
+      responseObjectType = returnType;
       return true;
     }
 
@@ -159,75 +260,131 @@ private boolean parseResponseType() {
           types[i] = ((WildcardType) type).getUpperBounds()[0];
         }
       }
-      type = types[0];
+      responseObjectType = types[0];
       return false;
     }
-    throw new IllegalArgumentException(
-        String.format("Last parameter of %s must be of type Callback<X> or Callback<? super X>.",
-            method));
+
+    throw new IllegalArgumentException("Last parameter of "
+        + method.getName()
+        + " must be of type Callback<X> or Callback<? super X>. Found: "
+        + lastArgType);
   }
 
   /**
-   * Loads {@link #namedParams}, {@link #singleEntityArgumentIndex}. Must be called after
-   * {@link #parseMethodAnnotations()}}.
+   * Loads {@link #requestUrlParam}, {@link #requestQueryName}, {@link #requestFormPair},
+   * {@link #requestMultipartPart}, and {@link #requestParamHeader}. Must be called after
+   * {@link #parseMethodAnnotations()}.
    */
   private void parseParameters() {
     Class<?>[] parameterTypes = method.getParameterTypes();
+
     Annotation[][] parameterAnnotationArrays = method.getParameterAnnotations();
     int count = parameterAnnotationArrays.length;
     if (!isSynchronous) {
       count -= 1; // Callback is last argument when not a synchronous method.
     }
 
-    String[] namedParams = new String[count];
+    String[] urlParam = new String[count];
+    String[] queryName = new String[count];
+    String[] formValue = new String[count];
+    String[] multipartPart = new String[count];
+    String[] paramHeader = new String[count];
+    boolean gotField = false;
+    boolean gotPart = false;
+
     for (int i = 0; i < count; i++) {
+      boolean hasRetrofitAnnotation = false;
+
       Class<?> parameterType = parameterTypes[i];
       Annotation[] parameterAnnotations = parameterAnnotationArrays[i];
-      if (parameterAnnotations == null || parameterAnnotations.length == 0) {
-        throw new IllegalStateException("Argument " + i + " lacks annotation.");
-      }
-      for (Annotation parameterAnnotation : parameterAnnotations) {
-        Class<? extends Annotation> annotationType = parameterAnnotation.annotationType();
-        if (annotationType == Name.class) {
-          String name = ((Name) parameterAnnotation).value();
-          namedParams[i] = name;
-          boolean isPathParam = pathParams.contains(name);
-          if (parameterType == TypedOutput.class && (isPathParam || !restMethod.hasBody())) {
-            throw new IllegalStateException("TypedOutput cannot be used as URL parameter.");
-          }
-          if (!isPathParam && !isMultipart && restMethod.hasBody()) {
-            throw new IllegalStateException(
-                "Non-path params can only be used in multipart request.");
-          }
-        } else if (annotationType == SingleEntity.class) {
-          if (isMultipart) {
-            throw new IllegalStateException("SingleEntity cannot be used with multipart request.");
-          }
-          if (singleEntityArgumentIndex != NO_SINGLE_ENTITY) {
-            throw new IllegalStateException(
-                "Method annotated with multiple SingleEntity method annotations: " + method);
+      if (parameterAnnotations != null) {
+        for (Annotation parameterAnnotation : parameterAnnotations) {
+          Class<? extends Annotation> annotationType = parameterAnnotation.annotationType();
+
+          if (annotationType == Path.class) {
+            hasRetrofitAnnotation = true;
+            String name = ((Path) parameterAnnotation).value();
+
+            // Verify URL replacement name is actually present in the URL path.
+            if (!requestUrlParamNames.contains(name)) {
+              throw new IllegalStateException(
+                  "Method path \"" + requestUrl + "\" does not contain {" + name + "}.");
+            }
+
+            urlParam[i] = name;
+          } else if (annotationType == Query.class) {
+            hasRetrofitAnnotation = true;
+            hasQueryParams = true;
+            String name = ((Query) parameterAnnotation).value();
+
+            queryName[i] = name;
+          } else if (annotationType == Header.class) {
+            String name = ((Header) parameterAnnotation).value();
+            if (parameterType != String.class) {
+              throw new IllegalStateException("@Header parameter type must be String: " + name);
+            }
+
+            hasRetrofitAnnotation = true;
+            paramHeader[i] = name;
+          } else if (annotationType == Field.class) {
+            if (requestType != RequestType.FORM_URL_ENCODED) {
+              throw new IllegalStateException(
+                  "@Field parameters can only be used with form encoding.");
+            }
+
+            String name = ((Field) parameterAnnotation).value();
+
+            gotField = true;
+            hasRetrofitAnnotation = true;
+            formValue[i] = name;
+          } else if (annotationType == Part.class) {
+            if (requestType != RequestType.MULTIPART) {
+              throw new IllegalStateException(
+                  "@Part parameters can only be used with multipart encoding.");
+            }
+
+            String name = ((Part) parameterAnnotation).value();
+
+            gotPart = true;
+            hasRetrofitAnnotation = true;
+            multipartPart[i] = name;
+          } else if (annotationType == Body.class) {
+            if (requestType != RequestType.SIMPLE) {
+              throw new IllegalStateException(
+                  "@Body parameters cannot be used with form or multi-part encoding.");
+            }
+            if (bodyIndex != NO_BODY) {
+              throw new IllegalStateException(
+                  "Method annotated with multiple Body method annotations: " + method);
+            }
+
+            hasRetrofitAnnotation = true;
+            bodyIndex = i;
           }
-          singleEntityArgumentIndex = i;
-        } else {
-          throw new IllegalStateException(
-              "Argument " + i + " has invalid annotation " + annotationType + ": " + method);
         }
       }
-    }
-    // Check for single entity + non-path parameters.
-    if (singleEntityArgumentIndex != NO_SINGLE_ENTITY) {
-      for (String namedParam : namedParams) {
-        if (namedParam != null && !pathParams.contains(namedParam)) {
-          throw new IllegalStateException(
-              "Single entity and non-path parameters cannot both be present.");
-        }
+
+      if (!hasRetrofitAnnotation) {
+        throw new IllegalStateException(
+            "No annotations found on parameter " + (i + 1) + " of " + method.getName());
       }
     }
-    if (!restMethod.hasBody() && (isMultipart || singleEntityArgumentIndex != NO_SINGLE_ENTITY)) {
-      throw new IllegalStateException(
-          "Non-body HTTP method cannot contain @SingleEntity or @TypedOutput.");
+
+    if (requestType == RequestType.SIMPLE && !requestHasBody && bodyIndex != NO_BODY) {
+      throw new IllegalStateException("Non-body HTTP method cannot contain @Body or @TypedOutput.");
     }
-    this.namedParams = namedParams;
+    if (requestType == RequestType.FORM_URL_ENCODED && !gotField) {
+      throw new IllegalStateException("Form-encoded method must contain at least one @Field.");
+    }
+    if (requestType == RequestType.MULTIPART && !gotPart) {
+      throw new IllegalStateException("Multipart method must contain at least one @Part.");
+    }
+
+    requestUrlParam = urlParam;
+    requestQueryName = queryName;
+    requestFormPair = formValue;
+    requestMultipartPart = multipartPart;
+    requestParamHeader = paramHeader;
   }
 
   /**
@@ -235,7 +392,7 @@ private void parseParameters() {
    * in the URI, it will only show up once in the set.
    */
   static Set<String> parsePathParameters(String path) {
-    Matcher m = PATH_PARAMETERS.matcher(path);
+    Matcher m = URL_PARAMETERS.matcher(path);
     Set<String> patterns = new LinkedHashSet<String>();
     while (m.find()) {
       patterns.add(m.group(1));
diff --git a/retrofit/src/main/java/retrofit/http/RetrofitError.java b/retrofit/src/main/java/retrofit/http/RetrofitError.java
index cd1476864..e2a46004a 100644
--- a/retrofit/src/main/java/retrofit/http/RetrofitError.java
+++ b/retrofit/src/main/java/retrofit/http/RetrofitError.java
@@ -1,4 +1,18 @@
-// Copyright 2012 Square, Inc.
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package retrofit.http;
 
 import java.io.IOException;
@@ -7,21 +21,21 @@
 import retrofit.http.mime.TypedInput;
 
 public class RetrofitError extends RuntimeException {
-  static RetrofitError networkError(String url, IOException exception) {
+  public static RetrofitError networkError(String url, IOException exception) {
     return new RetrofitError(url, null, null, null, true, exception);
   }
 
-  static RetrofitError conversionError(String url, Response response, Converter converter,
+  public static RetrofitError conversionError(String url, Response response, Converter converter,
       Type successType, ConversionException exception) {
     return new RetrofitError(url, response, converter, successType, false, exception);
   }
 
-  static RetrofitError httpError(String url, Response response, Converter converter,
+  public static RetrofitError httpError(String url, Response response, Converter converter,
       Type successType) {
     return new RetrofitError(url, response, converter, successType, false, null);
   }
 
-  static RetrofitError unexpectedError(String url, Throwable exception) {
+  public static RetrofitError unexpectedError(String url, Throwable exception) {
     return new RetrofitError(url, null, null, null, false, exception);
   }
 
diff --git a/retrofit/src/main/java/retrofit/http/Server.java b/retrofit/src/main/java/retrofit/http/Server.java
index b1c63b820..ec934774e 100644
--- a/retrofit/src/main/java/retrofit/http/Server.java
+++ b/retrofit/src/main/java/retrofit/http/Server.java
@@ -1,4 +1,18 @@
-// Copyright 2010 Square, Inc.
+/*
+ * Copyright (C) 2010 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package retrofit.http;
 
 /**
diff --git a/retrofit/src/main/java/retrofit/http/Types.java b/retrofit/src/main/java/retrofit/http/Types.java
index 3aadc9c22..83a1c69ee 100644
--- a/retrofit/src/main/java/retrofit/http/Types.java
+++ b/retrofit/src/main/java/retrofit/http/Types.java
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2008 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -13,7 +13,6 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
 package retrofit.http;
 
 import java.lang.reflect.Array;
diff --git a/retrofit/src/main/java/retrofit/http/Utils.java b/retrofit/src/main/java/retrofit/http/Utils.java
index e606f18f7..6781409f0 100644
--- a/retrofit/src/main/java/retrofit/http/Utils.java
+++ b/retrofit/src/main/java/retrofit/http/Utils.java
@@ -1,5 +1,19 @@
-// Copyright 2012 Square, Inc.
-// Copyright 2007 The Guava Authors
+/*
+ * Copyright (C) 2012 Square, Inc.
+ * Copyright (C) 2007 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package retrofit.http;
 
 import java.io.ByteArrayOutputStream;
@@ -8,6 +22,9 @@
 import java.util.concurrent.Executor;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
+import retrofit.http.client.Response;
+import retrofit.http.mime.TypedByteArray;
+import retrofit.http.mime.TypedInput;
 
 import static java.util.regex.Pattern.CASE_INSENSITIVE;
 
@@ -33,6 +50,27 @@
     return baos.toByteArray();
   }
 
+  /**
+   * Conditionally replace a {@link Response} with an identical copy whose body is backed by a
+   * byte[] rather than an input stream.
+   */
+  static Response readBodyToBytesIfNecessary(Response response) throws IOException {
+    TypedInput body = response.getBody();
+    if (body == null || body instanceof TypedByteArray) {
+      return response;
+    }
+
+    String bodyMime = body.mimeType();
+    byte[] bodyBytes = Utils.streamToBytes(body.in());
+    body = new TypedByteArray(bodyMime, bodyBytes);
+
+    return replaceResponseBody(response, body);
+  }
+
+  static Response replaceResponseBody(Response response, TypedInput body) {
+    return new Response(response.getStatus(), response.getReason(), response.getHeaders(), body);
+  }
+
   public static String parseCharset(String mimeType) {
     Matcher match = CHARSET.matcher(mimeType);
     if (match.find()) {
@@ -50,4 +88,4 @@ public static String parseCharset(String mimeType) {
   private Utils() {
     // No instances.
   }
-}
\ No newline at end of file
+}
diff --git a/retrofit/src/main/java/retrofit/http/android/AndroidApacheClient.java b/retrofit/src/main/java/retrofit/http/android/AndroidApacheClient.java
index d19e4710a..af615a20c 100644
--- a/retrofit/src/main/java/retrofit/http/android/AndroidApacheClient.java
+++ b/retrofit/src/main/java/retrofit/http/android/AndroidApacheClient.java
@@ -1,4 +1,18 @@
-// Copyright 2013 Square, Inc.
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package retrofit.http.android;
 
 import android.net.http.AndroidHttpClient;
diff --git a/retrofit/src/main/java/retrofit/http/android/MainThreadExecutor.java b/retrofit/src/main/java/retrofit/http/android/MainThreadExecutor.java
index 85bc92c53..fb003f471 100644
--- a/retrofit/src/main/java/retrofit/http/android/MainThreadExecutor.java
+++ b/retrofit/src/main/java/retrofit/http/android/MainThreadExecutor.java
@@ -1,4 +1,18 @@
-// Copyright 2012 Square, Inc.
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package retrofit.http.android;
 
 import android.os.Handler;
diff --git a/retrofit/src/main/java/retrofit/http/client/ApacheClient.java b/retrofit/src/main/java/retrofit/http/client/ApacheClient.java
index 8c0dcc660..d31081dd3 100644
--- a/retrofit/src/main/java/retrofit/http/client/ApacheClient.java
+++ b/retrofit/src/main/java/retrofit/http/client/ApacheClient.java
@@ -1,4 +1,18 @@
-// Copyright 2013 Square, Inc.
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package retrofit.http.client;
 
 import java.io.ByteArrayInputStream;
@@ -19,7 +33,6 @@
 import org.apache.http.impl.client.DefaultHttpClient;
 import org.apache.http.message.BasicHeader;
 import org.apache.http.util.EntityUtils;
-import retrofit.http.Header;
 import retrofit.http.mime.TypedByteArray;
 import retrofit.http.mime.TypedOutput;
 
diff --git a/retrofit/src/main/java/retrofit/http/client/Client.java b/retrofit/src/main/java/retrofit/http/client/Client.java
index e601a3edd..27f7949df 100644
--- a/retrofit/src/main/java/retrofit/http/client/Client.java
+++ b/retrofit/src/main/java/retrofit/http/client/Client.java
@@ -1,3 +1,18 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package retrofit.http.client;
 
 import java.io.IOException;
diff --git a/retrofit/src/main/java/retrofit/http/client/Header.java b/retrofit/src/main/java/retrofit/http/client/Header.java
new file mode 100644
index 000000000..a1d184d60
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/http/client/Header.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.http.client;
+
+/** Represents an HTTP header name/value pair. */
+public final class Header {
+  private final String name;
+  private final String value;
+
+  public Header(String name, String value) {
+    this.name = name;
+    this.value = value;
+  }
+
+  public String getName() {
+    return name;
+  }
+
+  public String getValue() {
+    return value;
+  }
+
+  @Override public boolean equals(Object o) {
+    if (this == o) return true;
+    if (o == null || getClass() != o.getClass()) return false;
+
+    Header header = (Header) o;
+
+    if (name != null ? !name.equals(header.name) : header.name != null) return false;
+    if (value != null ? !value.equals(header.value) : header.value != null) return false;
+
+    return true;
+  }
+
+  @Override public int hashCode() {
+    int result = name != null ? name.hashCode() : 0;
+    result = 31 * result + (value != null ? value.hashCode() : 0);
+    return result;
+  }
+
+  @Override public String toString() {
+    return (name != null ? name : "") + ": " + (value != null ? value : "");
+  }
+}
diff --git a/retrofit/src/main/java/retrofit/http/client/OkClient.java b/retrofit/src/main/java/retrofit/http/client/OkClient.java
new file mode 100644
index 000000000..9be66ec5d
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/http/client/OkClient.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.http.client;
+
+import com.squareup.okhttp.OkHttpClient;
+import java.io.IOException;
+import java.net.HttpURLConnection;
+import java.net.URL;
+
+/** Retrofit client that uses OkHttp for communication. */
+public class OkClient extends UrlConnectionClient {
+  private final OkHttpClient client;
+
+  public OkClient() {
+    this(new OkHttpClient());
+  }
+
+  public OkClient(OkHttpClient client) {
+    this.client = client;
+  }
+
+  @Override protected HttpURLConnection openConnection(Request request) throws IOException {
+    return client.open(new URL(request.getUrl()));
+  }
+}
diff --git a/retrofit/src/main/java/retrofit/http/client/Request.java b/retrofit/src/main/java/retrofit/http/client/Request.java
index dc1dc02bb..3e32ce586 100644
--- a/retrofit/src/main/java/retrofit/http/client/Request.java
+++ b/retrofit/src/main/java/retrofit/http/client/Request.java
@@ -1,9 +1,23 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package retrofit.http.client;
 
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
-import retrofit.http.Header;
 import retrofit.http.mime.TypedOutput;
 
 /** Encapsulates all of the information necessary to make an HTTP request. */
@@ -42,7 +56,7 @@ public String getUrl() {
     return url;
   }
 
-  /** Returns an unmodifiable list of headers.empty, never {@code null}. */
+  /** Returns an unmodifiable list of headers, never {@code null}. */
   public List<Header> getHeaders() {
     return headers;
   }
diff --git a/retrofit/src/main/java/retrofit/http/client/Response.java b/retrofit/src/main/java/retrofit/http/client/Response.java
index 9498a9b44..bc14ab291 100644
--- a/retrofit/src/main/java/retrofit/http/client/Response.java
+++ b/retrofit/src/main/java/retrofit/http/client/Response.java
@@ -1,10 +1,23 @@
-// Copyright 2013 Square, Inc.
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package retrofit.http.client;
 
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
-import retrofit.http.Header;
 import retrofit.http.mime.TypedInput;
 
 /** An HTTP response. */
diff --git a/retrofit/src/main/java/retrofit/http/client/UrlConnectionClient.java b/retrofit/src/main/java/retrofit/http/client/UrlConnectionClient.java
index 43f679b8f..84ad65719 100644
--- a/retrofit/src/main/java/retrofit/http/client/UrlConnectionClient.java
+++ b/retrofit/src/main/java/retrofit/http/client/UrlConnectionClient.java
@@ -1,4 +1,18 @@
-// Copyright 2013 Square, Inc.
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package retrofit.http.client;
 
 import java.io.IOException;
@@ -8,10 +22,10 @@
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
-import retrofit.http.Header;
 import retrofit.http.mime.TypedInput;
 import retrofit.http.mime.TypedOutput;
 
+/** Retrofit client that uses {@link HttpURLConnection} for communication. */
 public class UrlConnectionClient implements Client {
   @Override public Response execute(Request request) throws IOException {
     HttpURLConnection connection = openConnection(request);
diff --git a/retrofit/src/main/java/retrofit/http/mime/FormUrlEncodedTypedOutput.java b/retrofit/src/main/java/retrofit/http/mime/FormUrlEncodedTypedOutput.java
new file mode 100644
index 000000000..f748762d4
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/http/mime/FormUrlEncodedTypedOutput.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.http.mime;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.net.URLEncoder;
+
+public final class FormUrlEncodedTypedOutput implements TypedOutput {
+  final ByteArrayOutputStream content = new ByteArrayOutputStream();
+
+  public void addPair(String name, String value) {
+    if (name == null) {
+      throw new NullPointerException("name");
+    }
+    if (value == null) {
+      throw new NullPointerException("value");
+    }
+    if (content.size() > 0) {
+      content.write('&');
+    }
+    try {
+      name = URLEncoder.encode(name, "UTF-8");
+      value = URLEncoder.encode(value, "UTF-8");
+
+      content.write(name.getBytes("UTF-8"));
+      content.write('=');
+      content.write(value.getBytes("UTF-8"));
+    } catch (IOException e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  @Override public String fileName() {
+    return null;
+  }
+
+  @Override public String mimeType() {
+    return "application/x-www-form-urlencoded; charset=UTF-8";
+  }
+
+  @Override public long length() {
+    return content.size();
+  }
+
+  @Override public void writeTo(OutputStream out) throws IOException {
+    out.write(content.toByteArray());
+  }
+}
diff --git a/retrofit/src/main/java/retrofit/http/mime/MultipartTypedOutput.java b/retrofit/src/main/java/retrofit/http/mime/MultipartTypedOutput.java
new file mode 100644
index 000000000..8e740f1ad
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/http/mime/MultipartTypedOutput.java
@@ -0,0 +1,132 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.http.mime;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.UUID;
+
+public final class MultipartTypedOutput implements TypedOutput {
+  final List<byte[]> parts = new ArrayList<byte[]>();
+  private final byte[] footer;
+  private final String boundary;
+  private long length;
+
+  public MultipartTypedOutput() {
+    this(UUID.randomUUID().toString());
+  }
+
+  MultipartTypedOutput(String boundary) {
+    this.boundary = boundary;
+    footer = buildBoundary(boundary, false, true);
+    length = footer.length;
+  }
+
+  public void addPart(String name, TypedOutput body) {
+    if (name == null) {
+      throw new NullPointerException("Part name must not be null.");
+    }
+    if (body == null) {
+      throw new NullPointerException("Part body must not be null.");
+    }
+
+    byte[] part = buildPart(name, body, parts.isEmpty());
+    parts.add(part);
+    length += part.length;
+  }
+
+  @Override public String fileName() {
+    return null;
+  }
+
+  @Override public String mimeType() {
+    return "multipart/form-data; boundary=" + boundary;
+  }
+
+  @Override public long length() {
+    return length;
+  }
+
+  @Override public void writeTo(OutputStream out) throws IOException {
+    for (byte[] part : parts) {
+      out.write(part);
+    }
+    out.write(footer);
+  }
+
+  private byte[] buildPart(String name, TypedOutput body, boolean first) {
+    ByteArrayOutputStream out = null;
+    try {
+      out = new ByteArrayOutputStream();
+      out.write(buildBoundary(boundary, first, false));
+      out.write(buildHeader(name, body));
+      body.writeTo(out);
+      return out.toByteArray();
+    } catch (IOException ex) {
+      throw new RuntimeException("Unable to write multipart request.", ex);
+    } finally {
+      if (out != null) {
+        try {
+          out.close();
+        } catch (IOException ignored) {
+        }
+      }
+    }
+  }
+
+  private static byte[] buildBoundary(String boundary, boolean first, boolean last) {
+    try {
+      StringBuilder sb = new StringBuilder();
+      if (!first) {
+        sb.append("\r\n");
+      }
+      sb.append("--");
+      sb.append(boundary);
+      if (last) {
+        sb.append("--");
+      } else {
+        sb.append("\r\n");
+      }
+      return sb.toString().getBytes("UTF-8");
+    } catch (IOException ex) {
+      throw new RuntimeException("Unable to write multipart boundary", ex);
+    }
+  }
+
+  private byte[] buildHeader(String name, TypedOutput value) {
+    try {
+      StringBuilder headers = new StringBuilder();
+      headers.append("Content-Disposition: form-data; name=\"");
+      headers.append(name);
+      if (value.fileName() != null) {
+        headers.append("\"; filename=\"");
+        headers.append(value.fileName());
+      }
+      headers.append("\"\r\nContent-Type: ");
+      headers.append(value.mimeType());
+      if (value.length() != -1) {
+        headers.append("\r\nContent-Length: ").append(value.length());
+      }
+      headers.append("\r\nContent-Transfer-Encoding: binary\r\n\r\n");
+      return headers.toString().getBytes("UTF-8");
+    } catch (IOException ex) {
+      throw new RuntimeException("Unable to write multipart header", ex);
+    }
+  }
+}
diff --git a/retrofit/src/main/java/retrofit/http/mime/TypedByteArray.java b/retrofit/src/main/java/retrofit/http/mime/TypedByteArray.java
index f0b65f53d..66b8446be 100644
--- a/retrofit/src/main/java/retrofit/http/mime/TypedByteArray.java
+++ b/retrofit/src/main/java/retrofit/http/mime/TypedByteArray.java
@@ -1,4 +1,18 @@
-// Copyright 2010 Square, Inc.
+/*
+ * Copyright (C) 2010 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package retrofit.http.mime;
 
 import java.io.ByteArrayInputStream;
@@ -36,6 +50,10 @@ public TypedByteArray(String mimeType, byte[] bytes) {
     return bytes;
   }
 
+  @Override public String fileName() {
+    return null;
+  }
+
   @Override public String mimeType() {
     return mimeType;
   }
@@ -69,4 +87,4 @@ public TypedByteArray(String mimeType, byte[] bytes) {
     result = 31 * result + Arrays.hashCode(bytes);
     return result;
   }
-}
\ No newline at end of file
+}
diff --git a/retrofit/src/main/java/retrofit/http/mime/TypedFile.java b/retrofit/src/main/java/retrofit/http/mime/TypedFile.java
index 6721bd116..a13d7c349 100644
--- a/retrofit/src/main/java/retrofit/http/mime/TypedFile.java
+++ b/retrofit/src/main/java/retrofit/http/mime/TypedFile.java
@@ -1,4 +1,18 @@
-// Copyright 2010 Square, Inc.
+/*
+ * Copyright (C) 2010 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package retrofit.http.mime;
 
 import java.io.File;
@@ -47,6 +61,10 @@ public File file() {
     return file.length();
   }
 
+  @Override public String fileName() {
+    return file.getName();
+  }
+
   @Override public InputStream in() throws IOException {
     return new FileInputStream(file);
   }
diff --git a/retrofit/src/main/java/retrofit/http/mime/TypedInput.java b/retrofit/src/main/java/retrofit/http/mime/TypedInput.java
index 3fbb22535..b2d48b79e 100644
--- a/retrofit/src/main/java/retrofit/http/mime/TypedInput.java
+++ b/retrofit/src/main/java/retrofit/http/mime/TypedInput.java
@@ -1,4 +1,18 @@
-// Copyright 2013 Square, Inc.
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package retrofit.http.mime;
 
 import java.io.IOException;
diff --git a/retrofit/src/main/java/retrofit/http/mime/TypedOutput.java b/retrofit/src/main/java/retrofit/http/mime/TypedOutput.java
index 4e142ddfc..9a8bf8aeb 100644
--- a/retrofit/src/main/java/retrofit/http/mime/TypedOutput.java
+++ b/retrofit/src/main/java/retrofit/http/mime/TypedOutput.java
@@ -1,4 +1,18 @@
-// Copyright 2013 Square, Inc.
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package retrofit.http.mime;
 
 import java.io.IOException;
@@ -10,11 +24,15 @@
  * @author Bob Lee (bob@squareup.com)
  */
 public interface TypedOutput {
+  /** Original filename.
+   *
+   * Used only for multipart requests, may be null. */
+  String fileName();
 
   /** Returns the mime type. */
   String mimeType();
 
-  /** Length in bytes. */
+  /** Length in bytes or -1 if unknown. */
   long length();
 
   /** Writes these bytes to the given output stream. */
diff --git a/retrofit/src/main/java/retrofit/http/mime/TypedString.java b/retrofit/src/main/java/retrofit/http/mime/TypedString.java
index ab8792e76..0b0922f49 100644
--- a/retrofit/src/main/java/retrofit/http/mime/TypedString.java
+++ b/retrofit/src/main/java/retrofit/http/mime/TypedString.java
@@ -1,4 +1,18 @@
-// Copyright 2013 Square, Inc.
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package retrofit.http.mime;
 
 import java.io.UnsupportedEncodingException;
diff --git a/retrofit/src/test/java/retrofit/http/RequestBuilderTest.java b/retrofit/src/test/java/retrofit/http/RequestBuilderTest.java
index 44fc6d25f..987f92b35 100644
--- a/retrofit/src/test/java/retrofit/http/RequestBuilderTest.java
+++ b/retrofit/src/test/java/retrofit/http/RequestBuilderTest.java
@@ -5,22 +5,21 @@
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.lang.reflect.Method;
-import java.net.URISyntaxException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Iterator;
 import java.util.List;
-import java.util.Map;
-import java.util.Set;
 import org.junit.Test;
+import retrofit.http.client.Header;
 import retrofit.http.client.Request;
+import retrofit.http.mime.MimeHelper;
+import retrofit.http.mime.MultipartTypedOutput;
 import retrofit.http.mime.TypedOutput;
 import retrofit.http.mime.TypedString;
 
 import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-import static retrofit.http.RestMethodInfo.NO_SINGLE_ENTITY;
+import static retrofit.http.RestMethodInfo.NO_BODY;
+import static retrofit.http.RestMethodInfo.RequestType;
 
 public class RequestBuilderTest {
   @Test public void normalGet() throws Exception {
@@ -40,7 +39,7 @@
         .setMethod("GET") //
         .setUrl("http://example.com") //
         .setPath("/foo/bar/{ping}/") //
-        .addNamedParam("ping", "pong") //
+        .addPathParam("ping", "pong") //
         .build();
     assertThat(request.getMethod()).isEqualTo("GET");
     assertThat(request.getHeaders()).isEmpty();
@@ -61,75 +60,74 @@
     assertThat(request.getBody()).isNull();
   }
 
-  @Test public void getWithPathAndQueryParam() throws Exception {
+  @Test public void getWithQueryUrlAndParam() throws Exception {
     Request request = new Helper() //
         .setMethod("GET") //
         .setUrl("http://example.com") //
-        .setPath("/foo/bar/{ping}/") //
-        .addNamedParam("ping", "pong") //
-        .addNamedParam("kit", "kat") //
-        .addNamedParam("riff", "raff") //
+        .setPath("/foo/bar/") //
+        .setQuery("?hi=mom") //
+        .addQueryParam("ping", "pong") //
         .build();
     assertThat(request.getMethod()).isEqualTo("GET");
     assertThat(request.getHeaders()).isEmpty();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/pong/?kit=kat&riff=raff");
+    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/?hi=mom&ping=pong");
     assertThat(request.getBody()).isNull();
   }
 
-  @Test public void getWithPathAndQueryQuestionMarkParam() throws Exception {
+  @Test public void getWithPathAndQueryParam() throws Exception {
     Request request = new Helper() //
         .setMethod("GET") //
         .setUrl("http://example.com") //
         .setPath("/foo/bar/{ping}/") //
-        .addNamedParam("ping", "pong?") //
-        .addNamedParam("kit", "kat?") //
+        .addPathParam("ping", "pong") //
+        .addQueryParam("kit", "kat") //
+        .addQueryParam("riff", "raff") //
         .build();
     assertThat(request.getMethod()).isEqualTo("GET");
     assertThat(request.getHeaders()).isEmpty();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/pong%3F/?kit=kat%3F");
+    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/pong/?kit=kat&riff=raff");
     assertThat(request.getBody()).isNull();
   }
 
-  @Test public void getWithPathAndQueryAmpersandParam() throws Exception {
+  @Test public void getWithPathAndQueryQuestionMarkParam() throws Exception {
     Request request = new Helper() //
         .setMethod("GET") //
         .setUrl("http://example.com") //
         .setPath("/foo/bar/{ping}/") //
-        .addNamedParam("ping", "pong&") //
-        .addNamedParam("kit", "kat&") //
+        .addPathParam("ping", "pong?") //
+        .addQueryParam("kit", "kat?") //
         .build();
     assertThat(request.getMethod()).isEqualTo("GET");
     assertThat(request.getHeaders()).isEmpty();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/pong%26/?kit=kat%26");
+    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/pong%3F/?kit=kat%3F");
     assertThat(request.getBody()).isNull();
   }
 
-  @Test public void getWithPathAndQueryHashParam() throws Exception {
+  @Test public void getWithPathAndQueryAmpersandParam() throws Exception {
     Request request = new Helper() //
         .setMethod("GET") //
         .setUrl("http://example.com") //
         .setPath("/foo/bar/{ping}/") //
-        .addNamedParam("ping", "pong#") //
-        .addNamedParam("kit", "kat#") //
+        .addPathParam("ping", "pong&") //
+        .addQueryParam("kit", "kat&") //
         .build();
     assertThat(request.getMethod()).isEqualTo("GET");
     assertThat(request.getHeaders()).isEmpty();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/pong%23/?kit=kat%23");
+    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/pong%26/?kit=kat%26");
     assertThat(request.getBody()).isNull();
   }
 
-  @Test public void getWithPathAndQueryParamAsync() throws Exception {
+  @Test public void getWithPathAndQueryHashParam() throws Exception {
     Request request = new Helper() //
         .setMethod("GET") //
         .setUrl("http://example.com") //
         .setPath("/foo/bar/{ping}/") //
-        .addNamedParam("ping", "pong") //
-        .addNamedParam("kit", "kat") //
-        .setAsynchronous() //
+        .addPathParam("ping", "pong#") //
+        .addQueryParam("kit", "kat#") //
         .build();
     assertThat(request.getMethod()).isEqualTo("GET");
     assertThat(request.getHeaders()).isEmpty();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/pong/?kit=kat");
+    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/pong%23/?kit=kat%23");
     assertThat(request.getBody()).isNull();
   }
 
@@ -152,7 +150,7 @@
         .setHasBody() //
         .setUrl("http://example.com") //
         .setPath("/foo/bar/{ping}/") //
-        .addNamedParam("ping", "pong") //
+        .addPathParam("ping", "pong") //
         .build();
     assertThat(request.getMethod()).isEqualTo("POST");
     assertThat(request.getHeaders()).isEmpty();
@@ -166,7 +164,7 @@
         .setHasBody() //
         .setUrl("http://example.com") //
         .setPath("/foo/bar/") //
-        .addSingleEntityParam(Arrays.asList("quick", "brown", "fox")) //
+        .setBody(Arrays.asList("quick", "brown", "fox")) //
         .build();
     assertThat(request.getMethod()).isEqualTo("POST");
     assertThat(request.getHeaders()).isEmpty();
@@ -180,26 +178,9 @@
         .setHasBody() //
         .setUrl("http://example.com") //
         .setPath("/foo/bar/{ping}/{kit}/") //
-        .addNamedParam("ping", "pong") //
-        .addSingleEntityParam(Arrays.asList("quick", "brown", "fox")) //
-        .addNamedParam("kit", "kat") //
-        .build();
-    assertThat(request.getMethod()).isEqualTo("POST");
-    assertThat(request.getHeaders()).isEmpty();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/pong/kat/");
-    assertTypedBytes(request.getBody(), "[\"quick\",\"brown\",\"fox\"]");
-  }
-
-  @Test public void singleEntityWithPathParamsAsync() throws Exception {
-    Request request = new Helper() //
-        .setMethod("POST") //
-        .setHasBody() //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/{ping}/{kit}/") //
-        .addNamedParam("ping", "pong") //
-        .addSingleEntityParam(Arrays.asList("quick", "brown", "fox")) //
-        .addNamedParam("kit", "kat") //
-        .setAsynchronous() //
+        .addPathParam("ping", "pong") //
+        .setBody(Arrays.asList("quick", "brown", "fox")) //
+        .addPathParam("kit", "kat") //
         .build();
     assertThat(request.getMethod()).isEqualTo("POST");
     assertThat(request.getHeaders()).isEmpty();
@@ -213,26 +194,38 @@
         .setHasBody() //
         .setUrl("http://example.com") //
         .setPath("/foo/bar/") //
-        .addNamedParam("ping", "pong") //
-        .addNamedParam("kit", new TypedString("kat")) //
         .setMultipart() //
+        .addPart("ping", "pong") //
+        .addPart("kit", new TypedString("kat")) //
         .build();
     assertThat(request.getMethod()).isEqualTo("POST");
     assertThat(request.getHeaders()).isEmpty();
     assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
 
     MultipartTypedOutput body = (MultipartTypedOutput) request.getBody();
-    assertThat(body.parts).hasSize(2);
+    List<byte[]> bodyParts = MimeHelper.getParts(body);
+    assertThat(bodyParts).hasSize(2);
 
-    Iterator<Map.Entry<String, TypedOutput>> iterator = body.parts.entrySet().iterator();
+    Iterator<byte[]> iterator = bodyParts.iterator();
 
-    Map.Entry<String, TypedOutput> one = iterator.next();
-    assertThat(one.getKey()).isEqualTo("ping");
-    assertTypedBytes(one.getValue(), "pong");
+    String one = new String(iterator.next(), "UTF-8");
+    assertThat(one).contains("ping").contains("pong");
 
-    Map.Entry<String, TypedOutput> two = iterator.next();
-    assertThat(two.getKey()).isEqualTo("kit");
-    assertTypedBytes(two.getValue(), "kat");
+    String two = new String(iterator.next(), "UTF-8");
+    assertThat(two).contains("kit").contains("kat");
+  }
+
+  @Test public void simpleFormEncoded() throws Exception {
+    Request request = new Helper() //
+        .setMethod("POST") //
+        .setHasBody() //
+        .setUrl("http://example.com") //
+        .setPath("/foo") //
+        .setFormEncoded() //
+        .addPair("foo", "bar") //
+        .addPair("ping", "pong") //
+        .build();
+    assertTypedBytes(request.getBody(), "foo=bar&ping=pong");
   }
 
   @Test public void simpleHeaders() throws Exception {
@@ -250,6 +243,36 @@
     assertThat(request.getBody()).isNull();
   }
 
+  @Test public void methodHeader() throws Exception {
+    Request request = new Helper() //
+        .setMethod("GET") //
+        .setUrl("http://example.com") //
+        .setPath("/foo/bar/") //
+        .addHeader("ping", "pong") //
+        .addHeaderParam("kit", "kat") //
+        .build();
+    assertThat(request.getMethod()).isEqualTo("GET");
+    assertThat(request.getHeaders()) //
+        .containsExactly(new Header("ping", "pong"), new Header("kit", "kat"));
+    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.getBody()).isNull();
+  }
+
+  @Test public void headerParam() throws Exception {
+    Request request = new Helper() //
+        .setMethod("GET") //
+        .setUrl("http://example.com") //
+        .setPath("/foo/bar/") //
+        .addHeader("ping", "pong") //
+        .addHeaderParam("kit", "kat") //
+        .build();
+    assertThat(request.getMethod()).isEqualTo("GET");
+    assertThat(request.getHeaders()) //
+        .containsExactly(new Header("ping", "pong"), new Header("kit", "kat"));
+    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.getBody()).isNull();
+  }
+
   @Test public void noDuplicateSlashes() throws Exception {
     Request request = new Helper() //
         .setMethod("GET") //
@@ -269,24 +292,22 @@ private static void assertTypedBytes(TypedOutput bytes, String expected) throws
   private static class Helper {
     private static final Converter GSON = new GsonConverter(new Gson());
 
-    private boolean isSynchronous = true;
-    private boolean isMultipart = false;
+    private RequestType requestType = RequestType.SIMPLE;
     private String method;
     private boolean hasBody = false;
+    private boolean hasQueryParams = false;
     private String path;
-    private Set<String> pathParams;
-    private final List<QueryParam> queryParams = new ArrayList<QueryParam>();
-    private final List<String> namedParams = new ArrayList<String>();
+    private String query;
+    private final List<String> pathParams = new ArrayList<String>();
+    private final List<String> queryParams = new ArrayList<String>();
+    private final List<String> pairParams = new ArrayList<String>();
+    private final List<String> partParams = new ArrayList<String>();
+    private final List<String> headerParams = new ArrayList<String>();
     private final List<Object> args = new ArrayList<Object>();
     private final List<Header> headers = new ArrayList<Header>();
-    private int singleEntityArgumentIndex = NO_SINGLE_ENTITY;
+    private int bodyIndex = NO_BODY;
     private String url;
 
-    Helper setAsynchronous() {
-      isSynchronous = false;
-      return this;
-    }
-
     Helper setMethod(String method) {
       this.method = method;
       return this;
@@ -297,37 +318,61 @@ Helper setHasBody() {
       return this;
     }
 
+    Helper setUrl(String url) {
+      this.url = url;
+      return this;
+    }
+
     Helper setPath(String path) {
       this.path = path;
-      pathParams = RestMethodInfo.parsePathParameters(path);
       return this;
     }
 
-    Helper addQueryParam(String name, String value) {
-      QueryParam queryParam = mock(QueryParam.class);
-      when(queryParam.name()).thenReturn(name);
-      when(queryParam.value()).thenReturn(value);
-      queryParams.add(queryParam);
+    Helper setQuery(String query) {
+      this.query = query;
+      hasQueryParams = true;
       return this;
     }
 
-    Helper addNamedParam(String name, Object value) {
-      if (name == null) {
-        throw new IllegalArgumentException("Name can not be null.");
-      }
-      namedParams.add(name);
+    private void addParam(String path, String query, String pair, String part, String header,
+        Object value) {
+      pathParams.add(path);
+      queryParams.add(query);
+      pairParams.add(pair);
+      partParams.add(part);
+      headerParams.add(header);
       args.add(value);
+    }
+
+    Helper addPathParam(String name, Object value) {
+      addParam(name, null, null, null, null, value);
       return this;
     }
 
-    Helper addSingleEntityParam(Object value) {
-      if (singleEntityArgumentIndex != NO_SINGLE_ENTITY) {
-        throw new IllegalStateException("Single entity param already added.");
-      }
-      // Relying on the fact that this is already less one.
-      singleEntityArgumentIndex = namedParams.size();
-      namedParams.add(null);
-      args.add(value);
+    Helper addQueryParam(String name, String value) {
+      addParam(null, name, null, null, null, value);
+      hasQueryParams = true;
+      return this;
+    }
+
+    Helper addPair(String name, String value) {
+      addParam(null, null, name, null, null, value);
+      return this;
+    }
+
+    Helper addPart(String name, Object value) {
+      addParam(null, null, null, name, null, value);
+      return this;
+    }
+
+    Helper setBody(Object value) {
+      addParam(null, null, null, null, null, value);
+      bodyIndex = args.size() - 1;
+      return this;
+    }
+
+    Helper addHeaderParam(String name, Object value) {
+      addParam(null, null, null, null, name, value);
       return this;
     }
 
@@ -337,16 +382,16 @@ Helper addHeader(String name, String value) {
     }
 
     Helper setMultipart() {
-      isMultipart = true;
+      requestType = RequestType.MULTIPART;
       return this;
     }
 
-    Helper setUrl(String url) {
-      this.url = url;
+    Helper setFormEncoded() {
+      requestType = RequestType.FORM_URL_ENCODED;
       return this;
     }
 
-    Request build() throws NoSuchMethodException, URISyntaxException {
+    Request build() throws Exception {
       if (method == null) {
         throw new IllegalStateException("Method must be set.");
       }
@@ -354,34 +399,29 @@ Request build() throws NoSuchMethodException, URISyntaxException {
         throw new IllegalStateException("Path must be set.");
       }
 
-      final Method method;
-      if (isSynchronous) {
-        method = getClass().getDeclaredMethod("dummySync");
-      } else {
-        method = getClass().getDeclaredMethod("dummyAsync", Callback.class);
-        args.add(mock(Callback.class));
-      }
-
-      // Create a fake rest method annotation based on set values.
-      RestMethod restMethod = mock(RestMethod.class);
-      when(restMethod.hasBody()).thenReturn(hasBody);
-      when(restMethod.value()).thenReturn(this.method);
+      Method method = getClass().getDeclaredMethod("dummySync");
 
       RestMethodInfo methodInfo = new RestMethodInfo(method);
-      methodInfo.restMethod = restMethod;
-      methodInfo.path = path;
-      methodInfo.pathParams = pathParams;
-      methodInfo.pathQueryParams = queryParams.toArray(new QueryParam[queryParams.size()]);
-      methodInfo.namedParams = namedParams.toArray(new String[namedParams.size()]);
-      methodInfo.singleEntityArgumentIndex = singleEntityArgumentIndex;
-      methodInfo.isMultipart = isMultipart;
+      methodInfo.requestMethod = this.method;
+      methodInfo.requestHasBody = hasBody;
+      methodInfo.requestType = requestType;
+      methodInfo.requestUrl = path;
+      methodInfo.requestUrlParamNames = RestMethodInfo.parsePathParameters(path);
+      methodInfo.requestQuery = query;
+      methodInfo.hasQueryParams = hasQueryParams;
+      methodInfo.requestUrlParam = pathParams.toArray(new String[pathParams.size()]);
+      methodInfo.requestQueryName = queryParams.toArray(new String[queryParams.size()]);
+      methodInfo.requestFormPair = pairParams.toArray(new String[pairParams.size()]);
+      methodInfo.requestMultipartPart = partParams.toArray(new String[partParams.size()]);
+      methodInfo.requestParamHeader = headerParams.toArray(new String[headerParams.size()]);
+      methodInfo.bodyIndex = bodyIndex;
       methodInfo.loaded = true;
 
       return new RequestBuilder(GSON) //
-          .setApiUrl(url)
-          .setHeaders(headers)
-          .setArgs(args.toArray(new Object[args.size()]))
-          .setMethodInfo(methodInfo)
+          .apiUrl(url)
+          .headers(headers)
+          .args(args.toArray(new Object[args.size()]))
+          .methodInfo(methodInfo)
           .build();
     }
 
@@ -389,9 +429,5 @@ Request build() throws NoSuchMethodException, URISyntaxException {
     private Object dummySync() {
       return null;
     }
-
-    @SuppressWarnings("UnusedDeclaration") // Accessed via reflection.
-    private void dummyAsync(Callback<Object> cb) {
-    }
   }
 }
diff --git a/retrofit/src/test/java/retrofit/http/RestAdapterTest.java b/retrofit/src/test/java/retrofit/http/RestAdapterTest.java
index 683055a17..725296ada 100644
--- a/retrofit/src/test/java/retrofit/http/RestAdapterTest.java
+++ b/retrofit/src/test/java/retrofit/http/RestAdapterTest.java
@@ -8,6 +8,7 @@
 import org.junit.Before;
 import org.junit.Test;
 import retrofit.http.client.Client;
+import retrofit.http.client.Header;
 import retrofit.http.client.Request;
 import retrofit.http.client.Response;
 import retrofit.http.mime.TypedString;
@@ -111,7 +112,7 @@
     } catch (RetrofitError e) {
       assertThat(e.getResponse().getStatus()).isEqualTo(200);
       assertThat(e.getCause()).isInstanceOf(ConversionException.class);
-      assertThat(e.getResponse().getBody()).isEqualTo(new TypedString("{"));
+      assertThat(e.getResponse().getBody()).isNull();
     }
   }
 
diff --git a/retrofit/src/test/java/retrofit/http/RestMethodInfoTest.java b/retrofit/src/test/java/retrofit/http/RestMethodInfoTest.java
index 80255d253..9c48b046e 100644
--- a/retrofit/src/test/java/retrofit/http/RestMethodInfoTest.java
+++ b/retrofit/src/test/java/retrofit/http/RestMethodInfoTest.java
@@ -6,6 +6,7 @@
 import java.lang.annotation.Target;
 import java.lang.reflect.Method;
 import java.lang.reflect.Type;
+import java.util.Arrays;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
@@ -15,7 +16,9 @@
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 import static org.fest.assertions.api.Assertions.assertThat;
-import static retrofit.http.RestMethodInfo.NO_SINGLE_ENTITY;
+import static retrofit.http.RestMethodInfo.NO_BODY;
+import static retrofit.http.RestMethodInfo.RequestType.MULTIPART;
+import static retrofit.http.RestMethodInfo.RequestType.SIMPLE;
 
 public class RestMethodInfoTest {
   @Test public void pathParameterParsing() throws Exception {
@@ -31,6 +34,8 @@
     expectParams("foo/bar/{taco}/or/{taco}", "taco");
     expectParams("foo/bar/{taco-shell}", "taco-shell");
     expectParams("foo/bar/{taco_shell}", "taco_shell");
+    expectParams("foo/bar/{sha256}", "sha256");
+    expectParams("foo/bar/{1}"); // Invalid parameter, name cannot start with digit.
   }
 
   private static void expectParams(String path, String... expected) {
@@ -63,19 +68,19 @@ public void pathMustBePrefixedWithSlash() {
     Method method = TestingUtils.getMethod(Example.class, "a");
     RestMethodInfo methodInfo = new RestMethodInfo(method);
     assertThat(methodInfo.isSynchronous).isFalse();
-    assertThat(methodInfo.type).isEqualTo(Response.class);
+    assertThat(methodInfo.responseObjectType).isEqualTo(Response.class);
   }
 
   @Test public void concreteCallbackTypesWithParams() {
     class Example {
-      @GET("/foo") void a(@Name("id") String id, ResponseCallback cb) {
+      @GET("/foo") void a(@Path("id") String id, ResponseCallback cb) {
       }
     }
 
     Method method = TestingUtils.getMethod(Example.class, "a");
     RestMethodInfo methodInfo = new RestMethodInfo(method);
     assertThat(methodInfo.isSynchronous).isFalse();
-    assertThat(methodInfo.type).isEqualTo(Response.class);
+    assertThat(methodInfo.responseObjectType).isEqualTo(Response.class);
   }
 
   @Test public void genericCallbackTypes() {
@@ -87,19 +92,19 @@ public void pathMustBePrefixedWithSlash() {
     Method method = TestingUtils.getMethod(Example.class, "a");
     RestMethodInfo methodInfo = new RestMethodInfo(method);
     assertThat(methodInfo.isSynchronous).isFalse();
-    assertThat(methodInfo.type).isEqualTo(Response.class);
+    assertThat(methodInfo.responseObjectType).isEqualTo(Response.class);
   }
 
   @Test public void genericCallbackTypesWithParams() {
     class Example {
-      @GET("/foo") void a(@Name("id") String id, Callback<Response> c) {
+      @GET("/foo") void a(@Path("id") String id, Callback<Response> c) {
       }
     }
 
     Method method = TestingUtils.getMethod(Example.class, "a");
     RestMethodInfo methodInfo = new RestMethodInfo(method);
     assertThat(methodInfo.isSynchronous).isFalse();
-    assertThat(methodInfo.type).isEqualTo(Response.class);
+    assertThat(methodInfo.responseObjectType).isEqualTo(Response.class);
   }
 
   @Test public void wildcardGenericCallbackTypes() {
@@ -111,7 +116,7 @@ public void pathMustBePrefixedWithSlash() {
     Method method = TestingUtils.getMethod(Example.class, "a");
     RestMethodInfo methodInfo = new RestMethodInfo(method);
     assertThat(methodInfo.isSynchronous).isFalse();
-    assertThat(methodInfo.type).isEqualTo(Response.class);
+    assertThat(methodInfo.responseObjectType).isEqualTo(Response.class);
   }
 
   @Test public void genericCallbackWithGenericType() {
@@ -125,7 +130,7 @@ public void pathMustBePrefixedWithSlash() {
     assertThat(methodInfo.isSynchronous).isFalse();
 
     Type expected = new TypeToken<List<String>>() {}.getType();
-    assertThat(methodInfo.type).isEqualTo(expected);
+    assertThat(methodInfo.responseObjectType).isEqualTo(expected);
   }
 
   // RestMethodInfo reconstructs this type from MultimapCallback<String, Set<Long>>. It contains
@@ -141,7 +146,7 @@ public void pathMustBePrefixedWithSlash() {
     Method method = TestingUtils.getMethod(Example.class, "a");
     RestMethodInfo methodInfo = new RestMethodInfo(method);
     assertThat(methodInfo.isSynchronous).isFalse();
-    assertThat(methodInfo.type).isEqualTo(
+    assertThat(methodInfo.responseObjectType).isEqualTo(
         RestMethodInfoTest.class.getDeclaredField("extendingGenericCallbackType").getGenericType());
   }
 
@@ -155,7 +160,7 @@ public void pathMustBePrefixedWithSlash() {
     Method method = TestingUtils.getMethod(Example.class, "a");
     RestMethodInfo methodInfo = new RestMethodInfo(method);
     assertThat(methodInfo.isSynchronous).isTrue();
-    assertThat(methodInfo.type).isEqualTo(Response.class);
+    assertThat(methodInfo.responseObjectType).isEqualTo(Response.class);
   }
 
   @Test public void synchronousGenericResponse() {
@@ -170,13 +175,13 @@ public void pathMustBePrefixedWithSlash() {
     assertThat(methodInfo.isSynchronous).isTrue();
 
     Type expected = new TypeToken<List<String>>() {}.getType();
-    assertThat(methodInfo.type).isEqualTo(expected);
+    assertThat(methodInfo.responseObjectType).isEqualTo(expected);
   }
 
   @Test(expected = IllegalArgumentException.class)
   public void missingCallbackTypes() {
     class Example {
-      @GET("/foo") void a(@Name("id") String id) {
+      @GET("/foo") void a(@Path("id") String id) {
       }
     }
 
@@ -220,9 +225,9 @@ Response a() {
     RestMethodInfo methodInfo = new RestMethodInfo(method);
     methodInfo.init();
 
-    assertThat(methodInfo.restMethod.value()).isEqualTo("DELETE");
-    assertThat(methodInfo.restMethod.hasBody()).isFalse();
-    assertThat(methodInfo.path).isEqualTo("/foo");
+    assertThat(methodInfo.requestMethod).isEqualTo("DELETE");
+    assertThat(methodInfo.requestHasBody).isFalse();
+    assertThat(methodInfo.requestUrl).isEqualTo("/foo");
   }
 
   @Test public void getMethod() {
@@ -236,9 +241,9 @@ Response a() {
     RestMethodInfo methodInfo = new RestMethodInfo(method);
     methodInfo.init();
 
-    assertThat(methodInfo.restMethod.value()).isEqualTo("GET");
-    assertThat(methodInfo.restMethod.hasBody()).isFalse();
-    assertThat(methodInfo.path).isEqualTo("/foo");
+    assertThat(methodInfo.requestMethod).isEqualTo("GET");
+    assertThat(methodInfo.requestHasBody).isFalse();
+    assertThat(methodInfo.requestUrl).isEqualTo("/foo");
   }
 
   @Test public void headMethod() {
@@ -252,9 +257,9 @@ Response a() {
     RestMethodInfo methodInfo = new RestMethodInfo(method);
     methodInfo.init();
 
-    assertThat(methodInfo.restMethod.value()).isEqualTo("HEAD");
-    assertThat(methodInfo.restMethod.hasBody()).isFalse();
-    assertThat(methodInfo.path).isEqualTo("/foo");
+    assertThat(methodInfo.requestMethod).isEqualTo("HEAD");
+    assertThat(methodInfo.requestHasBody).isFalse();
+    assertThat(methodInfo.requestUrl).isEqualTo("/foo");
   }
 
   @Test public void postMethod() {
@@ -268,9 +273,9 @@ Response a() {
     RestMethodInfo methodInfo = new RestMethodInfo(method);
     methodInfo.init();
 
-    assertThat(methodInfo.restMethod.value()).isEqualTo("POST");
-    assertThat(methodInfo.restMethod.hasBody()).isTrue();
-    assertThat(methodInfo.path).isEqualTo("/foo");
+    assertThat(methodInfo.requestMethod).isEqualTo("POST");
+    assertThat(methodInfo.requestHasBody).isTrue();
+    assertThat(methodInfo.requestUrl).isEqualTo("/foo");
   }
 
   @Test public void putMethod() {
@@ -284,9 +289,9 @@ Response a() {
     RestMethodInfo methodInfo = new RestMethodInfo(method);
     methodInfo.init();
 
-    assertThat(methodInfo.restMethod.value()).isEqualTo("PUT");
-    assertThat(methodInfo.restMethod.hasBody()).isTrue();
-    assertThat(methodInfo.path).isEqualTo("/foo");
+    assertThat(methodInfo.requestMethod).isEqualTo("PUT");
+    assertThat(methodInfo.requestHasBody).isTrue();
+    assertThat(methodInfo.requestUrl).isEqualTo("/foo");
   }
 
   @RestMethod("CUSTOM1")
@@ -306,9 +311,9 @@ Response a() {
     RestMethodInfo methodInfo = new RestMethodInfo(method);
     methodInfo.init();
 
-    assertThat(methodInfo.restMethod.value()).isEqualTo("CUSTOM1");
-    assertThat(methodInfo.restMethod.hasBody()).isFalse();
-    assertThat(methodInfo.path).isEqualTo("/foo");
+    assertThat(methodInfo.requestMethod).isEqualTo("CUSTOM1");
+    assertThat(methodInfo.requestHasBody).isFalse();
+    assertThat(methodInfo.requestUrl).isEqualTo("/foo");
   }
 
   @RestMethod(value = "CUSTOM2", hasBody = true)
@@ -328,15 +333,14 @@ Response a() {
     RestMethodInfo methodInfo = new RestMethodInfo(method);
     methodInfo.init();
 
-    assertThat(methodInfo.restMethod.value()).isEqualTo("CUSTOM2");
-    assertThat(methodInfo.restMethod.hasBody()).isTrue();
-    assertThat(methodInfo.path).isEqualTo("/foo");
+    assertThat(methodInfo.requestMethod).isEqualTo("CUSTOM2");
+    assertThat(methodInfo.requestHasBody).isTrue();
+    assertThat(methodInfo.requestUrl).isEqualTo("/foo");
   }
 
   @Test public void singleQueryParam() {
     class Example {
-      @GET("/foo")
-      @QueryParam(name = "a", value = "b")
+      @GET("/foo?a=b")
       Response a() {
         return null;
       }
@@ -346,20 +350,13 @@ Response a() {
     RestMethodInfo methodInfo = new RestMethodInfo(method);
     methodInfo.init();
 
-    assertThat(methodInfo.pathQueryParams).hasSize(1);
-    QueryParam param = methodInfo.pathQueryParams[0];
-    assertThat(param.name()).isEqualTo("a");
-    assertThat(param.value()).isEqualTo("b");
+    assertThat(methodInfo.requestUrl).isEqualTo("/foo");
+    assertThat(methodInfo.requestQuery).isEqualTo("a=b");
   }
 
-  @Test public void multipleQueryParam() {
+  @Test public void emptyParams() {
     class Example {
-      @GET("/foo")
-      @QueryParams({
-          @QueryParam(name = "a", value = "b"),
-          @QueryParam(name = "c", value = "d")
-      })
-      Response a() {
+      @GET("/") Response a() {
         return null;
       }
     }
@@ -368,25 +365,17 @@ Response a() {
     RestMethodInfo methodInfo = new RestMethodInfo(method);
     methodInfo.init();
 
-    assertThat(methodInfo.pathQueryParams).hasSize(2);
-    QueryParam param1 = methodInfo.pathQueryParams[0];
-    assertThat(param1.name()).isEqualTo("a");
-    assertThat(param1.value()).isEqualTo("b");
-    QueryParam param2 = methodInfo.pathQueryParams[1];
-    assertThat(param2.name()).isEqualTo("c");
-    assertThat(param2.value()).isEqualTo("d");
+    assertThat(methodInfo.requestUrlParam).isEmpty();
+    assertThat(methodInfo.requestQueryName).isEmpty();
+    assertThat(methodInfo.requestFormPair).isEmpty();
+    assertThat(methodInfo.requestMultipartPart).isEmpty();
+    assertThat(methodInfo.bodyIndex).isEqualTo(NO_BODY);
+    assertThat(methodInfo.requestType).isEqualTo(SIMPLE);
   }
 
-  @Test(expected = IllegalStateException.class)
-  public void bothQueryParamAnnotations() {
-    class Example {
-      @GET("/foo")
-      @QueryParam(name = "a", value = "b")
-      @QueryParams({
-          @QueryParam(name = "a", value = "b"),
-          @QueryParam(name = "c", value = "d")
-      })
-      Response a() {
+  @Test public void singleParam() {
+    class Example {
+      @GET("/") Response a(@Query("a") String a) {
         return null;
       }
     }
@@ -394,25 +383,15 @@ Response a() {
     Method method = TestingUtils.getMethod(Example.class, "a");
     RestMethodInfo methodInfo = new RestMethodInfo(method);
     methodInfo.init();
-  }
 
-  @Test(expected = IllegalStateException.class)
-  public void emptyQueryParams() {
-    class Example {
-      @GET("/foo")
-      @QueryParams({})
-      Response a() {
-        return null;
-      }
-    }
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
+    assertThat(methodInfo.requestQueryName).hasSize(1).containsSequence("a");
+    assertThat(methodInfo.bodyIndex).isEqualTo(NO_BODY);
+    assertThat(methodInfo.requestType).isEqualTo(SIMPLE);
   }
 
-  @Test public void noQueryParamsNonNull() {
+  @Test public void multipleParams() {
     class Example {
-      @GET("/") Response a() {
+      @GET("/") Response a(@Query("a") String a, @Query("b") String b, @Query("c") String c) {
         return null;
       }
     }
@@ -421,16 +400,14 @@ Response a() {
     RestMethodInfo methodInfo = new RestMethodInfo(method);
     methodInfo.init();
 
-    assertThat(methodInfo.pathQueryParams).isEmpty();
-    assertThat(methodInfo.isMultipart).isFalse();
+    assertThat(methodInfo.requestQueryName).hasSize(3).containsSequence("a", "b", "c");
+    assertThat(methodInfo.bodyIndex).isEqualTo(NO_BODY);
+    assertThat(methodInfo.requestType).isEqualTo(SIMPLE);
   }
 
-  @Test(expected = IllegalStateException.class)
-  public void noQueryParamsInUrl() {
+  @Test public void bodyObject() {
     class Example {
-      @GET("/foo/{bar}/")
-      @QueryParam(name = "bar", value = "baz")
-      Response a() {
+      @PUT("/") Response a(@Body Object o) {
         return null;
       }
     }
@@ -438,11 +415,18 @@ Response a() {
     Method method = TestingUtils.getMethod(Example.class, "a");
     RestMethodInfo methodInfo = new RestMethodInfo(method);
     methodInfo.init();
+
+    assertThat(methodInfo.requestUrlParam).containsOnly(new String[] { null });
+    assertThat(methodInfo.requestQueryName).containsOnly(new String[] { null });
+    assertThat(methodInfo.requestFormPair).containsOnly(new String[] { null });
+    assertThat(methodInfo.requestMultipartPart).containsOnly(new String[] { null });
+    assertThat(methodInfo.bodyIndex).isEqualTo(0);
+    assertThat(methodInfo.requestType).isEqualTo(SIMPLE);
   }
 
-  @Test public void emptyParams() {
+  @Test public void bodyTypedBytes() {
     class Example {
-      @GET("/") Response a() {
+      @PUT("/") Response a(@Body TypedOutput o) {
         return null;
       }
     }
@@ -451,14 +435,18 @@ Response a() {
     RestMethodInfo methodInfo = new RestMethodInfo(method);
     methodInfo.init();
 
-    assertThat(methodInfo.namedParams).isEmpty();
-    assertThat(methodInfo.singleEntityArgumentIndex).isEqualTo(NO_SINGLE_ENTITY);
-    assertThat(methodInfo.isMultipart).isFalse();
+    assertThat(methodInfo.requestUrlParam).containsOnly(new String[] { null });
+    assertThat(methodInfo.requestQueryName).containsOnly(new String[] { null });
+    assertThat(methodInfo.requestFormPair).containsOnly(new String[] { null });
+    assertThat(methodInfo.requestMultipartPart).containsOnly(new String[] { null });
+    assertThat(methodInfo.bodyIndex).isEqualTo(0);
+    assertThat(methodInfo.requestType).isEqualTo(SIMPLE);
   }
 
-  @Test public void singleParam() {
+  @Test(expected = IllegalStateException.class)
+  public void twoBodies() {
     class Example {
-      @GET("/") Response a(@Name("a") String a) {
+      @PUT("/") Response a(@Body int o1, @Body int o2) {
         return null;
       }
     }
@@ -466,76 +454,56 @@ Response a() {
     Method method = TestingUtils.getMethod(Example.class, "a");
     RestMethodInfo methodInfo = new RestMethodInfo(method);
     methodInfo.init();
-
-    assertThat(methodInfo.namedParams).hasSize(1).containsSequence("a");
-    assertThat(methodInfo.singleEntityArgumentIndex).isEqualTo(NO_SINGLE_ENTITY);
-    assertThat(methodInfo.isMultipart).isFalse();
   }
 
-  @Test public void multipleParams() {
+  @Test public void bodyWithOtherParams() {
     class Example {
-      @GET("/") Response a(@Name("a") String a, @Name("b") String b, @Name("c") String c) {
+      @PUT("/{a}/{c}") Response a(@Path("a") int a, @Body int b, @Path("c") int c) {
         return null;
       }
     }
-
     Method method = TestingUtils.getMethod(Example.class, "a");
     RestMethodInfo methodInfo = new RestMethodInfo(method);
     methodInfo.init();
 
-    assertThat(methodInfo.namedParams).hasSize(3).containsSequence("a", "b", "c");
-    assertThat(methodInfo.singleEntityArgumentIndex).isEqualTo(NO_SINGLE_ENTITY);
-    assertThat(methodInfo.isMultipart).isFalse();
+    assertThat(methodInfo.requestUrlParam).containsExactly("a", null, "c");
+    assertThat(methodInfo.requestQueryName).containsExactly(null, null, null);
+    assertThat(methodInfo.requestFormPair).containsExactly(null, null, null);
+    assertThat(methodInfo.requestMultipartPart).containsExactly(null, null, null);
+    assertThat(methodInfo.bodyIndex).isEqualTo(1);
+    assertThat(methodInfo.requestType).isEqualTo(SIMPLE);
   }
 
-  @Test public void emptyParamsWithCallback() {
+  @Test(expected = IllegalStateException.class)
+  public void pathParamNonPathParamAndTypedBytes() {
     class Example {
-      @GET("/") void a(ResponseCallback cb) {
+      @PUT("/{a}") Response a(@Path("a") int a, @Path("b") int b, @Body int c) {
+        return null;
       }
     }
 
     Method method = TestingUtils.getMethod(Example.class, "a");
     RestMethodInfo methodInfo = new RestMethodInfo(method);
     methodInfo.init();
-
-    assertThat(methodInfo.namedParams).isEmpty();
-    assertThat(methodInfo.singleEntityArgumentIndex).isEqualTo(NO_SINGLE_ENTITY);
-    assertThat(methodInfo.isMultipart).isFalse();
   }
 
-  @Test public void singleParamWithCallback() {
+  @Test(expected = IllegalStateException.class)
+  public void parameterWithoutAnnotation() {
     class Example {
-      @GET("/") void a(@Name("a") String a, ResponseCallback cb) {
+      @GET("/") Response a(String a) {
+        return null;
       }
     }
 
     Method method = TestingUtils.getMethod(Example.class, "a");
     RestMethodInfo methodInfo = new RestMethodInfo(method);
     methodInfo.init();
-
-    assertThat(methodInfo.namedParams).hasSize(1).containsSequence("a");
-    assertThat(methodInfo.singleEntityArgumentIndex).isEqualTo(NO_SINGLE_ENTITY);
-    assertThat(methodInfo.isMultipart).isFalse();
   }
 
-  @Test public void multipleParamsWithCallback() {
-    class Example {
-      @GET("/") void a(@Name("a") String a, @Name("b") String b, ResponseCallback cb) {
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-
-    assertThat(methodInfo.namedParams).hasSize(2).containsSequence("a", "b");
-    assertThat(methodInfo.singleEntityArgumentIndex).isEqualTo(NO_SINGLE_ENTITY);
-    assertThat(methodInfo.isMultipart).isFalse();
-  }
-
-  @Test public void singleEntity() {
+  @Test(expected = IllegalStateException.class)
+  public void nonBodyHttpMethodWithSingleEntity() {
     class Example {
-      @PUT("/") Response a(@SingleEntity Object o) {
+      @GET("/") Response a(@Body Object o) {
         return null;
       }
     }
@@ -543,16 +511,12 @@ Response a() {
     Method method = TestingUtils.getMethod(Example.class, "a");
     RestMethodInfo methodInfo = new RestMethodInfo(method);
     methodInfo.init();
-
-    assertThat(methodInfo.namedParams).hasSize(1);
-    assertThat(methodInfo.namedParams[0]).isNull();
-    assertThat(methodInfo.singleEntityArgumentIndex).isEqualTo(0);
-    assertThat(methodInfo.isMultipart).isFalse();
   }
 
-  @Test public void singleEntityTypedBytes() {
+  @Test(expected = IllegalStateException.class)
+  public void nonBodyHttpMethodWithTypedBytes() {
     class Example {
-      @PUT("/") Response a(@SingleEntity TypedOutput o) {
+      @GET("/") Response a(@Path("a") TypedOutput a) {
         return null;
       }
     }
@@ -560,16 +524,13 @@ Response a() {
     Method method = TestingUtils.getMethod(Example.class, "a");
     RestMethodInfo methodInfo = new RestMethodInfo(method);
     methodInfo.init();
-
-    assertThat(methodInfo.namedParams).hasSize(1);
-    assertThat(methodInfo.namedParams[0]).isNull();
-    assertThat(methodInfo.singleEntityArgumentIndex).isEqualTo(0);
-    assertThat(methodInfo.isMultipart).isFalse();
   }
 
-  @Test public void singleEntityWithCallback() {
+  @Test public void simpleMultipart() {
     class Example {
-      @PUT("/") void a(@SingleEntity Object o, ResponseCallback cb) {
+      @Multipart @PUT("/")
+      Response a(@Part("a") TypedOutput a) {
+        return null;
       }
     }
 
@@ -577,16 +538,13 @@ Response a() {
     RestMethodInfo methodInfo = new RestMethodInfo(method);
     methodInfo.init();
 
-    assertThat(methodInfo.namedParams).hasSize(1);
-    assertThat(methodInfo.namedParams[0]).isNull();
-    assertThat(methodInfo.singleEntityArgumentIndex).isEqualTo(0);
-    assertThat(methodInfo.isMultipart).isFalse();
+    assertThat(methodInfo.requestType).isEqualTo(MULTIPART);
   }
 
-  @Test(expected = IllegalStateException.class)
-  public void twoSingleEntities() {
+  @Test public void twoTypedBytesMultipart() {
     class Example {
-      @PUT("/") Response a(@SingleEntity int o1, @SingleEntity int o2) {
+      @Multipart @PUT("/")
+      Response a(@Part("a") TypedOutput a, @Part("b") TypedOutput b) {
         return null;
       }
     }
@@ -594,26 +552,15 @@ public void twoSingleEntities() {
     Method method = TestingUtils.getMethod(Example.class, "a");
     RestMethodInfo methodInfo = new RestMethodInfo(method);
     methodInfo.init();
-  }
 
-  @Test public void singleEntityWithNamed() {
-    class Example {
-      @PUT("/{a}/{c}") Response a(@Name("a") int a, @SingleEntity int b, @Name("c") int c) {
-        return null;
-      }
-    }
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-
-    assertThat(methodInfo.namedParams).hasSize(3).containsSequence("a", null, "c");
-    assertThat(methodInfo.singleEntityArgumentIndex).isEqualTo(1);
-    assertThat(methodInfo.isMultipart).isFalse();
+    assertThat(methodInfo.requestType).isEqualTo(MULTIPART);
   }
 
-  @Test public void singleEntityWithNamedAndCallback() {
+  @Test public void twoTypesMultipart() {
     class Example {
-      @PUT("/{a}") void a(@Name("a") int a, @SingleEntity int b, ResponseCallback cb) {
+      @Multipart @PUT("/")
+      Response a(@Part("a") TypedOutput a, @Part("b") int b) {
+        return null;
       }
     }
 
@@ -621,15 +568,13 @@ public void twoSingleEntities() {
     RestMethodInfo methodInfo = new RestMethodInfo(method);
     methodInfo.init();
 
-    assertThat(methodInfo.namedParams).hasSize(2).containsSequence("a", null);
-    assertThat(methodInfo.singleEntityArgumentIndex).isEqualTo(1);
-    assertThat(methodInfo.isMultipart).isFalse();
+    assertThat(methodInfo.requestType).isEqualTo(MULTIPART);
   }
 
   @Test(expected = IllegalStateException.class)
-  public void nonPathParamAndSingleEntity() {
+  public void implicitMultipartForbidden() {
     class Example {
-      @PUT("/") Response a(@Name("a") int a, @SingleEntity int b) {
+      @POST("/") Response a(@Part("a") int a) {
         return null;
       }
     }
@@ -640,9 +585,9 @@ public void nonPathParamAndSingleEntity() {
   }
 
   @Test(expected = IllegalStateException.class)
-  public void typedBytesUrlParam() {
+  public void multipartFailsOnNonBodyMethod() {
     class Example {
-      @GET("/{a}") Response a(@Name("a") TypedOutput m) {
+      @Multipart @GET("/") Response a() {
         return null;
       }
     }
@@ -653,9 +598,9 @@ public void typedBytesUrlParam() {
   }
 
   @Test(expected = IllegalStateException.class)
-  public void pathParamNonPathParamAndTypedBytes() {
+  public void multipartFailsWithNoParts() {
     class Example {
-      @PUT("/{a}") Response a(@Name("a") int a, @Name("b") int b, @SingleEntity int c) {
+      @Multipart @POST("/") Response a() {
         return null;
       }
     }
@@ -666,9 +611,9 @@ public void pathParamNonPathParamAndTypedBytes() {
   }
 
   @Test(expected = IllegalStateException.class)
-  public void parameterWithoutAnnotation() {
+  public void implicitFormEncodingForbidden() {
     class Example {
-      @GET("/") Response a(String a) {
+      @POST("/") Response a(@Field("a") int a) {
         return null;
       }
     }
@@ -679,9 +624,9 @@ public void parameterWithoutAnnotation() {
   }
 
   @Test(expected = IllegalStateException.class)
-  public void nonBodyHttpMethodWithSingleEntity() {
+  public void formEncodingFailsOnNonBodyMethod() {
     class Example {
-      @GET("/") Response a(@SingleEntity Object o) {
+      @FormUrlEncoded @GET("/") Response a() {
         return null;
       }
     }
@@ -692,9 +637,9 @@ public void nonBodyHttpMethodWithSingleEntity() {
   }
 
   @Test(expected = IllegalStateException.class)
-  public void nonBodyHttpMethodWithTypedBytes() {
+  public void formEncodingFailsWithNoParts() {
     class Example {
-      @GET("/") Response a(@Name("a") TypedOutput a) {
+      @FormUrlEncoded @POST("/") Response a() {
         return null;
       }
     }
@@ -704,10 +649,10 @@ public void nonBodyHttpMethodWithTypedBytes() {
     methodInfo.init();
   }
 
-  @Test public void simpleMultipart() {
+  @Test(expected = IllegalStateException.class)
+  public void headersFailWhenEmptyOnMethod() {
     class Example {
-      @Multipart @PUT("/")
-      Response a(@Name("a") TypedOutput a) {
+      @GET("/") @Headers({}) Response a() {
         return null;
       }
     }
@@ -715,14 +660,15 @@ Response a(@Name("a") TypedOutput a) {
     Method method = TestingUtils.getMethod(Example.class, "a");
     RestMethodInfo methodInfo = new RestMethodInfo(method);
     methodInfo.init();
-
-    assertThat(methodInfo.isMultipart).isTrue();
   }
 
-  @Test public void twoTypedBytesMultipart() {
+  @Test public void twoMethodHeaders() {
+
     class Example {
-      @Multipart @PUT("/")
-      Response a(@Name("a") TypedOutput a, @Name("b") TypedOutput b) {
+      @GET("/") @Headers({
+        "X-Foo: Bar",
+        "X-Ping: Pong"
+      }) Response a() {
         return null;
       }
     }
@@ -731,13 +677,15 @@ Response a(@Name("a") TypedOutput a, @Name("b") TypedOutput b) {
     RestMethodInfo methodInfo = new RestMethodInfo(method);
     methodInfo.init();
 
-    assertThat(methodInfo.isMultipart).isTrue();
+    assertThat(methodInfo.headers).isEqualTo(
+        Arrays.asList(new retrofit.http.client.Header("X-Foo", "Bar"),
+            new retrofit.http.client.Header("X-Ping", "Pong")));
   }
 
-  @Test public void twoTypesMultipart() {
+  @Test public void twoHeaderParams() {
     class Example {
-      @Multipart @PUT("/")
-      Response a(@Name("a") TypedOutput a, @Name("b") int b) {
+      @GET("/")
+      Response a(@Header("a") String a, @Header("b") String b) {
         return null;
       }
     }
@@ -746,13 +694,15 @@ Response a(@Name("a") TypedOutput a, @Name("b") int b) {
     RestMethodInfo methodInfo = new RestMethodInfo(method);
     methodInfo.init();
 
-    assertThat(methodInfo.isMultipart).isTrue();
+    assertThat(Arrays.asList(methodInfo.requestParamHeader))
+      .isEqualTo(Arrays.asList("a", "b"));
   }
 
   @Test(expected = IllegalStateException.class)
-  public void implicitMultipartForbidden() {
+  public void headerParamMustBeString() {
     class Example {
-      @POST("/") Response a(@Name("a") int a) {
+      @GET("/")
+      Response a(@Header("a") TypedOutput a, @Header("b") int b) {
         return null;
       }
     }
@@ -763,9 +713,12 @@ public void implicitMultipartForbidden() {
   }
 
   @Test(expected = IllegalStateException.class)
-  public void multipartFailsOnNonBodyMethod() {
+  public void onlyOneEncodingIsAllowed() {
     class Example {
-      @Multipart @GET("/") Response a() {
+      @Multipart
+      @FormUrlEncoded
+      @POST("/")
+      Response a() {
         return null;
       }
     }
diff --git a/retrofit/src/test/java/retrofit/http/TestingUtils.java b/retrofit/src/test/java/retrofit/http/TestingUtils.java
index 91940816b..08b3a88a0 100644
--- a/retrofit/src/test/java/retrofit/http/TestingUtils.java
+++ b/retrofit/src/test/java/retrofit/http/TestingUtils.java
@@ -3,6 +3,7 @@
 
 import java.lang.reflect.Method;
 import java.util.Map;
+import retrofit.http.mime.MultipartTypedOutput;
 import retrofit.http.mime.TypedOutput;
 
 import static org.fest.assertions.api.Assertions.assertThat;
diff --git a/retrofit/src/test/java/retrofit/http/client/ApacheClientTest.java b/retrofit/src/test/java/retrofit/http/client/ApacheClientTest.java
index d2f745b98..cc65b7e42 100644
--- a/retrofit/src/test/java/retrofit/http/client/ApacheClientTest.java
+++ b/retrofit/src/test/java/retrofit/http/client/ApacheClientTest.java
@@ -15,7 +15,6 @@
 import org.apache.http.message.BasicHttpResponse;
 import org.apache.http.message.BasicStatusLine;
 import org.junit.Test;
-import retrofit.http.Header;
 import retrofit.http.TestingUtils;
 import retrofit.http.mime.TypedOutput;
 import retrofit.http.mime.TypedString;
diff --git a/retrofit/src/test/java/retrofit/http/client/UrlConnectionClientTest.java b/retrofit/src/test/java/retrofit/http/client/UrlConnectionClientTest.java
index 3b9df8cb7..bd00d7f51 100644
--- a/retrofit/src/test/java/retrofit/http/client/UrlConnectionClientTest.java
+++ b/retrofit/src/test/java/retrofit/http/client/UrlConnectionClientTest.java
@@ -10,7 +10,6 @@
 import java.util.List;
 import java.util.Map;
 import org.junit.Test;
-import retrofit.http.Header;
 import retrofit.http.TestingUtils;
 import retrofit.http.mime.TypedOutput;
 import retrofit.http.mime.TypedString;
@@ -64,11 +63,14 @@
     DummyHttpUrlConnection connection = (DummyHttpUrlConnection) client.openConnection(request);
     client.prepareRequest(connection, request);
 
+    byte[] output = connection.getOutputStream().toByteArray();
+
     assertThat(connection.getRequestMethod()).isEqualTo("POST");
     assertThat(connection.getURL().toString()).isEqualTo(HOST + "/that/");
-    assertThat(connection.getRequestProperties()).hasSize(1);
+    assertThat(connection.getRequestProperties()).hasSize(2);
     assertThat(connection.getRequestProperty("Content-Type")).startsWith("multipart/form-data;");
-    assertThat(connection.getOutputStream().toByteArray().length).isGreaterThan(0);
+    assertThat(connection.getRequestProperty("Content-Length")).isEqualTo(String.valueOf(output.length));
+    assertThat(output.length).isGreaterThan(0);
   }
 
   @Test public void headers() throws Exception {
diff --git a/retrofit/src/test/java/retrofit/http/mime/FormUrlEncodingTypedOutputTest.java b/retrofit/src/test/java/retrofit/http/mime/FormUrlEncodingTypedOutputTest.java
new file mode 100644
index 000000000..4d83794c8
--- /dev/null
+++ b/retrofit/src/test/java/retrofit/http/mime/FormUrlEncodingTypedOutputTest.java
@@ -0,0 +1,48 @@
+// Copyright 2013 Square, Inc.
+package retrofit.http.mime;
+
+import java.io.ByteArrayOutputStream;
+import org.junit.Test;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+
+public class FormUrlEncodingTypedOutputTest {
+  @Test public void urlEncoding() throws Exception {
+    FormUrlEncodedTypedOutput fe = new FormUrlEncodedTypedOutput();
+    fe.addPair("a&b", "c=d");
+    fe.addPair("space, the", "final frontier");
+
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    fe.writeTo(out);
+    String actual = new String(out.toByteArray(), "UTF-8");
+    assertThat(actual).isEqualTo("a%26b=c%3Dd&space%2C+the=final+frontier");
+  }
+
+  @Test public void utf8encoding() throws Exception {
+    FormUrlEncodedTypedOutput fe = new FormUrlEncodedTypedOutput();
+    fe.addPair("ooɟ", "ɹɐq");
+
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    fe.writeTo(out);
+    String actual = new String(out.toByteArray(), "UTF-8");
+    assertThat(actual).isEqualTo("oo%C9%9F=%C9%B9%C9%90q");
+  }
+
+  @Test public void encodedPairs() throws Exception {
+    FormUrlEncodedTypedOutput fe = new FormUrlEncodedTypedOutput();
+    fe.addPair("sim", "ple");
+
+    ByteArrayOutputStream out1 = new ByteArrayOutputStream();
+    fe.writeTo(out1);
+    String actual1 = new String(out1.toByteArray(), "UTF-8");
+    assertThat(actual1).isEqualTo("sim=ple");
+
+    fe.addPair("hey", "there");
+    fe.addPair("help", "me");
+
+    ByteArrayOutputStream out2 = new ByteArrayOutputStream();
+    fe.writeTo(out2);
+    String actual2 = new String(out2.toByteArray(), "UTF-8");
+    assertThat(actual2).isEqualTo("sim=ple&hey=there&help=me");
+  }
+}
diff --git a/retrofit/src/test/java/retrofit/http/mime/MimeHelper.java b/retrofit/src/test/java/retrofit/http/mime/MimeHelper.java
new file mode 100644
index 000000000..5840f1c09
--- /dev/null
+++ b/retrofit/src/test/java/retrofit/http/mime/MimeHelper.java
@@ -0,0 +1,10 @@
+// Copyright 2013 Square, Inc.
+package retrofit.http.mime;
+
+import java.util.List;
+
+public class MimeHelper {
+  public static List<byte[]> getParts(MultipartTypedOutput output) {
+    return output.parts;
+  }
+}
diff --git a/retrofit/src/test/java/retrofit/http/mime/MultipartTypedOutputTest.java b/retrofit/src/test/java/retrofit/http/mime/MultipartTypedOutputTest.java
new file mode 100644
index 000000000..67b03a6bf
--- /dev/null
+++ b/retrofit/src/test/java/retrofit/http/mime/MultipartTypedOutputTest.java
@@ -0,0 +1,67 @@
+// Copyright 2013 Square, Inc.
+package retrofit.http.mime;
+
+import java.io.ByteArrayOutputStream;
+import org.junit.Test;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+
+public class MultipartTypedOutputTest {
+  @Test public void singlePart() throws Exception {
+    String expected = "" //
+        + "--123\r\n"
+        + "Content-Disposition: form-data; name=\"greet\"\r\n"
+        + "Content-Type: text/plain; charset=UTF-8\r\n"
+        + "Content-Length: 13\r\n"
+        + "Content-Transfer-Encoding: binary\r\n" //
+        + "\r\n" //
+        + "Hello, World!\r\n" //
+        + "--123--";
+
+    MultipartTypedOutput mto = new MultipartTypedOutput("123");
+    mto.addPart("greet", new TypedString("Hello, World!"));
+
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    mto.writeTo(out);
+    String actual = new String(out.toByteArray(), "UTF-8");
+    assertThat(actual).isEqualTo(expected);
+    assertThat(mto.mimeType()).isEqualTo("multipart/form-data; boundary=123");
+  }
+
+  @Test public void threeParts() throws Exception {
+    String expected = ""
+        + "--123\r\n"
+        + "Content-Disposition: form-data; name=\"quick\"\r\n"
+        + "Content-Type: text/plain; charset=UTF-8\r\n"
+        + "Content-Length: 5\r\n"
+        + "Content-Transfer-Encoding: binary\r\n"
+        + "\r\n"
+        + "brown\r\n"
+        + "--123\r\n"
+        + "Content-Disposition: form-data; name=\"fox\"\r\n"
+        + "Content-Type: text/plain; charset=UTF-8\r\n"
+        + "Content-Length: 5\r\n"
+        + "Content-Transfer-Encoding: binary\r\n"
+        + "\r\n"
+        + "jumps\r\n"
+        + "--123\r\n"
+        + "Content-Disposition: form-data; name=\"lazy\"\r\n"
+        + "Content-Type: text/plain; charset=UTF-8\r\n"
+        + "Content-Length: 3\r\n"
+        + "Content-Transfer-Encoding: binary\r\n"
+        + "\r\n"
+        + "dog\r\n"
+        + "--123--";
+
+    MultipartTypedOutput mto = new MultipartTypedOutput("123");
+    mto.addPart("quick", new TypedString("brown"));
+    mto.addPart("fox", new TypedString("jumps"));
+    mto.addPart("lazy", new TypedString("dog"));
+
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    mto.writeTo(out);
+    String actual = new String(out.toByteArray(), "UTF-8");
+    assertThat(actual).isEqualTo(expected);
+    assertThat(mto.mimeType()).isEqualTo("multipart/form-data; boundary=123");
+  }
+}
diff --git a/samples/github-client/src/main/java/com/squareup/retrofit/sample/github/Client.java b/samples/github-client/src/main/java/com/squareup/retrofit/sample/github/Client.java
index aa1fdd4e9..56b155758 100644
--- a/samples/github-client/src/main/java/com/squareup/retrofit/sample/github/Client.java
+++ b/samples/github-client/src/main/java/com/squareup/retrofit/sample/github/Client.java
@@ -1,9 +1,23 @@
-// Copyright 2012 Square, Inc.
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package com.squareup.retrofit.sample.github;
 
 import java.util.List;
 import retrofit.http.GET;
-import retrofit.http.Name;
+import retrofit.http.Path;
 import retrofit.http.RestAdapter;
 
 public class Client {
@@ -17,8 +31,8 @@
   interface GitHub {
     @GET("/repos/{owner}/{repo}/contributors")
     List<Contributor> contributors(
-        @Name("owner") String owner,
-        @Name("repo") String repo
+        @Path("owner") String owner,
+        @Path("repo") String repo
     );
   }
 
