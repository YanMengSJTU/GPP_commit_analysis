diff --git a/retrofit/src/main/java/retrofit/http/Callback.java b/retrofit/src/main/java/retrofit/http/Callback.java
index 7b2a0ba10..28a556f22 100644
--- a/retrofit/src/main/java/retrofit/http/Callback.java
+++ b/retrofit/src/main/java/retrofit/http/Callback.java
@@ -1,6 +1,8 @@
 // Copyright 2012 Square, Inc.
 package retrofit.http;
 
+import retrofit.http.client.Response;
+
 /**
  * Communicates responses to server or offline requests. Contains a callback method for each
  * possible outcome. One and only one method will be invoked in response to a given request.
@@ -11,7 +13,7 @@
 public interface Callback<T> {
 
   /** Successful HTTP response. */
-  void success(T t);
+  void success(T t, Response response);
 
   /**
    * Unsuccessful HTTP response due to network failure, non-2XX status code, or unexpected
diff --git a/retrofit/src/main/java/retrofit/http/CallbackRunnable.java b/retrofit/src/main/java/retrofit/http/CallbackRunnable.java
index 626cdfe04..debfa2610 100644
--- a/retrofit/src/main/java/retrofit/http/CallbackRunnable.java
+++ b/retrofit/src/main/java/retrofit/http/CallbackRunnable.java
@@ -21,10 +21,10 @@
   @SuppressWarnings("unchecked")
   @Override public final void run() {
     try {
-      final Object response = obtainResponse();
+      final ResponseWrapper wrapper = obtainResponse();
       callbackExecutor.execute(new Runnable() {
         @Override public void run() {
-          callback.success((T) response);
+          callback.success((T) wrapper.responseBody, wrapper.response);
         }
       });
     } catch (final RetrofitError e) {
@@ -36,5 +36,5 @@
     }
   }
 
-  public abstract Object obtainResponse();
+  public abstract ResponseWrapper obtainResponse();
 }
diff --git a/retrofit/src/main/java/retrofit/http/GsonConverter.java b/retrofit/src/main/java/retrofit/http/GsonConverter.java
index ae032b3e6..a2372291b 100644
--- a/retrofit/src/main/java/retrofit/http/GsonConverter.java
+++ b/retrofit/src/main/java/retrofit/http/GsonConverter.java
@@ -11,8 +11,6 @@
 import retrofit.http.mime.TypedInput;
 import retrofit.http.mime.TypedOutput;
 
-import static retrofit.http.RestAdapter.UTF_8;
-
 /**
  * A {@link Converter} which uses GSON for serialization and deserialization of entities.
  *
@@ -26,9 +24,10 @@ public GsonConverter(Gson gson) {
   }
 
   @Override public Object fromBody(TypedInput body, Type type) throws ConversionException {
+    String charset = Utils.parseCharset(body.mimeType());
     InputStreamReader isr = null;
     try {
-      isr = new InputStreamReader(body.in(), UTF_8);
+      isr = new InputStreamReader(body.in(), charset);
       return gson.fromJson(isr, type);
     } catch (IOException e) {
       throw new ConversionException(e);
@@ -46,7 +45,7 @@ public GsonConverter(Gson gson) {
 
   @Override public TypedOutput toBody(Object object) {
     try {
-      return new JsonTypedOutput(gson.toJson(object).getBytes(UTF_8));
+      return new JsonTypedOutput(gson.toJson(object).getBytes("UTF-8"));
     } catch (UnsupportedEncodingException e) {
       throw new AssertionError(e);
     }
diff --git a/retrofit/src/main/java/retrofit/http/Parameter.java b/retrofit/src/main/java/retrofit/http/Parameter.java
index af25aee53..7812e7591 100644
--- a/retrofit/src/main/java/retrofit/http/Parameter.java
+++ b/retrofit/src/main/java/retrofit/http/Parameter.java
@@ -5,7 +5,7 @@
 
 /**
  * Represents a named parameter and its value.
- * <p/>
+ * <p>
  * This is used in one of three places in a request:
  * <ul>
  * <li>Named replacement in the relative URL path.
diff --git a/retrofit/src/main/java/retrofit/http/Profiler.java b/retrofit/src/main/java/retrofit/http/Profiler.java
index 4ede94a78..f1737906c 100644
--- a/retrofit/src/main/java/retrofit/http/Profiler.java
+++ b/retrofit/src/main/java/retrofit/http/Profiler.java
@@ -11,7 +11,7 @@
   /**
    * Invoked before an HTTP method call. The object returned by this method will be
    * passed to {@link #afterCall} when the call returns.
-   *
+   * <p>
    * This method gives implementors the opportunity to include information that may
    * change during the server call in {@code afterCall} logic.
    */
diff --git a/retrofit/src/main/java/retrofit/http/RequestBuilder.java b/retrofit/src/main/java/retrofit/http/RequestBuilder.java
index d73adcdd8..a7b849569 100644
--- a/retrofit/src/main/java/retrofit/http/RequestBuilder.java
+++ b/retrofit/src/main/java/retrofit/http/RequestBuilder.java
@@ -11,7 +11,6 @@
 import retrofit.http.mime.TypedOutput;
 import retrofit.http.mime.TypedString;
 
-import static retrofit.http.RestAdapter.UTF_8;
 import static retrofit.http.RestMethodInfo.NO_SINGLE_ENTITY;
 
 /**
@@ -156,7 +155,7 @@ Request build() {
 
   private static String getUrlEncodedValue(Parameter found) {
     try {
-      return URLEncoder.encode(String.valueOf(found.getValue()), UTF_8);
+      return URLEncoder.encode(String.valueOf(found.getValue()), "UTF-8");
     } catch (UnsupportedEncodingException e) {
       throw new AssertionError(e);
     }
diff --git a/retrofit/src/main/java/retrofit/http/ResponseWrapper.java b/retrofit/src/main/java/retrofit/http/ResponseWrapper.java
new file mode 100644
index 000000000..4be0b7822
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/http/ResponseWrapper.java
@@ -0,0 +1,20 @@
+package retrofit.http;
+
+import retrofit.http.client.Response;
+
+/**
+ * A wrapper that holds the {@link Response} and {@link Converter} response to be used by the
+ * {@link CallbackRunnable} for success method calls on {@link Callback}.
+ *
+ * @author JJ Ford (jj.n.ford@gmail.com)
+ */
+final class ResponseWrapper {
+
+  final Response response;
+  final Object responseBody;
+
+  public ResponseWrapper(Response response, Object responseBody) {
+    this.response = response;
+    this.responseBody = responseBody;
+  }
+}
diff --git a/retrofit/src/main/java/retrofit/http/RestAdapter.java b/retrofit/src/main/java/retrofit/http/RestAdapter.java
index a543af4d0..5679631b7 100644
--- a/retrofit/src/main/java/retrofit/http/RestAdapter.java
+++ b/retrofit/src/main/java/retrofit/http/RestAdapter.java
@@ -8,13 +8,11 @@
 import java.lang.reflect.Proxy;
 import java.lang.reflect.Type;
 import java.util.LinkedHashMap;
-import java.util.List;
 import java.util.Map;
 import java.util.concurrent.Executor;
 import java.util.concurrent.TimeUnit;
 import java.util.logging.Level;
 import java.util.logging.Logger;
-import org.apache.http.protocol.HTTP;
 import retrofit.http.Profiler.RequestInformation;
 import retrofit.http.client.Client;
 import retrofit.http.client.Request;
@@ -35,7 +33,6 @@
   private static final Logger LOGGER = Logger.getLogger(RestAdapter.class.getName());
   private static final int LOG_CHUNK_SIZE = 4000;
   static final String THREAD_PREFIX = "Retrofit-";
-  static final String UTF_8 = "UTF-8";
 
   private final Server server;
   private final Client.Provider clientProvider;
@@ -58,11 +55,11 @@ private RestAdapter(Server server, Client.Provider clientProvider, Executor http
 
   /**
    * Adapts a Java interface to a REST API.
-   * <p/>
+   * <p>
    * The relative path for a given method is obtained from an annotation on the method describing
    * the request type. The names of URL parameters are retrieved from {@link Name}
    * annotations on the method parameters.
-   * <p/>
+   * <p>
    * HTTP requests happen in one of two ways:
    * <ul>
    * <li>On the provided HTTP {@link Executor} with callbacks marshaled to the callback
@@ -74,7 +71,7 @@ private RestAdapter(Server server, Client.Provider clientProvider, Executor http
    * response will be converted to the method's return type using the specified
    * {@link Converter}.</li>
    * </ul>
-   * <p/>
+   * <p>
    * For example:
    * <pre>
    *   public interface MyApi {
@@ -128,8 +125,8 @@ private RestAdapter(Server server, Client.Provider clientProvider, Executor http
       }
       Callback<?> callback = (Callback<?>) args[args.length - 1];
       httpExecutor.execute(new CallbackRunnable(callback, callbackExecutor) {
-        @Override public Object obtainResponse() {
-          return invokeRequest(methodDetails, args);
+        @Override public ResponseWrapper obtainResponse() {
+          return (ResponseWrapper) invokeRequest(methodDetails, args);
         }
       });
       return null; // Asynchronous methods should have return type of void.
@@ -184,24 +181,23 @@ private Object invokeRequest(RestMethodInfo methodDetails, Object[] args) {
           body = logResponse(url, response.getStatus(), body, elapsedTime);
         }
 
-        List<Header> headers = response.getHeaders();
-        for (Header header : headers) {
-          if (HTTP.CONTENT_TYPE.equalsIgnoreCase(header.getName()) //
-              && !UTF_8.equalsIgnoreCase(Utils.parseCharset(header.getValue()))) {
-            throw new IOException("Only UTF-8 charset supported.");
-          }
-        }
-
         Type type = methodDetails.type;
         if (statusCode >= 200 && statusCode < 300) { // 2XX == successful request
           if (type.equals(Response.class)) {
-            return response;
+            if (methodDetails.isSynchronous) {
+              return response;
+            }
+            return new ResponseWrapper(response, response);
           }
           if (body == null) {
             return null;
           }
           try {
-            return converter.fromBody(body, type);
+            Object convert = converter.fromBody(body, type);
+            if (methodDetails.isSynchronous) {
+              return convert;
+            }
+            return new ResponseWrapper(response, convert);
           } catch (ConversionException e) {
             throw RetrofitError.conversionError(url, response, converter, type, e);
           }
@@ -231,7 +227,8 @@ private static TypedInput logResponse(String url, int statusCode, TypedInput bod
     LOGGER.fine("<--- HTTP " + statusCode + " " + url + " (" + elapsedTime + "ms)");
 
     byte[] bodyBytes = Utils.streamToBytes(body.in());
-    String bodyString = new String(bodyBytes, UTF_8);
+    String bodyCharset = Utils.parseCharset(body.mimeType());
+    String bodyString = new String(bodyBytes, bodyCharset);
     for (int i = 0; i < bodyString.length(); i += LOG_CHUNK_SIZE) {
       int end = Math.min(bodyString.length(), i + LOG_CHUNK_SIZE);
       LOGGER.fine(bodyString.substring(i, end));
@@ -260,13 +257,14 @@ private static TypedInput logResponse(String url, int statusCode, TypedInput bod
 
   /**
    * Build a new {@link RestAdapter}.
-   * <p/>
+   * <p>
    * Calling the following methods is required before calling {@link #build()}:
    * <ul>
    * <li>{@link #setServer(Server)}</li>
    * <li>{@link #setClient(Client.Provider)}</li>
    * <li>{@link #setConverter(Converter)}</li>
    * </ul>
+   * <p>
    * If you are using asynchronous execution (i.e., with {@link Callback Callbacks}) the following
    * is also required:
    * <ul>
diff --git a/retrofit/src/main/java/retrofit/http/Utils.java b/retrofit/src/main/java/retrofit/http/Utils.java
index c5d89a649..c989e34b1 100644
--- a/retrofit/src/main/java/retrofit/http/Utils.java
+++ b/retrofit/src/main/java/retrofit/http/Utils.java
@@ -11,9 +11,8 @@
 import java.util.regex.Pattern;
 
 import static java.util.regex.Pattern.CASE_INSENSITIVE;
-import static retrofit.http.RestAdapter.UTF_8;
 
-final class Utils {
+public final class Utils {
   private static final Pattern CHARSET = Pattern.compile("\\Wcharset=([^\\s;]+)", CASE_INSENSITIVE);
   private static final int BUFFER_SIZE = 0x1000;
 
@@ -75,12 +74,12 @@ static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResol
     return toResolve;
   }
 
-  static String parseCharset(String mimeType) {
+  public static String parseCharset(String mimeType) {
     Matcher match = CHARSET.matcher(mimeType);
     if (match.find()) {
       return match.group(1).replaceAll("[\"\\\\]", "");
     }
-    return UTF_8;
+    return "UTF-8";
   }
 
   static class SynchronousExecutor implements Executor {
@@ -88,4 +87,8 @@ static String parseCharset(String mimeType) {
       runnable.run();
     }
   }
+
+  private Utils() {
+    // No instances.
+  }
 }
\ No newline at end of file
diff --git a/retrofit/src/main/java/retrofit/http/client/ApacheClient.java b/retrofit/src/main/java/retrofit/http/client/ApacheClient.java
index eb6ddafd8..01ffa7994 100644
--- a/retrofit/src/main/java/retrofit/http/client/ApacheClient.java
+++ b/retrofit/src/main/java/retrofit/http/client/ApacheClient.java
@@ -18,7 +18,6 @@
 import org.apache.http.entity.AbstractHttpEntity;
 import org.apache.http.impl.client.DefaultHttpClient;
 import org.apache.http.message.BasicHeader;
-import org.apache.http.protocol.HTTP;
 import org.apache.http.util.EntityUtils;
 import retrofit.http.Header;
 import retrofit.http.mime.TypedByteArray;
@@ -67,11 +66,11 @@ static Response parseResponse(HttpResponse response) throws IOException {
     String reason = statusLine.getReasonPhrase();
 
     List<Header> headers = new ArrayList<Header>();
-    String contentType = HTTP.OCTET_STREAM_TYPE;
+    String contentType = "application/octet-stream";
     for (org.apache.http.Header header : response.getAllHeaders()) {
       String name = header.getName();
       String value = header.getValue();
-      if (name.equalsIgnoreCase(HTTP.CONTENT_TYPE)) {
+      if ("Content-Type".equalsIgnoreCase(name)) {
         contentType = value;
       }
       headers.add(new Header(name, value));
diff --git a/retrofit/src/test/java/retrofit/http/CallbackRunnableTest.java b/retrofit/src/test/java/retrofit/http/CallbackRunnableTest.java
index bfc46c949..225fed34e 100644
--- a/retrofit/src/test/java/retrofit/http/CallbackRunnableTest.java
+++ b/retrofit/src/test/java/retrofit/http/CallbackRunnableTest.java
@@ -21,20 +21,20 @@
   @Before public void setUp() {
     callback = mock(Callback.class);
     callbackRunnable = spy(new CallbackRunnable<Object>(callback, executor) {
-      @Override public Object obtainResponse() {
+      @Override public ResponseWrapper obtainResponse() {
         return null; // Must be mocked.
       }
     });
   }
 
   @Test public void responsePassedToSuccess() {
-    Object response = new Object();
-    when(callbackRunnable.obtainResponse()).thenReturn(response);
+    ResponseWrapper wrapper = new ResponseWrapper(null, new Object());
+    when(callbackRunnable.obtainResponse()).thenReturn(wrapper);
 
     callbackRunnable.run();
 
     verify(executor).execute(any(Runnable.class));
-    verify(callback).success(same(response));
+    verify(callback).success(same(wrapper.responseBody), same(wrapper.response));
   }
 
   @Test public void errorPassedToFailure() {
diff --git a/retrofit/src/test/java/retrofit/http/RestAdapterTest.java b/retrofit/src/test/java/retrofit/http/RestAdapterTest.java
index aeae442e5..089288aaf 100644
--- a/retrofit/src/test/java/retrofit/http/RestAdapterTest.java
+++ b/retrofit/src/test/java/retrofit/http/RestAdapterTest.java
@@ -16,6 +16,7 @@
 import static org.fest.assertions.api.Assertions.fail;
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.anyString;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Matchers.same;
 import static org.mockito.Mockito.mock;
@@ -88,15 +89,16 @@
   }
 
   @Test public void asynchronousUsesExecutors() throws Exception {
+    Response response = new Response(200, "OK", NO_HEADERS, new TypedString("{}"));
     when(mockClient.execute(any(Request.class))) //
-        .thenReturn(new Response(200, "OK", NO_HEADERS, null));
+        .thenReturn(response);
     Callback<Object> callback = mock(Callback.class);
 
     example.something(callback);
 
     verify(mockRequestExecutor).execute(any(CallbackRunnable.class));
     verify(mockCallbackExecutor).execute(any(Runnable.class));
-    verify(callback).success(eq(null));
+    verify(callback).success(anyString(), same(response));
   }
 
   @Test public void malformedResponseThrowsConversionException() throws Exception {
@@ -166,6 +168,6 @@
 
     verify(mockRequestExecutor).execute(any(CallbackRunnable.class));
     verify(mockCallbackExecutor).execute(any(Runnable.class));
-    verify(callback).success(eq(response));
+    verify(callback).success(eq(response), same(response));
   }
 }
diff --git a/retrofit/src/test/java/retrofit/http/UtilsTest.java b/retrofit/src/test/java/retrofit/http/UtilsTest.java
index a81347f37..5176f0230 100644
--- a/retrofit/src/test/java/retrofit/http/UtilsTest.java
+++ b/retrofit/src/test/java/retrofit/http/UtilsTest.java
@@ -4,21 +4,20 @@
 import org.junit.Test;
 
 import static org.fest.assertions.api.Assertions.assertThat;
-import static retrofit.http.RestAdapter.UTF_8;
 import static retrofit.http.Utils.parseCharset;
 
 public class UtilsTest {
   @Test public void charsetParsing() {
-    assertThat(parseCharset("text/plain;charset=utf-8")).isEqualToIgnoringCase(UTF_8);
-    assertThat(parseCharset("text/plain; charset=utf-8")).isEqualToIgnoringCase(UTF_8);
-    assertThat(parseCharset("text/plain;  charset=utf-8")).isEqualToIgnoringCase(UTF_8);
-    assertThat(parseCharset("text/plain; \tcharset=utf-8")).isEqualToIgnoringCase(UTF_8);
-    assertThat(parseCharset("text/plain; \r\n\tcharset=utf-8")).isEqualToIgnoringCase(UTF_8);
-    assertThat(parseCharset("text/plain; CHARSET=utf-8")).isEqualToIgnoringCase(UTF_8);
-    assertThat(parseCharset("text/plain; charset=UTF-8")).isEqualToIgnoringCase(UTF_8);
-    assertThat(parseCharset("text/plain; charset=\"\\u\\tf-\\8\"")).isEqualToIgnoringCase(UTF_8);
-    assertThat(parseCharset("text/plain; charset=\"utf-8\"")).isEqualToIgnoringCase(UTF_8);
-    assertThat(parseCharset("text/plain; charset=utf-8; other=thing")).isEqualToIgnoringCase(UTF_8);
-    assertThat(parseCharset("text/plain; notthecharset=utf-16;")).isEqualToIgnoringCase(UTF_8);
+    assertThat(parseCharset("text/plain;charset=utf-8")).isEqualToIgnoringCase("UTF-8");
+    assertThat(parseCharset("text/plain; charset=utf-8")).isEqualToIgnoringCase("UTF-8");
+    assertThat(parseCharset("text/plain;  charset=utf-8")).isEqualToIgnoringCase("UTF-8");
+    assertThat(parseCharset("text/plain; \tcharset=utf-8")).isEqualToIgnoringCase("UTF-8");
+    assertThat(parseCharset("text/plain; \r\n\tcharset=utf-8")).isEqualToIgnoringCase("UTF-8");
+    assertThat(parseCharset("text/plain; CHARSET=utf-8")).isEqualToIgnoringCase("UTF-8");
+    assertThat(parseCharset("text/plain; charset=UTF-8")).isEqualToIgnoringCase("UTF-8");
+    assertThat(parseCharset("text/plain; charset=\"\\u\\tf-\\8\"")).isEqualToIgnoringCase("UTF-8");
+    assertThat(parseCharset("text/plain; charset=\"utf-8\"")).isEqualToIgnoringCase("UTF-8");
+    assertThat(parseCharset("text/plain;charset=utf-8;other=thing")).isEqualToIgnoringCase("UTF-8");
+    assertThat(parseCharset("text/plain; notthecharset=utf-16;")).isEqualToIgnoringCase("UTF-8");
   }
 }
