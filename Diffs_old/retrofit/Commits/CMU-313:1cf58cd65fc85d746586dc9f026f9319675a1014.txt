diff --git a/retrofit/src/main/java/retrofit/Call.java b/retrofit/src/main/java/retrofit/Call.java
index 013da06a9..a2b1afbdd 100644
--- a/retrofit/src/main/java/retrofit/Call.java
+++ b/retrofit/src/main/java/retrofit/Call.java
@@ -1,7 +1,6 @@
 // Copyright 2013 Square, Inc.
 package retrofit;
 
-import java.util.concurrent.Callable;
 import java.util.concurrent.Executor;
 
 /**
@@ -9,61 +8,58 @@
  */
 public class Call<T> {
 
-	// RestHandler that created this Call<T> and that will carry out the actual
-	// request
-	private RestAdapter.RestHandler handler;
-
-	// Interceptor to call invokeRequest() with
-	private RequestInterceptor interceptor;
-
-	// RestMethodInfo to call invokeRequest() with
-	private RestMethodInfo methodInfo;
-
-	// Object[] to call invokeRequest() with
-	private Object[] args;
-
-	// Executor for HTTP requests
-	private Executor httpExecutor;
-
-	// Scheduled asynchronous execute() call
-	private ScheduledFuture<?> future;
+	private final RestAdapter.RestHandler handler;
+	private final RequestInterceptor interceptor;
+	private final RestMethodInfo methodInfo;
+	private final Object[] args;
+	private final Executor httpExecutor;
 
 	/**
-	 * Constructor
+	 * 
+	 * @param handler RestHandler that created this Call<T> and 
+	 * that will carry out the actual request.
+	 * @param interceptor Interceptor to call invokeRequest() with.
+	 * @param methodInfo RestMethodInfo to call invokeRequest() with.
+	 * @param args Object[] to call invokeRequest() with.
+	 * @param httpExecutor Executor for HTTP requests.
 	 */
-	public Call(RestAdapter.RestHandler handler, RequestInterceptor interceptor,
-		RestMethodInfo methodInfo, Object[] args, Executor httpExecutor)
-	{
+	public Call(RestAdapter.RestHandler handler,
+			RequestInterceptor interceptor, RestMethodInfo methodInfo,
+			Object[] args, Executor httpExecutor) {
 		this.handler = handler;
 		this.interceptor = interceptor;
 		this.methodInfo = methodInfo;
+		this.args = args;
 		this.httpExecutor = httpExecutor;
-		this.future = null;
 	}
 
 	/**
-	 * Execute immediately
+	 * Execute the request synchronously.
+	 * @return the request's response of type T
 	 */
+	@SuppressWarnings("unchecked")
 	public T execute() {
-		return (T)handler.invokeRequest(interceptor, methodInfo, args);
+		return (T) handler.invokeRequest(interceptor, methodInfo, args);
 	}
 
 	/**
-	 * Execute with a (API 2.0) callback
+	 * Execute the request asynchronously with a (API 2.0) callback.
+	 * @param callback (API 2.0) Callback2 to process the request with. 
+	 * @return Asynchronous execute() return void. 
 	 */
 	public void execute(final Callback2<T> callback) {
 		// Not handling the interceptor or observable for now. The synchronous
 		// version of RestHandler.invoke() does not handle this either.
 
-		future = httpExecutor.schedule(new Runnable() {
+		httpExecutor.execute(new Runnable() {
+			@SuppressWarnings("unchecked")
 			@Override
 			public void run() {
 				T response;
 
 				try {
-					response = (T)handler.invokeRequest(interceptor, methodInfo, args);
-				}
-				catch (RetrofitError err) {
+					response = (T) handler.invokeRequest(interceptor, methodInfo, args);
+				} catch (RetrofitError err) {
 					callback.failure(err);
 					return;
 				}
diff --git a/retrofit/src/main/java/retrofit/RestAdapter.java b/retrofit/src/main/java/retrofit/RestAdapter.java
index 6543aa154..449ca04db 100644
--- a/retrofit/src/main/java/retrofit/RestAdapter.java
+++ b/retrofit/src/main/java/retrofit/RestAdapter.java
@@ -29,6 +29,7 @@
 import java.util.concurrent.Callable;
 import java.util.concurrent.Executor;
 import java.util.concurrent.TimeUnit;
+
 import retrofit.Profiler.RequestInformation;
 import retrofit.client.Client;
 import retrofit.client.Header;
@@ -279,21 +280,9 @@ Observable createRequestObservable(final Callable<ResponseWrapper> request) {
 
       // Load or create the details cache for the current method.
       final RestMethodInfo methodInfo = getMethodInfo(methodDetailsCache, method);
-
-      // Check if the method returns a Call<T>
-      if (methodInfo.responseObjectType instanceof ParameterizedType) {
-        ParameterizedType parameterized = (ParameterizedType)methodInfo.responseObjectType;
-        Type rawType = parameterized.getRawType();
-
-        if (rawType.equals(Call.class)) {
-          if (parameterized.getActualTypeArguments().length != 1)
-            throw new IllegalArgumentException("Call must have a generic argument type");
-
-          // Instantiate the Call<T> with its constructor
-          Constructor<Call> cons = Call.class.getDeclaredConstructor(RestAdapter.RestHandler.class,
-            RequestInterceptor.class, RestMethodInfo.class, Object[].class, Executor.class);
-          return cons.newInstance(this, requestInterceptor, methodInfo, args, httpExecutor);
-        }
+      
+      if(methodInfo.isCallable) {
+    	return new Call(this, requestInterceptor, methodInfo, args, httpExecutor); 
       }
 
       if (methodInfo.isSynchronous) {
@@ -392,15 +381,9 @@ Object invokeRequest(RequestInterceptor requestInterceptor,
 
         // Check if the method returns a Call<T>, and if so use its generic
         // argument as the request return type
-        if (methodInfo.responseObjectType instanceof ParameterizedType) {
-          ParameterizedType parameterized = (ParameterizedType)methodInfo.responseObjectType;
-          Type rawType = parameterized.getRawType();
-
-          if (rawType.equals(Call.class)) {
-            type = parameterized.getActualTypeArguments()[0];
-            System.out.print(" --> ");
-            System.out.println(type);
-          }
+        if (methodInfo.isCallable) {
+          ParameterizedType pt = (ParameterizedType)methodInfo.responseObjectType;
+          type = pt.getActualTypeArguments()[0];
         }
 
         if (statusCode >= 200 && statusCode < 300) { // 2XX == successful request
diff --git a/retrofit/src/main/java/retrofit/RestMethodInfo.java b/retrofit/src/main/java/retrofit/RestMethodInfo.java
index cd0957e55..2c9ec5a93 100644
--- a/retrofit/src/main/java/retrofit/RestMethodInfo.java
+++ b/retrofit/src/main/java/retrofit/RestMethodInfo.java
@@ -75,6 +75,7 @@
   final ResponseType responseType;
   final boolean isSynchronous;
   final boolean isObservable;
+  final boolean isCallable; //Of type Call<T>.
   Type responseObjectType;
   RequestType requestType = RequestType.SIMPLE;
   String requestMethod;
@@ -93,6 +94,7 @@
     responseType = parseResponseType();
     isSynchronous = (responseType == ResponseType.OBJECT);
     isObservable = (responseType == ResponseType.OBSERVABLE);
+    isCallable = (Types.getRawType(responseObjectType) == Call.class);
   }
 
   synchronized void init() {
@@ -271,13 +273,14 @@ private ResponseType parseResponseType() {
 
     if (hasReturnType) {
       if (Platform.HAS_RX_JAVA) {
-        Class rawReturnType = Types.getRawType(returnType);
+    	Class rawReturnType = Types.getRawType(returnType);
         if (rawReturnType == Observable.class) {
           returnType = Types.getSupertype(returnType, rawReturnType, Observable.class);
           responseObjectType = getParameterUpperBound((ParameterizedType) returnType);
           return ResponseType.OBSERVABLE;
         }
       }
+      
       responseObjectType = returnType;
       return ResponseType.OBJECT;
     }
diff --git a/retrofit/src/test/java/retrofit/CallTest.java b/retrofit/src/test/java/retrofit/CallTest.java
index 5f1661e19..a3f86a14d 100644
--- a/retrofit/src/test/java/retrofit/CallTest.java
+++ b/retrofit/src/test/java/retrofit/CallTest.java
@@ -1,82 +1,33 @@
 // Copyright 2013 Square, Inc.
 package retrofit;
 
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.ArrayList;
-import java.util.Arrays;
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
 import java.util.Collections;
 import java.util.List;
 import java.util.concurrent.Executor;
+
 import org.junit.Before;
 import org.junit.Test;
-import org.mockito.ArgumentCaptor;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
+
+import retrofit.Utils.SynchronousExecutor;
 import retrofit.client.Client;
 import retrofit.client.Header;
 import retrofit.client.Request;
 import retrofit.client.Response;
-import retrofit.converter.ConversionException;
-import retrofit.http.Body;
 import retrofit.http.GET;
-import retrofit.http.Headers;
-import retrofit.http.POST;
-import retrofit.http.Path;
-import retrofit.mime.TypedInput;
-import retrofit.mime.TypedOutput;
 import retrofit.mime.TypedString;
-import rx.Observable;
-import rx.util.functions.Action1;
 
-import static org.junit.Assert.*;
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.fest.assertions.api.Assertions.fail;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.anyString;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Matchers.isA;
-import static org.mockito.Matchers.same;
-import static org.mockito.Mockito.atLeastOnce;
-import static org.mockito.Mockito.doReturn;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.spy;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.verifyZeroInteractions;
-import static org.mockito.Mockito.when;
-import static retrofit.Profiler.RequestInformation;
-import static retrofit.RestAdapter.LogLevel.BASIC;
-import static retrofit.RestAdapter.LogLevel.FULL;
-import static retrofit.RestAdapter.LogLevel.HEADERS;
-import static retrofit.Utils.SynchronousExecutor;
-
-/**
- * Example of the Call object behavior. Not a working test.
- */
 public class CallTest {
 
 	private static final List<Header> NO_HEADERS = Collections.emptyList();
-  	private static final List<Header> TWO_HEADERS =
-      Arrays.asList(new Header("Content-Type", "application/json"),
-          new Header("Content-Length", "42"));
-
-	/** Not all servers play nice and add content-type headers to responses. */
-	private static final TypedInput NO_MIME_BODY = new TypedInput() {
-		@Override public String mimeType() {
-		  return null;
-		}
-
-		@Override public long length() {
-		  return 2;
-		}
-
-		@Override public InputStream in() throws IOException {
-		  return new ByteArrayInputStream("{}".getBytes("UTF-8"));
-		}
-	};
-
+	
 	private interface Api {
 		@GET("/")
 		Call<String> something();
@@ -87,7 +38,6 @@
 	private Executor mockCallbackExecutor;
 	private Api api;
 
-	@SuppressWarnings("unchecked") // Mock profiler type erasure.
 	@Before public void setUp() throws Exception {
 		mockClient = mock(Client.class);
 		mockRequestExecutor = spy(new SynchronousExecutor());
@@ -102,7 +52,7 @@
 	}
 
 	@Test public void synchronousTest() throws Exception {
-		when(mockClient.execute(any(Request.class))) //
+		when(mockClient.execute(any(Request.class)))
         	.thenReturn(new Response(200, "OK", NO_HEADERS, new TypedString("Hello")));
 
 		Call<String> c = api.something();
@@ -111,8 +61,9 @@
 		assertEquals(result, "Hello");
 	}
 
+	@SuppressWarnings("unchecked")
 	@Test public void asyncTest() throws Exception {
-		when(mockClient.execute(any(Request.class))) //
+		when(mockClient.execute(any(Request.class)))
         	.thenReturn(new Response(200, "OK", NO_HEADERS, new TypedString("Hello")));
 
 		Call<String> c = api.something();
