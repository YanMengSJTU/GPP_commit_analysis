diff --git a/.travis.yml b/.travis.yml
index 79fe36a95..d5b32858e 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -3,6 +3,10 @@ language: java
 jdk:
   - oraclejdk8
 
+# Ensure Javadoc and source jar generation is exercised.
+install: mvn install javadoc:jar source:jar -DskipTests=true -B -V
+script: mvn test -B
+
 after_success:
   - .buildscript/deploy_snapshot.sh
 
@@ -18,8 +22,6 @@ branches:
 notifications:
   email: false
 
-sudo: false
-
 cache:
   directories:
     - $HOME/.m2
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 7b8d177c6..4a4492fe4 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,6 +1,40 @@
 Change Log
 ==========
 
+Version 2.5.0 *(2018-11-18)*
+----------------------------
+
+ * New: Built-in support for Kotlin's `Unit` type. This behaves the same as Java's `Void` where the body
+   content is ignored and immediately discarded.
+ * New: Built-in support for Java 8's `Optional` and `CompletableFuture` types. Previously the 'converter-java8'
+   and 'adapter-java8' dependencies were needed and explicitly adding `Java8OptionalConverterFactory` and/or
+   `Java8CallAdapterFactory` to your `Retrofit.Builder` in order to use these types. Support is now built-in and
+   those types and their artifacts are marked as deprecated.
+ * New: `Invocation` class provides a reference to the invoked method and argument list as a tag on the
+   underlying OkHttp `Call`. This can be accessed from an OkHttp interceptor for things like logging, analytics,
+   or metrics aggregation.
+ * New: Kotlin extension for `Retrofit` which allows you call `create` passing the interface type only as
+   a generic parameter (e.g., `retrofit.create<MyService>()`).
+ * New: Added `Response.success` overload which allows specifying a custom 2xx status code.
+ * New: Added `Calls.failure` overload which allows passing any `Throwable` subtype.
+ * New: Minimal R8 rules now ship inside the jar requiring no client configuration in the common case.
+ * Fix: Do not propagate fatal errors to the callback. They are sent to the thread's uncaught
+   exception handler.
+ * Fix: Do not enqueue/execute an otherwise useless call when the RxJava type is disposed by `onSubscribe`.
+ * Fix: Call `RxJavaPlugins` assembly hook when creating an RxJava 2 type.
+ * Fix: Ensure both the Guava and Java 8 `Optional` converters delegate properly. This ensures that converters
+   registered prior to the optional converter can be used for deserializing the body type.
+ * Fix: Prevent `@Path` values from participating in path-traversal. This ensures untrusted input passed as
+   a path value cannot cause you to make a request to an un-intended relative URL.
+ * Fix: Simple XML converter (which is deprecated) no longer wraps subtypes of `RuntimeException`
+   or `IOException` when it fails.
+ * Fix: Prevent JAXB converter from loading remote entities and DTDs.
+ * Fix: Correctly detect default methods in interfaces on Android (API 24+). These still do not work, but
+   now a correct exception will be thrown when detected.
+ * Fix: Report more accurate exceptions when a `@QueryName` or `@QueryMap` precedes a `@Url` parameter.
+ * Update OkHttp dependency to 3.12.
+
+
 Version 2.4.0 *(2018-03-14)*
 ----------------------------
 
diff --git a/README.md b/README.md
index 5b30970a6..74d6a26f2 100644
--- a/README.md
+++ b/README.md
@@ -9,18 +9,7 @@ For more information please see [the website][1].
 Download
 --------
 
-Download [the latest JAR][2] or grab via Maven:
-```xml
-<dependency>
-  <groupId>com.squareup.retrofit2</groupId>
-  <artifactId>retrofit</artifactId>
-  <version>2.4.0</version>
-</dependency>
-```
-or Gradle:
-```groovy
-implementation 'com.squareup.retrofit2:retrofit:2.4.0'
-```
+Download [the latest JAR][2] or grab from Maven central at the coordinates `com.squareup.retrofit2:retrofit:2.5.0`.
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
 
@@ -30,10 +19,11 @@ Retrofit requires at minimum Java 7 or Android 2.3.
 R8 / ProGuard
 -------------
 
-If you are using R8 or ProGuard add the options from
-[this file](https://github.com/square/retrofit/blob/master/retrofit/src/main/resources/META-INF/proguard/retrofit2.pro).
+If you are using R8 the shrinking and obfuscation rules are included automatically.
 
-You might also need rules for OkHttp and Okio which are dependencies of this library.
+ProGuard users must manually add the options from
+[this file](https://github.com/square/retrofit/blob/master/retrofit/src/main/resources/META-INF/proguard/retrofit2.pro).
+(Note: You might also need rules for OkHttp and Okio which are dependencies of this library)
 
 
 License
diff --git a/pom.xml b/pom.xml
index a389b655c..5779d6d7d 100644
--- a/pom.xml
+++ b/pom.xml
@@ -25,7 +25,7 @@
 
   <groupId>com.squareup.retrofit2</groupId>
   <artifactId>parent</artifactId>
-  <version>2.4.1-SNAPSHOT</version>
+  <version>2.6.0-SNAPSHOT</version>
   <packaging>pom</packaging>
 
   <name>Retrofit (Parent)</name>
@@ -46,10 +46,12 @@
 
     <!-- Compilation -->
     <java.version>1.7</java.version>
+    <kotlin.version>1.3.10</kotlin.version>
 
     <!-- Dependencies -->
     <android.version>4.1.1.4</android.version>
-    <okhttp.version>3.10.0</okhttp.version>
+    <okhttp.version>3.12.0</okhttp.version>
+    <kotlinx.coroutines.version>1.1.0</kotlinx.coroutines.version>
     <animal.sniffer.version>1.14</animal.sniffer.version>
 
     <!-- Adapter Dependencies -->
@@ -59,12 +61,12 @@
     <scala.version>2.12.4</scala.version>
 
     <!-- Converter Dependencies -->
-    <gson.version>2.8.2</gson.version>
-    <protobuf.version>3.0.0</protobuf.version>
-    <jackson.version>2.9.4</jackson.version>
+    <gson.version>2.8.5</gson.version>
+    <protobuf.version>3.5.0</protobuf.version>
+    <jackson.version>2.9.8</jackson.version>
     <wire.version>2.2.0</wire.version>
     <simplexml.version>2.7.1</simplexml.version>
-    <moshi.version>1.5.0</moshi.version>
+    <moshi.version>1.8.0</moshi.version>
     <jaxb.version>2.2.12</jaxb.version><!-- 2.3.0 breaks due to https://github.com/mojohaus/animal-sniffer/issues/29 -->
 
     <!-- Sample Dependencies -->
@@ -73,8 +75,7 @@
     <!-- Test Dependencies -->
     <junit.version>4.12</junit.version>
     <assertj.version>1.7.0</assertj.version>
-    <mockito.version>1.9.5</mockito.version>
-    <robolectric.version>3.0</robolectric.version>
+    <robolectric.version>3.8</robolectric.version>
   </properties>
 
   <scm>
@@ -108,6 +109,16 @@
         <artifactId>android</artifactId>
         <version>${android.version}</version>
       </dependency>
+      <dependency>
+        <groupId>org.jetbrains.kotlin</groupId>
+        <artifactId>kotlin-stdlib</artifactId>
+        <version>${kotlin.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>org.jetbrains.kotlinx</groupId>
+        <artifactId>kotlinx-coroutines-core</artifactId>
+        <version>${kotlinx.coroutines.version}</version>
+      </dependency>
       <dependency>
         <groupId>org.codehaus.mojo</groupId>
         <artifactId>animal-sniffer-annotations</artifactId>
@@ -183,11 +194,6 @@
         <artifactId>assertj-core</artifactId>
         <version>${assertj.version}</version>
       </dependency>
-      <dependency>
-        <groupId>org.mockito</groupId>
-        <artifactId>mockito-core</artifactId>
-        <version>${mockito.version}</version>
-      </dependency>
       <dependency>
         <groupId>com.google.guava</groupId>
         <artifactId>guava</artifactId>
@@ -209,6 +215,11 @@
   <build>
     <pluginManagement>
       <plugins>
+        <plugin>
+          <groupId>org.jetbrains.kotlin</groupId>
+          <artifactId>kotlin-maven-plugin</artifactId>
+          <version>${kotlin.version}</version>
+        </plugin>
         <plugin>
           <groupId>org.apache.maven.plugins</groupId>
           <artifactId>maven-compiler-plugin</artifactId>
diff --git a/retrofit-adapters/guava/README.md b/retrofit-adapters/guava/README.md
index b1449e80e..c2c3badfa 100644
--- a/retrofit-adapters/guava/README.md
+++ b/retrofit-adapters/guava/README.md
@@ -37,7 +37,7 @@ Download [the latest JAR][2] or grab via [Maven][3]:
 ```
 or [Gradle][3]:
 ```groovy
-compile 'com.squareup.retrofit2:adapter-guava:latest.version'
+implementation 'com.squareup.retrofit2:adapter-guava:latest.version'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/retrofit-adapters/guava/pom.xml b/retrofit-adapters/guava/pom.xml
index 98f9f531b..074b15d90 100644
--- a/retrofit-adapters/guava/pom.xml
+++ b/retrofit-adapters/guava/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-adapters</artifactId>
-    <version>2.4.1-SNAPSHOT</version>
+    <version>2.6.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
diff --git a/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/GuavaCallAdapterFactory.java b/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/GuavaCallAdapterFactory.java
index 64dd0f5ad..046bf3450 100644
--- a/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/GuavaCallAdapterFactory.java
+++ b/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/GuavaCallAdapterFactory.java
@@ -21,6 +21,7 @@
 import java.lang.annotation.Annotation;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
+import javax.annotation.Nullable;
 import retrofit2.Call;
 import retrofit2.CallAdapter;
 import retrofit2.Callback;
@@ -56,8 +57,8 @@ public static GuavaCallAdapterFactory create() {
   private GuavaCallAdapterFactory() {
   }
 
-  @Override
-  public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+  @Override public @Nullable CallAdapter<?, ?> get(
+      Type returnType, Annotation[] annotations, Retrofit retrofit) {
     if (getRawType(returnType) != ListenableFuture.class) {
       return null;
     }
diff --git a/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/package-info.java b/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/package-info.java
index 7943d1191..1866bbf30 100644
--- a/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/package-info.java
+++ b/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/package-info.java
@@ -1,4 +1,2 @@
-@ParametersAreNonnullByDefault
+@retrofit2.internal.EverythingIsNonNull
 package retrofit2.adapter.guava;
-
-import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/StringConverterFactory.java b/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/StringConverterFactory.java
index bb9ccf189..f56fcf63a 100644
--- a/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/StringConverterFactory.java
+++ b/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/StringConverterFactory.java
@@ -39,7 +39,7 @@
       Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     return new Converter<String, RequestBody>() {
       @Override public RequestBody convert(String value) throws IOException {
-        return RequestBody.create(MediaType.parse("text/plain"), value);
+        return RequestBody.create(MediaType.get("text/plain"), value);
       }
     };
   }
diff --git a/retrofit-adapters/java8/README.md b/retrofit-adapters/java8/README.md
index 83424c809..86510b820 100644
--- a/retrofit-adapters/java8/README.md
+++ b/retrofit-adapters/java8/README.md
@@ -1,50 +1,10 @@
-Java8 Adapter
-==============
+Java 8 Adapter (Deprecated)
+===========================
 
-An `Adapter` for adapting [Java8][1] `CompletableFuture`.
-
-
-Usage
------
-
-Add `Java8CallAdapterFactory` as a `Call` adapter when building your `Retrofit` instance:
-```java
-Retrofit retrofit = new Retrofit.Builder()
-    .baseUrl("https://example.com/")
-    .addCallAdapterFactory(Java8CallAdapterFactory.create())
-    .build();
-```
-
-Your service methods can now use `CompletableFuture` as their return type.
-```java
-interface MyService {
-  @GET("/user")
-  CompletableFuture<User> getUser();
-}
-```
-
-
-Download
---------
-
-Download [the latest JAR][2] or grab via [Maven][3]:
-```xml
-<dependency>
-  <groupId>com.squareup.retrofit2</groupId>
-  <artifactId>adapter-java8</artifactId>
-  <version>latest.version</version>
-</dependency>
-```
-or [Gradle][3]:
-```groovy
-compile 'com.squareup.retrofit2:adapter-java8:latest.version'
-```
-
-Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
+A call adapter [Java 8's `CompletableFuture`][1].
 
+This adapter is no longer needed. Support for `CompletableFuture` is built-in to Retrofit and now
+works without configuration.
 
 
  [1]: http://www.oracle.com/technetwork/java/javase/jdk-8-readme-2095712.html
- [2]: https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=adapter-java8&v=LATEST
- [3]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup.retrofit2%22%20a%3A%22adapter-java8%22
- [snap]: https://oss.sonatype.org/content/repositories/snapshots/
diff --git a/retrofit-adapters/java8/pom.xml b/retrofit-adapters/java8/pom.xml
index 675e96839..1a513ac2e 100644
--- a/retrofit-adapters/java8/pom.xml
+++ b/retrofit-adapters/java8/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-adapters</artifactId>
-    <version>2.4.1-SNAPSHOT</version>
+    <version>2.6.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
diff --git a/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/Java8CallAdapterFactory.java b/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/Java8CallAdapterFactory.java
index 35b79f1a3..8b1695eb8 100644
--- a/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/Java8CallAdapterFactory.java
+++ b/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/Java8CallAdapterFactory.java
@@ -20,6 +20,7 @@
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import java.util.concurrent.CompletableFuture;
+import javax.annotation.Nullable;
 import retrofit2.Call;
 import retrofit2.CallAdapter;
 import retrofit2.Callback;
@@ -27,6 +28,9 @@
 import retrofit2.Retrofit;
 
 /**
+ * @deprecated Retrofit includes support for CompletableFuture. This no longer needs to be added to
+ * the Retrofit instance explicitly.
+ * <p>
  * A {@linkplain CallAdapter.Factory call adapter} which creates Java 8 futures.
  * <p>
  * Adding this class to {@link Retrofit} allows you to return {@link CompletableFuture} from
@@ -47,6 +51,7 @@
  * errors</li>
  * </ul>
  */
+@Deprecated
 public final class Java8CallAdapterFactory extends CallAdapter.Factory {
   public static Java8CallAdapterFactory create() {
     return new Java8CallAdapterFactory();
@@ -55,8 +60,8 @@ public static Java8CallAdapterFactory create() {
   private Java8CallAdapterFactory() {
   }
 
-  @Override
-  public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+  @Override public @Nullable CallAdapter<?, ?> get(
+      Type returnType, Annotation[] annotations, Retrofit retrofit) {
     if (getRawType(returnType) != CompletableFuture.class) {
       return null;
     }
diff --git a/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/package-info.java b/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/package-info.java
index 7e36b199e..a45aba2ed 100644
--- a/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/package-info.java
+++ b/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/package-info.java
@@ -1,4 +1,2 @@
-@ParametersAreNonnullByDefault
+@retrofit2.internal.EverythingIsNonNull
 package retrofit2.adapter.java8;
-
-import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/StringConverterFactory.java b/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/StringConverterFactory.java
index de4b63e61..81c6ec90b 100644
--- a/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/StringConverterFactory.java
+++ b/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/StringConverterFactory.java
@@ -39,7 +39,7 @@
       Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     return new Converter<String, RequestBody>() {
       @Override public RequestBody convert(String value) throws IOException {
-        return RequestBody.create(MediaType.parse("text/plain"), value);
+        return RequestBody.create(MediaType.get("text/plain"), value);
       }
     };
   }
diff --git a/retrofit-adapters/pom.xml b/retrofit-adapters/pom.xml
index 45ae63173..ef0a5b107 100644
--- a/retrofit-adapters/pom.xml
+++ b/retrofit-adapters/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>parent</artifactId>
-    <version>2.4.1-SNAPSHOT</version>
+    <version>2.6.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
diff --git a/retrofit-adapters/rxjava/README.md b/retrofit-adapters/rxjava/README.md
index 3352daf8f..9b0a95828 100644
--- a/retrofit-adapters/rxjava/README.md
+++ b/retrofit-adapters/rxjava/README.md
@@ -50,7 +50,7 @@ Download [the latest JAR][2] or grab via [Maven][3]:
 ```
 or [Gradle][3]:
 ```groovy
-compile 'com.squareup.retrofit2:adapter-rxjava:latest.version'
+implementation 'com.squareup.retrofit2:adapter-rxjava:latest.version'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/retrofit-adapters/rxjava/pom.xml b/retrofit-adapters/rxjava/pom.xml
index 97d45857e..60ccffe7b 100644
--- a/retrofit-adapters/rxjava/pom.xml
+++ b/retrofit-adapters/rxjava/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-adapters</artifactId>
-    <version>2.4.1-SNAPSHOT</version>
+    <version>2.6.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactory.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactory.java
index 51804b76f..abec3e745 100644
--- a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactory.java
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactory.java
@@ -92,8 +92,8 @@ private RxJavaCallAdapterFactory(@Nullable Scheduler scheduler, boolean isAsync)
     this.isAsync = isAsync;
   }
 
-  @Override
-  public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+  @Override public @Nullable CallAdapter<?, ?> get(
+      Type returnType, Annotation[] annotations, Retrofit retrofit) {
     Class<?> rawType = getRawType(returnType);
     boolean isSingle = rawType == Single.class;
     boolean isCompletable = rawType == Completable.class;
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/package-info.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/package-info.java
index 255728495..e3d8acb68 100644
--- a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/package-info.java
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/package-info.java
@@ -1,4 +1,2 @@
-@ParametersAreNonnullByDefault
+@retrofit2.internal.EverythingIsNonNull
 package retrofit2.adapter.rxjava;
-
-import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableTest.java
index 3d84b39f2..27603602a 100644
--- a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableTest.java
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableTest.java
@@ -71,4 +71,19 @@
     service.completable().unsafeSubscribe(subscriber);
     subscriber.assertError(IOException.class);
   }
+
+  @Test public void subscribeTwice() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+    server.enqueue(new MockResponse().setBody("Hey"));
+
+    Completable observable = service.completable();
+
+    RecordingSubscriber<String> subscriber1 = subscriberRule.create();
+    observable.subscribe(subscriber1);
+    subscriber1.assertCompleted();
+
+    RecordingSubscriber<String> subscriber2 = subscriberRule.create();
+    observable.subscribe(subscriber2);
+    subscriber2.assertCompleted();
+  }
 }
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableTest.java
index 500c3c539..07b56dc36 100644
--- a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableTest.java
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableTest.java
@@ -191,4 +191,19 @@ public void call(Response<String> response) {
     subscriber.requestMore(Long.MAX_VALUE); // Subsequent requests do not trigger HTTP requests.
     assertThat(server.getRequestCount()).isEqualTo(1);
   }
+
+  @Test public void subscribeTwice() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+    server.enqueue(new MockResponse().setBody("Hey"));
+
+    Observable<String> observable = service.body();
+
+    RecordingSubscriber<String> subscriber1 = subscriberRule.create();
+    observable.subscribe(subscriber1);
+    subscriber1.assertValue("Hi").assertCompleted();
+
+    RecordingSubscriber<String> subscriber2 = subscriberRule.create();
+    observable.subscribe(subscriber2);
+    subscriber2.assertValue("Hey").assertCompleted();
+  }
 }
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleTest.java
index babd05c73..dae833a40 100644
--- a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleTest.java
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleTest.java
@@ -171,4 +171,19 @@
 
     subscriber.assertError(e);
   }
+
+  @Test public void subscribeTwice() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+    server.enqueue(new MockResponse().setBody("Hey"));
+
+    Single<String> observable = service.body();
+
+    RecordingSubscriber<String> subscriber1 = subscriberRule.create();
+    observable.subscribe(subscriber1);
+    subscriber1.assertValue("Hi").assertCompleted();
+
+    RecordingSubscriber<String> subscriber2 = subscriberRule.create();
+    observable.subscribe(subscriber2);
+    subscriber2.assertValue("Hey").assertCompleted();
+  }
 }
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/StringConverterFactory.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/StringConverterFactory.java
index c44038d02..49de8bf19 100644
--- a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/StringConverterFactory.java
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/StringConverterFactory.java
@@ -39,7 +39,7 @@
       Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     return new Converter<String, RequestBody>() {
       @Override public RequestBody convert(String value) throws IOException {
-        return RequestBody.create(MediaType.parse("text/plain"), value);
+        return RequestBody.create(MediaType.get("text/plain"), value);
       }
     };
   }
diff --git a/retrofit-adapters/rxjava2/README.md b/retrofit-adapters/rxjava2/README.md
index 0512f9fbb..74d14b4be 100644
--- a/retrofit-adapters/rxjava2/README.md
+++ b/retrofit-adapters/rxjava2/README.md
@@ -51,7 +51,7 @@ Download [the latest JAR][2] or grab via [Maven][3]:
 ```
 or [Gradle][3]:
 ```groovy
-compile 'com.squareup.retrofit2:adapter-rxjava2:latest.version'
+implementation 'com.squareup.retrofit2:adapter-rxjava2:latest.version'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/retrofit-adapters/rxjava2/pom.xml b/retrofit-adapters/rxjava2/pom.xml
index 5f1953a9a..d75008a48 100644
--- a/retrofit-adapters/rxjava2/pom.xml
+++ b/retrofit-adapters/rxjava2/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-adapters</artifactId>
-    <version>2.4.1-SNAPSHOT</version>
+    <version>2.6.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallEnqueueObservable.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallEnqueueObservable.java
index 8c7dc4ebc..c58c426f4 100644
--- a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallEnqueueObservable.java
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallEnqueueObservable.java
@@ -37,7 +37,9 @@
     Call<T> call = originalCall.clone();
     CallCallback<T> callback = new CallCallback<>(call, observer);
     observer.onSubscribe(callback);
-    call.enqueue(callback);
+    if (!callback.isDisposed()) {
+      call.enqueue(callback);
+    }
   }
 
   private static final class CallCallback<T> implements Disposable, Callback<T> {
@@ -62,6 +64,7 @@
           observer.onComplete();
         }
       } catch (Throwable t) {
+        Exceptions.throwIfFatal(t);
         if (terminated) {
           RxJavaPlugins.onError(t);
         } else if (!disposed) {
diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallExecuteObservable.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallExecuteObservable.java
index b4963e075..71b9066e7 100644
--- a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallExecuteObservable.java
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallExecuteObservable.java
@@ -36,6 +36,9 @@
     Call<T> call = originalCall.clone();
     CallDisposable disposable = new CallDisposable(call);
     observer.onSubscribe(disposable);
+    if (disposable.isDisposed()) {
+      return;
+    }
 
     boolean terminated = false;
     try {
diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactory.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactory.java
index 8af54c505..0870af1f1 100644
--- a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactory.java
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactory.java
@@ -90,8 +90,8 @@ private RxJava2CallAdapterFactory(@Nullable Scheduler scheduler, boolean isAsync
     this.isAsync = isAsync;
   }
 
-  @Override
-  public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+  @Override public @Nullable CallAdapter<?, ?> get(
+      Type returnType, Annotation[] annotations, Retrofit retrofit) {
     Class<?> rawType = getRawType(returnType);
 
     if (rawType == Completable.class) {
diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/package-info.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/package-info.java
index c5fc01992..e778f0fb9 100644
--- a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/package-info.java
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/package-info.java
@@ -1,4 +1,2 @@
-@ParametersAreNonnullByDefault
+@retrofit2.internal.EverythingIsNonNull
 package retrofit2.adapter.rxjava2;
-
-import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/AsyncTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/AsyncTest.java
index d008a5e70..d020b3a6a 100644
--- a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/AsyncTest.java
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/AsyncTest.java
@@ -22,10 +22,18 @@
 import io.reactivex.observers.TestObserver;
 import io.reactivex.plugins.RxJavaPlugins;
 import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
 import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.Dispatcher;
+import okhttp3.OkHttpClient;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
@@ -36,7 +44,10 @@
 import static java.util.concurrent.TimeUnit.SECONDS;
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
 
 public final class AsyncTest {
   @Rule public final MockWebServer server = new MockWebServer();
@@ -46,14 +57,36 @@
   }
 
   private Service service;
+  private List<Throwable> uncaughtExceptions = new ArrayList<>();
+
   @Before public void setUp() {
+    ExecutorService executorService = Executors.newCachedThreadPool(new ThreadFactory() {
+      @Override public Thread newThread(Runnable r) {
+        Thread thread = new Thread(r);
+        thread.setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
+          @Override public void uncaughtException(Thread t, Throwable e) {
+            uncaughtExceptions.add(e);
+          }
+        });
+        return thread;
+      }
+    });
+
+    OkHttpClient client = new OkHttpClient.Builder()
+        .dispatcher(new Dispatcher(executorService))
+        .build();
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
+        .client(client)
         .addCallAdapterFactory(RxJava2CallAdapterFactory.createAsync())
         .build();
     service = retrofit.create(Service.class);
   }
 
+  @After public void tearDown() {
+    assertTrue("Uncaught exceptions: " + uncaughtExceptions, uncaughtExceptions.isEmpty());
+  }
+
   @Test public void success() throws InterruptedException {
     TestObserver<Void> observer = new TestObserver<>();
     service.completable().subscribe(observer);
@@ -130,4 +163,23 @@
     CompositeException composite = (CompositeException) pluginRef.get();
     assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
   }
+
+  @Test public void bodyThrowingFatalInOnErrorPropagates() throws InterruptedException {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    final CountDownLatch latch = new CountDownLatch(1);
+
+    TestObserver<Void> observer = new TestObserver<>();
+    final Error e = new OutOfMemoryError("Not real");
+    service.completable().subscribe(new ForwardingCompletableObserver(observer) {
+      @Override public void onError(Throwable throwable) {
+        throw e;
+      }
+    });
+
+    latch.await(1, SECONDS);
+
+    assertEquals(1, uncaughtExceptions.size());
+    assertSame(e, uncaughtExceptions.remove(0));
+  }
 }
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CancelDisposeTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CancelDisposeTest.java
index d643e4eb1..8a9a6c375 100644
--- a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CancelDisposeTest.java
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CancelDisposeTest.java
@@ -59,6 +59,12 @@
     assertTrue(calls.get(0).isCanceled());
   }
 
+  @Test public void disposeBeforeEnqueueDoesNotEnqueue() {
+    service.go().test(true);
+    List<Call> calls = client.dispatcher().runningCalls();
+    assertEquals(0, calls.size());
+  }
+
   @Test public void cancelDoesNotDispose() {
     Disposable disposable = service.go().subscribe();
     List<Call> calls = client.dispatcher().runningCalls();
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CancelDisposeTestSync.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CancelDisposeTestSync.java
new file mode 100644
index 000000000..174536d13
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CancelDisposeTestSync.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Observable;
+import okhttp3.OkHttpClient;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+import static org.junit.Assert.assertEquals;
+
+public final class CancelDisposeTestSync {
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  interface Service {
+    @GET("/") Observable<String> go();
+  }
+
+  private final OkHttpClient client = new OkHttpClient();
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
+        .callFactory(client)
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void disposeBeforeExecuteDoesNotEnqueue() {
+    service.go().test(true);
+    assertEquals(0, server.getRequestCount());
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CompletableTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CompletableTest.java
index 999cf31bd..4f00f7112 100644
--- a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CompletableTest.java
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CompletableTest.java
@@ -70,4 +70,19 @@
     service.completable().subscribe(observer);
     observer.assertError(IOException.class);
   }
+
+  @Test public void subscribeTwice() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+    server.enqueue(new MockResponse().setBody("Hey"));
+
+    Completable observable = service.completable();
+
+    RecordingCompletableObserver observer1 = observerRule.create();
+    observable.subscribe(observer1);
+    observer1.assertComplete();
+
+    RecordingCompletableObserver observer2 = observerRule.create();
+    observable.subscribe(observer2);
+    observer2.assertComplete();
+  }
 }
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/FlowableTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/FlowableTest.java
index 22efcee2b..6347fa674 100644
--- a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/FlowableTest.java
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/FlowableTest.java
@@ -184,4 +184,19 @@
     subscriber.request(Long.MAX_VALUE); // Subsequent requests do not trigger HTTP or notifications.
     assertThat(server.getRequestCount()).isEqualTo(1);
   }
+
+  @Test public void subscribeTwice() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+    server.enqueue(new MockResponse().setBody("Hey"));
+
+    Flowable<String> observable = service.body();
+
+    RecordingSubscriber<Object> subscriber1 = subscriberRule.create();
+    observable.subscribe(subscriber1);
+    subscriber1.assertValue("Hi").assertComplete();
+
+    RecordingSubscriber<Object> subscriber2 = subscriberRule.create();
+    observable.subscribe(subscriber2);
+    subscriber2.assertValue("Hey").assertComplete();
+  }
 }
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/MaybeTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/MaybeTest.java
index 21f69c68a..73295bf02 100644
--- a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/MaybeTest.java
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/MaybeTest.java
@@ -16,6 +16,7 @@
 package retrofit2.adapter.rxjava2;
 
 import io.reactivex.Maybe;
+import java.io.IOException;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import org.junit.Before;
@@ -25,8 +26,6 @@
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
 
-import java.io.IOException;
-
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
 import static org.assertj.core.api.Assertions.assertThat;
 
@@ -130,4 +129,19 @@
     assertThat(result.isError()).isTrue();
     assertThat(result.error()).isInstanceOf(IOException.class);
   }
+
+  @Test public void subscribeTwice() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+    server.enqueue(new MockResponse().setBody("Hey"));
+
+    Maybe<String> observable = service.body();
+
+    RecordingMaybeObserver<Object> observer1 = observerRule.create();
+    observable.subscribe(observer1);
+    observer1.assertValue("Hi");
+
+    RecordingMaybeObserver<Object> observer2 = observerRule.create();
+    observable.subscribe(observer2);
+    observer2.assertValue("Hey");
+  }
 }
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ObservableTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ObservableTest.java
index 23c20f77e..1afe1eaa3 100644
--- a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ObservableTest.java
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ObservableTest.java
@@ -149,4 +149,19 @@
       RxJavaPlugins.reset();
     }
   }
+
+  @Test public void subscribeTwice() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+    server.enqueue(new MockResponse().setBody("Hey"));
+
+    Observable<String> observable = service.body();
+
+    RecordingObserver<String> observer1 = observerRule.create();
+    observable.subscribe(observer1);
+    observer1.assertValue("Hi").assertComplete();
+
+    RecordingObserver<String> observer2 = observerRule.create();
+    observable.subscribe(observer2);
+    observer2.assertValue("Hey").assertComplete();
+  }
 }
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/SingleTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/SingleTest.java
index dba2dd62a..2181e4eed 100644
--- a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/SingleTest.java
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/SingleTest.java
@@ -129,4 +129,19 @@
     assertThat(result.isError()).isTrue();
     assertThat(result.error()).isInstanceOf(IOException.class);
   }
+
+  @Test public void subscribeTwice() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+    server.enqueue(new MockResponse().setBody("Hey"));
+
+    Single<String> observable = service.body();
+
+    RecordingSingleObserver<Object> observer1 = observerRule.create();
+    observable.subscribe(observer1);
+    observer1.assertValue("Hi");
+
+    RecordingSingleObserver<Object> observer2 = observerRule.create();
+    observable.subscribe(observer2);
+    observer2.assertValue("Hey");
+  }
 }
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/StringConverterFactory.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/StringConverterFactory.java
index 5a6841840..c975258cb 100644
--- a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/StringConverterFactory.java
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/StringConverterFactory.java
@@ -39,7 +39,7 @@
       Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     return new Converter<String, RequestBody>() {
       @Override public RequestBody convert(String value) throws IOException {
-        return RequestBody.create(MediaType.parse("text/plain"), value);
+        return RequestBody.create(MediaType.get("text/plain"), value);
       }
     };
   }
diff --git a/retrofit-adapters/scala/README.md b/retrofit-adapters/scala/README.md
index 74aa0a7a1..24c427fed 100644
--- a/retrofit-adapters/scala/README.md
+++ b/retrofit-adapters/scala/README.md
@@ -37,7 +37,7 @@ Download [the latest JAR][2] or grab via [Maven][3]:
 ```
 or [Gradle][3]:
 ```groovy
-compile 'com.squareup.retrofit2:adapter-scala:latest.version'
+implementation 'com.squareup.retrofit2:adapter-scala:latest.version'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/retrofit-adapters/scala/pom.xml b/retrofit-adapters/scala/pom.xml
index ecbd8adde..a432d79b9 100644
--- a/retrofit-adapters/scala/pom.xml
+++ b/retrofit-adapters/scala/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-adapters</artifactId>
-    <version>2.4.1-SNAPSHOT</version>
+    <version>2.6.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
diff --git a/retrofit-adapters/scala/src/main/java/retrofit2/adapter/scala/BodyCallAdapter.java b/retrofit-adapters/scala/src/main/java/retrofit2/adapter/scala/BodyCallAdapter.java
index 432068f86..500f07808 100644
--- a/retrofit-adapters/scala/src/main/java/retrofit2/adapter/scala/BodyCallAdapter.java
+++ b/retrofit-adapters/scala/src/main/java/retrofit2/adapter/scala/BodyCallAdapter.java
@@ -16,7 +16,6 @@
 package retrofit2.adapter.scala;
 
 import java.lang.reflect.Type;
-import javax.annotation.Nonnull;
 import retrofit2.Call;
 import retrofit2.CallAdapter;
 import retrofit2.Callback;
@@ -36,11 +35,11 @@
     return responseType;
   }
 
-  @Override public Future<T> adapt(@Nonnull Call<T> call) {
+  @Override public Future<T> adapt(Call<T> call) {
     Promise<T> promise = Promise.apply();
 
     call.enqueue(new Callback<T>() {
-      @Override public void onResponse(@Nonnull Call<T> call, @Nonnull Response<T> response) {
+      @Override public void onResponse(Call<T> call, Response<T> response) {
         if (response.isSuccessful()) {
           promise.success(response.body());
         } else {
@@ -48,7 +47,7 @@
         }
       }
 
-      @Override public void onFailure(@Nonnull Call<T> call, @Nonnull Throwable t) {
+      @Override public void onFailure(Call<T> call, Throwable t) {
         promise.failure(t);
       }
     });
diff --git a/retrofit-adapters/scala/src/main/java/retrofit2/adapter/scala/ResponseCallAdapter.java b/retrofit-adapters/scala/src/main/java/retrofit2/adapter/scala/ResponseCallAdapter.java
index 75d75f99d..e9462dd61 100644
--- a/retrofit-adapters/scala/src/main/java/retrofit2/adapter/scala/ResponseCallAdapter.java
+++ b/retrofit-adapters/scala/src/main/java/retrofit2/adapter/scala/ResponseCallAdapter.java
@@ -16,7 +16,6 @@
 package retrofit2.adapter.scala;
 
 import java.lang.reflect.Type;
-import javax.annotation.Nonnull;
 import retrofit2.Call;
 import retrofit2.CallAdapter;
 import retrofit2.Callback;
@@ -35,15 +34,15 @@
     return responseType;
   }
 
-  @Override public Future<Response<T>> adapt(@Nonnull Call<T> call) {
+  @Override public Future<Response<T>> adapt(Call<T> call) {
     Promise<Response<T>> promise = Promise.apply();
 
     call.enqueue(new Callback<T>() {
-      @Override public void onResponse(@Nonnull Call<T> call, @Nonnull Response<T> response) {
+      @Override public void onResponse(Call<T> call, Response<T> response) {
         promise.success(response);
       }
 
-      @Override public void onFailure(@Nonnull Call<T> call, @Nonnull Throwable t) {
+      @Override public void onFailure(Call<T> call, Throwable t) {
         promise.failure(t);
       }
     });
diff --git a/retrofit-adapters/scala/src/main/java/retrofit2/adapter/scala/ScalaCallAdapterFactory.java b/retrofit-adapters/scala/src/main/java/retrofit2/adapter/scala/ScalaCallAdapterFactory.java
index afe2e7fe7..7737b8b0b 100644
--- a/retrofit-adapters/scala/src/main/java/retrofit2/adapter/scala/ScalaCallAdapterFactory.java
+++ b/retrofit-adapters/scala/src/main/java/retrofit2/adapter/scala/ScalaCallAdapterFactory.java
@@ -19,7 +19,7 @@
 import java.lang.annotation.Annotation;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
-import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
 import retrofit2.CallAdapter;
 import retrofit2.Response;
 import retrofit2.Retrofit;
@@ -54,9 +54,8 @@ public static ScalaCallAdapterFactory create() {
   private ScalaCallAdapterFactory() {
   }
 
-  @Override
-  public CallAdapter<?, ?> get(@Nonnull Type returnType, @Nonnull Annotation[] annotations,
-      @Nonnull Retrofit retrofit) {
+  @Override public @Nullable CallAdapter<?, ?> get(
+      Type returnType, Annotation[] annotations, Retrofit retrofit) {
     if (getRawType(returnType) != Future.class) {
       return null;
     }
diff --git a/retrofit-adapters/scala/src/main/java/retrofit2/adapter/scala/package-info.java b/retrofit-adapters/scala/src/main/java/retrofit2/adapter/scala/package-info.java
new file mode 100644
index 000000000..882801bd2
--- /dev/null
+++ b/retrofit-adapters/scala/src/main/java/retrofit2/adapter/scala/package-info.java
@@ -0,0 +1,2 @@
+@retrofit2.internal.EverythingIsNonNull
+package retrofit2.adapter.scala;
diff --git a/retrofit-adapters/scala/src/test/java/retrofit2/adapter/scala/StringConverterFactory.java b/retrofit-adapters/scala/src/test/java/retrofit2/adapter/scala/StringConverterFactory.java
index d14596c40..a46c087d3 100644
--- a/retrofit-adapters/scala/src/test/java/retrofit2/adapter/scala/StringConverterFactory.java
+++ b/retrofit-adapters/scala/src/test/java/retrofit2/adapter/scala/StringConverterFactory.java
@@ -39,7 +39,7 @@
       Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     return new Converter<String, RequestBody>() {
       @Override public RequestBody convert(String value) throws IOException {
-        return RequestBody.create(MediaType.parse("text/plain"), value);
+        return RequestBody.create(MediaType.get("text/plain"), value);
       }
     };
   }
diff --git a/retrofit-converters/gson/README.md b/retrofit-converters/gson/README.md
index 980d1d1f0..814f49ab1 100644
--- a/retrofit-converters/gson/README.md
+++ b/retrofit-converters/gson/README.md
@@ -20,7 +20,7 @@ Download [the latest JAR][2] or grab via [Maven][3]:
 ```
 or [Gradle][3]:
 ```groovy
-compile 'com.squareup.retrofit2:converter-gson:latest.version'
+implementation 'com.squareup.retrofit2:converter-gson:latest.version'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/retrofit-converters/gson/pom.xml b/retrofit-converters/gson/pom.xml
index 099da1b51..66d816eb3 100644
--- a/retrofit-converters/gson/pom.xml
+++ b/retrofit-converters/gson/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-converters</artifactId>
-    <version>2.4.1-SNAPSHOT</version>
+    <version>2.6.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
diff --git a/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonRequestBodyConverter.java b/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonRequestBodyConverter.java
index 2e30a4478..a47775748 100644
--- a/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonRequestBodyConverter.java
+++ b/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonRequestBodyConverter.java
@@ -28,7 +28,7 @@
 import retrofit2.Converter;
 
 final class GsonRequestBodyConverter<T> implements Converter<T, RequestBody> {
-  private static final MediaType MEDIA_TYPE = MediaType.parse("application/json; charset=UTF-8");
+  private static final MediaType MEDIA_TYPE = MediaType.get("application/json; charset=UTF-8");
   private static final Charset UTF_8 = Charset.forName("UTF-8");
 
   private final Gson gson;
diff --git a/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/package-info.java b/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/package-info.java
index b8ad27810..677188914 100644
--- a/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/package-info.java
+++ b/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/package-info.java
@@ -1,4 +1,2 @@
-@ParametersAreNonnullByDefault
+@retrofit2.internal.EverythingIsNonNull
 package retrofit2.converter.gson;
-
-import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-converters/guava/README.md b/retrofit-converters/guava/README.md
index 03eae96f5..e77280b77 100644
--- a/retrofit-converters/guava/README.md
+++ b/retrofit-converters/guava/README.md
@@ -1,14 +1,14 @@
 Guava Converter
 ===============
 
-A `Converter` which supports Guava's `Optional<T>` by delegating to other converters for `T`
+A `Converter` which supports [Guava][1]'s `Optional<T>` by delegating to other converters for `T`
 and then wrapping it into `Optional`.
 
 
 Download
 --------
 
-Download [the latest JAR][1] or grab via [Maven][2]:
+Download [the latest JAR][2] or grab via [Maven][3]:
 ```xml
 <dependency>
   <groupId>com.squareup.retrofit2</groupId>
@@ -16,15 +16,15 @@ Download [the latest JAR][1] or grab via [Maven][2]:
   <version>latest.version</version>
 </dependency>
 ```
-or [Gradle][2]:
+or [Gradle][3]:
 ```groovy
-compile 'com.squareup.retrofit2:converter-guava:latest.version'
+implementation 'com.squareup.retrofit2:converter-guava:latest.version'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
 
 
-
- [1]: https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=converter-guava&v=LATEST
- [2]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup.retrofit2%22%20a%3A%22converter-guava%22
+ [1]: https://github.com/google/guava
+ [2]: https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=converter-guava&v=LATEST
+ [3]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup.retrofit2%22%20a%3A%22converter-guava%22
  [snap]: https://oss.sonatype.org/content/repositories/snapshots/
diff --git a/retrofit-converters/guava/pom.xml b/retrofit-converters/guava/pom.xml
index 16e0d3896..ea734f257 100644
--- a/retrofit-converters/guava/pom.xml
+++ b/retrofit-converters/guava/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-converters</artifactId>
-    <version>2.4.1-SNAPSHOT</version>
+    <version>2.6.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
diff --git a/retrofit-converters/guava/src/main/java/retrofit/converter/guava/GuavaOptionalConverterFactory.java b/retrofit-converters/guava/src/main/java/retrofit/converter/guava/GuavaOptionalConverterFactory.java
index bfa033614..42b2c2745 100644
--- a/retrofit-converters/guava/src/main/java/retrofit/converter/guava/GuavaOptionalConverterFactory.java
+++ b/retrofit-converters/guava/src/main/java/retrofit/converter/guava/GuavaOptionalConverterFactory.java
@@ -36,16 +36,15 @@ public static GuavaOptionalConverterFactory create() {
   private GuavaOptionalConverterFactory() {
   }
 
-  @Nullable @Override
-  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
+  @Override public @Nullable Converter<ResponseBody, ?> responseBodyConverter(
+      Type type, Annotation[] annotations, Retrofit retrofit) {
     if (getRawType(type) != Optional.class) {
       return null;
     }
 
     Type innerType = getParameterUpperBound(0, (ParameterizedType) type);
     Converter<ResponseBody, Object> delegate =
-        retrofit.nextResponseBodyConverter(this, innerType, annotations);
+        retrofit.responseBodyConverter(innerType, annotations);
     return new OptionalConverter<>(delegate);
   }
 }
diff --git a/retrofit-converters/guava/src/main/java/retrofit/converter/guava/package-info.java b/retrofit-converters/guava/src/main/java/retrofit/converter/guava/package-info.java
index bd25d1fe4..04152af9c 100644
--- a/retrofit-converters/guava/src/main/java/retrofit/converter/guava/package-info.java
+++ b/retrofit-converters/guava/src/main/java/retrofit/converter/guava/package-info.java
@@ -1,4 +1,2 @@
-@ParametersAreNonnullByDefault
+@retrofit2.internal.EverythingIsNonNull
 package retrofit.converter.guava;
-
-import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-converters/guava/src/test/java/retrofit/converter/guava/GuavaOptionalConverterFactoryTest.java b/retrofit-converters/guava/src/test/java/retrofit/converter/guava/GuavaOptionalConverterFactoryTest.java
index 27680150e..24426222a 100644
--- a/retrofit-converters/guava/src/test/java/retrofit/converter/guava/GuavaOptionalConverterFactoryTest.java
+++ b/retrofit-converters/guava/src/test/java/retrofit/converter/guava/GuavaOptionalConverterFactoryTest.java
@@ -17,12 +17,17 @@
 
 import com.google.common.base.Optional;
 import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import javax.annotation.Nullable;
+import okhttp3.ResponseBody;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 import retrofit2.Call;
+import retrofit2.Converter;
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
 
@@ -61,4 +66,32 @@
     Object body = service.object().execute().body();
     assertThat(body).isNull();
   }
+
+  @Test public void delegates() throws IOException {
+    final Object object = new Object();
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new Converter.Factory() {
+          @Nullable @Override public Converter<ResponseBody, ?> responseBodyConverter(Type type,
+              Annotation[] annotations, Retrofit retrofit) {
+            if (getRawType(type) != Object.class) {
+              return null;
+            }
+            return new Converter<ResponseBody, Object>() {
+              @Override public Object convert(ResponseBody value) {
+                return object;
+              }
+            };
+          }
+        })
+        .addConverterFactory(GuavaOptionalConverterFactory.create())
+        .build();
+
+    server.enqueue(new MockResponse());
+
+    Service service = retrofit.create(Service.class);
+    Optional<Object> optional = service.optional().execute().body();
+    assertThat(optional).isNotNull();
+    assertThat(optional.get()).isSameAs(object);
+  }
 }
diff --git a/retrofit-converters/jackson/README.md b/retrofit-converters/jackson/README.md
index 2335d2903..0b6149e1e 100644
--- a/retrofit-converters/jackson/README.md
+++ b/retrofit-converters/jackson/README.md
@@ -20,14 +20,15 @@ Download [the latest JAR][2] or grab via [Maven][3]:
 ```
 or [Gradle][3]:
 ```groovy
-compile 'com.squareup.retrofit2:converter-jackson:latest.version'
+implementation 'com.squareup.retrofit2:converter-jackson:latest.version'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
 
 
 
- [1]: http://wiki.fasterxml.com/JacksonHome
+ [1]: https://github.com/FasterXML/jackson
  [2]: https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=converter-jackson&v=LATEST
  [3]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup.retrofit2%22%20a%3A%22converter-jackson%22
  [snap]: https://oss.sonatype.org/content/repositories/snapshots/
+
diff --git a/retrofit-converters/jackson/pom.xml b/retrofit-converters/jackson/pom.xml
index 332f5ed04..c8191ab87 100644
--- a/retrofit-converters/jackson/pom.xml
+++ b/retrofit-converters/jackson/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-converters</artifactId>
-    <version>2.4.1-SNAPSHOT</version>
+    <version>2.6.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
diff --git a/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonRequestBodyConverter.java b/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonRequestBodyConverter.java
index bd20a0ae0..85408a479 100644
--- a/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonRequestBodyConverter.java
+++ b/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonRequestBodyConverter.java
@@ -22,7 +22,7 @@
 import retrofit2.Converter;
 
 final class JacksonRequestBodyConverter<T> implements Converter<T, RequestBody> {
-  private static final MediaType MEDIA_TYPE = MediaType.parse("application/json; charset=UTF-8");
+  private static final MediaType MEDIA_TYPE = MediaType.get("application/json; charset=UTF-8");
 
   private final ObjectWriter adapter;
 
diff --git a/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/package-info.java b/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/package-info.java
index f747a1d6d..567bad26a 100644
--- a/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/package-info.java
+++ b/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/package-info.java
@@ -1,4 +1,2 @@
-@ParametersAreNonnullByDefault
+@retrofit2.internal.EverythingIsNonNull
 package retrofit2.converter.jackson;
-
-import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-converters/java8/README.md b/retrofit-converters/java8/README.md
index 696ac23c6..331ca6866 100644
--- a/retrofit-converters/java8/README.md
+++ b/retrofit-converters/java8/README.md
@@ -1,30 +1,8 @@
-Java 8 Converter
-================
+Java 8 Converter (Deprecated)
+=============================
 
 A `Converter` which supports Java 8's `Optional<T>` by delegating to other converters for `T`
 and then wrapping it into `Optional`.
 
-
-Download
---------
-
-Download [the latest JAR][1] or grab via [Maven][2]:
-```xml
-<dependency>
-  <groupId>com.squareup.retrofit2</groupId>
-  <artifactId>converter-java8</artifactId>
-  <version>latest.version</version>
-</dependency>
-```
-or [Gradle][2]:
-```groovy
-compile 'com.squareup.retrofit2:converter-java8:latest.version'
-```
-
-Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
-
-
-
- [1]: https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=converter-java8&v=LATEST
- [2]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup.retrofit2%22%20a%3A%22converter-java8%22
- [snap]: https://oss.sonatype.org/content/repositories/snapshots/
+This converter is no longer needed. Support for `Optional` is built-in to Retrofit and now works
+without configuration.
diff --git a/retrofit-converters/java8/pom.xml b/retrofit-converters/java8/pom.xml
index 4f9e094f9..3fbe9c62c 100644
--- a/retrofit-converters/java8/pom.xml
+++ b/retrofit-converters/java8/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-converters</artifactId>
-    <version>2.4.1-SNAPSHOT</version>
+    <version>2.6.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
diff --git a/retrofit-converters/java8/src/main/java/retrofit/converter/java8/Java8OptionalConverterFactory.java b/retrofit-converters/java8/src/main/java/retrofit/converter/java8/Java8OptionalConverterFactory.java
index 7b55ca965..512d73cb3 100644
--- a/retrofit-converters/java8/src/main/java/retrofit/converter/java8/Java8OptionalConverterFactory.java
+++ b/retrofit-converters/java8/src/main/java/retrofit/converter/java8/Java8OptionalConverterFactory.java
@@ -25,9 +25,13 @@
 import retrofit2.Retrofit;
 
 /**
+ * @deprecated Retrofit includes support for Optional. This no longer needs to be added to the
+ * Retrofit instance explicitly.
+ * <p>
  * A {@linkplain Converter.Factory converter} for {@code Optional<T>} which delegates to another
  * converter to deserialize {@code T} and then wraps it into {@link Optional}.
  */
+@Deprecated
 public final class Java8OptionalConverterFactory extends Converter.Factory {
   public static Java8OptionalConverterFactory create() {
     return new Java8OptionalConverterFactory();
@@ -36,16 +40,15 @@ public static Java8OptionalConverterFactory create() {
   private Java8OptionalConverterFactory() {
   }
 
-  @Nullable @Override
-  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
+  @Override public @Nullable Converter<ResponseBody, ?> responseBodyConverter(
+      Type type, Annotation[] annotations, Retrofit retrofit) {
     if (getRawType(type) != Optional.class) {
       return null;
     }
 
     Type innerType = getParameterUpperBound(0, (ParameterizedType) type);
     Converter<ResponseBody, Object> delegate =
-        retrofit.nextResponseBodyConverter(this, innerType, annotations);
+        retrofit.responseBodyConverter(innerType, annotations);
     return new OptionalConverter<>(delegate);
   }
 }
diff --git a/retrofit-converters/java8/src/main/java/retrofit/converter/java8/package-info.java b/retrofit-converters/java8/src/main/java/retrofit/converter/java8/package-info.java
index e883be032..fdd62e2d4 100644
--- a/retrofit-converters/java8/src/main/java/retrofit/converter/java8/package-info.java
+++ b/retrofit-converters/java8/src/main/java/retrofit/converter/java8/package-info.java
@@ -1,4 +1,2 @@
-@ParametersAreNonnullByDefault
+@retrofit2.internal.EverythingIsNonNull
 package retrofit.converter.java8;
-
-import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-converters/java8/src/test/java/retrofit/converter/java8/Java8OptionalConverterFactoryTest.java b/retrofit-converters/java8/src/test/java/retrofit/converter/java8/Java8OptionalConverterFactoryTest.java
index 73027907b..1052787da 100644
--- a/retrofit-converters/java8/src/test/java/retrofit/converter/java8/Java8OptionalConverterFactoryTest.java
+++ b/retrofit-converters/java8/src/test/java/retrofit/converter/java8/Java8OptionalConverterFactoryTest.java
@@ -16,13 +16,18 @@
 package retrofit.converter.java8;
 
 import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
 import java.util.Optional;
+import javax.annotation.Nullable;
+import okhttp3.ResponseBody;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 import retrofit2.Call;
+import retrofit2.Converter;
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
 
@@ -61,4 +66,28 @@
     Object body = service.object().execute().body();
     assertThat(body).isNull();
   }
+
+  @Test public void delegates() throws IOException {
+    Object object = new Object();
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new Converter.Factory() {
+          @Nullable @Override public Converter<ResponseBody, ?> responseBodyConverter(Type type,
+              Annotation[] annotations, Retrofit retrofit) {
+            if (getRawType(type) != Object.class) {
+              return null;
+            }
+            return value -> object;
+          }
+        })
+        .addConverterFactory(Java8OptionalConverterFactory.create())
+        .build();
+
+    server.enqueue(new MockResponse());
+
+    Service service = retrofit.create(Service.class);
+    Optional<Object> optional = service.optional().execute().body();
+    assertThat(optional).isNotNull();
+    assertThat(optional.get()).isSameAs(object);
+  }
 }
diff --git a/retrofit-converters/jaxb/README.md b/retrofit-converters/jaxb/README.md
index 76f311eb4..a2de474a9 100644
--- a/retrofit-converters/jaxb/README.md
+++ b/retrofit-converters/jaxb/README.md
@@ -21,14 +21,14 @@ Download [the latest JAR][2] or grab via [Maven][3]:
 ```
 or [Gradle][3]:
 ```groovy
-compile 'com.squareup.retrofit2:converter-jaxb:latest.version'
+implementation 'com.squareup.retrofit2:converter-jaxb:latest.version'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
 
 
 
- [1]: https://github.com/javaee/jaxb-v2
+ [1]: https://github.com/eclipse-ee4j/jaxb-ri
  [2]: https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=converter-jaxb&v=LATEST
  [3]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup.retrofit2%22%20a%3A%22converter-jaxb%22
  [snap]: https://oss.sonatype.org/content/repositories/snapshots/
diff --git a/retrofit-converters/jaxb/pom.xml b/retrofit-converters/jaxb/pom.xml
index ff2deee9e..857b8e84c 100644
--- a/retrofit-converters/jaxb/pom.xml
+++ b/retrofit-converters/jaxb/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-converters</artifactId>
-    <version>2.4.1-SNAPSHOT</version>
+    <version>2.6.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
diff --git a/retrofit-converters/jaxb/src/main/java/retrofit2/converter/jaxb/JaxbConverterFactory.java b/retrofit-converters/jaxb/src/main/java/retrofit2/converter/jaxb/JaxbConverterFactory.java
index f0c8116dc..b1317f838 100644
--- a/retrofit-converters/jaxb/src/main/java/retrofit2/converter/jaxb/JaxbConverterFactory.java
+++ b/retrofit-converters/jaxb/src/main/java/retrofit2/converter/jaxb/JaxbConverterFactory.java
@@ -32,7 +32,7 @@
  * ignored.
  */
 public final class JaxbConverterFactory extends Converter.Factory {
-  static final MediaType XML = MediaType.parse("application/xml; charset=utf-8");
+  static final MediaType XML = MediaType.get("application/xml; charset=utf-8");
 
   /** Create an instance using a default {@link JAXBContext} instance for conversion. */
   public static JaxbConverterFactory create() {
@@ -53,7 +53,7 @@ private JaxbConverterFactory(@Nullable JAXBContext context) {
     this.context = context;
   }
 
-  @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
+  @Override public @Nullable Converter<?, RequestBody> requestBodyConverter(Type type,
       Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     if (type instanceof Class && ((Class<?>) type).isAnnotationPresent(XmlRootElement.class)) {
       return new JaxbRequestConverter<>(contextForType((Class<?>) type), (Class<?>) type);
@@ -61,7 +61,7 @@ private JaxbConverterFactory(@Nullable JAXBContext context) {
     return null;
   }
 
-  @Override public Converter<ResponseBody, ?> responseBodyConverter(
+  @Override public @Nullable Converter<ResponseBody, ?> responseBodyConverter(
       Type type, Annotation[] annotations, Retrofit retrofit) {
     if (type instanceof Class && ((Class<?>) type).isAnnotationPresent(XmlRootElement.class)) {
       return new JaxbResponseConverter<>(contextForType((Class<?>) type), (Class<?>) type);
diff --git a/retrofit-converters/jaxb/src/main/java/retrofit2/converter/jaxb/JaxbResponseConverter.java b/retrofit-converters/jaxb/src/main/java/retrofit2/converter/jaxb/JaxbResponseConverter.java
index 469b863d1..e42568997 100644
--- a/retrofit-converters/jaxb/src/main/java/retrofit2/converter/jaxb/JaxbResponseConverter.java
+++ b/retrofit-converters/jaxb/src/main/java/retrofit2/converter/jaxb/JaxbResponseConverter.java
@@ -46,6 +46,8 @@
       return unmarshaller.unmarshal(streamReader, type).getValue();
     } catch (JAXBException | XMLStreamException e) {
       throw new RuntimeException(e);
+    } finally {
+      value.close();
     }
   }
 }
diff --git a/retrofit-converters/jaxb/src/main/java/retrofit2/converter/jaxb/package-info.java b/retrofit-converters/jaxb/src/main/java/retrofit2/converter/jaxb/package-info.java
index 7aebe7e7b..c14c5d1ff 100644
--- a/retrofit-converters/jaxb/src/main/java/retrofit2/converter/jaxb/package-info.java
+++ b/retrofit-converters/jaxb/src/main/java/retrofit2/converter/jaxb/package-info.java
@@ -1,4 +1,2 @@
-@ParametersAreNonnullByDefault
+@retrofit2.internal.EverythingIsNonNull
 package retrofit2.converter.jaxb;
-
-import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-converters/moshi/README.md b/retrofit-converters/moshi/README.md
index c5668f9ab..343b22dc0 100644
--- a/retrofit-converters/moshi/README.md
+++ b/retrofit-converters/moshi/README.md
@@ -20,7 +20,7 @@ Download [the latest JAR][2] or grab via [Maven][3]:
 ```
 or [Gradle][3]:
 ```groovy
-compile 'com.squareup.retrofit2:converter-moshi:latest.version'
+implementation 'com.squareup.retrofit2:converter-moshi:latest.version'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/retrofit-converters/moshi/pom.xml b/retrofit-converters/moshi/pom.xml
index 884422a43..2aefc02a8 100644
--- a/retrofit-converters/moshi/pom.xml
+++ b/retrofit-converters/moshi/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-converters</artifactId>
-    <version>2.4.1-SNAPSHOT</version>
+    <version>2.6.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
diff --git a/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiRequestBodyConverter.java b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiRequestBodyConverter.java
index edbcf243e..879d73fc4 100644
--- a/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiRequestBodyConverter.java
+++ b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiRequestBodyConverter.java
@@ -24,7 +24,7 @@
 import retrofit2.Converter;
 
 final class MoshiRequestBodyConverter<T> implements Converter<T, RequestBody> {
-  private static final MediaType MEDIA_TYPE = MediaType.parse("application/json; charset=UTF-8");
+  private static final MediaType MEDIA_TYPE = MediaType.get("application/json; charset=UTF-8");
 
   private final JsonAdapter<T> adapter;
 
diff --git a/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/package-info.java b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/package-info.java
index 2d5a38a51..38bee8e2f 100644
--- a/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/package-info.java
+++ b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/package-info.java
@@ -1,4 +1,2 @@
-@ParametersAreNonnullByDefault
+@retrofit2.internal.EverythingIsNonNull
 package retrofit2.converter.moshi;
-
-import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-converters/moshi/src/test/java/retrofit2/converter/moshi/MoshiConverterFactoryTest.java b/retrofit-converters/moshi/src/test/java/retrofit2/converter/moshi/MoshiConverterFactoryTest.java
index 0a015ff49..3eb6ceebc 100644
--- a/retrofit-converters/moshi/src/test/java/retrofit2/converter/moshi/MoshiConverterFactoryTest.java
+++ b/retrofit-converters/moshi/src/test/java/retrofit2/converter/moshi/MoshiConverterFactoryTest.java
@@ -118,7 +118,7 @@
 
     @FromJson public Value readWithoutEndingObject(JsonReader reader) throws IOException {
       reader.beginObject();
-      reader.nextName();
+      reader.skipName();
       String theName = reader.nextString();
       return new Value(theName);
     }
@@ -255,7 +255,7 @@
       call.execute();
       fail();
     } catch (JsonDataException e) {
-      assertThat(e).hasMessage("Cannot skip unexpected STRING at $.taco");
+      assertThat(e).hasMessage("Cannot skip unexpected NAME at $.");
     }
   }
 
diff --git a/retrofit-converters/pom.xml b/retrofit-converters/pom.xml
index 0aebd3275..399f25e60 100644
--- a/retrofit-converters/pom.xml
+++ b/retrofit-converters/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>parent</artifactId>
-    <version>2.4.1-SNAPSHOT</version>
+    <version>2.6.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
diff --git a/retrofit-converters/protobuf/README.md b/retrofit-converters/protobuf/README.md
index 7575a3d6c..2569fe962 100644
--- a/retrofit-converters/protobuf/README.md
+++ b/retrofit-converters/protobuf/README.md
@@ -17,7 +17,7 @@ Download [the latest JAR][2] or grab via [Maven][3]:
 ```
 or [Gradle][3]:
 ```groovy
-compile 'com.squareup.retrofit2:converter-protobuf:latest.version'
+implementation 'com.squareup.retrofit2:converter-protobuf:latest.version'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/retrofit-converters/protobuf/pom.xml b/retrofit-converters/protobuf/pom.xml
index 8d61abf6a..82ff21956 100644
--- a/retrofit-converters/protobuf/pom.xml
+++ b/retrofit-converters/protobuf/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-converters</artifactId>
-    <version>2.4.1-SNAPSHOT</version>
+    <version>2.6.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -47,7 +47,31 @@
   </dependencies>
 
   <build>
+    <extensions>
+      <extension>
+        <groupId>kr.motd.maven</groupId>
+        <artifactId>os-maven-plugin</artifactId>
+        <version>1.6.2</version>
+      </extension>
+    </extensions>
     <plugins>
+      <plugin>
+        <groupId>org.xolstice.maven.plugins</groupId>
+        <artifactId>protobuf-maven-plugin</artifactId>
+        <version>0.6.1</version>
+        <executions>
+          <execution>
+            <phase>generate-test-sources</phase>
+            <goals>
+              <goal>test-compile</goal>
+            </goals>
+          </execution>
+        </executions>
+        <configuration>
+          <protoTestSourceRoot>src/test/protos</protoTestSourceRoot>
+          <protocArtifact>com.google.protobuf:protoc:${protobuf.version}:exe:${os.detected.classifier}</protocArtifact>
+        </configuration>
+      </plugin>
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-jar-plugin</artifactId>
diff --git a/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoConverterFactory.java b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoConverterFactory.java
index 6fb529429..d41ebd2f8 100644
--- a/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoConverterFactory.java
+++ b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoConverterFactory.java
@@ -51,9 +51,8 @@ private ProtoConverterFactory(@Nullable ExtensionRegistryLite registry) {
     this.registry = registry;
   }
 
-  @Override
-  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
+  @Override public @Nullable Converter<ResponseBody, ?> responseBodyConverter(
+      Type type, Annotation[] annotations, Retrofit retrofit) {
     if (!(type instanceof Class<?>)) {
       return null;
     }
@@ -84,8 +83,7 @@ private ProtoConverterFactory(@Nullable ExtensionRegistryLite registry) {
     return new ProtoResponseBodyConverter<>(parser, registry);
   }
 
-  @Override
-  public Converter<?, RequestBody> requestBodyConverter(Type type,
+  @Override public @Nullable Converter<?, RequestBody> requestBodyConverter(Type type,
       Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     if (!(type instanceof Class<?>)) {
       return null;
diff --git a/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoRequestBodyConverter.java b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoRequestBodyConverter.java
index 814dc326b..90905db40 100644
--- a/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoRequestBodyConverter.java
+++ b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoRequestBodyConverter.java
@@ -22,7 +22,7 @@
 import retrofit2.Converter;
 
 final class ProtoRequestBodyConverter<T extends MessageLite> implements Converter<T, RequestBody> {
-  private static final MediaType MEDIA_TYPE = MediaType.parse("application/x-protobuf");
+  private static final MediaType MEDIA_TYPE = MediaType.get("application/x-protobuf");
 
   @Override public RequestBody convert(T value) throws IOException {
     byte[] bytes = value.toByteArray();
diff --git a/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoResponseBodyConverter.java b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoResponseBodyConverter.java
index fc840dc64..57daa759b 100644
--- a/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoResponseBodyConverter.java
+++ b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoResponseBodyConverter.java
@@ -36,7 +36,8 @@
 
   @Override public T convert(ResponseBody value) throws IOException {
     try {
-      return parser.parseFrom(value.byteStream(), registry);
+      return registry == null ? parser.parseFrom(value.byteStream())
+              : parser.parseFrom(value.byteStream(), registry);
     } catch (InvalidProtocolBufferException e) {
       throw new RuntimeException(e); // Despite extending IOException, this is data mismatch.
     } finally {
diff --git a/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/package-info.java b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/package-info.java
index c976ca568..84ed323c0 100644
--- a/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/package-info.java
+++ b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/package-info.java
@@ -1,4 +1,2 @@
-@ParametersAreNonnullByDefault
+@retrofit2.internal.EverythingIsNonNull
 package retrofit2.converter.protobuf;
-
-import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-converters/protobuf/src/test/gen-protos.sh b/retrofit-converters/protobuf/src/test/gen-protos.sh
deleted file mode 100755
index 999d7f533..000000000
--- a/retrofit-converters/protobuf/src/test/gen-protos.sh
+++ /dev/null
@@ -1,4 +0,0 @@
-#!/bin/bash
-
-set -ex
-protoc --java_out=java/ protos/phone.proto
diff --git a/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/PhoneProtos.java b/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/PhoneProtos.java
deleted file mode 100644
index 3ad1bb0f6..000000000
--- a/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/PhoneProtos.java
+++ /dev/null
@@ -1,656 +0,0 @@
-// Generated by the protocol buffer compiler.  DO NOT EDIT!
-// source: protos/phone.proto
-
-package retrofit2.converter.protobuf;
-
-public final class PhoneProtos {
-  private PhoneProtos() {}
-  public static void registerAllExtensions(
-      com.google.protobuf.ExtensionRegistryLite registry) {
-    registry.add(retrofit2.converter.protobuf.PhoneProtos.voicemail);
-  }
-
-  public static void registerAllExtensions(
-      com.google.protobuf.ExtensionRegistry registry) {
-    registerAllExtensions(
-        (com.google.protobuf.ExtensionRegistryLite) registry);
-  }
-  public interface PhoneOrBuilder extends
-      // @@protoc_insertion_point(interface_extends:retrofit2.converter.protobuf.Phone)
-      com.google.protobuf.GeneratedMessage.
-          ExtendableMessageOrBuilder<Phone> {
-
-    /**
-     * <code>optional string number = 1;</code>
-     */
-    boolean hasNumber();
-    /**
-     * <code>optional string number = 1;</code>
-     */
-    java.lang.String getNumber();
-    /**
-     * <code>optional string number = 1;</code>
-     */
-    com.google.protobuf.ByteString
-        getNumberBytes();
-  }
-  /**
-   * Protobuf type {@code retrofit2.converter.protobuf.Phone}
-   */
-  public  static final class Phone extends
-      com.google.protobuf.GeneratedMessage.ExtendableMessage<
-        Phone> implements
-      // @@protoc_insertion_point(message_implements:retrofit2.converter.protobuf.Phone)
-      PhoneOrBuilder {
-    // Use Phone.newBuilder() to construct.
-    private Phone(com.google.protobuf.GeneratedMessage.ExtendableBuilder<retrofit2.converter.protobuf.PhoneProtos.Phone, ?> builder) {
-      super(builder);
-    }
-    private Phone() {
-      number_ = "";
-    }
-
-    @java.lang.Override
-    public final com.google.protobuf.UnknownFieldSet
-    getUnknownFields() {
-      return this.unknownFields;
-    }
-    private Phone(
-        com.google.protobuf.CodedInputStream input,
-        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
-        throws com.google.protobuf.InvalidProtocolBufferException {
-      this();
-      int mutable_bitField0_ = 0;
-      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
-          com.google.protobuf.UnknownFieldSet.newBuilder();
-      try {
-        boolean done = false;
-        while (!done) {
-          int tag = input.readTag();
-          switch (tag) {
-            case 0:
-              done = true;
-              break;
-            default: {
-              if (!parseUnknownField(input, unknownFields,
-                                     extensionRegistry, tag)) {
-                done = true;
-              }
-              break;
-            }
-            case 10: {
-              com.google.protobuf.ByteString bs = input.readBytes();
-              bitField0_ |= 0x00000001;
-              number_ = bs;
-              break;
-            }
-          }
-        }
-      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
-        throw e.setUnfinishedMessage(this);
-      } catch (java.io.IOException e) {
-        throw new com.google.protobuf.InvalidProtocolBufferException(
-            e).setUnfinishedMessage(this);
-      } finally {
-        this.unknownFields = unknownFields.build();
-        makeExtensionsImmutable();
-      }
-    }
-    public static final com.google.protobuf.Descriptors.Descriptor
-        getDescriptor() {
-      return retrofit2.converter.protobuf.PhoneProtos.internal_static_retrofit2_converter_protobuf_Phone_descriptor;
-    }
-
-    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
-        internalGetFieldAccessorTable() {
-      return retrofit2.converter.protobuf.PhoneProtos.internal_static_retrofit2_converter_protobuf_Phone_fieldAccessorTable
-          .ensureFieldAccessorsInitialized(
-              retrofit2.converter.protobuf.PhoneProtos.Phone.class, retrofit2.converter.protobuf.PhoneProtos.Phone.Builder.class);
-    }
-
-    private int bitField0_;
-    public static final int NUMBER_FIELD_NUMBER = 1;
-    private volatile java.lang.Object number_;
-    /**
-     * <code>optional string number = 1;</code>
-     */
-    public boolean hasNumber() {
-      return ((bitField0_ & 0x00000001) == 0x00000001);
-    }
-    /**
-     * <code>optional string number = 1;</code>
-     */
-    public java.lang.String getNumber() {
-      java.lang.Object ref = number_;
-      if (ref instanceof java.lang.String) {
-        return (java.lang.String) ref;
-      } else {
-        com.google.protobuf.ByteString bs = 
-            (com.google.protobuf.ByteString) ref;
-        java.lang.String s = bs.toStringUtf8();
-        if (bs.isValidUtf8()) {
-          number_ = s;
-        }
-        return s;
-      }
-    }
-    /**
-     * <code>optional string number = 1;</code>
-     */
-    public com.google.protobuf.ByteString
-        getNumberBytes() {
-      java.lang.Object ref = number_;
-      if (ref instanceof java.lang.String) {
-        com.google.protobuf.ByteString b = 
-            com.google.protobuf.ByteString.copyFromUtf8(
-                (java.lang.String) ref);
-        number_ = b;
-        return b;
-      } else {
-        return (com.google.protobuf.ByteString) ref;
-      }
-    }
-
-    private byte memoizedIsInitialized = -1;
-    public final boolean isInitialized() {
-      byte isInitialized = memoizedIsInitialized;
-      if (isInitialized == 1) return true;
-      if (isInitialized == 0) return false;
-
-      if (!extensionsAreInitialized()) {
-        memoizedIsInitialized = 0;
-        return false;
-      }
-      memoizedIsInitialized = 1;
-      return true;
-    }
-
-    public void writeTo(com.google.protobuf.CodedOutputStream output)
-                        throws java.io.IOException {
-      com.google.protobuf.GeneratedMessage
-        .ExtendableMessage<retrofit2.converter.protobuf.PhoneProtos.Phone>.ExtensionWriter
-          extensionWriter = newExtensionWriter();
-      if (((bitField0_ & 0x00000001) == 0x00000001)) {
-        com.google.protobuf.GeneratedMessage.writeString(output, 1, number_);
-      }
-      extensionWriter.writeUntil(3, output);
-      unknownFields.writeTo(output);
-    }
-
-    public int getSerializedSize() {
-      int size = memoizedSize;
-      if (size != -1) return size;
-
-      size = 0;
-      if (((bitField0_ & 0x00000001) == 0x00000001)) {
-        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, number_);
-      }
-      size += extensionsSerializedSize();
-      size += unknownFields.getSerializedSize();
-      memoizedSize = size;
-      return size;
-    }
-
-    private static final long serialVersionUID = 0L;
-    @java.lang.Override
-    public boolean equals(final java.lang.Object obj) {
-      if (obj == this) {
-       return true;
-      }
-      if (!(obj instanceof retrofit2.converter.protobuf.PhoneProtos.Phone)) {
-        return super.equals(obj);
-      }
-      retrofit2.converter.protobuf.PhoneProtos.Phone other = (retrofit2.converter.protobuf.PhoneProtos.Phone) obj;
-
-      boolean result = true;
-      result = result && (hasNumber() == other.hasNumber());
-      if (hasNumber()) {
-        result = result && getNumber()
-            .equals(other.getNumber());
-      }
-      result = result && unknownFields.equals(other.unknownFields);
-      result = result &&
-          getExtensionFields().equals(other.getExtensionFields());
-      return result;
-    }
-
-    @java.lang.Override
-    public int hashCode() {
-      if (memoizedHashCode != 0) {
-        return memoizedHashCode;
-      }
-      int hash = 41;
-      hash = (19 * hash) + getDescriptorForType().hashCode();
-      if (hasNumber()) {
-        hash = (37 * hash) + NUMBER_FIELD_NUMBER;
-        hash = (53 * hash) + getNumber().hashCode();
-      }
-      hash = hashFields(hash, getExtensionFields());
-      hash = (29 * hash) + unknownFields.hashCode();
-      memoizedHashCode = hash;
-      return hash;
-    }
-
-    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(
-        com.google.protobuf.ByteString data)
-        throws com.google.protobuf.InvalidProtocolBufferException {
-      return PARSER.parseFrom(data);
-    }
-    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(
-        com.google.protobuf.ByteString data,
-        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
-        throws com.google.protobuf.InvalidProtocolBufferException {
-      return PARSER.parseFrom(data, extensionRegistry);
-    }
-    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(byte[] data)
-        throws com.google.protobuf.InvalidProtocolBufferException {
-      return PARSER.parseFrom(data);
-    }
-    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(
-        byte[] data,
-        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
-        throws com.google.protobuf.InvalidProtocolBufferException {
-      return PARSER.parseFrom(data, extensionRegistry);
-    }
-    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(java.io.InputStream input)
-        throws java.io.IOException {
-      return com.google.protobuf.GeneratedMessage
-          .parseWithIOException(PARSER, input);
-    }
-    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(
-        java.io.InputStream input,
-        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
-        throws java.io.IOException {
-      return com.google.protobuf.GeneratedMessage
-          .parseWithIOException(PARSER, input, extensionRegistry);
-    }
-    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseDelimitedFrom(java.io.InputStream input)
-        throws java.io.IOException {
-      return com.google.protobuf.GeneratedMessage
-          .parseDelimitedWithIOException(PARSER, input);
-    }
-    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseDelimitedFrom(
-        java.io.InputStream input,
-        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
-        throws java.io.IOException {
-      return com.google.protobuf.GeneratedMessage
-          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
-    }
-    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(
-        com.google.protobuf.CodedInputStream input)
-        throws java.io.IOException {
-      return com.google.protobuf.GeneratedMessage
-          .parseWithIOException(PARSER, input);
-    }
-    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(
-        com.google.protobuf.CodedInputStream input,
-        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
-        throws java.io.IOException {
-      return com.google.protobuf.GeneratedMessage
-          .parseWithIOException(PARSER, input, extensionRegistry);
-    }
-
-    public Builder newBuilderForType() { return newBuilder(); }
-    public static Builder newBuilder() {
-      return DEFAULT_INSTANCE.toBuilder();
-    }
-    public static Builder newBuilder(retrofit2.converter.protobuf.PhoneProtos.Phone prototype) {
-      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
-    }
-    public Builder toBuilder() {
-      return this == DEFAULT_INSTANCE
-          ? new Builder() : new Builder().mergeFrom(this);
-    }
-
-    @java.lang.Override
-    protected Builder newBuilderForType(
-        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
-      Builder builder = new Builder(parent);
-      return builder;
-    }
-    /**
-     * Protobuf type {@code retrofit2.converter.protobuf.Phone}
-     */
-    public static final class Builder extends
-        com.google.protobuf.GeneratedMessage.ExtendableBuilder<
-          retrofit2.converter.protobuf.PhoneProtos.Phone, Builder> implements
-        // @@protoc_insertion_point(builder_implements:retrofit2.converter.protobuf.Phone)
-        retrofit2.converter.protobuf.PhoneProtos.PhoneOrBuilder {
-      public static final com.google.protobuf.Descriptors.Descriptor
-          getDescriptor() {
-        return retrofit2.converter.protobuf.PhoneProtos.internal_static_retrofit2_converter_protobuf_Phone_descriptor;
-      }
-
-      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
-          internalGetFieldAccessorTable() {
-        return retrofit2.converter.protobuf.PhoneProtos.internal_static_retrofit2_converter_protobuf_Phone_fieldAccessorTable
-            .ensureFieldAccessorsInitialized(
-                retrofit2.converter.protobuf.PhoneProtos.Phone.class, retrofit2.converter.protobuf.PhoneProtos.Phone.Builder.class);
-      }
-
-      // Construct using retrofit2.converter.protobuf.PhoneProtos.Phone.newBuilder()
-      private Builder() {
-        maybeForceBuilderInitialization();
-      }
-
-      private Builder(
-          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
-        super(parent);
-        maybeForceBuilderInitialization();
-      }
-      private void maybeForceBuilderInitialization() {
-        if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {
-        }
-      }
-      public Builder clear() {
-        super.clear();
-        number_ = "";
-        bitField0_ = (bitField0_ & ~0x00000001);
-        return this;
-      }
-
-      public com.google.protobuf.Descriptors.Descriptor
-          getDescriptorForType() {
-        return retrofit2.converter.protobuf.PhoneProtos.internal_static_retrofit2_converter_protobuf_Phone_descriptor;
-      }
-
-      public retrofit2.converter.protobuf.PhoneProtos.Phone getDefaultInstanceForType() {
-        return retrofit2.converter.protobuf.PhoneProtos.Phone.getDefaultInstance();
-      }
-
-      public retrofit2.converter.protobuf.PhoneProtos.Phone build() {
-        retrofit2.converter.protobuf.PhoneProtos.Phone result = buildPartial();
-        if (!result.isInitialized()) {
-          throw newUninitializedMessageException(result);
-        }
-        return result;
-      }
-
-      public retrofit2.converter.protobuf.PhoneProtos.Phone buildPartial() {
-        retrofit2.converter.protobuf.PhoneProtos.Phone result = new retrofit2.converter.protobuf.PhoneProtos.Phone(this);
-        int from_bitField0_ = bitField0_;
-        int to_bitField0_ = 0;
-        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
-          to_bitField0_ |= 0x00000001;
-        }
-        result.number_ = number_;
-        result.bitField0_ = to_bitField0_;
-        onBuilt();
-        return result;
-      }
-
-      public Builder clone() {
-        return (Builder) super.clone();
-      }
-      public Builder setField(
-          com.google.protobuf.Descriptors.FieldDescriptor field,
-          Object value) {
-        return (Builder) super.setField(field, value);
-      }
-      public Builder clearField(
-          com.google.protobuf.Descriptors.FieldDescriptor field) {
-        return (Builder) super.clearField(field);
-      }
-      public Builder clearOneof(
-          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
-        return (Builder) super.clearOneof(oneof);
-      }
-      public Builder setRepeatedField(
-          com.google.protobuf.Descriptors.FieldDescriptor field,
-          int index, Object value) {
-        return (Builder) super.setRepeatedField(field, index, value);
-      }
-      public Builder addRepeatedField(
-          com.google.protobuf.Descriptors.FieldDescriptor field,
-          Object value) {
-        return (Builder) super.addRepeatedField(field, value);
-      }
-      public <Type> Builder setExtension(
-          com.google.protobuf.GeneratedMessage.GeneratedExtension<
-              retrofit2.converter.protobuf.PhoneProtos.Phone, Type> extension,
-          Type value) {
-        return (Builder) super.setExtension(extension, value);
-      }
-      public <Type> Builder setExtension(
-          com.google.protobuf.GeneratedMessage.GeneratedExtension<
-              retrofit2.converter.protobuf.PhoneProtos.Phone, java.util.List<Type>> extension,
-          int index, Type value) {
-        return (Builder) super.setExtension(extension, index, value);
-      }
-      public <Type> Builder addExtension(
-          com.google.protobuf.GeneratedMessage.GeneratedExtension<
-              retrofit2.converter.protobuf.PhoneProtos.Phone, java.util.List<Type>> extension,
-          Type value) {
-        return (Builder) super.addExtension(extension, value);
-      }
-      public <Type> Builder clearExtension(
-          com.google.protobuf.GeneratedMessage.GeneratedExtension<
-              retrofit2.converter.protobuf.PhoneProtos.Phone, ?> extension) {
-        return (Builder) super.clearExtension(extension);
-      }
-      public Builder mergeFrom(com.google.protobuf.Message other) {
-        if (other instanceof retrofit2.converter.protobuf.PhoneProtos.Phone) {
-          return mergeFrom((retrofit2.converter.protobuf.PhoneProtos.Phone)other);
-        } else {
-          super.mergeFrom(other);
-          return this;
-        }
-      }
-
-      public Builder mergeFrom(retrofit2.converter.protobuf.PhoneProtos.Phone other) {
-        if (other == retrofit2.converter.protobuf.PhoneProtos.Phone.getDefaultInstance()) return this;
-        if (other.hasNumber()) {
-          bitField0_ |= 0x00000001;
-          number_ = other.number_;
-          onChanged();
-        }
-        this.mergeExtensionFields(other);
-        this.mergeUnknownFields(other.unknownFields);
-        onChanged();
-        return this;
-      }
-
-      public final boolean isInitialized() {
-        if (!extensionsAreInitialized()) {
-          return false;
-        }
-        return true;
-      }
-
-      public Builder mergeFrom(
-          com.google.protobuf.CodedInputStream input,
-          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
-          throws java.io.IOException {
-        retrofit2.converter.protobuf.PhoneProtos.Phone parsedMessage = null;
-        try {
-          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
-        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
-          parsedMessage = (retrofit2.converter.protobuf.PhoneProtos.Phone) e.getUnfinishedMessage();
-          throw e.unwrapIOException();
-        } finally {
-          if (parsedMessage != null) {
-            mergeFrom(parsedMessage);
-          }
-        }
-        return this;
-      }
-      private int bitField0_;
-
-      private java.lang.Object number_ = "";
-      /**
-       * <code>optional string number = 1;</code>
-       */
-      public boolean hasNumber() {
-        return ((bitField0_ & 0x00000001) == 0x00000001);
-      }
-      /**
-       * <code>optional string number = 1;</code>
-       */
-      public java.lang.String getNumber() {
-        java.lang.Object ref = number_;
-        if (!(ref instanceof java.lang.String)) {
-          com.google.protobuf.ByteString bs =
-              (com.google.protobuf.ByteString) ref;
-          java.lang.String s = bs.toStringUtf8();
-          if (bs.isValidUtf8()) {
-            number_ = s;
-          }
-          return s;
-        } else {
-          return (java.lang.String) ref;
-        }
-      }
-      /**
-       * <code>optional string number = 1;</code>
-       */
-      public com.google.protobuf.ByteString
-          getNumberBytes() {
-        java.lang.Object ref = number_;
-        if (ref instanceof String) {
-          com.google.protobuf.ByteString b = 
-              com.google.protobuf.ByteString.copyFromUtf8(
-                  (java.lang.String) ref);
-          number_ = b;
-          return b;
-        } else {
-          return (com.google.protobuf.ByteString) ref;
-        }
-      }
-      /**
-       * <code>optional string number = 1;</code>
-       */
-      public Builder setNumber(
-          java.lang.String value) {
-        if (value == null) {
-    throw new NullPointerException();
-  }
-  bitField0_ |= 0x00000001;
-        number_ = value;
-        onChanged();
-        return this;
-      }
-      /**
-       * <code>optional string number = 1;</code>
-       */
-      public Builder clearNumber() {
-        bitField0_ = (bitField0_ & ~0x00000001);
-        number_ = getDefaultInstance().getNumber();
-        onChanged();
-        return this;
-      }
-      /**
-       * <code>optional string number = 1;</code>
-       */
-      public Builder setNumberBytes(
-          com.google.protobuf.ByteString value) {
-        if (value == null) {
-    throw new NullPointerException();
-  }
-  bitField0_ |= 0x00000001;
-        number_ = value;
-        onChanged();
-        return this;
-      }
-      public final Builder setUnknownFields(
-          final com.google.protobuf.UnknownFieldSet unknownFields) {
-        return super.setUnknownFields(unknownFields);
-      }
-
-      public final Builder mergeUnknownFields(
-          final com.google.protobuf.UnknownFieldSet unknownFields) {
-        return super.mergeUnknownFields(unknownFields);
-      }
-
-
-      // @@protoc_insertion_point(builder_scope:retrofit2.converter.protobuf.Phone)
-    }
-
-    // @@protoc_insertion_point(class_scope:retrofit2.converter.protobuf.Phone)
-    private static final retrofit2.converter.protobuf.PhoneProtos.Phone DEFAULT_INSTANCE;
-    static {
-      DEFAULT_INSTANCE = new retrofit2.converter.protobuf.PhoneProtos.Phone();
-    }
-
-    public static retrofit2.converter.protobuf.PhoneProtos.Phone getDefaultInstance() {
-      return DEFAULT_INSTANCE;
-    }
-
-    @java.lang.Deprecated public static final com.google.protobuf.Parser<Phone>
-        PARSER = new com.google.protobuf.AbstractParser<Phone>() {
-      public Phone parsePartialFrom(
-          com.google.protobuf.CodedInputStream input,
-          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
-          throws com.google.protobuf.InvalidProtocolBufferException {
-          return new Phone(input, extensionRegistry);
-      }
-    };
-
-    public static com.google.protobuf.Parser<Phone> parser() {
-      return PARSER;
-    }
-
-    @java.lang.Override
-    public com.google.protobuf.Parser<Phone> getParserForType() {
-      return PARSER;
-    }
-
-    public retrofit2.converter.protobuf.PhoneProtos.Phone getDefaultInstanceForType() {
-      return DEFAULT_INSTANCE;
-    }
-
-  }
-
-  public static final int VOICEMAIL_FIELD_NUMBER = 2;
-  /**
-   * <code>extend .retrofit2.converter.protobuf.Phone { ... }</code>
-   */
-  public static final
-    com.google.protobuf.GeneratedMessage.GeneratedExtension<
-      retrofit2.converter.protobuf.PhoneProtos.Phone,
-      java.lang.Boolean> voicemail = com.google.protobuf.GeneratedMessage
-          .newFileScopedGeneratedExtension(
-        java.lang.Boolean.class,
-        null);
-  private static final com.google.protobuf.Descriptors.Descriptor
-    internal_static_retrofit2_converter_protobuf_Phone_descriptor;
-  private static final 
-    com.google.protobuf.GeneratedMessage.FieldAccessorTable
-      internal_static_retrofit2_converter_protobuf_Phone_fieldAccessorTable;
-
-  public static com.google.protobuf.Descriptors.FileDescriptor
-      getDescriptor() {
-    return descriptor;
-  }
-  private static  com.google.protobuf.Descriptors.FileDescriptor
-      descriptor;
-  static {
-    java.lang.String[] descriptorData = {
-      "\n\022protos/phone.proto\022\034retrofit2.converte" +
-      "r.protobuf\"\035\n\005Phone\022\016\n\006number\030\001 \001(\t*\004\010\002\020" +
-      "\003:6\n\tvoicemail\022#.retrofit2.converter.pro" +
-      "tobuf.Phone\030\002 \001(\010B+\n\034retrofit2.converter" +
-      ".protobufB\013PhoneProtos"
-    };
-    com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner assigner =
-        new com.google.protobuf.Descriptors.FileDescriptor.    InternalDescriptorAssigner() {
-          public com.google.protobuf.ExtensionRegistry assignDescriptors(
-              com.google.protobuf.Descriptors.FileDescriptor root) {
-            descriptor = root;
-            return null;
-          }
-        };
-    com.google.protobuf.Descriptors.FileDescriptor
-      .internalBuildGeneratedFileFrom(descriptorData,
-        new com.google.protobuf.Descriptors.FileDescriptor[] {
-        }, assigner);
-    internal_static_retrofit2_converter_protobuf_Phone_descriptor =
-      getDescriptor().getMessageTypes().get(0);
-    internal_static_retrofit2_converter_protobuf_Phone_fieldAccessorTable = new
-      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
-        internal_static_retrofit2_converter_protobuf_Phone_descriptor,
-        new java.lang.String[] { "Number", });
-    voicemail.internalInit(descriptor.getExtensions().get(0));
-  }
-
-  // @@protoc_insertion_point(outer_class_scope)
-}
diff --git a/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/ProtoConverterFactoryTest.java b/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/ProtoConverterFactoryTest.java
index 5a585b21f..6f4cdf28e 100644
--- a/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/ProtoConverterFactoryTest.java
+++ b/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/ProtoConverterFactoryTest.java
@@ -119,7 +119,8 @@
           + "Could not locate ResponseBody converter for class java.lang.String.\n"
           + "  Tried:\n"
           + "   * retrofit2.BuiltInConverters\n"
-          + "   * retrofit2.converter.protobuf.ProtoConverterFactory");
+          + "   * retrofit2.converter.protobuf.ProtoConverterFactory\n"
+          + "   * retrofit2.OptionalConverterFactory");
     }
   }
 
@@ -138,7 +139,8 @@
           + "Could not locate ResponseBody converter for java.util.List<java.lang.String>.\n"
           + "  Tried:\n"
           + "   * retrofit2.BuiltInConverters\n"
-          + "   * retrofit2.converter.protobuf.ProtoConverterFactory");
+          + "   * retrofit2.converter.protobuf.ProtoConverterFactory\n"
+          + "   * retrofit2.OptionalConverterFactory");
     }
   }
 
diff --git a/retrofit-converters/scalars/README.md b/retrofit-converters/scalars/README.md
index 5231b6129..67f0fd15b 100644
--- a/retrofit-converters/scalars/README.md
+++ b/retrofit-converters/scalars/README.md
@@ -18,7 +18,7 @@ Download [the latest JAR][1] or grab via [Maven][2]:
 ```
 or [Gradle][2]:
 ```groovy
-compile 'com.squareup.retrofit2:converter-scalars:latest.version'
+implementation 'com.squareup.retrofit2:converter-scalars:latest.version'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/retrofit-converters/scalars/pom.xml b/retrofit-converters/scalars/pom.xml
index 7a019e69d..daa0b6838 100644
--- a/retrofit-converters/scalars/pom.xml
+++ b/retrofit-converters/scalars/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-converters</artifactId>
-    <version>2.4.1-SNAPSHOT</version>
+    <version>2.6.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
diff --git a/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarRequestBodyConverter.java b/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarRequestBodyConverter.java
index fd65200d4..fb2f4ec43 100644
--- a/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarRequestBodyConverter.java
+++ b/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarRequestBodyConverter.java
@@ -22,7 +22,7 @@
 
 final class ScalarRequestBodyConverter<T> implements Converter<T, RequestBody> {
   static final ScalarRequestBodyConverter<Object> INSTANCE = new ScalarRequestBodyConverter<>();
-  private static final MediaType MEDIA_TYPE = MediaType.parse("text/plain; charset=UTF-8");
+  private static final MediaType MEDIA_TYPE = MediaType.get("text/plain; charset=UTF-8");
 
   private ScalarRequestBodyConverter() {
   }
diff --git a/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarsConverterFactory.java b/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarsConverterFactory.java
index 5bf838fe9..73189634d 100644
--- a/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarsConverterFactory.java
+++ b/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarsConverterFactory.java
@@ -17,6 +17,7 @@
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+import javax.annotation.Nullable;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import retrofit2.Converter;
@@ -43,7 +44,7 @@ public static ScalarsConverterFactory create() {
   private ScalarsConverterFactory() {
   }
 
-  @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
+  @Override public @Nullable Converter<?, RequestBody> requestBodyConverter(Type type,
       Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     if (type == String.class
         || type == boolean.class
@@ -67,9 +68,8 @@ private ScalarsConverterFactory() {
     return null;
   }
 
-  @Override
-  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
+  @Override public @Nullable Converter<ResponseBody, ?> responseBodyConverter(
+      Type type, Annotation[] annotations, Retrofit retrofit) {
     if (type == String.class) {
       return StringResponseBodyConverter.INSTANCE;
     }
diff --git a/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/package-info.java b/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/package-info.java
index 0ea2f7740..ffb138825 100644
--- a/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/package-info.java
+++ b/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/package-info.java
@@ -1,4 +1,2 @@
-@ParametersAreNonnullByDefault
+@retrofit2.internal.EverythingIsNonNull
 package retrofit2.converter.scalars;
-
-import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-converters/scalars/src/test/java/retrofit2/converter/scalars/ScalarsConverterFactoryTest.java b/retrofit-converters/scalars/src/test/java/retrofit2/converter/scalars/ScalarsConverterFactoryTest.java
index cc19d4fbc..6e39dd537 100644
--- a/retrofit-converters/scalars/src/test/java/retrofit2/converter/scalars/ScalarsConverterFactoryTest.java
+++ b/retrofit-converters/scalars/src/test/java/retrofit2/converter/scalars/ScalarsConverterFactoryTest.java
@@ -26,7 +26,6 @@
 import retrofit2.Call;
 import retrofit2.Response;
 import retrofit2.Retrofit;
-import retrofit2.converter.scalars.ScalarsConverterFactory;
 import retrofit2.http.Body;
 import retrofit2.http.GET;
 import retrofit2.http.POST;
@@ -93,7 +92,8 @@
           + "Could not locate RequestBody converter for class java.lang.Object.\n"
           + "  Tried:\n"
           + "   * retrofit2.BuiltInConverters\n"
-          + "   * retrofit2.converter.scalars.ScalarsConverterFactory");
+          + "   * retrofit2.converter.scalars.ScalarsConverterFactory\n"
+          + "   * retrofit2.OptionalConverterFactory");
     }
   }
 
@@ -232,7 +232,8 @@
           + "Could not locate ResponseBody converter for class java.lang.Object.\n"
           + "  Tried:\n"
           + "   * retrofit2.BuiltInConverters\n"
-          + "   * retrofit2.converter.scalars.ScalarsConverterFactory");
+          + "   * retrofit2.converter.scalars.ScalarsConverterFactory\n"
+          + "   * retrofit2.OptionalConverterFactory");
     }
   }
 
diff --git a/retrofit-converters/simplexml/README.md b/retrofit-converters/simplexml/README.md
index 37e6f8f50..1a7ca6bf6 100644
--- a/retrofit-converters/simplexml/README.md
+++ b/retrofit-converters/simplexml/README.md
@@ -36,7 +36,7 @@ Download [the latest JAR][2] or grab via [Maven][3]:
 ```
 or [Gradle][3]:
 ```groovy
-compile 'com.squareup.retrofit2:converter-simplexml:latest.version'
+implementation 'com.squareup.retrofit2:converter-simplexml:latest.version'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/retrofit-converters/simplexml/pom.xml b/retrofit-converters/simplexml/pom.xml
index 109208e2e..360212071 100644
--- a/retrofit-converters/simplexml/pom.xml
+++ b/retrofit-converters/simplexml/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-converters</artifactId>
-    <version>2.4.1-SNAPSHOT</version>
+    <version>2.6.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
diff --git a/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlConverterFactory.java b/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlConverterFactory.java
index 793806d1d..a961721ca 100644
--- a/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlConverterFactory.java
+++ b/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlConverterFactory.java
@@ -17,6 +17,7 @@
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+import javax.annotation.Nullable;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import org.simpleframework.xml.Serializer;
@@ -78,8 +79,7 @@ public boolean isStrict() {
     return new SimpleXmlResponseBodyConverter<>(cls, serializer, strict);
   }
 
-  @Override
-  public Converter<?, RequestBody> requestBodyConverter(Type type,
+  @Override public @Nullable Converter<?, RequestBody> requestBodyConverter(Type type,
       Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     if (!(type instanceof Class)) {
       return null;
diff --git a/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlRequestBodyConverter.java b/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlRequestBodyConverter.java
index cb1c9dcb7..645b4bb73 100644
--- a/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlRequestBodyConverter.java
+++ b/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlRequestBodyConverter.java
@@ -24,7 +24,7 @@
 import retrofit2.Converter;
 
 final class SimpleXmlRequestBodyConverter<T> implements Converter<T, RequestBody> {
-  private static final MediaType MEDIA_TYPE = MediaType.parse("application/xml; charset=UTF-8");
+  private static final MediaType MEDIA_TYPE = MediaType.get("application/xml; charset=UTF-8");
   private static final String CHARSET = "UTF-8";
 
   private final Serializer serializer;
diff --git a/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/package-info.java b/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/package-info.java
index 69507b872..b12e7e178 100644
--- a/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/package-info.java
+++ b/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/package-info.java
@@ -1,4 +1,2 @@
-@ParametersAreNonnullByDefault
+@retrofit2.internal.EverythingIsNonNull
 package retrofit2.converter.simplexml;
-
-import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-converters/wire/README.md b/retrofit-converters/wire/README.md
index 6289cc8a7..eec260fd4 100644
--- a/retrofit-converters/wire/README.md
+++ b/retrofit-converters/wire/README.md
@@ -17,7 +17,7 @@ Download [the latest JAR][2] or grab via [Maven][3]:
 ```
 or [Gradle][3]:
 ```groovy
-compile 'com.squareup.retrofit2:converter-wire:latest.version'
+implementation 'com.squareup.retrofit2:converter-wire:latest.version'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/retrofit-converters/wire/pom.xml b/retrofit-converters/wire/pom.xml
index 333e91813..5d188cf89 100644
--- a/retrofit-converters/wire/pom.xml
+++ b/retrofit-converters/wire/pom.xml
@@ -10,7 +10,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-converters</artifactId>
-    <version>2.4.1-SNAPSHOT</version>
+    <version>2.6.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
diff --git a/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireConverterFactory.java b/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireConverterFactory.java
index fbaaeac4a..b97ce1011 100644
--- a/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireConverterFactory.java
+++ b/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireConverterFactory.java
@@ -19,6 +19,7 @@
 import com.squareup.wire.ProtoAdapter;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+import javax.annotation.Nullable;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import retrofit2.Converter;
@@ -37,9 +38,8 @@ public static WireConverterFactory create() {
   private WireConverterFactory() {
   }
 
-  @Override
-  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
+  @Override public @Nullable Converter<ResponseBody, ?> responseBodyConverter(
+      Type type, Annotation[] annotations, Retrofit retrofit) {
     if (!(type instanceof Class<?>)) {
       return null;
     }
@@ -52,8 +52,7 @@ private WireConverterFactory() {
     return new WireResponseBodyConverter<>(adapter);
   }
 
-  @Override
-  public Converter<?, RequestBody> requestBodyConverter(Type type,
+  @Override public @Nullable Converter<?, RequestBody> requestBodyConverter(Type type,
       Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     if (!(type instanceof Class<?>)) {
       return null;
diff --git a/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireRequestBodyConverter.java b/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireRequestBodyConverter.java
index d388a944c..fd6cc3291 100644
--- a/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireRequestBodyConverter.java
+++ b/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireRequestBodyConverter.java
@@ -24,7 +24,7 @@
 import retrofit2.Converter;
 
 final class WireRequestBodyConverter<T extends Message<T, ?>> implements Converter<T, RequestBody> {
-  private static final MediaType MEDIA_TYPE = MediaType.parse("application/x-protobuf");
+  private static final MediaType MEDIA_TYPE = MediaType.get("application/x-protobuf");
 
   private final ProtoAdapter<T> adapter;
 
diff --git a/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/package-info.java b/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/package-info.java
index 483b65c81..fb1bd79c6 100644
--- a/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/package-info.java
+++ b/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/package-info.java
@@ -1,4 +1,2 @@
-@ParametersAreNonnullByDefault
+@retrofit2.internal.EverythingIsNonNull
 package retrofit2.converter.wire;
-
-import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-converters/wire/src/test/java/retrofit2/converter/wire/WireConverterFactoryTest.java b/retrofit-converters/wire/src/test/java/retrofit2/converter/wire/WireConverterFactoryTest.java
index e972d5287..486de11f5 100644
--- a/retrofit-converters/wire/src/test/java/retrofit2/converter/wire/WireConverterFactoryTest.java
+++ b/retrofit-converters/wire/src/test/java/retrofit2/converter/wire/WireConverterFactoryTest.java
@@ -94,7 +94,8 @@
           + "Could not locate ResponseBody converter for class java.lang.String.\n"
           + "  Tried:\n"
           + "   * retrofit2.BuiltInConverters\n"
-          + "   * retrofit2.converter.wire.WireConverterFactory");
+          + "   * retrofit2.converter.wire.WireConverterFactory\n"
+          + "   * retrofit2.OptionalConverterFactory");
     }
   }
 
@@ -113,7 +114,8 @@
           + "Could not locate ResponseBody converter for java.util.List<java.lang.String>.\n"
           + "  Tried:\n"
           + "   * retrofit2.BuiltInConverters\n"
-          + "   * retrofit2.converter.wire.WireConverterFactory");
+          + "   * retrofit2.converter.wire.WireConverterFactory\n"
+          + "   * retrofit2.OptionalConverterFactory");
     }
   }
 
diff --git a/retrofit-mock/README.md b/retrofit-mock/README.md
index 851e9e82d..d846650b4 100644
--- a/retrofit-mock/README.md
+++ b/retrofit-mock/README.md
@@ -16,7 +16,7 @@ Download [the latest JAR][1] or grab via [Maven][2]:
 ```
 or [Gradle][1]:
 ```groovy
-compile 'com.squareup.retrofit2:retrofit-mock:see.latest.version'
+implementation 'com.squareup.retrofit2:retrofit-mock:see.latest.version'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/retrofit-mock/pom.xml b/retrofit-mock/pom.xml
index 5f978b16b..7cd6d4e3a 100644
--- a/retrofit-mock/pom.xml
+++ b/retrofit-mock/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>parent</artifactId>
-    <version>2.4.1-SNAPSHOT</version>
+    <version>2.6.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -35,11 +35,6 @@
       <artifactId>assertj-core</artifactId>
       <scope>test</scope>
     </dependency>
-    <dependency>
-      <groupId>org.mockito</groupId>
-      <artifactId>mockito-core</artifactId>
-      <scope>test</scope>
-    </dependency>
   </dependencies>
 
   <build>
diff --git a/retrofit-mock/src/main/java/retrofit2/mock/BehaviorCall.java b/retrofit-mock/src/main/java/retrofit2/mock/BehaviorCall.java
index e7c48cf22..a41664876 100644
--- a/retrofit-mock/src/main/java/retrofit2/mock/BehaviorCall.java
+++ b/retrofit-mock/src/main/java/retrofit2/mock/BehaviorCall.java
@@ -20,6 +20,7 @@
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Future;
 import java.util.concurrent.atomic.AtomicReference;
+import javax.annotation.Nullable;
 import javax.annotation.concurrent.GuardedBy;
 import okhttp3.Request;
 import retrofit2.Call;
@@ -33,7 +34,7 @@
   final ExecutorService backgroundExecutor;
   final Call<T> delegate;
 
-  private volatile Future<?> task;
+  private volatile @Nullable Future<?> task;
   volatile boolean canceled;
   @GuardedBy("this")
   private boolean executed;
diff --git a/retrofit-mock/src/main/java/retrofit2/mock/Calls.java b/retrofit-mock/src/main/java/retrofit2/mock/Calls.java
index f0e9affbe..65d3afd4a 100644
--- a/retrofit-mock/src/main/java/retrofit2/mock/Calls.java
+++ b/retrofit-mock/src/main/java/retrofit2/mock/Calls.java
@@ -132,13 +132,15 @@ private Calls() {
       if (response != null) {
         return response.raw().request();
       }
-      return new Request.Builder().url("http://localhost").build();
+      return new Request.Builder()
+          .url("http://localhost")
+          .build();
     }
   }
 
   static final class DeferredCall<T> implements Call<T> {
     private final Callable<Call<T>> callable;
-    private Call<T> delegate;
+    private @Nullable Call<T> delegate;
 
     DeferredCall(Callable<Call<T>> callable) {
       this.callable = callable;
diff --git a/retrofit-mock/src/main/java/retrofit2/mock/MockRetrofit.java b/retrofit-mock/src/main/java/retrofit2/mock/MockRetrofit.java
index 40185baaa..e7708f591 100644
--- a/retrofit-mock/src/main/java/retrofit2/mock/MockRetrofit.java
+++ b/retrofit-mock/src/main/java/retrofit2/mock/MockRetrofit.java
@@ -18,6 +18,7 @@
 import java.util.concurrent.Executor;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
+import javax.annotation.Nullable;
 import retrofit2.Retrofit;
 
 public final class MockRetrofit {
@@ -50,8 +51,8 @@ public Executor backgroundExecutor() {
 
   public static final class Builder {
     private final Retrofit retrofit;
-    private NetworkBehavior behavior;
-    private ExecutorService executor;
+    private @Nullable NetworkBehavior behavior;
+    private @Nullable ExecutorService executor;
 
     @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
     public Builder(Retrofit retrofit) {
diff --git a/retrofit-mock/src/main/java/retrofit2/mock/package-info.java b/retrofit-mock/src/main/java/retrofit2/mock/package-info.java
index cb99df00c..f2e13328e 100644
--- a/retrofit-mock/src/main/java/retrofit2/mock/package-info.java
+++ b/retrofit-mock/src/main/java/retrofit2/mock/package-info.java
@@ -1,4 +1,2 @@
-@ParametersAreNonnullByDefault
+@retrofit2.internal.EverythingIsNonNull
 package retrofit2.mock;
-
-import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-mock/src/test/java/retrofit2/mock/CallsTest.java b/retrofit-mock/src/test/java/retrofit2/mock/CallsTest.java
index bf67cad9a..8b044175a 100644
--- a/retrofit-mock/src/test/java/retrofit2/mock/CallsTest.java
+++ b/retrofit-mock/src/test/java/retrofit2/mock/CallsTest.java
@@ -15,7 +15,6 @@
  */
 package retrofit2.mock;
 
-import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.security.cert.CertificateException;
 import java.util.concurrent.Callable;
@@ -24,7 +23,6 @@
 import retrofit2.Call;
 import retrofit2.Callback;
 import retrofit2.Response;
-import retrofit2.Retrofit;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.assertEquals;
diff --git a/retrofit/pom.xml b/retrofit/pom.xml
index e665b66e2..eab2b859a 100644
--- a/retrofit/pom.xml
+++ b/retrofit/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>parent</artifactId>
-    <version>2.4.1-SNAPSHOT</version>
+    <version>2.6.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -24,6 +24,16 @@
       <artifactId>android</artifactId>
       <optional>true</optional>
     </dependency>
+    <dependency>
+      <groupId>org.jetbrains.kotlin</groupId>
+      <artifactId>kotlin-stdlib</artifactId>
+      <optional>true</optional>
+    </dependency>
+    <dependency>
+      <groupId>org.jetbrains.kotlinx</groupId>
+      <artifactId>kotlinx-coroutines-core</artifactId>
+      <optional>true</optional>
+    </dependency>
 
     <dependency>
       <groupId>org.codehaus.mojo</groupId>
@@ -46,11 +56,6 @@
       <artifactId>assertj-core</artifactId>
       <scope>test</scope>
     </dependency>
-    <dependency>
-      <groupId>org.mockito</groupId>
-      <artifactId>mockito-core</artifactId>
-      <scope>test</scope>
-    </dependency>
     <dependency>
       <groupId>com.google.guava</groupId>
       <artifactId>guava</artifactId>
@@ -70,6 +75,26 @@
 
   <build>
     <plugins>
+      <plugin>
+        <groupId>org.jetbrains.kotlin</groupId>
+        <artifactId>kotlin-maven-plugin</artifactId>
+        <executions>
+          <execution>
+            <id>compile</id>
+            <phase>process-sources</phase>
+            <goals>
+              <goal>compile</goal>
+            </goals>
+          </execution>
+          <execution>
+            <id>test-compile</id>
+            <phase>test-compile</phase>
+            <goals>
+              <goal>test-compile</goal>
+            </goals>
+          </execution>
+        </executions>
+      </plugin>
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-jar-plugin</artifactId>
@@ -81,6 +106,14 @@
           </archive>
         </configuration>
       </plugin>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-javadoc-plugin</artifactId>
+        <version>2.10.4</version>
+        <configuration>
+          <excludePackageNames>retrofit2.internal</excludePackageNames>
+        </configuration>
+      </plugin>
     </plugins>
   </build>
 </project>
diff --git a/retrofit/src/main/java/retrofit2/BuiltInConverters.java b/retrofit/src/main/java/retrofit2/BuiltInConverters.java
index 86228d5c3..df0f1073d 100644
--- a/retrofit/src/main/java/retrofit2/BuiltInConverters.java
+++ b/retrofit/src/main/java/retrofit2/BuiltInConverters.java
@@ -18,14 +18,18 @@
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+import javax.annotation.Nullable;
+import kotlin.Unit;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import retrofit2.http.Streaming;
 
 final class BuiltInConverters extends Converter.Factory {
-  @Override
-  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
+  /** Not volatile because we don't mind multiple threads discovering this. */
+  private boolean checkForKotlinUnit = true;
+
+  @Override public @Nullable Converter<ResponseBody, ?> responseBodyConverter(
+      Type type, Annotation[] annotations, Retrofit retrofit) {
     if (type == ResponseBody.class) {
       return Utils.isAnnotationPresent(annotations, Streaming.class)
           ? StreamingResponseBodyConverter.INSTANCE
@@ -34,11 +38,19 @@
     if (type == Void.class) {
       return VoidResponseBodyConverter.INSTANCE;
     }
+    if (checkForKotlinUnit) {
+      try {
+        if (type == Unit.class) {
+          return UnitResponseBodyConverter.INSTANCE;
+        }
+      } catch (NoClassDefFoundError ignored) {
+        checkForKotlinUnit = false;
+      }
+    }
     return null;
   }
 
-  @Override
-  public Converter<?, RequestBody> requestBodyConverter(Type type,
+  @Override public @Nullable Converter<?, RequestBody> requestBodyConverter(Type type,
       Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     if (RequestBody.class.isAssignableFrom(Utils.getRawType(type))) {
       return RequestBodyConverter.INSTANCE;
@@ -55,6 +67,15 @@
     }
   }
 
+  static final class UnitResponseBodyConverter implements Converter<ResponseBody, Unit> {
+    static final UnitResponseBodyConverter INSTANCE = new UnitResponseBodyConverter();
+
+    @Override public Unit convert(ResponseBody value) {
+      value.close();
+      return Unit.INSTANCE;
+    }
+  }
+
   static final class RequestBodyConverter implements Converter<RequestBody, RequestBody> {
     static final RequestBodyConverter INSTANCE = new RequestBodyConverter();
 
diff --git a/retrofit/src/main/java/retrofit2/CompletableFutureCallAdapterFactory.java b/retrofit/src/main/java/retrofit2/CompletableFutureCallAdapterFactory.java
new file mode 100644
index 000000000..537c16412
--- /dev/null
+++ b/retrofit/src/main/java/retrofit2/CompletableFutureCallAdapterFactory.java
@@ -0,0 +1,130 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.util.concurrent.CompletableFuture;
+import javax.annotation.Nullable;
+import org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement;
+
+@IgnoreJRERequirement // Only added when CompletableFuture is available (Java 8+ / Android API 24+).
+final class CompletableFutureCallAdapterFactory extends CallAdapter.Factory {
+  static final CallAdapter.Factory INSTANCE = new CompletableFutureCallAdapterFactory();
+
+  @Override public @Nullable CallAdapter<?, ?> get(
+      Type returnType, Annotation[] annotations, Retrofit retrofit) {
+    if (getRawType(returnType) != CompletableFuture.class) {
+      return null;
+    }
+    if (!(returnType instanceof ParameterizedType)) {
+      throw new IllegalStateException("CompletableFuture return type must be parameterized"
+          + " as CompletableFuture<Foo> or CompletableFuture<? extends Foo>");
+    }
+    Type innerType = getParameterUpperBound(0, (ParameterizedType) returnType);
+
+    if (getRawType(innerType) != Response.class) {
+      // Generic type is not Response<T>. Use it for body-only adapter.
+      return new BodyCallAdapter<>(innerType);
+    }
+
+    // Generic type is Response<T>. Extract T and create the Response version of the adapter.
+    if (!(innerType instanceof ParameterizedType)) {
+      throw new IllegalStateException("Response must be parameterized"
+          + " as Response<Foo> or Response<? extends Foo>");
+    }
+    Type responseType = getParameterUpperBound(0, (ParameterizedType) innerType);
+    return new ResponseCallAdapter<>(responseType);
+  }
+
+  @IgnoreJRERequirement
+  private static final class BodyCallAdapter<R> implements CallAdapter<R, CompletableFuture<R>> {
+    private final Type responseType;
+
+    BodyCallAdapter(Type responseType) {
+      this.responseType = responseType;
+    }
+
+    @Override public Type responseType() {
+      return responseType;
+    }
+
+    @Override public CompletableFuture<R> adapt(final Call<R> call) {
+      final CompletableFuture<R> future = new CompletableFuture<R>() {
+        @Override public boolean cancel(boolean mayInterruptIfRunning) {
+          if (mayInterruptIfRunning) {
+            call.cancel();
+          }
+          return super.cancel(mayInterruptIfRunning);
+        }
+      };
+
+      call.enqueue(new Callback<R>() {
+        @Override public void onResponse(Call<R> call, Response<R> response) {
+          if (response.isSuccessful()) {
+            future.complete(response.body());
+          } else {
+            future.completeExceptionally(new HttpException(response));
+          }
+        }
+
+        @Override public void onFailure(Call<R> call, Throwable t) {
+          future.completeExceptionally(t);
+        }
+      });
+
+      return future;
+    }
+  }
+
+  @IgnoreJRERequirement
+  private static final class ResponseCallAdapter<R>
+      implements CallAdapter<R, CompletableFuture<Response<R>>> {
+    private final Type responseType;
+
+    ResponseCallAdapter(Type responseType) {
+      this.responseType = responseType;
+    }
+
+    @Override public Type responseType() {
+      return responseType;
+    }
+
+    @Override public CompletableFuture<Response<R>> adapt(final Call<R> call) {
+      final CompletableFuture<Response<R>> future = new CompletableFuture<Response<R>>() {
+        @Override public boolean cancel(boolean mayInterruptIfRunning) {
+          if (mayInterruptIfRunning) {
+            call.cancel();
+          }
+          return super.cancel(mayInterruptIfRunning);
+        }
+      };
+
+      call.enqueue(new Callback<R>() {
+        @Override public void onResponse(Call<R> call, Response<R> response) {
+          future.complete(response);
+        }
+
+        @Override public void onFailure(Call<R> call, Throwable t) {
+          future.completeExceptionally(t);
+        }
+      });
+
+      return future;
+    }
+  }
+}
diff --git a/retrofit/src/main/java/retrofit2/Converter.java b/retrofit/src/main/java/retrofit2/Converter.java
index 37a64f8d1..370a14710 100644
--- a/retrofit/src/main/java/retrofit2/Converter.java
+++ b/retrofit/src/main/java/retrofit2/Converter.java
@@ -39,7 +39,7 @@
  * into the {@link Retrofit} instance.
  */
 public interface Converter<F, T> {
-  T convert(F value) throws IOException;
+  @Nullable T convert(F value) throws IOException;
 
   /** Creates {@link Converter} instances based on a type and target usage. */
   abstract class Factory {
diff --git a/retrofit/src/main/java/retrofit2/DefaultCallAdapterFactory.java b/retrofit/src/main/java/retrofit2/DefaultCallAdapterFactory.java
index c0f114cf3..a16aef4b2 100644
--- a/retrofit/src/main/java/retrofit2/DefaultCallAdapterFactory.java
+++ b/retrofit/src/main/java/retrofit2/DefaultCallAdapterFactory.java
@@ -15,32 +15,110 @@
  */
 package retrofit2;
 
+import java.io.IOException;
 import java.lang.annotation.Annotation;
+import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
+import java.util.concurrent.Executor;
+import javax.annotation.Nullable;
+import okhttp3.Request;
+
+import static retrofit2.Utils.checkNotNull;
 
-/**
- * Creates call adapters for that uses the same thread for both I/O and application-level
- * callbacks. For synchronous calls this is the application thread making the request; for
- * asynchronous calls this is a thread provided by OkHttp's dispatcher.
- */
 final class DefaultCallAdapterFactory extends CallAdapter.Factory {
-  static final CallAdapter.Factory INSTANCE = new DefaultCallAdapterFactory();
+  private final @Nullable Executor callbackExecutor;
+
+  DefaultCallAdapterFactory(@Nullable Executor callbackExecutor) {
+    this.callbackExecutor = callbackExecutor;
+  }
 
-  @Override
-  public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+  @Override public @Nullable CallAdapter<?, ?> get(
+      Type returnType, Annotation[] annotations, Retrofit retrofit) {
     if (getRawType(returnType) != Call.class) {
       return null;
     }
+    if (!(returnType instanceof ParameterizedType)) {
+      throw new IllegalArgumentException(
+          "Call return type must be parameterized as Call<Foo> or Call<? extends Foo>");
+    }
+    final Type responseType = Utils.getParameterUpperBound(0, (ParameterizedType) returnType);
+
+    final Executor executor = Utils.isAnnotationPresent(annotations, SkipCallbackExecutor.class)
+        ? null
+        : callbackExecutor;
 
-    final Type responseType = Utils.getCallResponseType(returnType);
     return new CallAdapter<Object, Call<?>>() {
       @Override public Type responseType() {
         return responseType;
       }
 
       @Override public Call<Object> adapt(Call<Object> call) {
-        return call;
+        return executor == null
+            ? call
+            : new ExecutorCallbackCall<>(executor, call);
       }
     };
   }
+
+  static final class ExecutorCallbackCall<T> implements Call<T> {
+    final Executor callbackExecutor;
+    final Call<T> delegate;
+
+    ExecutorCallbackCall(Executor callbackExecutor, Call<T> delegate) {
+      this.callbackExecutor = callbackExecutor;
+      this.delegate = delegate;
+    }
+
+    @Override public void enqueue(final Callback<T> callback) {
+      checkNotNull(callback, "callback == null");
+
+      delegate.enqueue(new Callback<T>() {
+        @Override public void onResponse(Call<T> call, final Response<T> response) {
+          callbackExecutor.execute(new Runnable() {
+            @Override public void run() {
+              if (delegate.isCanceled()) {
+                // Emulate OkHttp's behavior of throwing/delivering an IOException on cancellation.
+                callback.onFailure(ExecutorCallbackCall.this, new IOException("Canceled"));
+              } else {
+                callback.onResponse(ExecutorCallbackCall.this, response);
+              }
+            }
+          });
+        }
+
+        @Override public void onFailure(Call<T> call, final Throwable t) {
+          callbackExecutor.execute(new Runnable() {
+            @Override public void run() {
+              callback.onFailure(ExecutorCallbackCall.this, t);
+            }
+          });
+        }
+      });
+    }
+
+    @Override public boolean isExecuted() {
+      return delegate.isExecuted();
+    }
+
+    @Override public Response<T> execute() throws IOException {
+      return delegate.execute();
+    }
+
+    @Override public void cancel() {
+      delegate.cancel();
+    }
+
+    @Override public boolean isCanceled() {
+      return delegate.isCanceled();
+    }
+
+    @SuppressWarnings("CloneDoesntCallSuperClone") // Performing deep clone.
+    @Override public Call<T> clone() {
+      return new ExecutorCallbackCall<>(callbackExecutor, delegate.clone());
+    }
+
+    @Override public Request request() {
+      return delegate.request();
+    }
+  }
 }
diff --git a/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java b/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java
deleted file mode 100644
index f819c7863..000000000
--- a/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java
+++ /dev/null
@@ -1,111 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2;
-
-import java.io.IOException;
-import java.lang.annotation.Annotation;
-import java.lang.reflect.Type;
-import java.util.concurrent.Executor;
-import okhttp3.Request;
-
-import static retrofit2.Utils.checkNotNull;
-
-final class ExecutorCallAdapterFactory extends CallAdapter.Factory {
-  final Executor callbackExecutor;
-
-  ExecutorCallAdapterFactory(Executor callbackExecutor) {
-    this.callbackExecutor = callbackExecutor;
-  }
-
-  @Override
-  public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
-    if (getRawType(returnType) != Call.class) {
-      return null;
-    }
-    final Type responseType = Utils.getCallResponseType(returnType);
-    return new CallAdapter<Object, Call<?>>() {
-      @Override public Type responseType() {
-        return responseType;
-      }
-
-      @Override public Call<Object> adapt(Call<Object> call) {
-        return new ExecutorCallbackCall<>(callbackExecutor, call);
-      }
-    };
-  }
-
-  static final class ExecutorCallbackCall<T> implements Call<T> {
-    final Executor callbackExecutor;
-    final Call<T> delegate;
-
-    ExecutorCallbackCall(Executor callbackExecutor, Call<T> delegate) {
-      this.callbackExecutor = callbackExecutor;
-      this.delegate = delegate;
-    }
-
-    @Override public void enqueue(final Callback<T> callback) {
-      checkNotNull(callback, "callback == null");
-
-      delegate.enqueue(new Callback<T>() {
-        @Override public void onResponse(Call<T> call, final Response<T> response) {
-          callbackExecutor.execute(new Runnable() {
-            @Override public void run() {
-              if (delegate.isCanceled()) {
-                // Emulate OkHttp's behavior of throwing/delivering an IOException on cancellation.
-                callback.onFailure(ExecutorCallbackCall.this, new IOException("Canceled"));
-              } else {
-                callback.onResponse(ExecutorCallbackCall.this, response);
-              }
-            }
-          });
-        }
-
-        @Override public void onFailure(Call<T> call, final Throwable t) {
-          callbackExecutor.execute(new Runnable() {
-            @Override public void run() {
-              callback.onFailure(ExecutorCallbackCall.this, t);
-            }
-          });
-        }
-      });
-    }
-
-    @Override public boolean isExecuted() {
-      return delegate.isExecuted();
-    }
-
-    @Override public Response<T> execute() throws IOException {
-      return delegate.execute();
-    }
-
-    @Override public void cancel() {
-      delegate.cancel();
-    }
-
-    @Override public boolean isCanceled() {
-      return delegate.isCanceled();
-    }
-
-    @SuppressWarnings("CloneDoesntCallSuperClone") // Performing deep clone.
-    @Override public Call<T> clone() {
-      return new ExecutorCallbackCall<>(callbackExecutor, delegate.clone());
-    }
-
-    @Override public Request request() {
-      return delegate.request();
-    }
-  }
-}
diff --git a/retrofit/src/main/java/retrofit2/HttpException.java b/retrofit/src/main/java/retrofit2/HttpException.java
index c01f97dfe..f53e76e78 100644
--- a/retrofit/src/main/java/retrofit2/HttpException.java
+++ b/retrofit/src/main/java/retrofit2/HttpException.java
@@ -15,6 +15,8 @@
  */
 package retrofit2;
 
+import javax.annotation.Nullable;
+
 import static retrofit2.Utils.checkNotNull;
 
 /** Exception for an unexpected, non-2xx HTTP response. */
@@ -48,7 +50,7 @@ public String message() {
   /**
    * The full HTTP response. This may be null if the exception was serialized.
    */
-  public Response<?> response() {
+  public @Nullable Response<?> response() {
     return response;
   }
 }
diff --git a/retrofit/src/main/java/retrofit2/HttpServiceMethod.java b/retrofit/src/main/java/retrofit2/HttpServiceMethod.java
index d6e7f62bc..bc8bdf814 100644
--- a/retrofit/src/main/java/retrofit2/HttpServiceMethod.java
+++ b/retrofit/src/main/java/retrofit2/HttpServiceMethod.java
@@ -17,94 +17,178 @@
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Method;
+import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import javax.annotation.Nullable;
+import kotlin.coroutines.Continuation;
 import okhttp3.ResponseBody;
 
+import static retrofit2.Utils.getRawType;
 import static retrofit2.Utils.methodError;
 
 /** Adapts an invocation of an interface method into an HTTP call. */
-final class HttpServiceMethod<ResponseT, ReturnT> extends ServiceMethod<ReturnT> {
+abstract class HttpServiceMethod<ResponseT, ReturnT> extends ServiceMethod<ReturnT> {
+  /**
+   * Inspects the annotations on an interface method to construct a reusable service method that
+   * speaks HTTP. This requires potentially-expensive reflection so it is best to build each service
+   * method only once and reuse it.
+   */
+  static <ResponseT, ReturnT> HttpServiceMethod<ResponseT, ReturnT> parseAnnotations(
+      Retrofit retrofit, Method method, RequestFactory requestFactory) {
+    boolean isKotlinSuspendFunction = requestFactory.isKotlinSuspendFunction;
+    boolean continuationWantsResponse = false;
+    boolean continuationBodyNullable = false;
+
+    Annotation[] annotations = method.getAnnotations();
+    Type adapterType;
+    if (isKotlinSuspendFunction) {
+      Type[] parameterTypes = method.getGenericParameterTypes();
+      Type responseType = Utils.getParameterLowerBound(0,
+          (ParameterizedType) parameterTypes[parameterTypes.length - 1]);
+      if (getRawType(responseType) == Response.class && responseType instanceof ParameterizedType) {
+        // Unwrap the actual body type from Response<T>.
+        responseType = Utils.getParameterUpperBound(0, (ParameterizedType) responseType);
+        continuationWantsResponse = true;
+      } else {
+        // TODO figure out if type is nullable or not
+        // Metadata metadata = method.getDeclaringClass().getAnnotation(Metadata.class)
+        // Find the entry for method
+        // Determine if return type is nullable or not
+      }
+
+      adapterType = new Utils.ParameterizedTypeImpl(null, Call.class, responseType);
+      annotations = SkipCallbackExecutorImpl.ensurePresent(annotations);
+    } else {
+      adapterType = method.getGenericReturnType();
+    }
+
+    CallAdapter<ResponseT, ReturnT> callAdapter =
+        createCallAdapter(retrofit, method, adapterType, annotations);
+    Type responseType = callAdapter.responseType();
+    if (responseType == okhttp3.Response.class) {
+      throw methodError(method, "'"
+          + getRawType(responseType).getName()
+          + "' is not a valid response body type. Did you mean ResponseBody?");
+    }
+    if (responseType == Response.class) {
+      throw methodError(method, "Response must include generic type (e.g., Response<String>)");
+    }
+    // TODO support Unit for Kotlin?
+    if (requestFactory.httpMethod.equals("HEAD") && !Void.class.equals(responseType)) {
+      throw methodError(method, "HEAD method must use Void as response type.");
+    }
+
+    Converter<ResponseBody, ResponseT> responseConverter =
+        createResponseConverter(retrofit, method, responseType);
+
+    okhttp3.Call.Factory callFactory = retrofit.callFactory;
+    if (!isKotlinSuspendFunction) {
+      return new CallAdapted<>(requestFactory, callFactory, responseConverter, callAdapter);
+    } else if (continuationWantsResponse) {
+      //noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.
+      return (HttpServiceMethod<ResponseT, ReturnT>) new SuspendForResponse<>(requestFactory,
+          callFactory, responseConverter, (CallAdapter<ResponseT, Call<ResponseT>>) callAdapter);
+    } else {
+      //noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.
+      return (HttpServiceMethod<ResponseT, ReturnT>) new SuspendForBody<>(requestFactory,
+          callFactory, responseConverter, (CallAdapter<ResponseT, Call<ResponseT>>) callAdapter,
+          continuationBodyNullable);
+    }
+  }
+
+  private static <ResponseT, ReturnT> CallAdapter<ResponseT, ReturnT> createCallAdapter(
+      Retrofit retrofit, Method method, Type returnType, Annotation[] annotations) {
+    try {
+      //noinspection unchecked
+      return (CallAdapter<ResponseT, ReturnT>) retrofit.callAdapter(returnType, annotations);
+    } catch (RuntimeException e) { // Wide exception range because factories are user code.
+      throw methodError(method, e, "Unable to create call adapter for %s", returnType);
+    }
+  }
+
+  private static <ResponseT> Converter<ResponseBody, ResponseT> createResponseConverter(
+      Retrofit retrofit, Method method, Type responseType) {
+    Annotation[] annotations = method.getAnnotations();
+    try {
+      return retrofit.responseBodyConverter(responseType, annotations);
+    } catch (RuntimeException e) { // Wide exception range because factories are user code.
+      throw methodError(method, e, "Unable to create converter for %s", responseType);
+    }
+  }
+
   private final RequestFactory requestFactory;
   private final okhttp3.Call.Factory callFactory;
-  private final CallAdapter<ResponseT, ReturnT> callAdapter;
   private final Converter<ResponseBody, ResponseT> responseConverter;
 
-  HttpServiceMethod(Builder<ResponseT, ReturnT> builder) {
-    requestFactory = builder.requestFactory;
-    callFactory = builder.retrofit.callFactory();
-    callAdapter = builder.callAdapter;
-    responseConverter = builder.responseConverter;
+  HttpServiceMethod(RequestFactory requestFactory, okhttp3.Call.Factory callFactory,
+      Converter<ResponseBody, ResponseT> responseConverter) {
+    this.requestFactory = requestFactory;
+    this.callFactory = callFactory;
+    this.responseConverter = responseConverter;
   }
 
-  @Override ReturnT invoke(@Nullable Object[] args) {
-    return callAdapter.adapt(
-        new OkHttpCall<>(requestFactory, args, callFactory, responseConverter));
+  @Override final @Nullable ReturnT invoke(Object[] args) {
+    Call<ResponseT> call = new OkHttpCall<>(requestFactory, args, callFactory, responseConverter);
+    return adapt(call, args);
   }
 
-  /**
-   * Inspects the annotations on an interface method to construct a reusable service method. This
-   * requires potentially-expensive reflection so it is best to build each service method only once
-   * and reuse it. Builders cannot be reused.
-   */
-  static final class Builder<ResponseT, ReturnT> {
-    final Retrofit retrofit;
-    final Method method;
-
-    RequestFactory requestFactory;
-    Type responseType;
-    Converter<ResponseBody, ResponseT> responseConverter;
-    CallAdapter<ResponseT, ReturnT> callAdapter;
-
-    Builder(Retrofit retrofit, Method method) {
-      this.retrofit = retrofit;
-      this.method = method;
+  protected abstract @Nullable ReturnT adapt(Call<ResponseT> call, Object[] args);
+
+  static final class CallAdapted<ResponseT, ReturnT> extends HttpServiceMethod<ResponseT, ReturnT> {
+    private final CallAdapter<ResponseT, ReturnT> callAdapter;
+
+    CallAdapted(RequestFactory requestFactory, okhttp3.Call.Factory callFactory,
+        Converter<ResponseBody, ResponseT> responseConverter,
+        CallAdapter<ResponseT, ReturnT> callAdapter) {
+      super(requestFactory, callFactory, responseConverter);
+      this.callAdapter = callAdapter;
     }
 
-    HttpServiceMethod<ResponseT, ReturnT> build() {
-      requestFactory = RequestFactory.parseAnnotations(retrofit, method);
+    @Override protected ReturnT adapt(Call<ResponseT> call, Object[] args) {
+      return callAdapter.adapt(call);
+    }
+  }
 
-      callAdapter = createCallAdapter();
-      responseType = callAdapter.responseType();
-      if (responseType == Response.class || responseType == okhttp3.Response.class) {
-        throw methodError(method, "'"
-            + Utils.getRawType(responseType).getName()
-            + "' is not a valid response body type. Did you mean ResponseBody?");
-      }
-      responseConverter = createResponseConverter();
+  static final class SuspendForResponse<ResponseT> extends HttpServiceMethod<ResponseT, Object> {
+    private final CallAdapter<ResponseT, Call<ResponseT>> callAdapter;
 
-      if (requestFactory.httpMethod.equals("HEAD") && !Void.class.equals(responseType)) {
-        throw methodError(method, "HEAD method must use Void as response type.");
-      }
+    SuspendForResponse(RequestFactory requestFactory, okhttp3.Call.Factory callFactory,
+        Converter<ResponseBody, ResponseT> responseConverter,
+        CallAdapter<ResponseT, Call<ResponseT>> callAdapter) {
+      super(requestFactory, callFactory, responseConverter);
+      this.callAdapter = callAdapter;
+    }
+
+    @Override protected Object adapt(Call<ResponseT> call, Object[] args) {
+      call = callAdapter.adapt(call);
 
-      return new HttpServiceMethod<>(this);
+      //noinspection unchecked Checked by reflection inside RequestFactory.
+      Continuation<Response<ResponseT>> continuation =
+          (Continuation<Response<ResponseT>>) args[args.length - 1];
+      return KotlinExtensions.awaitResponse(call, continuation);
     }
+  }
 
-    private CallAdapter<ResponseT, ReturnT> createCallAdapter() {
-      Type returnType = method.getGenericReturnType();
-      if (Utils.hasUnresolvableType(returnType)) {
-        throw methodError(method,
-            "Method return type must not include a type variable or wildcard: %s", returnType);
-      }
-      if (returnType == void.class) {
-        throw methodError(method, "Service methods cannot return void.");
-      }
-      Annotation[] annotations = method.getAnnotations();
-      try {
-        //noinspection unchecked
-        return (CallAdapter<ResponseT, ReturnT>) retrofit.callAdapter(returnType, annotations);
-      } catch (RuntimeException e) { // Wide exception range because factories are user code.
-        throw methodError(method, e, "Unable to create call adapter for %s", returnType);
-      }
+  static final class SuspendForBody<ResponseT> extends HttpServiceMethod<ResponseT, Object> {
+    private final CallAdapter<ResponseT, Call<ResponseT>> callAdapter;
+    private final boolean isNullable;
+
+    SuspendForBody(RequestFactory requestFactory, okhttp3.Call.Factory callFactory,
+        Converter<ResponseBody, ResponseT> responseConverter,
+        CallAdapter<ResponseT, Call<ResponseT>> callAdapter, boolean isNullable) {
+      super(requestFactory, callFactory, responseConverter);
+      this.callAdapter = callAdapter;
+      this.isNullable = isNullable;
     }
 
-    private Converter<ResponseBody, ResponseT> createResponseConverter() {
-      Annotation[] annotations = method.getAnnotations();
-      try {
-        return retrofit.responseBodyConverter(responseType, annotations);
-      } catch (RuntimeException e) { // Wide exception range because factories are user code.
-        throw methodError(method, e, "Unable to create converter for %s", responseType);
-      }
+    @Override protected Object adapt(Call<ResponseT> call, Object[] args) {
+      call = callAdapter.adapt(call);
+
+      //noinspection unchecked Checked by reflection inside RequestFactory.
+      Continuation<ResponseT> continuation = (Continuation<ResponseT>) args[args.length - 1];
+      return isNullable
+          ? KotlinExtensions.awaitNullable(call, continuation)
+          : KotlinExtensions.await(call, continuation);
     }
   }
 }
diff --git a/retrofit/src/main/java/retrofit2/Invocation.java b/retrofit/src/main/java/retrofit2/Invocation.java
new file mode 100644
index 000000000..6f1ca5fb4
--- /dev/null
+++ b/retrofit/src/main/java/retrofit2/Invocation.java
@@ -0,0 +1,80 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import java.lang.reflect.Method;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+import static retrofit2.Utils.checkNotNull;
+
+/**
+ * A single invocation of a Retrofit service interface method. This class captures both the method
+ * that was called and the arguments to the method.
+ *
+ * <p>Retrofit automatically adds an invocation to each OkHttp request as a tag. You can retrieve
+ * the invocation in an OkHttp interceptor for metrics and monitoring.
+ *
+ * <pre><code>
+ * class InvocationLogger implements Interceptor {
+ *   &#64;Override public Response intercept(Chain chain) throws IOException {
+ *     Request request = chain.request();
+ *     Invocation invocation = request.tag(Invocation.class);
+ *     if (invocation != null) {
+ *       System.out.printf("%s.%s %s%n",
+ *           invocation.method().getDeclaringClass().getSimpleName(),
+ *           invocation.method().getName(), invocation.arguments());
+ *     }
+ *     return chain.proceed(request);
+ *   }
+ * }
+ * </code></pre>
+ *
+ * <strong>Note:</strong> use caution when examining an invocation's arguments. Although the
+ * arguments list is unmodifiable, the arguments themselves may be mutable. They may also be unsafe
+ * for concurrent access. For best results declare Retrofit service interfaces using only immutable
+ * types for parameters!
+ */
+public final class Invocation {
+  public static Invocation of(Method method, List<?> arguments) {
+    checkNotNull(method, "method == null");
+    checkNotNull(arguments, "arguments == null");
+    return new Invocation(method, new ArrayList<>(arguments)); // Defensive copy.
+  }
+
+  private final Method method;
+  private final List<?> arguments;
+
+  /** Trusted constructor assumes ownership of {@code arguments}. */
+  Invocation(Method method, List<?> arguments) {
+    this.method = method;
+    this.arguments = Collections.unmodifiableList(arguments);
+  }
+
+  public Method method() {
+    return method;
+  }
+
+  public List<?> arguments() {
+    return arguments;
+  }
+
+  @Override public String toString() {
+    return String.format("%s.%s() %s",
+        method.getDeclaringClass().getName(), method.getName(), arguments);
+  }
+}
diff --git a/retrofit/src/main/java/retrofit2/KotlinExtensions.kt b/retrofit/src/main/java/retrofit2/KotlinExtensions.kt
new file mode 100644
index 000000000..b24212e08
--- /dev/null
+++ b/retrofit/src/main/java/retrofit2/KotlinExtensions.kt
@@ -0,0 +1,97 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+@file:JvmName("KotlinExtensions")
+
+package retrofit2
+
+import kotlinx.coroutines.suspendCancellableCoroutine
+import kotlin.coroutines.resume
+import kotlin.coroutines.resumeWithException
+
+inline fun <reified T> Retrofit.create(): T = create(T::class.java)
+
+suspend fun <T : Any> Call<T>.await(): T {
+  return suspendCancellableCoroutine { continuation ->
+    continuation.invokeOnCancellation {
+      cancel()
+    }
+    enqueue(object : Callback<T> {
+      override fun onResponse(call: Call<T>, response: Response<T>) {
+        if (response.isSuccessful) {
+          val body = response.body()
+          if (body == null) {
+            val invocation = call.request().tag(Invocation::class.java)!!
+            val method = invocation.method()
+            val e = KotlinNullPointerException("Response from " +
+                method.declaringClass.name +
+                '.' +
+                method.name +
+                " was null but response body type was declared as non-null")
+            continuation.resumeWithException(e)
+          } else {
+            continuation.resume(body)
+          }
+        } else {
+          continuation.resumeWithException(HttpException(response))
+        }
+      }
+
+      override fun onFailure(call: Call<T>, t: Throwable) {
+        continuation.resumeWithException(t)
+      }
+    })
+  }
+}
+
+@JvmName("awaitNullable")
+suspend fun <T : Any> Call<T?>.await(): T? {
+  return suspendCancellableCoroutine { continuation ->
+    continuation.invokeOnCancellation {
+      cancel()
+    }
+    enqueue(object : Callback<T?> {
+      override fun onResponse(call: Call<T?>, response: Response<T?>) {
+        if (response.isSuccessful) {
+          continuation.resume(response.body())
+        } else {
+          continuation.resumeWithException(HttpException(response))
+        }
+      }
+
+      override fun onFailure(call: Call<T?>, t: Throwable) {
+        continuation.resumeWithException(t)
+      }
+    })
+  }
+}
+
+suspend fun <T : Any> Call<T>.awaitResponse(): Response<T> {
+  return suspendCancellableCoroutine { continuation ->
+    continuation.invokeOnCancellation {
+      cancel()
+    }
+    enqueue(object : Callback<T> {
+      override fun onResponse(call: Call<T>, response: Response<T>) {
+        continuation.resume(response)
+      }
+
+      override fun onFailure(call: Call<T>, t: Throwable) {
+        continuation.resumeWithException(t)
+      }
+    })
+  }
+}
diff --git a/retrofit/src/main/java/retrofit2/OkHttpCall.java b/retrofit/src/main/java/retrofit2/OkHttpCall.java
index 3a4d0562d..a5b5b9237 100644
--- a/retrofit/src/main/java/retrofit2/OkHttpCall.java
+++ b/retrofit/src/main/java/retrofit2/OkHttpCall.java
@@ -31,7 +31,7 @@
 
 final class OkHttpCall<T> implements Call<T> {
   private final RequestFactory requestFactory;
-  private final @Nullable Object[] args;
+  private final Object[] args;
   private final okhttp3.Call.Factory callFactory;
   private final Converter<ResponseBody, T> responseConverter;
 
@@ -44,7 +44,7 @@
   @GuardedBy("this")
   private boolean executed;
 
-  OkHttpCall(RequestFactory requestFactory, @Nullable Object[] args,
+  OkHttpCall(RequestFactory requestFactory, Object[] args,
       okhttp3.Call.Factory callFactory, Converter<ResponseBody, T> responseConverter) {
     this.requestFactory = requestFactory;
     this.args = args;
@@ -128,7 +128,8 @@
         try {
           callback.onResponse(OkHttpCall.this, response);
         } catch (Throwable t) {
-          t.printStackTrace();
+          throwIfFatal(t);
+          t.printStackTrace(); // TODO this is not great
         }
       }
 
@@ -140,7 +141,8 @@ private void callFailure(Throwable e) {
         try {
           callback.onFailure(OkHttpCall.this, e);
         } catch (Throwable t) {
-          t.printStackTrace();
+          throwIfFatal(t);
+          t.printStackTrace(); // TODO this is not great
         }
       }
     });
@@ -252,10 +254,10 @@ public void cancel() {
   }
 
   static final class NoContentResponseBody extends ResponseBody {
-    private final MediaType contentType;
+    private final @Nullable MediaType contentType;
     private final long contentLength;
 
-    NoContentResponseBody(MediaType contentType, long contentLength) {
+    NoContentResponseBody(@Nullable MediaType contentType, long contentLength) {
       this.contentType = contentType;
       this.contentLength = contentLength;
     }
@@ -275,10 +277,21 @@ public void cancel() {
 
   static final class ExceptionCatchingResponseBody extends ResponseBody {
     private final ResponseBody delegate;
-    IOException thrownException;
+    private final BufferedSource delegateSource;
+    @Nullable IOException thrownException;
 
     ExceptionCatchingResponseBody(ResponseBody delegate) {
       this.delegate = delegate;
+      this.delegateSource = Okio.buffer(new ForwardingSource(delegate.source()) {
+        @Override public long read(Buffer sink, long byteCount) throws IOException {
+          try {
+            return super.read(sink, byteCount);
+          } catch (IOException e) {
+            thrownException = e;
+            throw e;
+          }
+        }
+      });
     }
 
     @Override public MediaType contentType() {
@@ -290,16 +303,7 @@ public void cancel() {
     }
 
     @Override public BufferedSource source() {
-      return Okio.buffer(new ForwardingSource(delegate.source()) {
-        @Override public long read(Buffer sink, long byteCount) throws IOException {
-          try {
-            return super.read(sink, byteCount);
-          } catch (IOException e) {
-            thrownException = e;
-            throw e;
-          }
-        }
-      });
+      return delegateSource;
     }
 
     @Override public void close() {
diff --git a/retrofit/src/main/java/retrofit2/OptionalConverterFactory.java b/retrofit/src/main/java/retrofit2/OptionalConverterFactory.java
new file mode 100644
index 000000000..a9325322c
--- /dev/null
+++ b/retrofit/src/main/java/retrofit2/OptionalConverterFactory.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.util.Optional;
+import javax.annotation.Nullable;
+import okhttp3.ResponseBody;
+import org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement;
+
+@IgnoreJRERequirement // Only added when Optional is available (Java 8+ / Android API 24+).
+final class OptionalConverterFactory extends Converter.Factory {
+  static final Converter.Factory INSTANCE = new OptionalConverterFactory();
+
+  @Override public @Nullable Converter<ResponseBody, ?> responseBodyConverter(
+      Type type, Annotation[] annotations, Retrofit retrofit) {
+    if (getRawType(type) != Optional.class) {
+      return null;
+    }
+
+    Type innerType = getParameterUpperBound(0, (ParameterizedType) type);
+    Converter<ResponseBody, Object> delegate =
+        retrofit.responseBodyConverter(innerType, annotations);
+    return new OptionalConverter<>(delegate);
+  }
+
+  @IgnoreJRERequirement
+  static final class OptionalConverter<T> implements Converter<ResponseBody, Optional<T>> {
+    final Converter<ResponseBody, T> delegate;
+
+    OptionalConverter(Converter<ResponseBody, T> delegate) {
+      this.delegate = delegate;
+    }
+
+    @Override public Optional<T> convert(ResponseBody value) throws IOException {
+      return Optional.ofNullable(delegate.convert(value));
+    }
+  }
+}
diff --git a/retrofit/src/main/java/retrofit2/ParameterHandler.java b/retrofit/src/main/java/retrofit2/ParameterHandler.java
index 929413418..1d416c475 100644
--- a/retrofit/src/main/java/retrofit2/ParameterHandler.java
+++ b/retrofit/src/main/java/retrofit2/ParameterHandler.java
@@ -17,9 +17,9 @@
 
 import java.io.IOException;
 import java.lang.reflect.Array;
+import java.lang.reflect.Method;
 import java.util.Map;
 import javax.annotation.Nullable;
-import okhttp3.Headers;
 import okhttp3.MultipartBody;
 import okhttp3.RequestBody;
 
@@ -55,8 +55,18 @@
   }
 
   static final class RelativeUrl extends ParameterHandler<Object> {
+    private final Method method;
+    private final int p;
+
+    RelativeUrl(Method method, int p) {
+      this.method = method;
+      this.p = p;
+    }
+
     @Override void apply(RequestBuilder builder, @Nullable Object value) {
-      checkNotNull(value, "@Url parameter is null.");
+      if (value == null) {
+        throw Utils.parameterError(method, p, "@Url parameter is null.");
+      }
       builder.setRelativeUrl(value);
     }
   }
@@ -81,11 +91,16 @@
   }
 
   static final class Path<T> extends ParameterHandler<T> {
+    private final Method method;
+    private final int p;
     private final String name;
     private final Converter<T, String> valueConverter;
     private final boolean encoded;
 
-    Path(String name, Converter<T, String> valueConverter, boolean encoded) {
+
+    Path(Method method, int p, String name, Converter<T, String> valueConverter, boolean encoded) {
+      this.method = method;
+      this.p = p;
       this.name = checkNotNull(name, "name == null");
       this.valueConverter = valueConverter;
       this.encoded = encoded;
@@ -93,8 +108,8 @@
 
     @Override void apply(RequestBuilder builder, @Nullable T value) throws IOException {
       if (value == null) {
-        throw new IllegalArgumentException(
-            "Path parameter \"" + name + "\" value must not be null.");
+        throw Utils.parameterError(method, p,
+                "Path parameter \"" + name + "\" value must not be null.");
       }
       builder.addPathParam(name, valueConverter.convert(value), encoded);
     }
@@ -137,10 +152,14 @@
   }
 
   static final class QueryMap<T> extends ParameterHandler<Map<String, T>> {
+    private final Method method;
+    private final int p;
     private final Converter<T, String> valueConverter;
     private final boolean encoded;
 
-    QueryMap(Converter<T, String> valueConverter, boolean encoded) {
+    QueryMap(Method method, int p, Converter<T, String> valueConverter, boolean encoded) {
+      this.method = method;
+      this.p = p;
       this.valueConverter = valueConverter;
       this.encoded = encoded;
     }
@@ -148,23 +167,23 @@
     @Override void apply(RequestBuilder builder, @Nullable Map<String, T> value)
         throws IOException {
       if (value == null) {
-        throw new IllegalArgumentException("Query map was null.");
+        throw Utils.parameterError(method, p, "Query map was null");
       }
 
       for (Map.Entry<String, T> entry : value.entrySet()) {
         String entryKey = entry.getKey();
         if (entryKey == null) {
-          throw new IllegalArgumentException("Query map contained null key.");
+          throw Utils.parameterError(method, p, "Query map contained null key.");
         }
         T entryValue = entry.getValue();
         if (entryValue == null) {
-          throw new IllegalArgumentException(
-              "Query map contained null value for key '" + entryKey + "'.");
+          throw Utils.parameterError(method, p,
+                  "Query map contained null value for key '" + entryKey + "'.");
         }
 
         String convertedEntryValue = valueConverter.convert(entryValue);
         if (convertedEntryValue == null) {
-          throw new IllegalArgumentException("Query map value '"
+          throw Utils.parameterError(method, p, "Query map value '"
               + entryValue
               + "' converted to null by "
               + valueConverter.getClass().getName()
@@ -179,33 +198,54 @@
   }
 
   static final class HeaderMap<T> extends ParameterHandler<Map<String, T>> {
+    private final Method method;
+    private final int p;
     private final Converter<T, String> valueConverter;
 
-    HeaderMap(Converter<T, String> valueConverter) {
+    HeaderMap(Method method, int p, Converter<T, String> valueConverter) {
+      this.method = method;
+      this.p = p;
       this.valueConverter = valueConverter;
     }
 
     @Override void apply(RequestBuilder builder, @Nullable Map<String, T> value)
         throws IOException {
       if (value == null) {
-        throw new IllegalArgumentException("Header map was null.");
+        throw Utils.parameterError(method, p, "Header map was null.");
       }
 
       for (Map.Entry<String, T> entry : value.entrySet()) {
         String headerName = entry.getKey();
         if (headerName == null) {
-          throw new IllegalArgumentException("Header map contained null key.");
+          throw Utils.parameterError(method, p, "Header map contained null key.");
         }
         T headerValue = entry.getValue();
         if (headerValue == null) {
-          throw new IllegalArgumentException(
-              "Header map contained null value for key '" + headerName + "'.");
+          throw Utils.parameterError(method, p,
+                  "Header map contained null value for key '" + headerName + "'.");
         }
         builder.addHeader(headerName, valueConverter.convert(headerValue));
       }
     }
   }
 
+  static final class Headers extends ParameterHandler<okhttp3.Headers> {
+    private final Method method;
+    private final int p;
+
+    Headers(Method method, int p) {
+      this.method = method;
+      this.p = p;
+    }
+
+    @Override void apply(RequestBuilder builder, @Nullable okhttp3.Headers headers) {
+      if (headers == null) {
+        throw Utils.parameterError(method, p, "Headers parameter must not be null.");
+      }
+      builder.addHeaders(headers);
+    }
+  }
+
   static final class Field<T> extends ParameterHandler<T> {
     private final String name;
     private final Converter<T, String> valueConverter;
@@ -228,10 +268,14 @@
   }
 
   static final class FieldMap<T> extends ParameterHandler<Map<String, T>> {
+    private final Method method;
+    private final int p;
     private final Converter<T, String> valueConverter;
     private final boolean encoded;
 
-    FieldMap(Converter<T, String> valueConverter, boolean encoded) {
+    FieldMap(Method method, int p, Converter<T, String> valueConverter, boolean encoded) {
+      this.method = method;
+      this.p = p;
       this.valueConverter = valueConverter;
       this.encoded = encoded;
     }
@@ -239,23 +283,23 @@
     @Override void apply(RequestBuilder builder, @Nullable Map<String, T> value)
         throws IOException {
       if (value == null) {
-        throw new IllegalArgumentException("Field map was null.");
+        throw Utils.parameterError(method, p, "Field map was null.");
       }
 
       for (Map.Entry<String, T> entry : value.entrySet()) {
         String entryKey = entry.getKey();
         if (entryKey == null) {
-          throw new IllegalArgumentException("Field map contained null key.");
+          throw Utils.parameterError(method, p, "Field map contained null key.");
         }
         T entryValue = entry.getValue();
         if (entryValue == null) {
-          throw new IllegalArgumentException(
-              "Field map contained null value for key '" + entryKey + "'.");
+          throw Utils.parameterError(method, p,
+                  "Field map contained null value for key '" + entryKey + "'.");
         }
 
         String fieldEntry = valueConverter.convert(entryValue);
         if (fieldEntry == null) {
-          throw new IllegalArgumentException("Field map value '"
+          throw Utils.parameterError(method, p, "Field map value '"
               + entryValue
               + "' converted to null by "
               + valueConverter.getClass().getName()
@@ -270,10 +314,14 @@
   }
 
   static final class Part<T> extends ParameterHandler<T> {
-    private final Headers headers;
+    private final Method method;
+    private final int p;
+    private final okhttp3.Headers headers;
     private final Converter<T, RequestBody> converter;
 
-    Part(Headers headers, Converter<T, RequestBody> converter) {
+    Part(Method method, int p, okhttp3.Headers headers, Converter<T, RequestBody> converter) {
+      this.method = method;
+      this.p = p;
       this.headers = headers;
       this.converter = converter;
     }
@@ -285,7 +333,7 @@
       try {
         body = converter.convert(value);
       } catch (IOException e) {
-        throw new RuntimeException("Unable to convert " + value + " to RequestBody", e);
+        throw Utils.parameterError(method, p, "Unable to convert " + value + " to RequestBody", e);
       }
       builder.addPart(headers, body);
     }
@@ -305,10 +353,15 @@ private RawPart() {
   }
 
   static final class PartMap<T> extends ParameterHandler<Map<String, T>> {
+    private final Method method;
+    private final int p;
     private final Converter<T, RequestBody> valueConverter;
     private final String transferEncoding;
 
-    PartMap(Converter<T, RequestBody> valueConverter, String transferEncoding) {
+    PartMap(Method method, int p,
+            Converter<T, RequestBody> valueConverter, String transferEncoding) {
+      this.method = method;
+      this.p = p;
       this.valueConverter = valueConverter;
       this.transferEncoding = transferEncoding;
     }
@@ -316,21 +369,21 @@ private RawPart() {
     @Override void apply(RequestBuilder builder, @Nullable Map<String, T> value)
         throws IOException {
       if (value == null) {
-        throw new IllegalArgumentException("Part map was null.");
+        throw Utils.parameterError(method, p, "Part map was null.");
       }
 
       for (Map.Entry<String, T> entry : value.entrySet()) {
         String entryKey = entry.getKey();
         if (entryKey == null) {
-          throw new IllegalArgumentException("Part map contained null key.");
+          throw Utils.parameterError(method, p, "Part map contained null key.");
         }
         T entryValue = entry.getValue();
         if (entryValue == null) {
-          throw new IllegalArgumentException(
-              "Part map contained null value for key '" + entryKey + "'.");
+          throw Utils.parameterError(method, p,
+                  "Part map contained null value for key '" + entryKey + "'.");
         }
 
-        Headers headers = Headers.of(
+        okhttp3.Headers headers = okhttp3.Headers.of(
             "Content-Disposition", "form-data; name=\"" + entryKey + "\"",
             "Content-Transfer-Encoding", transferEncoding);
 
@@ -340,23 +393,39 @@ private RawPart() {
   }
 
   static final class Body<T> extends ParameterHandler<T> {
+    private final Method method;
+    private final int p;
     private final Converter<T, RequestBody> converter;
 
-    Body(Converter<T, RequestBody> converter) {
+    Body(Method method, int p, Converter<T, RequestBody> converter) {
+      this.method = method;
+      this.p = p;
       this.converter = converter;
     }
 
     @Override void apply(RequestBuilder builder, @Nullable T value) {
       if (value == null) {
-        throw new IllegalArgumentException("Body parameter value must not be null.");
+        throw Utils.parameterError(method, p, "Body parameter value must not be null.");
       }
       RequestBody body;
       try {
         body = converter.convert(value);
       } catch (IOException e) {
-        throw new RuntimeException("Unable to convert " + value + " to RequestBody", e);
+        throw Utils.parameterError(method, e, p, "Unable to convert " + value + " to RequestBody");
       }
       builder.setBody(body);
     }
   }
+
+  static final class Tag<T> extends ParameterHandler<T> {
+    final Class<T> cls;
+
+    Tag(Class<T> cls) {
+      this.cls = cls;
+    }
+
+    @Override void apply(RequestBuilder builder, @Nullable T value) {
+      builder.addTag(cls, value);
+    }
+  }
 }
diff --git a/retrofit/src/main/java/retrofit2/Platform.java b/retrofit/src/main/java/retrofit2/Platform.java
index 3c3307b70..f24d4817a 100644
--- a/retrofit/src/main/java/retrofit2/Platform.java
+++ b/retrofit/src/main/java/retrofit2/Platform.java
@@ -21,10 +21,18 @@
 import java.lang.invoke.MethodHandles.Lookup;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Method;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
 import java.util.concurrent.Executor;
 import javax.annotation.Nullable;
 import org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement;
 
+import static java.util.Arrays.asList;
+import static java.util.Collections.emptyList;
+import static java.util.Collections.singletonList;
+import static java.util.Collections.unmodifiableList;
+
 class Platform {
   private static final Platform PLATFORM = findPlatform();
 
@@ -52,11 +60,21 @@ private static Platform findPlatform() {
     return null;
   }
 
-  CallAdapter.Factory defaultCallAdapterFactory(@Nullable Executor callbackExecutor) {
-    if (callbackExecutor != null) {
-      return new ExecutorCallAdapterFactory(callbackExecutor);
-    }
-    return DefaultCallAdapterFactory.INSTANCE;
+  List<? extends CallAdapter.Factory> defaultCallAdapterFactories(
+      @Nullable Executor callbackExecutor) {
+    return singletonList(new DefaultCallAdapterFactory(callbackExecutor));
+  }
+
+  int defaultCallAdapterFactoriesSize() {
+    return 1;
+  }
+
+  List<? extends Converter.Factory> defaultConverterFactories() {
+    return emptyList();
+  }
+
+  int defaultConverterFactoriesSize() {
+    return 0;
   }
 
   boolean isDefaultMethod(Method method) {
@@ -85,16 +103,62 @@ boolean isDefaultMethod(Method method) {
           .bindTo(object)
           .invokeWithArguments(args);
     }
+
+    @Override List<? extends CallAdapter.Factory> defaultCallAdapterFactories(
+        @Nullable Executor callbackExecutor) {
+      List<CallAdapter.Factory> factories = new ArrayList<>(2);
+      factories.add(CompletableFutureCallAdapterFactory.INSTANCE);
+      factories.add(new DefaultCallAdapterFactory(callbackExecutor));
+      return unmodifiableList(factories);
+    }
+
+    @Override int defaultCallAdapterFactoriesSize() {
+      return 2;
+    }
+
+    @Override List<? extends Converter.Factory> defaultConverterFactories() {
+      return singletonList(OptionalConverterFactory.INSTANCE);
+    }
+
+    @Override int defaultConverterFactoriesSize() {
+      return 1;
+    }
   }
 
   static class Android extends Platform {
+    @IgnoreJRERequirement // Guarded by API check.
+    @Override boolean isDefaultMethod(Method method) {
+      if (Build.VERSION.SDK_INT < 24) {
+        return false;
+      }
+      return method.isDefault();
+    }
+
     @Override public Executor defaultCallbackExecutor() {
       return new MainThreadExecutor();
     }
 
-    @Override CallAdapter.Factory defaultCallAdapterFactory(@Nullable Executor callbackExecutor) {
+    @Override List<? extends CallAdapter.Factory> defaultCallAdapterFactories(
+        @Nullable Executor callbackExecutor) {
       if (callbackExecutor == null) throw new AssertionError();
-      return new ExecutorCallAdapterFactory(callbackExecutor);
+      DefaultCallAdapterFactory executorFactory = new DefaultCallAdapterFactory(callbackExecutor);
+      return Build.VERSION.SDK_INT >= 24
+        ? asList(CompletableFutureCallAdapterFactory.INSTANCE, executorFactory)
+        : singletonList(executorFactory);
+    }
+
+    @Override int defaultCallAdapterFactoriesSize() {
+      return Build.VERSION.SDK_INT >= 24 ? 2 : 1;
+    }
+
+    @Override List<? extends Converter.Factory> defaultConverterFactories() {
+      return Build.VERSION.SDK_INT >= 24
+          ? singletonList(OptionalConverterFactory.INSTANCE)
+          : Collections.<Converter.Factory>emptyList();
+    }
+
+    @Override int defaultConverterFactoriesSize() {
+      return Build.VERSION.SDK_INT >= 24 ? 1 : 0;
     }
 
     static class MainThreadExecutor implements Executor {
diff --git a/retrofit/src/main/java/retrofit2/RequestBuilder.java b/retrofit/src/main/java/retrofit2/RequestBuilder.java
index f27db26ee..6aab20dfc 100644
--- a/retrofit/src/main/java/retrofit2/RequestBuilder.java
+++ b/retrofit/src/main/java/retrofit2/RequestBuilder.java
@@ -16,6 +16,7 @@
 package retrofit2;
 
 import java.io.IOException;
+import java.util.regex.Pattern;
 import javax.annotation.Nullable;
 import okhttp3.FormBody;
 import okhttp3.Headers;
@@ -32,6 +33,21 @@
       { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
   private static final String PATH_SEGMENT_ALWAYS_ENCODE_SET = " \"<>^`{}|\\?#";
 
+  /**
+   * Matches strings that contain {@code .} or {@code ..} as a complete path segment. This also
+   * matches dots in their percent-encoded form, {@code %2E}.
+   *
+   * <p>It is okay to have these strings within a larger path segment (like {@code a..z} or {@code
+   * index.html}) but when alone they have a special meaning. A single dot resolves to no path
+   * segment so {@code /one/./three/} becomes {@code /one/three/}. A double-dot pops the preceding
+   * directory, so {@code /one/../three/} becomes {@code /three/}.
+   *
+   * <p>We forbid these in Retrofit paths because they're likely to have the unintended effect.
+   * For example, passing {@code ..} to {@code DELETE /account/book/{isbn}/} yields {@code DELETE
+   * /account/}.
+   */
+  private static final Pattern PATH_TRAVERSAL = Pattern.compile("(.*/)?(\\.|%2e|%2E){1,2}(/.*)?");
+
   private final String method;
 
   private final HttpUrl baseUrl;
@@ -39,6 +55,7 @@
   private @Nullable HttpUrl.Builder urlBuilder;
 
   private final Request.Builder requestBuilder;
+  private final Headers.Builder headersBuilder;
   private @Nullable MediaType contentType;
 
   private final boolean hasBody;
@@ -46,9 +63,9 @@
   private @Nullable FormBody.Builder formBuilder;
   private @Nullable RequestBody body;
 
-  RequestBuilder(String method, HttpUrl baseUrl, @Nullable String relativeUrl,
-      @Nullable Headers headers, @Nullable MediaType contentType, boolean hasBody,
-      boolean isFormEncoded, boolean isMultipart) {
+  RequestBuilder(String method, HttpUrl baseUrl,
+      @Nullable String relativeUrl, @Nullable Headers headers, @Nullable MediaType contentType,
+      boolean hasBody, boolean isFormEncoded, boolean isMultipart) {
     this.method = method;
     this.baseUrl = baseUrl;
     this.relativeUrl = relativeUrl;
@@ -57,7 +74,9 @@
     this.hasBody = hasBody;
 
     if (headers != null) {
-      requestBuilder.headers(headers);
+      headersBuilder = headers.newBuilder();
+    } else {
+      headersBuilder = new Headers.Builder();
     }
 
     if (isFormEncoded) {
@@ -76,22 +95,32 @@ void setRelativeUrl(Object relativeUrl) {
 
   void addHeader(String name, String value) {
     if ("Content-Type".equalsIgnoreCase(name)) {
-      MediaType type = MediaType.parse(value);
-      if (type == null) {
-        throw new IllegalArgumentException("Malformed content type: " + value);
+      try {
+        contentType = MediaType.get(value);
+      } catch (IllegalArgumentException e) {
+        throw new IllegalArgumentException("Malformed content type: " + value, e);
       }
-      contentType = type;
     } else {
-      requestBuilder.addHeader(name, value);
+      headersBuilder.add(name, value);
     }
   }
 
+  void addHeaders(Headers headers) {
+    headersBuilder.addAll(headers);
+  }
+
   void addPathParam(String name, String value, boolean encoded) {
     if (relativeUrl == null) {
       // The relative URL is cleared when the first query parameter is set.
       throw new AssertionError();
     }
-    relativeUrl = relativeUrl.replace("{" + name + "}", canonicalizeForPath(value, encoded));
+    String replacement = canonicalizeForPath(value, encoded);
+    String newRelativeUrl = relativeUrl.replace("{" + name + "}", replacement);
+    if (PATH_TRAVERSAL.matcher(newRelativeUrl).matches()) {
+      throw new IllegalArgumentException(
+          "@Path parameters shouldn't perform path traversal ('.' or '..'): " + value);
+    }
+    relativeUrl = newRelativeUrl;
   }
 
   private static String canonicalizeForPath(String input, boolean alreadyEncoded) {
@@ -186,7 +215,11 @@ void setBody(RequestBody body) {
     this.body = body;
   }
 
-  Request build() {
+  <T> void addTag(Class<T> cls, @Nullable T value) {
+    requestBuilder.tag(cls, value);
+  }
+
+  Request.Builder get() {
     HttpUrl url;
     HttpUrl.Builder urlBuilder = this.urlBuilder;
     if (urlBuilder != null) {
@@ -219,14 +252,14 @@ Request build() {
       if (body != null) {
         body = new ContentTypeOverridingRequestBody(body, contentType);
       } else {
-        requestBuilder.addHeader("Content-Type", contentType.toString());
+        headersBuilder.add("Content-Type", contentType.toString());
       }
     }
 
     return requestBuilder
         .url(url)
-        .method(method, body)
-        .build();
+        .headers(headersBuilder.build())
+        .method(method, body);
   }
 
   private static class ContentTypeOverridingRequestBody extends RequestBody {
diff --git a/retrofit/src/main/java/retrofit2/RequestFactory.java b/retrofit/src/main/java/retrofit2/RequestFactory.java
index 3ad718b3c..cc43226ed 100644
--- a/retrofit/src/main/java/retrofit2/RequestFactory.java
+++ b/retrofit/src/main/java/retrofit2/RequestFactory.java
@@ -21,12 +21,15 @@
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import java.net.URI;
+import java.util.ArrayList;
 import java.util.LinkedHashSet;
+import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 import javax.annotation.Nullable;
+import kotlin.coroutines.Continuation;
 import okhttp3.Headers;
 import okhttp3.HttpUrl;
 import okhttp3.MediaType;
@@ -53,6 +56,7 @@
 import retrofit2.http.Query;
 import retrofit2.http.QueryMap;
 import retrofit2.http.QueryName;
+import retrofit2.http.Tag;
 import retrofit2.http.Url;
 
 import static retrofit2.Utils.methodError;
@@ -63,17 +67,20 @@ static RequestFactory parseAnnotations(Retrofit retrofit, Method method) {
     return new Builder(retrofit, method).build();
   }
 
+  private final Method method;
   private final HttpUrl baseUrl;
   final String httpMethod;
-  private final String relativeUrl;
-  private final Headers headers;
-  private final MediaType contentType;
+  private final @Nullable String relativeUrl;
+  private final @Nullable Headers headers;
+  private final @Nullable MediaType contentType;
   private final boolean hasBody;
   private final boolean isFormEncoded;
   private final boolean isMultipart;
   private final ParameterHandler<?>[] parameterHandlers;
+  final boolean isKotlinSuspendFunction;
 
   RequestFactory(Builder builder) {
+    method = builder.method;
     baseUrl = builder.retrofit.baseUrl;
     httpMethod = builder.httpMethod;
     relativeUrl = builder.relativeUrl;
@@ -83,26 +90,36 @@ static RequestFactory parseAnnotations(Retrofit retrofit, Method method) {
     isFormEncoded = builder.isFormEncoded;
     isMultipart = builder.isMultipart;
     parameterHandlers = builder.parameterHandlers;
+    isKotlinSuspendFunction = builder.isKotlinSuspendFunction;
   }
 
-  okhttp3.Request create(@Nullable Object[] args) throws IOException {
-    RequestBuilder requestBuilder = new RequestBuilder(httpMethod, baseUrl, relativeUrl, headers,
-        contentType, hasBody, isFormEncoded, isMultipart);
-
+  okhttp3.Request create(Object[] args) throws IOException {
     @SuppressWarnings("unchecked") // It is an error to invoke a method with the wrong arg types.
     ParameterHandler<Object>[] handlers = (ParameterHandler<Object>[]) parameterHandlers;
 
-    int argumentCount = args != null ? args.length : 0;
+    int argumentCount = args.length;
     if (argumentCount != handlers.length) {
       throw new IllegalArgumentException("Argument count (" + argumentCount
           + ") doesn't match expected count (" + handlers.length + ")");
     }
 
+    RequestBuilder requestBuilder = new RequestBuilder(httpMethod, baseUrl, relativeUrl,
+        headers, contentType, hasBody, isFormEncoded, isMultipart);
+
+    if (isKotlinSuspendFunction) {
+      // The Continuation is the last parameter and the handlers array contains null at that index.
+      argumentCount--;
+    }
+
+    List<Object> argumentList = new ArrayList<>(argumentCount);
     for (int p = 0; p < argumentCount; p++) {
+      argumentList.add(args[p]);
       handlers[p].apply(requestBuilder, args[p]);
     }
 
-    return requestBuilder.build();
+    return requestBuilder.get()
+        .tag(Invocation.class, new Invocation(method, argumentList))
+        .build();
   }
 
   /**
@@ -127,16 +144,19 @@ static RequestFactory parseAnnotations(Retrofit retrofit, Method method) {
     boolean gotBody;
     boolean gotPath;
     boolean gotQuery;
+    boolean gotQueryName;
+    boolean gotQueryMap;
     boolean gotUrl;
-    String httpMethod;
+    @Nullable String httpMethod;
     boolean hasBody;
     boolean isFormEncoded;
     boolean isMultipart;
-    String relativeUrl;
-    Headers headers;
-    MediaType contentType;
-    Set<String> relativeUrlParamNames;
-    ParameterHandler<?>[] parameterHandlers;
+    @Nullable String relativeUrl;
+    @Nullable Headers headers;
+    @Nullable MediaType contentType;
+    @Nullable Set<String> relativeUrlParamNames;
+    @Nullable ParameterHandler<?>[] parameterHandlers;
+    boolean isKotlinSuspendFunction;
 
     Builder(Retrofit retrofit, Method method) {
       this.retrofit = retrofit;
@@ -168,19 +188,9 @@ RequestFactory build() {
 
       int parameterCount = parameterAnnotationsArray.length;
       parameterHandlers = new ParameterHandler<?>[parameterCount];
-      for (int p = 0; p < parameterCount; p++) {
-        Type parameterType = parameterTypes[p];
-        if (Utils.hasUnresolvableType(parameterType)) {
-          throw parameterError(method, p,
-              "Parameter type must not include a type variable or wildcard: %s", parameterType);
-        }
-
-        Annotation[] parameterAnnotations = parameterAnnotationsArray[p];
-        if (parameterAnnotations == null) {
-          throw parameterError(method, p, "No Retrofit annotation found.");
-        }
-
-        parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);
+      for (int p = 0, lastParameter = parameterCount - 1; p < parameterCount; p++) {
+        parameterHandlers[p] =
+            parseParameter(p, parameterTypes[p], parameterAnnotationsArray[p], p == lastParameter);
       }
 
       if (relativeUrl == null && !gotUrl) {
@@ -275,11 +285,11 @@ private Headers parseHeaders(String[] headers) {
         String headerName = header.substring(0, colon);
         String headerValue = header.substring(colon + 1).trim();
         if ("Content-Type".equalsIgnoreCase(headerName)) {
-          MediaType type = MediaType.parse(headerValue);
-          if (type == null) {
-            throw methodError(method, "Malformed content type: %s", headerValue);
+          try {
+            contentType = MediaType.get(headerValue);
+          } catch (IllegalArgumentException e) {
+            throw methodError(method, e, "Malformed content type: %s", headerValue);
           }
-          contentType = type;
         } else {
           builder.add(headerName, headerValue);
         }
@@ -287,34 +297,48 @@ private Headers parseHeaders(String[] headers) {
       return builder.build();
     }
 
-    private ParameterHandler<?> parseParameter(
-        int p, Type parameterType, Annotation[] annotations) {
+    private @Nullable ParameterHandler<?> parseParameter(
+        int p, Type parameterType, @Nullable Annotation[] annotations, boolean allowContinuation) {
       ParameterHandler<?> result = null;
-      for (Annotation annotation : annotations) {
-        ParameterHandler<?> annotationAction = parseParameterAnnotation(
-            p, parameterType, annotations, annotation);
+      if (annotations != null) {
+        for (Annotation annotation : annotations) {
+          ParameterHandler<?> annotationAction =
+              parseParameterAnnotation(p, parameterType, annotations, annotation);
 
-        if (annotationAction == null) {
-          continue;
-        }
+          if (annotationAction == null) {
+            continue;
+          }
 
-        if (result != null) {
-          throw parameterError(method, p, "Multiple Retrofit annotations found, only one allowed.");
-        }
+          if (result != null) {
+            throw parameterError(method, p,
+                "Multiple Retrofit annotations found, only one allowed.");
+          }
 
-        result = annotationAction;
+          result = annotationAction;
+        }
       }
 
       if (result == null) {
+        if (allowContinuation) {
+          try {
+            if (Utils.getRawType(parameterType) == Continuation.class) {
+              isKotlinSuspendFunction = true;
+              return null;
+            }
+          } catch (NoClassDefFoundError ignored) {
+          }
+        }
         throw parameterError(method, p, "No Retrofit annotation found.");
       }
 
       return result;
     }
 
+    @Nullable
     private ParameterHandler<?> parseParameterAnnotation(
         int p, Type type, Annotation[] annotations, Annotation annotation) {
       if (annotation instanceof Url) {
+        validateResolvableType(p, type);
         if (gotUrl) {
           throw parameterError(method, p, "Multiple @Url method annotations found.");
         }
@@ -322,7 +346,13 @@ private Headers parseHeaders(String[] headers) {
           throw parameterError(method, p, "@Path parameters may not be used with @Url.");
         }
         if (gotQuery) {
-          throw parameterError(method, p, "A @Url parameter must not come after a @Query");
+          throw parameterError(method, p, "A @Url parameter must not come after a @Query.");
+        }
+        if (gotQueryName) {
+          throw parameterError(method, p, "A @Url parameter must not come after a @QueryName.");
+        }
+        if (gotQueryMap) {
+          throw parameterError(method, p, "A @Url parameter must not come after a @QueryMap.");
         }
         if (relativeUrl != null) {
           throw parameterError(method, p, "@Url cannot be used with @%s URL", httpMethod);
@@ -334,16 +364,23 @@ private Headers parseHeaders(String[] headers) {
             || type == String.class
             || type == URI.class
             || (type instanceof Class && "android.net.Uri".equals(((Class<?>) type).getName()))) {
-          return new ParameterHandler.RelativeUrl();
+          return new ParameterHandler.RelativeUrl(method, p);
         } else {
           throw parameterError(method, p,
               "@Url must be okhttp3.HttpUrl, String, java.net.URI, or android.net.Uri type.");
         }
 
       } else if (annotation instanceof Path) {
+        validateResolvableType(p, type);
         if (gotQuery) {
           throw parameterError(method, p, "A @Path parameter must not come after a @Query.");
         }
+        if (gotQueryName) {
+          throw parameterError(method, p, "A @Path parameter must not come after a @QueryName.");
+        }
+        if (gotQueryMap) {
+          throw parameterError(method, p, "A @Path parameter must not come after a @QueryMap.");
+        }
         if (gotUrl) {
           throw parameterError(method, p, "@Path parameters may not be used with @Url.");
         }
@@ -358,9 +395,10 @@ private Headers parseHeaders(String[] headers) {
         validatePathName(p, name);
 
         Converter<?, String> converter = retrofit.stringConverter(type, annotations);
-        return new ParameterHandler.Path<>(name, converter, path.encoded());
+        return new ParameterHandler.Path<>(method, p, name, converter, path.encoded());
 
       } else if (annotation instanceof Query) {
+        validateResolvableType(p, type);
         Query query = (Query) annotation;
         String name = query.value();
         boolean encoded = query.encoded();
@@ -391,11 +429,12 @@ private Headers parseHeaders(String[] headers) {
         }
 
       } else if (annotation instanceof QueryName) {
+        validateResolvableType(p, type);
         QueryName query = (QueryName) annotation;
         boolean encoded = query.encoded();
 
         Class<?> rawParameterType = Utils.getRawType(type);
-        gotQuery = true;
+        gotQueryName = true;
         if (Iterable.class.isAssignableFrom(rawParameterType)) {
           if (!(type instanceof ParameterizedType)) {
             throw parameterError(method, p, rawParameterType.getSimpleName()
@@ -420,7 +459,9 @@ private Headers parseHeaders(String[] headers) {
         }
 
       } else if (annotation instanceof QueryMap) {
+        validateResolvableType(p, type);
         Class<?> rawParameterType = Utils.getRawType(type);
+        gotQueryMap = true;
         if (!Map.class.isAssignableFrom(rawParameterType)) {
           throw parameterError(method, p, "@QueryMap parameter type must be Map.");
         }
@@ -438,9 +479,11 @@ private Headers parseHeaders(String[] headers) {
         Converter<?, String> valueConverter =
             retrofit.stringConverter(valueType, annotations);
 
-        return new ParameterHandler.QueryMap<>(valueConverter, ((QueryMap) annotation).encoded());
+        return new ParameterHandler.QueryMap<>(method, p,
+                valueConverter, ((QueryMap) annotation).encoded());
 
       } else if (annotation instanceof Header) {
+        validateResolvableType(p, type);
         Header header = (Header) annotation;
         String name = header.value();
 
@@ -469,6 +512,11 @@ private Headers parseHeaders(String[] headers) {
         }
 
       } else if (annotation instanceof HeaderMap) {
+        if (type == Headers.class) {
+          return new ParameterHandler.Headers(method, p);
+        }
+
+        validateResolvableType(p, type);
         Class<?> rawParameterType = Utils.getRawType(type);
         if (!Map.class.isAssignableFrom(rawParameterType)) {
           throw parameterError(method, p, "@HeaderMap parameter type must be Map.");
@@ -487,9 +535,10 @@ private Headers parseHeaders(String[] headers) {
         Converter<?, String> valueConverter =
             retrofit.stringConverter(valueType, annotations);
 
-        return new ParameterHandler.HeaderMap<>(valueConverter);
+        return new ParameterHandler.HeaderMap<>(method, p, valueConverter);
 
       } else if (annotation instanceof Field) {
+        validateResolvableType(p, type);
         if (!isFormEncoded) {
           throw parameterError(method, p, "@Field parameters can only be used with form encoding.");
         }
@@ -524,6 +573,7 @@ private Headers parseHeaders(String[] headers) {
         }
 
       } else if (annotation instanceof FieldMap) {
+        validateResolvableType(p, type);
         if (!isFormEncoded) {
           throw parameterError(method, p,
               "@FieldMap parameters can only be used with form encoding.");
@@ -547,9 +597,11 @@ private Headers parseHeaders(String[] headers) {
             retrofit.stringConverter(valueType, annotations);
 
         gotField = true;
-        return new ParameterHandler.FieldMap<>(valueConverter, ((FieldMap) annotation).encoded());
+        return new ParameterHandler.FieldMap<>(method, p,
+                valueConverter, ((FieldMap) annotation).encoded());
 
       } else if (annotation instanceof Part) {
+        validateResolvableType(p, type);
         if (!isMultipart) {
           throw parameterError(method, p,
               "@Part parameters can only be used with multipart encoding.");
@@ -608,7 +660,7 @@ private Headers parseHeaders(String[] headers) {
             }
             Converter<?, RequestBody> converter =
                 retrofit.requestBodyConverter(iterableType, annotations, methodAnnotations);
-            return new ParameterHandler.Part<>(headers, converter).iterable();
+            return new ParameterHandler.Part<>(method, p, headers, converter).iterable();
           } else if (rawParameterType.isArray()) {
             Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
             if (MultipartBody.Part.class.isAssignableFrom(arrayComponentType)) {
@@ -618,7 +670,7 @@ private Headers parseHeaders(String[] headers) {
             }
             Converter<?, RequestBody> converter =
                 retrofit.requestBodyConverter(arrayComponentType, annotations, methodAnnotations);
-            return new ParameterHandler.Part<>(headers, converter).array();
+            return new ParameterHandler.Part<>(method, p, headers, converter).array();
           } else if (MultipartBody.Part.class.isAssignableFrom(rawParameterType)) {
             throw parameterError(method, p,
                 "@Part parameters using the MultipartBody.Part must not "
@@ -626,11 +678,12 @@ private Headers parseHeaders(String[] headers) {
           } else {
             Converter<?, RequestBody> converter =
                 retrofit.requestBodyConverter(type, annotations, methodAnnotations);
-            return new ParameterHandler.Part<>(headers, converter);
+            return new ParameterHandler.Part<>(method, p, headers, converter);
           }
         }
 
       } else if (annotation instanceof PartMap) {
+        validateResolvableType(p, type);
         if (!isMultipart) {
           throw parameterError(method, p,
               "@PartMap parameters can only be used with multipart encoding.");
@@ -662,9 +715,10 @@ private Headers parseHeaders(String[] headers) {
             retrofit.requestBodyConverter(valueType, annotations, methodAnnotations);
 
         PartMap partMap = (PartMap) annotation;
-        return new ParameterHandler.PartMap<>(valueConverter, partMap.encoding());
+        return new ParameterHandler.PartMap<>(method, p, valueConverter, partMap.encoding());
 
       } else if (annotation instanceof Body) {
+        validateResolvableType(p, type);
         if (isFormEncoded || isMultipart) {
           throw parameterError(method, p,
               "@Body parameters cannot be used with form or multi-part encoding.");
@@ -681,12 +735,37 @@ private Headers parseHeaders(String[] headers) {
           throw parameterError(method, e, p, "Unable to create @Body converter for %s", type);
         }
         gotBody = true;
-        return new ParameterHandler.Body<>(converter);
+        return new ParameterHandler.Body<>(method, p, converter);
+
+      } else if (annotation instanceof Tag) {
+        validateResolvableType(p, type);
+
+        Class<?> tagType = Utils.getRawType(type);
+        for (int i = p - 1; i >= 0; i--) {
+          ParameterHandler<?> otherHandler = parameterHandlers[i];
+          if (otherHandler instanceof ParameterHandler.Tag
+              && ((ParameterHandler.Tag) otherHandler).cls.equals(tagType)) {
+            throw parameterError(method, p, "@Tag type "
+                + tagType.getName()
+                + " is duplicate of parameter #"
+                + (i + 1)
+                + " and would always overwrite its value.");
+          }
+        }
+
+        return new ParameterHandler.Tag<>(tagType);
       }
 
       return null; // Not a Retrofit annotation.
     }
 
+    private void validateResolvableType(int p, Type type) {
+      if (Utils.hasUnresolvableType(type)) {
+        throw parameterError(method, p,
+            "Parameter type must not include a type variable or wildcard: %s", type);
+      }
+    }
+
     private void validatePathName(int p, String name) {
       if (!PARAM_NAME_REGEX.matcher(name).matches()) {
         throw parameterError(method, p, "@Path parameter name must match %s. Found: %s",
diff --git a/retrofit/src/main/java/retrofit2/Retrofit.java b/retrofit/src/main/java/retrofit2/Retrofit.java
index 993690898..a0cc56929 100644
--- a/retrofit/src/main/java/retrofit2/Retrofit.java
+++ b/retrofit/src/main/java/retrofit2/Retrofit.java
@@ -18,6 +18,7 @@
 import java.lang.annotation.Annotation;
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
 import java.lang.reflect.Proxy;
 import java.lang.reflect.Type;
 import java.util.ArrayList;
@@ -133,9 +134,10 @@
     return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service },
         new InvocationHandler() {
           private final Platform platform = Platform.get();
+          private final Object[] emptyArgs = new Object[0];
 
-          @Override public Object invoke(Object proxy, Method method, @Nullable Object[] args)
-              throws Throwable {
+          @Override public @Nullable Object invoke(Object proxy, Method method,
+              @Nullable Object[] args) throws Throwable {
             // If the method is a method from Object then defer to normal invocation.
             if (method.getDeclaringClass() == Object.class) {
               return method.invoke(this, args);
@@ -143,7 +145,7 @@
             if (platform.isDefaultMethod(method)) {
               return platform.invokeDefaultMethod(method, service, proxy, args);
             }
-            return loadServiceMethod(method).invoke(args);
+            return loadServiceMethod(method).invoke(args != null ? args : emptyArgs);
           }
         });
   }
@@ -151,7 +153,7 @@
   private void eagerlyValidateMethods(Class<?> service) {
     Platform platform = Platform.get();
     for (Method method : service.getDeclaredMethods()) {
-      if (!platform.isDefaultMethod(method)) {
+      if (!platform.isDefaultMethod(method) && !Modifier.isStatic(method.getModifiers())) {
         loadServiceMethod(method);
       }
     }
@@ -391,7 +393,7 @@ public Builder newBuilder() {
   public static final class Builder {
     private final Platform platform;
     private @Nullable okhttp3.Call.Factory callFactory;
-    private HttpUrl baseUrl;
+    private @Nullable HttpUrl baseUrl;
     private final List<Converter.Factory> converterFactories = new ArrayList<>();
     private final List<CallAdapter.Factory> callAdapterFactories = new ArrayList<>();
     private @Nullable Executor callbackExecutor;
@@ -410,13 +412,19 @@ public Builder() {
       callFactory = retrofit.callFactory;
       baseUrl = retrofit.baseUrl;
 
-      converterFactories.addAll(retrofit.converterFactories);
-      // Remove the default BuiltInConverters instance added by build().
-      converterFactories.remove(0);
+      // Do not add the default BuiltIntConverters and platform-aware converters added by build().
+      for (int i = 1,
+          size = retrofit.converterFactories.size() - platform.defaultConverterFactoriesSize();
+          i < size; i++) {
+        converterFactories.add(retrofit.converterFactories.get(i));
+      }
 
-      callAdapterFactories.addAll(retrofit.callAdapterFactories);
-      // Remove the default, platform-aware call adapter added by build().
-      callAdapterFactories.remove(callAdapterFactories.size() - 1);
+      // Do not add the default, platform-aware call adapters added by build().
+      for (int i = 0,
+          size = retrofit.callAdapterFactories.size() - platform.defaultCallAdapterFactoriesSize();
+          i < size; i++) {
+        callAdapterFactories.add(retrofit.callAdapterFactories.get(i));
+      }
 
       callbackExecutor = retrofit.callbackExecutor;
       validateEagerly = retrofit.validateEagerly;
@@ -448,11 +456,7 @@ public Builder callFactory(okhttp3.Call.Factory factory) {
      */
     public Builder baseUrl(String baseUrl) {
       checkNotNull(baseUrl, "baseUrl == null");
-      HttpUrl httpUrl = HttpUrl.parse(baseUrl);
-      if (httpUrl == null) {
-        throw new IllegalArgumentException("Illegal URL: " + baseUrl);
-      }
-      return baseUrl(httpUrl);
+      return baseUrl(HttpUrl.get(baseUrl));
     }
 
     /**
@@ -584,16 +588,17 @@ public Retrofit build() {
 
       // Make a defensive copy of the adapters and add the default Call adapter.
       List<CallAdapter.Factory> callAdapterFactories = new ArrayList<>(this.callAdapterFactories);
-      callAdapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));
+      callAdapterFactories.addAll(platform.defaultCallAdapterFactories(callbackExecutor));
 
       // Make a defensive copy of the converters.
-      List<Converter.Factory> converterFactories =
-          new ArrayList<>(1 + this.converterFactories.size());
+      List<Converter.Factory> converterFactories = new ArrayList<>(
+          1 + this.converterFactories.size() + platform.defaultConverterFactoriesSize());
 
       // Add the built-in converter factory first. This prevents overriding its behavior but also
       // ensures correct behavior when using converters that consume all types.
       converterFactories.add(new BuiltInConverters());
       converterFactories.addAll(this.converterFactories);
+      converterFactories.addAll(platform.defaultConverterFactories());
 
       return new Retrofit(callFactory, baseUrl, unmodifiableList(converterFactories),
           unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly);
diff --git a/retrofit/src/main/java/retrofit2/ServiceMethod.java b/retrofit/src/main/java/retrofit2/ServiceMethod.java
index 8434f9e85..758511f5f 100644
--- a/retrofit/src/main/java/retrofit2/ServiceMethod.java
+++ b/retrofit/src/main/java/retrofit2/ServiceMethod.java
@@ -16,12 +16,26 @@
 package retrofit2;
 
 import java.lang.reflect.Method;
+import java.lang.reflect.Type;
 import javax.annotation.Nullable;
 
+import static retrofit2.Utils.methodError;
+
 abstract class ServiceMethod<T> {
   static <T> ServiceMethod<T> parseAnnotations(Retrofit retrofit, Method method) {
-    return new HttpServiceMethod.Builder<Object, T>(retrofit, method).build();
+    RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method);
+
+    Type returnType = method.getGenericReturnType();
+    if (Utils.hasUnresolvableType(returnType)) {
+      throw methodError(method,
+          "Method return type must not include a type variable or wildcard: %s", returnType);
+    }
+    if (returnType == void.class) {
+      throw methodError(method, "Service methods cannot return void.");
+    }
+
+    return HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);
   }
 
-  abstract T invoke(@Nullable Object[] args);
+  abstract @Nullable T invoke(Object[] args);
 }
diff --git a/retrofit/src/main/java/retrofit2/SkipCallbackExecutor.java b/retrofit/src/main/java/retrofit2/SkipCallbackExecutor.java
new file mode 100644
index 000000000..930827cc9
--- /dev/null
+++ b/retrofit/src/main/java/retrofit2/SkipCallbackExecutor.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import java.lang.annotation.Annotation;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+import java.lang.reflect.Type;
+
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Change the behavior of a {@code Call<BodyType>} return type to not use the
+ * {@linkplain Retrofit#callbackExecutor() callback executor} for invoking the
+ * {@link Callback#onResponse(Call, Response) onResponse} or
+ * {@link Callback#onFailure(Call, Throwable) onFailure} methods.
+ *
+ * <pre><code>
+ * &#64;SkipCallbackExecutor
+ * &#64;GET("user/{id}/token")
+ * Call&lt;String&gt; getToken(@Path("id") long id);
+ * </code></pre>
+ *
+ * This annotation can also be used when a {@link CallAdapter.Factory} <em>explicitly</em> delegates
+ * to the built-in factory for {@link Call} via
+ * {@link Retrofit#nextCallAdapter(CallAdapter.Factory, Type, Annotation[])} in order for the
+ * returned {@link Call} to skip the executor. (Note: by default, a {@link Call} supplied directly
+ * to a {@link CallAdapter} will already skip the callback executor. The annotation is only useful
+ * when looking up the built-in adapter.)
+ */
+@Documented
+@Target(METHOD)
+@Retention(RUNTIME)
+public @interface SkipCallbackExecutor {
+}
diff --git a/retrofit/src/main/java/retrofit2/SkipCallbackExecutorImpl.java b/retrofit/src/main/java/retrofit2/SkipCallbackExecutorImpl.java
new file mode 100644
index 000000000..4a3593b75
--- /dev/null
+++ b/retrofit/src/main/java/retrofit2/SkipCallbackExecutorImpl.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import java.lang.annotation.Annotation;
+
+// This class conforms to the annotation requirements documented on Annotation.
+final class SkipCallbackExecutorImpl implements SkipCallbackExecutor {
+  private static final SkipCallbackExecutor INSTANCE = new SkipCallbackExecutorImpl();
+
+  static Annotation[] ensurePresent(Annotation[] annotations) {
+    if (Utils.isAnnotationPresent(annotations, SkipCallbackExecutor.class)) {
+      return annotations;
+    }
+
+    Annotation[] newAnnotations = new Annotation[annotations.length + 1];
+    // Place the skip annotation first since we're guaranteed to check for it in the call adapter.
+    newAnnotations[0] = SkipCallbackExecutorImpl.INSTANCE;
+    System.arraycopy(annotations, 0, newAnnotations, 1, annotations.length);
+    return newAnnotations;
+  }
+
+  @Override public Class<? extends Annotation> annotationType() {
+    return SkipCallbackExecutor.class;
+  }
+
+  @Override public boolean equals(Object obj) {
+    return obj instanceof SkipCallbackExecutor;
+  }
+
+  @Override public int hashCode() {
+    return 0;
+  }
+
+  @Override public String toString() {
+    return "@" + SkipCallbackExecutor.class.getName() + "()";
+  }
+}
diff --git a/retrofit/src/main/java/retrofit2/Utils.java b/retrofit/src/main/java/retrofit2/Utils.java
index 85258222c..25fdcbf5e 100644
--- a/retrofit/src/main/java/retrofit2/Utils.java
+++ b/retrofit/src/main/java/retrofit2/Utils.java
@@ -288,7 +288,7 @@ private static Type resolveTypeVariable(
    * Returns the declaring class of {@code typeVariable}, or {@code null} if it was not declared by
    * a class.
    */
-  private static Class<?> declaringClassOf(TypeVariable<?> typeVariable) {
+  private static @Nullable Class<?> declaringClassOf(TypeVariable<?> typeVariable) {
     GenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();
     return genericDeclaration instanceof Class ? (Class<?>) genericDeclaration : null;
   }
@@ -348,6 +348,14 @@ static Type getParameterUpperBound(int index, ParameterizedType type) {
     return paramType;
   }
 
+  static Type getParameterLowerBound(int index, ParameterizedType type) {
+    Type paramType = type.getActualTypeArguments()[index];
+    if (paramType instanceof WildcardType) {
+      return ((WildcardType) paramType).getLowerBounds()[0];
+    }
+    return paramType;
+  }
+
   static boolean hasUnresolvableType(@Nullable Type type) {
     if (type instanceof Class<?>) {
       return false;
@@ -375,16 +383,8 @@ static boolean hasUnresolvableType(@Nullable Type type) {
         + "GenericArrayType, but <" + type + "> is of type " + className);
   }
 
-  static Type getCallResponseType(Type returnType) {
-    if (!(returnType instanceof ParameterizedType)) {
-      throw new IllegalArgumentException(
-          "Call return type must be parameterized as Call<Foo> or Call<? extends Foo>");
-    }
-    return getParameterUpperBound(0, (ParameterizedType) returnType);
-  }
-
-  private static final class ParameterizedTypeImpl implements ParameterizedType {
-    private final Type ownerType;
+  static final class ParameterizedTypeImpl implements ParameterizedType {
+    private final @Nullable Type ownerType;
     private final Type rawType;
     private final Type[] typeArguments;
 
@@ -413,7 +413,7 @@ static Type getCallResponseType(Type returnType) {
       return rawType;
     }
 
-    @Override public Type getOwnerType() {
+    @Override public @Nullable Type getOwnerType() {
       return ownerType;
     }
 
@@ -471,7 +471,7 @@ static Type getCallResponseType(Type returnType) {
    */
   private static final class WildcardTypeImpl implements WildcardType {
     private final Type upperBound;
-    private final Type lowerBound;
+    private final @Nullable Type lowerBound;
 
     WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {
       if (lowerBounds.length > 1) throw new IllegalArgumentException();
diff --git a/retrofit/src/main/java/retrofit2/http/HeaderMap.java b/retrofit/src/main/java/retrofit2/http/HeaderMap.java
index 248abc15e..f758f3e1c 100644
--- a/retrofit/src/main/java/retrofit2/http/HeaderMap.java
+++ b/retrofit/src/main/java/retrofit2/http/HeaderMap.java
@@ -15,9 +15,6 @@
  */
 package retrofit2.http;
 
-import static java.lang.annotation.ElementType.PARAMETER;
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
 import java.lang.annotation.Annotation;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
@@ -26,11 +23,15 @@
 import java.util.Map;
 import retrofit2.Retrofit;
 
+import static java.lang.annotation.ElementType.PARAMETER;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
 /**
- * Adds headers specified in the {@link Map}.
+ * Adds headers specified in the {@link Map} or {@link okhttp3.Headers}.
  * <p>
- * Values are converted to strings using {@link Retrofit#stringConverter(Type, Annotation[])}
- * (or {@link Object#toString()}, if no matching string converter is installed).
+ * Values in the map are converted to strings using
+ * {@link Retrofit#stringConverter(Type, Annotation[])} (or {@link Object#toString()}, if no
+ * matching string converter is installed).
  * <p>
  * Simple Example:
  * <pre>
diff --git a/retrofit/src/main/java/retrofit2/http/Streaming.java b/retrofit/src/main/java/retrofit2/http/Streaming.java
index 4a87591df..23fc0e290 100644
--- a/retrofit/src/main/java/retrofit2/http/Streaming.java
+++ b/retrofit/src/main/java/retrofit2/http/Streaming.java
@@ -18,13 +18,14 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+import okhttp3.ResponseBody;
 
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 /**
- * Treat the response body on methods returning {@link okhttp3.Response Response} as is,
- * i.e. without converting {@link okhttp3.Response#body() body()} to {@code byte[]}.
+ * Treat the response body on methods returning {@link ResponseBody ResponseBody} as is,
+ * i.e. without converting the body to {@code byte[]}.
  */
 @Documented
 @Target(METHOD)
diff --git a/retrofit/src/main/java/retrofit2/http/Tag.java b/retrofit/src/main/java/retrofit2/http/Tag.java
new file mode 100644
index 000000000..d25c7af84
--- /dev/null
+++ b/retrofit/src/main/java/retrofit2/http/Tag.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.http;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.PARAMETER;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Adds the argument instance as a request tag using the type as the key.
+ * <pre><code>
+ * &#64;GET("/")
+ * Call&lt;ResponseBody&gt; foo(@Tag String tag);
+ * </code></pre>
+ * Tag arguments may be {@code null} which will omit them from the request. Passing a parameterized
+ * type such as {@code List<String>} will use the raw type (i.e., {@code List.class}) as the key.
+ * Duplicate tag types are not allowed.
+ */
+@Documented
+@Target(PARAMETER)
+@Retention(RUNTIME)
+public @interface Tag {
+}
diff --git a/retrofit/src/main/java/retrofit2/internal/EverythingIsNonNull.java b/retrofit/src/main/java/retrofit2/internal/EverythingIsNonNull.java
new file mode 100644
index 000000000..e3da90636
--- /dev/null
+++ b/retrofit/src/main/java/retrofit2/internal/EverythingIsNonNull.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.internal;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import javax.annotation.Nonnull;
+import javax.annotation.meta.TypeQualifierDefault;
+
+/**
+ * Extends {@code ParametersAreNonnullByDefault} to also apply to Method results and fields.
+ *
+ * @see javax.annotation.ParametersAreNonnullByDefault
+ */
+@Documented
+@Nonnull
+@TypeQualifierDefault({
+    ElementType.FIELD,
+    ElementType.METHOD,
+    ElementType.PARAMETER
+})
+@Retention(RetentionPolicy.RUNTIME)
+public @interface EverythingIsNonNull {
+}
diff --git a/retrofit/src/main/java/retrofit2/package-info.java b/retrofit/src/main/java/retrofit2/package-info.java
index 135079424..2638c2e96 100644
--- a/retrofit/src/main/java/retrofit2/package-info.java
+++ b/retrofit/src/main/java/retrofit2/package-info.java
@@ -9,7 +9,5 @@
  * }
  * </pre>
  */
-@ParametersAreNonnullByDefault
+@retrofit2.internal.EverythingIsNonNull
 package retrofit2;
-
-import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit/src/main/resources/META-INF/proguard/retrofit2.pro b/retrofit/src/main/resources/META-INF/proguard/retrofit2.pro
index 0861d3c87..67a4d45f2 100644
--- a/retrofit/src/main/resources/META-INF/proguard/retrofit2.pro
+++ b/retrofit/src/main/resources/META-INF/proguard/retrofit2.pro
@@ -1,5 +1,9 @@
-# Retain generic type information for use by reflection by converters and adapters.
--keepattributes Signature
+# Retrofit does reflection on generic parameters. InnerClasses is required to use Signature and
+# EnclosingMethod is required to use InnerClasses.
+-keepattributes Signature, InnerClasses, EnclosingMethod
+
+# Retrofit does reflection on method and parameter annotations.
+-keepattributes RuntimeVisibleAnnotations, RuntimeVisibleParameterAnnotations
 
 # Retain service method parameters when optimizing.
 -keepclassmembers,allowshrinking,allowobfuscation interface * {
@@ -11,3 +15,14 @@
 
 # Ignore JSR 305 annotations for embedding nullability information.
 -dontwarn javax.annotation.**
+
+# Guarded by a NoClassDefFoundError try/catch and only used when on the classpath.
+-dontwarn kotlin.Unit
+
+# Top-level functions that can only be used by Kotlin.
+-dontwarn retrofit2.KotlinExtensions
+
+# With R8 full mode, it sees no subtypes of Retrofit interfaces since they are created with a Proxy
+# and replaces all potential values with null. Explicitly keeping the interfaces prevents this.
+-if interface * { @retrofit2.http.* <methods>; }
+-keep,allowobfuscation interface <1>
diff --git a/retrofit/src/test/java/retrofit2/CallTest.java b/retrofit/src/test/java/retrofit2/CallTest.java
index aa9b882d8..a99bf3646 100644
--- a/retrofit/src/test/java/retrofit2/CallTest.java
+++ b/retrofit/src/test/java/retrofit2/CallTest.java
@@ -47,8 +47,7 @@
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
-import static org.mockito.Mockito.spy;
-import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static retrofit2.TestingUtils.repeat;
 
 public final class CallTest {
   @Rule public final MockWebServer server = new MockWebServer();
@@ -370,11 +369,11 @@
   }
 
   @Test public void http204SkipsConverter() throws IOException {
-    final Converter<ResponseBody, String> converter = spy(new Converter<ResponseBody, String>() {
-      @Override public String convert(ResponseBody value) throws IOException {
-        return value.string();
+    final Converter<ResponseBody, String> converter = new Converter<ResponseBody, String>() {
+      @Override public String convert(ResponseBody value) {
+        throw new AssertionError();
       }
-    });
+    };
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
         .addConverterFactory(new ToStringConverterFactory() {
@@ -392,15 +391,14 @@
     Response<String> response = example.getString().execute();
     assertThat(response.code()).isEqualTo(204);
     assertThat(response.body()).isNull();
-    verifyNoMoreInteractions(converter);
   }
 
   @Test public void http205SkipsConverter() throws IOException {
-    final Converter<ResponseBody, String> converter = spy(new Converter<ResponseBody, String>() {
-      @Override public String convert(ResponseBody value) throws IOException {
-        return value.string();
+    final Converter<ResponseBody, String> converter = new Converter<ResponseBody, String>() {
+      @Override public String convert(ResponseBody value) {
+        throw new AssertionError();
       }
-    });
+    };
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
         .addConverterFactory(new ToStringConverterFactory() {
@@ -418,7 +416,31 @@
     Response<String> response = example.getString().execute();
     assertThat(response.code()).isEqualTo(205);
     assertThat(response.body()).isNull();
-    verifyNoMoreInteractions(converter);
+  }
+
+  @Test public void converterBodyDoesNotLeakContentInIntermediateBuffers() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new Converter.Factory() {
+          @Override public Converter<ResponseBody, ?> responseBodyConverter(Type type,
+              Annotation[] annotations, Retrofit retrofit) {
+            return new Converter<ResponseBody, String>() {
+              @Override public String convert(ResponseBody value) throws IOException {
+                String prefix = value.source().readUtf8(2);
+                value.source().skip(20_000 - 4);
+                String suffix = value.source().readUtf8();
+                return prefix + suffix;
+              }
+            };
+          }
+        })
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setBody(repeat('a', 10_000) + repeat('b', 10_000)));
+
+    Response<String> response = example.getString().execute();
+    assertThat(response.body()).isEqualTo("aabb");
   }
 
   @Test public void executeCallOnce() throws IOException {
diff --git a/retrofit/src/test/java/retrofit2/CompletableFutureAndroidTest.java b/retrofit/src/test/java/retrofit2/CompletableFutureAndroidTest.java
new file mode 100644
index 000000000..b2eff2369
--- /dev/null
+++ b/retrofit/src/test/java/retrofit2/CompletableFutureAndroidTest.java
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import java.util.concurrent.CompletableFuture;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+import retrofit2.helpers.ToStringConverterFactory;
+import retrofit2.http.GET;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+import static org.robolectric.annotation.Config.NEWEST_SDK;
+import static org.robolectric.annotation.Config.NONE;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = NEWEST_SDK, manifest = NONE)
+public final class CompletableFutureAndroidTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  interface Service {
+    @GET("/") CompletableFuture<String> endpoint();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Config(sdk = 24)
+  @Test public void completableFutureApi24() throws Exception {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    CompletableFuture<String> future = service.endpoint();
+    assertThat(future.get()).isEqualTo("Hi");
+  }
+
+  @Config(sdk = 21)
+  @Test public void completableFuturePreApi24() {
+    try {
+      service.endpoint();
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "Unable to create call adapter for java.util.concurrent.CompletableFuture<java.lang.String>\n"
+              + "    for method Service.endpoint");
+    }
+  }
+}
diff --git a/retrofit/src/test/java/retrofit2/CompletableFutureCallAdapterFactoryTest.java b/retrofit/src/test/java/retrofit2/CompletableFutureCallAdapterFactoryTest.java
new file mode 100644
index 000000000..feaacc929
--- /dev/null
+++ b/retrofit/src/test/java/retrofit2/CompletableFutureCallAdapterFactoryTest.java
@@ -0,0 +1,97 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import com.google.common.reflect.TypeToken;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import java.util.List;
+import java.util.concurrent.CompletableFuture;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.helpers.ToStringConverterFactory;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class CompletableFutureCallAdapterFactoryTest {
+  private static final Annotation[] NO_ANNOTATIONS = new Annotation[0];
+
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private final CallAdapter.Factory factory = CompletableFutureCallAdapterFactory.INSTANCE;
+  private Retrofit retrofit;
+
+  @Before public void setUp() {
+    retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+  }
+
+  @Test public void responseType() {
+    Type bodyClass = new TypeToken<CompletableFuture<String>>() {}.getType();
+    assertThat(factory.get(bodyClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type bodyWildcard = new TypeToken<CompletableFuture<? extends String>>() {}.getType();
+    assertThat(factory.get(bodyWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type bodyGeneric = new TypeToken<CompletableFuture<List<String>>>() {}.getType();
+    assertThat(factory.get(bodyGeneric, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(new TypeToken<List<String>>() {}.getType());
+    Type responseClass = new TypeToken<CompletableFuture<Response<String>>>() {}.getType();
+    assertThat(factory.get(responseClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type responseWildcard = new TypeToken<CompletableFuture<Response<? extends String>>>() {}.getType();
+    assertThat(factory.get(responseWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type resultClass = new TypeToken<CompletableFuture<Response<String>>>() {}.getType();
+    assertThat(factory.get(resultClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type resultWildcard = new TypeToken<CompletableFuture<Response<? extends String>>>() {}.getType();
+    assertThat(factory.get(resultWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+  }
+
+  @Test public void nonListenableFutureReturnsNull() {
+    CallAdapter<?, ?> adapter = factory.get(String.class, NO_ANNOTATIONS, retrofit);
+    assertThat(adapter).isNull();
+  }
+
+  @Test public void rawTypeThrows() {
+    Type observableType = new TypeToken<CompletableFuture>() {}.getType();
+    try {
+      factory.get(observableType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "CompletableFuture return type must be parameterized as CompletableFuture<Foo> or CompletableFuture<? extends Foo>");
+    }
+  }
+
+  @Test public void rawResponseTypeThrows() {
+    Type observableType = new TypeToken<CompletableFuture<Response>>() {}.getType();
+    try {
+      factory.get(observableType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Response must be parameterized as Response<Foo> or Response<? extends Foo>");
+    }
+  }
+}
diff --git a/retrofit/src/test/java/retrofit2/CompletableFutureTest.java b/retrofit/src/test/java/retrofit2/CompletableFutureTest.java
new file mode 100644
index 000000000..bf44dfd55
--- /dev/null
+++ b/retrofit/src/test/java/retrofit2/CompletableFutureTest.java
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import java.io.IOException;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ExecutionException;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.helpers.ToStringConverterFactory;
+import retrofit2.http.GET;
+
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class CompletableFutureTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  interface Service {
+    @GET("/") CompletableFuture<String> body();
+    @GET("/") CompletableFuture<Response<String>> response();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodySuccess200() throws Exception {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    CompletableFuture<String> future = service.body();
+    assertThat(future.get()).isEqualTo("Hi");
+  }
+
+  @Test public void bodySuccess404() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    CompletableFuture<String> future = service.body();
+    try {
+      future.get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause())
+          .isInstanceOf(HttpException.class) // Required for backwards compatibility.
+          .isInstanceOf(HttpException.class)
+          .hasMessage("HTTP 404 Client Error");
+    }
+  }
+
+  @Test public void bodyFailure() throws Exception {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    CompletableFuture<String> future = service.body();
+    try {
+      future.get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).isInstanceOf(IOException.class);
+    }
+  }
+
+  @Test public void responseSuccess200() throws Exception {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    CompletableFuture<Response<String>> future = service.response();
+    Response<String> response = future.get();
+    assertThat(response.isSuccessful()).isTrue();
+    assertThat(response.body()).isEqualTo("Hi");
+  }
+
+  @Test public void responseSuccess404() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
+
+    CompletableFuture<Response<String>> future = service.response();
+    Response<String> response = future.get();
+    assertThat(response.isSuccessful()).isFalse();
+    assertThat(response.errorBody().string()).isEqualTo("Hi");
+  }
+
+  @Test public void responseFailure() throws Exception {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    CompletableFuture<Response<String>> future = service.response();
+    try {
+      future.get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).isInstanceOf(IOException.class);
+    }
+  }
+}
diff --git a/retrofit/src/test/java/retrofit2/ExecutorCallAdapterFactoryTest.java b/retrofit/src/test/java/retrofit2/DefaultCallAdapterFactoryTest.java
similarity index 62%
rename from retrofit/src/test/java/retrofit2/ExecutorCallAdapterFactoryTest.java
rename to retrofit/src/test/java/retrofit2/DefaultCallAdapterFactoryTest.java
index 6f1480d23..e23a5d3c1 100644
--- a/retrofit/src/test/java/retrofit2/ExecutorCallAdapterFactoryTest.java
+++ b/retrofit/src/test/java/retrofit2/DefaultCallAdapterFactoryTest.java
@@ -21,31 +21,27 @@
 import java.lang.reflect.Type;
 import java.util.List;
 import java.util.concurrent.Executor;
+import java.util.concurrent.atomic.AtomicBoolean;
 import okhttp3.Request;
+import org.jetbrains.annotations.NotNull;
 import org.junit.Test;
 
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.spy;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.verifyNoMoreInteractions;
 
 @SuppressWarnings("unchecked")
-public final class ExecutorCallAdapterFactoryTest {
+public final class DefaultCallAdapterFactoryTest {
   private static final Annotation[] NO_ANNOTATIONS = new Annotation[0];
 
   private final Retrofit retrofit = new Retrofit.Builder()
       .baseUrl("http://localhost:1")
       .build();
-  private final Callback<String> callback = mock(Callback.class);
-  private final Executor callbackExecutor = spy(new Executor() {
-    @Override public void execute(Runnable runnable) {
-      runnable.run();
+  private final CallAdapter.Factory factory = new DefaultCallAdapterFactory(new Executor() {
+    @Override public void execute(@NotNull Runnable command) {
+      command.run();
     }
   });
-  private final CallAdapter.Factory factory = new ExecutorCallAdapterFactory(callbackExecutor);
 
   @Test public void rawTypeThrows() {
     try {
@@ -74,68 +70,42 @@
         (CallAdapter<String, Call<String>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
     final Response<String> response = Response.success("Hi");
     Call<String> call = adapter.adapt(new EmptyCall() {
-      @Override public Response<String> execute() throws IOException {
+      @Override public Response<String> execute() {
         return response;
       }
     });
     assertThat(call.execute()).isSameAs(response);
   }
 
-  @Test public void adaptedCallEnqueueUsesExecutorForSuccessCallback() {
-    Type returnType = new TypeToken<Call<String>>() {}.getType();
-    CallAdapter<String, Call<String>> adapter =
-        (CallAdapter<String, Call<String>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
-    final Response<String> response = Response.success("Hi");
-    EmptyCall originalCall = new EmptyCall() {
-      @Override public void enqueue(Callback<String> callback) {
-        callback.onResponse(this, response);
-      }
-    };
-    Call<String> call = adapter.adapt(originalCall);
-    call.enqueue(callback);
-    verify(callbackExecutor).execute(any(Runnable.class));
-    verify(callback).onResponse(call, response);
-  }
-
-  @Test public void adaptedCallEnqueueUsesExecutorForFailureCallback() {
+  @Test public void adaptedCallCloneDeepCopy() {
     Type returnType = new TypeToken<Call<String>>() {}.getType();
     CallAdapter<String, Call<String>> adapter =
         (CallAdapter<String, Call<String>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
-    final Throwable throwable = new IOException();
-    EmptyCall originalCall = new EmptyCall() {
-      @Override public void enqueue(Callback<String> callback) {
-        callback.onFailure(this, throwable);
+    final AtomicBoolean cloned = new AtomicBoolean();
+    Call<String> delegate = new EmptyCall() {
+      @Override public Call<String> clone() {
+        cloned.set(true);
+        return this;
       }
     };
-    Call<String> call = adapter.adapt(originalCall);
-    call.enqueue(callback);
-    verify(callbackExecutor).execute(any(Runnable.class));
-    verifyNoMoreInteractions(callbackExecutor);
-    verify(callback).onFailure(call, throwable);
-    verifyNoMoreInteractions(callback);
-  }
-
-  @Test public void adaptedCallCloneDeepCopy() {
-    Type returnType = new TypeToken<Call<String>>() {}.getType();
-    CallAdapter<String, Call<String>> adapter =
-        (CallAdapter<String, Call<String>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
-    Call<String> delegate = mock(Call.class);
     Call<String> call = adapter.adapt(delegate);
-    Call<String> cloned = call.clone();
-    assertThat(cloned).isNotSameAs(call);
-    verify(delegate).clone();
-    verifyNoMoreInteractions(delegate);
+    assertThat(call.clone()).isNotSameAs(call);
+    assertTrue(cloned.get());
   }
 
   @Test public void adaptedCallCancel() {
     Type returnType = new TypeToken<Call<String>>() {}.getType();
     CallAdapter<String, Call<String>> adapter =
         (CallAdapter<String, Call<String>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
-    Call<String> delegate = mock(Call.class);
+    final AtomicBoolean canceled = new AtomicBoolean();
+    Call<String> delegate = new EmptyCall() {
+      @Override public void cancel() {
+        canceled.set(true);
+      }
+    };
     Call<String> call = adapter.adapt(delegate);
     call.cancel();
-    verify(delegate).cancel();
-    verifyNoMoreInteractions(delegate);
+    assertTrue(canceled.get());
   }
 
   static class EmptyCall implements Call<String> {
diff --git a/retrofit/src/test/java/retrofit2/InvocationTest.java b/retrofit/src/test/java/retrofit2/InvocationTest.java
new file mode 100644
index 000000000..0dda742ba
--- /dev/null
+++ b/retrofit/src/test/java/retrofit2/InvocationTest.java
@@ -0,0 +1,88 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import java.lang.reflect.Method;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import okhttp3.MediaType;
+import okhttp3.OkHttpClient;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import org.junit.Test;
+import retrofit2.http.Body;
+import retrofit2.http.POST;
+import retrofit2.http.Path;
+import retrofit2.http.Query;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class InvocationTest {
+  interface Example {
+    @POST("/{p1}") //
+    Call<ResponseBody> postMethod(
+        @Path("p1") String p1, @Query("p2") String p2, @Body RequestBody body);
+  }
+
+  @Test public void invocationObjectOnCallAndRequestTag() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .callFactory(new OkHttpClient())
+        .build();
+
+    Example example = retrofit.create(Example.class);
+    RequestBody requestBody = RequestBody.create(MediaType.get("text/plain"), "three");
+    Call<ResponseBody> call = example.postMethod("one", "two", requestBody);
+
+    Invocation invocation = call.request().tag(Invocation.class);
+    Method method = invocation.method();
+    assertThat(method.getName()).isEqualTo("postMethod");
+    assertThat(method.getDeclaringClass()).isEqualTo(Example.class);
+    assertThat(invocation.arguments()).isEqualTo(Arrays.asList("one", "two", requestBody));
+  }
+
+  @Test public void nullMethod() {
+    try {
+      Invocation.of(null, Arrays.asList("one", "two"));
+      fail();
+    } catch (NullPointerException expected) {
+      assertThat(expected).hasMessage("method == null");
+    }
+  }
+
+  @Test public void nullArguments() {
+    try {
+      Invocation.of(Example.class.getDeclaredMethods()[0], null);
+      fail();
+    } catch (NullPointerException expected) {
+      assertThat(expected).hasMessage("arguments == null");
+    }
+  }
+
+  @Test public void argumentsAreImmutable() {
+    List<String> mutableList = new ArrayList<>(Arrays.asList("one", "two"));
+    Invocation invocation = Invocation.of(Example.class.getDeclaredMethods()[0], mutableList);
+    mutableList.add("three");
+    assertThat(invocation.arguments()).isEqualTo(Arrays.asList("one", "two"));
+    try {
+      invocation.arguments().clear();
+      fail();
+    } catch (UnsupportedOperationException expected) {
+    }
+  }
+}
diff --git a/retrofit/src/test/java/retrofit2/Java8DefaultMethodsTest.java b/retrofit/src/test/java/retrofit2/Java8DefaultMethodsTest.java
index 8333969c6..501c909e4 100644
--- a/retrofit/src/test/java/retrofit2/Java8DefaultMethodsTest.java
+++ b/retrofit/src/test/java/retrofit2/Java8DefaultMethodsTest.java
@@ -39,7 +39,7 @@
   //
   //  Response<String> response = example.user().execute();
   //  assertThat(response.body()).isEqualTo("Hi");
-  //  Response<String> response = example.user("hi").execute();
-  //  assertThat(response.body()).isEqualTo("Hi");
+  //  Response<String> response2 = example.user("Hi").execute();
+  //  assertThat(response2.body()).isEqualTo("Hi");
   //}
 }
diff --git a/retrofit/src/test/java/retrofit2/Java8DefaultStaticMethodsInValidationTest.java b/retrofit/src/test/java/retrofit2/Java8DefaultStaticMethodsInValidationTest.java
new file mode 100644
index 000000000..bc2521d5a
--- /dev/null
+++ b/retrofit/src/test/java/retrofit2/Java8DefaultStaticMethodsInValidationTest.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+// TODO this test doesn't play nice in the IDE because it relies on Java 8 language features.
+public final class Java8DefaultStaticMethodsInValidationTest {
+  //@Rule public final MockWebServer server = new MockWebServer();
+  //
+  //interface Example {
+  //  @GET("/") Call<String> user(@Query("name") String name);
+  //
+  //  default Call<String> user() {
+  //    return user("hey");
+  //  }
+  //
+  //  static String staticMethod() {
+  //    return "Hi";
+  //  }
+  //}
+  //
+  //@Test public void test() throws IOException {
+  //  Retrofit retrofit = new Retrofit.Builder()
+  //      .baseUrl(server.url("/"))
+  //      .addConverterFactory(new ToStringConverterFactory())
+  //      .validateEagerly(true)
+  //      .build();
+  //  Example example = retrofit.create(Example.class);
+  //}
+}
diff --git a/retrofit/src/test/java/retrofit2/KotlinExtensionsTest.kt b/retrofit/src/test/java/retrofit2/KotlinExtensionsTest.kt
new file mode 100644
index 000000000..b8196c7e6
--- /dev/null
+++ b/retrofit/src/test/java/retrofit2/KotlinExtensionsTest.kt
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2
+
+import okhttp3.mockwebserver.MockWebServer
+import org.junit.Assert.assertNotNull
+import org.junit.Rule
+import org.junit.Test
+
+class KotlinExtensionsTest {
+  @get:Rule val server = MockWebServer()
+
+  interface Empty
+
+  @Test fun reifiedCreate() {
+    val retrofit = Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .build()
+
+    assertNotNull(retrofit.create<Empty>())
+  }
+}
diff --git a/retrofit/src/test/java/retrofit2/KotlinSuspendRawTest.java b/retrofit/src/test/java/retrofit2/KotlinSuspendRawTest.java
new file mode 100644
index 000000000..d6fbbe0c7
--- /dev/null
+++ b/retrofit/src/test/java/retrofit2/KotlinSuspendRawTest.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import kotlin.coroutines.Continuation;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.http.GET;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+/**
+ * This code path can only be tested from Java because Kotlin does not allow you specify a raw
+ * Response type. Win! We still test this codepath for completeness.
+ */
+public final class KotlinSuspendRawTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  interface Service {
+    @GET("/")
+    Object body(Continuation<? super Response> response);
+  }
+
+  @Test public void raw() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .build();
+    Service service = retrofit.create(Service.class);
+
+    try {
+      service.body(null);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Response must include generic type (e.g., Response<String>)\n"
+          + "    for method Service.body");
+    }
+  }
+}
diff --git a/retrofit/src/test/java/retrofit2/KotlinSuspendTest.kt b/retrofit/src/test/java/retrofit2/KotlinSuspendTest.kt
new file mode 100644
index 000000000..629b02624
--- /dev/null
+++ b/retrofit/src/test/java/retrofit2/KotlinSuspendTest.kt
@@ -0,0 +1,276 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2
+
+import kotlinx.coroutines.GlobalScope
+import kotlinx.coroutines.async
+import kotlinx.coroutines.runBlocking
+import okhttp3.OkHttpClient
+import okhttp3.mockwebserver.MockResponse
+import okhttp3.mockwebserver.MockWebServer
+import okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST
+import okhttp3.mockwebserver.SocketPolicy.NO_RESPONSE
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Assert.assertTrue
+import org.junit.Assert.fail
+import org.junit.Ignore
+import org.junit.Rule
+import org.junit.Test
+import retrofit2.helpers.ToStringConverterFactory
+import retrofit2.http.GET
+import retrofit2.http.Path
+import java.io.IOException
+import java.lang.reflect.ParameterizedType
+import java.lang.reflect.Type
+
+class KotlinSuspendTest {
+  @get:Rule val server = MockWebServer()
+
+  interface Service {
+    @GET("/") suspend fun body(): String
+    @GET("/") suspend fun bodyNullable(): String?
+    @GET("/") suspend fun response(): Response<String>
+
+    @GET("/{a}/{b}/{c}")
+    suspend fun params(
+        @Path("a") a: String,
+        @Path("b") b: String,
+        @Path("c") c: String
+    ): String
+  }
+
+  @Test fun body() {
+    val retrofit = Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(ToStringConverterFactory())
+        .build()
+    val example = retrofit.create(Service::class.java)
+
+    server.enqueue(MockResponse().setBody("Hi"))
+
+    val body = runBlocking { example.body() }
+    assertThat(body).isEqualTo("Hi")
+  }
+
+  @Test fun body404() {
+    val retrofit = Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(ToStringConverterFactory())
+        .build()
+    val example = retrofit.create(Service::class.java)
+
+    server.enqueue(MockResponse().setResponseCode(404))
+
+    try {
+      runBlocking { example.body() }
+      fail()
+    } catch (e: HttpException) {
+      assertThat(e.code()).isEqualTo(404)
+    }
+  }
+
+  @Test fun bodyFailure() {
+    val retrofit = Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(ToStringConverterFactory())
+        .build()
+    val example = retrofit.create(Service::class.java)
+
+    server.enqueue(MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST))
+
+    try {
+      runBlocking { example.body() }
+      fail()
+    } catch (e: IOException) {
+    }
+  }
+
+  @Test fun bodyThrowsOnNull() {
+    val retrofit = Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(ToStringConverterFactory())
+        .build()
+    val example = retrofit.create(Service::class.java)
+
+    server.enqueue(MockResponse().setResponseCode(204))
+
+    try {
+      runBlocking { example.body() }
+      fail()
+    } catch (e: KotlinNullPointerException) {
+      // Coroutines wraps exceptions with a synthetic trace so fall back to cause message.
+      val message = e.message ?: (e.cause as KotlinNullPointerException).message
+      assertThat(message).isEqualTo(
+          "Response from retrofit2.KotlinSuspendTest\$Service.body was null but response body type was declared as non-null")
+    }
+  }
+
+  @Ignore("Not working yet")
+  @Test fun bodyNullable() {
+    val retrofit = Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(ToStringConverterFactory())
+        .build()
+    val example = retrofit.create(Service::class.java)
+
+    server.enqueue(MockResponse().setResponseCode(204))
+
+    val body = runBlocking { example.bodyNullable() }
+    assertThat(body).isNull()
+  }
+
+  @Test fun response() {
+    val retrofit = Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(ToStringConverterFactory())
+        .build()
+    val example = retrofit.create(Service::class.java)
+
+    server.enqueue(MockResponse().setBody("Hi"))
+
+    val response = runBlocking { example.response() }
+    assertThat(response.code()).isEqualTo(200)
+    assertThat(response.body()).isEqualTo("Hi")
+  }
+
+  @Test fun response404() {
+    val retrofit = Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(ToStringConverterFactory())
+        .build()
+    val example = retrofit.create(Service::class.java)
+
+    server.enqueue(MockResponse().setResponseCode(404))
+
+    val response = runBlocking { example.response() }
+    assertThat(response.code()).isEqualTo(404)
+  }
+
+  @Test fun responseFailure() {
+    val retrofit = Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(ToStringConverterFactory())
+        .build()
+    val example = retrofit.create(Service::class.java)
+
+    server.enqueue(MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST))
+
+    try {
+      runBlocking { example.response() }
+      fail()
+    } catch (e: IOException) {
+    }
+  }
+
+  @Test fun params() {
+    val retrofit = Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(ToStringConverterFactory())
+        .build()
+    val example = retrofit.create(Service::class.java)
+
+    server.enqueue(MockResponse())
+
+    runBlocking { example.params("1", "2", "3") }
+    val request = server.takeRequest()
+    assertThat(request.path).isEqualTo("/1/2/3")
+  }
+
+  @Test fun cancelationWorks() {
+    lateinit var call: okhttp3.Call
+
+    val okHttpClient = OkHttpClient()
+    val retrofit = Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .callFactory {
+          val newCall = okHttpClient.newCall(it)
+          call = newCall
+          newCall
+        }
+        .addConverterFactory(ToStringConverterFactory())
+        .build()
+    val example = retrofit.create(Service::class.java)
+
+    // This leaves the connection open indefinitely allowing us to cancel without racing a body.
+    server.enqueue(MockResponse().setSocketPolicy(NO_RESPONSE))
+
+    val deferred = GlobalScope.async { example.body() }
+
+    // This will block until the server has received the request ensuring it's in flight.
+    server.takeRequest()
+
+    deferred.cancel()
+    assertTrue(call.isCanceled)
+  }
+
+  @Test fun doesNotUseCallbackExecutor() {
+    val retrofit = Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .callbackExecutor { fail() }
+        .addConverterFactory(ToStringConverterFactory())
+        .build()
+    val example = retrofit.create(Service::class.java)
+
+    server.enqueue(MockResponse().setBody("Hi"))
+
+    val body = runBlocking { example.body() }
+    assertThat(body).isEqualTo("Hi")
+  }
+
+  @Test fun usesCallAdapterForCall() {
+    val callAdapterFactory = object : CallAdapter.Factory() {
+      override fun get(returnType: Type, annotations: Array<Annotation>,
+          retrofit: Retrofit): CallAdapter<*, *>? {
+        if (getRawType(returnType) != Call::class.java) {
+          return null
+        }
+        if (getParameterUpperBound(0, returnType as ParameterizedType) != String::class.java) {
+          return null
+        }
+        return object : CallAdapter<String, Call<String>> {
+          override fun responseType() = String::class.java
+          override fun adapt(call: Call<String>): Call<String> {
+            return object : Call<String> by call {
+              override fun enqueue(callback: Callback<String>) {
+                call.enqueue(object : Callback<String> by callback {
+                  override fun onResponse(call: Call<String>, response: Response<String>) {
+                    if (response.isSuccessful) {
+                      callback.onResponse(call, Response.success(response.body()?.repeat(5)))
+                    } else {
+                      callback.onResponse(call, response)
+                    }
+                  }
+                })
+              }
+            }
+          }
+        }
+      }
+    }
+
+    val retrofit = Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addCallAdapterFactory(callAdapterFactory)
+        .addConverterFactory(ToStringConverterFactory())
+        .build()
+    val example = retrofit.create(Service::class.java)
+
+    server.enqueue(MockResponse().setBody("Hi"))
+
+    val body = runBlocking { example.body() }
+    assertThat(body).isEqualTo("HiHiHiHiHi")
+  }
+}
diff --git a/retrofit/src/test/java/retrofit2/KotlinUnitTest.java b/retrofit/src/test/java/retrofit2/KotlinUnitTest.java
new file mode 100644
index 000000000..e73f223c7
--- /dev/null
+++ b/retrofit/src/test/java/retrofit2/KotlinUnitTest.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import java.io.IOException;
+import kotlin.Unit;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Ignore;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.http.GET;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class KotlinUnitTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  interface Service {
+    @GET("/")
+    Call<Unit> empty();
+  }
+
+  @Test public void unitOnClasspath() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    Response<Unit> response = example.empty().execute();
+    assertThat(response.isSuccessful()).isTrue();
+    assertThat(response.body()).isSameAs(Unit.INSTANCE);
+  }
+
+  @Ignore("This is implicitly tested by integration tests of the adapters and converters")
+  @Test public void unitMissingFromClasspath() {
+  }
+}
diff --git a/retrofit/src/test/java/retrofit2/OptionalConverterFactoryAndroidTest.java b/retrofit/src/test/java/retrofit2/OptionalConverterFactoryAndroidTest.java
new file mode 100644
index 000000000..de9e37e3f
--- /dev/null
+++ b/retrofit/src/test/java/retrofit2/OptionalConverterFactoryAndroidTest.java
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import java.io.IOException;
+import java.util.Optional;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+import retrofit2.helpers.ObjectInstanceConverterFactory;
+import retrofit2.http.GET;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+import static org.robolectric.annotation.Config.NEWEST_SDK;
+import static org.robolectric.annotation.Config.NONE;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = NEWEST_SDK, manifest = NONE)
+public final class OptionalConverterFactoryAndroidTest {
+  interface Service {
+    @GET("/") Call<Optional<Object>> optional();
+    @GET("/") Call<Object> object();
+  }
+
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ObjectInstanceConverterFactory())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Config(sdk = 24)
+  @Test public void optionalApi24() throws IOException {
+    server.enqueue(new MockResponse());
+
+    Optional<Object> optional = service.optional().execute().body();
+    assertThat(optional).isNotNull();
+    assertThat(optional.get()).isSameAs(ObjectInstanceConverterFactory.VALUE);
+  }
+
+  @Config(sdk = 21)
+  @Test public void optionalPreApi24() {
+    try {
+      service.optional();
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "Unable to create converter for java.util.Optional<java.lang.Object>\n"
+              + "    for method Service.optional");
+    }
+  }
+
+  @Test public void onlyMatchesOptional() throws IOException {
+    server.enqueue(new MockResponse());
+
+    Object body = service.object().execute().body();
+    assertThat(body).isSameAs(ObjectInstanceConverterFactory.VALUE);
+  }
+}
diff --git a/retrofit/src/test/java/retrofit2/OptionalConverterFactoryTest.java b/retrofit/src/test/java/retrofit2/OptionalConverterFactoryTest.java
new file mode 100644
index 000000000..e7925f7a6
--- /dev/null
+++ b/retrofit/src/test/java/retrofit2/OptionalConverterFactoryTest.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import java.io.IOException;
+import java.util.Optional;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.helpers.ObjectInstanceConverterFactory;
+import retrofit2.http.GET;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class OptionalConverterFactoryTest {
+  interface Service {
+    @GET("/") Call<Optional<Object>> optional();
+    @GET("/") Call<Object> object();
+  }
+
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ObjectInstanceConverterFactory())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void optional() throws IOException {
+    server.enqueue(new MockResponse());
+
+    Optional<Object> optional = service.optional().execute().body();
+    assertThat(optional).isNotNull();
+    assertThat(optional.get()).isSameAs(ObjectInstanceConverterFactory.VALUE);
+  }
+
+  @Test public void onlyMatchesOptional() throws IOException {
+    server.enqueue(new MockResponse());
+
+    Object body = service.object().execute().body();
+    assertThat(body).isSameAs(ObjectInstanceConverterFactory.VALUE);
+  }
+}
diff --git a/retrofit/src/test/java/retrofit2/RequestFactoryAndroidTest.java b/retrofit/src/test/java/retrofit2/RequestFactoryAndroidTest.java
index 37c470529..4e0b38de2 100644
--- a/retrofit/src/test/java/retrofit2/RequestFactoryAndroidTest.java
+++ b/retrofit/src/test/java/retrofit2/RequestFactoryAndroidTest.java
@@ -21,13 +21,17 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 import retrofit2.http.GET;
 import retrofit2.http.Url;
 
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.robolectric.annotation.Config.NEWEST_SDK;
+import static org.robolectric.annotation.Config.NONE;
 import static retrofit2.RequestFactoryTest.buildRequest;
 
 @RunWith(RobolectricTestRunner.class)
+@Config(sdk = NEWEST_SDK, manifest = NONE)
 @SuppressWarnings({"UnusedParameters", "unused"}) // Parameters inspected reflectively.
 public final class RequestFactoryAndroidTest {
   @Test public void getWithAndroidUriUrl() {
diff --git a/retrofit/src/test/java/retrofit2/RequestFactoryTest.java b/retrofit/src/test/java/retrofit2/RequestFactoryTest.java
index db2c4c2e7..dd7f3a675 100644
--- a/retrofit/src/test/java/retrofit2/RequestFactoryTest.java
+++ b/retrofit/src/test/java/retrofit2/RequestFactoryTest.java
@@ -57,15 +57,18 @@
 import retrofit2.http.Query;
 import retrofit2.http.QueryMap;
 import retrofit2.http.QueryName;
+import retrofit2.http.Tag;
 import retrofit2.http.Url;
 
+import static java.util.Arrays.asList;
+import static java.util.Collections.emptyList;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.fail;
 
 @SuppressWarnings({"UnusedParameters", "unused"}) // Parameters inspected reflectively.
 public final class RequestFactoryTest {
-  private static final MediaType TEXT_PLAIN = MediaType.parse("text/plain");
+  private static final MediaType TEXT_PLAIN = MediaType.get("text/plain");
 
   @Test public void customMethodNoBody() {
     class Example {
@@ -89,7 +92,7 @@
       }
     }
 
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    RequestBody body = RequestBody.create(TEXT_PLAIN, "hi");
     Request request = buildRequest(Example.class, body);
     assertThat(request.method()).isEqualTo("CUSTOM2");
     assertThat(request.url().toString()).isEqualTo("http://example.com/foo");
@@ -488,7 +491,8 @@
       buildRequest(Example.class, new Object[] { null });
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Query map was null.");
+      assertThat(e).hasMessage("Query map was null (parameter #1)\n" +
+              "    for method Example.method");
     }
   }
 
@@ -508,7 +512,8 @@
       buildRequest(Example.class, queryParams);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Query map contained null key.");
+      assertThat(e).hasMessage("Query map contained null key. (parameter #1)\n" +
+              "    for method Example.method");
     }
   }
 
@@ -528,7 +533,8 @@
       buildRequest(Example.class, queryParams);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Query map contained null value for key 'kit'.");
+      assertThat(e).hasMessage("Query map contained null value for key 'kit'. (parameter #1)\n" +
+              "    for method Example.method");
     }
   }
 
@@ -601,7 +607,8 @@
       buildRequest(Example.class, (Map<String, String>) null);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Header map was null.");
+      assertThat(e).hasMessage("Header map was null. (parameter #1)\n" +
+              "    for method Example.method");
     }
   }
 
@@ -621,7 +628,8 @@
       buildRequest(Example.class, headers);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Header map contained null key.");
+      assertThat(e).hasMessage("Header map contained null key. (parameter #1)\n" +
+              "    for method Example.method");
     }
   }
 
@@ -641,7 +649,72 @@
       buildRequest(Example.class, headers);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Header map contained null value for key 'Accept-Charset'.");
+      assertThat(e).hasMessage("Header map contained null value for key 'Accept-Charset'. (parameter #1)\n" +
+              "    for method Example.method");
+    }
+  }
+
+  @Test public void getWithHeaders() {
+    class Example {
+      @GET("/search")
+      Call<ResponseBody> method(@HeaderMap okhttp3.Headers headers) {
+        throw new AssertionError();
+      }
+    }
+
+    okhttp3.Headers headers = new okhttp3.Headers.Builder()
+        .add("Accept", "text/plain")
+        .add("Accept", "application/json")
+        .add("Accept-Charset", "utf-8")
+        .build();
+
+    Request request = buildRequest(Example.class, headers);
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/search");
+    assertThat(request.body()).isNull();
+    assertThat(request.headers().size()).isEqualTo(3);
+    assertThat(request.headers("Accept")).isEqualTo(asList("text/plain", "application/json"));
+    assertThat(request.header("Accept-Charset")).isEqualTo("utf-8");
+  }
+
+  @Test public void getWithHeadersAndHeaderMap() {
+    class Example {
+      @GET("/search")
+      Call<ResponseBody> method(@HeaderMap okhttp3.Headers headers,
+          @HeaderMap Map<String, Object> headerMap) {
+        throw new AssertionError();
+      }
+    }
+
+    okhttp3.Headers headers = new okhttp3.Headers.Builder()
+        .add("Accept", "text/plain")
+        .add("Accept-Charset", "utf-8")
+        .build();
+    Map<String, String> headerMap = Collections.singletonMap("Accept", "application/json");
+
+    Request request = buildRequest(Example.class, headers, headerMap);
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/search");
+    assertThat(request.body()).isNull();
+    assertThat(request.headers().size()).isEqualTo(3);
+    assertThat(request.headers("Accept")).isEqualTo(asList("text/plain", "application/json"));
+    assertThat(request.header("Accept-Charset")).isEqualTo("utf-8");
+  }
+
+  @Test public void headersRejectsNull() {
+    class Example {
+      @GET("/")
+      Call<ResponseBody> method(@HeaderMap okhttp3.Headers headers) {
+        throw new AssertionError();
+      }
+    }
+
+    try {
+      buildRequest(Example.class, (okhttp3.Headers) null);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Headers parameter must not be null. (parameter #1)\n" +
+          "    for method Example.method");
     }
   }
 
@@ -742,7 +815,7 @@
         return null;
       }
     }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    RequestBody body = RequestBody.create(TEXT_PLAIN, "hi");
     Request request = buildRequest(Example.class, body);
     assertThat(request.method()).isEqualTo("POST");
     assertThat(request.headers().size()).isZero();
@@ -757,7 +830,7 @@
         return null;
       }
     }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    RequestBody body = RequestBody.create(TEXT_PLAIN, "hi");
     Request request = buildRequest(Example.class, body);
     assertThat(request.method()).isEqualTo("PUT");
     assertThat(request.headers().size()).isZero();
@@ -772,7 +845,7 @@
         return null;
       }
     }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    RequestBody body = RequestBody.create(TEXT_PLAIN, "hi");
     Request request = buildRequest(Example.class, body);
     assertThat(request.method()).isEqualTo("PATCH");
     assertThat(request.headers().size()).isZero();
@@ -878,6 +951,88 @@
     assertThat(request.body()).isNull();
   }
 
+  @Test public void pathParametersAndPathTraversal() {
+    class Example {
+      @GET("/foo/bar/{ping}/") //
+      Call<ResponseBody> method(@Path(value = "ping") String ping) {
+        return null;
+      }
+    }
+
+    assertMalformedRequest(Example.class, ".");
+    assertMalformedRequest(Example.class, "..");
+
+    assertThat(buildRequest(Example.class, "./a").url().encodedPath())
+        .isEqualTo("/foo/bar/.%2Fa/");
+    assertThat(buildRequest(Example.class, "a/.").url().encodedPath())
+        .isEqualTo("/foo/bar/a%2F./");
+    assertThat(buildRequest(Example.class, "a/..").url().encodedPath())
+        .isEqualTo("/foo/bar/a%2F../");
+    assertThat(buildRequest(Example.class, "../a").url().encodedPath())
+        .isEqualTo("/foo/bar/..%2Fa/");
+    assertThat(buildRequest(Example.class, "..\\..").url().encodedPath())
+        .isEqualTo("/foo/bar/..%5C../");
+
+    assertThat(buildRequest(Example.class, "%2E").url().encodedPath())
+        .isEqualTo("/foo/bar/%252E/");
+    assertThat(buildRequest(Example.class, "%2E%2E").url().encodedPath())
+        .isEqualTo("/foo/bar/%252E%252E/");
+  }
+
+  @Test public void encodedPathParametersAndPathTraversal() {
+    class Example {
+      @GET("/foo/bar/{ping}/") //
+      Call<ResponseBody> method(@Path(value = "ping", encoded = true) String ping) {
+        return null;
+      }
+    }
+
+    assertMalformedRequest(Example.class, ".");
+    assertMalformedRequest(Example.class, "%2E");
+    assertMalformedRequest(Example.class, "%2e");
+    assertMalformedRequest(Example.class, "..");
+    assertMalformedRequest(Example.class, "%2E.");
+    assertMalformedRequest(Example.class, "%2e.");
+    assertMalformedRequest(Example.class, ".%2E");
+    assertMalformedRequest(Example.class, ".%2e");
+    assertMalformedRequest(Example.class, "%2E%2e");
+    assertMalformedRequest(Example.class, "%2e%2E");
+    assertMalformedRequest(Example.class, "./a");
+    assertMalformedRequest(Example.class, "a/.");
+    assertMalformedRequest(Example.class, "../a");
+    assertMalformedRequest(Example.class, "a/..");
+    assertMalformedRequest(Example.class, "a/../b");
+    assertMalformedRequest(Example.class, "a/%2e%2E/b");
+
+    assertThat(buildRequest(Example.class, "...").url().encodedPath())
+        .isEqualTo("/foo/bar/.../");
+    assertThat(buildRequest(Example.class, "a..b").url().encodedPath())
+        .isEqualTo("/foo/bar/a..b/");
+    assertThat(buildRequest(Example.class, "a..").url().encodedPath())
+        .isEqualTo("/foo/bar/a../");
+    assertThat(buildRequest(Example.class, "a..b").url().encodedPath())
+        .isEqualTo("/foo/bar/a..b/");
+    assertThat(buildRequest(Example.class, "..b").url().encodedPath())
+        .isEqualTo("/foo/bar/..b/");
+    assertThat(buildRequest(Example.class, "..\\..").url().encodedPath())
+        .isEqualTo("/foo/bar/..%5C../");
+  }
+
+  @Test public void dotDotsOkayWhenNotFullPathSegment() {
+    class Example {
+      @GET("/foo{ping}bar/") //
+      Call<ResponseBody> method(@Path(value = "ping", encoded = true) String ping) {
+        return null;
+      }
+    }
+
+    assertMalformedRequest(Example.class, "/./");
+    assertMalformedRequest(Example.class, "/../");
+
+    assertThat(buildRequest(Example.class, ".").url().encodedPath()).isEqualTo("/foo.bar/");
+    assertThat(buildRequest(Example.class, "..").url().encodedPath()).isEqualTo("/foo..bar/");
+  }
+
   @Test public void pathParamRequired() {
     class Example {
       @GET("/foo/bar/{ping}/") //
@@ -889,7 +1044,8 @@
       buildRequest(Example.class, new Object[] { null });
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e.getMessage()).isEqualTo("Path parameter \"ping\" value must not be null.");
+      assertThat(e.getMessage()).isEqualTo("Path parameter \"ping\" value must not be null. (parameter #1)\n" +
+              "    for method Example.method");
     }
   }
 
@@ -1005,6 +1161,40 @@
     }
   }
 
+  @Test public void getWithQueryNameThenPathThrows() {
+    class Example {
+      @GET("/foo/bar/{ping}/") //
+      Call<ResponseBody> method(@QueryName String kit, @Path("ping") String ping) {
+        throw new AssertionError();
+      }
+    }
+
+    try {
+      buildRequest(Example.class, "kat", "pong");
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("A @Path parameter must not come after a @QueryName. (parameter #2)\n"
+          + "    for method Example.method");
+    }
+  }
+
+  @Test public void getWithQueryMapThenPathThrows() {
+    class Example {
+      @GET("/foo/bar/{ping}/") //
+      Call<ResponseBody> method(@QueryMap Map<String, String> queries, @Path("ping") String ping) {
+        throw new AssertionError();
+      }
+    }
+
+    try {
+      buildRequest(Example.class, Collections.singletonMap("kit", "kat"), "pong");
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("A @Path parameter must not come after a @QueryMap. (parameter #2)\n"
+          + "    for method Example.method");
+    }
+  }
+
   @Test public void getWithPathAndQueryQuestionMarkParam() {
     class Example {
       @GET("/foo/bar/{ping}/") //
@@ -1322,10 +1512,10 @@
       }
     }
 
-    Request request = buildRequest(Example.class, HttpUrl.parse("http://example.com/foo/bar/"));
+    Request request = buildRequest(Example.class, HttpUrl.get("http://example.com/foo/bar/"));
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.url()).isEqualTo(HttpUrl.parse("http://example.com/foo/bar/"));
+    assertThat(request.url()).isEqualTo(HttpUrl.get("http://example.com/foo/bar/"));
     assertThat(request.body()).isNull();
   }
 
@@ -1340,8 +1530,9 @@
     try {
       buildRequest(Example.class, (HttpUrl) null);
       fail();
-    } catch (NullPointerException expected) {
-      assertThat(expected).hasMessage("@Url parameter is null.");
+    } catch (IllegalArgumentException expected) {
+      assertThat(expected).hasMessage("@Url parameter is null. (parameter #1)\n" +
+              "    for method Example.method");
     }
   }
 
@@ -1444,7 +1635,41 @@
       buildRequest(Example.class, "hey", "foo/bar/");
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("A @Url parameter must not come after a @Query (parameter #2)\n"
+      assertThat(e).hasMessage("A @Url parameter must not come after a @Query. (parameter #2)\n"
+          + "    for method Example.method");
+    }
+  }
+
+  @Test public void getWithQueryNameThenUrlThrows() {
+    class Example {
+      @GET
+      Call<ResponseBody> method(@QueryName String name, @Url String url) {
+        throw new AssertionError();
+      }
+    }
+
+    try {
+      buildRequest(Example.class, Collections.singletonMap("kit", "kat"), "foo/bar/");
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("A @Url parameter must not come after a @QueryName. (parameter #2)\n"
+          + "    for method Example.method");
+    }
+  }
+
+  @Test public void getWithQueryMapThenUrlThrows() {
+    class Example {
+      @GET
+      Call<ResponseBody> method(@QueryMap Map<String, String> queries, @Url String url) {
+        throw new AssertionError();
+      }
+    }
+
+    try {
+      buildRequest(Example.class, Collections.singletonMap("kit", "kat"), "foo/bar/");
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("A @Url parameter must not come after a @QueryMap. (parameter #2)\n"
           + "    for method Example.method");
     }
   }
@@ -1470,7 +1695,7 @@
         return null;
       }
     }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    RequestBody body = RequestBody.create(TEXT_PLAIN, "hi");
     Request request = buildRequest(Example.class, "http://example.com/foo/bar", body);
     assertThat(request.method()).isEqualTo("POST");
     assertThat(request.headers().size()).isZero();
@@ -1532,7 +1757,8 @@
       buildRequest(Example.class, new Object[] { null });
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e.getMessage()).isEqualTo("Body parameter value must not be null.");
+      assertThat(e.getMessage()).isEqualTo("Body parameter value must not be null. (parameter #1)\n" +
+              "    for method Example.method");
     }
   }
 
@@ -1561,12 +1787,14 @@
     }
 
     Request request = buildRequest(Example.class, "pong", RequestBody.create(
-        MediaType.parse("text/plain"), "kat"));
+        TEXT_PLAIN, "kat"));
     assertThat(request.method()).isEqualTo("POST");
     assertThat(request.headers().size()).isZero();
     assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
 
     RequestBody body = request.body();
+    assertThat(body.contentType().toString()).startsWith("multipart/form-data; boundary=");
+
     Buffer buffer = new Buffer();
     body.writeTo(buffer);
     String bodyString = buffer.readUtf8();
@@ -1726,7 +1954,7 @@
 
     MultipartBody.Part part1 = MultipartBody.Part.createFormData("foo", "bar");
     MultipartBody.Part part2 = MultipartBody.Part.createFormData("kit", "kat");
-    Request request = buildRequest(Example.class, Arrays.asList(part1, part2));
+    Request request = buildRequest(Example.class, asList(part1, part2));
     assertThat(request.method()).isEqualTo("POST");
     assertThat(request.headers().size()).isZero();
     assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
@@ -1816,7 +2044,7 @@
       }
     }
 
-    Request request = buildRequest(Example.class, Arrays.asList("pong1", "pong2"));
+    Request request = buildRequest(Example.class, asList("pong1", "pong2"));
     assertThat(request.method()).isEqualTo("POST");
     assertThat(request.headers().size()).isZero();
     assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
@@ -1886,7 +2114,7 @@
     }
 
     Request request = buildRequest(Example.class, "pong", RequestBody.create(
-        MediaType.parse("text/plain"), "kat"));
+        TEXT_PLAIN, "kat"));
     assertThat(request.method()).isEqualTo("POST");
     assertThat(request.headers().size()).isZero();
     assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
@@ -2030,7 +2258,8 @@
       buildRequest(Example.class, new Object[] { null });
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Part map was null.");
+      assertThat(e).hasMessage("Part map was null. (parameter #1)\n" +
+              "    for method Example.method");
     }
   }
 
@@ -2051,7 +2280,8 @@
       buildRequest(Example.class, params);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Part map contained null key.");
+      assertThat(e).hasMessage("Part map contained null key. (parameter #1)\n" +
+              "    for method Example.method");
     }
   }
 
@@ -2072,7 +2302,8 @@
       buildRequest(Example.class, params);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Part map contained null value for key 'kit'.");
+      assertThat(e).hasMessage("Part map contained null value for key 'kit'. (parameter #1)\n" +
+              "    for method Example.method");
     }
   }
 
@@ -2086,7 +2317,7 @@
     }
 
     try {
-      buildRequest(Example.class, Collections.emptyList());
+      buildRequest(Example.class, emptyList());
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
@@ -2166,7 +2397,9 @@
       }
     }
     Request request = buildRequest(Example.class, "bar", "pong");
-    assertBody(request.body(), "foo=bar&ping=pong");
+    RequestBody body = request.body();
+    assertBody(body, "foo=bar&ping=pong");
+    assertThat(body.contentType().toString()).isEqualTo("application/x-www-form-urlencoded");
   }
 
   @Test public void formEncodedWithEncodedNameFieldParam() {
@@ -2283,7 +2516,8 @@
       buildRequest(Example.class, new Object[] { null });
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Field map was null.");
+      assertThat(e).hasMessage("Field map was null. (parameter #1)\n" +
+              "    for method Example.method");
     }
   }
 
@@ -2304,7 +2538,8 @@
       buildRequest(Example.class, fieldMap);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Field map contained null key.");
+      assertThat(e).hasMessage("Field map contained null key. (parameter #1)\n" +
+              "    for method Example.method");
     }
   }
 
@@ -2325,7 +2560,8 @@
       buildRequest(Example.class, fieldMap);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Field map contained null value for key 'foo'.");
+      assertThat(e).hasMessage("Field map contained null value for key 'foo'. (parameter #1)\n" +
+              "    for method Example.method");
     }
   }
 
@@ -2451,7 +2687,7 @@
         return null;
       }
     }
-    Request request = buildRequest(Example.class, Arrays.asList("bar", null, "baz"));
+    Request request = buildRequest(Example.class, asList("bar", null, "baz"));
     assertThat(request.method()).isEqualTo("GET");
     okhttp3.Headers headers = request.headers();
     assertThat(headers.size()).isEqualTo(2);
@@ -2484,11 +2720,41 @@
         return null;
       }
     }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    RequestBody body = RequestBody.create(TEXT_PLAIN, "hi");
     Request request = buildRequest(Example.class, body);
     assertThat(request.body().contentType().toString()).isEqualTo("text/not-plain");
   }
 
+  @Test public void contentTypeAnnotationHeaderOverridesFormEncoding() {
+    class Example {
+      @FormUrlEncoded //
+      @POST("/foo") //
+      @Headers("Content-Type: text/not-plain") //
+      Call<ResponseBody> method(@Field("foo") String foo, @Field("ping") String ping) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, "bar", "pong");
+    assertThat(request.body().contentType().toString()).isEqualTo("text/not-plain");
+  }
+
+  @Test public void contentTypeAnnotationHeaderOverridesMultipart() {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      @Headers("Content-Type: text/not-plain") //
+      Call<ResponseBody> method(@Part("ping") String ping, @Part("kit") RequestBody kit) {
+        return null;
+      }
+    }
+
+    Request request = buildRequest(Example.class, "pong", RequestBody.create(
+        TEXT_PLAIN, "kat"));
+
+    RequestBody body = request.body();
+    assertThat(request.body().contentType().toString()).isEqualTo("text/not-plain");
+  }
+
   @Test public void malformedContentTypeHeaderThrows() {
     class Example {
       @POST("/") //
@@ -2497,13 +2763,14 @@
         return null;
       }
     }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    RequestBody body = RequestBody.create(TEXT_PLAIN, "hi");
     try {
       buildRequest(Example.class, body);
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage("Malformed content type: hello, world!\n"
           + "    for method Example.method");
+      assertThat(e.getCause()).isInstanceOf(IllegalArgumentException.class); // OkHttp's cause.
     }
   }
 
@@ -2526,7 +2793,7 @@
         return null;
       }
     }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "Plain");
+    RequestBody body = RequestBody.create(TEXT_PLAIN, "Plain");
     Request request = buildRequest(Example.class, "text/not-plain", body);
     assertThat(request.body().contentType().toString()).isEqualTo("text/not-plain");
   }
@@ -2538,12 +2805,13 @@
         return null;
       }
     }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    RequestBody body = RequestBody.create(TEXT_PLAIN, "hi");
     try {
       buildRequest(Example.class, "hello, world!", body);
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage("Malformed content type: hello, world!");
+      assertThat(e.getCause()).isInstanceOf(IllegalArgumentException.class); // OkHttp's cause.
     }
   }
 
@@ -2676,6 +2944,63 @@
     }
   }
 
+  @Test public void tag() {
+    class Example {
+      @GET("/") Call<ResponseBody> method(@Tag String tag) {
+        return null;
+      }
+    }
+
+    Request request = buildRequest(Example.class, "tagValue");
+    assertThat(request.tag(String.class)).isEqualTo("tagValue");
+  }
+
+  @Test public void tagGeneric() {
+    class Example {
+      @GET("/") Call<ResponseBody> method(@Tag List<String> tag) {
+        return null;
+      }
+    }
+
+    List<String> strings = asList("tag", "value");
+    Request request = buildRequest(Example.class, strings);
+    assertThat(request.tag(List.class)).isSameAs(strings);
+  }
+
+  @Test public void tagDuplicateFails() {
+    class Example {
+      @GET("/") Call<ResponseBody> method(@Tag String one, @Tag String two) {
+        return null;
+      }
+    }
+
+    try {
+      buildRequest(Example.class, "one", "two");
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "@Tag type java.lang.String is duplicate of parameter #1 and would always overwrite its value. (parameter #2)\n"
+              + "    for method Example.method");
+    }
+  }
+
+  @Test public void tagGenericDuplicateFails() {
+    class Example {
+      @GET("/") Call<ResponseBody> method(@Tag List<String> one, @Tag List<Long> two) {
+        return null;
+      }
+    }
+
+    try {
+      buildRequest(Example.class, emptyList(), emptyList());
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "@Tag type java.util.List is duplicate of parameter #1 and would always overwrite its value. (parameter #2)\n"
+              + "    for method Example.method");
+    }
+  }
+
   private static void assertBody(RequestBody body, String expected) {
     assertThat(body).isNotNull();
     Buffer buffer = new Buffer();
@@ -2713,4 +3038,12 @@ private static void assertBody(RequestBody body, String expected) {
 
     return buildRequest(cls, retrofitBuilder, args);
   }
+
+  static void assertMalformedRequest(Class<?> cls, Object... args) {
+    try {
+      Request request = buildRequest(cls, args);
+      fail("expected a malformed request but was " + request);
+    } catch (IllegalArgumentException expected) {
+    }
+  }
 }
diff --git a/retrofit/src/test/java/retrofit2/RetrofitTest.java b/retrofit/src/test/java/retrofit2/RetrofitTest.java
index 4a1b2b773..7b7240dc6 100644
--- a/retrofit/src/test/java/retrofit2/RetrofitTest.java
+++ b/retrofit/src/test/java/retrofit2/RetrofitTest.java
@@ -31,6 +31,7 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
+import javax.annotation.Nullable;
 import okhttp3.HttpUrl;
 import okhttp3.MediaType;
 import okhttp3.OkHttpClient;
@@ -39,6 +40,7 @@
 import okhttp3.ResponseBody;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+import org.jetbrains.annotations.NotNull;
 import org.junit.Rule;
 import org.junit.Test;
 import retrofit2.helpers.DelegatingCallAdapterFactory;
@@ -54,16 +56,10 @@
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.doReturn;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.spy;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.verifyNoMoreInteractions;
-import static org.mockito.Mockito.verifyZeroInteractions;
 
 public final class RetrofitTest {
   @Rule public final MockWebServer server = new MockWebServer();
@@ -76,6 +72,9 @@
     @GET("/") Call<okhttp3.Response> badType2();
 
     @GET("/") Call<ResponseBody> getResponseBody();
+    @SkipCallbackExecutor
+    @GET("/") Call<ResponseBody> getResponseBodySkippedExecutor();
+
     @GET("/") Call<Void> getVoid();
     @POST("/") Call<ResponseBody> postRequestBody(@Body RequestBody body);
     @GET("/") Call<ResponseBody> queryString(@Query("foo") String foo);
@@ -143,11 +142,24 @@
   }
 
   @Test public void cloneSharesStatefulInstances() {
-    CallAdapter.Factory callAdapter = mock(CallAdapter.Factory.class);
-    Converter.Factory converter = mock(Converter.Factory.class);
+    CallAdapter.Factory callAdapter = new CallAdapter.Factory() {
+      @Nullable @Override
+      public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+        throw new AssertionError();
+      }
+    };
+    Converter.Factory converter = new Converter.Factory() {};
     HttpUrl baseUrl = server.url("/");
-    Executor executor = mock(Executor.class);
-    okhttp3.Call.Factory callFactory = mock(okhttp3.Call.Factory.class);
+    Executor executor = new Executor() {
+      @Override public void execute(@NotNull Runnable command) {
+        command.run();
+      }
+    };
+    okhttp3.Call.Factory callFactory = new okhttp3.Call.Factory() {
+      @Override public okhttp3.Call newCall(Request request) {
+        throw new AssertionError();
+      }
+    };
 
     Retrofit one = new Retrofit.Builder()
         .addCallAdapterFactory(callAdapter)
@@ -157,8 +169,13 @@
         .callFactory(callFactory)
         .build();
 
-    CallAdapter.Factory callAdapter2 = mock(CallAdapter.Factory.class);
-    Converter.Factory converter2 = mock(Converter.Factory.class);
+    CallAdapter.Factory callAdapter2 = new CallAdapter.Factory() {
+      @Nullable @Override
+      public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+        throw new AssertionError();
+      }
+    };
+    Converter.Factory converter2 = new Converter.Factory() {};
     Retrofit two = one.newBuilder()
         .addCallAdapterFactory(callAdapter2)
         .addConverterFactory(converter2)
@@ -190,7 +207,7 @@
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "'retrofit2.Response' is not a valid response body type. Did you mean ResponseBody?\n"
+          "Response must include generic type (e.g., Response<String>)\n"
               + "    for method CallMethod.badType1");
     }
   }
@@ -271,8 +288,8 @@
     final AtomicBoolean factoryCalled = new AtomicBoolean();
     final AtomicBoolean adapterCalled = new AtomicBoolean();
     class MyCallAdapterFactory extends CallAdapter.Factory {
-      @Override public CallAdapter<?, ?> get(final Type returnType, Annotation[] annotations,
-          Retrofit retrofit) {
+      @Override public @Nullable CallAdapter<?, ?> get(
+          final Type returnType, Annotation[] annotations, Retrofit retrofit) {
         factoryCalled.set(true);
         if (getRawType(returnType) != Call.class) {
           return null;
@@ -302,8 +319,8 @@
 
   @Test public void customCallAdapter() {
     class GreetingCallAdapterFactory extends CallAdapter.Factory {
-      @Override public CallAdapter<Object, String> get(Type returnType, Annotation[] annotations,
-          Retrofit retrofit) {
+      @Override public @Nullable CallAdapter<Object, String> get(
+          Type returnType, Annotation[] annotations, Retrofit retrofit) {
         if (getRawType(returnType) != String.class) {
           return null;
         }
@@ -331,8 +348,8 @@
   @Test public void methodAnnotationsPassedToCallAdapter() {
     final AtomicReference<Annotation[]> annotationsRef = new AtomicReference<>();
     class MyCallAdapterFactory extends CallAdapter.Factory {
-      @Override public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations,
-          Retrofit retrofit) {
+      @Override public @Nullable CallAdapter<?, ?> get(
+          Type returnType, Annotation[] annotations, Retrofit retrofit) {
         annotationsRef.set(annotations);
         return null;
       }
@@ -364,6 +381,7 @@
       assertThat(e.getCause()).hasMessage(""
           + "Could not locate call adapter for java.util.concurrent.Future<java.lang.String>.\n"
           + "  Tried:\n"
+          + "   * retrofit2.CompletableFutureCallAdapterFactory\n"
           + "   * retrofit2.DefaultCallAdapterFactory");
     }
   }
@@ -442,8 +460,8 @@
   @Test public void stringConverterCalledForString() {
     final AtomicBoolean factoryCalled = new AtomicBoolean();
     class MyConverterFactory extends Converter.Factory {
-      @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
-          Retrofit retrofit) {
+      @Override public @Nullable Converter<?, String> stringConverter(
+          Type type, Annotation[] annotations, Retrofit retrofit) {
         factoryCalled.set(true);
         return null;
       }
@@ -461,8 +479,8 @@
   @Test public void stringConverterReturningNullResultsInDefault() {
     final AtomicBoolean factoryCalled = new AtomicBoolean();
     class MyConverterFactory extends Converter.Factory {
-      @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
-          Retrofit retrofit) {
+      @Override public @Nullable Converter<?, String> stringConverter(
+          Type type, Annotation[] annotations, Retrofit retrofit) {
         factoryCalled.set(true);
         return null;
       }
@@ -492,7 +510,8 @@
       assertThat(e.getCause()).hasMessage(""
           + "Could not locate RequestBody converter for class java.lang.String.\n"
           + "  Tried:\n"
-          + "   * retrofit2.BuiltInConverters");
+          + "   * retrofit2.BuiltInConverters\n"
+          + "   * retrofit2.OptionalConverterFactory");
     }
   }
 
@@ -514,7 +533,8 @@
       assertThat(e.getCause()).hasMessage(""
           + "Could not locate ResponseBody converter for class java.lang.String.\n"
           + "  Tried:\n"
-          + "   * retrofit2.BuiltInConverters");
+          + "   * retrofit2.BuiltInConverters\n"
+          + "   * retrofit2.OptionalConverterFactory");
     }
   }
 
@@ -566,7 +586,7 @@
 
     server.enqueue(new MockResponse().setBody("Hi"));
 
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "Hey");
+    RequestBody body = RequestBody.create(MediaType.get("text/plain"), "Hey");
     Response<ResponseBody> response = example.postRequestBody(body).execute();
     assertThat(response.body().string()).isEqualTo("Hi");
 
@@ -693,8 +713,7 @@
     try {
       new Retrofit.Builder().baseUrl("ftp://foo/bar");
       fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Illegal URL: ftp://foo/bar");
+    } catch (IllegalArgumentException ignored) {
     }
   }
 
@@ -705,7 +724,7 @@
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage("baseUrl must end in /: http://example.com/api");
     }
-    HttpUrl parsed = HttpUrl.parse("http://example.com/api");
+    HttpUrl parsed = HttpUrl.get("http://example.com/api");
     try {
       new Retrofit.Builder().baseUrl(parsed);
       fail();
@@ -719,11 +738,11 @@
         .baseUrl("http://example.com/")
         .build();
     HttpUrl baseUrl = retrofit.baseUrl();
-    assertThat(baseUrl).isEqualTo(HttpUrl.parse("http://example.com/"));
+    assertThat(baseUrl).isEqualTo(HttpUrl.get("http://example.com/"));
   }
 
   @Test public void baseHttpUrlPropagated() {
-    HttpUrl url = HttpUrl.parse("http://example.com/");
+    HttpUrl url = HttpUrl.get("http://example.com/");
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(url)
         .build();
@@ -747,7 +766,11 @@
   }
 
   @Test public void callFactoryPropagated() {
-    okhttp3.Call.Factory callFactory = mock(okhttp3.Call.Factory.class);
+    okhttp3.Call.Factory callFactory = new okhttp3.Call.Factory() {
+      @Override public okhttp3.Call newCall(Request request) {
+        throw new AssertionError();
+      }
+    };
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl("http://example.com/")
         .callFactory(callFactory)
@@ -765,11 +788,13 @@
   }
 
   @Test public void callFactoryUsed() throws IOException {
-    okhttp3.Call.Factory callFactory = spy(new okhttp3.Call.Factory() {
+    final AtomicBoolean called = new AtomicBoolean();
+    okhttp3.Call.Factory callFactory = new okhttp3.Call.Factory() {
       @Override public okhttp3.Call newCall(Request request) {
+        called.set(true);
         return new OkHttpClient().newCall(request);
       }
-    });
+    };
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
         .callFactory(callFactory)
@@ -779,8 +804,7 @@
 
     CallMethod service = retrofit.create(CallMethod.class);
     service.getResponseBody().execute();
-    verify(callFactory).newCall(any(Request.class));
-    verifyNoMoreInteractions(callFactory);
+    assertTrue(called.get());
   }
 
   @Test public void callFactoryReturningNullThrows() throws IOException {
@@ -844,49 +868,52 @@
         .baseUrl("http://example.com/")
         .build();
     List<Converter.Factory> converterFactories = retrofit.converterFactories();
-    assertThat(converterFactories).hasSize(1);
+    assertThat(converterFactories).hasSize(2);
     assertThat(converterFactories.get(0)).isInstanceOf(BuiltInConverters.class);
   }
 
   @Test public void builtInConvertersFirstInClone() {
-    Converter<ResponseBody, Void> converter = mock(Converter.class);
-    Converter.Factory factory = mock(Converter.Factory.class);
-    Annotation[] annotations = new Annotation[0];
+    Converter.Factory factory = new Converter.Factory() {
+      @Nullable @Override
+      public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+          Retrofit retrofit) {
+        throw new AssertionError("User converter factory shouldn't be called for built-in types");
+      }
+    };
 
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl("http://example.com/")
         .addConverterFactory(factory)
+        .build()
+        .newBuilder() // Do a newBuilder().builder() dance to force the internal list to clone.
         .build();
 
-    doReturn(converter).when(factory).responseBodyConverter(Void.class, annotations, retrofit);
-
-    retrofit.newBuilder().build().responseBodyConverter(Void.class, annotations);
-
-    verifyZeroInteractions(factory);
+    assertNotNull(retrofit.responseBodyConverter(Void.class, new Annotation[0]));
   }
 
   @Test public void requestConverterFactoryQueried() {
-    Type type = String.class;
-    Annotation[] parameterAnnotations = new Annotation[0];
-    Annotation[] methodAnnotations = new Annotation[1];
-
-    Converter<?, RequestBody> expectedAdapter = mock(Converter.class);
-    Converter.Factory factory = mock(Converter.Factory.class);
+    final Converter<?, RequestBody> expectedAdapter = new Converter<Object, RequestBody>() {
+      @Nullable @Override public RequestBody convert(Object value) {
+        throw new AssertionError();
+      }
+    };
+    Converter.Factory factory = new Converter.Factory() {
+      @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
+          Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+        return String.class.equals(type)
+            ? expectedAdapter
+            : null;
+      }
+    };
 
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl("http://example.com/")
         .addConverterFactory(factory)
         .build();
 
-    doReturn(expectedAdapter).when(factory).requestBodyConverter(type, parameterAnnotations,
-        methodAnnotations, retrofit);
-
-    Converter<?, RequestBody> actualAdapter = retrofit.requestBodyConverter(type,
-        parameterAnnotations, methodAnnotations);
+    Converter<?, RequestBody> actualAdapter =
+        retrofit.requestBodyConverter(String.class, new Annotation[0], new Annotation[0]);
     assertThat(actualAdapter).isSameAs(expectedAdapter);
-
-    verify(factory).requestBodyConverter(type, parameterAnnotations, methodAnnotations, retrofit);
-    verifyNoMoreInteractions(factory);
   }
 
   @Test public void requestConverterFactoryNoMatchThrows() {
@@ -908,7 +935,8 @@
           + "Could not locate RequestBody converter for class java.lang.String.\n"
           + "  Tried:\n"
           + "   * retrofit2.BuiltInConverters\n"
-          + "   * retrofit2.helpers.NonMatchingConverterFactory");
+          + "   * retrofit2.helpers.NonMatchingConverterFactory\n"
+          + "   * retrofit2.OptionalConverterFactory");
     }
 
     assertThat(nonMatchingFactory.called).isTrue();
@@ -937,7 +965,8 @@
           + "   * retrofit2.BuiltInConverters\n"
           + "   * retrofit2.helpers.NonMatchingConverterFactory\n"
           + "  Tried:\n"
-          + "   * retrofit2.helpers.NonMatchingConverterFactory");
+          + "   * retrofit2.helpers.NonMatchingConverterFactory\n"
+          + "   * retrofit2.OptionalConverterFactory");
     }
 
     assertThat(nonMatchingFactory1.called).isFalse();
@@ -945,24 +974,29 @@
   }
 
   @Test public void responseConverterFactoryQueried() {
-    Type type = String.class;
-    Annotation[] annotations = new Annotation[0];
-
-    Converter<ResponseBody, ?> expectedAdapter = mock(Converter.class);
-    Converter.Factory factory = mock(Converter.Factory.class);
+    final Converter<ResponseBody, ?> expectedAdapter = new Converter<ResponseBody, Object>() {
+      @Nullable @Override public Object convert(ResponseBody value) {
+        throw new AssertionError();
+      }
+    };
+    Converter.Factory factory = new Converter.Factory() {
+      @Nullable @Override
+      public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+          Retrofit retrofit) {
+        return String.class.equals(type)
+            ? expectedAdapter
+            : null;
+      }
+    };
 
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl("http://example.com/")
         .addConverterFactory(factory)
         .build();
 
-    doReturn(expectedAdapter).when(factory).responseBodyConverter(type, annotations, retrofit);
-
-    Converter<ResponseBody, ?> actualAdapter = retrofit.responseBodyConverter(type, annotations);
+    Converter<ResponseBody, ?> actualAdapter =
+        retrofit.responseBodyConverter(String.class, new Annotation[0]);
     assertThat(actualAdapter).isSameAs(expectedAdapter);
-
-    verify(factory).responseBodyConverter(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory);
   }
 
   @Test public void responseConverterFactoryNoMatchThrows() {
@@ -984,7 +1018,8 @@
           + "Could not locate ResponseBody converter for class java.lang.String.\n"
           + "  Tried:\n"
           + "   * retrofit2.BuiltInConverters\n"
-          + "   * retrofit2.helpers.NonMatchingConverterFactory");
+          + "   * retrofit2.helpers.NonMatchingConverterFactory\n"
+          + "   * retrofit2.OptionalConverterFactory");
     }
 
     assertThat(nonMatchingFactory.called).isTrue();
@@ -1013,7 +1048,8 @@
           + "   * retrofit2.BuiltInConverters\n"
           + "   * retrofit2.helpers.NonMatchingConverterFactory\n"
           + "  Tried:\n"
-          + "   * retrofit2.helpers.NonMatchingConverterFactory");
+          + "   * retrofit2.helpers.NonMatchingConverterFactory\n"
+          + "   * retrofit2.OptionalConverterFactory");
     }
 
     assertThat(nonMatchingFactory1.called).isFalse();
@@ -1021,28 +1057,33 @@
   }
 
   @Test public void stringConverterFactoryQueried() {
-    Type type = Object.class;
-    Annotation[] annotations = new Annotation[0];
-
-    Converter<?, String> expectedConverter = mock(Converter.class);
-    Converter.Factory factory = mock(Converter.Factory.class);
+    final Converter<?, String> expectedConverter = new Converter<Object, String>() {
+      @Nullable @Override public String convert(Object value) {
+        throw new AssertionError();
+      }
+    };
+    Converter.Factory factory = new Converter.Factory() {
+      @Nullable @Override
+      public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+          Retrofit retrofit) {
+        return Object.class.equals(type)
+            ? expectedConverter
+            : null;
+      }
+    };
 
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl("http://example.com/")
         .addConverterFactory(factory)
         .build();
 
-    doReturn(expectedConverter).when(factory).stringConverter(type, annotations, retrofit);
-
-    Converter<?, String> actualConverter = retrofit.stringConverter(type, annotations);
+    Converter<?, String> actualConverter =
+        retrofit.stringConverter(Object.class, new Annotation[0]);
     assertThat(actualConverter).isSameAs(expectedConverter);
-
-    verify(factory).stringConverter(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory);
   }
 
   @Test public void converterFactoryPropagated() {
-    Converter.Factory factory = mock(Converter.Factory.class);
+    Converter.Factory factory = new Converter.Factory() {};
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl("http://example.com/")
         .addConverterFactory(factory)
@@ -1067,7 +1108,12 @@
   }
 
   @Test public void callAdapterFactoryPropagated() {
-    CallAdapter.Factory factory = mock(CallAdapter.Factory.class);
+    CallAdapter.Factory factory = new CallAdapter.Factory() {
+      @Nullable @Override
+      public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+        throw new AssertionError();
+      }
+    };
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl("http://example.com/")
         .addCallAdapterFactory(factory)
@@ -1076,38 +1122,55 @@
   }
 
   @Test public void callAdapterFactoryQueried() {
-    Type type = String.class;
-    Annotation[] annotations = new Annotation[0];
-
-    CallAdapter<?, ?> expectedAdapter = mock(CallAdapter.class);
-    CallAdapter.Factory factory = mock(CallAdapter.Factory.class);
+    final CallAdapter<?, ?> expectedAdapter = new CallAdapter<Object, Object>() {
+      @Override public Type responseType() {
+        throw new AssertionError();
+      }
+      @Override public Object adapt(Call<Object> call) {
+        throw new AssertionError();
+      }
+    };
+    CallAdapter.Factory factory = new CallAdapter.Factory() {
+      @Nullable @Override
+      public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+        return String.class.equals(returnType)
+            ? expectedAdapter
+            : null;
+      }
+    };
 
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl("http://example.com/")
         .addCallAdapterFactory(factory)
         .build();
 
-    doReturn(expectedAdapter).when(factory).get(type, annotations, retrofit);
-
-    CallAdapter<?, ?> actualAdapter = retrofit.callAdapter(type, annotations);
+    CallAdapter<?, ?> actualAdapter = retrofit.callAdapter(String.class, new Annotation[0]);
     assertThat(actualAdapter).isSameAs(expectedAdapter);
-
-    verify(factory).get(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory);
   }
 
   @Test public void callAdapterFactoryQueriedCanDelegate() {
-    Type type = String.class;
-    Annotation[] annotations = new Annotation[0];
-
-    CallAdapter<?, ?> expectedAdapter = mock(CallAdapter.class);
-    CallAdapter.Factory factory2 = mock(CallAdapter.Factory.class);
-    CallAdapter.Factory factory1 = spy(new CallAdapter.Factory() {
+    final CallAdapter<?, ?> expectedAdapter = new CallAdapter<Object, Object>() {
+      @Override public Type responseType() {
+        throw new AssertionError();
+      }
+      @Override public Object adapt(Call<Object> call) {
+        throw new AssertionError();
+      }
+    };
+    CallAdapter.Factory factory2 = new CallAdapter.Factory() {
+      @Override
+      public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+        return expectedAdapter;
+      }
+    };
+    final AtomicBoolean factory1called = new AtomicBoolean();
+    CallAdapter.Factory factory1 = new CallAdapter.Factory() {
       @Override
       public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+        factory1called.set(true);
         return retrofit.nextCallAdapter(this, returnType, annotations);
       }
-    });
+    };
 
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl("http://example.com/")
@@ -1115,35 +1178,45 @@
         .addCallAdapterFactory(factory2)
         .build();
 
-    doReturn(expectedAdapter).when(factory2).get(type, annotations, retrofit);
-
-    CallAdapter<?, ?> actualAdapter = retrofit.callAdapter(type, annotations);
+    CallAdapter<?, ?> actualAdapter = retrofit.callAdapter(String.class, new Annotation[0]);
     assertThat(actualAdapter).isSameAs(expectedAdapter);
-
-    verify(factory1).get(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory1);
-    verify(factory2).get(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory2);
+    assertTrue(factory1called.get());
   }
 
   @Test public void callAdapterFactoryQueriedCanDelegateTwiceWithoutRecursion() {
     Type type = String.class;
     Annotation[] annotations = new Annotation[0];
 
-    CallAdapter<?, ?> expectedAdapter = mock(CallAdapter.class);
-    CallAdapter.Factory factory3 = mock(CallAdapter.Factory.class);
-    CallAdapter.Factory factory2 = spy(new CallAdapter.Factory() {
+    final CallAdapter<?, ?> expectedAdapter = new CallAdapter<Object, Object>() {
+      @Override public Type responseType() {
+        throw new AssertionError();
+      }
+      @Override public Object adapt(Call<Object> call) {
+        throw new AssertionError();
+      }
+    };
+    CallAdapter.Factory factory3 = new CallAdapter.Factory() {
       @Override
       public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+        return expectedAdapter;
+      }
+    };
+    final AtomicBoolean factory2called = new AtomicBoolean();
+    CallAdapter.Factory factory2 = new CallAdapter.Factory() {
+      @Override
+      public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+        factory2called.set(true);
         return retrofit.nextCallAdapter(this, returnType, annotations);
       }
-    });
-    CallAdapter.Factory factory1 = spy(new CallAdapter.Factory() {
+    };
+    final AtomicBoolean factory1called = new AtomicBoolean();
+    CallAdapter.Factory factory1 = new CallAdapter.Factory() {
       @Override
       public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+        factory1called.set(true);
         return retrofit.nextCallAdapter(this, returnType, annotations);
       }
-    });
+    };
 
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl("http://example.com/")
@@ -1152,17 +1225,10 @@
         .addCallAdapterFactory(factory3)
         .build();
 
-    doReturn(expectedAdapter).when(factory3).get(type, annotations, retrofit);
-
     CallAdapter<?, ?> actualAdapter = retrofit.callAdapter(type, annotations);
     assertThat(actualAdapter).isSameAs(expectedAdapter);
-
-    verify(factory1).get(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory1);
-    verify(factory2).get(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory2);
-    verify(factory3).get(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory3);
+    assertTrue(factory1called.get());
+    assertTrue(factory2called.get());
   }
 
   @Test public void callAdapterFactoryNoMatchThrows() {
@@ -1184,6 +1250,7 @@
           + "Could not locate call adapter for class java.lang.String.\n"
           + "  Tried:\n"
           + "   * retrofit2.helpers.NonMatchingCallAdapterFactory\n"
+          + "   * retrofit2.CompletableFutureCallAdapterFactory\n"
           + "   * retrofit2.DefaultCallAdapterFactory");
     }
 
@@ -1216,6 +1283,7 @@
           + "   * retrofit2.helpers.DelegatingCallAdapterFactory\n"
           + "  Tried:\n"
           + "   * retrofit2.helpers.NonMatchingCallAdapterFactory\n"
+          + "   * retrofit2.CompletableFutureCallAdapterFactory\n"
           + "   * retrofit2.DefaultCallAdapterFactory");
     }
 
@@ -1262,7 +1330,11 @@
   }
 
   @Test public void callbackExecutorPropagated() {
-    Executor executor = mock(Executor.class);
+    Executor executor = new Executor() {
+      @Override public void execute(@NotNull Runnable command) {
+        throw new AssertionError();
+      }
+    };
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl("http://example.com/")
         .callbackExecutor(executor)
@@ -1271,11 +1343,50 @@
   }
 
   @Test public void callbackExecutorUsedForSuccess() throws InterruptedException {
-    Executor executor = spy(new Executor() {
+    final CountDownLatch runnableLatch = new CountDownLatch(1);
+    final AtomicReference<Runnable> runnableRef = new AtomicReference<>();
+    Executor executor = new Executor() {
       @Override public void execute(Runnable command) {
-        command.run();
+        runnableRef.set(command);
+        runnableLatch.countDown();
+      }
+    };
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .callbackExecutor(executor)
+        .build();
+    CallMethod service = retrofit.create(CallMethod.class);
+    Call<ResponseBody> call = service.getResponseBody();
+
+    server.enqueue(new MockResponse());
+
+    final CountDownLatch callbackLatch = new CountDownLatch(1);
+    call.enqueue(new Callback<ResponseBody>() {
+      @Override public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
+        callbackLatch.countDown();
+      }
+
+      @Override public void onFailure(Call<ResponseBody> call, Throwable t) {
+        t.printStackTrace();
       }
     });
+
+    assertTrue(runnableLatch.await(2, TimeUnit.SECONDS));
+    assertEquals(1, callbackLatch.getCount()); // Callback not run yet.
+
+    runnableRef.get().run();
+    assertTrue(callbackLatch.await(2, TimeUnit.SECONDS));
+  }
+
+  @Test public void callbackExecutorUsedForFailure() throws InterruptedException {
+    final CountDownLatch runnableLatch = new CountDownLatch(1);
+    final AtomicReference<Runnable> runnableRef = new AtomicReference<>();
+    Executor executor = new Executor() {
+      @Override public void execute(Runnable command) {
+        runnableRef.set(command);
+        runnableLatch.countDown();
+      }
+    };
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
         .callbackExecutor(executor)
@@ -1283,6 +1394,39 @@
     CallMethod service = retrofit.create(CallMethod.class);
     Call<ResponseBody> call = service.getResponseBody();
 
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AT_START));
+
+    final CountDownLatch callbackLatch = new CountDownLatch(1);
+    call.enqueue(new Callback<ResponseBody>() {
+      @Override public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
+        throw new AssertionError();
+      }
+
+      @Override public void onFailure(Call<ResponseBody> call, Throwable t) {
+        callbackLatch.countDown();
+      }
+    });
+
+    assertTrue(runnableLatch.await(2, TimeUnit.SECONDS));
+    assertEquals(1, callbackLatch.getCount()); // Callback not run yet.
+
+    runnableRef.get().run();
+    assertTrue(callbackLatch.await(2, TimeUnit.SECONDS));
+  }
+
+  @Test public void skippedCallbackExecutorNotUsedForSuccess() throws InterruptedException {
+    Executor executor = new Executor() {
+      @Override public void execute(Runnable command) {
+        fail();
+      }
+    };
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .callbackExecutor(executor)
+        .build();
+    CallMethod service = retrofit.create(CallMethod.class);
+    Call<ResponseBody> call = service.getResponseBodySkippedExecutor();
+
     server.enqueue(new MockResponse());
 
     final CountDownLatch latch = new CountDownLatch(1);
@@ -1296,23 +1440,20 @@
       }
     });
     assertTrue(latch.await(2, TimeUnit.SECONDS));
-
-    verify(executor).execute(any(Runnable.class));
-    verifyNoMoreInteractions(executor);
   }
 
-  @Test public void callbackExecutorUsedForFailure() throws InterruptedException {
-    Executor executor = spy(new Executor() {
+  @Test public void skippedCallbackExecutorNotUsedForFailure() throws InterruptedException {
+    Executor executor = new Executor() {
       @Override public void execute(Runnable command) {
-        command.run();
+        fail();
       }
-    });
+    };
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
         .callbackExecutor(executor)
         .build();
     CallMethod service = retrofit.create(CallMethod.class);
-    Call<ResponseBody> call = service.getResponseBody();
+    Call<ResponseBody> call = service.getResponseBodySkippedExecutor();
 
     server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AT_START));
 
@@ -1327,9 +1468,6 @@
       }
     });
     assertTrue(latch.await(2, TimeUnit.SECONDS));
-
-    verify(executor).execute(any(Runnable.class));
-    verifyNoMoreInteractions(executor);
   }
 
   /** Confirm that Retrofit encodes parameters when the call is executed, and not earlier. */
diff --git a/retrofit/src/test/java/retrofit2/TestingUtils.java b/retrofit/src/test/java/retrofit2/TestingUtils.java
index 3847509ea..f68b724cf 100644
--- a/retrofit/src/test/java/retrofit2/TestingUtils.java
+++ b/retrofit/src/test/java/retrofit2/TestingUtils.java
@@ -16,13 +16,20 @@
 package retrofit2;
 
 import java.lang.reflect.Method;
+import java.util.Arrays;
 
-public final class TestingUtils {
-  public static Method onlyMethod(Class c) {
+final class TestingUtils {
+  static Method onlyMethod(Class c) {
     Method[] declaredMethods = c.getDeclaredMethods();
     if (declaredMethods.length == 1) {
       return declaredMethods[0];
     }
     throw new IllegalArgumentException("More than one method declared.");
   }
+
+  static String repeat(char c, int times) {
+    char[] cs = new char[times];
+    Arrays.fill(cs, c);
+    return new String(cs);
+  }
 }
diff --git a/retrofit/src/test/java/retrofit2/helpers/NonMatchingCallAdapterFactory.java b/retrofit/src/test/java/retrofit2/helpers/NonMatchingCallAdapterFactory.java
index 3f44ddff8..76dfbf51f 100644
--- a/retrofit/src/test/java/retrofit2/helpers/NonMatchingCallAdapterFactory.java
+++ b/retrofit/src/test/java/retrofit2/helpers/NonMatchingCallAdapterFactory.java
@@ -17,14 +17,15 @@
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+import javax.annotation.Nullable;
 import retrofit2.CallAdapter;
 import retrofit2.Retrofit;
 
 public final class NonMatchingCallAdapterFactory extends CallAdapter.Factory {
   public boolean called;
 
-  @Override
-  public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+  @Override public @Nullable CallAdapter<?, ?> get(
+      Type returnType, Annotation[] annotations, Retrofit retrofit) {
     called = true;
     return null;
   }
diff --git a/retrofit/src/test/java/retrofit2/helpers/NonMatchingConverterFactory.java b/retrofit/src/test/java/retrofit2/helpers/NonMatchingConverterFactory.java
index 343839944..28c4dfb77 100644
--- a/retrofit/src/test/java/retrofit2/helpers/NonMatchingConverterFactory.java
+++ b/retrofit/src/test/java/retrofit2/helpers/NonMatchingConverterFactory.java
@@ -17,6 +17,7 @@
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+import javax.annotation.Nullable;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import retrofit2.Converter;
@@ -25,21 +26,20 @@
 public final class NonMatchingConverterFactory extends Converter.Factory {
   public boolean called;
 
-  @Override
-  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
+  @Override public @Nullable Converter<ResponseBody, ?> responseBodyConverter(
+      Type type, Annotation[] annotations, Retrofit retrofit) {
     called = true;
     return null;
   }
 
-  @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
+  @Override public @Nullable Converter<?, RequestBody> requestBodyConverter(Type type,
       Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     called = true;
     return null;
   }
 
-  @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
+  @Override public @Nullable Converter<?, String> stringConverter(
+      Type type, Annotation[] annotations, Retrofit retrofit) {
     called = true;
     return null;
   }
diff --git a/retrofit/src/test/java/retrofit2/helpers/ObjectInstanceConverterFactory.java b/retrofit/src/test/java/retrofit2/helpers/ObjectInstanceConverterFactory.java
new file mode 100644
index 000000000..bf3134696
--- /dev/null
+++ b/retrofit/src/test/java/retrofit2/helpers/ObjectInstanceConverterFactory.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.helpers;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import javax.annotation.Nullable;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
+
+public final class ObjectInstanceConverterFactory extends Converter.Factory {
+  public static final Object VALUE = new Object();
+
+  @Override public @Nullable Converter<ResponseBody, ?> responseBodyConverter(
+      Type type, Annotation[] annotations, Retrofit retrofit) {
+    if (type != Object.class) {
+      return null;
+    }
+    return new Converter<ResponseBody, Object>() {
+      @Override public Object convert(ResponseBody value) {
+        return VALUE;
+      }
+    };
+  }
+}
diff --git a/retrofit/src/test/java/retrofit2/helpers/ToStringConverterFactory.java b/retrofit/src/test/java/retrofit2/helpers/ToStringConverterFactory.java
index 0a70e3ddb..c267d3356 100644
--- a/retrofit/src/test/java/retrofit2/helpers/ToStringConverterFactory.java
+++ b/retrofit/src/test/java/retrofit2/helpers/ToStringConverterFactory.java
@@ -18,6 +18,7 @@
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+import javax.annotation.Nullable;
 import okhttp3.MediaType;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
@@ -25,11 +26,10 @@
 import retrofit2.Retrofit;
 
 public class ToStringConverterFactory extends Converter.Factory {
-  static final MediaType MEDIA_TYPE = MediaType.parse("text/plain");
+  static final MediaType MEDIA_TYPE = MediaType.get("text/plain");
 
-  @Override
-  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
+  @Override public @Nullable Converter<ResponseBody, ?> responseBodyConverter(
+      Type type, Annotation[] annotations, Retrofit retrofit) {
     if (String.class.equals(type)) {
       return new Converter<ResponseBody, String>() {
         @Override public String convert(ResponseBody value) throws IOException {
@@ -40,7 +40,7 @@
     return null;
   }
 
-  @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
+  @Override public @Nullable Converter<?, RequestBody> requestBodyConverter(Type type,
       Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     if (String.class.equals(type)) {
       return new Converter<String, RequestBody>() {
diff --git a/samples/pom.xml b/samples/pom.xml
index 10ce5624b..cd3997811 100644
--- a/samples/pom.xml
+++ b/samples/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>parent</artifactId>
-    <version>2.4.1-SNAPSHOT</version>
+    <version>2.6.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -52,6 +52,11 @@
       <groupId>com.google.guava</groupId>
       <artifactId>guava</artifactId>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
     <dependency>
       <groupId>org.jsoup</groupId>
       <artifactId>jsoup</artifactId>
diff --git a/samples/src/main/java/com/example/retrofit/AnnotatedConverters.java b/samples/src/main/java/com/example/retrofit/AnnotatedConverters.java
index 0664d3482..d4b86d56b 100644
--- a/samples/src/main/java/com/example/retrofit/AnnotatedConverters.java
+++ b/samples/src/main/java/com/example/retrofit/AnnotatedConverters.java
@@ -22,6 +22,7 @@
 import java.lang.reflect.Type;
 import java.util.LinkedHashMap;
 import java.util.Map;
+import javax.annotation.Nullable;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import okhttp3.mockwebserver.MockResponse;
@@ -67,9 +68,8 @@ public AnnotatedConverterFactory build() {
       this.factories = new LinkedHashMap<>(factories);
     }
 
-    @Override
-    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-        Retrofit retrofit) {
+    @Override public @Nullable Converter<ResponseBody, ?> responseBodyConverter(
+        Type type, Annotation[] annotations, Retrofit retrofit) {
       for (Annotation annotation : annotations) {
         Converter.Factory factory = factories.get(annotation.annotationType());
         if (factory != null) {
@@ -79,7 +79,7 @@ public AnnotatedConverterFactory build() {
       return null;
     }
 
-    @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
+    @Override public @Nullable Converter<?, RequestBody> requestBodyConverter(Type type,
         Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
       for (Annotation annotation : parameterAnnotations) {
         Converter.Factory factory = factories.get(annotation.annotationType());
diff --git a/samples/src/main/java/com/example/retrofit/ChunkingConverter.java b/samples/src/main/java/com/example/retrofit/ChunkingConverter.java
index 790675975..1a2bde63a 100644
--- a/samples/src/main/java/com/example/retrofit/ChunkingConverter.java
+++ b/samples/src/main/java/com/example/retrofit/ChunkingConverter.java
@@ -20,6 +20,7 @@
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 import java.lang.reflect.Type;
+import javax.annotation.Nullable;
 import okhttp3.MediaType;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
@@ -48,8 +49,7 @@
    * present on {@code @Body} params.
    */
   static class ChunkingConverterFactory extends Converter.Factory {
-    @Override
-    public Converter<?, RequestBody> requestBodyConverter(Type type,
+    @Override public @Nullable Converter<?, RequestBody> requestBodyConverter(Type type,
         Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
       boolean isBody = false;
       boolean isChunked = false;
diff --git a/samples/src/main/java/com/example/retrofit/Crawler.java b/samples/src/main/java/com/example/retrofit/Crawler.java
index 1e213e9a1..d2e1da916 100644
--- a/samples/src/main/java/com/example/retrofit/Crawler.java
+++ b/samples/src/main/java/com/example/retrofit/Crawler.java
@@ -27,6 +27,7 @@
 import java.util.concurrent.Executors;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
+import javax.annotation.Nullable;
 import okhttp3.ConnectionPool;
 import okhttp3.Dispatcher;
 import okhttp3.HttpUrl;
@@ -100,7 +101,7 @@ public static void main(String... args) throws Exception {
         .build();
 
     Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(HttpUrl.parse("https://example.com/"))
+        .baseUrl(HttpUrl.get("https://example.com/"))
         .addConverterFactory(PageAdapter.FACTORY)
         .client(okHttpClient)
         .build();
@@ -108,7 +109,7 @@ public static void main(String... args) throws Exception {
     PageService pageService = retrofit.create(PageService.class);
 
     Crawler crawler = new Crawler(pageService);
-    crawler.crawlPage(HttpUrl.parse(args[0]));
+    crawler.crawlPage(HttpUrl.get(args[0]));
   }
 
   interface PageService {
@@ -127,7 +128,7 @@ public static void main(String... args) throws Exception {
 
   static final class PageAdapter implements Converter<ResponseBody, Page> {
     static final Converter.Factory FACTORY = new Converter.Factory() {
-      @Override public Converter<ResponseBody, ?> responseBodyConverter(
+      @Override public @Nullable Converter<ResponseBody, ?> responseBodyConverter(
           Type type, Annotation[] annotations, Retrofit retrofit) {
         if (type == Page.class) return new PageAdapter();
         return null;
diff --git a/samples/src/main/java/com/example/retrofit/ErrorHandlingAdapter.java b/samples/src/main/java/com/example/retrofit/ErrorHandlingAdapter.java
index fd05c044d..03dc55029 100644
--- a/samples/src/main/java/com/example/retrofit/ErrorHandlingAdapter.java
+++ b/samples/src/main/java/com/example/retrofit/ErrorHandlingAdapter.java
@@ -20,6 +20,7 @@
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import java.util.concurrent.Executor;
+import javax.annotation.Nullable;
 import retrofit2.Call;
 import retrofit2.CallAdapter;
 import retrofit2.Callback;
@@ -59,8 +60,8 @@
   }
 
   public static class ErrorHandlingCallAdapterFactory extends CallAdapter.Factory {
-    @Override public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations,
-        Retrofit retrofit) {
+    @Override public @Nullable CallAdapter<?, ?> get(
+        Type returnType, Annotation[] annotations, Retrofit retrofit) {
       if (getRawType(returnType) != MyCall.class) {
         return null;
       }
diff --git a/samples/src/main/java/com/example/retrofit/InvocationMetrics.java b/samples/src/main/java/com/example/retrofit/InvocationMetrics.java
new file mode 100644
index 000000000..49ac30481
--- /dev/null
+++ b/samples/src/main/java/com/example/retrofit/InvocationMetrics.java
@@ -0,0 +1,89 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.retrofit;
+
+import java.io.IOException;
+import okhttp3.Interceptor;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+import retrofit2.Call;
+import retrofit2.Invocation;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+import retrofit2.http.Url;
+
+/**
+ * This example prints HTTP call metrics with the initiating method names and arguments.
+ */
+public final class InvocationMetrics {
+  public interface Browse {
+    @GET("/robots.txt")
+    Call<ResponseBody> robots();
+
+    @GET("/favicon.ico")
+    Call<ResponseBody> favicon();
+
+    @GET("/")
+    Call<ResponseBody> home();
+
+    @GET
+    Call<ResponseBody> page(@Url String path);
+  }
+
+  static final class InvocationLogger implements Interceptor {
+    @Override public Response intercept(Chain chain) throws IOException {
+      Request request = chain.request();
+      long startNanos = System.nanoTime();
+      Response response = chain.proceed(request);
+      long elapsedNanos = System.nanoTime() - startNanos;
+
+      Invocation invocation = request.tag(Invocation.class);
+      if (invocation != null) {
+        System.out.printf("%s.%s %s HTTP %s (%.0f ms)%n",
+            invocation.method().getDeclaringClass().getSimpleName(),
+            invocation.method().getName(),
+            invocation.arguments(),
+            response.code(),
+            elapsedNanos / 1_000_000.0);
+      }
+
+      return response;
+    }
+  }
+
+  public static void main(String... args) throws IOException {
+    InvocationLogger invocationLogger = new InvocationLogger();
+
+    OkHttpClient okHttpClient = new OkHttpClient.Builder()
+        .addInterceptor(invocationLogger)
+        .build();
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("https://square.com/")
+        .callFactory(okHttpClient)
+        .build();
+
+    Browse browse = retrofit.create(Browse.class);
+
+    browse.robots().execute();
+    browse.favicon().execute();
+    browse.home().execute();
+    browse.page("sitemap.xml").execute();
+    browse.page("notfound").execute();
+  }
+}
diff --git a/samples/src/main/java/com/example/retrofit/JsonAndXmlConverters.java b/samples/src/main/java/com/example/retrofit/JsonAndXmlConverters.java
index 2163f3dec..354e901c3 100644
--- a/samples/src/main/java/com/example/retrofit/JsonAndXmlConverters.java
+++ b/samples/src/main/java/com/example/retrofit/JsonAndXmlConverters.java
@@ -19,6 +19,7 @@
 import java.lang.annotation.Annotation;
 import java.lang.annotation.Retention;
 import java.lang.reflect.Type;
+import javax.annotation.Nullable;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import okhttp3.mockwebserver.MockResponse;
@@ -60,9 +61,8 @@
       this.xmlFactory = xmlFactory;
     }
 
-    @Override
-    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-        Retrofit retrofit) {
+    @Override public @Nullable Converter<ResponseBody, ?> responseBodyConverter(
+        Type type, Annotation[] annotations, Retrofit retrofit) {
       for (Annotation annotation : annotations) {
         if (annotation instanceof Json) {
           return jsonFactory.responseBodyConverter(type, annotations, retrofit);
@@ -74,7 +74,7 @@
       return null;
     }
 
-    @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
+    @Override public @Nullable Converter<?, RequestBody> requestBodyConverter(Type type,
         Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
       for (Annotation annotation : parameterAnnotations) {
         if (annotation instanceof Json) {
diff --git a/samples/src/main/java/com/example/retrofit/JsonQueryParameters.java b/samples/src/main/java/com/example/retrofit/JsonQueryParameters.java
index 724c75fb2..35489272a 100644
--- a/samples/src/main/java/com/example/retrofit/JsonQueryParameters.java
+++ b/samples/src/main/java/com/example/retrofit/JsonQueryParameters.java
@@ -19,6 +19,7 @@
 import java.lang.annotation.Annotation;
 import java.lang.annotation.Retention;
 import java.lang.reflect.Type;
+import javax.annotation.Nullable;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import okhttp3.mockwebserver.MockResponse;
@@ -47,8 +48,8 @@
       this.delegateFactory = delegateFactory;
     }
 
-    @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
-        Retrofit retrofit) {
+    @Override public @Nullable Converter<?, String> stringConverter(
+        Type type, Annotation[] annotations, Retrofit retrofit) {
       for (Annotation annotation : annotations) {
         if (annotation instanceof Json) {
           // NOTE: If you also have a JSON converter factory installed in addition to this factory,
diff --git a/samples/src/main/java/com/example/retrofit/RxJavaObserveOnMainThread.java b/samples/src/main/java/com/example/retrofit/RxJavaObserveOnMainThread.java
index 6c4fec40d..4e7a2d636 100644
--- a/samples/src/main/java/com/example/retrofit/RxJavaObserveOnMainThread.java
+++ b/samples/src/main/java/com/example/retrofit/RxJavaObserveOnMainThread.java
@@ -17,6 +17,7 @@
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+import javax.annotation.Nullable;
 import retrofit2.Call;
 import retrofit2.CallAdapter;
 import retrofit2.Retrofit;
@@ -48,8 +49,8 @@ public static void main(String... args) {
       this.scheduler = scheduler;
     }
 
-    @Override
-    public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+    @Override public @Nullable CallAdapter<?, ?> get(
+        Type returnType, Annotation[] annotations, Retrofit retrofit) {
       if (getRawType(returnType) != Observable.class) {
         return null; // Ignore non-Observable types.
       }
diff --git a/samples/src/main/java/com/example/retrofit/package-info.java b/samples/src/main/java/com/example/retrofit/package-info.java
new file mode 100644
index 000000000..5ec8c5bac
--- /dev/null
+++ b/samples/src/main/java/com/example/retrofit/package-info.java
@@ -0,0 +1,2 @@
+@javax.annotation.ParametersAreNonnullByDefault
+package com.example.retrofit;
